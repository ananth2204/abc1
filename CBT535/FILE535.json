{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012307000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE535.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE535.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\t'", "DS1TRBAL": "b'\\xa4('"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xf7\\x00\\x0c\\x03\\xf8\\x00\\x06\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00!\\x01\\x19\\x02\\x8f\\x01\\x19\\x02\\x8f\\x14&\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2019-01-28T14:26:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  535\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE535\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    6160    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,426 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/28/19    14:26:21    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00'\\x01\\x19\\x01O\\x01\\x19\\x01o\\x14\\x03\\x00\\x19\\x00N\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-14T00:00:00", "modifydate": "2019-01-16T14:03:27", "lines": 25, "newlines": 78, "modlines": 0, "user": "SBGOLOB"}, "text": "Notes from Sam Golob.\n\nI took the liberty of customizing this beautiful work from\nmy friend Deru, in the following way.  Submit member called\nJCCATS instead of member JCCAT, which goes against member\nASSEMBLS instead of against Deru's member ASSEMBLE.\n\nSMALL CHANGES:\n\n1.  ADDED FLAG(5) INTO THE ASSEMBLY PARMS, TO ELIMINATE THE\n    RETURN CODE 4 FROM THE 2 MESSAGES:\n\n    ASMA303W Multiple address resolutions may result ...\n\n2.  I WANTED TO ALTER THE LOAD MODULE CCAT TO GIVE IT AN SSI\n    THAT WOULD IDENTIFY IT, SO I ADDED AN EXTRA STEP TO INVOKE\n    THE PDS COMMAND (CBT FILE 182) AGAINST THE LOAD MODULE,\n    IN BATCH, TO ADD THE SSI THAT I WANTED IT TO HAVE.\n\n3.  I ADDED A TSO HELP MEMBER, #CCAT, BECAUSE SOMETIMES YOU\n    NEED A REMINDER ABOUT HOW TO USE THE PROGRAM.\n\n\nDeru did a beautiful job.  That's all folks.....\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x012O\\x01\\x012O\\x060\\x00\\x16\\x00\\x15\\x00\\x00\\xc4\\xc5\\xd9\\xe4`\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-11-20T00:00:00", "modifydate": "2001-11-20T06:30:56", "lines": 22, "newlines": 21, "modlines": 0, "user": "DERU-S"}, "text": "\nThis is my contribution, a program as text in zip file.  The zip\nconsist of:\n\nDERCCT.ASM   -  program source code (text) in assembly\nASSEMBLE.JCL -  JCL procedure for assembling and linkediting\nJCCAT.JCL    -  JCL to generate CCAT command processor (TSO) from\n                DERCCT.ASM\n\nCCAT command is a TSO command processor to do:\n(1)  Allocate a file (DD) from a dataset\n(2)  Concatenate a dataset to an existing file (DD)\n(3)  Display datasets list (concatenation) of a file (DD)\n(4)  Move a dataset to the top of concatenation\n(5)  Deconcatenate a dataset from a file (DD)\n(6)  Deallocate a file (DD) of a single dataset\n\nHope can help someone.\n\nWith regards,\nDeru Sudibyo\nOS/390 Tech Consultant\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#CCAT": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00G\\x01\\x19\\x01O\\x01 #o\\x12$\\x00m\\x00~\\x00\\x00\\xe3\\xe2\\xd6\\xc8\\xc5\\xd3\\xd7@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-01-14T00:00:00", "modifydate": "2020-08-23T12:24:47", "lines": 109, "newlines": 126, "modlines": 0, "user": "TSOHELP"}, "text": ")F FUNCTION -\n\n  NAME:    CCAT    -  TSO COMMAND\n                      FOR DYNAMIC DATASET CONCATENATION\n                      AND ALLOCATION\n\n---------------------------------------------------------------\n\n\n  PURPOSE: Dynamic allocate/deallocate a dataset into a\n           new DDname, or concatenate/deconcatenate a\n           dataset into the top of existing concatenation.\n\n           CCAT doesn't apply for dataset being opened,\n           uncataloged or cataloged in private catalog.\n           Disposition assigned by CCAT always shared.\n\n  INPUT:   specified operands\n\n  OUTPUT:  Informational messages, or error messages and\n           a return code.\n\n)X SYNTAX -\n\n\n  (1)   Perform allocation/deallocation:\n                                         +-   -+ +-     -+\n        CCAT  F(ddname) DS(datasetname)  | ON  | | MSG   |\n                                         |     | |       |\n                                         | top | | nomsg |\n                                         |     | |       |\n                                         | bot | | emsg  |\n                                         |     | |       |\n                                         | off | | lmsg  |\n                                         +-   -+ +-     -+\n\n       Option 1.    ON    -   Allocate/concatenate the\n                              specified DSname/DDname.\n                    TOP   -   Force to allocate/concatenate\n                              even the specified DSN has\n                              already allocated but not on the\n                              top of concatenation.\n                    BOT   -   Force to concatenate a dataset\n                              to the bottom order of existing\n                              concatenation.\n                    OFF   -   Deallocate/deconcatenate the\n                              specified DSname/DDname.\n\n       Option 2.    MSG   -   Display simple message (default)\n                    NOMSG -   No messages will be displayed\n                              upon completion.\n                    EMSG  -   Display error messages only.\n                    LMSG  -   Display complete messages\n                              (completion message and the\n                              new concatenation list.\n\n  (2)   Display current specified DDname concatenation list:\n\n        CCAT  F(ddname)\n\n\n  RETURN CODES:\n              0   - SUCCESSFULL\n              4   - Request wasn't performed, because,\n                    dataset already allocated (ON), or\n                    dataset was not allocated yet (OFF).\n              8   - Request was performed, but failed,\n                    RC=4 returned by SVC 99.\n                    Current concatenation was not changed.\n             12   - Request was failed, SVC 99 produce\n                    RC=8. Current specified DDname\n                    concatenation was not changed.\n             16   - Request was failed, SVC 99 produce\n                    RC=12. Current specified DDname\n                    concatenation was not updated.\n             20   - Request was failed, SVC 99 produce\n                    RC=16. Current specified DDname\n                    concatenation was unpredictable.\n             24   - Syntax error. Operand missing or\n                    invalid. Request wasn't performed.\n\n\n  MESSAGES:\n\n    CCAT000 XXXXX.YYYY.ZZZZZ successfully allocated.\n    CCAT001 XXXXX.YYYY.ZZZZZ successfully concatenated.\n    CCAT002 XXXXX.YYYY.ZZZZZ successfully released.\n    CCAT003 DDname DDDDDDDD already in use.\n    CCAT004 XXXXX.YYYY.ZZZZZ unallocatable.\n    CCAT005 XXXXX.YYYY.ZZZZZ already allocated.\n    CCAT006 XXXXX.YYYY.ZZZZZ not cataloged.\n    CCAT007 XXXXX.YYYY.ZZZZZ reserved by other job.\n    CCAT008 DDname DDDDDDDD is illegal for SVC 99.\n    CCAT009 DDname DDDDDDDD not allocated yet.\n    CCAT010 XXXXX.YYYY.ZZZZZ not allocated yet\n    CCAT011 DDname DDDDDDDD not available.\n    CCAT012 DDname DDDDDDDD internal conflict.\n    CCAT013 XXXXX.YYYY.ZZZZZ is a private catalog.\n    CCAT014 Catalog error, XXXXX.YYYY.ZZZZZ not accessed\n    CCAT015 OBTAIN error, XXXXX.YYYY.ZZZZZ not accessed\n    CCAT800 DD(ddname) concatenation:\n            001 ---> DATA.SET\n            002 ---> MY.DATA.LIBRARY\n                     :\n            nnn ---> APPL.USER.DATA\n    CCAT900 Function failure, S99ERROR=nnnnn-P, contact your engineer.\n    CCAT990 No dataset/DDname found in TIOT or JFCB\n    CCAT999 SYNTAX ERROR, Operand missing or invalid\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE535": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00\\x16\\x01\\x19\\x02\\x8f\\x01\\x19\\x02\\x8f\\x14&\\x00?\\x00?\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2019-01-28T14:26:16", "lines": 63, "newlines": 63, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 535 is from Deru Sudibyo and contains CCAT, which is a    *   FILE 535\n//*           TSO command for dynamic dataset allocation,           *   FILE 535\n//*           dataset concatenation, and deconcatenation.           *   FILE 535\n//*                                                                 *   FILE 535\n//*           CCAT is more flexible, and can do more things,        *   FILE 535\n//*           than most programs of this type.                      *   FILE 535\n//*                                                                 *   FILE 535\n//*           email:   deru.sudibyo@gmail.com                       *   FILE 535\n//*                                                                 *   FILE 535\n//*           As an alternative, try:                               *   FILE 535\n//*                                                                 *   FILE 535\n//*           email:  sbgolob@cbttape.org                           *   FILE 535\n//*                                                                 *   FILE 535\n//*           See new member $$NOTE01 from Sam Golob.               *   FILE 535\n//*                                                                 *   FILE 535\n//*   SYNTAX:                                                       *   FILE 535\n//*                                                                 *   FILE 535\n//*   (1)   Perform allocation/deallocation:                        *   FILE 535\n//*                                          +-   -+ +-     -+      *   FILE 535\n//*         CCAT  F(ddname) DS(datasetname)  | ON  | | MSG   |      *   FILE 535\n//*                                          |     | |       |      *   FILE 535\n//*                                          | top | | nomsg |      *   FILE 535\n//*                                          |     | |       |      *   FILE 535\n//*                                          | bot | | emsg  |      *   FILE 535\n//*                                          |     | |       |      *   FILE 535\n//*                                          | off | | lmsg  |      *   FILE 535\n//*                                          +-   -+ +-     -+      *   FILE 535\n//*                                                                 *   FILE 535\n//*        Option 1.    ON    -   Allocate/concatenate the          *   FILE 535\n//*                               specified DSname/DDname.  If      *   FILE 535\n//*                               the DDname is already exist,      *   FILE 535\n//*                               dataset will be concatenated      *   FILE 535\n//*                               on the top of concatenation.      *   FILE 535\n//*                                                                 *   FILE 535\n//*                     TOP   -   Force to concatenate a dataset    *   FILE 535\n//*                               to the top order of existing      *   FILE 535\n//*                               concatenation.  If specified      *   FILE 535\n//*                               dataset is newly added, this      *   FILE 535\n//*                               option is default.                *   FILE 535\n//*                                                                 *   FILE 535\n//*                     BOT   -   Force to concatenate a dataset    *   FILE 535\n//*                               to the bottom order of existing   *   FILE 535\n//*                               concatenation.                    *   FILE 535\n//*                                                                 *   FILE 535\n//*                     OFF   -   Deallocate/deconcatenate the      *   FILE 535\n//*                               specified DSname/DDname.          *   FILE 535\n//*                                                                 *   FILE 535\n//*        Option 2.    MSG   -   Display simple message (default)  *   FILE 535\n//*                                                                 *   FILE 535\n//*                     NOMSG -   No messages will be displayed     *   FILE 535\n//*                               upon completion.                  *   FILE 535\n//*                                                                 *   FILE 535\n//*                     EMSG  -   Display error messages only.      *   FILE 535\n//*                                                                 *   FILE 535\n//*                     LMSG  -   Display complete messages         *   FILE 535\n//*                               (completion message and the       *   FILE 535\n//*                               new concatenation list).          *   FILE 535\n//*                                                                 *   FILE 535\n//*                                                                 *   FILE 535\n//*   (2)   Display current specified DDname concatenation list:    *   FILE 535\n//*                                                                 *   FILE 535\n//*         CCAT  F(ddname)                                         *   FILE 535\n//*                                                                 *   FILE 535\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSEMBLE": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012O\\x01\\x012O\\x06(\\x00$\\x00$\\x00\\x00\\xc4\\xc5\\xd9\\xe4`\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-20T00:00:00", "modifydate": "2001-11-20T06:28:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "DERU-S"}, "text": "//ASSEMBLE PROC NAME=,\n//          MEMBER=,\n//          DSKUNIT=3390,\n//          SRCLIB=,\n//          MACLIB=SYS1.MACLIB,\n//          LNKLIB=,\n//          APARM='OBJECT,NODECK,ALIGN',\n//          LPARM='LIST'\n//*\n//* +-------------------------+\n//* ! ASSEMBLING              !\n//* +-------------------------+\n//*\n//ASM      EXEC PGM=ASMA90,PARM='&APARM'\n//SYSUT1   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSUT2   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSUT3   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSLIB   DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSLIN   DD  DSN=&&&MEMBER,DISP=(NEW,PASS),\n//             UNIT=&DSKUNIT,SPACE=(800,(2000,500)),\n//             DCB=(BLKSIZE=800,RECFM=FB,LRECL=80)\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY,SYSOUT=B\n//SYSIN    DD  DSN=&SRCLIB(&MEMBER),DISP=SHR\n//*\n//* +-------------------------+\n//* ! LINK-EDITING            !\n//* +-------------------------+\n//*\n//LNK      EXEC PGM=HEWL,PARM='MAP,LET,NCAL,&LPARM',COND=(8,LT,ASM)\n//SYSUT1   DD  UNIT=3390,SPACE=(1024,(500,20))\n//SYSLIN   DD  DSN=&&&MEMBER,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHR,DSN=&LNKLIB(&NAME)\n//SYSPRINT DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASSEMBLS": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00T\\x01\\x012O\\x01 $\\x0f\"6\\x00(\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-11-20T00:00:00", "modifydate": "2020-08-27T22:36:54", "lines": 40, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASSEMBLE PROC MEMBER=CCAT,\n//          SRCLIB='SBGOLOB.CBT500.FILE535',\n//          MACLIB=SYS1.MACLIB,\n//          LNKLIB='SYS1.W$$.LINKLIB',\n//          APARM='OBJECT,NODECK,ALIGN,FLAG(5)',\n//          LPARM='LIST'\n//*\n//* +-------------------------+\n//* ! ASSEMBLING              !\n//* +-------------------------+\n//*\n//ASM      EXEC PGM=ASMA90,PARM='&APARM'\n//SYSUT1   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSUT2   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSUT3   DD  UNIT=3390,SPACE=(1700,(6000,100))\n//SYSLIB   DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSLIN   DD  DSN=&&MEMBER,DISP=(NEW,PASS),\n//             UNIT=3390,SPACE=(800,(2000,500)),\n//             DCB=(BLKSIZE=800,RECFM=FB,LRECL=80)\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY,SYSOUT=B\n//SYSIN    DD  DSN=&SRCLIB(&MEMBER),DISP=SHR\n//*\n//* +-------------------------+\n//* ! LINK-EDITING            !\n//* +-------------------------+\n//*\n//LNK      EXEC PGM=HEWL,PARM='MAP,LET,NCAL,&LPARM',COND=(8,LT,ASM)\n//SYSUT1   DD  UNIT=3390,SPACE=(1024,(500,20))\n//SYSLIN   DD  DSN=&&MEMBER,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHR,DSN=&LNKLIB(&MEMBER)\n//SYSPRINT DD  SYSOUT=*\n//         PEND\n//ASMLINK  EXEC ASSEMBLE\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCAT": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x19\\x01o\\x01 #\\x8f\\x13\\x02\\x07\\xb2\\x07H\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-01-16T00:00:00", "modifydate": "2020-08-25T13:02:00", "lines": 1970, "newlines": 1864, "modlines": 0, "user": "SBGOLOB"}, "text": "     PUNCH ' SETSSI CB500535'\n***********************************************************************\n*                                                                     *\n*        NAME:    CCAT    -  TSO COMMAND                              *\n*                            FOR DYNAMIC DATASET CONCATENATION        *\n*                            AND ALLOCATION                           *\n*                                                                     *\n* --------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        PURPOSE: Dynamic allocate/deallocate a dataset into a        *\n*                 new DDname, or concatenate/deconcatenate a          *\n*                 dataset into the top of existing concatenation.     *\n*                                                                     *\n*                 CCAT doesn't applicable for dataset being           *\n*                 opened, uncataloged or cataloged in private         *\n*                 catalog.      Disposition assigned by CCAT          *\n*                 always SHAREd.                                      *\n*                                                                     *\n*        INPUT:   specified operands                                  *\n*                                                                     *\n*        OUTPUT:  Informational messages, or error messages and       *\n*                 a return code.                                      *\n*                                                                     *\n*        SYNTAX:                                                      *\n*                                                                     *\n*        (1)   Perform allocation/deallocation:                       *\n*                                               +-   -+ +-     -+     *\n*              CCAT  F(ddname) DS(datasetname)  | ON  | | MSG   |     *\n*                                               |     | |       |     *\n*                                               | top | | nomsg |     *\n*                                               |     | |       |     *\n*                                               | bot | | emsg  |     *\n*                                               |     | |       |     *\n*                                               | off | | lmsg  |     *\n*                                               +-   -+ +-     -+     *\n*                                                                     *\n*             Option 1.    ON    -   Allocate/concatenate the         *\n*                                    specified DSname/DDname.  If     *\n*                                    the DDname is already exist,     *\n*                                    dataset will be concatenated     *\n*                                    on the top of concatenation.     *\n*                                                                     *\n*                          TOP   -   Force to concatenate a dataset   *\n*                                    to the top order of existing     *\n*                                    concatenation.  If specified     *\n*                                    dataset is newly added, this     *\n*                                    option is default.               *\n*                                                                     *\n*                          BOT   -   Force to concatenate a dataset   *\n*                                    to the bottom order of existing  *\n*                                    concatenation.                   *\n*                                                                     *\n*                          OFF   -   Deallocate/deconcatenate the     *\n*                                    specified DSname/DDname.         *\n*                                                                     *\n*                                                                     *\n*             Option 2.    MSG   -   Display simple message (default) *\n*                                                                     *\n*                          NOMSG -   No messages will be displayed    *\n*                                    upon completion.                 *\n*                                                                     *\n*                          EMSG  -   Display error messages only.     *\n*                                                                     *\n*                          LMSG  -   Display complete messages        *\n*                                    (completion message and the      *\n*                                    new concatenation list.          *\n*                                                                     *\n*        (2)   Display current specified DDname concatenation list:   *\n*                                                                     *\n*              CCAT  F(ddname)                                        *\n*                                                                     *\n*                                                                     *\n*        ENTRYPOINTS: DERCCT   - Main Logic Processor                 *\n*                     DERCCTDS - Dataset name Validity Check Routine  *\n*                     DERCCTDD - DDNAME Validity Check Routine        *\n*                     DERCCTLS - Concatenation list service routine   *\n*                     DERCCTPL - PUTLINE/Messages service routine     *\n*                                                                     *\n*        CONTROL BLOCKS: CPPL    -  Command Processor Parameter List  *\n*                        JFCB    -  Job File Control Block            *\n*                        PPL     -  Parse Parameter List              *\n*                        PCL     -  Parameter Control List            *\n*                        PCE     -  Parameter Control Entry           *\n*                        PDL     -  Parameter Descriptor List         *\n*                        PDE     -  Parameter Descriptor Entry        *\n*                        SWA     -  Scheduler Work Area               *\n*                        S99RB   -  Dynamic allocation control block  *\n*                        TIOT    -  Task I/O Table                    *\n*                                                                     *\n*                                                                     *\n*        RETURN CODES:                                                *\n*                    0   - SUCCESSFULL                                *\n*                    4   - Request wasn't performed, because,         *\n*                          dataset already allocated (ON), or         *\n*                          dataset has not allocated yet (OFF).       *\n*                    8   - Request was performed, but didn't          *\n*                          effective, RC=4 returned by SVC 99.        *\n*                          Current concatenation didn't changed.      *\n*                   12   - Request was failed, SVC 99 produce         *\n*                          RC=8.   Current specified DDname           *\n*                          concatenation was not changed.             *\n*                   16   - Request was failed, SVC 99 produce         *\n*                          RC=12.   Current specified DDname          *\n*                          concatenation was not garenteed.           *\n*                   20   - Request was failed, SVC 99 produce         *\n*                          RC=16.   Current specified DDname          *\n*                          concatenation was unpredictable.           *\n*                   24   - Syntax error.   Operand missing or         *\n*                          invalid.   Request wasn't performed        *\n*                          and the plane and command finished.        *\n*                                                                     *\n*                                                                     *\n*      MESSAGES:                                                      *\n*                                                                     *\n*   CCAT000 XXXXX.YYYY.ZZZZZ successfully allocated.                  *\n*   CCAT001 XXXXX.YYYY.ZZZZZ successfully concatenated.               *\n*   CCAT002 XXXXX.YYYY.ZZZZZ successfully released.                   *\n*   CCAT003 DDname DDDDDDDD already in use.                           *\n*   CCAT004 XXXXX.YYYY.ZZZZZ unallocatable.                           *\n*   CCAT005 XXXXX.YYYY.ZZZZZ already allocated.                       *\n*   CCAT006 XXXXX.YYYY.ZZZZZ not cataloged.                           *\n*   CCAT007 XXXXX.YYYY.ZZZZZ reserved by other job.                   *\n*   CCAT008 DDname DDDDDDDD is illegal for SVC 99.                    *\n*   CCAT009 DDname DDDDDDDD not allocated yet.                        *\n*   CCAT010 XXXXX.YYYY.ZZZZZ not allocated yet                        *\n*   CCAT011 DDname DDDDDDDD not available.                            *\n*   CCAT012 DDname DDDDDDDD internally conflict.                      *\n*   CCAT013 XXXXX.YYYY.ZZZZZ is a private catalog.                    *\n*   CCAT014 Catalog error, XXXXX.YYYY.ZZZZZ not accessed              *\n*   CCAT015 OBTAIN error, XXXXX.YYYY.ZZZZZ not accessed               *\n*   CCAT800 DD(ddname) concatenation:                                 *\n*           001 ---> DATA.SET                                         *\n*           002 ---> MY.DATA.LIBRARY                                  *\n*                    :                                                *\n*           nnn ---> APPL.USER.DATA                                   *\n*   CCAT900 Function failure, S99ERROR=nnnnn-P, contact your engineer.*\n*   CCAT990 No dataset/DDname found in TIOT or JFCB                   *\n*   CCAT999 SYNTAX ERROR, Operand missing or invalid                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        AUTHOR AND COPYRIGHT                                         *\n*                                                                     *\n*        AUTHOR:     Ir. DERU SUDIBYO                                 *\n*                    Sr. Systems Designer                             *\n*                    PT. SDD/BNI-1946 INDONESIA                       *\n*                                                                     *\n*        COPYRIGHT:  (C) 1991  DERU SUDIBYO                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*  MODIFICATION LOG                                                   *\n*  -----------------------------------------------------------------  *\n*  No.  DATE     ENGINEER       V.R.L   DESCRIPTION                   *\n*  -----------------------------------------------------------------  *\n*   1  01/14/91  Deru Sudibyo   1.0.0   1st development               *\n*   2  01/18/91  Deru Sudibyo   1.0.1   Add LIST function             *\n*   3  01/31/91  Deru Sudibyo   1.0.2   Makeup messages and operands  *\n*   4  02/22/91  Stephen Davies 1.0.3   Correct bugs in LIST function *\n*   5  04/06/91  Deru Sudibyo   1.1.0   Declare release VRL 1.1.0     *\n*                                       and install in production     *\n*   6  01/17/19  Deru Sudibyo   1.1.1   Add BOT (bottom) operand to   *\n*                                       force a dataset move into the *\n*                                       bottom of concatenation.      *\n*                                                                     *\n***********************************************************************\nDERCCAT  TITLE  'DYNAMIC ALLOC/CONCATE UTILITY'\n*=====================================================================*\n*  MAIN LOGIC PROCESSOR                                               *\n*                                                                     *\n*        REGISTERS : R0  - UNUSED                                     *\n*                    R1  - CPPL map area                              *\n*                    R2  - PPL map area,                              *\n*                          PDL map area, and then                     *\n*                          DSLINK map area.                           *\n*                    R3  - work register                              *\n*                    R4  - work register                              *\n*                    R5  - work register                              *\n*                    R6  - S99RBP parameter block map area            *\n*                    R7  - S99TUNIT, Text unit map area               *\n*                    R8  - S99 TU Parameter list map area             *\n*                    R9  - S99RB SVC 99 request block                 *\n*                    R10 - Dynamic work area                          *\n*                    R11 - Inner linkage address                      *\n*                    R12 - Main Logic base                            *\n*                    R13 - save area                                  *\n*                    R14 - outer linkage address                      *\n*                    R15 - return code                                *\n*                                                                     *\n*=====================================================================*\nDERCCT   CSECT\nDERCCT   AMODE 31\nDERCCT   RMODE ANY\n         ENTRY CCT\nCCT      DS    0H\n         SAVE  (14,12),,'DERCCT - CCAT/TSO/E - &SYSDATE - &SYSTIME'\n         LR    R12,R15                 get base address\n         USING DERCCT,R12              ESTABLISH addressability\n         LR    R2,R1                   save PLIST address\n         GETMAIN R,LV=STORAGE          obtain dynamic workarea\n         LA    R10,L_SAVEAREA+8(R1)    past end of S99RBP and SAVEAREA\n         USING CCATAREA,R10            CCAT area addressability\n         STM   R0,R1,STOR_LEN          save storage specification\n         ST    R1,S99P_PTR             save S99RBP pointer\n         LA    R1,8(R1)                point to our savearea\n         ST    R1,SAVE_PTR             and save here\n         USING SAVEAREA,R1             savearea map\n         ST    R1,8(R13)               save its address\n         ST    R13,B_PTR\n         LR    R13,R1\n*2019jan XC    CCATFLAG,CCATFLAG       clean all flag bits\n         ni    CCATFLAG,0              clean all flag bits     @2019jan\n         DROP  R1\n         USING SAVEAREA,R13\n         LR    R1,R2\n         ST    R1,CPPL_PTR             save CPPL pointer\n         XC    RC,RC                   clear return code\n         USING CPPL,R1                 establish CPPL addressability\n         LA    R2,L_CCATAREA(R10)      past end CCAT DATA area\n         ST    R2,PPL_PTR              save PPL pointer\n         USING PPL,R2                  establish PPL addressability\n         MVC   PPLUPT,CPPLUPT          save CPPL UPT address in PPL\n         MVC   PPLECT,CPPLECT          ...also for ECT\n         MVC   PPLCBUF,CPPLCBUF        ...and CPPL command buffer\n         LA    R1,L_CCATAREA\n         ST    R1,CCAT_LEN\n         ST    R10,PPLUWA              and passed to VALIDCK routine\n         ST    R10,CCAT_PTR            and also save here\n         DROP  R1\n         LA    R1,L_PPL(R2)            pass end PPL area\n         ST    R1,ANSWER_PTR           save as answer pointer\n         ST    R1,PPLANS               and also saved in PPL\n         LA    R9,4(R1)                leave 1 fword\n         ST    R9,S99RB_PTR            save as RB pointer\n         L     R1,PCEADCON             point to PCE definition\n         ST    R1,PCL_PTR              save PCL pointer\n         ST    R1,PPLPCL               save as PCL poi\n         XC    ECB,ECB                 clear ECB\n         LA    R1,ECB                  point to ECB\n         ST    R1,PPLECB               save in PPL area\n         MVI   PROC_CODE,C'R'          process code\n         MVC   REASON_CODE(4),=C'0000'\n         CALLTSSR EP=IKJPARS,MF=(E,PPL) invoke PARSE routine\n         LTR   R15,R15                 generate CC\n         BNZ   ERROR_KWD               cleanup and exit if error\nPROCESS  DS    0H\n         L     R3,PPLANS               point to PCL\n         DROP  R2\n         L     R2,0(R3)                point to PDL\n         LH    R3,6(R2)                get PDL length\n         USING CCATPDL,R2              setup PCL addressability\n         L     R9,S99RB_PTR            save as RB pointer\n         LA    R8,L_S99RB(R9)          past end RB area\n         ST    R8,TUPL_PTR             save as TUPList pointer\n         LA    R7,32(R8)               skip 8 fullwords\n         ST    R7,DDTU_PTR             save as DD TU pointer\n         USING S99RBP,R6               SVC 99 RB pointer map\n         USING S99TUNIT,R7             TEXT UNIT addresability\n         USING S99TUPL,R8              TEXT UNIT PLIST map\n         USING S99RB,R9                SVC 99 RB addressability\n         L     R6,S99P_PTR             point to RBP\n         ST    R9,S99RBPTR             store pointer of S99RB\n         OI    S99RBPTR,S99RBPND       specify 31 bit addressing\n         LA    R7,14(R7)               past end DD TU\n         ST    R7,DSTU_PTR             save as DS TU\n         LA    R7,50(R7)               long jumping pass DS TU\n         ST    R7,TU_PTR               save as general purpose TU\n         DROP  R6                      not use anymore\n         EJECT\nGETSCMD  DS    0H\n         XC    MSGPARM(8),MSGPARM      clean all msg parameters\n         XC    MSGSKEL(12),MSGSKEL     clean all msg skeletons\n*2019jan XC    COMMAND,COMMAND         clear SUB COMMAND\n         ni    COMMAND,0               clear SUB COMMAND       @2019jan\n         XC    ER_CODE,ER_CODE         clear error code\n         LH    R3,PDLCMD               get subcommand keyword\n         BCTR  R3,0                    reduce 1\n         SLL   R3,3                    multiply 8\n         B     *+4(R3)                 select the following paths\n         OI    COMMAND,$ON             indicate subcmd 'ON'\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$TOP        indicate subcmd 'TOP'\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$BOT        indicate subcmd 'BOT'   @2019jan\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$BOT        indicate subcmd 'BOT'   @2019jan\n         B     GETDSN                  continue to get DSN\n                                       SPACE\nGETDSN   DS    0H\n         CLC   DSNAME(2),=H'1'         1=LIST  isn't it ?\n         BNE   GETDSN_GO               No, skip it\n*2019jan NI    COMMAND,0               clean all flag bits\n*2019jan OI    COMMAND,$LIST           indicate display CONCAT list\n         mvi   COMMAND,$LIST           indicate display CONCAT @2019jan\n         B     GETDDN                  then jump to process DDname\nGETDSN_GO      DS 0H\n         L     R7,DSTU_PTR             point to DS text unit\n         LM    R3,R4,DSN_PARM          get DSN address and pointer\n         MVC   S99TUNUM(2),=X'0001'       always 1\n         STH   R4,S99TULNG             put DSN length in text unit\n         BCTR  R4,0                    -1\n         EX    R4,MVCDSN               copy DSN into TU\n                                       SPACE\nGETDDN   DS    0H\n         CLC   DDNAME,=H'0'            is DDN spacified ?\n         BNH   ERROR_KWD               No, error\n         L     R7,DDTU_PTR             point to DD text unit\n         MVC   S99TUNUM(2),=X'0001'       always 1\n         LM    R3,R4,DDN_PARM          access specified DDname\n         STH   R4,S99TULNG             put length here\n         MVC   S99TUPAR(8),0(R3)       enter SVC 99 parameter\nGETMSG   DS    0H\n         TM    COMMAND,$LIST           does CONCAT list only ?\n         BO    CLEANUP                 go here if so\n         LH    R3,PDLMSG               get msg sign\n         BCTR  R3,0                    minus 1\n         SLL   R3,3                    multiply 8\n         B     *+4(R3)                 pass thru selected path\n         OI    COMMAND,$MSG            indicate full msg\n         B     EXECUTE                 go execute\n         OI    COMMAND,$NOMSG          indicate no msg\n         B     EXECUTE                 go execute\n         OI    COMMAND,$EMSG           indicate error msg only\n         B     EXECUTE                 go execute\n         OI    COMMAND,$LIST           indicate display CONCAT list\n                                       SPACE\nEXECUTE  DS    0H\n         TM    COMMAND,$ON             request = alloc ?\n         BO    ACCESS                  YES, perform it\n         B     RELEASE                 otherwise, deallocate\nMVCDSN   MVC   S99TUPAR(*-*),0(R3)       << EXECUTED >>\n         DROP  R2\n         EJECT\n*---------------------------------------------*\n* DSNAME/DDNAME ALLOCATION/CONCATENATION      *\n*---------------------------------------------*\n* Logic flow:                                 *\n* 1.  Check info using specified DDNAME       *\n* 2.  If it has already allocated on the      *\n*     top of concatenation, then ignore       *\n*     request.                                *\n*     Otherwise, DEALLOCATE entire concate-   *\n*     nation, then ALLOCATE the specified     *\n*     dataset name, so concatenate all of the *\n*     previous concatenation members as well. *\n* 3.  Check the result.   If it was not       *\n*     accepted, the turn back to previous     *\n*     condition as best it can.               *\n* 4.  Return to TSO and produce return code.  *\n*---------------------------------------------*\n         USING DSLINK,R2               DSN_Chained list addressability\n                                       SPACE\nACCESS   DS    0H\n         BAS   R14,SETALLOC            prepare SVC 99 PLIST\n         BNZ   ACCESS_NEW              suppose has not allocated yet\n         TM    CCATFLAG,$DDN           has ddname found in TIOT\n         BNO   ACCESS_NEW              no, process as new allocation\n         MVC   MSGSKEL(12),MSG_ALRDY   msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,LOOKUP_DSN          look up in Chained JFCB\n         bnz   ACCESS_CONCAT           this way if none        @2019jan\n         TM    CCATFLAG,$DSN           has it allocated ?\n         BNO   ACCESS_CONCAT           no, continue to add it\n         tm    COMMAND,$done           complied the request?   @2019jan\n         bo    In_good_order           yes, just ignore it     @2019jan\n*2019jan TM    COMMAND,$TOP            is it forced to be moved up ?\n         tm    COMMAND,$TOP+$BOT       to be moved up/down?    @2019jan\n*2019jan BNO   IGNORE_ON               NO, don't process it\n         bz    IGNORE_ON               NO, just ignore it      @2019jan\n         mvc   MSGSKEL(12),MSG_DDBUSY  msg skeleton            @2019jan\n         mvc   MSGPARM(8),DDN_PARM     use DDn for msg         @2019jan\n         bas   R14,DEALLOC_ALL         no, deallocate all      @2019jan\n         bnz   CANCEL_ON               break if error          @2019jan\n         tm    COMMAND,$top            to be moved to the top? @2019jan\n         bo    REALLOC_ON              yes, take this way      @2019jan\n         b     REALLOC_bot             no, take this new way   @2019jan\nACCESS_CONCAT  DS 0H\n*2019jan MVC   MSGSKEL(12),MSG_DDBUSY  msg skeleton\n*2019jan MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         tm    COMMAND,$BOT            to be moved down?       @2019jan\n         bo    ACCESS_CONCAT_bot       yes, take this way      @2019jan\n         BAS   R14,DEALLOC_ALL         deallocate all concatenation\n         BNZ   CANCEL_ON               break if error\n         B     REALLOC_ON              assume no allocated dataset\nACCESS_CONCAT_bot equ *                                        @2019jan\n         la    R2,DSN_CHAIN            point to start of chain @2019jan\n         bas   R14,SETCONCT            set concatenation PLIST @2019jan\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R6,DSTU_PTR             point to general DSN TU\n         MVC   S99TULNG(46),4(R6)      return to original value\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         b     REALLOC_DD              continue this way\nACCESS_NEW     DS 0H\n         OI    CCATFLAG,$NEW           indicate new DDname\n         MVC   MSGSKEL(12),MSG_DSWRONG msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,ALLOC_PERM          just allocate it\n         BNZ   ERROR                   break if error\n         OI    CCATFLAG,$DDN           it is allocated I guess !\n         B     FINISH                  then job finished\nCLC_DSN  CLC   S99TUPAR(*-*),0(R3)     << EXECUTED >>\n         EJECT\n*---------------------------------------------*\n* DSNAME/DDNAME DEALLOCATION/DECONCATENATION  *\n*---------------------------------------------*\n* Logic flow:                                 *\n* 1.  Check info using specified DDNAME       *\n*     for existences of both specified DD     *\n*     and DS names.                           *\n* 2.  If both are not any, ignore request     *\n*     Else, DEALLOCATE entire concatenation   *\n*     members, then REALLOCATE one of them    *\n*     so concatenate all of others as well    *\n*     except specified dataset name that      *\n*     requested to be deallocated.            *\n* 3.  Check the result.  If it was unexpected,*\n*     back to old condition as best it can.   *\n* 4.  Return to TSO and produce returncode.   *\n*---------------------------------------------*\n                                       SPACE\nRELEASE  DS    0H\n         MVC   MSGSKEL(12),MSG_DDMISS  msg skeleton\n         MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         TM    CCATFLAG,$DDN           has ddname found in TIOT\n         BNO   IGNORE_OFF              no, ignore\n         BAS   R14,SETALLOC            setup TU and check\n         BNZ   IGNORE_OFF              no, ignore it\n         MVC   MSGSKEL(12),MSG_DSMISS  msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DSn for msg\n         BAS   R14,LOOKUP_DSN          look up in Chained JFCB\n         TM    CCATFLAG,$DSN           has DSN allocated ?\n         BNO   IGNORE_OFF              no, ignore it\n         st    R2,SAVE_REGS            save top of ptr chain   @2019jan\n         MVC   MSGSKEL(12),MSG_DDBUSY  msg skeleton\n         MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         BAS   R14,DEALLOC_ALL         otherwise, deallocate all\n         BNZ   CANCEL_OFF              break if error\n         CLC   DD_COUNT,=H'1'          single allocation ?\n         BH    REALLOC_OFF             no, reallocate all others\n         LA    R2,DSN_CHAIN            point to start of chain\n         OI    DSLFLAG,$ERRALC         it is unallocable anymore\n         NI    DSLFLAG,X'FF'-$ON       turn off eligible bit\n         B     FINISH                  then finish\n         EJECT\n*---------------------------------------------*\n* SELECTIVE REALLOCATION AFTER ALLOC/DEALLOC  *\n*---------------------------------------------*\n                                       SPACE\nREALLOC  DS    0H\nREALLOC_OFF    EQU *\n*2019jan L     R2,SAVE_REGS            restore top of chain pointer\n*2019jan LTR   R2,R2                   check chained address\n         icm   R2,15,SAVE_REGS         restore top of chain    @2019jan\n         BZ    FINISH                  finish if no more\n         L     R7,ALLOC_DSN            point to alloc DSN TU\n         MVC   S99TULNG(2),DSLLEN+2    copy its length\n         MVC   S99TUPAR(44),DSLDSN     copy its string\n         OI    DSLFLAG,$ERRCON         and sign as unconcatable\n         B     REALLOC_ALL             go to reallocate it\nREALLOC_bot    DS 0H\n         st    R2,SAVE_REGS            save top of ptr chain   @2019jan\n         LA    R2,DSN_CHAIN            point to start of chain @2019jan\n*        b     REALLOC_bot_fwd         jump to this way        @2019jan\nREALLOC_bot_seek equ *                                         @2019jan\n         L     R7,DSTU_PTR             point to general DS TU  @2019jan\n         TM    DSLFLAG,$ERRALC+$ERRCON is it reallocable ?     @2019jan\n         BZ    REALLOC_bot_go          use if valid            @2019jan\nREALLOC_bot_fwd equ *                                          @2019jan\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bnz   REALLOC_bot_seek        iterate                 @2019jan\n         l     R2,SAVE_REGS            restore top of chain    @2019jan\n         b     ACCESS_NEW              treat as single alloc   @2019jan\nREALLOC_bot_go equ *                                           @2019jan\n         oi    COMMAND,$done           borrow this 4 indicator @2019jan\n         ni    COMMAND,255-$bot        turn this bit off       @2019jan\n         L     R7,ALLOC_DSN            point to DSN TU         @2019jan\n         L     R3,DSLLEN               get its length          @2019jan\n         STH   R3,S99TULNG             store to TU             @2019jan\n         MVC   S99TUPAR(44),DSLDSN     ...also DSN             @2019jan\n         BAS   R14,ALLOC_PERM          subcommand = ON         @2019jan\n         BZ    *+8                     go after done           @2019jan\n         OI    CCATFLAG,$ON            remember it is pending  @2019jan\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bz    REALLOC_next_check      this way if no more     @2019jan\n         b     REALLOC_PERM_DONE+4     else, process it        @2019jan\nREALLOC_ON     equ *\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R6,DSTU_PTR             point to general DSN TU\n         MVC   S99TULNG(46),4(R6)      return to original value\nREALLOC_ALL    equ *\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,ALLOC_PERM          subcommand = ON\n         BZ    REALLOC_PERM_DONE       go after done\n         OI    CCATFLAG,$ON            remember it is pending\nREALLOC_PERM_DONE equ *\n         LA    R2,DSN_CHAIN            point to start of chain\n         BAS   R14,SETCONCT            setup concatenation PLIST\nREALLOC_LOOP   equ *\n         L     R7,DSTU_PTR             point to general DS TU\n         TM    DSLFLAG,$ERRALC+$ERRCON is it reallocable ?\n         BZ    REALLOC_OKEY            use if valid\nREALLOC_CHEK   equ *\n         TM    DSLFLAG,$ERRCON         is it just unreconcatable ?\n         BO    REALLOC_NEXT            skip if so\n         NI    DSLFLAG,X'FF'-$ON       turn off eligible bit\n         B     REALLOC_NEXT            then skip it\nREALLOC_OKEY   equ *\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R3,DSLLEN               get its length\n         STH   R3,S99TULNG             store to TU\n         MVC   S99TUPAR(44),DSLDSN     ...also DSN\n         TM    CCATFLAG,$ON            is perm allocation pending ?\n         BO    REALLOC_PERM_AGAIN      reallocate an other permanently\nREALLOC_DD     equ *                                           @2019jan\n         L     R7,ALLOC_DDN            point to DDN TU\n         MVI   S99TULNG+1,8            length all = 8\n         MVC   S99TUPAR(8),DSLDDN      use temp. DDN\n         BAS   R14,ALLOC_TEMP          allocate for temporary\n         BNZ   REALLOC_CHEK            sign check bit\n         L     R7,CONCT_DDN            point to DDN TU\n         LH    R3,S99TULNG             get PARM length\n         LA    R3,S99TUPAR(R3)         pass over PARM string\n         MVC   0(2,R3),=X'0008'        length = 8\n         MVC   2(8,R3),DSLDDN          assign Temp DDN as source\n         BAS   R14,CONCATE             reconcatenate all old concate-\n         BNZ   REALLOC_CHEK            sign check bit\nREALLOC_NEXT   equ *\n         tm    COMMAND,$BOT            to be moved down?       @2019jan\n         bo    FINISH                  yes, just leave it      @2019jan\n*2019jan L     R2,DSLNEXT              get next DSLINK\n*2019jan LTR   R2,R2                   check for end of entry\n*2019jan BZ    FINISH                  finish if 0\n*2019jan BCT   R11,REALLOC_LOOP        otherwise, loop\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bnz   REALLOC_LOOP            iterate for all         @2019jan\nREALLOC_next_check equ *                                       @2019jan\n         tm    COMMAND,$done           concate at the bottom?  @2019jan\n         bno   FINISH                  no, just leave it       @2019jan\n         oi    COMMAND,$bot            yes, indicate it        @2019jan\n         ni    COMMAND,255-$done       turn this bit off       @2019jan\n         icm   R2,15,SAVE_REGS         restore top of chain    @2019jan\n         bnz   ACCESS_CONCAT_bot       this way if got it      @2019jan\n         B     FINISH                  then finish\nREALLOC_PERM_AGAIN equ *\n         BAS   R14,ALLOC_PERM          allocate permanently\n         BNZ   REALLOC_CHEK            sign check bit\n         NI    CCATFLAG,X'FF'-$ON      turn pending bit off\n         B     REALLOC_NEXT\n                                       SPACE\n*---------------------------------------------*\n* LOOKUP DSN_CHAINED LIST AND VALIDATE        *\n*---------------------------------------------*\nLOOKUP_DSN     DS 0H\n         LA    R2,DSN_CHAIN            point to DSN Chained list\n         LR    R1,R2                   and save it\n*2019jan XR    R15,R15                 clear RC\n         LA    R15,12                  set RC=12               @2019jan\n         L     R7,DSTU_PTR             point general DSN TU\nLOOKUP_LOOP    equ *\n         L     R3,DSLLEN               get its length\n         BCTR  R3,0                    reduce for EX CLC\n         EX    R3,LOOKUP_CLC           is it duplication ?\n         BNE   LOOKUP_NEXT             ignore if unmatch\n         xr    r15,r15                 set rc = 0              @2019jan\n         OI    CCATFLAG,$DSN           remember it exists\n         OI    DSLFLAG,$ERRALC         flag for unreallocable\n         CR    R1,R2                   is it the 1st entry\n*2019jan BNE   LOOKUP_NEXT             ignore if not\n         be    LOOKUP_top              this way if so          @2019jan\nLOOKUP_check   equ *                                           @2019jan\n         icm   r0,15,DSLNEXT           point to next entry     @2019jan\n         bnz   LOOKUP_NEXT             if not 0, ignore it     @2019jan\nLOOKUP_bot     equ *                                           @2019jan\n         tm    COMMAND,$bot            to be moved to bottom?  @2019jan\n         bo    LOOKUP_comply           yes, mark as complied   @2019jan\n         b     LOOKUP_NEXT             no, skip below          @2019jan\nLOOKUP_top     equ *                                           @2019jan\n         L     R1,DSLNEXT              switch to next entry\n         tm    COMMAND,$TOP            to be moved to the top? @2019jan\n         bno   LOOKUP_NEXT             no, skip below          @2019jan\nLOOKUP_comply  equ *                                           @2019jan\n         oi    COMMAND,$done           remember it is complied @2019jan\nLOOKUP_NEXT    equ *\n*2019jan L     R2,DSLNEXT              point to next entry\n*2019jan LTR   R2,R2                   CHECK\n         icm   r2,15,DSLNEXT           point to next entry     @2019jan\n         BNZ   LOOKUP_LOOP             loop for all entries\n*2019jan CR    R15,R1                  is top pointer valid ?\n*2019jan BNE   LOOKUP_STOP             stop end if so\n*2019jan LR    R1,R15                  else, zerroes R1\n*2019jan LA    R15,12                  set RC=12\nLOOKUP_STOP    equ *\n         LA    R2,DSN_CHAIN            restore DSN Chainedlist pointer\n         LTR   R15,R15                 generate CC\n         bzr   r14                     return if 0             @2019jan\n         xr    r1,r1                   else, zeroes reg 1      @2019jan\n         BR    R14                     return\nLOOKUP_CLC     CLC S99TUPAR(*-*),DSLDSN   << executed >>\n         EJECT\n*---------------------------------------------*\n* ALLOCATE SPECIFIED DSN AS SPECIFIED DDNAME  *\n*---------------------------------------------*\nALLOC_TEMP     DS 0H\n         LA    R1,L_ALLOC_TEMP         select temporary\n         MVI   PROC_CODE,C'T'          process code\n         B     ALLOCATE                then allocate\nALLOC_PERM DS  0H\n         LA    R1,L_ALLOC_PERM         select permanent\n         MVI   PROC_CODE,C'A'          process code\nALLOCATE DS    0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBAL        request is allocation\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_ALLOC_TUPLIST,R8),ALLOC_TUPLIST copy specified TUPL\n         LA    R8,0(R8,R1)             skip to the last TUPLIST\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if fine\n         CLI   PROC_CODE,C'T'          check process code\n         BNE   ALLOCATE_FAIL           go here if fail\n         OI    CCATFLAG,$ERRS99        put error flag\nALLOCATE_END   DS 0H\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\nALLOCATE_FAIL  DS 0H\n         STH   R15,ER_CODE             save error code here\n         OI    CCATFLAG,$ERRALC        put error flag\n         B     ALLOCATE_END            end, return\n                                       SPACE\n*---------------------------------------------*\n* CONCATE THE REMAINDER TO THE ALLOCATED DSN  *\n*---------------------------------------------*\n                                       SPACE\nCONCATE  DS    0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBCC        request is CONCATENATION\n         LA    R8,CONCT_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_CONCT_TUPLIST-4(R8) point to last TU PTR\n         MVI   PROC_CODE,C'C'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if no error\n         OI    CCATFLAG,$ERRCON+$ERRS99 turn error bit on\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\n                                       SPACE\n*---------------------------------------------*\n* RELEASE DSN FROM DDNAME CONCATENATION       *\n*---------------------------------------------*\n                                       SPACE\nDEALLOC_ALL    DS 0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBUN        request is DEALLOCATION\n         LA    R8,RELSE_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_RELSE_ALL(R8)      point to last TU PTR\n         MVI   PROC_CODE,C'U'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if so good\n         CH    R15,=H'4'               is it tolerable error ?\n         BH    DEALLOC_FAIL            no,.... error msg\nDEALLOC_ONE    DS 0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBUN        request is DEALLOCATION\n         LA    R8,RELSE_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_RELSE_ONE(R8)      point to last TU PTR\n         MVI   PROC_CODE,C'U'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if so good\n         OI    CCATFLAG,$ERRS99        indicate general error\n         CLC   =H'0856',S99ERROR       overriding disposition ?\n         BER   R14                     return if so\n*        CLC   =H'1088',S99ERROR       dsname not found ?\n*        BER   R14                     return if so\n         CLC   =H'1116',S99ERROR       DSN permanently concatenated ?\n         BER   R14                     return if so\n*        CLC   =H'1120',S99ERROR       DSN // DDN not associated ?\n*        BER   R14                     return if so\n         CLC   =H'1124',S99ERROR       DSN is in private catalog ?\n         BER   R14                     return if so\nDEALLOC_FAIL   DS 0H\n         STH   R15,ER_CODE             save error code here\n         OI    CCATFLAG,$ERRUNL        put error flag\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\n         EJECT\n*---------------------------------------------*\n* BUILD INFORMATION RETRIEVAL TEXT UNITS      *\n* and save the pointer in QRY_TUPLIST         *\n*---------------------------------------------*\nSETALLOC DS    0H                             *\n         L     R7,DSTU_PTR             point to DSN text unit\n         MVC   S99TUKEY(2),=AL2(DALDSNAM) query for specififed DDname\n         L     R2,TU_PTR               point to general TU\n         LH    R3,S99TULNG             get its parm length\n         MVC   0(50,R2),0(R7)          save the TU\n         ST    R2,ALLOC_DSN            save the pointer in directry\n         LA    R7,50(R2)               skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DALPERMA) permanent alloaction\n         XC    S99TUNUM(2),S99TULNG    number must be 0\n         ST    R7,ALLOC_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         MVC   S99TUKEY(2),=AL2(DALSTATS) permanent alloaction\n         MVI   S99TUNUM+1,1            number must be 1\n         MVI   S99TULNG+1,1            1 bytes length\n         MVI   S99TUPAR,$SHR           DISP=SHR\n         ST    R7,ALLOC_STS            save the pointer in directry\n         LA    R7,8(R7)                skip over this TU\n         L     R2,DDTU_PTR             point to DD text unit\n         MVC   0(14,R7),0(R2)          load whole DD TU\n         MVC   S99TUKEY(2),=AL2(DALDDNAM) DDname to be allocated\n         ST    R7,ALLOC_DDN            save the pointer in directry\n         LA    R2,14(R7)               next area\n         ST    R2,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD DEALLOCATION TEXT UNITS               *\n* and save the pointer in RELSE_TUPLIST       *\n*---------------------------------------------*\nSETRELSE DS    0H                             *\n         L     R2,DSTU_PTR             point to DSN text unit\n         L     R7,TU_PTR               point to general TU\n         MVC   S99TUNIT(50),0(R2)      load the TU\n         MVC   S99TUKEY(2),=AL2(DUNDSNAM) query for specififed DDname\n         LH    R3,S99TULNG             get its parm length\n         ST    R7,RELSE_DSN            save the pointer in directry\n         LA    R7,50(R7)               skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DUNUNALC) permanent alloaction\n         XC    S99TUNUM(2),S99TULNG    number must be 0\n         ST    R7,RELSE_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         L     R2,DDTU_PTR             point to DD text unit\n         MVC   S99TUNIT(50),0(R2)      load the TU\n         MVC   S99TUKEY(2),=AL2(DUNDDNAM) DDname to be allocated\n         ST    R7,RELSE_DDN            save the pointer in directry\n         LA    R2,14(R7)               next area\n         ST    R2,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD INFORMATION RETRIEVAL TEXT UNITS      *\n* and save the pointer in QRY_TUPLIST         *\n*---------------------------------------------*\nSETQUERY DS    0H\n         L     R7,DDTU_PTR             point to DD text unit\n         MVC   S99TUKEY(2),=AL2(DINDDNAM) query for specififed DDname\n         L     R2,TU_PTR               point to general TU\n         LH    R3,S99TULNG             get its parm length\n         MVC   0(50,R2),0(R7)          save the TU\n         ST    R2,QRY_DDN              save the pointer in directry\n         LA    R7,6(R3,R2)             skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DINRTATT) ask for allocation attibute\n         MVC   S99TUNUM(2),=X'0001'    always 1\n         MVC   S99TULNG(2),=X'0001'\n         MVI   S99VERB,S99VRBIN        request to get info\n         ST    R7,QRY_ATR              save the pointer in directry\n         LA    R7,8(R7)                skip over this TU\n         MVC   S99TUKEY(2),=AL2(DINRTDSN) ask for dataset name\n         MVC   S99TUNUM(2),=X'0001'    always 1\n         MVC   S99TULNG(2),=X'002C'    44 bytes length\n         ST    R7,QRY_DSN              store into TUPlist\n         LA    R7,50(R7)               skip over their area\n         ST    R7,TU_PTR               save as available TU area\nQUERY    DS    0H                             *\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBIN        request is INFO. RETRIEVAL\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_QRY_TUPLIST,R8),QRY_TUPLIST copy specified TUPL\n         LA    R8,L_QRY_TUPLIST-4(R8)  skip to the last TUPLIST\n         MVI   PROC_CODE,C'I'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BR    R14                     RETURN\n                                       SPACE\n*---------------------------------------------*\n* BUILD CONCATENATION TEXT UNITS              *\n* and save the pointer in CONCT_TU_PTR        *\n*---------------------------------------------*\nSETCONCT DS    0H                             *\n         L     R7,TU_PTR               point to general TU\n         MVC   S99TUKEY(2),=AL2(DCCPERMC) permanent alloaction\n         XC    S99TUNUM(2),S99TUNUM    number must be 0\n         ST    R7,CONCT_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         ST    R7,CONCT_DDN            save the pointer in directry\n         L     R3,DDTU_PTR             point to DD text unit\n         MVC   S99TUNIT(14),0(R3)      load whole DD TU\n         MVC   S99TUKEY(2),=AL2(DCCDDNAM) DDname to be allocated\n         MVI   S99TUNUM+1,X'02'        PARM num = 2\n         LA    R7,24(R7)               next area\n         ST    R7,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD DECONCATENATION TEXT UNITS            *\n* and save the pointer in DECON_TU_PTR        *\n*---------------------------------------------*\nSETDECON DS    0H                             *\n         BR    R14                     RETURN\n         EJECT\n*---------------------------------------------*\n* PROLOGUE PRIOR SVC 99 SERVICE LOGIC         *\n*---------------------------------------------*\nS99_PROLG DS   0H\n         L     R9,S99RB_PTR            point to RB\n         XC    S99RB(L_S99RB),S99RB    clear the area\n         MVI   S99RBLN,L_S99RB         save it's self length\n         BR    R11                     RETURN\n                                       SPACE\n*------------------------------------------------*\n* INVOKING SVC 99 SERVICE FOR DYNAMIC ALLOCATION *\n*------------------------------------------------*\nDYNALLOC DS    0H\n         OI    S99TUPTR,S99TUPLN       and sign EOTUPLIST\n         L     R1,S99P_PTR             point to SVC 99 plist pointer\n         SVC   99                      invoke SVC 99\n         TM    CCATFLAG,$ERRALC+$ERRUNL has any error before ?\n         BNZ   DYNALLOC_END            skip if so\n         MVC   IF_CODE,S99INFO         save info code\n         MVC   RS_CODE,S99ERROR        save reason code\nDYNALLOC_END   DS 0H\n         STH   R15,RT_CODE             save return code\n         LTR   R15,R15                 check CC\n         BR    R11                     RETURN\n         EJECT\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE WITH ERRONOUS  *\n*-------------------------------------*\nFINISH   DS    0H\n         TM    CCATFLAG,$ERRALC+$ERRUNL  has it any erronous\n         BNZ   ERROR                   Yes, go to error routine\n         B     RETURN                  else, cleanup and return\n                                       SPACE\n*----------------------------------------*\n*  EXIT EPILOG ROUTINE WITH CANCELLATION *\n*----------------------------------------*\nIn_good_order  ds 0h                                           @2019jan\n         MVC   MSGSKEL(12),MSG_INORDER msg skeleton            @2019jan\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg         @2019jan\n         B     IGNORE                  then take this way      @2019jan\nIGNORE_ON      DS 0H\n         OI    CCATFLAG,$ERRALC        indicate error allocation\n         B     IGNORE                  then cancel it\nIGNORE_OFF     DS 0H\n         OI    CCATFLAG,$ERRUNL        indicate error deallocation\nIGNORE   DS    0H\n         LA    R15,4                   ignoring RC = 4\n*2019jan ST    R15,RC                  save RC\n*2019jan TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n*2019jan BO    CLEANUP                 YES, so quit immediately\n*2019jan B     CHECK_MSG               prepare msg to be displayed\n         b     LEAVE                   continue this way       @2019jan\n                                       SPACE\nCANCEL_ON      DS 0H\n         OI    CCATFLAG,$ERRALC        indicate error allocation\n         B     CANCEL                  then cancel it\nCANCEL_OFF     DS 0H\n         OI    CCATFLAG,$ERRUNL        indicate error deallocation\nCANCEL   DS    0H\n         LA    R15,8                   cancellation RC = 8\nLEAVE    DS    0H                                              @2019jan\n         ST    R15,RC                  save RC\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         B     CHECK_MSG               prepare msg to be displayed\n                                       SPACE\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE WITH ERRONOUS  *\n*-------------------------------------*\nERROR    DS    0H\n         TM    COMMAND,$ON+$ERRS99     is it allocation or any g.error\n         BZ    ERRFAIL                 no, need not recovery\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBAL        request is allocation\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_ALLOC_TUPLIST_RETRY,R8),ALLOC_TUPLIST_RETRY\n         LA    R8,L_ALLOC_TUPLIST_RETRY-4(R8) skip to last TUPLIST\n         OI    S99TUPTR,S99TUPLN       and sign EOTUPLIST\n         L     R1,S99P_PTR             point to SVC 99 plist pointer\n         SVC   99                      invoke SVC 99\n         LTR   R15,R15                 check CC\n         BZ    ERRFAIL                 go here if recovery success\n         OI    CCATFLAG,$ERRCVRY       else, indicate recovery error\n         LA    R15,12                  set RC=12\n         STH   R15,ER_CODE             save it\n                                       SPACE\nERRFAIL  DS    0H\n         LH    R15,ER_CODE             get standard SVC 99 RC\n         LA    R15,4(R15)              add 4\n         ST    R15,RC                  save RC\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         BAS   R14,BUILDSKL            construct msg skeleton\n         BZ    CHECK_MSG               success, proceed\n         BAS   R14,BUILDMSG            construct msg text\n         MVC   MSGHDR+5(2),RETURN_CODE+2 insert RC in msg header\n         L     R15,MSGPARM             point to substitution location\n         MVI   5(R15),C'+'             insert process code\n         B     CHECK_MSG\n                                       SPACE\n*-------------------------------------*\n*  ERROR KEYWORD OR SYNTAX            *\n*-------------------------------------*\nERROR_KWD DS   0H\n         MVI   PROC_CODE,C'K'          process code\n         OI    CCATFLAG,$ERRKWD        remember it is syntax error\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         L     R15,ERRKWD_PTR          get ERROR KWD pointer\n         MVC   MSGLINE(L'ERRKWD),0(R15)   and move here\n         MVC   MSGLEN,=Y(L'ERRKWD+4)\n         BAS   R14,SHOW_MSG            display MSG\n         LM    R2,R3,HELPTAB_PTR       access help table\n         MVC   MSGHDR,=CL8' '          clear\nHELPLOOP DS    0H\n         MVC   MSGTEXT(L_HELPTAB),0(R2) get help text\n         MVC   MSGLEN,=Y(L'MSGHDR+L_HELPTAB+4) ...and its length\n         BAS   R14,SHOW_MSG            display MSG\n         LA    R2,L_HELPTAB(R2)        next help text\n         BCT   R3,HELPLOOP             loop for all\n         LA    R15,20                  RC = 20\n         ST    R15,RC                  save RC\n         B     EXIT                    then exit to TSO\n         EJECT\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE IF NO ERROR    *\n*-------------------------------------*\nRETURN   DS    0H\n         LH    R15,ER_CODE             load error code\n         LTR   R15,R15                 check CC\n         BNZ   ERROR                   error if wrong\n         TM    COMMAND,$NOMSG+$EMSG    is NOMSG/EMSG required ?\n         BNZ   CLEANUP                 YES, so quit immediately\n         MVC   MSGPARM(8),DSN_PARM     substitute msg text using DSN\n         TM    COMMAND,$ON             is it ON function ?\n         BO    RETURN_MSG              yes, handle completion msg\n         MVC   MSGSKEL(12),MSG_OFF     else, use OFF completion msg\n         B     CHECK_MSG               then,  process it\nRETURN_MSG     DS 0H\n         MVC   MSGSKEL(12),MSG_ON      select msg skeleton\n         TM    CCATFLAG,$NEW           is it new allocation ?\n         BNO   CHECK_MSG               no, use normal completion msg\n         MVC   MSGSKEL(12),MSG_NEW     otherwise, use special msg\nCHECK_MSG      DS 0H\n         BAS   R14,BUILDMSG            build msg text line\nDISPLAY_MSG    DS 0H\n         BAS   R14,SHOW_MSG            display MSG\n         B     CLEANUP                 then cleanup\n                                       SPACE\n*-------------------------------------*\n*   PUTLINE SERVICE GATE              *\n*-------------------------------------*\n                                       SPACE\nSHOW_MSG DS    0H\n         ST    R14,SAVE14              save linkage pointer\n         XC    MSGLEN+2(2),MSGLEN+2\n         L     R15,PUTLINE_PTR         point to PUTLINE service\n         BASR  R14,R15                 perform it\n         L     R14,SAVE14              save linkage pointer\n         BR    R14                     return\nSHOW_DSN DS    0H\n         LA    R15,64                  msg text length\n         STH   R15,MSGLEN              and store here\n         B     SHOW_MSG                then display MSG\nMVC_LIST_NEW   MVC MSGTEXT+8(*-*),S99TUPAR\n         EJECT\n*-------------------------------------*\n*  BUILD PUTLINE FORMAT MSG SKELETON  *\n*  - R14 :  Linkage address           *\n*-------------------------------------*\n                                       SPACE\nBUILDSKL DS    0H\n         USING MSGBLOK,R5              msg directory blok map\n         MVC   MSGPARM(8),DSN_PARM     suppose for substitution\n         LM    R5,R7,MSGDIR_PTR        point to msg directory entry\nBSKLOOP1 DS    0H\n         CLC   MSGCODE,RS_CODE         is it the error code ?\n         BE    BSKLOKEY                leave this loop if so\n         LA    R5,MSGBLOKL(R5)         otherwise, seek next entry\n         BCT   R6,BSKLOOP1             .. then loop for all entries\nBSKLOOP2 DS    0H\n         CLC   MSGCODE(1),RS_CODE      check 1st byte only\n         BE    BSKLOKEY                leave this loop if match\n         LA    R5,MSGBLOKL(R5)         otherwise, seek next entry\n         BCT   R7,BSKLOOP2             .. then loop for all entries\n         MVC   MSGSKEL(12),MSG_FAIL    it is function failure\n         LA    R15,REASON_CODE         access reason code field\n         ST    R15,MSGPARM             use as substitution parameter\n         MVC   MSGPARM+4(4),=F'6'      length is always 4\n         LH    R15,RS_CODE             get reason code\n         CVD   R15,PACKED              convert to packed decimal\n         UNPK  REASON_CODE,PACKED      unpack\n         OI    REASON_CODE+3,X'F0'     convert to printable EBCDIC\n         B     BSKLEND                 finish\nBSKLOKEY DS    0H\n         NI    CCATFLAG,X'FF'-$ERRCVRY turn off recovery flag bit\n         XR    R15,R15                 reset CC\n         L     R2,MSGDIR_PTR           point to msg directory entry\n         AH    R2,MSGSKLA              correct msg skeleton address\n         MVC   MSGSKEL(12),0(R2)       select this address for later\n         TM    MSGFLAG,$DSN            is substitution right ?\n         BO    BSKLEND                 yes, continue to build msg line\n         MVC   MSGPARM(8),DDN_PARM     else, use DDname\nBSKLEND  DS    0H\n         LTR   R15,R15                 generate CC\n         BR    R14                     return\n         DROP  R5\n                                       SPACE\n*-------------------------------------*\n*  BUILD PUTLINE FORMAT MSG TEXT LINE *\n*  - R14 :  Linkage address           *\n*-------------------------------------*\n                                       SPACE\nBUILDMSG DS    0H\n         L     R2,SKLHDR               msg header\n         LH    R3,SKLHDRL              ...its length\n         LR    R15,R3                  initialize msg length\n         LA    R5,MSGLINE              access msg text\n         EX    R3,MVCLINE              contruct msg line\n         LA    R5,0(R5,R3)             skip over writen line\n         LM    R2,R3,MSGPARM           access substitutor\n         AR    R15,R3                  add line length\n         EX    R3,MVCLINE              contruct msg line\n         LA    R5,0(R5,R3)             skip over writen line\n         L     R2,SKLTXT               msg text trailer\n         LH    R3,SKLTXTL              ...its length\n         AR    R15,R3                  add line length\n         EX    R3,MVCLINE              contruct msg line\n         LA    R15,4(R15)              add 4\n         L     R1,RC                   get RC\n         LTR   R1,R1                   check\n         BZ    BLDMEND                 end this routine if RC=0\n         L     R1,RC                   load RC\n         CVD   R1,PACKED               convert to packed decimal\n         UNPK  RETURN_CODE,PACKED      unpack\n         OI    RETURN_CODE+3,X'F0'     convert to printable EBCDIC\n         LA    R5,0(R5,R3)             skip over writen line\n         MVC   RC_TEXT,RC_LINE         build RC skeleton\n         MVC   RC_MSG,RETURN_CODE      and put its value in\n         LA    R2,RC_TEXT              point to text of RC\n         LA    R3,L'RC_TEXT            and access its length\n         AR    R15,R3                  correct total length\n         EX    R3,MVCLINE              move RC text to msg line\nBLDMEND  DS    0H\n         STH   R15,MSGLEN              total msg length\n         BR    R14                     return\nMVCLINE  MVC   0(*-*,R5),0(R2)\n         EJECT\n*-------------------------------------*\n*    FINAL EXIT EPILOG ROUTINE        *\n*                                     *\n*   NOTES:                            *\n*                                     *\n*        - The following logic quiet  *\n*          unstructured due to        *\n*          performance reason so far. *\n*                                     *\n*        - To make it structured      *\n*          logic, remove all \"TM\"     *\n*          instruction into SHOW_MSG  *\n*          routine.                   *\n*                                     *\n*-------------------------------------*\nCLEANUP  DS    0H\n         TM    COMMAND,$NOMSG          is msg allowed ?\n         BNO   CLEANUP_SETUP           no, skip, continue to cleanup\n         NI    COMMAND,X'FF'-$LIST     make sure no MSG\n         NI    CCATFLAG,0              ...and msg opportunity at all\n         B     CLEANUP_GO              then continue to cleanup\nCLEANUP_SETUP  DS 0H\n         USING DSLINK,R2               TIOT copy chain addressability\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_GO              no, skip, continue to cleanup\n         L     R7,DDTU_PTR             point to DD TU\n         MVI   MSGLINE,X'40'           use blank to clear msg area\n         MVC   MSGLINE+1(L'MSGLINE-1),MSGLINE\n         MVC   MSGHDR,=C'CCAT800 '     special header\n         LA    R5,MSGTEXT              access msg text\n         LM    R2,R3,JOBSPEC           access jobname and its length\n         EX    R3,MVCLINE              move in jobname\n         LA    R5,0(R5,R3)             jump over jobname string\n         MVC   0(3,R5),=C'DD('\n         LA    R5,3(R5)                jump over this string\n         LM    R2,R3,DDN_PARM          access DDN string\n         BCTR  R3,0                    correct for EX MVC\n         EX    R3,MVCLINE              move in ddname\n         LA    R5,1(R5,R3)             jump over ddname string\n         MVC   0(16,R5),=CL16') concatenation:'\n         LA    R5,16(R5)               jump over this string\n         LR    R3,R5                   copy\n         LA    R2,MSGLEN               PUTLINE text address\n         SLR   R5,R2                   calculate text length\n         STH   R5,MSGLEN               save the length\n         TM    CCATFLAG,$DDN           has it allocated ?\n         BO    CLEANUP_TPUT            skip if so\n         MVC   0(10,R3),=CL10' not found'\n         LA    R3,10(R3)               jump over this string\n         SLR   R3,R2                   correct text length\n         STH   R3,MSGLEN               save the length\n         NI    COMMAND,X'FF'-$LIST     remove list flag\nCLEANUP_TPUT   DS 0H\n         BAS   R14,SHOW_MSG            display msg\n         MVI   MSGLINE,X'40'           use blank to clear msg area\n         MVC   MSGLINE+1(L'MSGLINE-1),MSGLINE\n         TM    CCATFLAG,$ERRALC+$ERRUNL any serious error ?\n         BNZ   CLEANUP_GO              skip and proceed\nCLEANUP_GOHEAD DS 0H\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_GO              no, continue to cleanup\n         TM    COMMAND,$ON             is it allocation ?\n         BNO   CLEANUP_GO              skip if deallocation\n         MVC   MSGTEXT(8),=CL8'New --> ' put new sign\n         L     R7,DSTU_PTR             point to DSN TU\n         LH    R3,S99TULNG             get its length\n         BCTR  R3,0                    reduce for EX\n         EX    R3,MVC_LIST_NEW         get DSN\n         BAS   R14,SHOW_DSN            display msg\nCLEANUP_GO     DS 0H\n         LA    R2,DSN_CHAIN            point to chaining TIOT copy\n         L     R11,DSLNEXT             get next chain\n         LH    R3,DD_COUNT             # of concatenation members\n         LA    R3,1(R3)                add 1 for initialize loop\n         B     CLEANUP_ROLL            and go here\nCLEANUP_LOOP   DS 0H\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_ONLY            skip if not\n         LA    R2,DSN_CHAIN            point to chaining TIOT copy\n         MVC   MSGTEXT(3),DSLDDN+5\n         MVC   MSGTEXT+3(5),=CL5' --> '\n         TM    DSLFLAG,$ON             DSN eligible to be displayed ?\n         BO    CLEANUP_LIST            skip if not\n         MVC   MSGTEXT(8),=CL8'Error'  mark error\n         TM    CCATFLAG,$ERRCON        does CONCAT list requested ?\n         BO    CLEANUP_LIST            skip if not\n         MVC   MSGTEXT(8),=CL8'Skipped' mark skipped\nCLEANUP_LIST   DS 0H\n         MVC   MSGTEXT+8(44),DSLDSN    write DSN string into msg text\n         BAS   R14,SHOW_DSN            else display it\n         LTR   R2,R11                  check if 0\n         BZ    QUIT                    quit if 0\n         MVC   DSN_CHAIN(L_DSLINK),0(R11) move next chain here\n         B     CLEANUP_FRET\nCLEANUP_ONLY   DS 0H\n         LTR   R2,R11                  check if 0\n         BZ    QUIT                    quit if 0\nCLEANUP_FRET   DS 0H\n         L     R11,DSLNEXT             get next chain\n         FREEMAIN R,LV=L_DSLINK,A=(2)  release it\nCLEANUP_ROLL   DS 0H\n         BCT   R3,CLEANUP_LOOP         loop if any other chained area\n         DROP  R2\nQUIT     DS    0H\n         TM    CCATFLAG,$ERRCVRY       has error recoverd ?\n         BNO   EXIT                    yes, skip to exit\n         MVC   MSGHDR,=CL8' '          clear msg header\n         L     R15,CONCATE_PTR         point to concatenationlist serv\n         BASR  R14,R15                 perform this service\nEXIT     DS    0H\n         L     R5,RC                   save RC\n         L     R1,STOR_PTR             point to GETMAINed area\n         L     R13,B_PTR               restore system savearea pointer\n         DROP  R13                     reset privatearea addressing\n         FREEMAIN R,LV=STORAGE,A=(1)   release storage\n         L     R14,12(R13)\n         LR    R15,R5\n         LM    R0,R12,20(R13)\n         BSM   0,R14\n         EJECT\n*-------------------------------------*\n*  SERVICE ROUTINE DIRECTORY          *\n*-------------------------------------*\nPUTLINE_PTR    DC A(DERCCTPL)          PUTLINE service routine address\nCONCATE_PTR    DC A(DERCCTLS)          concatenation list service\nMSGDIR_PTR     DC A(MSGDIR,MSGDIRN,MSGDIRM) skeleton directory ptr/len\nERRKWD_PTR     DC A(ERRKWD)            syntax error text pointer\nHELPTAB_PTR    DC A(HELPTAB,HELPTABL)  syntax help table pointer\nPCEADCON       DC A(PCEDEFS)\n                                       SPACE\n*-------------------------------------*\n*  LITERALS POOL  #1                  *\n*-------------------------------------*\n         LTORG\n         EJECT\n*-------------------------------------*\n*  MESSAGES SKELETONS DIRECTORY       *\n*-------------------------------------*\nMSGDIR   DS    0H\n         DC    AL2(0572),AL1($DSN),XL1'00',AL2(MSG_UNCAT-MSGDIR)\n         DC    AL2(0596),AL1($DSN),XL1'00',AL2(MSG_DSBUSY-MSGDIR)\n         DC    AL2(0868),AL1($DDN),XL1'00',AL2(MSG_DDWRONG-MSGDIR)\n         DC    AL2(0872),AL1($DSN),XL1'00',AL2(MSG_DSWRONG-MSGDIR)\n         DC    AL2(1040),AL1($DDN),XL1'00',AL2(MSG_DDUNAVL-MSGDIR)\n         DC    AL2(1056),AL1($DDN),XL1'00',AL2(MSG_DDBUSY-MSGDIR)\n         DC    AL2(1060),AL1($DSN),XL1'00',AL2(MSG_DSWRONG-MSGDIR)\n         DC    AL2(1076),AL1($DDN),XL1'00',AL2(MSG_DDCNFLC-MSGDIR)\n         DC    AL2(1080),AL1($DDN),XL1'00',AL2(MSG_DDMISS-MSGDIR)\n         DC    AL2(1084),AL1($DDN),XL1'00',AL2(MSG_DDUNAVL-MSGDIR)\n         DC    AL2(1088),AL1($DSN),XL1'00',AL2(MSG_DSMISS-MSGDIR)\n         DC    AL2(1096),AL1($DSN),XL1'00',AL2(MSG_ALRDY-MSGDIR)\nMSGDIRX  DC    AL2(1124),AL1($DSN),XL1'00',AL2(MSG_PRVCAT-MSGDIR)\nMSGDIRL  EQU   *-MSGDIRX\nMSGDIRN  EQU   (*-MSGDIR)/MSGDIRL\n         DC    XL2'5700',AL1($DSN),XL1'00',AL2(MSG_ERCAT-MSGDIR)\n         DC    XL2'1700',AL1($DSN),XL1'00',AL2(MSG_UNCAT-MSGDIR)\n         DC    XL2'6700',AL1($DSN),XL1'00',AL2(MSG_EROBT-MSGDIR)\nMSGDIRM  EQU   (*-MSGDIR)/MSGDIRL\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES TEXT SKELETONS            *\n*-------------------------------------*\nMSGSKL   DS    0H\nMSG_NEW        DC  AL4(MH000),AL4(MT000),AL2(L'MH000),AL2(L'MT000)\nMSG_ON         DC  AL4(MH001),AL4(MT001),AL2(L'MH001),AL2(L'MT001)\nMSG_OFF        DC  AL4(MH002),AL4(MT002),AL2(L'MH002),AL2(L'MT002)\nMSG_DDBUSY     DC  AL4(MH003),AL4(MT003),AL2(L'MH003),AL2(L'MT003)\nMSG_DSWRONG    DC  AL4(MH004),AL4(MT004),AL2(L'MH004),AL2(L'MT004)\nMSG_ALRDY      DC  AL4(MH005),AL4(MT005),AL2(L'MH005),AL2(L'MT005)\nMSG_UNCAT      DC  AL4(MH006),AL4(MT006),AL2(L'MH006),AL2(L'MT006)\nMSG_DSBUSY     DC  AL4(MH007),AL4(MT007),AL2(L'MH007),AL2(L'MT007)\nMSG_DDWRONG    DC  AL4(MH008),AL4(MT008),AL2(L'MH008),AL2(L'MT008)\nMSG_DDMISS     DC  AL4(MH009),AL4(MT009),AL2(L'MH009),AL2(L'MT009)\nMSG_DSMISS     DC  AL4(MH010),AL4(MT010),AL2(L'MH010),AL2(L'MT010)\nMSG_DDUNAVL    DC  AL4(MH011),AL4(MT011),AL2(L'MH011),AL2(L'MT011)\nMSG_DDCNFLC    DC  AL4(MH012),AL4(MT012),AL2(L'MH012),AL2(L'MT012)\nMSG_PRVCAT     DC  AL4(MH013),AL4(MT013),AL2(L'MH013),AL2(L'MT013)\nMSG_ERCAT      DC  AL4(MH014),AL4(MT014),AL2(L'MH014),AL2(L'MT014)\nMSG_EROBT      DC  AL4(MH015),AL4(MT015),AL2(L'MH015),AL2(L'MT015)\nMSG_INORDER    DC  AL4(MH016),AL4(MT016),AL2(L'MH016),AL2(L'MT016)\nMSG_FAIL       DC  AL4(MH900),AL4(MT900),AL2(L'MH900),AL2(L'MT900)\nMSGSKLL  EQU   *-MSGSKL\nRC_LINE  DC    C', RC=0000.' RC for msg line\n         DROP  R7,R8,R9\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DSNAME OPERAND VALIDATOR                                           *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DSname from DS() operand       *\n*        of this command based on standard DSN string pattern in      *\n*        MVS system.                                                  *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified DS(dsname) in CONCAT operand                       *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DSN string pointer and length in CCATAREA storage          *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTDS\nDERCCTDS DS    0D\n         SAVE  (14,12),,'DERCCTDS: CCAT DSN VALIDATOR'\n         LR    R9,R15                  point to base register\n         USING DERCCTDS,R9             establish addessability\n         USING CCATAREA,R10            establish addressability\n         LR    R2,R1                   copy validity check PLIST\n         L     R10,4(R2)               point to the DWA\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$DSN           remember to process DSN\n         mvi   VALCFLAG,$DSN           remember to process DSN @2019jan\n         B     VALIDATE                proceed\n                                       SPACE\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  PUTLINE SERVICE CALL                                               *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Structuring MSG prototype and call PUTLINE to display        *\n*                                                                     *\n*  INPUT:                                                             *\n*        MSG text                                                     *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - MSG text displayed onto screen                             *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - R15 : as resulted from PUTLINE service processor           *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTPL\nDERCCTPL DS    0D\nL_DELTA_PUTLS  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTPL: CCAT MSG SERVICE'\n         LA    R9,L_DELTA_PUTLS        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy current base register\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n         ni    VALCFLAG,0              clear flag byte         @2019jan\n         B     VALIDATE                perform validation\n                                       SPACE\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DATASET CHAINED-LINKED LIST DISPLAY SERVICE                        *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DDname from F( ) operand       *\n*        of this command based on standard DDN string pattern in      *\n*        MVS system,  try to check if it has been allocated in        *\n*        TIOT.                                                        *\n*        If so, then try to lookup JFCB to search all datasets        *\n*        concatenated with, and build DSN chained list (DSLINK)       *\n*        as a private CONCAT control block                            *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified LIST keyword insted of DSN() or,                   *\n*        LMSG keyword instead of EMSG or NOMSG                        *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DDname string pointer and length in CCATAREA storage       *\n*        - $DDN flag bit in CCATFLAG byte if it is found in TIOT      *\n*        - Jobname (TSO userid) in CCATAREA storage                   *\n*        - Display (PUTLINE) all DSN in DD concatenation using        *\n*          msg CCAT800.                                               *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTLS\nDERCCTLS DS    0D\nL_DELTA_CCTCK  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTLS: CCAT DDN LIST DISPLAY'\n         LA    R9,L_DELTA_CCTCK        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy current base register\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$LIST          remember to process DSN\n         mvi   VALCFLAG,$LIST          remember to process DSN @2019jan\n         B     VALIDATE                perform validation\n                                       SPACE\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DDNAME OPERAND VALIDATOR                                           *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DDname from F( ) operand       *\n*        of this command based on standard DDN string pattern in      *\n*        MVS system,  try to check if it has been allocated in        *\n*        TIOT.                                                        *\n*        If so, then try to lookup JFCB to search all datasets        *\n*        concatenated with, and build DSN chained list (DSLINK)       *\n*        as a private CONCAT control block                            *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified F(DDname) in CONCAT operand                        *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DDname string pointer and length in CCATAREA storage       *\n*        - $DDN flag bit in CCATFLAG byte if it is found in TIOT      *\n*        - Jobname (TSO userid) in CCATAREA storage                   *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTDD\nDERCCTDD DS    0D\nL_DELTA_DDNCK  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTDD: CCAT DDN VALIDATOR'\n         LA    R9,L_DELTA_DDNCK        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy to current base register\n         LR    R2,R1                   copy validity check parm.list\n         L     R10,4(R2)               point to the dynamic work area\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$DDN           remember to process DSN\n         mvi   VALCFLAG,$DDN           remember to process DSN @2019jan\n         OI    CCATFLAG,$DDN           ... also here\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  COMMON LOGIC SERVICE PROCESSOR                                     *\n*                                                                     *\n*        REGISTERS : R0  - UNUSED                                     *\n*                    R1  - CPPL map area                              *\n*                    R2  - PPL map area,                              *\n*                          PDL map area, and then                     *\n*                          DSLINK map area.                           *\n*                    R3  - work register                              *\n*                    R4  - work register                              *\n*                    R5  - work register                              *\n*                    R6  - TIOT map area                              *\n*                    R7  - SWA map area                               *\n*                    R8  - S99 TU Parameter list map area             *\n*                    R9  - Base address of this routine               *\n*                    R10 - Dynamic work area                          *\n*                    R11 - Inner linkage address                      *\n*                    R12 - Main Logic base                            *\n*                    R13 - save area                                  *\n*                    R14 - outer linkage address                      *\n*                    R15 - return code                                *\n*                                                                     *\n*=====================================================================*\n         ENTRY VALIDATE\nVALIDATE DS    0H\n         GETMAIN RU,LV=L_SAVEAREA      obtain dynamic work area\n         USING SAVEAREA,R1\n         ST    R1,8(R13)               save its address\n         ST    R13,B_PTR               save R13\n         LR    R13,R1                  point to obtained area\n         DROP  R1\n         USING SAVEAREA,R13            establish addressability\n         TM    VALCFLAG,$DDN+$DSN+$LIST  is it flagged ?\n         BZ    PUTLINE_SRV             go here no flags\n         TM    VALCFLAG,$LIST          is it flagged ?\n         BO    GET_TIOT                go here no flags\n         XC    RC,RC                   clear RC\n         LM    R1,R3,0(R2)             get PDE address\n         STM   R1,R3,CK_PDE_PLIST      save here\n         TM    VALCFLAG,$DDN           is it DDn processing ?\n         BO    DD_EXEC                 go here if so\n         ST    R2,CKDS_PTR             save validity check pointer\n         L     R2,PDE_PTR              point to PDE address\n         USING PDE_DSN,R2              establish PDE addressing\n         L     R3,DS_PTR               yes, point to DSN field\n         LH    R4,DS_LEN               get it's length\n         TM    DS_FLAG,$PRESENT        any DSN specified ?\n         BO    CK_DS_EXIT              yes, exit\nCK_DS_MISS     DS 0H\n         LA    R15,4                   RC=4 for missing DSN\n         ST    R15,RC                  and save it\nCK_DS_EXIT     DS 0H\n         STM   R3,R4,DSN_PARM\n         DROP  R2\nCK_EXIT  DS    0H\n         LR    R1,R13                  restore savearea address\n         L     R13,B_PTR               point to original savearea\n         FREEMAIN RU,LV=L_SAVEAREA,A=(1)  release savearea\n         L     R15,RC                  restore RC\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BSM   0,R14\nDD_EXEC  DS    0H\n         ST    R2,CKDD_PTR             save validity check pointer\n         L     R2,PDE_PTR              point to PDE address\n         USING PDE_DDN,R2              establish PDE addressing\n         TM    DD_FLAG,$PRESENT        any DSN specified ?\n         BNO   CK_DD_MISS              error if not specified\n         MVC   SAVE_DDN+2(8),BLANK     make blank\n         LH    R5,DD_LEN               get DDname length\n         STH   R5,SAVE_DDN             save length here\n         L     R4,DD_PTR               point to ddname string\n         CH    R5,=H'8'                length > 8 ?\n         BNH   GOT_DDPARM              no, save it\n         LA    R5,8                    yes, make it 8\nGOT_DDPARM     DS 0H\n         STM   R4,R5,DDN_PARM          save DDN from CPPL here\n         BCTR  R5,0                    reduce for EX MVC\n         EX    R5,MVC_DD               copy DDname tring\n         B     GET_TIOT                continue to obtain TIOT\n         DROP  R2\nBLANK    DC    CL8' '                  blank\nMVC_DD   MVC   SAVE_DDN+2(*-*),0(R4)   << executed >>\n                                       SPACE\nGET_TIOT DS    0H\n         USING TIOENTRY,R6             establish addressability\n         LA    R6,TIOT_PTR             point to TIOT pointer\n         EXTRACT (R6),FIELDS=TIOT      access TIOT\n         L     R6,TIOT_PTR             point to TIOT\n         MVC   HEADER(24),0(R6)        save header\n         LA    R14,HEADER              point to header field\n         ST    R14,JOBSPEC             save it here\n         LA    R14,8(R14)              jump over jobname token\n         LA    R15,8                   intialize loop\nJOB_LOOP DS    0H\n         CLI   0(R14),X'40'            is it blank\n         BNE   GOT_JOBNAME             no, its mean upper limit\n         BCTR  R14,1                   previous byte\n         BCT   R15,JOB_LOOP            loop\nGOT_JOBNAME    DS 0H\n         ST    R15,JOBSPEC+4           save the length\n         XR    R15,R15                 clear R15\n         XR    R14,R14                 clear R14 for IC\n         LA    R6,24(R6)               skip header\nTIOT_LOOP DS   0H\n         CLC   SAVE_DDN+2(8),TIOEDDNM  check TIOT DDname 4(R6)\n         BE    DD_FOUND                find, go here\n         IC    R14,TIOELNGH            entry length 0(R6)\n         LA    R6,0(R6,R14)            next DD entry\n         CLC   =F'0',TIOELNGH          end of TIOT ?\n         BNE   TIOT_LOOP               No, loop\n         B     CK_DD_MISS              yes, DDname not found\nDD_FOUND DS    0H\n         USING DSLINK,R2               DSN chain addressability\n         USING SWAEPA,R5               SWA EPA addressability\n         USING INFMJFCB,R7             JFCB addressability\n         XR    R3,R3                   clear counter\n         XR    R14,R14                 clear R14 for IC\n         LA    R2,DSN_CHAIN            point to start DSN chaining\n         B     DD_COPY                 go to copy DSN\nDD_LOOP  DS    0H\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BO    DD_TIOT_CK              yes, skip msg display routine\n         MVC   MSGTEXT(3),DSLDDN+5     move up the sequent number\n         MVC   MSGTEXT+3(5),=CL5' -->'\n         MVC   MSGTEXT+8(44),DSLDSN    dataset name\n         BAS   R14,DISPLAY_DSN         display DSN\nDD_TIOT_CK     DS 0H\n         CLC   =F'0',TIOELNGH          end of TIOT ?\n         BE    DD_FINISH               Yes, finish anyway\n         CLC   BLANK(8),TIOEDDNM       is it DD concatenation member ?\n         BNE   DD_FINISH               No, end of concatenation\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BNO   DD_COPY                 no, skip GETMAIN routine\nDD_STORAGE     DS 0H\n         GETMAIN R,LV=L_DSLINK,LOC=ANY  obtain V.storage\n         ST    R1,DSLNEXT              create chain pointer\n         LR    R2,R1                   save chaining pointer\nDD_COPY  DS    0H\n         LA    R5,EPA                  point to EPA\n         ST    R5,EPA_PTR              save this pointer\n         XC    SWAEPA,SWAEPA           clean EPA area\n         MVC   SWVA,TIOEJFCB           Copy SVA of JFCB into EPA\n         SWAREQ FCODE=RL,EPA=EPA_PTR,MF=(E,SWAPLIST),UNAUTH=YES\n         L     R7,SWBLKPTR             point to JFCB\n         MVC   DSLDSN,JFCBDSNM         get DSN\n         XC    DSLNEXT(8),DSLNEXT      mark end of chain\n         OI    DSLFLAG,$ON             mark eligible to be used\n         LA    R3,1(R3)                add 1 to accumulator\n         CVD   R3,PACKED               convert to packed decimal\n         UNPK  DSLDDN+4(4),PACKED(8)   unpack for EBCDIC\n         OI    DSLDDN+7,X'F0'          turn off decimal sign\n         MVC   DSLDDN(4),=C'CCAT'\n         LA    R4,44                   DSN length\n         LA    R5,DSLDSN               point to DSN string\nDD_CALC  CLI   0(R5),X'40'             is it blank\n         BE    DD_NEXT                 go next DD entry if so\n         LA    R5,1(R5)                next byte\n         BCT   R4,DD_CALC              loop\nDD_NEXT  DS    0H\n         ST    R4,DSLLEN\n         LA    R4,44                   set length max 44\n         S     R4,DSLLEN               calculate correct length\n         ST    R4,DSLLEN               then .... save it\n         XR    R14,R14                 make sure R14 always cleaned\n         IC    R14,TIOELNGH            entry length 0(R6)\n         LA    R6,0(R6,R14)            next DD entry\n         B     DD_LOOP                 loop\nDD_FINISH DS   0H\n         STH   R3,DD_COUNT             save counter\n         B     CK_EXIT                 then exit\nCK_DD_MISS     DS 0H\n         NI    CCATFLAG,X'FF'-$DDN     indicate DDname not found\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BO    CK_EXIT                 yes, exit immediately\n         L     R1,ERRTIOT_PTR          point TIOT msg text\n         MVC   MSGLINE(L'ERRTIOT),0(R1)  put msg here\n         XC    MSGLEN(2),MSGLEN        clear length field\n         OI    MSGLEN+1,L'ERRTIOT+4    specify msg length\n         BAS   R14,DISPLAY             display this msg\n         B     CK_EXIT                 then exit\n         DROP  R2\n         EJECT\n*-------------------------------------*\n*  PUTLINE SERVICE ROUTINE            *\n*-------------------------------------*\nPUTLINE_SRV    DS 0H\n         BAS   R14,PUTLINE\n         B     CK_EXIT\nDISPLAY_DSN    DS 0H\n         XC    MSGLEN(4),MSGLEN        clear PUTLINE buffer spec.\n         MVI   MSGLEN+1,64             msg text length = 60 + 4\n         B     PUTLINE                 process PUTLINE service\nDISPLAY  DS    0H\n         XC    MSGLEN+2(2),MSGLEN+2\nPUTLINE  DS    0H\n         ST    R14,SAVE_PUTL           save R14\n         STM   R2,R4,SAVE_REGS         save work registers\n         L     R2,CPPL_PTR             point to CPPL\n         USING CPPL,R2                 establish addressability\n         L     R3,CPPLUPT\n         L     R4,CPPLECT\n         XC    IOPLADS(20),IOPLADS      clear IOPL\n         PUTLINE PARM=PUTBLOK,ECB=PUTLECB,ECT=(4),UPT=(3),             *\n               OUTPUT=(MSGLEN,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LM    R2,R4,SAVE_REGS         restore work registers\n         L     R14,SAVE_PUTL           restore R14\n         BR    R14                     return\n         DROP  R6,R2,R9,R10,R13\n         EJECT\n                                       SPACE\n*-------------------------------------*\n*  SIMPLE HELP TEXT LIST              *\n*-------------------------------------*\nHELPTAB  DS    0H\n         DC    C'Command Syntax:        +-   -+ +-     -+'\n         DC    C'                       | ON  | | MSG   |'\n         DC    C'  CCAT F(ddn) DS(dsn)  | top | | lmsg  |'\n         DC    C'                       | bot | | emsg  |'\n         DC    C'                       | off | | nomsg |'\n         DC    C'                       +-   -+ +-     -+'\n         DC    C'                                        '\n         DC    C'  Issue HELP CCAT for further hint      '\n         DC    C'                                        '\nHELPTABW DC    C'     Copyright (C) 1991 -  DERU SUDIBYO '\nL_HELPTAB      EQU *-HELPTABW\nHELPTABL EQU   (*-HELPTAB)/L_HELPTAB\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES TEXTS LIST                *\n*-------------------------------------*\nMH000    DC    C'CCAT000 '\nMT000    DC    C' successfully allocated'\nMH001    DC    C'CCAT001 '\nMT001    DC    C' successfully concatenated'\nMH002    DC    C'CCAT002 '\nMT002    DC    C' successfully released'\nMH003    DC    C'CCAT003 DDname '\nMT003    DC    C' already in use'\nMH004    DC    C'CCAT004 '\nMT004    DC    C' unallocatable'\nMH005    DC    C'CCAT005 '\nMT005    DC    C' already concatenated'\nMH006    DC    C'CCAT006 '\nMT006    DC    C' not cataloged'\nMH007    DC    C'CCAT007 '\nMT007    DC    C' reserved by other job'\nMH008    DC    C'CCAT008 DDname '\nMT008    DC    C' is illegal for SVC 99'\nMH009    DC    C'CCAT009 DDname '\nMT009    DC    C' not allocated yet'\nMH010    DC    C'CCAT010 '\nMT010    DC    C' not found'\nMH011    DC    C'CCAT011 DDname '\nMT011    DC    C' not available'\nMH012    DC    C'CCAT012 DDname '\nMT012    DC    C' internally conflict'\nMH013    DC    C'CCAT013 '\nMT013    DC    C' is a private catalog'\nMH014    DC    C'CCAT014 Catalog error, '\nMT014    DC    C' not accessed'\nMH015    DC    C'CCAT015 OBTAIN error, '\nMT015    DC    C' not accessed'\nMH016    DC    C'CCAT016 '                                     @2019jan\nMT016    DC    C' already in the right order'                  @2019jan\n*                                                              @2019jan\nMH900    DC    C'CCAT900 Function failure, S99ERROR='\nMT900    DC    C', call your engineer'\n                                       SPACE\nERRTIOT_PTR    DC A(ERRTIOT)\nERRTIOT  DC    C'CCAT990 No dataset/DDname found in TIOT or JFCB'\nERRKWD   DC    C'CCAT999 SYNTAX ERROR, Operand missing or invalid '\nPUTBLOK  PUTLINE MF=L\nSTORAGE  EQU   L_CCATAREA+L_PPL+L_SAVEAREA+L_PDE_DSN+L_S99RB+512\n         EJECT\n*-------------------------------------*\n*  PARAMETERS CONTROL LIST (PCL)      *\n*-------------------------------------*\nPCL      DS    0H\nPCEDEFS  IKJPARM  DSECT=CCATPDL\nPDLCMD   IKJKEYWD DEFAULT='ON'\n         IKJNAME  'ON'\n         IKJNAME  'TOP'\n         IKJNAME  'BOT'                                        @2019jan\n         IKJNAME  'BOTTOM'                                     @2019jan\n         IKJNAME  'OFF'\nDDNAME   IKJKEYWD\n         IKJNAME  'DD',SUBFLD=DDN,ALIAS=('DDNAME','FILE','F')\nDSNAME   IKJKEYWD DEFAULT='LIST'\n         IKJNAME  'LIST',ALIAS=('LST','MAP')\n         IKJNAME  'DS',SUBFLD=DSN,ALIAS=('DATASET','DSN')\nPDLMSG   IKJKEYWD DEFAULT='MSG'\n         IKJNAME  'MSG'\n         IKJNAME  'NOMSG'\n         IKJNAME  'EMSG'\n         IKJNAME  'LMSG'\nDDN      IKJSUBF\nPDLDDN   IKJIDENT 'DDNAME',                                            *\n               MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,                   *\n               VALIDCK=DERCCTDD,PROMPT='DDname for Concatenation:'\nDSN      IKJSUBF\nPDLDSN   IKJPOSIT DSNAME,                                              *\n               USID,                                                   *\n               VALIDCK=DERCCTDS\n         IKJENDP\nL_PCL    EQU   *-PCL\n         EJECT\n*-------------------------------------*\n*  PARAMETER DISCRIPTOR ENTRY (PDE)   *\n*-------------------------------------*\nPDE_DSN  DSECT\nDS_PTR   DS    F             PTR ==> DATASET NAME\nDS_LEN   DS    H             length of DSN exclude quotes\nDS_FLAG  DS    X             flags byte\nMEM_PTR  DS    F             PTR ==> MEMBER NAME\nMEM_LEN  DS    H             length of MEMBER\nMEM_FLAG DS    X             flags byte\nPWD_PTR  DS    F             PTR ==> PASSWORD\nPWD_LEN  DS    H             length of PASSWORD\nPWD_FLAG DS    X             flags byte\nL_PDE_DSN      EQU *-PDE_DSN\n                                       SPACE\nPDE_DDN  DSECT\nDD_PTR   DS    F             PTR ==> DDNAME\nDD_LEN   DS    H             length of DDNAME\nDD_FLAG  DS    X             flags byte\nL_PDE_DDN      EQU *-PDE_DDN\n         EJECT\n*-----------------------------*\n*  PARSE PARAMETER LIST (PPL) *\n*-----------------------------*\n         IKJPPL\nL_PPL    EQU   *-PPL\n         EJECT\n*------------------------------------------*\n*  COMMAND PROCESSOR PARAMETER LIST (CPPL) *\n*------------------------------------------*\n         IKJCPPL\nL_CPPL   EQU   *-CPPL\n         EJECT\n*-------------------------------------*\n*  SVC 99 PARAMETER AND CONTROL BLOCK *\n*-------------------------------------*\n         IEFZB4D0\n         IEFZB4D2\nL_S99RB  EQU   (S99RBEND-S99RB)\n         EJECT\n*----------------------------------*\n*  DSN_CHAIN LINKED LIST STRUCTURE *\n*----------------------------------*\nDSLINK   DSECT\n* +--4-+----8---+--------------44-----||-----------+-4--+----+\n* |Len |Temp.   | DATASET name                     |NEXT|////|\n* |    |DD name |                                  |PTR |////|\n* +----4--------12--------------------||-----------56---60---64\nDSLLEN   DS    F             DSN string length\nDSLDDN   DS    XL8           assigned temp. DDname\nDSLDSN   DS    XL44          copy DSN string from TIOT\nDSLNEXT  DS    F             pointer to next DSLINK\nDSLFLAG  DS    X             flag\n         DS    XL3           reserved for future used\nL_DSLINK EQU   *-DSLINK\n                                       SPACE\n*-----------------------------*\n*  SAVE/WORK AREA             *\n*-----------------------------*\nSAVEAREA DSECT\n         DS    F             unused\nB_PTR    DS    F             backword pointer\nF_PTR    DS    F             forword pointer\nREG_AREA DS    16F           registers save area\nL_SAVEAREA EQU   *-SAVEAREA  save area length\n*-------------------------------------*\n*  DYNAMIC WORK AREA                  *\n*-------------------------------------*\nCCATAREA DSECT\nCCAT_LEN       DS F          CCAT workarea length\nCCAT_PTR       DS F          PTR ==> CCAT workarea\nSTOR_LEN       DS F          PTR ==> length of getmained AREA\nSTOR_PTR       DS F          PTR ==> STORAGE GETMAIN\nS99P_PTR       DS F          PTR ==> S99RBP\nS99RB_PTR      DS F          PTR ==> S99RB\nSAVE_PTR       DS F          PTR ==> SAVEAREA\nTIOT_PTR       DS F          PTR ==> Task I/O table\nEPA_PTR        DS F          PTR ==> External Parameter Area\nCPPL_PTR       DS F          PTR ==> CPPL\nPPL_PTR        DS F          PTR ==> PPL\nPCL_PTR        DS F          PTR ==> PCL\nPDL_PTR        DS F          PTR ==> PDL\nTUPL_PTR       DS F          PTR ==> TUPLIST\nTU_PTR         DS F          PTR ==> TU\nANSWER_PTR     DS F          PTR ==> USER RESPONSE\nCKDS_PTR       DS F          PTR ==> CKDSNAME ROUTINE\nCKDD_PTR       DS F          PTR ==> CKDDNAME ROUTINE\nIOPLADS        DC 4F'0'      I/O PARM. LIST\nPUTLECB        DS F          ECB for PUTLINE service\nSAVE13         DS F          R13 ROOM\nSAVE14         DS F          R14 ROOM\nSAVE_PUTL      DS F          R14 ROOM\nSAVE_REGS      DS 5F         savearea for work registers\nDSN_PARM       DC A(0,0)     DSN PTR AND LENGTH\nMEM_PARM       DC A(0,0)     MEMBER PTR AND LENGTH\nPWD_PARM       DC A(0,0)     PASSWORD PTR AND LENGTH\nCCATJFCB       DS XL176      JFCB copy area\nSWAPLIST       SWAREQ MF=L   SWA Parameter List\nEPA            DS XL8\nQMPA           DS XL36\nHEADER         DS XL24       TIOT header\nDSN_CHAIN      DS XL(L_DSLINK) 1st DSN chaining linked list record\nPACKED         DS D\nINFO_CODE      DS XL4        copy of S99INFO\nRETURN_CODE    DS XL4        copy of R15\nREASON_CODE    DS XL4        copy of S99ERROR\nSTAT_CODE      DS X          status code                       @2019jan\nSTAT_C_dup     equ x'80'     - DS concat is duplicated         @2019jan\nPROC_CODE      DS X          process code\n               DS XL2        reserved\nSAVE_DDN       DS XL10       saved DDname specification\nTEMP_DDN       DS XL10       temporary DDname specification\nOTHER_DSN      DS XL46       other DSN\nECB            DS F          Event Control Block\nDDN_PARM       DC A(0,0)     DDN PTR AND LENGTH\nDDN_RC         DS F          DDN validity check RC\nRC             DS F          SVC 99 common return code\nIF_CODE        DS H          SVC 99 information code\nRS_CODE        DS H          SVC 99 reason code\nRT_CODE        DS H          SVC 99 error code\nER_CODE        DS H          CCAT error return code\nDD_COUNT       DS H          DD concatenation counter\n                                       SPACE\n*-----------------------------------*\n*  COMMAND/OPERAND FLAGS            *\n*-----------------------------------*\nCOMMAND  DS    X             SUBCOMMAND\n$ON      EQU   X'80'         allocate/concatenate bit\n$TOP     EQU   X'40'         force to reallocate existing DSN\n$BOT     EQU   X'20'         reallocate existing DS to bottom  @2019jan\n$done    EQU   X'10'         DS has complied as requested      @2019jan\n$EMSG    EQU   X'08'         requested to display ERROR response\n$MSG     EQU   X'04'         .................... INFO  ........\n$NOMSG   EQU   X'02'         no msg will be prompted, just RC\n$LIST    EQU   X'01'         request to display concatenation\n                                       SPACE\n*-----------------------------------*\n*  VALIDATION FLAGS                 *\n*-----------------------------------*\nVALCFLAG DS    X             VALCFLAG\n$DSN     EQU   X'10'         validate DSN\n$DDN     EQU   X'20'         validate DDN\n$QUOTE   EQU   X'40'         1.  DS is enclose in quotes\n$PRESENT EQU   X'80'         2.  DS is present\n                                       SPACE\n*-----------------------------------*\n*  PROCESSING FLAGS                 *\n*-----------------------------------*\nCCATFLAG DS    X             CCAT processing error flag\n$NEW     EQU   X'80'         DDname is new at this time\n$ERRS99  EQU   X'40'         general SVC 99 error\n$ERRCVRY EQU   X'01'         error allocation recovery\n$ERRALC  EQU   X'02'         error allocation\n$ERRCON  EQU   X'04'         error concatenantion\n$ERRUNL  EQU   X'08'         error unallocation\n$ERRKWD  EQU   $ERRALC+$ERRCON+$ERRUNL\n                                       SPACE\n*-----------------------------------*\n*  ALLOCATION TEXT UNIT PLIST       *\n*-----------------------------------*\nALLOC_TUPLIST  DS  0F\nALLOC_DSN      DS F          PTR ==> Dataset name TU\nALLOC_TUPLIST_RETRY EQU *\nALLOC_DDN      DS F          PTR ==> DDname TU\nALLOC_STS      DS F          PTR ==> STATUS TU\nALLOC_ATR      DS F          PTR ==> ATTRIBUTE TU\nL_ALLOC_TUPLIST_RETRY EQU  *-ALLOC_TUPLIST_RETRY\nL_ALLOC_TUPLIST EQU  *-ALLOC_TUPLIST\nL_ALLOC_PERM    EQU  L_ALLOC_TUPLIST-4  TUPL limit for perm alloc\nL_ALLOC_TEMP    EQU  L_ALLOC_TUPLIST-8  TUPL limit for temp alloc\n                                       SPACE\n*-----------------------------------*\n*  INFO_RETRIEVAL TEXT UNIT PLIST   *\n*-----------------------------------*\nQRY_TUPLIST    DS 0F\nQRY_DDN  DS    F             PTR ==> DDname TU\nQRY_ATR  DS    F             PTR ==> ATTRibute TU\nQRY_DSN  DS    F             PTR ==> DSname TU\nL_QRY_TUPLIST EQU   *-QRY_TUPLIST\n*--- possible bits configuration of QRY_ATR ---------\n$SHR     EQU   X'08'         DSN share attribute\n$PRMCONC EQU   X'80'         permanently concatenanted\n$BUSY    EQU   X'40'         in use\n$PRMALLC EQU   X'20'         permanently allocated\n$DYNALLC EQU   X'10'         dynamically allocated\n                                       SPACE\n*-----------------------------------*\n*  DEALLOCATION TEXT UNIT PLIST     *\n*-----------------------------------*\nRELSE_TUPLIST DS 0F\nRELSE_DDN DS   F             PTR ==> DDname TU\nRELSE_ATR DS   F             PTR ==> attribute TU\nRELSE_DSN DS   F             PTR ==> Dataset name TU\nL_RELSE_TUPLIST EQU *-RELSE_TUPLIST\nL_RELSE_ALL    EQU L_RELSE_TUPLIST-8\nL_RELSE_ONE    EQU L_RELSE_TUPLIST-4\n                                       SPACE\n*-----------------------------------*\n*  CONCATENATION TEXT UNIT PLIST    *\n*-----------------------------------*\nCONCT_TUPLIST  DS 0F         PTR ==> concatenation TU\nCONCT_DDN      DS F\nCONCT_ATR      DS F\nL_CONCT_TUPLIST EQU *-CONCT_TUPLIST\n                                       SPACE\n*-----------------------------------*\n*  DECONCATENATION TEXT UNIT PLIST  *\n*-----------------------------------*\nDECON_TUPLIST  DS F          PTR ==> concatenation TU\n                                       SPACE\nDSTU_PTR DS    F             PTR ==> DSN TEXT UNIT\nDDTU_PTR DS    F             PTR ==> DDNAME TEXT UNIT\n                                       SPACE\n*-------------------------------------*\n*  VALIDITY CHECK PARAMETER LIST      *\n*-------------------------------------*\nCK_PDE_PLIST   DS 0F\nPDE_PTR  DS    F             PTR ==> PDE\nUSERWORD DS    F             PTR ==> workarea we gave to parse\nCK_MSG   DS    F             PTR ==> 2nd level msg we can give back\n                                       SPACE\n*-------------------------------------*\n*  MESSAGE TEXT AND POINTER           *\n*-------------------------------------*\nJOBSPEC  DC    A(0,0)        PTR and length  jobid in TIOT\nMSGPARM  DC    A(0,0)        PTR and length of string for substitution\nMSGSKEL  DS    XL12          PTRs and lengths of msg text skeleton\n*-------------------------------------*\n*  MESSAGES SKELETON  CONTROL BLOCK   *\n*-------------------------------------*\n         ORG   MSGSKEL\nSKLHDR   DS    XL4           msg header pointer\nSKLTXT   DS    XL4           msg trailer text pointer\nSKLHDRL  DS    XL2           msg header length\nSKLTXTL  DS    XL2           msg trailer text length\n         ORG\nMSGID    DS    H             msg count ID\nMSGLEN   DC    H'164'\n         DC    H'0'\nMSGLINE  DC    CL160'Data ...//... allocated as a new file ..'\n         ORG   MSGLINE\nMSGHDR   DS    XL8           MSG HEADER AREA\nMSGTEXT  DS    XL152         MSG TEXT AREA\n         ORG\nL_MSG    EQU   *-MSGLEN\nRC_TEXT  DC    C', RC=0000.' RC for msg line\n         ORG   RC_TEXT+5\nRC_MSG   DC    C'0000'       printable RC value\n         ORG\nL_CCATAREA     EQU *-CCATAREA\n          EJECT\n*-------------------------------------*\n*  MVS/ESA systems control blocks     *\n*            and data areas           *\n*-------------------------------------*\nCVTMAP   CVT   DSECT=YES     CVT mapping needed by CALLTSSR\n         IEFJESCT            JES control table\n         IEFZB505\n         IEFQMNGR\n         IEFTIOT1            TIOT\n         IEFJFCBN            JFCB\nL_CVT    EQU   *-CVTMAP\n         YREGS\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES DIRECTORY CONTROL BLOCK   *\n*-------------------------------------*\nMSGBLOK  DSECT\nMSGCODE  DS    XL2           ERROR information code\nMSGFLAG  DS    X             flag bits\n         DS    X             reserved\nMSGSKLA  DS    XL2           relative text skeleton address\nMSGBLOKL EQU   *-MSGBLOK\n                                       SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DERCCT": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x001\\x01\\x19\\x01o\\x01\\x19\\x02\\x7f\\x195\\x07\\xb1\\x07H\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-01-16T00:00:00", "modifydate": "2019-01-27T19:35:31", "lines": 1969, "newlines": 1864, "modlines": 0, "user": "DERU"}, "text": "***********************************************************************\n*                                                                     *\n*        NAME:    CCAT    -  TSO COMMAND                              *\n*                            FOR DYNAMIC DATASET CONCATENATION        *\n*                            AND ALLOCATION                           *\n*                                                                     *\n* --------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*        PURPOSE: Dynamic allocate/deallocate a dataset into a        *\n*                 new DDname, or concatenate/deconcatenate a          *\n*                 dataset into the top of existing concatenation.     *\n*                                                                     *\n*                 CCAT doesn't applicable for dataset being           *\n*                 opened, uncataloged or cataloged in private         *\n*                 catalog.      Disposition assigned by CCAT          *\n*                 always SHAREd.                                      *\n*                                                                     *\n*        INPUT:   specified operands                                  *\n*                                                                     *\n*        OUTPUT:  Informational messages, or error messages and       *\n*                 a return code.                                      *\n*                                                                     *\n*        SYNTAX:                                                      *\n*                                                                     *\n*        (1)   Perform allocation/deallocation:                       *\n*                                               +-   -+ +-     -+     *\n*              CCAT  F(ddname) DS(datasetname)  | ON  | | MSG   |     *\n*                                               |     | |       |     *\n*                                               | top | | nomsg |     *\n*                                               |     | |       |     *\n*                                               | bot | | emsg  |     *\n*                                               |     | |       |     *\n*                                               | off | | lmsg  |     *\n*                                               +-   -+ +-     -+     *\n*                                                                     *\n*             Option 1.    ON    -   Allocate/concatenate the         *\n*                                    specified DSname/DDname.  If     *\n*                                    the DDname is already exist,     *\n*                                    dataset will be concatenated     *\n*                                    on the top of concatenation.     *\n*                                                                     *\n*                          TOP   -   Force to concatenate a dataset   *\n*                                    to the top order of existing     *\n*                                    concatenation.  If specified     *\n*                                    dataset is newly added, this     *\n*                                    option is default.               *\n*                                                                     *\n*                          BOT   -   Force to concatenate a dataset   *\n*                                    to the bottom order of existing  *\n*                                    concatenation.                   *\n*                                                                     *\n*                          OFF   -   Deallocate/deconcatenate the     *\n*                                    specified DSname/DDname.         *\n*                                                                     *\n*                                                                     *\n*             Option 2.    MSG   -   Display simple message (default) *\n*                                                                     *\n*                          NOMSG -   No messages will be displayed    *\n*                                    upon completion.                 *\n*                                                                     *\n*                          EMSG  -   Display error messages only.     *\n*                                                                     *\n*                          LMSG  -   Display complete messages        *\n*                                    (completion message and the      *\n*                                    new concatenation list.          *\n*                                                                     *\n*        (2)   Display current specified DDname concatenation list:   *\n*                                                                     *\n*              CCAT  F(ddname)                                        *\n*                                                                     *\n*                                                                     *\n*        ENTRYPOINTS: DERCCT   - Main Logic Processor                 *\n*                     DERCCTDS - Dataset name Validity Check Routine  *\n*                     DERCCTDD - DDNAME Validity Check Routine        *\n*                     DERCCTLS - Concatenation list service routine   *\n*                     DERCCTPL - PUTLINE/Messages service routine     *\n*                                                                     *\n*        CONTROL BLOCKS: CPPL    -  Command Processor Parameter List  *\n*                        JFCB    -  Job File Control Block            *\n*                        PPL     -  Parse Parameter List              *\n*                        PCL     -  Parameter Control List            *\n*                        PCE     -  Parameter Control Entry           *\n*                        PDL     -  Parameter Descriptor List         *\n*                        PDE     -  Parameter Descriptor Entry        *\n*                        SWA     -  Scheduler Work Area               *\n*                        S99RB   -  Dynamic allocation control block  *\n*                        TIOT    -  Task I/O Table                    *\n*                                                                     *\n*                                                                     *\n*        RETURN CODES:                                                *\n*                    0   - SUCCESSFULL                                *\n*                    4   - Request wasn't performed, because,         *\n*                          dataset already allocated (ON), or         *\n*                          dataset has not allocated yet (OFF).       *\n*                    8   - Request was performed, but didn't          *\n*                          effective, RC=4 returned by SVC 99.        *\n*                          Current concatenation didn't changed.      *\n*                   12   - Request was failed, SVC 99 produce         *\n*                          RC=8.   Current specified DDname           *\n*                          concatenation was not changed.             *\n*                   16   - Request was failed, SVC 99 produce         *\n*                          RC=12.   Current specified DDname          *\n*                          concatenation was not garenteed.           *\n*                   20   - Request was failed, SVC 99 produce         *\n*                          RC=16.   Current specified DDname          *\n*                          concatenation was unpredictable.           *\n*                   24   - Syntax error.   Operand missing or         *\n*                          invalid.   Request wasn't performed        *\n*                          and the plane and command finished.        *\n*                                                                     *\n*                                                                     *\n*      MESSAGES:                                                      *\n*                                                                     *\n*   CCAT000 XXXXX.YYYY.ZZZZZ successfully allocated.                  *\n*   CCAT001 XXXXX.YYYY.ZZZZZ successfully concatenated.               *\n*   CCAT002 XXXXX.YYYY.ZZZZZ successfully released.                   *\n*   CCAT003 DDname DDDDDDDD already in use.                           *\n*   CCAT004 XXXXX.YYYY.ZZZZZ unallocatable.                           *\n*   CCAT005 XXXXX.YYYY.ZZZZZ already allocated.                       *\n*   CCAT006 XXXXX.YYYY.ZZZZZ not cataloged.                           *\n*   CCAT007 XXXXX.YYYY.ZZZZZ reserved by other job.                   *\n*   CCAT008 DDname DDDDDDDD is illegal for SVC 99.                    *\n*   CCAT009 DDname DDDDDDDD not allocated yet.                        *\n*   CCAT010 XXXXX.YYYY.ZZZZZ not allocated yet                        *\n*   CCAT011 DDname DDDDDDDD not available.                            *\n*   CCAT012 DDname DDDDDDDD internally conflict.                      *\n*   CCAT013 XXXXX.YYYY.ZZZZZ is a private catalog.                    *\n*   CCAT014 Catalog error, XXXXX.YYYY.ZZZZZ not accessed              *\n*   CCAT015 OBTAIN error, XXXXX.YYYY.ZZZZZ not accessed               *\n*   CCAT800 DD(ddname) concatenation:                                 *\n*           001 ---> DATA.SET                                         *\n*           002 ---> MY.DATA.LIBRARY                                  *\n*                    :                                                *\n*           nnn ---> APPL.USER.DATA                                   *\n*   CCAT900 Function failure, S99ERROR=nnnnn-P, contact your engineer.*\n*   CCAT990 No dataset/DDname found in TIOT or JFCB                   *\n*   CCAT999 SYNTAX ERROR, Operand missing or invalid                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        AUTHOR AND COPYRIGHT                                         *\n*                                                                     *\n*        AUTHOR:     Ir. DERU SUDIBYO                                 *\n*                    Sr. Systems Designer                             *\n*                    PT. SDD/BNI-1946 INDONESIA                       *\n*                                                                     *\n*        COPYRIGHT:  (C) 1991  DERU SUDIBYO                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*                                                                     *\n*  MODIFICATION LOG                                                   *\n*  -----------------------------------------------------------------  *\n*  No.  DATE     ENGINEER       V.R.L   DESCRIPTION                   *\n*  -----------------------------------------------------------------  *\n*   1  01/14/91  Deru Sudibyo   1.0.0   1st development               *\n*   2  01/18/91  Deru Sudibyo   1.0.1   Add LIST function             *\n*   3  01/31/91  Deru Sudibyo   1.0.2   Makeup messages and operands  *\n*   4  02/22/91  Stephen Davies 1.0.3   Correct bugs in LIST function *\n*   5  04/06/91  Deru Sudibyo   1.1.0   Declare release VRL 1.1.0     *\n*                                       and install in production     *\n*   6  01/17/19  Deru Sudibyo   1.1.1   Add BOT (bottom) operand to   *\n*                                       force a dataset move into the *\n*                                       bottom of concatenation.      *\n*                                                                     *\n***********************************************************************\nDERCCAT  TITLE  'DYNAMIC ALLOC/CONCATE UTILITY'\n*=====================================================================*\n*  MAIN LOGIC PROCESSOR                                               *\n*                                                                     *\n*        REGISTERS : R0  - UNUSED                                     *\n*                    R1  - CPPL map area                              *\n*                    R2  - PPL map area,                              *\n*                          PDL map area, and then                     *\n*                          DSLINK map area.                           *\n*                    R3  - work register                              *\n*                    R4  - work register                              *\n*                    R5  - work register                              *\n*                    R6  - S99RBP parameter block map area            *\n*                    R7  - S99TUNIT, Text unit map area               *\n*                    R8  - S99 TU Parameter list map area             *\n*                    R9  - S99RB SVC 99 request block                 *\n*                    R10 - Dynamic work area                          *\n*                    R11 - Inner linkage address                      *\n*                    R12 - Main Logic base                            *\n*                    R13 - save area                                  *\n*                    R14 - outer linkage address                      *\n*                    R15 - return code                                *\n*                                                                     *\n*=====================================================================*\nDERCCT   CSECT\nDERCCT   AMODE 31\nDERCCT   RMODE ANY\n         ENTRY CCT\nCCT      DS    0H\n         SAVE  (14,12),,'DERCCT - CCAT/TSO/E - &SYSDATE - &SYSTIME'\n         LR    R12,R15                 get base address\n         USING DERCCT,R12              ESTABLISH addressability\n         LR    R2,R1                   save PLIST address\n         GETMAIN R,LV=STORAGE          obtain dynamic workarea\n         LA    R10,L_SAVEAREA+8(R1)    past end of S99RBP and SAVEAREA\n         USING CCATAREA,R10            CCAT area addressability\n         STM   R0,R1,STOR_LEN          save storage specification\n         ST    R1,S99P_PTR             save S99RBP pointer\n         LA    R1,8(R1)                point to our savearea\n         ST    R1,SAVE_PTR             and save here\n         USING SAVEAREA,R1             savearea map\n         ST    R1,8(R13)               save its address\n         ST    R13,B_PTR\n         LR    R13,R1\n*2019jan XC    CCATFLAG,CCATFLAG       clean all flag bits\n         ni    CCATFLAG,0              clean all flag bits     @2019jan\n         DROP  R1\n         USING SAVEAREA,R13\n         LR    R1,R2\n         ST    R1,CPPL_PTR             save CPPL pointer\n         XC    RC,RC                   clear return code\n         USING CPPL,R1                 establish CPPL addressability\n         LA    R2,L_CCATAREA(R10)      past end CCAT DATA area\n         ST    R2,PPL_PTR              save PPL pointer\n         USING PPL,R2                  establish PPL addressability\n         MVC   PPLUPT,CPPLUPT          save CPPL UPT address in PPL\n         MVC   PPLECT,CPPLECT          ...also for ECT\n         MVC   PPLCBUF,CPPLCBUF        ...and CPPL command buffer\n         LA    R1,L_CCATAREA\n         ST    R1,CCAT_LEN\n         ST    R10,PPLUWA              and passed to VALIDCK routine\n         ST    R10,CCAT_PTR            and also save here\n         DROP  R1\n         LA    R1,L_PPL(R2)            pass end PPL area\n         ST    R1,ANSWER_PTR           save as answer pointer\n         ST    R1,PPLANS               and also saved in PPL\n         LA    R9,4(R1)                leave 1 fword\n         ST    R9,S99RB_PTR            save as RB pointer\n         L     R1,PCEADCON             point to PCE definition\n         ST    R1,PCL_PTR              save PCL pointer\n         ST    R1,PPLPCL               save as PCL poi\n         XC    ECB,ECB                 clear ECB\n         LA    R1,ECB                  point to ECB\n         ST    R1,PPLECB               save in PPL area\n         MVI   PROC_CODE,C'R'          process code\n         MVC   REASON_CODE(4),=C'0000'\n         CALLTSSR EP=IKJPARS,MF=(E,PPL) invoke PARSE routine\n         LTR   R15,R15                 generate CC\n         BNZ   ERROR_KWD               cleanup and exit if error\nPROCESS  DS    0H\n         L     R3,PPLANS               point to PCL\n         DROP  R2\n         L     R2,0(R3)                point to PDL\n         LH    R3,6(R2)                get PDL length\n         USING CCATPDL,R2              setup PCL addressability\n         L     R9,S99RB_PTR            save as RB pointer\n         LA    R8,L_S99RB(R9)          past end RB area\n         ST    R8,TUPL_PTR             save as TUPList pointer\n         LA    R7,32(R8)               skip 8 fullwords\n         ST    R7,DDTU_PTR             save as DD TU pointer\n         USING S99RBP,R6               SVC 99 RB pointer map\n         USING S99TUNIT,R7             TEXT UNIT addresability\n         USING S99TUPL,R8              TEXT UNIT PLIST map\n         USING S99RB,R9                SVC 99 RB addressability\n         L     R6,S99P_PTR             point to RBP\n         ST    R9,S99RBPTR             store pointer of S99RB\n         OI    S99RBPTR,S99RBPND       specify 31 bit addressing\n         LA    R7,14(R7)               past end DD TU\n         ST    R7,DSTU_PTR             save as DS TU\n         LA    R7,50(R7)               long jumping pass DS TU\n         ST    R7,TU_PTR               save as general purpose TU\n         DROP  R6                      not use anymore\n         EJECT\nGETSCMD  DS    0H\n         XC    MSGPARM(8),MSGPARM      clean all msg parameters\n         XC    MSGSKEL(12),MSGSKEL     clean all msg skeletons\n*2019jan XC    COMMAND,COMMAND         clear SUB COMMAND\n         ni    COMMAND,0               clear SUB COMMAND       @2019jan\n         XC    ER_CODE,ER_CODE         clear error code\n         LH    R3,PDLCMD               get subcommand keyword\n         BCTR  R3,0                    reduce 1\n         SLL   R3,3                    multiply 8\n         B     *+4(R3)                 select the following paths\n         OI    COMMAND,$ON             indicate subcmd 'ON'\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$TOP        indicate subcmd 'TOP'\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$BOT        indicate subcmd 'BOT'   @2019jan\n         B     GETDSN                  continue to get DSN\n         OI    COMMAND,$ON+$BOT        indicate subcmd 'BOT'   @2019jan\n         B     GETDSN                  continue to get DSN\n                                       SPACE\nGETDSN   DS    0H\n         CLC   DSNAME(2),=H'1'         1=LIST  isn't it ?\n         BNE   GETDSN_GO               No, skip it\n*2019jan NI    COMMAND,0               clean all flag bits\n*2019jan OI    COMMAND,$LIST           indicate display CONCAT list\n         mvi   COMMAND,$LIST           indicate display CONCAT @2019jan\n         B     GETDDN                  then jump to process DDname\nGETDSN_GO      DS 0H\n         L     R7,DSTU_PTR             point to DS text unit\n         LM    R3,R4,DSN_PARM          get DSN address and pointer\n         MVC   S99TUNUM(2),=X'0001'       always 1\n         STH   R4,S99TULNG             put DSN length in text unit\n         BCTR  R4,0                    -1\n         EX    R4,MVCDSN               copy DSN into TU\n                                       SPACE\nGETDDN   DS    0H\n         CLC   DDNAME,=H'0'            is DDN spacified ?\n         BNH   ERROR_KWD               No, error\n         L     R7,DDTU_PTR             point to DD text unit\n         MVC   S99TUNUM(2),=X'0001'       always 1\n         LM    R3,R4,DDN_PARM          access specified DDname\n         STH   R4,S99TULNG             put length here\n         MVC   S99TUPAR(8),0(R3)       enter SVC 99 parameter\nGETMSG   DS    0H\n         TM    COMMAND,$LIST           does CONCAT list only ?\n         BO    CLEANUP                 go here if so\n         LH    R3,PDLMSG               get msg sign\n         BCTR  R3,0                    minus 1\n         SLL   R3,3                    multiply 8\n         B     *+4(R3)                 pass thru selected path\n         OI    COMMAND,$MSG            indicate full msg\n         B     EXECUTE                 go execute\n         OI    COMMAND,$NOMSG          indicate no msg\n         B     EXECUTE                 go execute\n         OI    COMMAND,$EMSG           indicate error msg only\n         B     EXECUTE                 go execute\n         OI    COMMAND,$LIST           indicate display CONCAT list\n                                       SPACE\nEXECUTE  DS    0H\n         TM    COMMAND,$ON             request = alloc ?\n         BO    ACCESS                  YES, perform it\n         B     RELEASE                 otherwise, deallocate\nMVCDSN   MVC   S99TUPAR(*-*),0(R3)       << EXECUTED >>\n         DROP  R2\n         EJECT\n*---------------------------------------------*\n* DSNAME/DDNAME ALLOCATION/CONCATENATION      *\n*---------------------------------------------*\n* Logic flow:                                 *\n* 1.  Check info using specified DDNAME       *\n* 2.  If it has already allocated on the      *\n*     top of concatenation, then ignore       *\n*     request.                                *\n*     Otherwise, DEALLOCATE entire concate-   *\n*     nation, then ALLOCATE the specified     *\n*     dataset name, so concatenate all of the *\n*     previous concatenation members as well. *\n* 3.  Check the result.   If it was not       *\n*     accepted, the turn back to previous     *\n*     condition as best it can.               *\n* 4.  Return to TSO and produce return code.  *\n*---------------------------------------------*\n         USING DSLINK,R2               DSN_Chained list addressability\n                                       SPACE\nACCESS   DS    0H\n         BAS   R14,SETALLOC            prepare SVC 99 PLIST\n         BNZ   ACCESS_NEW              suppose has not allocated yet\n         TM    CCATFLAG,$DDN           has ddname found in TIOT\n         BNO   ACCESS_NEW              no, process as new allocation\n         MVC   MSGSKEL(12),MSG_ALRDY   msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,LOOKUP_DSN          look up in Chained JFCB\n         bnz   ACCESS_CONCAT           this way if none        @2019jan\n         TM    CCATFLAG,$DSN           has it allocated ?\n         BNO   ACCESS_CONCAT           no, continue to add it\n         tm    COMMAND,$done           complied the request?   @2019jan\n         bo    In_good_order           yes, just ignore it     @2019jan\n*2019jan TM    COMMAND,$TOP            is it forced to be moved up ?\n         tm    COMMAND,$TOP+$BOT       to be moved up/down?    @2019jan\n*2019jan BNO   IGNORE_ON               NO, don't process it\n         bz    IGNORE_ON               NO, just ignore it      @2019jan\n         mvc   MSGSKEL(12),MSG_DDBUSY  msg skeleton            @2019jan\n         mvc   MSGPARM(8),DDN_PARM     use DDn for msg         @2019jan\n         bas   R14,DEALLOC_ALL         no, deallocate all      @2019jan\n         bnz   CANCEL_ON               break if error          @2019jan\n         tm    COMMAND,$top            to be moved to the top? @2019jan\n         bo    REALLOC_ON              yes, take this way      @2019jan\n         b     REALLOC_bot             no, take this new way   @2019jan\nACCESS_CONCAT  DS 0H\n*2019jan MVC   MSGSKEL(12),MSG_DDBUSY  msg skeleton\n*2019jan MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         tm    COMMAND,$BOT            to be moved down?       @2019jan\n         bo    ACCESS_CONCAT_bot       yes, take this way      @2019jan\n         BAS   R14,DEALLOC_ALL         deallocate all concatenation\n         BNZ   CANCEL_ON               break if error\n         B     REALLOC_ON              assume no allocated dataset\nACCESS_CONCAT_bot equ *                                        @2019jan\n         la    R2,DSN_CHAIN            point to start of chain @2019jan\n         bas   R14,SETCONCT            set concatenation PLIST @2019jan\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R6,DSTU_PTR             point to general DSN TU\n         MVC   S99TULNG(46),4(R6)      return to original value\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         b     REALLOC_DD              continue this way\nACCESS_NEW     DS 0H\n         OI    CCATFLAG,$NEW           indicate new DDname\n         MVC   MSGSKEL(12),MSG_DSWRONG msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,ALLOC_PERM          just allocate it\n         BNZ   ERROR                   break if error\n         OI    CCATFLAG,$DDN           it is allocated I guess !\n         B     FINISH                  then job finished\nCLC_DSN  CLC   S99TUPAR(*-*),0(R3)     << EXECUTED >>\n         EJECT\n*---------------------------------------------*\n* DSNAME/DDNAME DEALLOCATION/DECONCATENATION  *\n*---------------------------------------------*\n* Logic flow:                                 *\n* 1.  Check info using specified DDNAME       *\n*     for existences of both specified DD     *\n*     and DS names.                           *\n* 2.  If both are not any, ignore request     *\n*     Else, DEALLOCATE entire concatenation   *\n*     members, then REALLOCATE one of them    *\n*     so concatenate all of others as well    *\n*     except specified dataset name that      *\n*     requested to be deallocated.            *\n* 3.  Check the result.  If it was unexpected,*\n*     back to old condition as best it can.   *\n* 4.  Return to TSO and produce returncode.   *\n*---------------------------------------------*\n                                       SPACE\nRELEASE  DS    0H\n         MVC   MSGSKEL(12),MSG_DDMISS  msg skeleton\n         MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         TM    CCATFLAG,$DDN           has ddname found in TIOT\n         BNO   IGNORE_OFF              no, ignore\n         BAS   R14,SETALLOC            setup TU and check\n         BNZ   IGNORE_OFF              no, ignore it\n         MVC   MSGSKEL(12),MSG_DSMISS  msg skeleton\n         MVC   MSGPARM(8),DSN_PARM     use DSn for msg\n         BAS   R14,LOOKUP_DSN          look up in Chained JFCB\n         TM    CCATFLAG,$DSN           has DSN allocated ?\n         BNO   IGNORE_OFF              no, ignore it\n         st    R2,SAVE_REGS            save top of ptr chain   @2019jan\n         MVC   MSGSKEL(12),MSG_DDBUSY  msg skeleton\n         MVC   MSGPARM(8),DDN_PARM     use DDn for msg\n         BAS   R14,DEALLOC_ALL         otherwise, deallocate all\n         BNZ   CANCEL_OFF              break if error\n         CLC   DD_COUNT,=H'1'          single allocation ?\n         BH    REALLOC_OFF             no, reallocate all others\n         LA    R2,DSN_CHAIN            point to start of chain\n         OI    DSLFLAG,$ERRALC         it is unallocable anymore\n         NI    DSLFLAG,X'FF'-$ON       turn off eligible bit\n         B     FINISH                  then finish\n         EJECT\n*---------------------------------------------*\n* SELECTIVE REALLOCATION AFTER ALLOC/DEALLOC  *\n*---------------------------------------------*\n                                       SPACE\nREALLOC  DS    0H\nREALLOC_OFF    EQU *\n*2019jan L     R2,SAVE_REGS            restore top of chain pointer\n*2019jan LTR   R2,R2                   check chained address\n         icm   R2,15,SAVE_REGS         restore top of chain    @2019jan\n         BZ    FINISH                  finish if no more\n         L     R7,ALLOC_DSN            point to alloc DSN TU\n         MVC   S99TULNG(2),DSLLEN+2    copy its length\n         MVC   S99TUPAR(44),DSLDSN     copy its string\n         OI    DSLFLAG,$ERRCON         and sign as unconcatable\n         B     REALLOC_ALL             go to reallocate it\nREALLOC_bot    DS 0H\n         st    R2,SAVE_REGS            save top of ptr chain   @2019jan\n         LA    R2,DSN_CHAIN            point to start of chain @2019jan\n*        b     REALLOC_bot_fwd         jump to this way        @2019jan\nREALLOC_bot_seek equ *                                         @2019jan\n         L     R7,DSTU_PTR             point to general DS TU  @2019jan\n         TM    DSLFLAG,$ERRALC+$ERRCON is it reallocable ?     @2019jan\n         BZ    REALLOC_bot_go          use if valid            @2019jan\nREALLOC_bot_fwd equ *                                          @2019jan\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bnz   REALLOC_bot_seek        iterate                 @2019jan\n         l     R2,SAVE_REGS            restore top of chain    @2019jan\n         b     ACCESS_NEW              treat as single alloc   @2019jan\nREALLOC_bot_go equ *                                           @2019jan\n         oi    COMMAND,$done           borrow this 4 indicator @2019jan\n         ni    COMMAND,255-$bot        turn this bit off       @2019jan\n         L     R7,ALLOC_DSN            point to DSN TU         @2019jan\n         L     R3,DSLLEN               get its length          @2019jan\n         STH   R3,S99TULNG             store to TU             @2019jan\n         MVC   S99TUPAR(44),DSLDSN     ...also DSN             @2019jan\n         BAS   R14,ALLOC_PERM          subcommand = ON         @2019jan\n         BZ    *+8                     go after done           @2019jan\n         OI    CCATFLAG,$ON            remember it is pending  @2019jan\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bz    REALLOC_next_check      this way if no more     @2019jan\n         b     REALLOC_PERM_DONE+4     else, process it        @2019jan\nREALLOC_ON     equ *\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R6,DSTU_PTR             point to general DSN TU\n         MVC   S99TULNG(46),4(R6)      return to original value\nREALLOC_ALL    equ *\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg\n         BAS   R14,ALLOC_PERM          subcommand = ON\n         BZ    REALLOC_PERM_DONE       go after done\n         OI    CCATFLAG,$ON            remember it is pending\nREALLOC_PERM_DONE equ *\n         LA    R2,DSN_CHAIN            point to start of chain\n         BAS   R14,SETCONCT            setup concatenation PLIST\nREALLOC_LOOP   equ *\n         L     R7,DSTU_PTR             point to general DS TU\n         TM    DSLFLAG,$ERRALC+$ERRCON is it reallocable ?\n         BZ    REALLOC_OKEY            use if valid\nREALLOC_CHEK   equ *\n         TM    DSLFLAG,$ERRCON         is it just unreconcatable ?\n         BO    REALLOC_NEXT            skip if so\n         NI    DSLFLAG,X'FF'-$ON       turn off eligible bit\n         B     REALLOC_NEXT            then skip it\nREALLOC_OKEY   equ *\n         L     R7,ALLOC_DSN            point to DSN TU\n         L     R3,DSLLEN               get its length\n         STH   R3,S99TULNG             store to TU\n         MVC   S99TUPAR(44),DSLDSN     ...also DSN\n         TM    CCATFLAG,$ON            is perm allocation pending ?\n         BO    REALLOC_PERM_AGAIN      reallocate an other permanently\nREALLOC_DD     equ *                                           @2019jan\n         L     R7,ALLOC_DDN            point to DDN TU\n         MVI   S99TULNG+1,8            length all = 8\n         MVC   S99TUPAR(8),DSLDDN      use temp. DDN\n         BAS   R14,ALLOC_TEMP          allocate for temporary\n         BNZ   REALLOC_CHEK            sign check bit\n         L     R7,CONCT_DDN            point to DDN TU\n         LH    R3,S99TULNG             get PARM length\n         LA    R3,S99TUPAR(R3)         pass over PARM string\n         MVC   0(2,R3),=X'0008'        length = 8\n         MVC   2(8,R3),DSLDDN          assign Temp DDN as source\n         BAS   R14,CONCATE             reconcatenate all old concate-\n         BNZ   REALLOC_CHEK            sign check bit\nREALLOC_NEXT   equ *\n         tm    COMMAND,$BOT            to be moved down?       @2019jan\n         bo    FINISH                  yes, just leave it      @2019jan\n*2019jan L     R2,DSLNEXT              get next DSLINK\n*2019jan LTR   R2,R2                   check for end of entry\n*2019jan BZ    FINISH                  finish if 0\n*2019jan BCT   R11,REALLOC_LOOP        otherwise, loop\n         icm   R2,15,DSLNEXT           get next DSLINK         @2019jan\n         bnz   REALLOC_LOOP            iterate for all         @2019jan\nREALLOC_next_check equ *                                       @2019jan\n         tm    COMMAND,$done           concate at the bottom?  @2019jan\n         bno   FINISH                  no, just leave it       @2019jan\n         oi    COMMAND,$bot            yes, indicate it        @2019jan\n         ni    COMMAND,255-$done       turn this bit off       @2019jan\n         icm   R2,15,SAVE_REGS         restore top of chain    @2019jan\n         bnz   ACCESS_CONCAT_bot       this way if got it      @2019jan\n         B     FINISH                  then finish\nREALLOC_PERM_AGAIN equ *\n         BAS   R14,ALLOC_PERM          allocate permanently\n         BNZ   REALLOC_CHEK            sign check bit\n         NI    CCATFLAG,X'FF'-$ON      turn pending bit off\n         B     REALLOC_NEXT\n                                       SPACE\n*---------------------------------------------*\n* LOOKUP DSN_CHAINED LIST AND VALIDATE        *\n*---------------------------------------------*\nLOOKUP_DSN     DS 0H\n         LA    R2,DSN_CHAIN            point to DSN Chained list\n         LR    R1,R2                   and save it\n*2019jan XR    R15,R15                 clear RC\n         LA    R15,12                  set RC=12               @2019jan\n         L     R7,DSTU_PTR             point general DSN TU\nLOOKUP_LOOP    equ *\n         L     R3,DSLLEN               get its length\n         BCTR  R3,0                    reduce for EX CLC\n         EX    R3,LOOKUP_CLC           is it duplication ?\n         BNE   LOOKUP_NEXT             ignore if unmatch\n         xr    r15,r15                 set rc = 0              @2019jan\n         OI    CCATFLAG,$DSN           remember it exists\n         OI    DSLFLAG,$ERRALC         flag for unreallocable\n         CR    R1,R2                   is it the 1st entry\n*2019jan BNE   LOOKUP_NEXT             ignore if not\n         be    LOOKUP_top              this way if so          @2019jan\nLOOKUP_check   equ *                                           @2019jan\n         icm   r0,15,DSLNEXT           point to next entry     @2019jan\n         bnz   LOOKUP_NEXT             if not 0, ignore it     @2019jan\nLOOKUP_bot     equ *                                           @2019jan\n         tm    COMMAND,$bot            to be moved to bottom?  @2019jan\n         bo    LOOKUP_comply           yes, mark as complied   @2019jan\n         b     LOOKUP_NEXT             no, skip below          @2019jan\nLOOKUP_top     equ *                                           @2019jan\n         L     R1,DSLNEXT              switch to next entry\n         tm    COMMAND,$TOP            to be moved to the top? @2019jan\n         bno   LOOKUP_NEXT             no, skip below          @2019jan\nLOOKUP_comply  equ *                                           @2019jan\n         oi    COMMAND,$done           remember it is complied @2019jan\nLOOKUP_NEXT    equ *\n*2019jan L     R2,DSLNEXT              point to next entry\n*2019jan LTR   R2,R2                   CHECK\n         icm   r2,15,DSLNEXT           point to next entry     @2019jan\n         BNZ   LOOKUP_LOOP             loop for all entries\n*2019jan CR    R15,R1                  is top pointer valid ?\n*2019jan BNE   LOOKUP_STOP             stop end if so\n*2019jan LR    R1,R15                  else, zerroes R1\n*2019jan LA    R15,12                  set RC=12\nLOOKUP_STOP    equ *\n         LA    R2,DSN_CHAIN            restore DSN Chainedlist pointer\n         LTR   R15,R15                 generate CC\n         bzr   r14                     return if 0             @2019jan\n         xr    r1,r1                   else, zeroes reg 1      @2019jan\n         BR    R14                     return\nLOOKUP_CLC     CLC S99TUPAR(*-*),DSLDSN   << executed >>\n         EJECT\n*---------------------------------------------*\n* ALLOCATE SPECIFIED DSN AS SPECIFIED DDNAME  *\n*---------------------------------------------*\nALLOC_TEMP     DS 0H\n         LA    R1,L_ALLOC_TEMP         select temporary\n         MVI   PROC_CODE,C'T'          process code\n         B     ALLOCATE                then allocate\nALLOC_PERM DS  0H\n         LA    R1,L_ALLOC_PERM         select permanent\n         MVI   PROC_CODE,C'A'          process code\nALLOCATE DS    0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBAL        request is allocation\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_ALLOC_TUPLIST,R8),ALLOC_TUPLIST copy specified TUPL\n         LA    R8,0(R8,R1)             skip to the last TUPLIST\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if fine\n         CLI   PROC_CODE,C'T'          check process code\n         BNE   ALLOCATE_FAIL           go here if fail\n         OI    CCATFLAG,$ERRS99        put error flag\nALLOCATE_END   DS 0H\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\nALLOCATE_FAIL  DS 0H\n         STH   R15,ER_CODE             save error code here\n         OI    CCATFLAG,$ERRALC        put error flag\n         B     ALLOCATE_END            end, return\n                                       SPACE\n*---------------------------------------------*\n* CONCATE THE REMAINDER TO THE ALLOCATED DSN  *\n*---------------------------------------------*\n                                       SPACE\nCONCATE  DS    0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBCC        request is CONCATENATION\n         LA    R8,CONCT_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_CONCT_TUPLIST-4(R8) point to last TU PTR\n         MVI   PROC_CODE,C'C'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if no error\n         OI    CCATFLAG,$ERRCON+$ERRS99 turn error bit on\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\n                                       SPACE\n*---------------------------------------------*\n* RELEASE DSN FROM DDNAME CONCATENATION       *\n*---------------------------------------------*\n                                       SPACE\nDEALLOC_ALL    DS 0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBUN        request is DEALLOCATION\n         LA    R8,RELSE_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_RELSE_ALL(R8)      point to last TU PTR\n         MVI   PROC_CODE,C'U'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if so good\n         CH    R15,=H'4'               is it tolerable error ?\n         BH    DEALLOC_FAIL            no,.... error msg\nDEALLOC_ONE    DS 0H\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBUN        request is DEALLOCATION\n         LA    R8,RELSE_TUPLIST        point to PLIST\n         ST    R8,S99TXTPP             save here\n         LA    R8,L_RELSE_ONE(R8)      point to last TU PTR\n         MVI   PROC_CODE,C'U'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BZR   R14                     return if so good\n         OI    CCATFLAG,$ERRS99        indicate general error\n         CLC   =H'0856',S99ERROR       overriding disposition ?\n         BER   R14                     return if so\n*        CLC   =H'1088',S99ERROR       dsname not found ?\n*        BER   R14                     return if so\n         CLC   =H'1116',S99ERROR       DSN permanently concatenated ?\n         BER   R14                     return if so\n*        CLC   =H'1120',S99ERROR       DSN // DDN not associated ?\n*        BER   R14                     return if so\n         CLC   =H'1124',S99ERROR       DSN is in private catalog ?\n         BER   R14                     return if so\nDEALLOC_FAIL   DS 0H\n         STH   R15,ER_CODE             save error code here\n         OI    CCATFLAG,$ERRUNL        put error flag\n         LTR   R15,R15                 regenerate CC\n         BR    R14                     return\n         EJECT\n*---------------------------------------------*\n* BUILD INFORMATION RETRIEVAL TEXT UNITS      *\n* and save the pointer in QRY_TUPLIST         *\n*---------------------------------------------*\nSETALLOC DS    0H                             *\n         L     R7,DSTU_PTR             point to DSN text unit\n         MVC   S99TUKEY(2),=AL2(DALDSNAM) query for specififed DDname\n         L     R2,TU_PTR               point to general TU\n         LH    R3,S99TULNG             get its parm length\n         MVC   0(50,R2),0(R7)          save the TU\n         ST    R2,ALLOC_DSN            save the pointer in directry\n         LA    R7,50(R2)               skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DALPERMA) permanent alloaction\n         XC    S99TUNUM(2),S99TULNG    number must be 0\n         ST    R7,ALLOC_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         MVC   S99TUKEY(2),=AL2(DALSTATS) permanent alloaction\n         MVI   S99TUNUM+1,1            number must be 1\n         MVI   S99TULNG+1,1            1 bytes length\n         MVI   S99TUPAR,$SHR           DISP=SHR\n         ST    R7,ALLOC_STS            save the pointer in directry\n         LA    R7,8(R7)                skip over this TU\n         L     R2,DDTU_PTR             point to DD text unit\n         MVC   0(14,R7),0(R2)          load whole DD TU\n         MVC   S99TUKEY(2),=AL2(DALDDNAM) DDname to be allocated\n         ST    R7,ALLOC_DDN            save the pointer in directry\n         LA    R2,14(R7)               next area\n         ST    R2,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD DEALLOCATION TEXT UNITS               *\n* and save the pointer in RELSE_TUPLIST       *\n*---------------------------------------------*\nSETRELSE DS    0H                             *\n         L     R2,DSTU_PTR             point to DSN text unit\n         L     R7,TU_PTR               point to general TU\n         MVC   S99TUNIT(50),0(R2)      load the TU\n         MVC   S99TUKEY(2),=AL2(DUNDSNAM) query for specififed DDname\n         LH    R3,S99TULNG             get its parm length\n         ST    R7,RELSE_DSN            save the pointer in directry\n         LA    R7,50(R7)               skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DUNUNALC) permanent alloaction\n         XC    S99TUNUM(2),S99TULNG    number must be 0\n         ST    R7,RELSE_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         L     R2,DDTU_PTR             point to DD text unit\n         MVC   S99TUNIT(50),0(R2)      load the TU\n         MVC   S99TUKEY(2),=AL2(DUNDDNAM) DDname to be allocated\n         ST    R7,RELSE_DDN            save the pointer in directry\n         LA    R2,14(R7)               next area\n         ST    R2,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD INFORMATION RETRIEVAL TEXT UNITS      *\n* and save the pointer in QRY_TUPLIST         *\n*---------------------------------------------*\nSETQUERY DS    0H\n         L     R7,DDTU_PTR             point to DD text unit\n         MVC   S99TUKEY(2),=AL2(DINDDNAM) query for specififed DDname\n         L     R2,TU_PTR               point to general TU\n         LH    R3,S99TULNG             get its parm length\n         MVC   0(50,R2),0(R7)          save the TU\n         ST    R2,QRY_DDN              save the pointer in directry\n         LA    R7,6(R3,R2)             skip over the TU area\n         MVC   S99TUKEY(2),=AL2(DINRTATT) ask for allocation attibute\n         MVC   S99TUNUM(2),=X'0001'    always 1\n         MVC   S99TULNG(2),=X'0001'\n         MVI   S99VERB,S99VRBIN        request to get info\n         ST    R7,QRY_ATR              save the pointer in directry\n         LA    R7,8(R7)                skip over this TU\n         MVC   S99TUKEY(2),=AL2(DINRTDSN) ask for dataset name\n         MVC   S99TUNUM(2),=X'0001'    always 1\n         MVC   S99TULNG(2),=X'002C'    44 bytes length\n         ST    R7,QRY_DSN              store into TUPlist\n         LA    R7,50(R7)               skip over their area\n         ST    R7,TU_PTR               save as available TU area\nQUERY    DS    0H                             *\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBIN        request is INFO. RETRIEVAL\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_QRY_TUPLIST,R8),QRY_TUPLIST copy specified TUPL\n         LA    R8,L_QRY_TUPLIST-4(R8)  skip to the last TUPLIST\n         MVI   PROC_CODE,C'I'          process code\n         BAS   R11,DYNALLOC            invoke SVC 99\n         BR    R14                     RETURN\n                                       SPACE\n*---------------------------------------------*\n* BUILD CONCATENATION TEXT UNITS              *\n* and save the pointer in CONCT_TU_PTR        *\n*---------------------------------------------*\nSETCONCT DS    0H                             *\n         L     R7,TU_PTR               point to general TU\n         MVC   S99TUKEY(2),=AL2(DCCPERMC) permanent alloaction\n         XC    S99TUNUM(2),S99TUNUM    number must be 0\n         ST    R7,CONCT_ATR            save the pointer in directry\n         LA    R7,4(R7)                skip over this TU\n         ST    R7,CONCT_DDN            save the pointer in directry\n         L     R3,DDTU_PTR             point to DD text unit\n         MVC   S99TUNIT(14),0(R3)      load whole DD TU\n         MVC   S99TUKEY(2),=AL2(DCCDDNAM) DDname to be allocated\n         MVI   S99TUNUM+1,X'02'        PARM num = 2\n         LA    R7,24(R7)               next area\n         ST    R7,TU_PTR               start of available TU area\n                                       SPACE\n*---------------------------------------------*\n* BUILD DECONCATENATION TEXT UNITS            *\n* and save the pointer in DECON_TU_PTR        *\n*---------------------------------------------*\nSETDECON DS    0H                             *\n         BR    R14                     RETURN\n         EJECT\n*---------------------------------------------*\n* PROLOGUE PRIOR SVC 99 SERVICE LOGIC         *\n*---------------------------------------------*\nS99_PROLG DS   0H\n         L     R9,S99RB_PTR            point to RB\n         XC    S99RB(L_S99RB),S99RB    clear the area\n         MVI   S99RBLN,L_S99RB         save it's self length\n         BR    R11                     RETURN\n                                       SPACE\n*------------------------------------------------*\n* INVOKING SVC 99 SERVICE FOR DYNAMIC ALLOCATION *\n*------------------------------------------------*\nDYNALLOC DS    0H\n         OI    S99TUPTR,S99TUPLN       and sign EOTUPLIST\n         L     R1,S99P_PTR             point to SVC 99 plist pointer\n         SVC   99                      invoke SVC 99\n         TM    CCATFLAG,$ERRALC+$ERRUNL has any error before ?\n         BNZ   DYNALLOC_END            skip if so\n         MVC   IF_CODE,S99INFO         save info code\n         MVC   RS_CODE,S99ERROR        save reason code\nDYNALLOC_END   DS 0H\n         STH   R15,RT_CODE             save return code\n         LTR   R15,R15                 check CC\n         BR    R11                     RETURN\n         EJECT\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE WITH ERRONOUS  *\n*-------------------------------------*\nFINISH   DS    0H\n         TM    CCATFLAG,$ERRALC+$ERRUNL  has it any erronous\n         BNZ   ERROR                   Yes, go to error routine\n         B     RETURN                  else, cleanup and return\n                                       SPACE\n*----------------------------------------*\n*  EXIT EPILOG ROUTINE WITH CANCELLATION *\n*----------------------------------------*\nIn_good_order  ds 0h                                           @2019jan\n         MVC   MSGSKEL(12),MSG_INORDER msg skeleton            @2019jan\n         MVC   MSGPARM(8),DSN_PARM     use DDn for msg         @2019jan\n         B     IGNORE                  then take this way      @2019jan\nIGNORE_ON      DS 0H\n         OI    CCATFLAG,$ERRALC        indicate error allocation\n         B     IGNORE                  then cancel it\nIGNORE_OFF     DS 0H\n         OI    CCATFLAG,$ERRUNL        indicate error deallocation\nIGNORE   DS    0H\n         LA    R15,4                   ignoring RC = 4\n*2019jan ST    R15,RC                  save RC\n*2019jan TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n*2019jan BO    CLEANUP                 YES, so quit immediately\n*2019jan B     CHECK_MSG               prepare msg to be displayed\n         b     LEAVE                   continue this way       @2019jan\n                                       SPACE\nCANCEL_ON      DS 0H\n         OI    CCATFLAG,$ERRALC        indicate error allocation\n         B     CANCEL                  then cancel it\nCANCEL_OFF     DS 0H\n         OI    CCATFLAG,$ERRUNL        indicate error deallocation\nCANCEL   DS    0H\n         LA    R15,8                   cancellation RC = 8\nLEAVE    DS    0H                                              @2019jan\n         ST    R15,RC                  save RC\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         B     CHECK_MSG               prepare msg to be displayed\n                                       SPACE\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE WITH ERRONOUS  *\n*-------------------------------------*\nERROR    DS    0H\n         TM    COMMAND,$ON+$ERRS99     is it allocation or any g.error\n         BZ    ERRFAIL                 no, need not recovery\n         BAS   R11,S99_PROLG           prepare to invoke SVC 99\n         MVI   S99VERB,S99VRBAL        request is allocation\n         L     R8,TUPL_PTR             point to TUPLIST\n         ST    R8,S99TXTPP             store TUPLIST in RB\n         MVC   0(L_ALLOC_TUPLIST_RETRY,R8),ALLOC_TUPLIST_RETRY\n         LA    R8,L_ALLOC_TUPLIST_RETRY-4(R8) skip to last TUPLIST\n         OI    S99TUPTR,S99TUPLN       and sign EOTUPLIST\n         L     R1,S99P_PTR             point to SVC 99 plist pointer\n         SVC   99                      invoke SVC 99\n         LTR   R15,R15                 check CC\n         BZ    ERRFAIL                 go here if recovery success\n         OI    CCATFLAG,$ERRCVRY       else, indicate recovery error\n         LA    R15,12                  set RC=12\n         STH   R15,ER_CODE             save it\n                                       SPACE\nERRFAIL  DS    0H\n         LH    R15,ER_CODE             get standard SVC 99 RC\n         LA    R15,4(R15)              add 4\n         ST    R15,RC                  save RC\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         BAS   R14,BUILDSKL            construct msg skeleton\n         BZ    CHECK_MSG               success, proceed\n         BAS   R14,BUILDMSG            construct msg text\n         MVC   MSGHDR+5(2),RETURN_CODE+2 insert RC in msg header\n         L     R15,MSGPARM             point to substitution location\n         MVI   5(R15),C'+'             insert process code\n         B     CHECK_MSG\n                                       SPACE\n*-------------------------------------*\n*  ERROR KEYWORD OR SYNTAX            *\n*-------------------------------------*\nERROR_KWD DS   0H\n         MVI   PROC_CODE,C'K'          process code\n         OI    CCATFLAG,$ERRKWD        remember it is syntax error\n         TM    COMMAND,$NOMSG          is NOMSG/EMSG required ?\n         BO    CLEANUP                 YES, so quit immediately\n         L     R15,ERRKWD_PTR          get ERROR KWD pointer\n         MVC   MSGLINE(L'ERRKWD),0(R15)   and move here\n         MVC   MSGLEN,=Y(L'ERRKWD+4)\n         BAS   R14,SHOW_MSG            display MSG\n         LM    R2,R3,HELPTAB_PTR       access help table\n         MVC   MSGHDR,=CL8' '          clear\nHELPLOOP DS    0H\n         MVC   MSGTEXT(L_HELPTAB),0(R2) get help text\n         MVC   MSGLEN,=Y(L'MSGHDR+L_HELPTAB+4) ...and its length\n         BAS   R14,SHOW_MSG            display MSG\n         LA    R2,L_HELPTAB(R2)        next help text\n         BCT   R3,HELPLOOP             loop for all\n         LA    R15,20                  RC = 20\n         ST    R15,RC                  save RC\n         B     EXIT                    then exit to TSO\n         EJECT\n*-------------------------------------*\n*  EXIT EPILOG ROUTINE IF NO ERROR    *\n*-------------------------------------*\nRETURN   DS    0H\n         LH    R15,ER_CODE             load error code\n         LTR   R15,R15                 check CC\n         BNZ   ERROR                   error if wrong\n         TM    COMMAND,$NOMSG+$EMSG    is NOMSG/EMSG required ?\n         BNZ   CLEANUP                 YES, so quit immediately\n         MVC   MSGPARM(8),DSN_PARM     substitute msg text using DSN\n         TM    COMMAND,$ON             is it ON function ?\n         BO    RETURN_MSG              yes, handle completion msg\n         MVC   MSGSKEL(12),MSG_OFF     else, use OFF completion msg\n         B     CHECK_MSG               then,  process it\nRETURN_MSG     DS 0H\n         MVC   MSGSKEL(12),MSG_ON      select msg skeleton\n         TM    CCATFLAG,$NEW           is it new allocation ?\n         BNO   CHECK_MSG               no, use normal completion msg\n         MVC   MSGSKEL(12),MSG_NEW     otherwise, use special msg\nCHECK_MSG      DS 0H\n         BAS   R14,BUILDMSG            build msg text line\nDISPLAY_MSG    DS 0H\n         BAS   R14,SHOW_MSG            display MSG\n         B     CLEANUP                 then cleanup\n                                       SPACE\n*-------------------------------------*\n*   PUTLINE SERVICE GATE              *\n*-------------------------------------*\n                                       SPACE\nSHOW_MSG DS    0H\n         ST    R14,SAVE14              save linkage pointer\n         XC    MSGLEN+2(2),MSGLEN+2\n         L     R15,PUTLINE_PTR         point to PUTLINE service\n         BASR  R14,R15                 perform it\n         L     R14,SAVE14              save linkage pointer\n         BR    R14                     return\nSHOW_DSN DS    0H\n         LA    R15,64                  msg text length\n         STH   R15,MSGLEN              and store here\n         B     SHOW_MSG                then display MSG\nMVC_LIST_NEW   MVC MSGTEXT+8(*-*),S99TUPAR\n         EJECT\n*-------------------------------------*\n*  BUILD PUTLINE FORMAT MSG SKELETON  *\n*  - R14 :  Linkage address           *\n*-------------------------------------*\n                                       SPACE\nBUILDSKL DS    0H\n         USING MSGBLOK,R5              msg directory blok map\n         MVC   MSGPARM(8),DSN_PARM     suppose for substitution\n         LM    R5,R7,MSGDIR_PTR        point to msg directory entry\nBSKLOOP1 DS    0H\n         CLC   MSGCODE,RS_CODE         is it the error code ?\n         BE    BSKLOKEY                leave this loop if so\n         LA    R5,MSGBLOKL(R5)         otherwise, seek next entry\n         BCT   R6,BSKLOOP1             .. then loop for all entries\nBSKLOOP2 DS    0H\n         CLC   MSGCODE(1),RS_CODE      check 1st byte only\n         BE    BSKLOKEY                leave this loop if match\n         LA    R5,MSGBLOKL(R5)         otherwise, seek next entry\n         BCT   R7,BSKLOOP2             .. then loop for all entries\n         MVC   MSGSKEL(12),MSG_FAIL    it is function failure\n         LA    R15,REASON_CODE         access reason code field\n         ST    R15,MSGPARM             use as substitution parameter\n         MVC   MSGPARM+4(4),=F'6'      length is always 4\n         LH    R15,RS_CODE             get reason code\n         CVD   R15,PACKED              convert to packed decimal\n         UNPK  REASON_CODE,PACKED      unpack\n         OI    REASON_CODE+3,X'F0'     convert to printable EBCDIC\n         B     BSKLEND                 finish\nBSKLOKEY DS    0H\n         NI    CCATFLAG,X'FF'-$ERRCVRY turn off recovery flag bit\n         XR    R15,R15                 reset CC\n         L     R2,MSGDIR_PTR           point to msg directory entry\n         AH    R2,MSGSKLA              correct msg skeleton address\n         MVC   MSGSKEL(12),0(R2)       select this address for later\n         TM    MSGFLAG,$DSN            is substitution right ?\n         BO    BSKLEND                 yes, continue to build msg line\n         MVC   MSGPARM(8),DDN_PARM     else, use DDname\nBSKLEND  DS    0H\n         LTR   R15,R15                 generate CC\n         BR    R14                     return\n         DROP  R5\n                                       SPACE\n*-------------------------------------*\n*  BUILD PUTLINE FORMAT MSG TEXT LINE *\n*  - R14 :  Linkage address           *\n*-------------------------------------*\n                                       SPACE\nBUILDMSG DS    0H\n         L     R2,SKLHDR               msg header\n         LH    R3,SKLHDRL              ...its length\n         LR    R15,R3                  initialize msg length\n         LA    R5,MSGLINE              access msg text\n         EX    R3,MVCLINE              contruct msg line\n         LA    R5,0(R5,R3)             skip over writen line\n         LM    R2,R3,MSGPARM           access substitutor\n         AR    R15,R3                  add line length\n         EX    R3,MVCLINE              contruct msg line\n         LA    R5,0(R5,R3)             skip over writen line\n         L     R2,SKLTXT               msg text trailer\n         LH    R3,SKLTXTL              ...its length\n         AR    R15,R3                  add line length\n         EX    R3,MVCLINE              contruct msg line\n         LA    R15,4(R15)              add 4\n         L     R1,RC                   get RC\n         LTR   R1,R1                   check\n         BZ    BLDMEND                 end this routine if RC=0\n         L     R1,RC                   load RC\n         CVD   R1,PACKED               convert to packed decimal\n         UNPK  RETURN_CODE,PACKED      unpack\n         OI    RETURN_CODE+3,X'F0'     convert to printable EBCDIC\n         LA    R5,0(R5,R3)             skip over writen line\n         MVC   RC_TEXT,RC_LINE         build RC skeleton\n         MVC   RC_MSG,RETURN_CODE      and put its value in\n         LA    R2,RC_TEXT              point to text of RC\n         LA    R3,L'RC_TEXT            and access its length\n         AR    R15,R3                  correct total length\n         EX    R3,MVCLINE              move RC text to msg line\nBLDMEND  DS    0H\n         STH   R15,MSGLEN              total msg length\n         BR    R14                     return\nMVCLINE  MVC   0(*-*,R5),0(R2)\n         EJECT\n*-------------------------------------*\n*    FINAL EXIT EPILOG ROUTINE        *\n*                                     *\n*   NOTES:                            *\n*                                     *\n*        - The following logic quiet  *\n*          unstructured due to        *\n*          performance reason so far. *\n*                                     *\n*        - To make it structured      *\n*          logic, remove all \"TM\"     *\n*          instruction into SHOW_MSG  *\n*          routine.                   *\n*                                     *\n*-------------------------------------*\nCLEANUP  DS    0H\n         TM    COMMAND,$NOMSG          is msg allowed ?\n         BNO   CLEANUP_SETUP           no, skip, continue to cleanup\n         NI    COMMAND,X'FF'-$LIST     make sure no MSG\n         NI    CCATFLAG,0              ...and msg opportunity at all\n         B     CLEANUP_GO              then continue to cleanup\nCLEANUP_SETUP  DS 0H\n         USING DSLINK,R2               TIOT copy chain addressability\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_GO              no, skip, continue to cleanup\n         L     R7,DDTU_PTR             point to DD TU\n         MVI   MSGLINE,X'40'           use blank to clear msg area\n         MVC   MSGLINE+1(L'MSGLINE-1),MSGLINE\n         MVC   MSGHDR,=C'CCAT800 '     special header\n         LA    R5,MSGTEXT              access msg text\n         LM    R2,R3,JOBSPEC           access jobname and its length\n         EX    R3,MVCLINE              move in jobname\n         LA    R5,0(R5,R3)             jump over jobname string\n         MVC   0(3,R5),=C'DD('\n         LA    R5,3(R5)                jump over this string\n         LM    R2,R3,DDN_PARM          access DDN string\n         BCTR  R3,0                    correct for EX MVC\n         EX    R3,MVCLINE              move in ddname\n         LA    R5,1(R5,R3)             jump over ddname string\n         MVC   0(16,R5),=CL16') concatenation:'\n         LA    R5,16(R5)               jump over this string\n         LR    R3,R5                   copy\n         LA    R2,MSGLEN               PUTLINE text address\n         SLR   R5,R2                   calculate text length\n         STH   R5,MSGLEN               save the length\n         TM    CCATFLAG,$DDN           has it allocated ?\n         BO    CLEANUP_TPUT            skip if so\n         MVC   0(10,R3),=CL10' not found'\n         LA    R3,10(R3)               jump over this string\n         SLR   R3,R2                   correct text length\n         STH   R3,MSGLEN               save the length\n         NI    COMMAND,X'FF'-$LIST     remove list flag\nCLEANUP_TPUT   DS 0H\n         BAS   R14,SHOW_MSG            display msg\n         MVI   MSGLINE,X'40'           use blank to clear msg area\n         MVC   MSGLINE+1(L'MSGLINE-1),MSGLINE\n         TM    CCATFLAG,$ERRALC+$ERRUNL any serious error ?\n         BNZ   CLEANUP_GO              skip and proceed\nCLEANUP_GOHEAD DS 0H\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_GO              no, continue to cleanup\n         TM    COMMAND,$ON             is it allocation ?\n         BNO   CLEANUP_GO              skip if deallocation\n         MVC   MSGTEXT(8),=CL8'New --> ' put new sign\n         L     R7,DSTU_PTR             point to DSN TU\n         LH    R3,S99TULNG             get its length\n         BCTR  R3,0                    reduce for EX\n         EX    R3,MVC_LIST_NEW         get DSN\n         BAS   R14,SHOW_DSN            display msg\nCLEANUP_GO     DS 0H\n         LA    R2,DSN_CHAIN            point to chaining TIOT copy\n         L     R11,DSLNEXT             get next chain\n         LH    R3,DD_COUNT             # of concatenation members\n         LA    R3,1(R3)                add 1 for initialize loop\n         B     CLEANUP_ROLL            and go here\nCLEANUP_LOOP   DS 0H\n         TM    COMMAND,$LIST           does CONCAT list requested ?\n         BNO   CLEANUP_ONLY            skip if not\n         LA    R2,DSN_CHAIN            point to chaining TIOT copy\n         MVC   MSGTEXT(3),DSLDDN+5\n         MVC   MSGTEXT+3(5),=CL5' --> '\n         TM    DSLFLAG,$ON             DSN eligible to be displayed ?\n         BO    CLEANUP_LIST            skip if not\n         MVC   MSGTEXT(8),=CL8'Error'  mark error\n         TM    CCATFLAG,$ERRCON        does CONCAT list requested ?\n         BO    CLEANUP_LIST            skip if not\n         MVC   MSGTEXT(8),=CL8'Skipped' mark skipped\nCLEANUP_LIST   DS 0H\n         MVC   MSGTEXT+8(44),DSLDSN    write DSN string into msg text\n         BAS   R14,SHOW_DSN            else display it\n         LTR   R2,R11                  check if 0\n         BZ    QUIT                    quit if 0\n         MVC   DSN_CHAIN(L_DSLINK),0(R11) move next chain here\n         B     CLEANUP_FRET\nCLEANUP_ONLY   DS 0H\n         LTR   R2,R11                  check if 0\n         BZ    QUIT                    quit if 0\nCLEANUP_FRET   DS 0H\n         L     R11,DSLNEXT             get next chain\n         FREEMAIN R,LV=L_DSLINK,A=(2)  release it\nCLEANUP_ROLL   DS 0H\n         BCT   R3,CLEANUP_LOOP         loop if any other chained area\n         DROP  R2\nQUIT     DS    0H\n         TM    CCATFLAG,$ERRCVRY       has error recoverd ?\n         BNO   EXIT                    yes, skip to exit\n         MVC   MSGHDR,=CL8' '          clear msg header\n         L     R15,CONCATE_PTR         point to concatenationlist serv\n         BASR  R14,R15                 perform this service\nEXIT     DS    0H\n         L     R5,RC                   save RC\n         L     R1,STOR_PTR             point to GETMAINed area\n         L     R13,B_PTR               restore system savearea pointer\n         DROP  R13                     reset privatearea addressing\n         FREEMAIN R,LV=STORAGE,A=(1)   release storage\n         L     R14,12(R13)\n         LR    R15,R5\n         LM    R0,R12,20(R13)\n         BSM   0,R14\n         EJECT\n*-------------------------------------*\n*  SERVICE ROUTINE DIRECTORY          *\n*-------------------------------------*\nPUTLINE_PTR    DC A(DERCCTPL)          PUTLINE service routine address\nCONCATE_PTR    DC A(DERCCTLS)          concatenation list service\nMSGDIR_PTR     DC A(MSGDIR,MSGDIRN,MSGDIRM) skeleton directory ptr/len\nERRKWD_PTR     DC A(ERRKWD)            syntax error text pointer\nHELPTAB_PTR    DC A(HELPTAB,HELPTABL)  syntax help table pointer\nPCEADCON       DC A(PCEDEFS)\n                                       SPACE\n*-------------------------------------*\n*  LITERALS POOL  #1                  *\n*-------------------------------------*\n         LTORG\n         EJECT\n*-------------------------------------*\n*  MESSAGES SKELETONS DIRECTORY       *\n*-------------------------------------*\nMSGDIR   DS    0H\n         DC    AL2(0572),AL1($DSN),XL1'00',AL2(MSG_UNCAT-MSGDIR)\n         DC    AL2(0596),AL1($DSN),XL1'00',AL2(MSG_DSBUSY-MSGDIR)\n         DC    AL2(0868),AL1($DDN),XL1'00',AL2(MSG_DDWRONG-MSGDIR)\n         DC    AL2(0872),AL1($DSN),XL1'00',AL2(MSG_DSWRONG-MSGDIR)\n         DC    AL2(1040),AL1($DDN),XL1'00',AL2(MSG_DDUNAVL-MSGDIR)\n         DC    AL2(1056),AL1($DDN),XL1'00',AL2(MSG_DDBUSY-MSGDIR)\n         DC    AL2(1060),AL1($DSN),XL1'00',AL2(MSG_DSWRONG-MSGDIR)\n         DC    AL2(1076),AL1($DDN),XL1'00',AL2(MSG_DDCNFLC-MSGDIR)\n         DC    AL2(1080),AL1($DDN),XL1'00',AL2(MSG_DDMISS-MSGDIR)\n         DC    AL2(1084),AL1($DDN),XL1'00',AL2(MSG_DDUNAVL-MSGDIR)\n         DC    AL2(1088),AL1($DSN),XL1'00',AL2(MSG_DSMISS-MSGDIR)\n         DC    AL2(1096),AL1($DSN),XL1'00',AL2(MSG_ALRDY-MSGDIR)\nMSGDIRX  DC    AL2(1124),AL1($DSN),XL1'00',AL2(MSG_PRVCAT-MSGDIR)\nMSGDIRL  EQU   *-MSGDIRX\nMSGDIRN  EQU   (*-MSGDIR)/MSGDIRL\n         DC    XL2'5700',AL1($DSN),XL1'00',AL2(MSG_ERCAT-MSGDIR)\n         DC    XL2'1700',AL1($DSN),XL1'00',AL2(MSG_UNCAT-MSGDIR)\n         DC    XL2'6700',AL1($DSN),XL1'00',AL2(MSG_EROBT-MSGDIR)\nMSGDIRM  EQU   (*-MSGDIR)/MSGDIRL\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES TEXT SKELETONS            *\n*-------------------------------------*\nMSGSKL   DS    0H\nMSG_NEW        DC  AL4(MH000),AL4(MT000),AL2(L'MH000),AL2(L'MT000)\nMSG_ON         DC  AL4(MH001),AL4(MT001),AL2(L'MH001),AL2(L'MT001)\nMSG_OFF        DC  AL4(MH002),AL4(MT002),AL2(L'MH002),AL2(L'MT002)\nMSG_DDBUSY     DC  AL4(MH003),AL4(MT003),AL2(L'MH003),AL2(L'MT003)\nMSG_DSWRONG    DC  AL4(MH004),AL4(MT004),AL2(L'MH004),AL2(L'MT004)\nMSG_ALRDY      DC  AL4(MH005),AL4(MT005),AL2(L'MH005),AL2(L'MT005)\nMSG_UNCAT      DC  AL4(MH006),AL4(MT006),AL2(L'MH006),AL2(L'MT006)\nMSG_DSBUSY     DC  AL4(MH007),AL4(MT007),AL2(L'MH007),AL2(L'MT007)\nMSG_DDWRONG    DC  AL4(MH008),AL4(MT008),AL2(L'MH008),AL2(L'MT008)\nMSG_DDMISS     DC  AL4(MH009),AL4(MT009),AL2(L'MH009),AL2(L'MT009)\nMSG_DSMISS     DC  AL4(MH010),AL4(MT010),AL2(L'MH010),AL2(L'MT010)\nMSG_DDUNAVL    DC  AL4(MH011),AL4(MT011),AL2(L'MH011),AL2(L'MT011)\nMSG_DDCNFLC    DC  AL4(MH012),AL4(MT012),AL2(L'MH012),AL2(L'MT012)\nMSG_PRVCAT     DC  AL4(MH013),AL4(MT013),AL2(L'MH013),AL2(L'MT013)\nMSG_ERCAT      DC  AL4(MH014),AL4(MT014),AL2(L'MH014),AL2(L'MT014)\nMSG_EROBT      DC  AL4(MH015),AL4(MT015),AL2(L'MH015),AL2(L'MT015)\nMSG_INORDER    DC  AL4(MH016),AL4(MT016),AL2(L'MH016),AL2(L'MT016)\nMSG_FAIL       DC  AL4(MH900),AL4(MT900),AL2(L'MH900),AL2(L'MT900)\nMSGSKLL  EQU   *-MSGSKL\nRC_LINE  DC    C', RC=0000.' RC for msg line\n         DROP  R7,R8,R9\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DSNAME OPERAND VALIDATOR                                           *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DSname from DS() operand       *\n*        of this command based on standard DSN string pattern in      *\n*        MVS system.                                                  *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified DS(dsname) in CONCAT operand                       *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DSN string pointer and length in CCATAREA storage          *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTDS\nDERCCTDS DS    0D\n         SAVE  (14,12),,'DERCCTDS: CCAT DSN VALIDATOR'\n         LR    R9,R15                  point to base register\n         USING DERCCTDS,R9             establish addessability\n         USING CCATAREA,R10            establish addressability\n         LR    R2,R1                   copy validity check PLIST\n         L     R10,4(R2)               point to the DWA\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$DSN           remember to process DSN\n         mvi   VALCFLAG,$DSN           remember to process DSN @2019jan\n         B     VALIDATE                proceed\n                                       SPACE\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  PUTLINE SERVICE CALL                                               *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Structuring MSG prototype and call PUTLINE to display        *\n*                                                                     *\n*  INPUT:                                                             *\n*        MSG text                                                     *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - MSG text displayed onto screen                             *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - R15 : as resulted from PUTLINE service processor           *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTPL\nDERCCTPL DS    0D\nL_DELTA_PUTLS  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTPL: CCAT MSG SERVICE'\n         LA    R9,L_DELTA_PUTLS        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy current base register\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n         ni    VALCFLAG,0              clear flag byte         @2019jan\n         B     VALIDATE                perform validation\n                                       SPACE\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DATASET CHAINED-LINKED LIST DISPLAY SERVICE                        *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DDname from F( ) operand       *\n*        of this command based on standard DDN string pattern in      *\n*        MVS system,  try to check if it has been allocated in        *\n*        TIOT.                                                        *\n*        If so, then try to lookup JFCB to search all datasets        *\n*        concatenated with, and build DSN chained list (DSLINK)       *\n*        as a private CONCAT control block                            *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified LIST keyword insted of DSN() or,                   *\n*        LMSG keyword instead of EMSG or NOMSG                        *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DDname string pointer and length in CCATAREA storage       *\n*        - $DDN flag bit in CCATFLAG byte if it is found in TIOT      *\n*        - Jobname (TSO userid) in CCATAREA storage                   *\n*        - Display (PUTLINE) all DSN in DD concatenation using        *\n*          msg CCAT800.                                               *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTLS\nDERCCTLS DS    0D\nL_DELTA_CCTCK  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTLS: CCAT DDN LIST DISPLAY'\n         LA    R9,L_DELTA_CCTCK        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy current base register\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$LIST          remember to process DSN\n         mvi   VALCFLAG,$LIST          remember to process DSN @2019jan\n         B     VALIDATE                perform validation\n                                       SPACE\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  CONCAT SERVICE ROUTINE                                             *\n*  DDNAME OPERAND VALIDATOR                                           *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  FUNCTIONS:                                                         *\n*        Check and enter the specified DDname from F( ) operand       *\n*        of this command based on standard DDN string pattern in      *\n*        MVS system,  try to check if it has been allocated in        *\n*        TIOT.                                                        *\n*        If so, then try to lookup JFCB to search all datasets        *\n*        concatenated with, and build DSN chained list (DSLINK)       *\n*        as a private CONCAT control block                            *\n*                                                                     *\n*  INPUT:                                                             *\n*        Specified F(DDname) in CONCAT operand                        *\n*                                                                     *\n*  OUTPUT:                                                            *\n*        - DDname string pointer and length in CCATAREA storage       *\n*        - $DDN flag bit in CCATFLAG byte if it is found in TIOT      *\n*        - Jobname (TSO userid) in CCATAREA storage                   *\n*                                                                     *\n*  RETURN CODES:                                                      *\n*        - 0   : specified dsname is valid                            *\n*                                                                     *\n*                                                                     *\n*=====================================================================*\n         ENTRY DERCCTDD\nDERCCTDD DS    0D\nL_DELTA_DDNCK  EQU   *-DERCCTDS\n         SAVE  (14,12),,'DERCCTDD: CCAT DDN VALIDATOR'\n         LA    R9,L_DELTA_DDNCK        get delta\n         SR    R15,R9                  correct the program base\n         LR    R9,R15                  copy to current base register\n         LR    R2,R1                   copy validity check parm.list\n         L     R10,4(R2)               point to the dynamic work area\n*2019jan XC    VALCFLAG,VALCFLAG       clear flag byte\n*2019jan OI    VALCFLAG,$DDN           remember to process DSN\n         mvi   VALCFLAG,$DDN           remember to process DSN @2019jan\n         OI    CCATFLAG,$DDN           ... also here\n         EJECT\n*=====================================================================*\n*                                                                     *\n*  COMMON LOGIC SERVICE PROCESSOR                                     *\n*                                                                     *\n*        REGISTERS : R0  - UNUSED                                     *\n*                    R1  - CPPL map area                              *\n*                    R2  - PPL map area,                              *\n*                          PDL map area, and then                     *\n*                          DSLINK map area.                           *\n*                    R3  - work register                              *\n*                    R4  - work register                              *\n*                    R5  - work register                              *\n*                    R6  - TIOT map area                              *\n*                    R7  - SWA map area                               *\n*                    R8  - S99 TU Parameter list map area             *\n*                    R9  - Base address of this routine               *\n*                    R10 - Dynamic work area                          *\n*                    R11 - Inner linkage address                      *\n*                    R12 - Main Logic base                            *\n*                    R13 - save area                                  *\n*                    R14 - outer linkage address                      *\n*                    R15 - return code                                *\n*                                                                     *\n*=====================================================================*\n         ENTRY VALIDATE\nVALIDATE DS    0H\n         GETMAIN RU,LV=L_SAVEAREA      obtain dynamic work area\n         USING SAVEAREA,R1\n         ST    R1,8(R13)               save its address\n         ST    R13,B_PTR               save R13\n         LR    R13,R1                  point to obtained area\n         DROP  R1\n         USING SAVEAREA,R13            establish addressability\n         TM    VALCFLAG,$DDN+$DSN+$LIST  is it flagged ?\n         BZ    PUTLINE_SRV             go here no flags\n         TM    VALCFLAG,$LIST          is it flagged ?\n         BO    GET_TIOT                go here no flags\n         XC    RC,RC                   clear RC\n         LM    R1,R3,0(R2)             get PDE address\n         STM   R1,R3,CK_PDE_PLIST      save here\n         TM    VALCFLAG,$DDN           is it DDn processing ?\n         BO    DD_EXEC                 go here if so\n         ST    R2,CKDS_PTR             save validity check pointer\n         L     R2,PDE_PTR              point to PDE address\n         USING PDE_DSN,R2              establish PDE addressing\n         L     R3,DS_PTR               yes, point to DSN field\n         LH    R4,DS_LEN               get it's length\n         TM    DS_FLAG,$PRESENT        any DSN specified ?\n         BO    CK_DS_EXIT              yes, exit\nCK_DS_MISS     DS 0H\n         LA    R15,4                   RC=4 for missing DSN\n         ST    R15,RC                  and save it\nCK_DS_EXIT     DS 0H\n         STM   R3,R4,DSN_PARM\n         DROP  R2\nCK_EXIT  DS    0H\n         LR    R1,R13                  restore savearea address\n         L     R13,B_PTR               point to original savearea\n         FREEMAIN RU,LV=L_SAVEAREA,A=(1)  release savearea\n         L     R15,RC                  restore RC\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BSM   0,R14\nDD_EXEC  DS    0H\n         ST    R2,CKDD_PTR             save validity check pointer\n         L     R2,PDE_PTR              point to PDE address\n         USING PDE_DDN,R2              establish PDE addressing\n         TM    DD_FLAG,$PRESENT        any DSN specified ?\n         BNO   CK_DD_MISS              error if not specified\n         MVC   SAVE_DDN+2(8),BLANK     make blank\n         LH    R5,DD_LEN               get DDname length\n         STH   R5,SAVE_DDN             save length here\n         L     R4,DD_PTR               point to ddname string\n         CH    R5,=H'8'                length > 8 ?\n         BNH   GOT_DDPARM              no, save it\n         LA    R5,8                    yes, make it 8\nGOT_DDPARM     DS 0H\n         STM   R4,R5,DDN_PARM          save DDN from CPPL here\n         BCTR  R5,0                    reduce for EX MVC\n         EX    R5,MVC_DD               copy DDname tring\n         B     GET_TIOT                continue to obtain TIOT\n         DROP  R2\nBLANK    DC    CL8' '                  blank\nMVC_DD   MVC   SAVE_DDN+2(*-*),0(R4)   << executed >>\n                                       SPACE\nGET_TIOT DS    0H\n         USING TIOENTRY,R6             establish addressability\n         LA    R6,TIOT_PTR             point to TIOT pointer\n         EXTRACT (R6),FIELDS=TIOT      access TIOT\n         L     R6,TIOT_PTR             point to TIOT\n         MVC   HEADER(24),0(R6)        save header\n         LA    R14,HEADER              point to header field\n         ST    R14,JOBSPEC             save it here\n         LA    R14,8(R14)              jump over jobname token\n         LA    R15,8                   intialize loop\nJOB_LOOP DS    0H\n         CLI   0(R14),X'40'            is it blank\n         BNE   GOT_JOBNAME             no, its mean upper limit\n         BCTR  R14,1                   previous byte\n         BCT   R15,JOB_LOOP            loop\nGOT_JOBNAME    DS 0H\n         ST    R15,JOBSPEC+4           save the length\n         XR    R15,R15                 clear R15\n         XR    R14,R14                 clear R14 for IC\n         LA    R6,24(R6)               skip header\nTIOT_LOOP DS   0H\n         CLC   SAVE_DDN+2(8),TIOEDDNM  check TIOT DDname 4(R6)\n         BE    DD_FOUND                find, go here\n         IC    R14,TIOELNGH            entry length 0(R6)\n         LA    R6,0(R6,R14)            next DD entry\n         CLC   =F'0',TIOELNGH          end of TIOT ?\n         BNE   TIOT_LOOP               No, loop\n         B     CK_DD_MISS              yes, DDname not found\nDD_FOUND DS    0H\n         USING DSLINK,R2               DSN chain addressability\n         USING SWAEPA,R5               SWA EPA addressability\n         USING INFMJFCB,R7             JFCB addressability\n         XR    R3,R3                   clear counter\n         XR    R14,R14                 clear R14 for IC\n         LA    R2,DSN_CHAIN            point to start DSN chaining\n         B     DD_COPY                 go to copy DSN\nDD_LOOP  DS    0H\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BO    DD_TIOT_CK              yes, skip msg display routine\n         MVC   MSGTEXT(3),DSLDDN+5     move up the sequent number\n         MVC   MSGTEXT+3(5),=CL5' -->'\n         MVC   MSGTEXT+8(44),DSLDSN    dataset name\n         BAS   R14,DISPLAY_DSN         display DSN\nDD_TIOT_CK     DS 0H\n         CLC   =F'0',TIOELNGH          end of TIOT ?\n         BE    DD_FINISH               Yes, finish anyway\n         CLC   BLANK(8),TIOEDDNM       is it DD concatenation member ?\n         BNE   DD_FINISH               No, end of concatenation\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BNO   DD_COPY                 no, skip GETMAIN routine\nDD_STORAGE     DS 0H\n         GETMAIN R,LV=L_DSLINK,LOC=ANY  obtain V.storage\n         ST    R1,DSLNEXT              create chain pointer\n         LR    R2,R1                   save chaining pointer\nDD_COPY  DS    0H\n         LA    R5,EPA                  point to EPA\n         ST    R5,EPA_PTR              save this pointer\n         XC    SWAEPA,SWAEPA           clean EPA area\n         MVC   SWVA,TIOEJFCB           Copy SVA of JFCB into EPA\n         SWAREQ FCODE=RL,EPA=EPA_PTR,MF=(E,SWAPLIST),UNAUTH=YES\n         L     R7,SWBLKPTR             point to JFCB\n         MVC   DSLDSN,JFCBDSNM         get DSN\n         XC    DSLNEXT(8),DSLNEXT      mark end of chain\n         OI    DSLFLAG,$ON             mark eligible to be used\n         LA    R3,1(R3)                add 1 to accumulator\n         CVD   R3,PACKED               convert to packed decimal\n         UNPK  DSLDDN+4(4),PACKED(8)   unpack for EBCDIC\n         OI    DSLDDN+7,X'F0'          turn off decimal sign\n         MVC   DSLDDN(4),=C'CCAT'\n         LA    R4,44                   DSN length\n         LA    R5,DSLDSN               point to DSN string\nDD_CALC  CLI   0(R5),X'40'             is it blank\n         BE    DD_NEXT                 go next DD entry if so\n         LA    R5,1(R5)                next byte\n         BCT   R4,DD_CALC              loop\nDD_NEXT  DS    0H\n         ST    R4,DSLLEN\n         LA    R4,44                   set length max 44\n         S     R4,DSLLEN               calculate correct length\n         ST    R4,DSLLEN               then .... save it\n         XR    R14,R14                 make sure R14 always cleaned\n         IC    R14,TIOELNGH            entry length 0(R6)\n         LA    R6,0(R6,R14)            next DD entry\n         B     DD_LOOP                 loop\nDD_FINISH DS   0H\n         STH   R3,DD_COUNT             save counter\n         B     CK_EXIT                 then exit\nCK_DD_MISS     DS 0H\n         NI    CCATFLAG,X'FF'-$DDN     indicate DDname not found\n         TM    VALCFLAG,$DDN           is it accessing process ?\n         BO    CK_EXIT                 yes, exit immediately\n         L     R1,ERRTIOT_PTR          point TIOT msg text\n         MVC   MSGLINE(L'ERRTIOT),0(R1)  put msg here\n         XC    MSGLEN(2),MSGLEN        clear length field\n         OI    MSGLEN+1,L'ERRTIOT+4    specify msg length\n         BAS   R14,DISPLAY             display this msg\n         B     CK_EXIT                 then exit\n         DROP  R2\n         EJECT\n*-------------------------------------*\n*  PUTLINE SERVICE ROUTINE            *\n*-------------------------------------*\nPUTLINE_SRV    DS 0H\n         BAS   R14,PUTLINE\n         B     CK_EXIT\nDISPLAY_DSN    DS 0H\n         XC    MSGLEN(4),MSGLEN        clear PUTLINE buffer spec.\n         MVI   MSGLEN+1,64             msg text length = 60 + 4\n         B     PUTLINE                 process PUTLINE service\nDISPLAY  DS    0H\n         XC    MSGLEN+2(2),MSGLEN+2\nPUTLINE  DS    0H\n         ST    R14,SAVE_PUTL           save R14\n         STM   R2,R4,SAVE_REGS         save work registers\n         L     R2,CPPL_PTR             point to CPPL\n         USING CPPL,R2                 establish addressability\n         L     R3,CPPLUPT\n         L     R4,CPPLECT\n         XC    IOPLADS(20),IOPLADS      clear IOPL\n         PUTLINE PARM=PUTBLOK,ECB=PUTLECB,ECT=(4),UPT=(3),             *\n               OUTPUT=(MSGLEN,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LM    R2,R4,SAVE_REGS         restore work registers\n         L     R14,SAVE_PUTL           restore R14\n         BR    R14                     return\n         DROP  R6,R2,R9,R10,R13\n         EJECT\n                                       SPACE\n*-------------------------------------*\n*  SIMPLE HELP TEXT LIST              *\n*-------------------------------------*\nHELPTAB  DS    0H\n         DC    C'Command Syntax:        +-   -+ +-     -+'\n         DC    C'                       | ON  | | MSG   |'\n         DC    C'  CCAT F(ddn) DS(dsn)  | top | | lmsg  |'\n         DC    C'                       | bot | | emsg  |'\n         DC    C'                       | off | | nomsg |'\n         DC    C'                       +-   -+ +-     -+'\n         DC    C'                                        '\n         DC    C'  Issue HELP CCAT for further hint      '\n         DC    C'                                        '\nHELPTABW DC    C'     Copyright (C) 1991 -  DERU SUDIBYO '\nL_HELPTAB      EQU *-HELPTABW\nHELPTABL EQU   (*-HELPTAB)/L_HELPTAB\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES TEXTS LIST                *\n*-------------------------------------*\nMH000    DC    C'CCAT000 '\nMT000    DC    C' successfully allocated'\nMH001    DC    C'CCAT001 '\nMT001    DC    C' successfully concatenated'\nMH002    DC    C'CCAT002 '\nMT002    DC    C' successfully released'\nMH003    DC    C'CCAT003 DDname '\nMT003    DC    C' already in use'\nMH004    DC    C'CCAT004 '\nMT004    DC    C' unallocatable'\nMH005    DC    C'CCAT005 '\nMT005    DC    C' already concatenated'\nMH006    DC    C'CCAT006 '\nMT006    DC    C' not cataloged'\nMH007    DC    C'CCAT007 '\nMT007    DC    C' reserved by other job'\nMH008    DC    C'CCAT008 DDname '\nMT008    DC    C' is illegal for SVC 99'\nMH009    DC    C'CCAT009 DDname '\nMT009    DC    C' not allocated yet'\nMH010    DC    C'CCAT010 '\nMT010    DC    C' not found'\nMH011    DC    C'CCAT011 DDname '\nMT011    DC    C' not available'\nMH012    DC    C'CCAT012 DDname '\nMT012    DC    C' internally conflict'\nMH013    DC    C'CCAT013 '\nMT013    DC    C' is a private catalog'\nMH014    DC    C'CCAT014 Catalog error, '\nMT014    DC    C' not accessed'\nMH015    DC    C'CCAT015 OBTAIN error, '\nMT015    DC    C' not accessed'\nMH016    DC    C'CCAT016 '                                     @2019jan\nMT016    DC    C' already in the right order'                  @2019jan\n*                                                              @2019jan\nMH900    DC    C'CCAT900 Function failure, S99ERROR='\nMT900    DC    C', call your engineer'\n                                       SPACE\nERRTIOT_PTR    DC A(ERRTIOT)\nERRTIOT  DC    C'CCAT990 No dataset/DDname found in TIOT or JFCB'\nERRKWD   DC    C'CCAT999 SYNTAX ERROR, Operand missing or invalid '\nPUTBLOK  PUTLINE MF=L\nSTORAGE  EQU   L_CCATAREA+L_PPL+L_SAVEAREA+L_PDE_DSN+L_S99RB+512\n         EJECT\n*-------------------------------------*\n*  PARAMETERS CONTROL LIST (PCL)      *\n*-------------------------------------*\nPCL      DS    0H\nPCEDEFS  IKJPARM  DSECT=CCATPDL\nPDLCMD   IKJKEYWD DEFAULT='ON'\n         IKJNAME  'ON'\n         IKJNAME  'TOP'\n         IKJNAME  'BOT'                                        @2019jan\n         IKJNAME  'BOTTOM'                                     @2019jan\n         IKJNAME  'OFF'\nDDNAME   IKJKEYWD\n         IKJNAME  'DD',SUBFLD=DDN,ALIAS=('DDNAME','FILE','F')\nDSNAME   IKJKEYWD DEFAULT='LIST'\n         IKJNAME  'LIST',ALIAS=('LST','MAP')\n         IKJNAME  'DS',SUBFLD=DSN,ALIAS=('DATASET','DSN')\nPDLMSG   IKJKEYWD DEFAULT='MSG'\n         IKJNAME  'MSG'\n         IKJNAME  'NOMSG'\n         IKJNAME  'EMSG'\n         IKJNAME  'LMSG'\nDDN      IKJSUBF\nPDLDDN   IKJIDENT 'DDNAME',                                            *\n               MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM,                   *\n               VALIDCK=DERCCTDD,PROMPT='DDname for Concatenation:'\nDSN      IKJSUBF\nPDLDSN   IKJPOSIT DSNAME,                                              *\n               USID,                                                   *\n               VALIDCK=DERCCTDS\n         IKJENDP\nL_PCL    EQU   *-PCL\n         EJECT\n*-------------------------------------*\n*  PARAMETER DISCRIPTOR ENTRY (PDE)   *\n*-------------------------------------*\nPDE_DSN  DSECT\nDS_PTR   DS    F             PTR ==> DATASET NAME\nDS_LEN   DS    H             length of DSN exclude quotes\nDS_FLAG  DS    X             flags byte\nMEM_PTR  DS    F             PTR ==> MEMBER NAME\nMEM_LEN  DS    H             length of MEMBER\nMEM_FLAG DS    X             flags byte\nPWD_PTR  DS    F             PTR ==> PASSWORD\nPWD_LEN  DS    H             length of PASSWORD\nPWD_FLAG DS    X             flags byte\nL_PDE_DSN      EQU *-PDE_DSN\n                                       SPACE\nPDE_DDN  DSECT\nDD_PTR   DS    F             PTR ==> DDNAME\nDD_LEN   DS    H             length of DDNAME\nDD_FLAG  DS    X             flags byte\nL_PDE_DDN      EQU *-PDE_DDN\n         EJECT\n*-----------------------------*\n*  PARSE PARAMETER LIST (PPL) *\n*-----------------------------*\n         IKJPPL\nL_PPL    EQU   *-PPL\n         EJECT\n*------------------------------------------*\n*  COMMAND PROCESSOR PARAMETER LIST (CPPL) *\n*------------------------------------------*\n         IKJCPPL\nL_CPPL   EQU   *-CPPL\n         EJECT\n*-------------------------------------*\n*  SVC 99 PARAMETER AND CONTROL BLOCK *\n*-------------------------------------*\n         IEFZB4D0\n         IEFZB4D2\nL_S99RB  EQU   (S99RBEND-S99RB)\n         EJECT\n*----------------------------------*\n*  DSN_CHAIN LINKED LIST STRUCTURE *\n*----------------------------------*\nDSLINK   DSECT\n* +--4-+----8---+--------------44-----||-----------+-4--+----+\n* |Len |Temp.   | DATASET name                     |NEXT|////|\n* |    |DD name |                                  |PTR |////|\n* +----4--------12--------------------||-----------56---60---64\nDSLLEN   DS    F             DSN string length\nDSLDDN   DS    XL8           assigned temp. DDname\nDSLDSN   DS    XL44          copy DSN string from TIOT\nDSLNEXT  DS    F             pointer to next DSLINK\nDSLFLAG  DS    X             flag\n         DS    XL3           reserved for future used\nL_DSLINK EQU   *-DSLINK\n                                       SPACE\n*-----------------------------*\n*  SAVE/WORK AREA             *\n*-----------------------------*\nSAVEAREA DSECT\n         DS    F             unused\nB_PTR    DS    F             backword pointer\nF_PTR    DS    F             forword pointer\nREG_AREA DS    16F           registers save area\nL_SAVEAREA EQU   *-SAVEAREA  save area length\n*-------------------------------------*\n*  DYNAMIC WORK AREA                  *\n*-------------------------------------*\nCCATAREA DSECT\nCCAT_LEN       DS F          CCAT workarea length\nCCAT_PTR       DS F          PTR ==> CCAT workarea\nSTOR_LEN       DS F          PTR ==> length of getmained AREA\nSTOR_PTR       DS F          PTR ==> STORAGE GETMAIN\nS99P_PTR       DS F          PTR ==> S99RBP\nS99RB_PTR      DS F          PTR ==> S99RB\nSAVE_PTR       DS F          PTR ==> SAVEAREA\nTIOT_PTR       DS F          PTR ==> Task I/O table\nEPA_PTR        DS F          PTR ==> External Parameter Area\nCPPL_PTR       DS F          PTR ==> CPPL\nPPL_PTR        DS F          PTR ==> PPL\nPCL_PTR        DS F          PTR ==> PCL\nPDL_PTR        DS F          PTR ==> PDL\nTUPL_PTR       DS F          PTR ==> TUPLIST\nTU_PTR         DS F          PTR ==> TU\nANSWER_PTR     DS F          PTR ==> USER RESPONSE\nCKDS_PTR       DS F          PTR ==> CKDSNAME ROUTINE\nCKDD_PTR       DS F          PTR ==> CKDDNAME ROUTINE\nIOPLADS        DC 4F'0'      I/O PARM. LIST\nPUTLECB        DS F          ECB for PUTLINE service\nSAVE13         DS F          R13 ROOM\nSAVE14         DS F          R14 ROOM\nSAVE_PUTL      DS F          R14 ROOM\nSAVE_REGS      DS 5F         savearea for work registers\nDSN_PARM       DC A(0,0)     DSN PTR AND LENGTH\nMEM_PARM       DC A(0,0)     MEMBER PTR AND LENGTH\nPWD_PARM       DC A(0,0)     PASSWORD PTR AND LENGTH\nCCATJFCB       DS XL176      JFCB copy area\nSWAPLIST       SWAREQ MF=L   SWA Parameter List\nEPA            DS XL8\nQMPA           DS XL36\nHEADER         DS XL24       TIOT header\nDSN_CHAIN      DS XL(L_DSLINK) 1st DSN chaining linked list record\nPACKED         DS D\nINFO_CODE      DS XL4        copy of S99INFO\nRETURN_CODE    DS XL4        copy of R15\nREASON_CODE    DS XL4        copy of S99ERROR\nSTAT_CODE      DS X          status code                       @2019jan\nSTAT_C_dup     equ x'80'     - DS concat is duplicated         @2019jan\nPROC_CODE      DS X          process code\n               DS XL2        reserved\nSAVE_DDN       DS XL10       saved DDname specification\nTEMP_DDN       DS XL10       temporary DDname specification\nOTHER_DSN      DS XL46       other DSN\nECB            DS F          Event Control Block\nDDN_PARM       DC A(0,0)     DDN PTR AND LENGTH\nDDN_RC         DS F          DDN validity check RC\nRC             DS F          SVC 99 common return code\nIF_CODE        DS H          SVC 99 information code\nRS_CODE        DS H          SVC 99 reason code\nRT_CODE        DS H          SVC 99 error code\nER_CODE        DS H          CCAT error return code\nDD_COUNT       DS H          DD concatenation counter\n                                       SPACE\n*-----------------------------------*\n*  COMMAND/OPERAND FLAGS            *\n*-----------------------------------*\nCOMMAND  DS    X             SUBCOMMAND\n$ON      EQU   X'80'         allocate/concatenate bit\n$TOP     EQU   X'40'         force to reallocate existing DSN\n$BOT     EQU   X'20'         reallocate existing DS to bottom  @2019jan\n$done    EQU   X'10'         DS has complied as requested      @2019jan\n$EMSG    EQU   X'08'         requested to display ERROR response\n$MSG     EQU   X'04'         .................... INFO  ........\n$NOMSG   EQU   X'02'         no msg will be prompted, just RC\n$LIST    EQU   X'01'         request to display concatenation\n                                       SPACE\n*-----------------------------------*\n*  VALIDATION FLAGS                 *\n*-----------------------------------*\nVALCFLAG DS    X             VALCFLAG\n$DSN     EQU   X'10'         validate DSN\n$DDN     EQU   X'20'         validate DDN\n$QUOTE   EQU   X'40'         1.  DS is enclose in quotes\n$PRESENT EQU   X'80'         2.  DS is present\n                                       SPACE\n*-----------------------------------*\n*  PROCESSING FLAGS                 *\n*-----------------------------------*\nCCATFLAG DS    X             CCAT processing error flag\n$NEW     EQU   X'80'         DDname is new at this time\n$ERRS99  EQU   X'40'         general SVC 99 error\n$ERRCVRY EQU   X'01'         error allocation recovery\n$ERRALC  EQU   X'02'         error allocation\n$ERRCON  EQU   X'04'         error concatenantion\n$ERRUNL  EQU   X'08'         error unallocation\n$ERRKWD  EQU   $ERRALC+$ERRCON+$ERRUNL\n                                       SPACE\n*-----------------------------------*\n*  ALLOCATION TEXT UNIT PLIST       *\n*-----------------------------------*\nALLOC_TUPLIST  DS  0F\nALLOC_DSN      DS F          PTR ==> Dataset name TU\nALLOC_TUPLIST_RETRY EQU *\nALLOC_DDN      DS F          PTR ==> DDname TU\nALLOC_STS      DS F          PTR ==> STATUS TU\nALLOC_ATR      DS F          PTR ==> ATTRIBUTE TU\nL_ALLOC_TUPLIST_RETRY EQU  *-ALLOC_TUPLIST_RETRY\nL_ALLOC_TUPLIST EQU  *-ALLOC_TUPLIST\nL_ALLOC_PERM    EQU  L_ALLOC_TUPLIST-4  TUPL limit for perm alloc\nL_ALLOC_TEMP    EQU  L_ALLOC_TUPLIST-8  TUPL limit for temp alloc\n                                       SPACE\n*-----------------------------------*\n*  INFO_RETRIEVAL TEXT UNIT PLIST   *\n*-----------------------------------*\nQRY_TUPLIST    DS 0F\nQRY_DDN  DS    F             PTR ==> DDname TU\nQRY_ATR  DS    F             PTR ==> ATTRibute TU\nQRY_DSN  DS    F             PTR ==> DSname TU\nL_QRY_TUPLIST EQU   *-QRY_TUPLIST\n*--- possible bits configuration of QRY_ATR ---------\n$SHR     EQU   X'08'         DSN share attribute\n$PRMCONC EQU   X'80'         permanently concatenanted\n$BUSY    EQU   X'40'         in use\n$PRMALLC EQU   X'20'         permanently allocated\n$DYNALLC EQU   X'10'         dynamically allocated\n                                       SPACE\n*-----------------------------------*\n*  DEALLOCATION TEXT UNIT PLIST     *\n*-----------------------------------*\nRELSE_TUPLIST DS 0F\nRELSE_DDN DS   F             PTR ==> DDname TU\nRELSE_ATR DS   F             PTR ==> attribute TU\nRELSE_DSN DS   F             PTR ==> Dataset name TU\nL_RELSE_TUPLIST EQU *-RELSE_TUPLIST\nL_RELSE_ALL    EQU L_RELSE_TUPLIST-8\nL_RELSE_ONE    EQU L_RELSE_TUPLIST-4\n                                       SPACE\n*-----------------------------------*\n*  CONCATENATION TEXT UNIT PLIST    *\n*-----------------------------------*\nCONCT_TUPLIST  DS 0F         PTR ==> concatenation TU\nCONCT_DDN      DS F\nCONCT_ATR      DS F\nL_CONCT_TUPLIST EQU *-CONCT_TUPLIST\n                                       SPACE\n*-----------------------------------*\n*  DECONCATENATION TEXT UNIT PLIST  *\n*-----------------------------------*\nDECON_TUPLIST  DS F          PTR ==> concatenation TU\n                                       SPACE\nDSTU_PTR DS    F             PTR ==> DSN TEXT UNIT\nDDTU_PTR DS    F             PTR ==> DDNAME TEXT UNIT\n                                       SPACE\n*-------------------------------------*\n*  VALIDITY CHECK PARAMETER LIST      *\n*-------------------------------------*\nCK_PDE_PLIST   DS 0F\nPDE_PTR  DS    F             PTR ==> PDE\nUSERWORD DS    F             PTR ==> workarea we gave to parse\nCK_MSG   DS    F             PTR ==> 2nd level msg we can give back\n                                       SPACE\n*-------------------------------------*\n*  MESSAGE TEXT AND POINTER           *\n*-------------------------------------*\nJOBSPEC  DC    A(0,0)        PTR and length  jobid in TIOT\nMSGPARM  DC    A(0,0)        PTR and length of string for substitution\nMSGSKEL  DS    XL12          PTRs and lengths of msg text skeleton\n*-------------------------------------*\n*  MESSAGES SKELETON  CONTROL BLOCK   *\n*-------------------------------------*\n         ORG   MSGSKEL\nSKLHDR   DS    XL4           msg header pointer\nSKLTXT   DS    XL4           msg trailer text pointer\nSKLHDRL  DS    XL2           msg header length\nSKLTXTL  DS    XL2           msg trailer text length\n         ORG\nMSGID    DS    H             msg count ID\nMSGLEN   DC    H'164'\n         DC    H'0'\nMSGLINE  DC    CL160'Data ...//... allocated as a new file ..'\n         ORG   MSGLINE\nMSGHDR   DS    XL8           MSG HEADER AREA\nMSGTEXT  DS    XL152         MSG TEXT AREA\n         ORG\nL_MSG    EQU   *-MSGLEN\nRC_TEXT  DC    C', RC=0000.' RC for msg line\n         ORG   RC_TEXT+5\nRC_MSG   DC    C'0000'       printable RC value\n         ORG\nL_CCATAREA     EQU *-CCATAREA\n          EJECT\n*-------------------------------------*\n*  MVS/ESA systems control blocks     *\n*            and data areas           *\n*-------------------------------------*\nCVTMAP   CVT   DSECT=YES     CVT mapping needed by CALLTSSR\n         IEFJESCT            JES control table\n         IEFZB505\n         IEFQMNGR\n         IEFTIOT1            TIOT\n         IEFJFCBN            JFCB\nL_CVT    EQU   *-CVTMAP\n         YREGS\n                                       SPACE\n*-------------------------------------*\n*  MESSAGES DIRECTORY CONTROL BLOCK   *\n*-------------------------------------*\nMSGBLOK  DSECT\nMSGCODE  DS    XL2           ERROR information code\nMSGFLAG  DS    X             flag bits\n         DS    X             reserved\nMSGSKLA  DS    XL2           relative text skeleton address\nMSGBLOKL EQU   *-MSGBLOK\n                                       SPACE\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCCAT": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x012O\\x01\\x012O\\x061\\x00\\r\\x00\\r\\x00\\x00\\xc4\\xc5\\xd9\\xe4`\\xe2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-11-20T00:00:00", "modifydate": "2001-11-20T06:31:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "DERU-S"}, "text": "//JCCAT JOB (CCT01),'ASSEMBLE CCAT       ',\n//         CLASS=A,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n// JCLLIB ORDER=CAI.PROCLIB\n//*\n//  EXEC ASSEMBLE,NAME=CCAT,\n//          MEMBER=DERCCT,\n//          APARM='OBJECT,NODECK,ALIGN',\n//          LPARM='LIST',\n//          SRCLIB='CAI.OPS.ASM',\n//          LNKLIB='CAI.CA90S.CAILIB',\n//          MACLIB='SYS1.MACLIB'\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCCATS": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00$\\x01\\x012O\\x01 #o\\x12%\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-11-20T00:00:00", "modifydate": "2020-08-23T12:25:24", "lines": 13, "newlines": 13, "modlines": 0, "user": "SLBD"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n// JCLLIB ORDER=SBGOLOB.CBT497.FILE535\n//*\n//  EXEC ASSEMBLS,NAME=CCAT,\n//          MEMBER=CCAT,\n//          APARM='OBJECT,NODECK,ALIGN,FLAG(5)',\n//          LPARM='LIST',\n//          SRCLIB='SBGOLOB.CBT497.FILE535',\n//          LNKLIB='SYS1.W$$.LINKLIB',\n//          MACLIB='SYS1.MACLIB'\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADLIB": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x19\\x02\\x8f\\x01\\x19\\x02\\x8f\\x14#\\x00_\\x00_\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-28T00:00:00", "modifydate": "2019-01-28T14:23:14", "lines": 95, "newlines": 95, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT535/FILE535.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT535", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}