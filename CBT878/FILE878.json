{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013202000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE878.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE878.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x10'", "DS1TRBAL": "b'<n'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x07\\x98\\x00\\x06\\x07\\x98\\x00\\t\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x009\\x01\\x120o\\x01\\x120o\\x13C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-11-01T00:00:00", "modifydate": "2012-11-01T13:43:39", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  878\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE878\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 10 MEMBERS COUNTED; CUMULATIVE SIZE IS 930 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/01/12    13:43:39    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ASMLINK": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x004\\x01\\x12(O\\x01\\x120o\\x10G\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-10-10T00:00:00", "modifydate": "2012-11-01T10:47:34", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT485.FILE878\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT485.FILE878(BURN)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB485878\n SETCODE AC(1)\n NAME    BURN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE878": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x005\\x01\\x120o\\x01\\x120o\\x13C\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-11-01T00:00:00", "modifydate": "2012-11-01T13:43:35", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 878 is from Joe Reichman and contains an APF-authorized   *   FILE 878\n//*           TSO command to forcibly terminate an address space.   *   FILE 878\n//*           This command is newly written, and was inspired by    *   FILE 878\n//*           the old TSO BURN command, but it is completely new.   *   FILE 878\n//*           It has been tested to z/OS 1.13.  It was also tested  *   FILE 878\n//*           to work as far back as ESA 5.2.2.                     *   FILE 878\n//*                                                                 *   FILE 878\n//*           This command is useful when an address space          *   FILE 878\n//*           (system or user) is causing trouble in the system,    *   FILE 878\n//*           and it needs to be restarted.  And you can use this   *   FILE 878\n//*           command to get rid of that address space when you     *   FILE 878\n//*           can't easily do it by conventional means, which are   *   FILE 878\n//*           the CANCEL or FORCE operator console commands.        *   FILE 878\n//*                                                                 *   FILE 878\n//*           This is a handy emergency tool to keep in your        *   FILE 878\n//*           tool kit.  A HELP member is included in this file.    *   FILE 878\n//*                                                                 *   FILE 878\n//*           email:  joereichman@optonline.net                     *   FILE 878\n//*                                                                 *   FILE 878\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BEGIN": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12(O\\x01\\x12(O\\x01@\\x006\\x006\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-10-10T00:00:00", "modifydate": "2012-10-10T01:40:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n&NAME    BEGIN &BASE=\n&NAME    CSECT\n&NAME    AMODE ANY\n&NAME    RMODE ANY\n         YREGS\n         GBLA &WSLEN\n         LCLC  &B(4),&C(4),&D,&E,&F,&G,&H,&I,&J,&K\n         LCLA &VAR,&NCODE,&N\n&VAR     SETA 1\n         AIF  ('&BASE'(1,1) EQ '(').MULT\n&B(1)    SETC '&BASE(&VAR)'\n         AGO  .SETUP\n.MULT    ANOP\n&NCODE   SETA N'&BASE\n.LOOP    AIF  (&VAR GT &NCODE).SETUP\n&B(&VAR) SETC '&BASE(&VAR)'\n&VAR     SETA &VAR+1\n         AGO  .LOOP\n.SETUP   ANOP\n         USING *,R15                   BEGINING\n         STM   R14,R12,12(R13)         STORE USER REGISTERS\n&VAR     SETA  2\n         DROP R15\n         LR   &B(1),R15                GET FIRST\n.LOOP2   AIF  (&VAR GT &NCODE).USING\n         LA   &B(&VAR),4095(&B(&VAR-1))\n         LA   &B(&VAR),1(,&B(&VAR))\n&VAR     SETA &VAR+1\n         AGO  .LOOP2\n.USING   ANOP\n&N       SETA  &NCODE-1\n&VAR     SETA  1\n.LOOP3   AIF   (&VAR GT &N).SETREG\n&C(&VAR) SETC  ','\n&VAR     SETA  &VAR+1\n         AGO   .LOOP3\n.SETREG  ANOP\n&D       SETC  '&B(1)'\n&E       SETC  '&C(1)'\n&F       SETC  '&B(2)'\n&G       SETC  '&C(2)'\n&H       SETC  '&B(3)'\n&I       SETC  '&C(3)'\n&J       SETC  '&B(4)'\n&K       SETC  '&C(4)'\n         USING &NAME,&D&E&F&G&H&I&J&K\n         STORAGE OBTAIN,LENGTH=&WSLEN\n         ST    R13,4(,R1)              STORE BACK LINK\n         LR    R13,R1                  POINT TO CURRENT\n         ST    R13,8(,R13)             FORWARD LINK\n         USING WSDSECT,R13\n.FIN     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BURN": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x120o\\x01\\x120o\\x121\\x02\\xa6\\x02q\\x00\\x00\\xd1\\xd6\\xc5\\xd9@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2012-11-01T00:00:00", "modifydate": "2012-11-01T12:31:24", "lines": 678, "newlines": 625, "modlines": 0, "user": "JOER"}, "text": "         TITLE 'BURN - TERMINATE A JOB OR ADDRESS SPACE'\n********************************************************************\n*        'BURN' - TSO COMMAND TO TERMINATE AN ADDRESS SPACE        *\n********************************************************************\n*\n*        WRITTEN BY.     JOSEPH REICHMAN\n*\n*        DATE WRITTEN.   NOVEMBER 01 2012.\n*\n*        DATE UPDATED.\n*\n*        ATTRIBUTES.     RE-ENTRANT.  APF-AUTHORIZED TSO COMMAND.\n*\n*        DESCRIPTION.\n*\n*         THIS TSO COMMAND ALLOWS SYSTEMS PROGRAMMERS TO\n*         TERMINATE NEARLY ANY ADDRESS SPACE IN THE SYSTEM\n*         IF THAT ADDRESS SPACE IS CAUSING TROUBLE AND IT\n*         IS DIFFICULT TO GET RID OF IT BY CONVENTIONAL MEANS.\n*\n*        SYNTAX.\n*\n*         BURN  \u00dd JOBNAME(jobname) | ASID(hhhh)  \u00a8\n*               \u00dd JOB(jobname)     | ASID(hhhh)  \u00a8\n*\n*          Answer the prompts, and enter the job number to\n*           be burned, in hex.\n*\n*          * is a wildcard in the JOBNAME, if entered as jjj*\n*\n*          If no JOB or ASID entered, then the program will\n*           issue a message and terminate.\n*\n*          If J entered, the program will prompt for jobname.\n*\n*          If A entered, the program will prompt for ASID number.\n*\n*          If an incorrect prompt is entered, the program will\n*           prompt for a correct answer.\n*\n*          If 3 incorrect tries are entered, then the program\n*           will terminate.  (This is a convenient way to get out\n*           of the program.)\n*\n*\n*        LOG OF CHANGES.\n*\n*\n*\n********************************************************************\n         EJECT\n*                                BEGIN WORK AREA FOR REENTRANCY\n         WSDSECT\nMYPPL    DS   7F\nWSANS    DS    F\nWSASID   DS    X\n         DS    X\nWS_ASID  DS    PL2\nWORK_ASID DS   CL4                     WORK ASID\n         DS    X\nRTMSAVE  DS    CL72\nWSJOB    DS    CL8\nINNAME   DC    CL8' '\nSAVE2    DS    F\nDBLWD    DS    D\nASID_BUFF DS   CL80\nBURNED    DS   CL80\n*\nBURNCMD  DC    CL5'BURN '\nASKMSG   DC    CL40'NOT A TSO USER STARTING. OK?'\nPPL_ECB  DS    F\nMODESET_LIST MODESET KEY=ZERO,MODE=SUP,MF=L\n*\nMODESET_LIST1 MODESET KEY=NZERO,MODE=PROB,MF=L\n*\nREPLY    DS    CL10\nERRMSG   DS    0CL50\n         ORG   ERRMSG\n         DC    CL50' '\n         ORG   ERRMSG\nEMSG     DC    C'BURN000I:           NOT FOUND'\n         ORG\nSAVE14T3 DS     6F\nESTAELST ESTAEX ,MF=L              ESTAEX PARAMETER LIST                  92\nWRKASID  DC    CL4' '\n         ESTPARM\n         WSEND\n*                                  END WORK AREA FOR REENTRANCY\nBURN     BEGIN  BASE=RBASE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                  TEST IF PROGRAM IS RUN AUTHORIZED.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         STM    R14,R3,SAVE14T3    TESTAUTH USES THESE REGISTERS\n         TESTAUTH FCTN=1           ARE WE AUTHORIZED?\n         LTR    R15,R15            TEST THE RETURN CODE.\n         BNZ    NOTAUTHM           NOT ZERO, TELL NOT AUTHORIZED.\n         LM     R14,R3,SAVE14T3    RESTORE REGS USED BY TESTAUTH\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRCPPL    EQU    7                  COMMAND PROCESSOR PARAMETER LIST\nRPPL     EQU    8                  PARSER PARAMETER LIST\nRSAVE    EQU    13\nRBASE    EQU    12\nRCVT     EQU    11\nRASCB    EQU    10\nRASVT    EQU    9\nRCNT     EQU    8\nRPSCB    EQU    6\nRPDL     EQU    5\nXLNK     EQU    14\n         SPACE  5\n         L      R1,4(,R13)                   GET ORIGINAL R13\n         L      R1,24(,R1)                   POINT TO ORIGINAL R1\n         USING  CPPL,RCPPL\n         LR     RCPPL,R1                     RCPPL\n         LA     RPPL,MYPPL                   PARSE PARAMETER LIST\n         USING  PPL,RPPL                     USING\n         LA     R0,PPL_WK_LEN\n         STORAGE OBTAIN,LENGTH=(R0),SP=0     GET STORAGE FOR PPL\n         ST    R1,PPLUWA                     STORE WORKREA\n         MVC   ASIDS-PPL_WORK(4,R1),=4X'FF'  MOVE ENDPTR\n         USING PPL_WORK,R1\n         L     R3,X'10'                      CVT\n         USING CVT,R3\n         L     R3,CVTASVT                    ASVT POINTER\n         DROP  R3\n         USING ASVT,R3\n         DROP  R1\n         MVC    PPLUPT,CPPLUPT               PICK IT UP\n         MVC    PPLECT,CPPLECT               FROM CP PARM\n         XC     PPL_ECB,PPL_ECB               PRIME\n         LA     R1,PPL_ECB\n         ST     R1,PPLECB\n         MVC    PPLPCL,=A(CANCEL)            IKJPARMS\n         LA     R1,WSANS                     ANSWER AREA\n         ST     R1,PPLANS\n         XC     WSANS,WSANS\n         MVC    PPLCBUF,CPPLCBUF             CPPL BUF\n         XC     PPLVEWA,PPLVEWA              * NO VEWA\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\nVALIDATE DS    0H\n         MVC   WSJOB,=8C' '                  INITIALIZE TO SPACES\n         L     RPDL,WSANS\n         USING  PARSEAT,RPDL\n*\n*        VALIDATE JOBNAME\n*\n         CLI   JOBNAME+1,0              Q. JOBNAME NAME ENTERED\n         BE    GET_ASID                 NO; CHECK ASID\n         TM    JOBX+6,X'80'             Q. JOBNAME ENTERED\n         BZ    GET_ASID                 A; NO\n         L     R1,JOBX                  GET JOB PARAMETER\n         LH    R2,JOBX+4                GET LENGTH\n         BCTR  R2,0\n         EX    R2,MOVEJOB\n         B     GET_ASID\nMOVEJOB  MVC   WSJOB(0),0(R1)\n*\n*        VALIDATE ASID\n*\nGET_ASID DS    0H\n         CLI   ASID+1,0                 Q. ONLY NAME ENTERED\n         BNE   LIST_ASID                NO; CHECK IF THERE IS A JOB\n         TM    ASIDX+6,X'80'            ASID ENTERED\n         BNZ   LIST_ASID\n         CLC   WSJOB,=8C' '             Q. ANYTHING ENTERED\n         BNE   LIST_ASID\n         TPUT  NOPARM,L'NOPARM          NO PARAMS ENTERED\n         B     FINISH_UP\nLIST_ASID DS   0H\n         L     R11,PPLUWA               GET PARSE PARAMETER LIST\n         USING PPL_WORK,R11             ADDRESS DSECT\n         CLC   JOBERCTR,=H'3'           MAX REACHED?\n         BE    FINISH_UP                GET OUT\n         CLC   ASIDERCTR,=H'3'\n         BE    FINISH_UP\n         LA    R10,ASIDS\n         TPUT  ASIDLIST,L'ASIDLIST      ASID LIST MESSAGES\n         LA    R9,0                     R9 --> PUT CTR\nADDR_LOOP DS  0H\n         CLC  0(4,R10),=X'FFFFFFFF'     Q. END\n         BE   JOB_END                    YES\n         TPUT  0(R10),27                WRITE OUT ASID\n         LA    R10,27(,R10)             NEXT ENTRY\n         B     ADDR_LOOP\nJOB_END  DS    0H\n         DROP  R11\n         TPUT  BURNMESS,L'BURNMESS\n         TPUT  VALHEX,L'VALHEX\nTGET     DS    0H\n         TGET  ASID_BUFF,L'ASID_BUFF\n         OC    ASID_BUFF(L'ASID_BUFF),=80X'40'\n*------------------------------------------------------------*\n*            R9 --> INPUT CTR YOU GET 3 CHANCES              *\n*                    FOR ALL ERRORS                          *\n*------------------------------------------------------------*\n         LTR   R1,R1                    Q. ANY INPUT\n         BNZ   HEX_ASID\n         AH    R9,=H'1'                 ADD 1 TO COUNTER\n         CH    R9,=H'3'                 3 TIMES ?\n         BE    FINISH_UP                GO HOME\n         B     JOB_END                  TRY AGAIN\nHEX_ASID DS    0H\n         CH    R1,=H'4'                 4 OR LESS ENTERED\n         BH    MOVE_ASID                NO; CHECK IF ONLY 1\n*------------------------------------------------------------*\n*            INPUT IS 4 OR LESS                              *\n*------------------------------------------------------------*\n         MVC   WORK_ASID,=4CL1'0'       INITIALIZE TO ZEROS\n         LA    R2,ASID_BUFF             POINT TO END OF BUFFER\n         LA    R2,0(R1,R2)              POINT TO END\n         BCTR  R2,0                     DOWN BY 1\n         LA    R3,WORK_ASID+3           POINT TO END WORK\nASID_LP   DS   0H\n         MVC   0(1,R3),0(R2)            MOVE LAST DIGIT\n         BCTR  R3,0                     DOWN BY 1\n         BCTR  R2,0                     DITTO\n         BCT   R1,ASID_LP               LOOP THRU\n         LA    R15,VAL_ASID             VALIDATE USR INP\n         BALR  R14,R15                  VALIDATE\n         LTR   R15,R15\n         BZ    CONV_ASID                CONVERT IT\n         AH    R9,=H'1'                 ADD 1 TO CTR\n         CH    R9,=H'3'                 5 TIMES\n         BE    FINISH_UP                GO HOME\n         B     INVADD                   ISSUE MESSAGE\n*------------------------------------------------------------*\n*            INPUT IS GREATER THEN 4                         *\n*------------------------------------------------------------*\nMOVE_ASID DS   0H\n         SH    R1,=H'4'                 LEAVE 4 BYTES\n         LA    R2,ASID_BUFF             POINT TO BUFFER\n         LA    R2,0(R1,R2)              POINT TO SIGNIFICANT\n         MVC   WORK_ASID,0(R2)          MOVE IT\n         LA    R15,VAL_ASID             VALIDATE USR INPUT\n         BALR  R14,R15                  VALIDATE\n         LTR   R15,R15\n         BZ    CONV_ASID                CONVERT IT\n         AH    R9,=H'1'                 ADD 1 TO CTR\n         CH    R9,=H'3'                 3 TIMES\n         BE    FINISH_UP                GO HOME\n         B     INVADD                   ISSUE MESSAGE\nCONV_ASID DS   0H\n         MVC   WRKASID(4),WORK_ASID     SAVE UNTRANSLATED ASID\n         TR    WORK_ASID(4),TRTABLE     TRANSLATE TO HEX\n         PACK  WSASID(3),WORK_ASID(5)   STRIP SIGN\nCALL_TERM DS   0H\n         MVC   MODESET_LIST(MODESET_LEN),MODESET_CONS\n\n         MODESET MF=(E,MODESET_LIST)\n\n         LH   R10,WSASID                SET ASID\n         LR   R9,R13                    SAVE R13\n         LA   R13,RTMSAVE               RTM SAVE AREA\n         CALLRTM TYPE=MEMTERM,ASID=(R10),COMPCOD=100\nRETRYC03 DS    0H                       retry from c03\n         LR    R13,R9                   RESTORE R13\n         LTR   R15,R15                  WAS IT BURNED\n         BZ    BURNY                    YES IT WAS\n         MVC   BURNED,BURNNO            MOVE IN MESSAGE\n         LA    R10,BURNED               GET MESSAGE\n         MVC   JOBNO-BURNNO(8,R10),WSJOB     MOVE IN JOB\n         MVC   ASIDNO-BURNNO(4,R10),WRKASID\n         TPUT  BURNED,L'BURNED\n         B     SETOFF                   SET AUTHORIZATION OFF\nBURNY    DS    0H\n         MVC   BURNED,BURNOK\n         LA    R10,BURNED               MOVE MESSAGE\n         MVC   JOBYES-BURNOK(8,R10),WSJOB\n         MVC   ASIDYES-BURNOK(4,R10),WRKASID\n         TPUT  BURNED,L'BURNED\nSETOFF   DS    0H\n         MVC   MODESET_LIST1(MODESET_LEN1),MODESET_CONS1\n*\n         MODESET MF=(E,MODESET_LIST1)\n         B     FREENOUT\nNOTAUTHM DS    0H\n         TPUT  AUTHMSG,L'AUTHMSG\n         EXIT  RC=0\n*\nFREENOUT DS    0H                  FREE GOTTEN STORAGE AND GET OUT.\n\n*\nFINISH_UP DS   0H\n         LA    R0,PPL_WK_LEN\n         LA    RPPL,MYPPL\n         L     R1,PPLUWA\n*\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1),SP=0 RELEASE WORKAREA    =(R0),AD\n*\n         EXIT  RC=0\n*\n*\n*\nINVADD   DS    0H\n         TPUT  INVADDR,L'INVADDR\n         B     TGET\n*\n*\n*\nASIDLOOK DS    0D\n         STM   R14,R12,12(R13)     STORE USER REGISTERS\n         LR    R12,R15             R12 BASE AT THIS POINT\n         USING ASIDLOOK,R12        ADDRESS EXIT\n         USING ASCB,R6             ASCB ADDRESS\n         L     R2,0(,R1)           GET PDE ENTRY\n         L     R3,X'10'            CVT\n         USING CVT,R3\n         L     R3,CVTASVT          ASVT POINTER\n         DROP  R3\n         USING ASVT,R3\n         L     R4,ASVTMAXU         MAXIMUM ASID\n         LA    R5,ASVTFRST         STARTING ASID\n         XR    R3,R3               CLEAR R3\n         LH    R3,4(,R2)           LENGTH\n         BCTR  R3,0                for execute\n         L     R2,0(,R2)           GET TEXT\n         L     R7,4(,R1)           GET WORK AREA\n         USING PPL_WORK,R7\n         STH   R3,PARMLEN          SAVE LENGTH\n         LA    R11,ASIDS           GET ASID ENTRY\n*\n*\n*\n         LA    R2,1(R3,R2)         POINT TO END\n         BCTR  R2,0                BACK ONE\n         BCTR  R2,0                ONE MORE\n         MVC   WORKASID,=4C'0'     INITIALIZE ASID\n         MVC   WORKASID+2(2),0(R2) move asid in\n         TR    0(2,R2),TRTABLE     TRANSLATE A - F -> X'0A - 0F'\n         PACK  WSASID(2),0(3,R2)   MAKE ASID 1 BYTE\n         XR    R8,R8               CLEAR R8\n         IC    R8,WSASID           GET ASID IN QUESTION\n         SLL   R8,2                MULTIPLY BY 4\n         LA    R5,0(R8,R5)         POINT TO ASCB ENTRY\n         LA    R15,GETASCB         GET ASCB ENTRY\n         BALR  R14,R15\n         CLC   0(4,R6),=C'ASCB'    Sanity check\n         BE    SET_JOB#            OK\n         TPUT  INV_ADD,L'INV_ADD   invalid asid\n         LH    R9,ASIDERCTR        GET ERROR CTR\n         CH    R9,=H'3'            More than 3 ?\n         BL    ASIDRE              No. Retry.\n         LA    R15,12              Yes. Code 12.\n         B     RETURN\nASIDRE   DS    0H\n         AH    R9,=H'1'            1 MORE\n         STH   R9,ASIDERCTR        STORE IT\n         LA    R15,8               Code 8.\n         B     RETURN\nSET_JOB# DS    0H\n         LA    R15,SET_JOBNAME\n         BALR  R14,R15\n         CLC   0(4,R11),=4X'FF'    Was Jobname entered\n         BE    SET_IT              No set it\n         LA    R10,ASIDS           Get asid\nIS_IT    DS    0H\n         CLC   ASID#-ASIDS(4,R10),WORKASID\n         BNE   CK_END              IT IS OKAY\n         LA    R10,JOB#-ASIDS(R10) Point to asid\n         LA    R11,ASIDS           Point to beginning\n         B     SET_IT\nCK_END   DS    0H\n         CLC   0(4,R10),=X'FFFFFFFF'\n         BE    MISMAT              MisMatch\n         LA    R10,27(,R10)        Next\n         B     IS_IT\nMISMAT   DS    0H\n         TPUT  PARMMIS,L'PARMMIS\n         LH    R9,ASIDERCTR        Get Error counter\n         CH    R9,=H'3'            Max Error\n         BL    SETRE               Reprompt\n         LA    R15,12              Parameter mismatch\n         B     RETURN\nSETRE    DS    0H\n         AH    R9,=H'1'            1 MORE\n         STH   R9,ASIDERCTR        STORE IT\n         LA    R15,8               Parameter mismatch\n         B     RETURN\nSET_IT   DS    0H\n         LA    R15,SET_ENTRY       SET TABLE ENTRY\n         BALR  R14,R15             GO FOR IT\n         XR    R15,R15             GOOD RETURN\nRETURN   DS    0H\n         L     R14,12(,R13)\n         LM    0,12,20(R13)\n         BR    R14\n*\n*\n*\nERROR0   DS    0H\n         MVC   ERRMSG+24(8),=CL8'BURNED'\nERROR    DS    0H\n         MVC   ERRMSG+11(8),INNAME\n         TPUT  ERRMSG,50\n         B     RETURN\n*\n*  JOBX EXIT\n*\nJOBLOOK  DS    0D\n         STM   R14,R12,12(R13)     STORE USER REGISTERS\n         LR    R12,R15             R12 BASE AT THIS POINT\n         USING JOBLOOK,R12         ADDRESS EXIT\n         USING ASCB,R6\n         L     R2,0(,R1)           GET PDE ENTRY\n         XR    R3,R3               CLEAR R3\n         LH    R3,4(,R2)           LENGTH\n         L     R2,0(,R2)           GET TEXT\n         BCTR  R3,0                FOR EXECUTE\n         L     R7,4(,R1)           GET WORK AREA\n         STH   R3,PARMLEN          SAVE LENGTH\n         LA    R11,ASIDS           ADDRESS DSECT\n         L     R3,X'10'            CVT\n         USING CVT,R3              ADDRESS CVT\n         L     R3,CVTASVT          ASVT POINTER\n         DROP  R3\n         USING ASVT,R3\n         L     R4,ASVTMAXU         MAXIMUM ASID\n         LA    R5,ASVTFRST         STARTING ASID\n         MVC   JOBNME,=8C' '       SPACE IT OUT\n         LH    R3,PARMLEN          GET LENGTH\n         EX    R3,SET_JOB          MOVE JOB\nJOB_NAME DS    0H\n         LA    R15,GETASCB         RTN ENTRY POINT\n         BALR  R14,R15             GET ASCB\n         LTR   R4,R4               ALL DONE\n         BNZ   GET_JOB\n         LA    R15,ASIDS\n         CR    R11,R15             GET ANY JOBS\n         BE    JOB_ERR             NO; JOBNAME NOT FOUND\n         B     GOOD_RET1           OTHERWISE RETURN\nGET_JOB  DS    0H\n         L     R10,ASCBJBNI        INITIATOR JOB\n         LTR   R10,R10             ANY ADDRESS\n         BNZ   IS_JOB\n         L     R10,ASCBJBNS        STARTED TASK\nIS_JOB   DS    0H\n         TRT   JOBNME,ASTBL        LOOK FOR AN ASTERISK\n         BZ    NOWILD\n         LA    R15,JOBNME          GET BEGINNING ADDRESS\n         SR    R1,R15              FIND TRUE LENGTH\n         LA    R15,SET_ENTRY       ADD TO TABLE\n         BCTR  R1,0                DECREMENT BY 1\n         B     EXEC                EXEC COMPARE\nNOWILD   DS    0H\n         LA    R1,7                8 bytes trailing blanks\nEXEC     EX    R1,COMP             excute compare\n         BNE   JOB_NAME\n*\n*   WILDCARD NO NEED TO CHECK ENTRY FOR VALID ASID\n*\n         CLM   R2,B'0001',=C'*'    Wild Card Found?\n         BE    SET_IT#             Then set it\n         CLC   0(4,R11),=4X'FF'    Asid entered\n         BE    SET_IT#             No; set entry\n         UNPK  WORKASID(5),ASCBASID-ASCB(3,R6)\n         TR    WORKASID,TRTBL\n         CLC   ASID#-ASIDS(4,R11),WORKASID\n         BE    SET_IT#             IT IS OKAY\n         TPUT  PARMMIS,L'PARMMIS\n         LH    R9,JOBERCTR         Get error counter\n         CH    R9,=H'3'            More than 3\n         BL    JOBRE\n         LA    R15,12\n         B     RETURN1\nJOBRE    DS    0H\n         AH    R9,=H'1'            ADD 1\n         STH   R9,JOBERCTR         ADD IT\n         LA    R15,8               PARAMETER MISMATCH\n         B     RETURN1\nSET_IT#  DS    0H\n         LA    R15,SET_ENTRY       ADD TO TABLE\n         BALR  R14,R15             ADD IT\n         B     JOB_NAME            LOOK FOR MORE\nCOMP     CLC   0(0,R10),JOBNME     Q-IS THIS THE JOB NAME WE LOOK FOR?\n         LA    R15,4               RETURN CODE 4\n         B     RETURN1             FINISH UP\n*\nJOB_ERR  DS    0H\n         TPUT  NOJOB,L'NOJOB\n         LH    R9,JOBERCTR         GET ERROR CTR\n         CH    R9,=H'3'            MAX ERROR COUNTER?\n         BL    REJOB               RE-PROMPT\n         LA    R15,12\n         B     RETURN1             GO BACK\nREJOB    DS    0H\n         AH    R9,=H'1'            1 MORE\n         STH   R9,JOBERCTR         STORE IT\n         LA    R15,8\n         B     RETURN1\nGOOD_RET1 DS    0H\n         XR    R15,R15             GOOD RETURN\nRETURN1  DS    0H\n         L     R14,12(,R13)\n         LM    0,12,20(R13)\n         BR    R14\nSET_JOB  MVC   JOBNME(0),0(R2)\n*\n*   GETASCB GET ASCB ENTRY POINTED TO BY ASVT\n*\nGETASCB  DS    0H\n         DROP   R12              DROP BASE\n         USING  *,R15\n*       R6 --> ASCB\n*  CHECK VECTOR TABLE ADDRESS FOR VALID ADDRESS\n*\n*\nSCAN_ASVT DS   0H\n         TM    0(R5),X'80'     ASCB USED\n         BO    ASCB_NEXT\n         L     R6,0(,R5)       GET ASCB ENTRY\n         LTR   R6,R6           Q. AVALID ADDRESS\n         BNZ   BUMP_ASVT       SCAN ASVT\n         XR    R4,R4           CLEAR ASVT COUNT\n         BR    XLNK            GO BACK\nBUMP_ASVT DS   0H\n         A     R5,=F'4'        NEXT\n         BCTR  R4,0            DECREMENT MAX COUNT\n         BR    XLNK            GO BACK\nASCB_NEXT DS   0H\n         A     R5,=F'4'        NEXT\n         BCT   R4,GETASCB      NEXT\n         BR    XLNK\n*\n*    ASID FOUND SET THE JOBNAME\n*\nSET_JOBNAME DS 0H\n         USING  *,R15\n         L    R10,ASCBJBNI     INITIATOR JOB\n         LTR  R10,R10          ANY ADDRESS\n         BNZ  MOVE_JOB\n         L    R10,ASCBJBNS     STARTED TASK\nMOVE_JOB DS   0H\n         MVC  JOBNME,0(R10) MOVE JOBNAME\n         BR   XLNK\n*\n*   ASID OR JOBNAME FOUND SET IT IN THE TABLE\n*\nSET_ENTRY DS   0H\n         USING  *,R15\n         MVC   0(5,R11),=C'ASID='        MOVE ASID LITERAL\n         UNPK  5(5,R11),ASCBASID(3)      UNPK ASID\n         TR    5(4,R11),TRTBL\n         MVI   10(R11),X'40'\n         MVC   11(8,R11),=C'JOBNAME='\n         MVC   19(8,R11),0(R10)          MOVE JOB IN\n         LA    R11,27(,R11)              NEXT\n         MVC   0(4,R11),=4X'FF'          SET END MARKER\n         BR    R14\n*\n*     VALID DATE THAT THE ASID IS IN THE TABLE\n*\nVAL_ASID DS   0H\n         USING *,R15\n         L     R7,PPLUWA          RESET ADDRESSING\n         LA    R10,ASIDS          GET LIST OF ASIDS\nASID_LOOP DS   0H\n         CLC   0(4,R10),=4X'FF'   END OF TABLE\n         BE    ERR_INPUT          NOT ON LIST\n         CLC   WORK_ASID,5(R10)   Q, ON LIST\n         BE    ONLIST             YES;\n         LA    R10,27(,R10)       BUMP UP TABLE\n         B     ASID_LOOP\nERR_INPUT DS   0H\n         LA    R15,4              ERROR\n         BR    R14                GO BACK\nONLIST   DS    0H\n         MVC   WSJOB,JOB#-ASIDS(R10) MOVE JOBNAME\n         XR    R15,R15            EVERYTHING OK\n         BR    R14                GO BACK\n*\nINVADDR  DC    C'ASID ENTERED NOT ON LIST. PLEASE RE-ENTER...'\nBURNMESS DC    C'WHICH ADDRESS SPACE WOULD YOU LIKE TO BURN ?'\nVALHEX   DC    C'  ENTER ITS VALUE IN HEX:'\nINVASID  DC    C'ENTER VALID HEX CHARACTERS FOR ASID:'\nNOPARM   DC  C'AT LEAST ONE PARAMETER MUST BE ENTERED: JOBNAME OR ASID'\nASIDLIST DC    C'THE FOLLOWING ASID ARE VALID FOR THE JOBNAME:'\nLOADFAIL DC    C'Recovery routine load failed.....'\nINV_ADD  DC    C'ASID NOT FOUND ..'\nJOBNTFD  DC    C'JOBNAME NOT FOUND..'\nAUTHMSG  DC    C'IKJ56500I COMMAND BURN NOT FOUND'\nPARMMIS  DC    C'PARAMETER MISMATCH'\nNOJOB    DC    C'JOBNAME NOT FOUND'\nBURNOK   DS    0CL80\n         DC    C'JOBNAME '\nJOBYES   DC    C'XXXXXXXX'\n         DC    C' FOR '\n         DC    C'ASID '\nASIDYES  DC    CL4' '\n         DC    C' BURNED'\nRESOK    EQU   *-BURNOK\n         DC    (80-RESOK)C' '\nBURNNO   DS    0CL080\n         DC    C'JOBNAME '\nJOBNO    DC    C'XXXXXXXX'\n         DC    C' FOR '\n         DC    C'ASID '\nASIDNO   DC    CL4' '\n         DC    C' NOT BURNED'\nRESNO    EQU   *-BURNNO\n         DC   (80-RESNO)C' '\nTRTABLE  DS    0CL255\n         DC    193X'00'\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'\n         DC    C'0123456789'\n*\nTRTBL    DC   0CL255\n         DC   240X'00'\n         DC   C'0123456789ABCDEF'\n*\nASTBL    DC   255X'00'\n         ORG  ASTBL+C'*'\n         DC   C'*'\n         ORG\n*\nMODESET_CONS MODESET KEY=ZERO,MODE=SUP,MF=L\nMODESET_LEN EQU *-MODESET_CONS\n*\nMODESET_CONS1 MODESET KEY=NZERO,MODE=PROB,MF=L\nMODESET_LEN1 EQU *-MODESET_CONS1\n*\n         LTORG\n         DS    0D\nCANCEL   IKJPARM DSECT=PARSEAT\nJOBNAME  IKJKEYWD\n         IKJNAME  'JOBNAME',SUBFLD=JOB\nASID     IKJKEYWD\n         IKJNAME  'ASID',SUBFLD=ASIDF\nDUMP     IKJKEYWD\n         IKJNAME  'DUMP',SUBFLD=DUMPF\n*\n*   SUBFIELDS\n*\nJOB     IKJSUBF\nJOBX     IKJIDENT 'JOBNAME',FIRST=ANY,MAXLNTH=8,PROMPT='JOBNAME',VALIDCX\n               K=JOBLOOK,OTHER=ANY,ASTERISK\nASIDF    IKJSUBF\nASIDX    IKJIDENT 'ASID',FIRST=ALPHANUM,OTHER=ALPHANUM,PROMPT='ASID',VAX\n               LIDCK=ASIDLOOK\nDUMPF    IKJSUBF\nDUMPX    IKJIDENT 'DUMP',FIRST=ALPHA,MAXLNTH=3\n         IKJENDP\nADDR     DS    0H\nMOVE     MVC   INNAME(8),0(R2)      IF A TSO COMMAND PARAMETER\nCLCCMD   CLC   0(0,R2),BURNCMD      IS IT BURN COMMAND?\nPACK     PACK  PAREA(0),INNAME(0)\nK8       DC    H'8'\nPAREA    DC    D'0'\nK70      DC    X'00000070'\n         CVT   DSECT=YES,LIST=YES\n EJECT\n         IHAASVT\n EJECT\n         IHAASCB\n EJECT\n         IKJCPPL\n EJECT\n         IKJPPL\nPPL_LEN  EQU   *-PPL\nPPL_WORK   DSECT\nJOBNME     DS   CL8\nPARMLEN    DS   H\nWORKASID   DS   CL4\nASIDERCTR  DS   H\nJOBERCTR   DS   H\n           DS   C\nASIDS      EQU  *\nASIDLIT    DS   CL5\nASID#      DS   CL4\n           DS   X\nJOBLIT     DS   CL9\nJOB#       DS   CL8\nPPLLEN     EQU  *-ASIDS\n           DS    100CL(PPLLEN)        100 ENTRIES\nPPL_WK_LEN EQU  *-PPL_WORK\n EJECT\n         IKJPSCB\n         END   BURN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BURN#": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x120o\\x01\\x120o\\x12T\\x00`\\x00;\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2012-11-01T00:00:00", "modifydate": "2012-11-01T12:54:48", "lines": 96, "newlines": 59, "modlines": 0, "user": "HELP"}, "text": ")F FUNCTION -\n\n  The TSO command BURN will terminate an address space,\n  as if you would FORCE it.  BURN operates by issuing a\n  CALLRTM TYPE=MEMTERM, against that address space.\n\n  Since a single jobname may have multiple ASIDs,\n  you want to be very careful, which address space\n  you want to terminate.  So there is an ASID parameter\n  as well as a JOBNAME parameter associated with\n  the BURN command.\n\n  If you terminate an ASID that has multiple jobnames\n  attached to it, all those jobnames will be burned.\n\n  If you enter a JOBNAME(jobname) parameter, you will\n  be prompted to enter an ASID number in hex.\n  (See the examples below....)\n\n)X SYNTAX  -\n\n       BURN  JOBNAME(jobname) ASID(hhhh)\n       BURN  JOB(jobname)     ASID(hhhh)\n       BURN  JOBNAME(partj*)\n                              where * is a wildcard\n                              which will list all\n                              jobnames beginning with\n                              \"partj\"\n\n  REQUIRED - either JOBname( )  or ASID(  )\n  DEFAULTS - NONE\n  ALIAS    - NONE\n\n       Prompts will be returned after entering the initial\n        sub-parameters.\n\n       Answer the prompts, and enter the job number to\n        be burned, in hex.\n\n       * is a wildcard in the JOBNAME, if entered as jjj*\n\n       If no JOB or ASID entered, then the program will\n        issue a message and terminate.\n\n       If J entered, the program will prompt for jobname.\n\n       If A entered, the program will prompt for ASID number.\n\n       If an incorrect prompt is entered, the program will\n        prompt for a correct answer.\n\n       If 3 incorrect tries are entered, then the program\n        will terminate.  (This is a convenient way to get out\n        of the program.  Just enter 3 incorrect tries, or\n        enter PA1, either of which will get you out of the\n        program.)\n\n Examples:     DO NOT DO THIS UNLESS ABSOLUTELY NECESSARY.\n               -- --- -- ---- ------ ---------- ---------\n               (and ONLY do it to a job or address space\n               that you need to forcibly terminate.)\n\n    Example 1:\n    ------- -\n\n    BURN JOB(JES2)            (as a TSO command)\n\n    THE FOLLOWING ASID ARE VALID FOR THE JOBNAME:\n    ASID=001C  JOBNAME=JES2\n    WHICH ADDRESS SPACE WOULD YOU LIKE TO BURN ?\n      ENTER ITS VALUE IN HEX:\n    1c\n    JOBNAME JES2     FOR ASID 001C BURNED\n\n\n    Example 2:\n    ------- -\n\n    BURN JOB(JES2*)           (as a TSO command)\n\n    THE FOLLOWING ASID ARE VALID FOR THE JOBNAME:\n    ASID=001C  JOBNAME=JES2\n    ASID=0024  JOBNAME=JES2AUX\n    ASID=0025  JOBNAME=JES2MON\n    WHICH ADDRESS SPACE WOULD YOU LIKE TO BURN ?\n      ENTER ITS VALUE IN HEX:\n    1c\n    JOBNAME JES2     FOR ASID 001C BURNED\n\n\n)O OPERANDS -\n))JOBNAME(jobname) - Jobname of address space to be burned.\n))JOBNAME(partj*)  - Partial jobname of address space to be\n                     burned.\n))ASID(nnnn)       - ASID of address space to be burned, in\n                     hex.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ESTPARM": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x006\\x00\\x93\\x06\\x8f\\x01\\x12)o#4\\x00\\x15\\x00\\x15\\x00\\x00\\xd1\\xd6\\xc5\\xd9@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-03-09T00:00:00", "modifydate": "2012-10-22T23:34:36", "lines": 21, "newlines": 21, "modlines": 0, "user": "JOER"}, "text": "         MACRO                                                             1\n         ESTPARM                                                           2\n.*+-------------------------------------------------------------------+    3\n.*\u00a6       (C)   COPYRIGHT MD-PALADIN INC. 1992                        \u00a6    4\n*+--------------------------------------------------------------------+    5\n*\u00a6       PARMS SUPPLIED BY ESTABLISHER OF GENERALIZED RECOVERY RTN    \u00a6    6\n*+--------------------------------------------------------------------+    7\nESTPARM  DS    0H                                                          8\nESTRETRY DS    A                  ADDRESS RETRY ROUTINE                    9\nESTFLAG  DS    X                  1ST FLAGS BYTE                          10\n@ESTSTAE EQU   X'20'              RECURSIVE ENTRY (FRRS AND ARRS)         11\nESTFLAG2 DS    X                  2ND FLAGS BYTE                          12\n@ESTNWTO EQU   X'80'              DO NOT ISSUE WTOS                       13\n         DS    2X                 NOT USED                                14\nESTRTN   DS    A                  ADDRESS OF USER ROUTINE                 15\nESTXPAR  DS    A                  ADDRESS OF ADDITIONAL PARMLIST          16\nESTLOAD  DS    A                  ESTABLISHER'S LOAD POINT                17\nESTRUB   DS    CL66               REGISTER UPDATE BLOCK (FLAGS+16 REGS)   18\nESTMOD   DS    CL8                MODULE NAME                             19\nLESTPARM EQU   *-ESTPARM          LENGTH OF PARMLIST                      20\n         MEND                                                             21\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIT": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12(O\\x01\\x12(O\\x01@\\x00\\n\\x00\\n\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-10-10T00:00:00", "modifydate": "2012-10-10T01:40:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         EXIT &RC=0\n         GBLA &WSLEN\n         LR   R1,R13\n         L    R13,4(,R13)\n         STORAGE RELEASE,LENGTH=&WSLEN,ADDR=(R1)\n         LM   R14,R12,12(R13)\n         LA   R15,&RC\n         BR   R14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WSDSECT": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12(O\\x01\\x12(O\\x01@\\x00\\x05\\x00\\x05\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-10-10T00:00:00", "modifydate": "2012-10-10T01:40:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         WSDSECT\nWSDSECT  DSECT\n         DS    18F\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WSEND": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12(O\\x01\\x12(O\\x01T\\x00\\x06\\x00\\x06\\x00\\x00\\xd4\\xc1\\xc3\\xd9\\xd6@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-10-10T00:00:00", "modifydate": "2012-10-10T01:54:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "MACRO"}, "text": "         MACRO\n         WSEND\n         GBLA  &WSLEN\nWSLENGTH EQU   *-WSDSECT\n&WSLEN   SETA  WSLENGTH\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT878/FILE878.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT878", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}