{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013429000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE917.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE917.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00 \\x04'", "DS1TRBAL": "b'\\xad0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\x13\\x00\\x08\\t\\x15\\x00\\n\\x00!'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x006\\x01\\x19\\t\\x9f\\x01\\x19\\t\\x9f\\x10Q\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-09T00:00:00", "modifydate": "2019-04-09T10:51:36", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  917\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE917\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 5 MEMBERS COUNTED; CUMULATIVE SIZE IS 18,944 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/09/19    10:51:36    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE917": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x001\\x01\\x19\\t\\x9f\\x01\\x19\\t\\x9f\\x10Q\\x00H\\x00H\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2019-04-09T00:00:00", "modifydate": "2019-04-09T10:51:31", "lines": 72, "newlines": 72, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 917 is from George DeLuca and contains SELECTIT, which    *   FILE 917\n//*           is an EXTREMELY powerful file copying and file        *   FILE 917\n//*           manipulation program.  Included is its extensive      *   FILE 917\n//*           documentation in both Word and PDF format (over 100   *   FILE 917\n//*           pages).  Actually, this program was constructed to be *   FILE 917\n//*           very straightforward and simple to use.  There are    *   FILE 917\n//*           just a lot of capabilities, including concatenation   *   FILE 917\n//*           of input files with unlike formats, and also output   *   FILE 917\n//*           files with different formats than the input files.    *   FILE 917\n//*           This program is used extensively in production runs   *   FILE 917\n//*           at the site where it was developed.                   *   FILE 917\n//*                                                                 *   FILE 917\n//*           Fixed by Peter Glanzmann for EAV volumes.             *   FILE 917\n//*           (Extended Address Volumes)                            *   FILE 917\n//*                                                                 *   FILE 917\n//*           email:  gddeluca@gmail.com                            *   FILE 917\n//*                                                                 *   FILE 917\n//*           email:  peter@glanzmann.org                           *   FILE 917\n//*                                                                 *   FILE 917\n//*     Overview                                                    *   FILE 917\n//*     ========                                                    *   FILE 917\n//*                                                                 *   FILE 917\n//*     SELECTIT is a utility which provides a wide variety         *   FILE 917\n//*     of functions related to copying, printing and/or            *   FILE 917\n//*     modifying datasets.  Any and all SELECTIT functions         *   FILE 917\n//*     can be combined in a single run or requested                *   FILE 917\n//*     individually, as you desire.                                *   FILE 917\n//*                                                                 *   FILE 917\n//*     SELECTIT can sequentially read up to 9 input files          *   FILE 917\n//*     (sequential, partitioned, ISAM, or keyed VSAM) and          *   FILE 917\n//*     selectively create any number of output files.              *   FILE 917\n//*                                                                 *   FILE 917\n//*     You may use SELECTIT to copy records (with or without       *   FILE 917\n//*     alteration of the records) and/or print them.               *   FILE 917\n//*                                                                 *   FILE 917\n//*     Features                                                    *   FILE 917\n//*     ========                                                    *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** File Copy - Copy a record from an input file to an       *   FILE 917\n//*        output file (unconditionally).                           *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** Selective Copy - Copy a record only if your supplied     *   FILE 917\n//*        condition is met.                                        *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** Limit Copy - Copy a limited number of records            *   FILE 917\n//*        (possibly in conjunction with a user supplied            *   FILE 917\n//*        condition).                                              *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** File print - Print record(s) from an input file.         *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** Alter Data - Replace the data in any portion of the      *   FILE 917\n//*        record with your supplied constant data, data from       *   FILE 917\n//*        other locations in the record or data from               *   FILE 917\n//*        SELECTIT provided variables (date, jobname,              *   FILE 917\n//*        datasetname, etc.).                                      *   FILE 917\n//*                                                                 *   FILE 917\n//*     ** Record reformat - A record can be completely             *   FILE 917\n//*        reformatted, fields can be modified, deleted             *   FILE 917\n//*        and/or added.                                            *   FILE 917\n//*                                                                 *   FILE 917\n//*    ---------------------------------------------------------    *   FILE 917\n//*                                                                 *   FILE 917\n//*     Send questions, suggestions and/or bug reports to:          *   FILE 917\n//*                                                                 *   FILE 917\n//*     gddeluca@gmail.com                                          *   FILE 917\n//*                                                                 *   FILE 917\n//*     George D. Deluca                                            *   FILE 917\n//*     116-2075 Amherst Heights Drive                              *   FILE 917\n//*     Burlington, Ontario                                         *   FILE 917\n//*     L7P 5B8                                                     *   FILE 917\n//*     Canada                                                      *   FILE 917\n//*                                                                 *   FILE 917\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SELECTI#": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14#O\\x01\\x14#O\\x14!\\x1e\\xd9\\x1e\\xd9\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-08-22T00:00:00", "modifydate": "2014-08-22T14:21:00", "lines": 7897, "newlines": 7897, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "SELECTI@": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14#O\\x01\\x14#O\\x14\"\\x05\\xa0\\x05\\xa0\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-08-22T00:00:00", "modifydate": "2014-08-22T14:22:00", "lines": 1440, "newlines": 1440, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "datatype": "binary", "extension": ".docx"}, "SELECTIT": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x002\\x01\\x14#O\\x01\\x19\\t\\x9f\\x10B%3%-%3\\xc7\\xc4\\xc5\\xd3\\xe4\\xc3\\xc1@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2014-08-22T00:00:00", "modifydate": "2019-04-09T10:42:32", "lines": 9523, "newlines": 9517, "modlines": 9523, "user": "GDELUCA"}, "text": "//TCS1028A JOB (12345),'SELECTIT ASMLINK',MSGCLASS=X,\n//             USER=TCS1028,PASSWORD=SPFLITE\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,USING(WARN(8))'\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(20,5)),DSN=&SYSUT1\n//SYSPUNCH DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(CYL,(20,5)),DSN=&OBJ,DISP=(,PASS)\n//SYSIN DD *\nSELECTIT TITLE 'Program Memory/Module structure'\n*\n*---------------------------------------------------------------------+\n*                                                                     |\n* Overview                                                            |\n* ========                                                            |\n*                                                                     |\n* SELECTIT is a utility which provides a wide variety of functions    |\n* related to copying, printing and/or modifying datasets.  Any and all|\n* SELECTIT functions can be combined in a single run or requested     |\n* individually, as you desire.                                        |\n*                                                                     |\n* SELECTIT can sequentially read up to 9 input files (sequential,     |\n* partitioned, ISAM, or keyed VSAM) and selectively create any number |\n* of output files.                                                    |\n*                                                                     |\n* You may use SELECTIT to copy records (with or without alteration of |\n* the records) and/or print them.                                     |\n*                                                                     |\n* Features                                                            |\n* ========                                                            |\n*                                                                     |\n* ** File Copy Copy a record from an input file to an output file     |\n*    (unconditionally).                                               |\n*                                                                     |\n* ** Selective Copy Copy a record only if your supplied condition is  |\n*    met.                                                             |\n*                                                                     |\n* ** Limit Copy Copy a limited number of records (possibly in         |\n*    conjunction with a user supplied condition).                     |\n*                                                                     |\n* ** File print Print record(s) from an input file.                   |\n*                                                                     |\n* ** Alter Data Replace the data in any portion of the record with    |\n*    your supplied constant data, data from other locations in the    |\n*    record or data from SELECTIT provided variables (date, jobname,  |\n*    datasetname, etc.).                                              |\n*                                                                     |\n* ** Record reformat A record can be completely reformatted, fields   |\n*    can be modified, deleted and/or added.                           |\n*                                                                     |\n* Changes                                                             |\n* =======                                                             |\n*                                                                     |\n* 2019/04/09 Peter Glanzmann (peter@glanzmann.org)                    |\n*            Support EAV volumes (Extended Address Volumes)           |\n*                                                                     |\n*---------------------------------------------------------------------+\n* Send questions, suggestions and/or bug reports to:                  |\n*                                                                     |\n* gddeluca@gmail.com                                                  |\n*                                                                     |\n* George D. Deluca                                                    |\n* 116-2075 Amherst Heights Drive                                      |\n* Burlington, Ontario                                                 |\n* L7P 5B8                                                             |\n* Canada                                                              |\n*---------------------------------------------------------------------+\n* This program is free software: you can redistribute it and/or       |\n* modify it under the terms of the GNU General Public License as      |\n* published by the Free Software Foundation, either version 3 of      |\n* the License, or (at your option) any later version.                 |\n*                                                                     |\n* This program is distributed in the hope that it will be useful,     |\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      |\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the        |\n* GNU General Public License for more details.                        |\n*                                                                     |\n* You should have received a copy of the GNU General Public License   |\n* along with this program. If not, see <http://www.gnu.org/licenses/> |\n*---------------------------------------------------------------------+\n*\n*---------------------------------------------------------------------+\n*    Memory layout for SELECTIT\n*    ==========================\n*\n*    +--------------------------+\n*    | Initialization and procs | <-- Base R12,R11\n*    | which must be addressable|\n*    | to all other routines.   |\n*    +--------------------------+\n*    | Asynch STAE abend exit   |\n*    +--------------------------+\n*    | Proc 1                   | <-- Base R8 (Opt.R10 during compile)\n*    +--------------------------+\n*    .    Other $PROC's ...     . <-- Base R8\n*    .      .     .             .      .   .\n*    V      V     V             V      V   V\n*    +--------------------------+\n*    | Proc n                   |\n*    +--------------------------+\n*    | Savearea and global data | <-- Base R13\n*    +--------------------------+\n*    | Unaddressable Data areas |\n*    +--------------------------+\n*\n         TITLE 'Program MACRO definitions'\n*---------------------------------------------------------------------+\n*        $SKIP - Force skip to the end of this sentence.              |\n*---------------------------------------------------------------------+\n         MACRO\n&NAME    $SKIP\n&NAME    AP    COMNTCTL,=P'1'\n         NI    PCTF1,255-ACTIVE\n         L     R8,=A(MAINCOMP)\n         B     8(R8)\n         MEND\n*---------------------------------------------------------------------+\n*        $ERR - Issue messages to the user.                           |\n*---------------------------------------------------------------------+\n         MACRO\n&NAME    $ERR  &ERRNO,&LEVEL,&SKIP,&SAVE=NO,&TYPE=MSG,&GO=,&FLAG=YES\n&NAME    LA    R1,ERR&ERRNO\n         LA    R2,&LEVEL\n         AIF   ('&FLAG' EQ 'YES').SKFL\n         OI    PCTF4,NOFLAG\n.SKFL    AIF   ('&SAVE' EQ 'NO').NO\n         SR    R3,R3\n         AGO   .BAL\n.NO      ANOP\n         LA    R3,1\n.BAL     AIF   ('&TYPE' NE 'STAT').BALBAL\n         OI    PCTF1,STAT\n.BALBAL  ANOP\n         $CALL ERRSTORE\n         AIF   (T'&SKIP EQ 'O').SEEGO\n         $SKIP\n         AGO   .MEXIT\n.SEEGO   AIF   ('&GO' EQ '').MEXIT\n         B     &GO\n.MEXIT   MEND\n*---------------------------------------------------------------------+\n*        $ADD  - Add code blocks to the compiled program              |\n*---------------------------------------------------------------------+\n         MACRO\n&NAME    $ADD  &L,&LOC\n&NAME    LA    R1,&L\n         LA    R2,&LOC\n         $CALL PGMSTUFF\n         MEND\n         EJECT\n*---------------------------------------------------------------------+\n*        $TXT   - Generate message text blocks.                       |\n*---------------------------------------------------------------------+\n         MACRO\n         $TXT  &N,&L,&T,&TYPE=STD\n         LCLA  &A\n         GBLA  &ERRCNT\n         AIF   ('&TYPE' NE 'END').STD\n&ERRCNT  SETA  &ERRCNT+1\n*\nERRTX&ERRCNT EQU *\nERRTBL   DS    0F\n&A       SETA  1\n.ERRLOOP AIF   (&A GE &ERRCNT).MEXIT\n         DC    A(ERRTX&A)\n&A       SETA  &A+1\n         AGO   .ERRLOOP\n.STD     ANOP\n&A       SETA  &N\n&A       SETA  &A+1\nERRTX&N  DC    AL1(ERRTX&A-ERRTX&N-2),C&T\nERR&L    EQU   &N\n         AIF   (&N LT &ERRCNT).MEXIT\n&ERRCNT  SETA  &N\n.MEXIT   MEND\n         EJECT\n*---------------------------------------------------------------------+\n*        Misc. minor macros                                           |\n*---------------------------------------------------------------------+\n         MACRO\n&NAME    $INC  &LABEL\n&NAME    L     R14,&LABEL\n         AH    R14,=H'1'\n         ST    R14,&LABEL\n         MEND\n*\n*\n         MACRO\n         $KW   &ID,&KW,&F1=0,&F2=0,&F3=0,&D1=A(0),&D2=A(0),&D3=A(0)\n         LCLA  &A\n         DC    A(0)\n&A       SETA  K'&KW\n         AIF   (&A GT 10).KWER\n         DC    H'&A'\n         DC    CL10'&KW'\n         DC    AL1(&F1,&F2,&F3)\n&A       SETA  K'&ID\n         AIF   (&A GT 2).IDER\n         DC    X'&ID'\n         DC    &D1\n         DC    &D2\n         DC    &D3\n         MEXIT\n.KWER    MNOTE 8,'$KW ERROR IN KEYWORD OPERAND'\n         MEXIT\n.IDER    MNOTE 8,'$KW ERROR IN ID OPERAND'\n         MEXIT\n         MEND\n         EJECT\n*---------------------------------------------------------------------+\n*        Subroutine Support Macros                                    |\n*---------------------------------------------------------------------+\n         MACRO\n&NAME    $CALL &PROC\n         LCLA  &A,&B\n&A       SETA  N'&SYSLIST\n&NAME    L     R15,=A(&PROC)\n         ST    R8,4(R15)\n         AIF   (&A EQ 1).BALR\n&B       SETA  2\n.LOOP    AIF   (&B GT &A).BALR\n         AIF   ('&SYSLIST(&B)'(1,1) EQ '(').REG\n         LA    R14,&SYSLIST(&B)\n         ST    R14,(&B+1)*4(R15)\n         AGO   .BBUMP\n.REG     ST    &SYSLIST(&B),(&B+1)*4(R15)\n.BBUMP   ANOP\n&B       SETA  &B+1\n         AGO   .LOOP\n.BALR    BALR  R8,0\n         LA    R8,14(,R8)\n         ST    R8,0(R15)\n         LR    R8,R15\n         B     8(R8)\n         MEND\n         MACRO\n*\n&NAME    $RET  &DISP\n         LCLA  &D\n&D       SETA  &DISP\n&NAME    L     R15,0(R8)\n         AIF   (&D EQ 0).BR\n         LA    R15,&D.(,R15)\n.BR      L     R8,4(R8)\n         BR    R15\n         MEND\n*\n         MACRO\n&NAME    $PROC &NUM\n         LCLA  &A\n&A       SETA  0\n         AIF   (T'&NUM EQ 'O').NUN\n&A       SETA  &NUM\n.NUN     DS    0F\n         USING *,R8\n&NAME    DC    2A(0)\n         AIF   (&A EQ 0).MEND\n         B     *+((&A+1)*4)\n         DS    &A.F\n.MEND    MEND\n*\n         MACRO\n&NAME    $PEND\n         PRINT OFF\n         LTORG\n         DROP  R8\n         PRINT ON\n         MEND\n         TITLE 'Initialization'\nSELECTIT CSECT\n         PRINT NOGEN\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nAREG     EQU   4\nBREG     EQU   6\nOREG     EQU   5\nPCTBASE  EQU   13\n*---------------------------------------------------------------------+\n*        Register Usage                                               |\n*               R0  --  Work                                          |\n*               R1  --  Work                                          |\n*               R2  --  Work                                          |\n*               R3  --  Work                                          |\n*               R4  --  Work / A-REG                                  |\n*               R5  --  Work / O-REG                                  |\n*               R6  --  Work / B-REG                                  |\n*               R7  --  Work / FCB base usually, but not always       |\n*               R8  --  Base for independent Procs                    |\n*               R9  --  Work                                          |\n*               R10 --  Param ptr in compiled code/Base during compile|\n*               R11 --  Program Base                                  |\n*               R12 --     \"     \"                                    |\n*               R13 --  Savearea and data area base                   |\n*               R14 --  Work                                          |\n*               R15 --  Work                                          |\n*---------------------------------------------------------------------+\n         EJECT\n*---------------------------------------------------------------------+\n*        Get ourselves addressable etc.                               |\n*---------------------------------------------------------------------+\n         B     SKIPCOPR-SELECTIT(,R15)\n         DC    C'SELECTIT'\n         DC    CL44' (C) Copyright G.D. Deluca. 1974, 2013'\n         DC    CL8'&SYSDATE'\n*\nSKIPCOPR STM   R14,R12,12(R13)     Setup base regs etc\n         LR    R12,R15             .\n         USING SELECTIT,R12,R11    .\n         L     R2,FOURK            .\n         LR    R11,R12             .\n         AR    R11,R2              .\n         L     R8,SAVEADDR         .\n         ST    R13,4(R8)           .\n         ST    R8,8(R13)           .\n         LR    R13,R8              .\n         USING SAVEAREA,R13        Set some USINGs\n         USING SELDSECT,R15\n         USING FCBDSECT,R7\n         L     R1,0(R1)            Got a PARM field?\n         LH    R3,0(R1)            Get it's length\n         LTR   R3,R3               Any?\n         BZ    NOPARM              No\n         CLC   2(7,R1),=C'OPTIONS' Silly twit specify OPTIONS itself?\n         BNE   NOOPT               No, O.K.\n         LA    R1,8(,R1)           Yes, step over it\n         SH    R3,=H'8'            Adjust length\n         BNP   NOPARM              Skip if that was all\n*\nNOOPT    BCTR  R3,0                -1 for EX\n         EX    R3,*+4              Move it\n         MVC   PARMDATA+8(0),2(R1)\n         LA    R4,PARMDATA+8(R3)\n         CLI   0(R4),C'.'          Does it have a .\n         BE    *+8                 Yes, don't add another\n         MVI   1(R4),C'.'          No, terminate with period\n         LA    R3,9(,R3)           Adjust length\n         ST    R3,GETSCLN          Save for GETWORD\n         LA    R3,PARMDATA         Point at OPTIONS statement now\n         ST    R3,GETPTR           Save for GETWORD\n         ST    R3,GETIMAGE         Save for error processors\n         ST    R3,GETWSTRT         .\n         OI    PCTF1,DFLTFLAG      Set default flag\n         LM    R3,R6,GETDPTRS      Shift default pointers right\n         STM   R3,R6,GETDPTRS+4    .\n         MVC   GETDPTRS(4),=F'-1'  Flag as PARM 1st\n         MVC   LINE+17(110),PARMDATA\n         MVC   LINE(5),=C'00000'\n         OI    PCTF4,PWAITING\n         LA    R14,PARMDATA        Yes, search PARMDATA\n         LA    R15,110             .\n         CLC   =C'PDSMODE(ON)',0(R14)\n         BE    *+16                Got it, go set PDSMODE\n         LA    R14,1(,R14)         No, loop through field\n         BCT   R15,*-14            .\n         B     NOPARM              No present, ignore PDSMODE\n         OI    PCTF8,PDSMODE       PDSMODE found, set flag\n*\nNOPARM   B     MAINPGM             Continue\n*\nSAVEADDR DC    A(SAVEAREA)\nFOURK    DC    F'4096'\n         TITLE 'Super Main line'\n*---------------------------------------------------------------------+\n*        This is the supposed Main line of the beast.                 |\n*---------------------------------------------------------------------+\nMAINPGM  $CALL INITPROC  Go do all the basic initialization stuff     |\n         $CALL INITIODD  Go OPEN up our standard files                |\n*                                                                     |\nREDOSLCT $CALL INISLECT  Set the program mode based on the DD's found |\n         $CALL MAINCOMP  Compile the user's requests now.             |\n*                                                                     |\nREDOCOPY $CALL COPYDATA  O.K. Now go do I/O (Our real purpose in life)|\n*                                                                     |\nADDSTATS $CALL EOJ       Various places will come here to terminate   |\n         B     REDOCOPY  If EOJ returns, PDSMODE active, member loop  |\n*---------------------------------------------------------------------+\n         TITLE 'STAE retry routine'\n*---------------------------------------------------------------------+\n*        STAE retry comes here if ABEND was a User abend or an abend  |\n*        while executing in, or on behalf of, the user's program.     |\n*                                                                     |\n*        All the recovery consists of is:                             |\n*              a) Re-load a good set of registers                     |\n*              b) Dump the active record at the time of abend         |\n*                 if not still in COMPILE phase.                      |\n*              c) Terminate with appropriate messages                 |\n*---------------------------------------------------------------------+\n*\nABNDRCVR L     R1,0(R1)            Get address of STAESAVE\n         LM    R0,R15,0(R1)        Reload regs\n         TM    PCTF7,TIMEBOMB      Timer forced ABEND?\n         BZ    ABNDTCMP            No, continue\n         $ERR  LOOPR,16,FLAG=NO    Issue 'why' message before ABND one\n*\nABNDTCMP TM    PCTF4,COMPILE       Still in COMPILE mode?\n         BO    ADDSTATS            Yes, skip record dump & Msgs\n         TM    PCTF1,EXEC          Executing in Compiled program?\n         BZ    ADDSTATS            No, also skip\n         MVC   TRADDR,PCTINPT1     Move address of record for DMPIT\n         L     R15,PCTINPL1        Fudge length of record for DMPIT\n         ST    R15,TRLGTH\n         LA    R14,TRFLAG-1          \"   R15(R14) for DMPIT\n         $CALL DMPIT               Go dump record now\n*\nABNDJABN $ERR  ABND,16,GO=ADDSTATS,FLAG=NO Issue ABEND message\n         TITLE 'CONTAINS - See if record contains a field.'\n*---------------------------------------------------------------------+\n*        Do initialization for the scan.                              |\n*---------------------------------------------------------------------+\n*\nCONTAINS STM   R4,R6,CONTSAVE      Save everything\n         SR    R15,R15             Clear R15\n         ST    R5,OREGM            Save OREG in memory\n         ICM   R5,12,=X'0000'      Clear hi order bytes in OREG\n         TM    PCTIOFLG,IOFLOATA   Is A operand floating?\n         BO    *+10                Yes, R4/R6 are O.K.\n         XR    R4,R6               No, swap R4/R6 around\n         XR    R6,R4               .\n         XR    R4,R6               .\n         STCM  R4,8,CONTFILE+3     Replace file number\n         LA    R4,0(,R4)           Purify hi-bytes of param regs\n         LA    R6,0(,R6)           .\n         XC    TRTABLE,TRTABLE     Clear TRT table\n         IC    R15,0(R6)           Get first char from B-operand\n         LA    R15,TRTABLE(R15)    Point at it's loc in TRT table\n         MVI   0(R15),X'FF'        Make it non-zero\n         SR    R15,R15             Clear R15 again\n         L     R15,CONTFILE        Insert file number\n         SLL   R15,2               x 4\n         L     R5,PCTINPL1-4(R15)  Get length of current record\n         L     R7,PCTINPT1-4(R15)  Load start address of record\n         ST    R7,CONTSADR         Save start address locally\n         AR    R5,R7               Point at last byte of record\n         LR    R15,R4              Get start of scan\n         AH    R15,OREGBLEN        Add length of literal\n         CR    R15,R5              Room in record to find this?\n         BH    CONTNFND            Whoops, not this one!\n         LR    R7,R5               Get end of record\n         SR    R7,R4               Calc remaining length of record\n         BCTR  R7,0                -1 for EX\n         LH    R5,OREGBLEN         Get literal length\n         BCTR  R5,0                -1 for EX\n         EJECT\n*---------------------------------------------------------------------+\n*        Do tests while length is > 256.                              |\n*---------------------------------------------------------------------+\n*\nCONTLP1  CLM   R7,14,ZEROS         Is length > 256?\n         BE    CONTLAST            No, go test remaining chunk\n         LR    R1,R4               Swap address to R1\n         LA    R15,255             Set for 256 bytes\n         LR    R9,R4               Save start scan address\n*\nCONTLP2  EX    R15,CONTTRT         Look for 1st char\n         BZ    CONTLPB             Not there, bump\n         TM    PCTIOFLG,IOMASK     Masking?\n         BNO   CONTNCM1            No, do normal compare\n         EX    R5,CONTM1           Do MASK type test\n         EX    R5,CONTM2           .\n         EX    R5,CONTM3           .\n         EX    R5,CONTM4           .\n         B     CONTNCM2            Re-enter common code\n*\nCONTNCM1 EX    R5,CONTCOMP         Got it, is the rest there\n*\nCONTNCM2 BE    CONTEQ              Yep, return with = set\n         LA    R1,1(,R1)           No, step over this one\n         LR    R0,R1               Calc length searched\n         SR    R0,R9               .\n         SR    R15,R0              Subt from length remaining\n         BNP   CONTLPB             None left, go to outer loop\n         LR    R9,R1               Save new start scan\n         B     CONTLP2             Loop back\n*\nCONTLPB  LA    R4,256(,R4)         Bump to next 256 byte chunk\n         SH    R7,=H'256'          Decr count\n         B     CONTLP1             Loop back\n         EJECT\n*---------------------------------------------------------------------+\n*        Do tests for the remaining portion 256 or less.              |\n*---------------------------------------------------------------------+\n*\nCONTLAST LR    R1,R4               Swap address to R1\n         LR    R15,R7              Get length\n         SR    R15,R5              Reduce by length of argument\n         LR    R9,R4               Save start scan\n*\nCONTLP3  EX    R15,CONTTRT         Look for 1st char\n         BZ    CONTNFND            Not there, exit\n         TM    PCTIOFLG,IOMASK     Masking?\n         BNO   CONTLCM1            No, do normal compare\n         EX    R5,CONTM1           Do MASK type test\n         EX    R5,CONTM2           .\n         EX    R5,CONTM3           .\n         EX    R5,CONTM4           .\n         B     CONTLCM2            Re-enter common code\n*\nCONTLCM1 EX    R5,CONTCOMP         Got 1st char, is the rest there?\n*\nCONTLCM2 BE    CONTEQ              Yep, return with = set\n         LA    R1,1(,R1)           No, step over this one\n         LR    R0,R1               Calc length searched\n         SR    R0,R9               .\n         SR    R15,R0              Subt from length remaining\n         BNP   CONTNFND            None left, go to outer loop\n         LR    R9,R1               Save new start scan\n         B     CONTLP3             Loop back\n*---------------------------------------------------------------------+\n*        Do needed stuff, set CC, and exit now.                       |\n*---------------------------------------------------------------------+\n*\nCONTNFND CR    R4,R6               Force unequal compare\n         LM    R4,R6,CONTSAVE      Reload all the regs\n         BR    R14                 End return\n*\nCONTEQ   LA    R5,1(,R5)           Convert length back to actual\n         ST    R5,PCTSCLEN         Save length of found item\n         AR    R5,R1               Point at last byte of found\n         S     R5,CONTSADR         Calc offset in record\n         ST    R5,PCTPLOCE         Save it for PLOC\n         ST    R5,PCTFLOCE         Save it for FLOC\n         S     R1,CONTSADR         Calc offset to found\n         LA    R1,1(,R1)           Make it actual\n         ST    R1,PCTPLOC          And save it\n         CR    R7,R7               Force equal compare\n         LM    R4,R6,CONTSAVE      Reload all the regs\n         BR    R14                 End return\n         EJECT\n*\nCONTTRT  TRT   0(0,R1),TRTABLE     Executed\nCONTCOMP CLC   0(0,R1),0(R6)       Executed\nCONTM1   MVC   WORDTXT(0),0(R6)    Move literal to work area\nCONTM2   TR    WORDTXT(0),MASKTBL  Translate to 00 or FF\nCONTM3   NC    WORDTXT(0),0(R1)    AND in chars to compare\nCONTM4   CLC   WORDTXT(0),0(R6)    Now do the compare\nCONTSADR DS    F\nCONTFILE DC    F'0'\nCONTSAVE DS    3F\n         DS    0H\n         TITLE 'DCOPYDAT - Deferred copy of I/P buffer'\n*---------------------------------------------------------------------+\n*     Copying the primary input buffer to the output buffer as soon   |\n*     as it's read can add considerable overhead if the record ends   |\n*     up never being selected for output.  This is particularly true  |\n*     of variable records with an unusually large LRECL (like SMF),   |\n*     since the move does a fill to the maximum record length.        |\n*                                                                     |\n*     Instead, the buffer is not copied until some function really    |\n*     needs it.  The DEFRCOPY flag is used to control whether the     |\n*     record has already been copied or not.  A 'BAL   R14,DCOPYDAT'  |\n*     is inserted in the compiled program in front of any function    |\n*     which requires that the output buffer have been set up.         |\n*---------------------------------------------------------------------+\n*\nDCOPYDAT TM    PCTF6,DEFRCOPY      Copy needed?\n         BZR   R14                 No, return\n         TM    PCTBFCDF,COPYBUFF   Is COPYBUFF the default?\n         BZR   R14                 No, skip it then\n         NI    PCTF6,255-DEFRCOPY  Yes, kill flag and do it\n         ST    R14,DBL             Save return\n         L     R0,PCTINPT1         Get address of INPUT1 record\n         L     R1,PCTINPL1         Get length of INPUT1 record\n         ST    R1,PCTOBUFL         Set as length of rec in O/P buffer\n         L     R14,PCTOUTPT        Setup\n         LH    R15,DCBHLREC        An MVCL\n         ICM   R1,8,PCTPADCH       Put in the specified fill character\n         MVCL  R14,R0              Move input record to output area\n         L     R14,DBL             Get return address\n         BR    R14                 Return\n         TITLE 'HEXIT - Convert operands to hex'\n*---------------------------------------------------------------------+\n*        Convert data to EBCDIC hex.                                  |\n*---------------------------------------------------------------------+\n*\nHEXIT    LA    OREG,0(,OREG)       Clear hi-byte of OREG\n*\nHEXITLP  MVC   DBL(1),0(BREG)      Format 2 bytes into msg\n         UNPK  0(1,AREG),DBL(1)\n         MVO   DBL(1),DBL(1)\n         UNPK  1(1,AREG),DBL(1)\n         MVZ   0(2,AREG),ZEROS\n         TR    0(2,AREG),SNPTR\n         LA    BREG,1(,BREG)       Bump to next byte\n         LA    AREG,2(,AREG)\n         BCT   OREG,HEXITLP        And loop if not done\n         BR    R14                 Return\n         TITLE 'LINPRINT - PRINT a line'\n*---------------------------------------------------------------------+\n*        Print a single line                                          |\n*---------------------------------------------------------------------+\n*\nLINPRINT ST    R14,LINS14          Save return addr\n         ST    R7,LINS7            Save any current FCB address\n         ICM   R7,15,PCTPFCB       Point at printer FCB\n         BZ    LINCLR\n         TM    FCBF1,FCBOPEN       Is SYSPRINT available?\n         BZ    LINCLR              No, continue\n*\nLINCNTIT SP    LINECT,=P'1'        Count line\n         BNP   LINPGHD             And do page heads if needed\n*\nLINTTRAC TM    PCTF4,COMPILE       During compile phase?\n         BO    LINPUT              Yes, print it first\n         CLI   TRLINE+31,C' '      Anything waiting in TRACE line?\n         BE    LINPUT              No, just print normally\n         LA    R14,TRLINE-1        Yes, lets print it 1st\n         BAL   R15,LINEDO          .\n         MVC   TRLINE,BLANKS       Reset the TRACE line\n         MVC   TRPOS,=A(TRLINE+31) .\n         B     LINCNTIT            Go count the inserted line\n*\nLINPUT   LA    R14,LINE-1          Put out requested line\n         BAL   R15,LINEDO\n         CLC   TRLINE(132),BLANKS  Anything waiting in ERROR line?\n         BE    LINCLR              No, just exit normally\n         LA    R14,TRLINE-1        Yes, lets print it then\n         BAL   R15,LINEDO          .\n         MVC   TRLINE,BLANKS       Reset the ERROR line\n         SP    LINECT,=P'1'        Count line\n*\nLINCLR   MVC   LINE(132),BLANKS    Blank line\n         L     R14,LINS14          Restore return reg\n         L     R7,LINS7            Restore FCB pointer\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------+\n*        Page heading routine                                         |\n*---------------------------------------------------------------------+\n*\nLINPGHD  ZAP   LINECT,=P'52'       Reset line count\n         L     R14,LINHDA3         Get potential ruler line address\n         C     R14,=A(LINHD3)      Is it in use?\n         BNE   *+16                No, skip footing logic\n         B     *+8                 NOP/B 1st time switch\n         BAL   R15,LINEDO          Go print footing\n         NI    *-7,X'0F'           Flip 1st time switch\n         L     R14,LINHDA1         Get 1st pghd addr\n         AP    LINPGCT,=P'1'       Count page\n         MVC   129(4,R14),=X'40202120'\n         ED    129(4,R14),LINPGCT\n         BAL   R15,LINEDO          And print it\n         L     R14,LINHDA2         Get 2nd pghd addr\n         BAL   R15,LINEDO          And print it\n         L     R14,LINHDA3         Get 3rd pghd address\n         BAL   R15,LINEDO          Print it\n         L     R14,=A(LINHD9)\n         BAL   R15,LINEDO          Space the headings\n         B     LINTTRAC            Now do the original line\n         EJECT\n*---------------------------------------------------------------------+\n*        Print the actual lines based on SYSPRINT's RECFM/LRECL       |\n*---------------------------------------------------------------------+\n*\nLINEDO   STM   R0,R15,LINEDORG     Save regs\n         TM    FCBRECFM,X'C0'\n         BO    LINEDOST            Set length if RECFM=U\n         LH    R9,FCBDCB+DCBLRECL  Get length into R9\n         TM    FCBRECFM,X'80'\n         BO    LINENDO             Skip if RECFM=F\n*\nLINEDOST LR    R1,R14              R1 --> line to print\n         LA    R1,0(,R1)           Purify the hi-byte\n         LA    R4,133(R14)         R4 --> end of line+1\n         L     R5,=A(TRTBLB)       R5 --> blank TRT table\n         L     R6,=A(TRTBLNB)      R6 --> non-blank TRT table\n*\nLINEDTRT TRT   0(134,R1),0(R5)     Find next blank\n         LR    R9,R1               Save loc as last blank\n         TRT   0(134,R1),0(R6)     Find a non-blank\n         CR    R1,R4               Is it still inside line\n         BL    LINEDTRT            Yes, keep going\n         SR    R9,R14              No, calc effective lgth of line\n         LTR   R9,R9\n         BNZ   *+8\n         LA    R9,1\n         STH   R9,FCBDCB+DCBLRECL  Stuff in DCB\n         TM    FCBDCB+DCBRECFM,X'C0' RECFM=U\n         BO    LINENDO             Yes, no RDW need be built\n         LA    R9,4(,R9)           Add 4 for a RDW\n         SH    R14,=H'4'           Backup to RDW area\n         STH   R9,0(R14)           Put length in RDW\n         STH   R9,FCBDCB+DCBLRECL  And in DCB\n*\nLINENDO  LA    R3,FCBDCB           Point at DCB\n         LR    R2,R14              Save address of data\n         PUT   (R3)                Put the record (Get buffer loc)\n         LH    R15,FCBDCB+DCBLRECL Get length of record\n         EX    R15,*+4             Move it to buffer\n         MVC   0(0,R1),0(R2)       .\n         LM    R0,R15,LINEDORG     Restore regs\n         BR    R15                 Return\n         EJECT\n*---------------------------------------------------------------------+\n*        Print routine work areas                                     |\n*---------------------------------------------------------------------+\n         DC    X'00000000'         Reserved for possible RDW\n         DC    C' '                Print\nLINE     DC    CL132' '            Line\n         DC    C'X'                Don't remove\nLINHDA1  DC    A(LINHD1)           Addr of 1st hding\nLINHDA2  DC    A(LINHD2)             \"   \" 2nd   \"\nLINHDA3  DC    A(LINHD2A)            \"   \" 3rd   \"\nLINECT   DC    P'01'               Line counter\nLINPGCT  DC    PL2'0'              Page counter\nLINS14   DS    F\nLINS7    DS    F\nLINEDORG DS    16F\n         TITLE 'OPROUTE - SELECT O/P control routine'\n*---------------------------------------------------------------------+\n*        OPROUTE is CALLed by the compiled SELECT statement code      |\n*        when the SELECT contains either/or PRINT(...) or TODD(...).  |\n*                                                                     |\n*        On entry R15 points at the SELECT control area, see the      |\n*        DSECT SELDSECT for it's layout.                              |\n*---------------------------------------------------------------------+\n*\nOPROUTE  STM   R0,R15,OPRSAVE      Save all regs\n         ICM   R1,15,$SELBCTR      Get BY(...) counter\n         BZ    OPRSBYOK            It's zero we can output it\n         BCTR  R1,0                Non-zero, decrement it\n         ST    R1,$SELBCTR         And store it back\n         B     OPRINS              Then goto next sentence\n*\nOPRSBYOK MVC   $SELBCTR,$SELBREC   Reset the count\n         TM    $SELF1,CHAR+HEX     Any print requested?\n         BZ    OPRSTCPY            No, go see if copy called for\n         LR    R14,R15             Protect R15 from $CALL\n         $CALL DMPIT               Yes, go do it\n         L     R15,OPRSAVE+60      Restore R15\n*\nOPRSTCPY TM    $SELF1,COPY         Is copy requested?\n         BZ    OPRETURN            No, no more to do, return\n         L     R7,$SELOFCB         Point at FCB\n         LR    R14,R15             Protect R15 from $CALL\n         $CALL CPYIT               Go copy it\n*\nOPRETURN LM    R0,R15,OPRSAVE      Restore all regs\n         BR    R14                 And return\n         EJECT\n*---------------------------------------------------------------------+\n*        De-activate a SELECT command when done                       |\n*---------------------------------------------------------------------+\n*\nOPRISHUT MVC   $SELNREC,ZEROS      Set count to zero\n         L     R1,PCTMACNT         Get address of master active count\n         BCTR  R1,0                Decrement it\n         ST    R1,PCTMACNT         And put it back\n         NI    PCTF5,255-SHUTSEL   Reset the switch\n*\nOPRINS   LM    R0,R15,OPRSAVE      Restore regs\n         L     R14,$SELNXTS        Get address of next sentence\n         BR    R14                 And go to it\n         TITLE 'REPLACE - do the fancy types of ALTER'\n*---------------------------------------------------------------------+\n*        This code performs all the unusual types of ALTER to do      |\n*        with 'floating' fields and/or DLM type source fields.        |\n*---------------------------------------------------------------------+\n*\nREPLACE  LR    R3,R14              Save return temporarily\n         BAL   R14,DCOPYDAT        Go copy data if needed\n         LR    R14,R3              Restore R14\n         STM   R4,R6,REPLSAV1      Save execution code registers\n         MVC   PCTFLCHG,ZEROS      Zero length difference\n         MVC   REPLSCLN,PCTSCLEN   Set default 'scan found length'\n         ST    OREG,OREGM          Put OREG into memory\n         CLI   OREGALEN,X'00'      An A-operand length specified?\n         BE    *+16                No, skip\n         MVC   REPLSCLN,ZEROS      Yes, swap it in\n         MVC   REPLSCLN+3(1),OREGALEN\n         TM    PCTIOFLG,IODLML     A DLM type ALTER?\n         BZ    REPLREPL            No, OREGBLEN is correct already\n*---------------------------------------------------------------------+\n*        We don't yet know how long the source field is. (i.e. a DLM  |\n*        type ALTER.  This logic performs the needed scan to          |\n*        determine that now and set OREGBLEN to whatever it finds.    |\n*---------------------------------------------------------------------+\n         LR    R3,R6               Working copy of B-operand\n         CLM   R6,8,=X'00'         A buffer index in R6?\n         BNE   REPLBUFL            Yes, go do it\n         LA    R15,256             No, set 256 byte default\n         B     REPLSTLN            Continue with it\n*\nREPLBUFL LR    R15,R6              Isolate I/P file number index\n         SRL   R15,24              and multiply it by 4\n         SLL   R15,2               .\n         LA    R1,PCTINPT1-4(R15)  Point at address of this buffer\n         L     R1,0(R1)            Now point at the buffer\n         LA    R15,PCTINPL1-4(R15) Point at length of this buffer\n         L     R15,0(R15)          Get length of record\n         AR    R15,R1              Point at end of rec +1\n         TM    PCTIOFLG,IOFLOATB   Floating B-operand?\n         BZ    REPLNOBA            No, skip\n         TM    PCTIOFLG,IONOBADJ   NO B adjust?\n         BO    REPLNOBA            Correct, skip\n         AL    R3,PCTPLOC          Adjust location by PLOC\n         BCTR  R3,0                -1 (PLOC is next byte)\n*\nREPLNOBA LA    R3,0(,R3)           Clear hi byte of R6\n         SR    R15,R3              Calc remaining portion of record\n         BNP   REPLEXIT            Negative, ignore it\n         LA    R1,256              Check against max\n         CR    R15,R1              .\n         BNH   *+6                 <= 256, use it\n         LR    R15,R1              > swap 256 into it\n*\nREPLSTLN BCTR  R15,0               -1 for EX\n         EX    R15,REPLTRT         Look for delimiter\n         BZ    REPLEXIT            Do nothing if none\n         SR    R1,R3               Calc length found\n         LTR   R1,R1               Zero?\n         BZ    REPLEXIT            Yes, exit\n         STH   R1,OREGBLEN         Save as if passed to us\n         TM    PCTIOFLG,IONOEXPC   No expand/compress?\n         BZ    REPLREPL            No\n         ST    R1,REPLSCLN         Yes, make this the 'scan length'\n*---------------------------------------------------------------------+\n*        We now have the length, either passed to us or calculated    |\n*        by the above code based on the DLM logic.                    |\n*---------------------------------------------------------------------+\n*\nREPLREPL MVC   PCTFLEN+2(2),OREGBLEN Save ALTER's length\n         TM    PCTIOFLG,IOFLOATA   Floating A-operand\n         BZ    REPLRNOA            No, skip\n         TM    PCTIOFLG,IONOAADJ   No A adjust?\n         BO    REPLRNOA            Correct, skip\n         AL    R4,PCTPLOC          Yes, add PLOC then\n         BCTR  R4,0                -1 (PLOC is one past found)\n*\nREPLRNOA TM    PCTIOFLG,IOFLOATB   Floating B-operand\n         BZ    REPLRNOB            No, skip\n         TM    PCTIOFLG,IONOBADJ   No B adjust?\n         BO    REPLRNOB            Correct, skip\n         AL    R6,PCTPLOC          Yes, add PLOC then\n         BCTR  R6,0                -1 (PLOC is one past found)\n*---------------------------------------------------------------------+\n*        Now see if any expand or contraction of the record is needed |\n*        based on the lengths of the A and B operands.                |\n*---------------------------------------------------------------------+\n*\nREPLRNOB TM    PCTIOFLG,IONOEXPC   NOEXPC asked for?\n         BO    REPLEQUL            Yes, ignore expand contract\n         TM    PCTIOFLG,IOFLOATA   Floating A-operand?\n         BO    REPLTSTL            Yes, go compare lengths\n         CLI   OREGALEN,X'00'      Called with A-operand length?\n         BE    REPLEQUL            No, continue via EQUL\n*\nREPLTSTL CLC   OREGBLEN,REPLSCLN+2 Compare replace and found lengths\n         BH    REPLEXPN            High, go expand\n         BL    REPLCONT            Low, go contract\n         EJECT\n*---------------------------------------------------------------------+\n*        Expand/Contract has either been done or skipped, the         |\n*        B-operand is now moved into place.                           |\n*---------------------------------------------------------------------+\n*\nREPLEQUL LA    R4,0(,R4)           Purify pointer regs\n         LA    R6,0(,R6)           .\n         SR    R3,R3               Isolate I/P file number index\n         IC    R3,REPLSAV1         and multiply it by 4\n         SLL   R3,2                .\n         LA    R2,PCTINPT1-4(R3)   Point at address of this buffer\n         L     R2,0(R2)            Now point at the buffer\n         LA    R3,PCTINPL1-4(R3)   Point at length of buffer\n         L     R3,0(R3)            Now load buffer length\n         AR    R3,R2               Point 1 past buffer\n         SH    R3,OREGBLEN         Reduce by length of move\n         SR    R3,R4               and by starting location\n         BM    REPL0C4             Sorry, you lose\n         LH    R15,OREGBLEN        Get the length now\n         BCTR  R15,0               -1 for EX\n         EX    R15,REPLMVEQ        Move the data\n         LA    R4,1(R4,R15)        Point at last byte of moved data + 1\n         SR    R4,R2               Calc offset of last byte+1\n         ST    R4,PCTFLOCT         Save as FLOCTERM\n*\nREPLEXIT LM    R4,R6,REPLSAV1      Reload execution code regs\n         BR    R14                 And return\n*\nREPL0C4  $ERR  BUFFR,16,FLAG=NO    Issue error msg\n         OI    PCTF1,EXEC          Say we're in user's program\n         ABEND 16                  Issue User abend\n*\nREPLTRT  TRT   0(0,R3),0(OREG)\nREPLMVEQ MVC   0(0,R4),0(R6)       .\n         EJECT\n*---------------------------------------------------------------------+\n*        Replace a field (expand record to make room 1st)             |\n*---------------------------------------------------------------------+\n*\nREPLEXPN LH    R15,OREGBLEN        Calc difference in lengths\n         S     R15,REPLSCLN        .\n         ST    R15,PCTFLCHG        Save for FLCHG keyword\n         LR    R15,R4              Isolate Dest. buffer number\n         SRL   R15,24              and multiply it by 4\n         SLL   R15,2               .\n         LA    R7,PCTINPL1-4(R15)  Point at length of this buffer\n         L     R3,0(R7)            Get length\n         A     R3,PCTFLCHG         Adjust by expand amount\n         CLM   R4,8,=X'0A'         In UBUFF's or I/P buffers?\n         BNE   REPLNBFA            Yes, don't adjust them\n         CH    R3,DCBHLREC         Are we passing the max?\n         BH    REPL0C4             Yes, kill the sucker\n         ST    R3,0(R7)            Put adjusted length back\n*\nREPLNBFA L     R7,0(R7)            Get adjusted length of the record\n         LA    R2,PCTINPT1-4(R15)  Point at address of this buffer\n         L     R2,0(R2)            Now point at the buffer\n         AR    R2,R7               Point at end of O/P buffer\n         BCTR  R2,0                -1\n         TM    PCTIOFLG,IOFLOATA   Floating A-operand?\n         BO    REPLFLCL            Yes, do floating calculation\n         LA    R1,PCTINPT1-4(R15)  Get address of this buffer again\n         L     R1,0(R1)            .\n         LA    R15,0(,R4)          Get operand address\n         SR    R15,R1              Calc its offset\n         SR    R7,R15              Reduce length by offset\n         S     R7,PCTFLCHG         And by difference\n         BNP   REPL0C4             Better not be negative\n         BCTR  R7,0                One more\n         B     REPLENDA            Go calc end address\n*\nREPLFLCL TM    PCTIOFLG,IONOAADJ   Skip A adjust?\n         BO    *+8\n         S     R7,PCTPLOC          Adjust length by offset\n         S     R7,PCTFLCHG         Also less difference\n         BNP   REPL0C4             Better not be negative\n         BCTR  R7,0                -1\n*\nREPLENDA LR    R3,R2               Create end address of source\n         S     R3,PCTFLCHG         .\n         LA    R0,256              Put const 256 in R0\n         SR    R2,R0               Decr by initial 256\n         SR    R3,R0               .\n*\nREPLEX1  CR    R7,R0               More that 256 to move?\n         BL    REPLEX2             No\n         MVC   TRTABLE(256),0(R3)  Shift one chunk using TRTABLE\n         MVC   0(256,R2),TRTABLE   As a temp area\n         SR    R2,R0               Decr by another 256\n         SR    R3,R0               .\n         SR    R7,R0               Also decr count\n         B     REPLEX1             Loop till less than 256 left\n*\nREPLEX2  AR    R2,R0               Add back the 'one too many'\n         AR    R3,R0               .\n         SR    R2,R7               Less remaining length\n         SR    R3,R7               .\n         EX    R7,*+4              Shift last chunk\n         MVC   TRTABLE(0),0(R3)    .\n         EX    R7,*+4              .\n         MVC   0(0,R2),TRTABLE     .\n         B     REPLEQUL            Go copy data\n         EJECT\n*---------------------------------------------------------------------+\n*        Replace a field (contract record around it)                  |\n*---------------------------------------------------------------------+\n*\nREPLCONT STM   R4,R6,REPLSAV2      Save for a while\n         LR    R15,R4              Isolate Dest. buffer number\n         SRL   R15,24              and multiply it by 4\n         SLL   R15,2               .\n         LTR   R15,R15             Better not be zero\n         BNZ   *+6                 O.K. continue\n         DC    H'0'                Just S0C1 for now\n         LA    R2,PCTINPT1-4(R15)  Point at pointer to this buffer\n         L     R2,0(R2)            Now point at the buffer\n         TM    PCTIOFLG,IOFLOATA   Floating A-operand?\n         BZ    REPLFIXI            No\n         TM    PCTIOFLG,IONOAADJ   No A adjust?\n         BO    REPLFIXI            No\n         A     R2,PCTPLOC          Add offset into record\n         BCTR  R2,0                -1 (PLOC is one past)\n         B     REPLCDIF            Now go calc difference\n*\nREPLFIXI LR    R2,R4               For fixed just get A-operand\n         LA    R2,0(,R2)           Purify hi-byte\n*\nREPLCDIF L     R0,REPLSCLN         Calc difference in lengths\n         SH    R0,OREGBLEN         .\n         LCR   R0,R0               Change sign\n         ST    R0,PCTFLCHG         Save for FLCHG KW\n         LCR   R0,R0               Back again\n         LR    R6,R2               Calc input location\n         AR    R6,R0               .\n         LA    R3,PCTINPL1-4(R15)  Calc. destination length\n         L     R3,0(R3)            Load the length of record\n         TM    PCTIOFLG,IOFLOATA   Floating A-operand?\n         BZ    REPLFIXL            No\n         TM    PCTIOFLG,IONOAADJ   No A adjust?\n         BO    REPLFIXL            No\n         S     R3,PCTPLOC          Less offset\n         B     REPLCSRL            Go calc source length\n*\nREPLFIXL LA    R7,0(,R4)           Get orig dest. loc.\n         LA    R1,PCTINPT1-4(R15)  Point at pointer to this buffer\n         L     R1,0(R1)            Now point at the buffer\n         SR    R7,R1               Calc its offset\n         SR    R3,R7               Adjust length\n*\nREPLCSRL LR    R7,R3               Calc source length\n         SR    R7,R0               .\n         ICM   R7,8,PCTPADCH       Insert specified fill character\n         MVCL  R2,R6               Shift it left\n         LM    R4,R6,REPLSAV2      Restore regs\n         B     REPLEQUL            Go copy data\n*\nREPLSCLN DS    F\nREPLSAV1 DS    3F\nREPLSAV2 DS    3F\n         TITLE 'TRACE - Trace compiled Pgm logic'\n*---------------------------------------------------------------------+\n*        List STMNT # and WORD # on SYSPRINT                          |\n*---------------------------------------------------------------------+\n*\nTRACE    MVC   PCTLAST,0(R14)      Save the stmnt./word #\n         LA    R14,4(,R14)         Adjust the pseudo base\n         TM    PCTF7,DBTRACE       Return immed. if no TRACE\n         BZR   R14                 Goback +4 around data\n         STM   R14,R1,TRSV         Save regs\n         LM    R14,R15,TRPOS       Get pointers to TRACE line\n         MVI   0(R14),C'<'         Stuff in delims\n         MVI   9(R14),C'>'         .\n         MVI   5(R14),C'/'         .\n         LH    R0,PCTLAST          Pickup stmnt number\n         CVD   R0,DBL\n         UNPK  1(4,R14),DBL+5(3)   Put it in TRACE line\n         OI    4(R14),X'F0'        Make it pretty\n         LH    R0,PCTLAST+2        Pick up word number\n         CVD   R0,DBL\n         UNPK  6(3,R14),DBL+6(2)   Put it in print line\n         OI    8(R14),X'F0'        Make it pretty\n         MVC   TRLINE(30),=C'Trace . . . . . . . . . . . . '\n         LA    R14,10(,R14)        Bump to next position\n         CR    R14,R15             Time to print?\n         BL    TRACEXIT            No, not yet\n         MVC   LINE,TRLINE         Yes, then\n         MVC   TRLINE,BLANKS       Blank line\n         BAL   R14,LINPRINT        Print it\n         LA    R14,TRLINE+31       Then reset pointer\n*\nTRACEXIT ST    R14,TRPOS           Save position for next time\n         LM    R14,R1,TRSV         Reload regs\n         BR    R14                 And return\n         TITLE 'SUBRETN - Do a GOBACK'\n*---------------------------------------------------------------------+\n*        Pick  up the address saved by GOSUB and go to it             |\n*---------------------------------------------------------------------+\n*\nSUBRETN  STM   R14,R1,SUBSSAVE     Save regs\n         L     R1,PCTSUBSV         Get next place to save it\n         SH    R1,=H'4'            Backup 1 entry\n         C     R1,=A(SUBSAVE1)     Too far?\n         BL    SUBRABND            Yes, blow it all up\n         ST    R1,PCTSUBSV         Save new save address\n         L     R14,0(R1)           Pickup the address to go to\n         BR    R14                 And go to it\n*\nSUBRABND $ERR  BAKEX,16,FLAG=NO    Issue error msg\n         OI    PCTF1,EXEC          Say we're in user's program\n         ABEND 16                  Issue User abend\n         TITLE 'SUBSAVE - Save return address for a GOSUB'\n*---------------------------------------------------------------------+\n*        Setup the return address for a GOSUB command                 |\n*---------------------------------------------------------------------+\n*\nSUBSAVE  STM   R14,R1,SUBSSAVE     Save regs\n         LA    R0,8(R14)           Calc return address to save\n         L     R1,PCTSUBSV         Get next place to save it\n         ST    R0,0(R1)            Save the return\n         LA    R1,4(,R1)           Bump to next save slot\n         C     R1,=A(SUBSAVE2)     Too far?\n         BE    SUBSABND            Yes, blow it all up\n         ST    R1,PCTSUBSV         Save new save address\n         LM    R14,R1,SUBSSAVE     Reload regs\n         BR    R14                 And return\n*\nSUBSABND $ERR  SUBEX,16,FLAG=NO    Issue error msg\n         OI    PCTF1,EXEC          Say we're in user's program\n         ABEND 16                  Issue User abend\n*\nSUBSSAVE DS    4F\n         TITLE 'Crutch routines'\n*---------------------------------------------------------------------+\n*              Addressability type crutches                           |\n*---------------------------------------------------------------------+\n*\nMAINGEOS L     R8,=A(MAINCOMP)     Get base of proc set up\n         B     MAINGEOX-MAINCOMP(R8) go to entry point\n*\nMAINGOK  L     R8,=A(MAINCOMP)     Get base of proc set up\n         B     MAINGOKX-MAINCOMP(R8) go to entry point\n*\nINICHOOS L     R8,=A(INISLECT)     Get base of proc set up\n         B     INICHOOX-INISLECT(R8) go to entry point\n*\nEODAD    L     R8,=A(COPYDATA)     Get base of proc set up\n         B     COPEOFIN-COPYDATA(R8) go to entry point\n*---------------------------------------------------------------------+\n*        Misc routines  for ALTER  (ALTER needs more addressability)  |\n*---------------------------------------------------------------------+\n*\nALTNERR  $ERR  BADN,8,SKIP         Say bad numerics\n*\nALTTBT   $ERR  BADAT,8,SKIP        Issue err msg\n*\nALTLCONF $ERR  LCONF,8,SKIP        Issue err msg\n*---------------------------------------------------------------------+\n*              Duplicate code type crutches                           |\n*---------------------------------------------------------------------+\n*\nEXITGEOS TM    PCTF4,IFNXSENT      Genning within an IF?\n         BZ    MAINGEOS            No, leave now\n         $CALL POPIF               Yes, POP one next sentence pointer\n         NI    PCTF4,255-IFNXSENT  and clear the flag\n         B     MAINGEOS            Now leave\n*\nEXITGOK  TM    PCTF4,IFNXSENT      Genning within an IF?\n         BZ    MAINGOK             No, leave now\n         $CALL POPIF               Yes, POP one next sentence pointer\n         NI    PCTF4,255-IFNXSENT  and clear the flag\n         B     MAINGOK             Now leave\n         TITLE 'Compiled code support routines'\n*---------------------------------------------------------------------+\n*        Following instructions are EXecuted by compiled code         |\n*---------------------------------------------------------------------+\n*\nCOMPMVC  MVC   0(0,AREG),0(BREG)   Executed by compiled code\nCOMPNC   NC    0(0,AREG),0(BREG)   .\nCOMPOC   OC    0(0,AREG),0(BREG)   .\nCOMPXC   XC    0(0,AREG),0(BREG)   .\nCOMPTR   TR    0(0,AREG),0(BREG)   .\nCOMPCLC  CLC   0(0,AREG),0(BREG)   .\nCOMPCP   CP    0(0,AREG),0(0,BREG) .\nCOMPCR   CR    R0,R1               .\nCOMPTM   TM    0(AREG),0           .\nCOMPMSK1 MVC   TRTABLE(0),0(BREG)  .\nCOMPMSK2 TR    TRTABLE(0),MASKTBL  .\nCOMPMSK3 NC    TRTABLE(0),0(AREG)  .\nCOMPMSK4 CLC   TRTABLE(0),0(BREG)  .\n         EJECT\n*---------------------------------------------------------------------+\n*        Following 'mini' routines aid compiled code addressability   |\n*        problems by avoiding need for BALR R14,0's all the time      |\n*---------------------------------------------------------------------+\n*---------------------------------------------------------------------+\n*        Called by BAL   R14,COMPGOTO      Transfer Ctl. to GOTO adr. |\n*                  DC    A(where-to-go)                               |\n*---------------------------------------------------------------------+\n*\nCOMPGOTO TM    PCTF7,TIMEFLAG      STIMER needed?\n         BZ    COMPGGO             No, just GOTO\n*\nCOMPGTIM NI    PCTF7,255-TIMEFLAG  Clear flag\n         ST    R14,DBL             Save R14\n         STIMER TASK,TIMEEXIT,TUINTVL=ONESEC Re-issue STIMER\n         L     R14,DBL             Reload R14\n*\nCOMPGGO  ICM   R14,15,0(R14)       Pick up GOTO address\n         BR    R14                 Go to it\n*---------------------------------------------------------------------+\n*        Called by BAL   R10,COMP10X4      Set R10 -> 4 bytes of data |\n*                  DC    A(data)           and continue at R10+4      |\n*---------------------------------------------------------------------+\n*\nCOMP10X4 B     4(R10)              Branch around data\n*---------------------------------------------------------------------+\n*        Called by BAL   R7,COMP7X4        Set R7  -> 4 bytes of data |\n*                  DC    A(data)           and continue at R7+4       |\n*---------------------------------------------------------------------+\n*\nCOMP7X4  B     4(R7)               Branch around data\n*---------------------------------------------------------------------+\n*        Called by BAL   R15,COMP15X4      Set R15 -> 4 bytes of data |\n*                  DC    A(data)           and continue at R15+4      |\n*---------------------------------------------------------------------+\n*\nCOMP15X4 B     4(R15)              Branch around data\n*---------------------------------------------------------------------+\n*        Called by BAL   R15,COMP15X8      Set R15 -> 8 bytes of data |\n*                  DC    A(data1)          and continue at R15+8      |\n*                  DC    A(data2)                                     |\n*---------------------------------------------------------------------+\n*\nCOMP15X8 B     8(R15)              Branch around data\n         TITLE 'DCB exit lists and OPEN exits'\n         PUSH  USING\n         DROP  R7\n         USING FCBDSECT,R4\n*---------------------------------------------------------------------+\n*        SYSIN exit list                                              |\n*---------------------------------------------------------------------+\n*\nINXLST   DS    0F\n         DC    X'05',AL3(INOPEX)\n         DC    X'87',AL3(JFCB)\n*\nINOPEX   DS    0H\n         CLC   DCBBLKSI(2,R1),ZEROS\n         BNER  R14\n         MVC   DCBBLKSI(2,R1),=H'80'\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------+\n*        SYSPRINT exit list                                           |\n*---------------------------------------------------------------------+\n*\nPRXLST   DS    0F\n         DC    X'05',AL3(PROPEX)\n         DC    X'87',AL3(JFCB)\n*\nPROPEX   LR    R4,R1                      Copy DCB pointer\n         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB\n         SR    R4,R3                      Backup to start of FCB\n         LR    R2,R1                      Save R1\n         MVC   DDNAME,FCBDDNAM            Setup and\n         DEVTYPE DDNAME,DEVTAB            Get device type\n         LR    R1,R2                      Restore R1\n         NI    DCBRECFM(R1),X'FD'         Setup as ASA\n         OI    DCBRECFM(R1),X'04'         .\n         TM    DCBRECFM(R1),X'C0'         Any RECFM setup/\n         BNZ   *+8                        Yes, leave alone\n         OI    DCBRECFM(R1),X'90'         No, make it FB\n         TM    DCBRECFM(R1),X'C0'         RECFM=U?\n         BO    PROS133                    Yes\n         TM    DCBRECFM(R1),X'80'         RECFM=F?\n         BO    PROS133                    Yes\n         B     PROS137                    No, must be RECFM=V\n*\nPROS133  MVC   PROLRECL,=H'133'           Set 133 defaults\n         MVC   PROBLKSI,=H'133'\n         B     PROCOMN\n*\nPROS137  MVC   PROLRECL,=H'137'           Set 137 defaults\n         MVC   PROBLKSI,=H'141'\n*\nPROCOMN  TM    DEVTAB+2,X'28'             Tape/DASD device\n         BZ    PROCTEST                   No, leave unblocked\n         TM    DCBRECFM(R1),X'10'         Blocked RECFM?\n         BZ    PROCTEST                   No, also leave alone\n         MVC   PROBLKSI,=H'0'             Else let system assign it\n*\nPROCTEST CLC   DCBLRECL(2,R1),PROLRECL    Sufficient LRECL?\n         BL    PROSLREC                   No, go give it one\n         CLC   DCBBLKSI(2,R1),ZEROS       A blocksize?\n         BNER  R14                        Yes, leave it alone\n*\nPROSLREC MVC   DCBLRECL(2,R1),PROLRECL    Setup LRECL/BLKSIZE\n         MVC   DCBBLKSI(2,R1),PROBLKSI\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------+\n*         INPUTn exit list                                            |\n*---------------------------------------------------------------------+\n*\nUT1LIST  DS    0F\n         DC    X'05',AL3(UT1EX)\n         DC    X'87',AL3(JFCB)\n*\nUT1EX    LR    R4,R1                      Copy DCB pointer\n         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB\n         SR    R4,R3                      Backup to start of FCB\n         ST    R4,OPEXFCBP                Save FCB pointer\n         TM    FCBF2,FCB1ST               First time?\n         BO    UT1B                       No\n         OI    FCBF2,FCB1ST               Turn it on for next time\n         CLC   FCBJFCB(9),=C'NULLFILE '   Is the file dummied?\n         BNE   UT1NDMY                    No, skip next bit\n         CLC   FCBDDNAM,MDINPT1+2         Is it INPUT1\n         BE    UT1NDMY                    Skip if it is\n         CLC   DCBBLKSI(2,R1),ZEROS       Any BLKSIZE?\n         BNE   *+10                       Yes, skip\n         MVC   DCBBLKSI(2,R1),DEFBLKSI    No, give it one\n         CLC   DCBLRECL(2,R1),ZEROS       Any LRECL?\n         BNE   *+10                       Yes, skip\n         MVC   DCBLRECL(2,R1),DCBBLKSI(R1) No, give it one\n         CLI   DCBRECFM(R1),X'00'         Any RECFM?\n         BNE   *+10                       Yes, skip\n         MVC   DCBRECFM(1,R1),DEFRECFM    No, give it one\n*\nUT1NDMY  OI    DCBOFLAG(R1),X'08'         Turn on user concat in DCB\n         TM    DCBRECFM(R1),X'80'         RECFM U or F?\n         BOR   R14                        Yes, done\n         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?\n         BNOR  R14                        No, done\n         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A\n         BR    R14                        Now leave\n*\nUT1B     OI    FCBF2,FCBRREAD             Turn on reread sw\n         L     R3,=A(FASTCONC)\n         OI    1(R3),X'F0'                Also SW in FASTCOPY route\n         MVC   FCBRECAD,=A(0)             Zero ptr to record\n         NI    DCBBFTEK(R1),255-X'20'     BFTEK=A off\n         TM    DCBRECFM(R1),X'80'         RECFM U or F?\n         BO    UT1C                       Yes, skip over\n         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?\n         BNO   UT1C                       No, skip over\n         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A\n*\nUT1C     ST    R14,OPEXSV14               Save return address\n         CLC   FCBDDNAM,MDINPT1+2         Is it INPUT1\n         BNE   UT1CST                     Skip if not\n         TM    PCTF3,FAST                 Doing a fast copy\n         BZ    *+12                       No\n         ST    R7,FCBCOUNT                Yes, store counter right now\n         ST    R7,FCBCREC                 .\n*\nUT1CST   L     R7,OPEXFCBP                Get pointer to FCB\n         L     R3,FCBCOUNT                Format prev dataset stats\n         CVD   R3,DBL                     Count\n         MP    DBL,=P'10'          Shift it for ED\n         MVC   ERRCWORK(11),=X'4020206B2020206B202120'\n         ED    ERRCWORK(11),DBL+3  Put count in msg\n         L     R2,=A(ERRTX37)      Get msg addressable\n         MVC   1(10,R2),ERRCWORK+1 Copy edited data\n         MVC   33(8,R2),FCBDDNAM          Put DDname in message\n         MVC   46(54,R2),FCBDSNAM          \"  Dsname\n         $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         $ERR  MSG37,0,SAVE=YES,TYPE=STAT,FLAG=NO\n         L     R7,OPEXFCBP\n         $CALL MSG52FMT\n         B     UT1NOM52\n         $ERR  MVOLS,0,SAVE=YES,TYPE=STAT,FLAG=NO\n*\nUT1NOM52 L     R7,OPEXFCBP\n         $CALL MSG39FMT\n         $ERR  MSG39,0,SAVE=YES,TYPE=STAT,FLAG=NO\n*\nUT1EXIT  L     R14,OPEXSV14\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------+\n*        OUTPUT1 / anynamedd exit list                                |\n*---------------------------------------------------------------------+\nUT2LIST  DS    0F\n         DC    X'05',AL3(UT2EX)\n         DC    X'87',AL3(JFCB)\n*\nUT2EX    LR    R4,R1                      Copy DCB pointer\n         LA    R3,FCBDCB-FCBCHAIN         Calc pos of DCB in FCB\n         SR    R4,R3                      Backup to start of FCB\n         CLI   DCBRECFM(R1),X'00'         Any RECFM there ?\n         BNE   *+10                       Yes, skip\n         MVC   DCBRECFM(1,R1),DEFRECFM    No, stuff it\n         TM    DCBRECFM(R1),X'C0'         Undefined?\n         BO    UT2LRLOK                   Yes, ignore LRECL setting\n         CLC   DCBLRECL(2,R1),ZEROS       LRECL?\n         BNE   UT2LRLOK                   Yes, leave alone\n         MVC   DCBLRECL(2,R1),DEFLRECL    Stuff in DEFLRECL\n         L     R3,WKTIOT                  Get TIOT address\n         AH    R3,DCBDDNAM(R1)            Point at our TIOT entry\n         STM   R0,R15,SWASAVE             Save everything\n         LA    R1,12(R3)                  -> JFCB token\n         L     R2,=A(GTSWABLK)            Get routine address\n         BALR  R14,R2                     Go get block\n         LM    R0,R15,SWASAVE             Load everything\n         L     R3,=A(SWABLKA)             Get SWA block address\n         TM    4+X'44'(R3),X'20'          SYSOUT flagged in JFCBTSDM?\n         BZ    UT2LRLOK                   No, use normal default\n         LH    R3,DCBLRECL(R1)            Get LRECL\n         TM    DCBRECFM(R1),X'40'         Variable?\n         BZ    *+8                        No, skip\n         LA    R3,4(,R3)                  Yes, add 4 for RDW\n         STH   R3,DCBBLKSI(R1)            Stuff into BLKSIZE\n*\nUT2LRLOK CLC   DCBBLKSI(2,R1),ZEROS       BLKSIZE?\n         BNE   UT2BLKOK                   Yes, skip\n         TM    PCTF8,CBLKSIZE             No, Asked to Copy it?\n         BZ    UT2BLKOK                   No again, skip the copy\n         MVC   DCBBLKSI(2,R1),DEFBLKSI    Else, copy the BLKSIZE\n*\nUT2BLKOK L     R15,PCT1DCB                Point at INPUT1 DCB\n         TM    DCBRECFM(R1),X'80'         RECFM U or F?\n         BO    UT2B                       Yes, skip over\n         TM    DCBRECFM(R1),X'48'         RECFM VBS/VS ?\n         BNO   UT2B                       No, skip over\n         OI    DCBBFTEK(R1),X'60'         Make BFTEK=A\n*\nUT2B     BR    R14\n         POP   USING\n         TITLE 'Commonly addressable error msgs'\n*---------------------------------------------------------------------+\n*        Commonly addressable error routines                          |\n*---------------------------------------------------------------------+\n*\nBADLITBT $ERR  LITBT,8,SKIP\n*\nBADLITBH $ERR  LITBH,8,SKIP\n*\nBADLITBL $ERR  LITBL,8,SKIP\n*\nBADLITBQ $ERR  LITBQ,8,SKIP\n*\nBADLITBN $ERR  LITBN,8,SKIP\n*\nBADNUMB  $ERR  BADN,8,SKIP\n*\nBADLGTH  $ERR  BLGTH,8,SKIP\n*\nBADSYSPR WTO   'SELECTIT - NO SYSPRINT, BUT PRINT AND/OR DEBUG REQUESTSX\n                ARE PRESENT',                                          X\n               ROUTCDE=(11),MCSFLAG=HRDCPY\n         ABEND 12\n*\nBADKWORD $ERR  BADKW,8,SKIP        Invalid keyword found\n*\nBADKWVAL $ERR  BKWV,8,SKIP\n*\nBADOPTYP $ERR  BADOP,8,SKIP        Invalid operand format\n*\nBADDCB   $SKIP\n*\nBADIO    $ERR  CLOSI,16,FLAG=NO    Issue error msg\n         OI    PCTF1,EXEC          Say we're in user's program\n         ABEND 16                  Force User abend\n         TITLE 'Literal Pool for Main program'\n         LTORG\n         TITLE 'Asynch STAE exit routine'\n*---------------------------------------------------------------------+\n*        See if ABEND is in user's pgm or in main program             |\n*---------------------------------------------------------------------+\n         DS    0H\n         PUSH  USING\n         DROP\n         USING *,R15\n*\nABNDEXIT STM   R14,R12,12(R13)     Save systems regs\n         L     R7,0(R1)            Get address of PCT\n*\nABNDFORC NOP   ABNDRETN            Force abend if TRACE or DEBUG\n         TM    PCTF4-PCT(R7),ABENDING Have we been here before?\n         BO    ABNDRETN            Yes, let abend get rid of us\n         MVC   PCTABEND-PCT(4,R7),4(R1) Save ABEND code\n         OI    PCTF4-PCT(R7),ABENDING Show STAE occurred\n         TM    7(R1),X'FF'         Any user abend?\n         BNZ   ABNDRETR            Yes, go the retry route\n         TM    5(R1),X'FF'         S00x ABEND?\n         BZ    ABNDRETN            Let it continue\n         TM    PCTF1-PCT(R7),EXEC  Is execution in user pgm\n         BZ    ABNDRETN            No, tell ABEND to continue\n*\nABNDRETR NI    PCTABEND-PCT(R7),X'7F' Remove DUMP option\n         MVC   20(4,R13),=A(ABNDRCVR) Set retry address in R0\n         MVC   0(4,R1),=A(STAESAVE) Provide address of good regs\n         LM    R2,R7,=A(ERRTX44,PCTCOUNT,DBL,PCTLAST,PCTCOUNT,SNPTR)\n         TM    7(R1),X'FF'         User abend?\n         BZ    ABNDFMSY            No, system\n         LH    R8,6(R1)            Get user abend number\n         CVD   R8,ABNDDBL          Format it\n         UNPK  7(3,R2),ABNDDBL+6(2)\n         OI    9(R2),C'0'          .\n         B     ABNDCONT            Continue\n*\nABNDFMSY UNPK  7(3,R2),5(2,R1)     Format abend code into MSG44\n         MVZ   7(3,R2),=X'000000'\n         TR    7(3,R2),0(R7)       Translate to hex\n*\nABNDCONT L     R7,0(R6)            Format record number into MSG44\n         CVD   R7,0(R4)\n         UNPK  28(8,R2),3(5,R4)\n         OI    35(R2),X'F0'\n         LH    R7,0(R5)            Format STMNT # into msg44\n         CVD   R7,0(R4)\n         UNPK  58(4,R2),5(3,R4)\n         OI    61(R2),X'F0'\n         LH    R7,2(R5)            Format WORD # into msg44\n         CVD   R7,0(R4)\n         UNPK  72(3,R2),6(2,R4)\n         OI    74(R2),X'F0'\n         RETURN (14,12),RC=4       Return and call for retry\n*\nABNDRETN RETURN (14,12),RC=0       Return and continue with ABEND\n*\nABNDDBL  DS    D\n         LTORG\n         DROP  R15\n         POP   USING\n         TITLE 'Asynch TIMER exit routine'\n*---------------------------------------------------------------------+\n*        See if user is working i. e. not looping.                    |\n*---------------------------------------------------------------------+\n         DS    0H\n         PUSH  USING\n         DROP\n         USING *,R15\n*\nTIMEEXIT STM   R14,R12,12(R13)     Save systems regs\n         LM    R3,R4,=A(PCTF4,PCTF7) Point at some flags\n         TM    0(R3),IODONE        Some I/O done?\n         BZ    TIMEABND            No, force termination\n         NI    0(R3),255-IODONE    Reset IODONE flag\n         OI    0(R4),TIMEFLAG      Say we want STIMER re-issued\n         RETURN (14,12),RC=0       Return from exit\n*\nTIMEABND OI    0(R4),TIMEBOMB      Set timer failure flag\n         ABEND 16\n         LTORG\n         DROP  R15\n         POP   USING\n         TITLE 'ADDSTAT - Terminate the FCBs now'\n*---------------------------------------------------------------------+\n*        Loop down FCB chain and do termination processing for        |\n*        each FCB (Except SYSPRINT, otherwise it becomes very         |\n*        difficult to display statistics and end-of-job messages)     |\n*---------------------------------------------------------------------+\n*\nADDSTAT  $PROC\n         LA    R7,PCTFCB           Point at start of chain\n*\nADDCHN   LR    R3,R7               Swap regs\n         ICM   R7,15,0(R3)         Get next FCB\n         BZ    ADDEXIT             None, leave\n         CLC   FCBDDNAM,MDSYSP+2   Is this the SYSPRINT file\n         BE    ADDCHN              Yes, dont process it right now\n         TM    PCTF8,PDSMODE       Are we in PDSMODE?\n         BZ    ADDCALL             No, simply shutdown the FCB\n         TM    FCBF2,FCBPDS        Yes, is this a PDS mode file?\n         BZ    ADDCHN              No, ignore it\n*\nADDCALL  $CALL ADDPROC,(R7)        Process it\n         B     ADDCHN              Loop\n*\nADDEXIT  $RET  0                   Return\n         $PEND\n         TITLE 'ADDPROC - CLOSE an FCB and create msgs'\n*---------------------------------------------------------------------+\n*        CLOSE an FCB and create statistics messages for it           |\n*---------------------------------------------------------------------+\n*\nADDPROC  $PROC 1\n         L     R7,12(R8)           Get FCB address\n         CLC   FCBDDNAM,MDSYSP+2   Is this the SYSPRINT file\n         BE    ADDNCLS             Yes, dont close it yet\n         TM    FCBF1,FCBCLOSD      Already CLOSEd?\n         BO    ADDNCLS             Yes\n         OI    FCBF1,FCBCLOSD      Say we're closing it\n         TM    FCBDCB+48,X'10'     Is DCB open?\n         BZ    ADDNCLS             No, also skip close\n         LA    R2,FCBDCB           Get address of FCBDCB\n         RDJFCB ((R2))             Go read JFCB\n         MVC   FCBJFCB,JFCB        Save it\n         CLOSE ((R2))              Now close it\n         TM    FCBF2,FCBPDS        PDS mode?\n         BO    ADDNCLS             Yes, skip FREEPOOL\n         FREEPOOL (R2)             Free its buffers\n*\nADDNCLS  TM    FCBF1,FCBSTATS      Allowed?\n         BZ    ADDPEX0             No, skip\n         TM    FCBF2,FCBPDS        Yes, is this a PDS mode file?\n         BZ    ADDCKROM            No, go check for room\n         TM    PCTF8,PDSSTATS      PDS STATS requested?\n         BZ    ADDPEX0             No, skip these messages\n*\nADDCKROM NI    FCBF1,255-FCBSTATS  Kill until another OPEN happens\n         CP    =P'4',LINECT        Room on page?\n         BL    *+10                Yes, skip\n         ZAP   LINECT,=P'1'        No, force page head\n         L     R1,FCBCOUNT         Get output count\n         CVD   R1,DBL              Convert it\n         MP    DBL,=P'10'          Shift it for ED\n         MVC   ERRCWORK(11),=X'4020206B2020206B202120'\n         ED    ERRCWORK(11),DBL+3  Put count in msg\n         L     R2,=A(ERRTX37)      Get msg addressable\n         MVC   1(10,R2),ERRCWORK+1 Copy edited data\n         MVC   20(10,R2),=C'output to '\n         TM    FCBF2,FCBINPUT      Is this an input file?\n         BZ    *+10                No, leave as 'written to'\n         MVC   20(10,R2),=C'Read from ' Yes, alter message\n         MVC   33(8,R2),FCBDDNAM   Put DDname in message\n         MVC   46(54,R2),FCBDSNAM  Put DSNAME in msg\n         TM    FCBF2,FCBPDS        Is this a PDS mode file?\n         BZ    ADDIMSPC            No, DSNAME is just fine\n         TM    PCTF8,PDSMODE       If PDSMODE off, we're doing EOJ\n         BO    ADDIMSPC            No, also DSNAME is O.K.\n         MVC   46(54,R2),BLANKS    Yes, elim member from message\n         MVC   46(44,R2),FCBJFCB   .\n*\nADDIMSPC $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         $ERR  MSG37,0,SAVE=YES,TYPE=STAT,FLAG=NO Stack msg\n         $CALL MSG52FMT            Go format MSG52\n         B     ADDNO52B            None, skip\n         $ERR  MVOLS,0,SAVE=YES,TYPE=STAT,FLAG=NO\n*\nADDNO52B $CALL MSG39FMT            Go format MSG39 and return\n         $ERR  MSG39,0,SAVE=YES,TYPE=STAT,FLAG=NO\n*\nADDPEX0  TM    PCTF8,PDSMODE       PDS mode?\n         BZ    ADDPEX00            No, skip right out\n         TM    FCBF2,FCBPDS        PDS mode on this FCB?\n         BZ    ADDPEX00            No, skip right out\n         L     R2,PCTMEMBC         Get next member address\n         CLC   0(8,R2),=8X'FF'     Another member to do?\n         BE    ADDPEX00            No, don't reset the FCB\n         OI    FCBF1,FCBDOPEN      Yes, reset for future OPEN\n         NI    FCBF1,255-FCBOPEN-FCBCLOSD\n         NI    FCBF2,255-FCBEOF-FCBRREAD-FCB1ST\n         MVC   FCBCREC,ZEROS\n         TM    PCTF8,PDSSTATS      PDS STATS requested?\n         BZ    ADDPEX00            No, skip these messages\n         MVC   FCBCOUNT,ZEROS\n*\nADDPEX00 $RET  0                   Go back\n         $PEND\n         TITLE 'ALTER command processor'\n*---------------------------------------------------------------------+\n*        A L T E R   C o m m a n d   P r o c e s s o r                |\n*---------------------------------------------------------------------+\n*\nALTER    $PROC\n         LA    R10,4095(,R8)\n         LA    R10,1(,R10)\n         USING ALTER+4096,R10\n         USING KWDSECT,R14\n         OI    PCTF1,ACTIVE        Show command active\n         OI    PCTF3,COMPALTR      Let OPGEN know its ALTER\n         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address\n         MVC   OREGM,ZEROS         Clear the OREG work area\n         MVC   ALTAKWLN,ZEROS      Clear the KW A-operand length\n         MVI   PCTIOFLG,X'00'      Clear IO flags\n         MVI   PCTIOFL2,X'00'      .\n         NI    PCTF1,255-DCOPYGEN  Clear DCOPYDAT genned flag\n         NI    PCTF3,255-OPKWLEN   Clear OPKWLEN flag\n         $CALL DBGADD              Go add DEBUG code\n*---------------------------------------------------------------------+\n*        Get and process the destination operand (A-operand) unless   |\n*        its the COPYBUFF keyword, in which case split off elsewhere. |\n*---------------------------------------------------------------------+\n         $CALL GETNEXT             Go get the dest. operand\n         TM    WFLAG1,WWRD1        Possible buffer operand?\n         BNO   ALTSTDEF            No, continue\n         TM    WRD1F2,OPRKW+OPRKWV Valid KW. e.g. UBUFFx?\n         BNO   ALTSTDEF            No, go skip COPYBUFF logic\n         TM    WRD1F2,OPRKWOP      A KW(...) type?\n         BO    ALTTRCB             Yes, try COPYBUFF(...) type\n         LA    R14,WRD1KW1         No, see what keyword then\n         CLI   KWNUM,X'E5'         INPUTx?\n         BE    ALTGBNO             Yes, got an INPUTx buffer\n         CLI   KWNUM,X'E4'         UBUFFx ?\n         BE    ALTGBNO             Yes, got a UBUFFx\n         CLI   KWNUM,X'E3'         OBUFF ?\n         BNE   ALTSTDEF            No, skip\n*\nALTGBNO  L     R1,KWD3             Get buffer index\n         SLL   R1,2                x 4\n         ST    R1,ALTGUONX         Stuff in area\n         B     ALTCBFO             Continue, got buffer address\n*\nALTTRCB  TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Maybe, a valid KW and fmt?\n         BNO   ALTSTDEF            No, continue\n         LA    R14,WRD1KW1         Point at KW answer area\n*\nALTSTDEF MVI   WFLAG2,WAOP+WPREFOK+WTRLR Say what operand types are OK\n         $CALL OPGEN               Go gen code for the A-operand\n         B     BADOPTYP            +0 Invalid, kill it\n         MVC   ALTGDISP,OPGDISPL   Save generated displacement\n         MVC   ALTGABUF,OPGBASE    Save generated A-operand buffer\n         CLI   ALTGABUF,X'0A'      O/P buffer?\n         BE    ALTSGDCP            Yes, add deferred copy code\n         CLI   ALTGABUF,X'01'      Primary I/P buffer?\n         BNE   ALTSNDCP            No, skip\n*\nALTSGDCP $ADD  4,DCOPM010          Add test for deferred copy\n         OI    PCTF1,DCOPYGEN      Remember DCOPYDAT genned\n*\nALTSNDCP TM    WFLAG1,WWRD1        Got basic word?\n         BZ    ALTGNTYP            No, skip\n         TM    WRD1F2,OPRKW+OPRKWV A valid keyword?\n         BNO   ALTGNTYP            No, skip\n         CLI   WRD1KW1+(KWNUM-KWDSECT),X'AC' Was it RCODE?\n         BNE   ALTGNTYP            No, skip\n         $ADD  4,ALTGRCST          Yes, remember user altered it\n         EJECT\n*---------------------------------------------------------------------+\n*        Now get the type of ALTER to be performed.                   |\n*---------------------------------------------------------------------+\n*\nALTGNTYP $CALL GETNEXT             +4 Code genn'ed O.K., get next word\n         TM    WFLAG1,WWRD1        Got one?\n         BZ    ALTTBT              No, error\n         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?\n         BNZ   ALTTBT              Yes, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?\n         BNO   ALTTBT              No, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWALTER        Valid for ALTER sub-command?\n         BZ    ALTTBT              No, sorry again\n         MVC   ALTD1,KWD1          Save the answer words\n         MVC   ALTD3,KWD3          .\n         CLC   ALTD1,=F'40'        See if a CV, XC, or EDITx type\n         BL    ALTICK              No, skip\n         CLI   OREGALEN,X'00'      Better have an A length then\n         BE    BADLGTH             No, sorry\n         EJECT\n*---------------------------------------------------------------------+\n*        Get the source field for the ALTER.                          |\n*---------------------------------------------------------------------+\n*\nALTICK   $CALL GETNEXT             Get the source operand\n         MVI   WFLAG2,WBOP+WPREFOK+WTRLROK+WIPDEF+WLITOK\n         $CALL OPGEN               Go gen code for the B-operand\n         B     BADOPTYP            +0 Invalid, kill it\n         ST    R1,ALTBOPCD         +4 Save address of generated code\n         CLI   OPGBASE,X'0A'       Output buffer?\n         BNE   ALTTRTI             No, skip\n         TM    PCTF1,DCOPYGEN      Yes, already genned DCOPYDAT code?\n         BO    ALTTRTS             Yes, skip\n         $ADD  4,DCOPM010          Add test for deferred copy\n         OI    PCTF1,DCOPYGEN      Remember DCOPYDAT genned\n*\nALTTRTI  CLI   OPGBASE,X'01'       See if input buffer\n         BL    ALTTRTS             No\n         CLI   OPGBASE,X'09'       .\n         BH    ALTTRTS             No\n         OI    PCTF1,IPCOPY        Yes, set for I/P copies\n*\nALTTRTS  CLC   ALTD1,=F'20'        Is this TRANSLATE?\n         BNE   ALTGEN              No, go gen remainder of code\n         TM    WRD1F2,OPRLIT       Yes, should have been a literal\n         BNO   BADOPTYP            No, sorry\n         TM    LITL+3,X'01'        Was literal an even # characters\n         BO    BADLITBL            No, sorry\n         L     R15,=A(TRTBLDIT)    Get static change table\n         MVC   TRTABLE,0(R15)      Swap to working table\n         L     R1,LITL             Get length of literal\n         L     R5,LITA             Get address of literal\n*\nALTTRLP  SR    R15,R15             Clear work reg\n         IC    R15,0(R5)           Get 'old' character\n         LA    R15,TRTABLE(R15)    Point at its' position\n         MVC   0(1,R15),1(R5)      Put in new character\n         LA    R5,2(,R5)           Bump\n         BCTR  R1,0\n         BCT   R1,ALTTRLP          Loop till done\n         LA    R2,TRTABLE          Point at new table\n         LA    R3,256              Set length\n         LR    R4,R3               .\n         $CALL LITSTUFF            Go insert in litpool\n         XC    TRTABLE,TRTABLE     Reset TRTABLE for PARSE\n         L     R1,ALTBOPCD         Get address of generated B code\n         MVC   OPGBASE-OPGCODE(4,R1),LITA Swap to new literal addr.\n         TM    TRLRF2,OPRNUM       Numeric?\n         BZ    ALTGEN              No, assume its a KW length\n         MVC   OREGBLEN,TRLRNUM1+2 Yes, set its' length in\n         B     ALTGEN              Continue\n*\nALTBOPCD DS    F                   Save addr. of generated B code\n         EJECT\n*---------------------------------------------------------------------+\n*        Code to point at operands is in place, now generate the      |\n*        required code based on the type of ALTER.                    |\n*---------------------------------------------------------------------+\n*\nALTGEN   TM    PCTIOFLG,IODLML     Got a DLM?\n         BO    ALTGLGTH            Yes, continue\n         CLC   OREGBLEN,=H'0'      Or a B-operand length\n         BNE   ALTGLGTH            Yes, skip following\n         CLI   OREGALEN,X'00'      Or an A-operand length\n         BNE   ALTGLGTH            Yes, skip following\n         TM    PCTF3,OPKWLEN       KW type length?\n         BO    ALTGLGTH            Yes, skip\n         EJECT\n*---------------------------------------------------------------------+\n*        O.K. we now have the length (or DLM operand), first filter   |\n*        out the types that need floating type logic.  i.e. the       |\n*        stuff supported by REPLACE.                                  |\n*---------------------------------------------------------------------+\n*\nALTGLGTH TM    PCTIOFLG,IOFLOATA+IOFLOATB Any floating operands?\n         BNZ   ALTGFLT             Yes, go different path\n         CLC   ALTD1,=F'24'        See if an ADD/SUB, CV.. or EDITx ?\n         BL    ALTGLGTS            .\n         CLC   ALTD1,=F'80'        .\n         BNH   ALTGDOBR            Yes, skip additional tests\n*\nALTGLGTS TM    PCTF3,OPKWLEN       KW length operand?\n         BO    ALTGDOBR            Yes, skip\n         CLC   ALTAKWLN,ZEROS      A fixed length KW A-operand?\n         BE    ALTGDLMT            No, skip\n         CLC   OREGBLEN,ALTAKWLN+2 Better be the same as B-operand\n         BNE   BADLGTH             No? Sorry\n*\nALTGDLMT TM    PCTIOFLG,IODLML     A DLM type copy?\n         BO    ALTGFLT             Yes, also go to float logic\n         CLC   ALTD1,=F'4'         COPY?\n         BNE   ALTGLNTS            No, skip\n         SR    R1,R1               Lets see if NE to B-operand\n         ICM   R1,1,OREGALEN       Get the length\n         BZ    ALTGLNTS            It's zero, skip\n         CH    R1,OREGBLEN         Same as B-operand?\n         BE    ALTGLNTS            Yes, continue\n         CLC   OREGBLEN,ZEROS      Because B-length is zero?\n         BNE   ALTGFLT             No, different length, go to float\n         MVC   OREGBLEN+1(1),OREGALEN Swap A-length over B-length\n         MVI   OREGALEN,X'00'      and clear A-length\n*---------------------------------------------------------------------+\n*        Checkout the lengths of the ALTER to prevent the user        |\n*        causing grief later by modifying data outside the buffer     |\n*        limits.  Yes, I know this doesn't catch all possibilities    |\n*        but its better than not checking at all.                     |\n*---------------------------------------------------------------------+\n*\nALTGLNTS L     R1,ALTGDISP         Get displacement\n         CLC   ALTD1,=F'40'        A CV.. type?\n         BL    ALTGLABL            No, go add B-operand length\n         SR    R2,R2               Clear a reg\n         IC    R2,OREGALEN         Get A-operand length\n         AR    R1,R2               Add to displ.\n         B     ALTGBFLT            Continue\n*\nALTGLABL AH    R1,OREGBLEN         Add length of move\n*\nALTGBFLT CLI   ALTGABUF,X'00'      Is dest a buffer?\n         BE    ALTGDOBR            No, skip next tests\n         CLI   ALTGABUF,X'0A'      A user buffer?\n         BNH   ALTGLNLR            No, do LRECL test\n         C     R1,PCTUBFSZ         Yes, test against size of user buffs\n         BNH   ALTGDOBR            No, continue\n         $ERR  BUFFX,8,SKIP,FLAG=YES  Yes, kill it\n*\nALTGLNLR CH    R1,DCBALREC         New high-water mark?\n         BNH   ALTGDOBR            No, continue\n         STH   R1,DCBALREC         Yes, save it\n         MVC   DCBASNO,GETCTR1     and the statement/word number\n         MVC   DCBAWNO,GETCTR2     .\n         EJECT\n*---------------------------------------------------------------------+\n*        The KWD3 field for KWALTER types is the address of the       |\n*        routine to handle it.     ALTD3 was used to save it.         |\n*---------------------------------------------------------------------+\n*\nALTGDOBR L     R1,ALTD3            Pickup KW table subcommand index\n         BR    R1                  Branch via D3 address\n         EJECT\n*---------------------------------------------------------------------+\n*        Gen the code for the various types of ALTER now.             |\n*---------------------------------------------------------------------+\n*\nALTGCOPY TM    PCTF3,OPKWLEN       A KW length operand?\n         BZ    ALTGCPLT            No\n         $ADD  4,ORLLCOD           Yes, stuff code for it\n         B     ALTGMVL             And use MVCL type copy\n*\nALTGCPLT LH    R1,OREGBLEN         Get the length of the COPY\n         CH    R1,=H'256'          See if MVCL is needed\n         BH    ALTGM256            Yes,\n         BCTR  R1,0                Reduce length for use in EX\n         STH   R1,OREGBLEN         Put back in OREGBLEN\n         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm\n         $ADD  12,ALTGMMVC         Stuff in EX of MVC\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGM256 MVI   OREGALEN,X'00'      Clear any A-operand length\n         MVI   OREGFLAG,X'00'      and Flag byte\n         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm\n*\nALTGMVL  $ADD  8,ALTGMVL1          Stuff in MVCL\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGAND  BAL   R5,ALTGTSTL         Go process length value\n         $ADD  4,ALTGMAND          Stuff in EX of NC\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGOR   BAL   R5,ALTGTSTL         Go process length value\n         $ADD  4,ALTGMOR           Stuff in EX of OC\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGXOR  BAL   R5,ALTGTSTL         Go process length value\n         $ADD  4,ALTGMXOR          Stuff in EX of XC\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGTRAN BAL   R5,ALTGTSTL         Go process length value\n         $ADD  4,ALTGMTR           Stuff in EX of TR\n         B     EXITGEOS            Go gen the close-off code\n*\nALTGTSTL ST    R5,ALTGTSVR         Save return\n         TM    PCTF3,OPKWLEN       KW length operand?\n         BO    ALTGTSTK            Yes, alternate code\n         LH    R1,OREGBLEN         Get the length of the operation\n         CH    R1,=H'256'          See if too big\n         BH    BADLGTH             Yes, kill it\n         BCTR  R1,0                Reduce length for use in EX\n         STH   R1,OREGBLEN         Put back in OREGBLEN\n         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm\n         L     R5,ALTGTSVR         Pick up return\n         BR    R5                  Return\n*\nALTGTSTK $ADD  6,ORLLCOD           Add code to load length\n         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         $ADD  4,ORLMVI            Add setting of PCTIOFLG\n         L     R5,ALTGTSVR         Get return address\n         BR    R5                  Return\n         EJECT\n*---------------------------------------------------------------------+\n*        Gen the code for a floating ALTER.                           |\n*---------------------------------------------------------------------+\n*\nALTGFLT  CLC   ALTD1,=F'4'         COPY request\n         BNE   ALTTBT              No, sorry\n         MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         TM    PCTIOFLG,IODLML     A DLM type?\n         BO    ALTGFLDL            Yes, skip length test\n         TM    PCTF3,OPKWLEN       A KW length operand?\n         BO    ALTGFLKW            Yes\n         LH    R1,OREGBLEN         Get the length of the COPY\n         CH    R1,=H'256'          See if too big\n         BH    BADLGTH             Yes, kill it\n*\nALTGFLDL $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm\n         $ADD  4,ALTGMREP          Stuff in BAL to REPLACE code\n         B     EXITGEOS            Go stuff close off code\n*\nALTGFLKW $ADD  4,ORLLCOD           Add KW load length code\n         $ADD  4,ORLMVI            Add code to set it\n         $ADD  4,ALTGMREP          Stuff in BAL to REPLACE code\n         B     EXITGEOS            Done\n         EJECT\n*---------------------------------------------------------------------+\n*        Gen the code for the Arithmetic/Convert type of ALTER's      |\n*---------------------------------------------------------------------+\n*\nALTGPLUS BAL   R5,ALTGTBLA         Put in code to pick up A-operand\n         BAL   R5,ALTGTBLB         Put in code to pick up B-operand\n         $ADD  2,ALTGMAR           Put in code to ADD them\n         BAL   R5,ALTGSBLA         Put in code to store answer\n         B     EXITGEOS            Done\n*\nALTGSUBT BAL   R5,ALTGTBLA         Put in code to pick up A-operand\n         BAL   R5,ALTGTBLB         Put in code to pick up B-operand\n         $ADD  2,ALTGMSR           Put in code to SUBT them\n         BAL   R5,ALTGSBLA         Put in code to store answer\n         B     EXITGEOS            Done\n*\nALTGMULT BAL   R5,ALTGTBLA         Put in code to pick up A-operand\n         BAL   R5,ALTGTBLB         Put in code to pick up B-operand\n         $ADD  2,ALTGMMR           Put in code to MULT them\n         BAL   R5,ALTGSBLA         Put in code to store answer\n         B     EXITGEOS            Done\n*\nALTGDIV  BAL   R5,ALTGTBLA         Put in code to pick up A-operand\n         BAL   R5,ALTGTBLB         Put in code to pick up B-operand\n         $ADD  4,ALTGMDR           Put in code to DIVIDE them\n         BAL   R5,ALTGSBLA         Put in code to store answer\n         B     EXITGEOS            Done\n*\nALTGAP   BAL   R5,ALTGTPLA         Go prepare lengths\n         STC   R1,ALTGMAP+1        Shove length in instruction\n         $ADD  6,ALTGMAP           Put instr. in pgm\n         B     EXITGEOS            Done\n*\nALTGSP   BAL   R5,ALTGTPLA         Go prepare lengths\n         STC   R1,ALTGMSP+1        Shove length in instruction\n         $ADD  6,ALTGMSP           Put instr. in pgm\n         B     EXITGEOS            Done\n*\nALTGEDTB BAL   R5,ALTGTBLB         Go make code to put B in R2\n         $ADD  4,ALTGMCV2          CVD R2 into DBL\n         $ADD  6,ALTGMED1          Move EDIT mask to DBL2\n         $ADD  6,ALTGMED3          EDIT DBL into DBL2\n         B     ALTGEDMR            Go to common code\n*\nALTGEDB$ BAL   R5,ALTGTBLB         Go make code to put B in R2\n         $ADD  4,ALTGMCV2          CVD R2 into DBL\n         $ADD  12,ALTGMED2         EDIT DBL into DBL2\n         B     ALTGEDMR            Go to common code\n*\nALTGEDTP BAL   R5,ALTGTCVL         Get B length into R1\n         BCTR  R1,0                -1 for machine length\n         O     R1,=A(7*16)         OR in length of DBL\n         STC   R1,ALTGMZAP+1       Stuff lengths into instr.\n         $ADD  6,ALTGMZAP          ZAP B-operand into DBL\n         $ADD  6,ALTGMED1          Move EDIT mask to DBL2\n         $ADD  6,ALTGMED3          EDIT DBL into DBL2\n         B     ALTGEDMR            Go to common code\n*\nALTGEDP$ BAL   R5,ALTGTCVL         Get B length into R1\n         BCTR  R1,0                -1 for machine length\n         O     R1,=A(7*16)         OR in length of DBL\n         STC   R1,ALTGMZAP+1       Stuff lengths into instr.\n         $ADD  6,ALTGMZAP          ZAP B-operand into DBL\n         $ADD  12,ALTGMED2         EDIT DBL into DBL2\n*\nALTGEDMR CLI   OREGALEN,X'00'      An A length ?\n         BE    BADLGTH             No, sorry\n         SR    R1,R1               Clear a reg.\n         IC    R1,OREGALEN         Get the A length\n         LA    R2,16               Get length of DBL2\n         SR    R2,R1               Calc displ. into DBL2\n         AH    R2,=S(DBL2)         Create Base/Displ of instr\n         STH   R2,ALTGMMD2+4       Put into instr.\n         BCTR  R1,0                Reduce length by 1\n         STC   R1,ALTGMMD2+1       Put it into instr.\n         $ADD  6,ALTGMMD2          Stuff instr. into pgm\n         B     EXITGEOS            Done\n*\nALTGCVXC SR    R5,R5               Check out lengths\n         IC    R5,OREGALEN         Get A length\n         LH    R4,OREGBLEN         Get B length\n         AR    R4,R4               Double B\n         CR    R5,R4               Better be equal\n         BNE   BADLGTH             Sorry\n         $ADD  ORLM999-ORLCODE,ORLCODE Put OREG code into pgm\n         $ADD  4,ALTGMHEX          Stuff in BAL to HEXIT code\n         B     EXITGEOS            Done\n*\nALTGCVZP BAL   R5,ALTGTCVL         Go Check lengths\n         BAL   R5,ALTGGPAK         Make code to put B into DBL\n         BAL   R5,ALTGGMDS         Make code to move DBL to A\n         B     EXITGEOS            Done\n*\nALTGCVZB BAL   R5,ALTGTCVL         Go Check lengths\n         BAL   R5,ALTGGPAK         Make code to put B into DBL\n         $ADD  4,ALTGMCV1          Make code to get B into R1\n         CLI   OREGALEN,X'04'      Test for valid binary length\n         BH    BADLGTH             Sorry\n         BAL   R5,ALTGSBLA         Make code to put answer into A\n         B     EXITGEOS            Done\n*\nALTGCVPZ BAL   R5,ALTGTPLA         Go prepare A/B lengths\n         STC   R1,ALTGMUP1+1       Stuff lengths into instr.\n         $ADD  6,ALTGMUP1          Stuff UNPK into pgm\n         BAL   R5,ALTGGOI          Make code to correct sign\n         B     EXITGEOS            Done\n*\nALTGCVPB BAL   R5,ALTGTCVL         Go check lengths\n         BCTR  R1,0                -1 for machine length\n         O     R1,=A(7*16)         OR in length of DBL\n         STC   R1,ALTGMZAP+1       Stuff lengths into instr.\n         $ADD  6,ALTGMZAP          Stuff UNPK into pgm\n         $ADD  4,ALTGMCV1          Stuff CVB into pgm\n         CLI   OREGALEN,X'04'      Test for valid binary length\n         BH    BADLGTH             Sorry\n         BAL   R5,ALTGSBLA         Make code to put answer into A\n         B     EXITGEOS            Done\n*\nALTGCVBP BAL   R5,ALTGTBLB         Go make code to put B in R2\n         $ADD  4,ALTGMCV2          CVD R2 into DBL\n         CLI   OREGALEN,X'00'      An A length ?\n         BE    BADLGTH             No, sorry\n         BAL   R5,ALTGGMDS         Make code to move DBL to A\n         B     EXITGEOS            Done\n*\nALTGCVBZ BAL   R5,ALTGTBLB         Go make code to put B in R2\n         $ADD  4,ALTGMCV2          CVD R2 into DBL\n         $ADD  6,ALTGMUP2          UNPK DBL to DBL2\n         CLI   OREGALEN,X'00'      An A length ?\n         BE    BADLGTH             No, sorry\n         SR    R1,R1               Clear a reg.\n         IC    R1,OREGALEN         Get the A length\n         LA    R2,16               Get length of DBL2\n         SR    R2,R1               Calc displ. into DBL2\n         AH    R2,=S(DBL2)         Create Base/Displ of instr\n         STH   R2,ALTGMMD2+4       Put into instr.\n         BCTR  R1,0                Reduce length by 1\n         STC   R1,ALTGMMD2+1       Put it into instr.\n         $ADD  6,ALTGMMD2          Stuff instr. into pgm\n         BAL   R5,ALTGGOI          Make code to correct sign\n         B     EXITGEOS            Done\n         EJECT\n*---------------------------------------------------------------------+\n*        Misc. support routines for CV.. code creation                |\n*---------------------------------------------------------------------+\n*\nALTGGPAK ST    R5,ALTGTSVR         Save return\n         BCTR  R1,0                Make B length an instr length\n         O     R1,=A(7*16)         OR in the length of DBL\n         STC   R1,ALTGMPAK+1       Stuff in instr\n         $ADD  6,ALTGMPAK          Put instr in program\n         B     ALTGBEX             Return\n*\nALTGGMDS ST    R5,ALTGTSVR         Save return\n         SR    R1,R1               Clear a reg.\n         IC    R1,OREGALEN         Get the A length\n         LA    R2,8                Get length of DBL\n         SR    R2,R1               Calc displ. into DBL\n         AH    R2,=S(DBL)          Create Base/Displ of instr\n         STH   R2,ALTGMMDS+4       Put into instr.\n         BCTR  R1,0                Reduce length by 1\n         STC   R1,ALTGMMDS+1       Put it into instr.\n         $ADD  6,ALTGMMDS          Stuff instr. into pgm\n         B     ALTGBEX             Return\n*\nALTGGOI  ST    R5,ALTGTSVR         Save return\n         SR    R1,R1               Clear a reg.\n         IC    R1,OREGALEN         Get the A length\n         BCTR  R1,0                -1 to calc displ. for OI\n         STC   R1,ALTGMOI+3        Stuff into instr.\n         $ADD  4,ALTGMOI           Put OI into pgm\n         B     ALTGBEX             Return\n*---------------------------------------------------------------------+\n*        Length checker for the CV.. routines                         |\n*---------------------------------------------------------------------+\n*\nALTGTCVL ST    R5,ALTGTSVR         Save return\n         CLI   OREGALEN,X'00'      Better have an A length\n         BE    BADLGTH             None, kill it\n         LH    R1,OREGBLEN         No, swap in B length\n         CH    R1,=H'16'           Test against max\n         BH    BADLGTH             Too high\n         LTR   R1,R1               Zero?\n         BZ    BADLGTH             Also no good\n         B     ALTGBEX             Return with B-length in R1\n         EJECT\n*---------------------------------------------------------------------+\n*        PACKed length support routine for ADDP/SUBP                  |\n*---------------------------------------------------------------------+\n*\nALTGTPLA ST    R5,ALTGTSVR         Save return\n         SR    R1,R1               Clear R1\n         ICM   R1,1,OREGALEN       Any A length?\n         BNZ   *+8                 Yes, skip\n         LH    R1,OREGBLEN         No, swap in B length\n         CH    R1,=H'16'           Test against max\n         BH    BADLGTH             Too high\n         BCTR  R1,0                -1 for instr. length\n         SLL   R1,4                Shift to A-operand location\n         LH    R2,OREGBLEN         Swap in B length\n         CH    R2,=H'16'           Test against max\n         BH    BADLGTH             Too high\n         BCTR  R2,0                -1 for instr. length\n         OR    R1,R2               .\n         B     ALTGBEX             Return\n         EJECT\n*---------------------------------------------------------------------+\n*        Length checker/generate routines for Binary ADD/SUB logic.   |\n*---------------------------------------------------------------------+\n*\nALTGTBLA ST    R5,ALTGTSVR         Save return\n         LA    R2,4                Set for A-operand\n         SR    R1,R1               Clear R1\n         ICM   R1,1,OREGALEN       Any A length?\n         BNZ   ALTGTLTT            Yes, skip\n         LH    R1,OREGBLEN         No, swap in B length\n         STC   R1,OREGALEN         .\n         B     ALTGTLTT            Skip into common code\n*\nALTGTBLB ST    R5,ALTGTSVR         Save return\n         LA    R2,8                Set for B-operand\n         SR    R1,R1               Clear R1\n         ICM   R1,3,OREGBLEN       Get length\n         BZ    BADLGTH             Kill it if zero\n*\nALTGTLTT CH    R1,=H'4'            Test against max\n         BH    BADLGTH             Yes, kill it\n         SLL   R1,2                x 4\n         B     *(R1)               Branch by length of operand\n         B     ALTGOL1             Length = 1\n         B     ALTGOL2             Length = 2\n         B     ALTGOL3             Length = 3\n         B     ALTGOL4             Length = 4\n*\nALTGOL1  B     *(R2)               Branch by A/B operand type\n         B     ALTGOL1A            A\n         B     ALTGOL1B            B\n*\nALTGOL1A $ADD  6,ALTGML1A          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL1B $ADD  6,ALTGML1B          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL2  B     *(R2)               Branch by A/B operand type\n         B     ALTGOL2A            A\n         B     ALTGOL2B            B\n*\nALTGOL2A $ADD  4,ALTGML2A          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL2B $ADD  4,ALTGML2B          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL3  B     *(R2)               Branch by A/B operand type\n         B     ALTGOL3A            A\n         B     ALTGOL3B            B\n*\nALTGOL3A $ADD  6,ALTGML3A          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL3B $ADD  6,ALTGML3B          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL4  B     *(R2)               Branch by A/B operand type\n         B     ALTGOL4A            A\n         B     ALTGOL4B            B\n*\nALTGOL4A $ADD  4,ALTGML4A          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGOL4B $ADD  4,ALTGML4B          Stuff in code\n         B     ALTGBEX             Return\n*\nALTGSBLA ST    R5,ALTGTSVR         Save return\n         SR    R1,R1               Clear R1\n         IC    R1,OREGALEN         Get length\n         SLL   R1,2                x 4\n         B     *(R1)               Branch by length of operand\n         B     ALTGBSL1            Length = 1\n         B     ALTGBSL2            Length = 2\n         B     ALTGBSL3            Length = 3\n         B     ALTGBSL4            Length = 4\n*\nALTGBSL1 $ADD  4,ALTGMS1A          Shove in code\n         B     ALTGBEX             Return\n*\nALTGBSL2 $ADD  4,ALTGMS2A          Shove in code\n         B     ALTGBEX             Return\n*\nALTGBSL3 $ADD  4,ALTGMS3A          Shove in code\n         B     ALTGBEX             Return\n*\nALTGBSL4 $ADD  4,ALTGMS4A          Shove in code\n*\nALTGBEX  L     R5,ALTGTSVR         Pick up return\n         BR    R5                  Return\n         EJECT\n*---------------------------------------------------------------------+\n*   Generate the code for the ALTER COPYBUFF(.......) command.        |\n*---------------------------------------------------------------------+\n*\nALTCBFO  CLI   KWNUM,X'E4'         Was it UBUFFx?\n         BNE   ALTCBBF             No, skip\n         L     R1,KWD3             Get index again\n         SLL   R1,2                x 4\n         LA    R1,PCTINPL1-4(R1)   Point at length field\n         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed\n*\nALTCBBF  $CALL GETNEXT             Get next word (better be COPYBUFF!)\n         TM    WFLAG1,WWRD1        Got a word?\n         BNO   ALTTBT              No, error\n         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Maybe, a valid KW and fmt?\n         BNO   ALTTBT              No, error\n         LA    R14,WRD1KW1         Point at KW answer area\n*\nALTCBUFD CLC   ALTGUONX,=F'40'     OBUFF destination ?\n         BNE   ALTCNDBC            No, then no deferred buffer copy\n         $ADD  4,DCOPM010          Yes, add test for deferred copy\n         OI    PCTF1,DCOPYGEN      and remember it\n*\nALTCNDBC TM    WRD1F2,OPRKWOPV     Valid (...) KW. i.e. (UBUFFx)?\n         BZ    ALTCBFCB            No, go try as a DDname\n         LA    R14,WRD1KW2         Yes, point at answer area\n         CLI   KWNUM,X'E5'         INPUTx?\n         BE    ALTCBBUF            Yes\n         CLI   KWNUM,X'E4'         UBUFFx ?\n         BE    ALTCBBUF            Yes\n         CLI   KWNUM,X'E3'         OBUFF  ?\n         BNE   ALTCBFCB            No, again treat as DDname\n*\nALTCBBUF L     R1,KWD3             Get buffer index\n         SLL   R1,2                x 4\n         ST    R1,ALTGUINX         Stuff in\n         CLI   KWNUM,X'E4'         UBUFFx ?\n         BNE   *+14                Yes\n         LA    R1,PCTINPL1-4(R1)   Point at length field\n         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed\n         $ADD  ALTGUBF9-ALTGUBF1,ALTGUBF1 Point at UBUFFx\n         $ADD  ALTGMLO3-ALTGMLO1,ALTGMLO1 Point at output buffer\n         CLC   ALTGUONX,=F'40'     OBUFF destination?\n         BNE   ALTCBSOD            No\n         $ADD  18,ALTSOBL1         Yes, alter OBUFF length\n*\nALTCBSOD $ADD  ALTGMLO9-ALTGMLO3,ALTGMLO3 Complete code\n         B     ALTCBCLS            Go gen the close-off code\n*\nALTCBFCB $CALL DCBI1BLD,WRD1L2     Go get FCB address\n         B     BADDCB              +0 error, kill it\n         STCM  R1,7,OPGBASE+1      Save FCB address\n         MVC   OPGBASE(1),FCBFILNO+1-FCBDSECT(R1) Save file number\n         MVC   ALTGMFCB,OPGBASE    Copy FCB address\n         $ADD  ALTGMLF9-ALTGMLF1,ALTGMLF1 Point at input buffer\n         $ADD  ALTGMLO3-ALTGMLO1,ALTGMLO1 Point at output buffer\n         CLC   ALTGUONX,=F'40'     OBUFF destination?\n         BNE   ALTCBFOD            No\n         $ADD  18,ALTSOBL1         Yes, alter OBUFF length\n*\nALTCBFOD $ADD  ALTGMLO9-ALTGMLO3,ALTGMLO3 Point at output buffer\n*\nALTCBCLS $ADD  6,ALTGMML1          MVCL it\n         OI    PCTF1,IPCOPY        Force alternate O/P buffer.\n         B     EXITGEOS            Go gen the close-off code\n         EJECT\n*---------------------------------------------------------------------+\n*        ALTER command work areas and model code                      |\n*---------------------------------------------------------------------+\n*\n         DS    0F\nALTGUBF1 BAL   R10,COMP10X4        Skip over ADCON\nALTGUINX DC    XL4'00'             BUFFx index x 4\nALTGUBF2 ICM   R15,15,0(R10)       Load buffer index\nALTGUBF3 L     R2,PCTINPT1-4(R15)  Get address of record\nALTGUBF4 L     R3,PCTINPL1-4(R15)  Get length of input record\nALTGUBF9 EQU   *\n*\nALTGMLF1 BAL   R10,COMP10X4        Skip over ADCON\nALTGMFCB DC    XL4'00'             Address of FCB\nALTGMLF2 ICM   R15,15,0(R10)       Point R15 at FCB\nALTGMLF3 L     R2,FCBRECAD-FCBDSECT(R15) Get address of record\nALTGMLF4 LH    R3,FCBLRECL-FCBDSECT(R15) Get length of input record\nALTGMLF9 EQU   *\n*\nALTGMLO1 BAL   R10,COMP10X4        Skip over ADCON\nALTGUONX DC    XL4'00'             BUFFx index x 4\nALTGMLO2 ICM   R15,15,0(R10)       Load buffer index\nALTGMLO3 L     R4,PCTINPT1-4(R15)  Get address of record\nALTGMLO4 L     R5,PCTINPL1-4(R15)  Get length of input record\nALTGMLO9 EQU   *\n*\nALTSOBL1 BALR  R10,0               Get temp addressability\nALTSOBL2 CH    R3,DCBHLREC         Ensure not bigger than OBUFF\nALTSOBL3 BNH   12(R10)  (*+8)      Its not, skip next instr\nALTSOBL4 LH    R3,DCBHLREC         It is, use DCBHLREC instead\nALTSOBL5 ST    R3,PCTINPL1-4(R15)  Update OBUFF length\n*\nALTGMML1 ICM   R3,8,PCTPADCH       Insert fill character\nALTGMML2 MVCL  R4,R2               Move the data\n*\nALTGMVL1 ST    OREG,PCTFLEN        Save length of ALTER's move\nALTGMVL2 LR    R3,R5               Copy length for MVCL\nALTGMVL3 MVCL  AREG,BREG           Move the data\n*\nALTGML1A SR    R1,R1               Clear work reg\n         IC    R1,0(AREG)          Get value\nALTGML1B SR    R2,R2               Clear work reg\n         IC    R2,0(BREG)          Get value\nALTGML2A LH    R1,0(AREG)          Get value\nALTGML2B LH    R2,0(BREG)          Get value\nALTGML3A SR    R1,R1               Clear work reg\n         ICM   R1,7,0(AREG)        Get value\nALTGML3B SR    R2,R2               Clear work reg\n         ICM   R2,7,0(BREG)        Get value\nALTGML4A L     R1,0(AREG)          Get value\nALTGML4B L     R2,0(BREG)          Get value\n*\nALTGMS1A STC   R1,0(AREG)          Store value\nALTGMS2A STH   R1,0(AREG)          Store value\nALTGMS3A STCM  R1,7,0(AREG)        Store value\nALTGMS4A ST    R1,0(AREG)          Store value\n*\nALTGMAR  AR    R1,R2               Add the two\nALTGMSR  SR    R1,R2               Subtract the two\nALTGMMR  MR    R0,R2               Multiply them\nALTGMDR  SR    R0,R0               Clear R0\n         DR    R0,R2               Divide them\nALTGMAP  AP    0(0,AREG),0(0,BREG) ADD packed\nALTGMSP  SP    0(0,AREG),0(0,BREG) SUB packed\n*\nALTGMPAK PACK  DBL,0(0,BREG)       PACK B-operand\nALTGMMDS MVC   0(0,AREG),DBL+0     Move DBL to A-operand\nALTGMCV1 CVB   R1,DBL              CVB DBL to R1\nALTGMCV2 CVD   R2,DBL              CVD R2 to DBL\nALTGMUP1 UNPK  0(0,AREG),0(0,BREG) UNPK B-operand to A-operand\nALTGMOI  OI    0(AREG),C'0'        OI for correct zone\nALTGMZAP ZAP   DBL,0(0,BREG)       Packed B-operand to DBL\nALTGMUP2 UNPK  DBL2(16),DBL(8)     UNPK entire DBL to DBL2\nALTGMMD2 MVC   0(0,AREG),DBL2+0    Move DBL2 to A-operand\nALTGMED1 MVC   DBL2(16),ALTGEDT1   Move EDIT mask1\nALTGMED2 MVC   DBL2(16),ALTGEDT2   Move EDIT mask2\nALTGMED3 ED    DBL2(16),DBL+2      EDIT DBL into DBL2\n         $PEND\n         DROP  R10\n         TITLE 'CKCOMENT - Handle comment control'\n*---------------------------------------------------------------------+\n*        Routine skips to number of end of sentences                  |\n*        specified in nest counter COMNTCTL                           |\n*        or puts routine into skip mode if a label                    |\n*        of the type '*:' is found in WORDTXT.                        |\n*---------------------------------------------------------------------+\n*\nCKCOMENT $PROC\n         USING KWDSECT,R14\n         CP    COMNTCTL,=P'0'      In skip mode already?\n         BNE   CKCEOS2             Yes, go see if nested\n         TM    WFLAG1,WPREF        Is this prefixed?\n         BZ    CKCOEX              No, leave now\n         TM    WFLAG1,WWRD1+WWRD2+WTRLR+WPLUS+WMINUS If any other\n         BNZ   CKCOEX              present its not a simple *:\n         TM    PREFF2,OPRKW+OPRKWV With a valid keyword?\n         BNO   CKCOEX              No, leave now\n         LA    R14,PREFKW1\n         CLI   KWNUM,COMMENT       A comment?\n         BNE   CKCOEX              No, leave now\n         AP    COMNTCTL,=P'1'      Yes, start nest count\n*\nCKCGNEXT L     R8,=A(GETNEXT)      Reset back to GETNEXT\n         B     8(R8)               And go for next word\n*\nCKCOEX   $RET  0\n*\nCKCEOS2  CLC   WORDL,ZEROS         Is this end of sentence?\n         BNE   CKCNEST             No, go test for nested comments\n         SP    COMNTCTL,=P'1'      Decrement nest count\n         B     CKCGNEXT            And go for next word\n*\nCKCNEST  TM    WFLAG1,WPREF        Is this prefixed?\n         BZ    CKCGNEXT            No, leave now\n         TM    WFLAG1,WWRD1+WWRD2+WTRLR+WPLUS+WMINUS If any other\n         BNZ   CKCGNEXT            present its not a simple *:\n         TM    PREFF2,OPRKW+OPRKWV With a valid keyword?\n         BNO   CKCGNEXT            No, leave now\n         LA    R14,PREFKW1\n         CLI   KWNUM,COMMENT       A comment?\n         BNE   CKCGNEXT            No, leave now\n         AP    COMNTCTL,=P'1'      Yes, bump nest count\n         B     CKCGNEXT            And go back for a word\n         DROP  R14\n         $PEND\n         TITLE 'CLOSE - Command processor'\n*---------------------------------------------------------------------+\n*        C L O S E   C o m m a n d    P r o c e s s o r               |\n*---------------------------------------------------------------------+\n*\nCLOSE    $PROC\n         $CALL DBGADD              Go add DEBUG code\n*\nCLOSLOOP $CALL GETNEXT             Get next word, (if any).\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    EXITGOK             Yes, go to common command exit\n         TM    WFLAG1,WPREF+WTRLR  Invalid format?\n         BNZ   BADKWORD            Yes, kill it\n         TM    WFLAG1,WWRD1        Got WRD1?\n         BNO   BADKWORD            Yes, kill it\n         TM    WRD1F2,OPRKW+OPRKWV Valid KW?\n         BNO   BADOPTYP            No, kill it\n         LA    R14,WRD1KW1         Point at KW answer area\n         USING KWDSECT,R14\n         TM    KWF1,KWOPRAND+KWSUBVAL Valid type?\n         BNO   BADKWORD            No, sorry\n         CLI   KWNUM,X'9A'         Valid CLOSE KW?\n         BE    CLOSBR              Yes, continue\n         CLI   KWNUM,X'9B'         Valid CLOSE KW?\n         BE    CLOSBR              Yes, continue\n         B     BADKWORD            No, kill it\n*\nCLOSBR   L     R2,KWD2             Get address of routine\n         BR    R2                  Branch by type\n*---------------------------------------------------------------------+\n*        Process the INPUT(ddname) operand                            |\n*---------------------------------------------------------------------+\n*\nCLOSINPT TM    WRD1F2,OPRKWOP      Got a (...) operand?\n         BZ    BADOPTYP            No, sorry\n         OI    PCTF3,INPUT         Make this DDname count\n         $CALL DCBI1BLD,WRD1L2     Go setup input DCB\n         B     BADDCB              Error, too bad\n         ST    R1,CLOSFCBA         Save address of FCB area\n         B     CLOSGEN             Go gen some code\n*---------------------------------------------------------------------+\n*        Process the OUTPUT(ddname) operand                           |\n*---------------------------------------------------------------------+\n*\nCLOSOUTP TM    WRD1F2,OPRKWOP      Got a (...) operand?\n         BZ    BADOPTYP            No, sorry\n         NI    PCTF3,255-INPUT     Reset input type\n         $CALL DCBO1BLD,WRD1L2     Go setup output DCB\n         B     BADDCB              Error, too bad\n         ST    R1,CLOSFCBA         Save address of FCB area\n*---------------------------------------------------------------------+\n*        Gen the CLOSE code now                                       |\n*---------------------------------------------------------------------+\n*\nCLOSGEN  $ADD  CLOSDONE-CLOSBALR,CLOSBALR Add the code\n         B     CLOSLOOP            Loop for next operand\n*\n*---------------------------------------------------------------------+\n*        CLOSE routine work area and model code                       |\n*---------------------------------------------------------------------+\n*\n         CNOP  2,4                 So CLOSADDA is aligned\nCLOSBALR BALR  R14,0               Get local addressability\nCLOSCALL STM   R0,R15,CLOSSAVE-CLOSCALL(R14) Get ADDPROC address\n         ICM   R15,15,CLOSADDA-CLOSCALL(R14) Get ADDPROC address\n         ST    R8,4(R15)           Save this PROC's base\n         MVC   12(4,R15),CLOSFCBA-CLOSCALL(R14) Setup passed param\n         BALR  R8,0                Calc my return address\n         LA    R8,14(,R8)          .\n         ST    R8,0(R15)           Save at +0 in called routine\n         LR    R8,R15              Make called routine addressable\n         B     8(R8)               Go to it\n         BALR  R14,0               Get addressable again\nCLOSSKIP LM    R0,R15,CLOSSAVE-CLOSSKIP(R14) Reload regs\n         B     CLOSDONE-CLOSCALL(R14) Skip constants\nCLOSFCBA DC    4X'00'              Location of FCB for this DD\nCLOSADDA DC    A(ADDPROC)          ADDPROC routine address\nCLOSSAVE DC    16A(0)              Save area\nCLOSDONE EQU   *\n*\nCLOSNOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue\n*\nCLOSDDN  $ERR  BDDN,8,SKIP\n         DROP  R14\n         $PEND\n         TITLE 'COPYDATA - Do some real I/O for the user'\n*---------------------------------------------------------------------+\n*        Initialize for an actual run                                 |\n*---------------------------------------------------------------------+\n*\nCOPYDATA $PROC\n         MVC   PCTPGMS,PCTPGM      Copy so COPEOF.. doesn't swap in 0\n*\nCOPYFILE ICM   R1,15,PCTMACNT      Get master active count\n         BNZ   COPSETUP            Yes, go ahead\n         TM    PCTF6,OPCHECK       Told about the no-I/O?\n         BZ    COPSETUP            Yes, don't give an error\n         $ERR  NOOP,12,GO=ADDSTATS,FLAG=NO No, terminate now\n*\nCOPSETUP TM    PCTF1,IPCOPY        I/P copies?\n         BZ    COPSTART            No, need no O/P buffer then\n         LH    R0,DCBHLREC         Use output high LRECL\n         ST    R0,PCTOBUFL         Set in the length\n         AH    R0,=H'4'            Get room for possible RDW\n         CLC   PCTOUTPT,ZEROS      Already got O/P buffer?\n         BNE   COPSTART            Yes, don't get another\n         GETMAIN R,LV=(0)          Get a work area\n         LA    R1,4(,R1)           Step over possible RDW\n         ST    R1,PCTOUTPT         And save its address\n         TITLE 'COPYDATA - Data Main Line'\n*---------------------------------------------------------------------+\n*        This is the actual main data reading mainline                |\n*                                                                     |\n*        Changes to the following should be watched carefully.        |\n*        Every instr. added to this code has a significant            |\n*        impact on performance.                                       |\n*---------------------------------------------------------------------+\n*\nCOPSTART NI    PCTF4,255-COMPILE   Say compile is done\n         MVC   PCTCFLAG,PCTBFCDF   Copy buffer copy default to start\n         TM    PCTF2,DINPUT1       Did we get an INPUT1 DD?\n         BZ    COPREAL             No, pass control to user\n         $CALL FASTCOPY            If FASTCOPY returns, it means it\n*                                  couldn't do it, we take over again\n         L     R7,PCT1FCB          Point at INPUT1 FCB for 1st read\n*\nCOPREAD  TM    PCTF7,TIMEFLAG      Is STIMER needed?\n         BZ    COPREAD2\n         STIMER TASK,TIMEEXIT,TUINTVL=ONESEC Set a timer interval\n         NI    PCTF7,255-TIMEFLAG  Say STIMER not needed\n*\nCOPREAD2 TM    FCBF2,FCBEOF        Already hit EOF?\n         BO    COPEOFER            Yes, too bad\n         TM    FCBF1,FCBCLOSD      CLOSED?\n         BO    BADIO               Yes, too bad!\n         LA    R2,FCBDCB           Point at DCB to be read\n         GET   (R2)                Get next record\n         TM    FCBF2,FCBRREAD      Re-read needed for concatenation\n         BZ    COPR1STR            No\n         NI    FCBF2,255-FCBRREAD  Turn off reread sw\n         RDJFCB ((R2))             Get the new JFCB for the file\n         MVC   FCBJFCB,JFCB        Save the new JFCB\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   FCBORECF,FCBDCB+DCBRECFM And some other things\n         MVC   FCBRECFM,FCBORECF\n         MVC   FCBOBLK,FCBDCB+DCBBLKSI\n         MVC   FCBBLKSI,FCBOBLK\n         TM    FCBRECFM,X'C0'      Undefined?\n         BNO   *+10                No\n         MVC   FCBDCB+DCBLRECL(2),FCBDCB+DCBBLKSI\n         MVC   FCBOLREC,FCBDCB+DCBLRECL\n         MVC   FCBLRECL,FCBOLREC\n         MVC   FCBULREC,FCBOLREC\n         MVC   FCBCOUNT,ZEROS      Reset count of records read\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         CLC   FCBLRECL,DCBHLREC   Is this a new hi-water mark\n         BNH   COPSROUT            No, continue\n         CLC   PCTINPT1,PCTOUTPT   Are we running with 2 buffers?\n         BE    COPSROUT            No, skip the buffer swap\n         LA    R2,4                Get +4 into a reg\n         LH    R0,FCBLRECL         Yes, get size of the new one\n         AR    R0,R2               +4 for possible RDW\n         GETMAIN R,LV=(0)          Go get it\n         L     R14,PCTOUTPT        Point at old buffer\n         SR    R14,R2              -4 for RDW area\n         LH    R15,DCBHLREC        Get old buffer length\n         AR    R0,R2               +4 for possible RDW\n         STM   R14,R15,DBL         Save old location/length for a bit\n         AR    R1,R2               Adjust new address for possible RDW\n         ST    R1,PCTOUTPT         Save address of new buffer\n         SR    R1,R2               Adjust back for MVCL\n         LR    R0,R1               Swap for MVCL regs\n         LH    R1,FCBLRECL         .\n         AR    R1,R2               .\n         MVCL  R0,R14              Copy the old buffer data\n         L     R0,DBL+4            Free the old buffer\n         L     R1,DBL              .\n         FREEMAIN R,LV=(0),A=(1)   .\n         MVC   DCBHLREC,FCBLRECL   Set new hi-water mark\n*\nCOPSROUT LR    R5,R7               Save R7 around SETROUTE\n         $CALL SETROUTE            Go setup output routes\n         LR    R7,R5               Reload R7\n         B     COPREAD             And go do it\n*\nCOPR1STR L     R14,FCBRECPT        Get address of I/P record save area\n         ST    R1,0(R14)           Save address of record read in PCT\n         ST    R1,FCBRECAD         and in it's FCB\n         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL\n         TM    FCBRECFM,X'C0'      An undefined record?\n         BNO   COPTIO2             No, skip this bit\n         CLC   FCBLRECL,FCBOBLK    Is blocksize read invalid?\n         BNH   COPTIO2             No, leave it alone\n         MVC   FCBLRECL,FCBOBLK    Yes, correct it right now\n         MVC   FCBDCB+DCBLRECL(2),FCBOBLK Before it causes problems\n*\nCOPTIO2  MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL read\n         MVC   FCBULREC,FCBDCB+DCBLRECL Also for user\n         L     R14,FCBLENPT        Get address of I/P reclen save area\n         MVC   2(2,R14),FCBLRECL   Save length of record just read\n         OI    PCTF4,IODONE        Say we did some I/O\n         CLC   FCBDDNAM,MDINPT1+2  Is this INPUT1?\n         BNE   COPBCOPY            No, skip unique INPUT1 stuff\n         $INC  PCTCOUNT            Update CREC counter\n         TM    PCTF1,IPCOPY        Separate Output buffer?\n         BZ    COPDFBUF            No, default O/P to I/P buffer\n         TM    PCTBFCDF,COPYBUFF   AUTOCOPY(YES)?\n         BZ    COPBCOPY            No, see if specific request\n         TM    PCTCFLAG,COPYBUFF   COPYBUFF request?\n         BZ    COPRDONE            No, ignore copies\n         OI    PCTF6,DEFRCOPY      Yes, try for the deferred mode\n         B     COPRDONE            Continue\n*\nCOPBCOPY TM    PCTCFLAG,COPYBUFF   COPYBUFF request?\n         BZ    COPRDONE            No, ignore copies\n*\nCOPBDOIT LR    R2,R1               Do\n         L     R4,PCTOUTPT         Setup\n         LH    R3,FCBLRECL         For\n         STH   R3,PCTOBUFL+2       Save length of rec on O/P buffer\n         LH    R5,DCBHLREC         An MVCL\n         ICM   R3,8,PCTPADCH       Put in specified fill char\n         MVCL  R4,R2               Move input record to output area\n         NI    PCTF6,255-DEFRCOPY  Kill any deferred copy\n         B     COPRDONE            Continue\n*\nCOPDFBUF ST    R1,PCTOUTPT         Make O/P buffer = I/P buffer\n         MVC   PCTOBUFL+2(2),FCBLRECL Save length of rec on O/P buffer.\n*\nCOPRDONE $INC  FCBCOUNT            Count the record\n         $INC  FCBCREC             .\n*\nCOPTRACE TM    PCTF7,DBIOTRAC      DEBUG IOTRACE?\n         BZ    COPDUMP             No\n         MVC   LINE(5),=C'Input'   Move in heading\n         MVC   LINE+6(23),TRHD     .\n         MVC   LINE+7(8),FCBDDNAM  Fill in data\n         L     R1,FCBCREC          Get current record number\n         CVD   R1,DBL\n         ED    LINE+20(8),DBL+4    Edit record number into line\n         MVI   LINE+20,C'('        Insert (\n         BAL   R14,LINPRINT        Print line\n*\nCOPDUMP  TM    PCTF7,DBDUMP        DEBUG DUMP?\n         BZ    COPREAL             No\n         MVC   TRADDR,FCBRECAD     Move address of record for DMPIT\n         LH    R15,FCBLRECL        Get length of record\n         ST    R15,TRLGTH          for DMPIT\n         LA    R14,TRFLAG-1        Fudge R15(R14) for DMPIT\n         $CALL DMPIT               Go dump record\n         EJECT\n*---------------------------------------------------------------------+\n*        The user's compiled program is given control here            |\n*        and will normally give control back at the label COPRETN.    |\n*---------------------------------------------------------------------+\n*\nCOPREAL  OI    PCTF1,EXEC          Show execution in user pgm\n         L     R14,PCTPGM          Get address of compiled pgm\n         BR    R14                 And go to it\n*\nCOPRETN  MVC   PCTCFLAG(12),0(R15) Save I/P control addressses\n         NI    PCTF1,255-EXEC      Show EXEC in main pgm\n         ICM   R7,15,PCTIPFCB      Point at FCB to be read\n         BZ    COPNOUT1            Null, then no INPUT1 present\n         TM    FCBF1,FCBOPEN       OPEN?\n         BZ    COPDFOPN            No, go see if Deferred OPEN\n*\nCOPCOPMD TM    PCTF3,ALL           SELECT's 'ALL' present?\n         BO    COPREAD             Yes, go back and read then\n         TM    PCTF6,OPCHECK       Told about the no-I/O?\n         BZ    COPREAD             Yes, don't give an error\n         ICM   R1,15,PCTMACNT      Get master active count\n         BNZ   COPREAD             Non-zero, go do the read\n         B     ADDSTATS            Zero, we're all done\n*\nCOPNOUT1 L     R1,=A(ERRTX33)      Point at error message\n         MVC   4(8,R1),MDINPT1+2   Move in DDname\n         $ERR  NOUT,12,SAVE=YES,FLAG=NO No, kill\n         B     ADDSTATS            Terminate\n*---------------------------------------------------------------------+\n*        FCB is not OPEN, if Deferred, try it now                     |\n*---------------------------------------------------------------------+\n*\nCOPDFOPN TM    FCBF1,FCBDOPEN      A Deferred file?\n         BZ    COPDFER1            No, whoops!\n         TM    PCTF8,PDSMODE       Global PDSMODE?\n         BZ    COPDIONR            No, normal OPEN\n         TM    FCBF2,FCBPDS        Is this FCB in PDS mode?\n         BNO   COPDIONR            No, skip\n         L     R2,PCTMEMBC         Get current 'member' name\n         MVC   FCBJFCB+44(8),0(R2) Stuff in member name\n         LA    R2,8(,R2)           Bump\n         ST    R2,PCTMEMBC         Save back for next time\n         OI    FCBJFCB+86,X'01'    Flag as a member\n         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   JFCB,FCBJFCB        Swap to common area\n         LA    R2,FCBDCB           OPEN it now\n         OPEN  ((R2),INPUT),TYPE=J .\n         B     COPDIOTS            Continue\n*\nCOPDIONR LA    R2,FCBDCB           Point at DCB\n         OPEN  ((R2),INPUT)        And open it\n*\nCOPDIOTS TM    48(R2),X'10'        Open O.K. ?\n         BNO   COPDFER2            No, whoops again!\n         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed\n         TM    FCBDCB+17,X'4F'     Is this a terminal file?\n         BNO   *+16                No\n         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM\n         MVC   FCBDSNAM(8),=C'TERMFILE' And insert termfile\n         LH    R1,FCBDCB+DCBLRECL  Save DCBDATA\n         STH   R1,FCBLRECL\n         STH   R1,FCBOLREC\n         LH    R1,FCBDCB+DCBBLKSI\n         STH   R1,FCBBLKSI\n         STH   R1,FCBOBLK\n         MVC   FCBRECFM,FCBDCB+DCBRECFM\n         MVC   FCBORECF,FCBRECFM\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         B     COPCOPMD            Go see if READ to do\n*\nCOPDFER1 $ERR  DOP1,20,FLAG=NO     Tell user\n         B     ADDSTATS            Terminate\n*\nCOPDFER2 L     R1,=A(ERRTX76)      Insert DDname into message\n         MVC   15(8,R1),FCBDDNAM   .\n         $ERR  DOP1,20,SAVE=YES,FLAG=NO  Tell user\n         B     ADDSTATS            Terminate\n         TITLE 'COPYDATA - End of file on INPUTn'\n*---------------------------------------------------------------------+\n*        EOF occurred on one of the INPUTn files                      |\n*---------------------------------------------------------------------+\n*\nCOPEOFIN NI    PCTF1,255-EXEC      Show exec in main pgm\n         TM    PCTF3,FAST          FASTCOPY?\n         BZ    COPEOFNR            No\n         L     R2,PCT1FCB          Yes, save counters really quick\n         ST    R7,FCBCOUNT-FCBDSECT(R2) Before we clobber them\n         ST    R7,FCBCREC-FCBDSECT(R2)  .\n         L     R7,PCT2FCB          .\n         ST    R9,FCBCOUNT         .\n         ST    R9,FCBCREC          .\n         B     COPEOFNF            Skip filling record\n*\nCOPEOFNR LH    R5,FCBLRECL         Get length of the record\n         CLI   FCBDCB+17,X'4F'     Terminal file?\n         BNE   *+10                No, continue\n         MVC   FCBRECAD,ZEROS      Yes, pretend no buffer\n         ICM   R4,15,FCBRECAD      Get address of record\n         BNZ   COPEOFFL            Yes, go fill it with FF's\n         LTR   R5,R5               No, got a length even?\n         BNZ   *+8                 Yes, use it\n         LH    R5,DCBHLREC         No, use our hi-water lrecl then\n         GETMAIN R,LV=(R5)         Get area if we don't have one\n         ST    R1,FCBRECAD         Save it's address\n         LR    R4,R1               Now put in R4 and continue\n*\nCOPEOFFL LR    R2,R4               Point at something\n         SR    R3,R3               Clear length\n         ICM   R3,8,PCTEOFFL       Pick up EOF fill character\n         MVCL  R4,R2               Fill it\n*\nCOPEOFNF OI    FCBF2,FCBEOF        Say we're at EOF\n         MVC   PCTPGM,PCTPGMS      Correct resume address\n         L     R14,PCTIPEOF        Get user's EOF address\n         BR    R14\n*\nCOPEOFER L     R2,=A(ERRTX38)      Point at error msg\n         MVC   27(8,R2),FCBDDNAM   Stuff in DDname\n         LH    R7,PCTLAST          Format STMNT # into msg\n         CVD   R7,DBL              .\n         UNPK  58(4,R2),DBL+5(3)   .\n         OI    61(R2),X'F0'        .\n         LH    R7,PCTLAST+2        Format WORD # into msg\n         CVD   R7,DBL              .\n         UNPK  72(3,R2),DBL+6(2)   .\n         OI    74(R2),X'F0'        .\n         $ERR  PEOF,12,GO=ADDSTATS,FLAG=NO Msg and terminate\n         $PEND\n         TITLE 'CPYIT put record to an Output file'\n*---------------------------------------------------------------------+\n*        Put selected records to the specified output file.           |\n*---------------------------------------------------------------------+\n*\nCPYIT    $PROC\n         STM   R0,R15,CPYSV        Save a few regs\n         LR    R15,R14             Swap control reg\n         TM    FCBF1,FCBOPEN       Already OPEN?\n         BO    CPYOPEN             Yes, continue\n*---------------------------------------------------------------------+\n*        This  FCB isn't OPEN, must be a deferred one, OPEN it now    |\n*---------------------------------------------------------------------+\n         TM    FCBF2,FCBPDS        Is this FCB in PDS mode?\n         BNO   CPYONOPN            No, skip\n         MVC   FCBJFCB+44(8),PCTOMEMB Stuff in member name\n         OI    FCBJFCB+86,X'01'    Flag as a member\n         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   JFCB,FCBJFCB        Swap to common area\n         LA    R2,FCBDCB           OPEN it now\n         OPEN  ((R2),OUTPUT),TYPE=J .\n         B     CPYOOPTS            Continue\n*\nCPYONOPN LA    R2,FCBDCB           Point at DCB\n         OPEN  ((R2),OUTPUT)       Open the file\n*\nCPYOOPTS TM    FCBDCB+48,X'10'     O. K. ?\n         BNO   CPYDOPR1            No, too bad\n         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed\n         TM    FCBDCB+17,X'4F'     Is this a terminal file?\n         BNO   *+16                No\n         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM\n         MVC   FCBDSNAM(8),=C'TERMFILE' And flag as terminal\n         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL\n         MVC   FCBOLREC,FCBLRECL\n         MVC   FCBULREC,FCBLRECL\n         MVC   FCBBLKSI,FCBDCB+DCBBLKSI BLKSIZE\n         MVC   FCBRECFM,FCBDCB+DCBRECFM And RECFM\n         MVC   FCBOBLK,FCBBLKSI\n         MVC   FCBORECF,FCBRECFM\n*\nCPYSETR  $CALL SDCBROUT,(R7)       Go assign I/P - O/P route\n         RDJFCB ((R2))             Go get JFCB again (after OPEN)\n         LTR   R15,R15             O.K. ?\n         BNZ   CPYDOPR1            No, error please\n         MVC   FCBJFCB,JFCB        Save the JFCB again\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         CLC   DDNAME,MDOUTP1+2    Is this OUTPUT1?\n         BNE   CPYOPEN             No, just exit then\n         ST    R7,PCT2FCB          Save address of OUTPUT1 FCB\n         LA    R2,FCBDCB           Point at DCB itself\n         ST    R2,PCT2DCB          Save it\n*---------------------------------------------------------------------+\n*        O.K. Now write the record                                    |\n*---------------------------------------------------------------------+\n*\nCPYOPEN  LM    R0,R15,CPYSV        Reload regs\n         LR    R15,R14             Swap control reg\n         TM    FCBF1,FCBCLOSD      CLOSED?\n         BO    BADIO               Yes, too bad!\n         $INC  FCBCOUNT            Count the record\n         $INC  FCBCREC             .\n         OI    PCTF4,IODONE        Say we did some I/O\n*        MVC   CPYULREC,FCBULREC   Save current ULREC\n*\nCPYTRACE TM    PCTF7,DBIOTRAC      I/O TRACE?\n         BZ    CPYREAL             No\n         MVC   LINE(6),=C'Output'  Move headings\n         MVC   LINE+6(23),TRHD     .\n         MVC   LINE+7(8),FCBDDNAM  Fill in data\n         L     R1,FCBCREC          Get current record number\n         CVD   R1,DBL\n         ED    LINE+20(8),DBL+4    Edit record number into line\n         MVI   LINE+20,C'('        Insert (\n         BAL   R14,LINPRINT        Print line\n         L     R15,CPYSV+56        Restore R15\n*\nCPYREAL  CLC   $SELLGTH,ZEROS      A LENGTH(...) override?\n         BE    CPYUCHK             No\n         MVC   FCBULREC,$SELLGTH+2 Swap in the override\n*\nCPYUCHK  CLC   FCBULREC,FCBOLREC   Has user created crappy LRECL?\n         BH    CPYABND             Yes, fail him now\n         EX    R0,FCBROUTE         Go to correct O/P route\n*\nCPYRFF   PUT   FCBDCB              Get std size O/P buffer area\n         LR    R2,R1               O/P loc is gotten buffer\n         LH    R3,FCBLRECL         O/P length is O/P LRECL\n         L     R4,PCTOUTPT         I/P loc is standard buffer\n         LR    R5,R3               I/P length is O/P LRECL\n         B     CPYRR5T             Go do MVCL\n*\nCPYRFV   L     R5,PCTOBUFL         I/P length is lngth of O/P buffer\n         L     R4,PCTOUTPT         I/P loc is standard buffer\n         LH    R2,FCBULREC         See if user gave us an LRECL\n         LTR   R2,R2               Zero (Not provided)\n         BNZ   CPYRFVX             Non-zero, skip\n         LA    R2,4(,R5)           Calc O/P length (including RDW)\n         CH    R2,FCBOLREC         If length greater than O/P\n         BNH   *+8                 Then set\n         LH    R2,FCBOLREC         It to the output LRECL\n*\nCPYRFVX  STH   R2,FCBDCB+DCBLRECL  Stuff in O/P DCB\n         PUT   FCBDCB              Get O/P buffer area\n         STH   R2,0(R1)            Put O/P length in RDW\n         LR    R3,R2               Calc O/P length for MVCL\n         SH    R3,=H'4'            As (LRECL-RDW)\n         MVC   2(2,R1),ZEROS       Complete RDW\n         LA    R2,4(,R1)           O/P loc is standard + 4\n         B     CPYRR5T             Go do MVCL\n*\nCPYRFU   L     R5,PCTOBUFL         I/P length is curr buff length\n         LH    R3,FCBULREC         See if user gave us an LRECL\n         LTR   R3,R3               Zero (Not provided)\n         BNZ   CPYRFUX             Non-zero, skip\n         LR    R3,R5               O/P length = I/P length\n         CH    R3,FCBOLREC         If length greater than O/P\n         BNH   *+8                 Then set\n         LH    R3,FCBOLREC         It to the output LRECL\n*\nCPYRFUX  STH   R3,FCBDCB+DCBLRECL  Put length in FCBDCB\n         PUT   FCBDCB              Get O/P area in buffer\n         LR    R2,R1               O/P loc is gotten buffer\n         L     R4,PCTOUTPT         I/P loc is standard buffer\n         B     CPYRR5T             Go do MVCL\n*\nCPYRVF   PUT   FCBDCB              Get O/P area in buffer\n         LR    R2,R1               O/P loc is gotten buffer\n         LH    R3,FCBLRECL         O/P length is O/P LRECL\n         L     R4,PCTOUTPT         Get normal I/P loc\n         LH    R5,0(R4)            Get normal length of I/P record\n         SH    R5,=H'4'            I/P length = standard - 4 (less RDW)\n         LA    R4,4(,R4)           I/P loc = standard+4 (over RDW)\n         B     CPYRR5T             Go do MVCL\n*\nCPYRVV   L     R4,PCTOUTPT         I/P loc is standard buffer\n         LH    R3,FCBULREC         See if user gave us an LRECL\n         LTR   R3,R3               Zero (Not provided)\n         BNZ   CPYRVVX             Non-zero, skip\n         LH    R3,0(R4)            O/P length = I/P RDW length\n         CH    R3,FCBOLREC         If length greater than O/P LRECL\n         BNH   *+8                 Then set\n         LH    R3,FCBOLREC         It to the output LRECL\n*\nCPYRVVX  STH   R3,0(R4)            Stuff altered length in RDW\n         STH   R3,FCBDCB+DCBLRECL  Stuff LRECL in FCBDCB\n         PUT   FCBDCB              Get O/P area in buffer\n         LR    R2,R1               O/P loc is gotten buffer\n         LR    R5,R3               I/P length = O/P length\n         B     CPYRR5T             Go do MVCL\n*\nCPYRVU   L     R4,PCTOUTPT         Get standard I/P loc\n         LH    R3,FCBULREC         See if user gave us an LRECL\n         LTR   R3,R3               Zero (Not provided)\n         BNZ   CPYRVUX             Non-zero, skip\n         LH    R3,0(R4)            Get I/P RDW length\n         SH    R3,=H'4'            O/P length = I/P RDW - 4 (less RDW)\n         CH    R3,FCBOLREC         If length greater than O/P\n         BNH   *+8                 Then set\n         LH    R3,FCBOLREC         It to the output LRECL\n*\nCPYRVUX  STH   R3,FCBDCB+DCBLRECL  Stuff length in FCBDCB\n         PUT   FCBDCB              Get O/P area in buffer\n         LR    R2,R1               O/P loc is gotten buffer\n         LA    R4,4(,R4)           I/P loc is standard + 4 (less RDW)\n         LR    R5,R3               I/P length is I/P RDW - 4 (less RDW)\n         B     CPYRR5T\n*\nCPYRUF   EQU   CPYRFF              Ditto logic for CPYRFF\n*\nCPYRUV   EQU   CPYRFV              Ditto logic for CPYRFV\n*\nCPYRUU   EQU   CPYRFU              Ditto logic for CPYRFU\n*\nCPYRR5T  TM    PCTF7,DBDUMP        DEBUG DUMP on?\n         BZ    CPYRR5M             No\n         STCM  R4,15,TRADDR        Set dump addresses\n         STCM  R3,15,TRLGTH        and length\n         LA    R14,TRFLAG-1        Fudge R15(R14)\n         $CALL DMPIT               Go dump record\n*\nCPYRR5M  ICM   R5,8,PCTPADCH       Stuff in fill char\n         MVCL  R2,R4               Do the move\n*        MVC   FCBULREC,CPYULREC   Restore user's LRECL for this file\n         MVC   FCBULREC,ZEROS      Reset the User's LRECL to zero\n         LM    R0,R15,CPYSV        Restore regs\n         $RET  0                   Go back\n*\nCPYABND  $ERR  LRECX,16,FLAG=NO    Issue error msg\n         ABEND 16                  Force User abend\n*\nCPYDOPR1 L     R1,=A(ERRTX76)      Insert DDname into message\n         MVC   15(8,R1),FCBDDNAM   .\n         $ERR  DOP1,20,SAVE=YES,FLAG=NO  Tell user\n         B     ADDSTATS            Terminate\n*\nCPYULREC DC    H'0'\n         EJECT\n*---------------------------------------------------------------------+\n* DCBRTBL   -  Copy routine select table                              |\n*                                                                     |\n*              1st byte has RECFM bits of INPUT1                      |\n*              2nd byte has RECFM bits of output anynameDD            |\n*              B instr. following is ultimately executed              |\n*---------------------------------------------------------------------+\nDCBRTBL  DS    0F\n         DC    X'C0C0'\n         B     CPYRUU\n         DC    X'C080'\n         B     CPYRFU\n         DC    X'C040'\n         B     CPYRVU\n         DC    X'C000'\n         B     CPYRUU\n         DC    X'80C0'\n         B     CPYRUF\n         DC    X'8080'\n         B     CPYRFF\n         DC    X'8040'\n         B     CPYRVF\n         DC    X'8000'\n         B     CPYRUF\n         DC    X'40C0'\n         B     CPYRUV\n         DC    X'4080'\n         B     CPYRFV\n         DC    X'4040'\n         B     CPYRVV\n         DC    X'4000'\n         B     CPYRUV\n         DC    X'00C0'\n         B     CPYRUU\n         DC    X'0080'\n         B     CPYRFU\n         DC    X'0040'\n         B     CPYRVU\nDCBRTBLE EQU   *\n         DC    X'0000'                     Default entry\n         B     CPYRUU\n         $PEND\n         TITLE 'CVOTOFCB - Get FCB address for sub-operand'\n*---------------------------------------------------------------------+\n*        Convert a sub-operand to an FCB address in OPGBASE           |\n*        ==================================================           |\n*                                                                     |\n*        Called:   $CALL CVOTOFCB,operand                             |\n*                                                                     |\n*        Operands: operand  - Pointer to a standard sub-operand       |\n*                             area. (See OPRDSECT for layout          |\n*                                                                     |\n*        Returns:  +0 if unable to complete successfully              |\n*                  +4 if completed O.K.                               |\n*                                                                     |\n*                  If O.K. OPGBASE has been completed.                |\n*---------------------------------------------------------------------+\n*\nCVOTOFCB $PROC 1\n         USING OPRDSECT,R3\n         L     R3,12(R8)\n         TM    OPRF2,OPRNUM        Numeric?\n         BNO   CVOOPDD             No, try as an O/P DD\n         CLC   PREFL,=H'6'         Correct length for INPUTn\n         BNE   CVOOPDD             No, treat as O/P DD\n         CLC   OPRL(8),MDINPT1     INPUT1?\n         BE    CVOIPGO             Yes, treat as I/P then\n         CLC   OPRTXT(5),=C'INPUT' INPUTn?\n         BE    CVOIPGO             Yes, treat as I/P then\n         B     CVOOPDD             Better be O/P then\n*\nCVOIPGO  L     R1,OPRNUM1          Load number then\n         CH    R1,=H'9'            Test against max\n         BH    CVOEX0              Sorry\n         CH    R1,=H'1'            Test against Min\n         BL    CVOEX0              Error if zero or neg\n         STC   R1,OPGBASE          Stuff file number in\n         OI    PCTF3,INPUT         Official Input file\n*\nCVOIPDD  $CALL DCBI1BLD,PREFL      Go get FCB address\n         B     BADDCB              +0 Verrrry sorrrry\n         NI    PCTF3,255-INPUT     +4 Remove flag\n         B     CVOSVAD             Go save address\n*\nCVOOPDD  $CALL DCBO1BLD,PREFL      Go get FCB address\n         B     BADDCB              +0 Verrrry sorrrry\n         MVI   OPGBASE,X'0A'       +4 Insert pseudo file number 10\n*\nCVOSVAD  STCM  R1,7,OPGBASE+1      Save in code\nCVOEX4   $RET  4                   And exit\n*\nCVOEX0   $RET  0                   Return with error\n         DROP  R3\n         $PEND\n         TITLE 'DBGADD - Add TRACE DEBUG code'\n*---------------------------------------------------------------------+\n*        Add TRACE logic to the compiled program                      |\n*---------------------------------------------------------------------+\n*\nDBGADD   $PROC\n         ZAP   DBL,GETCTR1         Convert\n         CVB   R1,DBL              Stmnt # to binary\n         STH   R1,DBGMSNO          Stuff in model code\n         ZAP   DBL,GETCTR2         Do also the word number\n         CVB   R1,DBL\n         STH   R1,DBGMWNO          Save it\n         $ADD  DBGM999-DBGMADR,DBGMADR Stuff it in pgm\n         $RET  0                   Return\n*---------------------------------------------------------------------+\n*        DEBUG routine model code                                     |\n*---------------------------------------------------------------------+\nDBGMADR  BAL   R14,TRACE           Go to TRACE (Returns +4)\nDBGMSNO  DC    XL2'00'             Stmnt #\nDBGMWNO  DC    XL2'00'             Word #\nDBGM999  EQU   *\n         $PEND\n         TITLE 'DCBx1BLD - Build I/O control blocks'\n*---------------------------------------------------------------------+\n*        Prepare control blocks for an input or output file           |\n*---------------------------------------------------------------------+\n*\nDCBI1BLD $PROC 1\n         NI    PCTF6,255-OUTPUT    Set to input processing\n         L     R2,12(R8)           Pick up pointer to 'word'\n         $CALL DCBCBLD             Perform common logic\n         B     DCBI1RT0            If returned +0 then also return +0\n         $RET  4                   Return +4 if returned to +4\n*\nDCBI1RT0 $RET  0                   Return +0\n         $PEND\n*\nDCBO1BLD $PROC 1\n         OI    PCTF6,OUTPUT        Set to output processing\n         L     R2,12(R8)           Pick up pointer to 'word'\n         $CALL DCBCBLD             Perform common logic\n         B     DCBO1RT0            If returned +0 then also return +0\n         $RET  4                   Return +4 if returned to +4\n*\nDCBO1RT0 $RET  0                   Return +0\n         $PEND\n*\nDCBCBLD  $PROC\n         MVC   DDNAME,BLANKS       Blank DDname\n         LH    R1,0(R2)            Get length of DDname\n         BCTR  R1,0                -1 for EX\n         EX    R1,*+4              Move it\n         MVC   DDNAME(0),2(R2)     .\n         LA    R3,PCTFCB           Load address of start of FCB chain\n*\nDCBCCHLP ICM   R7,15,0(R3)         Load next FCB address\n         BZ    DCBCEOCH            End of chain?, go add one to it\n         CLC   DDNAME,FCBDDNAM     See if we have this DDname already\n         BNE   DCBCCHN             No, try the next FCB\n*---------------------------------------------------------------------+\n*        The FCBINPUT/FCBOUTPT can only be off if this FCB was        |\n*        created by an OPTIONS DEFER(ddname) request (which of course |\n*        has no way of knowing whether its INPUT or OUTPUT)           |\n*---------------------------------------------------------------------+\n         TM    FCBF2,FCBINPUT+FCBOUTPT I/O mode already set?\n         BNZ   DCBTMODE            Yes, make sure we match\n         TM    PCTF6,OUTPUT        No, set it then\n         BO    *+12                .\n         OI    FCBF2,FCBINPUT      .\n         B     DCBCEOCH            .\n         OI    FCBF2,FCBOUTPT      .\n         B     DCBCEOCH            Go fill in more of the FCB\n*\nDCBTMODE TM    PCTF6,OUTPUT        Asked for as output?\n         BZ    DCBCICHK            No, input, see if thats what it is\n         TM    FCBF2,FCBOUTPT      Yes, is FCB output?\n         BZ    DCBCBDMD            No, bad mode then\n         B     DCBCCHEX            Yes, exit then\n*\nDCBCICHK TM    FCBF2,FCBINPUT      FCB better be input\n         BO    DCBCCHEX            Yes, we can exit\n*\nDCBCCHEX LR    R1,R7               Yes, put FCB address in R1\n         $RET  4                   And return +4\n*\nDCBCBDMD $ERR  BADMD,8,SKIP        Issue error message\n*\nDCBCCHN  LR    R3,R7               Setup for chaining\n         B     DCBCCHLP            And try again\n*---------------------------------------------------------------------+\n*        Fill in an FCB                                               |\n*---------------------------------------------------------------------+\n*\nDCBCEOCH DEVTYPE DDNAME,DEVTAB     Get device type of DDname\n         LTR   R15,R15             O.K. ?\n         BNZ   DCBCER1             No\n         LTR   R7,R7               Are we here cause no FCB exists?\n         BZ    DCBCGMIT            Right, go get an FCB\n         TM    FCBF1,FCBDOPEN      Deferred OPEN type?\n         BO    DCBCFFCB            Yes, also don't need GETMAIN\n         TM    FCBF2,FCBPDS        Or PDSMODE type?\n         BO    DCBCFFCB            Yes, also don't need GETMAIN\n*\nDCBCGMIT LA    R0,FCBLNGTH         Set length for GETMAIN\n         GETMAIN R,LV=(0)          Get an FCB area\n         LR    R7,R1               Put address of FCB in R7\n         ST    R7,0(R3)            Add to FCB chain\n         MVI   FCBCHAIN,X'00'      Zero area\n         MVC   FCBCHAIN+1(FCBDSNAM-FCBDSECT),FCBCHAIN\n         MVC   FCBDDNAM,DDNAME     Insert DDname\n         OI    FCBF1,FCBSTATS      Allow STATS at least once\n         NI    PCTF3,255-DCBOPT    DCB no longer optional\n*\nDCBCFFCB L     R2,=A(MDLSODCB)     Point at any old DCB\n         MVC   DCBDDNAM(8,R2),DDNAME Set DDname in DCB\n         RDJFCB ((R2))             Go get JFCB (if present)\n         LTR   R15,R15             O.K. ?\n         BNZ   DCBIER1             No, error please\n         MVC   FCBJFCB,JFCB        Save the JFCB\n         $CALL JFCNAME,FCBDSECT    Go build full dsname\n         MVC   FCBRECFM,JFCRECFM   Set in JFCB values\n         MVC   FCBLRECL,JFCLRECL   .\n         MVC   FCBBLKSI,JFCBLKSI   .\n         MVC   FCBDSORG,JFCDSORG   Save DSORG in FCB\n*\nDCBCIOSW TM    PCTF6,OUTPUT        Building output blocks?\n         BO    DCBCOSET            Yes, go there to complete it\n         $CALL DCBI2BLD            Input, go finish there\n         B     DCBCRT0             If returned +0 then also return +0\n         $RET  4                   Return +4 if returned to +4\n*\nDCBCER1  TM    PCTF3,DCBOPT        Is DDname optional?\n         BO    DCBCER1X            Yes, don't issue error message\n         L     R1,=A(ERRTX33)      Point at error message\n         MVC   4(8,R1),DDNAME      Move in DDname\n         $ERR  NOUT,12,SAVE=YES    No, kill\n*\nDCBCER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now\n         $RET  0                   Return +0 for error\n*\nDCBCRT0  $RET  0                   Return +0\n*\nDCBCOSET $CALL DCBO2BLD            Go complete as output file\n         B     DCBCRT0             If returned +0 then also return +0\n         $RET  4                   Return +4 if returned to +4\n         $PEND\n         EJECT\n*---------------------------------------------------------------------+\n*        Common preparation done, now complete as an input file       |\n*---------------------------------------------------------------------+\n*\nDCBI2BLD $PROC\n         CLI   DEVTAB+2,X'20'      DASD device?\n         BNE   DCBIUTS             No, then its got to be seq.\n         OBTAIN OBTCMLST,EADSCB=OK Yes, then go get it's DSCB\n         LTR   R15,R15             O.K. ?\n         BNZ   DCBIER2             No, verry sorry\n         L     R1,OBTCMLST+12      Get DSCB address\n         MVC   FCBDSORG,DS1DSORG-44(R1) Save DSORG from DSCB\n         CLC   FCBRECFM,ZEROS      Any RECFM yet?\n         BNE   *+10\n         MVC   FCBRECFM,DS1RECFM-44(R1) Save RECFM from DSCB\n         CLC   FCBLRECL,ZEROS      Any LRECL yet?\n         BNE   *+10\n         MVC   FCBLRECL,DS1LRECL-44(R1) Save LRECL from DSCB\n         CLC   FCBBLKSI,ZEROS      Any BLKSI yet?\n         BNE   *+10\n         MVC   FCBBLKSI,DS1BLKSI-44(R1) Save BLKSI from DSCB\n*\nDCBIUTS  L     R2,=A(MDLSIDCB)     Point at QSAM DCB\n*\nDCBIMV   MVC   FCBDCB,0(R2)        Move DCB into the FCB\n         OI    FCBF2,FCBINPUT      Flag as input DCB\n         MVC   FCBDCB+DCBDDNAM(8),FCBDDNAM\n         TM    PCTF3,INPUT         An official input file?\n         BZ    DCBIOPEN            No, just go open it\n         NI    PCTF3,255-INPUT     Yes, reset it then\n         CLC   FCBDDNAM,MDINPT1+2  Validate DDname\n         BE    DCBITPO             .\n         CLC   FCBDDNAM(5),=C'INPUT'\n         BNE   DCBIBDD             .\n         CLC   FCBDDNAM+6(2),BLANKS\n         BNE   DCBIBDD             .\n         CLI   FCBDDNAM+5,C'2'     .\n         BL    DCBIBDD             .\n         TM    FCBDDNAM+5,X'F0'    .\n         BNO   DCBIBDD             .\n         OI    PCTF1,IPCOPY        Treat as I/P copy run\n         B     DCBICNVT            Continue\n*\nDCBITPO  TM    PCTF8,PDSMODE       Was PDSMODE specified?\n         BZ    DCBICNVT            No, skip all this\n         CLC   FCBJFCB+44(8),BLANKS A Member name?\n         BNE   DCBICNVT            Yes, leave as sequential\n         TM    FCBDSORG,X'02'      PO dataset?\n         BZ    DCBICNVT            No, leave as sequential\n         OI    FCBF2,FCBPDS        Yes, mark for PDSMODE processing\n         $CALL DIRREAD             then read PDS Directory\n         B     DCBITR0             +0 Error reading directory\n*\nDCBICNVT IC    R2,FCBDDNAM+5       Convert it\n         N     R2,=X'0000000F'     .\n         STH   R2,FCBFILNO         And save in FCB\n         SLL   R2,2                x 4\n         LA    R1,PCTINPT1-4(R2)   Point at PCT record address area\n         ST    R1,FCBRECPT         Save its address\n         LA    R1,PCTINPL1-4(R2)   Point at PCT record length area\n         ST    R1,FCBLENPT         Save its address\n         SR    R1,R1               Clear reg\n         ST    R1,FCBRECAD         Clear record address field\n         B     DCBIOPEN            Now go open it\n*\nDCBIBDD  $ERR  MAXI,12,GO=DCBIER1X Sorry, you get a message\n         EJECT\n*---------------------------------------------------------------------+\n*        Open input DCB and save some data about it                   |\n*---------------------------------------------------------------------+\n*\nDCBIOPEN TM    FCBF1,FCBDOPEN      Deferred OPEN?\n         BO    DCBIEX              Yes, skip this stuff for now\n         TM    PCTF8,PDSMODE       PDSMODE?\n         BZ    DCBINRM             No, normal OPEN\n         CLC   FCBDDNAM,MDINPT1+2  INPUT1 DDname\n         BNE   DCBINRM             No, skip\n         TM    PCTF8,PDSEMPTY      Is INPUT1 empty of members?\n         BO    DCBIEX              Skip the OPEN\n         L     R2,PCTMEMBC         Get current 'member' name\n         MVC   FCBJFCB+44(8),0(R2) Stuff in member name\n         MVC   PCTIMEMB,0(R2)      Stuff as global I/P member\n         MVC   PCTOMEMB,0(R2)      Stuff in global O/P member\n         LA    R2,8(,R2)           Bump\n         ST    R2,PCTMEMBC         Save back for next time\n         OI    FCBJFCB+86,X'01'    Flag as a member\n         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   JFCB,FCBJFCB        Swap to common area\n         LA    R2,FCBDCB           OPEN it now\n         OPEN  ((R2),INPUT),TYPE=J .\n         B     DCBIOPNT            Continue\n*\nDCBINRM  LA    R2,FCBDCB           Point at DCB\n         OPEN  ((R2),INPUT)        And open it\n*\nDCBIOPNT TM    48(R2),X'10'        Open O.K. ?\n         BNO   DCBIER3             Yes\n         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed\n         TM    FCBDCB+17,X'4F'     Is this a terminal file?\n         BNO   *+16                No\n         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM\n         MVC   FCBDSNAM(8),=C'TERMFILE' And insert termfile\n         LH    R1,FCBDCB+DCBLRECL  Save DCBDATA\n         STH   R1,FCBLRECL\n         STH   R1,FCBOLREC\n         LH    R1,FCBDCB+DCBBLKSI\n         STH   R1,FCBBLKSI\n         STH   R1,FCBOBLK\n         MVC   FCBRECFM,FCBDCB+DCBRECFM\n         MVC   FCBORECF,FCBRECFM\n         CLC   DCBHLREC,FCBLRECL   New high LRECL ??\n         BNL   *+10                Still O. K.\n         MVC   DCBHLREC,FCBLRECL   Save the new high value\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n*\nDCBIEX   LR    R1,R7               Pass FCB address back in R1\n         $RET  4                   Return +4, all O.K.\n*\nDCBIER1  TM    PCTF3,DCBOPT        Is DDname optional?\n         BO    DCBIER1X            Yes, don't issue error message\n         L     R1,=A(ERRTX33)      Point at error message\n         MVC   4(8,R1),DDNAME      Move in DDname\n         $ERR  NOUT,12,SAVE=YES    No, kill\n*\nDCBIER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now\n*\nDCBITR0  $RET  0                   Return +0 for error\n*\nDCBIER2  L     R1,=A(ERRTX34)      Point at error message\n         MVC   19(8,R1),DDNAME     Insert DDname\n         $ERR  DSUT,12,SAVE=YES    No, kill the step\n         $RET  0                   Return +0 for error\n*\nDCBIER3  L     R1,=A(ERRTX29)      Point at error text\n         MVC   17(8,R1),DDNAME     Stuff in DDname\n         $ERR  ODCB,12,SAVE=YES    No, issue err msg\n         $RET  0                   Return +0 for error\n         $PEND\n         EJECT\n*---------------------------------------------------------------------+\n*        Common preparation done, now complete as an output file      |\n*---------------------------------------------------------------------+\n*\nDCBO2BLD $PROC\n         OI    FCBF2,FCBOUTPT      Flag as output FCB\n         L     R2,=A(MDLSODCB)     Point at model sequential DCB\n         CLI   DEVTAB+2,X'20'      Is it DASD?\n         BNE   DCBOMV              No, must be seq\n         OBTAIN OBTCMLST,EADSCB=OK Yes, then go get it's DSCB\n         LTR   R15,R15             O.K. ?\n         BNZ   DCBOER2             No, verry sorry\n         L     R1,OBTCMLST+12      Get DSCB address\n         MVC   FCBDSORG,DS1DSORG-44(R1) Save DSORG from DSCB\n         TM    PCTF8,PDSMODE       Was PDSMODE specified?\n         BZ    DCBOMV              No, skip all this\n         CLC   FCBJFCB+44(8),BLANKS A Member name?\n         BNE   DCBOMV              Yes, leave as sequential\n         TM    FCBDSORG,X'02'      PO dataset?\n         BZ    DCBOMV              No, leave as sequential\n         OI    FCBF2,FCBPDS        Yes, mark for PDSMODE processing\n         OI    FCBF1,FCBDOPEN      and set FCB to deferred OPEN\n         B     DCBOMV              Continue\n*\nDCBOMV   MVC   FCBDCB,0(R2)        Move in model output DCB\n         MVC   FCBDCB+DCBDDNAM(8),FCBDDNAM\n         TM    FCBF1,FCBDOPEN      Deferred OPEN ?\n         BO    DCBORETN            Yes, skip this for now\n         LA    R2,FCBDCB           Point at DCB\n         OPEN  ((R2),OUTPUT)       Open the file\n         TM    FCBDCB+48,X'10'     O. K. ?\n         BNO   DCBOER3             No, too bad\n         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed\n         TM    FCBDCB+17,X'4F'     Is this a terminal file?\n         BNO   *+16                No\n         MVC   FCBDSNAM,BLANKS     Blank FCBDSNAM\n         MVC   FCBDSNAM(8),=C'TERMFILE' And flag as terminal\n         MVC   FCBLRECL,FCBDCB+DCBLRECL Save LRECL\n         MVC   FCBOLREC,FCBLRECL\n         MVC   FCBBLKSI,FCBDCB+DCBBLKSI BLKSIZE\n         MVC   FCBRECFM,FCBDCB+DCBRECFM And RECFM\n         MVC   FCBOBLK,FCBBLKSI\n         MVC   FCBORECF,FCBRECFM\n         CLC   DEFLRECL,ZEROS      Got a default LRECL yet?\n         BE    DCBOSETR            No, skip\n         CLC   DCBHLREC,FCBLRECL   New high LRECL ??\n         BNL   DCBOSETR            Still O. K.\n         MVC   DCBHLREC,FCBLRECL   Save the new high value\n         CLC   FCBLRECL,DEFLRECL   Is this LRECL > DEFLRECL?\n         BNH   DCBOSETR            No, continue\n         OI    PCTF1,IPCOPY        Yes, force 2 buffers\n*\nDCBOSETR $CALL SDCBROUT,(R7)       Go assign I/P - O/P route\n         RDJFCB ((R2))             Go get JFCB again (after OPEN)\n         LTR   R15,R15             O.K. ?\n         BNZ   DCBOER3             No, error please\n         MVC   FCBJFCB,JFCB        Save the JFCB again\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         CLC   DDNAME,MDOUTP1+2    Is this OUTPUT1?\n         BNE   DCBORETN            No, just exit then\n         ST    R7,PCT2FCB          Save address of OUTPUT1 FCB\n         LA    R2,FCBDCB           Point at DCB itself\n         ST    R2,PCT2DCB          Save it\n*\nDCBORETN LR    R1,R7               Pass FCB address back in R1\n         $RET  4                   Return now\n*\nDCBOER1  TM    PCTF3,DCBOPT        Is DDname optional?\n         BO    DCBOER1X            Yes, don't issue error message\n         L     R1,=A(ERRTX33)      Point at error message\n         MVC   4(8,R1),DDNAME      Move in DDname\n         $ERR  NOUT,12,SAVE=YES    No, kill\n*\nDCBOER1X NI    PCTF3,255-DCBOPT    Remove DCBOPT flag now\n         $RET  0                   Return +0 for error\n*\nDCBOER2  L     R1,=A(ERRTX34)      Point at error message\n         MVC   19(8,R1),DDNAME     Insert DDname\n         $ERR  DSUT,12,SAVE=YES    No, kill the step\n         $RET  0                   Return +0 for error\n*\nDCBOER3  L     R1,=A(ERRTX29)      Point at error text\n         MVC   17(8,R1),DDNAME     Stuff in DDname\n         $ERR  ODCB,12,SAVE=YES    No, issue err msg\n         $RET  0                   Return +0 for error\n         $PEND\n         TITLE 'DEBUG - Command processor'\n*---------------------------------------------------------------------+\n*        D E B U G    C o m m a n d   P r o c e s s o r               |\n*---------------------------------------------------------------------+\n*\nDEBUG    $PROC\n         USING KWDSECT,R14\n         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address\n         TM    PCTF2,DSYSPRT       Better have a SYSPRINT DD then\n         BZ    BADSYSPR            No, velly sully!\n*---------------------------------------------------------------------+\n*        Loop for each DEBUG operand                                  |\n*---------------------------------------------------------------------+\n*\nDEBLOOP  $CALL GETNEXT             Go get next word\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    EXITGOK             Yes, exit\n         TM    WFLAG1,WPREF+WTRLR  Invalid format?\n         BNZ   BADOPTYP            Yes, kill it\n         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP+OPRKWOPV Valid KW(...)?\n         BNO   BADKWORD            No, kill it\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWOPRAND       A valid type?\n         BZ    BADKWORD            No, sorry\n         MVN   KWNUM,=X'00'        Clear lo-order nibble\n         CLI   KWNUM,X'60'         Valid debug KW?\n         BNE   BADKWORD            No, sorry\n         L     R2,KWD2             Get address of routine\n         BR    R2                  Branch by type\n*---------------------------------------------------------------------+\n*        Process the IOTRACE(..) operand                              |\n*---------------------------------------------------------------------+\n*\nDEBIOTR  $CALL DBGADD              Go add DEBUG code\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     DEBIOTON            ON\n         B     DEBIOTOF            OFF\n         B     DEBIOTIN            INIT\n*\nDEBIOTON $ADD  4,DEBMITON          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBIOTOF $ADD  4,DEBMITOF          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBIOTIN OI    PCTF7,DBIOTRAC      Turn on I/O trace right now\n         B     DEBLOOP             Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the IODUMP(...) operand                              |\n*---------------------------------------------------------------------+\n*\nDEBIODM  $CALL DBGADD              Go add DEBUG code\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     DEBIODON            ON\n         B     DEBIODOF            OFF\n         B     DEBIODIN            INIT\n*\nDEBIODON $ADD  4,DEBMIDON          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBIODOF $ADD  4,DEBMIDOF          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBIODIN OI    PCTF7,DBIOTRAC+DBDUMP Turn on I/O trace & dump now\n         B     DEBLOOP             Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the TRACE(....) operand                              |\n*---------------------------------------------------------------------+\n*\nDEBTRAC  $CALL DBGADD              Go add DEBUG code\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     DEBTRON             ON\n         B     DEBTROF             OFF\n         B     DEBTRIN             INIT\n*\nDEBTRON  $ADD  4,DEBMTRON          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBTROF  $ADD  4,DEBMTROF          Add code\n         B     DEBLOOP             Keep on truckin'\n*\nDEBTRIN  OI    PCTF7,DBTRACE       Turn on Trace now\n         B     DEBLOOP             Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the SUPPORT(ON) operand                              |\n*---------------------------------------------------------------------+\n*\nDEBSUPP  LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLC   KWD2,=F'4'          'ON'\n         BNE   BADKWVAL            No, sorry\n         ICM   R1,15,PGMIC         A program started?\n         BNZ   DEBSUPER            Yes, sorrry!\n         L     R1,=A(ABNDFORC)     Let abends complete\n         OI    1(R1),X'F0'         .\n         L     R15,=A(MAINETRC)    Point at flag\n         NI    1(R15),X'0F'        Force snap of program area\n         GETMAIN R,LV=400          Get a support table area\n         MVC   0(4,R1),HEXFFS      Stuff in delimiter\n         ST    R1,PCTSUPP1         Save its address\n         ST    R1,PCTSUPP2         ... Twice\n         B     DEBLOOP             Keep on truckin'\n*\nDEBSUPER $ERR  SUPER,8,SKIP        Kill it\n         EJECT\n*---------------------------------------------------------------------+\n*        DEBUG  routine work areas                                    |\n*---------------------------------------------------------------------+\n*\nDEBMITOF NI    PCTF7,255-DBIOTRAC-DBDUMP Turn off I/O trace and dump\nDEBMITON OI    PCTF7,DBIOTRAC      Turn on I/O trace\nDEBMIDON OI    PCTF7,DBIOTRAC+DBDUMP Turn on I/O trace and dump\nDEBMIDOF NI    PCTF7,255-DBDUMP    Turn off I/O dump\nDEBMTRON OI    PCTF7,DBTRACE       Turn on logic trace\nDEBMTROF NI    PCTF7,255-DBTRACE   Turn off logic trace\n         DROP  R14\n         $PEND\n         TITLE 'DIRREAD - Read PDS Directory into memory'\n*---------------------------------------------------------------------+\n*        In PDSMODE, Read INPUT1 Directory                            |\n*---------------------------------------------------------------------+\n*\nDIRREAD  $PROC\n         MVC   DIRINPUT+DCBDDNAM(8),MDINPT1+2 Pick up correct DDNAME\n         OPEN  (DIRINPUT,INPUT)    OPEN directory\n         TM    DIRINPUT+48,X'10'\n         BZ    DIROERR             No good, error message\n         SR    R2,R2               Count Dir blocks\n*\nDIRLOOP1 GET   DIRINPUT            Get a block\n         LA    R2,1(,R2)           Count it\n         B     DIRLOOP1            Loop\n*\nDIREOD1  CLOSE DIRINPUT            Close\n         MVC   DIRINPUT+DCBEODAD(3),=AL3(DIREOD2) Swap EOD address\n         OPEN  (DIRINPUT,INPUT)    Start over\n         LA    R2,1(,R2)           Insurance space\n         MH    R2,=H'160'          8 * (# membs / block) = table size\n         GETMAIN R,LV=(R2)         Get a member storage area\n         ST    R1,PCTMEMBT         Save its address\n         ST    R1,PCTMEMBC         and as 'current'\n         LR    R2,R1               Work Reg\n*\nDIRLOOP2 GET   DIRINPUT            Get a record\n         LH    R3,0(R1)            Pickup length of data in block\n         AR    R3,R1               Create ptr to last+1\n         LA    R4,2(R1)            Point at 1st members dir data\n*\nDIRCEOF  CLC   0(8,R4),=8X'FF'     End of directory\n         BE    DIREOD2             Yes, end list\n         TM    11(R4),X'80'        ALIAS name?\n         BO    DIRCNEXT            Yes, skip it\n         MVC   0(8,R2),0(R4)       No, save in table\n         LA    R2,8(,R2)           Bump to next location\n*\nDIRCNEXT IC    R1,11(R4)           And step to next member in dir\n         N     R1,=X'0000001F'     Clear rubbish bits to leave length\n         SLL   R1,1                Convert from Hwords to bytes\n         LA    R4,12(R4,R1)        Step to next dir location\n         CR    R4,R3               Check against last location\n         BNL   DIRLOOP2            If block done, go get another\n         B     DIRCEOF             Go check for logical EOF\n*\nDIREOD2  MVC   0(8,R2),=8X'FF'     Terminate member list\n         CLOSE (DIRINPUT)          Close Directory\n         FREEPOOL DIRINPUT         Free its buffers\n         C     R2,PCTMEMBT         Empty directory?\n         BE    DIREMPTY            Yes, kill it\n         $RET  4                   Return O.K.\n*\nDIROERR  L     R1,=A(ERRTX29)      Point at error text\n         MVC   17(8,R1),MDINPT1+2  Stuff in DDname\n         $ERR  ODCB,12,SAVE=YES    No, issue err msg\n         $RET  0                   Return +0 for error\n*\nDIREMPTY $ERR  PEMPT,8,SAVE=YES,FLAG=NO Issue err msg\n         OI    PCTF8,PDSEMPTY      Remember we're empty\n         $RET  4                   Continue RC=8 will cause termnate\n*\nDIRINPUT DCB   DDNAME=INPUT1,DSORG=PS,EODAD=DIREOD1,MACRF=GL,          X\n               RECFM=F,LRECL=256,BLKSIZE=256\n         $PEND\n         TITLE 'DMPIT - Dump selected record to SYSPRINT'\n*---------------------------------------------------------------------+\n*        Print output record in the requested format                  |\n*---------------------------------------------------------------------+\n*\nDMPIT    $PROC\n         STM   R0,R15,DMPSV        Save regs in DMPSV\n         LR    R15,R14             Put ctl reg back in R15\n         NOP   DMPGO               First time sw\n         OI    *-3,X'F0'           Set it\n         MVC   LINHDA3,=A(LINHD3)  Swap page heads\n         ZAP   LINECT,=P'1'        Force new page\n*\nDMPGO    ZAP   NEEDCNT,=P'1'       See how many lines needed\n         TM    $SELF1,CHAR         CHAR?\n         BZ    *+10                No\n         AP    NEEDCNT,=P'1'       +1\n         TM    $SELF1,HEX          HEX?\n         BZ    *+10                No\n         AP    NEEDCNT,=P'2'       +2\n         MVC   LINE(6),=C'Record'  Setup ident info\n         MVC   LINE+15(6),=C'Length'\n         L     R1,PCTCOUNT         Get record number\n         CVD   R1,DBL              Convert it\n         MVC   LINE+6(8),=X'4020202020202120'\n         ED    LINE+6(8),DBL+4\n         L     R1,PCTOUTPT         Get address of rec to print\n         MVC   DMPLRECL,PCTOBUFL+2 Put length in work field\n         TM    DEFRECFM,X'80'      Fixed or undefined?\n         BO    DMPSEETR            Yes, see if overridden\n         TM    DEFRECFM,X'40'      Variable?\n         BNO   DMPSEETR            No, skip\n         MVC   DMPLRECL,0(R1)      Yes, use RDW length\n*\nDMPSEETR TM    $SELF1,SPTR         Special IODUMP request\n         BZ    DMPSEELN            No, see if LENGTH(...) override\n         ICM   R1,15,TRADDR        Yes, get alternate address\n         MVC   DMPLRECL,TRLGTH+2   and get alternate length\n         B     DMPSTADD            Go process with these values\n*\nDMPSEELN CLC   $SELLGTH,ZEROS      An override?\n         BE    DMPSTADD            No, continue\n         MVC   DMPLRECL,$SELLGTH+2 Yes, copy it\n*\nDMPSTADD ST    R1,DMPADDR          Put address of rec in work field\n         CLC   DMPLRECL,DCBHLREC   Over absolute max LRECL?\n         BNH   *+10                No, continue\n         MVC   DMPLRECL,DCBHLREC   Yes, set it to max\n         LH    R1,DMPLRECL         Get length of record\n         CVD   R1,DBL              Convert it\n         MVC   LINE+24(6),=X'402020202120'\n         ED    LINE+24(6),DBL+5\n*\nDMPFMTLP CP    NEEDCNT,LINECT      Enough lines left on page?\n         BL    *+10                Yes, continue\n         ZAP   LINECT,=P'1'        No, force page head\n         TM    $SELF1,CHAR         Is CHAR dump wanted?\n         BZ    DMPNOCH             No, go see if HEX wanted\n         BAL   R14,DMPMV           Yes, move data to line\n         LTR   R1,R1               Zero length?\n         BZ    *+12                Yes, skip right to print\n         L     R15,=A(TRTBLC)      Get address of char TR table\n         EX    R1,DMPTR1           Get rid of unprintable\n         BAL   R14,LINPRINT        And print it\n         L     R15,DMPSV+56        Restore R15\n*\nDMPNOCH  TM    $SELF1,HEX          HEX wanted?\n         BZ    DMPLOOP             No, print is done,see if rec is done\n         BAL   R14,DMPMV           Yes, go move the data\n         LTR   R1,R1               Zero length?\n         BZ    *+12                Yes, skip right to print\n         L     R15,=A(TRTBLLH)     Get LH TR table address\n         EX    R1,DMPTR1           Convert to hex\n         BAL   R14,LINPRINT        And print it\n         BAL   R14,DMPMV           Go move it again\n         LTR   R1,R1               Zero length?\n         BZ    *+12                Yes, skip right to print\n         L     R15,=A(TRTBLRH)     Get RH TR table address\n         EX    R1,DMPTR1           Convert to hex\n         BAL   R14,LINPRINT        And print it\n*\nDMPLOOP  LH    R1,DMPLRECL         Get LRECL\n         CH    R1,=H'100'          Did it all fit on last line?\n         BNH   DMPEXIT             Yes, exit\n         LA    R2,100              Put 100 in a reg\n         SR    R1,R2               Subt 100 from remaining data to prt\n         STH   R1,DMPLRECL         And put it back\n         L     R1,DMPADDR          Then get dump address\n         AR    R1,R2               Bump by 100\n         ST    R1,DMPADDR          And put it back too\n         L     R15,DMPSV+56        Restore R15\n         ICM   R2,7,PCTOUTPT+1     Get original start addr\n         TM    $SELF1,SPTR         Special IODUMP request\n         BZ    *+8                 No, R1 is O.K.\n         ICM   R2,15,TRADDR        Yes, get alternate address\n         SR    R1,R2               Calc current offset\n         CVD   R1,DBL              Convert it\n         OI    DBL+6,X'0F'         Truncate to 100's\n         UNPK  LINE+27(3),DBL+5(2) Put in line\n         B     DMPFMTLP            Then loop back\n*\nDMPMV    LH    R1,DMPLRECL         Get LRECL\n         CH    R1,=H'100'          Check against max line length\n         BNH   *+8                 Will fit OK\n         LA    R1,100              Won't fit, set to 100\n         LTR   R1,R1               Zero?\n         BZ    DMPMVEX\n         BCTR  R1,0                Set it up for EX\n         L     R2,DMPADDR          Get from address\n         EX    R1,*+4              Move to print line\n         MVC   LINE+31(0),0(R2)    .\n*\nDMPMVEX  LA    R3,LINE+31(R1)      Point 1 byte past end of data\n         MVI   1(R3),C'|'          Put in delimiter\n         MVI   LINE+30,C'|'\n         BR    R14\n*\nDMPEXIT  ICM   R7,15,PCTPFCB       Point at printer FCB\n         BZ    DMPEXIT2            Skip if none\n         $INC  FCBCOUNT            Count recs printed\n         $INC  FCBCREC             .\n*\nDMPEXIT2 LM    R0,R15,DMPSV\n         $RET  0\nNEEDCNT  DC    P'55'\n         $PEND\n         TITLE 'ELSE - Command processor'\n*---------------------------------------------------------------------+\n*        E L S E   C o m m a n d   P r o c e s s o r                  |\n*---------------------------------------------------------------------+\n*\nELSE     $PROC\n         USING KWDSECT,R14\n         ICM   R3,15,PCTPOPLS      Get last POP'ed address\n         BNZ   ELSOK               Non-zero, continue\n         $ERR  BELSE,8,SKIP        Zero, too bad\n*\nELSOK    $ADD  ELSGM999-ELSGMBAL,ELSGMBAL Stuff in chain code\n         LA    R1,4(,R1)           Point at Adcon\n         $CALL PUSHIF              Save its address\n         OI    PCTF4,IFNXSENT      Set to have it resolved later\n         $ADD  0,*                 Get I.C.\n         ICM   R3,15,PCTPOPLS      Get last POP'ed address again\n         ST    R1,0(R3)            Make prev. Nxt Sent point here\n         SR    R1,R1               Clear R1\n         ST    R1,PCTPOPLS         Clear PCTPOPLS\n         $CALL GETNEXT             Get the next word\n         TM    WFLAG1,WPREF+WWRD2+WTRLR Eliminate invalid sub-operands\n         BNZ   ELSEBD              .\n         TM    WFLAG1,WWRD1        Better have this one\n         BZ    ELSEBD              Nope, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?\n         BZ    ELSEBD              Nope, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWIFTRU        Valid in context?\n         BZ    ELSEBD              No, sorry\n         L     R8,KWD3             Get addr of routine\n         B     8(R8)               And go to it\n*\nELSEDO   DS    CL8                 Make compatible with a $PROC\n         NI    PCTF4,255-IFNXSENT  Ensure flag is off\n         B     MAINGEOS            Go get the period.\n*\nELSEBD   $ERR  BELSB,8,SKIP\n*\nELSGMBAL BAL   R14,COMPGOTO        Off to the GOTO support routine\nELSGMADC DC    XL4'00'             Adcon\nELSGM999 EQU   *\n         DROP  R14\n         $PEND\n         TITLE 'END - Command processor'\n*---------------------------------------------------------------------+\n*        E N D   C o m m a n d   P r o c e s s o r                    |\n*---------------------------------------------------------------------+\n*\nEND      $PROC\n         ICM   R0,15,PCTNEST       Nest counter > 0\n         BP    ENDISOK             Yes, good\n         $ERR  BADDO,8,SKIP        No, too bad\n*\nENDISOK  $CALL POPIF               POP one next sentence pointer\n         B     MAINGEOS            Go finish with period (.)\n         $PEND\n         TITLE 'EOJ - End of job routines'\n*---------------------------------------------------------------------+\n*        Enter here on program termination                            |\n*---------------------------------------------------------------------+\n*\nEOJ      $PROC\n*\nEOJCADD  $CALL ADDSTAT             Go close outputs and build stat msgs\n         TM    PCTF8,PDSMODE       PDSMODE?\n         BZ    EOJKTIME            No, continue shutdown\n         CLI   PCTRC+3,X'08'       RC type shutdown?\n         BNL   EOJKTIME            Yes, keep shutting down\n         L     R2,PCTMEMBC         Get next member address\n         CLC   0(8,R2),=8X'FF'     All done?\n         BE    EOJPDSMD            Yes, PDSMODE all done\n         L     R7,PCT1FCB          Point at INPUT1 FCB\n         L     R2,PCTMEMBC         Get current 'member' name\n         MVC   FCBJFCB+44(8),0(R2) Stuff in member name\n         MVC   PCTIMEMB,0(R2)      Stuff as global I/P member\n         MVC   PCTOMEMB,0(R2)      Stuff in global O/P member\n         LA    R2,8(,R2)           Bump\n         ST    R2,PCTMEMBC         Save back for next time\n         OI    FCBJFCB+86,X'01'    Flag as a member\n         OI    FCBJFCB+52,X'08'    Don't re-write JFCB during OPEN\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   JFCB,FCBJFCB        Swap to common area\n         LA    R2,FCBDCB           OPEN it now\n         OPEN  ((R2),INPUT),TYPE=J .\n         TM    48(R2),X'10'        Open O.K. ?\n         BNO   EOJIER3             Yes\n         OI    FCBF1,FCBOPEN+FCBSTATS Flag as open STATS allowed\n*---------------------------------------------------------------------+\n*        Reset other stuff for Loopback processing                    |\n*---------------------------------------------------------------------+\n         MVC   PCTCOUNT,ZEROS      Master CREC\n         MVC   PCTOBUFL,ZEROS      Length in OBUFF\n         MVC   PCTFLCHG(28),ZEROS  Floating field support\n         MVC   PCTPOPLS,ZEROS      POP ctr\n         MVC   PCTNEST,ZEROS       Nest ctr\n         MVI   PCTNEXT,X'00'       Next sentence stack\n         MVC   PCTNEXT+1(79),PCTNEXT\n         ICM   R2,15,PCTRESET      Get reset chain\n         BZ    EOJRET0             None? O.K. exit then\n         L     R3,4(R2)            Get address of where to reset\n         MVC   0(4,R3),8(R2)       Stuff in reset value\n         ICM   R2,15,0(R2)         Chain onward\n         BNZ   *-14                Loop till done\n*\nEOJRET0  $RET  0                   Return for next member\n*\nEOJIER3  L     R1,=A(ERRTX29)      Point at error text\n         MVC   17(8,R1),FCBDDNAM   Stuff in DDname\n         $ERR  ODCB,12,SAVE=YES    No, issue err msg\n*\nEOJPDSMD NI    PCTF8,255-PDSMODE   Kill PDS mode now\n         OI    PCTF8,PDSSTATS      Now say we want stats\n         B     EOJCADD             Loop back for full shutdown\n*\nEOJKTIME TTIMER CANCEL             Cancel outstanding STIMER\n         ICM   R7,15,PCTPFCB       Now point at SYSPRINT FCB\n         BZ    EOJUCTRS            Skip if not there\n         $CALL ADDPROC,(R7)        Else process it now (i.e. last)\n*\nEOJUCTRS TM    PCTF7,UCTRDUMP      UCTRx dump wanted?\n         BZ    EOJSEEAB            No\n         CLI   PCTUCTRA,X'00'      See if all counters are zero\n         BNE   EOJUINIT            No, go dump them\n         CLC   PCTUCTRA((4*26)-1),PCTUCTRA+1\n         BE    EOJSEEAB            Yes, all zero, skip\n*\nEOJUINIT $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         $ERR  UCTRH,0,TYPE=STAT,FLAG=NO   Init with heading\n         $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         LA    R3,PCTUCTRA         Point at counters\n         SR    R4,R4               Clear index\n         LA    R5,26               Set count\n         L     R14,=A(ERRTX66+12)  Point at message\n*\nEOJULP   CLC   0(4,R3),ZEROS       Is the counter zero?\n         BE    EOJULB              Yes, bump to next\n         MVC   0(4,R14),=C'Uctr'   Build counter I.D.\n         LA    R15,=C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         LA    R15,0(R15,R4)\n         MVC   4(1,R14),0(R15)     Move counter I.D. in\n         MVC   5(12,R14),=X'402020206B2020206B202021'\n         L     R0,0(R3)            Get value\n         CVD   R0,DBL\n         EDMK  5(12,R14),DBL+3     Put number in\n         BNM   *+10                If negative\n         BCTR  R1,0                backup and\n         MVI   0(R1),C'-'          stick in a minus\n         LA    R14,31(,R14)        Bump in message line\n         C     R14,=A(ERRTX66+60)  Time to print it\n         BL    EOJULB              No, bump\n         STM   R0,R15,EOJUSAVE     Save regs a while\n         $ERR  UCTRL,0,TYPE=STAT,FLAG=NO,SAVE=YES\n         LM    R0,R15,EOJUSAVE     Restore regs\n         L     R14,=A(ERRTX66+12)  Point at message\n         MVC   0(60,R14),BLANKS    Clear line\n*\nEOJULB   LA    R3,4(,R3)           Next counter\n         LA    R4,1(,R4)           Next index number\n         BCT   R5,EOJULP           Loop till done\n         C     R14,=A(ERRTX66+12)  Something to print\n         BE    EOJSEEAB            No, skip\n         $ERR  UCTRL,0,TYPE=STAT,FLAG=NO\n*\nEOJSEEAB TM    PCTF4,ABENDING      Have we ABENDed?\n         BZ    EOJRETN             No, issue return code\n*\nEOJCMNAB L     R1,=A(ERRTX67)      Point at message\n         MVC   32(15,R1),=C'Abend code S...'\n         TM    PCTABEND+3,X'FF'    User abend?\n         BZ    EOJCMNSY            No, system\n         MVC   43(5,R1),=C'U....'  Alter message\n         LH    R2,PCTABEND+2       Get user abend number\n         CVD   R2,DBL              Format it\n         UNPK  43(5,R1),DBL+5(3)   .\n         OI    47(R1),C'0'         .\n         MVI   43(R1),C'U'         .\n         B     EOJCMNMS            Continue\n*\nEOJCMNSY UNPK  44(3,R1),PCTABEND+1(2) Format abend code\n         MVZ   44(3,R1),=XL3'00'   .\n         L     R15,=A(SNPTR)       .\n         TR    44(3,R1),0(R15)     .\n*\nEOJCMNMS $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         $ERR  EJRC,0,TYPE=STAT,FLAG=NO\n         $CALL ERPRINT             Go print diagnostics\n         STAE  0                   Remove STAE\n         SR    R0,R0               Then do ABEND all over again\n         L     R1,PCTABEND         Get original ABEND code\n         ABEND (1)                 ABEND\n*\nEOJRETN  TM    PCTF6,USERRC        Has user changed RCODE?\n         BO    EOJEXIT             Yes, just issue as a RC\n*\nEOJRC    L     R15,PCTRC           Pickup return code\n         CH    R15,=H'8'           How bad?\n         BL    EOJEXIT             Not very\n         MVC   PCTABEND,PCTRC      Swap RC into Abend code\n         B     EOJCMNAB            Continue\n*\nEOJEXIT  L     R1,=A(ERRTX67)      Get address of message\n         L     R2,PCTRC            Get return code\n         CVD   R2,DBL              Get ready to ED\n         MVC   36(6,R1),=X'402020202120'\n         ED    36(6,R1),DBL+5\n         $ERR  SPACE,0,TYPE=STAT,FLAG=NO\n         $ERR  EJRC,0,TYPE=STAT,FLAG=NO\n         $CALL ERPRINT             Go print diagnostics\n         L     R15,PCTRC           Terminate with return code\n         L     R13,4(R13)\n         RETURN (14,12),RC=(15)\n*\nEOJUSAVE DS    16F\n         $PEND\n         TITLE 'ERPRINT - Process the error Msg Queue'\n*---------------------------------------------------------------------+\n*        Process the error message queue onto SYSPRINT                |\n*        or if SYSPRINT not avail, then WTO or TPUT them.             |\n*---------------------------------------------------------------------+\n*\nERPRINT  $PROC\n         LA    R2,PCTERCHN         Get start of err msg chain\n         CLC   LINHDA3,=A(LINHD2A) Has normal hding been replaced?\n         BE    ERPPSPCC            No, then leave alone\n         CLI   TRLINE+31,C' '      Something in TRACE line\n         BE    ERPNTRAC            No\n         LA    R14,TRLINE-1        Yes, lets print it 1st\n         BAL   R15,LINEDO          .\n         MVC   TRLINE,BLANKS       Reset the TRACE line\n         MVC   TRPOS,=A(TRLINE+31) .\n*\nERPNTRAC MVC   LINHDA3,=A(LINHD4)  Swap page heads\n         ZAP   LINECT,=P'1'        Force next to page heads\n         B     ERPPBUMP            Go print msgs\n*\nERPPSPCC BAL   R14,LINPRINT\n         BAL   R14,LINPRINT\n*\nERPPBUMP ICM   R2,15,0(R2)         Get next message on chain\n         BZ    ERPPSTAT            Done, see if both chains done\n         TM    PCTF5,STATPRNT      Printing stats?\n         BO    ERPGSTR             Yes, skip formatting stmnt/word #\n         UNPK  LINE(5),4(3,R2)     Put STMNT # in print line\n         OI    LINE+4,X'F0'        Set good zone\n         UNPK  LINE+10(3),7(3,R2)  Put word number in line\n         OI    LINE+12,X'F0'       Set good zone\n         CLC   =C'09999     999',LINE If EOF type errors\n         BNE   *+10                then\n         MVC   LINE(13),BLANKS     Blank them also\n*\nERPGSTR  ICM   R1,15,12(R2)        Load text string address\n         BZ    ERPPTBL             None, do it the old way\n         BCTR  R1,0\n         IC    R14,12(R2)          Load length too\n         BCTR  R14,0               Less one\n         B     ERPPMVMS            And go move it\n*\nERPPTBL  IC    R1,11(R2)           Pickup err msg code\n         SLL   R1,2                X 4\n         L     R14,=A(ERRTBL-4)    Point at error table\n         AR    R1,R14              Bump to Adcon of this msg\n         L     R1,0(R1)            Point at message itself\n         IC    R14,0(R1)           Get length of message\n*\nERPPMVMS LA    R15,LINE+17         Set default move address\n         TM    PCTF5,STATPRNT      Doing stats msgs?\n         BNO   *+8                 No, R15 is O.K.\n         SH    R15,=H'11'          Yes, shift left a bit\n         EX    R14,*+4             Move message to line\n         MVC   0(0,R15),1(R1)      .\n         TM    PCTF2,DSYSPRT       Is SYSPRINT available?\n         BO    ERPPPRNT            Yes, go use it\n         CLI   10(R2),X'08'        What severity level is this\n         BNH   ERPPBUMP            Trivial, ignore WTO'ing it\n         L     R1,=A(ERRWTL+4)     Locate WTO MF=L data\n         MVC   11(100,R1),LINE+17  Move print line to WTO text\n         TM    PCTF1,TSOSTEP       Is this a TSO step?\n         BZ    ERPPDWTO            No, do a WTO\n         TPUT  (1),115             Yes, do a TPUT to the user\n         B     ERPPBUMP            And go back\n*\nERPPDWTO OC    11(100,R1),BLANKS   Uppercase it\n         SH    R1,=H'4'            Backup to ctl data\n         WTO   MF=(E,(1))          WTO it\n         B     ERPPBUMP            Then go back for next\n*\nERPPPRNT BAL   R14,LINPRINT        Then print it\n         B     ERPPBUMP            And go back\n*\nERPPSTAT TM    PCTF5,STATPRNT      Printing stats?\n         BO    ERPCPRT             Yes, we're done, go close SYSPRINT\n         OI    PCTF5,STATPRNT      Force exit the next time thru\n         LA    R2,PCTSTCHN         Get start of statistics chain\n         BAL   R14,LINPRINT        Yes, space a bit\n         BAL   R14,LINPRINT        .\n         B     ERPPBUMP            Continue\n*\nERPCPRT  ICM   R7,15,PCTPFCB       Now see if SYSPRINT is around\n         BZ    ERPPEX              No, return\n         TM    FCBDCB+48,X'10'     Is SYSPRINT even OPEN?\n         BZ    ERPPEX              No, return\n         LA    R2,FCBDCB           Point at DCB\n         CLOSE ((R2))              Close it\n         FREEPOOL (R2)             Free its buffers\n*\nERPPEX   $RET  0                   Return\n         $PEND\n         TITLE 'ERRSTORE - Save message for later printing'\n*---------------------------------------------------------------------+\n*        Add error msg to message queue                               |\n*        for later printing at end of compile                         |\n*---------------------------------------------------------------------+\n*\nERRSTORE $PROC\n         STC   R1,ERRCDSTF+1       Put error code in MVI for later\n         STC   R2,ERRLVSTF+1       Put level code in the other MVI\n         LA    R1,ERRCWORK         Point at work area\n         MVC   12(4,R1),ZEROS      Set text pointer to zero for now\n         MVC   4(3,R1),GETCTR1     Put STMNT # in error message\n         MVC   7(3,R1),GETCTR2     Put WORD # in\n         TM    PCTF4,NOFLAG        Don't flag this error?\n         BO    ERRCDSTF            Correct\n         LA    R14,TRLINE+17       Underline error word\n         LR    R15,R14             .\n         A     R14,GETPTR          .\n         S     R14,GETIMAGE        .\n         BCTR  R14,0               .\n         A     R15,GETWSTRT        .\n         S     R15,GETIMAGE        .\n         MVI   0(R15),C'#'         Flag location with error\n         LA    R15,1(,R15)         Bump\n         CR    R15,R14             Done?\n         BNH   *-10                No, loop\n         CLC   LINE+6(9),=C'* Error *' Already flagged as an error?\n         BE    ERRCDSTF            Yes, skip\n         MVC   LINE+6(9),=C'* Error *' Flag error\n         CLI   ERRLVSTF+1,X'00'    Just a warning message?\n         BNE   ERRCDSTF            No, error, leave it alone\n         MVC   LINE+6(9),=C'Warning >' Alter it to a warning\n*\nERRCDSTF MVI   11(R1),0            Put in error msg code\n         NI    PCTF4,255-NOFLAG    Clear NOFLAG\n*\nERRLVSTF MVI   10(R1),0            Put in severity level\n         CLC   PCTRC+3(1),10(R1)   Higher than last RC?\n         BH    ERRTSAVE            No, see if save needed\n         MVC   PCTRC+3(1),10(R1)   Yes, swap it\n*\nERRTSAVE LTR   R3,R3               Save requested?\n         BNZ   ERRCHNIT            No, go chain entry\n         EJECT\n*---------------------------------------------------------------------+\n*        Save the requested message in the literal pool               |\n*---------------------------------------------------------------------+\n         L     R14,=A(ERRTBL-4)    Get address of error table\n         IC    R2,11(R1)           Get err numb.\n         SLL   R2,2                X 4\n         AR    R14,R2              Bump into Adcon table\n         L     R14,0(R14)          Point at text string\n         IC    R3,0(R14)           Pickup length of string\n         LA    R3,1(,R3)           Make it actual for lit routine\n         LR    R4,R3               Its needed in both regs\n         LA    R2,1(R14)           Point at actual start of text\n         ST    R1,ERRSV1           Save a few regs\n         MVC   LITR,=F'1'          Set repeat to 1\n         $CALL LITSTUFF            Go save in LITPOOL\n         L     R1,ERRSV1           Restore regs\n         MVC   13(3,R1),LITA+1     Save abs. loc of text\n         MVC   12(1,R1),LITL+3     Save its length\n*\nERRCHNIT TM    PCTF1,STAT          What type of msg is this\n         BO    ERRLASTA            Statistics\n         LA    R2,PCTERCHN         Get start of err msg chain\n         B     ERRFEND             And start search\n*\nERRLASTA LA    R2,PCTSTCHN         Get start of stat chain\n         NI    PCTF1,255-STAT      Reset stat flag\n*\nERRFEND  CLC   0(4,R2),ZEROS       Look for end of chain\n         BE    ERRSTF              Got it, go add to chain\n         L     R2,0(R2)            Get addr of element\n         B     ERRFEND             Continue looking for end\n*\nERRSTF   ST    R2,ERRSV1           Save end for a while\n         LA    R3,16               Setup to save work area\n         LR    R4,R3\n         LA    R2,ERRCWORK\n         MVC   LITR,=F'1'          Set repeat to 1\n         $CALL LITSTUFF            Go put it in LITPOOL\n         L     R2,ERRSV1           Restore end address\n         L     R1,LITA             Get address where stored\n         ST    R1,0(R2)            Add new area to chain\n         SR    R2,R2               Set R2 to zero\n         ST    R2,0(R1)            And set new chain terminator\n*\nERRTTEST TM    PCTF1,TSOSTEP       Is this a TSO step?\n         BZ    ERRSEX              No, just return\n         L     R14,PCTIDCB         Get address of SYSIN DCB\n         TM    17(R14),X'4F'       Is SYSIN a termfile?\n         BNO   ERRSEX              No, just return\n         CLI   ERRCWORK+10,X'00'   An error\n         BE    ERRSEX              No\n         CLI   TRLINE,C' '         Anything waiting in TRACE line?\n         BE    ERRTMSK             No, just print normally\n         L     R7,PCTPFCB          Yes, point at SYSPRINT FCB\n         LA    R14,TRLINE-1        and print it 1st\n         BAL   R15,LINEDO          .\n         MVC   TRLINE,BLANKS       Reset the TRACE line\n         MVC   TRPOS,=A(TRLINE+31) .\n*\nERRTMSK  MVI   ERRTMSG,C' '                Blank error build area\n         MVC   ERRTMSG+1(131),ERRTMSG      .\n         UNPK  ERRTMSG(5),ERRCWORK+4(3)    Put STMNT # in print line\n         OI    ERRTMSG+4,X'F0'             Set good zone\n         UNPK  ERRTMSG+10(3),ERRCWORK+7(3) Put word number in errtmsg\n         OI    ERRTMSG+12,X'F0'            Set good zone\n         CLC   =C'09999     999',ERRTMSG   If EOF type errors\n         BNE   *+10                        Then\n         MVC   ERRTMSG(13),BLANKS          Clear it\n         L     R14,=A(ERRTBL-4)    Get address of error table\n         IC    R2,ERRCWORK+11      Get err numb.\n         SLL   R2,2                X 4\n         AR    R14,R2              Bump into Adcon table\n         L     R14,0(R14)          Point at text string\n         IC    R3,0(R14)           Pickup length of string\n         EX    R3,*+4              Move it\n         MVC   ERRTMSG+17(0),1(R14)\n         TPUT  ERRTMSG,L'ERRTMSG   TPUT it right now\n*\nERRSEX   $RET  0                   Exit\n         $PEND\n         TITLE 'FASTCOPY - High performance I/O routine'\n*---------------------------------------------------------------------+\n*        Test to see if fast copy is possible                         |\n*---------------------------------------------------------------------+\n*\nFASTCOPY $PROC\n         TM    PCTF8,PDSMODE       Never FASTCOPY in PDSMODE\n         BO    FASTRET0            .\n         TM    PCTF6,TRYFAST       Should FAST even be attempted?\n         BO    FASTTEST            Yes, let's see if we can do it\n*\nFASTRET0 NI    PCTF6,255-TRYFAST   Never do FASTTEST\n         $RET  0                   No, go back to normal route\n*\nFASTTEST L     R7,PCT2FCB          Get OUTPUT1 control area\n         MVC   DBL(1),FCBRECFM     Copy OUTPUT1 RECFM\n         MVC   DBL+2(2),FCBLRECL            And LRECL\n         L     R7,PCT1FCB          Get INPUT1 control area\n         CLC   FCBLRECL,DBL+2      Are UT1/UT2 LRECL's the same?\n         BNE   FASTRET0            Not same, ignore fast copy\n         MVC   DBL+1(1),FCBRECFM   Copy UT1's RECFM\n         NC    DBL(2),=X'C0C0'     Clear rubbish bits from RECFM's\n         CLC   DBL(1),DBL+1        Are UT1/UT2 RECFM's the same?\n         BNE   FASTRET0            No, ignore fast copy\n*---------------------------------------------------------------------+\n*        Now let's worry about unlike concatenations                  |\n*---------------------------------------------------------------------+\n         L     R2,WKTIOT           Start by getting TIOT address\n         LA    R2,24(,R2)          Step over header area\n*\nFASTTLOP CLC   4(8,R2),FCBDDNAM    Look for the INPUT1 entry\n         BE    FASTTFND            Got it\n         SR    R1,R1               Clear wkreg\n         IC    R1,0(R2)            Insert length of this TIOT entry\n         AR    R2,R1               Bump to next entry\n         CLC   0(4,R2),ZEROS       End of TIOT?\n         BE    FASTRET0            Never happens, lets pretend it didnt\n         B     FASTTLOP            Not end, loop back till found\n*\nFASTTFND SR    R1,R1               Clear wkreg again\n         IC    R1,0(R2)            Get length of entry\n         AR    R2,R1               Step to next entry\n         CLC   0(4,R2),ZEROS       End of TIOT\n         BE    FASTREAD            Yes, so no concats, do it fast way\n         CLC   4(8,R2),BLANKS      Blank? (concat)\n         BNE   FASTREAD            No, again use fast route\n         STM   R0,R15,SWASAVE      Save everything\n         LA    R1,12(R2)           -> JFCB token\n         L     R2,=A(GTSWABLK)     Get routine address\n         BALR  R14,R2              Go get block\n         LM    R0,R15,SWASAVE      Load everything\n         L     R3,=A(SWABLKA)      Get address of SWA block\n         LA    R3,4(,R3)           Step over header\n         MVC   JFCB,0(R3)          Copy JFCB\n         CLI   JFCRECFM,X'00'      Any RECFM in JFCB?\n         BE    FASTTDSD            No, see if its DASD\n         MVC   DBL+1(1),JFCRECFM   Compare RECFM's of UT2 and UT1\n         NC    DBL(2),=X'C0C0'     Clear rubbish bits\n         CLC   DBL(1),DBL+1        Same RECFM's\n         BNE   FASTRET0            No, dont use FASTREAD\n         CLC   JFCLRECL,ZEROS      Any LRECL in JFCB?\n         BE    FASTTDSD            No see if DASD\n         CLC   DBL+2(2),JFCLRECL   Same LRECL?\n         BNE   FASTRET0            No, use regular read\n         B     FASTTFND            Yes, this ones OK, see if any more\n*---------------------------------------------------------------------+\n*        JFCB didn't contain enough data to let us decide,            |\n*        see if DASD, and if so, get DSCB in to check.                |\n*---------------------------------------------------------------------+\n*\nFASTTDSD L     R3,16(R2)           Get UCB address\n         TM    18(R3),X'20'        Is it DASD?\n         BZ    FASTRET0            No, cant tell, must use slow way\n         OBTAIN OBTCMLST,EADSCB=OK Try to get DSCB\n         LTR   R15,R15             O.K. ?\n         BNZ   FASTRET0            No, dont care why, use slow route\n         L     R3,OBTCMLST+12\n         CLI   DS1RECFM-44(R3),X'00' Any RECFM?\n         BE    FASTRET0            No, must use slow route\n         MVC   DBL+1(1),DS1RECFM-44(R3) Compare RECFM's\n         NC    DBL(2),=X'C0C0'     Clear rubbish bits\n         CLC   DBL(1),DBL+1        Same RECFM's\n         BNE   FASTRET0            No, dont use FASTREAD\n         CLC   DS1LRECL-44(2,R3),ZEROS Any LRECL in DSCB?\n         BE    FASTRET0            No can't do\n         CLC   DBL+2(2),DS1LRECL-44(R3) Same LRECL?\n         BNE   FASTRET0            No, use regular read\n         B     FASTTFND            Yes, go see if more concat\n         EJECT\n*---------------------------------------------------------------------+\n*        This is the FASTCOPY main loop.  It has been optimized       |\n*        to use the minimum possible instructions / record.           |\n*                                                                     |\n*        Exit from this loop is only at end-of-file to label EODAD.   |\n*---------------------------------------------------------------------+\n*\nFASTREAD SR    R9,R9               Clear FCB counters\n         SR    R7,R7               .\n         LA    R6,1                Constant 1\n         OI    PCTF3,FAST          Say we're in fast route\n         NI    PCTF4,255-COMPILE   Say compile is done\n         L     R2,PCT1DCB          Get address of input DCB\n         L     R3,PCT2DCB          Get address of output DCB\n*\nFASTLOOP GET   (R2)                Get next record (GET LOCATE)\n*\nFASTCONC NOP   FASTRR              BR if re-read needed for concat\n         LR    R4,R1               Put record address in R4\n         AR    R7,R6               Count input records\n         LH    R5,DCBLRECL(R2)     Get LRECL of input record\n         STH   R5,DCBLRECL(R3)     Stuff LRECL in output DCB\n         PUT   (R3)                Get output buffer addr (PUT LOCATE)\n         LR    R14,R1              Set up for MVCL to output buffer\n         LR    R15,R5              .\n         MVCL  R14,R4              Move record to output buffer\n         AR    R9,R6               Count output records\n         B     FASTLOOP            Loop-de-loop\n*\nFASTRR   NI    FASTCONC+1,X'0F'    Turn off reread sw\n         RDJFCB ((R2))             Get the new JFCB for INPUT1\n         L     R5,PCT1FCB          Point at INPUT1 FCB\n         PUSH  USING               Get temp FCB addressability\n         DROP  R7                  .\n         USING FCBDSECT,R5         .\n         MVC   FCBJFCB,JFCB        Save the new JFCB\n         $CALL JFCNAME,FCBDSECT    Go build a full dsname\n         MVC   FCBORECF,FCBDCB+DCBRECFM And some other things\n         MVC   FCBRECFM,FCBORECF\n         TM    FCBRECFM,X'C0'      Undefined?\n         BNO   *+10                No\n         MVC   FCBDCB+DCBLRECL(2),FCBDCB+DCBBLKSI\n         MVC   FCBOBLK,FCBDCB+DCBBLKSI\n         MVC   FCBBLKSI,FCBOBLK\n         MVC   FCBOLREC,FCBDCB+DCBLRECL\n         MVC   FCBLRECL,FCBOLREC\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         SR    R7,R7               Clear input count\n         B     FASTLOOP            And go read next record\n         POP   USING               Restore normal addressability\n         $PEND\n         TITLE 'GETNEXT - Get next word to compile'\n*---------------------------------------------------------------------+\n*        Get next word for Compiler                                   |\n*---------------------------------------------------------------------+\n*\nGETNEXT  $PROC\n         $CALL GETWORD             Go get a word\n         CLC   WORDL,HEXFFS        End of file??\n         BE    GETNEOF             Yes, its end of source deck\n         CLC   WORDL,=X'7FFF'      Bad cont. at end of file?\n         BE    GETNMISS            Yes, tell of it\n         CLC   WORDL,=X'7FFE'      Still in comment mode?\n         BE    GETCMISS            Yes, tell of it\n         $CALL PARSE,WORDL         Go parse it for the caller\n         $CALL CKCOMENT            Go handle command comments\n         $RET  0                   Return now\n*\nGETNEOF  L     R8,=A(MAINCOMP)     Get compiler addressable\n         B     MAINENDC-MAINCOMP(R8) Return\n*\nGETNMISS L     R8,=A(MAINCOMP)     Get compiler addressable\n         B     MAINENDM-MAINCOMP(R8) Return\n*\nGETCMISS L     R8,=A(MAINCOMP)     Get compiler addressable\n         B     MAINCMS-MAINCOMP(R8) Return\n         $PEND\n         TITLE 'GETWORD - Read SYSIN'\n*---------------------------------------------------------------------+\n*        This routine reads SYSIN and returns a 'word'                |\n*        at a time to the main line. Continuations are                |\n*        handled by this routine, the caller need not concern         |\n*        themselves with them.                                        |\n*---------------------------------------------------------------------+\n*\nGETWORD  $PROC\n         TM    PCTF1,DFLTFLAG      Are we processing default SYSIN\n         BO    GETWEOST            Yes, ignore open type crap\n         TM    PCTF3,DEFREOF       A deferred EOF waiting?\n         BZ    GETWEOST            No\n         MVC   WORDL,HEXFFS        Yes\n*\nGETWEX0  $RET  0\n*\nGETWEOST TM    PCTF6,EOS           End of sentence?\n         BZ    GETWCDPT            No\n         MVC   WORDL,ZEROS         Yes, set lgth to zero to say E.O.S.\n         NI    PCTF6,255-EOS       Reset switch to normal value\n         B     GETWEX0             And return to caller\n*\nGETWTBG  $ERR  WTBIG,8,FLAG=NO     Kill current word\n*\nGETWCDPT MVC   WORDL,ZEROS         Reset word area\n         MVC   GETWDPT,=A(WORDTXT) Reset Ptr to start of area\n         SR    R15,R15\n         ICM   R3,15,GETSCLN       Get curr length left to scan\n         BNZ   GETWSCNI            Go scan if we have something\n*\nGETWNCRD TM    PCTF1,DFLTFLAG      Processing default SYSIN\n         BZ    GETWRCRD            No, get a real card\n         TM    PCTF4,PWAITING      Previous line waiting?\n         BZ    *+12                No\n         BAL   R14,LINPRINT        Yes, Print it\n         NI    PCTF4,255-PWAITING  and clear flag\n         ICM   R1,15,GETDPTRS      Get next pointer\n         BM    GETWEODP            If -ve, the  it was PARM\n         BZ    GETWEODT            If zero its pseudo EOF\n         MVC   GETDPTRS(16),GETDPTRS+4 Shift to next card image ptr\n         B     GETWPSTR            Skip over real GET\n*\nGETWEODP NI    PCTF1,255-DFLTFLAG  Remove default flag\n         MVC   GETDPTRS(16),GETDPTRS+4 Shift to next card image ptr\n         MVC   GETPTR(8),ZEROS     Clear pointers\n         B     REDOSLCT            Restart select process\n*\nGETWRCRD TM    PCTF4,PWAITING      Previous line waiting?\n         BZ    *+12                No\n         BAL   R14,LINPRINT        Yes, Print it\n         NI    PCTF4,255-PWAITING  and clear flag\n         L     R2,PCTIDCB          Point at SYSIN DCB\n         GET   (R2)                Get a card\n         LA    R1,0(R1)            Purify address\n         ST    R1,GETIMAGE         Save where it starts\n         ST    R1,GETWSTRT         .\n         L     R2,PCTIFCB          Point at SYSIN FCB\n         $INC  FCBCOUNT-FCBDSECT(R2) Count records\n         $INC  FCBCREC-FCBDSECT(R2)  .\n         OI    PCTF6,EOD           Set sw to say we got at least 1 card\n*\nGETWPSTR LA    R1,0(R1)            Purify it\n         ST    R1,GETPTR           Save its loc. as start scan addr\n         AP    GETCTR1,=P'1'       Count card\n         SP    GETCTR2,GETCTR2     Reset word number on card\n         UNPK  LINE(5),GETCTR1     Put stmnt number in line\n         OI    LINE+4,X'F0'        Make it pretty\n         MVC   LINE+17(80),0(R1)   Move to print line\n         OI    PCTF4,PWAITING      Remember to print it\n         MVC   GETSCLN,=F'71'      Set scan length\n         EJECT\n*---------------------------------------------------------------------+\n*        Main scanning loop                                           |\n*---------------------------------------------------------------------+\n*\nGETWSCNI LM    R3,R4,GETPTR        Get length to scan\n         L     R14,=A(TRTBLNB)     Point at TRT table\n         EX    R4,GETFTRT          Scan for 1st non-blank\n         BZ    GETWNCRD            No chars, go get another card\n         AP    GETCTR2,=P'1'       Count word on card\n         LA    R1,0(R1)            Purify address\n         ST    R1,GETWSTRT         Save start loc of word\n         LR    R2,R1               Put found loc in work reg\n         SR    R2,R3               Calc length of blanks\n         SR    R4,R2               Subt it from tot length of scan left\n         BNM   *+6                 Skip if positive\n         SR    R4,R4               Zero if its gone negative\n         ST    R4,GETSCLN          And store it\n         LA    R1,0(R1)            Purify it\n         ST    R1,GETPTR           Also alter start scan address\n*\nGETWSCAN LM    R3,R4,GETPTR        Load scan regs\n         SR    R2,R2               Clear R2 for BR table\n         L     R14,=A(TRTBLDLM)    Point at TRT table\n         EX    R4,GETFTRT          Look for delimiters\n         BZ    GETWNDLM            None? go handle this\n         B     *(R2)               Do BR table depending on char found\n         B     GETWBLNK            Blank\n         B     GETWPERD            Period\n         B     GETWQUOT            Quote\n*\nGETWNDLM L     R2,GETWDPT          Get next loc in word area\n         EX    R4,GETMV1           Move entire data to word area\n         EX    R4,GETOR2           Uppercase it\n         LA    R2,1(R2,R4)         Step over data moved\n         ST    R2,GETWDPT          And save as next loc\n         C     R2,=A(WORDTXT+270)  Gotten too big?\n         BH    GETWTBG             Yes, kill it\n         TM    PCTF4,PWAITING      Previous line waiting?\n         BZ    *+12                No\n         BAL   R14,LINPRINT        Yes, Print it\n         NI    PCTF4,255-PWAITING  and clear flag\n         L     R2,PCTIDCB          Get address of SYSIN DCB\n         GET   (R2)                Go get another card\n         LA    R1,0(R1)            Purify address\n         ST    R1,GETIMAGE         Save where it starts\n         ST    R1,GETWSTRT         .\n         L     R2,PCTIFCB          Point at SYSIN FCB\n         $INC  FCBCOUNT-FCBDSECT(R2) Count records\n         $INC  FCBCREC-FCBDSECT(R2)  .\n         LA    R1,0(R1)            Purify it\n         ST    R1,GETPTR           Reset pointer\n         AP    GETCTR1,=P'1'       Count it\n         SP    GETCTR2,GETCTR2     Reset word number\n         UNPK  LINE(5),GETCTR1     Put STMNT # in line\n         OI    LINE+4,X'F0'        Set good zone\n         MVC   LINE+17(80),0(R1)   Put in print line\n         OI    PCTF4,PWAITING      Remember\n         MVC   GETSCLN,=F'70'      Reset scan length\n         B     GETWSCAN            Go resume scan\n*\nGETWBLNK LA    R1,0(R1)            Purify it\n         ST    R1,GETPTR           Save for next entry\n         SR    R1,R3               Calc length of word found\n         SR    R4,R1               Deduct from remaining length\n         BNM   *+6                 Skip if positive\n         SR    R4,R4               Zero if its gone negative\n         ST    R4,GETSCLN          Save new length\n         LTR   R1,R1               Is length zero?\n         BZ    GETWDEX             Yes, exit now\n         BCTR  R1,0                Minus one\n         L     R2,GETWDPT          Get next loc in word area\n         EX    R1,GETMV1           Move found word to word area\n         EX    R1,GETOR2           Uppercase it\n         LA    R2,1(R2,R1)         Step over moved word\n         ST    R2,GETWDPT          And save it\n         B     GETWDEX             And exit\n*\nGETWPERD LA    R1,1(,R1)           Step over period\n         ST    R1,GETPTR           And save it\n         SR    R1,R3               Calc length\n         SR    R4,R1               Subt from tot length\n         BNM   *+6                 Skip if positive\n         SR    R4,R4               Zero if its gone negative\n         ST    R4,GETSCLN          Save new length\n         SH    R1,=H'2'            Adjust length\n         BM    GETWTMPY            If single per. see if word empty\n         L     R2,GETWDPT          Get next loc in word area\n         EX    R1,GETMV1           Move the word\n         EX    R1,GETOR2           Uppercase it\n         LA    R2,1(R2,R1)         Step over the word\n         ST    R2,GETWDPT          Save new loc\n         OI    PCTF6,EOS           Set end of sent. switch\n         B     GETWDEX             And exit\n*\nGETWTMPY CLC   GETWDPT,=A(WORDTXT) Anything in word?\n         BE    GETWEOST+8          No, leave now\n         OI    PCTF6,EOS\n         B     GETWDEX             And leave with that word\n*---------------------------------------------------------------------+\n*        Handle quoted words                                          |\n*---------------------------------------------------------------------+\n*\nGETWQUOT SR    R1,R3               Calc length\n         SR    R4,R1               Subt from length\n         LTR   R1,R1               Any data before the quote?\n         BZ    *+8                 No, skip\n         EX    R1,GETOR1           Uppercase stuff before quotes\n         LA    R3,1(R3,R1)         Create new temp start scan addr\n*\nGETWSQUT L     R14,=A(TRTBLQ)      Point at TRT table\n         EX    R4,GETFTRT          Try to find next quote\n         BZ    GETWNO2Q            None on this card\n         CLI   1(R1),C''''         Is the next also a quote\n         BE    GETWDBLQ            Yes, go handle double quotes\n         L     R3,GETPTR           Get start of original scan\n         LR    R14,R1              Put end addr in work reg\n         LA    R14,1(,R14)         Adjust it\n         ST    R14,GETPTR          And store it\n         SR    R1,R3               Calc length up to end quote\n         L     R4,GETSCLN          Get original length\n         SR    R4,R1               Deduct it from total length\n         BCTR  R4,0                Another\n         L     R2,GETWDPT          Get next loc in word area\n         EX    R1,GETMV1           Move up to end quote to word area\n         LA    R2,1(R2,R1)         Step over\n         ST    R2,GETWDPT          And save it for next time\n         ST    R4,GETSCLN          Save length also\n         B     GETWSCAN\n*\nGETWDBLQ L     R3,GETPTR           Get original start scan addr\n         LR    R14,R1              Put end loc in work reg\n         LA    R14,2(,R14)         Bump over quotes\n         ST    R14,GETPTR          Save for resume scan\n         SR    R1,R3               Calc length\n         SR    R4,R1               Reduce amount remaining\n         BCTR  R4,0                One more for EX\n         L     R2,GETWDPT          Get next loc in word area\n         EX    R1,GETMV1           Move to word area\n         LA    R2,1(R2,R1)         Step over\n         ST    R2,GETWDPT          And save it\n         ST    R4,GETSCLN          Save length\n         L     R3,GETPTR           Get back start scan addr\n         B     GETWSQUT            And resume scan\n*\nGETWNO2Q L     R2,GETWDPT          Get next loc in word area\n         LM    R3,R4,GETPTR        Get orig scan params\n         EX    R4,GETMV1           And use them to do move all\n         LA    R2,1(R2,R4)         Step over\n         ST    R2,GETWDPT          And save it\n         C     R2,=A(WORDTXT+270)  Gotten too big?\n         BH    GETWTBG             Yes, kill it\n         TM    PCTF4,PWAITING      Previous line waiting?\n         BZ    *+12                No\n         BAL   R14,LINPRINT        Yes, Print it\n         NI    PCTF4,255-PWAITING  and clear flag\n         L     R2,PCTIDCB          Get address of SYSIN DCB\n         GET   (R2)                Get another card\n         LA    R1,0(R1)            Purify address\n         ST    R1,GETIMAGE         Save where it starts\n         ST    R1,GETWSTRT         Save where it starts\n         L     R2,PCTIFCB          Point at SYSIN FCB\n         $INC  FCBCOUNT-FCBDSECT(R2) Count records\n         $INC  FCBCREC-FCBDSECT(R2)  .\n         LA    R1,0(R1)            Purify it\n         ST    R1,GETPTR           Save cards address\n         AP    GETCTR1,=P'1'       Count card\n         SP    GETCTR2,GETCTR2     Reset word number\n         UNPK  LINE(5),GETCTR1     Put STMNT # in line\n         OI    LINE+4,X'F0'        Pretty it up\n         MVC   LINE+17(80),0(R1)   Put in line\n         OI    PCTF4,PWAITING      And print it\n         MVC   GETSCLN,=F'70'      Reset length\n         LM    R3,R4,GETPTR        Load scan regs\n         B     GETWSQUT            Go continue scan for 2nd quote\n*\nGETWDEX  L     R2,GETWDPT          Get next loc in word area\n         LA    R3,WORDTXT          Get start address\n         SR    R2,R3               Calc length of word\n         STH   R2,WORDL            Put length in word prefix\n         B     GETWEX0             And exit\n         EJECT\n*---------------------------------------------------------------------+\n*        End-of-file on SYSIN                                         |\n*---------------------------------------------------------------------+\n*\nGETWEODT TM    PCTF6,EOD           If input occurred, keep going\n         BO    GETWEODX            .\n         OI    PCTF6,EOD           Set SW back\n         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB\n         BZ    INICHOOS            Skip if none\n         TM    48(R2),X'10'        OPEN?\n         BZ    INICHOOS            No, skip CLOSE then\n         CLOSE ((R2))              Close the file\n         FREEPOOL (R2)             Free its buffers\n         B     INICHOOS            Go choose default option\n*\nGETWEODX CLC   GETWDPT,=A(WORDTXT) Anything in word??\n         BE    GETWGEOD            No, clean EOD occurred\n         MVC   WORDL,=X'7FFF'      Yes, missing continuation\n         B     GETWCLOS\n*\nGETWGEOD TM    PCTF1,ACTIVE        Is a command still active?\n         BZ    GETWEOOK            No, then all's well\n         OI    PCTF3,DEFREOF       Set deferred end of file\n         MVC   WORDL,ZEROS\n         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB\n         BZ    GETWEX0             Skip if none\n         L     R2,PCTIDCB          Get address of SYSIN DCB\n         TM    48(R2),X'10'        OPEN?\n         BZ    GETWEX0             No, skip CLOSE then\n         CLOSE ((R2))\n         FREEPOOL (R2)             Free its buffers\n         B     GETWEX0\n*\nGETWEOOK CP    COMNTCTL,=P'0'      Inside a comment?\n         BE    GETSTEO             No, continue\n         MVC   WORDL,=X'7FFE'      Yes, flag it\n         B     GETWCLOS            now continue\n*\nGETSTEO  MVC   WORDL,HEXFFS        Flag as end of file\n*\nGETWCLOS TM    PCTF1,DFLTFLAG      Default processing?\n         BO    GETWEX0\n         ICM   R2,15,PCTIDCB       Get address of SYSIN DCB\n         BZ    GETWEX0             Skip if none\n         TM    48(R2),X'10'        OPEN?\n         BZ    GETWEX0             No, skip CLOSE then\n         CLOSE ((R2))              Close input\n         FREEPOOL (R2)             Free its buffers\n         B     GETWEX0             And exit\n*\nGETWEOFX MVC   WORDL,HEXFFS\n         B     GETWEX0\n         $PEND\n         TITLE 'GOBACK - Command processor'\n*---------------------------------------------------------------------+\n*        G O B A C K    C o m m a n d    P r o c e s s o r            |\n*---------------------------------------------------------------------+\n*\nGOBACK   $PROC\n         USING KWDSECT,R14\n         $CALL DBGADD              Go add DEBUG code\n         $ADD  4,GOBKBAL1          Put branch code into program\n         B     EXITGEOS            Go to common command exit\n*\n*---------------------------------------------------------------------+\n*        GOSUB routine work areas                                     |\n*---------------------------------------------------------------------+\n*\nGOBKBAL1 BAL   R14,SUBRETN         Off to SUBRETN support routine\n         DROP  R14\n         $PEND\n         TITLE 'GOSUB - Command processor'\n*---------------------------------------------------------------------+\n*        G O S U B   C o m m a n d    P r o c e s s o r               |\n*---------------------------------------------------------------------+\n*\nGOSUB    $PROC\n         USING KWDSECT,R14\n         $CALL DBGADD              Go add DEBUG code\n*\nGOSBGWRD OI    PCTF4,LABLLOOK      Say we're looking for a LABEL:\n         $CALL GETNEXT             Go get next word\n         TM    WFLAG1,WPREF+WTRLR  Eliminate invalid sub-operands\n         BNZ   BADOPTYP            .\n         TM    WFLAG1,WWRD1        Better have this one\n         BZ    GOSBNOPS            Nope, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?\n         BZ    GOSBBLD             Nope, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWNOISE        Eliminate 'noise' words\n         BO    GOSBGWRD            .\n         B     GOSBBLD             No, put it in code\n*\nGOSBNOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue\n*\nGOSBBLD  TM    WRD1F2,OPRPTR       If operand is PTR type, fudge 1st 8\n         BNO   GOSBSTUF            Yes, noise, get next word\n         MVC   WRD1L,=H'8'         Set length to max\n         L     R15,WRD1ADDR        Get address of operand\n         MVC   WRD1TXT,0(R15)      Copy leading characters of string\n*\nGOSBSTUF $ADD  12,GOSBBAL1         Put branch code into program\n         LA    R1,8(,R1)           -> Adcon to be resolved later\n         $CALL LBLOGEN,WRD1L,(R1)  Go add to unresolved table\n         B     EXITGEOS            Go to common command exit\n*\n*---------------------------------------------------------------------+\n*        GOSUB routine work areas                                     |\n*---------------------------------------------------------------------+\n*\nGOSBBAL1 BAL   R14,SUBSAVE         Off to SUBSAVE support routine\nGOSBBAL2 BAL   R14,COMPGOTO        Off to GOTO support routine\nGOSBADCN DC    4X'00'              Adcon to be stuffed\n         DROP  R14\n         $PEND\n         TITLE 'GOTO - Command processor'\n*---------------------------------------------------------------------+\n*        G O T O   C o m m a n d   P r o c e s s o r                  |\n*---------------------------------------------------------------------+\n*\nGOTO     $PROC\n         USING KWDSECT,R14\n         $CALL DBGADD              Go add DEBUG code\n*\nGOTOGWRD OI    PCTF4,LABLLOOK      Say we're looking for a LABEL:\n         $CALL GETNEXT             Go get next word\n         TM    WFLAG1,WPREF+WTRLR  Eliminate invalid sub-operands\n         BNZ   BADOPTYP            .\n         TM    WFLAG1,WWRD1        Better have this one\n         BZ    GOTONOPS            Nope, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?\n         BZ    GOTOBLD             Nope, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWNOISE        Eliminate 'noise' words\n         BO    GOTOGWRD            .\n         B     GOTOBLD             No, put it in code\n*\nGOTONOPS $ERR  NOOPS,8,GO=MAINGOK  Yes, kill it and continue\n*\nGOTOBLD  TM    WRD1F2,OPRPTR       If operand is PTR type, fudge 1st 8\n         BNO   GOTOSTUF            Yes, noise, get next word\n         MVC   WRD1L,=H'8'         Set length to max\n         L     R15,WRD1ADDR        Get address of operand\n         MVC   WRD1TXT,0(R15)      Copy leading characters of string\n*\nGOTOSTUF $ADD  8,GOGMBAL           Put branch code into program\n         LA    R1,4(,R1)           -> Adcon to be resolved later\n         $CALL LBLOGEN,WRD1L,(R1)  Go add to unresolved table\n         B     EXITGEOS            Go to common command exit\n*\n*---------------------------------------------------------------------+\n*        GOTO routine work areas                                      |\n*---------------------------------------------------------------------+\n*\nGOGMBAL  BAL   R14,COMPGOTO        Off to GOTO support routine\nGOGMADCN DC    4X'00'              Adcon to be stuffed\n         DROP  R14\n         $PEND\n         TITLE 'IF - Command processor'\n*---------------------------------------------------------------------+\n*        I F   C o m m a n d   P r o c e s s o r                      |\n*---------------------------------------------------------------------+\n*\nIF       $PROC\n         USING KWDSECT,R14\n         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address\n         OI    PCTF1,ACTIVE        Show command active\n         MVC   OREGM,ZEROS         Clear OREGM area\n         MVI   PCTIOFLG,X'00'      Clear IO flags\n         MVI   PCTIOFL2,X'00'      .\n         NI    PCTF5,255-IFAOPG-IFBOPG-IFRELG Clear operand flags\n         NI    PCTF3,255-OPKWLEN   .\n         CLC   IFTRUCH,ZEROS       TRUE/AND tables gotten yet?\n         BNE   IFADBG              Yes, keep going\n         GETMAIN R,LV=8192         No, get one then\n         ST    R1,IFTRUCH          Save 'TRUE' table address\n         MVC   0(4,R1),HEXFFS      Set delimiter\n         AH    R1,=H'4096'         Bump to reach 'AND' table\n         ST    R1,IFANDCH          Save 'AND' table address\n         MVC   0(4,R1),HEXFFS      Set delimiter\n         AH    R1,=H'4096'         Bump to reach 'AND' table\n         ST    R1,IFTAEND          Save end address\n*\nIFADBG   $CALL DBGADD              Go add DEBUG code\n         $ADD  8,IFGMBAL1          Create code to point at next sent.\n         LA    R1,4(,R1)           Point at next sent Adcon\n         $CALL PUSHIF              Then save its address\n         OI    PCTF4,IFNXSENT      Flag to complete it\n*---------------------------------------------------------------------+\n*        Get the operands for an IF command                           |\n*---------------------------------------------------------------------+\n*\n         $CALL GETNEXT             Go get the A-operand\n         MVI   WFLAG2,WAOP+WPREFOK+WTRLROK+WIPDEF+WLITOK Set bld flags\n         MVI   OREGALEN,X'00'      Zero A-operand length\n         $CALL OPGEN               Go gen code for the A-operand\n         B     BADOPTYP            +0 Invalid, kill it\n         OI    PCTF5,IFAOPG        +4 Code genn'ed O.K., remember that\n         CLI   OPGBASE,X'0A'       OBUFF operand?\n         BNE   IFNOCPG             No\n         $ADD  4,DCOPM010          Yes, stuff in deferred copy\n         OI    PCTF1,DCOPYGEN      Remember we did it\n*\nIFNOCPG  TM    PCTIOFLG,IOFLOATA   Is it a floating A-operand?\n         BZ    IFNEXTC             No, continue\n         CLI   OREGALEN,X'00'      An A length?\n         BNE   BADLGTH             Yes, sorry\n*\nIFNEXTC  $CALL GETNEXT             Get type of test to do\n*\nIFRELOOK TM    WFLAG1,WWRD1        Got one?\n         BZ    IFBIFT              No, error\n         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?\n         BNZ   IFBIFT              Yes, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?\n         BNO   IFBIFT              No, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWIFREL        Valid for IF relation test?\n         BZ    IFBIFT              No, see if implied\n*\nIFSAVED1 MVC   IFD1,KWD1           Save the answer word\n         OI    PCTF5,IFRELG        Remember we got the test operand\n         MVC   OREGBLEN,ZEROS      Zero B-operand status\n         NI    PCTIOFLG,255-IOFLOATB\n         $CALL GETNEXT             Get the B-operand\n*\nIFSEEBOP MVI   WFLAG2,WBOP+WPREFOK+WTRLROK+WIPDEF+WLITOK\n         MVC   OREGBLEN,ZEROS      Zero B-operand length\n         $CALL OPGEN               Go gen code for the B-operand\n         B     BADOPTYP            +0 Invalid, kill it\n         CLI   OPGBASE,X'0A'       +4 OBUFF operand?\n         BNE   IFNOBCP             No\n         TM    PCTF1,DCOPYGEN      Already done?\n         BO    IFNOBCP             Yes, skip\n         $ADD  4,DCOPM010          Yes, stuff in deferred copy\n         OI    PCTF1,DCOPYGEN      Remember we did it\n*\nIFNOBCP  CLI   IFD1+1,X'02'        O.K. Is this a MASK type\n         BNE   IFDUN1              No, see if we can try Imply\n         TM    WRD1F2,OPRLIT       Yes, B-op must be a literal\n         BZ    IFIMASK             It isn't, kill it\n         OI    PCTIOFLG,IOMASK     Set flag then for CONTAINS\n         L     R15,LITL            Get length of literal\n         L     R14,LITA            Get it's address\n         TM    PCTIOFLG,IOFLOATA   Floating A-op?\n         BZ    *+12\n         CLI   0(R14),C'?'         Leading ?\n         BE    IFIMASK1            Yes, kill it\n         CLI   0(R14),C'?'         Mask character?\n         BNE   *+8                 No\n         MVI   0(R14),X'00'        Make null\n         LA    R14,1(,R14)         Bump\n         BCT   R15,*-16            Loop\n*\nIFDUN1   TM    PCTF5,IFBOPG        Done a complete B-operand set?\n         BZ    IFGEN1              No, go generate something Now\n*\nIFIMPLY  $CALL GETNEXT             Get next word\n         OI    PCTF4,IFDONEW       Say we've got the next word\n         TM    WFLAG1,WWRD1        Got one?\n         BZ    IFGEN1              No, -> IFGEN1, error found later\n         TM    WFLAG1,WPREF+WWRD2+WTRLR Any bad sub-fields?\n         BNZ   IFGEN1              Yes,-> IFGEN1, error found later\n         TM    WRD1F2,OPRKW+OPRKWV Is it a valid KW?\n         BNO   IFGEN1              No, -> IFGEN1, error found later\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWIFREL        Valid for IF relation test?\n         BZ    IFGEN1              No, -> IFGEN1, error found later\n         $ADD  2,OPGSWAP1          Swap B-reg to A-reg\n         NI    PCTF4,255-IFDONEW   Clear word gotten flag\n         MVC   OREGALEN,OREGBLEN+1 Swap B values to A and zero B\n         MVC   OREGBLEN,ZEROS      .\n         NI    PCTIOFLG,255-IOFLOATA\n         TM    PCTIOFLG,IOFLOATB   .\n         BZ    *+8                 .\n         OI    PCTIOFLG,IOFLOATA   .\n         NI    PCTIOFLG,255-IOFLOATB\n         NI    PCTIOFLG,255-IONOAADJ\n         TM    PCTIOFLG,IONOBADJ   .\n         BZ    *+8                 .\n         OI    PCTIOFLG,IONOAADJ   .\n         NI    PCTIOFLG,255-IONOBADJ\n         NI    PCTF5,255-IFRELG    Forget we had a rel. test\n         B     IFRELOOK            Done, continue with relation\n*\nIFBIFT   TM    PCTF5,IFAOPG+IFRELG Got A-op and test type?\n         BNO   IFBIF               No, sorry\n         B     IFSEEBOP            Yes, see if valid B-op\n         EJECT\n*---------------------------------------------------------------------+\n*        Start generating the code for the IF test type               |\n*---------------------------------------------------------------------+\n*\nIFGEN1   $CALL DBGADD              Add some more DEBUG code\n         OI    PCTF5,IFBOPG        Remember we've Genn'd something\n         TM    PCTIOFLG,IOFLOATA+IOFLOATB Both floating?\n         BO    IFFLOATR            Yes, error\n         CLI   IFD1+1,X'01'        A TM type of test?\n         BE    IFGENTM             Yes, go do it\n         SR    R1,R1               Clear R1\n         ICM   R1,1,OREGALEN       Get A-operand length\n         BZ    IFGENSB             None, See if B\n         CLC   OREGBLEN,ZEROS      A B-length?\n         BNE   IFGABSM             Yes, make sure they're the same\n         MVC   OREGBLEN+1(1),OREGALEN Swap to B-length\n         MVI   OREGALEN,X'00'      Zero A-length\n         B     IFGENIO             Continue\n*\nIFGABSM  CH    R1,OREGBLEN         Same as B-operand length?\n         BNE   BADLGTH             No, error\n         B     IFGENIO             Yes, continue\n*\nIFGENSB  TM    PCTF3,OPKWLEN       A KW length field?\n         BO    IFGENIO             Yes, who cares about OREGBLEN\n         CLC   OREGBLEN,ZEROS      Better be one here!\n         BE    BADLGTH             No, terrible\n*\nIFGENIO  MVC   ORLMVID,PCTIOFLG    Jam in IO flag byte\n         TM    PCTF3,OPKWLEN       A KW length operand?\n         BZ    IFGENION            No, do normal length load\n         $ADD  4,ORLLCOD           Yes, Add code for it\n         $ADD  4,ORLMVI            .\n         TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating?\n         BNZ   IFCNTAIN            Yes, go do it\n         $ADD  2,ORLLCODB          Add BCTR now\n         B     IFGENMTS            Skip\n*\nIFGENION $ADD  ORLM999-ORLCODE,ORLCODE Stuff in OREG code\n         TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating?\n         BNZ   IFCNTAIN            Yes, go do it\n         MVI   OREGALEN-ORLCODE(R1),X'00' Clear any A-operand length\n         MVI   OREGFLAG-ORLCODE(R1),X'00' and Flag byte\n         SR    R2,R2               Clear a reg\n         ICM   R2,3,OREGBLEN-ORLCODE(R1) Get the length\n         CH    R2,=H'256'          Validate length\n         BH    BADLGTH             Sorry, too big\n         BCTR  R2,0                -1 for EX\n         STCM  R2,3,OREGBLEN-ORLCODE(R1) Put it back\n*\nIFGENMTS CLI   IFD1+1,X'02'        A MASK type?\n         BE    IFGMASK             Yes, go do it\n         TM    PCTIOFLG,IOPACKED   A packed compare?\n         BO    IFGEN1CP            Yes, gen that type then\n         TM    PCTIOFL2,IOUCTRX    A UCTRx compare?\n         BO    IFGEN1CR            Yes, gen that type then\n*---------------------------------------------------------------------+\n*        Generate code for a 'normal' compare                         |\n*---------------------------------------------------------------------+\n         $ADD  4,IFGMCLC           No, insert a EX of CLC then\n         B     IFGENTST            and go insert test code\n*---------------------------------------------------------------------+\n*        Generate code for a 'packed' compare                         |\n*---------------------------------------------------------------------+\n*\nIFGEN1CP LH    R15,OREGBLEN        Get the length\n         BCTR  R15,0               -1 for EX\n         SLL   R15,4               Shift left 4 bits\n         LH    R14,OREGBLEN        Get length again\n         BCTR  R14,0               -1 for EX\n         OR    R15,R14             OR both 4 bit lengths together\n         STC   R15,OREGBLEN+1-ORLCODE(R1) Modify in the compile area\n         $ADD  4,IFGMCP            Insert a EX of CP then\n         B     IFGENTST            and go insert test code\n*---------------------------------------------------------------------+\n*        Generate code for a 'fullword' compare                       |\n*---------------------------------------------------------------------+\n*\nIFGEN1CR $ADD  12,IFGMLR0          Insert the load and compare code\n         B     IFGENTST            and go insert test code\n         EJECT\n*---------------------------------------------------------------------+\n*        Generate code for the IF ... ON/OFF/MIX ... tests            |\n*---------------------------------------------------------------------+\n*\nIFGENTM  TM    PCTIOFLG,IOFLOATA+IOFLOATB Floating operands?\n         BNZ   IFBFLOAT            Yes, kill it\n         $ADD  8,IFGMTM1           Add code for TM type test\n         B     IFGENTST            Go add code to test result\n*---------------------------------------------------------------------+\n*        Generate code for the IF ... MASK ...                        |\n*---------------------------------------------------------------------+\n*\nIFGMASK  $ADD  16,IFGMMSK1         Add code for MASK type test\n         B     IFGENTST            Go add code to test result\n*---------------------------------------------------------------------+\n*        Generate code for the IF 0 ..... (Contains) logic            |\n*---------------------------------------------------------------------+\n*\nIFCNTAIN CLI   IFD1,X'80'          Must be = or \u00bc= for CONTAINS\n         BE    *+12                = is O.K., continue\n         CLI   IFD1,X'70'          \u00bc= ?\n         BNE   IFBFLOAT            No, sorry\n         $ADD  4,IFGMCNT1          Add code to goto CONTAIN\n         B     IFGENTST            Go add code to test result\n*---------------------------------------------------------------------+\n*        Generate code to test the result of the compare              |\n*---------------------------------------------------------------------+\n*\nIFGENTST $ADD  IFGM999-IFGMBAL2,IFGMBAL2 Add code to test result\n         LA    R1,IFGMTAAD-IFGMBAL2(,R1) Point at true/and Adcon\n         ST    R1,IFTADSV          And save it\n         LA    R1,IFGMTEST-IFGMTAAD(,R1) Point at BCR inst\n         ST    R1,IFBCRSV          And save it\n         OC    1(1,R1),IFD1        Set correct mask bits\n         EJECT\n*---------------------------------------------------------------------+\n*        Code generation complete, see what to do next                |\n*---------------------------------------------------------------------+\n*\nIFGDONE  TM    PCTF4,IFDONEW       Word 'gotten' already?\n         BO    IFGDONE2            Yes, don't do it again then\n         $CALL GETNEXT             Go get another word\n*\nIFGDONE2 NI    PCTF4,255-IFDONEW   Reset the flag\n         TM    WFLAG1,WPREF+WWRD2+WTRLR Eliminate invalid sub-operands\n         BNZ   IFBREL              .\n         TM    WFLAG1,WWRD1        Better have this one\n         BZ    IFBREL              Nope, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?\n         BZ    IFBREL              Nope, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWNOISE        Eliminate 'noise' words\n         BO    IFGDONE             .\n         TM    KWF1,KWIFTRU        Valid in context?\n         BZ    IFBREL              No, sorry\n         L     R2,KWD2             Get addr of routine\n         BR    R2                  And go to it\n*\nIFOR     BAL   R14,IFAATRU         Go add to TRUE chain\n         $ADD  0,*                 Get current inst counter\n         BAL   R14,IFANDCLR        Make AND's point here\n         NI    PCTF3,255-OPKWLEN   .\n         B     IFNEXTC             And loop back\n*\nIFAND    BAL   R14,IFAAAND         Go add to AND chain\n         L     R14,IFBCRSV         Get address of last BCR inst\n         XC    1(1,R14),FOXZERO    Reverse mask bits\n         NI    PCTF3,255-OPKWLEN   .\n         B     IFNEXTC             And loop back\n*\nIFDO     MVC   IFEXR,=A(MAINGEOS-8) Set exit address\n         NI    PCTF4,255-IFNXSENT  Clear complete next sentence\n         B     IFCMDCM\n*\nIFGOTO   MVC   IFEXR,=A(GOTO)      Set exit address\n         B     IFCMDCM\n*\nIFALTER  MVC   IFEXR,=A(ALTER)     Set exit address\n         B     IFCMDCM\n*\nIFCLOSE  MVC   IFEXR,=A(CLOSE)     Set exit address\n         B     IFCMDCM\n*\nIFDEBUG  MVC   IFEXR,=A(DEBUG)     Set exit address\n         B     IFCMDCM\n*\nIFGNEXT  MVC   IFEXR,=A(NEXTREC)   Set exit address\n         B     IFCMDCM\n*\nIFGOSUB  MVC   IFEXR,=A(GOSUB)     Set exit address\n         B     IFCMDCM\n*\nIFGOBACK MVC   IFEXR,=A(GOBACK)    Set exit address\n         B     IFCMDCM\n*\nIFSELECT MVC   IFEXR,=A(SELECT)    Set exit address\n         EJECT\n*---------------------------------------------------------------------+\n*        Generate close off code for the IF                           |\n*---------------------------------------------------------------------+\n*\nIFCMDCM  BAL   R14,IFAATRU         Add to true chain\n         $ADD  0,*                 Get currect inst counter\n         BAL   R14,IFANDCLR        Point all AND's here\n         $ADD  6,IFGMLDNS          Stuff in GOTO next sentence\n         $ADD  0,*                 Get current inst counter\n         BAL   R14,IFTRUCLR        Point all TRUE's here\n*\nIFCMDEX  L     R8,IFEXR            Go to continue address\n         B     8(R8)               Enter it\n         EJECT\n*---------------------------------------------------------------------+\n*        Stack routines for TRUE/AND address chains                   |\n*---------------------------------------------------------------------+\n*\nIFAAAND  L     R1,IFANDCH          Get start of 'AND' table\n         L     R0,IFTAEND          Get end address of table\n         SH    R0,=H'4'            - 1\n         B     IFAATL              And enter common code\n*\nIFAATRU  L     R1,IFTRUCH          Get start of 'TRUE' table\n         L     R0,IFANDCH          Get end address of table\n         SH    R0,=H'4'            - 1\n*\nIFAATL   CLC   0(4,R1),=4X'FF'     At end yet\n         BE    IFAATF              Yes\n         LA    R1,4(,R1)           No, bump\n         B     IFAATL              And loop back\n*\nIFAATF   CR    R1,R0               Check for overflow\n         BNL   IFTCMPLX            Too complex\n         MVC   0(4,R1),IFTADSV     Save address\n         MVC   4(4,R1),=4X'FF'     Set new end marker\n         BR    R14\n*---------------------------------------------------------------------+\n*        Process TRUE/AND address stacks                              |\n*---------------------------------------------------------------------+\n*\nIFTRUCLR L     R2,IFTRUCH          Get address of tbl\n*\nIFTRULP  CLC   0(4,R2),=4X'FF'     End yet?\n         BE    IFTRURST            Yes, leave\n         L     R3,0(R2)            Point at Adcon loc\n         ST    R1,0(R3)            Stuff it\n         LA    R2,4(,R2)           Bump to next\n         B     IFTRULP             And loop\n*\nIFTRURST L     R2,IFTRUCH          Get start of tbl\n         MVC   0(4,R2),=4X'FF'     Reset to null\n         BR    R14\n*\nIFANDCLR L     R2,IFANDCH          Get address of tbl\n*\nIFANDLP  CLC   0(4,R2),=4X'FF'     End yet?\n         BE    IFANDRST            Yes, leave\n         L     R3,0(R2)            Point at Adcon loc\n         ST    R1,0(R3)            Stuff it\n         LA    R2,4(,R2)           Bump to next\n         B     IFANDLP             And loop\n*\nIFANDRST L     R2,IFANDCH          Get start of tbl\n         MVC   0(4,R2),=4X'FF'     Reset to null\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------+\n*        IF error message routines                                    |\n*---------------------------------------------------------------------+\n*\nIFNERR   $ERR  BADN,8,SKIP\n*\nIFBIF    $ERR  BIF,8,SKIP\n*\nIFBREL   $ERR  IFREL,8,SKIP\n*\nIFFLOATR $ERR  FLOAT,8,SKIP\n*\nIFBFLOAT $ERR  BFLOAT,8,SKIP\n*\nIFIMASK  $ERR  IMASK,8,SKIP\n*\nIFIMASK1 $ERR  IMASK1,8,SKIP\n*\nIFTCMPLX $ERR  TCMPL,8,SKIP\n         EJECT\n*---------------------------------------------------------------------+\n*        IF routine work areas                                        |\n*---------------------------------------------------------------------+\nIFD1     DC    A(0)                Saved value of KWD1 from KW lookup\nIFTRUCH  DC    A(0)                Table of TRUE Adcons to stuff\nIFANDCH  DC    A(0)                Table of AND Adcons to stuff\nIFTAEND  DC    A(0)                End of TRUE/AND tables\nIFTADSV  DC    A(0)                Address of true Adcon for this blk\nIFBCRSV  DC    A(0)                Address of BCR inst for this block\n*\nIFGMBAL1 BAL   R10,COMP10X4        Get over the next sentence Adcon\nIFGMNSAD DC    4X'00'              Next sentence Adcon\n*\nIFGMCLC  EX    OREG,COMPCLC        Execute the CLC\nIFGMCP   EX    OREG,COMPCP         Execute the CP\nIFGMLR0  ICM   R0,15,0(AREG)       Get value into R0\nIFGMLR1  ICM   R1,15,0(BREG)       Get value into R1\nIFGMCR   EX    0,COMPCR            Execute the CR\n*\nIFGMTM1  IC    BREG,0(BREG)        Get the immediate data into BREG\nIFGMTM2  EX    BREG,COMPTM         EXecute a TM instruction\n*\nIFGMCNT1 BAL   R14,CONTAINS        Go let CONTAINS test it\n*\nIFGMMSK1 EX    OREG,COMPMSK1       Move literal to work area\nIFGMMSK2 EX    OREG,COMPMSK2       Translate to 00 or FF\nIFGMMSK3 EX    OREG,COMPMSK3       AND in chars to compare\nIFGMMSK4 EX    OREG,COMPMSK4       Now do the compare\n*\nIFGMLDNS L     R14,0(R10)          Get address of next sentence\nIFGMGONS BR    R14                 And go to it\n*\nIFGMBAL2 BAL   R7,COMP7X4          Get pointer to TRUE/AND adcon\nIFGMTAAD DC    4X'00'              TRUE/AND Adcon\nIFGMLDGT L     R14,0(R7)           Get address to GOTO\nIFGMTEST BCR   0,R14               Test result (mask is stuffed later)\nIFGM999  EQU   *\n         DROP  R14\n         $PEND\n         TITLE 'INISLECT - Set basic program mode'\n*---------------------------------------------------------------------+\n*        Select mode based on what combination of DD's found          |\n*---------------------------------------------------------------------+\n*\nINISLECT $PROC\n         TM    PCTF1,DFLTFLAG      Has DFLTFLAG been set for PARM?\n         BO    INISEX              Yes, go compile the PARM field\n         TM    PCTF2,DSYSIN        If SYSIN is present and not DUMMY\n         BO    INISEX              Return to do compile\n*\nINICHOOX TM    PCTF2,DINPUT1+DOUTPUT1 If both INPUT1 and OUTPUT1 here\n         BO    INICOPY             Go setup for COPY ALL default\n         TM    PCTF2,DINPUT1+DSYSPRT If INPUT1 and SYSPRINT then\n         BO    INIDUMP             Go setup for DUMP ALL default\n         $ERR  NULLR,12,GO=ADDSTATS,FLAG=NO Say why exist and terminate\n*\nINICOPY  OI    PCTF1,DFLTFLAG      Set flag to show defaults are used\n         OI    PCTF6,TRYFAST       Force to test for fast copy route\n         B     INISEX              Return now\n*\nINIDUMP  OI    PCTF1,DFLTFLAG      Set default flag\n         MVC   GETDPTRS+4(4),GETDPTRS+12 Setup dump default\n*\nINISEX   $RET   0                  Return (Back to do compile)\n         TITLE 'INITIODD - Initialize our own DDnames'\n*---------------------------------------------------------------------+\n*        Initialize SYSPRINT                                          |\n*---------------------------------------------------------------------+\n*\nINITIODD $PROC\n         PUSH  USING               Temporarily use R1 to\n         DROP  R7\n         USING FCBDSECT,R1         Address FCB's\n*\nINIPRINT L     R2,=A(MDLSODCB)     Point at model DCB\n         MVC   DCBEXLST(3,R2),=AL3(PRXLST) Setup SYSPRINT EXLST\n         OI    PCTF3,DCBOPT        Say DCB is optional\n         $CALL DCBO1BLD,MDSYSP     Go build I/O blocks\n         B     INIUT1              +0 no DD found/OPEN failed\n         LA    R15,PCTPFCB         Point at print FCB save area\n         ST    R1,0(R15)           Save address of print FCB\n         LA    R2,FCBDCB           Point at DCB\n         ST    R2,PCTPDCB          Save it's address\n         OI    PCTF2,DSYSPRT       Flag as SYSPRINT present\n         EJECT\n*---------------------------------------------------------------------+\n*        Initialize INPUT1                                            |\n*---------------------------------------------------------------------+\n*\nINIUT1   L     R2,=A(MDLSODCB)     Reset output model to normal\n         MVC   DCBEXLST(3,R2),=AL3(UT2LIST) Reset normal EXLST\n         OI    PCTF3,INPUT+DCBOPT  Set to optional input file\n         $CALL DCBI1BLD,MDINPT1    Go build I/O control blocks\n         B     INIUT2              +0 no DD found/OPEN failed\n         ST    R1,PCT1FCB          Save address of INPUT1 FCB\n         ST    R1,PCTIPFCB         Set as 1st input FCB address\n         OI    PCTF2,DINPUT1       Flag as present\n         LA    R2,FCBDCB           Point at DCB itself\n         ST    R2,PCT1DCB          Save it\n         MVC   DEFRECFM,FCBRECFM   Save default DCB parameters\n         MVC   DEFLRECL,FCBLRECL   .\n         MVC   DEFBLKSI,FCBBLKSI   .\n         CLC   DEFLRECL,ZEROS      Zero LRECL (RECFM=U)??\n         BNE   *+10                No\n         MVC   DEFLRECL,DEFBLKSI   Yes, use BLKSIZE\n         L     R2,=A(LINHD1T)      Get address of pghead title area\n         MVC   0(54,R2),FCBDSNAM   Stuff in DSNAME as default\n         EJECT\n*---------------------------------------------------------------------+\n*        Initialize OUTPUT1                                           |\n*---------------------------------------------------------------------+\n*\nINIUT2   MVC   DDNAME,MDOUTP1+2    Setup for OUTPUT1\n         NI    PCTF3,255-INPUT     Remove official INPUT status\n         DEVTYPE DDNAME,DEVTAB     See if DD is present\n         LTR   R15,R15             Well?\n         BNZ   INISYSIN            No, skip to SYSIN\n         OI    PCTF2,DOUTPUT1      Yes, flag as present\n*---------------------------------------------------------------------+\n*        Initialize SYSIN                                             |\n*---------------------------------------------------------------------+\n*\nINISYSIN L     R2,=A(MDLSIDCB)     Point at model DCB\n         MVC   DCBEXLST(3,R2),=AL3(INXLST) Setup SYSIN EXLST\n         OI    PCTF3,DCBOPT        Say DCB is optional\n         $CALL DCBI1BLD,MDSYSI     Go build I/O control blocks\n         B     INIMCLR             +0 no DD found/open failed\n         ST    R1,PCTIFCB          Save address of SYSIN FCB\n         LA    R2,FCBDCB           Point at DCB\n         ST    R2,PCTIDCB          Save it's address\n         MVC   DCBEODAD(3,R2),=AL3(GETWEODT) Set EOD address\n         TM    FCBDCB+17,X'4F'     Is SYSIN a TERMFILE?\n         BNO   INIDMY              No, go see if DUMMY\n         LR    R2,R1               Save R1 over TPUT\n         TPUT  TSOREADY,L'TSOREADY Prompt TSO user\n         LR    R1,R2               Restore R1\n         B     INIIDN              Go say SYSIN is here\n*\nINIDMY   CLC   FCBDSNAM(9),=C'NULLFILE ' Dummied?\n         BE    INIMCLR             Yes, treat as not here\n*\nINIIDN   OI    PCTF2,DSYSIN        Flag as present\n*\nINIMCLR  L     R2,=A(MDLSIDCB)     Point at model DCB\n         MVC   DCBEXLST(3,R2),=AL3(UT1LIST) Reset normal exlst\n         POP   USING               Restore normal usings\n         $RET  0\n         $PEND\n         TITLE 'INITPROC - Initialization routines'\n*---------------------------------------------------------------------+\n*        Build some data about job for page headings.                 |\n*---------------------------------------------------------------------+\n*\nINITPROC $PROC\n         $CALL KWRDINIT            Go initialize the KW table\n         EXTRACT WKTIOT,FIELDS=(TSO,TIOT)\n         L     R1,WKTIOT+4         Get TSO word\n         TM    0(R1),X'80'         TSO?\n         BZ    *+8                 No, skip over\n         OI    PCTF1,TSOSTEP       Yes, flag it\n         $CALL TIMEPROC            Go get date and time\n         L     R1,16               -> CVT\n         L     R9,204(R1)          -> CCVT (Leave in R9)\n         LA    R7,PCT              -> PCT\n         L     R1,WKTIOT           Get TIOT address\n         L     R2,=A(LINHD1)       Get address of 1st page head\n         MVC   11(4,R2),PCTVERNO   Move in version number\n         MVC   38(8,R2),0(R1)      Complete with JOB/$PROC/STEP names\n         MVI   46(R2),C'/'         .\n         MVC   47(8,R2),8(R1)      .\n         CLC   16(8,R1),BLANKS     .\n         BE    *+14                .\n         MVI   55(R2),C'/'         .\n         MVC   56(8,R2),16(R1)     .\n         MVC   19(3,R2),TIMEWORK+10 Month\n         MVC   23(2,R2),TIMEWORK+8  Day\n         MVI   25(R2),C'/'\n         MVC   26(2,R2),TIMEWORK+13 Year\n         MVC   29(5,R2),TIMEWORK+24 Time\n         L     R15,X'21C'          -> TCB\n         TM    20(R15),X'84'       Test mode?\n         BNZ   INITPEX             Yes, skip STAE\n         STAE  ABNDEXIT,,PARAM=PCT Setup to trap ABENDS\n         LTR   R15,R15             Accepted?\n         BZ    STAEOK              Yes\n         $ERR  NOSTA,12,GO=ADDSTATS,FLAG=NO No, issue msg\n*\nSTAEOK   STM   R0,R15,STAESAVE     Save good set of regs\n*\nINITPEX  $RET  0                   Done\n         $PEND\n         TITLE 'INTLBLS - Generate internal labels'\n*---------------------------------------------------------------------+\n*        Labels 'RETURN' and 'EOJ' are inserted here                  |\n*---------------------------------------------------------------------+\n*\nINTLBLS  $PROC\n         CLC   LBLOUT,ZEROS        Any unresolved labels?\n         BE    INTNRETN            No, dont put RETURN in\n         $CALL LBLGEN,INTRETN      Go put label into pgm\n*\nINTNRETN $CALL DBGADD              Go add DEBUG code\n         $ADD  INTG499-INTGRET1,INTGRET1 Then put in pgm code\n         LA    R2,INTGREST-INTGRET1(,R1) Point at resume address\n         ST    R2,INTGRESM-INTGRET1(,R1) Stuff in code\n         MVC   INTGFCBA-INTGRET1(4,R1),PCT1FCB Stuff in INPUT1 FCB\n         MVC   INTGRESM-INTGRET1(1,R1),PCTBFCDF Stuff in COPYBUFF def.\n         LA    R2,INTGEOFA-INTGRET1(,R1)\n         L     R3,=A(NXTEOFD)\n         $CALL LBLOGEN,(R3),(R2)\n         LA    R2,PCTIPEOF\n         L     R3,=A(NXTEOFD)\n         $CALL LBLOGEN,(R3),(R2)\n         CLC   LBLOUT,ZEROS        Any unresolved labels?\n         BE    INTNEOJ             No, don't put EOJ in\n         $CALL LBLGEN,INTEOJ       And EOJ label\n*\nINTNEOJ  $ADD  8,INTGEOJ1          Stuff in GOTO EOJ\n         $RET  0                   Return\n*\n*---------------------------------------------------------------------+\n*        Internal label creation work areas                           |\n*---------------------------------------------------------------------+\n         CNOP  2,4\n*\nINTGRET1 BALR  R15,0               Get locally addressable\nINTGSAVE MVC   PCTPGMS,PCTPGM      Save PCTPGM address\nINTGSWAP MVC   PCTPGM,INTGRESM-INTGSAVE(R15) Swap in our resume address\nINTGBALR BAL   R15,COPRETN-COPYDATA(R8) Go to COPRETN to read record\nINTGRESM DC    XL4'00'             Address of code to resume at\nINTGFCBA DC    A(0)                Address of FCB area\nINTGEOFA DC    A(ADDSTATS)         Address of EOF label\nINTGREST MVC   PCTPGM,PCTPGMS      Restore original PCTPGM address\nINTGLADD L     R14,PCTPGM          Get PCTPGM address\nINTGBR   BR    R14                 And go to it\nINTG499  EQU   *                   End of model code\n         CNOP  0,4\n*\nINTGEOJ1 BAL   R14,COMPGOTO        Off to the GOTO support\nINTGEOJ2 DC    A(ADDSTATS)         Adcon\nINTRETN  DC    H'6',CL10'RETURN'\nINTEOJ   DC    H'3',CL10'EOJ'\n*\n         DS    0F\nINTULADD BAL   R14,COMPGOTO        Use GOTO support routine\nINTUADCN DC    4X'00'              Adcon\n         $PEND\n         TITLE 'JFCNAME - Build full DSNAME for messages'\n*---------------------------------------------------------------------+\n*        Pretty up the DSNAME in an FCB area                          |\n*        ===================================                          |\n*                                                                     |\n*        Called:   $CALL JFCNAME,fcb                                  |\n*                                                                     |\n*        Operands: fcb     - the address of the FCB to be processed   |\n*                                                                     |\n*        Returns +0 on completion                                     |\n*---------------------------------------------------------------------+\n*\nJFCNAME  $PROC 1                   One param passed\n         L     R7,12(R8)           Get FCB address\n         MVC   FCBDSNAM,FCBJFCB    Put in DSNAME from JFCB\n         MVC   FCBDSNAM+44(10),BLANKS Blank rest\n         TM    FCBJFCB+86,X'01'    Member ??\n         BZ    JFCNEX              No, we're done, go back now\n         L     R15,=A(TRTBLB)      Point at TRT table\n         TRT   FCBDSNAM(45),0(R15) Look for blank (must be there)\n         MVI   0(R1),C'('          Now build member name\n         MVC   1(8,R1),FCBJFCB+44  .\n         TRT   1(9,R1),0(R15)      .\n         MVI   0(R1),C')'          .\n*\nJFCNEX   $RET  0                   And leave\n         $PEND\n         TITLE 'KWRDINIT - Keyword Table Initialize'\n*---------------------------------------------------------------------+\n*        Initialize the KW lookup table                               |\n*        ==============================                               |\n*                                                                     |\n*        Called:   $CALL KWRDINIT                                     |\n*                                                                     |\n*        Operands: none.                                              |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*                                                                     |\n*        Notes:    This routine must be called before any KW lookups  |\n*                  are performed. It's purpose is to initialize the   |\n*                  lookup hash table.                                 |\n*---------------------------------------------------------------------+\n*\nKWRDINIT $PROC\n         L     R4,=A(KWTBL)        Get address of KW table\n         LA    R5,KWTBLL/KWENTL    Get number of entries in table\n         USING KWDSECT,R4\n*\nKWRDILP  L     R6,=A(KWHASH)       Get address of KW hash table\n         ICM   R1,15,KWL           Hash the KW name\n         X     R1,KWL+4            .\n         X     R1,KWL+8            .\n         SR    R0,R0               Clear R0 for divide\n         D     R0,=F'67'           Calc hash table index\n         SLL   R0,2                Index x 4\nKWDT1    AR    R6,R0               Add hash table address\n         LR    R15,R6              Swap regs\n         ICM   R6,15,0(R15)        Find end of chain\n         BNZ   *-6                 .\n         ST    R4,0(R15)           Stuff entry into chain\n         LA    R4,KWENTL(,R4)      Next KW entry\n         BCT   R5,KWRDILP          Loop till all done\n         $RET  0\n         $PEND\n         DROP  R4\n         TITLE 'KWRDSRCH - Keyword Search Routine'\n*---------------------------------------------------------------------+\n*        Lookup a word in the KW table.                               |\n*        ==============================                               |\n*                                                                     |\n*        Called:   $CALL KWRDSRCH,word,answer                         |\n*                                                                     |\n*        Operands: word     - A standard 'word' area.                 |\n*                              i.e.  H'nn',C'text'                    |\n*                                                                     |\n*                  answer   - KW answer area. See KWDSECT for the     |\n*                             mapping of this area.                   |\n*                                                                     |\n*        Returns:  +0 if not found                                    |\n*                  +4 if found                                        |\n*                                                                     |\n*        Notes:    The routine KWRDINIT must be called BEFORE any     |\n*                  call to this routine.                              |\n*---------------------------------------------------------------------+\n*\nKWRDSRCH $PROC 2                   Receives 2 parameters\n         STM   R1,R3,KWRDSAVE      Save the regs we use\n         L     R1,16(R8)           Get address of area to receive ans\n         MVC   0(KWENTL,R1),ZEROS  Clear the answer area\n         L     R3,12(R8)           Point at name to be found\n         L     R2,=A(KWHASH)       Get address of KW hash table\n         MVC   KWRDWORK+2(10),=CL10' '\n         LH    R1,0(R3)            Get length of search arg\n         CH    R1,=H'10'           Test against max KW length\n         BH    KWMISS              Too long, pass back 'not found'\n         LA    R1,1(,R1)           Adjust it\n         EX    R1,*+4              Move it\n         MVC   KWRDWORK(0),0(R3)   .\n*---------------------------------------------------------------------+\n*        Hash the name to be looked up.                               |\n*---------------------------------------------------------------------+\n         ICM   R1,15,KWRDWORK      Hash up the name\n         X     R1,KWRDWORK+4       .\n         X     R1,KWRDWORK+8       .\n         SR    R0,R0               Get ready for divide\n         D     R0,=F'67'           Calc hash table index\n         SLL   R0,2                Remainder x 4\n         AR    R2,R0               Add hash table address\n         USING KWDSECT,R2\n*---------------------------------------------------------------------+\n*        Search the hash chains for the name.                         |\n*---------------------------------------------------------------------+\n*\nKWRDCHN  ICM   R2,15,KWCHAIN       Chain to next\n         BZ    KWMISS              If zero then not found\n         CLC   KWRDWORK(12),KWL    Is this the one?\n         BNE   KWRDCHN             No, point at next in chain\n         L     R1,16(R8)           Get address of area to receive ans\n         MVC   0(KWENTL,R1),KWCHAIN Pass back the answer\n         CP    COMNTCTL,=P'0'      In comment/skip mode?\n         BNE   KWRDEX              Yes, don't test comment words.\n*\nKWRDEX   LM    R1,R3,KWRDSAVE      Reload regs\n         $RET  4                   Exit found\n*\nKWMISS   LM    R1,R3,KWRDSAVE      Reload regs\n         $RET  0                   Return +0 for an error\nKWRDSAVE DS    3F\nKWRDWORK DS    H'0',CL10' '\n         DROP  R2\n         $PEND\n         TITLE 'LBLGEN - Label generate/lookup routines'\n*---------------------------------------------------------------------+\n*        Add an entry to the label table pointing at current I.C.     |\n*        ========================================================     |\n*                                                                     |\n*        Called:   $CALL LBLGEN,word                                  |\n*                                                                     |\n*        Operands: word     - is standard 'word' format               |\n*                               i.e. H'nn',C'text'                    |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*---------------------------------------------------------------------+\n*\nLBLGEN   $PROC 1\n         L     R1,12(R8)           Get address of passed parameter\n         LH    R2,0(R1)            Pickup length of label\n         BCTR  R2,0                Less 1 for EX command\n         CH    R2,=H'7'            Too long?\n         BNH   *+8                 No\n         LA    R2,7                Yes, force it to 8 bytes\n         MVC   LBLHOLD,BLANKS      Clear hold area\n         CLC   0(2,R1),=H'10'      Over max in-line data?\n         BNH   LBLGENM             No, continue\n         ICM   R1,15,2(R1)         Yes, get pointer to data\n         SH    R1,=H'2'            Adjust it\n*\nLBLGENM  EX    R2,*+4              Move passed label\n         MVC   LBLHOLD(0),2(R1)    .\n         ICM   R4,15,LBLIN         Get start of label in table\n         BNZ   LBLSLOOP            Search it if we have one\n         GETMAIN R,LV=2040,SP=1    Else, get 1st block\n         LR    R4,R1               Put it in R4\n         ST    R1,LBLIN            And save it\n         MVC   LBLINCT,=F'170'     Set max avail. count in area\n         MVI   0(R4),X'FF'         Set end flag at start of table\n*\nLBLSLOOP CLI   0(R4),X'FF'         Is this the end\n         BE    LBLTEND             Yes, go stuff in new label\n         CLI   0(R4),X'FE'         No, maybe its a chain flag\n         BNE   *+12                Not this, try equal labels\n         L     R4,8(R4)            Its a chain, pick it up\n         B     LBLSLOOP            And keep searching\n         CLC   LBLHOLD,0(R4)       Is it a duplicate label\n         BNE   LBLSBMP             No, keep looking for end of table\n         $ERR  LBLDP,8             Flag with warning message\n*\nLBLGEX   $RET  0                   And return\n*\nLBLSBMP  LA    R4,12(,R4)          Bump up to next entry\n         B     LBLSLOOP            And continue search\n*\nLBLTEND  L     R2,LBLINCT          See how many entries left in table\n         CH    R2,=H'2'            Almost at end\n         BL    LBLCHN              Yes, go get a new area and chain it\n         BCTR  R2,0                Reduce number remaining\n         ST    R2,LBLINCT          And save it\n         $ADD  0,*                 Go get current inst. counter\n         ST    R1,8(R4)            Put it in entry\n         MVC   0(8,R4),LBLHOLD     Put in the label\n         MVI   12(R4),X'FF'        Put new end DLM in next entry\n         B     LBLGEX              And exit\n*\nLBLCHN   MVI   0(R4),X'FE'         Make this a chain entry\n         GETMAIN R,LV=2040         Get another block\n         ST    R1,8(R4)            Put its address in chain area\n         MVC   LBLINCT,=F'170'     Reset number entries\n         LR    R4,R1               Swap regs\n         MVI   0(R4),X'FF'         Make it look like end of tbl\n         B     LBLTEND             Re-enter normal logic\n         $PEND\n         TITLE 'LBLOGEN - Add entry to unresolved table'\n*---------------------------------------------------------------------+\n*        Add an entry to the unresolved label table                   |\n*        ==========================================                   |\n*                                                                     |\n*        Called:   $CALL LBLOGEN,word,address                         |\n*                                                                     |\n*        Operands: word     - is standard 'word' format               |\n*                               i.e. H'nn',C'text'                    |\n*                                                                     |\n*                  address  - address of the fullword to eventually   |\n*                             be completed with the address of the    |\n*                             label in 'word'                         |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*---------------------------------------------------------------------+\n*\nLBLOGEN  $PROC 2                   Passed 'word', address as parameters\n         L     R1,12(R8)           Get address of word\n         LH    R2,0(R1)            Pickup length of label\n         BCTR  R2,0                Less 1 for EX command\n         CH    R2,=H'7'            Too long?\n         BNH   *+8                 No\n         LA    R2,7                Yes, force it to 8 bytes\n         MVC   LBLHOLD,BLANKS      Clear hold area\n         CLC   0(2,R1),=H'10'      Over max in-line data?\n         BNH   LBLOGENM            No, continue\n         ICM   R1,15,2(R1)         Yes, get pointer to data\n         SH    R1,=H'2'            Adjust it\n*\nLBLOGENM EX    R2,*+4              Move passed label\n         MVC   LBLHOLD(0),2(R1)\n         ICM   R4,15,LBLOUT        Get start of label in table\n         BNZ   LBLOSLP             Search it if we have one\n         GETMAIN R,LV=2033,SP=1    Else, get 1st block\n         LR    R4,R1               Put it in R4\n         ST    R1,LBLOUT           And save it\n         MVC   LBLOUTCT,=F'107'    Set max avail. count in area\n         MVI   0(R4),X'FF'         Set end flag at start of table\n*\nLBLOSLP  CLI   0(R4),X'FF'         Is this the end\n         BE    LBLOTEND            Yes, go stuff in new label\n         CLI   0(R4),X'FE'         No, maybe its a chain flag\n         BNE   LBLOSBMP            No, keep looking for end\n         L     R4,8(R4)            Its a chain, pick it up\n         B     LBLOSLP             And keep searching\n*\nLBLOSBMP LA    R4,19(,R4)          Bump up to next entry\n         B     LBLOSLP             And continue search\n*\nLBLOTEND L     R2,LBLOUTCT         See how many entries left in table\n         CH    R2,=H'2'            Almost at end\n         BL    LBLOCHN             Yes, go get a new area and chain it\n         BCTR  R2,0                Reduce number remaining\n         ST    R2,LBLOUTCT         And save it\n         L     R1,16(R8)           Go get address to be completed\n         ST    R1,8(R4)            Put it in entry\n         MVC   0(8,R4),LBLHOLD     Put in the label\n         MVC   12(3,R4),GETCTR1    Put in statement number\n         MVC   15(3,R4),GETCTR2    Put in word no\n         MVI   19(R4),X'FF'        Put new end DLM in next entry\n         $RET  0                   And exit, we're done\n*\nLBLOCHN  MVI   0(R4),X'FE'         Make this a chain entry\n         GETMAIN R,LV=2033         Get another block\n         ST    R1,8(R4)            Put its address in chain area\n         MVC   LBLOUTCT,=F'107'    Reset number entries\n         LR    R4,R1               Swap regs\n         MVI   0(R4),X'FF'         Make it look like end of tbl\n         B     LBLOTEND            Re-enter normal logic\n         $PEND\n         TITLE 'LBLRESLV - Process unresolved labels'\n*---------------------------------------------------------------------+\n*        Process unresolved label table                               |\n*---------------------------------------------------------------------+\n*\nLBLRESLV $PROC\n         ICM   R1,15,LBLOUT        Get start of unresolved labels\n         BZ    LBLRDONE            None? exit\n*\nLBLRESL1 CLI   0(R1),X'FF'         End of table?\n         BE    LBLRDONE            Yes, we're done\n         CLI   0(R1),X'FE'         Chain to new GETMAIN block?\n         BNE   *+12                No, go process it\n         L     R1,8(R1)            Yes, load address of next block\n         B     LBLRESL1            And loop back\n         ICM   R2,15,LBLIN         Now get address of full label table\n         BZ    LBLNOTF             No table, then its unresolved\n*\nLBLRESL2 CLI   0(R2),X'FF'         End of table?\n         BE    LBLNOTF             Yes, then its not there\n         CLI   0(R2),X'FE'         Chain to new GETMAIN block?\n         BNE   *+12                No, go test this entry\n         L     R2,8(R2)            Yes, pickup address of next block\n         B     LBLRESL2            And loop back\n         CLC   0(8,R1),0(R2)       Do labels match???\n         BE    LBLRESFN            Yes, we've found it\n         LA    R2,12(,R2)          No, bump to next entry\n         B     LBLRESL2            And loop backk\n*\nLBLRESFN L     R3,8(R1)            Get address to be completed\n         MVC   0(4,R3),8(R2)       Move in desired address\n         LA    R1,19(,R1)          Bump to next unresolved entry\n         B     LBLRESL1            And loop back\n*\nLBLNOTF  MVC   GETCTR1(6),12(R1)   Stuff back original source loc.\n         STM   R1,R2,LBLSV12       Save loop control regs\n         $ERR  UNRES,8,FLAG=NO     Issue error message\n         LM    R1,R2,LBLSV12       Get back loop control regs\n         LA    R1,19(,R1)          Bump to next unresolved\n         B     LBLRESL1            And loop back\n*\nLBLRDONE ICM   R1,15,LBLOUT        Any table to free?\n         BNZ   LBLRFREE            Yes, go free it\n         ICM   R1,15,LBLIN         Any table here?\n         BZ    LBLREX              No, we can leave\n*\nLBLRFREE FREEMAIN R,SP=1           Yes, free it/them\n*\nLBLREX   $RET  0                   And then leave\n         $PEND\n         TITLE 'LITPOOL - Process literals'\n*---------------------------------------------------------------------+\n*        Decode and generate a Literal in the Literal pool            |\n*        =================================================            |\n*                                                                     |\n*        Called:   $CALL LITPOOL,word                                 |\n*                                                                     |\n*        Operands: word     - is standard 'word' format               |\n*                               i.e. H'nn',C'text'                    |\n*                                                                     |\n*        Returns:  +0   Success                                       |\n*                  +4   Bad literal type                              |\n*                  +8   Odd number or invalid hex characters          |\n*                  +12  Incorrect length specified                    |\n*                  +16  Incorrect use of quotes                       |\n*                  +20  Non-numeric value in numeric literal          |\n*                                                                     |\n*        Notes:    All answers are in the following areas:            |\n*                                                                     |\n*                  LITL     - Length of the Literal                   |\n*                  LITT     - The type of literal (C,X,P,F,H)         |\n*                  LITA     - The absolute address of the literal.    |\n*---------------------------------------------------------------------+\n*\nLITPOOL  $PROC 1\n         L     R7,12(R8)           Pickup passed param address\n         MVC   LITR,=F'1'          Set default repeat count\n*\nLITREDO  LH    R0,0(R7)            R0 - length of input\n         LA    R1,2(,R7)           R1 - address of input\n         CH    R0,=H'10'           If length > 10 then get pointer\n         BNH   *+8                 No, skip\n         ICM   R1,15,2(R7)         Yes, load it's pointer\n         ST    R1,LITSTRTT         Save start of text address\n         LR    R14,R1              Put addr in usable reg\n         LR    R3,R0               Ditto for length\n         BCTR  R3,0                Convert length for EX\n         L     R15,=A(TRTBLQ)      Point at TRT table\n         EX    R3,LITFQ            Look for 1st quote\n         BNZ   LIT1Q               Got the 1st one\n*\nLITQERR  $RET  16                  Return +16\n*\nLIT1Q    ST    R1,LIT1STQ          Save its address\n         LR    R2,R14              Setup to scan out repeat factor\n         L     R15,=A(TRTBLN)      .\n         TM    0(R2),X'F0'         Leading numeric\n         BNO   LIT1QO              No, no repeat factor then\n         EX    R3,LITTR            Extract repeat factor\n         LR    R2,R1               .\n         SR    R1,R14              .\n         BCTR  R1,0                .\n         EX    R1,LITRPACK         .\n         LH    R15,0(R7)           Adjust WORD length\n         SR    R15,R1              .\n         BCTR  R15,0               .\n         STH   R15,0(R7)           .\n         BCTR  R15,0               Shift WORD\n         L     R3,LITSTRTT         Pick up addr. of start of lit. text\n         MVC   0(0,R3),0(R2)       .\n         EX    R15,*-6             .\n         CVB   R1,DBL              Binary repeat factor\n         ST    R1,LITR             Save it\n         B     LITREDO             Continue as if not there\n*\nLIT1QO   LR    R2,R14              Put start of data in R2\n         AR    R2,R0               And add length\n         BCTR  R2,0                Backup one to get last char\n         ST    R2,LIT2NDQ          Save its address\n         CLI   0(R2),C''''         See if its really a quote\n         BNE   LITQERR             No, possible error\n         BCTR  R2,0                Backup one\n         C     R2,LIT1STQ          Make sure its not a null lit\n         BE    LITQERR             If it is reject it\n         LR    R1,R14              Get back start of data\n         C     R1,LIT1STQ          Start with a quote?\n         BE    *+8                 Yes, skip looking for length operand\n         BAL   R14,LITCHEKL        Go check length operand\n         LM    R2,R3,LIT1STQ       Lets setup regs for data portion\n         SR    R3,R2               Calc length\n         BCTR  R3,0                Minus one\n         LA    R2,1(,R2)           Step over opening quote\n         LH    R4,LITLGTH          Pickup length operand length\n         LTR   R4,R4               Zero?\n         BNZ   LITNOLGT            No, there was a length operand, skip\n         LR    R4,R3               Else set to length of data\n         C     R1,LIT1STQ          Start with a quote?\n         BE    LITDFALT            Yes, default to C type literal\n         B     LITNOLGT            Continue\n         EJECT\n*---------------------------------------------------------------------+\n*        Check type of literal request                                |\n*---------------------------------------------------------------------+\n*\nLITNOLGT MVC   LITT,0(R1)          Save type of literal for caller\n         CLI   0(R1),C'C'          Then see what it is\n         BE    LITC\n         CLI   0(R1),C'P'\n         BE    LITP\n         CLI   0(R1),C'X'\n         BE    LITX\n         CLI   0(R1),C'H'\n         BE    LITH\n         CLI   0(R1),C'F'\n         BE    LITF\n*\nLITBTYPE $RET  4                   Return +4\n*---------------------------------------------------------------------+\n*        Check for, and process literal length operand                |\n*---------------------------------------------------------------------+\n*\nLITCHEKL MVC   LITLGTH,ZEROS       Reset length\n         CLI   1(R1),C'L'          Is there a length operand\n         BE    LITLEXTR            Yes go extract it\n         CLI   1(R1),C''''         If no L then next must be quote\n         BER   R14                 Yes, return with zero length\n*\nLITLERR  $RET  12                  Return +12\n*\nLITLEXTR L     R2,LITZERO          Set reg to C'0000'\n         LA    R3,2(R1)            Setup for loop\n*\nLITLNXT  CLI   0(R3),C'0'          Test numeric\n         BL    LITLERR\n         CLI   0(R3),C'9'\n         BH    LITLERR\n         SLL   R2,8                Its numeric, make room in reg\n         IC    R2,0(R3)            And insert it\n         LA    R3,1(,R3)           Bump reg\n         CLI   0(R3),C''''         End of length field?\n         BNE   LITLNXT             No, loop back\n         ST    R2,LITW1            Store result\n         PACK  DBL,LITW1           Pack it\n         CVB   R2,DBL              Then to binary\n         STH   R2,LITLGTH          And save it\n         C     R2,=F'256'          Test for max\n         BNHR  R14                 OK, go back\n*\nLITBL    $RET  12                  Return +12\n         EJECT\n*---------------------------------------------------------------------+\n*        Character type literals                                      |\n*---------------------------------------------------------------------+\n*\nLITC     MVI   LITFILL,C' '        Set fill char\n*\nLITCDEFF $CALL LITSTUFF            Go find place in literal pool\n         $RET  0                   Return +0\n*---------------------------------------------------------------------+\n*        Packed decimal type literals                                 |\n*---------------------------------------------------------------------+\n*\nLITP     MVI   LITFILL,X'00'       Set fill char\n         CLI   0(R2),C'-'          Is value negative?\n         BNE   LITPNNEG            No, skip over neg logic\n         LA    R2,1(,R2)           Step over sign\n         BCTR  R3,0                Adjust length\n         BCTR  R3,0                And again\n         L     R14,=A(TRTBLN)      Get address of TRT table\n         EX    R3,LITTNUM          See if num.\n         BNZ   LITNNUM             No\n         CH    R3,=H'14'           Length OK?\n         BH    LITLERR             No, kill it\n         LA    R14,0(R2,R3)        Find low order digit\n         MVZ   0(1,R14),=X'D0'     Set overpunch\n         B     LITPCOMM\n*\nLITPNNEG BCTR  R3,0                Set for EX\n         CH    R3,=H'14'           Length OK?\n         BH    LITLERR             No, kill it\n         CLC   LITLGTH,=H'8'       Check override length too\n         BH    LITLERR\n         L     R14,=A(TRTBLN)      Point at TRT table\n         EX    R3,LITTNUM          See if valid numerics\n         BNZ   LITNNUM             No, kill it\n*\nLITPCOMM EX    R3,LITPACK          Yes, process it\n         LA    R3,1(,R3)           Set R3 back to actual\n         TM    DBL+7,X'0F'         Is sign + (F)\n         BNO   *+10                No\n         MVN   DBL+7(1),=X'0C'     Yes, make it a + (C)\n         SRL   R3,1                Calc number of packed bytes\n         LA    R3,1(,R3)\n         LA    R2,DBL+8            Now point at correct loc in DBL\n         SR    R2,R3\n         CLC   LITLGTH,ZEROS       Any  overriding length?\n         BNE   LITPSTFF            Yes, use it, its in R4 already\n         LR    R4,R3               Else use length of actual data\n*\nLITPSTFF $CALL LITSTUFF            Go store in literal pool\n         $RET  0                   Return +0\n         EJECT\n*---------------------------------------------------------------------+\n*        Full/Halfword type literals                                  |\n*---------------------------------------------------------------------+\n*\nLITF     LA    R4,4                Set length\n         OI    PCTF5,FWTYPE        Set sw to say fullword\n         B     LITFH               Enter shared logic\n*\nLITH     LA    R4,2                Set length\n*\nLITFH    CLI   0(R2),C'-'          Negative value?\n         BNE   LITFNNEG            No, skip over neg logic\n         LA    R2,1(,R2)           Step over sign\n         BCTR  R3,0                Drop length\n         BCTR  R3,0                And again\n         L     R14,=A(TRTBLN)      Point at TRT table\n         EX    R3,LITTNUM          See if numeric\n         BNZ   LITNNUM             And reject if not\n         LA    R14,0(R2,R3)        Find low order digit\n         MVZ   0(1,R14),=X'D0'     Set negative sign\n         B     LITFTLG             Go continue testing\n*\nLITFNNEG BCTR  R3,0                Setup for EX\n         L     R14,=A(TRTBLN)      Point at TRT table\n         EX    R3,LITTNUM          Is it numeric\n         BNZ   LITNNUM             No kill it\n*\nLITFTLG  CH    R3,=H'14'           Check for max\n         BH    LITLERR             Too big reject it\n         EX    R3,LITPACK\n         CP    DBL,=P'2147483647'  Test fullword limits\n         BH    LITNNUM             If outside treat an non numeric\n         CP    DBL,=P'-2147483648'\n         BL    LITNNUM\n         CVB   R0,DBL              Make it binary\n*\nLITFHTST TM    PCTF5,FWTYPE        Fullword type?\n         BO    LITFSTR             Yes\n         STH   R0,DBL\n         B     LITFSTF             Go stuff it\n*\nLITFSTR  ST    R0,DBL              Do fullword store\n         NI    PCTF5,255-FWTYPE    Reset switch\n*\nLITFSTF  LA    R2,DBL              Set Ptr to dbl\n         LR    R3,R4\n         $CALL LITSTUFF            Go store it\n         $RET  0                   Return +0\n         EJECT\n*---------------------------------------------------------------------+\n*        Hexadecimal type literals                                    |\n*---------------------------------------------------------------------+\n*\nLITX     MVI   LITFILL,X'00'       Set fill char\n         ST    R3,DBL              Put length in memory\n         TM    DBL+3,X'01'         Is it an even number\n         BNO   LITXEVN             Yes, continue\n*\nLITBHEX  $RET  8                   Return +8\n*\nLITXEVN  LR    R5,R2               Setup loop regs\n         LR    R9,R2\n         SRL   R3,1                Set loop count\n*\nLITXLOOP L     R14,=A(TRTBLX)      Get address of TR table\n         TR    0(2,R9),0(R14)      Translate to 00 to 0F\n         TM    0(R9),X'F0'         Test for invalid hex chars\n         BO    LITBHEX\n         TM    1(R9),X'F0'\n         BO    LITBHEX\n         PACK  0(0,R5),0(0,R9)     Do LH nibble\n         OC    0(0,R5),1(R9)       Do RH nibble\n         LA    R5,1(,R5)           Bump up\n         LA    R9,2(,R9)\n         BCT   R3,LITXLOOP         And loop if more\n         LR    R3,R5               Now calc new length\n         SR    R3,R2\n         CLC   LITLGTH,ZEROS       Was a length coded?\n         BNE   LITXSTFF            Yes, use the value in R4\n         LR    R4,R3               Else swap it from R3\n*\nLITXSTFF $CALL LITSTUFF            Go store it\n         $RET  0                   Return +0\n*\nLITNNUM  $RET  20                  Return +20\n*\nLITDFALT MVI   LITT,C'C'           Setup defaults\n         MVI   LITFILL,C' '        .\n         MVC   LITLGTH,ZEROS       .\n         B     LITCDEFF            Go process with these defaults\n*\nLITSTRTT DS    F                   Real start of literal text\nLITTR    TRT   0(0,R2),0(R15)\nLITRPACK PACK  DBL,0(0,R14)\nLITFQ    TRT   0(0,R1),0(R15)\n         $PEND                     And return\n         TITLE 'LITSTUFF - Save things in Literal Pool'\n*---------------------------------------------------------------------+\n*        Store prosessed literal in the literal pool                  |\n*        *** Note: LITSTUFF may be entered to save any                |\n*                  value in a getmained area                          |\n*                  Calling seq. is -  R2 --> text                     |\n*                                  -  R3 --> length of text           |\n*                                  -  R4 --> length of text           |\n*---------------------------------------------------------------------+\n*\nLITSTUFF $PROC\n         LR    R15,R4              Calc total size of literal\n         MH    R15,LITR+2          .\n         ST    R15,LITL            Save it\n         CH    R15,=H'256'         Too big?\n         BH    BADLITBL            Yes, sorry\n         STM   R2,R4,LITSRSV       No, save regs for repeat loop\n         C     R15,PCTGMLIT        Enough room in this block?\n         BNH   LITSTSV             Go store in this block\n         GETMAIN R,LV=1024         Go get a block\n         L     R15,=A(MAINETRC)    Point at trace flag\n         TM    1(R15),X'F0'        Is support active?\n         BO    LITNOSUP            No\n         L     R15,PCTSUPP2        Get place to store it\n         ST    R1,0(R15)           Save it\n         OI    0(R15),X'80'        Flag as litpool block\n         MVC   4(4,R15),HEXFFS     Stuff in new delim\n         LA    R15,4(,R15)         Bump to next slot\n         ST    R15,PCTSUPP2        Save for next time\n*\nLITNOSUP ST    R1,PCTGMLIT+4       Store address of block\n         ST    R1,PCTGMLIT+8       Save begin block address\n         MVC   PCTGMLIT(4),=F'1024' Set available length\n*\nLITSTSV  L     R1,PCTGMLIT+4\n         ST    R1,LITA             Save absolute address of lit\n*\nLITSRLP  LR    R9,R1               Get addr in litpool\n         AR    R1,R4\n         ST    R1,PCTGMLIT+4\n         L     R1,PCTGMLIT\n         SR    R1,R4\n         ST    R1,PCTGMLIT\n         CR    R3,R4               More char. than lgth. operand??\n         BNH   LITSPST             No, go spread\n         SR    R2,R3               Change pointer to input data\n         SR    R2,R4\n         LR    R3,R4               Show new length of input\n*\nLITSPST  MVC   0(1,R9),LITFILL\n         BCTR  R4,0                Set length for fill spread\n         LTR   R4,R4               Is length long enough to need spread\n         BZ    LITSPDN             No, skip over\n         BCTR  R4,0                Adjust it one more\n         EX    R4,*+4              Spread with fill char\n         MVC   1(0,R9),0(R9)\n         LA    R4,1(,R4)           Put R4 back\n*\nLITSPDN  CLI   LITFILL,C' '        What kind of align, right or left\n         BE    LITSSRDY\n         AR    R9,R4               Adjust address for right align\n         SR    R9,R3\n         LA    R9,1(,R9)\n*\nLITSSRDY BCTR  R3,0                Adjust for EX\n         CR    R3,R4               Select smaller of two regs\n         BL    LITSDOEX            R3 is OK use it\n         LR    R3,R4               Else load and use R4\n*\nLITSDOEX EX    R3,*+4              Put in literal pool\n         MVC   0(0,R9),0(R2)\n         L     R15,LITR            Get repeat count\n         BCTR  R15,0               - 1\n         ST    R15,LITR            Save repeat count\n         LTR   R15,R15             Done?\n         BZ    LITSREX             Yes, exit\n         LM    R2,R4,LITSRSV       No, reload regs\n         L     R1,PCTGMLIT+4       Get next address in pool\n         B     LITSRLP             And do it again\n*\nLITSREX  MVC   LITR,=F'1'          Ensure it defaults to 1\n         $RET  0                   Return\n         $PEND\n         TITLE 'MAINCOMP - Compiler main line'\n*---------------------------------------------------------------------+\n*        Main  line for the Compile phase                             |\n*---------------------------------------------------------------------+\n*\nMAINCOMP $PROC\n         USING KWDSECT,R14\n*\nMAINNWD  $CALL GETNEXT             Go get next word\n*\nMAINDATA TM    WFLAG1,WPREF        Is word prefixed?\n         BZ    MAINWDS             No, then it's not labelled\n         TM    WFLAG1,WWRD1+WWRD2+WTRLR Other sub-fields?\n         BNZ   MAINWDS             Yes, not a valid label then\n         TM    PREFF2,OPRKW+OPRKWV Was it a valid keyword?\n         BNO   MAINADDL            No, go add as label\n         LA    R14,PREFKW1         Yes, point at KW answer area\n         CLI   KWNUM,RESERVED      Is this a reserved label?\n         BE    MAINRWD             Yes, sorry\n*\nMAINADDL $CALL LBLGEN,PREFL        Go generate internal label\n         B     MAINNWD             And go back for next word\n*\nMAINRWD  $ERR  RSVDWD,8,SKIP       Kill it\n*---------------------------------------------------------------------+\n*        Check command type                                           |\n*---------------------------------------------------------------------+\n*\nMAINWDS  TM    WFLAG1,WPREF+WWRD2+WTRLR Other sub-fields?\n         BNZ   MAINBCMD            Yes, sorry about that\n         TM    WRD1F2,OPRKW+OPRKWV A valid keyword?\n         BNO   MAINBCMD            No, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWMAJ          A major command?\n         BZ    MAINBCMD            No, sorry\n         NI    PCTF3,255-COMPALTR  Kill ALTER flag\n         L     R8,KWD3             Get addr of routine\n         B     8(R8)               And go to it\n*\nMAINBCMD CLC   WORDL,=H'0'         Caused by null sentence?\n         BNE   MAINBCMR            No, real error\n         $ERR  EXTP,4              Yes, tell user that\n         B     MAINNWD             Continue\n*\nMAINBCMR $ERR  BADC,8,SKIP         Not found? issue error message\n*\nMAINRUN  L     R8,PCTMAINC         Get routine addressable\n         B     MAINENDC-MAINCOMP(R8) Go to it\n         EJECT\n*---------------------------------------------------------------------+\n*        Ensure that next 'word' is end-of-sentence                   |\n*        and issue error message if it isn't                          |\n*---------------------------------------------------------------------+\n*\nMAINGEOX NI    PCTF1,255-ACTIVE    Show command no longer active\n         $CALL GETNEXT             Go get next word\n         CLC   WORDL,ZEROS         Should be end of sentence\n         BE    MAINNWD             O.K. Start next sentence\n         $ERR  NOPER,0,GO=MAINDATA,FLAG=NO NO, Msg and assume period\n*\nMAINGOKX NI    PCTF1,255-ACTIVE    Show command no longer active\n         B     MAINNWD             And go for next\n         DROP  R14\n         TITLE 'MAINCOMP - Compiler - End of Input routine'\n*---------------------------------------------------------------------+\n*        End of command input to compiler                             |\n*---------------------------------------------------------------------+\n*\nMAINCMS  $ERR  CCLOS,8,FLAG=NO     Issue error and terminate\n         B     MAINENDC            Skip\n*\nMAINENDM $ERR  MCONT,8,FLAG=NO     Issue error and terminate\n*\nMAINENDC ZAP   GETCTR1,=P'1'       Set GETCTRS to EOF status to stop\n         ZAP   GETCTR2,=P'1'       STMNT/WORD #'s in error messages\n         $CALL INTLBLS             Go add internal labels to pgm\n         $CALL LBLRESLV            Go process unresolved labels\n         CLC   DCBALREC,ZEROS      A deferred LRECL test to do?\n         BE    MAINNLTS            No, skip\n         CLC   DCBALREC,DCBHLREC   Did something pass the high-water?\n         BNH   MAINNLTS            No, we're O.K.\n         MVC   GETCTR1,DCBASNO     Yes, swap in it's statement/word #\n         MVC   GETCTR2,DCBAWNO     .\n         $ERR  BUFFX,8,FLAG=NO     and issue error message now\n*\nMAINNLTS ZAP   GETCTR1,=P'9999'    Do again, LBLRESLV may have reset\n         ZAP   GETCTR2,=P'999'     them if it detects errors.\n         $ERR  MSG40,0,TYPE=STAT,FLAG=NO   Init statistics msg chain\n         $ERR  SPACE,0,TYPE=STAT,FLAG=NO   With headings\n         ICM   R0,15,PCTNEST       Still an IF stack?\n         BNP   MAINRCTS            No\n         $ERR  NODO,8,FLAG=NO      Yes, kill it\n*\nMAINRCTS TM    PCTF4,PWAITING      Previous line waiting?\n         BZ    *+12                No\n         BAL   R14,LINPRINT        Yes, Print it\n         NI    PCTF4,255-PWAITING  and clear flag\n         CLI   PCTRC+3,X'08'       What is highest RC so far\n         BL    MAINETRC            Less than 8, O.K. To start copy\n         $ERR  TERM,12,GO=ADDSTATS,FLAG=NO 8+, set to 12 and terminate\n*\nMAINETRC B     MAINUBFS            No-op if DEBUG\n         $CALL SNAPIT              SNAP our code\n*\nMAINUBFS LA    R2,PCTUBFL1         Point at address of user buffers\n         LA    R3,26               Set count\n         LA    R4,PCTUBFA          Point at 1st buffer address\n*\nMAINUBFL CLC   0(4,R2),=F'-1'      Buffer needed here\n         BE    MAINUBFG            Yes, go get one\n*\nMAINUBFB LA    R2,4(,R2)           No, bump\n         LA    R4,4(,R4)           .\n         BCT   R3,MAINUBFL         Loop till all examined\n         B     MAINCEX             Exit now\n*\nMAINUBFG L     R0,PCTUBFSZ         Get size of buffer\n         ST    R0,0(R2)            Save length\n         GETMAIN R,LV=(0)          Go get one\n         ST    R1,0(R4)            Save its address\n         B     MAINUBFB            Continue\n*\nMAINCEX  GETMAIN R,LV=12           Get a RESET block\n         MVC   0(4,R1),PCTRESET    Add to RESET chain\n         ST    R1,PCTRESET         .\n         LA    R0,PCTMACNT         Add address to be reset\n         ST    R0,4(R1)            .\n         MVC   8(4,R1),PCTMACNT    Add value to be put back\n         $RET  0                   Compile done\n         TITLE 'MSG39FMT - Format FCB stats message'\n*---------------------------------------------------------------------+\n*        Format the statistics message for an FCB                     |\n*---------------------------------------------------------------------+\n*\nMSG39FMT $PROC\n         ICM   R2,8,FCBORECF       Get RECFM\n         SRL   R2,30               Shift to Lo-order\n         LA    R1,=C'*VFU'         Point at string\n         AR    R1,R2               Now point at specific character\n         L     R2,=A(ERRTX39)      Address message\n         MVC   28(5,R2),BLANKS     Clear RECFM area\n         MVC   28(1,R2),0(R1)      Stuff in RECFM\n         L     R1,=A(ERRTX39)      Address message\n         LA    R2,29(,R1)          Point past it\n*\nMSGTB    TM    FCBORECF,X'10'      Blocked ?\n         BNO   MSGTS\n         MVI   0(R2),C'B'\n         LA    R2,1(R2)\n*\nMSGTS    TM    FCBORECF,X'08'      Spanned ?\n         BNO   MSGTA\n         MVI   0(R2),C'S'\n         LA    R2,1(R2)\n*\nMSGTA    TM    FCBORECF,X'04'      ASA ?\n         BNO   MSGTM\n         MVI   0(R2),C'A'\n         LA    R2,1(R2)\n*\nMSGTM    TM    FCBORECF,X'02'      Machine ?\n         BNO   MSGTT\n         MVI   0(R2),C'M'\n         LA    R2,1(R2)\n*\nMSGTT    TM    FCBORECF,X'20'      Track overflow ?\n         BNO   MSGREX\n         MVI   0(R2),C'T'\n         LA    R2,1(R2)\n*\nMSGREX   LH    R2,FCBOLREC         Get LRECL\n         CVD   R2,DBL              Convert it\n         UNPK  42(5,R1),DBL+5(3)   Put in msg\n         OI    46(R1),X'F0'        Pretty it up\n         LH    R2,FCBOBLK          Get BLKSIZE\n         CVD   R2,DBL              Convert it\n         UNPK  58(5,R1),DBL+5(3)   Put it in msg\n         OI    62(R1),X'F0'        Pretty it up\n         MVC   18(2,R1),=C'PS'     Set to PS for now\n         $RET  0                   Now return\n         $PEND\n         TITLE 'MSG52FMT - Format FCB volsers'\n*---------------------------------------------------------------------+\n*        Format the volser's used for an FCB                          |\n*---------------------------------------------------------------------+\n*\nMSG52FMT $PROC\n         MVC   FCBNVOLS(31),FCBJFCB+JFCBNVOL-JFCB\n         L     R1,=A(ERRTX52)      Get address of text\n         LA    R2,21(,R1)          Point at list-7\n         MVI   7(R2),C' '          Blank it out\n         MVC   8(34,R2),7(R2)\n         CLI   FCBNVOLS,X'00'      Any volumes?\n         BE    MSG52EX0            No, return and say so\n         MVI   MSG52CLS,C')'       Set close default\n         CLI   FCBNVOLS,X'05'      More than 5\n         BNH   MSG52LOW            No\n         MVI   MSG52CLS,C'+'       Yes, change default close character\n         MVI   FCBNVOLS,X'05'      And force to only 1st 5 vols\n*\nMSG52LOW SR    R1,R1               Clear BCT reg\n         IC    R1,FCBNVOLS         Get number of volsers\n         LA    R3,FCBVOLS-6        Init for loop\n*\nMSG52LOP LA    R2,7(,R2)           Bump in MSG52\n         LA    R3,6(,R3)           Bump in FCBVOLS\n         MVC   0(6,R2),0(R3)       Move in one volser\n         MVI   6(R2),C','          And a comma\n         BCT   R1,MSG52LOP         And loop back if not done\n         MVC   6(1,R2),MSG52CLS    If done, close off string\n         $RET  4                   And go back +4\n*\nMSG52EX0 $RET  0                   Return +0\n         $PEND\n         TITLE 'GETNEXT - Command processor'\n*---------------------------------------------------------------------+\n*        G E T N E X T   C o m m a n d   P r o c e s s o r            |\n*---------------------------------------------------------------------+\n*\nNEXTREC  $PROC\n         USING KWDSECT,R14\n         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address\n         $CALL DBGADD              Go add DEBUG code\n         MVC   NXTEOF(12),NXTEOFD  Set EOF default\n         MVC   NXTGFCBA,PCT1FCB    And FCB default\n         MVI   NXTBFTYP,X'00'      Set default to NOCOPYBUFF\n         MVI   NXTFLAG,X'00'       Reset flag\n*---------------------------------------------------------------------+\n*        Loop processing all GETNEXT operands                         |\n*---------------------------------------------------------------------+\n*\nNEXTLOOP $CALL GETNEXT             Get next word, (if any).\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    NEXTGEN             Yes, go gen some stuff\n         TM    WFLAG1,WPREF+WTRLR  Invalid format?\n         BNZ   BADKWORD            Yes, kill it\n         TM    WFLAG1,WWRD1        Got WRD1?\n         BNO   BADKWORD            Yes, kill it\n         TM    WRD1F2,OPRKW+OPRKWV Valid KW?\n         BNO   BADOPTYP            No, kill it\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWOPRAND+KWSUBVAL Valid type?\n         BNO   BADKWORD            No, sorry\n         CLI   KWNUM,X'26'         Handle the COPYBUFF KW collision\n         BE    NEXTBR              .\n         MVN   KWNUM,=X'00'        Clear lo-order nibble\n         CLI   KWNUM,X'70'         Valid NEXTREC KW?\n         BNE   BADKWORD            No, sorry\n*\nNEXTBR   L     R2,KWD2             Get address of routine\n         BR    R2                  Branch by type\n*---------------------------------------------------------------------+\n*        Process the COPYBUFF operand                                 |\n*---------------------------------------------------------------------+\n*\nNEXTBUFF TM    WRD1F2,OPRKWOPV     Valid sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Yes, point at answer area\n         CLI   KWNUM,X'3F'         ON/OFF YES/NO ?\n         BNE   BADKWORD            Sorry\n         L     R2,KWD2             Pick up Yes/No index\n         B     *(R2)               Branch\n         B     NEXTBFYS            YES/ON\n         B     NEXTBFNO            NO/OFF\n*\nNEXTBFNO MVI   NXTBFTYP,X'00'      Flag as COPYBUFF(NO)\n         B     NEXTBFDN            Continue\n*\nNEXTBFYS MVI   NXTBFTYP,X'80'      Flag as COPYBUFF(YES)\n*\nNEXTBFDN OI    NXTFLAG,NXTBSEEN    Flag as COPYBUFF seen\n         OI    PCTF1,IPCOPY        Force separate output buffer\n         B     NEXTLOOP            Continue\n*---------------------------------------------------------------------+\n*        Process the EOF(label) operand                               |\n*---------------------------------------------------------------------+\n*\nNEXTEOF  TM    WRD1F2,OPRKWOP      Got a (...) operand?\n         BZ    BADOPTYP            No, sorry\n         MVC   NXTEOF(12),WRD1L2   Swap on top of default\n         B     NEXTLOOP            Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the FILE(ddname) operand                             |\n*---------------------------------------------------------------------+\n*\nNEXTFILE TM    WRD1F2,OPRKWOP      Got a (...) operand?\n         BZ    BADOPTYP            No, sorry\n         OI    PCTF3,INPUT         Make this DDname count\n         OI    NXTFLAG,NXTFSEEN    Flag as FILE(...) seen\n         TM    NXTFLAG,NXTBSEEN    COPYBUFF(YES/NO) seen?\n         BO    NEXTSDCB            Yes, go set DCB address\n         CLC   WRD1TXT2(6),MDINPT1+2 Is this INPUT1?\n         BNE   NEXTSDCB            No, skip\n         MVC   NXTBFTYP,PCTBFCDF   Set COPYBUFF as per default\n*\nNEXTSDCB $CALL DCBI1BLD,WRD1L2     Go setup input DCB\n         B     BADDCB              Error, too bad\n         ST    R1,NXTGFCBA         Save address of FCB area\n         B     NEXTLOOP            Continue\n         EJECT\n*---------------------------------------------------------------------+\n*        Now generate the code for GETNEXT                            |\n*---------------------------------------------------------------------+\n*\nNEXTGEN  TM    NXTFLAG,NXTFSEEN    Was FILE(...) seen?\n         BO    NEXTGNIT            Yes, leave BUFFCOPY alone\n         TM    NXTFLAG,NXTBSEEN    COPYBUFF specified?\n         BO    NEXTGNIT            Yes, don't default it\n         MVC   NXTBFTYP,PCTBFCDF   No, set COPYBUFF as per default\n*\nNEXTGNIT MVC   NXTGRESM(1),NXTBFTYP Set buffer type\n         $ADD  NXTG999-NXTGBAL1,NXTGBAL1\n         LA    R2,NXTGREST-NXTGBAL1(,R1) Get resume address\n         STCM  R2,7,NXTGRESM-NXTGBAL1+1(R1) Shove in pgm area\n         LA    R2,NXTGEOFA-NXTGBAL1(,R1) Set up EOF address\n         $CALL LBLOGEN,NXTEOF,(R2) .\n         B     EXITGOK             Go to common command exit\n*        EJECT\n*---------------------------------------------------------------------+\n*        GETNEXT routine work areas                                   |\n*---------------------------------------------------------------------+\n         CNOP  2,4\n*\nNXTGBAL1 BALR  R15,0               Get locally addressable\nNXTGSAVE MVC   PCTPGMS,PCTPGM      Save PCTPGM address\nNXTGSWAP MVC   PCTPGM,NXTGRESM-NXTGSAVE(R15) Swap in resume address\nNXTGBAL2 BAL   R15,COPRETN-COPYDATA(R8) Go to 'COPRETN' to read record\nNXTGRESM DC    XL4'00'             Address of code to resume at\nNXTGFCBA DC    XL4'00'             Address of FCB area\nNXTGEOFA DC    XL4'00'             Address of EOF label\nNXTGREST MVC   PCTPGM,PCTPGMS      Restore original PCTPGM address\nNXTG999  EQU   *                   End of model code\nNXTEOFD  DC    H'3',CL10'EOJ'      Default value for reset\nNXTEOF   DC    H'0',CL10' '        Current GETNEXT EOF value\nNXTBFTYP DC    X'00'               COPYBUFF type requested\nNXTFLAG  DC    X'00'               Scanning flags\nNXTBSEEN       EQU   X'80'         COPYBUFF/NOCOPYBUFF seen\nNXTFSEEN       EQU   X'40'         FILE(...) seen\n         DROP  R14\n         $PEND\n         TITLE 'OPBLDPRF - Build base pointer for an oprand'\n*---------------------------------------------------------------------+\n*        Build OPGEN's base pointer based of the prefix or a default  |\n*        ===========================================================  |\n*                                                                     |\n*        Called:   $CALL OPBLDPRF                                     |\n*                                                                     |\n*        Operands: none                                               |\n*                                                                     |\n*        Returns:  +0 if unable to complete successfully              |\n*                  +4 if completed O.K.                               |\n*                                                                     |\n*                  If O.K. OPGBASE has been completed.                |\n*                                                                     |\n*        Notes:    Assumes the following variables are setup on       |\n*                  input:                                             |\n*                                                                     |\n*                  WFLAG1    - Basic answers about what was found     |\n*                              i.e. Prefix, word, trailer,            |\n*                              +/- operand, etc.                      |\n*                  WFLAG2    - What is allowable in context and       |\n*                              options re: genn'ed code.              |\n*                  PREF....  - From PARSE. | \\                        |\n*                  WRD1....  -   \"    \"    |==\\   Mapped by           |\n*                  WRD2....  -   \"    \"    |==/   OPRDSECT            |\n*                  TRLR....  -   \"    \"    | /                        |\n*---------------------------------------------------------------------+\n*\nOPBLDPRF $PROC\n         USING KWDSECT,R14\n         TM    WFLAG1,WPREF        Was a prefix coded?\n         BO    OPBDECOD            Yes, go process it\n         OI    WFLAG1,WPREF        No, lets build a default\n         TM    WFLAG2,WIPDEF       Should we default an INPUT1?\n         BZ    OPBDEFOP            No, make it the O/P buffer\n         MVC   PREFNUM1,=F'1'      Create an INPUT1 prefix\n         MVI   PREFF2,OPRNUM       .\n         B     OPBDECOD            Continue\n*\nOPBDEFOP MVC   PREFL,=H'5'         Create an OBUFF prefix\n         MVC   PREFTXT,=C'OBUFF'   .\n         MVI   PREFF2,OPRKW+OPRKWV .\n         $CALL KWRDSRCH,PREFL,PREFKW1 Go get it's KW entry\n         B     *+4                 +0 Errors are impossible, ignore it\n*\nOPBDECOD TM    PREFF2,OPRKW+OPRKWV A valid keyword?\n         BNO   OPBNTO              No, then should be a ddname type\n         LA    R14,PREFKW1         Point at KW answer area\n         CLI   KWNUM,X'E3'         Was it OBUFF: ?\n         BNE   OPBTUB              No, try UBUFFx\n         MVC   OPGBASE,=A(PCTOUTPT-(FCBRECAD-FCBDSECT)) Kludge addr.\n         MVI   OPGBASE,X'0A'       .\n         TM    WFLAG2,WIPDEF       Is this an INPUT reference?\n         BZ    OPBEX4              No, just exit, else,\n*\nOPBSFLG  OI    PCTF1,IPCOPY        Flag for two buffers\n*\nOPBEX4   $RET   4                  And return\n*\nOPBEX0   $RET  0                   Return with error\n*\nOPBNTO   TM    PREFF2,OPRNUM       Numeric?\n         BZ    OPBNTOC             No, just call\n         CLC   PREFNUM1,=F'1'      The silly one?\n         BE    OPBNTOD1            Yes\n         BL    OPBEX0              Zero? Kill it\n         CLC   PREFNUM1,=F'9'      Over max?\n         BH    OPBEX0              Yes, also kill it\n         MVC   PREFL,=H'6'         No\n         MVC   PREFTXT,=C'INPUT'   Build it\n         MVC   PREFTXT+5,PREFNUM1+3\n         OI    PREFTXT+5,X'F0'\n         B     OPBNTOC             Done, go call\n*\nOPBNTOD1 MVC   PREFL(12),MDINPT1   Set default\n*\nOPBNTOC  $CALL CVOTOFCB,PREFNUM1   Go get the prefix's FCB address\n         B     OPBEX0              +0 Error, couldn't convert\n         B     OPBEX4              And exit now\n*\nOPBTUB   CLI   KWNUM,X'E4'         Was it UBUFFx?\n         BNE   OPBEX0              No, kill it\n         MVC   OPGBASE,KWD2        Move base address\n         MVC   OPGBASE(1),KWD3+3   And buffer index\n         L     R1,KWD3             Get index again\n         SLL   R1,2                x 4\n         LA    R1,PCTINPL1-4(R1)   Point at length field\n         MVC   0(4,R1),=F'-1'      Flag as GETMAIN needed\n         B     OPBEX4              Now exit\n         DROP  R14\n         $PEND\n         TITLE 'OPGEN - Gen code to point at an operand'\n*---------------------------------------------------------------------+\n*        Generate the code to point at an operand                     |\n*        ========================================                     |\n*                                                                     |\n*        Called:   $CALL OPGEN                                        |\n*                                                                     |\n*        Operands: none                                               |\n*                                                                     |\n*        Returns:  +0 if unable to complete successfully              |\n*                  +4 if completed O.K.                               |\n*                                                                     |\n*        Notes:    Assumes the following variables are setup on       |\n*                  input:                                             |\n*                                                                     |\n*                  WFLAG1    - Basic answers about what was found     |\n*                              i.e. Prefix, word, trailer,            |\n*                              +/- operand, etc.                      |\n*                  WFLAG2    - What is allowable in context and       |\n*                              options re: genn'ed code.              |\n*                  PREF....  - From PARSE. | \\                        |\n*                  WRD1....  -   \"    \"    |==\\   Mapped by           |\n*                  WRD2....  -   \"    \"    |==/   OPRDSECT            |\n*                  TRLR....  -   \"    \"    | /                        |\n*---------------------------------------------------------------------+\n*\nOPGEN    $PROC\n         USING KWDSECT,R14\n*---------------------------------------------------------------------+\n*        Check the basic validity of the operands.                    |\n*---------------------------------------------------------------------+\n         TM    WFLAG1,WPREF        Validate the operands\n         BZ    *+12                to ensure we don't have any\n         TM    WFLAG2,WPREFOK      sub-fields we shouldn't have.\n         BZ    OPGENEX0\n         TM    WFLAG1,WWRD1\n         BZ    OPGVLTRL\n         TM    WRD1F2,OPRLIT\n         BZ    OPGVLTRL\n         TM    WFLAG2,WLITOK\n         BZ    OPGENEX0\n*\nOPGVLTRL TM    WFLAG1,WTRLR\n         BZ    OPGSTAB\n         TM    WFLAG2,WTRLROK\n         BO    OPGSTAB             Operands look O.K., continue\n*\nOPGENEX0 $RET  0                   Return +0 to show error status\n         EJECT\n*---------------------------------------------------------------------+\n*        Setup to gen either A-operand or B-operand as requested.     |\n*---------------------------------------------------------------------+\n*\nOPGSTAB  NC    OPGICM1(L'OPGMASK),OPGMASK Clear out prev regs from code\n         TM    WFLAG2,WAOP         AREG requested?\n         BZ    *+14                No, BREG\n         OC    OPGICM1(L'OPGMASK),OPGAREG Set to AREG\n         B     *+10                Continue\n         OC    OPGICM1(L'OPGMASK),OPGBREG Set to BREG\n         MVC   OPGBASE,ZEROS       Zero base/displacement\n         MVC   OPGDISPL,ZEROS      .\n*---------------------------------------------------------------------+\n*        If a literal, then gen it and exit.                          |\n*---------------------------------------------------------------------+\n         TM    WRD1F2,OPRLIT       A literal?\n         BZ    OPGTNUM             No, go try as numeric\n         TM    WFLAG2,WIPDEF       A source field?\n         BZ    OPGBDDST            No, kill it\n*\nOPGGLIT  $CALL LITPOOL,WRD1L       Go try it as a literal\n         B     OPGLITOK            +00 O.K.\n         B     BADLITBT            +04 Bad type\n         B     BADLITBH            +08 Bad Hex\n         B     BADLITBL            +12 Bad length\n         B     BADLITBQ            +16 Bad quotes\n         B     BADLITBN            +20 Bad numerics\n*\nOPGLITOK MVC   OPGBASE,LITA        Create pointer to literal\n         MVC   OPGDISPL,ZEROS      Set displacement to zero\n         $ADD  OPGICM2-OPGCODE,OPGCODE Add code to program\n         ST    R1,OPGCADDR         Save code address\n         NI    PCTIOFLG,255-IOPACKED Set packed flag as appropriate\n         CLI   LITT,C'P'           A packed decimal literal\n         BNE   *+8                 No, skip\n         OI    PCTIOFLG,IOPACKED   Yes, remember that\n         L     R15,LITL            Pick up length\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         BAL   R14,OPGALCON        Go set A if no conflicts\n         B     OPGOPLEN            Continue\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n         B     OPGOPLEN            Go see if length is overridden\n*\nOPGENEX4 L     R1,OPGCADDR         Pass back address of genn'ed code\n         $RET  4\n         EJECT\n*---------------------------------------------------------------------+\n*        Not a literal, try a numeric address next                    |\n*---------------------------------------------------------------------+\n*\nOPGTNUM  TM    WRD1F2,OPRNUM       Is it numeric?\n         BZ    OPGTKW              No, go try as a KW\n         ICM   R1,15,WRD1NUM1      Get the number\n         BNZ   OPGMREL             If non-zero, go make relative\n         ST    R1,OPGDISPL         Stuff it in code\n         IC    R1,WFLAG2           Now set IOFLOATA/IOFLOATB in flags\n         N     R1,=A(WAOP+WBOP)    depending on which of WAOP/WBOP are\n         STC   R1,*+5              on in WFLAG2. Note: The EQU's must\n         OI    PCTIOFLG,0          be the same for this to work.\n         OI    WFLAG2,WPMOK        Allow +/- operands\n         B     OPGDOPRF            Continue\n*\nOPGMREL  BCTR  R1,0                Make it relative\n         ST    R1,OPGDISPL         Save in code\n*---------------------------------------------------------------------+\n*        Had a  number, go process it's prefix (or default)           |\n*---------------------------------------------------------------------+\n*\nOPGDOPRF $CALL OPBLDPRF            Go setup prefix (i.e. OPGBASE)\n         B     OPGENEX0            +0 Error, something wrong in prefix\n         L     R1,OPGBASE          +4 Now adjust base -> record address\n         AL    R1,=A(FCBRECAD-FCBDSECT)\n         ST    R1,OPGBASE          Put it back\n         TM    WFLAG1,WPLUS+WMINUS +4 O.K. then, was a +- value coded?\n         BNZ   OPGPMT              Yes, go see if valid\n         CLC   OPGDISPL,=F'1'      Was this pos 1-2 of the buffer?\n         BH    OPGSTUFF            No, continue\n         CLI   OPGBASE,X'01'       INPUT1 buffer?\n         BE    *+12                Yes, see if RECFM=V\n         CLI   OPGBASE,X'0A'       OBUFF  buffer?\n         BNE   OPGSTUFF            No, skip\n         TM    DEFRECFM,X'80'      RECFM=F or U?\n         BO    OPGSTUFF            Yes, skip\n         OI    PCTF1,IPCOPY        No, V, force two buffers\n*\nOPGSTUFF $ADD  OPGENDC-OPGCODE,OPGCODE No, add code to program\n         ST    R1,OPGCADDR         Save code address\n         B     OPGOPLEN            and exit\n         EJECT\n*---------------------------------------------------------------------+\n*        If a  +/- adjustment present, validate and process it.       |\n*---------------------------------------------------------------------+\n*\nOPGPMT   TM    WFLAG2,WPMOK        Is +/- allowable?\n         BZ    OPGENEX0            No, sorry\n         TM    WRD2F2,OPRNUM       Is +/- value numeric\n         BZ    OPGPMTK             No, go try KW\n         L     R14,WRD2NUM1        Yes, get it in register\n         TM    WFLAG1,WPLUS        Was it plus?\n         BO    *+6                 Yes, leave alone\n         LCR   R14,R14             No, change its sign\n         L     R1,OPGDISPL         Yes, adjust OPGDISPL\n         AR    R1,R14              .\n         ST    R1,OPGDISPL         .\n         B     OPGSTUFF            Go stuff code and exit\n*\nOPGPMTK  TM    WRD2F2,OPRKW+OPRKWV Is +/- operand a valid KW?\n         BNO   OPGENEX0            No, kill it\n         LA    R14,WRD2KW1         Yes, point at KW answer area\n         TM    KWF2,KWPMVALU       A valid +/- KW ?\n         BZ    OPGENEX0            No, sorry about that\n         CLI   KWGTYPE,KWPCTFLD    A PCT field?\n         BNE   OPGENEX0            Sorry, it's the only one supported\n         $ADD  OPGENDC-OPGCODE,OPGCODE Now add code to program\n         ST    R1,OPGCADDR         Save code address\n         MVC   OPGADD1+2-OPGCODE(2,R1),KWD1+2   Copy displ. to ADD1\n         OI    OPGADD1+2-OPGCODE(R1),PCTBASE*16 OR in the PCTBASE\n         TM    WFLAG2,WAOP         Genning A-operand?\n         BZ    *+12                No, B, skip\n         OI    PCTIOFLG,IONOAADJ   Yes, say no adjust\n         B     OPGOPLEN            Continue\n         OI    PCTIOFLG,IONOBADJ   Don't adjust B-operand\n         B     OPGOPLEN            and exit\n*---------------------------------------------------------------------+\n*        If a  KW operand, process that.                              |\n*---------------------------------------------------------------------+\n*\nOPGTKW   TM    WRD1F2,OPRKW+OPRKWV Valid keyword?\n         BNO   OPGENEX0            No, sorry, you lose\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF2,KWOPRPTR       Valid as an operand pointer?\n         BZ    OPGENEX0            No, lose again!\n         TM    KWF2,KWPMADJ        Is is +/- adjustable?\n         BZ    OPGTKWPM            No, skip\n         OI    WFLAG2,WPMOK        Yes, remember it\n         B     OPGTKWI             Continue\n*\nOPGTKWPM TM    WFLAG1,WPLUS+WMINUS Were +/- specified?\n         BNZ   BADOPTYP\n*\nOPGTKWI  CLI   KWNUM,X'E2'         UCTRx KW?\n         BNE   *+8                 No, skip\n         OI    PCTIOFL2,IOUCTRX    Set for CR type compare\n         TM    WFLAG2,WIPDEF       A source field?\n         BO    OPGTKWBR            Yes, any keyword is valid\n         TM    KWF2,KWDEST         No, dest, is this KW valid as DEST\n         BZ    OPGBDDST            No, error\n         CLI   KWNUM,X'E2'         UCTRx KW?\n         BNE   *+12                No, skip\n         OI    PCTF7,UCTRDUMP      Set for UCTRx dump at EOJ\n         OI    PCTIOFL2,IOUCTRX    Set for CR type compare\n         MVC   ALTAKWLN,KWD3       Save KW length to match B-operand\n         B     OPGTKWBR            Yes, continue\n*\nOPGBDDST $ERR  BDDST,8,SKIP        No way Jose'\n         EJECT\n*---------------------------------------------------------------------+\n*        Branch by type of KW entry.                                  |\n*---------------------------------------------------------------------+\n*\nOPGTKWBR SR    R15,R15             Clear a reg\n         IC    R15,KWGTYPE         Get type index\n         B     *(R15)              Branch by type\n         B     OPGKWFCB            FCBFLD type\n         B     OPGKWFCB            FCBPTR type\n         B     OPGKWADR            ADRFLD type\n         B     OPGKWADR            ADRPTR type\n         B     OPGKWPCT            PCTFLD type\n         B     OPGKWPCT            PCTADR type\n*---------------------------------------------------------------------+\n*        An FCB based KW.                                             |\n*---------------------------------------------------------------------+\n*\nOPGKWFCB TM    WFLAG1,WPREF        Is there a prefix?\n         BO    OPGKWT4C            Yes, skip\n         MVC   PREFL(10),MDINPT1   No, fudge as INPUT1\n         MVC   PREFNUM1,=F'1'      .\n         OI    PREFF2,OPRNUM+OPRSPECN\n*\nOPGKWT4C $CALL CVOTOFCB,PREFNUM1   Go get it's FCB address\n         B     OPGENEX0            +0 Couldn't do it\n         LA    R14,WRD1KW1         +4 O.K. Point at KW answer area\n         L     R1,OPGBASE          Adjust by offset in FCB\n         AL    R1,KWD1             .\n         ST    R1,OPGBASE          Stuff it back\n         L     R15,KWD3            Pick up length\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         BAL   R14,OPGALCON        Go set A if no conflicts\n         B     *+8                 Continue\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n*\nOPGKWSTF $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program\n         ST    R1,OPGCADDR         Save code address\n         LA    R14,WRD1KW1         Point at KW answer area\n         CLI   KWGTYPE,KWFCBPTR    Is it an indirect address?\n         BNE   OPGKWNIN            No, skip indirect load\n         $ADD  4,OPGICM2           Add the indirect load\n*\nOPGKWNIN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?\n         BZ    OPGOPLEN            No, exit\n         BAL   R14,OPGPMADJ        Go process +/- adjustment\n         B     OPGOPLEN            Then exit\n         EJECT\n*---------------------------------------------------------------------+\n*        A fixed address KW.                                          |\n*---------------------------------------------------------------------+\n*\nOPGKWADR MVC   OPGBASE,KWD1        Put address in code\n         L     R15,KWD3            Pick up length\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         BAL   R14,OPGALCON        Go set A if no conflicts\n         B     *+8                 Continue\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n*\nOPGKWAST $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program\n         ST    R1,OPGCADDR         Save code address\n         LA    R14,WRD1KW1         Point at KW answer area\n         CLI   KWGTYPE,KWADRPTR    Is it an indirect address?\n         BNE   OPGKWNNN            No, skip indirect load\n         $ADD  4,OPGICM2           Add the indirect load\n*\nOPGKWNNN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?\n         BZ    OPGOPLEN            No, exit\n         BAL   R14,OPGPMADJ        Go process +/- adjustment\n         B     OPGOPLEN            and exit\n*---------------------------------------------------------------------+\n*        A PCT based KW.                                              |\n*---------------------------------------------------------------------+\n*\nOPGKWPCT TM    KWF2,KWOFFSET       A keyword type offset?\n         BO    OPGKWPOF            Yes, split off here\n*\nOPGKWPNK LA    R1,PCT              Convert displ. to actual addr\n         A     R1,KWD1             .\n         ST    R1,OPGBASE          Save in code\n         L     R15,KWD3            Pick up length\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         BAL   R14,OPGALCON        Go set A if no conflicts\n         B     *+8                 Continue\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n*\nOPGKWPST $ADD  OPGICM2-OPGCODE,OPGCODE Now add code to program\n         ST    R1,OPGCADDR         Save code address\n         LA    R14,WRD1KW1         Point at KW answer area\n         CLI   KWGTYPE,KWPCTPTR    Is it an indirect address?\n         BNE   OPGKWNPN            No, skip indirect load\n         $ADD  4,OPGICM2           Add the indirect load\n*\nOPGKWNPN TM    WFLAG1,WPLUS+WMINUS Was a +/- operand coded?\n         BZ    OPGOPLEN            No, exit\n         BAL   R14,OPGPMADJ        Go process +/- adjustment\n         B     OPGOPLEN            and exit\n*\nOPGKWPOF TM    WFLAG1,WPREF        Better have a prefix\n         BZ    OPGKWPNK            No, back to the old way\n         $CALL OPBLDPRF            Go setup prefix (i.e. OPGBASE)\n         B     OPGENEX0            +0 Error, something wrong in prefix\n         MVC   ALTAKWLN,ZEROS      +4 Forget now that it was a KW\n         LA    R14,WRD1KW1         Point at KW answer area\n         L     R1,OPGBASE          Now adjust base -> record address\n         AL    R1,=A(FCBRECAD-FCBDSECT)\n         ST    R1,OPGBASE          Put it back\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         MVI   OREGALEN,X'00'      Yes, clear A length then\n         B     *+10                Continue\n         MVC   OREGBLEN,ZEROS      Zero B then\n         $ADD  OPGENDC-OPGCODE,OPGCODE Add code to program\n         ST    R1,OPGCADDR         Save code address\n         LA    R14,WRD1KW1         Point at KW answer area\n         L     R15,KWD1            Get displacement of field in PCT\n         AL    R15,=X'0000D000'    Add base of R13 for PCT\n         STCM  R15,3,OPGADD1+2-OPGCODE(R1) Modify compiled code\n         $ADD  2,OPGBCTR           Add BCTR to cnvrt relative->actual\n         TM    WFLAG2,WAOP         AREG requested?\n         BO    OPGKWPOV            Yes, model code was correct\n         MVI   1(R1),BREG*16       No, swap it to BCTR BREG,0\n         B     OPGOPLEN            Continue\n*\nOPGKWPOV TM    PCTF3,COMPALTR      Compiling an ALTER command?\n         BZ    OPGOPLEN            No, continue\n         CLI   OPGBASE,X'01'       INPUT1 buffer?\n         BE    *+12                Yes, see if RECFM=V\n         CLI   OPGBASE,X'0A'       OBUFF  buffer?\n         BNE   OPGOPLEN            No, skip\n         TM    DEFRECFM,X'80'      RECFM=F or U?\n         BO    OPGOPLEN            Yes, skip\n         OI    PCTF1,IPCOPY        No, V, force two buffers\n         B     OPGOPLEN            Continue\n         EJECT\n*---------------------------------------------------------------------+\n*        Do the +/- adjustment for a KW if present and allowed.       |\n*---------------------------------------------------------------------+\n*\nOPGPMADJ TM    WFLAG2,WPMOK        Yes, allowed?\n         BZ    OPGENEX0            No, sorry\n         TM    WRD2F2,OPRNUM       Numeric?\n         BZ    OPGENEX0            No, sorry\n         $ADD  4,OPGADD1           Add the adjust code\n         MVC   2(2,R1),=X'F004'    Point ADD1 @ OPGDISPL\n         L     R1,OPGCADDR         Load basic code address\n         L     R2,WRD2NUM1         Get adjust number\n         TM    WFLAG1,WPLUS        Positive?\n         BO    *+6                 Yes, skip complement\n         LCR   R2,R2               Make negative\n         ST    R2,OPGDISPL-OPGCODE(R1) Shove in code\n         BR    R14                 Return\n*---------------------------------------------------------------------+\n*        See if optional length operand/DLM is present.               |\n*---------------------------------------------------------------------+\n*\nOPGOPLEN TM    WFLAG1,WTRLR        Is there even a trailer?\n         BZ    OPGENEX4            No, exit then\n         TM    TRLRF2,OPRNUM       A number?\n         BZ    OPGOTLIT            No, go see if a literal\n         L     R15,TRLRNUM1        Pick up length\n         TM    WFLAG2,WAOP         A-operand?\n         BZ    *+12                No, skip\n         BAL   R14,OPGALCON        Go set A if no conflicts\n         B     *+8                 Continue\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n         B     OPGENEX4            Now exit\n*\nOPGOTLIT TM    TRLRF2,OPRLIT       Is it a literal then ?\n         BNO   OPGOLKW             No, see if a KW\n         $CALL LITPOOL,TRLRL       Yep, go put in LITPOOL\n         B     OPGDLMLK            +00 O.K.\n         B     BADLITBT            +04 Bad type\n         B     BADLITBH            +08 Bad Hex\n         B     BADLITBL            +12 Bad length\n         B     BADLITBQ            +16 Bad quotes\n         B     BADLITBN            +20 Bad numerics\n*\nOPGDLMLK MVC   OPGLITSV,LITA       Save address of the literal\n         L     R6,LITL             Get number of bytes\n         LA    R3,256              Go get 256 bytes in Literal pool\n         LR    R4,R3               .\n         LA    R2,TRTABLE          .\n         $CALL LITSTUFF            Go get it\n         L     R5,OPGLITSV         Get address of the original literal\n         L     R2,LITA             Get address of gotten area\n         XC    0(256,R2),0(R2)     Clear it\n         L     R15,LITA            Pick up address of DLM table\n         TM    WFLAG2,WAOP         A-operand?\n         BO    BADOPTYP            Yes, shouldn't have been\n         BAL   R14,OPGBLCON        Go set B if no conflicts\n         MVC   OREGDLMT,LITA+1     Put DLM table address in OREGDLMT\n         OI    PCTIOFLG,IODLML     Set flag\n*\nOPGOLLTL SR    R3,R3               Clear a reg.\n         IC    R3,0(R5)            Pick up the next character in DLM\n         AR    R3,R2               Index into TRTABLE\n         MVI   0(R3),X'FF'         Make it a DLM\n         LA    R5,1(,R5)           Bump\n         BCT   R6,OPGOLLTL\n         B     OPGENEX4            Now we can exit\n*\nOPGOLKW  TM    TRLRF2,OPRKW+OPRKWV Valid KW?\n         BNO   BADOPTYP            No, sorry\n         LA    R14,TRLRKW1         Yes, point at KW answer area\n         CLI   KWNUM,X'30'         An '='\n         BNE   OPGOLKW2            No, one last chance coming up\n         OI    PCTIOFLG,IONOEXPC   Yes, set NOEXPC flag then\n         B     OPGENEX4            And exit\n*\nOPGOLKW2 TM    KWF2,KWOFFSET       Allowable KW length?\n         BNO   BADOPTYP            No, sorry about that\n         TM    PCTF3,OPKWLEN       Already have one?\n         BO    ALTLCONF            Yes, too bad\n         L     R15,KWD1            Get displacement of field in PCT\n         AL    R15,=X'0000D000'    Add base of R13 for PCT\n         STCM  R15,3,ORLLCOD+2     Modify code to be inserted\n         OI    PCTF3,OPKWLEN       Flag as KW length operand\n         B     OPGENEX4            and exit\n*---------------------------------------------------------------------+\n*        Test for length conflicts (OPGALCON for A-operand)           |\n*                                  (OPGBLCON for B-operand)           |\n*                                                                     |\n*        Entered: R15 - Potential new value                           |\n*                 R14 - Return address                                |\n*---------------------------------------------------------------------+\n*\nOPGALCON CLI   OREGALEN,X'00'      A-operand already set?\n         BE    OPGALSET            No, just go set it thene\n         TM    WFLAG2,WIPDEF       Yes, source field?\n         BZ    OPGLCONF            No, Dest, kill it\n*\nOPGALSET STC   R15,OREGALEN        Set in the length\n         BR    R14                 and go back\n*\nOPGBLCON CLC   OREGBLEN,=H'0'      B-operand already set?\n         BE    OPGBLSET            No, just go set it thene\n         TM    WFLAG2,WIPDEF       Yes, source field?\n         BZ    OPGLCONF            No, Dest, kill it\n*\nOPGBLSET STCM  R15,7,OREGDLMT      Set in the length/DLM table address\n         BR    R14                 and go back\n*\nOPGLCONF $ERR  LCONF,8,SKIP        Kill this one\n*\nOPGLITSV DS    F\n         DROP  R14\n         $PEND\n         TITLE 'OPTIONS - Command processor'\n*---------------------------------------------------------------------+\n*        O P T I O N S   C o m m a n d   P r o c e s s o r            |\n*---------------------------------------------------------------------+\n*\nOPTIONS  $PROC\n         ICM   R1,15,PGMIC         Has program started?\n         BZ    OPTLOOP             No, all is well, continue\n         $ERR  BDOPT,8,SKIP        Yes, sorry, ignored\n         USING KWDSECT,R14\n*---------------------------------------------------------------------+\n*        Loop for each OPTIONS operand                                |\n*---------------------------------------------------------------------+\n*\nOPTLOOP  $CALL GETNEXT             Go get next word\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    OPTEXIT             Yes, exit\n         TM    WFLAG1,WPREF+WTRLR  Invalid format?\n         BNZ   BADOPTYP            Yes, kill it\n         TM    WRD1F2,OPRKW+OPRKWV+OPRKWOP Valid KW(...)?\n         BNO   BADKWORD            No, kill it\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWOPRAND       A valid type?\n         BZ    BADKWORD            No, sorry\n         CLI   KWNUM,X'91'         CBLKSIZE(91) is outside 4x range\n         BE    OPTDOBR             So we keep going\n         MVN   KWNUM,=X'00'        Clear lo-order nibble\n         CLI   KWNUM,X'40'         Valid OPTIONS KW?\n         BNE   BADKWORD            No, sorry\n*\nOPTDOBR  L     R2,KWD2             Get address of routine\n         BR    R2                  Branch by type\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the CBLKSIZE(...) operand                            |\n*---------------------------------------------------------------------+\n*\nOPTCBLK  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTCBON             ON/YES\n         B     OPTCBOFF            OFF/NO\n*\nOPTCBON  OI    PCTF8,CBLKSIZE      Ensure CBLKSIZE is ON\n         B     OPTLOOP             Keep on truckin'\n*\nOPTCBOFF NI    PCTF8,255-CBLKSIZE  Set for NO stats\n         B     OPTLOOP             Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the MEMBSTAT(...)  operand                           |\n*---------------------------------------------------------------------+\n*\nOPTPDSST TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTPDON             ON/YES\n         B     OPTPDOFF            OFF/NO\n*\nOPTPDON  OI    PCTF8,PDSSTATS      Ensure STATS is ON\n         B     OPTLOOP             Keep on truckin'\n*\nOPTPDOFF NI    PCTF8,255-PDSSTATS  Set for NO stats\n         B     OPTLOOP             Keep on truckin'\n*---------------------------------------------------------------------+\n*        Process the OPCHECK(...) operand                             |\n*---------------------------------------------------------------------+\n*\nOPTOPCHK TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTOPCON            ON/YES\n         B     OPTOPCOF            OFF/NO\n*\nOPTOPCON OI    PCTF6,OPCHECK       Ensure OPCHECK is ON\n         B     OPTLOOP             Keep on truckin'\n*\nOPTOPCOF NI    PCTF6,255-OPCHECK   Set for NO checking\n         B     OPTLOOP             Keep on truckin'\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the AUTOCOPY(...) operand                            |\n*---------------------------------------------------------------------+\n*\nOPTAUTO  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTAUON             ON/YES\n         B     OPTAUOFF            OFF/NO\n*\nOPTAUON  OI    PCTBFCDF,COPYBUFF   Ensure COPYBUFF is on\n         B     OPTLOOP             Keep on truckin'\n*\nOPTAUOFF NI    PCTBFCDF,255-COPYBUFF Set for NO COPYBUFF\n         B     OPTLOOP             Keep on truckin'\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the OBFORCE(...)  operand                            |\n*---------------------------------------------------------------------+\n*\nOPTOBFOR TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTOBON             ON/YES\n         B     OPTOBOFF            OFF/NO\n*\nOPTOBON  OI    PCTF1,IPCOPY        Force two buffers\n         B     OPTLOOP             Keep on truckin'\n*\nOPTOBOFF B     OPTLOOP             Ignore OFF requests\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the UBSIZE(nnn)   operand                            |\n*---------------------------------------------------------------------+\n*\nOPTUBUF  TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         TM    KWF2,KWNUMFUG       Numeric?\n         BZ    BADKWVAL            No, sorry\n         ICM   R1,15,WRD1NUM2      Yes, see if zero\n         BZ    BADKWVAL            It is, sorry\n         ST    R1,PCTUBFSZ         Save for use then\n         B     OPTLOOP             Continue\n*---------------------------------------------------------------------+\n*        Process the PARM(xx...)   operand                            |\n*---------------------------------------------------------------------+\n*\nOPTPARM  LH    R14,WRD1L2          Get length of field\n         LA    R15,WRD1TXT2        Point at data string\n         CLI   0(R15),C''''        Quoted string?\n         BNE   OPTPNQU             No, skip down\n         LA    R15,1(,R15)         Yes, strip off the quotes\n         BCTR  R14,0               .\n         BCTR  R14,0               .\n*\nOPTPNQU  CH    R14,=H'8'           Make sure not too long\n         BH    BADKWVAL            .\n         BCTR  R14,0               -1 for EX\n         EX    R14,*+4             Move it to PCT field\n         MVC   PCTUPARM(0),0(R15)  .\n         B     OPTLOOP             Continue\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the EOFFILL(...)  operand                            |\n*---------------------------------------------------------------------+\n*\nOPTEOFF  LA    R1,PCTEOFFL         Point at answer area\n         B     OPTLITER            Go to common code\n*---------------------------------------------------------------------+\n*        Process the PADCHAR(...)  operand                            |\n*---------------------------------------------------------------------+\n*\nOPTPADCH LA    R1,PCTPADCH         Point at answer area\n*---------------------------------------------------------------------+\n*        Process the literal operands for EOFFILL/PADCHAR             |\n*---------------------------------------------------------------------+\n*\nOPTLITER ST    R1,OPTPSAVE         Save answer address for a while\n         $CALL LITPOOL,WRD1L2      Go put in literal pool\n         B     OPTLITOK            +0  Good\n         B     BADLITBT            +4  Type no good\n         B     BADLITBH            +8  HEX no good\n         B     BADLITBL            +12 Length no good\n         B     BADLITBQ            +16 Quotes no good\n         B     BADLITBN            +20 Numeric no good\n*\nOPTLITOK L     R2,LITA             Point at literal\n         L     R1,OPTPSAVE         Point at answer area\n         MVC   0(1,R1),0(R2)       Copy 1st character\n         B     OPTLOOP             Done\n         EJECT\n*---------------------------------------------------------------------+\n*        Process EOFLABEL(...) operand                                |\n*---------------------------------------------------------------------+\n*\nOPTEOFL  L     R1,=A(NXTEOFD)      Point at answer area\n         LA    R2,WRD1L2           Point at text\n         CLC   WRD1L2,=H'10'       Within limits?\n         BH    OPTLBLSL            No, do specially\n         MVC   0(12,R1),WRD1L2     Copy to answer area\n         B     OPTLOOP             Done\n*\nOPTLBLSL MVC   0(2,R1),=H'10'      Set default length\n         L     R2,WRD1TXT2         Point at data\n         MVC   2(10,R1),0(R2)      Copy 1st 10 bytes\n         B     OPTLOOP             Done\n*---------------------------------------------------------------------+\n*        Process the DEFER(ddname) operand                            |\n*---------------------------------------------------------------------+\n*\nOPTDEFER TM    WRD1F2,OPRKWOP      Got a sub-operand?\n         BZ    BADOPTYP            No, error\n         MVC   DDNAME,BLANKS       Align in 8 byte area\n         LH    R15,WRD1L2          .\n         BCTR  R15,0               .\n         EX    R15,*+4             .\n         MVC   DDNAME(0),WRD1TXT2  .\n         CLC   WRD1L2(8),MDINPT1   Is it INPUT1?\n         BE    OPTBDDN             That's a no-no\n         CLC   WRD1L2(7),MDSYSI    Is it SYSIN?\n         BE    OPTBDDN             That's a no-no\n         CLC   WRD1L2(10),MDSYSP   Is it SYSPRINT?\n         BE    OPTBDDN             That's a no-no\n         LA    R3,PCTFCB           Load address of start of FCB chain\n*\nOPTFCBLP ICM   R7,15,0(R3)         Load next FCB address\n         BZ    OPTFCBNW            End of chain?, go add one to it\n         CLC   DDNAME,FCBDDNAM     See if we have this DDname already\n         BE    OPTLOOP             Yes, skip out\n         LR    R3,R7               Setup for chaining\n         B     OPTFCBLP            And try again\n*---------------------------------------------------------------------+\n*        GETMAIN and build an FCB                                     |\n*---------------------------------------------------------------------+\n*\nOPTFCBNW LA    R0,FCBLNGTH         Set length for GETMAIN\n         GETMAIN R,LV=(0)          Get an FCB area\n         LR    R7,R1               Put address of FCB in R7\n         ST    R7,0(R3)            Add to FCB chain\n         MVI   FCBCHAIN,X'00'      Zero area\n         MVC   FCBCHAIN+1(FCBDSNAM-FCBDSECT),FCBCHAIN\n         MVC   FCBDDNAM,DDNAME     Insert DDname\n         OI    FCBF1,FCBDOPEN+FCBSTATS Flag as def. OPEN + Stats\n         MVC   DCBHLREC,=H'32764'  Set max default high lrecl\n         B     OPTLOOP             Go get another kw\n*---------------------------------------------------------------------+\n*        Process the PDSMODE operand                                  |\n*                                                                     |\n*              N.B. This just gives this code something to do while   |\n*                   processing the OPTIONS statement since PDSMODE    |\n*                   MUST be specified via the PARM field. If this     |\n*                   stub were not here, OPTIONS would flag it as an   |\n*                   invalid keyword. See PARM field handling.         |\n*---------------------------------------------------------------------+\n*\nOPTPDSMD TM    WRD1F2,OPRKWOPV     Valid KW sub-operand?\n         BZ    BADKWORD            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area for sub-op\n         CLI   KWNUM,X'3F'         ON/OFF?\n         BNE   BADKWORD            No, kill it\n         L     R2,KWD2             Get type index\n         B     *(R2)               Branch by type\n         B     OPTPDSON            ON/YES\n         B     OPTPDSOF            OFF/NO\n*\nOPTPDSON OI    PCTF8,PDSMODE       Set PDSMODE on\n         B     OPTLOOP             Keep on truckin'\n*\nOPTPDSOF NI    PCTF8,255-PDSMODE   Set PDSMODE off\n         B     OPTLOOP             Keep on truckin'\n*\nOPTBDDN  $ERR  BDDN,8,SKIP\n*\nOPTEXIT  B     EXITGOK             We're done\nOPTPSAVE DS    F                   Temp save area\n         $PEND\n         TITLE 'PARSE - Parse a \"word\"'\n*---------------------------------------------------------------------+\n*        Parse a passed word into it's component pieces               |\n*        ==============================================               |\n*                                                                     |\n*        Called:   $CALL PARSE,word                                   |\n*                                                                     |\n*        Operands: word     - is standard 'word' format               |\n*                               i.e. H'nn',C'text'                    |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*                                                                     |\n*        Notes:    All answers are in the following areas:            |\n*                                                                     |\n*                  WFLAG1    - Basic answers about what was found     |\n*                              i.e. Prefix, word, trailer,            |\n*                              +/- operand, etc.                      |\n*                                                                     |\n*                  PREF....  - These areas are completed if the       |\n*                  WRD1....  - WFLAG1 status says they were detected. |\n*                  WRD2....  - Residual data may be present and must  |\n*                  TRLR....  - be ignored if no valid WFLAG1 is on.   |\n*                                                                     |\n*                              These areas are mapped by OPRDSECT.    |\n*---------------------------------------------------------------------+\n*\nPARSE    $PROC 1\n         L     R6,12(R8)           Point R6 at passed area\n         SR    R3,R3               Clear previous status\n         SR    R4,R4               .\n         SR    R5,R5               .\n         STM   R3,R5,PREFNUM1      .\n         STM   R3,R5,WRD1NUM1      .\n         STM   R3,R5,WRD2NUM1      .\n         STM   R3,R5,TRLRNUM1      .\n         MVI   PREFF1,WPREF        Reset type flags\n         MVI   WRD1F1,WWRD1        .\n         MVI   WRD2F1,WWRD2        .\n         MVI   TRLRF1,WTRLR        .\n         MVI   WFLAG1,X'00'        .\n         LH    R3,0(R6)            R3 > Length of word being processed\n         LA    R4,2(R6)            R4 > Start of word\n         MVI   TRTABLE+C':',X'08'  Reset TRTABLE delimiters\n         MVI   TRTABLE+C'''',X'04' .\n         MVI   TRTABLE+C'/',X'14'  .\n         MVI   TRTABLE+C'+',X'0C'  .\n         MVI   TRTABLE+C'-',X'10'  .\n         MVI   TRTABLE+C' ',X'18'  .\n         MVI   TRTABLE+C'(',X'1C'  .\n         MVI   TRTABLE+C')',X'1C'  .\n         LA    R7,WRD1NUM1         Set default operand area\n         ST    R7,PARSDFLT         .\n         PUSH  USING\n         USING OPRDSECT,R7         Make it addressable\n*---------------------------------------------------------------------+\n*        Do some fudges for LABEL:  handling\n*---------------------------------------------------------------------+\n         LR    R6,R4               See if last is a :\n         LR    R5,R3               .\n         TM    PCTF4,LABLLOOK      Looking for a LABEL?\n         BO    PARSLABL            Yes\n         LR    R15,R6              .\n         AR    R15,R5              .\n         BCTR  R15,0               .\n         CLI   0(R15),C':'         .\n         BNE   PARSSVST            No, continue\n         LR    R1,R15              Make it look like TRT result\n         LR    R15,R6              Ensure no other : inside word\n         CLI   0(R15),C':'         .\n         BE    PARSSVST            .\n         LA    R15,1(,R15)         .\n         CR    R15,R1              .\n         BNE   *-14                .\n         B     PARSCOLN            .\n*\nPARSLABL NI    PCTF4,255-LABLLOOK  Kill flag\n         B     PARSNDLM            Treat as one big word\n         EJECT\n*---------------------------------------------------------------------+\n*        Main PARSE Scanning Loop\n*---------------------------------------------------------------------+\n*\nPARSSVST LR    R6,R4               Setup working scan registers\n         LTR   R5,R3               .\n         BZ    PARSEEX             Exit if nothing left\n*\nPARSSCAN BCTR  R5,0                -1 for EX\n         SR    R2,R2               Clear R2\n         SR    R1,R1               and R1\n         EX    R5,PARSTRT1         Look for a delimiter\n         BZ    PARSNDLM            None, do default processing\n         B     *(R2)               Got a DLM, branch accordingly\n         B     PARSQT              ' (Quote) detected\n         B     PARSCOLN            : (Colon)     \"\n         B     PARSPLUS            + (Plus)      \"\n         B     PARSMINS            - (Minus)     \"\n         B     PARSSLSH            / (Slash)     \"\n         B     PARSNDLM              (Blank)     \"\n         B     PARSPARN            () Parenthesis\n*---------------------------------------------------------------------+\n*        Parenthesis detected, kill some delimiters\n*---------------------------------------------------------------------+\n*\nPARSPARN MVI   TRTABLE+C':',X'00'  Clear some delimiters\n         MVI   TRTABLE+C'+',X'00'  .\n         MVI   TRTABLE+C'-',X'00'  .\n         MVI   TRTABLE+C' ',X'18'  .\n         MVI   TRTABLE+C'(',X'00'  .\n         MVI   TRTABLE+C')',X'00'  .\n         B     PARSSVST            Start scan over\n*---------------------------------------------------------------------+\n*        No delimiter, remaining text goes to the default\n*---------------------------------------------------------------------+\n*\nPARSNDLM L     R7,PARSDFLT         Pick up the default answer area\n         OC    WFLAG1,OPRF1        Set WFLAG1\n         STH   R3,OPRL             Set the 'word' in the default\n         CH    R3,=H'10'           See if 'word' will fit\n         BH    *+14                No, make it a pointer then\n         MVC   OPRTXT,0(R4)        Yes, copy to operand area\n         B     PARSDFTY            and go to type it\n         ST    R4,OPRADDR          Save pointer to it\n         OI    OPRF2,OPRPTR        Flag it as pointer type\n*\nPARSDFTY CP    COMNTCTL,=P'0'      In SKIP mode?\n         BNE   PARSEEX             Yes, just exit\n         $CALL TYPEOPER,(R7)       Go set the type flags\n         TM    OPRF1,WWRD1         Is this the 'main' word?\n         BZ    PARSEEX             No, just exit\n         TM    OPRF2,OPRKWOP       KW(...) type?\n         BZ    PARSEEX             No, exit\n         OI    WFLAG1,WWRD2        Yes, flag it\n         B     PARSEEX             and exit\n         EJECT\n*---------------------------------------------------------------------+\n*        Quote found, process it                                      |\n*---------------------------------------------------------------------+\n*\nPARSQT   LR    R15,R1              Calc displacement of quote\n         SR    R15,R6              .\n         SR    R5,R15              Adjust remaining length\n         BZ    PARSNDLM            If null, bail out\n         CLI   1(R1),C''''         Double quote?\n         BNE   PARSNDQT            No\n         LA    R1,1(,R1)           Yes, step over it\n         SH    R5,=H'1'            Reduce length one more\n         BZ    PARSNDLM            If null, bail out\n*\nPARSNDQT BCTR  R5,0                -1 for EX length\n         L     R15,=A(TRTBLQ)      Get address of quote TRTable\n         LA    R1,1(,R1)           Step over the 1st quote\n         EX    R5,PARSTRT3         Look for end quote\n         BZ    PARSNDLM            None, bail out\n         LR    R15,R1              Calc displacement of ending quote\n         SR    R15,R4              .\n         LR    R5,R3               Pick up original length again\n         SR    R5,R15              Adjust remaining length\n         BCTR  R5,0                Fudge\n         LTR   R5,R5               See if zero\n         BZ    PARSNDLM            If null, bail out\n         LA    R6,1(,R1)           Swap to working scan reg\n         B     PARSSCAN            Resume scanning\n*---------------------------------------------------------------------+\n*        Colon found, process it\n*---------------------------------------------------------------------+\n*\nPARSCOLN MVI   TRTABLE+C':',X'00'  Remove : from delimiter status\n         LA    R7,WRD1NUM1         Setup next default\n         ST    R7,PARSDFLT         .\n         LA    R7,PREFNUM1         Swap operand to PREF area\n         B     PARSDO1             Go save answer values\n         EJECT\n*---------------------------------------------------------------------+\n*        Plus/ Minus found, process them\n*---------------------------------------------------------------------+\n*\nPARSPLUS OI    WFLAG1,WPLUS        Remember PLUS\n         B     *+8                 Skip MINUS entry point\n*\nPARSMINS OI    WFLAG1,WMINUS       Remember Minus\n         MVI   TRTABLE+C'+',X'00'  Remove +/- from delimiter status\n         MVI   TRTABLE+C'-',X'00'  .\n         LA    R7,WRD2NUM1         Setup next default\n         ST    R7,PARSDFLT         .\n         LA    R7,WRD1NUM1         Use WRD1 area for answer\n         B     PARSDO1             Go setup answer area\n*---------------------------------------------------------------------+\n*        Slash found, process it\n*---------------------------------------------------------------------+\n*\nPARSSLSH MVI   TRTABLE+C'/',X'00'  Remove / from delimiter status\n         L     R7,PARSDFLT         Pickup default answer area address\n         LA    R15,TRLRNUM1        Setup next default\n         ST    R15,PARSDFLT        .\n         B     PARSDO1             Go setup answer area\n         EJECT\n*---------------------------------------------------------------------+\n*        Setup answers for 1 sub-operand\n*---------------------------------------------------------------------+\n*\nPARSDO1  LR    R15,R1              Calc length of operand\n         SR    R15,R4              .\n         BZ    PARSDO1A            Skip if null operand\n         OC    WFLAG1,OPRF1        Set WFLAG1\n         STH   R15,OPRL            Save in operand area\n         CH    R15,=H'10'          See if 'word' will fit\n         BH    *+14                No, make it a pointer then\n         MVC   OPRTXT,0(R4)        Yes, copy to operand area\n         B     PARSDO1A            continue\n         ST    R4,OPRADDR          Save pointer to it\n         OI    OPRF2,OPRPTR        Flag it as pointer type\n*\nPARSDO1A SR    R3,R15              Adjust main 'word' length\n         BCTR  R3,0                Less 1 for delimiter\n         LA    R4,1(R4,R15)        Adjust pointer to 'word'\n         LTR   R3,R3               Any left?\n         BZ    PARSDOTY            No, just type the one we've got\n         LTR   R15,R15             Was null operand found?\n         BZ    PARSSVST            Yes, forget typeing it then\n*\nPARSDOTY CP    COMNTCTL,=P'0'      In SKIP mode?\n         BE    PARSDXTY            No, do typing\n         CLC   WORDL,=H'2'         Don't miss the *: for nested comment\n         BNE   PARSSVST            Can't be, skip\n         CLC   WORDTXT(2),=C'*:'   Is this it?\n         BNE   PARSSVST            Yes, do a full parse\n*\nPARSDXTY $CALL TYPEOPER,(R7)       Go type it\n         B     PARSSVST            Resume for next operand\n*\nPARSEEX  $RET  0                   Return\n*\nPARSDFLT DS    F\nPARSTRT1 TRT   0(0,R6),TRTABLE\nPARSTRT2 TRT   0(0,R6),0(R15)\nPARSTRT3 TRT   0(0,R1),0(R15)\nPARSPAK1 PACK  DBL,0(0,R1)\nPARSMV1  MVC   WORDTXT(0),1(R4)\n         DROP  R7\n         POP   USING\n         $PEND\n         TITLE 'PGMSTUFF - Add code to the program'\n*---------------------------------------------------------------------+\n*        Insert code into the 'compiled' program                      |\n*        =======================================                      |\n*                                                                     |\n*        Called:   $CALL PGMSTUFF                                     |\n*                                                                     |\n*        Input:    R1      - the length of the code to be inserted    |\n*                            N.B.  A length of zero (0) is taken to   |\n*                                  be a request for the current       |\n*                                  location counter.                  |\n*                                                                     |\n*                  R2      - the address of the code to be inserted   |\n*                                                                     |\n*        Returns:  +0      - on completion                            |\n*                                                                     |\n*                  R1      - Will contain the location of the inserted|\n*                            code in the compiled program or of the   |\n*                            location counter if length=0 passed.     |\n*---------------------------------------------------------------------+\n*\nPGMSTUFF $PROC\n         LTR   R5,R1               Test length of code\n         BNZ   PGMFNDAD            There's something there\n         ICM   R1,15,PGMIC         Zero means a req. for curr. I.C.\n         BNZ   PGMEX               If one exists, return with it\n         B     PGMGMAIN            Else go get one\n*\nPGMEX    $RET  0\n*\nPGMFNDAD LA    R3,PGMLINKE-PGMLINKS(,R1) Add safety factor to length\n         C     R3,PGMRESID         Is there room for code + safety code\n         BNH   PGMSTSV             Yes, go store it\n*\nPGMGMAIN GETMAIN R,LV=1024         No, get a new 1k area\n         L     R15,=A(MAINETRC)    Get flag address\n         TM    1(R15),X'F0'        Is support active?\n         BO    PGMNOSUP            No\n         L     R15,PCTSUPP2        Get place to store it\n         ST    R1,0(R15)           Save it\n         MVC   4(4,R15),HEXFFS     Stuff in new delim\n         LA    R15,4(,R15)         Bump to next slot\n         ST    R15,PCTSUPP2        Save for next time\n*\nPGMNOSUP MVC   PGMRESID,=F'1024'   Set new available size\n         CLC   PGMIC,ZEROS         First pgm area?\n         BNE   PGMADCHN            No, go chain it\n         ST    R1,PCTPGM           Yes, save start of pgm in pct\n         ST    R1,PGMIC            And save as new I.C.\n         LTR   R5,R5               Is this only an I.C. Request\n         BZ    PGMEX               Yes, leave now\n         B     PGMSTSV             No, go stuff in code\n*\nPGMADCHN ST    R1,PGMMADCN         Store new GM area\n         L     R4,PGMIC            Get addr of old I.C.\n         ST    R1,PGMIC            Swap to new one\n         MVC   0(PGMLINKE-PGMLINKS,R4),PGMLINKS Store link code\n*\nPGMSTSV  BCTR  R5,0                Reduce count for EX\n         L     R1,PGMIC            Get loc to store\n         LR    R3,R1               Let R1 stay at start of code\n         EX    R5,*+4              Move model code to pgm area\n         MVC   0(0,R3),0(R2)       .\n         LA    R3,1(R5,R3)         Create new I.C. Address\n         ST    R3,PGMIC            And save it\n         L     R3,PGMRESID         Get residual count\n         SR    R3,R5               Reduce by amount used\n         BCTR  R3,0\n         ST    R3,PGMRESID         And save it\n         B     PGMEX               Return, we're done\n         $PEND\n         TITLE 'PUSHIF/POPIF - Routines for IF processing'\n*---------------------------------------------------------------------+\n*        PUSHIF/POPIF routines                                        |\n*---------------------------------------------------------------------+\n*\nPUSHIF   $PROC\n         USING KWDSECT,R14\n         L     R2,PCTNEST          Get nest count\n         CH    R2,=H'19'           At limit?\n         BNL   PUSHERR             Yes, sorry\n         LA    R2,1(,R2)           +1\n         ST    R2,PCTNEST          Save it back\n         SLL   R2,2                Index x 4\n         LA    R2,PCTNEXT-4(R2)    Point at stack item\n         ST    R1,0(R2)            Save address in stack\n         $RET  0                   Return\n*\nPUSHERR  $ERR  NESTH,8,SKIP        Kill it\n         $PEND\n*\nPOPIF    $PROC\n         ICM   R2,15,PCTNEST       Get nest count\n         BZ    POPEX               Ignore zero, nesting error\n         LR    R1,R2               Copy it for BCTR\n         BCTR  R1,0                -1\n         ST    R1,PCTNEST          Save it back\n         SLL   R2,2                Index x 4\n         L     R4,PCTNEXT-4(R2)    Now get the address to be stuffed\n         $ADD  0,*                 Get current I.C.\n         ST    R1,0(R4)            Save in pointed-to location\n         ST    R4,PCTPOPLS         Save the last POP'ed position\n*\nPOPEX    $RET  0                   Return\n         $PEND\n         TITLE 'SDCBROUT - Select Output route for DCB'\n*---------------------------------------------------------------------+\n*        Select an output route for an FCB                            |\n*        =================================                            |\n*                                                                     |\n*        Called:   $CALL SDCBROUT,fcb                                 |\n*                                                                     |\n*        Operands: fcb     - the address of the FCB to be processed   |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*                                                                     |\n*                  FCBROUTE will be set to the appropriate address    |\n*                           of the routine to copy between the RECFM  |\n*                           of INPUT1 and the RECFM of the passed FCB.|\n*---------------------------------------------------------------------+\n*\nSDCBROUT $PROC 1\n         L     R7,12(R8)           Pick up passed param\n         MVC   SDCBRWK(1),FCBDCB+DCBRECFM Build search key\n         MVI   SDCBRWK+1,X'C0'     Set default to Undefined\n         ICM   R15,15,PCT1DCB      Point at INPUT1 DCB\n         BZ    *+10                Skip if no input RECFM avail.\n         MVC   SDCBRWK+1(1),DCBRECFM(R15)\n         NC    SDCBRWK,=X'C0C0'    Kill rubbish bits\n         LA    R3,(DCBRTBLE-DCBRTBL)/6 Set limit on loop\n         L     R4,=A(DCBRTBL)      Point at table\n*\nSDCBLOOP CLC   0(2,R4),SDCBRWK     Look for our match\n         BE    SDCBFND             Got it\n         LA    R4,6(,R4)           Else, bump\n         BCT   R3,SDCBLOOP         Loop, fall through R4 is at default\n*\nSDCBFND  MVC   FCBROUTE,2(R4)      Setup output route in FCB\n         $RET  0                   Leave\n*\nSDCBRWK  DC    X'0000'\n         $PEND\n         TITLE 'SELECT - Command processor'\n*---------------------------------------------------------------------+\n*        S E L E C T   C o m m a n d   P r o c e s s o r              |\n*---------------------------------------------------------------------+\n*\nSELECT   $PROC\n         MVC   PCTPOPLS,ZEROS      Clear last POP'ed address\n         $CALL DBGADD              Go add DEBUG code\n         MVI   SELF1,X'00'         Blank out work areas\n         MVC   SELF2(SELGLDEX-SELF2),SELF1\n         MVC   SELNREC,=X'7FFFFFFF' Stuff max value for RECS\n         MVC   SELGOTOA,ZEROS      Clear any prior GOTO\n         OI    PCTF1,ACTIVE        Show command active\n*---------------------------------------------------------------------+\n*        Loop for each SELECT operand                                 |\n*---------------------------------------------------------------------+\n*\nSELLOOP  $CALL GETNEXT             Go get next word\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    SELEOS              Yes\n         TM    WFLAG1,WPREF+WTRLR  Invalid format?\n         BNZ   BADOPTYP            Yes, kill it\n         TM    WFLAG1,WWRD1        Better have this on\n         BZ    BADOPTYP            No, sorry\n         TM    WRD1F2,OPRKW+OPRKWV Valid KW?\n         BNO   BADKWORD            No, kill it\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWNOISE        Noise word?\n         BO    SELLOOP             Yes, ignore it\n         CLI   KWNUM,X'52'         Handle the GOTO collision\n         BE    SELBR               .\n         MVN   KWNUM,=X'00'        Clear lo-order nibble\n         CLI   KWNUM,X'80'         Valid SELECT KW?\n         BNE   BADKWORD            No, sorry\n*\nSELBR    L     R2,KWD1             Get address of routine\n         BR    R2                  Branch by type\n*---------------------------------------------------------------------+\n*        Process the RECS(...) operand                                |\n*---------------------------------------------------------------------+\n*\nSELRECS  TM    WRD1F2,OPRKWOP      Do we have a sub-operand\n         BZ    BADOPTYP            No, sorry\n         TM    WRD1F2,OPRKWOP+OPRKWOPV Valid KW?\n         BNO   SELRECSN            No, go try as numeric\n         LA    R14,WRD1KW2         Point at KW answer area\n         CLI   KWNUM,X'93'         Is it (ALL) ?\n         BNE   SELRECSN            No, see if numeric\n         MVC   SELNREC,=X'7FFFFFFF' Stuff max value\n         OI    PCTF3,ALL           Turn on permanent active bit\n         B     SELLOOP             And loop back\n*\nSELRECSN LA    R2,SELNREC          Point at location to receive answer\n         SR    R3,R3               Set adjustment to zero\n         B     SELNUMBR            Go to common code\n*---------------------------------------------------------------------+\n*        Process the SREC(...) operand                                |\n*---------------------------------------------------------------------+\n*\nSELSREC  LA    R2,SELSRECD         Point at location to receive answer\n         SR    R3,R3               Set adjustment to zero\n         B     SELNUMBR            Go to common code\n*---------------------------------------------------------------------+\n*        Process the BY(...) operand                                  |\n*---------------------------------------------------------------------+\n*\nSELBY    LA    R2,SELBREC          Point at location to receive answer\n         L     R3,=F'-1'           Set adjustment to -1\n         B     SELNUMBR            Go to common code\n*---------------------------------------------------------------------+\n*        Process the LENGTH(...) operand                              |\n*---------------------------------------------------------------------+\n*\nSELDLEN  LA    R2,SELNLGTH         Point at location to receive answer\n         SR    R3,R3               Set adjustment to zero\n         B     SELNUMBR            Go to common code\n*---------------------------------------------------------------------+\n*        Process numeric (...) operands                               |\n*---------------------------------------------------------------------+\n*\nSELNUMBR TM    WRD1F2,OPRKWOPV     Do we have a sub-operand\n         BZ    BADOPTYP            No, sorry\n         TM    WRD1KW2+(KWF2-KWDSECT),KWNUMFUG Got a number\n         BZ    BADKWVAL            No good\n         ICM   R1,15,WRD1NUM2      Pick up the value\n         BZ    BADKWVAL            Zero is no good\n         AR    R1,R3               Adjust the value as needed\n         ST    R1,0(R2)            Save it if OK\n         B     SELLOOP             Go for another kw\n*---------------------------------------------------------------------+\n*        Process the TODD(...) operand                                |\n*---------------------------------------------------------------------+\n*\nSELTODD  TM    WRD1F2,OPRKWOP      Got a sub-operand?\n         BZ    BADOPTYP            No, error\n         CLC   WRD1L2(10),MDSYSP   Is it SYSPRINT?\n         BE    SELBDDN             SYSPRINT is a no-no\n         $CALL DCBO1BLD,WRD1L2     No, go build DCB's etc\n         B     BADDCB              Leave if NFG\n         ST    R1,SELODCB          Save Ptr to O/P cntl area\n         OI    SELF1,COPY          Activate copy\n         B     SELLOOP             Go get another kw\n         EJECT\n*---------------------------------------------------------------------+\n*        Process the GOTO(...) operand                                |\n*---------------------------------------------------------------------+\n*\nSELGOTO  TM    WRD1F2,OPRKWOP      Got a sub operand?\n         BO    SELGOTOS            Yes, go that route\n*\nSELGOTON $CALL GETNEXT             No, get next word then\n         CLC   WORDL,=H'0'         End of sentence?\n         BE    BADOPTYP            Yes, kill it\n         TM    WRD1F2,OPRKW+OPRKWV Valid Keyword?\n         BZ    SELGOTOP            Nope, sorry\n         LA    R14,WRD1KW1         Point at KW answer area\n         TM    KWF1,KWNOISE        Eliminate 'noise' words\n         BO    SELGOTON            .\n*\nSELGOTOP LA    R2,WORDL            Point at the word\n         B     SELGOTOM            Continue\n*\nSELGOTOS LA    R2,WRD1L2           Point at sub-operand\n*\nSELGOTOM CLC   0(2,R2),=H'80'      Too long?\n         BNH   *+10                No, skip\n         MVC   0(2,R2),=H'80'      Yes, shorten it\n         MVC   SELGOTOH-2(82),0(R2) Now save it\n         MVC   SELGOTOA,=F'1'      Flag as present\n         B     SELLOOP\n*---------------------------------------------------------------------+\n*        Process the PRINT(...) operand                               |\n*---------------------------------------------------------------------+\n*\nSELPRINT TM    WRD1F2,OPRKWOP      Do we have a sub-operand\n         BZ    BADOPTYP            No, sorry\n         TM    WRD1F2,OPRKWOP+OPRKWOPV Valid KW?\n         BNO   SELRECSN            No, go try as numeric\n         TM    PCTF2,DSYSPRT       Yes, better have a SYSPRINT DD then\n         BZ    BADSYSPR            No, sorry\n         LA    R14,WRD1KW2         Point at KW answer area\n         CLI   KWNUM,X'94'         See if valid\n         BL    BADKWORD            Sorry\n         CLI   KWNUM,X'96'         .\n         BH    BADKWORD            .\n         OC    SELF1,KWD1          OR in the PRINT bits\n         B     SELLOOP             And get next kw\n         EJECT\n*---------------------------------------------------------------------+\n*        End of SELECT sentence processing                            |\n*---------------------------------------------------------------------+\n*\nSELEOS   NI    PCTF1,255-ACTIVE    Turn off active flag\n         EJECT\n*---------------------------------------------------------------------+\n*        Generate code for the SELECT sentence.                       |\n*---------------------------------------------------------------------+\n*\nSELGEN   TM    SELF1,CHAR+HEX+COPY Any output requested\n         BZ    SELTGOTO            No, was GOTO specified\n         $ADD  4,DCOPM010          Add test for deferred copy\n*\nSELBACTV $INC  PCTMACNT            Count one more active SELECT\n         B     SELBLDIT            Then go generate some code\n*\nSELTGOTO CLC   SELGOTOA,ZEROS      Was GOTO specified?\n         BNE   SELTLEN             Yes, see if LENGTH(..) coded\n         $ERR  SELWY,8,GO=MAINGOK  Error msg and goto next sentence\n*\nSELTLEN  CLC   SELNLGTH,ZEROS      This should be zeros then\n         BE    SELBACTV            Correct, continue\n         $ERR  ILLOG,4,GO=SELBACTV Message and let it continue\n*\nSELBLDIT CLC   SELNLGTH,ZEROS      A LENGTH(...) specified?\n         BE    *+8                 No, skip\n         OI    PCTF1,IPCOPY        Yes, force alternate buffer\n         $ADD  SELGICRC-SELGBAL1,SELGBAL1\n         LA    R15,SELNEXTS-SELGBAL1(,R1) Point at next sent Adcon\n         ST    R15,SELSNEXT        And save it\n         LA    R2,SELNREC-SELGBAL1(,R1) Point at RECS value\n         GETMAIN R,LV=12           Get a RESET block\n         MVC   0(4,R1),PCTRESET    Add to RESET chain\n         ST    R1,PCTRESET         .\n         ST    R2,4(R1)            Add address to be reset\n         MVC   8(4,R1),0(R2)       Add value to be put back\n         CLC   SELNREC,=X'7FFFFFFF' (ALL) recs?\n         BE    SELTSREC            Yes, dont build count logic\n         CLC   SELNREC,=F'-1'      Count set?\n         BE    SELTSREC            No, skip build as well\n*\nSELBCOUN $ADD  SELGCRTS-SELGICRC,SELGICRC\n*\nSELTSREC CLC   SELSRECD,ZEROS      Start record?\n         BE    SELTF1              No, ignore start rec code\n*\nSELBSREC $ADD  SELGBALO-SELGCRTS,SELGCRTS\n*\nSELTF1   TM    SELF1,CHAR+HEX+COPY Any outputs?\n         BNZ   SELBOUTP            Yes, go gen output code\n         CLC   SELBREC,ZEROS       Any BY (...) count ?\n         BE    SELTKEY             No, skip the output code\n*\nSELBOUTP $ADD  SELGBCT1-SELGBALO,SELGBALO\n*\nSELTKEY  CLC   SELNREC,=X'7FFFFFFF' (ALL) ?\n         BE    SELZGOTO            Yes, dont count\n         CLC   SELNREC,=F'-1'      Count set?\n         BE    SELZGOTO            No, skip genning code\n*\nSELBDECR $ADD  SELGLGO-SELGBCT1,SELGBCT1\n*\nSELZGOTO CLC   SELGOTOA,ZEROS      Was GOTO specified?\n         BE    SELBNS              No, we're done\n         $ADD  8,SELGLGO\n         LA    R2,4(,R1)\n         $CALL LBLOGEN,SELGOTOH-2,(R2) Go add to unresolved table\n*\nSELBNS   $ADD  0,*                 Get next IC\n         L     R2,SELSNEXT         Get address of next sent Adcon\n         ST    R1,0(R2)            Stuff address of next sent. in\n         B     EXITGOK             Go to common command exit\n         EJECT\n*---------------------------------------------------------------------+\n*        SELECT Error message routines                                |\n*---------------------------------------------------------------------+\n*\nSELBADPT $ERR  BADPT,8,SKIP\n*\nSELBDDN  $ERR  BDDN,8,SKIP\n         $PEND\n         TITLE 'SETROUTE - Alter O/P ROUTES FOR ALL FCB''S'\n*---------------------------------------------------------------------+\n*        Process each FCB to reselect an output route                 |\n*---------------------------------------------------------------------+\n*\nSETROUTE $PROC\n         USING FCBDSECT,R7\n         LA    R7,PCTFCB           Init to start of chain\n*\nSETCHAIN ICM   R7,15,0(R7)         Get next item on chain\n         BZ    SETREX              Done? exit\n         TM    FCBF2,FCBINPUT      An input DCB?\n         BO    SETCHAIN            Yes, skip this one\n         $CALL SDCBROUT,(R7)       No, process this FCB\n         B     SETCHAIN            And loop back\n*\nSETREX   $RET  0                   Exit\n         DROP  R7\n         $PEND\n         TITLE 'SNAPIT - SNAP compiled code'\n*---------------------------------------------------------------------+\n*        Snap generated program if in DEBUG SUPPORT(ON) mode          |\n*        ===================================================          |\n*                                                                     |\n*        Called:   $CALL SNAPIT                                       |\n*                                                                     |\n*        Returns:  +0 on completionn                                  |\n*---------------------------------------------------------------------+\nSNAPIT   $PROC\n         L     R5,PCTSUPP1         Get start of 1k blocks\n*\nSNPLP    CLC   0(4,R5),HEXFFS      End?\n         BE    SNAPEX              Yes\n         MVC   LINE(16),=C'Program Block >>'\n         TM    0(R5),X'80'         Litpool block\n         BZ    *+10                No, skip\n         MVC   LINE(13),=C'Litpool Block'\n         L     R2,0(R5)            Lower bound address\n         LA    R2,0(R2)            Purify register\n         LR    R4,R2               Upper bound address\n         A     R4,=F'1024'         .\n         SH    R4,=H'4'            .\n         LA    R5,4(,R5)           Bump to next block\n*\nSNPLN    ST    R2,DBL              Put address into memory\n         LR    R14,R4              Calc length left\n         SR    R14,R2              .\n         CH    R14,=H'32'          Still 32 bytes left?\n         BL    SNPDO\n         CLC   0(32,R2),ZEROS      Stop this block if all zeros\n         BE    SNPLP\n*\nSNPDO    UNPK  LINE+17(7),DBL(5)   Put into print line\n         TR    LINE+17(6),SNPTR-240\n         MVI   LINE+23,C' '\n         MVI   LINE+98,C'|'        Border characters\n         MVI   LINE+131,C'|'       .\n         MVC   LINE+99(32),0(R2)   EBCDIC version\n         L     R1,=A(TRTBLC)       Get address of pretty chars\n         TR    LINE+99(32),0(R1)   Eliminate crappy chars\n         LA    R1,LINE+25\n         LA    R0,8                Line counter\n*\nSNPAL    CR    R2,R4               At end of dump yet ?\n         BH    SNPOUT\n         C     R0,=F'4'            Check if halfway (add a\n         BNE   *+8                 blank if we are)\n         LA    R1,1(R1)\n         MVC   DBL(4),0(R2)\n         UNPK  0(9,R1),DBL(5)\n         TR    0(8,R1),SNPTR-240\n         MVI   8(R1),C' '\n         LA    R1,9(,R1)\n         LA    R2,4(,R2)\n         BCT   R0,SNPAL\n*\nSNPOUT   STM   R0,R5,SNPREGS       Save regs\n         BAL   R14,LINPRINT        Put the line\n         LM    R0,R5,SNPREGS       Reload regs\n         MVC   LINE,BLANKS         Blank it - not needed mostly\n         CR    R2,R4               See if have more to dump\n         BNH   SNPLN               Yes continue\n         B     SNPLP               Loop till done\n*\nSNAPEX   $RET  0\n         $PEND\n         TITLE 'TIMEPROC - Get Time and date'\n*---------------------------------------------------------------------+\n*        Make a 'pretty' version of the current Time/Date             |\n*        ================================================             |\n*                                                                     |\n*        Called:   $CALL TIMEPROC                                     |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*                                                                     |\n*        Note:     On completion the TIMEWORK area is formatted as    |\n*                  follows:                                           |\n*                              X'yydddhhmmssmmmmm'                    |\n*                              C'ddMTHyy (yyddd) hh:mm:ss.mmmmm'      |\n*                              C'ccccmmdd'                            |\n*---------------------------------------------------------------------+\n*\nTIMEPROC $PROC\n         TIME  STCK,DBL,LINKAGE=SYSTEM Get the CLOCK\n         L     R1,16               -> CVT\n         L     R1,304(R1)          Get time zone constant\n         AL    R1,DBL              Adjust STCK value\n         ST    R1,DBL              .\n         STCKCONV STCKVAL=DBL,CONVVAL=STCKWORK Convert it\n*------- Build yydddhhmmssth000 in  1st 8 bytes------------------------\n         L     R0,STCKWORK+8       Get R0=0yyyyddd\n         L     R1,STCKWORK             R1=        hhmmssth\n         SLDL  R0,12                R0/R1=yydddhhmmsth0000\n         O     R1,=X'0000000F'\n         STM   R0,R1,TIMEWORK      Save in answer area\n*------- Build yyyymmdd in TIMECENT -----------------------------------\n         STCKCONV STCKVAL=DBL,CONVVAL=STCKWORK, Convert again          X\n               DATETYPE=YYYYMMDD\n         SR    R0,R0               Get R0=00000000\n         L     R1,STCKWORK+8           R1=        yyyymmdd\n         SLDL  R0,4                 R0/R1=0000000yyyymmdd0\n         O     R1,=X'0000000F'      R0/R1=0000000yyyymmdds\n         STM   R0,R1,DBL2          Store in work area\n         UNPK  TIMECENT(8),DBL2+3(5) Unpack it to answer area\n*------- Edit to readable characters ----------------------------------\n         UNPK  TIMEWORK+8(2),DBL2+6(2)\n         SRL   R1,8                R1=0yyyymm0\n         O     R1,=X'0000000F'     R1=0yyyymms\n         N     R1,=X'00000FFF'     R1=00000mms\n         SR    R0,R0               Get R0=00000000\n         STM   R0,R1,DBL2          Make an index\n         CVB   R1,DBL2             .\n         MH    R1,=H'3'            .\n         LA    R1,MTHTAB-3(R1)     Index into table\n         MVC   TIMEWORK+10(3),0(R1) Move it\n         OC    TIMEWORK+10(3),=C'    ' Uppercase it\n         MVC   TIMEWORK+13(2),TIMECENT+2\n         MVC   DBL2+5(3),TIMEWORK\n         OI    DBL2+7,X'0F'\n         UNPK  TIMEWORK+17(5),DBL2+5(3)\n*------- Edit hh:mm:ss.hhhhh ------------------------------------------\n         MVC   TIMEHMSH-2(L'EDITPAT1),EDITPAT1\n         LM    R0,R1,TIMEWORK\n         SRDL  R0,8\n         STM   R0,R1,DBL2\n         ED    TIMEHMSH-2(L'EDITPAT1),DBL2+3\n         MVC   TIMEHMSH-2(2),=C') ' Replace clobbered chars\n         $RET  0                   Return to caller\n         $PEND\n         TITLE 'TYPEOPER - Type an operand found by PARSE'\n*---------------------------------------------------------------------+\n*        Do detailed typeing of a sub-operand found by PARSE          |\n*        ===================================================          |\n*                                                                     |\n*        Called:   $CALL TYPEOPER,operarea                            |\n*                                                                     |\n*        Operands: operarea - is operand area as defined by OPRDSECT  |\n*                                                                     |\n*        Returns:  +0 on completion                                   |\n*                                                                     |\n*        Notes:    The detailed fields of the operand area are        |\n*                  completed by this routine.                         |\n*                                                                     |\n*                  OPRF2     - Operand type flags.                    |\n*                  OPRKW1    - Completed if operand is a KW and has   |\n*                              been successfully found in the KW      |\n*                              table.                                 |\n*                  OPRKW2    - Ditto OPRKW1 if the sub-operand is a   |\n*                              KW.  Also set if suboperand is numeric.|\n*                              KWNUMFUG is on and the number is in    |\n*                              OPRNUM2.                               |\n*---------------------------------------------------------------------+\n*\nTYPEOPER $PROC 1\n         USING OPRDSECT,R7\n         L     R7,12(R8)           Pick up passed area\n         LH    R5,OPRL             Copy length value\n         BCTR  R5,0                -1 for EX\n         LA    R6,OPRTXT           Point at text\n         TM    OPRF2,OPRPTR        An indirect type?\n         BZ    *+8                 No\n         L     R6,OPRADDR          Yes, pick up it's pointer\n*---------------------------------------------------------------------+\n*        Try as a normal numeric type.                                |\n*---------------------------------------------------------------------+\n*\nTYPETRYN L     R15,=A(TRTBLN)      Get addr. of Num TRT table\n         EX    R5,TYPETRT1         See if all numeric\n         BNZ   TYPETRYS            No, go see if special numeric\n         EX    R5,TYPEPAK1         Yes, convert it\n         CVB   R1,DBL              .\n         ST    R1,OPRNUM1          Save answer\n         OI    OPRF2,OPRNUM        Set NUM flag\n         B     TYPEEXIT            and exit\n*---------------------------------------------------------------------+\n*        Try as a special numeric type.                               |\n*---------------------------------------------------------------------+\n*\nTYPETRYS L     R15,=A(TRTBLNN)     Get TRTable address\n         EX    R5,TYPETRT1         See if any numerics\n         BZ    TYPETRYK            No, go treat as KW then\n         LR    R2,R1               Calc remaining length of numerics\n         SR    R2,R6               .\n         LR    R14,R5              .\n         SR    R14,R2              .\n         L     R15,=A(TRTBLN)      Get addr. of Num TRT table\n         EX    R14,TYPETRT2        See if remainder is all numeric\n         BNZ   TYPETRYK            No, then treat as KW\n         EX    R14,TYPEPAK2        Yes, convert it\n         CVB   R1,DBL              .\n         ST    R1,OPRNUM1          Save answer\n         OI    OPRF2,OPRNUM+OPRSPECN Set NUM flag\n         B     TYPEEXIT            and exit\n*---------------------------------------------------------------------+\n*        Now try the KW type route.                                   |\n*---------------------------------------------------------------------+\n*\nTYPETRYK LR    R15,R6              Point at start of word\n         LA    R14,10              Set length limit\n         CH    R5,=H'9'            If length of word is < 10\n         BH    *+8                 Leave R14 at it's maximum\n         LA    R14,1(,R5)          Else set R14 based on length of word\n*\nTYPEBRLP CLI   0(R15),C''''        Look for ' (Maybe a literal)\n         BE    TYPESTLI            Yes, ' preceeds (, it's a literal\n         CLI   0(R15),C'('         Look for (\n         BE    TYPEGBRK            Got one, go extract value\n         LA    R15,1(,R15)         No, bump\n         BCT   R14,TYPEBRLP        Loop\n         OI    OPRF2,OPRKW         Flag as some kind of KW\n         B     TYPENSKW            No sub-KW, just process this one\n*\nTYPEGBRK OI    OPRF2,OPRKW         Flag as some kind of KW with operand\n         TM    OPRF2,OPRPTR        Is this a pointer type?\n         BZ    *+14                No, skip\n         NI    OPRF2,255-OPRPTR    Yes, convert back to normal type\n         MVC   OPRTXT,0(R6)        Copy data back to OPRTXT\n         LH    R14,OPRL            Get orig length of word\n         STM   R14,R15,TYPESAVE    Save for a while\n         LR    R2,R15              Save address of (\n         SR    R15,R6              Calc length of KW\n         STH   R15,OPRL            Reset OPRL\n         B     TYPEKWLK            Go lookup KW\n*\nTYPENSKW STM   R14,R15,TYPESAVE    Save for a while\n         EJECT\n*---------------------------------------------------------------------+\n*        Go see if the KW is in the KW table.                         |\n*---------------------------------------------------------------------+\n*\nTYPEKWLK $CALL KWRDSRCH,OPRL,OPRKW1\n         B     *+12                +0 > Invalid KW\n         OI    OPRF2,OPRKWV        +4 > Remember its a valid KW\n         B     TYPESEO2            Go see if sub-operand\n*---------------------------------------------------------------------+\n*        Not in KW table, try operand prefix as numeric.              |\n*---------------------------------------------------------------------+\n         LH    R5,OPRL             Get length of it again\n         BCTR  R5,0                -1 for EX's\n         L     R15,=A(TRTBLN)      Point at TRT table\n         LA    R6,OPRTXT           and at data\n         TM    OPRF1,OPRPTR        .\n         BZ    *+8                 .\n         L     R6,OPRADDR          .\n         EX    R5,TYPETRT1         See if all numeric\n         BNZ   TYPEKWSP            No, See if special numeric then\n         EX    R5,TYPEPAK1         Yes, convert it\n         CVB   R1,DBL              .\n         ST    R1,OPRNUM1          Save it\n         OI    OPRF1,OPRNUM        Flag as a NUM operand\n         NI    OPRF1,255-OPRKW     Remove KW flag\n         B     TYPESEO2\n*---------------------------------------------------------------------+\n*        Operand prefix wasn't numeric, try special numeric.          |\n*---------------------------------------------------------------------+\n*\nTYPEKWSP L     R15,=A(TRTBLNN)     Get TRTable address\n         EX    R5,TYPETRT1         See if any numerics\n         BZ    TYPETRYL            No, go try as literal\n         LR    R2,R1               Calc remaining length of numerics\n         SR    R2,R6               .\n         SR    R5,R2               .\n         L     R15,=A(TRTBLN)      Get addr. of Num TRT table\n         EX    R5,TYPETRT2         See if remainder is all numeric\n         BNZ   TYPESEO2            No, then treat as KW\n         EX    R5,TYPEPAK2         Yes, convert it\n         CVB   R1,DBL              .\n         ST    R1,OPRNUM1          Save answer\n         OI    OPRF2,OPRNUM+OPRSPECN Set NUM flag\n         NI    OPRF1,255-OPRKW     Remove KW flag\n         EJECT\n*---------------------------------------------------------------------+\n*        See if we had a sub-operand.                                 |\n*---------------------------------------------------------------------+\n*\nTYPESEO2 LM    R14,R15,TYPESAVE    Restore regs\n         LTR   R14,R14             Sub-operand?\n         BZ    TYPETRYL            No, go try the literal\n         OI    OPRF2,OPRKWOP       Remember we had a sub-operand\n         LR    R5,R14              Swap original length to R5\n         SH    R5,OPRL             Calc length of remaining bit\n         SH    R5,=H'2'            Less 2 more for ()\n         BNP   BADKWVAL            If -ve, kill it\n         STH   R5,OPRL2            Save it\n         MVC   OPRTXT2,1(R15)      Move text\n         CH    R5,=H'10'           Is this a biggy?\n         BNH   TYPESBKW            No, go see if KW\n         LA    R15,1(,R15)         Adjust R15\n         STCM  R15,15,OPRTXT2      Save in TXT2 as a pointer\n         B     TYPEEXIT            And exit\n*---------------------------------------------------------------------+\n*        See if sub-operand was a KW.                                 |\n*---------------------------------------------------------------------+\n*\nTYPESBKW $CALL KWRDSRCH,OPRL2,OPRKW2\n         B     TYPEOPNM            +0 > Invalid KW\n         OI    OPRF2,OPRKWOPV      +4 > It's valid\n         B     TYPEEXIT            Exit, we're done\n*---------------------------------------------------------------------+\n*        Sub-operand wasn't a KW, try as numeric then.                |\n*---------------------------------------------------------------------+\n*\nTYPEOPNM LH    R5,OPRL2            Get length of it again\n         BCTR  R5,0                -1 for EX's\n         L     R15,=A(TRTBLN)      Point at TRT table\n         LA    R6,OPRTXT2          and at data\n         NI    OPRKW2+(KWF2-KWDSECT),255-KWNUMFUG Clear KWNUMFUG\n         EX    R5,TYPETRT1         See if all numeric\n         BNZ   TYPEEXIT            No, forget it\n         EX    R5,TYPEPAK1         Yes, convert it\n         CVB   R1,DBL              .\n         ST    R1,OPRNUM2          Save it\n         OI    OPRF2,OPRKWOPV      Say KW2 area is valid\n         OI    OPRKW2+(KWF2-KWDSECT),KWNUMFUG Say OPRNUM2 is valid\n         MVI   OPRKW2+(KWNUM-KWDSECT),X'00'   Clear any valid KW numb.\n         B     TYPEEXIT\n         EJECT\n*---------------------------------------------------------------------+\n*        Last  see if it's a literal type.                            |\n*---------------------------------------------------------------------+\n*\nTYPETRYL L     R15,=A(TRTBLQ)      Get address of quote TRTable\n         EX    R5,TYPETRT1         See if any quotes\n         BZ    TYPEDFKW            No, call it a KW\n*\nTYPESTLI OI    OPRF2,OPRLIT        Yes, flag as a literal\n*\nTYPEEXIT $RET  0                   Exit now\n*\nTYPEDFKW OI    OPRF2,OPRKW         Flag as some kind of KW\n         B     TYPEEXIT\n*\nTYPETRT1 TRT   0(0,R6),0(R15)\nTYPETRT2 TRT   0(0,R1),0(R15)\nTYPEPAK1 PACK  DBL,0(0,R6)\nTYPEPAK2 PACK  DBL,0(0,R1)\nTYPESAVE DS    2F\n         DROP  R7\n         $PEND\n         TITLE 'Data areas'\n         ORG   SELECTIT+((*-SELECTIT+31)/32*32)\n*---------------------------------------------------------------------+\n*        Program control table                                        |\n*---------------------------------------------------------------------+\n*\nPCT      DS    0F\nSAVEAREA DS    18F\nPCTHEAD  DC    C'================================'\n         DC    C'=     SELECTIT VERSION 1.0b    ='\n         DC    C'================================'\nPCTVERNO EQU   PCTHEAD+55,4,C'C'\n         PRINT NOGEN\n*\nPCTF1    DC    X'00'\nDCOPYGEN       EQU         X'80'   ALTER has genned DCOPYDAT test\nDFLTFLAG       EQU         X'40'   No SYSIN, default images used\nTSOSTEP        EQU         X'20'   This is a TSO step\nIPCOPY         EQU         X'08'   ALTER copies from I/P record\nACTIVE         EQU         X'04'   Compiler is processing a command\nEXEC           EQU         X'02'   Program is executing in user pgm\nSTAT           EQU         X'01'   Msg to be processed to stat chain\nPCTF2    DC    X'00'\nDSYSPRT        EQU         X'80'   SYSPRINT DD is present\nDSYSIN         EQU         X'40'   SYSIN    DD is present\nDINPUT1        EQU         X'20'   INPUT1   DD is present\nDOUTPUT1       EQU         X'10'   OUTPUT1  DD is present\nPCTF3    DC    AL1(0)\nDEFREOF        EQU         X'80'   Deferred end of file on SYSIN\nFAST           EQU         X'20'   Doing a FASTCOPY route\nINPUT          EQU         X'10'   Input is an 'official' one\nDCBOPT         EQU         X'08'   DDname to be built is optional\nALL            EQU         X'04'   Copy 'ALL' present somewhere\nOPKWLEN        EQU         X'02'   Length operand is a KW field\nCOMPALTR       EQU         X'01'   Compiling an ALTER command\nPCTF4    DC    AL1(COMPILE+IODONE)\nNOFLAG         EQU         X'80'   Don't flag error line\nPWAITING       EQU         X'40'   Cmd print line waiting\nCOMPILE        EQU         X'20'   Executing in compile phase\nLABLLOOK       EQU         X'10'   GETNEXT looking for a LABEL:\nABENDING       EQU         X'08'   Pgm is shutting down after an abend\nIFDONEW        EQU         X'04'   IF has gotten the TRUE word\nIFNXSENT       EQU         X'02'   IF requires next sentence completed\nIODONE         EQU         X'01'   Set whenever I/O is done\nPCTF5    DC    X'00'\nSHUTSEL        EQU         X'80'   Forces shutdown of SELECT block\nFWTYPE         EQU         X'40'   Fullword/Halfword literal switch\nIFAOPG         EQU         X'20'   IF code to -> A-op genned\nIFRELG         EQU         X'10'   IF has gotten test operand\nIFBOPG         EQU         X'08'   IF has gotten B-op at least once\nSTATPRNT       EQU         X'04'   ERPRINT processing stats msg chain\nPCTF6    DC    AL1(OPCHECK)\nOUTPUT         EQU         X'80'   DCB build is building an output set\nTRYFAST        EQU         X'40'   Make attempt at FASTCOPY route\nEOS            EQU         X'20'   End of sentence\nEOD            EQU         X'10'   Real end of SYSIN occurred\nUSERRC         EQU         X'08'   User has modified RCODE\nOPCHECK        EQU         X'04'   Check for real O/P requests\nDEFRCOPY       EQU         X'02'   Deferred I/P -> O/P copy\nPCTF7    DC    AL1(TIMEFLAG)\nDBDUMP         EQU         X'80'   DEBUG DUMP flag\nDBIOTRAC       EQU         X'40'   DEBUG IO Trace flag\nDBTRACE        EQU         X'20'   DEBUG Logic Trace flag\nUCTRDUMP       EQU         X'08'   UCTRx print at EOJ\nTIMEFLAG       EQU         X'02'   TIMEEXIT wants STIMER issued\nTIMEBOMB       EQU         X'01'   TIMEEXIT has forced an abend\nPCTF8    DC    X'00'               Still more flags\nPDSMODE        EQU         X'80'   We're in PDS Mode processing\nPDSEMPTY       EQU         X'40'   I/P PDS has no members\nPDSSTATS       EQU         X'20'   Full PDS Stats wanted\nCBLKSIZE       EQU         X'10'   CBLKSIZE(YES) specified\nPCTIOFLG DC    X'00'\nIOFLOATA       EQU         X'80'   A-operand is floating\nIOFLOATB       EQU         X'40'   B-operand is floating\nIODLML         EQU         X'20'   DLM type copy, OREGDLMT -> Table\nIONOEXPC       EQU         X'10'   No Expand/Contract on ALTER\nIOPACKED       EQU         X'08'   A or B operand is Packed Decimal\nIOMASK         EQU         X'04'   An IF MASK function\nIONOAADJ       EQU         X'02'   Don't adjust A-operand in REPLACE\nIONOBADJ       EQU         X'01'   Don't adjust B-operand in REPLACE\nPCTIOFL2 DC    X'00'\nIOUCTRX        EQU         X'80'   A or B operand is a UCTR\nPCTABEND DC    A(0)                ABEND code saved by STAE exit\nPCTPFCB  DC    A(0)                Address of SYSPRINT FCB\nPCTIFCB  DC    A(0)                Address of SYSIN    FCB\nPCT1FCB  DC    A(0)                Address of INPUT1   FCB\nPCT2FCB  DC    A(0)                Address of OUTPUT1  FCB\nPCTPDCB  DC    A(0)                Address of SYSPRINT DCB\nPCTIDCB  DC    A(0)                Address of SYSIN    DCB\nPCT1DCB  DC    A(0)                Address of INPUT1   DCB\nPCT2DCB  DC    A(0)                Address of OUTPUT1  DCB\nPCTCFLAG DC    X'00'               GETNEXT copy flag\nCOPYBUFF       EQU       X'80'     COPYBUFF requested\nPCTIPRET DC    AL3(COPRETN)        Current I/P return address\nPCTIPFCB DC    A(0)                Current I/P FCB address\nPCTIPEOF DC    A(ADDSTATS)         Current I/P EOF address\nPCTGMLIT DC    3A(0)               Litpool GETMAIN control area\nPCTLAST  DC    A(0)                Last stmnt # entered in execution\nPCTPGM   DC    A(0)                Start address of 'compiled' pgm\nPCTPGMS  DC    A(0)                Saved PCTPGM during 'GETNEXT'\nPCTERCHN DC    A(0)                Start of error message chain\nPCTSTCHN DC    A(0)                Start of statistics msg chain\nPCTFLCHG DC    F'0'  |\\            Difference in lgths last ALTER 0\nPCTSCLEN DC    F'0'  | \\           Length of last 'IF' scan found\nPCTPLOC  DC    F'0'  |  \\          I/P offset of last 'IF' scan found\nPCTPLOCE DC    F'0'  |Keep togeth. I/P offset of IF scan end(PLOCEND)\nPCTFLOCE DC    F'0'  |  /          I/P offset of IF scan end(FLOCEND)\nPCTFLOCT DC    F'0'  | /           O/P offset last byte mvd (FLOCTERM)\nPCTFLEN  DC    F'0'  |/            Length of last ALTER COPY\nPCTRC    DC    F'0'                Highest return code\nPCTUBFSZ DC    F'1024'             Default size of UBUFFx areas\nPCTINPT1 DC    A(0)                Address of Input buffers\nPCTINPT2 DC    A(0)                .\nPCTINPT3 DC    A(0)                .\nPCTINPT4 DC    A(0)                .\nPCTINPT5 DC    A(0)                .\nPCTINPT6 DC    A(0)                .\nPCTINPT7 DC    A(0)                .\nPCTINPT8 DC    A(0)                .\nPCTINPT9 DC    A(0)                .\nPCTOUTPT DC    A(0)                Address of output record\nPCTUBFA  DC    A(0)                Address of user buffers\nPCTUBFB  DC    A(0)                .\nPCTUBFC  DC    A(0)                .\nPCTUBFD  DC    A(0)                .\nPCTUBFE  DC    A(0)                .\nPCTUBFF  DC    A(0)                .\nPCTUBFG  DC    A(0)                .\nPCTUBFH  DC    A(0)                .\nPCTUBFI  DC    A(0)                .\nPCTUBFJ  DC    A(0)                .\nPCTUBFK  DC    A(0)                .\nPCTUBFL  DC    A(0)                .\nPCTUBFM  DC    A(0)                .\nPCTUBFN  DC    A(0)                .\nPCTUBFO  DC    A(0)                .\nPCTUBFP  DC    A(0)                .\nPCTUBFQ  DC    A(0)                .\nPCTUBFR  DC    A(0)                .\nPCTUBFS  DC    A(0)                .\nPCTUBFT  DC    A(0)                .\nPCTUBFU  DC    A(0)                .\nPCTUBFV  DC    A(0)                .\nPCTUBFW  DC    A(0)                .\nPCTUBFX  DC    A(0)                .\nPCTUBFY  DC    A(0)                .\nPCTUBFZ  DC    A(0)                .\nPCTINPL1 DC    9F'0'               Lengths of current I/P records\nPCTOBUFL DC    F'0'                Current length of rec in O/P buffer\nPCTUBFL1 DC    26F'0'              Length's of user buffers\nPCTMACNT DC    F'0'                Master active count\nPCTCOUNT DC    F'0'                Current record number of INPUT1\nPCTFCB   DC    A(0)                Start of FCB chain\nPCTFILNO DC    F'0'                Input file number\nPCTMAINC DC    A(MAINCOMP)         Address of main Compiler logic\nPCTSUPP1 DS    F                   SUPPORT(ON) Getmain values\nPCTSUPP2 DS    F                   SUPPORT(ON) Getmain values\nPCTPOPLS DC    A(0)                Last POP'ed Next sentence adcon\nPCTNEST  DC    F'0'                Count of nested IF's\nPCTNEXT  DC    20A(0)              Stack of next sentences.\nPCTUCTRA DC    F'0'                User counters A -> Z\nPCTUCTRB DC    F'0'                .\nPCTUCTRC DC    F'0'                .\nPCTUCTRD DC    F'0'                .\nPCTUCTRE DC    F'0'                .\nPCTUCTRF DC    F'0'                .\nPCTUCTRG DC    F'0'                .\nPCTUCTRH DC    F'0'                .\nPCTUCTRI DC    F'0'                .\nPCTUCTRJ DC    F'0'                .\nPCTUCTRK DC    F'0'                .\nPCTUCTRL DC    F'0'                .\nPCTUCTRM DC    F'0'                .\nPCTUCTRN DC    F'0'                .\nPCTUCTRO DC    F'0'                .\nPCTUCTRP DC    F'0'                .\nPCTUCTRQ DC    F'0'                .\nPCTUCTRR DC    F'0'                .\nPCTUCTRS DC    F'0'                .\nPCTUCTRT DC    F'0'                .\nPCTUCTRU DC    F'0'                .\nPCTUCTRV DC    F'0'                .\nPCTUCTRW DC    F'0'                .\nPCTUCTRX DC    F'0'                .\nPCTUCTRY DC    F'0'                .\nPCTUCTRZ DC    F'0'                .\nPCTBFCDF DC    AL1(COPYBUFF)       COPYBUFF default for INPUT1\nPCTEOFFL DC    X'FF'               Buffer fill character at EOF\nPCTPADCH DC    X'40'               Buffer fill character (Buffers)\nPCTSUBSV DC    A(SUBSAVE1)         Current stack pointer\nPCTIMEMB DC    CL8' '              I/P Member in PDSMODE\nPCTOMEMB DC    CL8' '              O/P Member name to create\nPCTMEMBT DC    A(0)                Address of member table\nPCTMEMBC DC    A(0)                'Current' member name\nPCTRESET DC    A(0)                Address of reset chain\nPCTUPARM DC    CL8' '              User PARM field\n         EJECT\n*---------------------------------------------------------------------+\n*        Miscellaneous work areas                                     |\n*---------------------------------------------------------------------+\nONESEC   DC    F'38400'\nHEXFFS   DC    X'FFFFFFFF'\n         CNOP  2,4\n         DS    C\nFOXZERO  DC    X'F0'               Must be in front of zeros\nZEROS    DC    32X'00'\nSNPTR    DC    C'0123456789ABCDEF'\nSNPREGS  DS    6F\nDBL      DC    D'0'\n         DC    D'0'                Don't move, used by TIME STCK\nDBL2     DS    2D\nALTAKWLN DC    F'0'\nALTGTSVR DS    F\nDEFLRECL DC    H'0'\nDEFBLKSI DC    H'0'\nDEFRECFM DC    X'00'\nPROLRECL DC    H'0'\nPROBLKSI DC    H'0'\nCOMNTCTL DC    P'000'              Comment nest counter\nIFEXR    DC    A(0)\nSTAESAVE DS    16F\nOPRSAVE  DS    16F\nCPYSV    DS    16F\nDMPSV    DS    16F\nALTGEDT1 DC    X'4020206B2020206B2020206B20212060'\nALTGEDT2 DC    X'402020206B2020206B2021204B202060'\nERRSV1   DS    F\nERRCWORK DC    16X'00'\nDDNAME   DS    CL8\nDEVTAB   DS    2F\nOPEXSV14 DS    F\nOPEXFCBP DS    F\nJFCB     DS    CL176\nOBTCMLST CAMLST SEARCH,JFCB,JFCBVOLS,DSCB\nDCBHLREC DC    H'0'\nDCBALREC DC    H'0'\nDCBASNO  DC    PL3'0'\nDCBAWNO  DC    PL3'0'\nDMPADDR  DS    F\nDMPLRECL DS    H\nTRSV     DS    4F\nWKTIOT   DS    2F\n         CNOP  2,4                 Align the next\n         DC    X'00'               few fields\nTRFLAG   DC    AL1(DUMP+SPTR)\nTRADDR   DC    XL4'00'\nTRLGTH   DC    XL4'00'\nMSG52CLS DC    C' '\nTSOREADY DC    C'SELECTIT.. Ready'\nTRHD     DC    C'(........) Rec ',X'20202020202120',C')'\nERRTMSG  DC    CL132' '\nMDSYSP   DC    H'8',C'SYSPRINT',AL2(DSYSPRT)\nMDSYSI   DC    H'5',C'SYSIN   ',AL2(DSYSIN)\nMDINPT1  DC    H'6',C'INPUT1  ',AL2(DINPUT1)\nMDOUTP1  DC    H'7',C'OUTPUT1 ',AL2(DOUTPUT1)\n         DC    X'00000000'\nTRLINE   DC    CL133' '\n         DC    C'X'\nTRPOS    DC    A(TRLINE+31)        Current position in trace line\nTREND    DC    A(TRLINE+131)       End of trace line\n*\nSTCKWORK DS    XL16                Work area for STCKCONV\n*\nTIMEWORK DS    0D\nTIMEXVAL DC    XL8'00'\nTIMEDMY  DC    CL7' '\n         DC    C' '\nTIMEYDDD DC    CL7'(     )'\n         DC    C' '\nTIMEHMSH DC    CL14' '\n         DC    C' '\nTIMECENT DC    C'        '\nEDITPAT1 DC    X'402120207A20207A20204B2020202020'\nMTHTAB   DC    C'JanFebMarAprMayJunJulAugSepOctNovDec'\nSWASAVE  DS    16F\n         TITLE 'PARSE work areas'\n*---------------------------------------------------------------------+\n*        PARSE routine areas.                                         |\n*---------------------------------------------------------------------+\n*\n*              WFLAG1 is set by PARSE to show what was 'seen'\n*\nWFLAG1   DC    X'00'\nWPREF          EQU   X'80'         Prefix is present\nWWRD1          EQU   X'40'         WRD1   is present\nWWRD2          EQU   X'20'         WRD2   is present\nWTRLR          EQU   X'10'         TRLR   is present\nWPLUS          EQU   X'08'         WRD1/WRD2 connected by +\nWMINUS         EQU   X'04'         WRD1/WRD2 connected by -\n*\n*              WFLAG2 set by caller of OPGEN to say what's wanted/O.K.\n*\nWFLAG2   DC    X'00'\nWAOP           EQU   X'80'         Generate an A-operand\nWBOP           EQU   X'40'         Generate a  B-operand\nWPREFOK        EQU   X'20'         Prefixing is allowed\nWTRLROK        EQU   X'10'         Trailers are allowed\nWPMOK          EQU   X'08'         +/- operands allowed\nWLITOK         EQU   X'04'         Literals are allowed\nWIPDEF         EQU   X'02'         I/O default to Input (else Output)\n*\n*---------------------------------------------------------------------+\n*   If the 1st 12 bytes of these 4 scan areas change then the code at |\n*   the beginning of PARSE which clears them must also be altered.    |\n*---------------------------------------------------------------------+\n*\nPREFNUM1 DC    F'0'                Prefix area\nPREFNUM2 DC    F'0'\nPREFF1   DC    X'00'\nPREFF2   DC    X'00'\nPREFL    DC    H'0'\nPREFTXT  DC    CL10' '\nPREFADDR EQU   PREFTXT,4,C'A'\nPREFL2   DC    H'0'\nPREFTXT2 DC    CL10' '\nPREFKW1  DS    CL(KWENTL)\nPREFKW2  DS    CL(KWENTL)\n*\nWRD1NUM1 DC    F'0'                Main word area\nWRD1NUM2 DC    F'0'\nWRD1F1   DC    X'00'\nWRD1F2   DC    X'00'\nWRD1L    DC    H'0'\nWRD1TXT  DC    CL10' '\nWRD1ADDR EQU   WRD1TXT,4,C'A'\nWRD1L2   DC    H'0'\nWRD1TXT2 DC    CL10' '\nWRD1KW1  DS    CL(KWENTL)\nWRD1KW2  DS    CL(KWENTL)\n*\nWRD2NUM1 DC    F'0'                +/- word area\nWRD2NUM2 DC    F'0'\nWRD2F1   DC    X'00'\nWRD2F2   DC    X'00'\nWRD2L    DC    H'0'\nWRD2TXT  DC    CL10' '\nWRD2ADDR EQU   WRD2TXT,4,C'A'\nWRD2L2   DC    H'0'\nWRD2TXT2 DC    CL10' '\nWRD2KW1  DS    CL(KWENTL)\nWRD2KW2  DS    CL(KWENTL)\n*\nTRLRNUM1 DC    F'0'                Trailer word area\nTRLRNUM2 DC    F'0'\nTRLRF1   DC    X'00'\nTRLRF2   DC    X'00'\nTRLRL    DC    H'0'\nTRLRTXT  DC    CL10' '\nTRLRADDR EQU   TRLRTXT,4,C'A'\nTRLRL2   DC    H'0'\nTRLRTXT2 DC    CL10' '\nTRLRKW1  DS    CL(KWENTL)\nTRLRKW2  DS    CL(KWENTL)\n         TITLE 'Code generation work areas'\n*---------------------------------------------------------------------+\n*        Data work areas for generation of operand addresses.         |\n*---------------------------------------------------------------------+\n         DS    0F\nORLCODE  BAL   R15,COMP15X4        BAL over data\nOREGM    DS    0F\nOREGALEN DC    X'00'               Length of A-operand\nOREGDLMT DS    0AL3(0)             Address of DLM TRT table\nOREGFLAG DC    X'00'               Flag? Spare for now\nOREGBLEN DC    H'0'                Length of B-operand\nORLICM   ICM   OREG,15,0(R15)      Load OREG\nORLMVI   MVI   PCTIOFLG,0          Restore PCTIOFLG\nORLMVID  EQU   *-3,1,C'X'          Data portion of prev instr.\nORLM999  EQU   *                   End of OREG code\n*\nORLLCOD  ICM   OREG,15,0           Load KW data as length operand\nORLLCODB BCTR  OREG,0              -1 for EX (Sometimes)\n         DS    0F\n*\nOPGCODE  BAL   R15,COMP15X8        BAL over data\nOPGBASE  DC    A(0)                Base value for ICM1 and ICM2 below\n*                                  Hi byte of OPGBASE has the file\n*                                  ID when we're pointing at a file\n*                                  buffer, or 00 when pointing at a\n*                                  literal or fixed memory location.\nOPGDISPL DC    F'0'                Displacement value\nOPGICM1  ICM   AREG,15,0(R15)      Load base value into register\nOPGICM2  ICM   AREG,7,1(AREG)      Do indirect load\nOPGADD1  AL    AREG,4(,R15)        Add displacement\nOPGENDC  EQU   *\n*\nOPGBCTR  BCTR  AREG,0              Decr. when KW displacement used\n*\nOPGSWAP1 LR    AREG,BREG           Swap value to correct reg\n*\nOPGMASK  DS    0XL12               Mask to clear AREG/BREG from instr.\nOPGMASK1 DC    X'FF0FFFFF'         ICM 1\nOPGMASK2 DC    X'FF0F0FFF'         ICM 2\nOPGMASK3 DC    X'FF0FFFFF'         AL\n*\nOPGAREG  DS    0XL12               Model to set to AREG\nOPGAREG1 DC    X'00',AL1(AREG*16),X'0000'          ICM 1\nOPGAREG2 DC    X'00',2AL1(AREG*16),X'00'           ICM 2\nOPGAREG3 DC    X'00',AL1(AREG*16),X'0000'          AL\n*\nOPGBREG  DS    0XL12               Model to set to BREG\nOPGBREG1 DC    X'00',AL1(BREG*16),X'0000'          ICM 1\nOPGBREG2 DC    X'00',2AL1(BREG*16),X'00'           ICM 2\nOPGBREG3 DC    X'00',AL1(BREG*16),X'0000'          AL\n*\nOPGCADDR DS    F                   Address where code stuffed\n         EJECT\n*---------------------------------------------------------------------+\n*        SELECT routine work areas                                    |\n*---------------------------------------------------------------------+\nSELSNEXT DS    F                   Temp save next sent Adcon address\n         DS    0F\n*\nSELGBAL1 BAL   R15,SELGLDEX-SELGBAL1(R14) Get addressable\nSELID    DC    X'CC'               Control block ID\nSELF1    DC    X'00'               SELECT flag 1\nCHAR           EQU         X'80'   CHAR dump requested\nHEX            EQU         X'40'   HEX   \"      \"\nDUMP           EQU         X'C0'   HEX/CHAR dump requested\nCOPY           EQU         X'20'   Copy to output DD requested\nSPTR           EQU         X'10'   Special pointers for IODUMP\nSELF2    DC    X'00'               SELECT flag 2\nSELF3    DC    X'00'               SELECT flag 3\nSELSRECD DC    F'0'                SREC record number\nSELBREC  DC    F'0'                BY record number\nSELBCTR  DC    F'0'                BY record counter\nSELNREC  DC    F'0'                Number of records\nSELODCB  DC    A(0)                Address of output ctl area\nSELNEXTS DC    A(0)                Address of next sentence\nSELNLGTH DC    F'0'                Data length for this select\nSELGLDEX LM    R2,R3,$SELNXTS      Load exit addresses\nSELGSWP1 LR    R14,R2              Put next sent in R14\nSELGICRC ICM   R1,15,$SELNREC      Load number of records\nSELGTZ1  BZR   R14                 If zero, go next sentence\nSELGCRTS CLC   $SELSREC,PCTCOUNT   At start rec yet?\nSELGNSSK BHR   R14                 No, go to next sentence\nSELGBALO BAL   R14,OPROUTE         Bal to copy output control\nSELGBCT1 BCTR  R1,0                Decrement number of recs\nSELGSTNR ST    R1,$SELNREC         And store it back\nSELGBALT BALR  R7,0                Get addressable for SELGUPSK\nSELGALLT LTR   R1,R1               All records selected?\nSELGUPSK BNZ   SELGLGO-SELGALLT(R7) Skip over table flag update\nSELGLMAC L     R1,PCTMACNT         Get master actv count\nSELGBCT2 BCTR  R1,0                Decr. It\nSELGSMAC ST    R1,PCTMACNT         Store it back\nSELGLGO  BAL   R14,COMPGOTO        Go via GOTO support routine\nSELGOTOA DC    XL4'00'             GOTO address\nSELGM999 EQU   *\n         DC    H'0'\nSELGOTOH DC    CL80' '             Hold for actual GOTO name\n         DS    0F\nSELSKDF  DC    AL1(63),AL3(ZEROC)\nSELEKDF  DC    AL1(63),AL3(FFFF)\n         TITLE 'EXecuted instructions'\n*---------------------------------------------------------------------+\n*        EXecuted instructions                                        |\n*---------------------------------------------------------------------+\nDMPTR1   TR    LINE+31(0),0(R15)\nGETFTRT  TRT   0(0,R3),0(R14)\nGETMV1   MVC   0(0,R2),0(R3)\nGETOR1   OC    0(0,R3),BLANKS\nGETOR2   OC    0(0,R2),BLANKS\nKEYCOMP  CLC   0(0,R1),0(R2)\nLITTNUM  TRT   0(0,R2),0(R14)\nLITPACK  PACK  DBL,0(0,R2)\n         TITLE 'Extra ALTER work areas'\n*---------------------------------------------------------------------+\n*        ALTER command work areas and model code                      |\n*---------------------------------------------------------------------+\nALTD1    DC    F'0'                Save for KWD1 answer value\nALTD3    DC    F'0'                Save for KWD3 answer value\nALTGDISP DC    F'0'                Displacement of A-operand\nALTLITSV DC    F'0'                Save for address of DLM literal\nALTGABUF DC    X'00'               Buffer index of A-operand\n*\nALTGMMVC EX    OREG,COMPMVC        Execute MVC instruction\nALTGMST1 LA    OREG,1(,OREG)       Make length actual again\nALTGMST2 ST    OREG,PCTFLEN        Save as ALTER's length\nALTGMAND EX    OREG,COMPNC         Execute NC  instruction\nALTGMOR  EX    OREG,COMPOC         Execute OC  instruction\nALTGMXOR EX    OREG,COMPXC         Execute XC  instruction\nALTGMTR  EX    OREG,COMPTR         Execute TR  instruction\n*\nALTGMREP BAL   R14,REPLACE         Go do replace\n*\nALTGMHEX BAL   R14,HEXIT           Go do Hex conversion\n*\nALTGRCST OI    PCTF6,USERRC        Remember user altered RCODE\n         TITLE 'Model Code and Associated work areas'\nDCOPM010 BAL   R14,DCOPYDAT        See if deferred copy needed\n*---------------------------------------------------------------------+\n*        Getword routine work areas                                   |\n*---------------------------------------------------------------------+\nGETPTR   DC    A(0)                Ptr to next loc in card\nGETSCLN  DC    A(0)                Length to scan\nGETWDPT  DC    A(0)                Next available loc in 'word'\nGETCTR1  DC    PL3'0'              Count of cards read\nGETCTR2  DC    PL3'0'              Count of word in a card\nGETDPTRS DC    A(GETDF1,GETDF2,0,GETDF3,0)\nGETIMAGE DC    A(0)                Ptr to start of card\nGETWSTRT DC    A(0)                Ptr to start of word\n         EJECT\n*---------------------------------------------------------------------+\n*        LITPOOL routine work areas                                   |\n*---------------------------------------------------------------------+\nLIT1STQ  DS    F                   Loc. Of 1st quote\nLIT2NDQ  DS    F                   Loc. Of 2nd quote\nLITZERO  DC    C'0000'             Const. Must be on word boundary\nLITW1    DS    F                   Work field\nLITFILL  DS    C                   Fill char if lgth > supplied value\nLITL     DS    F                   Effective length of processed lit.\nLITA     DS    A                   Absolute address of literal\nLITR     DC    F'1'                Literal repeat factor\nLITSRSV  DS    3F                  Repeat regs save area\nLITLGTH  DC    H'0'                Temp work value of lit. Length\nLITT     DC    C' '                Type of last literal processed\n*\n*---------------------------------------------------------------------+\n*        PGMSTUFF routine work areas                                  |\n*---------------------------------------------------------------------+\nPGMIC    DC    F'0'                Instruction counter\nPGMRESID DC    F'0'                Remaining area in curr. Getmain\nPGMRSTRT DC    2F'0'               Save in case restart invoked\n*\n*        NOTE! The following link code MUST NOT alter the cc!\n*\n         DS    0F\nPGMLINKS BALR  R14,0               Get locally addressable\n         L     R14,6(R14)          Load address of next block\n         BR    R14                 Go to it\nPGMMADCN DC    4X'00'              Address to be stuffed\nPGMLINKE EQU   *                   End of linkage code\n*\n*---------------------------------------------------------------------+\n*        Label table routine work areas                               |\n*---------------------------------------------------------------------+\nLBLHOLD  DC    CL8' '              Temp hold of label to be added\nLBLIN    DC    A(0)                Start of label table in\nLBLINCT  DC    F'0'                Number of empty entries in tbl\nLBLOUT   DC    A(0)                Start of unresolved label table\nLBLOUTCT DC    F'0'                Number of empty entries in tbl\nLBLSV12  DC    A(0,0)              Save for R1,R2\n         EJECT\n*---------------------------------------------------------------------+\n*        Miscellaneous equates                                        |\n*---------------------------------------------------------------------+\nDCBDEVT  EQU   17\nDCBDSORG EQU   26\nDCBBFTEK EQU   32\nDCBEODAD EQU   33\nDCBRECFM EQU   36\nDCBEXLST EQU   37\nDCBDDNAM EQU   40\nDCBOFLAG EQU   48\nDCBMACRF EQU   50\nDCBOPTCD EQU   52\nDCBBLKSI EQU   62\nDCBRECAD EQU   76\nDCBEXCD1 EQU   80\nDCBLRECL EQU   82\nDS1DSORG EQU   82\nDS1RECFM EQU   84\nDS1BLKSI EQU   86\nDS1LRECL EQU   88\nJFCDSNAM EQU   JFCB,44,C'C'\nJFCBELNM EQU   JFCB+44,8,C'C'\nJFCLRECL EQU   JFCB+62,2,C'H'\nJFCBIND1 EQU   JFCB+86,1,C'X'\nJFCDSORG EQU   JFCB+98,2,C'X'\nJFCRECFM EQU   JFCB+100,1,C'X'\nJFCBLKSI EQU   JFCB+102,2,C'H'\nJFCBNVOL EQU   JFCB+117,1,C'X'\nJFCBVOLS EQU   JFCB+118,30,C'C'\n         TITLE 'Big crap'\nBLANKS   DC    CL133' '\nPARMDATA DC    CL120'OPTIONS '\nMASKTBL  DC    X'00',255X'FF'\nTRTABLE  DC    XL256'00'\nWORDL    DC    H'0'\nWORDTXT  DS    CL300\nSUBSAVE1 DS    50A(0)              GOSUB stack\nSUBSAVE2 EQU   *                   End of stack\n         TITLE 'SWA Block access'\n*---------------------------------------------------------------------+\n*        Routine to get a block from SWA                              |\n*---------------------------------------------------------------------+\n         PUSH  USING\n         DROP\n         USING GTSWABLK,R2\n*\nGTSWABLK ST    R14,GTSWARET        Save ret address\n         LA    R0,ZBAREA           Init pointer\n         ST    R0,ZBPTR            to area for SWAREQ\n         MVC   SWVA-ZB505+ZBAREA,0(R1) Copy token\n         L     R1,=A(*+6+X'80000000')  31-bit mode\n         BSM   R0,R1               ...\n         SWAREQ EPA=ZBPTR,FCODE=RL, Get block                          X\n               UNAUTH=YES,                                             X\n               MF=(E,SWALIST)\n         LTR   R15,R15             Got block ?\n         BNZ   GTSWAXIT            No - err exit\n         L     R15,SWPFXPTR-ZB505+ZBAREA Get blk prefix addr\n         L     R1,SWLNGTH-ZB505+ZBAREA   Get block len\n         AH    R1,SWPFXLTH-ZB505+ZBAREA  + prefix len\n         BCTR  R1,0                      -1 for \"EX\"\n         MVC   SWABLKA(0),0(R15)   Move prefix + block\n         EX    R1,*-6              ...\n         SLR   R15,R15             Set rc=0\n*\nGTSWAXIT LA    R1,*+6              24-bit\n         BSM   R0,R1               ...\n         L     R14,GTSWARET        Load return address\n         BR    R14                 Exit, rc= R15\nGTSWARET DS    A\n*\nSWALIST  SWAREQ MF=L\n*\nZBAREA   DS    CL(L'SWAEPAX)       SWA manager work area\nZBPTR    DS    F\nSWABLKA  DS    CL256\n         LTORG\n         POP   USING\n         TITLE 'Unaddressable (Normally) Data areas'\n*---------------------------------------------------------------------+\n*        Error message text strings                                   |\n*---------------------------------------------------------------------+\n         PRINT NOGEN\n         $TXT  1,RSVDWD,'Reserved label used.'\n         $TXT  2,BADC,'Invalid command type.'\n         $TXT  3,NOPER,'Period missing, assumed.'\n         $TXT  4,BADAT,'Invalid ALTER type code.'\n         $TXT  5,BADN,'Invalid numeric operand.'\n         $TXT  6,LITBT,'Invalid literal type.'\n         $TXT  7,LITBH,'Invalid HEX value.'\n         $TXT  8,LITBL,'Invalid literal length.'\n         $TXT  9,LITBQ,'Invalid use of quotes in literal.'\n         $TXT  10,LITBN,'Invalid numeric value in literal.'\n         $TXT  11,LBLDP,'Duplicate label encountered, ignored.'\n         $TXT  12,UNRES,'Unresolved label.'\n         $TXT  13,BDDST,'Operand invalid as a destination field'\n         $TXT  14,BADPT,'Invalid PRINT request.'\n         $TXT  15,BADKW,'Invalid keyword found.'\n         $TXT  16,NODO,'No ''END'' encountered for a ''DO'' group or inX\n               complete ''IF'' command.'\n         $TXT  17,BKEY,'Invalid KEY operand.'\n         $TXT  18,LCONF,'Conflicting length operands detected'\n         $TXT  19,BKWV,'Invalid value for a KEYWORD operand.'\n         $TXT  20,NESTH,'IF/DO nesting level exceeded.'\n         $TXT  21,KFULL,'More than 100 key ranges specified.'\n         $TXT  22,SP06,' '\n         $TXT  23,SELWY,'SELECT command has NO purpose to exist.'\n         $TXT  24,BIF,'Invalid operator for ''IF''.'\n         $TXT  25,IFREL,'Invalid ''IF'' connector or conditional commanX\n               d'\n         $TXT  26,NULLR,'No SYSIN found and unable to generate internalX\n                defaults.'\n         $TXT  27,SP05,' '\n         $TXT  28,BADDO,'''END'' is allowed only as part of a ''DO'' grx\n               oup.'\n         $TXT  29,ODCB,'OPEN failure on XXXXXXXX'\n         $TXT  30,TERM,'Run cancelled due to compile time diagnostics.'\n         $TXT  31,MCONT,'Missing continuation card(s) at EOF on SYSIN.'\n         $TXT  32,NOOPS,'Invalid or missing operand.'\n         $TXT  33,NOUT,'No XXXXXXXX DD statement is present.'\n         $TXT  34,DSUT,'OBTAIN failure on XXXXXXXX Dsname.'\n         $TXT  35,MAXI,'Input DD must be INPUT1 thru INPUT9.'\n         $TXT  36,BACTV,'SYSIN EOF has caused an incomplete command.'\n         $TXT  37,MSG37,' 9,999,999 Records read from DD=xxxxxxxx DSN= X\n                                                                       X\n                '\n         $TXT  38,PEOF,'READ past end of file on (XXXXXXXX) during StatX\n               ement No. 9999 Word No. 999'\n         $TXT  39,MSG39,'           DSORG=XX  RECFM=XXXXX   LRECL=99999X\n                  BLKSIZE=99999 '\n         $TXT  40,MSG40,'           **** Input / Output  Statistics  byX\n                 DDname ****'\n         $TXT  41,IUNK,'Unknown error occurred on INPUT1'\n         $TXT  42,IIO,'Permanent I/O error on INPUT1'\n         $TXT  43,IBKEY,'KEY                      cannot be found, willX\n                try next range.'\n         $TXT  44,ABND,'ABEND XXX on record number 99999999 during StatX\n               ement No. 9999 Word No. 999'\n         $TXT  45,NOSTA,'STAE setup not successful.'\n         $TXT  46,SPACE,' '\n         $TXT  47,NOOP,'No OUTPUT functions requested, run cancelled.'\n         $TXT  48,FLOAT,'Both Source and Destination may not be Floatinx\n               g operands'\n         $TXT  49,BADMD,'DDname used as both INPUT and OUTPUT.'\n         $TXT  50,WTBIG,'Excessively long word ignored, Check for invalX\n               id quoted strings.'\n         $TXT  51,LOOPR,'User Abend forced due to loop detection in useX\n               r commands.'\n         $TXT  52,MVOLS,'           On volume(s) - (111111,222222,33333X\n               3,444444,555555)'\n         $TXT  53,BDDN,'Invalid use of DDname.'\n         $TXT  54,SUPER,'SUPPORT(ON) must occur before any executable sX\n               tatements'\n         $TXT  55,SP01,' '\n         $TXT  56,SP02,' '\n         $TXT  57,IMASK,'MASK is only allowed with literal operands.'\n         $TXT  58,IMASK1,'? may not be the first char. of MASK literal.X\n               '\n         $TXT  59,BADOP,'Invalid operand format or usage.'\n         $TXT  60,BFLOAT,'Invalid floating operand request'\n         $TXT  61,BLGTH,'Invalid length operand'\n         $TXT  62,BUFFR,'User Abend forced due to ALTER command ''reachX\n               ing'' outside buffer limits'\n         $TXT  63,BUFFX,'Location + length is larger than maximum BUFFEX\n               R size'\n         $TXT  64,BDOPT,'OPTIONS statement must be the very first commaX\n               nd'\n         $TXT  65,UCTRH,'           **** User Counters  (Zero values noX\n               t shown) ****'\n         $TXT  66,UCTRL,'                                              X\n                                                       '\n         $TXT  67,EJRC,'           SELECTIT ended with RC =            X\n                           '\n         $TXT  68,LRECX,'User Abend forced due to detection of Output fX\n               ile LRECL greater than maximum.'\n         $TXT  69,BELSE,'Incorrectly placed ELSE.'\n         $TXT  70,BELSB,'Unsupported command following ELSE.'\n         $TXT  71,CCLOS,'Unterminated comment sentence at EOF on SYSIN.X\n               '\n         $TXT  72,ILLOG,'Illogical combination of operands.'\n         $TXT  73,SP07,' '\n         $TXT  74,TCMPL,'Maximum AND/OR limit in an IF has been excededX\n               .'\n         $TXT  75,EXTP,'Extraneous period detected, ignored.'\n         $TXT  76,DOP1,'User Abend forced due to DEFER OPEN logic failuX\n               re.'\n         $TXT  77,DOP2,'DEFER OPEN of xxxxxxxx failed. Run terminated.'\n         $TXT  78,CLOSI,'I/O directed to file which has been closed.'\n         $TXT  79,SP03,' '\n         $TXT  80,SP04,' '\n         $TXT  81,SUBEX,'Too many GOSUBs without accompanying GOBACKs hX\n               ave been issued.'\n         $TXT  82,BAKEX,'Too many GOBACKs without accompanying GOSUBs hX\n               ave been issued.'\n         $TXT  83,PEMPT,'No members in input dataset for PDS mode proceX\n               ssing.'\n         $TXT  TYPE=END\n         PRINT NOGEN\n         EJECT\n*---------------------------------------------------------------------+\n*        Miscellaneous translate tables                               |\n*---------------------------------------------------------------------+\nTRTBLDLM DC    64X'00',X'04',10X'00',X'08',49X'00',X'0C',130X'00'\nTRTBLNB  DC    64X'FF',X'00',191X'FF'\nTRTBLB   DC    64X'00',X'FF',191X'00'\nTRTBLQ   DC    125X'00',X'FF',130X'00'\nTRTBLN   DC    240X'FF',10X'00',6X'FF'\nTRTBLX   DC    129X'FF',X'0A0B0C0D0E0F'\n         DC    58X'FF',X'0A0B0C0D0E0F',41X'FF'\n         DC    X'00010203040506070809',6X'FF'\nTRTBLNN  DC    240X'00',10X'FF',6X'00'\nTRTBLLH  DC    16C'0',16C'1',16C'2',16C'3',16C'4',16C'5',16C'6'\n         DC    16C'7',16C'8',16C'9',16C'A',16C'B',16C'C',16C'D'\n         DC    16C'E',16C'F'\nTRTBLRH  DC    16C'0123456789ABCDEF'\nTRTBLC   DC    74C' ',C'\u00f3.<(+|&&',9C' ',C'!$*);\u00bc-/',8C' ',C'\u00aa,%_>?'\n         DC    9C' ',C'`:#@''=\"'\n         DC    C' abcdefghi {     jklmnopqr }      stuvwxyz',22C' '\n         DC    C'{ABCDEFGHI      }JKLMNOPQR      \\ STUVWXYZ      '\n         DC    C'0123456789|     '\nTRTBLDIT DC    256AL1(*-TRTBLDIT)\n*---------------------------------------------------------------------+\n*        Miscellaneous work fields                                    |\n*---------------------------------------------------------------------+\nFFFF     DC    64X'FF'\nZEROC    DC    64X'00'\nDSCB     DS    CL148\n         DS    0H\n         DC    X'00000000'\nLINHD1   DC    CL133'1SELECTIT (xxxx)'\n         ORG   LINHD1+125\n         DC    C'Page'\n         ORG\n         DC    C'X',X'00000000'\nLINHD2   DC    CL133' (C) Copyright G.D. Deluca 1974, 2019'\n         DC    C'X',X'00000000'\nLINHD2A  DC    CL133'-Stmnt #  Word #  C o m m a n d s   /   M e s s a X\n               g e s   . . .'\n         DC    C'X',X'00000000'\nLINHD3   DC    CL32' '\n         DC    C'----+----1----+----2----+----3----+----4----+----5----X\n               +----6----+----7----+----8----+----9----+----0 '\n         DC    C'X',X'00000000'\nLINHD4   DC    CL133'-Stmnt #  Word #  M e s s a g e . . . . .'\n         DC    C'X',X'00000000'\nLINHD9   DC    CL133'-',C'X'\nLINHD1T  EQU   LINHD1+70\n         EJECT\n*\nKWTBL    DS    0F\n         $KW   E0,*\nCOMMENT        EQU   X'E0'\n         $KW   E1,RETURN\n         $KW   E1,EOJ\nRESERVED       EQU   X'E1'\n         $KW   30,=,F1=KWIFREL,D1=X'80000000'\n         $KW   31,>,F1=KWIFREL,D1=X'20000000'\n         $KW   34,>=,F1=KWIFREL,D1=X'B0000000'\n         $KW   32,<,F1=KWIFREL,D1=X'40000000'\n         $KW   35,<=,F1=KWIFREL,D1=X'D0000000'\n         $KW   33,<>,F1=KWIFREL,D1=X'70000000'\n         $KW   31,\u00bc<=,F1=KWIFREL,D1=X'20000000'\n         $KW   32,\u00bc>=,F1=KWIFREL,D1=X'40000000'\n         $KW   33,\u00bc=,F1=KWIFREL,D1=X'70000000'\n         $KW   34,\u00bc<,F1=KWIFREL,D1=X'B0000000'\n         $KW   35,\u00bc>,F1=KWIFREL,D1=X'D0000000'\n         $KW   27,ADD,F1=KWALTER,D1=F'24',D3=A(ALTGPLUS)\n         $KW   29,ADDP,F1=KWALTER,D1=F'32',D3=A(ALTGAP)\n         $KW   93,ALL,F1=KWSUBVAL\n         $KW   53,ALTER,F1=KWMAJ+KWIFTRU,D2=A(IFALTER),D3=A(ALTER)\n         $KW   23,AND,F1=KWALTER+KWIFTRU,D1=F'8',D2=A(IFAND),          X\n               D3=A(ALTGAND)\n         $KW   49,AUTOCOPY,F1=KWOPRAND+KWSUBVAL,D2=A(OPTAUTO)\n         $KW   C7,BLKSIZE,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,         X\n               D1=A(FCBBLKSI-FCBDSECT),D3=F'2'\n         $KW   82,BY,F1=KWOPRAND+KWSUBVAL,D1=A(SELBY)\n         $KW   22,C,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)\n         $KW   91,CBLKSIZE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTCBLK)\n         $KW   CF,CENTURY,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X\n               D1=A(TIMECENT),D3=F'2'\n         $KW   96,CHAR,F1=KWSUBVAL,D1=AL1(CHAR,0,0,0)\n         $KW   5D,CLOSE,F1=KWMAJ+KWIFTRU,D2=A(IFCLOSE),D3=A(CLOSE)\n         $KW   22,COPY,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)\n         $KW   26,COPYBUFF,F1=KWALTER+KWOPRAND+KWSUBVAL,D2=A(NEXTBUFF)\n         $KW   C0,CREC,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,            X\n               D1=A(FCBCREC-FCBDSECT),D3=F'4'\n         $KW   2F,CVBP,F1=KWALTER,D1=F'56',D3=A(ALTGCVBP)\n         $KW   2F,CVBZ,F1=KWALTER,D1=F'60',D3=A(ALTGCVBZ)\n         $KW   2F,CVZB,F1=KWALTER,D1=F'44',D3=A(ALTGCVZB)\n         $KW   2F,CVZP,F1=KWALTER,D1=F'40',D3=A(ALTGCVZP)\n         $KW   2F,CVPB,F1=KWALTER,D1=F'52',D3=A(ALTGCVPB)\n         $KW   2F,CVPZ,F1=KWALTER,D1=F'48',D3=A(ALTGCVPZ)\n         $KW   2F,CVXC,F1=KWALTER,D1=F'64',D3=A(ALTGCVXC)\n         $KW   AB,DATALEN,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWFCBFLD,  X\n               D1=A(FCBULRFW-FCBDSECT),D3=F'4'\n         $KW   A3,DATETIME,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWADRFLD,X\n               D1=A(TIMEWORK),D3=F'8'\n         $KW   A7,DAY,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,             X\n               D1=A(TIMEWORK+8),D3=F'2'\n         $KW   CA,DCB,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,     X\n               D1=A(FCBDCB-FCBDSECT),D3=F'4'\n         $KW   54,DEBUG,F1=KWMAJ+KWIFTRU,D2=A(IFDEBUG),D3=A(DEBUG)\n         $KW   4C,DEFER,F1=KWOPRAND+KWSUBVAL,D2=A(OPTDEFER)\n         $KW   27,DIV,F1=KWALTER,D1=F'24',D3=A(ALTGDIV)\n         $KW   51,DO,F1=KWIFTRU,D2=A(IFDO),D3=A(ELSEDO)\n         $KW   C2,DSNAME,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,  X\n               D1=A(FCBJFCB-FCBDSECT),D3=F'44'\n         $KW   C5,DSNAMEX,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD, X\n               D1=A(FCBDSNAM-FCBDSECT),D3=F'54'\n         $KW   C4,DSORG,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X\n               D1=A(FCBDSORG-FCBDSECT),D3=F'1'\n         $KW   94,DUMP,F1=KWSUBVAL,D1=AL1(DUMP,0,0,0)\n         $KW   2B,EDITP,F1=KWALTER,D1=F'68',D3=A(ALTGEDTP)\n         $KW   2C,EDITB,F1=KWALTER,D1=F'72',D3=A(ALTGEDTB)\n         $KW   2D,EDITP$,F1=KWALTER,D1=F'76',D3=A(ALTGEDP$)\n         $KW   2E,EDITB$,F1=KWALTER,D1=F'80',D3=A(ALTGEDB$)\n         $KW   5C,ELSE,F1=KWMAJ,D3=A(ELSE)\n         $KW   59,END,F1=KWMAJ,D3=A(END)\n         $KW   71,EOF,F1=KWOPRAND+KWSUBVAL,D2=A(NEXTEOF)\n         $KW   44,EOFFILL,F1=KWOPRAND+KWSUBVAL,D2=A(OPTEOFF)\n         $KW   46,EOFLABEL,F1=KWOPRAND+KWSUBVAL,D2=A(OPTEOFL)\n         $KW   30,EQ,F1=KWIFREL,D1=X'80000000'\n         $KW   70,FILE,F1=KWOPRAND+KWSUBVAL,D2=A(NEXTFILE)\n         $KW   D6,FLCHG,F1=KWOPRAND,F2=KWOPRPTR,F3=KWPCTFLD,           X\n               D1=A(PCTFLCHG-PCT),D3=F'4'\n         $KW   D7,FLEN,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,               X\n               F3=KWPCTFLD,D1=A(PCTFLEN-PCT),D3=F'4'\n         $KW   D2,FLOC,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,               X\n               F3=KWPCTFLD,D1=A(PCTPLOC-PCT),D3=F'4'\n         $KW   D3,FLOCEND,F1=KWOPRAND,F2=KWOPRPTR+KWOFFSET,            X\n               F3=KWPCTFLD,D1=A(PCTFLOCE-PCT),D3=F'4'\n         $KW   D5,FLOCTERM,F2=KWPMVALU+KWOFFSET,                       X\n               F3=KWPCTFLD,D1=A(PCTFLOCT-PCT),D3=F'4'\n         $KW   34,GE,F1=KWIFREL,D1=X'B0000000'\n         $KW   56,GETNEXT,F1=KWMAJ+KWIFTRU,D2=A(IFGNEXT),D3=A(NEXTREC)\n         $KW   52,GO,F1=KWMAJ+KWIFTRU+KWOPRAND+KWSUBVAL,D1=A(SELGOTO), X\n               D2=A(IFGOTO),D3=A(GOTO)\n         $KW   52,GOTO,F1=KWMAJ+KWIFTRU+KWOPRAND+KWSUBVAL,             X\n               D1=A(SELGOTO),D2=A(IFGOTO),D3=A(GOTO)\n         $KW   9C,GOBACK,F1=KWMAJ+KWIFTRU,D2=A(IFGOBACK),D3=A(GOBACK)\n         $KW   9C,GOSUB,F1=KWMAJ+KWIFTRU,D2=A(IFGOSUB),D3=A(GOSUB)\n         $KW   31,GT,F1=KWIFREL,D1=X'20000000'\n         $KW   95,HEX,F1=KWSUBVAL,D1=AL1(HEX,0,0,0)\n         $KW   57,IF,F1=KWMAJ,D3=A(IF)\n         $KW   AD,IMEMBER,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X\n               D1=A(PCTIMEMB),D3=F'8'\n         $KW   92,INIT,F1=KWSUBVAL,D2=F'12'\n         $KW   9A,INPUT,F1=KWOPRAND+KWSUBVAL,D2=A(CLOSINPT)\n         $KW   63,IODUMP,F1=KWOPRAND+KWSUBVAL,D2=A(DEBIODM)\n         $KW   62,IOTRACE,F1=KWOPRAND+KWSUBVAL,D2=A(DEBIOTR)\n         $KW   C3,JFCB,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,    X\n               D1=A(FCBJFCB-FCBDSECT),D3=F'176'\n         $KW   A0,JOBNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,         X\n               D1=A(LINHD1+38),D3=F'8'\n         $KW   A4,JULIAN,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,          X\n               D1=A(TIMEWORK+17),D3=F'5'\n         $KW   87,LENGTH,F1=KWOPRAND+KWSUBVAL,D1=A(SELDLEN)\n         $KW   AA,LINECTR,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWADRFLD,  X\n               D1=A(LINECT),D3=F'2'\n         $KW   C1,LRECL,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWFCBFLD,    X\n               D1=A(FCBOLREC-FCBDSECT),D3=F'2'\n         $KW   35,LE,F1=KWIFREL,D1=X'D0000000'\n         $KW   32,LT,F1=KWIFREL,D1=X'40000000'\n         $KW   3E,MASK,F1=KWIFREL,D1=X'80020000'\n         $KW   4D,MEMBSTAT,F1=KWOPRAND+KWSUBVAL,D2=A(OPTPDSST)\n         $KW   3F,MIX,F1=KWIFREL,D1=X'40010000'\n         $KW   A6,MONTH,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,           X\n               D1=A(TIMEWORK+10),D3=F'3'\n         $KW   CD,MONTHNUM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X\n               D1=A(TIMECENT+4),D3=F'2'\n         $KW   27,MULT,F1=KWALTER,D1=F'24',D3=A(ALTGMULT)\n         $KW   23,N,F1=KWALTER,D1=F'8',D3=A(ALTGAND)\n         $KW   33,NE,F1=KWIFREL,D1=X'70000000'\n         $KW   32,NGE,F1=KWIFREL,D1=X'40000000'\n         $KW   35,NGT,F1=KWIFREL,D1=X'D0000000'\n         $KW   31,NLE,F1=KWIFREL,D1=X'20000000'\n         $KW   34,NLT,F1=KWIFREL,D1=X'B0000000'\n         $KW   3F,NO,F1=KWIFREL+KWOPRVAL,D1=X'80010000',D2=F'8'\n         $KW   C8,NVOLS,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X\n               D1=A(FCBNVOLS-FCBDSECT),D3=F'1'\n         $KW   25,O,F1=KWALTER,D1=F'12',D3=A(ALTGOR)\n         $KW   48,OBFORCE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTOBFOR)\n         $KW   E3,OBUFF,F1=KWOPRAND,D2=A(PCTOUTPT-(FCBRECAD-FCBDSECT)),X\n               D3=F'10'\n         $KW   3F,OFF,F1=KWIFREL+KWOPRVAL,D1=X'80010000',D2=F'8'\n         $KW   AE,OMEMBER,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWADRFLD,  X\n               D1=A(PCTOMEMB),D3=F'8'\n         $KW   3F,ON,F1=KWIFREL+KWOPRVAL,D1=X'10010000',D2=F'4'\n         $KW   42,OPCHECK,F1=KWOPRAND+KWSUBVAL,D2=A(OPTOPCHK)\n         $KW   5B,OPTIONS,F1=KWMAJ,D3=A(OPTIONS)\n         $KW   25,OR,F1=KWALTER+KWIFTRU,D1=F'12',D2=A(IFOR),           X\n               D3=A(ALTGOR)\n         $KW   9B,OUTPUT,F1=KWOPRAND+KWSUBVAL,D2=A(CLOSOUTP)\n         $KW   45,PADCHAR,F1=KWOPRAND+KWSUBVAL,D2=A(OPTPADCH)\n         $KW   4F,PARM,F1=KWOPRAND,D2=A(OPTPARM)\n         $KW   4E,PDSMODE,F1=KWOPRAND,D2=A(OPTPDSMD)\n         $KW   D1,PLOC,F2=KWPMVALU,F3=KWPCTFLD,                        X\n               D1=A(PCTPLOC-PCT),D3=F'4'\n         $KW   D4,PLOCEND,F2=KWPMVALU,F3=KWPCTFLD,                     X\n               D1=A(PCTPLOCE-PCT),D3=F'4'\n         $KW   86,PRINT,F1=KWOPRAND+KWSUBVAL,D1=A(SELPRINT)\n         $KW   A2,PROCNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X\n               D1=A(LINHD1+56),D3=F'8'\n         $KW   21,R,F1=KWALTER,D1=F'4',D3=A(ALTGCOPY)\n         $KW   AC,RCODE,F1=KWOPRAND,F2=KWOPRPTR+KWDEST,F3=KWPCTFLD,    X\n               D1=A(PCTRC-PCT),D3=F'4'\n         $KW   C6,RECFM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWFCBFLD,           X\n               D1=A(FCBRECFM-FCBDSECT),D3=F'2'\n         $KW   80,RECS,F1=KWOPRAND+KWSUBVAL,D1=A(SELRECS)\n         $KW   5A,RUN,F1=KWMAJ,D3=A(MAINRUN-8)\n         $KW   55,SELECT,F1=KWMAJ+KWIFTRU,D2=A(IFSELECT),D3=A(SELECT)\n         $KW   81,SREC,F1=KWOPRAND+KWSUBVAL,D1=A(SELSREC)\n         $KW   A1,STEPNAME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X\n               D1=A(LINHD1+47),D3=F'8'\n         $KW   28,SUB,F1=KWALTER,D1=F'28',D3=A(ALTGSUBT)\n         $KW   2A,SUBP,F1=KWALTER,D1=F'36',D3=A(ALTGSP)\n         $KW   60,SUPPORT,F1=KWOPRAND+KWSUBVAL,D2=A(DEBSUPP)\n         $KW   20,T,F1=KWALTER,D1=F'20',D3=A(ALTGTRAN)\n         $KW   50,THEN,F1=KWNOISE+KWIFTRU,D2=A(IFGDONE)\n         $KW   A8,TIME,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,            X\n               D1=A(TIMEWORK+24),D3=F'5'\n         $KW   85,TODD,F1=KWOPRAND+KWSUBVAL,D1=A(SELTODD)\n         $KW   61,TRACE,F1=KWOPRAND+KWSUBVAL,D2=A(DEBTRAC)\n         $KW   20,TRANSLATE,F1=KWALTER,D1=F'20',D3=A(ALTGTRAN)\n         $KW   43,UBSIZE,F1=KWOPRAND+KWSUBVAL,D2=A(OPTUBUF)\n         $KW   E4,UBUFFA,F1=KWOPRAND,D2=A(PCTUBFA-(FCBRECAD-FCBDSECT)),X\n               D3=F'11'\n         $KW   E4,UBUFFB,F1=KWOPRAND,D2=A(PCTUBFB-(FCBRECAD-FCBDSECT)),X\n               D3=F'12'\n         $KW   E4,UBUFFC,F1=KWOPRAND,D2=A(PCTUBFC-(FCBRECAD-FCBDSECT)),X\n               D3=F'13'\n         $KW   E4,UBUFFD,F1=KWOPRAND,D2=A(PCTUBFD-(FCBRECAD-FCBDSECT)),X\n               D3=F'14'\n         $KW   E4,UBUFFE,F1=KWOPRAND,D2=A(PCTUBFE-(FCBRECAD-FCBDSECT)),X\n               D3=F'15'\n         $KW   E4,UBUFFF,F1=KWOPRAND,D2=A(PCTUBFF-(FCBRECAD-FCBDSECT)),X\n               D3=F'16'\n         $KW   E4,UBUFFG,F1=KWOPRAND,D2=A(PCTUBFG-(FCBRECAD-FCBDSECT)),X\n               D3=F'17'\n         $KW   E4,UBUFFH,F1=KWOPRAND,D2=A(PCTUBFH-(FCBRECAD-FCBDSECT)),X\n               D3=F'18'\n         $KW   E4,UBUFFI,F1=KWOPRAND,D2=A(PCTUBFI-(FCBRECAD-FCBDSECT)),X\n               D3=F'19'\n         $KW   E4,UBUFFJ,F1=KWOPRAND,D2=A(PCTUBFJ-(FCBRECAD-FCBDSECT)),X\n               D3=F'20'\n         $KW   E4,UBUFFK,F1=KWOPRAND,D2=A(PCTUBFK-(FCBRECAD-FCBDSECT)),X\n               D3=F'21'\n         $KW   E4,UBUFFL,F1=KWOPRAND,D2=A(PCTUBFL-(FCBRECAD-FCBDSECT)),X\n               D3=F'22'\n         $KW   E4,UBUFFM,F1=KWOPRAND,D2=A(PCTUBFM-(FCBRECAD-FCBDSECT)),X\n               D3=F'23'\n         $KW   E4,UBUFFN,F1=KWOPRAND,D2=A(PCTUBFN-(FCBRECAD-FCBDSECT)),X\n               D3=F'24'\n         $KW   E4,UBUFFO,F1=KWOPRAND,D2=A(PCTUBFO-(FCBRECAD-FCBDSECT)),X\n               D3=F'25'\n         $KW   E4,UBUFFP,F1=KWOPRAND,D2=A(PCTUBFP-(FCBRECAD-FCBDSECT)),X\n               D3=F'26'\n         $KW   E4,UBUFFQ,F1=KWOPRAND,D2=A(PCTUBFQ-(FCBRECAD-FCBDSECT)),X\n               D3=F'27'\n         $KW   E4,UBUFFR,F1=KWOPRAND,D2=A(PCTUBFR-(FCBRECAD-FCBDSECT)),X\n               D3=F'28'\n         $KW   E4,UBUFFS,F1=KWOPRAND,D2=A(PCTUBFS-(FCBRECAD-FCBDSECT)),X\n               D3=F'29'\n         $KW   E4,UBUFFT,F1=KWOPRAND,D2=A(PCTUBFT-(FCBRECAD-FCBDSECT)),X\n               D3=F'30'\n         $KW   E4,UBUFFU,F1=KWOPRAND,D2=A(PCTUBFU-(FCBRECAD-FCBDSECT)),X\n               D3=F'31'\n         $KW   E4,UBUFFV,F1=KWOPRAND,D2=A(PCTUBFV-(FCBRECAD-FCBDSECT)),X\n               D3=F'32'\n         $KW   E4,UBUFFW,F1=KWOPRAND,D2=A(PCTUBFW-(FCBRECAD-FCBDSECT)),X\n               D3=F'33'\n         $KW   E4,UBUFFX,F1=KWOPRAND,D2=A(PCTUBFX-(FCBRECAD-FCBDSECT)),X\n               D3=F'34'\n         $KW   E4,UBUFFY,F1=KWOPRAND,D2=A(PCTUBFY-(FCBRECAD-FCBDSECT)),X\n               D3=F'35'\n         $KW   E4,UBUFFZ,F1=KWOPRAND,D2=A(PCTUBFZ-(FCBRECAD-FCBDSECT)),X\n               D3=F'36'\n         $KW   E2,UCTRA,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRA-PCT),D3=F'4'\n         $KW   E2,UCTRB,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRB-PCT),D3=F'4'\n         $KW   E2,UCTRC,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRC-PCT),D3=F'4'\n         $KW   E2,UCTRD,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRD-PCT),D3=F'4'\n         $KW   E2,UCTRE,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRE-PCT),D3=F'4'\n         $KW   E2,UCTRF,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRF-PCT),D3=F'4'\n         $KW   E2,UCTRG,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRG-PCT),D3=F'4'\n         $KW   E2,UCTRH,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRH-PCT),D3=F'4'\n         $KW   E2,UCTRI,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRI-PCT),D3=F'4'\n         $KW   E2,UCTRJ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRJ-PCT),D3=F'4'\n         $KW   E2,UCTRK,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRK-PCT),D3=F'4'\n         $KW   E2,UCTRL,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRL-PCT),D3=F'4'\n         $KW   E2,UCTRM,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRM-PCT),D3=F'4'\n         $KW   E2,UCTRN,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRN-PCT),D3=F'4'\n         $KW   E2,UCTRO,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRO-PCT),D3=F'4'\n         $KW   E2,UCTRP,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRP-PCT),D3=F'4'\n         $KW   E2,UCTRQ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRQ-PCT),D3=F'4'\n         $KW   E2,UCTRR,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRR-PCT),D3=F'4'\n         $KW   E2,UCTRS,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRS-PCT),D3=F'4'\n         $KW   E2,UCTRT,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRT-PCT),D3=F'4'\n         $KW   E2,UCTRU,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRU-PCT),D3=F'4'\n         $KW   E2,UCTRV,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRV-PCT),D3=F'4'\n         $KW   E2,UCTRW,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRW-PCT),D3=F'4'\n         $KW   E2,UCTRX,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRX-PCT),D3=F'4'\n         $KW   E2,UCTRY,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRY-PCT),D3=F'4'\n         $KW   E2,UCTRZ,F1=KWOPRAND,F2=KWOPRPTR+KWDEST+KWOFFSET,       X\n               F3=KWPCTFLD,D1=A(PCTUCTRZ-PCT),D3=F'4'\n         $KW   AF,USERPARM,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X\n               D1=A(PCTUPARM),D3=F'8'\n         $KW   C9,VOLSER,F1=KWOPRAND,F2=KWOPRPTR+KWPMADJ,F3=KWFCBFLD,  X\n               D1=A(FCBVOLS-FCBDSECT),D3=F'6'\n         $KW   24,X,F1=KWALTER,D1=F'16',D3=A(ALTGXOR)\n         $KW   24,XOR,F1=KWALTER,D1=F'16',D3=A(ALTGXOR)\n         $KW   A5,YEAR,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,            X\n               D1=A(TIMEWORK+13),D3=F'2'\n         $KW   CE,FULLYEAR,F1=KWOPRAND,F2=KWOPRPTR,F3=KWADRFLD,        X\n               D1=A(TIMECENT),D3=F'4'\n         $KW   3F,YES,F1=KWIFREL+KWOPRVAL,D1=X'10010000',D2=F'4'\nKWTBLL   EQU   *-KWTBL\nKWHASH   DC    70A(0)\n         EJECT\n*\n         PRINT NOGEN\nMDLSIDCB DCB   DDNAME=INPUT1,DSORG=PS,EODAD=EODAD,EXLST=UT1LIST,       X\n               MACRF=GL\nMDLSODCB DCB   DDNAME=OUTPUT1,DSORG=PS,EXLST=UT2LIST,MACRF=PL\n*\nGETDF1   DC    CL80'*: The following default has been generated.'\nGETDF2   DC    CL80'   SELECT RECS(ALL) TODD(OUTPUT1).'\nGETDF3   DC    CL80'   SELECT RECS(ALL) PRINT(DUMP).'\n*\nERRWTL   WTO   'SELECTIT -                                             X\n                                                                       X\n                  ',ROUTCDE=(11),MCSFLAG=HRDCPY,MF=L\nSELCODE  EQU   *\n         PRINT GEN\n         TITLE 'FCBDSECT'\n*---------------------------------------------------------------------+\n*        FCBDSECT - Map the FCB (File Control Block) area             |\n*---------------------------------------------------------------------+\n*\nFCBDSECT DSECT\nFCBCHAIN DS    A                   Chain to next FCB\nFCBDDNAM DS    CL8                 External DDname\nFCBCOUNT DS    F                   Count of records (per file)\nFCBCREC  DS    F                   Count of records (CREC)\nFCBROUTE DS    XL4                 EXecuted branch instr for routing\nFCBDSORG DS    X                   DSORG\nFCBRECFM DS    X                   RECFM\nFCBF1    DS    X                   Status flag 1\nFCBDOPEN       EQU         X'80'   Deferred OPEN requested\nFCBOPEN        EQU         X'40'   OPEN complete successfully\nFCBCLOSD       EQU         X'20'   CLOSE done already\nFCBSTATS       EQU         X'10'   O.K. to produce stats\nFCBF2    DS    X                   Status flag 2\nFCBINPUT       EQU         X'80'   FCB is for an input file\nFCBOUTPT       EQU         X'40'   FCB is for an output file\nFCBEOF         EQU         X'20'   EOF has occurred\nFCBRREAD       EQU         X'10'   Unlike re-read switch\nFCB1ST         EQU         X'08'   First time switch\nFCBPDS         EQU         X'04'   PDSMODE active\nFCBRECAD DS    A                   Address of I/P record address\nFCBRECPT DS    A                   Address of record address in PCT\nFCBLENPT DS    A                   Address of record length in PCT\nFCBULRFW DS    H                   Filler to allow ULREC to be fullwd\nFCBULREC DS    H                   User's LRECL\nFCBLRECL DS    H                   LRECL\nFCBBLKSI DS    H                   BLKSIZE\nFCBOLREC DS    H                   Open time LRECL\nFCBOBLK  DS    H                     \"   \"   BLKSIZE\nFCBFILNO DS    H                   Index of file number\nFCBORECF DS    X                   Open time RECFM\nFCBDSNAM DS    CL54                DSNAME\nFCBNVOLS DS    X                   Number of volumes\nFCBVOLS  DS    5CL6                Volume serial numbers\nFCBJFCB  DS    CL176               JFCB\n         DS    0F\nFCBDCB   DS    CL256               Actual DCB area\nFCBLNGTH EQU   *-FCBDSECT          Length of area\n         TITLE 'SELDSECT'\n*---------------------------------------------------------------------+\n*        SELDSECT - Map the SELECT control area.                      |\n*---------------------------------------------------------------------+\n*\nSELDSECT DSECT\n$SELID   DC    X'CC'               Control block ID\n$SELF1   DC    X'00'               SELECT flag 1\n$SELF2   DC    X'00'               SELECT flag 2\n$SELF3   DC    X'00'               SELECT flag 3\n$SELSREC DC    F'0'                START record number\n$SELBREC DC    F'0'                BY record number\n$SELBCTR DC    F'0'                BY record counter\n$SELNREC DC    F'0'                Number of records\n$SELOFCB DC    A(0)                Address of output FCB area\n$SELNXTS DC    A(0)                Address of next sentence\n$SELLGTH DC    F'0'                Data length for this select\n         TITLE 'OPRDSECT'\n*---------------------------------------------------------------------+\n*        OPRDSECT - Map the operand answer area.                      |\n*---------------------------------------------------------------------+\n*\nOPRDSECT DSECT                     Map of operand scan area\n*\nOPRNUM1  DC    F'0'                Numeric value of main operand\nOPRNUM2  DC    F'0'                Numeric value of sub-operand\n*\nOPRF1    DC    X'00'               Flag to be OR'ed with WFLAG1\nOPRF2    DC    X'00'               Status of this operand\nOPRNUM         EQU   X'80'         Operand is Numeric\nOPRSPECN       EQU   X'40'            \"    \"  Commented numeric\nOPRLIT         EQU   X'20'            \"    \"  a Literal\nOPRKW          EQU   X'10'            \"    \"  a KW type\nOPRKWV         EQU   X'08'            \"    KW is valid\nOPRKWOP        EQU   X'04'            \"    is a KW(operand) type\nOPRKWOPV       EQU   X'02'            \"    KW(operand) is valid\nOPRPTR         EQU   X'01'         Use OPRADDR to -> text\n*\nOPRL     DC    H'0'                Length of operand\nOPRTXT   DS    0CL10' '            Actual operand if <= 10 bytes\nOPRADDR  DC    A(0)                -> operand if > 10 bytes\n         DC    XL6'00'             Pad to length of OPRTXT\nOPRL2    DC    H'0'                Length of (...) sub-operand\nOPRTXT2  DS    CL10' '             Actual (..) operand\n*---------------------------------------------------------------------+\n*        OPRKW1/OPRKW2 below are mapped by KWDSECT.                   |\n*---------------------------------------------------------------------+\n*\nOPRKW1   DS    CL(KWENTL)          If oper. is KW, entry from KW table\nOPRKW2   DS    CL(KWENTL)          If val. sub-oper, it's KW table ent.\n         TITLE 'KWDSECT'\n*---------------------------------------------------------------------+\n*        KWDSECT - Map an entry in the KW table.                      |\n*---------------------------------------------------------------------+\n*\nKWDSECT  DSECT                     Map of Keyword Table\n*\nKWCHAIN  DS    A                   Hash chain\n*\nKWL      DS    H                   Length of keyword\nKWKW     DS    CL10                Keyword\n*\nKWF1     DS    X                   Status of the keyword\n*\nKWMAJ          EQU   X'80'         KW is major command\nKWALTER        EQU   X'40'         KW is ALTER subcommand\nKWIFREL        EQU   X'20'         KW is IF relational test\nKWIFTRU        EQU   X'10'         KW is IF True path\nKWOPRAND       EQU   X'08'         KW is Operand specifier\nKWOPRVAL       EQU   X'04'         KW is Operand value\nKWNOISE        EQU   X'02'         KW is a 'noise' word\nKWSUBVAL       EQU   X'01'         KW may have sub-operands\n*\nKWF2     DS    X                   KW flag 2\nKWNUMFUG       EQU   X'80'         Fudge when (...) is numeric (..NUM2)\nKWPMVALU       EQU   X'40'         Valid as a +/- adjustment\nKWPREVAL       EQU   X'20'         Value is prefixable\nKWOPRPTR       EQU   X'10'         Valid as an operand location\nKWPMADJ        EQU   X'08'         KW location may be +/- adjusted\nKWDEST         EQU   X'04'         KW data may be modified (else R/O)\nKWOFFSET       EQU   X'02'         Field may be used as a buffer offset\n*\nKWGTYPE  DS    X                   KW type of code to Gen.\nKWFCBFLD       EQU   4             Actual data is in the FCB at offset\n*                                  of KWD1, length is in KWD3.\nKWFCBPTR       EQU   8             Actual data pointed to by FCB field\n*                                  at offset KWD1, length is in KWD3.\nKWADRFLD       EQU   12            Actual data is pointed to by the\n*                                  addr in KWD1, length is in KWD3.\nKWADRPTR       EQU   16            KWD1 points at the pointer to the\n*                                  actual data, length is in KWD3.\nKWPCTFLD       EQU   20            Data is in the PCT at the offset\n*                                  in KWD1, length is in KWD3.\nKWPCTPTR       EQU   24            Data is pointed to by the PCT field\n*                                  at the offset in KWD1, length KWD3\n*\nKWNUM    DS    X                   Keyword number\n*\nKWD1     DS    XL4                 Data 1\nKWD2     DS    A                   Data 2\nKWD3     DS    A                   Data 3\nKWENTL   EQU   *-KWDSECT\n*---------------------------------------------------------------------+\n*        For SWA block access                                         |\n*---------------------------------------------------------------------+\n         IEFZB505 LOCEPAX=YES\nSWAL     EQU   *-ZB505\n         CVT   DSECT=YES\n         IEFJESCT\n         IEFQMIDS\n         END   SELECTIT\n/*\n//LINK    EXEC PGM=IEWL,PARM='MAP,LET,LIST,NCAL'\n//SYSLIN   DD  DSN=&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DSN=TCS1028.LOAD(SELECTIT),DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT917/FILE917.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT917", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}