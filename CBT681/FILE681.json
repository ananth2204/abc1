{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012604000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE681.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE681.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x07'", "DS1TRBAL": "b'|.'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xc6\\x00\\x01\\x04\\xc6\\x00\\x0b\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04B\\x00\\x00\\x01\\x04\\x16\\x8f\\x01\\x04\\x16\\x8f\\x126\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf6@@@'", "ispf": {"version": "04.66", "flags": 0, "createdate": "2004-06-16T00:00:00", "modifydate": "2004-06-16T12:36:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-466"}, "text": "REGULAR CBT TAPE - VERSION 466    FILE:  681\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT466.FILE681\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   19 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,971 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/16/04    12:36:18    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$COMPILE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00!\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x140\\x01.\\x01\\xac\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T14:30:21", "lines": 302, "newlines": 428, "modlines": 0, "user": "QC22505"}, "text": "//QC22505R JOB (),'PLEA',CLASS=D,MSGCLASS=X,\n//         MSGLEVEL=(1,1),NOTIFY=QC22505,PRTY=0\n/*JOBPARM LINES=99\n//*\n//*\n//**********************************************************************\n//*  THIS JCL COMPILES THREE PROGRAMS:                               ***\n//*                                                                  ***\n//*  LINKDATE - GENERATE AN OBJECT RECORD (CSECT) WITH THE CURRENT   ***\n//*             DATE IN IT.  LETS A PROGRAM SHOW WHEN IT WAS LINKED. ***\n//*  PLEA     - THE PL/I EXECUTION ANALYZER                          ***\n//*  PLEAREP  - GENERATE A REPORT FROM PLEA TRACE DATA               ***\n//*                                                                  ***\n//*  TO RUN THIS JCL:                                                ***\n//*  1.  CHANGE QC22505 TO THE HIGH LEVEL QUALIFIER OF YOUR CHOICE   ***\n//*      GLOBALLY.                                                   ***\n//*                                                                  ***\n//*  2.  BEFORE THE ABOVE CHANGE, THIS FILE IS WOULD BE IN           ***\n//*      QC22505.PLEA.DATA                                           ***\n//*                                                                  ***\n//*  3.  THE TARGET LOAD LIB IS                                      ***\n//*      QC22505.PLEA.LOAD                                           ***\n//*                                                                  ***\n//*  NOTE:  ROUTINES REVERSE AND HEX AS WELL AS PROGRAM LINKDATE     ***\n//*         ARE GENERAL PURPOSE AND MY BE USEFUL FOR OTHER THINGS.   ***\n//*                                                                  ***\n//*  MEMBER $RUN IN THIS PDS SHOWS HOW TO RUN PLEA.                  ***\n//*                                                                  ***\n//**********************************************************************\n//*                                                                  ***\n//*    STEP ASM0 COMPILE LINKDATE                                    ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//ASM0    EXEC PGM=ASMA90,     <ASSEMBLE BAL SOURCE WITH ASMH>\n//             REGION=1000K,\n//             TIME=999,\n//             PARM=('NODECK,BATCH,ASA,XREF(SHORT)')\n//*\n//SYSIN    DD  DSN=QC22505.PLEA.DATA(LINKDATE),\n//             DISP=SHR\n//*\n//SYSLIB   DD  DSN=SYS1.MACLIB,    <GENERAL MACROS>\n//             DCB=BLKSIZE=27920,\n//             DISP=SHR\n//*\n//         DD  DSN=QC22505.PLEA.DATA,\n//             DISP=SHR\n//*\n//*\n//SYSLIN   DD  DSN=&OBJECT0,       <ASSEMBLED OBJECT CODE>\n//             DISP=(NEW,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(40,2)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(5,1))\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LKED                                                    ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LKED     EXEC  PGM=IEWL,      < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('LET,DCBS,LIST,MAP,SIZE=(2000K,100K)',\n//             '')\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SYSUDUMP DD  SYSOUT=*\n//*\n//SYSUT1   DD  UNIT=SYSDA,           < LINKAGE EDITOR WORK FILE       >\n//             SPACE=(CYL,(6,1))\n//*\n//SYSLIN   DD  DSN=&&OBJECT0,      < OBJECT FORM PREVIOUS COMPILE   >\n//             DISP=(OLD,DELETE)     < STEP                           >\n//*\n//SYSLMOD  DD  DSN=QC22505.PLEA.LOAD(LINKDATE),\n//             DISP=OLD\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LINKDATE                                                ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LINKDATE EXEC  PGM=LINKDATE,  < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             PARM='L,IEFBR14'\n//*\n//STEPLIB  DD  DSN=QC22505.PLEA.LOAD, < LOAD LIBRARY FOR LINKDATE >\n//             DISP=SHR\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SETSSI   DD  DSN=&&OBJECT,         < SSI CARD GENERATED BY THIS   >\n//             DISP=(NEW,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(10,2)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP PLI  (COMPILE PLEA)                                      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//PLI      EXEC PGM=IEL0AA,       <COMPILE THE SOURCE>\n//             REGION=1200K,\n//             TIME=999,\n//             PARM=('MAP,LC(80),NEST',\n//             'TEST(STMT,SYM)',\n//  'GS,OPT(2),AG,A,X,C,STG,')\n//*\n//SYSIN    DD  DSN=QC22505.PLEA.DATA(PLEA),\n//             DISP=SHR\n//*\n//SYSLIN  DD   DSN=&&OBJECT,       <OBTECT MODULE>\n//             DISP=(MOD,PASS)\n//*\n//SYSUT1   DD  DSN=&&SYSUT1,       <PL/I WORK FILE>\n//             DISP=NEW,\n//             DCB=BLKSIZE=1024,\n//             SPACE=(CYL,5,,CONTIG),\n//             UNIT=SYSDA\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP ASM  (SUPPORTING ROUTINES FOR PLEA)                      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//ASM     EXEC PGM=ASMA90,     <ASSEMBLE BAL SOURCE WITH ASMH>\n//             REGION=1000K,\n//             TIME=999,\n//             PARM=('NODECK,BATCH,ASA,XREF(SHORT)')\n//*\n//SYSIN    DD  DSN=QC22505.PLEA.DATA(SAMPLER),\n//             DISP=SHR\n//*\n//         DD  DSN=QC22505.PLEA.DATA(HEX),\n//             DISP=SHR\n//*\n//         DD  *\n         PUNCH '   ENTRY CEESTART'\n         PUNCH '   MODE AMODE(31),RMODE(24)'\n         PUNCH '   NAME PLEA(R)'\n         END\n//*\n//SYSLIB   DD  DSN=SYS1.MACLIB,    <GENERAL MACROS>\n//             DCB=BLKSIZE=27920,\n//             DISP=SHR\n//*\n//         DD  DSN=QC22505.PLEA.DATA,\n//             DISP=SHR\n//*\n//*\n//SYSLIN   DD  DSN=&OBJECT,       <ASSEMBLED OBJECT CODE>\n//             DISP=(MOD,PASS)\n//*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(5,1))\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LINKDATE                                                ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LINKDATE EXEC  PGM=LINKDATE,  < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             PARM='L,IEFBR14'\n//*\n//STEPLIB  DD  DSN=QC22505.PLEA.LOAD, <LOAD LIBRARY FOR LINKDATE >\n//             DISP=SHR\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SETSSI   DD  DSN=&&OBJECT,         < SSI CARD GENERATED BY THIS   >\n//             DISP=(MOD,PASS)\n//*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP PLI COMPILE PLEAREP                                      ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//PLI2     EXEC PGM=IEL0AA,       <COMPILE THE SOURCE>\n//             REGION=1200K,\n//             TIME=999,\n//             PARM=('MAP,LC(80),NEST',\n//             'TEST(STMT,SYM)',\n//  'GS,OPT(2),AG,A,X,C,STG,')\n//*\n//SYSIN    DD  DSN=QC22505.PLEA.DATA(PLEAREP),\n//             DISP=SHR\n//*\n//SYSLIN  DD   DSN=&&OBJECT,       <OBTECT MODULE>\n//             DISP=(MOD,PASS)\n//*\n//SYSUT1   DD  DSN=&&SYSUT1,       <PL/I WORK FILE>\n//             DISP=NEW,\n//             DCB=BLKSIZE=1024,\n//             SPACE=(CYL,5,,CONTIG),\n//             UNIT=SYSDA\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//**********************************************************************\n//*                                                                  ***\n//*    STEP ASM2 (SUPPORTING ROUTINES FOR PLEAREP)                   ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//ASM2    EXEC PGM=ASMA90,     <ASSEMBLE BAL SOURCE WITH ASMH>\n//             REGION=1000K,\n//             TIME=999,\n//             PARM=('NODECK,BATCH,ASA,XREF(SHORT)')\n//*\n//SYSIN    DD  DSN=QC22505.PLEA.DATA(REVERSE),\n//             DISP=SHR\n//*\n//         DD  DSN=QC22505.PLEA.DATA(HEX),\n//             DISP=SHR\n//*\n//         DD  *\n         PUNCH '   ENTRY CEESTART'\n         PUNCH '   MODE RMODE(ANY) '\n         PUNCH '   NAME PLEAREP(R)'\n         END\n//*\n//SYSLIB   DD  DSN=SYS1.MACLIB,    <GENERAL MACROS>\n//             DCB=BLKSIZE=27920,\n//             DISP=SHR\n//*\n//         DD  DSN=QC22505.PLEA.DATA,\n//             DISP=SHR\n//*\n//*\n//SYSLIN   DD  DSN=&OBJECT,       <ASSEMBLED OBJECT CODE>\n//             DISP=(MOD,PASS),\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(40,2)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             UNIT=SYSDA,\n//             SPACE=(CYL,(5,1))\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//*\n//*\n//**********************************************************************\n//*\n//*   RUN THE LINKAGE EDITOR AND SAVE THE LOAD MODULE\n//*\n//**********************************************************************\n//*\n//**********************************************************************\n//*                                                                  ***\n//*     STEP LKED                                                    ***\n//*                                                                  ***\n//**********************************************************************\n//*\n//LKED     EXEC  PGM=IEWL,      < EXEC LINK EDITOR TO GEN LOAD MODULE >\n//             REGION=4000K,\n//             TIME=999,\n//             PARM=('LET,DCBS,LIST,MAP,SIZE=(2000K,100K)',\n//             '')\n//*\n//SYSPRINT DD  SYSOUT=*\n//*\n//SYSUDUMP DD  SYSOUT=*\n//*\n//SYSLIB   DD  DSN=CEE.SCEELKED,\n//             DISP=SHR\n//*\n//SYSUT1   DD  UNIT=SYSDA,           < LINKAGE EDITOR WORK FILE       >\n//             SPACE=(CYL,(6,1))\n//*\n//SYSLIN   DD  DSN=&&OBJECT,       < OBJECT FORM PREVIOUS COMPILE   >\n//             DISP=(OLD,DELETE)     < STEP                           >\n//*\n//*\n//SYSLMOD  DD  DSN=QC22505.PLEA.LOAD,\n//             DISP=OLD\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$REPORT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x14R\\x00!\\x00!\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T14:52:26", "lines": 33, "newlines": 33, "modlines": 0, "user": "QC22505"}, "text": "//QC22505C JOB (),'PLEAREP',\n//    NOTIFY=QC22505,\n//    MSGLEVEL=(2,1),PRTY=0,CLASS=E,MSGCLASS=X\n/*JOBPARM LINES=20\n//*********************************************************************\n//*\n//* THIS JCL STREAM RUNS THE PLEA REP PROGRAM.\n//* THE PLEAREP PROGRAM GENERATES A REPORT FROM THE OUTPUT GENERATED\n//* BY THE PLEA PROGRAM.  YOU CAN SEE SAMPLE OUTPUT IN MEMBER\n//* $SAMPRUN\n//*\n//*  THE ONLY PARM TO THIS PROGRAM IS TERM=Y WHICH FORMATS\n//*  THE OUTPUT TO BE EASIER TO READ FROM A TERMINAL (SDSF).\n//*  TERM=N FORMATS FOR A HARDCOPY LISTING.\n//*\n//*********************************************************************\n//PLEAREP  EXEC PGM=PLEAREP,REGION=3000K,PARM='/TERM=Y'\n//STEPLIB  DD  DSN=EAXC.SUPPORT.LOADLIB.RELEASE,DISP=SHR\n//PLEAPRNT DD  SYSOUT=*\n//REPORT   DD  SYSOUT=*\n//SORTWK01 DD  UNIT=SYSDA,SPACE=(CYL,(30,20))\n//SORTWK02 DD  UNIT=SYSDA,SPACE=(CYL,(30,20))\n//SORTWK03 DD  UNIT=SYSDA,SPACE=(CYL,(30,20))\n//SYSOUT   DD  SYSOUT=*\n//WORK1    DD  UNIT=SYSDA,SPACE=(CYL,(30,20)),\n//             DCB=(LRECL=55,RECFM=FB,BLKSIZE=9075)\n//WORK2    DD  UNIT=SYSDA,SPACE=(CYL,(30,20)),\n//             DCB=(LRECL=55,RECFM=FB,BLKSIZE=9075)\n//*\n//*\n//* THE FOLLOWING FILE IS THE INPUT GENERATED BY PLEA (MEMBER $RUN)\n//*\n//TRACE$$  DD  DSN=QC22505.TRACE.DATA,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RUN": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x14U\\x00[\\x00V\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T14:55:03", "lines": 91, "newlines": 86, "modlines": 0, "user": "QC22505"}, "text": "//QC22505P JOB (),'PLEA HPAN#1',\n//         CLASS=E,MSGCLASS=X,\n//         MSGLEVEL=(1,1),NOTIFY=QC22505,PRTY=0\n/*JOBPARM LINES=9999,CARDS=99999,COPIES=1\n//*\n//*********************************************************************\n//*\n//* TO RUN PLEA,  IN A NUTSHELL YOU START WITH YOUR PROGRAM JCL\n//* AND ADD THE DD STATEMENTS CMD$FILE, TRACE$$, AND PLEAPRNT\n//* WHICH ARE NEEDED BY PLEA.  YOU THEN MODIFY THE EXEC STATEMENT\n//* TO RUN PLEA INSTEAD OF YOUR PROGRAM AND MODIFY THE PARM=\n//* TO TELL PLEA THE NAME OF YOUR PROGRAM AND HOW TO DO THE SAMPLING.\n//* THIS IS FOLLOWED BY THE PARMS TO YOUR PROGRAM.\n//*\n//* THE STEPLIB GETS MODIFIED TO INCLUDE THE PLEA STEPLIB.  THE\n//* MVS LIBRARY EQAW.SEQAMOD MUST BE ADDED IF IT IS NOT IN YOUR\n//* LINKLIST.\n//*\n//* SAMPLE STATS\n//* WITHOUT  28.87 SEC\n//* WITH     58.60 SEC   TAKES 203% AS LONG TO RUN WITH PLEA RUNNING\n//*\n//*  //SAMPLE EXEC PGM=PLEA,\n//*  //   PARM='/A1,1,TASK,NOSPIE/PGMPARMS'\n//*              |  |  |     |     |\n//*              |  |  |     |     +- PARMS TO YOUR PROGRAM\n//*              |  |  |     +------- PL/I PARMS FOR YOUR PGM\n//*              |  |  +------------- SAMPLE CPU TIME\n//*              |  |                 SPECIFY REAL FOR WALL TIME\n//*              |  +---------------- SAMPLE EVERY 1/100 SECOND\n//*              +------------------- NAME OF PROGRAM TO EXECUTE\n//*  //STEPLIB  DD DSN=YOUR.NORMAL.STEPLIBS,DISP=SHR\n//*  //         DD DSN=YOUR.PLEA.LOAD,DISP=SHR\n//*  //         DD DSN=EQAW.SEQAMOD,DISP=SHR   <- REQUIRED FOR PLEA\n//*\n//*        YOUR.PLEA.LOAD CAN BE THE FIRST OR LAST STEPLIB,\n//*\n//*  ROUTINE $REPORT SHOWS HOW TO GENERATE A REPORT FROM THE TRACE\n//*  DATA.\n//*\n//**********************************************************************\n//*\n//*  KILL DELETE THE TRACE DATA IF IT IS ALREADY THERE\n//*\n//**********************************************************************\n//KILL     EXEC PGM=IEFBR14\n//TRACE$$  DD  DSN=QC22505.TRACE.DATA,\n//             DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n//*\n//*\n//*\n//**********************************************************************\n//*\n//*  COLLECT RUN THE TEST PROGRAM TO COLLECT DATA\n//*\n//**********************************************************************\n//PAN1     EXEC PGM=PLEA,\n//     PARM='/PAN#1,1,TASK,/'\n//*              |  |  |\n//*              |  |  |\n//*              |  |  |\n//*              |  |  +------------- SAMPLE CPU TIME\n//*              |  |                 SPECIFY REAL FOR WALL TIME\n//*              |  +---------------- SAMPLE EVERY 1/100 SECOND\n//*              +------------------- NAME OF PROGRAM TO EXECUTE\n//STEPLIB  DD  DSN=EAXC.HPAN.LOAD,\n//             DISP=SHR\n//         DD  DSN=QC22505.PLEA.LOAD,\n//             DISP=SHR\n//         DD  DSN=EQAW.SEQAMOD,            <- REQUIRED FOR PLEA\n//             DISP=SHR\n//PANDD1   DD  DISP=SHR,DSN=EAX2I.HPAN.TEST\n//PANDD2   DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//PANPRINT DD  SYSOUT=*\n//SYSIN    DD  DISP=SHR,DSN=QC22505.ZINITLIB.DATA\n//*\n//**********************************************************************\n//*\n//*                 PLEA WORK DATASETS\n//*\n//**********************************************************************\n//*\n//*CMD$FILE DD  DSN=QC22505.TRACE.CMD,DISP=SHR\n//CMD$FILE DD  SPACE=(TRK,1),UNIT=SYSDA,\n//*            DSN=QC22505.TRACE.CMDS,DISP=(NEW,CATLG),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//TRACE$$  DD  DSN=QC22505.TRACE.DATA,\n//             DISP=(NEW,CATLG),UNIT=SYSDA,SPACE=(CYL,(200,20),RLSE)\n//PLEAPRNT DD  SYSOUT=*\n//*SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAMPOUT": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x141\\x01R\\x01R\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T14:31:54", "lines": 338, "newlines": 338, "modlines": 0, "user": "QC22505"}, "text": "1BASIC STATISTICS\n0\n NAME OF LOAD MODULE IS:               PAN#1\n INTERRUPT INTERVAL IS:                  .01 SECONDS\n INTERRUPTS BASED ON TASK CPU TIME.\n NUMBER OF INTERRUPTS IS:               9476\n NUMBER OF PLI STATEMENTS IS:      111581851\n ELAPSED TIME FOR SAMPLING RUN:            3 MINUTE(S)\n\n1*******************************************************************************\n SUMMARY OF TIME SPENT IN EACH PROC FOR PGM PAN#1\n\n *******************************************************************************\n PROC       TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n CREATE_FILE(HPNREAD)                  42      0.4\n HPNREAD(HPNREAD)                    4057     42.8 *****************************\n PAN#1(PAN#1)                          30      0.3\n ADD_DIRENT(PN1ADD)                   346      3.6 ****\n CREATE_FILE(PN1ADD)                 3908     41.2 *****************************\n HPNREAD(PN1ADD)                       16      0.1\n PARSE_ADD(PN1ADD)                     36      0.3\n PN1ADD(PN1ADD)                         5      0.0\n VALID_TYPE(PN1ADD)                     3      0.0\n PARSE_COMMENT(PN1COMM)                34      0.3\n PN1COMM(PN1COMM)                     377      3.9 ****\n APPLY_DATES(PN1DIR)                   62      0.6 *\n PAN#1(PN1DIR)                          1      0.0\n PN1DIR(PN1DIR)                       425      4.4 ****\n TRIM(PN1DIR)                           3      0.0\n\n1*******************************************************************************\n TIME SPENT IN STATEMENTS, BY PROC FOR PGM PAN#1\n\n *******************************************************************************\n PROC CREATE_FILE IN EXTERNAL PROC HPNREAD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n      326          42      0.4\n\n TOTAL INTERRUPTS THIS PROC:       42\n THIS PROC CONSUMED       0.4 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC HPNREAD IN EXTERNAL PROC HPNREAD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n        1          21      0.2\n       10         324      3.4      ***\n       11          42      0.4\n       12         196      2.0      **\n       13          62      0.6      *\n       14         149      1.5      **\n       15         145      1.5      **\n       16         158      1.6      **\n       17         130      1.3      *\n       18         250      2.6      ***\n       19         155      1.6      **\n       20         523      5.5      ******\n       23         137      1.4      *\n       33         137      1.4      *\n       34         151      1.5      **\n       35         163      1.7      **\n       36         164      1.7      **\n       37         245      2.5      ***\n       38         155      1.6      **\n       39         146      1.5      **\n       50         126      1.3      *\n       51         300      3.1      ***\n     3598         178      1.8      **\n\n TOTAL INTERRUPTS THIS PROC:     4057\n THIS PROC CONSUMED      42.8 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PAN#1 IN EXTERNAL PROC PAN#1\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       40           1      0.0\n       60           1      0.0\n       64           2      0.0\n       66           1      0.0\n       67           1      0.0\n       68           1      0.0\n       69           2      0.0\n       77           1      0.0\n\n\n *******************************************************************************\n PROC PAN#1 IN EXTERNAL PROC PAN#1\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n         78           2      0.0\n       96           1      0.0\n       98           1      0.0\n       99           1      0.0\n      158           1      0.0\n      173           1      0.0\n      180           1      0.0\n      185           1      0.0\n      219           1      0.0\n      223           1      0.0\n      228           1      0.0\n      230           5      0.0\n      231           1      0.0\n      234           1      0.0\n      317           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:       30\n THIS PROC CONSUMED       0.3 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC ADD_DIRENT IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n      250           1      0.0\n      259           1      0.0\n      274           1      0.0\n      278         342      3.6      ****\n      280           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:      346\n THIS PROC CONSUMED       3.6 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC CREATE_FILE IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n      305           1      0.0\n      308          56      0.5      *\n      311         526      5.5      ******\n      313         174      1.8      **\n      317         175      1.8      **\n      318        1820     19.2      *******************\n      319         151      1.5      **\n      325         318      3.3      ***\n      326         146      1.5      **\n      327         163      1.7      **\n      328         166      1.7      **\n      329         155      1.6      **\n      331          32      0.3\n 00021936          25      0.2\n\n TOTAL INTERRUPTS THIS PROC:     3908\n THIS PROC CONSUMED      41.2 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC HPNREAD IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       10          16      0.1\n\n TOTAL INTERRUPTS THIS PROC:       16\n THIS PROC CONSUMED       0.1 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PARSE_ADD IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       83           1      0.0\n       87           1      0.0\n       89           3      0.0\n       90           1      0.0\n       91           4      0.0\n       93           3      0.0\n       94           3      0.0\n       99           1      0.0\n      100           2      0.0\n      114           2      0.0\n      115           1      0.0\n      117           2      0.0\n      122           1      0.0\n      128           1      0.0\n      129           1      0.0\n      132           2      0.0\n      149           1      0.0\n      197           3      0.0\n      198           2      0.0\n      203           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:       36\n THIS PROC CONSUMED       0.3 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PN1ADD IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       30           1      0.0\n       33           1      0.0\n       36           1      0.0\n       58           1      0.0\n      427           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:        5\n THIS PROC CONSUMED       0.0 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC VALID_TYPE IN EXTERNAL PROC PN1ADD\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n      215           2      0.0\n      227           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:        3\n THIS PROC CONSUMED       0.0 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PARSE_COMMENT IN EXTERNAL PROC PN1COMM\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       50           2      0.0\n       51           2      0.0\n       52           3      0.0\n       55           2      0.0\n       59           1      0.0\n       60           1      0.0\n       61           5      0.0\n       75           3      0.0\n       76           1      0.0\n       83           1      0.0\n       89           1      0.0\n       90           1      0.0\n       93           1      0.0\n       95           6      0.0\n       97           4      0.0\n\n TOTAL INTERRUPTS THIS PROC:       34\n THIS PROC CONSUMED       0.3 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PN1COMM IN EXTERNAL PROC PN1COMM\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       14           1      0.0\n       16          34      0.3\n       20         342      3.6      ****\n\n TOTAL INTERRUPTS THIS PROC:      377\n THIS PROC CONSUMED       3.9 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC APPLY_DATES IN EXTERNAL PROC PN1DIR\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       73           1      0.0\n       76           1      0.0\n       81           4      0.0\n       82           5      0.0\n       83           3      0.0\n       84           3      0.0\n       85          45      0.4\n\n TOTAL INTERRUPTS THIS PROC:       62\n THIS PROC CONSUMED       0.6 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PAN#1 IN EXTERNAL PROC PN1DIR\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n      222           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:        1\n THIS PROC CONSUMED       0.0 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PN1DIR IN EXTERNAL PROC PN1DIR\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       29           1      0.0\n       31           1      0.0\n       37           1      0.0\n       40           1      0.0\n       41          55      0.5      *\n       43           2      0.0\n       47          47      0.4\n       53           2      0.0\n       54         314      3.3      ***\n       58           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:      425\n THIS PROC CONSUMED       4.4 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC TRIM IN EXTERNAL PROC PN1DIR\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       92           1      0.0\n       94           1      0.0\n       96           1      0.0\n\n TOTAL INTERRUPTS THIS PROC:        3\n THIS PROC CONSUMED       0.0 OF THE TOTAL CPU TIME\n\n\n *******************************************************************************\n PROC PPRINT IN EXTERNAL PROC PPRINT\n\n STATEMENT  TRAP COUNT  %TOTAL                    TOTAL PERCENTAGE GRAPH,  * = 1\n\n       19           3      0.0\n       20           1      0.0\n       21           1      0.0\n       23           2      0.0\n       25           1      0.0\n       26           2      0.0\n       27           1      0.0\n       30           1      0.0\n       31           1      0.0\n       36           1      0.0\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAMPOUX": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x8f\\x01\\x04\\x16\\x8f\\x123\\x02U\\x02U\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-16T00:00:00", "modifydate": "2004-06-16T12:33:00", "lines": 597, "newlines": 597, "modlines": 0, "user": "XMIT"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "@FILE681": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04B\\x00\\x00\\x01\\x04\\x16\\x8f\\x01\\x04\\x16\\x8f\\x126\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf6@@@'", "ispf": {"version": "04.66", "flags": 0, "createdate": "2004-06-16T00:00:00", "modifydate": "2004-06-16T12:36:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CBT-466"}, "text": "//***FILE 681 is from Robert Styma and contains an updated          *   FILE 681\n//*           version of the powerful PL/I Execution Analyzer       *   FILE 681\n//*           program called PLEA.                                  *   FILE 681\n//*                                                                 *   FILE 681\n//*           Sample output of PLEA is found in members $SAMPOUT    *   FILE 681\n//*           and $SAMPOUX.                                         *   FILE 681\n//*                                                                 *   FILE 681\n//*           email:  stymar@lucent.com                             *   FILE 681\n//*                                                                 *   FILE 681\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENTER": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x13Q\\x00\\xb6\\x00\\xb6\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T13:51:40", "lines": 182, "newlines": 182, "modlines": 0, "user": "QC22505"}, "text": "         MACRO\n&NAME    ENTER &R,&FPR,&SAVE=,&BASE=,&SPIE=YES,&ID=YES,&BASE2=0\n         LCLA  &SIZE,&SIZE1,&SIZE2\n         LCLC  &BASE1,&BR(06),&HOLD,&SPIE1\n.*\n.*       AUTHOR - GARY R. KOENIG\n.*\n.*       DATE - SEPTEMBER 25, 1969\n.*\n.*       FUNCTION - THE ENTER MACRO IS USED IN ASSEMBLER ROUTINES TO\n.*         SAVE CODING THE REGISTER EQUATES, THE SAVING OF REGISTERS,\n.*         ESTABLISHING A BASE REGISTER, ESTABLISHING A NEW SAVE AREA\n.*         AND CROSS-LINKING WITH THE OLD SAVE AREA.  A STATIC OR A\n.*         DYNAMIC SAVE AREA CAN BE GENERATED BY THE MACRO OR THE AD-\n.*         DRESS OF A SAVE AREA OUTSIDE THE MACRO CAN BE USED.  THE\n.*         ENTER MACRO ALSO INSERTS THE PROGRAM IDENTIFICATION FOR THE\n.*         ABEND/DUMP ROUTINE.  THE SPIE MACRO IS ALSO ISSUED TO ALLOW\n.*         ASSEMBLER SUBROUTINES TO BE LINKED WITH COMPILER LEVEL\n.*         LANGUAGES.\n.*\n.*       CODING - ENTER IS CODED INTO THE ASSEMBLER PROGRAM ACCORDING\n.*         TO THE RULES OF MACRO INSERTION.  IT HAS TWO POSITIONAL\n.*         PARAMETERS AND FOUR KEYWORD PARAMETERS AS FOLLOWS:\n.*         1)  THE FIRST POSITIONAL PARAMETER (P/P) IS AN ALPHA-NUMERIC\n.*           VARIABLE (1 TO 6 CHARACTERS LONG) USED FOR GENERAL-PURPOSE\n.*           REGISTER EQUATES.  IF THIS PARAMETER IS OMITTED NO EQUATES\n.*           ARE MADE.\n.*         2)  THE SECOND P/P IS THE SAME AS THE FIRST AND IS USED FOR\n.*           FLOATING-POINT REGISTER EQUATES.\n.*         3)  THE &SAVE KEYWORD PARAMETER (K/P) CAN BE CODED &SAVE=XXX\n.*           IN WHICH CASE THE ENTER MACRO WILL USE THE LOCATION AD-\n.*           DRESSED BY XXX TO STORE THE REGISTERS.  IF &SAVE=RENT IS\n.*           CODED, A DYNAMIC AREA WILL BE GENERATED USING A GETMAIN\n.*           MACRO INSTRUCTION.  IF &SAVE IS OMITTED OR IS NULL, AN IN-\n.*           TERNAL STATIC SAVE AREA WILL BE GENERATED WITH NO LABEL.\n.*         4)  THE &BASE K/P IS USED TO DEFINE WHICH REGISTER IS TO BE\n.*           USED FOR A BASE REGISTER.  IF &BASE IS NOT CODED AND A\n.*           STATIC SAVE AREA WAS GENERATED BY THE PROGRAM, REGISTER 13\n.*           WILL BE USED FOR BOTH THE ADDRESS OF THE SAVE AREA AND THE\n.*           BASE REGISTER.  IF &BASE IS NOT CODED AND A STATIC SAVE\n.*           AREA WAS NOT GENERATED BY THE MACRO, REGISTER 12 WILL BE\n.*           USED AS THE BASE REGISTER.  IF &BASE=15 IS CODED, REGISTER\n.*           15 WILL BE USED AS A BASE REGISTER, THE REGISTERS WILL BE\n.*           STORED BUT NO NEW SAVE AREA WILL BE GENERATED NOR THE\n.*           CROSS-LINKING OF THE SAVE AREAS UNLESS &SAVE=XXX IS EXPLI-\n.*           CITLY CODED.  IF &BASE=14 IS CODED THIS WOULD CAUSE ERRORS\n.*           SO REGISTER 12 OR 13 WILL BE USED ACCORDING TO THE &SAVE\n.*           K/P.\n.*         5)  THE &SPIE K/P IS USED TO CONTROL GENERATION OF THE SPIE\n.*           MACRO.  IF &SPIE=NO IS CODED, NO SPIE MACRO WILL BE GENER-\n.*           ATED.  IF &SPIE=YES IS CODED OR &SPIE IS OMITTED, THE SPIE\n.*           MACRO WILL BE GENERATED FOR SYSTEM ACTION ON ALL INTER-\n.*           RUPTS.  IF AN INTERRUPTION EXIT ADDRESS IS DESIRED ALONG\n.*           WITH DESIGNATED INTERRUPTION TYPES, THEY SHOULD BE CODED\n.*           ACCORDING TO THE RULES OF THE SPIE MACRO BUT INSERTED IN\n.*           AN EXTRA SET OF PARENTHESES.\n.*           EX:  &SPIE=(SPIEXIT,((7,9),15))\n.*         6)  THE &ID K/P IS USED TO CONTROL GENERATION OF THE PROGRAM\n.*           IDENTIFICATION FOR ABEND/DUMP ROUTINE AT OFFSET +4 FROM\n.*           THE BEGINNING OF THE CSECT.  IF &ID=NO IS CODED, THE IDEN-\n.*           TIFICATION WILL NOT BE GENERATED.  IF &ID=YES IS CODED OR\n.*           &ID IS OMITTED, THE IDENTIFICATION WILL BE GENERATED.\n&BASE1   SETC  '&BASE'\n&HOLD    SETC  '&R'.'2'\n&SPIE1   SETC  '&SPIE'\n         AIF   ('&BASE' NE '15' AND '&BASE' NE '1').C0\n&SPIE1   SETC  'NO'\n         AGO   .C2\n.C0      AIF   ('&BASE1' NE '2').C1\n&HOLD    SETC  '&R'.'3'\n         AGO   .C2\n.C1      AIF  ('&BASE' NE '14' AND '&BASE' NE '0' AND '&BASE' NE '').C3\n&BASE1   SETC  '13'\n.C2      AIF   ('&BASE1' NE '13' OR '&SAVE' EQ '').C3\n&BASE1   SETC  '12'\n.C3      AIF   ('&R' EQ '').C4\n         MNOTE *,'GENERAL PURPOSE REGISTER EQUATES'\n         MNOTE *,'     REGISTER &BASE1 IS THE BASE'\n         AIF   ('&BASE2' EQ '0').D3\n         MNOTE *,'  REGISTER &BASE2 IS THE SECOND BASE'\n.D3      ANOP\n&R.0     EQU   0\n&R.1     EQU   1\n&R.2     EQU   2\n&R.3     EQU   3\n&R.4     EQU   4\n&R.5     EQU   5\n&R.6     EQU   6\n&R.7     EQU   7\n&R.8     EQU   8\n&R.9     EQU   9\n&R.10    EQU   10\n&R.11    EQU   11\n&R.12    EQU   12\n&R.13    EQU   13\n&R.14    EQU   14\n&R.15    EQU   15\n         SPACE 1\n.C4      AIF   ('&FPR' EQ '').C5\n&FPR.0   EQU   0                  FLOATING POINT REGISTER EQUATES\n&FPR.2   EQU   2\n&FPR.4   EQU   4\n&FPR.6   EQU   6\n         SPACE 1\n.C5      AIF   ('&BASE1' NE '15' AND '&BASE1' NE '13').C6\n         USING *,&R.15\n.C6      AIF   ('&ID' EQ 'NO').C11\n         AIF   ('&NAME' EQ '').C7\n&BR(1)   SETC  '&NAME'\n&BR(2)   SETC  ''\n&SIZE    SETA  1\n         AGO   .C8\n.C7      AIF   ('&SYSECT' EQ '').C9\n&BR(1)   SETC  '&SYSECT'\n&BR(2)   SETC  ''\n&SIZE    SETA  1\n.C8      AIF   ('&BR(1)'(1,&SIZE) EQ '&BR(1)').C10\n&SIZE    SETA  &SIZE+1\n         AGO   .C8\n.C9      ANOP\n&BR(1)   SETC  'PRIVATE '\n&BR(2)   SETC  'CODE'\n&SIZE    SETA  12\n.C10     ANOP\n&SIZE1   SETA  ((&SIZE+2)/2)*2+4\n&NAME    B     &SIZE1.(0,&R.15)   BRANCH AROUND IDENTIFIER\n         DC    AL1(&SIZE)         LENGTH OF IDENTIFIER\n         DC    CL&SIZE'&BR(1)&BR(2)' IDENTIFIER\n         STM   &R.14,&R.12,12(&R.13)\n         AGO   .C12\n.C11     ANOP\n&NAME    STM   &R.14,&R.12,12(&R.13)\n.C12     AIF   ('&BASE1' EQ '15' OR '&BASE1' EQ '13').C13\n         BALR  &R&BASE1,0\n         AIF   ('&BASE2' NE '0').D12\n         USING *,&R&BASE1\n         AGO   .E12\n.D12     USING *,&R&BASE1,&R&BASE2\n.E12     AIF   ('&SAVE' NE 'RENT').C13\n         LR    &HOLD,&R.1         SAVE PARAMETER ADDRESS REGISTER\n         LA    &R.0,72            LOAD LENGTH\n         BAL   &R.1,*+4           INDICATE GETMAIN\n         SVC   10                 ISSUE GETMAIN SVC\n         ST    &R.13,4(&R.1)      CROSS-LINK\n         ST    &R.1,8(&R.13)      THE SAVE AREAS\n         LR    &R.13,&R.1         RELOCATE ADDRESS OF NEW SAVE AREA\n         AIF   ('&SPIE1' EQ 'NO').C21\n         AGO   .C18\n.C13     AIF   ('&SAVE' NE '').C14\n         AIF   ('&BASE1' EQ '15').C22\n         CNOP  2,4\n         LA    &R.14,*+18         LOAD ADDRESS OF NEW SAVE AREA\n         AGO   .C15\n.C14     LA    &R.14,&SAVE        LOAD ADDRESS OF NEW SAVE AREA\n.C15     ST    &R.13,4(&R.14)     CROSS-LINK\n         ST    &R.14,8(&R.13)     THE SAVE AREAS\n         LR    &R.13,&R.14        RELOCATE ADDRESS OF NEW SAVE AREA\n         AIF   ('&SAVE' NE '').C17\n         B     *+4+72             BRANCH AROUND SAVE AREA\n         AIF   ('&BASE1' NE '13').C16\n         DROP  &R.15              DROP THE TEMPORARY BASE REGISTER\n         AIF   ('&BASE2' NE '0').D15\n         USING *,&R.13            USE SAVE AREA ADDRESS ALSO AS BASE\n         AGO   .E15\n.D15     USING *,&R.13,&R&BASE2   USE SAVE AREA ADDRESS ALSO AS BASE\n.E15     ANOP\n.C16     DC    18CL4'SAVE'        REGISTER SAVE AREA\n.C17     AIF   ('&SPIE1' EQ 'NO').C22\n         LR    &HOLD,&R.1         SAVE PARAMETER ADDRESS REGISTER\n.C18     ANOP\n         CNOP  2,4\n.C185    LA    &R.1,*+12          LOAD BRANCH ADDRESS\n         BALR  &R.1,&R.1          BRANCH AROUND PARAMETERS\n         DC    A(0)               EXIT ROUTINE ADDRESS\n         DC    AL2(0)             INTERUPTION MASK\n         SVC   14                 ISSUE SPIE SVC\n.C20     ST    &R.1,0(&R.13)      SAVE PREVIOUS PICA\n.C21     LR    &R.1,&HOLD         RESTORE PARAMETER ADDRESS REGISTER\n.C22     AIF   ('&BASE2' EQ '0').C23\n         LA    &R&BASE2,2048(&R&BASE1) LOAD SECOND BASE REGISTER WITH\n         LA    &R&BASE2,2048(&R&BASE2) VALUE 4096 BEYOND FIRST BASE REG\n.C23     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETDCB": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x19&\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T19:26:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "QC22505"}, "text": "         MACRO\n&LAB     GETDCB &DCBREG,&FCBREG,&ERRADDR\n.*  THIS MACRO PUTS THE ADDRESS OF THE DCB RELATED TO A PL/I FILE\n.*  IN THE REGISTER INDICATED BY &DCBREG USING THE REGISTER AT &FCBREG\n.*  AS  A WORK REGISTER.  THE ADDRESS OF THE FCB IS LEFT IN &FCBREG\n.*\n.*  PARAMETERS:\n.*  &DCBREG   THE REGISTER INTO WHICH THE ADDRESS OF THE DCB IS TO\n.*            BE PLACED  1 - 15\n.*  &FCBREG   A WORK REGISTER  1 -  15\n.*  &ERRADDR  A LABEL SPECIFYING THE POINT TO BRANCH TO IF THE FILE\n.*  VARIABLE IS NOT OPEN.\n.*\n.*  NOTE THAT NEITHER REGISTER MAY BE REGISTER ZERO\n.*  THE FOLLOWING TWO THINGS ARE ASSUMED.\n.*  1.  ADDRESSABILITY IS ESTABLISTED TO PLIFILE\n.*  2.  REGISTER R12 POINTS TO THE PL/I TASK COMMUNICATIONS AREA\n&LAB     L     &DCBREG,PLIFILE          POINT TO FILE LOCATOR\n         L     &DCBREG,0(&DCBREG)       POINT TO OFFSET INTO PRV\n         L     &DCBREG,0(&DCBREG)       LOAD OFFSET INTO PRV FOR THIS\n*                                       FILE\n         L     &FCBREG,4(R12)           POINT TO THE PRV\n         L     &FCBREG,0(&FCBREG,&DCBREG)  LOAD  FCB ADDR\n         C     &FCBREG,X'64'(R12)       IS THE FILE OPEN?\n         BE    &ERRADDR\n         SPACE\n         L     &DCBREG,X'14'(&FCBREG)   POINT TO THE DCB\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEX": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x13H\\x00p\\x00n\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T13:48:18", "lines": 112, "newlines": 110, "modlines": 0, "user": "QC22505"}, "text": "HEX      TITLE 'FIXED TO HEX CHARACTER CONVERSION'\n***********************************************************************\n*                                                                     *\n*     THIS MODULE ACCEPTS AS A PARM A FIXED BINARY(31) VALUE AND      *\n*     RETURNS THE VALUE IN ITS HEX CHARACTER FORMAT.  THE RETURNED    *\n*     CHARACTER STRING CAN BE FIXED LENGTH OF VARYING.  IF THE        *\n*     LENGTH OF THE REQUESTED STRING IS LESS THAN 8 THE RETURNED      *\n*     STRING IS TRUNCATED FROM THE LEFT.  IF A FIXED LENGTH           *\n*     STRING OF LENGTH GREATER THAN 8 IS REQUESTED, THE STRING IS     *\n*     FILLED TO THE RIGHT.                                            *\n*                                                                     *\n*     THIS MODULE OPERATES IN A PL/I ENVIONMENT AS A LIBRARY          *\n*     ROUTINE.   THIS LOWERS THE OVERHEAD FOR CALLS.                  *\n*                                                                     *\n*     TO INVOKE THIS ROUTINE IT MUST BE DESCRIBED TO THE CALLING      *\n*     PL/I PROGRAM. THE BASIC FORM IS:                                *\n*                                                         |-   -|     *\n*            DCL HEX ENTRY(FIXED BIN(31)) RETURNS(CHAR(N) | VAR | )   *\n*                                                         |-   -|     *\n*                  EXTERNAL;                                          *\n*                                                                     *\n*     WHERE N IS THE REQUESTED NUMBER OF CHARACTERS TO BE RETURNED    *\n*     AND THE KEY WORD VAR IS OPTIONAL.                               *\n*                                                                     *\n*     THE ENTRY MAY BE DECLARED WITH DIFFERENT RETURNS FOR EACH       *\n*     CHANGE OF SCOPE OR MODULE WITHIN A PROCEDURE AND THE CHANGES    *\n*     ARE DETECTED THOUGHT THE USE OF THE STRING LOCATOR/DESCRIPTOR.  *\n*                                                                     *\n*     AUTHOR: R.W.CALLAGHAN, DEPT.482.61                              *\n*     ISSUE DATE: MARCH 14, 1977                                      *\n*                                                                     *\n*     ISSUE HISTORY:                                                  *\n*     REASON FOR ISSUE 02:                                            *\n*     ADD SYMBAR                                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n*     PROLOG\n         SPACE\nHEX      RENTR BASE=3,PARM=R10,WORK=(WORKLEN,WORKAREA)\nHEX1     AMODE ANY\nHEX1     RMODE ANY\n         SPACE 3\n*     TRANSLATE FIXED TO HEX\n         SPACE\n         LM    R14,R15,0(R10)      OBTAIN PARMS\n         MVC   WORD(4),0(R14)      CONVERT INPUT PARM TO HEX CHAR\n         UNPK  DWORD(9),WORD(5)\n         TR    DWORD(8),HEXSTRNG\n         SPACE 3\n*     RETURN HEX CHARACTER STRING\n         SPACE\n         L     R1,0(,R15)          OBTAIN STRING LOCATOR VALUES\n         LH    R2,4(,R15)\n         TM    6(R15),X'80'        VARYING STRING?\n         BO    HEX0020             YES: PROCESS AS VARYING\n         SPACE\n*     PROCESS FIXED LENGTH STRING\n         SPACE\n         CH    R2,=H'8'            STRING LENGTH < 8\n         BL    HEX0010             YES: TRUNCATE\n         MVC   0(8,R1),DWORD       MOVE OUTPUT TO STRING\n         BE    HEX0040             STRING LENGTH = 8: BYPASS FILL\n         MVI   8(R1),C' '          ADD BLANK TO STRING\n         SH    R2,=H'9'            CALCULATE REMAING LENGTH\n         BNH   HEX0040             NONE REMAING: BYPASS REMAINING FILL\n         BCTR  R2,0                EXTEND BLANKS TO REMING STRING\n         EX    R2,FILL\n         B     HEX0040\n         SPACE\n*     TRUNCATE OUTPUT STRING\n         SPACE\nHEX0010  LA    R14,8               CALCULATE LENGTH OF TRUNCATION\n         SR    R14,R2\n         LA    R14,DWORD(R14)      SET POINTER TO REMAINING OUTPUT\n         BCTR  R2,0                MOVE REMAING OUTPUT TO STRING\n         EX    R2,TRUNCATE\n         B     HEX0040\n         SPACE\n*     PROCESS VARYING STRING\n         SPACE\nHEX0020  CH    R2,=H'8'            ALLOCATE STRING LENGTH < 8\n         BL    HEX0030             YES: TRUNCATE\n         MVC   2(8,R1),DWORD       MOVE OUTPUT TO STRING\n         MVC   0(2,R1),=H'8'       SET CURRENT LENGTH OF STRING\n         B     HEX0040\nHEX0030  STH   R2,0(,R1)           STORE CURRENT LENGTH\n         LA    R1,2(R1)            ADJUST STRING POINTER\n         B     HEX0010\n         SPACE\n*     RETURN\n         SPACE\nHEX0040  DS    0H\n         REXIT\n         SPACE 3\n*     CONSTANTS\n         SPACE\nFILL     MVC   9(*-*,R1),8(R1)     EXTEND BLANK TO FILL STRING\nTRUNCATE MVC   0(*-*,R1),0(R14)    MOVE OUTPUT TO STRING\n         LTORG\n*FILLADDR EQU   246-(*-HEX)\n*        DC    (FILLADDR)C'#'      FILL TO ALLOW ADDRESSIBILITY\nHEXSTRNG EQU   *-240\n         DC    C'0123456789ABCDEF' HEX CHARACTER REPRENSATION STRING\nWORKAREA DSECT\n         DS    26F\nWORD     DS    2F\nDWORD    DS    2D\nWORKLEN  EQU   *-WORKAREA\n         SPACE 3\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKDATE": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x130\\x015\\x015\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T13:30:29", "lines": 309, "newlines": 309, "modlines": 0, "user": "QC22505"}, "text": "LINKDATE TITLE 'LINK EDITOR INTERFACE - DATE/TIME STAMP LOAD MODULES'\n***********************************************************************\n*                                                                     *\n*  NAME: LINKDATE                                                     *\n*                                                                     *\n*  PROGRAM WRITTEN BY: R.D.WIRTH   9/22/75                            *\n*  LAST MAINTAINED BY: R.D.WIRTH   9/22/75                            *\n*  LAST MAINTAINED BY: R.E.STYMA   5/10/85                            *\n*  LAST MAINTAINED BY: R.E.STYMA  12/12/2003 MAKE OUTPUT RMODE ANY    *\n*                                            AND AMODE ANY            *\n*                                                                     *\n*                                                                     *\n*  PURPOSE: FETCH THE DATE AND TIME OF AN IBM LINKAGE EDITOR JOB STEP *\n*           AND BUILD A \" SETSSI \" COMMAND WHICH CAN BE CONCATENATED  *\n*           TO THE FRONT OF THE LINK EDITORS SYSLIN INPUT STREAM.  THE*\n*           OPERAND OF THE SETSSI COMMAND WILL BE AN ENCODING OF THE  *\n*           DATE AND TIME AS DEFINED BELOW.  THE LINK EDITOR INSERTS  *\n*           THE OPERAND OF THE SETSSI COMMAND INTO THE USER DATA FIELD*\n*           OF THE LOAD MODULE PDS DIRECTORY WHERE IT CAN SUBSEQUENTLY*\n*           BE PRINTED ON A LOAD MODULE LIBRARY DIRECTORY ( SEE       *\n*           LINKDIR ).                                                *\n*           5/10/85 - ADD AN OPTION TO PUT THE DATE IN THE FORMAT     *\n*           MM/DD/YY IN A VARYING LENGTH EXTERNAL STRING.             *\n*           THE EXTERNAL CSECT NAME GENERATED IS LINKDTE AND THE      *\n*           FORMAT IS A TWO BYTE LENGTH FIELD FOLLOWED BY             *\n*           AN EIGHT BYTE STRING.                                     *\n*           TO ACTIVATE THIS OPTION, PLACE THE TWO CHARACTERS \"L,\"    *\n*           AS THE FIRST TWO CHARACTERS OF THE PARM STRING.           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  FUNCTIONS: 1) FETCH THE DATE & TIME USING THE OS MACRO.            *\n*             2) BUILD A SINGLE 80 BYTE RECORD TO BE WRITTEN TO OUTPUT*\n*                CARD IMAGE FILE (SETSSI).                            *\n*                THE CARD FORMAT IS:                                  *\n*                       '  SETSSI XXXXXYYY '                          *\n*                   WHERE  XXXXX  IS THE JULIAN DATE IN YYDDD FORMAT  *\n*                            YYY  IS THE TIME IN HOURS & TENS MINUTES *\n*                IE; '         SETSSI 75237184 '                      *\n*                    237 TH DAY OF 1975                               *\n*                    AT 6:40 PM                                       *\n*                NOTE THE THE CHARACTERS IN THE OPERAND OF            *\n*                     SETSSI ARE LIMITED TO 0-9 & A-F.                *\n*             3) PRINT A LINE (121 BYTES) ON AN OUTPUT FILE (PRINTDAT)*\n*                CONTAINING:                                          *\n*                  TITLE                                              *\n*                  JULIAN DATE   YYDDD                                *\n*                  CALENDAR DATE   MM/DD/YY                           *\n*                  TIME  HH:MM:SS                                     *\n*                  IMAGE OF SETSSI COMMAND                            *\n*             4) READ THE PARM:                                       *\n*                  FIRST PARAMETER IS THE NAME TO LOAD (TO 1ST COMMA) *\n*                  REST IS PASSED TO PROGRAM CALLED.                  *\n*             5) LINK TO THE LINK EDITOR LOAD MODULE, THE NAME        *\n*                WAS PASSED AS THE FIRST PARAMETER IN THE PARM STRING.*\n*             6) UPON RETURN FROM THE LINKED PROGRAM, RETURN WITH     *\n*                THE LINKED PROGRAMS RETURN CODE                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* OBTAIN THE CURRENT DATE AND TIME AND PROCEED TO FORMAT              *\n* THE OUTPUT CARD IMAGE AND PRINT LINE                                *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        PRINT NOGEN\nLINKDATE CSECT\n         ENTER R,SPIE=NO,ID=YES,BASE=13 * ESTABLISH SAVE AREA & ENTRY\n         ST    R1,PARMSAVE    * SAVE THE POINTER TO THE PARM\n         SPACE\n         TIME  DEC            * FETCH THE CURRENT DATE AND TIME\n         ST    R1,DATESAVE    * SAVE THE PACKED DECIMAL DATE (00YYDDDF)\n         ST    R0,TIMESAVE    * SAVE THE PACKED DECIMAL TIME (HHMMSSTH)\n         SPACE\n         UNPK  DATEUNPK,DATESAVE  * UNPACK THE DATE FOR PRINTING  YYDDD\n         MVC   SSICARD+10(5),DATEUNPK+3  * MOVE DATE CHARS INTO SETSSI\n         LA    R3,DATESAVE    * SET UP JULIAN DATE (PACKED) FOR SUBR.\n         BAL   R6,DATECONV    * GO CONVERT JULIAN DATE\n         ST    R3,SSICARD+52  *  TO MM/DD/YY FORMAT  (1ST 4 CHAR)\n         ST    R4,SSICARD+56  *                      (LAST 4 CHAR)\n         STCM  R3,15,OBJDATE     *  SAVE IN OBJ RECORD  (1ST 4 CHAR)\n         STCM  R4,15,OBJDATE+4   *  IN CASE WE NEED IT  (LAST 4 CHAR)\n         SPACE\n         OI    TIMESAVE+3,X'0F'  * SET THE SIGN TO PERMIT UNPACKING\n         UNPK  TIMEUNPK,TIMESAVE  * UNPACK THE TIME FOR PRINTING\n         MVC   SSICARD+15(3),TIMEUNPK+1  * MOVE HOURS & TENS OF MINUTES\n         MVC   SSICARD+63(2),TIMEUNPK+1  * MOVE HOURS TO PRINT LINE\n         MVC   SSICARD+66(2),TIMEUNPK+3  * MOVE MINUTES TO PRINT LINE\n         MVC   SSICARD+69(2),TIMEUNPK+5  * MOVE SECONDS TO PRINT LINE\n         MVC   OBJTIME+00(2),TIMEUNPK+1  * MOVE HOURS TO OBJECT CARD\n         MVC   OBJTIME+03(2),TIMEUNPK+3  * MOVE MINUTES TO OBJECT CARD\n         EJECT\n***********************************************************************\n*                                                                     *\n* PERFORM ALL OUTPUT TO THE CARD AND PRINT FILES                      *\n*   SETSSI    IS THE DDNAME OF THE CARD OUTPUT FILE                   *\n*   PRINTDAT  IS THE DDNAME OF THE PRINT OUTPUT FILE                  *\n*                                                                     *\n***********************************************************************\n         SPACE\n         OPEN  (SSIDCB,OUTPUT,PRINTDCB,OUTPUT)  * OPEN BOTH OUTPUT FILE\n         SPACE\n         TM    PRINTDCB+DCBOFLGS-IHADCB,X'10'  * TEST FOR OPEN DCB\n         BZ    NOOPENPT       * BRANCH IF OPEN NOT SUCCESSFUL\n         TM    SSIDCB+DCBOFLGS-IHADCB,X'10'  * TEST FOR OPEN DCB\n         BZ    NOOPENCD       * BRANCH IF OPEN NOT SUCCESSFUL\n         SPACE\n         PUT   SSIDCB,SSICARD              * WRITE CARD TO OUTPUT FILE\n         PUT   PRINTDCB,SSICARD              * WRITE PRINT OUTPUT FILE\n         SPACE\n         L     R15,PARMSAVE   * RETIREVE THE INPUT PARM POINTER\n         L     R1,0(R15)      * POINT TO THE PARM STRING LENGTH\n         LH    R2,0(R1)       * FETCH THE LENGTH OF THE PARM STRING\n         LTR   R2,R2          * TEST LENGTH OF THE PARM STRING\n         BZ    PARMERR        * BRANCH TO ERROR IF NO PARM WAS PASSED\n         LA    R1,2(R1)       * BUMP PARM POINTER PAST LENGTH FIELD\n         SPACE\n         CLC   0(2,R1),=CL2'L,' * IS THE FIRST PARM THE L PARM\n         BNE   DOCLOSE        * IF NOT, SKIP OUTPUTING THE OBJ\n         SPACE\n         BCTR  R2,0           * DECREMENT TWICE TO COMPENSATE FOR\n         BCTR  R2,0           * THE L PARM AND COMMA\n         STH   R2,0(R1)       * STORE LENGTH OF NEW PARM\n         ST    R1,0(R15)      * REPLACE STRING ADDR IN PARM LIST\n         SPACE\n         PUT   SSIDCB,OBJ1    * OUTPUT ESD RECORD\n         PUT   SSIDCB,OBJ2    * OUTPUT TXT RECORD\n         PUT   SSIDCB,OBJ3    * OUTPUT END RECORD\n         SPACE\nDOCLOSE  EQU   *\n         CLOSE (SSIDCB,,PRINTDCB)  * CLOSE BOTH OUTPUT FILES\n         EJECT\n***********************************************************************\n*                                                                     *\n*  FETCH THE FIRST PARAMETER OF THE PARM STRING (WHICH SHOULD BE A    *\n*  NAME OF A LINK EDITOR) AND USE IT TO LINK TO THE APPROPRIATE       *\n*  LOAD MODULE.  THEN PASS THE REMAINDER OF THE PARM TO THE PROGRAM.  *\n*  TERMINATE UPON RETURN.                                             *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     R1,PARMSAVE    * RETIREVE THE INPUT PARM POINTER\n         L     R1,0(R1)       * POINT TO THE PARM STRING LENGTH\n         LH    R2,0(R1)       * FETCH THE LENGTH OF THE PARM STRING\n         LTR   R2,R2          * TEST LENGTH OF THE PARM STRING\n         BZ    PARMERR        * BRANCH TO ERROR IF NO PARM WAS PASSED\n         LA    R1,2(R1)       * BUMP PARM POINTER PAST LENGTH FIELD\n         SPACE\n         LR    R3,R1          * CURRENT CHAR POINTER TO PARM STRING\n         SR    R4,R4          * LENGTH OF FIRST PARAMETER OF PARM\n         SPACE\nNEXTCHAR EQU   *\n         CH    R2,=H'0'       * RUN OUT OF PARM? MEANS ONLY NAME PASSED\n         BNH   GOTNAME        * YES, GO SAVE NAME FOR LINK\n         CLI   0(R3),C','     * COMMA? INDICATING END OF FIRST PARAM\n         BE    GOTPARM        * YES, GO SAVE NAME & REMAINIGN PARM\n         BCTR  R2,0           * DECREMENT PARM STRING LENGTH -REMAINDER\n         LA    R3,1(R3)       * BUMP PARM POINTER TO NEXT CHAR\n         LA    R4,1(R4)       * BUMP NAME PARAMETER LENGTH\n         B     NEXTCHAR       * GO LOOK AT NEXT CHARACTER\n         SPACE\nGOTPARM  EQU   *\n         BCTR  R2,0           * DECREMENT ONCE TO GET PASSED COMMA\n         STH   R2,LPRMLST     * STORE LENGTH OF NEW PARM TO LINK EDITOR\n         BCTR  R2,0           * DECREMENT AGAIN TO ADJUST FOR MVC\n         EX    R2,PARMMVC     * GO EXECUTE MVC TO MOVE PARM FOR LINK\n         SPACE\nGOTNAME  EQU   *\n         CH    R4,=H'8'       * IS THE NAME TOO LARGE? (>8 CHAR)\n         BH    PARMERR        * YES, GO ABEND SIGNALLING PARM ERROR\n         BCTR  R4,0           * DECREMENT TO ADJUST LENGTH FOR MVC\n         EX    R4,NAMEMVC     * GO EXECUTE MVC TO MOVE NAME FOR LINK\n         SPACE\n         LA    R1,APRMLST     * ADDRESS OF PARM PASSED TO LINK EDITOR\n         LINK  EPLOC=EPNAME   * GO LINK TO THE REQUESTED LINK EDITOR\n         SPACE\n         RETRN R,SPIE=NO,RC=(15)  * RETURN - PASS L/E RETURN CODE BACK\n         SPACE\nNAMEMVC  MVC   EPNAME(*-*),0(R1)  * EXECUTED!  CAPTURE NAME FOR LINK\nPARMMVC  MVC   PARM(*-*),1(R3)  * EXECUTED!  CAPTURE REMAINING PARM\n         EJECT\n***********************************************************************\n*                                                                     *\n*  SUBROUTINE TO CONVERT THE JULIAN DATE (AS OBTAINED FROM THE        *\n*  OS TIME MACRO) INTO THE NORMAL CALENDAR DATE                       *\n*                                                                     *\n*  CALLING SEQUENCE:  (R3) = A(X'00YYDDDF')      YY = YEAR            *\n*                     BAL  R6,DATECONV          DDD = DAY OF YEAR     *\n*                                                                     *\n*  RETURNS:           (R3) = C'MM/D'             MM = MONTH           *\n*                     (R4) = C'D/YY'             DD = DAY             *\n*                                                YY = YEAR            *\n*                                                                     *\n***********************************************************************\n         SPACE\nDATECONV EQU   *\n         ST    R6,DATERTRN    * SAVE THE RETURN LINKAGE\n         SPACE\n         MVC   DATEPACK(4),=X'0000000F'  * CONVERT YEAR OF DATE TO DEC\n         MVO   DATEPACK(4),1(1,R3)  *\n         UNPK  DATEUNPK(3),DATEPACK+2(2)  *\n         OI    DATEUNPK+2,X'F0'\n         MVC   DATECHAR+6(2),DATEUNPK+1  * MOVE THE YEAR TO DATE CHARS\n         SPACE\n         DP    DATEPACK(4),=PL2'4'  * DETERMINE IF LEAP YEAR (MULT 4)\n         CP    DATEPACK+2(2),=PL2'0'  * REMAINDER OF ZERO IF IT IS\n         MVC   DATEPACK(2),2(R3)  * CAPTURE DAY OF YEAR\n         BNE   DATELEAP       * BRANCH IF NOT LEAP YEAR\n         CP    DATEPACK(2),=P'60'  * SEE IF AFTER FEB 28\n         BNH   DATELEAP       * BRANCH IF AFTER FEB 28\n         SP    DATEPACK(2),=P'1'  * DECREASE DATE TO COMPENSATE\nDATELEAP EQU   *\n         LA    R4,DATETAB+22  * POINT TO LAST ENTRY IN THE TABLE\nDATELOOP EQU   *\n         CP    DATEPACK(2),0(2,R4)  * SEE IF RIGHT RANGE OF MONTH\n         BH    DATEGOT        * BRANCH IF RIGHT MONTH\n         SH    R4,=H'2'       * POINT TO THE NEXT ENTRY OF THE TABLE\n         B     DATELOOP       * GO BACK TO TRY NEXT ENTRY\nDATEGOT  EQU   *\n         SP    DATEPACK(2),0(2,R4)  * GET DAY OF MONTH\n         LA    R6,DATETAB-2   * CONVERT THE TABLE POINTER\n         SR    R4,R6          *   INTO AN OFFSET\n         SRA   R4,1           *     AND THEN INTO MONTH NUMBER\n         CVD   R4,DATEUNPK    * CONVERT THE MONTH # INTO DECIMAL\n         UNPK  DATEUNPK(3),DATEUNPK+6(2)  * AND UNPACK MONTH # TO PRINT\n         OI    DATEUNPK+2,X'F0'  * ADJUST SIGN FOR PROPER PRINTING\n         MVC   DATECHAR(2),DATEUNPK+1  * PUT MONTH # INTO RTRN PARM\n         SPACE\n         UNPK  DATEUNPK(3),DATEPACK(2)  * CONVERT DAY OF MONTH\n         OI    DATEUNPK+2,X'F0'         *   INTO DECIMAL FOR PRINT\n         MVC   DATECHAR+3(2),DATEUNPK+1 * PUT DAY INTO RETURN PARAM\n         SPACE\n         L     R3,DATECHAR    * PICK UP 1ST HALF OF DATE CHARS\n         L     R4,DATECHAR+4  * PICK UP LAST HALF OF DATE CHARS\n         SPACE\n         L     R6,DATERTRN    * RESTORE THE RETURN LINKAGE\n         BR    R6             * RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* ERROR PROCESSING CONSISTS OF GENERATING A USER ABEND UNIQUE TO      *\n* EACH TYPE OF ERROR DETECTED.                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nNOOPENPT EQU  *\n         ABEND 1000           * OUTPUT PRINT FILE DID NOT OPEN\n         SPACE\nNOOPENCD EQU   *\n         ABEND 1004           * OUTPUT CARD FILE DID NOT OPEN\n         SPACE\nPARMERR  EQU   *\n         ABEND 1008           * INVALID PARM INPUT STRING\n*                             * EITHER: NO PARM?\n*                             *     OR  FIRST PARAMETER > 8 CHARACTERS?\n         EJECT\n***********************************************************************\n*                                                                     *\n*  DATA AREAS / DCB'S FOR OUTPUT / PARAMETER LISTS / DCB SYMBOLICS    *\n*                                                                     *\n***********************************************************************\n         SPACE\n         DS   0F\nSSICARD  DC    CL52'  SETSSI  XXXXXXXX  <SET LOADLIB SSI - YYDDDHHM>'\n         DC    CL28'MM/DD/YY   HH:MM:SS'\n         DC    CL41'PROGRAM: LINKDATE  (LINK EDIT DATE/TIME)'\n         SPACE\nTIMEUNPK DC    D'0'           * UNPACKED TIME\nTIMESAVE DC    F'0'           * SAVE AREA FOR THE PACKED TIME\nDATERTRN DC    F'0'           * DATE CONVERSION SUBR RETURN LINK\nDATESAVE DC    F'0'           * SAVE AREA FOR THE PACKED DATE\nDATEPACK DC    F'0'\nDATEUNPK DC    D'0'           * UNPACKED DATE\nDATECHAR DC    CL8'XX/XX/XX'  * PARAMETER RETURNED FROM DATECONV\nDATETAB  DC    PL2'0,31,59,90,120,151,181,212,243,273,304,334'\n         SPACE\nEPNAME   DC    CL8' '         * CALLED LINK EDITOR ENTRY NAME\n         SPACE\nPARMSAVE DC    F'0'           * SAVE ADDRESS OF PARM TO LINKDATE\nAPRMLST  DC    AL1(X'80'),AL3(LPRMLST)  * ADDRESS OF PARM PASSED TO L/E\nLPRMLST  DC    H'0'           * LENGTH OF PARM PASSED TO LINK EDITOR\nPARM     DC    CL255' '       * ACTUAL PARM PASSED TO LINK EDITOR\n         SPACE\nPRINTDCB DCB   DDNAME=SYSPRINT,BLKSIZE=121,DEVD=DA,DSORG=PS,           X\n               LRECL=121,MACRF=PM,RECFM=FA,BUFNO=1\n         SPACE\nSSIDCB   DCB   DDNAME=SETSSI,BLKSIZE=3200,BUFNO=1,DEVD=DA,DSORG=PS,    X\n               LRECL=80,MACRF=PM,RECFM=FB\n         SPACE\nOBJ1    DC    X'02'\n        DC    C'ESD      '\n        DC    X'001040400001'\n        DC    C'LINKDTE '\n        DC    X'0000000047000028'\n        DC    CL48' '\nOBJ2    DC    X'02'\n        DC    C'TXT '\n        DC    X'000000404000284040000141F0F02807FF0000000F'\nOBJDATE DC    CL10'MM/DD/YY  '\nOBJTIME DC    CL5'HH:MM'\n        DC    CL41' '\nOBJ3    DC    X'02'\n        DC    CL79'END                            15741SC103 020185130'\n         SPACE\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA  * GENERATE SYMBOLICS FOR DCB ADDRESSES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLEA": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x10A\\x01\\x8a\\x01\\x8a\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T10:41:16", "lines": 394, "newlines": 394, "modlines": 0, "user": "QC22505"}, "text": "*PROCESS MAR(2,72,1);\n /**********************************************************************\n *\n *  PROGRAM PLEA - PL/I EXECUTION ANALYZER\n *\n *  THIS PROGRAM PERFORMS CPU OR WALL TIME PERFORMANCE ANALYSIS ON\n *  APPLICATION PROGRAMS WRITTEN IN PL/I.  THE VERSION 2 PL/I COMPILER\n *  MUST BE USED IN THE APPLICATION.  THE PROGRAM MUST HAVE BEEN\n *  COMPILED WITH THE TEST(STMT) OR TEST(ALL) AND GS OPTIONS.\n *\n *\n *   //SAMPLE EXEC PGM=PLEA,\n *   //   PARM='/A1,1,TASK,NOSPIE/PGMPARMS'\n *               |  |  |     |     |\n *               |  |  |     |     +- PARMS TO YOUR PROGRAM\n *               |  |  |     +------- PL/I PARMS FOR YOUR PGM\n *               |  |  +------------- SAMPLE CPU TIME\n *               |  |                 SPECIFY REAL FOR WALL TIME SAMPLES\n *               |  +---------------- SAMPLE EVERY 1/100 SECOND\n *               +------------------- NAME OF PROGRAM TO EXECUTE\n *   //STEPLIB  DD DSN=YOUR.NORMAL.STEPLIBS,DISP=SHR\n *   //         DD DSN=YOUR.PLEA.LOAD,DISP=SHR\n *   //         DD DSN=EQAW.SEQAMOD,DISP=SHR\n *         YOUR.PLEA.LOAD CAN BE THE FIRST OR LAST STEPLIB,\n *         EQAW.SEQAMOD IS REQUIRED IF IT IS NOT IN THE LINK LIST\n *\n *                       PLEA WORK DATASETS\n *\n *   //CMD$FILE DD  UNIT=SYSVIO,SPACE=(TRK,1),\n *   //             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n *   //PLEAPRNT DD  SYSOUT=*\n *   //SYSUDUMP DD  SYSOUT=*\n *\n *        THE SAMPLES END UP IN THE FOLLOWING DATASET\n *\n *   //TRACE$$  DD  DSN=QC22505.TRACE.DATA,\n *   //             DISP=(NEW,CATLG),UNIT=SYSDA,SPACE=(CYL,(50,20),RLSE)\n *\n *\n *\n *\n *\n *\n **********************************************************************/\n\n PLEA:\n    PROCEDURE(MAINPARM) OPTIONS(MAIN) REORDER;\n    DECLARE  MAINPARM    VARYING CHAR(100);\n    DECLARE  CARD        CHAR(80);\n    DECLARE  SYSPRINT    FILE PRINT;\n    DECLARE  CMDFILE     FILE RECORD OUTPUT\n                         ENV(TOTAL,RECSIZE(80),FB,BLKSIZE(9040));\n    DECLARE  CMDFILE_DD  VARYING CHAR(8) STATIC INIT('CMD$FILE');\n    DECLARE  RC          FIXED BINARY(31) AUTO INIT(0);\n    DECLARE  I           FIXED BINARY(31) AUTO;\n    DECLARE  J           FIXED BINARY(31) AUTO;\n    DECLARE  REASON(2)   FIXED BINARY(15) AUTO;\n    DECLARE  ABEND_CODE  VARYING CHAR(5)  AUTO;\n    DECLARE  1  CUR$LOC  AUTO,\n                2  STMT    CHAR(8)         INIT('        '),\n                2  PROC    CHAR(31)        INIT('        ');\n    DECLARE  1  LOC_HEADER   AUTO,\n                2  STMT    CHAR(8)         INIT(' '),\n                2  HEADER  CHAR(4)         INIT(' '),\n                2  LOAD    CHAR(8)         INIT(' '),\n                2  TYPE    CHAR(4)         INIT(' '),\n                2  INT     PIC'ZZZZZZ99'   INIT(0),\n                2  SPARE   CHAR(15)        INIT(' ');\n    DECLARE  1  LOC_TRAILER  AUTO,\n                2  STMT    CHAR(8)         INIT(' '),\n                2  HEADER  CHAR(4)         INIT(' '),\n                2  SP1     CHAR(2)         INIT(' '),\n                2  COUNT   PIC'ZZZZZZZ9'   INIT(0),\n                2  MINUTES PIC'ZZZZZZZ9'   INIT(0),\n                2  STMTS   PIC'ZZZZZZZZ9'  INIT(0),\n                2  SPARE   CHAR(8)         INIT(' ');\n    DECLARE  LOC_HEADER_PTR    POINTER AUTO INIT(ADDR(LOC_HEADER));\n    DECLARE  LOC_TRAILER_PTR   POINTER AUTO INIT(ADDR(LOC_TRAILER));\n    DECLARE  REC_LOC      CHAR(8) AUTO;\n    DECLARE  C            CHAR(1) AUTO;\n    DECLARE  COUNT        FIXED BINARY(31) AUTO INIT(0);\n    DECLARE  STMTS        FIXED BINARY(31) AUTO INIT(0);\n    DECLARE  PROGRAM      CHAR(8)  AUTO;\n    DECLARE  OS_PARM      VARYING CHAR(256) AUTO;\n    DECLARE  SAMPLE_TYPE  VARYING CHAR(30)  AUTO;\n    DECLARE  TIMEINT      FIXED BINARY(31)  AUTO;\n    DECLARE  TIMEING_TYPE  CHAR(4)           AUTO INIT(' ');\n    DECLARE  TYPE_REAL_TIME CHAR(4)  STATIC INIT('REAL');\n    DECLARE  TYPE_CPU_TIME  CHAR(4)  STATIC INIT('CPU ');\n    DECLARE  START_TIME     CHAR(6)  AUTO;\n    DECLARE  STOP_TIME      CHAR(6)  AUTO;\n    DECLARE  PLITEST_CMDS(15) CHAR(80) INIT(\n           ' DECLARE P12 POINTER;                 ',\n           ' DECLARE A12(150) POINTER BASED;      ',\n           ' DECLARE C12(512) CHAR(1) BASED;      ',\n           ' P12 = %GPR12;                        ',\n           ' P12->A12(106) = ''XXXXXXXX''PX;      ',\n           ' P12->C12(429) = ''45''X;             ',\n           ' P12->C12(430) = ''C0''X;             ',\n           ' AT STATEMENT * DO;                   ',\n           ' P12 = %GPR12;                        ',\n           ' DIM = P12->A12(106);                 ',\n           ' P12->A12(106) = ''XXXXXXXX''PX;      ',\n           ' P12->C12(429) = ''45''X;             ',\n           ' P12->C12(430) = ''C0''X;             ',\n           ' GO;                                  ',\n           ' END;                                 ');\n    OPEN FILE(SYSPRINT) TITLE('PLEAPRNT') OUTPUT;\n    PUT FILE(SYSPRINT) SKIP EDIT('PLEA - PL/I EXECUTION ANALYZER',\n                                 'RELEASE 2.4 AS OF ',\n                                 LINKDTE.LINK_DATE)(A,X(1),A,A);\n    SAMPLE_TYPE = 'SAMPLING CPU TIME';\n    TIMEING_TYPE = TYPE_CPU_TIME;\n    I = INDEX(MAINPARM,',');\n    IF I \u00ac= 0\n    THEN\n       DO;\n          PROGRAM = SUBSTR(MAINPARM,1,I-1);\n          MAINPARM = SUBSTR(MAINPARM,I+1);\n          TIMEINT = 0;\n          C = SUBSTR(MAINPARM,1,1);\n          DO WHILE(VERIFY(C,'0123456789') = 0);\n             TIMEINT = TIMEINT * 10 + FIXED(C);\n             MAINPARM = SUBSTR(MAINPARM,2);\n             C = SUBSTR(MAINPARM,1,1);\n          END;\n          IF C = ','\n          THEN\n             MAINPARM = SUBSTR(MAINPARM,2);\n          IF SUBSTR(MAINPARM,1,4) = 'REAL'\n          THEN\n             DO;\n                TIMEING_TYPE = TYPE_REAL_TIME;\n                SAMPLE_TYPE = 'SAMPLING REAL TIME';\n                MAINPARM = SUBSTR(MAINPARM,5);\n                IF SUBSTR(MAINPARM,1,1) = ','\n                THEN\n                   MAINPARM = SUBSTR(MAINPARM,2);\n             END;\n          IF SUBSTR(MAINPARM,1,4) = 'TASK'\n          THEN\n             DO;\n                TIMEING_TYPE = TYPE_CPU_TIME;\n                SAMPLE_TYPE = 'SAMPLING CPU TIME';\n                MAINPARM = SUBSTR(MAINPARM,5);\n                IF SUBSTR(MAINPARM,1,1) = ','\n                THEN\n                   MAINPARM = SUBSTR(MAINPARM,2);\n             END;\n\n          OS_PARM = 'TEST(NONE,,''USE '||\n                    CMDFILE_DD || ';GO;'')'||MAINPARM;\n          IF TIMEINT = 0\n          THEN\n             TIMEINT = 3;\n       END;\n    ELSE\n       DO;\n          PROGRAM = MAINPARM;\n          OS_PARM = 'TEST(NONE,,''USE '||\n                    CMDFILE_DD || ';GO;'')';\n          TIMEINT = 3;\n       END;\n    PUT FILE(SYSPRINT) SKIP(2) EDIT(\n                       'RUNNING PROGRAM: ',PROGRAM)(A,A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n                       SAMPLE_TYPE)(A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n                      'SAMPLE TAKEN EVERY ',TIMEINT,'/100 OF A SECOND')\n                       (A,F(5),A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n                       'USING PARM: ',OS_PARM)(A,A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n        'NOTE: PROGRAM MUST BE COMPILED WITH VERSION 2 PL/I')(A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n        '      PROGRAM MUST BE COMPILED OPTION TEST(STMT) OR TEST(ALL)')\n        (A);\n    PUT FILE(SYSPRINT) SKIP(1) EDIT(\n        '      PROGRAM SHOULD BE COMPILED OPTION GOSTMT')\n        (A);\n    IF PROGRAM = ' '\n    THEN\n       DO;\n           PUT FILE(SYSPRINT) SKIP(1) EDIT('NO PROGRAM NAME SPECIFIED')\n                                          (A);\n           CALL PLIRETC(16);\n           RETURN;\n       END;\n\n    OPEN FILE(CMDFILE) TITLE(CMDFILE_DD) RECORD OUTPUT;\n    GETSAMP_LOC  = HEX(GETSAMP_BIN);\n    DO I = 1 TO HBOUND(PLITEST_CMDS,1);\n       J = INDEX(PLITEST_CMDS(I),'XXXXXXXX');\n       IF J > 0\n       THEN\n          SUBSTR(PLITEST_CMDS(I),J,8) = GETSAMP_LOC;\n       WRITE FILE(CMDFILE) FROM(PLITEST_CMDS(I));\n    END;\n    CLOSE FILE(CMDFILE);\n    LOC_HEADER.STMT   = '        ';\n    LOC_HEADER.HEADER = '+++1';\n    LOC_HEADER.LOAD   = PROGRAM;\n    LOC_HEADER.TYPE   = TIMEING_TYPE;\n    LOC_HEADER.INT    = TIMEINT;\n    ON ERROR\n    BEGIN;\n       LOC_TRAILER.STMT    = ' ';\n       LOC_TRAILER.HEADER  = '+++2';\n       LOC_TRAILER.COUNT   = COUNT;\n       LOC_TRAILER.STMTS   = STMTS;\n       CALL STOPSAM(LOC_TRAILER_PTR);\n    END;\n    START_TIME = SUBSTR(TIME(),1,6);\n    CALL SAMPLER(COUNT,STMTS,LOC_HEADER_PTR,TIMEINT,TIMEING_TYPE,\n                 PROGRAM,OS_PARM,RC);\n    STOP_TIME  = SUBSTR(TIME(),1,6);\n    LOC_TRAILER.STMT    = ' ';\n    LOC_TRAILER.HEADER  = '+++2';\n    LOC_TRAILER.COUNT   = COUNT;\n    LOC_TRAILER.STMTS   = STMTS;\n    LOC_TRAILER.MINUTES = SUBTRACT_TIME(START_TIME,STOP_TIME);\n    CALL STOPSAM(LOC_TRAILER_PTR);\n    PUT FILE(SYSPRINT) SKIP EDIT('PROGRAM ',PROGRAM,\n                                 ' ENDED, RC = ',RC)\n                                 (A,A,A,F(8));\n    CALL PLIRETC(RC);\n    PUT FILE(SYSPRINT) SKIP EDIT(COUNT,' SAMPLES TAKEN')\n                                 (F(9),A);\n    PUT FILE(SYSPRINT) SKIP EDIT(STMTS,' PL/I STATEMENTS EXECUTED')\n                                 (F(9),A);\n    RETURN;\n1\n /**********************************************************************\n *                                                                     *\n * SEGMENT NAME:                                                       *\n *                                                                     *\n *    SUBTRACT_TIME -- CALCULATE A TIME INTERVAL BASED ON TO CLOCK     *\n *       TIMES                                                         *\n *                                                                     *\n * INPUTS (*TO FUNCTIONS):                                             *\n *                                                                     *\n *    START_TIME -- START OF TIME INTERVAL TO BE CALCULATED (*1)       *\n *       THE FIRST PARM TO THIS ROUTINE IS THE STARTING TIME OF THE    *\n *       INTERVAL TO BE CALCULATED IN THE FORM HHMMSS.                 *\n *                                                                     *\n *    STOP_TIME -- STOP OF TIME INTERVAL TO BE CALCULATED (*1)         *\n *       THE SECOND PARM TO THIS ROUTINE IS THE ENDING TIME OF THE     *\n *       INTERVAL TO BE CALCULATED IN THE FORM HHMMSS.                 *\n *                                                                     *\n * FUNCTIONS:                                                          *\n *                                                                     *\n *    1. CALCULATE THE NUMBER OF SECONDS, MINUTES, AND HOURS BETWEEN   *\n *       THE START AND STOP TIMES, CARRYING WHEN NECESSARY.            *\n *                                                                     *\n *    2. ROUND THE TIME INTERNVAL TO THE NEAREST MINUTES.  ALWAYS      *\n *       RETURN AT LEAST 1 MINUTE.                                     *\n *                                                                     *\n * OUTPUTS (*FROM FUNCTIONS):                                          *\n *                                                                     *\n *    INTERVAL -- INTERVAL IN MINUTES. (*2)                            *\n *       THE RETURNED PICTURE VARIABLE IS THE NUMBER OF MINUTES        *\n *       BETWEEN THE START TIME AND THE STOP TIME ROUNDED TO THE       *\n *       CLOSEST MINUTE.  THE MINIMUM VALUE RETURNED IN 1.             *\n *                                                                     *\n **********************************************************************/\n\n SUBTRACT_TIME:\n    PROCEDURE(START_TIME,STOP_TIME) RETURNS(PIC'ZZZZZZZ9');\n    DECLARE  START_TIME    CHAR(*);\n    DECLARE  STOP_TIME     CHAR(*);\n    DECLARE  01  START_OVLY BASED(ADDR(START_TIME)),\n                 02  HH    PIC'99',\n                 02  MM    PIC'99',\n                 02  SS    PIC'99';\n    DECLARE  01  STOP_OVLY  BASED(ADDR(STOP_TIME)),\n                 02  HH    PIC'99',\n                 02  MM    PIC'99',\n                 02  SS    PIC'99';\n    DECLARE  DIFF_MINUTES  PIC'ZZZZZZZ9' AUTO;\n    /* TAKE CARE OF CROSSING DATE BOUNDARY        */\n    /* NO MODULE TAKES MORE THAN 1 DAY TO COMPILE */\n    IF START_OVLY.SS > STOP_OVLY.SS\n    THEN\n       DO;  /* CARRY ONE MINUTE IF NECCESSARY */\n          STOP_OVLY.SS = STOP_OVLY.SS + 60;\n          STOP_OVLY.MM = STOP_OVLY.MM - 1;\n       END;\n    /* WE DON'T SAVE SECONDS, BUT ROUND TO THE NEAREST MINUTE */\n    IF STOP_OVLY.SS - START_OVLY.SS >= 30\n    THEN\n       STOP_OVLY.MM = STOP_OVLY.MM + 1;\n    IF START_OVLY.MM > STOP_OVLY.MM\n    THEN\n       DO;\n          STOP_OVLY.MM = STOP_OVLY.MM + 60;\n          STOP_OVLY.HH = STOP_OVLY.HH - 1;\n       END;\n    IF STOP_OVLY.HH < START_OVLY.HH\n    THEN\n       STOP_OVLY.HH = STOP_OVLY.HH + 24;\n    DIFF_MINUTES = 60 * (STOP_OVLY.HH - START_OVLY.HH) +\n                        (STOP_OVLY.MM - START_OVLY.MM);\n    IF DIFF_MINUTES = 0\n    THEN\n       DIFF_MINUTES = 1;\n    RETURN(DIFF_MINUTES);\n\n END SUBTRACT_TIME;\n\n DEFAULT RANGE(*) ALIGNED FIXED BINARY STATIC,\n                  DESCRIPTORS ALIGNED;\n DECLARE (ABS,\n          ADDR,\n          ALLOCATION,\n          ANY,\n          BIT,\n          BINARY,\n          CHAR,\n          COMPLETION,\n          DATE,\n          DATETIME,\n          DIM,\n          DECIMAL,\n          EMPTY,\n          FIXED,\n          HBOUND,\n          HIGH,\n          INDEX,\n          LBOUND,\n          LENGTH,\n          LINENO,\n          LOW,\n          MAX,\n          MIN,\n          MOD,\n          NULL,\n          ONCODE,\n          ONKEY,\n          PLIRETC,\n          PLIRETV,\n          PLISRTA,\n          PLISRTB,\n          PLISRTC,\n          PLISRTD,\n          REPEAT,\n          ROUND,\n          SAMEKEY,\n          STATUS,\n          STG,\n          STORAGE,\n          STRING,\n          SUBSTR,\n          TIME,\n          TRANSLATE,\n          TRUNC,\n          UNSPEC,\n          VERIFY)            BUILTIN;\n\n  DECLARE HEX       ENTRY(FIXED BINARY(31)) RETURNS(CHAR(8)) EXTERNAL;\n\n /*******************************************************************\n *\n *   DECLARATION FOR THE LINK DATE INFORMATION BUILD BY THE LINKDATE\n *   PROGRAM AND LINKED WITH THIS PROGRAM.\n *\n *    LINKDTE IS A SPECIAL VARIABLE SET UP BY THE LINKDATE PROGRAM\n *    WHICH IS PART OF THE RELEASE PROCEDURE AND THE MDLKED CATALOGUED\n *    PROCEDURE.  THE LINKDATE PROGRAM GENERATES AN EXTERNAL VARIABLE\n *    NAMED LINKDTE WHICH CONTAINS THE CURRENT DATE IN MM/DD/YY FORMAT.\n *    NOTE: THAT WHEN USING LINKDTE YOU MUST ALWAYS INCLUDE THE\n *    ENTRY PLISTART CARD AS LINKDTE IS THE FIRST CSECT AND WOULD\n *    BECOME THE DEFAULT ENTRY POINT.\n *\n *********************************************************************/\n    DECLARE  01  LINKDTE  STATIC EXTERNAL ALIGNED,\n                 02    HEADER_JUNK    CHAR(8) INIT(' '),\n                 02    LINK_DATE      VARYING CHAR(30) INIT('UNKNOWN');\n\n    DECLARE  SAMPLER  ENTRY(FIXED BINARY(31),    /* COUNT OF SAMPLES */\n                            FIXED BINARY(31),    /* COUNT OF STMTS   */\n                            POINTER,             /* POINTER TO HEADER*/\n                            FIXED BINARY(31),    /* TIMER INTERVAL   */\n                            CHAR(4),             /* 'CPU ' OR 'REAL' */\n                            CHAR(8),             /* LMOD NAME TO CALL*/\n                            VARYING CHAR(*),     /* LMOD PARM        */\n                            FIXED BINARY(31))    /* RETUNR CODE      */\n                            EXTERNAL;\n    DECLARE  STOPSAM  ENTRY(POINTER) EXTERNAL;\n    DECLARE  GETSAMP      ENTRY EXTERNAL;\n    DECLARE  GETSAMP_VAR  ENTRY VARIABLE AUTO INIT(GETSAMP);\n    DECLARE  GETSAMP_BIN  FIXED BINARY(31) BASED(ADDR(GETSAMP_VAR));\n    DECLARE  GETSAMP_LOC  CHAR(8) AUTO;\n\n END PLEA;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PLEAREP": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x13\\x11\\x03E\\x03E\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T13:11:36", "lines": 837, "newlines": 837, "modlines": 0, "user": "QC22505"}, "text": "*PROCESS MAR(2,72,1);                                                   00001\n /**********************************************************************00002\n *                                                                     *00002\n * SEGMENT NAME:                                                       *00002\n *                                                                     *00002\n *    PLEAREP -- PLI_EXECUTION_ANALYZER_REPORT                         *00002\n *                                                                     *00003\n *       THIS PROGRAM IS READS THE SAMPLER FILE GENERATED BY THE PLEA  *00003\n *       PROGRAM AND GENERATES THE PERFORMANCE REPORTS. THE ONLY PARM  *00003\n *       TO THIS PROGRAM IS TERM=Y WHICH FORMATS THE FILE TO BE EASIER *00003\n *       TO READ FROM A TERMINAL (SDSF).  TERM=N FORMATS FOR A         *00003\n *       HARDCOPY LISTING.                                             *00003\n *                                                                     *00008\n * NOTES:                                                              *00008\n *                                                                     *00008\n *    1. ISSUE HISTORY:                                                *00008\n *                                                                     *00009\n *       REASON FOR ISSUE 02:                                          *00009\n *       MODIFY HEADINGS TO READ EASIER FROM SDSF                      *00010\n *                                                                     *00011\n *       REASON FOR ISSUE 03:                                          *00011\n *       ADD EXTNAME FIELD                                             *00012\n *                                                                     *00013\n *       REASON FOR ISSUE 04:                                          *00013\n *       HANDLE CASE WHERE TRAILER RECORD IS MISSING.                  *00014\n *                                                                     *00015\n *       REASON FOR ISSUE 05:                                          *00015\n *       FIX TWO BUGS FOUND AND REPAIRED BY MIKE FERERO.  MISSING LAST *00016\n *       LINE IN BLOCK AND PROC REPORTS.                               *00016\n *                                                                     *00018\n **********************************************************************/00018\n\n PLEAREP:                                                               00019\n    PROCEDURE(MAINPARM) OPTIONS(MAIN) REORDER;                          00020\n    DECLARE  MAINPARM    VARYING CHAR(100);                             00021\n\n /**********************************************************************00022\n *                                                                     *00022\n * STRUCTURE CUR$LOC IS THE STANDARD TRACE RECORD OUTPUT BY THE        *00022\n * SAMPLER ROUTINE.                                                    *00022\n *                                                                     *00025\n * STRUCTURES LOC_HEADER AND LOC_TRAILER ARE OUTPUT BY THE SAMPLER     *00025\n * ROUTINE AT THE START AND END OF THE DATA.                           *00025\n *                                                                     *00027\n **********************************************************************/00027\n    DECLARE  1  CUR$LOC  BASED(C_PTR),                                  00028\n                2  STMT   CHAR(8)       INIT('        '),               00029\n                2  PROC   CHAR(31)      INIT('        '),               00030\n                2  EXT    CHAR(8)       INIT('        ');               00031\n    DECLARE  C_PTR        POINTER AUTO INIT(NULL());                    00032\n    DECLARE  1  LOC_HEADER   AUTO,                                      00033\n                2  STMT   CHAR(8)       INIT(' '),                      00034\n                2  HEADER CHAR(4)       INIT(' '),                      00035\n                2  LOAD   CHAR(8)       INIT(' '),                      00036\n                2  TYPE   CHAR(4)       INIT(' '),                      00037\n                2  INT    PIC'ZZZZZZ99' INIT(0),                        00038\n                2  SPARE  CHAR(15)        INIT(' ');                    00039\n    DECLARE  1  LOC_TRAILER  AUTO,                                      00040\n                2  STMT    CHAR(8)         INIT(' '),                   00041\n                2  HEADER  CHAR(4)         INIT(' '),                   00042\n                2  SP1     CHAR(2)         INIT(' '),                   00043\n                2  COUNT   PIC'ZZZZZZZ9'   INIT(0),                     00044\n                2  MINUTES PIC'ZZZZZZZ9'   INIT(0),                     00045\n                2  STMTS   PIC'ZZZZZZZZ9'  INIT(0),                     00046\n                2  SPARE  CHAR(8)         INIT(' ');                    00047\n                                                                        00048\n    DECLARE  1  LOC_SUMMARY  BASED(L_PTR),                              00049\n                2  STMT   CHAR(8)       INIT('        '),               00050\n                2  PROC   CHAR(31)      INIT('        '),               00051\n                2  EXT    CHAR(8)       INIT('        '),               00052\n                2  COUNT  PIC'ZZZZZZZ9' INIT(0);                        00053\n    DECLARE  L_PTR        POINTER AUTO INIT(NULL());                    00054\n    DECLARE  1  PROC_SUMMARY  BASED(P_PTR),                             00055\n                2  STMT   CHAR(8)       INIT('        '),               00056\n                2  PROC   CHAR(31)      INIT('        '),               00057\n                2  EXT    CHAR(8)       INIT('        '),               00058\n                2  COUNT  PIC'ZZZZZZZ9' INIT(0);                        00059\n    DECLARE  P_PTR        POINTER AUTO   INIT(NULL());                  00060\n    DECLARE  REPORT       FILE PRINT;                                   00061\n    DECLARE  PAGE#        PIC'ZZZ9' AUTO INIT(1);                       00062\n    DECLARE  SYSPRINT     FILE PRINT;                                   00063\n    DECLARE  TRACE$$      FILE RECORD INPUT  ENV(TOTAL,FB,RECSIZE(47)); 00064\n    DECLARE  WORKOUT      FILE RECORD OUTPUT ENV(TOTAL,FB,RECSIZE(55)); 00065\n    DECLARE  WORKOU2      FILE RECORD OUTPUT ENV(TOTAL,FB,RECSIZE(55)); 00066\n    DECLARE  WORKIN       FILE RECORD INPUT  ENV(TOTAL,FB,RECSIZE(55)); 00067\n    DECLARE  EOF_TRACE$$   BIT(1) ALIGNED STATIC INIT('0'B);            00068\n    DECLARE  EOF_WORKIN    BIT(1) ALIGNED STATIC INIT('0'B);            00069\n    DECLARE  TRACE_HEADER  CHAR(4) INIT('+++1');                        00070\n    DECLARE  TRACE_TRAILER CHAR(4) INIT('+++2');                        00071\n    DECLARE  TOTAL_INTERRUPTS FIXED BINARY(31) INIT(0);                 00072\n    DECLARE  STARS         CHAR(100) STATIC INIT((100)'*');             00073\n    DECLARE  STARS_80      CHAR(80)  STATIC INIT((80)'*');              00074\n    DECLARE  TERM_FORMAT   BIT(1) ALIGNED AUTO INIT('0'B);              00075\n    DECLARE  TRAILER_FOUND BIT(1) ALIGNED AUTO INIT('0'B);              00076\n                                                                        00077\n    TERM_FORMAT = INDEX(MAINPARM,'TERM=Y') > 0;                         00078\n    OPEN FILE(SYSPRINT) TITLE('PLEAPRNT') OUTPUT;                       00079\n    ON ENDFILE(TRACE$$) EOF_TRACE$$ = '1'B;                             00080\n    ON ENDFILE(WORKIN)  EOF_WORKIN  = '1'B;                             00081\n    OPEN FILE(REPORT)  STREAM OUTPUT;                                   00082\n    CALL INITIAL_SORT_AND_HEADERS();                                    00083\n    IF \u00acTRAILER_FOUND                                                   00084\n    THEN                                                                00085\n       DO;                                                              00086\n          PUT FILE(REPORT) SKIP(1)  EDIT(                               00087\n              'NO TRAILER RECORD FOUND, SAMPLING JOB PROBABLY ABENDED') 00088\n              (A);                                                      00089\n          PUT FILE(REPORT) SKIP(1)  EDIT(                               00090\n              'NUMBER OF INTERRUPTS IS:      ',                         00091\n              TOTAL_INTERRUPTS)                                         00092\n              (A,X(5),F(11));                                           00093\n       END;                                                             00094\n    CALL PRODUCE_PROC_REPORT();                                         00095\n    CALL PRODUCE_BLOCK_REPORT();                                        00096\n    CALL PLIRETC(0);                                                    00097\n    RETURN;                                                             00098\n                                                                        00099\n INITIAL_SORT_AND_HEADERS:                                              00100\n    PROCEDURE;                                                          00101\n    DECLARE  RC           FIXED BINARY(31) AUTO INIT(0);                00102\n    OPEN FILE(TRACE$$) INPUT;                                           00103\n    ON ENDPAGE(REPORT)                                                  00104\n    BEGIN;                                                              00105\n       IF PAGE# \u00ac= 1                                                    00106\n       THEN                                                             00107\n          PUT FILE(REPORT) PAGE EDIT(                                   00108\n          'BASIC STATISTICS',                                           00109\n          'PAGE ',PAGE#)(A,COL(65),A,A);                                00110\n       ELSE                                                             00111\n          DO;                                                           00112\n             PUT FILE(SYSPRINT) SKIP EDIT(                              00113\n                 'PLEAREP - PL/I EXECUTION ANALYZER REPORT',            00114\n                 'RELEASE 2.2 AS OF ',                                  00115\n                  LINKDTE.LINK_DATE)(A,X(1),A,A);                       00116\n             IF TERM_FORMAT                                             00117\n             THEN                                                       00118\n                PUT FILE(REPORT) SKIP EDIT(                             00119\n                    'BASIC STATISTICS')(A);                             00120\n             ELSE                                                       00121\n                PUT FILE(REPORT) SKIP EDIT(                             00122\n                    'BASIC STATISTICS',                                 00123\n                    'PAGE ',PAGE#)(A,COL(65),A,A);                      00124\n          END;                                                          00125\n       PUT FILE(REPORT) SKIP(2) LIST(' ');                              00126\n       PAGE# = PAGE# + 1;                                               00127\n    END;                                                                00128\n    OPEN FILE(WORKOUT) RECORD OUTPUT TITLE('WORK1'),                    00129\n         FILE(WORKOU2) RECORD OUTPUT TITLE('WORK2'),                    00130\n         FILE(TRACE$$) RECORD INPUT;                                    00131\n    EOF_TRACE$$ = '0'B;                                                 00132\n    SIGNAL ENDPAGE(REPORT);                                             00133\n    ALLOCATE LOC_SUMMARY;                                               00134\n    ALLOCATE PROC_SUMMARY;                                              00135\n    CALL PLISRTD(' SORT FIELDS=(40,8,CH,A,9,31,CH,A,1,8,CH,A) ',        00136\n                 ' RECORD TYPE=F,LENGTH=80 ',                           00137\n                 3000000,                                               00138\n                 RC,                                                    00139\n                 SORT_INPUT,                                            00140\n                 SORT_OUTPUT);                                          00141\n    FREE LOC_SUMMARY;                                                   00142\n    FREE PROC_SUMMARY;                                                  00143\n    CLOSE FILE(WORKOUT),                                                00144\n          FILE(WORKOU2),                                                00145\n          FILE(TRACE$$);                                                00146\n    RETURN;                                                             00147\n\n SORT_INPUT:                                                            00148\n    PROCEDURE RETURNS(CHAR(80));                                        00149\n    DECLARE  CARD            CHAR(80) BASED(C_PTR);                     00150\n    DECLARE  BLANKS          CHAR(80) STATIC INIT(' ');                 00151\n    DECLARE  FOXES           CHAR(80) STATIC INIT((80)'FF'X);           00152\n    DECLARE  FOXES_DONE      BIT(1) ALIGNED STATIC INIT('0'B);          00153\n    DECLARE  PROGRAM         CHAR(8)  STATIC INIT(' ');                 00154\n    DECLARE  01 HEADER_OVLY  LIKE LOC_HEADER   BASED(C_PTR);            00155\n    DECLARE  01 TRAILER_OVLY LIKE LOC_TRAILER  BASED(C_PTR);            00156\n    DECLARE  GOT_RECORD      BIT(1) ALIGNED AUTO INIT('0'B);            00157\n                                                                        00158\n    READ FILE(TRACE$$) SET(C_PTR);                                      00159\n    DO UNTIL(GOT_RECORD);                                               00160\n       /**************************************************************  00161\n       *                                                                00162\n       *   CHECK IF WE HAVE REACHED EOF ON THE INPUT FILE.  IF SO       00163\n       *   ADD ONE MORE RECORD OF ALL X'FF'.  IF THAT RECORD HAS        00164\n       *   ALREADY BEEN OUTPUT. TELL SORT THAT WE ARE DONE.             00165\n       *                                                                00166\n       **************************************************************/  00167\n       IF EOF_TRACE$$                                                   00168\n       THEN                                                             00169\n          DO;                                                           00170\n             IF FOXES_DONE                                              00171\n             THEN                                                       00172\n                DO;                                                     00173\n                   CALL PLIRETC(8);/* SHOW LAST RECORD ALREADY PASSED */00174\n                   C_PTR = ADDR(BLANKS);                                00175\n                   GOT_RECORD = '1'B;                                   00176\n                END;                                                    00177\n             ELSE                                                       00178\n                DO;                                                     00179\n                   CALL PLIRETC(12); /* SHOW PASSING RECORD */          00180\n                   C_PTR = ADDR(FOXES);                                 00181\n                   GOT_RECORD = '1'B;                                   00182\n                   FOXES_DONE = '1'B;                                   00183\n                END;                                                    00184\n          END;                                                          00185\n       ELSE                                                             00186\n          DO;                                                           00187\n             /********************************************************  00188\n             *                                                          00189\n             *   HANDLE THE RECORD JUST READ.                           00190\n             *   RIGHT ADJUST THE STATEMENT NUMBER SO IT SORTS          00191\n             *   CORRECTLY.                                             00192\n             *                                                          00193\n             ********************************************************/  00194\n             CUR$LOC.STMT = RIGHT_ADJUST(CUR$LOC.STMT,8);               00195\n             /********************************************************  00196\n             *                                                          00197\n             *   CHECK FOR THE HEADER RECORD.  IF IT IS FOUND           00198\n             *   SAVE THE DATA FROM IT AND ALSO OUTPUT THE DATA TO      00199\n             *   THE REPORT.  DO NOT PASS THIS RECORD TO SORT.          00200\n             *                                                          00201\n             ********************************************************/  00202\n             IF SUBSTR(CUR$LOC.PROC,1,4) = TRACE_HEADER                 00203\n             THEN                                                       00204\n                DO;                                                     00205\n                   LOC_HEADER = HEADER_OVLY;                            00206\n                   PROGRAM = HEADER_OVLY.LOAD;                          00207\n                   PUT FILE(REPORT) SKIP EDIT(                          00208\n                       'NAME OF LOAD MODULE IS:       ',                00209\n                        RIGHT_ADJUST(HEADER_OVLY.LOAD,8))(A,X(5),A);    00210\n                   PUT FILE(REPORT) SKIP EDIT(                          00211\n                       'INTERRUPT INTERVAL IS:       ',                 00212\n                       SUBSTR(HEADER_OVLY.INT,1,6),'.',                 00213\n                       SUBSTR(HEADER_OVLY.INT,7,2),                     00214\n                       ' SECONDS')                                      00215\n                       (A,X(5),A,A,A,A);                                00216\n                   IF HEADER_OVLY.TYPE = 'REAL'                         00217\n                   THEN                                                 00218\n                      PUT FILE(REPORT) SKIP                             00219\n                          LIST('INTERRUPTS BASED ON WALL TIME.');       00220\n                   ELSE                                                 00221\n                      PUT FILE(REPORT) SKIP                             00222\n                          LIST('INTERRUPTS BASED ON TASK CPU TIME.');   00223\n                END;                                                    00224\n             ELSE                                                       00225\n                /*****************************************************  00226\n                *                                                       00227\n                *   CHECK FOR THE TRAILER RECORD.  IF IT IS FOUND       00228\n                *   SAVE THE DATA FROM IT AND ALSO OUTPUT THE DATA TO   00229\n                *   THE REPORT.  DO NOT PASS THIS RECORD TO SORT.       00230\n                *                                                       00231\n                *****************************************************/  00232\n                IF SUBSTR(CUR$LOC.PROC,1,4) = TRACE_TRAILER             00233\n                THEN                                                    00234\n                   DO;                                                  00235\n                      LOC_TRAILER = TRAILER_OVLY;                       00236\n                      TRAILER_FOUND = '1'B;                             00237\n                      PUT FILE(REPORT) SKIP(1)  EDIT(                   00238\n                          'NUMBER OF INTERRUPTS IS:      ',             00239\n                          TRAILER_OVLY.COUNT)                           00240\n                          (A,X(5),A);                                   00241\n                      PUT FILE(REPORT) SKIP(1)  EDIT(                   00242\n                          'NUMBER OF PLI STATEMENTS IS: ',              00243\n                          TRAILER_OVLY.STMTS)                           00244\n                          (A,X(5),A);                                   00245\n                      PUT FILE(REPORT) SKIP(1) EDIT(                    00246\n                          'ELAPSED TIME FOR SAMPLING RUN:',             00247\n                          TRAILER_OVLY.MINUTES,' MINUTE(S)')            00248\n                          (A,X(5),A,A);                                 00249\n                      PUT FILE(REPORT) SKIP(1) LIST(' ');               00250\n                      GET STRING(TRAILER_OVLY.COUNT)                    00251\n                          LIST(TOTAL_INTERRUPTS);                       00252\n                   END;                                                 00253\n                ELSE                                                    00254\n                   GOT_RECORD = '1'B;                                   00255\n             /********************************************************  00256\n             *                                                          00257\n             *   ALL RECORDS GET TO HERE.  IF THIS WAS A HEADER OR      00258\n             *   TRAILER RECORD, WE WILL READ ANOTHER.  OTHERWISE       00259\n             *   WE WILL TELL SORT WE ARE PASSING A RECORD VIA          00260\n             *   PLIRETV.                                               00261\n             *                                                          00262\n             ********************************************************/  00263\n             IF CUR$LOC.PROC = '*'                                      00264\n             THEN                                                       00265\n                CUR$LOC.PROC = PROGRAM;                                 00266\n             IF (GOT_RECORD)                                            00267\n             THEN                                                       00268\n                CALL PLIRETC(12); /* SHOW PASSING RECORD */             00269\n             ELSE                                                       00270\n                READ FILE(TRACE$$) SET(C_PTR);                          00271\n          END; /* NOT EOF */                                            00272\n    END; /* END OF DO WHILE LOOP */                                     00273\n                                                                        00274\n    RETURN(CARD);                                                       00275\n END SORT_INPUT;                                                        00276\n                                                                        00277\n /**********************************************************************00278\n *                                                                     *00278\n * SEGMENT NAME:                                                       *00278\n *                                                                     *00278\n *    SORT_OUTPUT -- PROCESS SORTED TRACE RECORDS                      *00278\n *                                                                     *00299\n * INPUTS (*TO FUNCTIONS):                                             *00299\n *                                                                     *00279\n *    CARD -- SORTED TRACE RECORD (*1,3,4)                             *00279\n *       THE SORTED TRACE RECORDS, SORTED BY SORT AND CONSTRUCTED BY   *00280\n *       THE SORT INPUT ROUTINE ARE PASSED TO THIS ROUTINE ONE AT AT   *00280\n *       TIME.  THERE IS A TRAILER RECORD OF ALL X'FF' WHICH IS PASSED *00280\n *       IN BUT NOT OUTPUT.                                            *00280\n *                                                                     *00298\n * FUNCTIONS:                                                          *00298\n *                                                                     *00298\n *    1. OVERLAY THE TRACE RECORD WITH THE STRUCTURE OVERLAY           *00298\n *                                                                     *00300\n *    2. IF THERE IS NO TRAILER RECORD, COUNT THE TRAP RECORD.         *00300\n *                                                                     *00302\n *    3. IF THIS TRACE RECORD IS FOR THE SAME STATEMENT AS THE         *00302\n *       PREVIOUS ONE, BUMP THE TRAP COUNT IN THE STATEMENT SUMMARY.   *00302\n *       IF THIS IS FOR A DIFFERENT STATEMENT, OUTPUT THE OLD RECORD   *00302\n *       AND START A NEW ONE.                                          *00302\n *                                                                     *00308\n *    4. IF THIS TRACE RECORD IS FOR THE SAME PROCEDURE AS THE         *00308\n *       PREVIOUS ONE, BUMP THE TRAP COUNT IN THE PROCEDURE SUMMARY.   *00308\n *       IF THIS IS FOR A DIFFERENT PROCEDURE, OUTPUT THE OLD RECORD   *00308\n *       AND START A NEW ONE.                                          *00308\n *                                                                     *00301\n * OUTPUTS (*FROM FUNCTIONS):                                          *00301\n *                                                                     *00292\n *    TRAILER_FOUND -- GLOBAL FLAG (*2)                                *00292\n *       THE TRAILER FOUND FLAG IS SET BY THE SORT_INPUT ROUTINE WHEN  *00293\n *       THE TRAILER RECORD IS ENCOUNTERED.  WHEN THE RECORD IS NOT    *00293\n *       FOUND, WE WANT TO COUNT THE TOTAL NUMBER OF INTERUPTS         *00293\n *       OURSELVES.                                                    *00293\n *                                                                     *00288\n *    WORKOUT -- WORK FILE DD (DDNAME = WORK2) (*3)                    *00288\n *       INTO THIS WORK FILE IS PLACED THE STATMENT SUMMARY RECORDS.   *00289\n *       THESE RECORDS ARE GENERATED ONE PER STATEMENT WITH A COUNT OF *00289\n *       ALL THE TRAPS WHICH OCCURED IN THAT STATEMENT.                *00289\n *                                                                     *00284\n *    WORKOU2 -- WORK FILE DD (DDNAME = WORK1) (*4)                    *00284\n *       INTO THIS WORK FILE IS PLACED THE PROCEDURE SUMMARY RECORDS.  *00285\n *       THESE RECORDS ARE GENERATED ONE PER PROCEDURE WITH A COUNT OF *00285\n *       ALL THE TRAPS WHICH OCCURED IN THAT PROCEDURE.                *00285\n *                                                                     *00314\n **********************************************************************/00314\n\n SORT_OUTPUT:                                                           00315\n    PROCEDURE(CARD);                                                    00316\n    DECLARE  CARD    CHAR(80);                                          00317\n    DECLARE  LOC_STMT_COUNT   FIXED BINARY(31) STATIC INIT(0);          00318\n    DECLARE  PROC_STMT_COUNT  FIXED BINARY(31) STATIC INIT(0);          00319\n                                                                        00320\n    C_PTR = ADDR(CARD);                                                 00321\n    IF \u00acTRAILER_FOUND                                                   00322\n    THEN                                                                00323\n       TOTAL_INTERRUPTS = TOTAL_INTERRUPTS + 1;                         00324\n                                                                        00325\n    /**************************************************************     00326\n    *                                                                   00327\n    *   COLLECT DATA INTO THE STATEMENT SUMMARY RECORD.  WHEN           00328\n    *   THE STATEMENTS CHANGE, OUTPUT THE OLD RECORD AND START          00329\n    *   A NEW ONE.  DO NOT OUTPUT THE INITIAL BLANK RECORD.             00330\n    *                                                                   00331\n    **************************************************************/     00332\n    IF CUR$LOC.STMT  \u00ac= LOC_SUMMARY.STMT |                              00333\n       CUR$LOC.PROC  \u00ac= LOC_SUMMARY.PROC |                              00334\n       CUR$LOC.EXT   \u00ac= LOC_SUMMARY.EXT                                 00335\n    THEN                                                                00336\n       DO;                                                              00337\n          IF LOC_SUMMARY.PROC  \u00ac= ' '                                   00338\n          THEN                                                          00339\n             DO;                                                        00340\n                LOC_SUMMARY.COUNT = LOC_STMT_COUNT;                     00341\n                WRITE FILE(WORKOUT) FROM(LOC_SUMMARY);                  00342\n             END;                                                       00343\n          LOC_SUMMARY.STMT  = CUR$LOC.STMT;                             00344\n          LOC_SUMMARY.PROC  = CUR$LOC.PROC;                             00345\n          LOC_SUMMARY.EXT   = CUR$LOC.EXT;                              00346\n          LOC_STMT_COUNT = 1;                                           00347\n       END;                                                             00348\n    ELSE                                                                00349\n       LOC_STMT_COUNT = LOC_STMT_COUNT + 1;                             00350\n                                                                        00351\n    /**************************************************************     00352\n    *                                                                   00353\n    *   COLLECT DATA INTO THE PROCEDURE SUMMARY RECORD.  WHEN           00354\n    *   THE PROCEDURES CHANGE, OUTPUT THE OLD RECORD AND START          00355\n    *   A NEW ONE.  DO NOT OUTPUT THE INITIAL BLANK RECORD.             00356\n    *                                                                   00357\n    **************************************************************/     00358\n    IF CUR$LOC.PROC  \u00ac= PROC_SUMMARY.PROC  |                            00359\n       CUR$LOC.EXT   \u00ac= PROC_SUMMARY.EXT                                00360\n    THEN                                                                00361\n       DO;                                                              00362\n          IF PROC_SUMMARY.PROC \u00ac= ' '                                   00363\n          THEN                                                          00364\n             DO;                                                        00365\n                PROC_SUMMARY.COUNT = PROC_STMT_COUNT;                   00366\n                WRITE FILE(WORKOU2) FROM(PROC_SUMMARY);                 00367\n             END;                                                       00368\n          PROC_SUMMARY.STMT  = ' ';                                     00369\n          PROC_SUMMARY.PROC  = CUR$LOC.PROC;                            00370\n          PROC_SUMMARY.EXT   = CUR$LOC.EXT;                             00371\n          PROC_STMT_COUNT = 1;                                          00372\n       END;                                                             00373\n    ELSE                                                                00374\n       PROC_STMT_COUNT = PROC_STMT_COUNT + 1;                           00375\n\n END SORT_OUTPUT;                                                       00376\n END INITIAL_SORT_AND_HEADERS;                                          00377\n                                                                        00378\n PRODUCE_PROC_REPORT:                                                   00379\n    PROCEDURE;                                                          00380\n    DECLARE  RC           FIXED BINARY(31) AUTO;                        00381\n    DECLARE  LAST_PROC    CHAR(08) AUTO INIT(' ');                      00382\n    DECLARE  INT_COUNT    FIXED BINARY(31) AUTO INIT(0);                00383\n    DECLARE  PERCENT      FIXED BINARY(31) AUTO INIT(0);                00384\n    DECLARE  PERCENT_PIC  PIC'ZZZZZZ9.9'   AUTO;                        00385\n    DECLARE  FIRST_PAGE   BIT(1) AUTO ALIGNED INIT('1'B);               00386\n    DECLARE  PROC_WORK1   VARYING CHAR(31) AUTO;                        00387\n    DECLARE  PROC_WORK2           CHAR(31) AUTO;                        00388\n                                                                        00389\n    ON ENDPAGE(REPORT)                                                  00390\n    BEGIN;                                                              00391\n       IF TERM_FORMAT                                                   00392\n       THEN                                                             00393\n          DO;                                                           00394\n             IF FIRST_PAGE                                              00395\n             THEN                                                       00396\n                DO;                                                     00397\n                   PUT FILE(REPORT) PAGE LIST(STARS_80);                00398\n                   PUT FILE(REPORT) SKIP EDIT(                          00399\n                       'SUMMARY OF TIME SPENT IN EACH PROC FOR PGM ',   00400\n                       LOC_HEADER.LOAD)                                 00401\n                       (A);                                             00402\n                   PUT FILE(REPORT) SKIP LIST(' ');                     00403\n                   PUT FILE(REPORT) SKIP LIST(STARS_80);                00404\n                   PUT FILE(REPORT) SKIP EDIT(                          00405\n                      'PROC       TRAP COUNT  %TOTAL ',                 00406\n                      'TOTAL PERCENTAGE GRAPH,  * = 1%')(A,COL(50),A);  00407\n                   PUT FILE(REPORT) SKIP LIST(' ');                     00408\n                END;                                                    00409\n             FIRST_PAGE = '0'B;                                         00410\n          END;                                                          00411\n       ELSE                                                             00412\n          DO;                                                           00413\n             IF PAGE# \u00ac= 1                                              00414\n             THEN                                                       00415\n                PUT FILE(REPORT) PAGE EDIT(                             00416\n                'SUMMARY OF TIME SPENT IN EACH PROC FOR PGM ',          00417\n                 LOC_HEADER.LOAD,                                       00418\n                'PAGE ',PAGE#)(A,A,COL(65),A,A);                        00419\n             ELSE                                                       00420\n                PUT FILE(REPORT) SKIP EDIT(                             00421\n                'SUMMARY OF TIME SPENT IN EACH PROC FOR PGM ',          00422\n                 LOC_HEADER.LOAD,                                       00423\n                'PAGE ',PAGE#)(A,A,COL(65),A,A);                        00424\n             PUT FILE(REPORT) SKIP LIST(' ');                           00425\n             PUT FILE(REPORT) SKIP EDIT(                                00426\n                'PROC       TRAP COUNT  %TOTAL ',                       00427\n                'TOTAL PERCENTAGE GRAPH,  * = 1%')(A,COL(50),A);        00428\n             PUT FILE(REPORT) SKIP LIST(' ');                           00429\n          END;                                                          00430\n       PAGE# = PAGE# + 1;                                               00431\n    END; /* END OF ENDPAGE UNIT */                                      00432\n                                                                        00433\n    OPEN FILE(WORKIN) RECORD INPUT TITLE('WORK2');                      00434\n    EOF_WORKIN = '0'B;                                                  00435\n    READ FILE(WORKIN) SET(P_PTR);                                       00436\n                                                                        00437\n    SIGNAL ENDPAGE(REPORT);                                             00438\n                                                                        00439\n    DO WHILE(\u00acEOF_WORKIN);                                              00440\n       PERCENT = (1000 * PROC_SUMMARY.COUNT) / TOTAL_INTERRUPTS;        00441\n       PERCENT_PIC = PERCENT;                                           00442\n       PROC_WORK1 = TRIMX(PROC_SUMMARY.PROC);                           00443\n       PROC_WORK2 = PROC_WORK1 || '(' || TRIMX(PROC_SUMMARY.EXT) || ')';00444\n       PUT FILE(REPORT) SKIP EDIT(PROC_WORK2,                           00445\n                                  PROC_SUMMARY.COUNT,                   00446\n                                  PERCENT_PIC,                          00447\n                                  SUBSTR(STARS,1,((PERCENT+5)/10)))     00448\n                             (A,X(1),A,A,X(1),A);                       00449\n       READ FILE(WORKIN) SET(P_PTR);                                    00450\n    END;                                                                00451\n                                                                        00452\n    CLOSE FILE(WORKIN);                                                 00453\n    PUT FILE(REPORT) SKIP LIST(' ');                                    00454\n\n END PRODUCE_PROC_REPORT;                                               00455\n\n\n PRODUCE_BLOCK_REPORT:                                                  00456\n    PROCEDURE;                                                          00457\n    DECLARE  RC           FIXED BINARY(31) AUTO;                        00458\n    DECLARE  LAST_PROC    CHAR(31) AUTO INIT(' ');                      00459\n    DECLARE  LAST_EXT     CHAR(8)  AUTO INIT(' ');                      00460\n    DECLARE  INT_COUNT    FIXED BINARY(31) AUTO INIT(0);                00461\n    DECLARE  PERCENT      FIXED BINARY(31) AUTO INIT(0);                00462\n    DECLARE  PERCENT_PIC  PIC'ZZZZZZ9.9'   AUTO;                        00463\n    DECLARE  FIRST_PAGE   BIT(1) AUTO ALIGNED INIT('1'B);               00464\n                                                                        00465\n    ON ENDPAGE(REPORT)                                                  00466\n    BEGIN;                                                              00467\n       IF TERM_FORMAT                                                   00468\n       THEN                                                             00469\n          DO;                                                           00470\n             IF FIRST_PAGE                                              00471\n             THEN                                                       00472\n                DO;                                                     00473\n                   PUT FILE(REPORT) PAGE LIST(STARS_80);                00474\n                   PUT FILE(REPORT) SKIP EDIT(                          00475\n                       'TIME SPENT IN STATEMENTS, BY PROC FOR PGM ',    00476\n                       LOC_HEADER.LOAD)                                 00477\n                       (A);                                             00478\n                END;                                                    00479\n             PUT FILE(REPORT) SKIP LIST(' ');                           00480\n             PUT FILE(REPORT) SKIP LIST(STARS_80);                      00481\n             FIRST_PAGE = '0'B;                                         00482\n          END;                                                          00483\n       ELSE                                                             00484\n          DO;                                                           00485\n             IF PAGE# \u00ac= 1                                              00486\n             THEN                                                       00487\n                PUT FILE(REPORT) PAGE EDIT(                             00488\n                'TIME SPENT IN STATEMENTS, BY PROC FOR PGM ',           00489\n                LOC_HEADER.LOAD,                                        00490\n                'PAGE ',PAGE#)(A,A,A,COL(65),A,A);                      00491\n             ELSE                                                       00492\n                PUT FILE(REPORT) SKIP EDIT(                             00493\n                'TIME SPENT IN STATEMENTS, BY PROC FOR PGM ',           00494\n                LOC_HEADER.LOAD,                                        00495\n                'PAGE ',PAGE#)(A,A,A,COL(65),A,A);                      00496\n             PUT FILE(REPORT) SKIP LIST(' ');                           00497\n          END;                                                          00498\n       PUT FILE(REPORT) SKIP EDIT('PROC ',                              00499\n          TRIMX(LOC_SUMMARY.PROC),                                      00500\n          ' IN EXTERNAL PROC ',LOC_SUMMARY.EXT)(A);                     00501\n       PUT FILE(REPORT) SKIP LIST(' ');                                 00502\n       PUT FILE(REPORT) SKIP EDIT(                                      00503\n          'STATEMENT  TRAP COUNT  %TOTAL ',                             00504\n          'TOTAL PERCENTAGE GRAPH,  * = 1%')(A,COL(50),A);              00505\n       PUT FILE(REPORT) SKIP LIST(' ');                                 00506\n       PAGE# = PAGE# + 1;                                               00507\n    END; /* ENDPAGE UNIT */                                             00508\n                                                                        00509\n    OPEN FILE(WORKIN) RECORD INPUT TITLE('WORK1');                      00510\n    EOF_WORKIN = '0'B;                                                  00511\n    READ FILE(WORKIN) SET(L_PTR);                                       00512\n                                                                        00513\n    DO WHILE(\u00acEOF_WORKIN);                                              00514\n       IF LAST_PROC \u00ac= LOC_SUMMARY.PROC                                 00515\n       THEN                                                             00516\n          DO;                                                           00517\n             IF LAST_PROC \u00ac= ' '                                        00518\n             THEN                                                       00519\n                DO;                                                     00520\n                   PERCENT = (1000 * INT_COUNT) / TOTAL_INTERRUPTS;     00521\n                   PUT FILE(REPORT) SKIP LIST(' ');                     00522\n                   PUT FILE(REPORT) SKIP EDIT(                          00523\n                       'TOTAL INTERRUPTS THIS PROC: ',INT_COUNT)        00524\n                       (A,F(8));                                        00525\n                   PERCENT_PIC = PERCENT;                               00526\n                   PUT FILE(REPORT) SKIP EDIT(                          00527\n                       'THIS PROC CONSUMED ',PERCENT_PIC,               00528\n                       ' OF THE TOTAL CPU TIME')(A);                    00529\n                   PUT FILE(REPORT) SKIP LIST(' ');                     00530\n                END;                                                    00531\n             SIGNAL ENDPAGE(REPORT);                                    00532\n             INT_COUNT = 0;                                             00533\n             LAST_PROC = LOC_SUMMARY.PROC;                              00534\n             LAST_EXT  = LOC_SUMMARY.EXT;                               00535\n          END;                                                          00536\n                                                                        00537\n       PERCENT = (1000 * LOC_SUMMARY.COUNT) / TOTAL_INTERRUPTS;         00538\n       PERCENT_PIC = PERCENT;                                           00539\n       PUT FILE(REPORT) SKIP EDIT(LOC_SUMMARY.STMT,                     00540\n                                  LOC_SUMMARY.COUNT,                    00541\n                                  PERCENT_PIC,                          00542\n                                  SUBSTR(STARS,1,((PERCENT+5)/10)))     00543\n                             (A,X(4),A,A,COL(36),A);                    00544\n       INT_COUNT = INT_COUNT + LOC_SUMMARY.COUNT;                       00545\n       READ FILE(WORKIN) SET(L_PTR);                                    00546\n    END;                                                                00547\n    IF LAST_PROC \u00ac= ' '                                                 00548\n    THEN                                                                00549\n       DO;                                                              00550\n          PERCENT = (1000 * INT_COUNT) / TOTAL_INTERRUPTS;              00551\n          PUT FILE(REPORT) SKIP LIST(' ');                              00552\n          PUT FILE(REPORT) SKIP EDIT(                                   00553\n              'TOTAL INTERRUPTS THIS PROC: ',INT_COUNT)                 00554\n              (A,F(8));                                                 00555\n          PERCENT_PIC = PERCENT;                                        00556\n          PUT FILE(REPORT) SKIP EDIT(                                   00557\n              'THIS PROC CONSUMED ',PERCENT_PIC,                        00558\n              ' OF THE TOTAL CPU TIME')(A);                             00559\n          PUT FILE(REPORT) SKIP LIST(' ');                              00560\n       END;                                                             00561\n    CLOSE FILE(WORKIN);                                                 00562\n\n END PRODUCE_BLOCK_REPORT;                                              00563\n\n\n                                                                        00564\n /**********************************************************************00565\n *                                                                     *00565\n * SEGMENT NAME:                                                       *00565\n *                                                                     *00565\n *    RIGHT_ADJUST -- RIGHT ADJUST A STRING WITHIN A FIXED LENGTH      *00565\n *       FIELD.                                                        *00565\n *                                                                     *00578\n * INPUTS (*TO FUNCTIONS):                                             *00578\n *                                                                     *00566\n *    STRING -- INPUT STRING TO BE ADJUSTED (*1,2,3)                   *00566\n *       THE FIRST PARM TO THIS ROUTINE IS A STRING WHICH IS TO BE     *00567\n *       RIGHT ADJUSTED.                                               *00567\n *                                                                     *00569\n *    LEN -- LENGTH OF THE FIXED LENGTH FIELD (*2,3)                   *00569\n *       THE LENGTH OF THE FIELD INTO WHICH THE PASSED STRING IS TO BE *00570\n *       ADJUSTED IS THE SECOND PARM TO THIS STRING.                   *00570\n *                                                                     *00577\n * FUNCTIONS:                                                          *00577\n *                                                                     *00577\n *    1. TRIM LEADING AND TRAILING BLANKS OFF THE INPUT STRING         *00577\n *                                                                     *00579\n *    2. IF THE STRING IS LONGER THAN THE FIELD LENGTH, TRUNCATE IT TO *00579\n *       THIS LENGTH.                                                  *00579\n *                                                                     *00584\n *    3. PAD THE INPUT STRING ON THE LEFT WITH ENOUGH BLANKS TO MAKE   *00584\n *       IT THE LENGTH SPECIFIED IN THE LENGTH PARMATER.               *00584\n *                                                                     *00583\n * OUTPUTS (*FROM FUNCTIONS):                                          *00583\n *                                                                     *00572\n *    RET -- RETURNED STRING (*2,3)                                    *00572\n *       THE RETURNED VALUE OF THIS FUNCTION IS THE INPUT STRING       *00573\n *       PADDED ON THE LEFT WITH BLANKS TO THE LENGTH INIDICATED IN    *00573\n *       THE LENGTH PARM.                                              *00573\n *                                                                     *00589\n **********************************************************************/00589\n\n RIGHT_ADJUST:                                                          00590\n    PROCEDURE(STRING,LEN) RETURNS(VARYING CHAR(80));                    00591\n    DECLARE  STRING   CHAR(*);                                          00592\n    DECLARE  LEN      FIXED BINARY(15);                                 00593\n    DECLARE  WORK     VARYING CHAR(80) AUTO;                            00594\n    DECLARE  BLANKS   CHAR(80) INIT(' ');                               00595\n    DECLARE  I        FIXED BINARY(15) AUTO;                            00596\n    WORK = TRIMX((STRING));                                             00597\n    IF LENGTH(WORK) >= LEN                                              00598\n    THEN                                                                00599\n       WORK = SUBSTR(WORK,1,LEN);                                       00600\n    ELSE                                                                00601\n       WORK = SUBSTR(BLANKS,1,LEN-LENGTH(WORK)) || WORK;                00602\n    RETURN(WORK);                                                       00603\n END RIGHT_ADJUST;                                                      00604\n                                                                        00605\n\n /**********************************************************************00606\n *                                                                     *00606\n * SEGMENT NAME:                                                       *00606\n *                                                                     *00606\n *    TRIM -- SEGMENTS TRIM AND TRIMX                                  *00606\n *                                                                     *00611\n * INPUTS (*TO FUNCTIONS):                                             *00611\n *                                                                     *00607\n *    FIX_STR -- INPUT STRING (*1,2)                                   *00607\n *                                                                     *00609\n * FUNCTIONS:                                                          *00609\n *                                                                     *00609\n *    1. FUNCTION TRIM REMOVES TRAILING BLANKS ASSUMING THAT THE DATA  *00609\n *       IS LEFT JUSTIFIED AND CONTAINS NO IMBEDDED BLANKS.            *00609\n *                                                                     *00613\n *    2. FUNCTION TRIMX REMOVES LEADING AND TRAILING BLANKS.  IMBEDDED *00613\n *       BLANKS ARE ACCEPTABLE.                                        *00613\n *                                                                     *00612\n * OUTPUTS (*FROM FUNCTIONS):                                          *00612\n *                                                                     *00608\n *    OUT_STR -- RETURNED OUTPUT STRING (*1,2)                         *00608\n *                                                                     *00617\n **********************************************************************/00617\n\n TRIM:                                                                  00618\n    PROCEDURE(FIX_STR) RETURNS(VARYING CHAR(80));                       00619\n  DECLARE FIX_STR  CHAR(*);                                             00620\n  DECLARE I        FIXED BINARY(15) AUTO;                               00621\n  I = INDEX(FIX_STR,' ');                                               00622\n  IF I = 0                                                              00623\n  THEN                                                                  00624\n     RETURN(FIX_STR);                                                   00625\n  ELSE                                                                  00626\n     RETURN(SUBSTR(FIX_STR,1,I-1));                                     00627\n END TRIM;                                                              00628\n\n TRIMX:                                                                 00629\n  PROCEDURE(FIX_STR)  RETURNS(VARYING CHAR(256));                       00630\n  DECLARE FIX_STR           CHAR(*);                                    00631\n  DECLARE INSTR     VARYING CHAR(256) AUTO;                             00632\n  DECLARE I         FIXED BIN(15);                                      00633\n\n /**********************************************************************00634\n *                                                                     *00634\n * TRIM LEADING AND TRAILING BLANKS                                    *00634\n *                                                                     *00636\n **********************************************************************/00636\n   INSTR = FIX_STR;                                                     00637\n  I = VERIFY(INSTR,' ');                                                00638\n  IF  I = 0                                                             00639\n  THEN                                                                  00640\n     IF INDEX(INSTR,' ') = 0                                            00641\n     THEN                                                               00642\n        RETURN(INSTR);                                                  00643\n     ELSE                                                               00644\n        RETURN('');                                                     00645\n  RETURN(SUBSTR(INSTR,I,LENGTH(INSTR) - (I-1) -                         00646\n                (VERIFY(REVERSE(INSTR),' ')-1)) );                      00647\n\n END TRIMX;                                                             00648\n\n /**********************************************************************00001\n *                                                                     *00002\n *                      SUBSET FG500299.ASETDCLS                       *00002\n *                                                                     *00003\n * MASTER LIST COMMON DECLARATIONS                                     *00003\n *                                                                     *00004\n * EXTERNAL VARIABLE SYSENV IS SET TO THE VALUE 'FORE' FOR FORGROUND   *00004\n * OPERATION AND 'BACK' FOR BACKGROUND (BATCH JOB) OPERATION.  FOR     *00004\n * INTERACTIVE SPF DIALOGS, THE VALUE 'SPF' CAN BE USED TO CAUSE THE   *00004\n * ERROR ROUTINE TO FILL IN THE SPFMSGS ARRAY INSTEAD OF WRITING TO    *00004\n * FILE PRINT.                                                         *00004\n *                                                                     *00009\n * EXTERNAL VARIABLE LOGONID IS ALWAYS INITIALIZED BY THE INITIALIZE   *00009\n * ROUTINE TO THE CURRENT USERID.  IT IS USED IN OUT_ENT TO MARK THE   *00009\n * USER WHO LAST UPDATED ANY PARTICULAR RECORD.                        *00009\n *                                                                     *00013\n * QUIET IS SET TO TRUE WHEN INFORMATORY MESSAGES ARE TO BE            *00013\n * SUPPRESSED.                                                         *00013\n *                                                                     *00015\n **********************************************************************/00015\n                                                                        00016\n DEFAULT RANGE(*) ALIGNED FIXED BINARY STATIC,                          00017\n                  DESCRIPTORS ALIGNED;                                  00018\n                                                                        00019\n\n /**********************************************************************00001\n *                                                                     *00001\n *                       SUBSET FG500299.BUILTIN                       *00001\n *                                                                     *00002\n *                                                                     *00003\n *                       BUILTIN PL/I FUNCTIONS                        *00003\n *                                                                     *00003\n **********************************************************************/00003\n                                                                        00016\n DECLARE (ABS,                                                          00004\n          ADDR,                                                         00005\n          ALLOCATION,                                                   00006\n          ANY,                                                          00007\n          BIT,                                                          00008\n          BINARY,                                                       00009\n          CHAR,                                                         00010\n          COMPLETION,                                                   00011\n          DATE,                                                         00012\n          DATETIME,                                                     00013\n          DIM,                                                          00014\n          DECIMAL,                                                      00015\n          EMPTY,                                                        00016\n          FIXED,                                                        00017\n          HBOUND,                                                       00018\n          HIGH,                                                         00019\n          INDEX,                                                        00020\n          LBOUND,                                                       00021\n          LENGTH,                                                       00022\n          LINENO,                                                       00023\n          LOW,                                                          00024\n          MAX,                                                          00025\n          MIN,                                                          00026\n          MOD,                                                          00027\n          NULL,                                                         00028\n          ONCODE,                                                       00029\n          ONKEY,                                                        00030\n          PLIRETC,                                                      00031\n          PLIRETV,                                                      00032\n          PLISRTA,                                                      00033\n          PLISRTB,                                                      00034\n          PLISRTC,                                                      00035\n          PLISRTD,                                                      00036\n          REPEAT,                                                       00037\n          ROUND,                                                        00038\n          SAMEKEY,                                                      00039\n          STATUS,                                                       00040\n          STG,                                                          00041\n          STORAGE,                                                      00042\n          STRING,                                                       00043\n          SUBSTR,                                                       00044\n          TIME,                                                         00045\n          TRANSLATE,                                                    00046\n          TRUNC,                                                        00047\n          UNSPEC,                                                       00048\n          VERIFY)            BUILTIN;                                   00049\n                                                                        00021\n                                                                        00027\n /**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET LINKDTE                            *00002\n *                                                                     *00003\n * DECLARATION FOR THE LINK DATE INFORMATION BUILD BY THE LINKDATE     *00003\n * PROGRAM AND LINKED WITH THIS PROGRAM.                               *00003\n *                                                                     *00005\n * LINKDTE IS A SPECIAL VARIABLE SET UP BY THE LINKDATE PROGRAM WHICH  *00005\n * IS PART OF THE RELEASE PROCEDURE AND THE MDLKED CATALOGUED          *00005\n * PROCEDURE.  THE LINKDATE PROGRAM GENERATES AN EXTERNAL VARIABLE     *00005\n * NAMED LINKDTE WHICH CONTAINS THE CURRENT DATE IN MM/DD/YY FORMAT.   *00005\n * NOTE: THAT WHEN USING LINKDTE YOU MUST ALWAYS INCLUDE THE ENTRY     *00005\n * PLISTART CARD AS LINKDTE IS THE FIRST CSECT AND WOULD BECOME THE    *00005\n * DEFAULT ENTRY POINT.                                                *00005\n *                                                                     *00012\n **********************************************************************/00012\n                                                                        00027\n    DECLARE  01  LINKDTE  STATIC EXTERNAL ALIGNED,                      00013\n                 02    HEADER_JUNK    CHAR(8) INIT(' '),                00014\n                 02    LINK_DATE      VARYING CHAR(30) INIT('UNKNOWN'); 00015\n\n /**********************************************************************00001\n *                                                                     *00002\n *                           SUBSET REVERSE                            *00002\n * DECLARATION FOR FUNCTION REVERSE                                    *00003\n * THIS ROUTINE WILL RETURN THE STRING PASSED IN REVERSE ORDER, E.I.   *00004\n * WITH THE FIRST CHARACTER LAST, ETC.                                 *00004\n *                                                                     *00006\n * BACKWARD_STRING = REVERSE(STRING)                                   *00006\n *                                                                     *00007\n * SOURCE IS IN FG500242                                               *00007\n *                                                                     *00008\n **********************************************************************/00008\n\n    DECLARE REVERSE ENTRY(VARYING CHAR(*))                              00009\n                    RETURNS(VARYING CHAR(256)) EXTERNAL;                00010\n\n END PLEAREP;                                                           00652\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RENTR": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x103\\x01 \\x01 \\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T10:33:53", "lines": 288, "newlines": 288, "modlines": 0, "user": "QC22505"}, "text": "         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*REVERSE RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO PLISTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN PLISTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(PLISTART)\n         L     15,*-4         LOAD PLISTART ADDR\n         LTR   15,15          IS PLISTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         ST    0,76(,1)       STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         MVC   72(4,1),72(13) COPY ADDR OF WORKSPACE USED BY PLI LIB\n         LR    13,1           POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RETRN": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x19&\\x00J\\x00J\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T19:26:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "QC22505"}, "text": "         MACRO\n&NAME    RETRN &R,&FPR,&SAVE=,&BASE=,&SPIE=YES,&ID=YES,&RC=,&SAVEREG=\n         LCLC  &BASE1,&HOLD,&SPIE1\n.*\n.*       AUTHOR - GARY R. KOENIG\n.*\n.*       DATE - NOVEMBER 1, 1969\n.*\n.*       FUNCTION - THE RETRN MACRO IS USED IN ASSEMBLER ROUTINES TO\n.*         RETURN TO THE CALLING PROGRAM.  RETRN SHOULD BE USED ONLY\n.*         AND ALWAYS IF THE ENTER MACRO IS USED.\n.*\n.*       CODING - RETRN IS CODED INTO THE ASSEMBLER PROGRAM ACCORDING\n.*         TO THE RULES OF MACRO INSERTION.  ALL PARAMETERS SHOULD BE\n.*         CODED EXACTLY THE WAY THEY WERE FOR THE ENTER MACRO.  IN\n.*         ADDITION TWO MORE KEYWORD PARAMETERS CAN BE CODED FOR THE\n.*         RETRN MACRO.  THESE ARE AS FOLLOWS:\n.*         1)  &RC IS USED TO PASS A RETURN CODE THROUGH REGISTER 15.\n.*           IF RC=20 IS CODED, 20 WILL BE THE RETURN CODE PASSED IN\n.*           REGISTER 15.  IF REGISTER 15 ALREADY CONTAINS THE RETURN\n.*           CODE, CODE RC=(15).\n.*         2)  &SAVEREG IS USED TO INDICATE THE SUBPROGRAM IS A FUNC-\n.*           TION AND A VALUE IS BEING RETURNED IN REGISTER 0.  TO\n.*           INDICATE THIS, CODE &SAVEREG=0.\n&BASE1   SETC  '&BASE'\n&HOLD    SETC  '&R'.'2'\n&SPIE1   SETC  '&SPIE'\n         AIF   ('&BASE' NE '15' AND '&BASE' NE '1').C0\n&SPIE1   SETC  'NO'\n         AGO   .C2\n.C0      AIF   ('&BASE1' NE '2' AND '&SAVEREG' NE '2').C1\n&HOLD    SETC  '&R'.'3'\n         AGO   .C2\n.C1      AIF  ('&BASE' NE '14' AND '&BASE' NE '0' AND '&BASE' NE '').C3\n&BASE1   SETC  '13'\n.C2      AIF   ('&BASE1' NE '13' OR '&SAVE' EQ '').C3\n&BASE1   SETC  '12'\n.C3      AIF   ('&NAME' EQ '').C4\n&NAME    DS    0H\n.C4      AIF   ('&BASE1' EQ '15').C7\n         AIF   ('&SPIE1' EQ 'NO').C5\n         L     &R.1,0(&R.13)      RELOAD THE PREVIOUS PICA ADDRESS\n         SVC   14                 ISSUE SPIE SVC\n.C5      AIF   ('&ID' EQ 'NO' OR '&SAVE' EQ 'RENT').C6\n         MVI   0(&R.13),X'FF'     FLAG ROUTINE COMPLETE\n.C6      L     &R.13,4(&R.13)     LOAD ADDR OF PREVIOUS SAVE AREA\n         AIF   ('&SAVE' EQ 'RENT').C8\n.C7      AIF   ('&SAVEREG' EQ '0' OR '&SAVEREG' EQ '&R.0').C12\n         AGO   .D8\n.C8      AIF   ('&SAVEREG' EQ '0' OR '&SAVEREG' EQ '&R.0').C11\n         LA    &R.0,72            LOAD LENGTH\n         SVC   10                 ISSUE FREEMAIN SVC\n.D8      AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(&R.15)').C10\n         AIF   ('&RC' NE '').C9\n         LM    &R.14,&R.12,12(&R.13)   RESTORE REGISTERS\n         AGO   .END\n.C9      LA    &R.15,&RC          LOAD RETURN CODE\n.C10     L     &R.14,12(&R.13)    RESTORE\n         LM    &R.0,&R.12,20(&R.13) REGISTERS\n         AGO   .END\n.C11     LR    &HOLD,&R.0         SAVE REG 0\n         LA    &R.0,72            LOAD LENGTH\n         SVC   10                 ISSUE FREEMAIN SVC\n         LR    &R.0,&HOLD         RESTORE REG 0\n.C12     AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(&R.15)').C14\n         AIF   ('&RC' NE '').C13\n         LM    &R.14,&R.15,12(&R.13)   RESTORE\n         LM    &R.1,&R.12,24(&R.13)      REGISTERS\n         AGO   .END\n.C13     LA    &R.15,&RC          LOAD RETURN CODE\n.C14     L     &R.14,12(&R.13)    RESTORE\n         LM    &R.1,&R.12,24(&R.13) REGISTERS\n.END     BR    &R.14              RETURN CONTROL\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REVERSE": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x13$\\x00\\xe5\\x00\\xe5\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T13:24:18", "lines": 229, "newlines": 229, "modlines": 0, "user": "QC22505"}, "text": "REVERSE  TITLE 'PLI FUNCTION TO REVERSE A CHARACTER STRING'\n***********************************************************************\n*                                                                     *\n* SEGMENT NAME:                                                       *\n*                                                                     *\n*    REVERSE -- PLI FUNCTION TO REVERSE A CHARACTER STRING            *\n*                                                                     *\n* INPUTS (*TO FUNCTIONS):                                             *\n*                                                                     *\n*    SOURCE -- THE STRING TO BE REVERSED (*1,2,3)                     *\n*       THIS IS A PL/I VARYING LENGTH CHARACTER STRING WHOSE          *\n*       CHARACTERS ARE TO BE REVERSED.                                *\n*                                                                     *\n* FUNCTIONS:                                                          *\n*                                                                     *\n*    1. IF THE SOURCE STRING IS LONGER THAT THE MAXIMUM (DECLARED)    *\n*       LENGTH OF THE TARGET STRING, SET UP TO DO THE REVERSE ONLY ON *\n*       THE FIRST 'N' CHARACTERS IN THE SOURCE STRING, WHERE 'N' IS   *\n*       THE DECLARED LENGTH OF THE TARGET STRING.                     *\n*                                                                     *\n*    2. IF THE SOURCE STRING IS LONGER THAT 256 CHARACTERS, REVERSE   *\n*       THE LAST 256 CHARACTERS OF THE SOURCE INTO THE FIRST 256      *\n*       CHARACTERS OF THE TARGET.  REPEAT FOR THE NEXT 256 BYTES      *\n*       UNTIL THERE ARE 256 CHARACTER OR LESS TO PROCESS.             *\n*                                                                     *\n*    3. IF THERE ARE LESS THAT 256 CHARACTERS TO PROCESS, REVERSE THE *\n*       SOURCE TRING INTO THE TARGET STRING                           *\n*                                                                     *\n* OUTPUTS (*FROM FUNCTIONS):                                          *\n*                                                                     *\n*    TARGET -- THE STRING TO BE RETURNED (*2,3)                       *\n*       THIS IS A PL/I VARYING LENGTH CHARACTER STRING INTO WHICH IS  *\n*       PUT THE TARGET STRING WITH THE FIRST LETTER LAST AND THE LAST *\n*       LETTER FIRST.                                                 *\n*                                                                     *\n* NOTES:                                                              *\n*                                                                     *\n*    1. SAMPLE DECLARATION                                            *\n*                                                                     *\n*       DECLARE REVERSE ENTRY(VARYING CHARACTER(*)) RETURNS(VARYING   *\n*       CHARACTER(256)) EXTERNAL;                                     *\n*                                                                     *\n*       IF CHARACTER STRINGS LONGER THAN 256 NEED TO BE REVERSED,     *\n*       THEN THE RETURNS SPECIFICATION MAY BE INCREASED TO WHATEVER   *\n*       IS REQUIRED.                                                  *\n*                                                                     *\n*       SAMPLE CALL:                                                  *\n*       STRING_A = REVERSE(STRING_B);                                 *\n*                                                                     *\n*    2. THE REVERSE IS DONE USING AN ALGORITHM FROM GRIZWOLDS BOOK    *\n*       \"ALGORITHMS IN SNOBOL 4\".  EACH 256 BYTES OR LESS OF THE      *\n*       TARGET IS INITIALIZED WITH THE REQUIRED NUMBER OF CHARACTERS  *\n*       FROM THE REVERSE EBCIDIC STRING.  THIS NUMBER IS EQUAL TO THE *\n*       LENGTH OF THE SOURCE STRING AND IS TAKEN SO AS TO INCLUDE THE *\n*       LAST CHARACTER IN THE STRING.  E.I.  IF TEN CHARACTERS ARE    *\n*       REQUIRED, THE LAST TEN IN THE REVERSE EBCDIC STRING.  THE     *\n*       EBCIDIC STRING IS STRING OF HEX CHARACTERS STARTING WITH      *\n*       X'FF' AND GOING DOWN TO X'00'.  THE INITIALIZED TARGET IS     *\n*       THEN USED AS THE FIRST OPERAND OF A TRANSLATE INSTRUCTION AND *\n*       THE SOURCE STRING IS USED AS THE SECOND OPERAND.              *\n*                                                                     *\n*    3. ISSUE HISTORY:                                                *\n*                                                                     *\n*       ISSUE 02:                                                     *\n*       CHANGE THE INCLUDES TO INCLUDE PLRENTR AND PLREXIT.  THIS     *\n*       ROUTINE IS ONLY CALLED FROM PL/I AND THE NEW FORM OF THESE    *\n*       MACROS DOES NOT USE GETMAIN FREEMAIN.  PL/I'S STACK IS USED   *\n*       INSTEAD.                                                      *\n*                                                                     *\n*       REASON FOR ISSUE 02:  02/13/2004                              *\n*       ADD AMODE AND RMODE CARDS TO GET RID OF LINKER MESSAGES       *\n*                                                                     *\n***********************************************************************\n         SPACE\nREVERSE1 AMODE ANY\nREVERSE1 RMODE ANY\nREVERSE  RENTR  BASE=11,PARM=(10,PLIPARMS)\n         EJECT\n***********************************************************************\n*                                                                     *\n* GET THE CURRENT LENGTH OF THE SOURCE STRING AND THE MAXIMUM LENGTH  *\n* OF THE TARGET STRING.  USE THE MINIMUM AS THE LENGTH TO BE          *\n* PROCESSED.  IF THE TARGET IS TO SHORT, ONLY THE FIRST CHARACTERS IN *\n* THE SOURCE WILL BE USED.                                            *\n*                                                                     *\n*      REGISTER USAGE:                                                *\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                *\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          *\n*                     PROCESSED                                       *\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     *\n*              R10 -> PARM LIST FROM PL/I                             *\n*              R11 -  BASE FOR PROGRAM                                *\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  *\n*              R13 -> DYNAMIC SAVE AREA                               *\n*              R15 -  WORK REGISTER                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     R15,PLIFROM    POINT TO THE SOURCE PARM L/D\n         L     R15,0(R15)     POINT TO THE SOURCE STRING\n         LH    R9,0(R15)      GET SOURCE STIRNG CURRENT LENGTH\n         LA    R7,2(R15)      SAVE THE ADDR OF THE BEGINNING OF THE\n*                             SOURCE TEXT\n         SPACE\n         L     R15,PLITO      POINT TO THE TARGET PARM L/D\n         CH    R9,4(R15)      COMPARE THE SOURCE LENGTH TO THE\n*                             DECLARED LENGTH OF THE TARGET.\n         BNH   SOURCEOK       IF THE TARGET IS LONG ENOUGH, THE\n*                             SOURCE LENGTH IS THE ONE TO USE.\n         SPACE\n         LH    R9,4(R15)      IF THE TARGET IS TO SHORT, ONLY USE\n*                             THE FIRST TARGET_LENGTH CHARACTERS\n         SPACE\nSOURCEOK DS    0H\n         L     R8,0(R15)      POINT TO THE TARGET STRING\n         STH   R9,0(R8)       STORE THE LENGTH OF THE TARGET STRING\n*                             IN THE STRING'S 2 BYTE HEADER.\n         LA    R8,2(R9,R8)    POINT TO JUST PAST THE PORTION OF THE\n*                             TARGET STRING TO BE USED.\n         EJECT\n***********************************************************************\n*                                                                     *\n* CHECK IF THE AMOUNT OF SOURCE STRING LENF TO PROCESS IS LESS THAN   *\n* OR EQUAL TO 256 CHARACTERS.  IF SO, GO PROCESS THE REMAINING AMOUNT *\n* OF THE STRING.  IF THERE ARE MORE THAN 256 CHARACTERS TO BE         *\n* PROCESSED, PROCESS 256 OF THEM AND SEE HOW MUCH IS LEFT.            *\n*                                                                     *\n*      REGISTER USAGE:                                                *\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                *\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          *\n*                     PROCESSED                                       *\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     *\n*              R10 -> PARM LIST FROM PL/I                             *\n*              R11 -  BASE FOR PROGRAM                                *\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  *\n*              R13 -> DYNAMIC SAVE AREA                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nTESTLEN  DS    0H\n         CH    R9,=H'256'     IS THE STRING MORE THAN 256 CHARACTERS?\n         BNH   LASTREV        IF NOT, GO DO THE WHOLE STRING.\n         SPACE 5\nPROC256  DS    0H\n         SH    R8,=H'256'     MOVE BACK 256 CHARACTERS FROM THE END\n*                             OF THE STRING\n         MVC   0(256,R8),REVERSES    MOVE IN THE REVERSING STRING\n         TR    0(256,R8),0(R7)       AND REVERSE IN THE FIRST 256\n*                                    BYTES OF THE SOURCE INTO THE LAST\n*                                    256 BYTES OF THE TARGET.\n         SPACE\n         LA    R7,256(R7)            MOVE THE SOURCE POINTER\n         SH    R9,=H'256'            REDUCE THE LENGTH TO BE PROCESSED\n         B     TESTLEN               AND GO BACK FOR MORE\n         EJECT\n***********************************************************************\n*                                                                     *\n* FOR STRINGS LESS THAN 256 CHRACTERS THE LAST 'N' BYTES OF THE       *\n* REVERSING STRING ARE MOVED INTO THE TARGET.  'N' IS LENGTH OF THE   *\n* SOURCE STRING.  THE TRANSLATE IS THEN EXECUTED FOR THE LENGTH OF    *\n* THE SOURCE TO BE PROCESSED.                                         *\n*                                                                     *\n*      REGISTER USAGE:                                                *\n*              R7  -> NEXT SOURCE TEXT TO BE PROCESSED                *\n*              R8  -> JUST PAST THE NEXT TARGET SOURCE TO BE          *\n*                     PROCESSED                                       *\n*              R9  -  LENGTH OF THE SOURCE STRING LEFT TO PROCESS     *\n*              R10 -> PARM LIST FROM PL/I                             *\n*              R11 -  BASE FOR PROGRAM                                *\n*              R12 -> PLI TASK COMMUNICATIONS AREA  -  DO NOT MODIFY  *\n*              R13 -> DYNAMIC SAVE AREA                               *\n*                                                                     *\n***********************************************************************\n         SPACE\nLASTREV  DS    0H\n         SR    R8,R9          POINT TO FRONT OF TARGET STRING\n         LA    R15,REVERSES+256    POINT JUST PAST REVERSES\n         SR    R15,R9         BACK UP NEEDED NUMBER OF BYTES\n         SPACE\n         BCTR  R9,0           SUBTRACT 1 FROM LENGTH FOR EXEC INSTR\n         SPACE\n         EX    R9,MOVEREV     MOVE IN THE REVERSING STRING\n         EX    R9,TRANREV     REVERSE THE STRING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* GO BACK TO PL/I                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n         REXIT\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            CONSTANT DATA                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nMOVEREV  MVC   0(*-*,R8),0(R15)      MOVE REVERSING STRING\nTRANREV  TR    0(*-*,R8),0(R7)       REVERSE STRING\n         SPACE 2\nREVERSES DC    XL16'FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0'\n         DC    XL16'EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0'\n         DC    XL16'DFDEDDDCDBDAD9D8D7D6D5D4D3D2D1D0'\n         DC    XL16'CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0'\n         DC    XL16'BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0'\n         DC    XL16'AFAEADACABAAA9A8A7A6A5A4A3A2A1A0'\n         DC    XL16'9F9E9D9C9B9A99989796959493929190'\n         DC    XL16'8F8E8D8C8B8A89888786858483828180'\n         DC    XL16'7F7E7D7C7B7A79787776757473727170'\n         DC    XL16'6F6E6D6C6B6A69686766656463626160'\n         DC    XL16'5F5E5D5C5B5A59585756555453525150'\n         DC    XL16'4F4E4D4C4B4A49484746454443424140'\n         DC    XL16'3F3E3D3C3B3A39383736353433323130'\n         DC    XL16'2F2E2D2C2B2A29282726252423222120'\n         DC    XL16'1F1E1D1C1B1A19181716151413121110'\n         DC    XL16'0F0E0D0C0B0A09080706050403020100'\n         SPACE 5\n***********************************************************************\n*                                                                     *\n* PLI DSECT                                                           *\n*                                                                     *\n***********************************************************************\nPLIPARMS DSECT\nPLIFROM  DS    A            POINTS TO SOURCE PARM LOCATOR DESCRIPTOR\nPLITO    DS    A            POINTS TO TARGET PARM LOCATOR DESCRIPTOR\n         SPACE 3\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXIT": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x104\\x00\\xa5\\x00\\xa5\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T10:34:03", "lines": 165, "newlines": 165, "modlines": 0, "user": "QC22505"}, "text": "         MACRO ,\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI\n.*\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM\n.*    ENTERED WITH THE RENTR MACRO\n.*\n.*   PARMS:\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE\n.*\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.\n.*\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM\n.*\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING\n.*          ROUTINE.\n.*\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*\n.*\n.* SAMPLE:\n.*RET     REXIT RC=(15)\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         LCLC  &LCLENV,&IDX\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&IDX     SETC  '&SYSNDX'\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n.*\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE\n.*       THE ENV PARM TO THIS VALUE.\n.*\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK\n.*       UP ONE SAVE AREA.\n.*\n         AIF   ('&LSA' EQ 'NO').NOLEN\n.*\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE\n.*\n         AIF   ('&LABL' EQ '').NOLABL\n&LABL    DS    0H\n.NOLABL  ANOP\n         LA    1,0(0,13)           WORK AREA ADDRESS\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS\n.*\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.\n.*\n         AIF   ('&RETURN' EQ '').NORET\n         AIF   ('&RETURN'(1,1) NE '(').NORET\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM\n.NORET   ANOP\n.*\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR\n.*       DOING THE FREEMAIN\n.*\n         AIF   ('&LCLENV' EQ 'PLI').PLI1\n         L     14,16(0,13)         GET ORIG ENTRY POINT\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)\n.*\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.\n.*\n.PLI1    ANOP\n         AIF   ('&RC' EQ '').RCNREG\n         AIF   ('&RC'(1,1) NE '(').RCNREG\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE\n.RCNREG  ANOP  ,\n.*\n.*       DO FREEMAIN PROCESSING IF WE NEED TO\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO PLISTART IS\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES.\n.*\n         AIF   ('&LCLENV' EQ 'PLI').CKRC\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN PLISTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(PLISTART)\n         L     15,*-4         LOAD PLISTART ADDR\n         LTR   15,15          IS PLISTART LINKED IN?\n         BNZ   PL1&IDX\n.NOBOTH  ANOP\n         FREEMAIN R,LV=(0),A=(1)\n.CKRC    ANOP\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1\nPL1&IDX  DS    0H\n.NOBOTH1 ANOP\n.*\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.\n.*\n         LM    14,12,12(13)        RESTORE REGISTERS\n         AIF   ('&RC' EQ '').NORC\n         AIF   ('&RC'(1,1) EQ '(').NORC\n         AIF   ('&RC' EQ '0').ZERORC\n         LA    15,&RC              SET RETURN CODE\n         AGO   .NORC\n.ZERORC  SLR   15,15               ZERO RETURN CODE\n.NORC    AIF   ('&T' NE 'T').NOT\n         MVI   12(13),X'FF'        SET RETURN INDICATION\n.NOT     BR    14                  RETURN\n         MEXIT\n.*\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.\n.*\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB\n&LABL    DS    0H\n.NOLAB   ANOP  ,\n         AIF   ('&RC'(1,1) NE '(').CKRC\n         AIF   ('&RC' EQ '(15)').RC15\n         LR    15,&RC(1)           LOAD RETURN CODE\n.RC15    L     14,12(0,13)         RESTORE R14\n         LM    2,12,28(13)         RESTORE R2-R12\n         AGO   .NORC\n         MEND  , REXIT                                   RES 09/86\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAMPLER": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x10B\\x03\\xab\\x03\\xab\\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T10:42:09", "lines": 939, "newlines": 939, "modlines": 0, "user": "QC22505"}, "text": "SAMPLER  TITLE 'SAMPLER- STATEMENT SAMPLER FOR PL/I V2.1 W TEST HOOKS'\nMAXTASKS EQU   512\n***********************************************************************\n*                                                                     *\n*        PLEA SAMPLER ROUTINES                                        *\n*                                                                     *\n*        THIS MODULE CONTAINS THE THREE EXTERNAL ROUTINES AND         *\n*        ONE ROUTINE EXECUTED AS AN STIMER INTERRUPT EXIT.            *\n*        THESE MODULES ARE DESIGNED TO RUN AMODE=31,RMODE=24          *\n*        THIS MODULE IS NOT REENTRANT.                                *\n*                                                                     *\n*        ROUTINE SAMPLER:                                             *\n*                                                                     *\n*        THIS IS THE MAIN ROUTINE CALLED FROM PL/I TO INITIATE        *\n*        THE SAMPLING.  IT INITIALIZES THE DATA THE GETSAMP ROUTINE   *\n*        AND THE EXPIRED (STIMER EXIT) ROUTINE NEED.  IT SETS UP THE  *\n*        'SAMPLE' STRUCTURE FOR THE MAIN TASK IF THIS IS MULTITASKING.*\n*        NOTE THAT 'EQAW.SEQAMOD' MUST BE IN THE STEPLIB OR LINKLIST  *\n*        FOR THIS PROGRAM TO WORK.  OTHERWISE PLITEST WILL NOT SET    *\n*        UP THE SAMPLING ROUTINES.                                    *\n*                                                                     *\n*        PARMS TO THIS ROUTINE:                                       *\n*        PARM 1:  FIXED BINARY(31) INITIALIZED TO 0.  THIS PARM       *\n*                 IS INCREMENTED EACH TIME THE TIMER GOES OFF.        *\n*        PARM 2:  HEADER RECORD ADDRESS.  THIS IS THE ADDRESS OF THE  *\n*                 FIRST RECORD TO WRITE OUT TO THE TRACE FILE         *\n*        PARM 3:  FIXED BINARY(31) TIMER INTERVAL IN HUNDRETHS        *\n*                 OF A SECOND.  THAT IS, HOW OFTEN DO WE FIRE THE     *\n*                 TRAP.                                               *\n*        PARM 4:  CHAR(4) VARIABLE INDICATING TYPE OF TIMING TO       *\n*                 DO.  THIS HAS THE STRING 'REAL' OR 'CPU ' IN IT.    *\n*        PARM 5:  CHAR(8) VARIABLE CONTAINING THE PROGRAM TO CALL.    *\n*                 THIS PROGRAM IS LOADED AND CALLED.                  *\n*        PARM 6:  VARYING CHAR(*) VARIABLE CONTAINING THE PARM TO     *\n*                 PASS TO THE CALLED ROUTINE.                         *\n*        PARM 7:  FIXED BINARY(31) VARIABLE WHICH WILL CONTAIN THE    *\n*                 RETURN CODE OF THE CALLED PROGRAM.                  *\n*                                                                     *\n*                                                                     *\n*        ROUTINE GETSAMP                                              *\n*                                                                     *\n*        THIS ROUTINE IS REFERENCED BY THE MAIN PROCEDURE PLEA.       *\n*        IT IS REFERENCED THROUGH AN ENTRY VARIABLE.  THE ADDRESS     *\n*        OF THIS ROUTINE IS PUT IN A BUNCH OF PLITEST COMMANDS WHICH  *\n*        PUT THIS ROUTINE'S ADDRESS IN PLACE OF THE IBM TEST MODULE   *\n*        THE RESULT IS GETSAMP IS CALLED FROM THE STATEMENT HOOK.     *\n*        NOTE THAT THIS CODE HAS VERY NON-STANDARD LINKAGE.           *\n*        SEE THE COMMENTS BY THE ROUTINE FOR A DESCRIPTION OF WHAT    *\n*        IS GOING ON.                                                 *\n*                                                                     *\n*                                                                     *\n*        ROUTINE STOPSAM                                              *\n*                                                                     *\n*        THIS ROUTINE IS CALLED AFTER THE PROGRAM BEING TESTED        *\n*        RETURNS.  IT STOPS THE STIMER.                               *\n*                                                                     *\n*                                                                     *\n*        ROUTINE EXPIRED                                              *\n*                                                                     *\n*        THIS ROUTINE IS THE STIMER EXIT.  IT GETS CALLED WHEN THE    *\n*        STIMER POPS.  IT LOOKS AT THE DATA GATHERED IN GETSAMP AND   *\n*        WRITES IT OUT TO THE OUTPUT FILE.                            *\n*                                                                     *\n*  ISSUE HISTORY:                                                     *\n*                                                                     *\n*  REASON FOR ISSUE 02:                                               *\n*  ADD CODE TO SUPPORT MULTI TASKING                                  *\n*                                                                     *\n*  REASON FOR ISSUE 03:                                               *\n*  ADD CODE TO TRACK DOWN EXTERNAL PROCEDURE NAME.                    *\n*                                                                     *\n*  REASON FOR ISSUE 04:                                               *\n*  ADD CODE TO PREVENT OVERFLOW ON STMT COUNT AND SAMPLE COUNT.       *\n*                                                                     *\n*  REASON FOR ISSUE 05:                                               *\n*  UPDATE FOR USE WITH CEE, DON'T USE THE TUSR FIELD ANY MORE.        *\n*                                                                     *\n***********************************************************************\n         SPACE\nSAMPLER1 CSECT\n         DC    CL7'SAMPLER'\n         DC    X'07'\n         SPACE\n***********************************************************************\n*\n*              FIRST ENTRY --- LOAD UP THE OPRATIONAL PARMS PASSED\n*              BY PL/I INTO LOCAL VARIABLES. (NON-REENTRANT)\n*\n***********************************************************************\n         SPACE\n         ENTRY SAMPLER,STOPSAM,GETSAMP\nSAMPLER  DS    0D\n         USING SAMPLER,R15         R15-> TEMPORARY BASE.\n         STM   R14,R12,12(13)      STORE CALLERS REGISTERS.\n         LR    R14,R13             SAVE R13 INTO R14.\n         LA    R13,SAVEAREA        GET SAVEAREA ADDRESS.\n         ST    R13,8(R14)          STORE OUR SA ADDRESS INTO CALLERS.\n         ST    R14,4(R13)          STORE CALLERS SA ADDRESS INTO OURS.\n         L     R11,=A(SAMPLER1)    GET BASE ADDRESS.\n         DROP  R15\n         USING SAMPLER1,R11        R11-> PROGRAM BASE.\n         SPACE\n         LR    R10,R1              SAVE REGISTER WITH PARM LIST\n         USING PLIPARM,R10\n         SPACE\n         L     R1,PLICNT           GET ADDR OF COUNT VARIABLE\n         ST    R1,COUNT            SAVE ADDR OF COUNT TO WRITE ON\n         L     R1,PLISTMTS         GET ADDR OF SMTS VARIABLE\n         ST    R1,STMTS            SAVE ADDR OF STMTS TO WRITE ON\n         L     R1,PLITIME          POINT TO STIMER INTERVAL\n         L     R1,0(,R1)           LOAD TIMER VALUE\n         ST    R1,TIME             SAVE IN PLACE USED BY STIMER\n         SPACE\n***********************************************************************\n*\n*        CREATE AN INITIAL MAIN TASK SAMPLER AREA\n*        THIS IS A SPACE CAPABLE OF HOLDING MAXTASKS SUBTASKS.\n*        IF TCB'S ARE REUSED, THEN THE ENTRIES ARE REUSED.\n*        THIS IS WHERE STATEMENT DATA FOR EACH SUBTASK IS SAVED.\n*\n***********************************************************************\n         SPACE\n         LA    R2,SAMPLEN          POINT TO SAMPLER SIZE\n         MH    R2,=AL2(MAXTASKS)   GET SAMPLER WORK AREA\n         SPACE\n         GETMAIN R,LV=(R2),SP=22\n         XC    0(SAMPLEN,R1),0(R1) CLEAR NEW ENTRY\n         ST    R1,SAMPLIST         ADD TO THE LINKED LIST\n         LA    R15,0(R1,R2)        POINT TO END OF SAMPLER AREA\n         ST    R15,SAMPEND         SAVE END OF SAMPLER AREA\n         USING SAMPLE,R1\n         L     R15,16              POINT TO THE CVT\n         L     R15,0(,R15)         POINT TO THE TCB DOUBLEWORD\n         L     R15,0(,R15)         POINT TO THE CURRENT TCB\n         ST    R15,SAMPTCB         SAVE THE TCB ADDR\n         DROP  R1\n         SPACE\n***********************************************************************\n*\n*        OPEN THE TRACE FILE AND OUTPUT A HEADER RECORD\n*        THE HEADER RECORD IS PASSED IN AS A PARM.\n*        NOTE THAT SINCE WE ARE AMODE=ANY, RMODE=24, WE SWITCH MODES\n*        PRIOR TO DOING THE PUT AND THEN PUT THE AMODE BACK.\n*\n***********************************************************************\n         SPACE\n         OPEN  (TRACE$$,(OUTPUT))  OPEN THE TRACE FILE\n         TM    TRACE$$+(DCBOFLGS-IHADCB),DCBOFOPN  DID IT OPEN\n         BO    OPENOK\n         SPACE\n         WTO   'UNABLE TO OPEN DDNAME TRACE$$, WILL ABEND CODE=222',   X\n               ROUTCDE=11\n         ABEND 222\n         SPACE\nOPENOK   DS    0H\n         L     R3,PLIHDR           POINT TO HEADER REC LOC/DES\n         L     R3,0(,R3)           POINT TO HEADER RECORD\n         LA    R7,PUTHDR           ADDR BEFORE THE PUT\n         LA    R6,HDRDONE          ADDR AFTER THE PUT\n         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE\nPUTHDR   DS    0H\n         PUT   TRACE$$,(R3)        PUT RETURNS ADDR OF WHERE TO PUT REC\n         BSM   0,R6                PUT THE ADDRESSING MODE BACK\nHDRDONE  DS    0H\n         EJECT\n***********************************************************************\n*\n*        LOAD THE PL/I PROGRAM AND START IT.\n*        SAVE THE TIMING TYPE IN A FLAG.\n*        WHEN THE PROGRAM RETURNS, SAVE THE RETURN CODE AND CANCEL\n*        ANY REMAINING TIMERS.\n*\n***********************************************************************\n         SPACE\n         L     R1,PLILMOD          POINT TO THE LOADMODULE L/D\n         L     R1,0(,R1)           POINT TO THE LOADMOD NAME\n         MVC   LOADMOD(8),0(R1)    SAVE THE LOAD MODULE NAME\n         LOAD  EPLOC=LOADMOD       LOAD THE PROGRAM\n         ST    R0,LOADPT           SAVE THE ENTRY POINT\n         SPACE\n         L     R1,PLITYPE          POINT TO TYPE PARM LOC/DES\n         L     R1,0(R1)            POINT TO TYPE PARM\n         CLC   0(4,R1),=CL4'REAL'  ARE WE MEASURING REAL TIME?\n         BE    TIMEREAL            IF SO, ISSUE THE REAL TIME STIMER\n         SPACE\n         MVI   TIMETYPE,TYPETASK   FLAG TASK TYPE TIMEING\n         B     CALLPGM\n         SPACE\nTIMEREAL DS    0H\n         MVI   TIMETYPE,TYPEREAL   FLAG REAL TYPE TIMEING\n         SPACE\nCALLPGM  DS    0H\n         L     R1,PLILPRM          POINT TO THE LOADMOD PARM L/D\n         OI    0(R1),X'80'         TURN ON THE HIGH BIT\n         LA    R6,LMODDONE         ADDR AFTER THE CALL\n         BSM   R6,0                SAVE THE AMODE IN THE HIGH BIT\n         L     R15,LOADPT          LOAD THE TARGET ADDRESS\n         BASSM R14,R15             CALL THE PROGRAM\n         BSM   0,R6     -+ LOCKED  PUT THE ADDRESSING MODE BACK\nLMODDONE DS    0H       -+ TOGETHER\n         LR    R2,R15              SAVE THE RETURN CODE\n         TTIMER CANCEL,TU          CANCEL ANY MAIN TASK TIMERS\n         SPACE\n         L     R1,PLIRC            POINT TO THE RETURN CODE PARM\n         ST    R2,0(,R1)           SAVE IN THE PL/I PARM\n         SPACE\nRETURN   DS    0H\n         L     13,4(13)            RESTORE OLD R13.\n         LM    14,12,12(13)        RESTORE REGISTERS.\n         BR    14                  RETURN.\n         DROP  R10\n         SPACE 2\n         DROP  R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*    ROUTINE EXPIRED                                                  *\n*                                                                     *\n*              STIMER EXPIRATION EXIT; RECEIVES CONTROL WHEN STIMER   *\n*              INTERVAL EXPIRES. FOR CPU TIME SAMPLING                *\n*                                                                     *\n*    THIS ROUTINE IS REALLY AMODE=ANY.  THE STIMER FIRST ISSUED IN    *\n*    GETSAMP IS IN THE ADDRESSING MODE OF THE TEST PROGRAM.  THIS     *\n*    IS THE ADDRESSING MODE WE ARE ENTERED IN.                        *\n*                                                                     *\n***********************************************************************\n         SPACE\nEXPIRED  DS    0D\n         USING EXPIRED,R15\n         STM   R14,R12,12(R13)     SAVE REGISTER 14 THRU 13.\n         L     R11,=A(SAMPLER1)    GET ADDRESS OF BASE.\n         DROP  R15                 DROP TEMPORARY BASE.\n         USING SAMPLER1,R11        R11-> PROGRAM BASE.\n         SPACE\n***********************************************************************\n*\n*              INCREMENT COUNTER OF HITS\n*\n***********************************************************************\n         SPACE\n         L     R1,COUNT            PUT ADDR OF COUNT IN R1\n         L     R2,0(,R1)           PUT CONTENTS OF COUNT IN R2\n         C     R2,=X'7FFFFFFF'     COMPARE AGAINST MAXINT.\n         BE    EXITDONE            NO MORE SAMPLES THIS RUN\n         SPACE\n         A     R2,=F'1'            INCRMT COUNTER BY 1\n         ST    R2,0(,R1)           RETURN THE NOW UPDATED COUNT\n         SPACE\n***********************************************************************\n*\n*              FIND THE SAMPLER DATA AREA\n*\n***********************************************************************\n         SPACE\n         L     R4,16               POINT TO THE CVT\n         L     R4,0(,R4)           POINT TO THE TCB DOUBLE WORD\n         L     R4,0(,R4)           POINT TO THE CURRENT TCB\n***** DEBUG CODE START\n*        SLR   R0,R0               CLEAR COUNTER REG\n***** DEBUG CODE END\n         SPACE\n         L     R5,SAMPLIST         POINT TO FIRST SAMPLIST ENTRY\n         USING SAMPLE,R5\nSAMPLOOP DS    0H\n         LTR   R5,R5               END OF LIST?\n         BE    NOSAMP\n         SPACE\n***** DEBUG CODE START\n*        A     R0,=F'1'            COUNT SAMPLER ENTRIES\n***** DEBUG CODE END\n         C     R4,SAMPTCB          IS THIS THE ONE?\n         BE    GOTSAMP             IF SO, GREAT\n         SPACE\n         L     R5,SAMPNEXT         POINT TO THE NEXT ONE\n         B     SAMPLOOP            AND TRY AGAIN\n         SPACE\nNOSAMP   DS    0H\n         LR    R14,R13             COPY HSA ADDR\n         LA    R13,EXPSAVE         R13-> SAVEAREA.\n         ST    R14,4(,R13)         SAVE OUR SA ADDRESS INTO CALLERS.\n         ST    R13,8(,R14)         SAVE HSA  ADDRESS INTO LSA.\n         MVC   STMT(8),=C'        ' BLANK THE STATEMENT NUMBER\n         MVC   PROC(31),=CL31'?? NO SAMPLER DATA AREA'\n         B     PUTREC\n         SPACE\nGOTSAMP  DS    0H\n         LR    R14,R13             COPY HSA ADDR\n         LA    R13,SAMPSAVE        R13-> SAVEAREA.\n         ST    R14,4(,R13)         SAVE OUR SA ADDRESS INTO CALLERS.\n         ST    R13,8(,R14)         SAVE HSA  ADDRESS INTO LSA.\n         SPACE\n***********************************************************************\n*\n*              IF THERE IS VALID DATA IN THE POSITION DATA FIELD\n*              GET THE PROC NAME FROM THE AREA JUST BEFORE THE EP\n*\n***********************************************************************\n         SPACE\n***** DEBUG CODE START\n*        CVD   R0,DWORK            CONVERT NUMBER TO DECIMAL\n*        MVC   DWORK2(10),=X'40202020202020202021'\n*        ED    DWORK2(10),DWORK+3     MAKE PRINTABLE\n*        MVC   TCBADDR(8),DWORK2+2\n*        OI    TCBADDR+7,X'F0'        THE SIGN BIT TOO.\n*        L     R15,SAMPRET\n*        ST    R4,WORK1            SAVE THE TCB ADDR\n*        UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX\n*        TR    DWORK(8),HEXCHAR\n*        MVC   TCBADDR(8),DWORK   MOVE DATA TO THE RECORD\n*        L     R15,STMTS\n*        L     R15,0(,R15)         LOAD COUNT\n*        ST    R15,WORK1           SAVE THE OFFSET\n*        UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX\n*        TR    DWORK(8),HEXCHAR\n*        MVC   R12S(8),DWORK       MOVE DATA TO THE RECORD\n***** DEBUG CODE END\n         SPACE\n         LM    R6,R7,SAMPR15       GET THE ENTRY POINT\n         LA    R6,0(,R6)           MAKE SURE HIGH BIT IS OFF\n         LA    R7,0(,R7)           MAKE SURE THE HIGH BIT IS OFF\n         LTR   R6,R6               IS IT ZERO?\n         BNZ   GOTEP               IF SO, GO CONTINUE\n         SPACE\n         MVC   STMT(8),=C'        ' BLANK THE STATEMENT NUMBER\n         MVC   PROC(31),=CL31'!! INITIALIZATION' SHOW NO DATA YET\n         MVC   EXT(8),=C'        '\n         B     PUTREC\n         SPACE\nGOTEP    DS    0H\n         LR    R15,R6              GET A COPY OF THE RECORD\n         S     R15,=F'1'           BACK UP ONE BYTE\n         SLR   R14,R14             CLEAR A REGISTER FOR THE PROC LEN\n         IC    R14,0(R15)          GET THE LENGTH\n         C     R14,=F'31'          IS THE NAME TOO LONG?\n         BNH   GETNAME             IF NOT, FINE\n         SPACE\nUNKNOWN  DS    0H\n         MVC   PROC(31),=CL31'!! UNKNOWN PROCEDURE '\n         B     CHKEXT              SEE IF THE STATEMENT NUM TBL IS OK\n*        LA    R14,31              TRUNCATE TO 31 CHARS\n         SPACE\nGETNAME  DS    0H\n         MVC   PROC(31),=CL31' '   BLANK OUT THE TARGET FIELD\n         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME\n         BCTR  R14,0               SUB ONE FOR THE EXECUTE\n         EX    R14,TESTNAME        IS THIS A VALID NAME?\n         BNZ   UNKNOWN             IF NOT, USE THE UNKNOWN PROC NAME\n         EX    R14,MOVENAME        MOVE THE PROC NAME.\n         EJECT\n***********************************************************************\n*\n*        EXAMINE THE STATEMENT NUMBER TABLE TO GET THE STATEMENT\n*        NUMBER.  OTHERWISE SAVE THE OFFSET.\n*\n***********************************************************************\n         SPACE\nCHKEXT   DS    0H\n         L     R15,SAMPEXT         GET THE EXT ENTRY POINT\n         LA    R15,0(,R15)         MAKE SURE HIGH BIT IS OFF\n         LTR   R15,R15             IS IT ZERO?\n         BNZ   GOTEEP              IF SO, GO CONTINUE\n         SPACE\nNOEP     DS    0H\n         MVC   EXT(8),=CL8'!UNKNOWN' SHOW NO DATA\n         B     CHKSTMT\n         SPACE\nGOTEEP   DS    0H\n         MVC   EXT(8),=CL8' '      BLANK OUT THE TARGET FIELD\n         S     R15,=F'1'           BACK UP ONE BYTE\n         SLR   R14,R14             CLEAR A REGISTER FOR THE PROC LEN\n         IC    R14,0(R15)          GET THE LENGTH\n         C     R14,=F'31'          IS THE NAME TOO LONG?\n         BH    NOEP                IF SO, GO USE UNKOWN\n         C     R14,=F'8'           IS THE NAME TOO LONG?\n         BNH   GETEXT              IF NOT, FINE\n         SPACE\n         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME\n         MVC   EXT(4),0(R15)       MOVE FIRST 4\n         AR    R15,R14             GO BACK TO END\n         S     R15,=F'3'           BACK UP 3\n         MVC   EXT+4(3),0(R15)     LAST 3\n         B     CHKSTMT\n         SPACE\nGETEXT   DS    0H\n         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME\n         BCTR  R14,0               SUB ONE FOR THE EXECUTE\n         EX    R14,TESTNAME        IS THIS A VALID NAME?\n         BNZ   NOEP                IF NOT, USE THE UNKNOWN PROC NAME\n         EX    R14,MOVENAM2        MOVE THE PROC NAME.\n         EJECT\n***********************************************************************\n*\n*        EXAMINE THE STATEMENT NUMBER TABLE TO GET THE STATEMENT\n*        NUMBER.  OTHERWISE SAVE THE OFFSET.\n*\n***********************************************************************\n         SPACE\nCHKSTMT  DS    0H\n         L     R8,8(R6)            STATEMENT NUMBER TABLE ADDRESS\n         LTR   R8,R8               IS IT ZERO?\n         BNZ   FINDSTMT            IF NOT, GO FIND THE STATEMENT\n         SPACE\nHEXOFF   DS    0H\n         LR    R15,R6              COPY OF THE ENTRY POINT\n         LR    R14,R7              STATEMENT BEING EXECUTED\n         SR    R14,R15             OFFSET OF STATEMENT BEING EXECUTED\n         ST    R14,WORK1           SAVE THE OFFSET\n         UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX\n         TR    DWORK,HEXCHAR\n         MVC   STMT(8),DWORK       MOVE DATA TO THE RECORD\n         B     PUTREC\n         EJECT\n***********************************************************************\n*\n*        THE STATEMENT NUMBER TABLE IS DIVIDED INTO SEGMENTS.  THE\n*        HEADER IS OF A FIXED FORMAT AND IS 12 BYTES LONG.\n*\n*        0                         4 FIRST STMT TABLE BLOCK\n*        +-------------------------+\n*        | ENTRY POINT ADDR        | TO CALC OFFSET FOR THIS PROC\n*        +-------------------------+\n*        | MAX OFFSET IN THIS PROC | MAX OFFSET FOR THIS PROCEDURE\n*        +-------------------------+\n*        | ADDRESS OF 2ND BLK      | POINTER TO SECOND BLOCK\n*        +-------------------------+\n*\n*        THE TABLE ENTRIES ARE PAIRS OF HALFWORDS.  AN OFFSET AND\n*        A STATEMENT NUMBER.  THE HIGH BIT OF THE STATEMENT NUMBER\n*        MAY BE ON.\n*\n*        0                         4 2ND STMT TABLE BLOCK AND BEYOND\n*        +-------------------------+\n*        | ADDR OF NEXT BLOCK      |\n*        +-------------------------+\n*        | FIRST TABLE ENTRY       | MAX OFFSET FOR THIS PROCEDURE\n*        +-------------------------+\n*\n*        FOR THE SECOND TABLE, YOU MUST SUBTRACT X'7FFF' FROM THE\n*        OFFSET TO USE THE TABLE ENTRIES.\n*\n*\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* PROCEDURE FOR FINDING THE STATEMENT.  FIRST CALC THE OFFSET IN THE  *\n* PROC BY SUBTRACTING THE STATEMENT ADDRESS FROM THE FIRST WORD OF    *\n* THE STATEMENT NUMBER TABLE (THE ENTRY POINT OF THE PROCEDURE).  IF  *\n* THE OFFSET IS LESS THAN X'7FFF', THE STATEMENT IS IN THE FIRST      *\n* BLOCK OF THE TABLE.  THIS STARTS AT OFFSET 12 IN THE TABLE.         *\n* OTHERWISE SHIFT OUT THE LOW 15 BITS OF THE OFFSET TO GET THE NUMBER *\n* OF TABLE BLOCKS WE MUST STEP THROUGH TO GET TO THE ONE WE NEED.     *\n* FOR EACH BLOCK WE MUST REDUCE THE STATEMENT OFFSET BY X'7FFF'.      *\n* NOTE THAT STEPPING TO THE SECOND BLOCK USES OFFSET 8 IN THE FIRST   *\n* BLOCK.  STEPPING TO ANY LATER BLOCKS USES OFFSET 0 AS THE ADDRESS   *\n* OF THE NEXT BLOCK.  ALSO, THE SECOND BLOCK AND BEYOND HAS STATEMENT *\n* ENTRIES STARTING AT 4 INTO THE BLOCK INSTEAD OF 12.                 *\n*                                                                     *\n*      REGISTER USAGE:                                                *\n*              R6  -  REGISTER 15 OF PROGRAM (EP OF INTERRUPTED PL/I  *\n*                     ROUTINE)                                        *\n*              R7  -> STATEMENT IN CODE WHICH WAS EXECUTING WHEN      *\n*                     INTERRUPTED                                     *\n*              R8  -> STATEMENT NUMBER TABLE FOR THE ROUTINE          *\n*              R9  -> FIRST STMT NUMBER TBL ENTRY FOR CURRENT STMT    *\n*                     TBL BLOCK.                                      *\n*              R11 -  PROGRAM BASE FOR THIS ROUTINE                   *\n*              R12 -  ?                                               *\n*              R13 -> LOWER SAVE AREA                                 *\n*              R14 -  OFFSET OF STATEMENT WE ARE LOOKING FOR          *\n*              R15 -  CURRENT STATEMENT NUMBER TABLE ENTRY            *\n*                                                                     *\n***********************************************************************\n         SPACE\nFINDSTMT DS    0H\n         LR    R14,R7              COPY OF STATEMENT BEING EXECUTED\n         S     R14,0(R8)           GET THE OFFSET\n         C     R14,4(R8)           SANITY CHECK, ARE WE IN THE PROC?\n         BH    HEXOFF              IF NOT, FORGET IT, USE THE HEX.\n         SPACE\n         LA    R9,12(R8)           FIRST STMT ENTRY IN FIRST TABLE\n         C     R14,=X'00007FFF'    IS IT IN THIS BLOCK?\n         BNH   INBLOCK             YES, GO FIND IT\n         SPACE\n         L     R8,8(R8)            GO TO THE SECOND BLOCK\n         LA    R9,4(R8)            FIRST ENTRY IN SECOND BLOCK.\n         LR    R15,R14             GET A COPY OF THE OFFSET TO BUTCHER\n         S     R14,=X'00007FFF'    SUB OFF THE OFFSET FOR THE 2ND TBL\n         SRL   R15,15              GET RID OF THE LOW 15 BITS\n*                                  R15 HAS NUMBER OF TABLES TO STEP\n*                                  THROUGH.  NOTE WE DID 1 ALREADY.\n*                                  FIRST STEP IS SPECIAL CASE, NEXT\n*                                  BLK ADDR AT OFFSET 8, INSTEAD OF 0.\n         BCTR  R15,0               SUB 1 FOR THE LOAD WE DID\n         LTR   R15,R15             DO WE NEED MORE?\n         BZ    INBLOCK             IF NOT, GO PROCESS THE BLOCK\n         SPACE\nBLKLOOP  DS    0H\n         L     R8,0(R8)            GO TO THE NEXT BLOCK\n         S     R14,=X'00007FFF'    SUB OFF THE OFFSET FOR THE NEXT TBL\n         LA    R9,4(R8)            FIRST ENTRY IN THIS BLOCK\n         BCT   R15,BLKLOOP         LOOP TILL WE STEP RIGHT NUM TIMES.\n         SPACE\nINBLOCK  DS    0H\n         LR    R15,R9              POINT TO FIRST ENTRY IN BLOCK\n         SPACE\nWALKBLK  DS    0H\n         SLR   R0,R0               CLEAR R0\n         L     R1,0(R15)           LOAD AN ENTRY\n         N     R1,=X'7FFFFFFF'     CLEAR HIGH BIT\n         SLDL  R0,16               SPLIT THE HALFWORDS\n         SRL   R1,16               PUT R1 BACK WHERE IT BELONGS\n         CR    R14,R0              IS OFFSET HIGHER THAN TABLE OFFSET?\n         BNH   GOTSTMT             IF NOT, WE GOT IT\n         SPACE\n         LA    R15,4(R15)          BUMP TO THE NEXT ENTRY\n         B     WALKBLK             AND TRY AGAIN\n         SPACE\nGOTSTMT  DS    0H\n*        CVD   R1,DWORK            CONVERT NUMBER TO DECIMAL\n*        UNPK  STMT(8),DWORK+3(5)  MAKE PRINTABLE\n*        OI    STMT+7,X'F0'        THE SIGN BIT TOO.\n         CVD   R1,DWORK            CONVERT NUMBER TO DECIMAL\n         MVC   DWORK2(10),=X'40202020202020202021'\n         ED    DWORK2(10),DWORK+3     MAKE PRINTABLE\n         MVC   STMT(8),DWORK2+2\n         OI    STMT+7,X'F0'        THE SIGN BIT TOO.\n         EJECT\n***********************************************************************\n*\n*              WRITE OUT RECORD TO THE PL/I FILE\n*              THIS RECORD HAS HE CURRENT LOCATION INFORMATION\n*              THE FILE IS A PUT LOCATE FILE.\n*\n***********************************************************************\n         SPACE\nPUTREC   DS    0H\n         LA    R14,SAMPTCB         LOAD LOCKED VALUE\n         LA    R15,0               LOAD UNLOCKED VALUE\n         CS    R15,R14,DCBLOCK     PUT LOCK VALUE IN SEMAPHORE\n         BNZ   PUTREC              SPIN WAITING FOR DCB\n         SPACE\n         LA    R7,PUTSTRT          ADDR BEFORE THE PUT\n         LA    R6,PUTDONE          ADDR AFTER THE PUT\n         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE\nPUTSTRT  DS    0H\n         PUT   TRACE$$,CUR$LOC     PUT RETURNS ADDR OF WHERE TO PUT REC\n         BSM   0,R6                PUT THE ADDRESSING MODE BACK\nPUTDONE  DS    0H\n         XC    DCBLOCK(4),DCBLOCK  UNLOCK THE DCB\n         SPACE\n***********************************************************************\n*\n*              REISSUE STIMER AND RETURN TO PROGRAM BEING ANALYZED,\n*              VIA STIMER EXIT LINKAGE.\n*\n***********************************************************************\n         SPACE\n         CLI   TIMETYPE,TYPETASK   IS THIS TASK TIMEING\n         BE    RESETTSK            IF SO, RESET THE TASK TIMER\n         SPACE\n         STIMER REAL,EXPIRED,BINTVL=TIME   REISSUE TIME INTERVAL.\n         B     EXITDONE\n         SPACE\nRESETTSK DS    0H\n         STIMER TASK,EXPIRED,BINTVL=TIME   REISSUE TIME INTERVAL.\n         SPACE\nEXITDONE DS    0H\n         L     R13,4(,R13)         POINT TO HSA\n         LM    14,12,12(R13)       RESTORE REGISTERS.\n         BR    14                  RETURN.\n         SPACE 2\nMOVENAME MVC   PROC(*-*),0(R15)    MOVE PROC NAME TO OUTPUT RECORD\nMOVENAM2 MVC   EXT(*-*),0(R15)     MOVE EXT NAME TO OUTPUT RECORD\nTESTNAME TRT   0(*-*,R15),VALIDPRC  TEST PROCEDURE NAME\n         SPACE\n         DROP  R5,R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*    ROUTINE STOPSAM                                                  *\n*                                                                     *\n*    THIS ROUTINE IS CALLED FROM THE PLEA MAIN PROCEDURE DURING       *\n*    CLEANUP TO TURN OFF THE SAMPLER.  IT KILLS THE STIMER            *\n*                                                                     *\n***********************************************************************\n         DS    0D\n         DC    CL7'STOPSAM'\n         DC    X'07'\nSTOPSAM  DS    0D\n         USING *,R15               R15-> TEMPORARY BASE.\n         STM   R14,R12,12(13)      STORE CALLERS REGISTERS.\n         LR    R14,R13             SAVE R13 INTO R14.\n         LA    R13,SAVEAREA        GET SAVEAREA ADDRESS.\n         ST    R13,8(R14)          STORE OUR SA ADDRESS INTO CALLERS.\n         ST    R14,4(R13)          STORE CALLERS SA ADDRESS INTO OURS.\n         L     R11,=A(SAMPLER1)    GET BASE ADDRESS.\n         LR    R10,R1              SAVE PARM ADDRESS\n         DROP  R15\n         USING SAMPLER1,R11        R11-> PROGRAM BASE.\n         L     R10,0(R10)          POINT TO TRAILER REC L/D\n         L     R10,0(R10)          POINT TO TRAILER REC.\n         SPACE\n         LA    R7,PUTTRL           ADDR BEFORE THE PUT\n         LA    R6,TRLDONE          ADDR AFTER THE PUT\n         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE\nPUTTRL   DS    0H\n         PUT   TRACE$$,(R10)       PUT RETURNS ADDR OF WHERE TO PUT REC\n         BSM   0,R6                PUT THE ADDRESSING MODE BACK\nTRLDONE  DS    0H\n         DELETE EPLOC=LOADMOD\n         SPACE\n         CLOSE (TRACE$$)\n         SPACE\n         L     R13,4(R13)          RESTORE OLD R13.\n         LM    R14,R12,12(R13)     RESTORE REGISTERS.\n         BR    R14                 RETURN.\n         DROP  R11\n         EJECT\n***********************************************************************\n*                                                                     *\n*    ROUTINE GETSAMP                                                  *\n*                                                                     *\n*    ROUTINE TO COLLECT LOCATION DATA FROM THE PL/I ROUTINE.          *\n*    THIS ROUTINE IS ENTERED AS A PLITEST STATEMENT ENTRY.  IT IS     *\n*    REQUIRED THAT THE PROGRAM BEING TESTED WAS COMPILED WITH THE     *\n*    TEST(ALL) OR TEST(STMT) OPTION AS WELL AS GOSTMT.                *\n*                                                                     *\n*    THE FUNCTIONALITY OF THIS ROUTINE IS VERY SIMPLE.  IT SAVES      *\n*    THE ENTRY POINT OF THE ROUTINE AND THE ADDRESS IN THE PROGRAM    *\n*    WHICH CALLED THE ROUTINE.                                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* HOW PLITEST DOES ITS LINKAGE                                        *\n*                                                                     *\n* WHEN PL/I VERSION 2.1 OR LATER IS COMPILED WITH THE TEST OPTION     *\n* HOOKS ARE PUT IN TO IMPLEMENT THE PLITEST INTERFACE.  THESE HOOKS   *\n* ARE IN THE FORM OF 'EX'ECUTE ISNTRUCTIONS WHICH EXECUTE AN          *\n* INSTRUCTION AT AN OFFSET OFF REGISTER 12.  THESE OFFSETS START AT   *\n* +1A8.  THERE ARE 14 OF THESE FULLWORD INSTRUATIONS.  WHEN TEST IS   *\n* INACTIVE, EACH FULLWORD CONTAINS 0700C198.  0700 IS A NOOP .  C198  *\n* IS A BASE DISPLACEMENT OF 12 BYTES OF INSTRUCTIONS AND 4 BYTES OF   *\n* CODE.  WHEN PLITEST IS ACTIVE THE 0700 IS REPLACE BY 45C0 WHICH IS  *\n* A BAL USING R12 AS A RETURN ADDRESS.  THUS IF PLITEST IS ACTIVE,    *\n* THE NOOP BECOMES A BAL TO THE CODE AT 198 IN THE TCA.  THIS CODE    *\n* SAVES THE RETURN ADDRESS AT OFFSET DECIMAL 100 OFF REGISTER 13.     *\n* LOADS THE ADDRESS OF THE PLITEST MODULE IBM0DIM.IBM0DIM AND         *\n* BRANCHES TO IT.  THIS ROUTINE USES THE SAVE AREA OFF R13,           *\n* PRESERVES THE PSW CC WITH AN IPM INSTRUCTION AND FIXES UP R12.  IT  *\n* KNOWS TO SUBTRACT +1A4 FROM THE CURRENT R12 TO GET THE REAL R12.    *\n* THIS IS BECAUSE  WHEN IBM0DIM IS CALLED, IT IS WITH A BAL 12,12     *\n* WHICH LEAVES AN ADDRESS IN R12 WHICH IS JUST PAST THE BALR WHICH    *\n* WAS IN CODE BASED OFF R12.                                          *\n*                                                                     *\n* (NOTE:  CEE USES A DIFFERENT ROUTINE, BUT THE LINKAGE IS THE SAME)  *\n* IBM0DIM GETS ROLLING WITH THE FOLLOWING INSTRUCTIONS:               *\n*                                                                     *\n* STM     R14,R12,12(R13) NORMAL REGISTER SAVE                        *\n* IPM     R9              SAVE THE PROGRAM MASK IN R9                 *\n* BALR    R3,0            GET A BASE REGISTER                         *\n* * NORMAL SAVE AREA CROSS LINKAGE                                    *\n*                                                                     *\n* AFTER THE ROUTINE DOES ITS THING, IT NEEDS TO RESTORE THE           *\n* ENVIRONMENT EXACTLY AND RETURN TO THE CALLED PLACE.  THIS IS        *\n* TRICKY.  THE KEY SEQUENCE TO RETURNING IS:                          *\n*                                                                     *\n* LA      R5,6            GET A SIX                                   *\n* SR      R12,R5          BACK UP 6 BYTES BEFORE THE MAIN TCA BEGINNING\n* SPM     R9              WHERE R9 HAS THE SAVED CC (IPM INSTRUCTION) *\n* LM      R14,R11,12(R13) RELOAD EVERYTHING BUT R12                   *\n* BR      R12                                                         *\n*                                                                     *\n* AT 6 BYTES BEFORE THE TCA START EXIST THE INSTRUCTIONS:             *\n*                                                                     *\n* L       R12,100(R13)    GET ORIGINAL RETURN POINT                   *\n* BALR    R12,R12         GO TO IT AND SET R12 TO THE CORRECT VALUE   *\n*                                                                     *\n* THE CODE FROM +198 OFF R12 IS:                                      *\n*                                                                     *\n* ST      R12,100(R13)    SAVE RETURN POINT                           *\n* BALR    R12,0           GET A TEMP BASE                             *\n* L       R12,6(R12)              LOAD THE PLITEST ROUTINE ADDRESS    *\n* BALR    R12,R12         GO TO IBM0DIM.                              *\n* DC      A(IBM0DIM)                                                  *\n*                                                                     *\n* TO DO THE PLEA HOOKUP, WE WILL TURN ON STATEMENT HOOKS (OFFSET      *\n* +1AC OFF R12) AND PUT OUR OWN ROUTINE ADDRESS AT +1A4 OFF R12.      *\n* THIS ROUTINE SAVES THE RETURN ADDRESS FROM 100(R13) AND BACKS UP 1  *\n* SAVE AREA AND GETS THE EP ADDRESS FROM R15 IN THE PREVIOUS SAVE     *\n* AREA AND THE ADDRESS OF THE STATEMENT NUMBER TABLE WHICH IS LOCATED *\n* AT THE R15 EP PLUS 8 BYTES.                                         *\n*                                                                     *\n* WHEN THE SAMPLER GETS CONTROL, IT WILL LOOK UP THE STATEMENT USING  *\n* THE AVAILABLE INFORMATION AND WRITE OUT THE DATA.                   *\n*                                                                     *\n*    THIS ROUTINE IS REALLY AMODE=ANY.  IT IS ENTERED DIRECTLY FROM   *\n*    THE TEST PROGRAM.  THEREFORE IT IS IN THE ADDRESSING MODE OF     *\n*    THE TEST PROGRAM.                                                *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         DS    0D\n         DC    CL7'GETSAMP'\n         DC    X'07'\nGETSAMP  DS    0D\n         STM   R14,R11,12(13)      STORE CALLERS REGISTERS.\n*        L     R7,100(R13)         GET RETURN ADDRESS (NON-XA) PM\n         IPM   R7                  SAVE PROGRAM MASK (FOR XA)\n         BALR  R3,0                GET A BASE REGISTER\n         USING *,R3                AND USE IT\n         SPACE\n         LA    R12,0(R12)          MAKE SURE HIGH BIT IS CLEAR\n         SH    R12,R12FIX          FIX UP R12 TO ITS TRUE VALUE - 6\n         SPACE\n         L     R4,16               POINT TO THE CVT\n         L     R4,0(,R4)           POINT TO THE TCB DOUBLE WORD\n         L     R4,0(,R4)           POINT TO THE CURRENT TCB\n         SPACE\n***********************************************************************\n*                                                                     *\n*        FIND THE SAMPLE AREA FOR THIS TCB.  IF WE CANNOT FIND IT     *\n*        GO TO \"NEWONE\" TO CREATE A NEW ENTRY.                        *\n*                                                                     *\n***********************************************************************\n         SPACE\n         L     R5,SAMPLIST         POINT TO FIRST SAMPLIST ENTRY\n         USING SAMPLE,R5\nFINDSAMP DS    0H\n         C     R4,SAMPTCB          IS THIS THE ONE?\n         BE    GOTIT               IF SO, GREAT\n         SPACE\n         CLC   SAMPNEXT,=F'0'      LAST ONE IN LIST?\n         BE    NEWONE\n         SPACE\n         L     R5,SAMPNEXT\n         B     FINDSAMP            IF NOT, TRY AGAIN\n         SPACE\nGOTIT    DS    0H\n         L     R2,100(R13)         GET RETURN POINT\n         S     R2,=F'4'            BACK UP BEFORE THE EXECUTE INSTR\n         ST    R2,SAMPRET          SAVE THE RETURN POINT\n         L     R1,4(,R13)          BACK UP 1 SAVE AREA\n         L     R2,16(,R1)          LOAD OLD EP ADDRESS\n         C     R2,SAMPR15          SAME PROC AS LAST TIME?\n         BE    GOTEXT              THEN WE ARE SET,\n         SPACE\n         ST    R2,SAMPR15          SAVE THE PROC ENTRY POINT\n         SPACE\n         SLR   R0,R0               GET A ZERO\n         SPACE\nFINDEXT  DS    0H\n         C     R0,40(,R1)          IS REG 5 A ZERO IN SAVE AREA (EXT?)\n         BNE   NEXTSA              IF SO, SAVE IT\n         SPACE\n         L     R1,16(,R1)          GET THIS EP ADDRESS (R15 IN SA)\n         ST    R1,SAMPEXT          SAVE EXTERNAL PROC ADDR\n         B     GOTEXT              AND USE IT\n         SPACE\nNEXTSA   DS    0H\n         L     R1,4(,R1)           BACK UP 1 SAVE AREA\n         LTR   R1,R1               ZERO?\n         BNZ   FINDEXT             IF NOT, KEEP TRYING\n         SPACE\n         ST    R1,SAMPEXT          SAVE EXTERNAL PROC ADDR\n         SPACE\nGOTEXT   DS    0H\n         L     R1,STMTS            LOAD COUNT POINTER\n         L     R2,0(,R1)           LOAD COUNT\n         C     R2,=X'7FFFFFFF'     ARE WE AT MAXINT,\n         BE    NOBUMP\n         SPACE\n         A     R2,=F'1'            BUMP IT\n         ST    R2,0(,R1)           AND SAVE\n         SPACE\nNOBUMP   DS    0H\n         CLI   ACTIVE,X'FF'        IS THE TIMER ACTIVE?\n         BNE   STARTTME\n         SPACE\nSAMPDONE DS    0H\n         SPM   R7                  RESET THE PROGRAM MASK IN THE PSW\n         SPACE\n         LM    R14,R11,12(R13)      RESTORE REGISTERS.\n         BR    R12                 RETURN TO TCA PREFIX\n         SPACE\n*      NEW ENTRY, ADD TO TABLE\nNEWONE   DS    0H\n         LA    R1,SAMPLEN(,R5)     FREE SPACE STARTS JUST PAST LAST ENT\n         C     R1,SAMPEND          ARE WE AT THE END?\n         BNL   SAMPDONE            IF SO, NO SAMPLES\n         SPACE\n         XC    0(SAMPLEN,R1),0(R1) CLEAR NEW ENTRY\n         ST    R1,SAMPNEXT         ADD TO THE LINKED LIST\n         LR    R5,R1               NEW ENTRY IS THE CURRENT ONE\n         ST    R4,SAMPTCB          SAVE THE TCB ADDR\n         B     GOTIT\n         SPACE\nSTARTTME DS    0H\n         MVI   ACTIVE,X'FF'        MARK THE TIMER ACTIVE?\n         LR    R2,R13              COPY HSA ADDR\n         LA    R13,SAMPSAV2        R13-> SAVEAREA.\n         L     R6,=A(EXPIRED)\n         SPACE\n         CLI   TIMETYPE,TYPETASK   IS THIS TASK TIMING?\n         BE    INITTSK             IF SO, RESET THE TASK TIMER\n         SPACE\n         STIMER REAL,(R6),BINTVL=TIME   ISSUE TIME INTERVAL.\n         LR    R13,R2              RESTORE SAVE AREA ADDRESS\n         B     SAMPDONE\n         SPACE\nINITTSK  DS    0H\n         STIMER TASK,(R6),BINTVL=TIME   ISSUE TIME INTERVAL.\n         LR    R13,R2              RESTORE SAVE AREA ADDRESS\n         B     SAMPDONE\n         DROP  R3\n         EJECT\nR12FIX   DC    XL2'01AA'\nTIMETYPE DC    X'00'               TASK OR REAL TIMEING BEING DONE\nTYPETASK EQU   X'FF'               VALUE FOR TASK TIMING\nTYPEREAL EQU   X'00'               VALUE FOR REAL TIMING\nLOADMOD  DC    CL8' '\nLOADPT   DC    A(0)\nSAVEAREA DC    20F'0'\nEXPSAVE  DC    20F'0'\n*\n*\nTIME     DC    F'03'  (DEFAULT OF .03 MILLISEC SAMPLING INTERVAL)\n         DS    0F\nCOUNT    DS    A\nSTMTS    DS    A\nSAMPLIST DC    A(0)\nSAMPEND  DC    A(0)\n         EJECT\n**********************************************************************\n*     OUTPUT TRACE RECORD WRITTEN BY ROUTINE EXPIRED\n**********************************************************************\n         SPACE\n         SPACE 2\nDCBLOCK  DC    A(0)\n*RACE$$  DCB   DSORG=PS,MACRF=PM,RECFM=FB,BLKSIZE=9048,LRECL=39,\n*              DDNAME=TRACE$$\n         SPACE 2\nTRACE$$  DCB   DSORG=PS,MACRF=PM,RECFM=FB,BLKSIZE=9071,LRECL=47,       X\n               DDNAME=TRACE$$\n         SPACE 2\nHEXCHAR  DC    240X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         SPACE 2\n***********************************************************************\n*\n*        THIS TRT TABLE IS USED TO IDENTIFY CHARACTERS WHICH ARE VALID\n*        IN PL/I NAMES.  IT IS USED TO SCREEN THE PROCEDURE NAMES\n*        FOUND JUST BEFORE THE ENTRY POINTS.\n*\n***********************************************************************\n         SPACE\n*                    0 1 2 3 4 5 6 7 8 9 A B C D E F\nVALIDPRC DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    0\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    1\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    2\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    3\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    4\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF'    5\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFF00FFFF'    6\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF'    7\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    8\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    9\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    A\n         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    B\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'    C\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'    D\n         DC    XL16'FF000000000000000000FFFFFFFFFFFF'    E\n         DC    XL16'00000000000000000000FFFFFFFFFFFF'    F\n         SPACE\n         LTORG\n         SPACE 2\nPLIPARM  DSECT\nPLICNT   DS    A\nPLISTMTS DS    A\nPLIHDR   DS    A\nPLITIME  DS    A\nPLITYPE  DS    A\nPLILMOD  DS    A\nPLILPRM  DS    A\nPLIRC    DS    A\n         SPACE\nSAMPLE   DSECT\nSAMPNEXT DS    A   <-  MUST BE FIRST\nSAMPTCB  DS    A\nSAMPR15  DS    A\nSAMPRET  DS    A\nSAMPEXT  DS    A\nDWORK    DS    D,F\nWORK1    DS    F\nDWORK2   DS    D,F\nCUR$LOC  DS    0D\nSTMT     DS    CL8' '\nPROC     DS    CL31' '\nEXT      DS    CL8' '\nACTIVE   DS    X\nSAMPSAVE DS    18A\nSAMPSAV2 DS    18A\nSAMPLEN  EQU   *-SAMPLE\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n         PRINT NOGEN\n         DCBD  DSORG=PS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYMBAR": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x04\\x16\\x7f\\x01\\x04\\x16\\x7f\\x104\\x00 \\x00 \\x00\\x00\\xd8\\xc3\\xf2\\xf2\\xf5\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-15T00:00:00", "modifydate": "2004-06-15T10:34:15", "lines": 32, "newlines": 32, "modlines": 0, "user": "QC22505"}, "text": "         MACRO\n         SYMBAR &MODE=HEX\nR0       EQU   0  PARAMETER PASSING REG./UTILITY\nR1       EQU   1  PARAMETER PASSING REG./UTILITY\nR2       EQU   2  UTILITY\nR3       EQU   3  UTILITY\nR4       EQU   4  UTILITY\nR5       EQU   5  UTILITY\nR6       EQU   6  UTILITY\nR7       EQU   7  UTILITY\nR8       EQU   8 UTILITY\nR9       EQU   9  UTILITY\n         AIF   (K'&MODE NE 3).MHEX\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''\n.HEX     ANOP\nRA       EQU   10 UTILITY\nRB       EQU   11 UTILITY\nRC       EQU   12 UTILITY\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS\n         AGO   .END\n.DEC     ANOP\nR10      EQU   10 UTILITY\nR11      EQU   11 UTILITY\nR12      EQU   12 UTILITY\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT681/FILE681.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT681", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}