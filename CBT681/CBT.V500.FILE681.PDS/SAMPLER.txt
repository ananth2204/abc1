SAMPLER  TITLE 'SAMPLER- STATEMENT SAMPLER FOR PL/I V2.1 W TEST HOOKS'
MAXTASKS EQU   512
***********************************************************************
*                                                                     *
*        PLEA SAMPLER ROUTINES                                        *
*                                                                     *
*        THIS MODULE CONTAINS THE THREE EXTERNAL ROUTINES AND         *
*        ONE ROUTINE EXECUTED AS AN STIMER INTERRUPT EXIT.            *
*        THESE MODULES ARE DESIGNED TO RUN AMODE=31,RMODE=24          *
*        THIS MODULE IS NOT REENTRANT.                                *
*                                                                     *
*        ROUTINE SAMPLER:                                             *
*                                                                     *
*        THIS IS THE MAIN ROUTINE CALLED FROM PL/I TO INITIATE        *
*        THE SAMPLING.  IT INITIALIZES THE DATA THE GETSAMP ROUTINE   *
*        AND THE EXPIRED (STIMER EXIT) ROUTINE NEED.  IT SETS UP THE  *
*        'SAMPLE' STRUCTURE FOR THE MAIN TASK IF THIS IS MULTITASKING.*
*        NOTE THAT 'EQAW.SEQAMOD' MUST BE IN THE STEPLIB OR LINKLIST  *
*        FOR THIS PROGRAM TO WORK.  OTHERWISE PLITEST WILL NOT SET    *
*        UP THE SAMPLING ROUTINES.                                    *
*                                                                     *
*        PARMS TO THIS ROUTINE:                                       *
*        PARM 1:  FIXED BINARY(31) INITIALIZED TO 0.  THIS PARM       *
*                 IS INCREMENTED EACH TIME THE TIMER GOES OFF.        *
*        PARM 2:  HEADER RECORD ADDRESS.  THIS IS THE ADDRESS OF THE  *
*                 FIRST RECORD TO WRITE OUT TO THE TRACE FILE         *
*        PARM 3:  FIXED BINARY(31) TIMER INTERVAL IN HUNDRETHS        *
*                 OF A SECOND.  THAT IS, HOW OFTEN DO WE FIRE THE     *
*                 TRAP.                                               *
*        PARM 4:  CHAR(4) VARIABLE INDICATING TYPE OF TIMING TO       *
*                 DO.  THIS HAS THE STRING 'REAL' OR 'CPU ' IN IT.    *
*        PARM 5:  CHAR(8) VARIABLE CONTAINING THE PROGRAM TO CALL.    *
*                 THIS PROGRAM IS LOADED AND CALLED.                  *
*        PARM 6:  VARYING CHAR(*) VARIABLE CONTAINING THE PARM TO     *
*                 PASS TO THE CALLED ROUTINE.                         *
*        PARM 7:  FIXED BINARY(31) VARIABLE WHICH WILL CONTAIN THE    *
*                 RETURN CODE OF THE CALLED PROGRAM.                  *
*                                                                     *
*                                                                     *
*        ROUTINE GETSAMP                                              *
*                                                                     *
*        THIS ROUTINE IS REFERENCED BY THE MAIN PROCEDURE PLEA.       *
*        IT IS REFERENCED THROUGH AN ENTRY VARIABLE.  THE ADDRESS     *
*        OF THIS ROUTINE IS PUT IN A BUNCH OF PLITEST COMMANDS WHICH  *
*        PUT THIS ROUTINE'S ADDRESS IN PLACE OF THE IBM TEST MODULE   *
*        THE RESULT IS GETSAMP IS CALLED FROM THE STATEMENT HOOK.     *
*        NOTE THAT THIS CODE HAS VERY NON-STANDARD LINKAGE.           *
*        SEE THE COMMENTS BY THE ROUTINE FOR A DESCRIPTION OF WHAT    *
*        IS GOING ON.                                                 *
*                                                                     *
*                                                                     *
*        ROUTINE STOPSAM                                              *
*                                                                     *
*        THIS ROUTINE IS CALLED AFTER THE PROGRAM BEING TESTED        *
*        RETURNS.  IT STOPS THE STIMER.                               *
*                                                                     *
*                                                                     *
*        ROUTINE EXPIRED                                              *
*                                                                     *
*        THIS ROUTINE IS THE STIMER EXIT.  IT GETS CALLED WHEN THE    *
*        STIMER POPS.  IT LOOKS AT THE DATA GATHERED IN GETSAMP AND   *
*        WRITES IT OUT TO THE OUTPUT FILE.                            *
*                                                                     *
*  ISSUE HISTORY:                                                     *
*                                                                     *
*  REASON FOR ISSUE 02:                                               *
*  ADD CODE TO SUPPORT MULTI TASKING                                  *
*                                                                     *
*  REASON FOR ISSUE 03:                                               *
*  ADD CODE TO TRACK DOWN EXTERNAL PROCEDURE NAME.                    *
*                                                                     *
*  REASON FOR ISSUE 04:                                               *
*  ADD CODE TO PREVENT OVERFLOW ON STMT COUNT AND SAMPLE COUNT.       *
*                                                                     *
*  REASON FOR ISSUE 05:                                               *
*  UPDATE FOR USE WITH CEE, DON'T USE THE TUSR FIELD ANY MORE.        *
*                                                                     *
***********************************************************************
         SPACE
SAMPLER1 CSECT
         DC    CL7'SAMPLER'
         DC    X'07'
         SPACE
***********************************************************************
*
*              FIRST ENTRY --- LOAD UP THE OPRATIONAL PARMS PASSED
*              BY PL/I INTO LOCAL VARIABLES. (NON-REENTRANT)
*
***********************************************************************
         SPACE
         ENTRY SAMPLER,STOPSAM,GETSAMP
SAMPLER  DS    0D
         USING SAMPLER,R15         R15-> TEMPORARY BASE.
         STM   R14,R12,12(13)      STORE CALLERS REGISTERS.
         LR    R14,R13             SAVE R13 INTO R14.
         LA    R13,SAVEAREA        GET SAVEAREA ADDRESS.
         ST    R13,8(R14)          STORE OUR SA ADDRESS INTO CALLERS.
         ST    R14,4(R13)          STORE CALLERS SA ADDRESS INTO OURS.
         L     R11,=A(SAMPLER1)    GET BASE ADDRESS.
         DROP  R15
         USING SAMPLER1,R11        R11-> PROGRAM BASE.
         SPACE
         LR    R10,R1              SAVE REGISTER WITH PARM LIST
         USING PLIPARM,R10
         SPACE
         L     R1,PLICNT           GET ADDR OF COUNT VARIABLE
         ST    R1,COUNT            SAVE ADDR OF COUNT TO WRITE ON
         L     R1,PLISTMTS         GET ADDR OF SMTS VARIABLE
         ST    R1,STMTS            SAVE ADDR OF STMTS TO WRITE ON
         L     R1,PLITIME          POINT TO STIMER INTERVAL
         L     R1,0(,R1)           LOAD TIMER VALUE
         ST    R1,TIME             SAVE IN PLACE USED BY STIMER
         SPACE
***********************************************************************
*
*        CREATE AN INITIAL MAIN TASK SAMPLER AREA
*        THIS IS A SPACE CAPABLE OF HOLDING MAXTASKS SUBTASKS.
*        IF TCB'S ARE REUSED, THEN THE ENTRIES ARE REUSED.
*        THIS IS WHERE STATEMENT DATA FOR EACH SUBTASK IS SAVED.
*
***********************************************************************
         SPACE
         LA    R2,SAMPLEN          POINT TO SAMPLER SIZE
         MH    R2,=AL2(MAXTASKS)   GET SAMPLER WORK AREA
         SPACE
         GETMAIN R,LV=(R2),SP=22
         XC    0(SAMPLEN,R1),0(R1) CLEAR NEW ENTRY
         ST    R1,SAMPLIST         ADD TO THE LINKED LIST
         LA    R15,0(R1,R2)        POINT TO END OF SAMPLER AREA
         ST    R15,SAMPEND         SAVE END OF SAMPLER AREA
         USING SAMPLE,R1
         L     R15,16              POINT TO THE CVT
         L     R15,0(,R15)         POINT TO THE TCB DOUBLEWORD
         L     R15,0(,R15)         POINT TO THE CURRENT TCB
         ST    R15,SAMPTCB         SAVE THE TCB ADDR
         DROP  R1
         SPACE
***********************************************************************
*
*        OPEN THE TRACE FILE AND OUTPUT A HEADER RECORD
*        THE HEADER RECORD IS PASSED IN AS A PARM.
*        NOTE THAT SINCE WE ARE AMODE=ANY, RMODE=24, WE SWITCH MODES
*        PRIOR TO DOING THE PUT AND THEN PUT THE AMODE BACK.
*
***********************************************************************
         SPACE
         OPEN  (TRACE$$,(OUTPUT))  OPEN THE TRACE FILE
         TM    TRACE$$+(DCBOFLGS-IHADCB),DCBOFOPN  DID IT OPEN
         BO    OPENOK
         SPACE
         WTO   'UNABLE TO OPEN DDNAME TRACE$$, WILL ABEND CODE=222',   X
               ROUTCDE=11
         ABEND 222
         SPACE
OPENOK   DS    0H
         L     R3,PLIHDR           POINT TO HEADER REC LOC/DES
         L     R3,0(,R3)           POINT TO HEADER RECORD
         LA    R7,PUTHDR           ADDR BEFORE THE PUT
         LA    R6,HDRDONE          ADDR AFTER THE PUT
         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE
PUTHDR   DS    0H
         PUT   TRACE$$,(R3)        PUT RETURNS ADDR OF WHERE TO PUT REC
         BSM   0,R6                PUT THE ADDRESSING MODE BACK
HDRDONE  DS    0H
         EJECT
***********************************************************************
*
*        LOAD THE PL/I PROGRAM AND START IT.
*        SAVE THE TIMING TYPE IN A FLAG.
*        WHEN THE PROGRAM RETURNS, SAVE THE RETURN CODE AND CANCEL
*        ANY REMAINING TIMERS.
*
***********************************************************************
         SPACE
         L     R1,PLILMOD          POINT TO THE LOADMODULE L/D
         L     R1,0(,R1)           POINT TO THE LOADMOD NAME
         MVC   LOADMOD(8),0(R1)    SAVE THE LOAD MODULE NAME
         LOAD  EPLOC=LOADMOD       LOAD THE PROGRAM
         ST    R0,LOADPT           SAVE THE ENTRY POINT
         SPACE
         L     R1,PLITYPE          POINT TO TYPE PARM LOC/DES
         L     R1,0(R1)            POINT TO TYPE PARM
         CLC   0(4,R1),=CL4'REAL'  ARE WE MEASURING REAL TIME?
         BE    TIMEREAL            IF SO, ISSUE THE REAL TIME STIMER
         SPACE
         MVI   TIMETYPE,TYPETASK   FLAG TASK TYPE TIMEING
         B     CALLPGM
         SPACE
TIMEREAL DS    0H
         MVI   TIMETYPE,TYPEREAL   FLAG REAL TYPE TIMEING
         SPACE
CALLPGM  DS    0H
         L     R1,PLILPRM          POINT TO THE LOADMOD PARM L/D
         OI    0(R1),X'80'         TURN ON THE HIGH BIT
         LA    R6,LMODDONE         ADDR AFTER THE CALL
         BSM   R6,0                SAVE THE AMODE IN THE HIGH BIT
         L     R15,LOADPT          LOAD THE TARGET ADDRESS
         BASSM R14,R15             CALL THE PROGRAM
         BSM   0,R6     -+ LOCKED  PUT THE ADDRESSING MODE BACK
LMODDONE DS    0H       -+ TOGETHER
         LR    R2,R15              SAVE THE RETURN CODE
         TTIMER CANCEL,TU          CANCEL ANY MAIN TASK TIMERS
         SPACE
         L     R1,PLIRC            POINT TO THE RETURN CODE PARM
         ST    R2,0(,R1)           SAVE IN THE PL/I PARM
         SPACE
RETURN   DS    0H
         L     13,4(13)            RESTORE OLD R13.
         LM    14,12,12(13)        RESTORE REGISTERS.
         BR    14                  RETURN.
         DROP  R10
         SPACE 2
         DROP  R11
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*    ROUTINE EXPIRED                                                  *
*                                                                     *
*              STIMER EXPIRATION EXIT; RECEIVES CONTROL WHEN STIMER   *
*              INTERVAL EXPIRES. FOR CPU TIME SAMPLING                *
*                                                                     *
*    THIS ROUTINE IS REALLY AMODE=ANY.  THE STIMER FIRST ISSUED IN    *
*    GETSAMP IS IN THE ADDRESSING MODE OF THE TEST PROGRAM.  THIS     *
*    IS THE ADDRESSING MODE WE ARE ENTERED IN.                        *
*                                                                     *
***********************************************************************
         SPACE
EXPIRED  DS    0D
         USING EXPIRED,R15
         STM   R14,R12,12(R13)     SAVE REGISTER 14 THRU 13.
         L     R11,=A(SAMPLER1)    GET ADDRESS OF BASE.
         DROP  R15                 DROP TEMPORARY BASE.
         USING SAMPLER1,R11        R11-> PROGRAM BASE.
         SPACE
***********************************************************************
*
*              INCREMENT COUNTER OF HITS
*
***********************************************************************
         SPACE
         L     R1,COUNT            PUT ADDR OF COUNT IN R1
         L     R2,0(,R1)           PUT CONTENTS OF COUNT IN R2
         C     R2,=X'7FFFFFFF'     COMPARE AGAINST MAXINT.
         BE    EXITDONE            NO MORE SAMPLES THIS RUN
         SPACE
         A     R2,=F'1'            INCRMT COUNTER BY 1
         ST    R2,0(,R1)           RETURN THE NOW UPDATED COUNT
         SPACE
***********************************************************************
*
*              FIND THE SAMPLER DATA AREA
*
***********************************************************************
         SPACE
         L     R4,16               POINT TO THE CVT
         L     R4,0(,R4)           POINT TO THE TCB DOUBLE WORD
         L     R4,0(,R4)           POINT TO THE CURRENT TCB
***** DEBUG CODE START
*        SLR   R0,R0               CLEAR COUNTER REG
***** DEBUG CODE END
         SPACE
         L     R5,SAMPLIST         POINT TO FIRST SAMPLIST ENTRY
         USING SAMPLE,R5
SAMPLOOP DS    0H
         LTR   R5,R5               END OF LIST?
         BE    NOSAMP
         SPACE
***** DEBUG CODE START
*        A     R0,=F'1'            COUNT SAMPLER ENTRIES
***** DEBUG CODE END
         C     R4,SAMPTCB          IS THIS THE ONE?
         BE    GOTSAMP             IF SO, GREAT
         SPACE
         L     R5,SAMPNEXT         POINT TO THE NEXT ONE
         B     SAMPLOOP            AND TRY AGAIN
         SPACE
NOSAMP   DS    0H
         LR    R14,R13             COPY HSA ADDR
         LA    R13,EXPSAVE         R13-> SAVEAREA.
         ST    R14,4(,R13)         SAVE OUR SA ADDRESS INTO CALLERS.
         ST    R13,8(,R14)         SAVE HSA  ADDRESS INTO LSA.
         MVC   STMT(8),=C'        ' BLANK THE STATEMENT NUMBER
         MVC   PROC(31),=CL31'?? NO SAMPLER DATA AREA'
         B     PUTREC
         SPACE
GOTSAMP  DS    0H
         LR    R14,R13             COPY HSA ADDR
         LA    R13,SAMPSAVE        R13-> SAVEAREA.
         ST    R14,4(,R13)         SAVE OUR SA ADDRESS INTO CALLERS.
         ST    R13,8(,R14)         SAVE HSA  ADDRESS INTO LSA.
         SPACE
***********************************************************************
*
*              IF THERE IS VALID DATA IN THE POSITION DATA FIELD
*              GET THE PROC NAME FROM THE AREA JUST BEFORE THE EP
*
***********************************************************************
         SPACE
***** DEBUG CODE START
*        CVD   R0,DWORK            CONVERT NUMBER TO DECIMAL
*        MVC   DWORK2(10),=X'40202020202020202021'
*        ED    DWORK2(10),DWORK+3     MAKE PRINTABLE
*        MVC   TCBADDR(8),DWORK2+2
*        OI    TCBADDR+7,X'F0'        THE SIGN BIT TOO.
*        L     R15,SAMPRET
*        ST    R4,WORK1            SAVE THE TCB ADDR
*        UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX
*        TR    DWORK(8),HEXCHAR
*        MVC   TCBADDR(8),DWORK   MOVE DATA TO THE RECORD
*        L     R15,STMTS
*        L     R15,0(,R15)         LOAD COUNT
*        ST    R15,WORK1           SAVE THE OFFSET
*        UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX
*        TR    DWORK(8),HEXCHAR
*        MVC   R12S(8),DWORK       MOVE DATA TO THE RECORD
***** DEBUG CODE END
         SPACE
         LM    R6,R7,SAMPR15       GET THE ENTRY POINT
         LA    R6,0(,R6)           MAKE SURE HIGH BIT IS OFF
         LA    R7,0(,R7)           MAKE SURE THE HIGH BIT IS OFF
         LTR   R6,R6               IS IT ZERO?
         BNZ   GOTEP               IF SO, GO CONTINUE
         SPACE
         MVC   STMT(8),=C'        ' BLANK THE STATEMENT NUMBER
         MVC   PROC(31),=CL31'!! INITIALIZATION' SHOW NO DATA YET
         MVC   EXT(8),=C'        '
         B     PUTREC
         SPACE
GOTEP    DS    0H
         LR    R15,R6              GET A COPY OF THE RECORD
         S     R15,=F'1'           BACK UP ONE BYTE
         SLR   R14,R14             CLEAR A REGISTER FOR THE PROC LEN
         IC    R14,0(R15)          GET THE LENGTH
         C     R14,=F'31'          IS THE NAME TOO LONG?
         BNH   GETNAME             IF NOT, FINE
         SPACE
UNKNOWN  DS    0H
         MVC   PROC(31),=CL31'!! UNKNOWN PROCEDURE '
         B     CHKEXT              SEE IF THE STATEMENT NUM TBL IS OK
*        LA    R14,31              TRUNCATE TO 31 CHARS
         SPACE
GETNAME  DS    0H
         MVC   PROC(31),=CL31' '   BLANK OUT THE TARGET FIELD
         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME
         BCTR  R14,0               SUB ONE FOR THE EXECUTE
         EX    R14,TESTNAME        IS THIS A VALID NAME?
         BNZ   UNKNOWN             IF NOT, USE THE UNKNOWN PROC NAME
         EX    R14,MOVENAME        MOVE THE PROC NAME.
         EJECT
***********************************************************************
*
*        EXAMINE THE STATEMENT NUMBER TABLE TO GET THE STATEMENT
*        NUMBER.  OTHERWISE SAVE THE OFFSET.
*
***********************************************************************
         SPACE
CHKEXT   DS    0H
         L     R15,SAMPEXT         GET THE EXT ENTRY POINT
         LA    R15,0(,R15)         MAKE SURE HIGH BIT IS OFF
         LTR   R15,R15             IS IT ZERO?
         BNZ   GOTEEP              IF SO, GO CONTINUE
         SPACE
NOEP     DS    0H
         MVC   EXT(8),=CL8'!UNKNOWN' SHOW NO DATA
         B     CHKSTMT
         SPACE
GOTEEP   DS    0H
         MVC   EXT(8),=CL8' '      BLANK OUT THE TARGET FIELD
         S     R15,=F'1'           BACK UP ONE BYTE
         SLR   R14,R14             CLEAR A REGISTER FOR THE PROC LEN
         IC    R14,0(R15)          GET THE LENGTH
         C     R14,=F'31'          IS THE NAME TOO LONG?
         BH    NOEP                IF SO, GO USE UNKOWN
         C     R14,=F'8'           IS THE NAME TOO LONG?
         BNH   GETEXT              IF NOT, FINE
         SPACE
         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME
         MVC   EXT(4),0(R15)       MOVE FIRST 4
         AR    R15,R14             GO BACK TO END
         S     R15,=F'3'           BACK UP 3
         MVC   EXT+4(3),0(R15)     LAST 3
         B     CHKSTMT
         SPACE
GETEXT   DS    0H
         SR    R15,R14             BACK UP TO THE BEGINNING OF THE NAME
         BCTR  R14,0               SUB ONE FOR THE EXECUTE
         EX    R14,TESTNAME        IS THIS A VALID NAME?
         BNZ   NOEP                IF NOT, USE THE UNKNOWN PROC NAME
         EX    R14,MOVENAM2        MOVE THE PROC NAME.
         EJECT
***********************************************************************
*
*        EXAMINE THE STATEMENT NUMBER TABLE TO GET THE STATEMENT
*        NUMBER.  OTHERWISE SAVE THE OFFSET.
*
***********************************************************************
         SPACE
CHKSTMT  DS    0H
         L     R8,8(R6)            STATEMENT NUMBER TABLE ADDRESS
         LTR   R8,R8               IS IT ZERO?
         BNZ   FINDSTMT            IF NOT, GO FIND THE STATEMENT
         SPACE
HEXOFF   DS    0H
         LR    R15,R6              COPY OF THE ENTRY POINT
         LR    R14,R7              STATEMENT BEING EXECUTED
         SR    R14,R15             OFFSET OF STATEMENT BEING EXECUTED
         ST    R14,WORK1           SAVE THE OFFSET
         UNPK  DWORK(9),WORK1(5)   CONVERT TO HEX
         TR    DWORK,HEXCHAR
         MVC   STMT(8),DWORK       MOVE DATA TO THE RECORD
         B     PUTREC
         EJECT
***********************************************************************
*
*        THE STATEMENT NUMBER TABLE IS DIVIDED INTO SEGMENTS.  THE
*        HEADER IS OF A FIXED FORMAT AND IS 12 BYTES LONG.
*
*        0                         4 FIRST STMT TABLE BLOCK
*        +-------------------------+
*        | ENTRY POINT ADDR        | TO CALC OFFSET FOR THIS PROC
*        +-------------------------+
*        | MAX OFFSET IN THIS PROC | MAX OFFSET FOR THIS PROCEDURE
*        +-------------------------+
*        | ADDRESS OF 2ND BLK      | POINTER TO SECOND BLOCK
*        +-------------------------+
*
*        THE TABLE ENTRIES ARE PAIRS OF HALFWORDS.  AN OFFSET AND
*        A STATEMENT NUMBER.  THE HIGH BIT OF THE STATEMENT NUMBER
*        MAY BE ON.
*
*        0                         4 2ND STMT TABLE BLOCK AND BEYOND
*        +-------------------------+
*        | ADDR OF NEXT BLOCK      |
*        +-------------------------+
*        | FIRST TABLE ENTRY       | MAX OFFSET FOR THIS PROCEDURE
*        +-------------------------+
*
*        FOR THE SECOND TABLE, YOU MUST SUBTRACT X'7FFF' FROM THE
*        OFFSET TO USE THE TABLE ENTRIES.
*
*
***********************************************************************
***********************************************************************
*                                                                     *
* PROCEDURE FOR FINDING THE STATEMENT.  FIRST CALC THE OFFSET IN THE  *
* PROC BY SUBTRACTING THE STATEMENT ADDRESS FROM THE FIRST WORD OF    *
* THE STATEMENT NUMBER TABLE (THE ENTRY POINT OF THE PROCEDURE).  IF  *
* THE OFFSET IS LESS THAN X'7FFF', THE STATEMENT IS IN THE FIRST      *
* BLOCK OF THE TABLE.  THIS STARTS AT OFFSET 12 IN THE TABLE.         *
* OTHERWISE SHIFT OUT THE LOW 15 BITS OF THE OFFSET TO GET THE NUMBER *
* OF TABLE BLOCKS WE MUST STEP THROUGH TO GET TO THE ONE WE NEED.     *
* FOR EACH BLOCK WE MUST REDUCE THE STATEMENT OFFSET BY X'7FFF'.      *
* NOTE THAT STEPPING TO THE SECOND BLOCK USES OFFSET 8 IN THE FIRST   *
* BLOCK.  STEPPING TO ANY LATER BLOCKS USES OFFSET 0 AS THE ADDRESS   *
* OF THE NEXT BLOCK.  ALSO, THE SECOND BLOCK AND BEYOND HAS STATEMENT *
* ENTRIES STARTING AT 4 INTO THE BLOCK INSTEAD OF 12.                 *
*                                                                     *
*      REGISTER USAGE:                                                *
*              R6  -  REGISTER 15 OF PROGRAM (EP OF INTERRUPTED PL/I  *
*                     ROUTINE)                                        *
*              R7  -> STATEMENT IN CODE WHICH WAS EXECUTING WHEN      *
*                     INTERRUPTED                                     *
*              R8  -> STATEMENT NUMBER TABLE FOR THE ROUTINE          *
*              R9  -> FIRST STMT NUMBER TBL ENTRY FOR CURRENT STMT    *
*                     TBL BLOCK.                                      *
*              R11 -  PROGRAM BASE FOR THIS ROUTINE                   *
*              R12 -  ?                                               *
*              R13 -> LOWER SAVE AREA                                 *
*              R14 -  OFFSET OF STATEMENT WE ARE LOOKING FOR          *
*              R15 -  CURRENT STATEMENT NUMBER TABLE ENTRY            *
*                                                                     *
***********************************************************************
         SPACE
FINDSTMT DS    0H
         LR    R14,R7              COPY OF STATEMENT BEING EXECUTED
         S     R14,0(R8)           GET THE OFFSET
         C     R14,4(R8)           SANITY CHECK, ARE WE IN THE PROC?
         BH    HEXOFF              IF NOT, FORGET IT, USE THE HEX.
         SPACE
         LA    R9,12(R8)           FIRST STMT ENTRY IN FIRST TABLE
         C     R14,=X'00007FFF'    IS IT IN THIS BLOCK?
         BNH   INBLOCK             YES, GO FIND IT
         SPACE
         L     R8,8(R8)            GO TO THE SECOND BLOCK
         LA    R9,4(R8)            FIRST ENTRY IN SECOND BLOCK.
         LR    R15,R14             GET A COPY OF THE OFFSET TO BUTCHER
         S     R14,=X'00007FFF'    SUB OFF THE OFFSET FOR THE 2ND TBL
         SRL   R15,15              GET RID OF THE LOW 15 BITS
*                                  R15 HAS NUMBER OF TABLES TO STEP
*                                  THROUGH.  NOTE WE DID 1 ALREADY.
*                                  FIRST STEP IS SPECIAL CASE, NEXT
*                                  BLK ADDR AT OFFSET 8, INSTEAD OF 0.
         BCTR  R15,0               SUB 1 FOR THE LOAD WE DID
         LTR   R15,R15             DO WE NEED MORE?
         BZ    INBLOCK             IF NOT, GO PROCESS THE BLOCK
         SPACE
BLKLOOP  DS    0H
         L     R8,0(R8)            GO TO THE NEXT BLOCK
         S     R14,=X'00007FFF'    SUB OFF THE OFFSET FOR THE NEXT TBL
         LA    R9,4(R8)            FIRST ENTRY IN THIS BLOCK
         BCT   R15,BLKLOOP         LOOP TILL WE STEP RIGHT NUM TIMES.
         SPACE
INBLOCK  DS    0H
         LR    R15,R9              POINT TO FIRST ENTRY IN BLOCK
         SPACE
WALKBLK  DS    0H
         SLR   R0,R0               CLEAR R0
         L     R1,0(R15)           LOAD AN ENTRY
         N     R1,=X'7FFFFFFF'     CLEAR HIGH BIT
         SLDL  R0,16               SPLIT THE HALFWORDS
         SRL   R1,16               PUT R1 BACK WHERE IT BELONGS
         CR    R14,R0              IS OFFSET HIGHER THAN TABLE OFFSET?
         BNH   GOTSTMT             IF NOT, WE GOT IT
         SPACE
         LA    R15,4(R15)          BUMP TO THE NEXT ENTRY
         B     WALKBLK             AND TRY AGAIN
         SPACE
GOTSTMT  DS    0H
*        CVD   R1,DWORK            CONVERT NUMBER TO DECIMAL
*        UNPK  STMT(8),DWORK+3(5)  MAKE PRINTABLE
*        OI    STMT+7,X'F0'        THE SIGN BIT TOO.
         CVD   R1,DWORK            CONVERT NUMBER TO DECIMAL
         MVC   DWORK2(10),=X'40202020202020202021'
         ED    DWORK2(10),DWORK+3     MAKE PRINTABLE
         MVC   STMT(8),DWORK2+2
         OI    STMT+7,X'F0'        THE SIGN BIT TOO.
         EJECT
***********************************************************************
*
*              WRITE OUT RECORD TO THE PL/I FILE
*              THIS RECORD HAS HE CURRENT LOCATION INFORMATION
*              THE FILE IS A PUT LOCATE FILE.
*
***********************************************************************
         SPACE
PUTREC   DS    0H
         LA    R14,SAMPTCB         LOAD LOCKED VALUE
         LA    R15,0               LOAD UNLOCKED VALUE
         CS    R15,R14,DCBLOCK     PUT LOCK VALUE IN SEMAPHORE
         BNZ   PUTREC              SPIN WAITING FOR DCB
         SPACE
         LA    R7,PUTSTRT          ADDR BEFORE THE PUT
         LA    R6,PUTDONE          ADDR AFTER THE PUT
         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE
PUTSTRT  DS    0H
         PUT   TRACE$$,CUR$LOC     PUT RETURNS ADDR OF WHERE TO PUT REC
         BSM   0,R6                PUT THE ADDRESSING MODE BACK
PUTDONE  DS    0H
         XC    DCBLOCK(4),DCBLOCK  UNLOCK THE DCB
         SPACE
***********************************************************************
*
*              REISSUE STIMER AND RETURN TO PROGRAM BEING ANALYZED,
*              VIA STIMER EXIT LINKAGE.
*
***********************************************************************
         SPACE
         CLI   TIMETYPE,TYPETASK   IS THIS TASK TIMEING
         BE    RESETTSK            IF SO, RESET THE TASK TIMER
         SPACE
         STIMER REAL,EXPIRED,BINTVL=TIME   REISSUE TIME INTERVAL.
         B     EXITDONE
         SPACE
RESETTSK DS    0H
         STIMER TASK,EXPIRED,BINTVL=TIME   REISSUE TIME INTERVAL.
         SPACE
EXITDONE DS    0H
         L     R13,4(,R13)         POINT TO HSA
         LM    14,12,12(R13)       RESTORE REGISTERS.
         BR    14                  RETURN.
         SPACE 2
MOVENAME MVC   PROC(*-*),0(R15)    MOVE PROC NAME TO OUTPUT RECORD
MOVENAM2 MVC   EXT(*-*),0(R15)     MOVE EXT NAME TO OUTPUT RECORD
TESTNAME TRT   0(*-*,R15),VALIDPRC  TEST PROCEDURE NAME
         SPACE
         DROP  R5,R11
         EJECT
***********************************************************************
*                                                                     *
*    ROUTINE STOPSAM                                                  *
*                                                                     *
*    THIS ROUTINE IS CALLED FROM THE PLEA MAIN PROCEDURE DURING       *
*    CLEANUP TO TURN OFF THE SAMPLER.  IT KILLS THE STIMER            *
*                                                                     *
***********************************************************************
         DS    0D
         DC    CL7'STOPSAM'
         DC    X'07'
STOPSAM  DS    0D
         USING *,R15               R15-> TEMPORARY BASE.
         STM   R14,R12,12(13)      STORE CALLERS REGISTERS.
         LR    R14,R13             SAVE R13 INTO R14.
         LA    R13,SAVEAREA        GET SAVEAREA ADDRESS.
         ST    R13,8(R14)          STORE OUR SA ADDRESS INTO CALLERS.
         ST    R14,4(R13)          STORE CALLERS SA ADDRESS INTO OURS.
         L     R11,=A(SAMPLER1)    GET BASE ADDRESS.
         LR    R10,R1              SAVE PARM ADDRESS
         DROP  R15
         USING SAMPLER1,R11        R11-> PROGRAM BASE.
         L     R10,0(R10)          POINT TO TRAILER REC L/D
         L     R10,0(R10)          POINT TO TRAILER REC.
         SPACE
         LA    R7,PUTTRL           ADDR BEFORE THE PUT
         LA    R6,TRLDONE          ADDR AFTER THE PUT
         BSM   R6,R7               SWITCH TO 24 BIT MODE, SAVE AMODE
PUTTRL   DS    0H
         PUT   TRACE$$,(R10)       PUT RETURNS ADDR OF WHERE TO PUT REC
         BSM   0,R6                PUT THE ADDRESSING MODE BACK
TRLDONE  DS    0H
         DELETE EPLOC=LOADMOD
         SPACE
         CLOSE (TRACE$$)
         SPACE
         L     R13,4(R13)          RESTORE OLD R13.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP  R11
         EJECT
***********************************************************************
*                                                                     *
*    ROUTINE GETSAMP                                                  *
*                                                                     *
*    ROUTINE TO COLLECT LOCATION DATA FROM THE PL/I ROUTINE.          *
*    THIS ROUTINE IS ENTERED AS A PLITEST STATEMENT ENTRY.  IT IS     *
*    REQUIRED THAT THE PROGRAM BEING TESTED WAS COMPILED WITH THE     *
*    TEST(ALL) OR TEST(STMT) OPTION AS WELL AS GOSTMT.                *
*                                                                     *
*    THE FUNCTIONALITY OF THIS ROUTINE IS VERY SIMPLE.  IT SAVES      *
*    THE ENTRY POINT OF THE ROUTINE AND THE ADDRESS IN THE PROGRAM    *
*    WHICH CALLED THE ROUTINE.                                        *
*                                                                     *
*                                                                     *
*                                                                     *
* HOW PLITEST DOES ITS LINKAGE                                        *
*                                                                     *
* WHEN PL/I VERSION 2.1 OR LATER IS COMPILED WITH THE TEST OPTION     *
* HOOKS ARE PUT IN TO IMPLEMENT THE PLITEST INTERFACE.  THESE HOOKS   *
* ARE IN THE FORM OF 'EX'ECUTE ISNTRUCTIONS WHICH EXECUTE AN          *
* INSTRUCTION AT AN OFFSET OFF REGISTER 12.  THESE OFFSETS START AT   *
* +1A8.  THERE ARE 14 OF THESE FULLWORD INSTRUATIONS.  WHEN TEST IS   *
* INACTIVE, EACH FULLWORD CONTAINS 0700C198.  0700 IS A NOOP .  C198  *
* IS A BASE DISPLACEMENT OF 12 BYTES OF INSTRUCTIONS AND 4 BYTES OF   *
* CODE.  WHEN PLITEST IS ACTIVE THE 0700 IS REPLACE BY 45C0 WHICH IS  *
* A BAL USING R12 AS A RETURN ADDRESS.  THUS IF PLITEST IS ACTIVE,    *
* THE NOOP BECOMES A BAL TO THE CODE AT 198 IN THE TCA.  THIS CODE    *
* SAVES THE RETURN ADDRESS AT OFFSET DECIMAL 100 OFF REGISTER 13.     *
* LOADS THE ADDRESS OF THE PLITEST MODULE IBM0DIM.IBM0DIM AND         *
* BRANCHES TO IT.  THIS ROUTINE USES THE SAVE AREA OFF R13,           *
* PRESERVES THE PSW CC WITH AN IPM INSTRUCTION AND FIXES UP R12.  IT  *
* KNOWS TO SUBTRACT +1A4 FROM THE CURRENT R12 TO GET THE REAL R12.    *
* THIS IS BECAUSE  WHEN IBM0DIM IS CALLED, IT IS WITH A BAL 12,12     *
* WHICH LEAVES AN ADDRESS IN R12 WHICH IS JUST PAST THE BALR WHICH    *
* WAS IN CODE BASED OFF R12.                                          *
*                                                                     *
* (NOTE:  CEE USES A DIFFERENT ROUTINE, BUT THE LINKAGE IS THE SAME)  *
* IBM0DIM GETS ROLLING WITH THE FOLLOWING INSTRUCTIONS:               *
*                                                                     *
* STM     R14,R12,12(R13) NORMAL REGISTER SAVE                        *
* IPM     R9              SAVE THE PROGRAM MASK IN R9                 *
* BALR    R3,0            GET A BASE REGISTER                         *
* * NORMAL SAVE AREA CROSS LINKAGE                                    *
*                                                                     *
* AFTER THE ROUTINE DOES ITS THING, IT NEEDS TO RESTORE THE           *
* ENVIRONMENT EXACTLY AND RETURN TO THE CALLED PLACE.  THIS IS        *
* TRICKY.  THE KEY SEQUENCE TO RETURNING IS:                          *
*                                                                     *
* LA      R5,6            GET A SIX                                   *
* SR      R12,R5          BACK UP 6 BYTES BEFORE THE MAIN TCA BEGINNING
* SPM     R9              WHERE R9 HAS THE SAVED CC (IPM INSTRUCTION) *
* LM      R14,R11,12(R13) RELOAD EVERYTHING BUT R12                   *
* BR      R12                                                         *
*                                                                     *
* AT 6 BYTES BEFORE THE TCA START EXIST THE INSTRUCTIONS:             *
*                                                                     *
* L       R12,100(R13)    GET ORIGINAL RETURN POINT                   *
* BALR    R12,R12         GO TO IT AND SET R12 TO THE CORRECT VALUE   *
*                                                                     *
* THE CODE FROM +198 OFF R12 IS:                                      *
*                                                                     *
* ST      R12,100(R13)    SAVE RETURN POINT                           *
* BALR    R12,0           GET A TEMP BASE                             *
* L       R12,6(R12)              LOAD THE PLITEST ROUTINE ADDRESS    *
* BALR    R12,R12         GO TO IBM0DIM.                              *
* DC      A(IBM0DIM)                                                  *
*                                                                     *
* TO DO THE PLEA HOOKUP, WE WILL TURN ON STATEMENT HOOKS (OFFSET      *
* +1AC OFF R12) AND PUT OUR OWN ROUTINE ADDRESS AT +1A4 OFF R12.      *
* THIS ROUTINE SAVES THE RETURN ADDRESS FROM 100(R13) AND BACKS UP 1  *
* SAVE AREA AND GETS THE EP ADDRESS FROM R15 IN THE PREVIOUS SAVE     *
* AREA AND THE ADDRESS OF THE STATEMENT NUMBER TABLE WHICH IS LOCATED *
* AT THE R15 EP PLUS 8 BYTES.                                         *
*                                                                     *
* WHEN THE SAMPLER GETS CONTROL, IT WILL LOOK UP THE STATEMENT USING  *
* THE AVAILABLE INFORMATION AND WRITE OUT THE DATA.                   *
*                                                                     *
*    THIS ROUTINE IS REALLY AMODE=ANY.  IT IS ENTERED DIRECTLY FROM   *
*    THE TEST PROGRAM.  THEREFORE IT IS IN THE ADDRESSING MODE OF     *
*    THE TEST PROGRAM.                                                *
*                                                                     *
*                                                                     *
***********************************************************************
         DS    0D
         DC    CL7'GETSAMP'
         DC    X'07'
GETSAMP  DS    0D
         STM   R14,R11,12(13)      STORE CALLERS REGISTERS.
*        L     R7,100(R13)         GET RETURN ADDRESS (NON-XA) PM
         IPM   R7                  SAVE PROGRAM MASK (FOR XA)
         BALR  R3,0                GET A BASE REGISTER
         USING *,R3                AND USE IT
         SPACE
         LA    R12,0(R12)          MAKE SURE HIGH BIT IS CLEAR
         SH    R12,R12FIX          FIX UP R12 TO ITS TRUE VALUE - 6
         SPACE
         L     R4,16               POINT TO THE CVT
         L     R4,0(,R4)           POINT TO THE TCB DOUBLE WORD
         L     R4,0(,R4)           POINT TO THE CURRENT TCB
         SPACE
***********************************************************************
*                                                                     *
*        FIND THE SAMPLE AREA FOR THIS TCB.  IF WE CANNOT FIND IT     *
*        GO TO "NEWONE" TO CREATE A NEW ENTRY.                        *
*                                                                     *
***********************************************************************
         SPACE
         L     R5,SAMPLIST         POINT TO FIRST SAMPLIST ENTRY
         USING SAMPLE,R5
FINDSAMP DS    0H
         C     R4,SAMPTCB          IS THIS THE ONE?
         BE    GOTIT               IF SO, GREAT
         SPACE
         CLC   SAMPNEXT,=F'0'      LAST ONE IN LIST?
         BE    NEWONE
         SPACE
         L     R5,SAMPNEXT
         B     FINDSAMP            IF NOT, TRY AGAIN
         SPACE
GOTIT    DS    0H
         L     R2,100(R13)         GET RETURN POINT
         S     R2,=F'4'            BACK UP BEFORE THE EXECUTE INSTR
         ST    R2,SAMPRET          SAVE THE RETURN POINT
         L     R1,4(,R13)          BACK UP 1 SAVE AREA
         L     R2,16(,R1)          LOAD OLD EP ADDRESS
         C     R2,SAMPR15          SAME PROC AS LAST TIME?
         BE    GOTEXT              THEN WE ARE SET,
         SPACE
         ST    R2,SAMPR15          SAVE THE PROC ENTRY POINT
         SPACE
         SLR   R0,R0               GET A ZERO
         SPACE
FINDEXT  DS    0H
         C     R0,40(,R1)          IS REG 5 A ZERO IN SAVE AREA (EXT?)
         BNE   NEXTSA              IF SO, SAVE IT
         SPACE
         L     R1,16(,R1)          GET THIS EP ADDRESS (R15 IN SA)
         ST    R1,SAMPEXT          SAVE EXTERNAL PROC ADDR
         B     GOTEXT              AND USE IT
         SPACE
NEXTSA   DS    0H
         L     R1,4(,R1)           BACK UP 1 SAVE AREA
         LTR   R1,R1               ZERO?
         BNZ   FINDEXT             IF NOT, KEEP TRYING
         SPACE
         ST    R1,SAMPEXT          SAVE EXTERNAL PROC ADDR
         SPACE
GOTEXT   DS    0H
         L     R1,STMTS            LOAD COUNT POINTER
         L     R2,0(,R1)           LOAD COUNT
         C     R2,=X'7FFFFFFF'     ARE WE AT MAXINT,
         BE    NOBUMP
         SPACE
         A     R2,=F'1'            BUMP IT
         ST    R2,0(,R1)           AND SAVE
         SPACE
NOBUMP   DS    0H
         CLI   ACTIVE,X'FF'        IS THE TIMER ACTIVE?
         BNE   STARTTME
         SPACE
SAMPDONE DS    0H
         SPM   R7                  RESET THE PROGRAM MASK IN THE PSW
         SPACE
         LM    R14,R11,12(R13)      RESTORE REGISTERS.
         BR    R12                 RETURN TO TCA PREFIX
         SPACE
*      NEW ENTRY, ADD TO TABLE
NEWONE   DS    0H
         LA    R1,SAMPLEN(,R5)     FREE SPACE STARTS JUST PAST LAST ENT
         C     R1,SAMPEND          ARE WE AT THE END?
         BNL   SAMPDONE            IF SO, NO SAMPLES
         SPACE
         XC    0(SAMPLEN,R1),0(R1) CLEAR NEW ENTRY
         ST    R1,SAMPNEXT         ADD TO THE LINKED LIST
         LR    R5,R1               NEW ENTRY IS THE CURRENT ONE
         ST    R4,SAMPTCB          SAVE THE TCB ADDR
         B     GOTIT
         SPACE
STARTTME DS    0H
         MVI   ACTIVE,X'FF'        MARK THE TIMER ACTIVE?
         LR    R2,R13              COPY HSA ADDR
         LA    R13,SAMPSAV2        R13-> SAVEAREA.
         L     R6,=A(EXPIRED)
         SPACE
         CLI   TIMETYPE,TYPETASK   IS THIS TASK TIMING?
         BE    INITTSK             IF SO, RESET THE TASK TIMER
         SPACE
         STIMER REAL,(R6),BINTVL=TIME   ISSUE TIME INTERVAL.
         LR    R13,R2              RESTORE SAVE AREA ADDRESS
         B     SAMPDONE
         SPACE
INITTSK  DS    0H
         STIMER TASK,(R6),BINTVL=TIME   ISSUE TIME INTERVAL.
         LR    R13,R2              RESTORE SAVE AREA ADDRESS
         B     SAMPDONE
         DROP  R3
         EJECT
R12FIX   DC    XL2'01AA'
TIMETYPE DC    X'00'               TASK OR REAL TIMEING BEING DONE
TYPETASK EQU   X'FF'               VALUE FOR TASK TIMING
TYPEREAL EQU   X'00'               VALUE FOR REAL TIMING
LOADMOD  DC    CL8' '
LOADPT   DC    A(0)
SAVEAREA DC    20F'0'
EXPSAVE  DC    20F'0'
*
*
TIME     DC    F'03'  (DEFAULT OF .03 MILLISEC SAMPLING INTERVAL)
         DS    0F
COUNT    DS    A
STMTS    DS    A
SAMPLIST DC    A(0)
SAMPEND  DC    A(0)
         EJECT
**********************************************************************
*     OUTPUT TRACE RECORD WRITTEN BY ROUTINE EXPIRED
**********************************************************************
         SPACE
         SPACE 2
DCBLOCK  DC    A(0)
*RACE$$  DCB   DSORG=PS,MACRF=PM,RECFM=FB,BLKSIZE=9048,LRECL=39,
*              DDNAME=TRACE$$
         SPACE 2
TRACE$$  DCB   DSORG=PS,MACRF=PM,RECFM=FB,BLKSIZE=9071,LRECL=47,       X
               DDNAME=TRACE$$
         SPACE 2
HEXCHAR  DC    240X'F0'
         DC    C'0'
         DC    C'1'
         DC    C'2'
         DC    C'3'
         DC    C'4'
         DC    C'5'
         DC    C'6'
         DC    C'7'
         DC    C'8'
         DC    C'9'
         DC    C'A'
         DC    C'B'
         DC    C'C'
         DC    C'D'
         DC    C'E'
         DC    C'F'
         SPACE 2
***********************************************************************
*
*        THIS TRT TABLE IS USED TO IDENTIFY CHARACTERS WHICH ARE VALID
*        IN PL/I NAMES.  IT IS USED TO SCREEN THE PROCEDURE NAMES
*        FOUND JUST BEFORE THE ENTRY POINTS.
*
***********************************************************************
         SPACE
*                    0 1 2 3 4 5 6 7 8 9 A B C D E F
VALIDPRC DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    0
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    1
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    2
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    3
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    4
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF'    5
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFF00FFFF'    6
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF'    7
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    8
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    9
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    A
         DC    XL16'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'    B
         DC    XL16'00000000000000000000FFFFFFFFFFFF'    C
         DC    XL16'00000000000000000000FFFFFFFFFFFF'    D
         DC    XL16'FF000000000000000000FFFFFFFFFFFF'    E
         DC    XL16'00000000000000000000FFFFFFFFFFFF'    F
         SPACE
         LTORG
         SPACE 2
PLIPARM  DSECT
PLICNT   DS    A
PLISTMTS DS    A
PLIHDR   DS    A
PLITIME  DS    A
PLITYPE  DS    A
PLILMOD  DS    A
PLILPRM  DS    A
PLIRC    DS    A
         SPACE
SAMPLE   DSECT
SAMPNEXT DS    A   <-  MUST BE FIRST
SAMPTCB  DS    A
SAMPR15  DS    A
SAMPRET  DS    A
SAMPEXT  DS    A
DWORK    DS    D,F
WORK1    DS    F
DWORK2   DS    D,F
CUR$LOC  DS    0D
STMT     DS    CL8' '
PROC     DS    CL31' '
EXT      DS    CL8' '
ACTIVE   DS    X
SAMPSAVE DS    18A
SAMPSAV2 DS    18A
SAMPLEN  EQU   *-SAMPLE
         SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE
         PRINT NOGEN
         DCBD  DSORG=PS
         END
