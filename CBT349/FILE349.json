{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011818000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE349.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE349.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\r'", "DS1TRBAL": "b' \\xac'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x8b\\x00\\x05\\x02\\x8b\\x00\\x0b\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x001\\x01\\x18)o\\x01\\x18)o\\x15%\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-10-23T00:00:00", "modifydate": "2018-10-23T15:25:31", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  349\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE349\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 28 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,560 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/23/18    15:25:30    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\t\\x00\\x00\\x01\\x18'\\x1f\\x01\\x18)_\\x17\\x16\\x003\\x00\\x15\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.09", "flags": 0, "createdate": "2018-09-28T00:00:00", "modifydate": "2018-10-22T17:16:00", "lines": 51, "newlines": 21, "modlines": 0, "user": "DVL"}, "text": "ISPF Command table handlers\n\nPackages in distribution\n ISPCMDU  Update active command table from a dataset.\n ISPCMDE  Dialog for edit of the ISPCMDU dataset.\n ISPCMDL  List and view open ISPF command tables.\n ISPCTE   Dialog to update permanent ISPF command tables.\n ISPCTL   Dialog to list and update ISPF command tables.\n XISPTBL  Subroutine for ISPF table handling.\n\nInstall ISPCMDU (updater only)\n Copy ISPCMDU to REXX lib.\n Copy ISPCMDU@ to doc lib, if you have one.\n\nInstall ISPCMDE\n Copy ISPCMDE and XISPCTL to REXX lib.\n Copy ISPCMDED and ISPCMDEL to panel lib.\n Copy ISPCMDE@ to doc lib, if you have one.\n\nInstall ISPCMDL\n Copy ISPCMDL and XISPCTL to REXX lib.\n Copy ISPCMDL@ to doc lib, if you have one.\n\nInstall ISPCTE\n Copy ISPCTE and XISPTBL to REXX lib.\n Copy ISPCTEP, ISPCTED and ISPCTEL to panel lib.\n Copy ISPCTE@ to doc lib, if you have one.\n Set variables 'usertable' and 'sitetable' in ISPCTE to your\n local values.\n\nInstall ISPCTL\n Copy ISPCTL and XISPTBL to REXX lib.\n Copy ISPCTL#1, ISPCTL#2 and ISPCTL#3 to panel lib.\n Copy ISPCTL@ to doc lib, if you have one.\n\nYou can also install the XISPTBL demo programs as follows:\n Copy XISPTBD1, XISPTBD2 and XISPCTL to REXX lib.\n Copy XISPTBLD and XISPCTLL to panel lib.\n Copy XISPTBL@ to doc lib, if you have one.\n\n\nMember $$$INST is sample JCL for copying the programs.\n\n\nDocumentation members\n ISPCMDU@  Command table updater\n ISPCMDL@  Open command table lister\n ISPCMDE@  Command table updater dialog\n ISPCTE@   Stored command table update\n ISPCTL@   Stored command table list and update\n XISPTBL@  General ISPF command table handler subroutine\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$INST": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00F\\x01\\x18(?\\x01\\x18)_\\x19\\x08\\x00<\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2018-10-10T00:00:00", "modifydate": "2018-10-22T19:08:46", "lines": 60, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "//*\n//* copy members to site\n//*\n//C        EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//PKGLIB   DD DISP=SHR,DSN=this.lib\n//EXELIB   DD DISP=SHR,DSN=your.exec.lib\n//PNLLIB   DD DISP=SHR,DSN=your.panel.lib\n//HLPLIB   DD DISP=SHR,DSN=your.help.lib\n*--\n*   ISPCMDU\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(ISPCMDU)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((ISPCMDU@,ISPCMDU))\n*--\n*   ISPCMDL\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(ISPCMDL,XISPTBL)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((ISPCMDL@,ISPCMDL))\n*--\n*   ISPCMDE\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(ISPCMDE,XISPTBL)\n C I=((PKGLIB,R)),O=PNLLIB\n   S M=(ISPCMDED,ISPCMDEL)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((ISPCMDE@,ISPCMDE))\n*--\n*   ISPCTE\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(ISPCTE,XISPTBL)\n C I=((PKGLIB,R)),O=PNLLIB\n   S M=(ISPCTED,ISPCTEL,ISPCTEP)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((ISPCTE@,ISPCTE))\n*--\n*   ISPCTL\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(ISPCTL,XISPTBL)\n C I=((PKGLIB,R)),O=PNLLIB\n   S M=(ISPCTL#1,ISPCTL#2,ISPCTL#3)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((ISPCTL@,ISPCTL))\n*--\n*   XISPTBL\n*--\n C I=((PKGLIB,R)),O=EXELIB\n   S M=(XISPTBL,XISPTBD1,XISPTBD2)\n C I=((PKGLIB,R)),O=PNLLIB\n   S M=(XISPTBLD,XISPTBLL)\n C I=((PKGLIB,R)),O=HLPLIB\n   S M=((XISPTBL@,XISPTBL))\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE349": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00$\\x01\\x18)o\\x01\\x18)o\\x15%\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-10-23T00:00:00", "modifydate": "2018-10-23T15:25:24", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 349 is from Willy Jensen and contains programs to update  *   FILE 349\n//*           the ISPF commmand tables in-flight and through a      *   FILE 349\n//*           dialog.                                               *   FILE 349\n//*                                                                 *   FILE 349\n//*           email:        willy.h.jensen@outlook.com              *   FILE 349\n//*           website:      http://harders-jensen.com/wjtech        *   FILE 349\n//*                                                                 *   FILE 349\n//*       Programs contained in the package:                        *   FILE 349\n//*                                                                 *   FILE 349\n//*        ISPCMDU  - update the  command  table in-flight          *   FILE 349\n//*                   using a pds member as input                   *   FILE 349\n//*                                                                 *   FILE 349\n//*        ISPCMDL  - dialog to list all active command tables      *   FILE 349\n//*                                                                 *   FILE 349\n//*        ISPCMDD  - dialog for update ISPCMDU member              *   FILE 349\n//*                                                                 *   FILE 349\n//*        ISPCTE   - dialog to update the ISPF command             *   FILE 349\n//*                   table members, can activate changes           *   FILE 349\n//*                   in-flight                                     *   FILE 349\n//*                                                                 *   FILE 349\n//*        XISPTBL  - ISPF table display pgm, used by ISPCTE        *   FILE 349\n//*                                                                 *   FILE 349\n//*        Member list                                              *   FILE 349\n//*                                                                 *   FILE 349\n//*         $$$DOC     - Installation instructions                  *   FILE 349\n//*         $$$#DATE   - File 349 package date and version          *   FILE 349\n//*         ISPCMDD    - REXX pgm - dialog for update ISPCMDU       *   FILE 349\n//*                      member                                     *   FILE 349\n//*         ISPCMDDD   - panel for ISPCMDD                          *   FILE 349\n//*         ISPCMDDL   - panel for ISPCMDD                          *   FILE 349\n//*         ISPCMDL    - REXX pgm - list table(s)                   *   FILE 349\n//*         ISPCMDL1   - panel for ISPCMDL                          *   FILE 349\n//*         ISPCMDL2   - panel for ISPCMDL                          *   FILE 349\n//*         ISPCMDL3   - panel for ISPCMDL                          *   FILE 349\n//*         ISPCMDU    - REXX pgm - update ISPCMDS in-flight        *   FILE 349\n//*         ISPCOMND   - Sample file for ISPCMDU                    *   FILE 349\n//*         ISPCTE     - REXX pgm - update command table            *   FILE 349\n//*         ISPCTED    - ISPCTE panel - detail                      *   FILE 349\n//*         ISPCTEL    - ISPCTE panel - list                        *   FILE 349\n//*         ISPCTEP    - ISPCTE panel - prompt                      *   FILE 349\n//*         XISPTBL    - REXX pgm - general table display           *   FILE 349\n//*         XISPTBD1   - XISPTBL demo pgm 1 - simple case           *   FILE 349\n//*         XISPTBD2   - XISPTBL demo pgm 2 - call external         *   FILE 349\n//*                      cmd handler                                *   FILE 349\n//*         XISPTBL@   - XISPTBL doc                                *   FILE 349\n//*         XISPTBLD   - XISPTBL panel for demo programs.           *   FILE 349\n//*         XISPTBLL   - XISPTBL panel for demo programs.           *   FILE 349\n//*                                                                 *   FILE 349\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCMDE": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x005\\x01\\x16)\\x9f\\x01\\x18)/\\x16$\\x00\\xb4\\x00\\xb6\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "2016-10-25T00:00:00", "modifydate": "2018-10-19T16:24:35", "lines": 180, "newlines": 182, "modlines": 0, "user": "DVL"}, "text": "/*                                                                          REXX\n\n ISPCMDE  - ISF Command Table Update (ISPCMDU) edit data\n\n Syntax: ISPCMDE USER | SYS | dataset\u00dd(member)\u00a8 | null\n\n History\n 2016-10-31 Initial\n 2016-12-28 Add primary commands Insert and Find.\n            Change parm to USER | SYS | dataset\n            Dataset must be fully qualified, quotes will be ignored.\n            Some restructure.\n 2018-09-26 Major rewrite, use XISPTBL for table display and update.\n*/\n\n Address TSO\n Address Ispexec \"control errors return\"\n parse source sys type whoami ddn whereami .\n parse value 0 with $changed $table cmddsn ispcmdue enve lastfind\n parse value '' with $ddlist cmdmname\n numeric digits 12\n $table='A'left(d2x(space(translate(time('l'),' ','.:'),0)),7)\n\n parse value space(translate(translate(arg(1),\" \",\"'()\"))) with cmddsn cmdmbr\n cmdmbr=word(cmdmbr 'ISPCOMND',1)\n cmdmname=cmdmbr\n\n Select\n   when pos('.',cmddsn)>0 then nop\n   when cmddsn='SYS' then do\n     cmddsn=PrmLbLoc(cmdmbr)\n     if cmddsn='' then call close 8 'Could not find' cmdmbr 'in parmlib'\n   end\n   when cmddsn='USER' | cmddsn='' then do\n     zz=Listdsi('ispprof file')\n     cmddsn=sysdsname\n   end\n   otherwise call close 8 'Invalid parm:' p\n End\n fullds=\"'\"cmddsn\"(\"cmdmbr\")'\"\n\n /* setup enviroment       */\n Address ispexec\n \"control errors return\"\n if MakeTbl()<>0 then call close\n if EditTbl()=1 | $changed then call SaveTbl\n Call close\n\n /*--------------------------------------------------------------------\n                               Return\n --------------------------------------------------------------------*/\nClose:\n parse arg clsrc clsmsg\n if clsmsg<>'' then say clsmsg\n Address TSO \"delstack\"\n if $table<>'' then Address ispexec \"tbend\" $table\n if $ddlist<>'' then call silent \"free dd(\"$ddlist\")\"\n Exit word(clsrc 0,1)\n\n /*--------------------------------------------------------------------\n                      This is where it happens\n --------------------------------------------------------------------*/\nMakeTbl:\n /* load data or make initial list */\n address tso\n if Sysdsn(fullds)='OK' then do\n   cc=bpxwdyn('alloc da('fullds') shr rtddn(xdd)')\n   if cc<>0 then return xmsg(\"Alloc ds\" fullds \"failed\" cc,8)\n   \"execio * diskr\" xdd \"(stem cmds. finis)\"\n   if rc<>0 then return xmsg('Read ds failed rc' rc,8)\n   cc=bpxwdyn('free dd('xdd')')\n end\n else do\n   parse value '1 \\MYCMDS\\0\\select cmd(%ispcmde)\\my commands',\n         with cmds.0 cmds.1\n   $changed=1\n end\n\n /* create work table        */\n Address ispexec\n \"tbcreate\" $table \"names(verb abrv cmd desc dlm zsel grp)\"\n if rc<>0 then return xmsg('Tbcreate failed rc' rc zerrlm,8)\n rec=''\n zsel=''\n do i=1 to cmds.0\n   if cmds.i='' | word(cmds.i,1) = '/*' | left(cmds.i,1)='*' then iterate\n   rec=rec''strip(cmds.i)\n   if right(rec,1)='-' then rec=left(rec,length(rec)-1)\n   else do\n     if pos('\\',rec)=0 then rec=translate(rec,'\\',left(rec,1)) /* new dlm */\n     parse var rec dlm +1 verb . (dlm) abrv . (dlm) cmd (dlm) desc (dlm) .\n     desc=strip(desc)\n     upper verb\n     rec=''\n     grp=3\n     if translate(cmd)='ALIAS' then grp=1\n     if translate(cmd)='PASSTHRU' then grp=2\n     \"tbadd\"   $table  /* rc 8 => duplicate */\n     if rc<>0 & rc<>8 then return xmsg('Tbadd failed rc' rc zerrlm)\n   end\n end\n Return 0\n\n /*--------------------------------------------------------------------\n                         Edit table dialog\n --------------------------------------------------------------------*/\nEditTbl:\n cc=XIspTbl('table('$table') panel(ispcmdel) dpanel(ispcmded)',\n            'crc(1) isel(all) sort(=) icmd(sort)',\n            'hdr(Edit ISPF Command Table additions in' cmddsn')')\n if cc>8 then return xmsg('error',8)\n if cc=8 then return xmsg('cancelled',4)\n if cc=1 then return xmsg('List has been changed',1)\n return 0\n\n /*--------------------------------------------------------------------\n                       (re)write table\n Commands with 'ALIAS' at top, followed by lines with 'PASSTHRU',\n followed by the rest.\n --------------------------------------------------------------------*/\nSaveTbl:\n say 'Saving table' fullds\n\n /* reorder table */\n \"TBSORT\" $table \"FIELDS(grp,N,A,verb,C,A)\"\n\n /* pull table rows */\n address tso \"delstack\"\n queue  '*saved' date('s') time()\n \"tbtop\" $table\n \"tbquery\" $table \"rownum(rows)\"\n do n=1 to rows\n   \"tbskip\" $table\n   line=dlm''verb''dlm''abrv''dlm''cmd''dlm''desc\n   do while length(line)>68\n     parse var line l =68 line\n     queue l'-'\n   end\n   queue line\n end\n\n /* write external data */\n cc=bpxwdyn('alloc da('fullds') shr rtddn(xdd)')\n if cc<>0 then return xmsg(\"Alloc ds\" fullds \"failed\" cc)\n address tso \"execio\" queued() \"diskw\" xdd \"(finis)\"\n if rc<>0 then return xmsg('Write ds failed rc' rc)\n cc=bpxwdyn('free dd('xdd')')\n address tso \"delstack\"\n return 0\n\n /*--------------------------------------------------------------------\n                            Subroutines\n --------------------------------------------------------------------*/\nPrmLbLoc: Procedure /* locate member in parmlib concatenation */\n arg mbr\n trace off\n /* go through list of parmlibs*/\n cvt      = Storage(10,4)                    /* get the CVT address   */\n cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address  */\n ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address*/\n Do loop = 0 to 10                           /* loop for parmlibs    */\n  ipaplib = Storage(D2x(c2d(ecvtipa)+416+(loop*64)),64) /*           */\n  ipapldsn = Substr(ipaplib,1,44)            /* parmlib dsname       */\n  ipaplvol = Substr(ipaplib,46,6)            /* parmlib volume       */\n  ipaplflg = X2b(C2x(Substr(ipaplib,64,1)))  /* parmlib flags        */\n  if Strip(ipapldsn) = '' then iterate       /*                      */\n  if sysdsn(\"'\"strip(ipapldsn)\"(\"mbr\")'\")='OK' then return strip(ipapldsn)\n End\n return ''\n\nRequote: if arg(1)='' then return '';else return \"'\"Unquote(arg(1))\"'\"\nUnquote: return space(translate(arg(1),\" \",\"'\"),0)\nSilent:$=outtrap('$.');Address TSO arg(1);$=outtrap('off');return 0\n\nXMsg:\n parse arg zedlmsg\n if zedlmsg='' then return word(arg(2) 0,1)\n address ispexec \"vput zedlmsg\"\n address ispexec \"setmsg msg(isrz000)\"\n return  word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDE@": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00C\\x01\\x18'_\\x01\\x18)/\\x17\\x19\\x00\\x16\\x00\\x0c\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2018-10-02T00:00:00", "modifydate": "2018-10-19T17:19:43", "lines": 22, "newlines": 12, "modlines": 0, "user": "DVL"}, "text": ")F  ISPCMDE - Dialog to update the ISPCMDU command file\n\nProgram  ISPCMDE is  an ISPF  dialog to  update and  activate the\nISPF command table dataset used by ISPCMDU program.\n\nParameters for ISPCMDE:\n\n none          use member ISPCOMND in your ISPF profile dataset.\n name          use member 'name' in your ISPF profile dataset.\n USER(name)    use member 'name' in your ISPF profile dataset.\n dsname        use member ISPCOMND in named dataset.\n dsname(name)  use member 'name' in named dataset.\n SYS           use member ISPCOMND in your parmlib concatenation.\n SYS(name)     use member 'name' in your parmlib concatenation.\n\nRefer  to  the  documentation  for   the  ISPCMDU  program  for  a\ndescription of the ISPF command table dataset.\n\nRefer  to  the  documentation  for   the  XISPTBL  program  for  a\ndescription of the primary- and  line commands while editing.\n)X\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCMDED": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x004\\x01\\x160_\\x01\\x18&\\x9f\\x13X\\x00(\\x00\\x1a\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2016-10-31T00:00:00", "modifydate": "2018-09-26T13:58:34", "lines": 40, "newlines": 26, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n @ type(input)  caps(on)  just(left) color(turq) hilite(uscore)\n # type(input)  caps(off) just(left) color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(blue )\n \u00dd type(input ) caps(off) color(green)\n \" type(text)   color(blue ) skip(on)\n + type(text)   color(green) skip(on)\n)BODY expand(\\\\)\n%\\ \\ISPF command table entry\\ \\+\n%Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n+\n%&athpnltx \\ \\+\n+\n+Verb       @verb    \" min 2 characters\n+Description#desc\\ \\+\n+Command    #cmd1\\ \\+\n+           #cmd2\\ \\+\n+Delimiter  #z+\n)INIT\n .zvars = '(dlm)'\n*REXX (cmd,cmd1,cmd2)\n parse value '' with cmd1 cmd2\n if length(cmd)>66 then parse var cmd cmd1 =67 cmd2\n else cmd1=cmd\n*ENDREXX\n)PROC\n*REXX (cmd1,cmd2,cmd,grp)\n cmd = cmd1''cmd2\n grp=3\n if translate(cmd)='ALIAS' then parse value 1 'ALIAS' with grp cmd\n if translate(cmd)='PASSTHRU' then parse value 2 'PASSTHRU' with grp cmd\n*ENDREXX\n &c = trunc(&zcmd,3)\n if (&c NE 'CAN')\n   ver (&verb,nb,len,GE,2)\n   ver (&verb,name)\n   ver (&cmd1,nb)\n   ver (&dlm ,nb)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDEL": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00%\\x01\\x160_\\x01\\x18&\\x9f\\x15\\x07\\x00,\\x00\\x17\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2016-10-31T00:00:00", "modifydate": "2018-09-26T15:07:25", "lines": 44, "newlines": 23, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n _ type(input)  caps(off) color(turq) hilite(uscore)\n # type(input)  caps(on)  color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(green)\n \u00dd type(output) caps(off) color(blue)\n \" type(text)   color(blue ) skip(on)\n + type(text)   color(green) skip(on)\n)BODY expand(\\\\) width(&athwidth)\n\"&athhdr\n+Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n\"Primary cmds: ALL, CANcel, eXcl text, Only text, RESet, SORT, NEW\n\"Line cmds:    Delete, Edit, Insert, Repeat\n+\n%   Verb     Ab Cmd \\ \\ Desc \\ \\+\n)MODEL ROWS(SCAN)\n#z \u00a8Verb    \u00ddz \u00ddcmd \\ \\\u00dddesc \\ \\+\n)INIT\n .zvars = '(zsel abrv)'\n)PROC\n ver (&zsel,list,D,E,I,R,S,L)\n &athcsrrw = .csrrow\n*REXX (zcmd,athcsrrw)\n if abbrev('CANCEL',translate(zcmd),3) then zcmd='CANCEL'\n if abbrev('RES',translate(zcmd),3) then zcmd='RESET'\n*ENDREXX\n)END\n\n\n+Primary cmds \"|pc1txt,pc1clr  \\ \\|\n+Line cmds    \"|lc1txt,lc1clr  \\ \\|\n+\n+S Verb     Command                         Description\n)MODEL clear(lcmd)\n@z#verb    #cmd                            #desc\\ \\+\n)INIT\n .zvars = '(lcmd)'\n &pc1txt ='Listcmds  CANcel  SAVE  Insert'\n &pc1clr ='{         {{{     {{{{  {     '\n &lc1txt ='Delete  Edit  Insert  Repeat'\n &lc1clr ='{       {     {       {     '\n)PROC\n ver (&lcmd,list,D,E,I,R,T)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x18)\\x1f\\x01\\x18)\\x1f\\x16B\\x00Y\\x00Y\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-10-18T00:00:00", "modifydate": "2018-10-18T16:42:46", "lines": 89, "newlines": 89, "modlines": 0, "user": "DVL"}, "text": "/*                                                         REXX\n List all active ispf in-storage command tables.\n*/\n\n parse value copies('0 ',30) with $edit $all lst.0 .\n parse value '' with tables\n\n address ispexec\n \"control errors return\"\n \"vget zscrmaxw\"\n width=zscrmaxw\n awidth=(width-19)%2\n tliblist=ListTlibs()\n\n \"qtabopen list(qtol.)\"\n\n do qtoln=1 to qtol.0\n   tblname=strip(qtol.qtoln)\n   if right(tblname,4)<>'CMDS' then iterate\n   tables=tables tblname\n   Call AddList '-->' tblname LocDsn(tliblist,tblname)\n   Call AddList ''\n\n   'tbquery' tblname 'rownum(rows)'\n   if rc<>0 then do\n     Call AddList '*Table is probably libdef''d in another screen'\n     Call AddList ''\n     iterate\n   end\n   tblid = left(tblname,length(tblname)-4)\n   zerrlm=''\n   'tbtop' tblname\n   do rows\n     'tbskip' tblname\n     Call AddList  left(zctverb,8) left(tblid,4),\n       left(zcttrunc,3) left(zctact,awidth) left(zctdesc,awidth)\n   end\n   Call AddList ''\n end\n call Xispmsg 'Tables listed:' space(tables)\n\n address tso\n Signal on syntax name AltDisplay\n call StemEdit 'VIEW','lst.',,lst.0,cmd,,width+14\n exit 0\n\nAltDisplay: /* used if pgm STEMEDIT is not installed */\n cc=bpxwdyn('alloc new delete rtddn(lstdd) unit(vio) dsorg(ps)',\n    'lrecl('width+14') recfm(v,b) blksize(0) tracks space(1,4)')\n if cc<>0 then exit xmsg(\"alloc failed\" cc)+12\n\n \"execio\" lst.0 \"diskw\" lstdd \"(stem lst. finis\"\n address ispexec  \"lminit dataid(did1) ddname(\"lstdd\")\"\n address ispexec  \"view dataid(\"did1\")\"\n exit Bpxwdyn(\"free dd(\"lstdd\")\")*0\n\nAddList: Procedure expose lst.\n parse value 1+lst.0 1+lst.0 arg(1) with n lst.0 lst.n\n return 0\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\nXISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\n\nLocDsn: Procedure\n trace off\n arg list ,mbr .\n do n=1 to words(list)\n   dsn=word(list,n)\n   if sysdsn(\"'\"dsn\"(\"mbr\")'\")='OK' then return 'in' dsn\n end\n return 'library not located'\n\nListTlibs: Procedure /* locate mbrname in library */\n trace off\n parse value '' with qpl qbl qll ltype\n address ispexec\n \"qbaselib ISPPROF id(qpl)\"\n \"qbaselib ISPTLIB id(qbl)\"\n \"qlibdef  ISPTLIB id(qll) type(ltype)\"\n if ltype='LIBRARY' then \"qbaselib\" qll \"id(qll)\"\n rtn=space(translate(qpl qll qbl,\" \",\"',\"))\n do n=words(rtn) to 1 by -1\n   w=word(rtn,n)\n   if left(w,3)='SYS' & substr(w,9,2)='.T' then rtn=delword(rtn,n,1)\n end\n return rtn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDL@": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18)?\\x01\\x18)?\\x17\\x18\\x00\\t\\x00\\t\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-10-20T00:00:00", "modifydate": "2018-10-20T17:18:59", "lines": 9, "newlines": 9, "modlines": 0, "user": "DVL"}, "text": ")F  ISPCMDL - List all open command tables\n\nISPCMDL lists all open command tables in one big list.\n\nParameters\n\n none\n)X\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCMDU": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00I\\x01\\x16\\x03\\x1f\\x01\\x18(/\\x14'\\x00\\xe0\\x00\\xcb\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "2016-01-31T00:00:00", "modifydate": "2018-10-09T14:27:49", "lines": 224, "newlines": 203, "modlines": 0, "user": "DVL"}, "text": "/* ------------------------------------------------------- rexx\n  Add commands to ISPF in-storage command table ISPCMDS.\n\n  Parameters:\n\n   DA(dsname(member))   Both dataset and membername are\n                        optional. Default datasets is the\n                        ISPPROF dataset, default membername\n                        is 'ISPCOMND'.\n                        If dsname is PARMLIB or .PARMLIB, then the\n                        parmlib concatenation is searched.\n   QUIET                Do not show confirmation and statistics.\n   ID(id)               set 'desc' field to id.\n\n  History:\n\n   2018.10.09 da(PARMLIB(mbr)) locate mbr in parmlibs\n   2016.10.25 Support long split lines\n              da(.parmlib) locate ISPCOMND in parmlibs\n   2016.02.17 Fix error in load in an edit macro\n   2016.01.31 Retain aliases at top\n              Use BPXWDYN instead of ALLOCATE\n   2005.04.18 Initial\n\n   ------------------------------------------------------------ */\n\n $table=''\n parse value ' 'translate(arg(1)) with p1 'DA('pmda')' p2\n if right(p2,1)=')' then p2=substr(p2,2)\n parse value p1 p2 with p1 'ID('pmid')' p2\n parse value p1 p2 with p1 ' QUIET ' +0 pmquiet p2\n if p1 p2<>'' then call close 8 'Invalid parm:' space(p1 p2)\n address isredit \"MACRO NOPROCESS\"\n Select\n   when rc = 0 then call Edit_load /* edit macro */\n   when pmda \u00ac= \"\" then call Dsn_Load pmda\n   otherwise call Dsn_Load Locate_Ispprof()\n end\n\n Address IspExec\n \"control errors return\"\n\n Call MakeWorkTable\n\n added=0\n updated=0\n deleted=0\n rec=''\n do i=1 to r.0\n   if r.i='' | word(r.i,1) = '/*' | left(r.i,1)='*' then iterate\n   rec=rec''strip(r.i)\n   if right(rec,1)='-' then rec=left(rec,length(rec)-1)\n   else do\n     parse var rec c +1 verb . (c) trunc . (c) act  (c) desc\n     act =strip(act)\n     desc=strip(desc)\n     upper verb act\n     if dlm = '-' then call tbldel\n     else call tblupd\n     rec=''\n   end\n end\n\n Call RebuildTable    /* rewrite ISPCMDS */\n\n Call Close 0 'added('added') updated('updated') deleted('deleted')'\n\nClose:\n parse arg _rc _msg\n Address TSO \"delstack\"\n if $table<>'' then Address IspExec \"tbend\" $table\n parse arg _rc _msg\n if _msg<>'' then call XMsg _msg\n Exit word(_rc 0,1)\n\nTblUpd:\n if locate(verb) = 0 then do\n   call updvars\n   \"tbput\" $table\n   updated=updated+1\n   return\n end\n /* verb not found, add it */\n \"tbtop\" $table\n call updvars\n \"tbadd\" $table\n added=added+1\n return\n\nTblDel:\n if Locate(verb) > 0 then return\n \"tbdelete\" $table\n deleted=deleted+1\n return\n\nUpdVars:\n zctverb=verb\n zcttrunc=trunc\n zctact=act\n rtype='C'\n if desc = \"\" then desc = \"*\"pmid\"*\"\n zctdesc=desc\n return\n\nLocate:\n \"tbtop\" $table\n \"tbvclear\" $table\n arg zctverb .\n \"tbscan\" $table \"arglist(zctverb)\"\n return rc\n\nXMsg:\n if pmquiet<>'' then return 0\n parse arg zedlmsg\n if zedlmsg = '' then return 0\n zedlmsg= 'ISPCMDU' zedlmsg\n address ispexec \"Vput (zedlmsg)\"\n address ispexec \"setmsg msg(isrz000)\"\n return 0\n\nEdit_Load:   /* load data to stem from edit session */\n address isredit \"(ln) = linenum .zlast\"\n do i=1 to ln\n   address isredit '(l) = line' i\n   r.i = strip(l,t)\n end\n r.0=ln\n return\n\nDsn_Load:   /* load from library */\n arg d m .\n d = strip(d,\"b\",\"'\")\n if m = '' then m = 'ISPCOMND'\n if d='PARMLIB' | d='.PARMLIB' then do\n   d=Locate_Parmlib(m)\n   if d='' then call close 8 'Could not find member' m 'in parmlib'\n end\n d = \"'\"d\"(\"m\")'\"\n address tso\n if sysdsn(d)<>'OK' then ,\n   call close 8 'Could not locate file' d\n if BpxWdyn('alloc da('d') shr rtddn(xdd)')<>0 then,\n   call close 8 'Allocate' d 'failed'\n \"execio * diskr\" xdd \"(stem r. finis)\"\n cc = rc\n zz=BpxWdyn('free dd('xdd')')\n if cc<>0 then call close 8 'Reading' d 'failed rc' cc\n return 0\n\nMakeWorkTable:  /* copy system ISPCMDS */\n $table='T'left(space(translate(time('l'),' ','.:'),0),7)\n Address IspExec\n \"tbcreate\" $table \"names(rtype zctverb zcttrunc zctact zctdesc)\"\n \"tbtop ispcmds\"\n do forever\n   \"tbskip ispcmds\"\n   if rc<>0 then leave\n   if word(zctact,1)='ALIAS' then rtype='A'  /* alias   */\n   else rtype='C'                     /* command */\n   \"tbadd\" $table\n end\n \"tbtop\" $table\n return 0\n\nRebuildTable:  /* rewrite system ISPCMDS */\n Address IspExec\n /* clear system table */\n \"tbbottom ispcmds\"\n do forever\n   \"tbdelete ispcmds\"\n   if rc<>0 then leave\n end\n /* build system table */\n \"tbsort\" $table \"FIELDS(RTYPE,C,A,ZCTVERB,C,A) \"\n \"tbtop\"  $table\n do forever\n   \"tbskip\" $table\n   if rc<>0 then leave\n   \"tbadd ispcmds\"\n end\n \"tbtop ispcmds\"\n return 0\n Call ListTable 'ispcmds'\n return 0\n\nListTable: Procedure   /* list in-storage command table */\n arg name\n address ispexec\n 'tbtop' name\n i=1\n r.i='T' left(\"Verb\",8,\".\") left(\"Len\",3,\".\"),\n     left(\"Action\",50,\".\") left(\"Desc\",15\".\")\n do forever\n   'tbskip' name\n   if rc > 0 then leave\n   i=i+1\n   r.i=left(rtype,1) left(zctverb,8) left(zcttrunc,3),\n       left(zctact,50) left(zctdesc,15)\n end\n r.0=i\n Address TSO\n CALL STEMEDIT 'BROWSE','R.',,,'Command table' name\n return 0\n\nLocate_Ispprof:   /* locate profile dataset */\n cc=Listdsi('ispprof file')\n if cc=0 then return sysdsname\n return ''\n\nLocate_Parmlib: Procedure /* locate member in parmlib concatenation */\n arg mbr\n /* go through list of parmlibs*/\n cvt      = Storage(10,4)                    /* get the CVT address   */\n cvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address  */\n ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address*/\n Do loop = 0 to 10                           /* loop for parmlibs    */\n  ipaplib = Storage(D2x(c2d(ecvtipa)+416+(loop*64)),64) /*           */\n  ipapldsn = Substr(ipaplib,1,44)            /* parmlib dsname       */\n  ipaplvol = Substr(ipaplib,46,6)            /* parmlib volume       */\n  ipaplflg = X2b(C2x(Substr(ipaplib,64,1)))  /* parmlib flags        */\n  if Strip(ipapldsn) = '' then iterate       /*                      */\n  if sysdsn(\"'\"strip(ipapldsn)\"(\"mbr\")'\")='OK' then return strip(ipapldsn)\n End\n return ''\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDU@": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00G\\x01\\x18'\\x1f\\x01\\x18)/\\x17$\\x00\\x88\\x00\\x9b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2018-09-28T00:00:00", "modifydate": "2018-10-19T17:24:47", "lines": 136, "newlines": 155, "modlines": 0, "user": "DVL"}, "text": ")F  ISPCMDU - Dynamic update of the ISPF command Table\n\n\nPreface\n\nUsing program  ISPCMDU you can  add, replace or delete  entries in\nthe the in-storage command table  ISPCMDS, giving the the user the\nfollowing immediate benefits:\n\n -   The default IBM supplied command table(s) remains unchanged.\n -   Changes are active immediately.\n -   You  can  modify  the  command table  at  logon  time  and/or\n     whenever you choose.\n\n\nBackground\n\nThe ISPF  command table is a  very convenient place to  store user\ndefined command shorthands for ISPF  or TSO commands. Many  people\nwould  customize the  ISPF command  table to  suit their  personal\npreferences.  The  main drawback  is,  and  has always  been,  the\nmaintenance issue. If you start by  distributing a copy of the IBM\nsupplied command table  and let each user update his  or her local\ncopy, you have a major  problem distributing updates to the vendor\nsupplied part of the table.\n With  the later  releases of  Z/OS  you have  the possibility  of\nhaving  multiple ISPF  command tables,  which goes  a long  way to\nsolve  this  problem,  but  it  requires an  update  to  the  ISPF\nconfiguration.\n A  minor  nuisance is  that  each  update  requires the  user  to\nrestart the ISPF session. A lot  of effort has gone into trying to\nsolve  the first  problem, without  much success.  And the  second\nproblem has, until now, remained unsolved.\n ISPCMDU attepmpts  to solve  both issues. It  relies on  the fact\nthat the ISPF command table is just that - an ISPF table, although\nwith  a reserved  name and  specific purpose.  But as  it is  just\nanother table means that it can be treated as any other ISPF table\n- it is open, in storage  and modifiable. And it is shared between\nall the  sessions if you  are in  split- or multiple  screen mode.\n\n\nPrograms in the distribution\n\n -   ISPCMDU  update the command table from a datasset.\n -   ISPCMDL  lists the contents of open command tables.\n\n\nDescription of ISPCMDU\n\n Parameters\n\n  DA(dsname member)       where to find input.\n                          Dataset must be fully qualified, quotes\n                          are ignored, it can be PARMLIB for\n                          locating the  member in the parmlib\n                          concatenation.\n                          Default dsname is your ISPPROF dataset.\n                          Default member name is ISPCOMND.\n                          See below for details.\n  QUIET                   Don't show any message.\n  ID(desc)                Description.\n\n Sample\n  IspCmdU da(user.parmlib mycmds) quiet\n\n\nISPCMDU can run  as an edit macro, allowing  for immediate command\ntable updates.\n\n\nISPCMDU command file details.\n\nThe first character  is a delimiter. Any character  except '-' may\nbe used,  as '-' indicates  deletion of the command.  It obviously\ncannot be one that is part of the command itself. In the following\na slash '/' is used as the delimiter.\n Lines where the  first blank-delimited string (word)  is \"/*\" are\nconsidered comment lines.\n Blank lines are ignored.\n\nThe command line format for adding commands is:\n\n/verb/truncation/action/description/\n\n'Verb' is  what you  write on the  command line,  'truncation,' is\nthe least number of characters  to enter (0=no truncation allowed,\nand it must be >= 2), 'action' is what you wish ISPF to do for you\nand  'description'  is an  optional  description  of the  command.\n\nThe format for deleting commands is:\n\n-verb\n\nSamples, these are  part of  my very  own ISPF  command additions:\n\n/SDST/0/SELECT PGM(ISFISP) NEWAPPL(ISF) PARM(ST)/SDSF ST\n/RACF/2/SELECT PANEL(ICHP00) NEWAPPL(RACF)/RACF Admin Panels\n\n\nImplementing ISPCMDU\n\nTo  really make  it fly,  you must  invoke ISPCMDU  at ISPF  start\ntime. ISPCMDU only  works after ISPF has been  initialized, so you\nmust do it like this:\n\nAdd this REXX  pgm as name RUNISPF2, it combines  global and local\nISPCMDU definitions.\n\n Address IspExec /* REXX */\n \"Select cmd(%IspCmdU da(PARMLIB) quiet)\"      /* global */\n \"Select cmd(%IspCmdU quiet)\"                  /* user   */\n \"Select PANEL(ISR@PRIM)\"\n Exit 4\n\nReplace  the   normal  ISPF   initialization  command,   'PDF'  or\n'ISPSTART' with the following:\n\n  Pdf cmd(RUNISPF2)\n\n\nIf you  wish to make changes  later, just edit a  command file and\nissue the command ISPCMDU. It will automatically detect that is is\nbeing run  as an edit  macro and load  the comnands from  the file\nbeing edited.  And you don't even  have to save it  before running\nISPCMDU.\n\n\n**Note This is not related to  ISPFCMDU, it's more a general note.\nYou should make sure that you do not have a ISPCMDS member in your\nISPPROF, or  if you have  then it  must be up  to date. I  had one\nsituation  where the  SWAPBAR command  caused an  'Invalid option'\nmesssage. It  turned out that  I had an  old ISPCMDS member  in my\nISPPROF datasets.  After I  deleted that, everything  was working.\n\n)X\n)O\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTE": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00S\\x01\\x18\\x00\\x9f\\x01\\x18)_\\x18I\\x01\\x88\\x00\\xd6\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2018-01-09T00:00:00", "modifydate": "2018-10-22T18:49:53", "lines": 392, "newlines": 214, "modlines": 0, "user": "DVL"}, "text": "/*                                                                         REXX\n ISPCTE - ISPF command table edit\n\n parameters\n  libname mbrname\n  libname(mbrname)      - allows ISPCTE to be used from ISPF 3.4\n  mbrname               - ispf profile ds will be used as libname\n\n !! After installation, change the usertable and sitetable to your\n local values.\n\n Note - an internal work table is created to be able to sort to\n        put ZACT 'ALIAS' values up front.\n\n Externalized variables\n   icteplds  - permanent table dsname\n   icteptbl  - permanent table name\n   ictepmds  - permanent dsname(mbrname)\n   ictepmds  - permanent dsname(mbrname) ddname\n   ictetlds  - temp lib dsname\n   ictetldd  - temp lib ddname\n   ictetmdd  - temp mbr ddname\n   ictettbl  - temp table name\n   ictewtbl  - work table name (the one being displayed)\n   ictenowr  - nowrite option\n\n Updates:\n  2018-01-08  fix problems with internal copies\n  2018-01-10  add export / import commands and GetCfgTableNames()\n  2018-01-15  fix problem with prompt for new table\n              add NOWRITE option, i.e. when viewing ISPCMDS.\n  2018-09-28  minor internal changes\n  2018-10-19  add prompt for table rewrite\n  2018-10-22  check for proper ISPF cmd table\n              add support for user2-3 and site2-3 tables\n\n Written by Willy Jensen, email willy.h.jensen@outlook.com\n*/\n /* !! you must set the usertable / sitetable to your local values !! */\n usertable1 = 'UCT1CMDS' dd2dsn('ispprof')      /* name and library */\n usertable2 = ''\n usertable3 = ''\n sitetable1 = 'SCT1CMDS  SYSX.ISPTLIB'          /* name and library */\n sitetable2 = ''\n sitetable3 = ''\n ictevlist  = 'icteplds icteptbl ictepmds ictepmdd',\n              'ictetlds ictettbl ictetldd ictetmdd',\n              'ictewtbl ictecfgd ictenowr'\n parse value usertable1 sitetable1 with usertbl userlib sitetbl sitelib,\n              ddlist   /* set to null */\n parse value copies('0 ',20) with ictenowr .\n /* Locate and read the ISPF config table if not named above */\n if usertbl='' then do\n   Parse value GetCfgTableNames() with ut st\n   if ut<>0 then usertbl=ut\n   if st<>0 then sitetbl=ut\n end\n\n /* called as subroutine from XISPTBL ?? */\n arg p1,pid,pcmd,ptable,ptext\n if p1='XISPTBL' then Exit XispCmdX(pid,pcmd,ptable,ptext)\n\n /* standard path */\n parse source sys type whoami ddn whereami .\n parse value '' with ictetldd ictetmdd ictettbl ictewtbl\n Address ispexec \"control errors return\"\n\n ictenowr=(wordpos('NOWRITE',p1)>0)\n if ictenowr then p1=space(delword(p1,wordpos('NOWRITE',p1),1))\n\n parse value translate(p1,' ',\"'()\") with p1 p2 .\n if p1<>'' & p2='' & length(p1)>4 then ,\n    call close 8 'Invalid table name' p1\n\n Select\n   when p1''p2=''       then parse var usertable1 icteptbl icteplds .\n   when p1''p2='USER'   then parse var usertable1 icteptbl icteplds .\n   when p1''p2='USER1'  then parse var usertable1 icteptbl icteplds .\n   when p1''p2='USER2'  then parse var usertable2 icteptbl icteplds .\n   when p1''p2='USER3'  then parse var usertable3 icteptbl icteplds .\n   when p1''p2='SITE'   then parse var sitetable1 icteptbl icteplds .\n   when p1''p2='SITE1'  then parse var sitetable1 icteptbl icteplds .\n   when p1''p2='SITE2'  then parse var sitetable2 icteptbl icteplds .\n   when p1''p2='SITE3'  then parse var sitetable3 icteptbl icteplds .\n   when p1<>'' & p2=''  then parse value p1 LocMbrDs(p1,'isptlib'),\n     with icteptbl icteplds\n   otherwise                 parse value p2 p1,\n     with icteptbl icteplds\n End\n\n if icteptbl='' then call close 8 'Table not set'\n\n if right(icteptbl,4)<>'CMDS' then icteptbl=icteptbl'CMDS'\n icteplds = word(icteplds userlib,1)\n ictepmds = icteplds'('icteptbl')'\n\n Address ispexec\n\n /*--------------------------------------------------------------------\n              Ensure that permanent user table exist\n --------------------------------------------------------------------*/\n\n if sysdsn(\"'\"ictepmds\"'\")<>'OK' then do\n   parse value '' with isctep3 isctep4\n   isctep1 = 'Permanent table' ictepmds 'not found'\n   isctep2 = 'Press ENTER to continue, END/RETURN to abort'\n   \"addpop\"\n   \"display panel(ispctep)\"\n   cc=rc\n   \"rempop\"\n   if cc<>0 then exit 0\n   zerrlm=''\n   \"tbcreate\" icteptbl \"names(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\"\n   if rc<>0 then call close 8 \"Create new table failed\" cc zerrlm\n   \"tbclose\"  icteptbl \"library(ispprof)\"\n   if rc<>0 then call close 8 \"Initial write of new table failed\" cc zerrlm\n end\n\n /*--------------------------------------------------------------------\n                        Make temp table lib\n --------------------------------------------------------------------*/\n\n cc=bpxwdyn('alloc new delete rtddn(ictetldd) rtdsn(ictetlds)',\n            'tracks space(1,1) unit(vio) like('dd2dsn('ispprof')')')\n if cc<>0 then call close 8 \"alloc templib failed\" cc\n ictettbl=ictetldd\n ddlist=ddlist ictetldd\n cc=bpxwdyn('alloc shr rtddn(ictetmdd) da('ictetlds'('ictettbl')')\n if cc<>0 then call close 8 'alloc temp table rc' rc\n ddlist=ddlist ictetmdd\n\n cc=bpxwdyn('alloc shr rtddn(ictepmdd) da('ictepmds')')\n if cc<>0 then call close 8 'alloc perm ds' ictepmds 'failed' rc\n ddlist=ddlist ictepmdd\n\n Call Silent \"Repro infile(\"ictepmdd\") outfile(\"ictetmdd\")\"\n if rc<>0 then do n=1 to $.0\n   say $.n\n end\n if rc<>0 then call close 8 \"repro to templib failed\" rc\n\n /*--------------------------------------------------------------------\n                Open temp table, create edit-table\n --------------------------------------------------------------------*/\n \"tbopen\" ictettbl \"library(\"ictetldd\")\"  /* table copy */\n if rc<>0 then call close 8 \"initial load from templib failed\" rc\n ictewtbl='ZZZ'substr(ictettbl,4) /* SYS -> ZZZ */\n \"tbquery\" ictettbl \"names(names) rownum(n)\"\n names = translate(names,' ','()')\n if wordpos('ZCTVERB',names)=0 | wordpos('ZCTTRUNC',names)=0 ,\n  | wordpos('ZCTACT',names)=0  | wordpos('ZCTDESC',names)=0 ,\n    then call close 8 \"Table\" icteptbl \"is not a proper ISPF cmd table\"\n if wordpos('ZSEL',names)=0    then names='ZSEL' names\n if wordpos('ZCTSORT',names)=0 then names='ZCTSORT' names\n \"tbcreate\" ictewtbl \"names(\"names\") nowrite\"\n if rc<>0 then call close 8 \"Create work table failed\" rc\n Call CopyTable ictettbl,ictewtbl\n\n /*--------------------------------------------------------------------\n                     Run the table edit dialog\n --------------------------------------------------------------------*/\n\n \"tbquery\" icteptbl\n if rc<>0 then call ispmsg 'Note, table' icteptbl 'is not active'\n \"vput (\"ictevlist\")\"\n \"vget zscrmaxw\"\n w=min(zscrmaxw,160)\n cc=XISPTBL('table('ictewtbl') panel(ispctel) dpanel(ispcted) width('w')',\n            'isel(all) proc('whoami') id('ictettbl') crc(1)',\n            'sort(zctverb) hdr(Edit table' icteptbl 'in' icteplds')')\n if cc>8  then call close 8 'Error rc' cc\n if cc=8  then call close 1 'Cancelled'\n if ictenowr then call close 0\n if cc<>1 & initial<>'Y' then call close 0 'no change'\n\n /* better prompt before saving table */\n parse value '' with isctep2 isctep4\n isctep1 = 'Rewrite changed table' ictepmds '?'\n isctep3 = 'Press ENTER to continue, END/RETURN to abort'\n \"addpop\"\n \"display panel(ispctep)\"\n cc=rc\n \"rempop\"\n if cc=0 then call SaveTable\n else call ispmsg 'Save aborted'\n\n Call Close 0\n\n /*--------------------------------------------------------------------\n             Make and sort work table - ALIAS must be first\n --------------------------------------------------------------------*/\n\nSaveTable:\n if ictenowr then return ispmsg('Table is in NOWRITE mode')\n address ispexec\n \"vget (\"ictevlist\")\"\n \"tbsort\"   ictewtbl \"fields(zctsort,C,A,zctverb,C,A)\"\n if rc<>0 then call close 8 \"Sort work table failed\" rc\n Call CopyTable ictewtbl,ictettbl   /* work -> temp */\n \"tbsort\"   ictewtbl \"fields(zctverb,C,A)\"\n Call CopyTable ictettbl,icteptbl   /* temp -> perm */\n /* Replace temporary table */\n \"tbsave\"  ictettbl \"library(\"ictetldd\")\"\n /* make backup copy - requires PDS86 installed */\n Call Silent \"pdsmain '\"icteplds\"' repro\" icteptbl,\n             \"as(\"overlay('Z',icteptbl,length(icteptbl))\") replace\"\n /* Replace permanent table */\n cc=Silent(\"Repro infile(\"ictetmdd\") outfile('\"ictepmdd\"')\")\n if cc=0 then Return ispmsg('Table' icteptbl 'saved')\n say \"Repro to templib failed\" cc\n do n=1 to $.0\n   say $.n\n end\n Return 0\n\n /*--------------------------------------------------------------------\n                             Copy table\n --------------------------------------------------------------------*/\n\nCopyTable: Procedure\n trace off\n arg srctbl,tgttbl\n Address IspExec\n /* clear target table */\n zerrlm=''\n \"tbquery\"  tgttbl \"rownum(rows)\"\n if rows>0 then do\n   \"tbbottom\" tgttbl\n   do rows\n     \"tbdelete\" tgttbl\n   end\n end\n /* copy table */\n \"tbquery\" srctbl  \"rownum(rows)\"\n \"tbtop\"   srctbl\n do rows\n   \"tbskip\"   srctbl\n   if wordpos(translate(zctact),'ALIAS')>0 then upper zctact\n   zctsort=(zctact<>'ALIAS')  /* 0 if 'ALIAS', else '1' */\n   zsel   =''\n   \"tbadd\"    tgttbl\n end\n \"tbtop\"    tgttbl\n return 0\n\n /*--------------------------------------------------------------------\n                       Cleanup and terminate\n --------------------------------------------------------------------*/\n\nClose:\n trace off\n parse arg clsrc clsmsg\n z=outtrap('zz.')   /* silent commands */\n if ictettbl<>'' then address ispexec \"tbend\" ictettbl\n if ictewtbl<>'' then address ispexec \"tbend\" ictewtbl\n address ispexec \"tbopen zzzzzzzz library(zzzzzzzz)\" /* release libdef */\n Call Silent \"free dd(\"ictetmdd ictetldd ictepmdd ictepldd\")\"\n z=outtrap('off')\n Exit XMsg(clsmsg,clsrc)\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n\nISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\n\nSilent: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');return rc\n\nDD2Dsn: zz=Listdsi(arg(1) 'file'); return sysdsname\n\nUnParan: return strip(translate(arg(1),' ','()'))\n\nLocMbrDs:\ntrace off\n liblist=''\n arg libmbr .\n if right(libmbr,4)<>'CMDS' then libmbr=arg(1)'CMDS'\n address ispexec \"qbaselib isptlib id(liblist)\"\n liblist=dd2dsn('ispprof') space(translate(liblist,\" \",\"',\"))\n do liblistn=1 to words(liblist)\n   libds=word(liblist,liblistn)\n   if Sysdsn(\"'\"libds\"(\"libmbr\")'\")='OK' then return libds\n end\n return ''\n\n /*--------------------------------------------------------------------\n                      XISPTBL command handler\n --------------------------------------------------------------------*/\n\nXispCmdX:\n arg pid,pcmd,ptable,ptext\n address ispexec \"vget (\"ictevlist\")\"\n /* i.e.  \"ZYZ00269\",\"CMD\",\"ZYZ00269\",\"ACTivate\"  */\n parse var ptext ptverb ptdata\n Select\n   when pcmd<>'CMD'  then exit 0\n   when ptext='SAVE' then exit SaveTable()\n   when ptext ='EXPORT' then exit Export()\n   when ptverb='IMPORT' & ptdata<>'' then exit Import(ptdata)\n   when abbrev('ACTIVATE',ptext,3) then,\n     exit CopyTable(ictewtbl,icteptbl)\n   otherwise exit ispmsg(ptext 'is not a valid command')\n End\n Exit 0\n\n /*--------------------------------------------------------------------\n       Import dataset, add to active table. format is ISPCMDU\n --------------------------------------------------------------------*/\n\nImport:\n if Ds2stem(arg(1),'imp.')<>0 then,\n   exit ispmsg('Import - load' arg(1) 'did not return data')\n parse value '' with zsel zctsort\n impn=0\n do n=1 to imp.0\n   d=left(imp.n,1)\n   if d='*' then iterate\n   parse var imp.n . (d) zctverb (d) zcttrunc (d) zctact (d) zctdesc\n   if word(zctdesc,1)='*U*' |  word(zctdesc,1)='*S*',\n     then zctdesc=subword(zctdesc,2)\n   address ispexec \"tbadd\" ptable\n   if rc=0 then impn=impn+1\n end\n if impn>0 then address ispexec \"tbsort\" ptable \"fields(zctverb,C,A)\"\n return ispmsg(impn 'records imported from' arg(1))\n\n /*--------------------------------------------------------------------\n            Export table to dataset, in ISPCMDU format\n --------------------------------------------------------------------*/\n\nExport:\n address tso \"delstack\"  /*just in case */\n expds=userid()\".ISPCTE.\"icteptbl\".EXPORT\"\n if sysdsn(\"'\"expds\"'\")='OK' then Call silent \"delete '\"expds\"'\"\n cc=bpxwdyn('alloc new catalog rtddn(expdd) da('expds')',\n    'tracks space(1,1) unit(sysda) recfm(v,b) lrecl(500) blksize(0)')\n if cc<>0 then  exit ispmsg('Export - alloc' expds 'rc' cc)\n ddlist=ddlist expdd\n address ispexec\n \"tbquery\" ptable \"rownum(rows)\"\n \"tbtop\" ptable\n queue '* table' ictetbl 'in' icteplds 'exported' date() time() 'by' userid()\n do n=1 to rows\n   \"tbskip\" ptable\n   queue ';'zctverb';'zcttrunc';'zctact';'zctdesc\n end\n address tso \"execio\" queued() \"diskw\" expdd \"(finis)\"\n cc=rc\n address tso \"delstack\"  /*just in case */\n if cc=0 then \"edit dataset('\"expds\"')\"\n Call FreeDD expdd\n return 0\n\n /*--------------------------------------------------------------------\n                          some subroutines\n --------------------------------------------------------------------*/\n\nFreeDD: Procedure expose ddlist\n arg p .\n if bpxwdyn('free dd('p')')<>0 then return 1\n n=wordpos(p,ddlist)\n if n>0 then ddlist=delword(ddlist,n,1)\n return 0\n\nDs2Stem: /* dataset,stem */\n arg ds2sds .,ds2sstm .\n zz=Value(ds2sstm'0',0)\n cc=bpxwdyn('alloc da('ds2sds') shr rtddn(ds2sdd)')\n if cc=0 then address tso \"execio * diskr\" ds2sdd \"(stem\" ds2sstm \"finis)\"\n if cc=0 then zz=bpxwdyn('free dd('ds2sdd')')\n return Value(ds2sstm'0')=0\n\nGetCfgTableNames: procedure\n cfgds=LocMbrDs('ISPCFIGU','ISPLLIB')\n if cfgds='' then return xmsg('ISPCFIGU not found in ISPLLIB')\n cfgmbr.0=0\n cc=bpxwdyn('alloc da('cfgds'(ISPCFIGU)) shr rtddn(cfgmbrdd)')\n if cc=0 then address tso \"execio * diskr\" cfgmbrdd \"(stem cfgmbr. finis)\"\n if cc=0 then zz=bpxwdyn('free dd('cfgmbrdd')')\n if cfgmbr.0=0  then return xmsg('ISPCFIGU not loaded')\n do n=1 to cfgmbr.0 until p<>0\n   p=pos('BYES',cfgmbr.n) /* this works for z/OS 1.13 - 2.3 */\n end\n if p=0 then return xmsg('BYES not found in config')\n ictecfgd=cfgds\n address ispexec \"vput ictecfgd\"\n parse value substr(cfgmbr.n,p-8,8) with ut +4 st\n if ut='' then return xmsg('Config User table name is blank')\n if st='' then return xmsg('Config Site table name is blank')\n return ut\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTE@": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x08\\x00\\x16\\x01\\x18'_\\x01\\x18)O\\x10Y\\x00\\x15\\x00\\x13\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.08", "flags": 0, "createdate": "2018-10-02T00:00:00", "modifydate": "2018-10-21T10:59:16", "lines": 21, "newlines": 19, "modlines": 0, "user": "DVL"}, "text": ")F  ISPCTE   Dialog to update the ISPF command tables\n\nProgram  ISPCTE is  an ISPF  dialog to  update and  activate the  ISPF\nstored command tables.\n\nParameters for ISPCTE\n\n libname mbrname\n libname(mbrname)\n mbrname               ispf profile ds will be used as libname\n SITE                  name of site table, must be set in the program\n                       prolog.\n USER                  name of user table, must be set in the program\n                       prolog.\n\n\nRefer to the  documentation for the XISPTBL program  for a description\nof the primary- and line commands while editing.\n\n)X\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCTED": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00H\\x01\\x174?\\x01\\x18\\x01?\\x12\\x16\\x00:\\x007\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2017-12-09T00:00:00", "modifydate": "2018-01-13T12:16:48", "lines": 58, "newlines": 55, "modlines": 0, "user": "DVL"}, "text": ")ATTR DEFAULT($+_)\n # type(input)  caps(on)  just(left) color(turq) hilite(uscore)\n _ type(input)  caps(off) just(left) color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(blue )\n \u00dd type(input ) caps(off) color(green)\n \" type(text)   color(blue ) skip(on)\n + type(text)   color(green) skip(on)\n | AREA(DYNAMIC) SCROLL(OFF) EXTEND(OFF)\n { TYPE(CHAR)   COLOR(white)\n } TYPE(CHAR)   COLOR(green)\n)BODY expand(\\\\)\n\"\\ \\ISPF command table entry\\ \\+\n+Cmd =>_zcmd \\ \\+    +\n+\n+\n\"Primary cmds \"|pc1txt,pc1clr  \\ \\|\n+\n+\n+Verb       #zctverb \" min 2 characters\n+\n+Truncation _z\"        2-7, 0 means no truncation\n+\n+Command    _zctact1\\ \\+\n+           _zctact2\\ \\+\n+\n+Description_zctdesc\\ \\+\n+\n+\n$Command samples\n\"  SELECT CMD(%finddsct &zparm)\n\"  SELECT PANEL(ISPYXD1)\n)INIT\n .zvars = '(zcttrunc)'\n*REXX (zctact,zctact1,zctact2,zcttrunc)\n zctact1=zctact\n zctact2=''\n if length(zctact)>66 then zctact2=substr(zctact,67)\n if zcttrunc='' then zcttrunc=0\n*ENDREXX\n &pc1txt ='CANcel'\n &pc1clr ='{{{    '\n)PROC\n &resp = .resp\n*REXX (zcmd,zctact,zctact1,zctact2,zctverb,resp)\n zctact=zctact1''zctact2\n parse var zctact f '(' r\n upper f\n if wordpos(f,'CMD PANEL')>0  then zctact='SELECT' f'('r\n if abbrev('CANCEL',translate(zcmd),3) then zcmd='CANCEL'\n resp=strip(resp)\n if resp='END' & zctverb='' then zcmd='CANCEL'\n*ENDREXX\n if (&zcmd NE 'CANCEL' and &athzsel NE 'D')\n   ver (&zctverb,nb,len,GE,2)\n   ver (&zctverb,name)\n   ver (&zctact1,nb)\n   ver (&zcttrunc,nb,num)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTEL": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1f\\x00\\x01\\x01\\x174?\\x01\\x18'\\x1f\\x10\\x01\\x00$\\x00!\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.31", "flags": 0, "createdate": "2017-12-09T00:00:00", "modifydate": "2018-09-28T10:01:01", "lines": 36, "newlines": 33, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n /* ISPF command table edit dialog (ISCTE) - list panel\n /* Written by Willy Jensen, email willy.h.jensen@outlook.com\n _ type(nef) caps(on)  /* input, color(turq) adjust(left) */\n # type(nef) /* input, caps(off) color(turq) adjust(left) */\n \" type(nt)  /* normal text, color=green                  */\n ! type(ct)  /* caution text.  color=yellow               */\n \u00a8 type(output) caps(off) color(green)\n \u00dd type(output) caps(off) color(blue)\n | AREA(DYNAMIC) SCROLL(OFF) EXTEND(OFF)\n { TYPE(CHAR)   COLOR(white)\n } TYPE(CHAR)   COLOR(green)\n)BODY EXPAND(\\\\) width(&athwidth)\n+\\ \\User ISPF Command Table\\ \\+\n\"Cmd =>_ZCMD \\ \\+Scrl_scrl+\n+\n+\n\"Table &icteptbl in &icteplds\n+\n+Primary cmds +|pc1txt,pc1clr  \\ \\|\n+Line cmds    +|lc1txt,lc1clr  \\ \\|\n+\n%S  Verb     Command \\ \\ Description\\ \\+\n)Model rows(scan)\n_z \u00a8zctverb \u00ddzctact  \\ \\\u00ddzctdesc    \\ \\+\n)INIT\n vget (icteptbl icteplds)\n .zvars = '(zsel)'\n &pc1txt ='CANcel  NEW   ACTivate  All  Find text  Only text  X text  '\n &pc1clr ='{{{     {{{   {{{       {{{  {          {          {       '\n &lc1txt ='Delete  Edit  Insert  Repeat'\n &lc1clr ='{       {     {       {     '\n)PROC\n /* note, the list must include 'X'\n ver (&zsel,list,D,E,I,R,X)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTEP": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x005\\x01\\x18\\x01/\\x01\\x18\\x01/\\x16#\\x00\\x14\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-01-12T00:00:00", "modifydate": "2018-01-12T16:23:35", "lines": 20, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n /* ISPF command table edit dialog (ISCTE) - prompts panel\n /* Written by Willy Jensen, email willy.h.jensen@outlook.com\n _ type(nef) caps(on)  /* input, color(turq) adjust(left) */\n \" type(nt)  /* normal text, color=green                  */\n ! type(ct)  /* caution text.  color=yellow               */\n)BODY EXPAND(\\\\)\n+\\ \\ISPF command table entry\\ \\+\n\"Cmd =>_ZCMD \\ \\+    +\n+\n+\n+\n+\n   \"&isctep1\n   \"&isctep2\n   \"&isctep3\n   \"&isctep4\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTL": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x18)\\x1f\\x01\\x18)/\\x16C\\x00x\\x00w\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-10-18T00:00:00", "modifydate": "2018-10-19T16:43:41", "lines": 120, "newlines": 119, "modlines": 0, "user": "DVL"}, "text": "/*                                                         REXX\n  List all ispf in-storage command tables\n  Can list command table contents internally.\n  Can call table-edit function.\n\n  Updates\n  2018-10-18  Major rewrite\n*/\n\n parse value copies('0 ',30) with $edit $all lstn alst.0 .\n parse value '' with list\n parse source . . $me .\n\n address ispexec\n \"control errors return\"\n \"vget zscrmaxw\"\n width=zscrmaxw\n if width>160 then width=160\n\n /* determine if called as command handler */\n arg p1,pid,pcmd,ptable,ptext,passtext\n if p1 pcmd='XISPTBL CMD' then Exit PCmdX()\n if p1 pcmd='XISPTBL SEL' then Exit LCmdX()\n\n $pid  = right(left(space(translate(time('l'),' ','.:'),0),10),7)\n table = 'P'$pid\n tliblist=ListTlibs()\n\n /* make list of tables */\n cc=XISP(\"tbcreate\" table \"names(zsel tblname tbllib)\")\n if cc<>0 then exit xmsg('Create work table' cc zerrlm)\n cc=XIsp(\"qtabopen list(alst.)\")\n if cc<>0 then Exit Epilog('QTAB rc' cc zerrlm)\n zsel=''\n do n=1 to alst.0\n   if right(strip(alst.n),4)<>'CMDS' then iterate\n   list=list alst.n\n end\n\n /* make list table, display table */\n do n=1 to words(list)\n   tblname=word(list,n)\n   zerrlm=''\n   tbllib=LocDsn(tliblist,tblname)\n   \"tbadd\" table\n end\n cc=XISPTBL('table('table') panel(ispctl#1)',\n           'proc('$me') id('$pid') sel(s e)',\n           'hdr(ISPF Command Table List) passtext(prim)')\n Exit Epilog()\n\n /* cleanup       */\nEpilog:\n parse arg m,c\n if m<>'' then say m\n cc=XIsp(\"tbend\" table)\n exit word(c 0,1)\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\nISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\nXIsp: zerrlm='';address ispexec arg(1); xisprc=rc; return rc\n\nLocDsn: Procedure\n trace off\n arg list,mbr .\n do n=1 to words(list)\n   dsn=word(list,n)\n   if sysdsn(\"'\"dsn\"(\"mbr\")'\")='OK' then return dsn\n end\n return 'library not located'\n\nListTlibs: Procedure /* locate mbrname in library */\n trace off\n parse value '' with tlqpl tlqbl tlqll tlltype\n address ispexec\n \"qbaselib ISPPROF id(tlqpl)\"\n \"qbaselib ISPTLIB id(tlqbl)\"\n \"qlibdef  ISPTLIB id(tlqll) type(tlLtype)\"\n if tlltype='LIBRARY' then \"qbaselib\" tlqll \"id(tlqll)\"\n tlrtn=space(translate(tlqpl tlqll tlqbl,\" \",\"',\"))\n do n=words(tlrtn) to 1 by -1\n   w=word(tlrtn,n)\n   if left(w,3)='SYS' & substr(w,9,2)='.T' then tlrtn=delword(tlrtn,n,1)\n end\n return tlrtn\n\n/* Primary command subroutine */\nPcmdx:\n exit ispmsg('Invalid command' ptext)\n\n/* Line command subroutine */\nLcmdx:\n \"tbget\" ptable\n err=''\n\n if left(ptable,1)='P' then select /* primary selection */\n   when ptext='S' then,\n     cc=XISPTBL('table('tblname') panel(ispctl#2) width('width')',\n           'proc('$me') sel(s ex) passtext('tblname tbllib')',\n           'hdr(ISPF Command Table' tblname 'in' tbllib')')\n   when ptext='E' & pos('.',tbllib)>0 then cc=Ispcte(tbllib tblname)\n   otherwise err='Y'\n end\n\n else select                       /* secondary selection */\n   when ptext='S' then do\n     parse var passtext tblname tbllib\n     \"display panel(ispctl#3)\"\n   end\n   when ptext='EX' then \"\"zctact\n   otherwise err='Y'\n end\n\n if err='Y' then zsel='?'zsel\n else zsel=''\n \"tbput\" ptable\n exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCTL#1": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x04\\x01\\x18%\\x8f\\x01\\x18)/\\x16A\\x00\\x1b\\x00\\x18\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2018-09-15T00:00:00", "modifydate": "2018-10-19T16:41:04", "lines": 27, "newlines": 24, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n @ type(input)  caps(on) just(left) color(yellow) hilite(uscore)\n # type(input)  caps(on) just(left) color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(blue )\n \u00dd type(output) caps(off) color(green)\n ! type(text)   color(blue ) skip(on)\n + type(text)   color(turq ) skip(on)\n)BODY expand(\\\\)\n%\\ \\ISPF open command table list\\ \\+ +\n%Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n+\n+Line cmds %S!select list\n+\n%Sl Name      Library\n)MODEL clear(zsel)\n#z \u00ddtblname +\u00a8tbllib \\ \\+ +\n)INIT\n .zvars = '(zsel)'\n)PROC\n &athcsrrw = .csrrow\n &key     = .pfkey\n &csrpos  = .csrpos\n &cursor  = .cursor\n Ver (&zsel,list,S,E)\n /* Ver (&zcmd,list,ZZZZZZZZZ)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCTL#2": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00D\\x01\\x18%\\x8f\\x01\\x18)\\x1f\\x174\\x00\\x1b\\x00\\x17\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2018-09-15T00:00:00", "modifydate": "2018-10-18T17:34:44", "lines": 27, "newlines": 23, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n @ type(input)  caps(on) just(left) color(yellow) hilite(uscore)\n # type(input)  caps(on) just(left) color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(blue )\n \u00dd type(output) caps(off) color(green)\n + type(text)   color(turq ) skip(on)\n ! type(text)   color(blue ) skip(on)\n)BODY expand(\\\\) width(&zscrmaxw)\n%&athhdr\n%Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n+\n+Line cmds %S!display entry %EX!execute command\n+\n%Sl Name     Description\\ \\ Command\\ \\+\n)MODEL clear(zsel)\n#z \u00ddzctverb \u00a8zctdesc    \\ \\\u00a8zctact \\ \\+\n)INIT\n .zvars = '(zsel)'\n)PROC\n &athcsrrw = .csrrow\n &key     = .pfkey\n &csrpos  = .csrpos\n &cursor  = .cursor\n Ver (&zsel,list,S,X,EX)\n Ver (&zcmd,list,ZZZZZZZZZ)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCTL#3": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x009\\x01\\x18%\\x8f\\x01\\x18)\\x1f\\x17!\\x00\\x15\\x00\\x15\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-09-15T00:00:00", "modifydate": "2018-10-18T17:21:39", "lines": 21, "newlines": 21, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n @ type(input)  caps(on) just(left) color(yellow) hilite(uscore)\n # type(input)  caps(on) just(left) color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(blue )\n \u00dd type(input ) caps(off) color(green)\n ! type(text)   color(green) skip(on)\n + type(text)   color(turq ) skip(on)\n)BODY expand(\\\\)\n%\\ \\ISPF command table entry\\ \\+ +\n%Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n+\n%Table name &tblname in &tbllib\n+\n!Verb   \u00a8zctverb +\n!Trunc  \u00a8zcttrunc+\n!Desc   \u00a8zctdesc  \\ \\+ +\n!Command\u00a8zctact   \\ \\+ +\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPCTL@": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x001\\x01\\x18'_\\x01\\x18)/\\x16 \\x00\\t\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2018-10-02T00:00:00", "modifydate": "2018-10-19T16:20:31", "lines": 9, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": ")F  ISPCTL - List open ISPF command tables\n\nThe  ISPCTL dialog  lists the  open command  tables. You  can then\nselect view or edit of a single table.\n Note that a  table may me listed even though  it is not viewable,\nthis  can happen  if the  table has  been opened  from a  LIBDEF'd\nlibrary in another screen.\n)X\n)O\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XISPTBD1": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x04\\x01\\x17#\\x0f\\x01\\x18&_\\x14V\\x00.\\x005\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2017-08-18T00:00:00", "modifydate": "2018-09-22T14:56:04", "lines": 46, "newlines": 53, "modlines": 0, "user": "DVL"}, "text": " /*----------------------------------------------------------------rexx\n   XISPTBL table subroutine demo 1\n   Simple case, display table, allow all built-in commands\n --------------------------------------------------------------------*/\n\n /* initiaization */\n $table= 'T'right(left(space(translate(time('l'),' ','.:'),0),10),7)\n Address ispexec\n \"control errors return\"\n\n \"tbend\" $table\n zerrlm=''\n \"tbcreate\" $table \"names(zsel data) nowrite share\"\n if rc<>0 then exit xmsg('table create rc' rc zerrlm,8)\n\n /* populate table */\n zz=outtrap('lst.')\n Address TSO \"listalc\"\n zz=outtrap('off')\n zsel=''\n t.=''                                 /* drop non-unique */\n do n=1 to lst.0\n   data=strip(lst.n)\n   if t.data<>'',\n   |  data='NULLFILE' | data='TERMFILE',\n   |  right(data,1)='?' then iterate\n   \"tbadd\" $table\n   if rc>0 then call xreturn 'tbadd failed' rc zerrlm\n   t.data='x'\n end\n drop t.\n\n /* call driver, using both list and detail panels */\n  cc=XISPTBL('table('$table') panel(xisptbll) dpanel(xisptbld)',\n     'hdr(Table driver demo 1) width(80) isel(all) crc(1)',\n     'sort(=) icmd(sort)')\n if cc=8 then say 'Cancelled'\n if cc=1 then say 'List has been changed'\n\n /* cleanup and terminate */\n Call XReturn 'Done'\n\nXReturn:\n address ispexec \"tbend\" $table\n Exit xmsg(arg(1),arg(2))\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBD2": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00$\\x01\\x18&O\\x01\\x18)/\\x17\\x15\\x00Q\\x009\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2018-09-21T00:00:00", "modifydate": "2018-10-19T17:15:24", "lines": 81, "newlines": 57, "modlines": 0, "user": "DVL"}, "text": " /*----------------------------------------------------------------rexx\n   XISPTBL table subroutine demo 2\n   Call external routine (actually self) to handle primary- and\n   line commands.\n --------------------------------------------------------------------*/\n\n /* initiaization */\n parse source . . $me .\n $pid  = right(left(space(translate(time('l'),' ','.:'),0),10),7)\n $table= 'T'$pid\n Address ispexec\n \"control errors return\"\n\n /* determine if called as command handler */\n arg p1,pid,pcmd,ptable,ptext\n if p1 pcmd='XISPTBL CMD' then Exit PCmdX()\n if p1 pcmd='XISPTBL SEL' then Exit LCmdX()\n\n /* Mainline */\n \"tbend\" $table\n \"tbcreate\" $table \"names(zsel data) nowrite share\"\n if rc<>0 then exit xmsg('table create rc' rc,8)\n\n /* populate table */\n zz=outtrap('lst.')\n Address TSO \"listalc\"\n zz=outtrap('off')\n zsel=''\n t.=''                       /* drop non-unique */\n do n=1 to lst.0\n   data=strip(lst.n)\n   if t.data<>'',\n   |  data='NULLFILE' | data='TERMFILE',\n   |  right(data,1)='?' then iterate\n   \"tbadd\" $table\n   if rc>0 then call xreturn 'tbadd failed' rc zerrlm\n   t.data='x'\n end\n drop t.\n\n /* call driver, list panel only */\n cc=XISPTBL('table('$table') panel(xisptbll) width(80)',\n           'proc('$me') id('$pid') sel(s e v) hdr(Table driver demo 2)',\n           'sort(=) icmd(sort) isel(all) dpanel(xisptbld)')\n\n /* cleanup and terminate */\n Call XReturn\n\nXReturn:\n address ispexec \"tbend\" $table\n Exit xmsg(arg(1),arg(2))\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\nISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n\n /*- Line command handlers -*/\nLCmdX:\n \"tbget\" ptable\n err=''\n dsn=strip(data)\n Select\n   when zsel='E' then \"Edit dataset('\"dsn\"')\"\n   when zsel='V' then \"View dataset('\"dsn\"')\"\n   when zsel='S' then do\n     cc=listdsi(\"'\"dsn\"'\")\n     call ispmsg dsn sysvolume sysdsorg syslrecl sysblksize\n   end\n   otherwise err='Y'\n End\n if err='Y' then zsel='?'zsel\n else zsel=''\n \"tbput\" ptable\n exit 0\n\n /*- Primary command handlers -*/\nPCmdX:\n call ispmsg 'Pcmd' ptext 'not implemeted yet'\n exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBL": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00W\\x01\\x174\\x0f\\x01\\x18)\\x1f\\x17C\\x02,\\x01\\xbc\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-12-06T00:00:00", "modifydate": "2018-10-18T17:43:57", "lines": 556, "newlines": 444, "modlines": 0, "user": "DVL"}, "text": " /*                                                                   REXX\n\n  XISPTBL: General ISPF Table Handler - list and manage ISPF table contents\n           Subroutine to be called from other program\n\n  parms: see below\n\n  Return codes\n   00       ok, data may have be changed if CRC parameter is not used.\n   crcval   data changed (value set by the CRC parameter)\n   08   User cancelled process\n  >08   Something very bad happened\n\n  2017-12-11  Opt RETCMD added\n  2017-12-14  point-and-shoot selection added\n  2017-12-21  make work table if original does not have ZSEL var\n  2017-12-23  fix update detection problem\n  2018-01-08  fix problems with details display and with internal copy.\n  2018-01-15  fix problem with change detection\n  2018-01-16  change remaining EXITs to RETURNs\n              change all labels so that XISPTBL can be included in other\n  2018-05-18  add display refresh after TSOX\n  2018-07-17  add ERROR and SYNTAX OFF in a couple of places\n  2018-09-26  add parm WIDTH. add test for valid ISEL values, center header\n  2018-10-18  add parm PASSTEXT - pass text to called pgm.\n\n  Lables and variables are mostly prefixed by 'ath' - A Table Handler.\n\n  Written by Willy Jensen, email willy.h.jensen@outlook.com\n\n */\n parse value '' with athdosort athwtbl athotbl\n vkl='ID TABLE PANEL DPANEL WIDTH PROC SEL ISEL SPROC ICMD CPROC DPROC',\n     'SORT HDR SELVAR SEARCHVAR POPUP CRC RETCMD ASEL', /* valid keywords */\n     'PASSTEXT'\n do n=1 to words(vkl)\n   zz=Value('ATH'word(vkl,n),'')\n end\n cc=AthParser(arg(1),vkl,'ATH')\n if word(cc,1)<>0 then return xmsg(cc)\n upper athsel athisel athselvar\n if athisel='ALL' then athisel='D E I L R S'\n do n=1 to words(athisel)    /* check values */\n   if wordpos(word(athisel,n),'D E I L R S')=0 ,\n         then return AthTblErr('Invalid ISEL value' word(athisel,n),90)\n end\n if athtable  ='' then return AthTblErr('Missing table name',90)\n if athpanel  ='' then return AthTblErr('Missing panel name',90)\n if athproc<>'' then,\n   parse value athproc athproc athproc with athcproc athsproc athdproc\n athuid=right(left(space(translate(time('l'),' ','.:'),0),10),7)\n athasel=translate(word(athasel 'S',1))   /* auto selection char */\n\n /*--------------------------------------------------------------------\n                     Table handler main routine\n --------------------------------------------------------------------*/\n Address ispexec\n parse value copies('0 ',20) with athrc athtdtop athcrp .\n parse value '' with athsell athfind athonly\n \"vget zscrmaxw\"\n Select\n   when datatype(athwidth)='NUM' then nop\n   when athwidth='MAX' then athwidth=zscrmax\n   otherwise athwidth=80\n End\n if athhdr<>'' then athhdr=center(athhdr,athwidth-2)\n athme = 'XISPTBL'\n \"vput (athsel athisel)\"\n\n /* get table info */\n athotbl=athtable\n \"tbquery\" athtable \"names(athonl) keys(athokl) rownum(rows)\"\n if rc<>0 then return AthIspMsg('TBQUERY' zerrlm,8)\n parse value UnPar(athonl','athokl) with athonl','athokl\n athvarl =space(athokl athonl)\n athovarl=athvarl   /* keep original list */\n athvarlnz=athvarl\n n=wordpos('ZSEL',athvarlnz)\n if n>0 then athvarlnz=delword(athvarlnz,n,1)\n\n /* make change base */\n \"tbtop\" athotbl                                /* re-position      */\n interpret,\n   'do n=1 to' rows';\"tbskip\"' athotbl';dbase.n='athvarlnz';end'\n dbase.0=rows\n\n /* make copy table if original does not contain ZSEL var */\n if wordpos('ZSEL',athvarl)=0 then do  /* make copy */\n   athtable='W'athuid\n   If AthIspCmd(\"tbcreate\" athtable \"keys(\"athokl\") names(zsel \"athonl\")\",0),\n     then return 12\n   Call AthTblCopy athotbl athtable\n   \"tbquery\" athtable \"names(n) keys(k) rownum(r)\"\n end\n\n /* setup sort opts */\n if athsearchvar='' then athsearchvar = athvarlnz\n if athsort='=' then athsort=athvarlnz\n if athsort<>'' then do\n   s=''\n   do n=1 to words(athsort)\n     if word(athsort,n)<>'ZSEL' then s=s','word(athsort,n)',C,A'\n   end\n   athsort=substr(s,2)\n end\n\n if athicmd<>'' then do    /* initial command */\n   cc=AthTblCmd(athicmd)\n   if cc>=8 then return cc\n end\n\n /* main handler */\n Do athmain$=1 to 999999                          /* forever          */\n   if athdosort='Y' & athsort<>'' then Call AthTblSort\n   athdosort='N'                                  /* sort before show?*/\n   \"tbtop\" athtable                               /* re-position      */\n   if athtdtop<>0 then \"tbskip\" athtable \"number(\"athtdtop\") NOREAD\"\n   zerrlm=''\n   \"tbvclear\" athtable\n   zsel='X'\n   \"tbsarg\"   athtable \"namecond(zsel ne)\"\n   athcsrrw=''\n   if athpopup='Y' then \"addpop\"\n   \"tbquery\"  athtable \"rownum(athrown)\"\n   \"tbdispl\"  athtable \"panel(\"athpanel\")\",        /* stack selection 1*/\n            \"rowid(athrowid) position(athcrp)\"    /* return csr and id*/\n   drc=rc\n   if athpopup='Y' then \"rempop\"\n   /* athrowid   - will contain a number that uniquely identifies the\n                   row being accessed\n      athcrp     - will contain the row number pointed to by the crp\n   */\n   if drc>8 then,\n     return AthTblErr('Table display' athpanel 'rc' drc)+AthEpilog(drc)\n   if drc=8 then return AthEpilog()                /* END / RETURN     */\n\n   athtdtop=ztdtop                                /* save 1st displayd*/\n\n   /* handle primary commands */\n   if zcmd<>'' then do\n     if AthAbrList(zcmd,athretcmd) then return abbrlistv\n     cc=AthTblCmd(zcmd)\n     if cc>=8 then Return AthEpilog(cc)\n     iterate athmain$\n   end\n\n   /* save row selections */\n   zselsave=''\n   If athcsrrw<>'' & ztdsels=0 & athcsrrw<>0 then do  /* sel by cursor */\n     \"tbtop\"  athtable\n     \"tbskip\" athtable \"number(\"athcsrrw\") rowid(athsell)\"\n     parse value athasel athasel with zsel zselsave\n     \"tbput\" athtable   /* rewrite data */\n   End\n   Else do athseln=1 to ztdsels\n     if athseln>1 then \"tbdispl\" athtable \"rowid(athrowid) position(athcrp)\"\n     if zsel='=' then zsel=zselsave\n     else if zsel<>'' then zselsave=zsel\n     \"tbput\" athtable   /* rewrite data */\n     if zsel<>'' & wordpos(athrowid+0,athsell)=0 then,\n       athsell=athsell athrowid+0\n   End\n\n   /* process row selections */\n   Do while athsell<>''\n     athrowid=word(athsell,1)\n     \"tbskip\" athtable \"row(\"athrowid\")\"\n     parse value '' with athpnlhi\n     athzsel=zsel\n     Select\n       when zsel='' then nop\n       when left(zsel,1)='?' then iterate athmain$\n       when zsel='X' then NOP\n       when wordpos(zsel,athselvar)>0 then do\n         if value(word(athselvar,wordpos(zsel,athselvar)+1))<>'' then,\n            zz=AthRunCmd(value(word(athselvar,wordpos(zsel,athselvar)+1))),\n              +AthTblSetSel('')\n       end\n       when wordpos(zsel,athsel)>0 & athsproc<>'' then do\n         Interpret,\n           \"cc=\"athsproc\"('\"athme\"','\"athid\"','SEL','\"athtable\"','\"zsel\"'\",\n             || \",'\"athpasstext\"')\"\n         if cc=0 & queued()>0 then return AthEpilog(0)\n         if cc>4 then return AthEpilog(cc)\n       end\n       when wordpos(zsel,athisel)>0 then Interpret \"cc=AthTblEdit\"zsel\"()\"\n       otherwise do\n         call AthIspMsg zsel 'is not a valid line command'\n         call AthTblSetSel('?'zsel)\n         iterate athmain$\n       end\n     End\n     athsell=subword(athsell,2)\n   End\n end\n Return AthEpilog(athrc)\n\n/* processing done at final return */\nAthEpilog: /* parm: rc */\n $ischg=AthChkChg()\n if athotbl<>athtable then do   /* rewrite original tale if needed */\n   if $ischg then do  /* change detected */\n     \"tbquery\" athotbl \"rownum($rows)\"\n     \"tbbottom\" athotbl\n     do $rows /* clear table */\n       \"tbdelete\" athotbl\n     end\n     Call AthTblCopy athtable athotbl\n   end\n   \"tbend\" athtable\n end\n if arg(1)>=8 then return arg(1)\n if $ischg & athcrc<>'' then return athcrc  /* change detected */\n return word(arg(1) 0,1)\n\n /* set changed rc  */\nAthChkChg:\n \"tbquery\" athtable \"rownum(ccrows)\"\n if ccrows<>dbase.0 then return 1\n \"tbtop\" athotbl\n Interpret,\n 'do n=1 to' ccrows';',\n   '\"tbskip\"' athtable';',\n   'if dbase.n<>'athvarlnz 'then return 1;',\n 'end'\n return 0\n\n/* handle primary commands */\nAthTblCmd:\n arg athpcmd\n parse var athpcmd athpcverb athpcdata\n Select\n   when Abbrev('CANCEL',athpcmd,3)   then return 8\n   when Abbrev('RESET', athpcmd,3)   then call AthTblReset\n   when Abbrev('FIND',  athpcverb,1) then call AthTblFind athpcdata\n   when Abbrev('ONLY',  athpcverb,1) then call AthTblOnly athpcdata\n   when athpcverb = 'ALL'            then call AthTblReset\n   when athpcverb = 'SORT' & athsort<>'' then call AthTblSort\n   when athpcverb = 'EDIT' then \"Edit dataset(\"requote(athpcdata)\")\"\n   when athpcverb='X' | Abbrev('EXCLUDE',athpverb,3) then,\n        call AthTblExcl athpcdata\n   when athpcverb = 'NEW' & wordpos('I',athisel)>0 then Call AthTblInsertRow\n   when athcproc<>'' then do\n     Signal on error  name AthTblCmdErr\n     Signal on syntax name AthTblCmdSyn\n     Interpret,\n       \"cc=\"athcproc\"('\"athme\"','\"athid\"','CMD','\"athtable\"'\",\n       ||  \",'\"strip(translate(zcmd,\" \",\"'\"))\"','\"athpasstext\"')\"\n     Signal off error\n     Signal off syntax\n     Select\n       when cc='ALL'          then call AthTblAll\n       when word(cc,1)='ONLY' then zz=AthTblAll()+AthTblOnly(subword(cc,2))\n       when word(cc,1)='EXCL' then zz=AthTblAll()+AthTblExcl(subword(cc,2))\n       when cc>4 then return cc\n       when cc=1 then athtdtop=0    /* view from top */\n       otherwise return 0\n     end\n   end\n   otherwise call AthIspMsg 'Invalid command:' athpcmd\n End\n return 0\nAthTblCmdErr:\n Signal off error\n Signal off syntax\n say 'XISPTBL error' rc 'in line' sigl\n return 0\nAthTblCmdSyn:\n Signal off error\n Signal off syntax\n say 'XISPTBL syntax' rc 'in line' sigl':' \"ERRORTEXT\"(rc)\n return 0\n\nAthTblErr:\n if arg(1)<>'' then say arg(1) zerrlm\n if arg(2)<>'' then athrc=arg(2)\n Return word(arg(2) 0,1)\n\nAthTblSetSel:\n zsel=arg(1)\n \"tbput\" word(arg(2) athtable,1)\n return rc\n\n /*-------------------------------------------------------------------\n                           table functions\n --------------------------------------------------------------------*/\nAthTblAll:\nAthTblReset:\n \"tbtop\"    athtable\n do forever\n   zsel=''\n   \"tbscan\" athtable \"arglist(zsel) condlist(NE)\"\n   if rc<>0 then leave\n   zsel=''\n   \"tbput\"  athtable\n end\n parse value 0 with athtdtop athsell\n Return 0\n\nAthTblFind: /* copy row with text */\n if arg(1)<>'' then arg athfind\n if athfind='' then return AthIspMsg('No find arg set')\n \"tbskip\" athtable \"row(\"athtdtop\") noread\" /* position   */\n Do forever\n   \"tbskip\" athtable \"rowid(#)\"\n   if rc<>0 then return AthIspMsg('No match for' athfind)\n   if zsel='X' then iterate\n   Interpret \"n=pos(athfind,translate(\"athsearchvar\"))\"\n   if n>0 then leave\n End\n athtdtop=#\n Return 0\n\nAthTblOnly: /* show only lines with text */\n arg athonly\n if athonly='' then return AthIspMsg('No ONLY arg set')\n Call AthTblReset\n athonlyn=0\n \"tbtop\"  athtable\n do forever\n   \"tbskip\" athtable\n   if rc<>0 then leave\n   Interpret \"n=pos(athonly,translate(\"athsearchvar\"))\"\n   if n=0 then do\n     zsel='X'\n     \"tbput\"  athtable\n   end\n   else athonlyn=athonlyn+1\n End\n athtdtop=0\n call AthIspMsg athonlyn 'records with match'\n Return 0\n\nAthTblExcl: /* suppress lines with text */\n arg athexcl\n if athexcl='' then return AthIspMsg('No excl arg set')\n athexcln=0\n \"tbtop\"  athtable\n do forever\n   \"tbskip\" athtable\n   if rc<>0 then leave\n   Interpret \"n=pos(athexcl,translate(\"athsearchvar\"))\"\n   if n>0 then do\n     zsel='X'\n     \"tbput\"  athtable\n     athexcln=athexcln+1\n   end\n End\n athtdtop=0\n call AthIspMsg athexcln 'records excluded'\n Return 0\n\nAthTblSort: /* sort */\n zerrlm=''\n \"tbsort\" athtable \"fields(\"athsort\")\"\n if rc<>0 then return AthIspMsg('SORT error rc' rc zerrlm)\n athtdtop=0\n return 0\n\n /*--------------------------------------------------------------------\n                        Table edit functions\n --------------------------------------------------------------------*/\nAthTblListRow:\nAthTblShowRow:\nAthTblEditL:  /* list table row (detail list) */\nAthTblEditS:  /* show table row (detail list) */\ntrace off\n Call AthTblSetSel      /* clear zsel */\n if athdpanel<>'' then do\n   athpnlac ='OUTPUT'\n   athpnltx =''\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc >8 then Return AthIspMsg('Panel' athdpanel 'display error rc' rc)\n end\n Return 0\n\nAthTblDeleteRow:\nAthTblEditD:  /* delete table row */\ntrace off\n Call AthTblSetSel      /* clear zsel */\n if athdpanel<>'' then do\n   athpnlac ='OUTPUT'\n   athpnltx ='Hit ENTER to delete record, enter CANcel to abort'\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc >8 then Return AthIspMsg('Panel' athdpanel 'display error rc' rc)\n   if rc<>0 then Return AthIspMsg('Row delete aborted')\n end\n Return AthIspCmd(\"tbdelete\" athtable,,,'Delete failed')\n\nAthTblEditRow:\nAthTblEditE:  /* edit table row   */\ntrace off\n if athdpanel='' then return AthIspMsg('DPANEL is required for EDIT')\n Call AthTblSetSel      /* clear zsel */\n athwtbl='W'athuid\n parse value 'INPUT USCORE' with athpnlac athpnlhi\n athpnltx = word(arg(1) 'Edit',1) 'record, enter CANcel to discard changes'\n do forever\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc>8 then Return AthIspMsg('Panel' athdpanel 'rc' rc zerrlm)\n   if abbrev('CANCEL',zcmd,3) then Return AthIspMsg('Updates aborted',4)\n   if rc=8 then Return AthIspCmd(\"tbput\" athtable)\n   if zcmd<>'' then do\n     /* run command with copy of table row*/\n     if athdproc<>'' then do\n       \"tbcreate\" athwtbl \"names(\"athvarl\") nowrite share\"\n       \"tbadd\" athwtbl\n       Interpret,\n         \"cc=\"athdproc\"('\"athme\"','\"athid\"','DTL','\"athwtbl\"','\"zcmd\"')\"\n       if cc=0 then do\n         \"tbget\" athwtbl\n         \"tbput\" athtable\n       end\n       \"tbend\" athwtbl\n     end\n     else zz=AthIspMsg('Invalid command' zcmd)\n   end\n end\n Return 0\n\nAthTblInsertRow:\nAthTblEditI:  /* insert table row */\n Call AthTblSetSel      /* clear zsel */\n \"tbvclear\" athtable\n \"tbadd\" athtable\n if athdpanel='' then return 0\n if AthTblEditRow('Insert')<>0 then return AthIspCmd(\"tbdelete\" athtable)\n /* drop row if all fields are null\n \"tbquery\" athtable \"names(n) keys(k)\"\n n=space(translate(n k,' ','()'))\n p=wordpos('ZSEL',n)\n if p>0 then n =delword(n,p,1)\n interpret 'if' n '=\"\" then return AthIspCmd(\"tbdelete\"' athtable')' */\n athdosort='Y'\n Return 0\n\nAthTblRepeatRow:\nAthTblEditR:  /* repeat table row */\n Call AthTblSetSel      /* clear zsel */\n \"tbadd\" athtable\n if athdpanel<>'' then do\n   if AthTblEditRow('Repeat')=0 then athdosort='Y'\n   else \"tbdelete\" athtable\n end\n Return 0\n\n /*--------------------------------------------------------------------\n                               other\n --------------------------------------------------------------------*/\nRequote: if arg(1)='' then return '';else return \"'\"Unquote(arg(1))\"'\"\nUnquote: return space(translate(arg(1),\" \",\"'\"),0)\nXMsg: say 'XISPTBL' arg(1); return word(arg(2) 0,1)\nUnPar: return space(translate(arg(1),' ','()'))\n\nAthIspCmd: /* command,rc,msg-ok-prefix,msg-nok-prefix */\n zerrlm=''\n address ispexec arg(1);\n AthIspCmdrc=rc\n AthIspCmdmsg='rc' rc zerrlm\n if rc<>0 & arg(4)<>'' then return AthIspMsg(arg(3) AthIspCmdmsg,rc)\n if rc<>0 then return rc\n if rc= 0 & arg(3)<>'' then return AthIspMsg(arg(3) 'ok')\n return max(word(arg(2) 0,1),AthIspCmdrc)\n\nAthIspMsg:\n trace off\n zedlmsg='XISPTBL' arg(1)\n address ispexec\"setmsg msg(isrz000)\"\n return word(arg(2) 0,1)\n\nAthRunCmd:\ntrace off\n parse value '0 0' with rc result zerrlm\n Select\n   when word(translate(arg(1)),1)='ISPX' then,\n     address ispexec subword(arg(1),2)\n   when wordpos(translate(arg(1)),'EDITROW REPEATROW DELETEROW',\n     'INSERTROW')>0 then Interpret \"Call Table\"arg(1)\n   otherwise do\n     signal on error  name AthRunCmdErr\n     signal on syntax name AthRunCmdErr\n     Select\n       when left(arg(1),1)='%' then address tso arg(1)\n       when word(translate(arg(1)),1)='TSOX' then do\n         address tso subword(arg(1),2)\n         address ispexec 'CONTROL DISPLAY REFRESH'\n       end\n       otherwise Interpret arg(1)\n     End\n     signal off error\n     signal off syntax\n   end\n end\n rc= max(rc,result)\nAthRunCmdErr:\n if rc>8 | rc<0 then say 'Execution error' arg(1) 'RC' rc zerrlm\n signal off error\n signal off syntax\n return 0\n\nAthParser:\ntrace off\n parse arg zpstring,zpvalids,zppfx\n upper zpvalids\n do while zpstring<>''\n   zpstring=strip(zpstring,'b')\n   if zpstring='' then return 0\n   zn=Min(pos('(',zpstring'('),pos(' ',zpstring' '))\n   parse var zpstring zpverb =(zn) zpstring\n   if zpvalids<>'' & wordpos(translate(zpverb),zpvalids)=0 ,\n     then return 1 'Invalid verb' zpverb\n   if left(zpstring' ',1)=' ' then zn=Value(zppfx''zpverb,'Y')\n   else do\n     parse value 1 0 substr(zpstring,2) with zn zp zpstring\n     if left(zpstring,1)=')' then zpstring=' 'zpstring /* null */\n     do until zn<=0\n       zp=Verify(zpstring')','()','M',zp+1)\n       if zp=0 then return 2 'Missing end at' zpstring\n       if substr(zpstring,zp,1)=')' then zn=zn-1\n       else zn=zn+1\n     end\n     parse var zpstring zpdata =(zp) zpstring\n     zn=Value(zppfx''zpverb,strip(zpdata))\n     if left(zpstring,1)=')' then zpstring=substr(zpstring,2)\n   end\n end\n return 0\n\n/* test value against a list of verbs/abbreviations\n   value,list - returns 1: true or 0: false\n   list must include the length of the abbreviation, i.e. NAME(1)\n*/\nAthAbrList: Procedure expose abbrlistv\n arg val,lst\n if wordpos(val,translate(lst,' ','()'))>0 then return 1\n do while lst<>''\n   parse value space(lst) with abbrlistv'('lstl')' lst\n   if lstl<>'' then,\n     if abbrev(abbrlistv,val,lstl) then return 1\n end\n return 0   /* false */\n\nAthTblCopy: Procedure\n arg $ctn1 $ctn2            /* name1,name2 */\n zsel=''\n address ispexec\n \"tbtop\" $ctn1\n \"tbquery\" $ctn1 \"rownum($rows)\"\n do $rows\n   \"tbskip\" $ctn1\n   \"tbadd\"  $ctn2\n end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBL@": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x003\\x01\\x18&\\x9f\\x01\\x18)/\\x17\\x17\\x00\\xb4\\x00\\x8d\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-09-26T00:00:00", "modifydate": "2018-10-19T17:17:33", "lines": 180, "newlines": 141, "modlines": 0, "user": "DVL"}, "text": ")F XISPTBL - Subroutine for ISPF table handling\n\nCallable subroutine  for standard ISPF table  handling. The subroutine\nhas  built-in support  for  filtering, sorting  and  edit -  table-row\ndelete, edit, insert and repeat.\n You can also specify primary-  and linecommands for which an external\nprogram is to be called.\n\nIt is recommended  that the table contains variable  ZSEL, otherwise a\ntemporary table  Wnnnnnnn is  created as  a copy.  Any changes  to the\ntemporary table are copied back to the original.\n\n\nSyntax\n\n rv = XISPTBL(parameters)\n\nParameters\n\n ASEL(value)      Auto-select char. Set zsel to 'value' for\n                  point-and-shoot selected lines. Default is 'S'.\n CRC(value)       Return code to set if changes were made. Default = 0.\n CPROC(name)      Name of program to call for primary commands not\n                  handled internally.\n                  See 'External programs' below for details.\n DPANEL(name)     Optional details panel, displayed for line commands\n                  D, E, I, L and R.\n DPROC(name)      Name of program to call for primary commands from the\n                  details edit panel.\n                  See 'External programs' below for details.\n HDR(text)        List panel header (title). Imbedded paranthesis are\n                  allowed, but must be paired, i.e HDR(just testing(1)).\n ICMD(text)       A command to run before first display, i. e. SORT or\n                  a filter command.\n ISEL(list)       List of line commands to be handled internally. They\n                  must be seperated by at least one blank.\n                  If the DPANEL option is used then the named panel will\n                  be shown, which allows the command to be verified and\n                  aborted.\n                  See Built-in line commands below for details.\n PANEL(name)      Table display panel for showing the list.\n PASSTEXT(text)   Pass 'text' to external procedure(s).\n POPUP            The table display will be shown as a popup panel.\n PROC(name)       Combined CPROC, DPROC and SPROC when the same external\n                  program can be used.\n                  See 'External programs' below for details.\n RETCMD(list)     List of commands causing XISPTBL to terminate, returning\n                  the command. This can be used to redrive the list.\n                  Values in the list may be abbreviated, see\n                  'Abbreviations' below.\n SEARCHVAR(list)  List of variables used for the filter commands. Default\n                  is all the variables.\n SEL(list)        List of line commands to be handled externally. The\n                  PROC or SPROC parameter names the program.\n SELVAR(list)     List of variables containing action to take for a given\n                  selection, see 'The SELVAR feature' section below for\n                  details.\n SORT(list)       List of variable name(s) to use for the SORT command.\n                  If this parameter is not specfied then SORT is not\n                  allowed. The parameter can be an equal sign,\n                  meaning all variables in the table.\n SPROC(list)      Name of program to call for line commands defined\n                  by the SEL parameter.\n                  See 'External programs' below for details.\n TABLE(name)      Name of table containg data.\n\n\nThe SELVAR feature\n\n This feature allows selection commands to be passed in the table,\n instead of having to call an external program.\n The value is a series of doublets: the selection character followed\n by the name of the variable containing the command. The command may\n start with some special values:\n  ISPX text  - Do an ADDRESS ISPEXEC text\n  TSOX text  - Do an ADDRESS TSO text\n Otherwise the text is INTERPRETed.\n Sample:\n   \"tbcreate\" table \"names(zsel dsname cmde cmdb cmdv)\"\n   cmde=\"ISPX edit dataset('\"dsname\"')\"\n   cmdb=\"ISPX browse dataset('\"dsname\"')\"\n   cmdv=\"ISPX view dataset('\"dsname\"')\"\n   \"tbadd\" table\n   cc=XISPTBL('table('table') panel('panel')',\n           'sel(e b v) selvar(e cmde b cmdb v cmdv)')\n\n\nAbbreviations (RETCMD only)\n\n A list of names may contain an abbreviation length in parenthesis,\n like this:  NAME(1) allows 'N' as an abbreviation of 'NAME'.\n\n\nBuilt-in primary commands\n\n Note that the built-in primary commmands cannot be disabled, only\n ammended. Also ISPF commands, built-in and user added, takes\n precedence to XISPTBL primary commands, unless prefixed by >.\n\n ALL               Show all lines.\n CANcel            Return with rc 8. If a temporary table is used,\n                   then it is just dropped.\n END               Return with rc 0. If a temporary table is used,\n                   then changes are applied to the base table.\n eXclude text      Exclude all lines containing 'text'. Note that\n                   the data might not actually be on the display\n                   if the variable containing the data is not in\n                   the screen row model.\n Find text         Find next occurence of 'text'\n NEW               Insert line. The DPANEL parameter is required.\n Only text         Show only rows with 'text'. Note that the data\n                   might not actually be displayed if the variable\n                   is not in the screen row model.\n RESet             Show all lines.\n SORT              Sort lines based on the SORT parmeter.\n\n\nBuilt-in line commands\n\n These are activated by the ISEL parameter.\n Note that the SEL parameters takes precedence over ISEL.\n\n D                 Delete row. If DPANEL parameter is used then the\n                   named panel is shown for confirmation.\n E                 Edit. The DPANEL parameter is required.\n I                 Insert. This also activates the NEW primary command.\n                   The DPANEL parameter is required.\n L                 List row details, requires the DPANEL parameter.\n R                 Repeat row. If DPANEL parameter is used then the\n                   named panel is shown for confirmation.\n                   Repeating a row in a keyed table will cause an error\n                   if the key value(s) is not changed.\n S                 Show - alias of L\n X                 eXclude line from display. Note, this cannot be\n                   changed by the SEL/ISEL operands as eXclude line\n                   is part of the filter feature.\n ALL               All of the above\n\n\nPoint-and-shoot feature\n\n Enter key is pressed with the cursor on a displayed table row with\n empty 'zsel' field. Will use the ASEL value as selection.\n\n\nExternal programs\n\n External  programs are  called when  the 'PROC',  'CPROC', 'DPROC'  or\n 'SPROC' parameter is specified, and  the primary- or linecommand is to\n be handled externally (see the SEL operand).\n\n The program(s) are called with these parameters:\n\n   XISPTBL   Identifies the call as comming from XISPTBL.\n   id        the id option from the XISPTBL call\n   CMD       this is a call for a primary command\n   SEL       this is a call for a line (select) command\n   table     either the table from the XISPTBL call, or a temporary\n             table 'Wnnnnnnn' if the table did not include the ZSEL\n             variable.\n   cmd       the line- or primary command\n   passtext  the value from the 'PASSTEXT' option of the XISPTBL call.\n\n   i.e.\n    linecmd: XISPTBL,8496350,SEL,P8496350,S,PRIM\n    primcmd: XISPTBL,1194206,CMD,P1194206,A B,PRIM\n\n\nOther members\n\n XISPTBD1   Demo  program  - simple  case,  display  table, allow  all\n            built-in commands\n XISPTBD2   Demo program  - call  external routine (actually  self) to\n            handle primary- and line commands.\n XISPTBLD   Sample panel for detail view/edit/delete\n XISPTBLL   Sample panel for listing the table\n\n\n)X\n)O\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBLD": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x17\\x18?\\x01\\x18\\x01?\\x12@\\x00\\x16\\x00\\x16\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-07-02T00:00:00", "modifydate": "2018-01-13T12:40:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n+ type(text) color(green)  skip(on)\n% type(text) color(white)  skip(on)\n\" type(text) color(yellow) skip(on)\n$ type(text  ) color(blue)\n_ type(input   ) color(turq  ) hilite(uscore) caps(on)\n\u00dd type(&athpnlac) color(turq ) hilite(&athpnlhi) caps(on)\n\u00a8 type(&athpnlac) color(turq ) hilite(&athpnlhi) caps(off)\n{ type(&accid  ) color(turq  ) caps(on)\n)BODY EXPAND(\\\\)\n\"\\ \\Table test detail\\ \\+\n%Cmd =>_zcmd \\ \\+  +\n+\n+\n+\n%&athpnltx \\ \\+\n+\n+\n+Data\u00a8data \\ \\+    +\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBLL": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x08\\x01\\x17\\x18?\\x01\\x18&O\\x12Y\\x00\\x1d\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2017-07-02T00:00:00", "modifydate": "2018-09-21T12:59:08", "lines": 29, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n _ type(input)  caps(off) color(turq) hilite(uscore)\n # type(input)  caps(on)  color(turq) hilite(uscore)\n \u00a8 type(output) caps(off) color(green)\n \u00dd type(output) caps(off) color(blue)\n \" type(text)   color(blue ) skip(on)\n + type(text)   color(green) skip(on)\n)BODY expand(\\\\) width(&athwidth)\n\"&athhdr\n+Cmd =>_zcmd \\ \\+Scrl#scrl+\n+\n\"Primary cmds: ALL, CANcel, eXcl text, Only text, RESet, SORT, NEW\n\"Line cmds:    Delete, Edit, Insert, Repeat\n+\n%   Data\n)MODEL ROWS(SCAN)\n#z \u00a8data \\ \\+    +\n)INIT\n .zvars = '(zsel)'\n)PROC\n &athcsrrw = .csrrow\n*REXX (zcmd,athcsrrw)\n if abbrev('CANCEL',translate(zcmd),3) then zcmd='CANCEL'\n*ENDREXX\n if (&zcmd NE 'CANCEL' AND &athcsrrw GT 0)\n   ver (&data,nb)\n   /*  note, the list must include 'X'\n   /* ver (&zsel,list,D,E,I,R,X)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT349/FILE349.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT349", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}