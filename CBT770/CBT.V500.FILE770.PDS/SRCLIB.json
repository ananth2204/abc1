{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "DERU", "INMTNODE": "MFOC", "INMTUID": "DERU", "INMFTIME": "20071025070211000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 3200, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "REXX.CBT.SRCLIB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"REXX.CBT.SRCLIB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3200, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "070298", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x01'", "DS1LSTAR": "b'\\x00\\x03\\n'", "DS1TRBAL": "b']\\x1a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0e \\x00\\x04\\x8a4\\x80'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0e \\x00\\x04\\x8a4\\x80'", "b'P\\xf3\\xe5\\xa8\\x00\\x00\\x025\\x00\\x00\\x029\\x00\\x0e\\x00K'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CBTREX": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00\\x05\\x01\\x07'O\\x01\\x07)\\x8f\\x11U\\x06\\xf9\\x05\\x9c\\x05s\\xc4\\xe8\\xc1\\xc8@@@@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2007-10-01T00:00:00", "modifydate": "2007-10-25T11:55:05", "lines": 1785, "newlines": 1436, "modlines": 1395, "user": "DYAH"}, "text": "zREX  TITLE 'LOCFN: REXX Local function package for zCBT'\n         EJECT\n***********************************************************************\n*                                                                     *\n*                     +---------+                                     *\n*     Module Name  -  | CBTREX  |                                     *\n*                     +---------+                                     *\n*                     Rexx Local Function Package                     *\n*                     to perform automation procedure                 *\n*                     supported by zCBT subsystem                     *\n*                                                                     *\n*     Function -                                                      *\n*                                                                     *\n*     Operating Environment -                                         *\n*        Type              TSO/Rexx program                           *\n*        Min. Auth.        Problem and supervisor state               *\n*                          (some function need supervisor state)      *\n*        Dsp.unit mode     Task                                       *\n*        AMODE             24-bit or 31-bit                           *\n*        XM                PASN=HASN=SASN                             *\n*        ASC mode          Primary                                    *\n*        Interrupt status  Enabled for I/O and Ext. interrupts        *\n*        Locks             No locks held                              *\n*        Control Parm      The SSOB and SSSO control blocks can       *\n*                          reside in storage above 16 megabytes.      *\n*        Recovery          N/A                                        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*     Register Usage -                                                *\n*          R0-R1   -->  System interface                              *\n*          R2-r7   -->  Work registers                                *\n*          r8      -->  Argument table address                        *\n*          r9      -->  EVALBLOCK base address                        *\n*          R10     -->  work register                                 *\n*          R11     -->  COM address                                   *\n*          R12     -->  Main module base address                      *\n*          R13     -->  SVA base address (savearea)                   *\n*          R14     -->  BAS or BASR return address                    *\n*          R15     -->  Return code                                   *\n*                                                                     *\n*     Author -                                                        *\n*          Name     :  Deru Sudibyo                                   *\n*                      Software Architect                             *\n*                                                                     *\n*          Copyright:  (C)2006 Deru Sudibyo                           *\n*                                                                     *\n*                                                                     *\n*     Modification Log -                                              *\n*     +--------+------------+--------+---------------------------+    *\n*     | Date   | Engineer   | V.R.L. | Description               |    *\n*     +--------+------------+--------+---------------------------+    *\n*     |06/12/03| Deru S.    | 1.0.0. | First development         |    *\n*     |        |            |        |                           |    *\n*     |        |            |        |                           |    *\n*     +--------+------------+--------+---------------------------+    *\n*                                                                     *\n***********************************************************************\n         EJECT ,\nCBTREX   @PROLOG esa=370,                                              +\n               amode=31,                                               +\n               rmode=ANY,                                              +\n               rent=YES,entry=NO,                                      +\n               sva=YES,domsave=NO,svainit=NO,                          +\n               breg=R12\n         copy  cbtgblvr\n         entry IRXFUSER\nIRXFUSER ds    0d\n         @rxfdir start,rows=8\n         @rxfdir function,ep=CBTREXSN,dd=STEPLIB,name=CBSYSTEM\n         @rxfdir function,ep=CBTREXXC,dd=STEPLIB,name=CBCMD\n         @rxfdir function,ep=CBTREXST,dd=STEPLIB,name=CBSTATE\n         @rxfdir function,ep=CBTREXSE,dd=STEPLIB,name=CBSET\n         @rxfdir function,ep=CBTREXEV,dd=STEPLIB,name=CBEVENT\n         @rxfdir function,ep=CBTREXWT,dd=STEPLIB,name=CBWAIT\n         @rxfdir function,ep=CBTREXWO,dd=STEPLIB,name=CBWTO\n         @rxfdir function,ep=CBTREXWR,dd=STEPLIB,name=CBWTOR\n         @rxfdir finish\n         using EFPL,R1                 map parameter list\n         using argtable_entry,r8       map argument table entry\n         using EVALBLOCK,r9            map EVALBLOCK\n         using CBTCOM,r11              map COM\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXSN                                         *\n*                                                                     *\n*   Function name  - cbsystem()                                       *\n*                    Extract system name                              *\n*                                                                     *\n*   Function desc  - Return local system name based on CVT info       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXSN @ENTRY breg=(r12),svainit=NO\n         SPACE 2\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         using CVTMAP,r2              CVT addressability\n         l     R2,CVTPTR              Get CVT address\n         mvc   SVAdword,CVTSNAME      get system name\n         drop  r2\n         la    r0,l'SVAdword          record length\n         st    r0,SVAword             hold it on this word\n         mvc   EVALBLOCK_EVLEN,SVAword specify length of result\n         mvc   EVALBLOCK_EVDATA(l'SVAdword),SVAdword put the result\n         xr    r15,r15                set RC = 0\n         @exit keepRC=YES\n         space ,\n         ltorg ,\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXST                                         *\n*                                                                     *\n*   Function name  - cbstate()                                        *\n*                    return state of address space argumented         *\n*                    by jobname                                       *\n*                                                                     *\n*                                                                     *\n*     var = cbstate(jobname)                                          *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*           UP  -- address space is up                                *\n*           DOWN -- address space is down                             *\n*           ERROR_ARGUMENT - no argument or argument length > 8       *\n*           UNAUTHORIZE nnn - authorization not granted               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXST @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n         using PSA,0                  establish PSA map\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    ST_error               no, handle error\n         ch    r3,=h'8'               more than 8?\n         bh    ST_error               yes, handle error\n         mvc   SVAdword,=cl8' '       blanks the area\n         lr    r2,r3                  copy length to reg 2\n         bctr  r3,0                   reduce 1 for ex\n         ex    r3,*+4                 copy source to temp area\n         mvc   SVAdword(*-*),0(r5)      <<executed>>\n         @call Get_auth               require authorization\n         bnz   ST_unauth              leave if error\nST_start equ   *\n         using ASCB,r5                map ASCB\n         l     r5,PSAAOLD             my ASCB\nST_as_loop_fwd equ *\n         icm   r15,b'1111',ASCBJBNI   address of jobname\n         bz    ST_as_ckstc_fwd        go this way if nothing\n         clc   SVAdword,0(r15)        is it match?\n         be    ST_found_job           yes, go this way\n         b     ST_as_next_fwd         no, seek next ascb fwd\nST_as_ckstc_fwd equ *\n         icm   r15,b'1111',ASCBJBNS   address of stcname\n         bz    ST_as_next_fwd         go this way if nothing\n         clc   SVAdword,0(r15)        is it match?\n         be    ST_found_stc           yes, go this way\nST_as_next_fwd equ *\n         icm   r5,b'1111',ASCBFWDP    seek fwd\n         bnz   ST_as_loop_fwd         iterate if exist\n         l     r5,PSAAOLD             my ASCB\n         b     ST_as_next_bwd         skip mine\nST_as_loop_bwd equ *\n         icm   r15,b'1111',ASCBJBNI   address of jobname\n         bz    ST_as_ckstc_bwd        go this way if nothing\n         clc   SVAdword,0(r15)        is it match?\n         be    ST_found_job           yes, go this way\n         b     ST_as_next_bwd         no, seek next ascb fwd\nST_as_ckstc_bwd equ *\n         icm   r15,b'1111',ASCBJBNS   address of stcname\n         bz    ST_as_next_bwd         go this way if nothing\n         clc   SVAdword,0(r15)        is it match?\n         be    ST_found_stc           yes, go this way\nST_as_next_bwd equ *\n         icm   r5,b'1111',ASCBBWDP    seek fwd\n         bnz   ST_as_loop_bwd         iterate if exist\n         mvc   EVALBLOCK_EVDATA(4),=cl4'DOWN'\n         la    r1,4                   true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     ST_done                finish\nST_found_stc equ *\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UP STC ASCB='\n         b     ST_ascb                continue this way\nST_found_job equ *\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UP STC ASCB='\nST_ascb  equ   *\n         st    r5,SVAinword           store ASCB address\n         @call Edit_hex               edit in ebcdic hex\n         mvc   EVALBLOCK_EVDATA+12(8),SVAoutdbwd print it in result var\n         mvc   EVALBLOCK_EVDATA+20(6),=cl6' ASID='\n         xc    SVAinword,SVAinword    clear input\n         mvc   SVAinword+2(2),ASCBASID get asid\n         @call Edit_hex               edit in ebcdic hex\n         mvc   EVALBLOCK_EVDATA+26(4),SVAoutdbwd+4 print in result var\n         mvc   EVALBLOCK_EVDATA+30(15),=cl15' JOBID=**none**'\n         la    r1,45                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   SVAbuf80(8),=cl8' '    clear this buffer\n         iazxjsab READ,ascb=(r5),jobid=SVAbuf80\n         ltr   r15,r15                success?\n         bnz   ST_done                no, just finish it\n         mvc   EVALBLOCK_EVDATA+3(3),SVAbuf80\n         mvc   EVALBLOCK_EVDATA+37(8),SVAbuf80\nST_done  equ   *\n         l     r2,SVAkey              get saved key\n         spka  0(r2)                  restore key\n         modeset mf=(E,SVA_lmprob)    back to problem state\n         b     ST_finish              finish\nST_unauth equ  *\n         cvd   r15,SVAdword           convert RC to packed decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  SVAword,SVAdword       convert to EBCDIC\n         mvi   SVAword,c' '           blank 1st digit\n         la    r1,16                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'\n         mvc   EVALBLOCK_EVDATA+12(4),SVAword\n         b     ST_finish              finish\nST_error equ   *\n         la    r1,14                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'\nST_finish equ  *\n         xr    r15,r15                set RC = 0\nST_exit  equ   *\n         @exit keepRC=YES\n         space ,\n         ltorg ,\n         drop  r5                     reset ASCB mapping\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXWO                                         *\n*                                                                     *\n*   Function name  - cbwto()                                          *\n*                    Issue WTO message                                *\n*                                                                     *\n*                                                                     *\n*     var = cbwto(message_text)                                       *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*           ISSUED - message was issued                               *\n*           ABORTED - message not issued                              *\n*           ERROR_ARGUMENT - no argument specified                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n         using EFPL,R1                map parameter list\nCBTREXWO @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    WO_error               no, handle error\n         ch    r3,=h'126'             more than 126?\n         bh    WO_error               yes, handle error\n         lr    r2,r3                  copy length to reg 2\n         bctr  r3,0                   reduce 1 for ex\n         ex    r3,*+4                 copy source to temp area\n         mvc   SVAbufff+2(*-*),0(r5)   <<executed>>\n         sth   r2,SVAbufff            put length in 1st halfword\n*        mvc   SVAwtobuf(WO_lflen),WO_lform copy wto list form\n         wto   text=SVABufff,mf=(E,SVA_wto)\n         ltr   r15,r15                was it success?\n         bz    WO_success             yes, go this way\n         mvc   EVALBLOCK_EVDATA(7),=cl7'ABORTED'\n         la    r1,7                   true length of result\n         b     WO_done                continue this way\nWO_success equ *\n         mvc   EVALBLOCK_EVDATA(6),=cl6'ISSUED'\n         la    r1,6                   true length of result\nWO_done  equ   *\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     WO_finish              finish\nWO_unauth equ  *\n         cvd   r15,SVAdword           convert RC to packed decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  SVAword,SVAdword       convert to EBCDIC\n         mvi   SVAword,c' '           blank 1st digit\n         la    r1,16                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'\n         mvc   EVALBLOCK_EVDATA+12(4),SVAword\n         b     WO_finish              finish\nWO_error equ   *\n         la    r1,14                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'\nWO_finish equ  *\n         xr    r15,r15                set RC = 0\nWO_exit  equ   *\n         @exit keepRC=YES\n         space ,\n         ltorg ,\nWO_lform DS    0H\n         WTO   TEXT=,ROUTCDE=(1,2,10),desc=(9,11,12),MF=L\nWO_lflen equ   *-WO_lform\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXWR                                         *\n*                                                                     *\n*   Function name  - cbwtor()                                         *\n*                    Issue WTOR message                               *\n*                                                                     *\n*                                                                     *\n*     var = cbwtor(message_text)                                      *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*           reply text - message was issued and got reply             *\n*           ABORTED - message not issued                              *\n*           ERROR_ARGUMENT - no argument specified                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXWR @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    WR_error               no, handle error\n         ch    r3,=h'126'             more than 126?\n         bh    WR_error               yes, handle error\n         lr    r2,r3                  copy length to reg 2\n         bctr  r3,0                   reduce 1 for ex\n         ex    r3,*+4                 copy source to temp area\n         mvc   SVAbufff+2(*-*),0(r5)   <<executed>>\n         sth   r2,SVAbufff            put length in 1st halfword\n         xc    SVAecb,SVAecb          clear ECB\n*        mvc   SVAwtobuf(WR_lflen),WR_lform copy wto list form\n         WTOR  text=(SVAbufff,SVAcard1,54,SVAecb),   Issue WTOR msg    +\n               MF=(E,SVA_wtor),RPLYISUR=SVAlist\n         ltr   r15,r15                was it success?\n         bz    WR_success             yes, go this way\n         mvc   EVALBLOCK_EVDATA(11),=cl11'ABORTED RC='\n         cvd   r15,SVAdword           convert to decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  EVALBLOCK_EVDATA+11(4),SVAdword put in return var\n         la    r1,15                  true length of result\n         b     WR_done                continue this way\nWR_success equ *\n         WAIT  ecb=SVAecb             Wait for reply\n         mvc   EVALBLOCK_EVDATA(6),=cl6'REPLY='\n         mvc   EVALBLOCK_EVDATA+6(54),SVAcard1 get reply message\n         la    r1,60                  true length of result\nWR_done  equ   *\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     WR_finish              finish\nWR_unauth equ  *\n         cvd   r15,SVAdword           convert RC to packed decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  SVAword,SVAdword       convert to EBCDIC\n         mvi   SVAword,c' '           blank 1st digit\n         la    r1,16                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'\n         mvc   EVALBLOCK_EVDATA+12(4),SVAword\n         b     WR_finish              finish\nWR_error equ   *\n         la    r1,14                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'\nWR_finish equ  *\n         xr    r15,r15                set RC = 0\nWR_exit  equ   *\n         @exit keepRC=YES\n         space ,\n         ltorg ,\nWR_lform DS    0H\n         WTOR  TEXT=(,,,),CONSID=,ROUTCDE=(1,2,10),                    +\n               desc=(2,7),RPLYISUR=,MF=L\nWR_lflen equ   *-WR_lform\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXWT                                         *\n*                                                                     *\n*   Function name  - cbwait()                                         *\n*                    Wait for TOD or timer                            *\n*                                                                     *\n*                                                                     *\n*     var = cbwait(waitargument)                                      *\n*                                                                     *\n*     waitargument                                                    *\n*                                                                     *\n*         HH:MM:SS -- wait until HH:MM:SS                             *\n*         +HH:MM:SS -- wait for HH:MM:SS                              *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*           'EXPIRED' - time was expired                              *\n*           'ABORTED' - process not performed                         *\n*           'ERROR_ARGUMENT' - no argument specified                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXWT @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    WT_error               no, handle error\n         ch    r3,=h'9'               more than 9?\n         bh    WT_error               yes, handle error\n         mvi   SVAflags,0             init indicator\n         cli   0(r5),c'+'             is it interval?\n         bne   WT_getparm             no, just get parm\n         mvi   SVAflags,1             yes, indicate it is interval\n         la    r5,1(r5)               skip interval sign\n         bctr  r3,0                   reduce length\nWT_getparm equ *\n         lr    r2,r3                  copy length to reg 2\n         bctr  r2,0                   reduce 1 for ex\n         ex    r2,*+4                 copy source to temp area\n         mvc   SVAbuf80(*-*),0(r5)    <<executed>>\n         la    r15,SVAbuf80(r2)       point to last digit\n         la    r2,1                   init ss converter\n         xr    r5,r5                  init ss accumulator\nWT_parse equ   *\n         mvc   SVAword,=c'0000'       init this word with ebcdic zero\n         la    r14,SVAword+3          point last digit\nWT_get_digit equ *\n         cli   0(r15),c':'            is it delimiter?\n         be    WT_calc                yes, calculate\n         tm    0(r15),c'0'            is it numeric?\n         bno   WT_calc                no, leave it\n         mvc   0(1,r14),0(r15)        get the digit\n         bctr  r15,0                  no, bwd 1 digit source\n         bctr  r14,0                  bwd 1 digit target\n         bct   r3,WT_get_digit        iterate\nWT_calc  equ   *\n         pack  SVAdword,SVAword       pack it\n         cvb   r0,SVAdword            convert it to binary\n         srdl  r0,32                  move to reg 1\n         mr    r0,r2                  convert it to num of second\n         ar    r5,r1                  accumulate ss\n         ch    r2,=h'3600'            is it the last?\n         bl    WT_ck_digit            no, continue this way\n         ltr   r3,r3                  still exist?\n         bnz   WT_error               yes, must be error\nWT_ck_digit equ *\n         mh    r2,=h'60'              set ss converter\n         ltr   r3,r3                  still exist?\n         bz    WT_got_digit           no, go this way\n         bctr  r15,0                  yes, bwd 1 digit source\n         bct   r3,WT_parse            iterate\nWT_got_digit equ *\n         c     r5,=a(24*3600)         is time valid?\n         bh    WT_error               no, handle error\n         mh    r5,=h'100'             convert to centisec\n         cli   SVAflags,1             is it an interval?\n         be    WT_settimer            yes, just set timer\n         time  BIN,SVAtod,zone=LT,    obtain TOD in decimal            +\n               datetype=YYYYMMDD,     date in standard format          +\n               linkage=SYSTEM,mf=(E,SVA_ltime)\n         ltr   r15,r15                check RC\n         bnz   WT_errclock            go this way if error\n         s     r5,SVAtime             calculate interval\n         bc    #cc2,WT_settimer       go this way if > 0\n         b     WT_expired             else, this way\nWT_settimer equ *\n         st    r5,SVAword             place binary timer\n         stimer WAIT,bintvl=SVAword   set timer and wait\nWT_expired equ *\n         lr    r0,r5                  copy binary interval\n         la    r5,100                 set 100\n         srda  r0,32                  move to reg 1\n         dr    r0,r5                  convert back to secs\n         cvd   r1,SVAdword            convert to decimal\n         tm    SVAdword+7,x'0D'       is it negative?\n         bo    WT_negative            yes, this way\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         mvc   EVALBLOCK_EVDATA(12),=cl12'EXPIRED FOR'\n         unpk  EVALBLOCK_EVDATA+12(6),SVAdword put in return var\n         mvc   EVALBLOCK_EVDATA+18(5),=cl5' SECS'\n         la    r1,23                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     WT_finish              finish\nWT_negative equ *\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         mvc   EVALBLOCK_EVDATA(13),=cl13'EXPIRED FOR -'\n         unpk  EVALBLOCK_EVDATA+13(6),SVAdword put in return var\n         mvc   EVALBLOCK_EVDATA+19(5),=cl5' SECS'\n         la    r1,24                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     WT_finish              finish\nWT_errclock equ   *\n         mvc   EVALBLOCK_EVDATA(15),=cl15'ERROR_CLOCK RC='\n         cvd   r15,SVAdword           convert RC to decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  EVALBLOCK_EVDATA+15(4),SVAdword put in return var\n         la    r1,19                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     WT_finish              finish\nWT_error equ   *\n         la    r1,14                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'\nWT_finish equ  *\n         xr    r15,r15                set RC = 0\nWT_exit  equ   *\n         @exit keepRC=YES\n         space ,\n         ltorg ,\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXSE                                         *\n*                                                                     *\n*   Function name  - cbset()                                          *\n*                    set argument to trap event                       *\n*                                                                     *\n*                                                                     *\n*     var = cbset(evtype,evstring,suppression,immed_action)           *\n*                                                                     *\n*     argument:                                                       *\n*                                                                     *\n*         evtype       --> event type (MSG, CMD, EOJ, EOS)            *\n*         evstring     --> event string/text                          *\n*         suppression  --> 'SUPPRESS' (for MSG and CMD only)          *\n*         immed_action --> immediate action:                          *\n*                          'CMD=commandtext'                          *\n*                          'REPLY=replytext'                          *\n*                          'MSG=messagetext'                          *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*         'DONE'         - event parameters were set                  *\n*         'NOTHING'      - when no zCBT data area found               *\n*         'UNAUTHORIZED nnn' - authorization was not granted          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXSE @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n*        sac   0\n         mvi   SVA_trace,SVA_tr_set   indicate this start\n         l     r15,=a(Ev_start)       routine address\n         l     r12,=a(CBTREXEV)       base address\n         br    r15                    go to the routine\n         ltorg ,\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXEV                                         *\n*                                                                     *\n*   Function name  - cbevent()                                        *\n*                    Wait and trap event                              *\n*                                                                     *\n*                                                                     *\n*     var = cbevent(evtype,evstring,suppression,immed_action)         *\n*                                                                     *\n*     argument:                                                       *\n*                                                                     *\n*         evtype       --> event type (MSG, CMD, EOJ, EOS)            *\n*         evstring     --> event string/text                          *\n*         suppression  --> 'SUPPRESS' (for MSG and CMD only)          *\n*         immed_action --> immediate action:                          *\n*                          'CMD=commandtext'                          *\n*                          'REPLY=replytext'                          *\n*                          'MSG=messagetext'                          *\n*                                                                     *\n*     Resulted var can be                                             *\n*                                                                     *\n*         eventinformation:                                           *\n*           CMD --> 'command text'                                    *\n*           MSG --> WTO  -> 'message text'                            *\n*                   WTOR -> '(REPLYID=nn) message text'               *\n*           EOS --> 'JOB=jobname  STEP=stepname SCC=nnn UCC=nnn'      *\n*           EOJ --> 'JOB=jobname  SCC=nnn MAXCC=nnn'                  *\n*                                                                     *\n*         'NOTHING'      - when no zCBT data area found               *\n*         'UNAUTHORIZED nnn' - authorization was not granted          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXEV @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n*        sac   0\n         mvi   SVA_trace,SVA_tr_wait  indicate this start\nEv_start equ   *\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?\n         bne   EV_get_arg             no, get arguments\n         cli   SVA_trace,SVA_tr_wait  is it cbevent() function?\n         bne   EV_error               no, error\n         mvi   SVA_trace,SVA_tr_any   indicate this start\n         @call Get_auth               get authorization\n         bnz   EV_unauth              leave if error\n         @call Access_zCBT            access zCBT data area\n         bnz   EV_zCBTdown            leave it if nothing\n         @call EV_extend              yes, perform extended function\n         bz    EV_unknown             go this way if nothing\n         b     EV_wakeup              else, go this way\n         space ,\n* +---------------------------------------------------+\n* | Get 1st argument: Event type                      |\n* +---------------------------------------------------+\n         space ,\nEV_get_arg equ *\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    EV_error               error if nothing\n         ch    r3,=h'3'               arg 1 length = 3?\n         be    EV_get_type            yes, proceed\n         bl    EV_error               error if < 3\n         cli   3(r5),c' '             only 3 char effective?\n         bne   EV_error               no, error\nEV_get_type equ *\n         mvc   SVAdword,=cl8' '       get blanks\n         oc    SVAdword(3),0(r5)      make type in uppercase\n         clc   =c'MSG',SVAdword       is it for msg event?\n         be    EV_trap_msg            yes, go this way\n         clc   =c'CMD',SVAdword       is it for cmd event?\n         be    EV_trap_cmd            yes, go this way\n         clc   =c'EOS',SVAdword       is it for EOS event?\n         be    EV_trap_eos            yes, go this way\n         clc   =c'EOJ',SVAdword       is it for EOJ event?\n         bne   EV_error               no, error\nEV_trap_eoj equ *\n         mvi   RX_evtype,EVB_ev_eoj   indicate event is eoj\n         la    r14,EV_find_eoj        logic flow switch 0\n         la    r15,EV_init_eoj        logic flow switch 1\n         la    r0,EV_wakeup_eoj       logic flow switch 2\n         b     EV_get_evid            continue get event id/string\nEV_trap_eos equ *\n         mvi   RX_evtype,EVB_ev_eos   indicate event is eos\n         la    r14,EV_find_eos        logic flow switch 0\n         la    r15,EV_init_eos        logic flow switch 1\n         la    r0,EV_wakeup_eos       logic flow switch 2\n         b     EV_get_evid            continue get event id/string\nEV_trap_cmd equ *\n         mvi   RX_evtype,EVB_ev_cmd   indicate event is cmd\n         la    r14,EV_find_cmd        logic flow switch 0\n         la    r15,EV_init_cmd        logic flow switch 1\n         la    r0,EV_wakeup_cmd       logic flow switch 2\n         b     EV_get_evid            continue get event id/string\nEV_trap_msg equ *\n         mvi   RX_evtype,EVB_ev_msg   indicate event is msg\n         la    r14,EV_find_msg        logic flow switch 0\n         la    r15,EV_init_msg        logic flow switch 1\n         la    r0,EV_wakeup_msg       logic flow switch 2\n         space ,\n* +---------------------------------------------------+\n* | Get 2nd argument: Event id/string                 |\n* +---------------------------------------------------+\n         space ,\nEV_get_evid equ *\n         stm   r14,r0,RX_address      set logic flow switches\n         la    r8,argtable_next       seek 2nd argument\n         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?\n         be    EV_error               yes, error\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    EV_error               error if nothing\n         sth   r3,RX_evidlen          if ok, hold it in SVA\n         mvc   RX_evidptr,argtable_argstring_ptr hold the address also\n         space ,\n* +---------------------------------------------------+\n* | Get 3rd argument: suppression option              |\n* +---------------------------------------------------+\n         space ,\n         la    r8,argtable_next       seek 2nd argument\n         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?\n         be    EV_ck_auth             yes, ignore it\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    EV_get_action          ignore if nothing\n         ch    r3,=h'8'               is length = 8?\n         bne   EV_get_action          no, ignore it\n         l     r5,argtable_argstring_ptr pointer of argument\n         clc   =c'SUPPRESS',0(r5)     option = suppress?\n         be    EV_get_supp            yes, take it\n         mvc   SVAdword,=cl8' '       get blanks\n         oc    SVAdword,0(r5)         make it uppercase\n         clc   =c'SUPPRESS',SVAdword  option = suppress?\n         bne   EV_get_action          no, ignore it\nEV_get_supp equ *\n         mvi   RX_option,RX_suppress  yes, remember it\n         space ,\n* +---------------------------------------------------+\n* | Get 4th argument: Immediate action                |\n* +---------------------------------------------------+\n         space ,\nEV_get_action equ *\n         la    r8,argtable_next       seek 2nd argument\n         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?\n         be    EV_ck_auth             ignore if nothing\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    EV_ck_auth             ignore if nothing\n         l     r5,argtable_argstring_ptr pointer of argument\n         mvc   SVAdword,=cl8' '       get blanks\n         oc    SVAdword,0(r5)         make it uppercase\n         clc   =c'CMD=',SVAdword      action = cmd?\n         be    EV_get_accmd           yes, handle it\n         clc   =c'MSG=',SVAdword      action = msg?\n         be    EV_get_acmsg           yes, handle it\n         clc   =c'REPLY=',SVAdword    action = reply?\n         bne   EV_ck_auth             no, ignore it\n         cli   RX_evtype,EVB_ev_msg   is it msg event?\n         bne   EV_ck_auth             no, ignore it\n         mvi   RX_action,EVB_ac_rpy   yes, indicate it\n         la    r0,6                   set keyword length = 6\n         b     EV_got_action          go this way\nEV_get_accmd equ *\n         mvi   RX_action,EVB_ac_cmd   indicate it is cmd\n         la    r0,4                   set keyword length = 4\n         b     EV_got_action          go this way\nEV_get_acmsg equ *\n         mvi   RX_action,EVB_ac_msg   indicate it is msg\n         la    r0,4                   set keyword length = 4\nEV_got_action equ *\n         sr    r3,r0                  adjust to value length\n         bz    EV_ck_auth             ignore if 0\n         bm    EV_ck_auth             ignore if < 0\n         sth   r3,RX_aclen            hold length in SVA\n         ar    r5,r0                  adjust to value position\n         st    r5,RX_acptr            hold address in SVA\n         space ,\n* +---------------------------------------------------+\n* | Validate authorization                            |\n* +---------------------------------------------------+\n         space ,\nEV_ck_auth equ *\n         @call Get_auth               get authorization\n         bnz   EV_unauth              leave if error\n         space ,\n* +---------------------------------------------------+\n* | Begin processing                                  |\n* +---------------------------------------------------+\n         space ,\nEV_begin equ   *\n         @call Access_zCBT            access zCBT data area\n         bnz   EV_zCBTdown            leave it if nothing\n         l     r15,RX_address0        get logic flow switch\n         br    r15                    go follow switch\nEV_find_msg equ *\n         la    r2,COMrex_msg          EVB chain in com for MSG\n         b     EV_find_evb            find chained EVB\nEV_find_cmd equ *\n         la    r2,COMrex_cmd          EVB chain in com for CMD\n         b     EV_find_evb            find chained EVB\nEV_find_eos equ *\n         la    r2,COMrex_eos          EVB chain in com for EOS\n         b     EV_find_evb            find chained EVB\nEV_find_eoj equ *\n         la    r2,COMrex_eoj          EVB chain in com for EOJ\n         space ,\n* +---------------------------------------------------+\n* | Find unused EVB in chain                          |\n* +---------------------------------------------------+\n         space ,\nEV_find_evb equ *\n         using EVBlok,r7              map EVB\n         st    r2,RX_evbcom           hold chain address\n         icm   r7,b'1111',0(r2)       check and establish EVB\n         bz    EV_obtain_evb          no, obtain a new one\nEV_seek_evb equ *\n         tm    EVB_flags,EVB_f_error  is it error entry?\n         bo    EV_found_evb           yes, potentially take it\n         l     r1,EVB_usrascb         address of original ASCB\n         clc   =c'ASCB',ASCBASCB-ASCB(r1) is it correct ASCB?\n         bne   EV_found_evb           no, potentially take it\n         icm   r15,b'1111',ASCBJBNI-ASCB(r1) get jobname (init)\n         bnz   EV_ascb_evb            check it if so\n         icm   r15,b'1111',ASCBJBNS-ASCB(r1) get jobname (STC)\n         bz    EV_found_evb           take it if nothing\nEV_ascb_evb equ *\n         clc   EVB_usrjname,0(r15)    is jobname valid?\n         bne   EV_found_evb           no, potentially take it\n         clc   EVB_usrjname,RX_jobname is it mine?\n         be    EV_my_evb              yes, handle it\n         clc   EVB_usrascb,PSAAOLD    is it on my ASCB?\n         be    EV_found_evb           yes, must be orphan, take it\n         b     EV_next_evb            no, ignore it\nEV_my_evb equ  *\n         clc   EVB_usrascb,PSAAOLD    is it on my ASCB?\n         be    EV_test_evb            yes, test it\n         cli   RX_jobtype,RX_job_job  is it a batch job?\n         be    EV_found_evb           yes, duplication, take it\n         cli   RX_jobtype,RX_job_tsu  is it a TSO user?\n         be    EV_found_evb           yes, duplication, take it\n         b     EV_next_evb            no, must be STC, ignore it\nEV_test_evb equ *\n         clc   EVB_usrtcb,PSATOLD     is it on my TCB?\n         bne   EV_found_evb           no, must be orphan, take it\n         tm    EVB_flags,EVB_f_hold+EVB_f_perm is it held/perm EVB?\n         bnz   EV_next_evb            yes, ignore it\n         tm    EVB_flags,EVB_f_exp    is it expired entry?\n         bo    EV_found_evb           yes, potentially take it\nEV_next_evb equ *\n         icm   r7,b'1111',EVB_evnext  yes, seek next\n         bz    EV_obtain_evb          go this way if no more\n         b     EV_seek_evb            else, iterate\nEV_found_evb equ *\n*        ni    EVB_flags,255-EVB_f_hold-EVB_f_perm clean it\n*        oi    EVB_flags,EVB_f_exp    make it as expired EVB\n         ni    EVB_flags,0            clear all indicators\n         la    r2,EVB_len+EOTinfolen  size of planned EVB\n         st    r7,RX_evbptr           hold EVB in SVA\n         sth   r2,RX_evblen           and also its length\n         mvi   RX_evbtype,RX_evbt_old indicate using old EVB\n         b     EV_init_evb            continue init it\n         space ,\n* +---------------------------------------------------+\n* | Obtain a new EVB                                  |\n* |                                                   |\n* |   - when no unused EVB was found                  |\n* +---------------------------------------------------+\n         space ,\nEV_obtain_evb equ *\n         mvi   RX_evbtype,RX_evbt_new indicate using new EVB\n         la    r2,EVB_len+EOTinfolen  size of planned EVB\n         storage OBTAIN,length=(r2),  obtain storage                   +\n               sp=228,loc=ANY,key=0,  subpool 228 in either CSA/ECSA   +\n               owner=SYSTEM,          owned by system                  +\n               cond=NO                req is unconditional\n         st    r1,RX_evbptr           hold EVB in SVA\n         sth   r2,RX_evblen           and also its length\n         lr    r7,r1                  establish EVB map\n         xc    EVBlok(EVB_len),EVBlok clear EVB\n         space ,\n* +---------------------------------------------------+\n* | Initialize EVB with common information            |\n* +---------------------------------------------------+\n         space ,\nEV_init_evb equ *\n         la    r1,EVB_len(r7)         past end of EVB\n         st    r1,EVB_usrevsrc        hold it for event source copy\n         mvi   EVB_string,c' '        put a blank and roll it\n         mvc   EVB_string+1(l'EVB_string-1),EVB_string to clear it\n         mvi   EVB_supp,0             init suppression option\n         mvc   EVB_evtype,RX_evtype   set event type\n         mvc   EVB_action,RX_action   set immediate action\n         mvc   EVB_usrascb,PSAAOLD    hold ASCB address in EVB\n         mvc   EVB_usrtcb,PSATOLD     hold TCB address in EVB\n         mvc   EVB_usrjname,RX_jobname hold jobname in EVB\n         using CVTMAP,r2              CVT addressability\n         l     R2,CVTPTR              Get CVT address\n         mvc   EVB_sysname,CVTSNAME   get system name\n         drop  r2\n         l     r2,RX_evidptr          event id/string pointer\n         lh    r3,RX_evidlen          and its length\n         l     r15,RX_address1        get logic flow switch\n         br    r15                    go follow switch\n         space ,\n* +---------------------------------------------------+\n* | Initialize EVB for CMD event                      |\n* +---------------------------------------------------+\n         space ,\nEV_init_cmd equ *\n         cli   RX_option,RX_suppress  is suppress option specified?\n         bne   EV_init_eoj            no, straight to txt evaluation\n         mvi   EVB_supp,EVB_supp_cmd  yes, set suppression in EVB\n         b     EV_init_eoj            go this way\n         space ,\n* +---------------------------------------------------+\n* | Initialize EVB for MSG event                      |\n* +---------------------------------------------------+\n         space ,\nEV_init_msg equ *\n         cli   RX_option,RX_suppress  is suppress option specified?\n         bne   EV_init_eoj            no, straight to txt evaluation\n         mvi   EVB_supp,EVB_supp_all  yes, set suppression in EVB\n         space ,\n* +---------------------------------------------------+\n* | Initialize EVB for EOJ event                      |\n* +---------------------------------------------------+\n         space ,\nEV_init_eoj equ *\n         lr    r15,r3                 copy original length\n         bctr  r3,0                   reduce length by 1\n         lr    r1,r3                  copy length into reg 1\n         alr   r3,r2                  address of last byte\n         cli   0(r3),c'*'             is it wild card?\n         bne   EV_gettxt              no, just copy text\n         bctr  r1,0                   reduce again length by 1\n         lr    r15,r1                 adjust original length\nEV_gettxt equ  *\n         ex    r1,*+4                 copy event id/text into EVB\n         mvc   EVB_string(*-*),0(r2)  <<executed>>\n         la    r1,8(r15)              add length of sysname\n         sth   r1,EVB_idlen           hold adjusted length in EVB\n         b     EV_chain               continue this way\n         space ,\n* +---------------------------------------------------+\n* | Initialize EVB for EOS event                      |\n* +---------------------------------------------------+\n         space ,\nEV_init_eos equ *\n         la    r4,EVB_string          address of target\n         la    r15,8                  max length of jobname is 8\n         lr    r1,r2                  copy address of argument\n         la    r14,15                 length of sysname+jobname-1\nEV_seek_jobnm equ *\n         cli   0(r1),c'.'             is it dot?\n         be    EV_get_step            yes, continue get step name\n         mvc   0(1,r4),0(r1)          no, take it\n         la    r4,1(r4)               fwd target\n         la    r1,1(r1)               fwd source\n         bct   r3,EV_seek_jobfwd      continue and adjust length\n         b     EV_got_step            go this way if no more\nEV_seek_jobfwd equ *\n         bct   r15,EV_seek_jobnm      iterate\nEV_get_step equ *\n         bctr  r3,0                   adjust for dot sign\n         la    r1,1(r1)               skip dot\n         la    r4,EVB_string+8        address of target for step name\n         la    r15,8                  max length of stepname is 8\nEV_seek_step equ *\n         cli   0(r1),c'*'             is it dot?\n         be    EV_got_step            yes, continue get step name\n         mvc   0(1,r4),0(r1)          no, take it\n         la    r4,1(r4)               fwd target\n         la    r1,1(r1)               fwd source\n         la    r14,1(r14)             add 1 to counter\n         bct   r3,EV_seek_stepfwd     continue and adjust length\n         b     EV_seek_stepok         go this way if no more\nEV_seek_stepfwd equ *\n         bct   r15,EV_seek_step       iterate\nEV_seek_stepok equ *\n         mvc   EVB_idlen,=y(16+8)     set full length\n         b     EV_chain               continue this way\nEV_got_step equ *\n         sth   r14,EVB_idlen          hold total length-1 in EVB\n         ch    r14,=h'15'             is step argumented?\n         bh    EV_chain               yes, go ahead\n         mvi   EVB_evtype,EVB_ev_eoj  no, change event to eoj\n         la    r0,COMrex_eoj          EVB chain in com for EOJ\n         st    r0,RX_evbcom           hold chain address\n         la    r15,EV_wakeup_eoj      logic flow switch 2\n         st    r15,RX_address2        set logic flow switch 2\n         space ,\n* +---------------------------------------------------+\n* | Chain EVB into existing EVB chain on COM          |\n* |                                                   |\n* |   - only for newly obtained EVB                   |\n* |                                                   |\n* +---------------------------------------------------+\n         space ,\nEV_chain equ   *\n         cli   RX_evbtype,RX_evbt_old is it using old EVB?\n         be    EV_wait                yes, skip chaining\n*        ago   .enq001\n         space ,\n*------------lock-resource--------------------\n         mvc   SVAmajor,=cl8'ZCBTREXX'   resource major name\n         mvc   SVAminor,=cl8'USER-EVB'   resource minor name\n         @call Enqueue_system     lock system\n*------------lock-resource--------------------\n         space ,\n.enq001  anop\n         l     r1,RX_evbcom           EVB chain address in COM\n         icm   r7,b'1111',0(r1)       exist?\n         bnz   EV_chain_fwd           yes, chain it as the last\n         mvc   0(4,r1),RX_evbptr      no, put as 1st chain\n         l     r7,RX_evbptr           back to my EVB\n         b     EV_okchain             then go this way\nEV_chain_fwd equ *\n         lr    r15,r7                 hold this EVB\n         la    r1,EVB_evnext          address of fwd pointer\n         icm   r7,b'1111',EVB_evnext  seek fwd\n         bnz   EV_chain_fwd           iterate until no more\n         mvc   0(4,r1),RX_evbptr      put my EVB as the last\n         l     r7,RX_evbptr           establish my EVB\n         st    r15,EVB_evprev         the last EVB as my prev EVB\n         st    r1,RX_evbcom           update chain pointer\nEV_okchain equ *\n*        ago   .deq001\n         space ,\n*------------unlock-resource--------------------\n         mvc   SVAmajor,=cl8'ZCBTREXX'   resource major name\n         mvc   SVAminor,=cl8'USER-EVB'   resource minor name\n         @call Dequeue_system     unlock system\n*------------unlock-resource--------------------\n         space ,\n.deq001  anop\n*        wto   'zjevent: EVB has been chained.'\n* +---------------------------------------------------+\n* | Entering wait state to wait signal from zCBT      |\n* +---------------------------------------------------+\n         space ,\nEV_wait  equ   *\n         cli   SVA_trace,SVA_tr_set   is it from cbset() function?\n         be    EV_set                 yes, go this way\n         ni    EVB_flags,255-EVB_f_exp-EVB_f_error clear flags\n         cli   EVB_evtype,EVB_ev_eoj  is it for EOJ?\n         bne   EV_sleep               no, skip below\n         oi    EVB_flags,EVB_f_hold   yes, hold it\nEV_sleep equ   *\n         xc    EVB_usrecb,EVB_usrecb  clear ECB\n         mvc   RX_waitnum,=h'1'       num of awaiting ECB must be 1\n         wait  ecb=EVB_usrecb,long=YES, issue wait for signal          +\n               linkage=SYSTEM\n         mvc   EVALBLOCK_EVDATA(15),=cl15'*UNPRESENTABLE*'\n         la    r1,15                  total length of resulted text\n         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length\n         mvc   RX_postnum,=h'1'       num of posted ECB must be 1\nEV_wakeup equ  *\n         lh    r15,RX_waitnum         num of awaiting ECBs\n         bctr  r15,0                  reduce 1\n         sth   r15,RX_waitnum         update it\n         l     r15,RX_address2        get logic flow switch\n         br    r15\n         space ,\n* +---------------------------------------------------+\n* | Wakeup for MSG event                              |\n* +---------------------------------------------------+\n         space ,\nEV_wakeup_msg equ *\n         mvc   EVALBLOCK_EVDATA(4),=cl4'MSG'\n         lh    r14,EVB_usrrplen       reply id length\n         ltr   r14,r14                exist?\n         bz    EV_wakeup_cmd1         no, just take the msg text\n         mvc   EVALBLOCK_EVDATA+4(9),=cl9'(REPLYID='\n         ex    r14,*+4                get replyid\n         mvc   EVALBLOCK_EVDATA+13(*-*),EVB_usrrplid <<executed>>\n         la    r14,EVALBLOCK_EVDATA+13(r14) skip reply id\n         mvi   0(r14),c')'            put close bracket\n         mvi   1(r14),c' '            followed by a blank\n         la    r14,2(r14)             set msg start position\n         l     r1,EVB_usrevsrc        address of event source text\n         lh    r2,0(r1)               length of event source text\n         la    r15,10                 length of prefix+sysname\n         alr   r1,r15                 skip length prefix and sysname\n         slr   r2,r15                 adjust length as well\n         ex    r2,*+4                 get result\n         mvc   0(*-*,r14),0(r1)       <<execute>>\n         la    r15,EVALBLOCK_EVDATA   address data buffer\n         slr   r14,r15                calc length of replyid prefix\n         la    r2,1(r14,r2)           add it to msg text length\n         stcm  r2,b'1111',EVALBLOCK_EVLEN set result length\n         b     EV_action              then go this way\n         space ,\n* +---------------------------------------------------+\n* | Wakeup for CMD event                              |\n* +---------------------------------------------------+\n         space ,\nEV_wakeup_cmd equ *\n         mvc   EVALBLOCK_EVDATA(4),=cl4'CMD'\nEV_wakeup_cmd1 equ *\n         l     r1,EVB_usrevsrc        address of event source text\n         lh    r2,0(r1)               length of event source text\n         la    r15,10                 length of prefix+sysname\n         alr   r1,r15                 skip length prefix and sysname\n         slr   r2,r15                 adjust length as well\n         ex    r2,*+4                 get result\n         mvc   EVALBLOCK_EVDATA+4(*-*),0(r1) <<execute>>\n         la    r2,6(r2)               add 5 for correction\n         stcm  r2,b'1111',EVALBLOCK_EVLEN set result length\n         b     EV_action1             then go this way\n         space ,\n* +---------------------------------------------------+\n* | Wakeup for EOS event                              |\n* +---------------------------------------------------+\n         space ,\nEV_wakeup_eos equ  *\n         using EOTinfo,r6             map EOT info\n         icm   r6,b'1111',EVB_usreot  establish EOT info\n         bz    EV_action1             go this way if nothing\n         mvc   EVALBLOCK_EVDATA(4),=cl4'EOS'\n         mvc   EVALBLOCK_EVDATA+4(4),=cl4'JOB='\n         mvc   EVALBLOCK_EVDATA+8(8),EOTjobname put jobname\n         mvc   EVALBLOCK_EVDATA+16(6),=cl6' STEP='\n         mvc   EVALBLOCK_EVDATA+22(8),EOTjstep  put step name\n         cli   EOTjstep,c' '          is it blank?\n         bne   EV_wakeup_eoscc        no, go ahead\n         mvc   EVALBLOCK_EVDATA+22(8),EOTpstep yes, use proc step name\nEV_wakeup_eoscc equ *\n         mvc   SVAinword,EOTscc       get SCC and UCC\n         @call Edit_hex               edit in ebcdic hex\n         mvc   EVALBLOCK_EVDATA+30(5),=cl5' SCC='\n         mvc   EVALBLOCK_EVDATA+35(3),SVAoutdbwd+1\n         mvc   EVALBLOCK_EVDATA+38(5),=cl5' UCC='\n         mvc   EVALBLOCK_EVDATA+43(3),SVAoutdbwd+5\n         la    r1,46                  total length of resulted text\n         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length\n         b     EV_action1             then go this way\n         space ,\n* +---------------------------------------------------+\n* | Wakeup for EOJ event                              |\n* +---------------------------------------------------+\n         space ,\nEV_wakeup_eoj equ *\n         icm   r6,b'1111',EVB_usreot  establish EOT info\n         bz    EV_action1             go this way if nothing\n         clc   =c'EOTINFO',EOTid      is it valid EOT?\n         be    EV_wkck_eot            yes, go this way\n         clc   =c'NO_EOT ',EOTid      is it simulation from WQE?\n         be    EV_process_eoj         yes, go this way\n         b     EV_unfinish_eoj        else, back to wait state\nEV_wkck_eot equ *\n         cli   EOTttype,EOTttjob      is it EOJ?\n         be    EV_process_eoj         yes, go ahead\n         lh    r0,EOTscc              else, get scc\n         ltr   r0,r0                  is it?\n         bz    *+8                    no, skip below\n         sth   r0,EVB_syscc           hold SCC in EVB\n         lh    r0,EOTucc              get ucc\n         ch    r0,EVB_maxcc           check against max cc\n         bnh   *+8                    skip below if not higher\n         sth   r0,EVB_maxcc           update max cc if it higher\n         mvc   EVB_cc,EOTucc          update user cc\n         using ASCB,r5                map ASCB\n         icm   r5,15,EOTascb          establish ASCB\n         bz    EV_unfinish_eoj        back to wait state if nothing\n         xc    SVAword,SVAword        clear this word\nEV_wkck_ascb equ *\n         clc   =c'ASCB',ASCBASCB      is it correct?\n         bne   EV_process_eoj         no, already eoj\n         icm   r4,b'1111',ASCBJBNI    address of jobname\n         bnz   EV_wkck_jname          check it if exist\n         icm   r4,b'1111',ASCBJBNS    address of STCname\n         bz    EV_process_eoj         process EOJ if nothing\nEV_wkck_jname equ *\n         clc   EOTjobname,0(r4)       is it still consistant?\n         bne   EV_process_eoj         process EOJ if no more\n         la    r0,100                 set 1 sec\n         c     r0,SVAword             was it done before?\n         be    EV_unfinish_eoj        back to wait state if so\n         st    r0,SVAword             save it in this word\n         stimer WAIT,bintvl=SVAword   wait 1 sec\n         b     EV_wkck_ascb           redo from this point\nEV_unfinish_eoj equ *\n         cli   SVA_trace,SVA_tr_any   is it cbevent() call\n         bne   EV_wait                back to wait state if not\n         lh    r15,RX_waitnum         num of awaiting ECBs\n         ltr   r15,r15                exist?\n         bz    EV_wait                back to wait state if nothing\n         mvc   EVALBLOCK_EVDATA(12),=cl12'PENDING EOJ'\n         la    r1,11                  total length of resulted text\n         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length\n         b     EV_cleanup             then leave\nEV_process_eoj equ *\n         mvc   EVALBLOCK_EVDATA(4),=cl4'EOJ'\n         mvc   EVALBLOCK_EVDATA+4(4),=cl4'JOB='\n         mvc   EVALBLOCK_EVDATA+8(8),EOTjobname put jobname\n         mvc   SVAinword(2),EVB_syscc get SCC\n         mvc   SVAinword+2(2),EVB_maxcc and max CC\n         @call Edit_hex               edit in ebcdic hex\n         mvc   EVALBLOCK_EVDATA+16(5),=cl5' SCC='\n         mvc   EVALBLOCK_EVDATA+21(3),SVAoutdbwd+1\n         mvc   EVALBLOCK_EVDATA+24(7),=cl7' MAXCC='\n         mvc   EVALBLOCK_EVDATA+31(3),SVAoutdbwd+5\n         la    r1,34                  total length of resulted text\n         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length\n         b     EV_action1             then go this way\n         space ,\n* +---------------------------------------------------+\n* | Perform immediate action (if any)                 |\n* +---------------------------------------------------+\n         space ,\nEV_action equ  *\n         cli   RX_action,EVB_ac_rpy   is action = reply?\n         be    EV_ac_rpy              yes, handle it\nEV_action1 equ *\n         lh    r1,RX_aclen            get action txt length\n         ltr   r1,r1                  check it\n         bz    EV_cleanup             skip all if nothing\n         sth   r1,SVAbufff            put in this buffer\n         bctr  r1,0                   reduce 1 for ex\n         l     r15,RX_acptr           address of text\n         ex    r1,*+4                 copy text to buffer\n         mvc   SVAbufff+2(*-*),0(r15) <<execute>>\n         cli   RX_action,EVB_ac_msg   is action = msg?\n         be    EV_ac_msg              yes, handle it\n         cli   RX_action,EVB_ac_cmd   is action = cmd?\n         bne   EV_cleanup             otherwise, nop\n         space ,\n* +---------------------------------------------------+\n* | Immediate action: Execute command                 |\n* +---------------------------------------------------+\n         space ,\nEV_ac_cmd equ  *\n         xc    SVAword,SVAword        clear console id\n         la    r2,SVAbufff            address of buffer\n         mgcre TEXT=(R2),             execute cmd in this buffer       +\n               CONSID=SVAword,        issue from this console          +\n               CMDFLAG=NOHCPY,        no hardcopy                      +\n               MF=(E,SVA_lmgcre)      list form in MGCREPL\n         b     EV_cleanup             then, continue this way\n         space ,\n* +---------------------------------------------------+\n* | Immediate action: Reply to current message        |\n* +---------------------------------------------------+\n         space ,\nEV_ac_rpy equ  *\n         mvc   SVAbufff+2(6),=cl6'REPLY' put reply command\n         lh    r1,EVB_usrrplen        reply id length\n         ex    r1,*+4                 get replyid\n         mvc   SVAbufff+8(*-*),EVB_usrrplid <<executed>>\n         la    r1,SVAbufff+8(r1)      pass over reply id\n         mvi   0(r1),c','             put comma\n         la    r1,1(r1)               fwd next byte\n         lh    r15,RX_aclen           reply text length\n         l     r14,RX_acptr           address of reply text\n         ex    r15,*+4                take the text\n         mvc   0(*-*,r1),0(r14)       << executed >>\n         alr   r1,r15                 end of the text\n         la    r0,SVAbufff+2          address of start of buffer\n         slr   r1,r0                  calc length of buffer\n         sth   r1,SVAbufff            put at the 1st 2-byte\n         b     EV_ac_cmd              process as command\n         space ,\n* +---------------------------------------------------+\n* | Immediate action: Issue WTO message               |\n* +---------------------------------------------------+\n         space ,\nEV_ac_msg equ  *\n         mvc   SVAwtobuf(EV_wtolflen),EV_wtolf\n         wto   text=SVAbufff,mf=(E,SVAwtobuf)\n         b     EV_cleanup             then, continue this way\nEV_wtolf  equ  *\n         WTO   TEXT=,ROUTCDE=(1,2,10),desc=(9,11,12),MF=L\nEV_wtolflen equ *-EV_wtolf\n         space ,\n* +---------------------------------------------------+\n* | Cleaning up EVB and other storage areas           |\n* +---------------------------------------------------+\n         ds    0h\nEV_cleanup equ *\n         tm    EVB_flags,EVB_f_perm   is it set permanently?\n         bo    EV_done                yes, leave it\n         tm    EVB_flags,EVB_f_hold   is it being held?\n         bno   EV_purge               no, release it\n         ni    EVB_flags,255-EVB_f_hold yes, no more held\n         b     EV_done                then leave it\nEV_purge equ   *\n         l     r1,RX_evbptr           address of EVB in SVA\n         la    r0,EVB_len+EOTinfolen  and its length\n         storage RELEASE,length=(r0), release storage                  +\n               addr=(r1),sp=228       subpool 228 in either CSA/ECSA\n         b     EV_done                then leave it\n         space ,\n* +---------------------------------------------------+\n* | SET only request - from function cbset()          |\n* +---------------------------------------------------+\n         space ,\nEV_set   equ   *\n         ni    EVB_flags,0            clear all indicators\n         oi    EVB_flags,EVB_f_perm+EVB_f_hold make it permanent\n         xc    EVB_usrecb,EVB_usrecb  clear ECB\n         mvc   EVALBLOCK_EVDATA(7),=cl3'SET'\n         la    r1,3                   true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         b     EV_done                then, leave\n         space ,\n* +---------------------------------------------------+\n* | Unknown request                                   |\n* +---------------------------------------------------+\n         space ,\nEV_unknown equ *\n         mvc   EVALBLOCK_EVDATA(7),=cl7'UNKNOWN'\n         b     EV_leave               then, leave\n         space ,\n* +---------------------------------------------------+\n* | zCBT down - no further action is process          |\n* +---------------------------------------------------+\n         space ,\nEV_zCBTdown equ *\n         mvc   EVALBLOCK_EVDATA(7),=cl7'NOTHING'\nEV_leave equ   *\n         la    r1,7                   true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         space ,\n* +---------------------------------------------------+\n* | Restore PSW key                                   |\n* +---------------------------------------------------+\n         space ,\nEV_done  equ   *\n         l     r2,SVAkey              get saved key\n         spka  0(r2)                  restore key\n         modeset mf=(E,SVA_lmprob)\n         b     EV_finish              finish\n         space ,\n* +---------------------------------------------------+\n* | Authorization failed                              |\n* +---------------------------------------------------+\n         space ,\nEV_unauth equ  *\n         cvd   r15,SVAdword           convert RC to packed decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  SVAword,SVAdword       convert to EBCDIC\n         mvi   SVAword,c' '           blank 1st digit\n         la    r1,16                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'\n         mvc   EVALBLOCK_EVDATA+12(4),SVAword\n         b     EV_finish              finish\n         space ,\n* +---------------------------------------------------+\n* | Error argument                                    |\n* +---------------------------------------------------+\n         space ,\nEV_error equ   *\n         la    r1,14                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'\n         space ,\n* +---------------------------------------------------+\n* | Exit                                              |\n* +---------------------------------------------------+\n         space ,\nEV_finish equ  *\n         xr    r15,r15                set RC = 0\nEV_exit  equ   *\n         @exit keepRC=YES\n         space ,\n         ltorg ,\n         drop  r12                    reset base address\n         eject ,\n* +---------------------------------------------------+\n* | Requires authorization                            |\n* |                                                   |\n* |  o Check the environment.                         |\n* |    - If possible, issue MODESET macro to          |\n* |      get authorization                            |\n* |                                                   |\n* |  o Otherwise, issue SVC 109 with ESR code 212     |\n* |    - This ESR will force system to grant          |\n* |      authorization                                |\n* |                                                   |\n* +---------------------------------------------------+\n         ds    0h\n         using Get_auth,r12           map the routine\nGet_auth equ   *\n         stm   r0,r15,SVAregs         save all regs\n         lr    r12,r15                establish addressability\n         xr    r2,r2                  clear reg 2\n         ipk   0                      save key into reg 2\n         st    r2,SVAkey              save key in SVA\n         TESTAUTH FCTN=1,STATE=YES,KEY=YES,RBLEVEL=1 CHECK AUTH\n         ltr   R15,R15                is this environmant authorized?\n         bnz   Get_auth_esr           no, get authorization\n         modeset mf=(E,SVA_lmsupz)    set supervisor mode with key 0\n         b     Get_auth_done          then complete\nGet_auth_esr equ *\n         xr    r0,r0                  clear reg 0\n         la    r1,1                   set reg 1 to 1\n         la    r15,212                set reg 15 to 212 (ESR code)\n         svc   109                    get authorization\nGet_auth_done equ *\n         lm    r0,r14,SVAregs         restore reg 0-14\n         ltr   r15,r15                generate CC\n         br    r14                    return\n         space ,\n* +---------------------------------------------------+\n* | Prepares Extended cbevent() Function              |\n* |                                                   |\n* |  o Find all chained EVBs which belong to this     |\n* |    address space.  Leave if nothing if found.     |\n* |                                                   |\n* |  o Build ECB list to contain all its EVB_usrecb   |\n* |    fields                                         |\n* |                                                   |\n* |  o Issue WAIT macro                               |\n* |                                                   |\n* |                                                   |\n* +---------------------------------------------------+\n         ds    0h\nEV_extend equ  *\n         stm   r0,r15,SVAregs         save all regs\n         la    r12,EV_extend-Get_auth calculate offset\n         slr   r15,r12                calculate base address\n         lr    r12,r15                establish addressability\n         la    r4,SVAlist             use this buffer for ECB list\n         la    r5,l'SVAlist           length of buffer\n         srl   r5,2                   divided by 4 = num of ECB slots\n         xr    r15,r15                init counter\n         xc    SVAlist,SVAlist        clear the list\nEVx_list_msg equ *\n         la    r3,EVx_list_cmd        next is CMD\n         icm   r7,b'1111',COMrex_msg  point to 1st MSG EVB in chain\n         bnz   EVx_list_loop          perform iteration\nEVx_list_cmd equ *\n         la    r3,EVx_list_eoj        next is EOJ\n         icm   r7,b'1111',COMrex_cmd  point to 1st CMD EVB in chain\n         bnz   EVx_list_loop          perform iteration\nEVx_list_eoj equ *\n         la    r3,EVx_list_eos        next is EOJ\n         icm   r7,b'1111',COMrex_eoj  point to 1st EOJ EVB in chain\n         bnz   EVx_list_loop          perform iteration\nEVx_list_eos equ *\n         la    r3,EVx_list_done       next is finish\n         icm   r7,b'1111',COMrex_eos  point to 1st EOS EVB in chain\n         bz    EVx_list_done          leave if nothing\nEVx_list_loop equ *\n         tm    EVB_flags,EVB_f_error  is it error EVB?\n         bo    EVx_list_next          yes, seek next\n         clc   EVB_usrascb,PSAAOLD    is it belong to me?\n         bne   EVx_list_next          no, seek next\n         ni    EVB_flags,255-EVB_f_exp off expiry bit\n         using ECB,r2                 map ECB\n         la    r2,EVB_usrecb          establish ECB\n         ni    ECBCC,255-ECBWAIT      turn wait bit off\n         lr    r1,r4                  hold content of reg 4 in reg 1\n         st    r2,0(r4)               hold it in ECB list?\n         la    r15,1(r15)             add 1 to counter\n         bct   r5,EVx_list_fwd        jump this way along with index\n         b     EVx_list_done          then, leave the loop\nEVx_list_fwd equ *\n         la    r4,4(r4)               fwd to next EVB\nEVx_list_next equ *\n         icm   r7,b'1111',EVB_evnext  search next\n         bnz   EVx_list_loop          iterate\n         br    r3                     go this way if no more\nEVx_list_done equ *\n         sth   r15,RX_waitnum         num of awaiting ECBs\n         ltr   r5,r15                 check counter\n         bz    EVx_finish             leave it if nothing\n         oi    0(r1),x'80'            indicate it is the last slot\nEvx_wait equ   *\n         wait  ECBLIST=SVAlist,long=YES, enter wait state              +\n               linkage=SYSTEM\n         la    r4,SVAlist             address ECB list\nEvx_loop_ecb equ *\n         icm   r2,15,0(r4)            get the ECB\n         bz    Evx_next_ecb           ignore if none (just safeguard)\n         ni    ECBCC,255-ECBWAIT      turn wait bit off\n         tm    ECBCC,ECBPOST          was signal posted?\n         bo    EVx_wakeup             yes, wake up and check ECB\nEvx_next_ecb equ *\n         la    r4,4(r4)               next slot\n         bct   r5,Evx_loop_ecb        iterate\n         xr    r15,r15                if no more, clear reg 15\n         b     EVx_finish             then, finish\n*        b     Evx_wait               back to wait state if no more\nEVx_wakeup equ *\n         lh    r15,RX_postnum         num of posted ECBs\n         la    r15,1(r15)             add 1\n         sth   r15,RX_postnum         update it\n         lr    r7,r2                  address of EVB user's ECB\n         la    r1,EVB_usrecb-EVBlok   calculate offset to ECB\n         slr   r7,r1                  establish this EVB\n         st    r7,SVAregs+4*7         hold it in reg 7 slot\n         st    r7,RX_evbptr           and in SVA\n         xc    EVB_usrecb,EVB_usrecb  clear ECB\n         cli   EVB_evtype,EVB_ev_msg  is it msg event?\n         be    EVx_wakeup_msg         yes, handle it\n         cli   EVB_evtype,EVB_ev_cmd  is it cmd event?\n         be    EVx_wakeup_cmd         yes, handle it\n         cli   EVB_evtype,EVB_ev_eoj  is it eoj event?\n         be    EVx_wakeup_eoj         yes, handle it\n         cli   EVB_evtype,EVB_ev_eos  is it eos event?\n         be    EVx_wakeup_eos         yes, handle it\n         xr    r15,r15                else, clear reg 15\n         b     EVx_finish             then, finish\nEVx_wakeup_msg equ *\n*        wto   'zCBTREX: ----- Wakeup msg ------'\n         l     r15,=a(EV_wakeup_msg)  get msg handler address\n         la    r0,COMrex_msg          msg EVB anchor pointer\n         b     EVx_wakeup_go          then, finish\nEVx_wakeup_cmd equ *\n*        wto   'zCBTREX: ----- Wakeup cmd ------'\n         l     r15,=a(EV_wakeup_cmd)  get cmd handler address\n         la    r0,COMrex_cmd          cmd EVB anchor pointer\n         b     EVx_wakeup_go          then, finish\nEVx_wakeup_eos equ *\n         l     r15,=a(EV_wakeup_eos)  get eos handler address\n         la    r0,COMrex_eos          EOS EVB anchor pointer\n         b     EVx_wakeup_go          then, finish\nEVx_wakeup_eoj equ *\n         l     r15,=a(EV_wakeup_eoj)  get eos handler address\n         la    r0,COMrex_eos          EOJ EVB anchor pointer\nEVx_wakeup_go equ *\n         st    r0,RX_evbcom           chain EVB anchor in SVA\n         xc    RX_aclen,RX_aclen      make sure no immediate action\n         st    r15,RX_address2        save address in SVA\nEVx_finish equ *\n         lm    r0,r14,SVAregs         restore reg 0-14\n         ltr   r15,r15                generate CC\n         br    r14                    return\n         ltorg ,\n         drop  r2                     reset ECB map\n         drop  r7                     reset EVB map\n         drop  r12                    reset base address\n         eject ,\n***********************************************************************\n*                                                                     *\n*   Entry name -     CBTREXXC                                         *\n*                                                                     *\n*   Function name  - cbcmd()                                          *\n*                    Execute console command                          *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nCBTREXXC @ENTRY breg=(r12),svainit=YES\n         SPACE 2\n         l     r8,efplarg             establish arg table entry\n         l     r9,EFPLEVAL            address of EVALBLOCK pointer\n         l     r9,0(r9)               establish EVALBLOCK structure\n         l     r5,argtable_argstring_ptr pointer of argument\n         icm   r3,b'1111',argtable_argstring_length length of argument\n         bz    XC_error               no, handle error\n         lr    r2,r3                  copy length to reg 2\n         bctr  r3,0                   reduce 1 for ex\n         ex    r3,*+4                 copy source to temp area\n         mvc   SVAbuf80+2(*-*),0(r5)    <<executed>>\n         sth   r2,SVAbuf80            put length in 1st halfword\n         @call Get_auth               require authorization\n         bnz   XC_unauth              leave if error\nXC_start equ   *\n         la    r2,SVAbuf80            locate cmd buffer\n         xc    SVAword,SVAword        zap console id to 0\n         mgcre text=(r2),mf=(E,SVA_lmgcre),                            +\n               cmdflag=(NOHCPY),consid=SVAword\n         l     r2,SVAkey              get saved key\n         spka  0(r2)                  restore key\n         modeset mf=(E,SVA_lmprob)    back to problem state\n         la    r1,8                   true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(8),=cl8'ISSUED'\n         xr    r15,r15                set RC = 0\n         b     XC_finish              finish\nXC_unauth equ  *\n         cvd   r15,SVAdword           convert RC to packed decimal\n         oi    SVAdword+7,x'0F'       change sign to ebcdic\n         unpk  SVAword,SVAdword       convert to EBCDIC\n         mvi   SVAword,c' '           blank 1st digit\n         la    r1,16                  true length of result\n         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result\n         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'\n         mvc   EVALBLOCK_EVDATA+12(4),SVAword\n         xr    r15,r15                set RC = 0\n         b     XC_finish              finish\nXC_error equ   *\n         la    r15,8                  set RC = 8\nXC_finish equ  *\n         @exit keepRC=YES\n         space ,\n         cbtinsva base=CBTREXXC       SVA initializer\n         space ,\n*\n*  +------------------------------------------------------------+\n*  | Access zCBT Dataarea                                       |\n*  | --------------------                                       |\n*  |   Retrieve token-paired to find address of COM in common   |\n*  |   storage area (CSA).                                      |\n*  |                                                            |\n*  |   Input:                                                   |\n*  |         n/a                                                |\n*  |                                                            |\n*  |   Output:                                                  |\n*  |                                                            |\n*  |        Reg 11  - Address of COM area                       |\n*  |                  (applicable only when RC in reg 15 is 0)  |\n*  |        Reg 15  - Return code                               |\n*  |                                                            |\n*  |                                                            |\n*  +------------------------------------------------------------+\n*\n         ds    0h\nAccess_zCBT equ *\n         stm   r0,r15,SVAregs           save all regs\n         la    r12,Access_zCBT-CBTREXXC    calculate offset\n         slr   r15,r12                  calc base address\n         lr    r12,r15                  establish addressability\n         ago   .acc001\n         space ,\n*------------lock-resource--------------------\n         mvc   SVAmajor,=cl8'ZCBTSSI'   resource major name\n         mvc   SVAminor,=cl8'COMMAREA'  resource minor name\n         @call Enqueue_system           lock system\n*------------lock-resource--------------------\n         space ,\n.acc001  anop\n         la    r1,IEANT_SYSTEM_LEVEL\n         st    r1,SVAword               set share level\n         mvc   SSI_shrname1,=cl8'&DERSHRID' specify entity name\n         mvc   SSI_shrname2,=cl8'&DERCOMMX' specify entity type\n         xc    SSI_shrtoken,SSI_shrtoken clear token\n         xc    SSI_rcode,SSI_rcode      clear Rcode\n         Call  IEANTRT,(SVAword,SSI_shrname,SSI_shrtoken,SSI_rcode),   +\n               VL,MF=(E,SVA_calllist)\n         ago   .acc002\n         space ,\n*------------unlock-resource------------------\n         mvc   SVAmajor,=cl8'ZCBTSSI'   resource major name\n         mvc   SVAminor,=cl8'COMMAREA'  resource minor name\n         @call Dequeue_system           unlock system\n*------------unlock-resource------------------\n         space ,\n.acc002  anop\n         mvc   SVAregs+4*11(4),SSI_comcb place COM addr in r11 slot\n         mvc   SVAregs+4*15(4),SSI_rcode place RC addr in r11 slot\n         mvi   RX_jobtype,RX_job_job    assume initiated job\n         l     r5,PSAAOLD               current ASCB address\n         icm   r4,15,ASCBJBNI-ASCB(r5)  get jobname address\n         bnz   Access_zCBT_done         go this way if exist\n         mvi   RX_jobtype,RX_job_stc    must be started/mounted/logged\n         icm   r4,15,ASCBJBNS-ASCB(r5)  get STC name address\n         iazxjsab READ,ascb=(r5),jobid=RX_jobid\n         ltr   r15,r15                  success?\n         bnz   Access_zCBT_done         go this way if failed\n         mvc   RX_jobtype,RX_jobid      take 1st byte of jobid\nAccess_zCBT_done equ *\n         mvc   RX_jobname,0(r4)         copy job/user name\n         lm    r0,r15,SVAregs           restore all regs\n         ltr   r15,r15                  generate CC\n         br    r14                      return\n         eject ,\n* +---------------------------------------------------+\n* | Enqueue/Dequeue Services Pool                     |\n* | -----------------------------                     |\n* |                                                   |\n* |   *  Before issueing ENQ, accummulate its         |\n* |      occurrences with similar major and minor     |\n* |      names                                        |\n* |                                                   |\n* |   *  After issueing DEQ, reduces its occurrences  |\n* |      count for with similar major and minor       |\n* |      names                                        |\n* |                                                   |\n* +---------------------------------------------------+\n         space ,\n* +-----------------------------------+\n* | Lock Global Resource              |\n* +-----------------------------------+\n         ds    0h\nEnqueue_system equ *\n         stm   r0,r15,SVArecsv2        save all regs\n         la    r12,Enqueue_system-CBTREXXC  calculate offset from base\n         slr   r15,r12                 calculate base address\n         lr    r12,r15                 establish base addressability\n*------------lock-system-resource--------------------\n         aif   (&derzos).sysenqz\n         enq   (SVAmajor,SVAminor,E,8,SYSTEM), lock the resource       +\n               ret=NONE,mf=(E,SVA_enq)\n         ago   .sysenq\n.sysenqz anop\n         enq   (SVAmajor,SVAminor,E,8,SYSTEM), lock the resource       +\n               ret=NONE,linkage=SYSTEM,mf=(E,SVA_enq)\n.sysenq  anop\n*------------lock-systm-resource--------------------\n         b     Locking_done\n         space ,\n* +-----------------------------------+\n* | Unlock Global Resource            |\n* +-----------------------------------+\n         ds    0h\nDequeue_system equ *\n         stm   r0,r15,SVArecsv2        save all regs\n         la    r12,Dequeue_system-CBTREXXC  calculate offset from base\n         slr   r15,r12                 calculate base address\n         lr    r12,r15                 establish base addressability\n*------------unlock-system-resource------------------\n         aif   (&derzos).sysdeqz\n         deq   (SVAmajor,SVAminor,8,SYSTEM), release the resource      +\n               ret=NONE,mf=(E,SVA_deq)\n         ago   .sysdeq\n.sysdeqz anop\n         deq   (SVAmajor,SVAminor,8,SYSTEM), release the resource      +\n               ret=NONE,linkage=SYSTEM,mf=(E,SVA_deq)\n.sysdeq  anop\n*------------unlock-system-resource------------------\n         b     UnLocking_done\n         space ,\n* +-----------------------------------+\n* | Lock Local Resource               |\n* +-----------------------------------+\n         ds    0h\nEnqueue_local equ *\n         stm   r0,r15,SVArecsv2        save all regs\n         la    r12,Enqueue_local-CBTREXXC  calculate offset from base\n         slr   r15,r12                 calculate base address\n         lr    r12,r15                 establish base addressability\n*------------------lock-local-resouce----------------\n         aif   (&derzos).locenqz\n         enq   (SVAmajor,SVAminor,E,8,STEP),  enqueue for it           +\n               ret=NONE,mf=(E,SVA_enq)\n         ago   .locenq\n.locenqz anop\n         enq   (SVAmajor,SVAminor,E,8,STEP),  enqueue for it           +\n               ret=NONE,linkage=SYSTEM,mf=(E,SVA_enq)\n.locenq  anop\n*------------------lock-local-resouce-----------------\n         b     Locking_done\n         space ,\n* +-----------------------------------+\n* | Unlock Local Resource             |\n* +-----------------------------------+\n         ds    0h\nDequeue_local equ *\n         stm   r0,r15,SVArecsv2        save all regs\n         la    r12,Dequeue_local-CBTREXXC  calculate offset from base\n         slr   r15,r12                 calculate base address\n         lr    r12,r15                 establish base addressability\n*------------------unlock-local-resouce---------------\n         aif   (&derzos).locdeqz\n         deq   (SVAmajor,SVAminor,8,STEP),  release the resource       +\n               ret=NONE,mf=(E,SVA_deq)\n         ago   .locdeq\n.locdeqz anop\n         deq   (SVAmajor,SVAminor,8,STEP),  release the resource       +\n               ret=NONE,linkage=SYSTEM,mf=(E,SVA_deq)\n.locdeq  anop\n*------------------unlock-local-resouce---------------\n         space ,\nUnLocking_done equ *\nLocking_done equ *\n         lm    r0,r14,SVArecsv2        restore reg 0-14\n         br    r14                     return\n         space ,\n*\n*  +--------------------------------------------------------------+\n*  |  Hexadecimal EBCDIC Editor                                   |\n*  |  -------------------------                                   |\n*  |    Input  -  SVAinword   - binary fullword                   |\n*  |    Output -  SVAoutdbwd  - hex EBCDIC printable text         |\n*  |                                                              |\n*  +--------------------------------------------------------------+\n         ds    0h\nEdit_hex equ   *\n         stm   r0,r15,SVArecsv2        save all regs\n         la    r12,Edit_hex-CBTREXXC   calc offset from Retry1\n         slr   r15,r12                 calc base address\n         lr    r12,r15                 establish addressability\n         @edithex input=SVAinword,length=8,output=SVAoutdbwd\n         lm    r0,r15,SVArecsv2        restore all regs\n         br    r14\n         ltorg ,\n         drop  r12                    reset base address\n*\n         SPACE 2\n*--------------------------------------*\n*  zCBT data area                      *\n*--------------------------------------*\n         CBTSVA   ,                    Save area\n         CBTCOM   ,                    Common communication area\n         CBTEVB   ,                    Event definition control block\n         CBTEOT   ,                    End-of-task info control block\n         SPACE 2\n*--------------------------------------*\n*  Rexx data area and control block    *\n*--------------------------------------*\n         IRXARGTB                      Argument table entry map\n         IRXPARMB                      Parameter block map\n         IRXEVALB                      Evalblock map\nEvalblock_length equ *-Evalblock\nEvalblock_dwords equ (*-Evalblock+7)/8\nEVCTLEN  EQU   Evalblock_EVDATA-Evalblock\n         IRXEFPL\n         SPACE 2\n*--------------------------------------*\n*  System data area                    *\n*--------------------------------------*\n         CVT   DSECT=YES\n         IHAECB   ,\n         IHAEPIE  ,\n         IHAASCB  ,\n         IHAASSB  ,\n         IHAPSA   ,\n         IHASTCB  ,\n         IAZJSAB  ,\n         IKJTCB   ,\n         IEANTASM ,\n         IHASDWA  ,\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT770/CBT.V500.FILE770.PDS/SRCLIB.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT770/CBT.V500.FILE770.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}