zREX  TITLE 'LOCFN: REXX Local function package for zCBT'
         EJECT
***********************************************************************
*                                                                     *
*                     +---------+                                     *
*     Module Name  -  | CBTREX  |                                     *
*                     +---------+                                     *
*                     Rexx Local Function Package                     *
*                     to perform automation procedure                 *
*                     supported by zCBT subsystem                     *
*                                                                     *
*     Function -                                                      *
*                                                                     *
*     Operating Environment -                                         *
*        Type              TSO/Rexx program                           *
*        Min. Auth.        Problem and supervisor state               *
*                          (some function need supervisor state)      *
*        Dsp.unit mode     Task                                       *
*        AMODE             24-bit or 31-bit                           *
*        XM                PASN=HASN=SASN                             *
*        ASC mode          Primary                                    *
*        Interrupt status  Enabled for I/O and Ext. interrupts        *
*        Locks             No locks held                              *
*        Control Parm      The SSOB and SSSO control blocks can       *
*                          reside in storage above 16 megabytes.      *
*        Recovery          N/A                                        *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*     Register Usage -                                                *
*          R0-R1   -->  System interface                              *
*          R2-r7   -->  Work registers                                *
*          r8      -->  Argument table address                        *
*          r9      -->  EVALBLOCK base address                        *
*          R10     -->  work register                                 *
*          R11     -->  COM address                                   *
*          R12     -->  Main module base address                      *
*          R13     -->  SVA base address (savearea)                   *
*          R14     -->  BAS or BASR return address                    *
*          R15     -->  Return code                                   *
*                                                                     *
*     Author -                                                        *
*          Name     :  Deru Sudibyo                                   *
*                      Software Architect                             *
*                                                                     *
*          Copyright:  (C)2006 Deru Sudibyo                           *
*                                                                     *
*                                                                     *
*     Modification Log -                                              *
*     +--------+------------+--------+---------------------------+    *
*     | Date   | Engineer   | V.R.L. | Description               |    *
*     +--------+------------+--------+---------------------------+    *
*     |06/12/03| Deru S.    | 1.0.0. | First development         |    *
*     |        |            |        |                           |    *
*     |        |            |        |                           |    *
*     +--------+------------+--------+---------------------------+    *
*                                                                     *
***********************************************************************
         EJECT ,
CBTREX   @PROLOG esa=370,                                              +
               amode=31,                                               +
               rmode=ANY,                                              +
               rent=YES,entry=NO,                                      +
               sva=YES,domsave=NO,svainit=NO,                          +
               breg=R12
         copy  cbtgblvr
         entry IRXFUSER
IRXFUSER ds    0d
         @rxfdir start,rows=8
         @rxfdir function,ep=CBTREXSN,dd=STEPLIB,name=CBSYSTEM
         @rxfdir function,ep=CBTREXXC,dd=STEPLIB,name=CBCMD
         @rxfdir function,ep=CBTREXST,dd=STEPLIB,name=CBSTATE
         @rxfdir function,ep=CBTREXSE,dd=STEPLIB,name=CBSET
         @rxfdir function,ep=CBTREXEV,dd=STEPLIB,name=CBEVENT
         @rxfdir function,ep=CBTREXWT,dd=STEPLIB,name=CBWAIT
         @rxfdir function,ep=CBTREXWO,dd=STEPLIB,name=CBWTO
         @rxfdir function,ep=CBTREXWR,dd=STEPLIB,name=CBWTOR
         @rxfdir finish
         using EFPL,R1                 map parameter list
         using argtable_entry,r8       map argument table entry
         using EVALBLOCK,r9            map EVALBLOCK
         using CBTCOM,r11              map COM
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXSN                                         *
*                                                                     *
*   Function name  - cbsystem()                                       *
*                    Extract system name                              *
*                                                                     *
*   Function desc  - Return local system name based on CVT info       *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXSN @ENTRY breg=(r12),svainit=NO
         SPACE 2
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         using CVTMAP,r2              CVT addressability
         l     R2,CVTPTR              Get CVT address
         mvc   SVAdword,CVTSNAME      get system name
         drop  r2
         la    r0,l'SVAdword          record length
         st    r0,SVAword             hold it on this word
         mvc   EVALBLOCK_EVLEN,SVAword specify length of result
         mvc   EVALBLOCK_EVDATA(l'SVAdword),SVAdword put the result
         xr    r15,r15                set RC = 0
         @exit keepRC=YES
         space ,
         ltorg ,
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXST                                         *
*                                                                     *
*   Function name  - cbstate()                                        *
*                    return state of address space argumented         *
*                    by jobname                                       *
*                                                                     *
*                                                                     *
*     var = cbstate(jobname)                                          *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*           UP  -- address space is up                                *
*           DOWN -- address space is down                             *
*           ERROR_ARGUMENT - no argument or argument length > 8       *
*           UNAUTHORIZE nnn - authorization not granted               *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXST @ENTRY breg=(r12),svainit=YES
         SPACE 2
         using PSA,0                  establish PSA map
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    ST_error               no, handle error
         ch    r3,=h'8'               more than 8?
         bh    ST_error               yes, handle error
         mvc   SVAdword,=cl8' '       blanks the area
         lr    r2,r3                  copy length to reg 2
         bctr  r3,0                   reduce 1 for ex
         ex    r3,*+4                 copy source to temp area
         mvc   SVAdword(*-*),0(r5)      <<executed>>
         @call Get_auth               require authorization
         bnz   ST_unauth              leave if error
ST_start equ   *
         using ASCB,r5                map ASCB
         l     r5,PSAAOLD             my ASCB
ST_as_loop_fwd equ *
         icm   r15,b'1111',ASCBJBNI   address of jobname
         bz    ST_as_ckstc_fwd        go this way if nothing
         clc   SVAdword,0(r15)        is it match?
         be    ST_found_job           yes, go this way
         b     ST_as_next_fwd         no, seek next ascb fwd
ST_as_ckstc_fwd equ *
         icm   r15,b'1111',ASCBJBNS   address of stcname
         bz    ST_as_next_fwd         go this way if nothing
         clc   SVAdword,0(r15)        is it match?
         be    ST_found_stc           yes, go this way
ST_as_next_fwd equ *
         icm   r5,b'1111',ASCBFWDP    seek fwd
         bnz   ST_as_loop_fwd         iterate if exist
         l     r5,PSAAOLD             my ASCB
         b     ST_as_next_bwd         skip mine
ST_as_loop_bwd equ *
         icm   r15,b'1111',ASCBJBNI   address of jobname
         bz    ST_as_ckstc_bwd        go this way if nothing
         clc   SVAdword,0(r15)        is it match?
         be    ST_found_job           yes, go this way
         b     ST_as_next_bwd         no, seek next ascb fwd
ST_as_ckstc_bwd equ *
         icm   r15,b'1111',ASCBJBNS   address of stcname
         bz    ST_as_next_bwd         go this way if nothing
         clc   SVAdword,0(r15)        is it match?
         be    ST_found_stc           yes, go this way
ST_as_next_bwd equ *
         icm   r5,b'1111',ASCBBWDP    seek fwd
         bnz   ST_as_loop_bwd         iterate if exist
         mvc   EVALBLOCK_EVDATA(4),=cl4'DOWN'
         la    r1,4                   true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     ST_done                finish
ST_found_stc equ *
         mvc   EVALBLOCK_EVDATA(12),=cl12'UP STC ASCB='
         b     ST_ascb                continue this way
ST_found_job equ *
         mvc   EVALBLOCK_EVDATA(12),=cl12'UP STC ASCB='
ST_ascb  equ   *
         st    r5,SVAinword           store ASCB address
         @call Edit_hex               edit in ebcdic hex
         mvc   EVALBLOCK_EVDATA+12(8),SVAoutdbwd print it in result var
         mvc   EVALBLOCK_EVDATA+20(6),=cl6' ASID='
         xc    SVAinword,SVAinword    clear input
         mvc   SVAinword+2(2),ASCBASID get asid
         @call Edit_hex               edit in ebcdic hex
         mvc   EVALBLOCK_EVDATA+26(4),SVAoutdbwd+4 print in result var
         mvc   EVALBLOCK_EVDATA+30(15),=cl15' JOBID=**none**'
         la    r1,45                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   SVAbuf80(8),=cl8' '    clear this buffer
         iazxjsab READ,ascb=(r5),jobid=SVAbuf80
         ltr   r15,r15                success?
         bnz   ST_done                no, just finish it
         mvc   EVALBLOCK_EVDATA+3(3),SVAbuf80
         mvc   EVALBLOCK_EVDATA+37(8),SVAbuf80
ST_done  equ   *
         l     r2,SVAkey              get saved key
         spka  0(r2)                  restore key
         modeset mf=(E,SVA_lmprob)    back to problem state
         b     ST_finish              finish
ST_unauth equ  *
         cvd   r15,SVAdword           convert RC to packed decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  SVAword,SVAdword       convert to EBCDIC
         mvi   SVAword,c' '           blank 1st digit
         la    r1,16                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'
         mvc   EVALBLOCK_EVDATA+12(4),SVAword
         b     ST_finish              finish
ST_error equ   *
         la    r1,14                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'
ST_finish equ  *
         xr    r15,r15                set RC = 0
ST_exit  equ   *
         @exit keepRC=YES
         space ,
         ltorg ,
         drop  r5                     reset ASCB mapping
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXWO                                         *
*                                                                     *
*   Function name  - cbwto()                                          *
*                    Issue WTO message                                *
*                                                                     *
*                                                                     *
*     var = cbwto(message_text)                                       *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*           ISSUED - message was issued                               *
*           ABORTED - message not issued                              *
*           ERROR_ARGUMENT - no argument specified                    *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
         using EFPL,R1                map parameter list
CBTREXWO @ENTRY breg=(r12),svainit=YES
         SPACE 2
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    WO_error               no, handle error
         ch    r3,=h'126'             more than 126?
         bh    WO_error               yes, handle error
         lr    r2,r3                  copy length to reg 2
         bctr  r3,0                   reduce 1 for ex
         ex    r3,*+4                 copy source to temp area
         mvc   SVAbufff+2(*-*),0(r5)   <<executed>>
         sth   r2,SVAbufff            put length in 1st halfword
*        mvc   SVAwtobuf(WO_lflen),WO_lform copy wto list form
         wto   text=SVABufff,mf=(E,SVA_wto)
         ltr   r15,r15                was it success?
         bz    WO_success             yes, go this way
         mvc   EVALBLOCK_EVDATA(7),=cl7'ABORTED'
         la    r1,7                   true length of result
         b     WO_done                continue this way
WO_success equ *
         mvc   EVALBLOCK_EVDATA(6),=cl6'ISSUED'
         la    r1,6                   true length of result
WO_done  equ   *
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     WO_finish              finish
WO_unauth equ  *
         cvd   r15,SVAdword           convert RC to packed decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  SVAword,SVAdword       convert to EBCDIC
         mvi   SVAword,c' '           blank 1st digit
         la    r1,16                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'
         mvc   EVALBLOCK_EVDATA+12(4),SVAword
         b     WO_finish              finish
WO_error equ   *
         la    r1,14                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'
WO_finish equ  *
         xr    r15,r15                set RC = 0
WO_exit  equ   *
         @exit keepRC=YES
         space ,
         ltorg ,
WO_lform DS    0H
         WTO   TEXT=,ROUTCDE=(1,2,10),desc=(9,11,12),MF=L
WO_lflen equ   *-WO_lform
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXWR                                         *
*                                                                     *
*   Function name  - cbwtor()                                         *
*                    Issue WTOR message                               *
*                                                                     *
*                                                                     *
*     var = cbwtor(message_text)                                      *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*           reply text - message was issued and got reply             *
*           ABORTED - message not issued                              *
*           ERROR_ARGUMENT - no argument specified                    *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXWR @ENTRY breg=(r12),svainit=YES
         SPACE 2
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    WR_error               no, handle error
         ch    r3,=h'126'             more than 126?
         bh    WR_error               yes, handle error
         lr    r2,r3                  copy length to reg 2
         bctr  r3,0                   reduce 1 for ex
         ex    r3,*+4                 copy source to temp area
         mvc   SVAbufff+2(*-*),0(r5)   <<executed>>
         sth   r2,SVAbufff            put length in 1st halfword
         xc    SVAecb,SVAecb          clear ECB
*        mvc   SVAwtobuf(WR_lflen),WR_lform copy wto list form
         WTOR  text=(SVAbufff,SVAcard1,54,SVAecb),   Issue WTOR msg    +
               MF=(E,SVA_wtor),RPLYISUR=SVAlist
         ltr   r15,r15                was it success?
         bz    WR_success             yes, go this way
         mvc   EVALBLOCK_EVDATA(11),=cl11'ABORTED RC='
         cvd   r15,SVAdword           convert to decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  EVALBLOCK_EVDATA+11(4),SVAdword put in return var
         la    r1,15                  true length of result
         b     WR_done                continue this way
WR_success equ *
         WAIT  ecb=SVAecb             Wait for reply
         mvc   EVALBLOCK_EVDATA(6),=cl6'REPLY='
         mvc   EVALBLOCK_EVDATA+6(54),SVAcard1 get reply message
         la    r1,60                  true length of result
WR_done  equ   *
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     WR_finish              finish
WR_unauth equ  *
         cvd   r15,SVAdword           convert RC to packed decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  SVAword,SVAdword       convert to EBCDIC
         mvi   SVAword,c' '           blank 1st digit
         la    r1,16                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'
         mvc   EVALBLOCK_EVDATA+12(4),SVAword
         b     WR_finish              finish
WR_error equ   *
         la    r1,14                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'
WR_finish equ  *
         xr    r15,r15                set RC = 0
WR_exit  equ   *
         @exit keepRC=YES
         space ,
         ltorg ,
WR_lform DS    0H
         WTOR  TEXT=(,,,),CONSID=,ROUTCDE=(1,2,10),                    +
               desc=(2,7),RPLYISUR=,MF=L
WR_lflen equ   *-WR_lform
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXWT                                         *
*                                                                     *
*   Function name  - cbwait()                                         *
*                    Wait for TOD or timer                            *
*                                                                     *
*                                                                     *
*     var = cbwait(waitargument)                                      *
*                                                                     *
*     waitargument                                                    *
*                                                                     *
*         HH:MM:SS -- wait until HH:MM:SS                             *
*         +HH:MM:SS -- wait for HH:MM:SS                              *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*           'EXPIRED' - time was expired                              *
*           'ABORTED' - process not performed                         *
*           'ERROR_ARGUMENT' - no argument specified                  *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXWT @ENTRY breg=(r12),svainit=YES
         SPACE 2
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    WT_error               no, handle error
         ch    r3,=h'9'               more than 9?
         bh    WT_error               yes, handle error
         mvi   SVAflags,0             init indicator
         cli   0(r5),c'+'             is it interval?
         bne   WT_getparm             no, just get parm
         mvi   SVAflags,1             yes, indicate it is interval
         la    r5,1(r5)               skip interval sign
         bctr  r3,0                   reduce length
WT_getparm equ *
         lr    r2,r3                  copy length to reg 2
         bctr  r2,0                   reduce 1 for ex
         ex    r2,*+4                 copy source to temp area
         mvc   SVAbuf80(*-*),0(r5)    <<executed>>
         la    r15,SVAbuf80(r2)       point to last digit
         la    r2,1                   init ss converter
         xr    r5,r5                  init ss accumulator
WT_parse equ   *
         mvc   SVAword,=c'0000'       init this word with ebcdic zero
         la    r14,SVAword+3          point last digit
WT_get_digit equ *
         cli   0(r15),c':'            is it delimiter?
         be    WT_calc                yes, calculate
         tm    0(r15),c'0'            is it numeric?
         bno   WT_calc                no, leave it
         mvc   0(1,r14),0(r15)        get the digit
         bctr  r15,0                  no, bwd 1 digit source
         bctr  r14,0                  bwd 1 digit target
         bct   r3,WT_get_digit        iterate
WT_calc  equ   *
         pack  SVAdword,SVAword       pack it
         cvb   r0,SVAdword            convert it to binary
         srdl  r0,32                  move to reg 1
         mr    r0,r2                  convert it to num of second
         ar    r5,r1                  accumulate ss
         ch    r2,=h'3600'            is it the last?
         bl    WT_ck_digit            no, continue this way
         ltr   r3,r3                  still exist?
         bnz   WT_error               yes, must be error
WT_ck_digit equ *
         mh    r2,=h'60'              set ss converter
         ltr   r3,r3                  still exist?
         bz    WT_got_digit           no, go this way
         bctr  r15,0                  yes, bwd 1 digit source
         bct   r3,WT_parse            iterate
WT_got_digit equ *
         c     r5,=a(24*3600)         is time valid?
         bh    WT_error               no, handle error
         mh    r5,=h'100'             convert to centisec
         cli   SVAflags,1             is it an interval?
         be    WT_settimer            yes, just set timer
         time  BIN,SVAtod,zone=LT,    obtain TOD in decimal            +
               datetype=YYYYMMDD,     date in standard format          +
               linkage=SYSTEM,mf=(E,SVA_ltime)
         ltr   r15,r15                check RC
         bnz   WT_errclock            go this way if error
         s     r5,SVAtime             calculate interval
         bc    #cc2,WT_settimer       go this way if > 0
         b     WT_expired             else, this way
WT_settimer equ *
         st    r5,SVAword             place binary timer
         stimer WAIT,bintvl=SVAword   set timer and wait
WT_expired equ *
         lr    r0,r5                  copy binary interval
         la    r5,100                 set 100
         srda  r0,32                  move to reg 1
         dr    r0,r5                  convert back to secs
         cvd   r1,SVAdword            convert to decimal
         tm    SVAdword+7,x'0D'       is it negative?
         bo    WT_negative            yes, this way
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         mvc   EVALBLOCK_EVDATA(12),=cl12'EXPIRED FOR'
         unpk  EVALBLOCK_EVDATA+12(6),SVAdword put in return var
         mvc   EVALBLOCK_EVDATA+18(5),=cl5' SECS'
         la    r1,23                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     WT_finish              finish
WT_negative equ *
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         mvc   EVALBLOCK_EVDATA(13),=cl13'EXPIRED FOR -'
         unpk  EVALBLOCK_EVDATA+13(6),SVAdword put in return var
         mvc   EVALBLOCK_EVDATA+19(5),=cl5' SECS'
         la    r1,24                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     WT_finish              finish
WT_errclock equ   *
         mvc   EVALBLOCK_EVDATA(15),=cl15'ERROR_CLOCK RC='
         cvd   r15,SVAdword           convert RC to decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  EVALBLOCK_EVDATA+15(4),SVAdword put in return var
         la    r1,19                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     WT_finish              finish
WT_error equ   *
         la    r1,14                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'
WT_finish equ  *
         xr    r15,r15                set RC = 0
WT_exit  equ   *
         @exit keepRC=YES
         space ,
         ltorg ,
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXSE                                         *
*                                                                     *
*   Function name  - cbset()                                          *
*                    set argument to trap event                       *
*                                                                     *
*                                                                     *
*     var = cbset(evtype,evstring,suppression,immed_action)           *
*                                                                     *
*     argument:                                                       *
*                                                                     *
*         evtype       --> event type (MSG, CMD, EOJ, EOS)            *
*         evstring     --> event string/text                          *
*         suppression  --> 'SUPPRESS' (for MSG and CMD only)          *
*         immed_action --> immediate action:                          *
*                          'CMD=commandtext'                          *
*                          'REPLY=replytext'                          *
*                          'MSG=messagetext'                          *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*         'DONE'         - event parameters were set                  *
*         'NOTHING'      - when no zCBT data area found               *
*         'UNAUTHORIZED nnn' - authorization was not granted          *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXSE @ENTRY breg=(r12),svainit=YES
         SPACE 2
*        sac   0
         mvi   SVA_trace,SVA_tr_set   indicate this start
         l     r15,=a(Ev_start)       routine address
         l     r12,=a(CBTREXEV)       base address
         br    r15                    go to the routine
         ltorg ,
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXEV                                         *
*                                                                     *
*   Function name  - cbevent()                                        *
*                    Wait and trap event                              *
*                                                                     *
*                                                                     *
*     var = cbevent(evtype,evstring,suppression,immed_action)         *
*                                                                     *
*     argument:                                                       *
*                                                                     *
*         evtype       --> event type (MSG, CMD, EOJ, EOS)            *
*         evstring     --> event string/text                          *
*         suppression  --> 'SUPPRESS' (for MSG and CMD only)          *
*         immed_action --> immediate action:                          *
*                          'CMD=commandtext'                          *
*                          'REPLY=replytext'                          *
*                          'MSG=messagetext'                          *
*                                                                     *
*     Resulted var can be                                             *
*                                                                     *
*         eventinformation:                                           *
*           CMD --> 'command text'                                    *
*           MSG --> WTO  -> 'message text'                            *
*                   WTOR -> '(REPLYID=nn) message text'               *
*           EOS --> 'JOB=jobname  STEP=stepname SCC=nnn UCC=nnn'      *
*           EOJ --> 'JOB=jobname  SCC=nnn MAXCC=nnn'                  *
*                                                                     *
*         'NOTHING'      - when no zCBT data area found               *
*         'UNAUTHORIZED nnn' - authorization was not granted          *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXEV @ENTRY breg=(r12),svainit=YES
         SPACE 2
*        sac   0
         mvi   SVA_trace,SVA_tr_wait  indicate this start
Ev_start equ   *
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?
         bne   EV_get_arg             no, get arguments
         cli   SVA_trace,SVA_tr_wait  is it cbevent() function?
         bne   EV_error               no, error
         mvi   SVA_trace,SVA_tr_any   indicate this start
         @call Get_auth               get authorization
         bnz   EV_unauth              leave if error
         @call Access_zCBT            access zCBT data area
         bnz   EV_zCBTdown            leave it if nothing
         @call EV_extend              yes, perform extended function
         bz    EV_unknown             go this way if nothing
         b     EV_wakeup              else, go this way
         space ,
* +---------------------------------------------------+
* | Get 1st argument: Event type                      |
* +---------------------------------------------------+
         space ,
EV_get_arg equ *
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    EV_error               error if nothing
         ch    r3,=h'3'               arg 1 length = 3?
         be    EV_get_type            yes, proceed
         bl    EV_error               error if < 3
         cli   3(r5),c' '             only 3 char effective?
         bne   EV_error               no, error
EV_get_type equ *
         mvc   SVAdword,=cl8' '       get blanks
         oc    SVAdword(3),0(r5)      make type in uppercase
         clc   =c'MSG',SVAdword       is it for msg event?
         be    EV_trap_msg            yes, go this way
         clc   =c'CMD',SVAdword       is it for cmd event?
         be    EV_trap_cmd            yes, go this way
         clc   =c'EOS',SVAdword       is it for EOS event?
         be    EV_trap_eos            yes, go this way
         clc   =c'EOJ',SVAdword       is it for EOJ event?
         bne   EV_error               no, error
EV_trap_eoj equ *
         mvi   RX_evtype,EVB_ev_eoj   indicate event is eoj
         la    r14,EV_find_eoj        logic flow switch 0
         la    r15,EV_init_eoj        logic flow switch 1
         la    r0,EV_wakeup_eoj       logic flow switch 2
         b     EV_get_evid            continue get event id/string
EV_trap_eos equ *
         mvi   RX_evtype,EVB_ev_eos   indicate event is eos
         la    r14,EV_find_eos        logic flow switch 0
         la    r15,EV_init_eos        logic flow switch 1
         la    r0,EV_wakeup_eos       logic flow switch 2
         b     EV_get_evid            continue get event id/string
EV_trap_cmd equ *
         mvi   RX_evtype,EVB_ev_cmd   indicate event is cmd
         la    r14,EV_find_cmd        logic flow switch 0
         la    r15,EV_init_cmd        logic flow switch 1
         la    r0,EV_wakeup_cmd       logic flow switch 2
         b     EV_get_evid            continue get event id/string
EV_trap_msg equ *
         mvi   RX_evtype,EVB_ev_msg   indicate event is msg
         la    r14,EV_find_msg        logic flow switch 0
         la    r15,EV_init_msg        logic flow switch 1
         la    r0,EV_wakeup_msg       logic flow switch 2
         space ,
* +---------------------------------------------------+
* | Get 2nd argument: Event id/string                 |
* +---------------------------------------------------+
         space ,
EV_get_evid equ *
         stm   r14,r0,RX_address      set logic flow switches
         la    r8,argtable_next       seek 2nd argument
         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?
         be    EV_error               yes, error
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    EV_error               error if nothing
         sth   r3,RX_evidlen          if ok, hold it in SVA
         mvc   RX_evidptr,argtable_argstring_ptr hold the address also
         space ,
* +---------------------------------------------------+
* | Get 3rd argument: suppression option              |
* +---------------------------------------------------+
         space ,
         la    r8,argtable_next       seek 2nd argument
         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?
         be    EV_ck_auth             yes, ignore it
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    EV_get_action          ignore if nothing
         ch    r3,=h'8'               is length = 8?
         bne   EV_get_action          no, ignore it
         l     r5,argtable_argstring_ptr pointer of argument
         clc   =c'SUPPRESS',0(r5)     option = suppress?
         be    EV_get_supp            yes, take it
         mvc   SVAdword,=cl8' '       get blanks
         oc    SVAdword,0(r5)         make it uppercase
         clc   =c'SUPPRESS',SVAdword  option = suppress?
         bne   EV_get_action          no, ignore it
EV_get_supp equ *
         mvi   RX_option,RX_suppress  yes, remember it
         space ,
* +---------------------------------------------------+
* | Get 4th argument: Immediate action                |
* +---------------------------------------------------+
         space ,
EV_get_action equ *
         la    r8,argtable_next       seek 2nd argument
         clc   =XL8'FFFFFFFFFFFFFFFF',0(r8) end of table?
         be    EV_ck_auth             ignore if nothing
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    EV_ck_auth             ignore if nothing
         l     r5,argtable_argstring_ptr pointer of argument
         mvc   SVAdword,=cl8' '       get blanks
         oc    SVAdword,0(r5)         make it uppercase
         clc   =c'CMD=',SVAdword      action = cmd?
         be    EV_get_accmd           yes, handle it
         clc   =c'MSG=',SVAdword      action = msg?
         be    EV_get_acmsg           yes, handle it
         clc   =c'REPLY=',SVAdword    action = reply?
         bne   EV_ck_auth             no, ignore it
         cli   RX_evtype,EVB_ev_msg   is it msg event?
         bne   EV_ck_auth             no, ignore it
         mvi   RX_action,EVB_ac_rpy   yes, indicate it
         la    r0,6                   set keyword length = 6
         b     EV_got_action          go this way
EV_get_accmd equ *
         mvi   RX_action,EVB_ac_cmd   indicate it is cmd
         la    r0,4                   set keyword length = 4
         b     EV_got_action          go this way
EV_get_acmsg equ *
         mvi   RX_action,EVB_ac_msg   indicate it is msg
         la    r0,4                   set keyword length = 4
EV_got_action equ *
         sr    r3,r0                  adjust to value length
         bz    EV_ck_auth             ignore if 0
         bm    EV_ck_auth             ignore if < 0
         sth   r3,RX_aclen            hold length in SVA
         ar    r5,r0                  adjust to value position
         st    r5,RX_acptr            hold address in SVA
         space ,
* +---------------------------------------------------+
* | Validate authorization                            |
* +---------------------------------------------------+
         space ,
EV_ck_auth equ *
         @call Get_auth               get authorization
         bnz   EV_unauth              leave if error
         space ,
* +---------------------------------------------------+
* | Begin processing                                  |
* +---------------------------------------------------+
         space ,
EV_begin equ   *
         @call Access_zCBT            access zCBT data area
         bnz   EV_zCBTdown            leave it if nothing
         l     r15,RX_address0        get logic flow switch
         br    r15                    go follow switch
EV_find_msg equ *
         la    r2,COMrex_msg          EVB chain in com for MSG
         b     EV_find_evb            find chained EVB
EV_find_cmd equ *
         la    r2,COMrex_cmd          EVB chain in com for CMD
         b     EV_find_evb            find chained EVB
EV_find_eos equ *
         la    r2,COMrex_eos          EVB chain in com for EOS
         b     EV_find_evb            find chained EVB
EV_find_eoj equ *
         la    r2,COMrex_eoj          EVB chain in com for EOJ
         space ,
* +---------------------------------------------------+
* | Find unused EVB in chain                          |
* +---------------------------------------------------+
         space ,
EV_find_evb equ *
         using EVBlok,r7              map EVB
         st    r2,RX_evbcom           hold chain address
         icm   r7,b'1111',0(r2)       check and establish EVB
         bz    EV_obtain_evb          no, obtain a new one
EV_seek_evb equ *
         tm    EVB_flags,EVB_f_error  is it error entry?
         bo    EV_found_evb           yes, potentially take it
         l     r1,EVB_usrascb         address of original ASCB
         clc   =c'ASCB',ASCBASCB-ASCB(r1) is it correct ASCB?
         bne   EV_found_evb           no, potentially take it
         icm   r15,b'1111',ASCBJBNI-ASCB(r1) get jobname (init)
         bnz   EV_ascb_evb            check it if so
         icm   r15,b'1111',ASCBJBNS-ASCB(r1) get jobname (STC)
         bz    EV_found_evb           take it if nothing
EV_ascb_evb equ *
         clc   EVB_usrjname,0(r15)    is jobname valid?
         bne   EV_found_evb           no, potentially take it
         clc   EVB_usrjname,RX_jobname is it mine?
         be    EV_my_evb              yes, handle it
         clc   EVB_usrascb,PSAAOLD    is it on my ASCB?
         be    EV_found_evb           yes, must be orphan, take it
         b     EV_next_evb            no, ignore it
EV_my_evb equ  *
         clc   EVB_usrascb,PSAAOLD    is it on my ASCB?
         be    EV_test_evb            yes, test it
         cli   RX_jobtype,RX_job_job  is it a batch job?
         be    EV_found_evb           yes, duplication, take it
         cli   RX_jobtype,RX_job_tsu  is it a TSO user?
         be    EV_found_evb           yes, duplication, take it
         b     EV_next_evb            no, must be STC, ignore it
EV_test_evb equ *
         clc   EVB_usrtcb,PSATOLD     is it on my TCB?
         bne   EV_found_evb           no, must be orphan, take it
         tm    EVB_flags,EVB_f_hold+EVB_f_perm is it held/perm EVB?
         bnz   EV_next_evb            yes, ignore it
         tm    EVB_flags,EVB_f_exp    is it expired entry?
         bo    EV_found_evb           yes, potentially take it
EV_next_evb equ *
         icm   r7,b'1111',EVB_evnext  yes, seek next
         bz    EV_obtain_evb          go this way if no more
         b     EV_seek_evb            else, iterate
EV_found_evb equ *
*        ni    EVB_flags,255-EVB_f_hold-EVB_f_perm clean it
*        oi    EVB_flags,EVB_f_exp    make it as expired EVB
         ni    EVB_flags,0            clear all indicators
         la    r2,EVB_len+EOTinfolen  size of planned EVB
         st    r7,RX_evbptr           hold EVB in SVA
         sth   r2,RX_evblen           and also its length
         mvi   RX_evbtype,RX_evbt_old indicate using old EVB
         b     EV_init_evb            continue init it
         space ,
* +---------------------------------------------------+
* | Obtain a new EVB                                  |
* |                                                   |
* |   - when no unused EVB was found                  |
* +---------------------------------------------------+
         space ,
EV_obtain_evb equ *
         mvi   RX_evbtype,RX_evbt_new indicate using new EVB
         la    r2,EVB_len+EOTinfolen  size of planned EVB
         storage OBTAIN,length=(r2),  obtain storage                   +
               sp=228,loc=ANY,key=0,  subpool 228 in either CSA/ECSA   +
               owner=SYSTEM,          owned by system                  +
               cond=NO                req is unconditional
         st    r1,RX_evbptr           hold EVB in SVA
         sth   r2,RX_evblen           and also its length
         lr    r7,r1                  establish EVB map
         xc    EVBlok(EVB_len),EVBlok clear EVB
         space ,
* +---------------------------------------------------+
* | Initialize EVB with common information            |
* +---------------------------------------------------+
         space ,
EV_init_evb equ *
         la    r1,EVB_len(r7)         past end of EVB
         st    r1,EVB_usrevsrc        hold it for event source copy
         mvi   EVB_string,c' '        put a blank and roll it
         mvc   EVB_string+1(l'EVB_string-1),EVB_string to clear it
         mvi   EVB_supp,0             init suppression option
         mvc   EVB_evtype,RX_evtype   set event type
         mvc   EVB_action,RX_action   set immediate action
         mvc   EVB_usrascb,PSAAOLD    hold ASCB address in EVB
         mvc   EVB_usrtcb,PSATOLD     hold TCB address in EVB
         mvc   EVB_usrjname,RX_jobname hold jobname in EVB
         using CVTMAP,r2              CVT addressability
         l     R2,CVTPTR              Get CVT address
         mvc   EVB_sysname,CVTSNAME   get system name
         drop  r2
         l     r2,RX_evidptr          event id/string pointer
         lh    r3,RX_evidlen          and its length
         l     r15,RX_address1        get logic flow switch
         br    r15                    go follow switch
         space ,
* +---------------------------------------------------+
* | Initialize EVB for CMD event                      |
* +---------------------------------------------------+
         space ,
EV_init_cmd equ *
         cli   RX_option,RX_suppress  is suppress option specified?
         bne   EV_init_eoj            no, straight to txt evaluation
         mvi   EVB_supp,EVB_supp_cmd  yes, set suppression in EVB
         b     EV_init_eoj            go this way
         space ,
* +---------------------------------------------------+
* | Initialize EVB for MSG event                      |
* +---------------------------------------------------+
         space ,
EV_init_msg equ *
         cli   RX_option,RX_suppress  is suppress option specified?
         bne   EV_init_eoj            no, straight to txt evaluation
         mvi   EVB_supp,EVB_supp_all  yes, set suppression in EVB
         space ,
* +---------------------------------------------------+
* | Initialize EVB for EOJ event                      |
* +---------------------------------------------------+
         space ,
EV_init_eoj equ *
         lr    r15,r3                 copy original length
         bctr  r3,0                   reduce length by 1
         lr    r1,r3                  copy length into reg 1
         alr   r3,r2                  address of last byte
         cli   0(r3),c'*'             is it wild card?
         bne   EV_gettxt              no, just copy text
         bctr  r1,0                   reduce again length by 1
         lr    r15,r1                 adjust original length
EV_gettxt equ  *
         ex    r1,*+4                 copy event id/text into EVB
         mvc   EVB_string(*-*),0(r2)  <<executed>>
         la    r1,8(r15)              add length of sysname
         sth   r1,EVB_idlen           hold adjusted length in EVB
         b     EV_chain               continue this way
         space ,
* +---------------------------------------------------+
* | Initialize EVB for EOS event                      |
* +---------------------------------------------------+
         space ,
EV_init_eos equ *
         la    r4,EVB_string          address of target
         la    r15,8                  max length of jobname is 8
         lr    r1,r2                  copy address of argument
         la    r14,15                 length of sysname+jobname-1
EV_seek_jobnm equ *
         cli   0(r1),c'.'             is it dot?
         be    EV_get_step            yes, continue get step name
         mvc   0(1,r4),0(r1)          no, take it
         la    r4,1(r4)               fwd target
         la    r1,1(r1)               fwd source
         bct   r3,EV_seek_jobfwd      continue and adjust length
         b     EV_got_step            go this way if no more
EV_seek_jobfwd equ *
         bct   r15,EV_seek_jobnm      iterate
EV_get_step equ *
         bctr  r3,0                   adjust for dot sign
         la    r1,1(r1)               skip dot
         la    r4,EVB_string+8        address of target for step name
         la    r15,8                  max length of stepname is 8
EV_seek_step equ *
         cli   0(r1),c'*'             is it dot?
         be    EV_got_step            yes, continue get step name
         mvc   0(1,r4),0(r1)          no, take it
         la    r4,1(r4)               fwd target
         la    r1,1(r1)               fwd source
         la    r14,1(r14)             add 1 to counter
         bct   r3,EV_seek_stepfwd     continue and adjust length
         b     EV_seek_stepok         go this way if no more
EV_seek_stepfwd equ *
         bct   r15,EV_seek_step       iterate
EV_seek_stepok equ *
         mvc   EVB_idlen,=y(16+8)     set full length
         b     EV_chain               continue this way
EV_got_step equ *
         sth   r14,EVB_idlen          hold total length-1 in EVB
         ch    r14,=h'15'             is step argumented?
         bh    EV_chain               yes, go ahead
         mvi   EVB_evtype,EVB_ev_eoj  no, change event to eoj
         la    r0,COMrex_eoj          EVB chain in com for EOJ
         st    r0,RX_evbcom           hold chain address
         la    r15,EV_wakeup_eoj      logic flow switch 2
         st    r15,RX_address2        set logic flow switch 2
         space ,
* +---------------------------------------------------+
* | Chain EVB into existing EVB chain on COM          |
* |                                                   |
* |   - only for newly obtained EVB                   |
* |                                                   |
* +---------------------------------------------------+
         space ,
EV_chain equ   *
         cli   RX_evbtype,RX_evbt_old is it using old EVB?
         be    EV_wait                yes, skip chaining
*        ago   .enq001
         space ,
*------------lock-resource--------------------
         mvc   SVAmajor,=cl8'ZCBTREXX'   resource major name
         mvc   SVAminor,=cl8'USER-EVB'   resource minor name
         @call Enqueue_system     lock system
*------------lock-resource--------------------
         space ,
.enq001  anop
         l     r1,RX_evbcom           EVB chain address in COM
         icm   r7,b'1111',0(r1)       exist?
         bnz   EV_chain_fwd           yes, chain it as the last
         mvc   0(4,r1),RX_evbptr      no, put as 1st chain
         l     r7,RX_evbptr           back to my EVB
         b     EV_okchain             then go this way
EV_chain_fwd equ *
         lr    r15,r7                 hold this EVB
         la    r1,EVB_evnext          address of fwd pointer
         icm   r7,b'1111',EVB_evnext  seek fwd
         bnz   EV_chain_fwd           iterate until no more
         mvc   0(4,r1),RX_evbptr      put my EVB as the last
         l     r7,RX_evbptr           establish my EVB
         st    r15,EVB_evprev         the last EVB as my prev EVB
         st    r1,RX_evbcom           update chain pointer
EV_okchain equ *
*        ago   .deq001
         space ,
*------------unlock-resource--------------------
         mvc   SVAmajor,=cl8'ZCBTREXX'   resource major name
         mvc   SVAminor,=cl8'USER-EVB'   resource minor name
         @call Dequeue_system     unlock system
*------------unlock-resource--------------------
         space ,
.deq001  anop
*        wto   'zjevent: EVB has been chained.'
* +---------------------------------------------------+
* | Entering wait state to wait signal from zCBT      |
* +---------------------------------------------------+
         space ,
EV_wait  equ   *
         cli   SVA_trace,SVA_tr_set   is it from cbset() function?
         be    EV_set                 yes, go this way
         ni    EVB_flags,255-EVB_f_exp-EVB_f_error clear flags
         cli   EVB_evtype,EVB_ev_eoj  is it for EOJ?
         bne   EV_sleep               no, skip below
         oi    EVB_flags,EVB_f_hold   yes, hold it
EV_sleep equ   *
         xc    EVB_usrecb,EVB_usrecb  clear ECB
         mvc   RX_waitnum,=h'1'       num of awaiting ECB must be 1
         wait  ecb=EVB_usrecb,long=YES, issue wait for signal          +
               linkage=SYSTEM
         mvc   EVALBLOCK_EVDATA(15),=cl15'*UNPRESENTABLE*'
         la    r1,15                  total length of resulted text
         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length
         mvc   RX_postnum,=h'1'       num of posted ECB must be 1
EV_wakeup equ  *
         lh    r15,RX_waitnum         num of awaiting ECBs
         bctr  r15,0                  reduce 1
         sth   r15,RX_waitnum         update it
         l     r15,RX_address2        get logic flow switch
         br    r15
         space ,
* +---------------------------------------------------+
* | Wakeup for MSG event                              |
* +---------------------------------------------------+
         space ,
EV_wakeup_msg equ *
         mvc   EVALBLOCK_EVDATA(4),=cl4'MSG'
         lh    r14,EVB_usrrplen       reply id length
         ltr   r14,r14                exist?
         bz    EV_wakeup_cmd1         no, just take the msg text
         mvc   EVALBLOCK_EVDATA+4(9),=cl9'(REPLYID='
         ex    r14,*+4                get replyid
         mvc   EVALBLOCK_EVDATA+13(*-*),EVB_usrrplid <<executed>>
         la    r14,EVALBLOCK_EVDATA+13(r14) skip reply id
         mvi   0(r14),c')'            put close bracket
         mvi   1(r14),c' '            followed by a blank
         la    r14,2(r14)             set msg start position
         l     r1,EVB_usrevsrc        address of event source text
         lh    r2,0(r1)               length of event source text
         la    r15,10                 length of prefix+sysname
         alr   r1,r15                 skip length prefix and sysname
         slr   r2,r15                 adjust length as well
         ex    r2,*+4                 get result
         mvc   0(*-*,r14),0(r1)       <<execute>>
         la    r15,EVALBLOCK_EVDATA   address data buffer
         slr   r14,r15                calc length of replyid prefix
         la    r2,1(r14,r2)           add it to msg text length
         stcm  r2,b'1111',EVALBLOCK_EVLEN set result length
         b     EV_action              then go this way
         space ,
* +---------------------------------------------------+
* | Wakeup for CMD event                              |
* +---------------------------------------------------+
         space ,
EV_wakeup_cmd equ *
         mvc   EVALBLOCK_EVDATA(4),=cl4'CMD'
EV_wakeup_cmd1 equ *
         l     r1,EVB_usrevsrc        address of event source text
         lh    r2,0(r1)               length of event source text
         la    r15,10                 length of prefix+sysname
         alr   r1,r15                 skip length prefix and sysname
         slr   r2,r15                 adjust length as well
         ex    r2,*+4                 get result
         mvc   EVALBLOCK_EVDATA+4(*-*),0(r1) <<execute>>
         la    r2,6(r2)               add 5 for correction
         stcm  r2,b'1111',EVALBLOCK_EVLEN set result length
         b     EV_action1             then go this way
         space ,
* +---------------------------------------------------+
* | Wakeup for EOS event                              |
* +---------------------------------------------------+
         space ,
EV_wakeup_eos equ  *
         using EOTinfo,r6             map EOT info
         icm   r6,b'1111',EVB_usreot  establish EOT info
         bz    EV_action1             go this way if nothing
         mvc   EVALBLOCK_EVDATA(4),=cl4'EOS'
         mvc   EVALBLOCK_EVDATA+4(4),=cl4'JOB='
         mvc   EVALBLOCK_EVDATA+8(8),EOTjobname put jobname
         mvc   EVALBLOCK_EVDATA+16(6),=cl6' STEP='
         mvc   EVALBLOCK_EVDATA+22(8),EOTjstep  put step name
         cli   EOTjstep,c' '          is it blank?
         bne   EV_wakeup_eoscc        no, go ahead
         mvc   EVALBLOCK_EVDATA+22(8),EOTpstep yes, use proc step name
EV_wakeup_eoscc equ *
         mvc   SVAinword,EOTscc       get SCC and UCC
         @call Edit_hex               edit in ebcdic hex
         mvc   EVALBLOCK_EVDATA+30(5),=cl5' SCC='
         mvc   EVALBLOCK_EVDATA+35(3),SVAoutdbwd+1
         mvc   EVALBLOCK_EVDATA+38(5),=cl5' UCC='
         mvc   EVALBLOCK_EVDATA+43(3),SVAoutdbwd+5
         la    r1,46                  total length of resulted text
         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length
         b     EV_action1             then go this way
         space ,
* +---------------------------------------------------+
* | Wakeup for EOJ event                              |
* +---------------------------------------------------+
         space ,
EV_wakeup_eoj equ *
         icm   r6,b'1111',EVB_usreot  establish EOT info
         bz    EV_action1             go this way if nothing
         clc   =c'EOTINFO',EOTid      is it valid EOT?
         be    EV_wkck_eot            yes, go this way
         clc   =c'NO_EOT ',EOTid      is it simulation from WQE?
         be    EV_process_eoj         yes, go this way
         b     EV_unfinish_eoj        else, back to wait state
EV_wkck_eot equ *
         cli   EOTttype,EOTttjob      is it EOJ?
         be    EV_process_eoj         yes, go ahead
         lh    r0,EOTscc              else, get scc
         ltr   r0,r0                  is it?
         bz    *+8                    no, skip below
         sth   r0,EVB_syscc           hold SCC in EVB
         lh    r0,EOTucc              get ucc
         ch    r0,EVB_maxcc           check against max cc
         bnh   *+8                    skip below if not higher
         sth   r0,EVB_maxcc           update max cc if it higher
         mvc   EVB_cc,EOTucc          update user cc
         using ASCB,r5                map ASCB
         icm   r5,15,EOTascb          establish ASCB
         bz    EV_unfinish_eoj        back to wait state if nothing
         xc    SVAword,SVAword        clear this word
EV_wkck_ascb equ *
         clc   =c'ASCB',ASCBASCB      is it correct?
         bne   EV_process_eoj         no, already eoj
         icm   r4,b'1111',ASCBJBNI    address of jobname
         bnz   EV_wkck_jname          check it if exist
         icm   r4,b'1111',ASCBJBNS    address of STCname
         bz    EV_process_eoj         process EOJ if nothing
EV_wkck_jname equ *
         clc   EOTjobname,0(r4)       is it still consistant?
         bne   EV_process_eoj         process EOJ if no more
         la    r0,100                 set 1 sec
         c     r0,SVAword             was it done before?
         be    EV_unfinish_eoj        back to wait state if so
         st    r0,SVAword             save it in this word
         stimer WAIT,bintvl=SVAword   wait 1 sec
         b     EV_wkck_ascb           redo from this point
EV_unfinish_eoj equ *
         cli   SVA_trace,SVA_tr_any   is it cbevent() call
         bne   EV_wait                back to wait state if not
         lh    r15,RX_waitnum         num of awaiting ECBs
         ltr   r15,r15                exist?
         bz    EV_wait                back to wait state if nothing
         mvc   EVALBLOCK_EVDATA(12),=cl12'PENDING EOJ'
         la    r1,11                  total length of resulted text
         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length
         b     EV_cleanup             then leave
EV_process_eoj equ *
         mvc   EVALBLOCK_EVDATA(4),=cl4'EOJ'
         mvc   EVALBLOCK_EVDATA+4(4),=cl4'JOB='
         mvc   EVALBLOCK_EVDATA+8(8),EOTjobname put jobname
         mvc   SVAinword(2),EVB_syscc get SCC
         mvc   SVAinword+2(2),EVB_maxcc and max CC
         @call Edit_hex               edit in ebcdic hex
         mvc   EVALBLOCK_EVDATA+16(5),=cl5' SCC='
         mvc   EVALBLOCK_EVDATA+21(3),SVAoutdbwd+1
         mvc   EVALBLOCK_EVDATA+24(7),=cl7' MAXCC='
         mvc   EVALBLOCK_EVDATA+31(3),SVAoutdbwd+5
         la    r1,34                  total length of resulted text
         stcm  r1,b'1111',EVALBLOCK_EVLEN set result length
         b     EV_action1             then go this way
         space ,
* +---------------------------------------------------+
* | Perform immediate action (if any)                 |
* +---------------------------------------------------+
         space ,
EV_action equ  *
         cli   RX_action,EVB_ac_rpy   is action = reply?
         be    EV_ac_rpy              yes, handle it
EV_action1 equ *
         lh    r1,RX_aclen            get action txt length
         ltr   r1,r1                  check it
         bz    EV_cleanup             skip all if nothing
         sth   r1,SVAbufff            put in this buffer
         bctr  r1,0                   reduce 1 for ex
         l     r15,RX_acptr           address of text
         ex    r1,*+4                 copy text to buffer
         mvc   SVAbufff+2(*-*),0(r15) <<execute>>
         cli   RX_action,EVB_ac_msg   is action = msg?
         be    EV_ac_msg              yes, handle it
         cli   RX_action,EVB_ac_cmd   is action = cmd?
         bne   EV_cleanup             otherwise, nop
         space ,
* +---------------------------------------------------+
* | Immediate action: Execute command                 |
* +---------------------------------------------------+
         space ,
EV_ac_cmd equ  *
         xc    SVAword,SVAword        clear console id
         la    r2,SVAbufff            address of buffer
         mgcre TEXT=(R2),             execute cmd in this buffer       +
               CONSID=SVAword,        issue from this console          +
               CMDFLAG=NOHCPY,        no hardcopy                      +
               MF=(E,SVA_lmgcre)      list form in MGCREPL
         b     EV_cleanup             then, continue this way
         space ,
* +---------------------------------------------------+
* | Immediate action: Reply to current message        |
* +---------------------------------------------------+
         space ,
EV_ac_rpy equ  *
         mvc   SVAbufff+2(6),=cl6'REPLY' put reply command
         lh    r1,EVB_usrrplen        reply id length
         ex    r1,*+4                 get replyid
         mvc   SVAbufff+8(*-*),EVB_usrrplid <<executed>>
         la    r1,SVAbufff+8(r1)      pass over reply id
         mvi   0(r1),c','             put comma
         la    r1,1(r1)               fwd next byte
         lh    r15,RX_aclen           reply text length
         l     r14,RX_acptr           address of reply text
         ex    r15,*+4                take the text
         mvc   0(*-*,r1),0(r14)       << executed >>
         alr   r1,r15                 end of the text
         la    r0,SVAbufff+2          address of start of buffer
         slr   r1,r0                  calc length of buffer
         sth   r1,SVAbufff            put at the 1st 2-byte
         b     EV_ac_cmd              process as command
         space ,
* +---------------------------------------------------+
* | Immediate action: Issue WTO message               |
* +---------------------------------------------------+
         space ,
EV_ac_msg equ  *
         mvc   SVAwtobuf(EV_wtolflen),EV_wtolf
         wto   text=SVAbufff,mf=(E,SVAwtobuf)
         b     EV_cleanup             then, continue this way
EV_wtolf  equ  *
         WTO   TEXT=,ROUTCDE=(1,2,10),desc=(9,11,12),MF=L
EV_wtolflen equ *-EV_wtolf
         space ,
* +---------------------------------------------------+
* | Cleaning up EVB and other storage areas           |
* +---------------------------------------------------+
         ds    0h
EV_cleanup equ *
         tm    EVB_flags,EVB_f_perm   is it set permanently?
         bo    EV_done                yes, leave it
         tm    EVB_flags,EVB_f_hold   is it being held?
         bno   EV_purge               no, release it
         ni    EVB_flags,255-EVB_f_hold yes, no more held
         b     EV_done                then leave it
EV_purge equ   *
         l     r1,RX_evbptr           address of EVB in SVA
         la    r0,EVB_len+EOTinfolen  and its length
         storage RELEASE,length=(r0), release storage                  +
               addr=(r1),sp=228       subpool 228 in either CSA/ECSA
         b     EV_done                then leave it
         space ,
* +---------------------------------------------------+
* | SET only request - from function cbset()          |
* +---------------------------------------------------+
         space ,
EV_set   equ   *
         ni    EVB_flags,0            clear all indicators
         oi    EVB_flags,EVB_f_perm+EVB_f_hold make it permanent
         xc    EVB_usrecb,EVB_usrecb  clear ECB
         mvc   EVALBLOCK_EVDATA(7),=cl3'SET'
         la    r1,3                   true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         b     EV_done                then, leave
         space ,
* +---------------------------------------------------+
* | Unknown request                                   |
* +---------------------------------------------------+
         space ,
EV_unknown equ *
         mvc   EVALBLOCK_EVDATA(7),=cl7'UNKNOWN'
         b     EV_leave               then, leave
         space ,
* +---------------------------------------------------+
* | zCBT down - no further action is process          |
* +---------------------------------------------------+
         space ,
EV_zCBTdown equ *
         mvc   EVALBLOCK_EVDATA(7),=cl7'NOTHING'
EV_leave equ   *
         la    r1,7                   true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         space ,
* +---------------------------------------------------+
* | Restore PSW key                                   |
* +---------------------------------------------------+
         space ,
EV_done  equ   *
         l     r2,SVAkey              get saved key
         spka  0(r2)                  restore key
         modeset mf=(E,SVA_lmprob)
         b     EV_finish              finish
         space ,
* +---------------------------------------------------+
* | Authorization failed                              |
* +---------------------------------------------------+
         space ,
EV_unauth equ  *
         cvd   r15,SVAdword           convert RC to packed decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  SVAword,SVAdword       convert to EBCDIC
         mvi   SVAword,c' '           blank 1st digit
         la    r1,16                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'
         mvc   EVALBLOCK_EVDATA+12(4),SVAword
         b     EV_finish              finish
         space ,
* +---------------------------------------------------+
* | Error argument                                    |
* +---------------------------------------------------+
         space ,
EV_error equ   *
         la    r1,14                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(14),=cl14'ERROR_ARGUMENT'
         space ,
* +---------------------------------------------------+
* | Exit                                              |
* +---------------------------------------------------+
         space ,
EV_finish equ  *
         xr    r15,r15                set RC = 0
EV_exit  equ   *
         @exit keepRC=YES
         space ,
         ltorg ,
         drop  r12                    reset base address
         eject ,
* +---------------------------------------------------+
* | Requires authorization                            |
* |                                                   |
* |  o Check the environment.                         |
* |    - If possible, issue MODESET macro to          |
* |      get authorization                            |
* |                                                   |
* |  o Otherwise, issue SVC 109 with ESR code 212     |
* |    - This ESR will force system to grant          |
* |      authorization                                |
* |                                                   |
* +---------------------------------------------------+
         ds    0h
         using Get_auth,r12           map the routine
Get_auth equ   *
         stm   r0,r15,SVAregs         save all regs
         lr    r12,r15                establish addressability
         xr    r2,r2                  clear reg 2
         ipk   0                      save key into reg 2
         st    r2,SVAkey              save key in SVA
         TESTAUTH FCTN=1,STATE=YES,KEY=YES,RBLEVEL=1 CHECK AUTH
         ltr   R15,R15                is this environmant authorized?
         bnz   Get_auth_esr           no, get authorization
         modeset mf=(E,SVA_lmsupz)    set supervisor mode with key 0
         b     Get_auth_done          then complete
Get_auth_esr equ *
         xr    r0,r0                  clear reg 0
         la    r1,1                   set reg 1 to 1
         la    r15,212                set reg 15 to 212 (ESR code)
         svc   109                    get authorization
Get_auth_done equ *
         lm    r0,r14,SVAregs         restore reg 0-14
         ltr   r15,r15                generate CC
         br    r14                    return
         space ,
* +---------------------------------------------------+
* | Prepares Extended cbevent() Function              |
* |                                                   |
* |  o Find all chained EVBs which belong to this     |
* |    address space.  Leave if nothing if found.     |
* |                                                   |
* |  o Build ECB list to contain all its EVB_usrecb   |
* |    fields                                         |
* |                                                   |
* |  o Issue WAIT macro                               |
* |                                                   |
* |                                                   |
* +---------------------------------------------------+
         ds    0h
EV_extend equ  *
         stm   r0,r15,SVAregs         save all regs
         la    r12,EV_extend-Get_auth calculate offset
         slr   r15,r12                calculate base address
         lr    r12,r15                establish addressability
         la    r4,SVAlist             use this buffer for ECB list
         la    r5,l'SVAlist           length of buffer
         srl   r5,2                   divided by 4 = num of ECB slots
         xr    r15,r15                init counter
         xc    SVAlist,SVAlist        clear the list
EVx_list_msg equ *
         la    r3,EVx_list_cmd        next is CMD
         icm   r7,b'1111',COMrex_msg  point to 1st MSG EVB in chain
         bnz   EVx_list_loop          perform iteration
EVx_list_cmd equ *
         la    r3,EVx_list_eoj        next is EOJ
         icm   r7,b'1111',COMrex_cmd  point to 1st CMD EVB in chain
         bnz   EVx_list_loop          perform iteration
EVx_list_eoj equ *
         la    r3,EVx_list_eos        next is EOJ
         icm   r7,b'1111',COMrex_eoj  point to 1st EOJ EVB in chain
         bnz   EVx_list_loop          perform iteration
EVx_list_eos equ *
         la    r3,EVx_list_done       next is finish
         icm   r7,b'1111',COMrex_eos  point to 1st EOS EVB in chain
         bz    EVx_list_done          leave if nothing
EVx_list_loop equ *
         tm    EVB_flags,EVB_f_error  is it error EVB?
         bo    EVx_list_next          yes, seek next
         clc   EVB_usrascb,PSAAOLD    is it belong to me?
         bne   EVx_list_next          no, seek next
         ni    EVB_flags,255-EVB_f_exp off expiry bit
         using ECB,r2                 map ECB
         la    r2,EVB_usrecb          establish ECB
         ni    ECBCC,255-ECBWAIT      turn wait bit off
         lr    r1,r4                  hold content of reg 4 in reg 1
         st    r2,0(r4)               hold it in ECB list?
         la    r15,1(r15)             add 1 to counter
         bct   r5,EVx_list_fwd        jump this way along with index
         b     EVx_list_done          then, leave the loop
EVx_list_fwd equ *
         la    r4,4(r4)               fwd to next EVB
EVx_list_next equ *
         icm   r7,b'1111',EVB_evnext  search next
         bnz   EVx_list_loop          iterate
         br    r3                     go this way if no more
EVx_list_done equ *
         sth   r15,RX_waitnum         num of awaiting ECBs
         ltr   r5,r15                 check counter
         bz    EVx_finish             leave it if nothing
         oi    0(r1),x'80'            indicate it is the last slot
Evx_wait equ   *
         wait  ECBLIST=SVAlist,long=YES, enter wait state              +
               linkage=SYSTEM
         la    r4,SVAlist             address ECB list
Evx_loop_ecb equ *
         icm   r2,15,0(r4)            get the ECB
         bz    Evx_next_ecb           ignore if none (just safeguard)
         ni    ECBCC,255-ECBWAIT      turn wait bit off
         tm    ECBCC,ECBPOST          was signal posted?
         bo    EVx_wakeup             yes, wake up and check ECB
Evx_next_ecb equ *
         la    r4,4(r4)               next slot
         bct   r5,Evx_loop_ecb        iterate
         xr    r15,r15                if no more, clear reg 15
         b     EVx_finish             then, finish
*        b     Evx_wait               back to wait state if no more
EVx_wakeup equ *
         lh    r15,RX_postnum         num of posted ECBs
         la    r15,1(r15)             add 1
         sth   r15,RX_postnum         update it
         lr    r7,r2                  address of EVB user's ECB
         la    r1,EVB_usrecb-EVBlok   calculate offset to ECB
         slr   r7,r1                  establish this EVB
         st    r7,SVAregs+4*7         hold it in reg 7 slot
         st    r7,RX_evbptr           and in SVA
         xc    EVB_usrecb,EVB_usrecb  clear ECB
         cli   EVB_evtype,EVB_ev_msg  is it msg event?
         be    EVx_wakeup_msg         yes, handle it
         cli   EVB_evtype,EVB_ev_cmd  is it cmd event?
         be    EVx_wakeup_cmd         yes, handle it
         cli   EVB_evtype,EVB_ev_eoj  is it eoj event?
         be    EVx_wakeup_eoj         yes, handle it
         cli   EVB_evtype,EVB_ev_eos  is it eos event?
         be    EVx_wakeup_eos         yes, handle it
         xr    r15,r15                else, clear reg 15
         b     EVx_finish             then, finish
EVx_wakeup_msg equ *
*        wto   'zCBTREX: ----- Wakeup msg ------'
         l     r15,=a(EV_wakeup_msg)  get msg handler address
         la    r0,COMrex_msg          msg EVB anchor pointer
         b     EVx_wakeup_go          then, finish
EVx_wakeup_cmd equ *
*        wto   'zCBTREX: ----- Wakeup cmd ------'
         l     r15,=a(EV_wakeup_cmd)  get cmd handler address
         la    r0,COMrex_cmd          cmd EVB anchor pointer
         b     EVx_wakeup_go          then, finish
EVx_wakeup_eos equ *
         l     r15,=a(EV_wakeup_eos)  get eos handler address
         la    r0,COMrex_eos          EOS EVB anchor pointer
         b     EVx_wakeup_go          then, finish
EVx_wakeup_eoj equ *
         l     r15,=a(EV_wakeup_eoj)  get eos handler address
         la    r0,COMrex_eos          EOJ EVB anchor pointer
EVx_wakeup_go equ *
         st    r0,RX_evbcom           chain EVB anchor in SVA
         xc    RX_aclen,RX_aclen      make sure no immediate action
         st    r15,RX_address2        save address in SVA
EVx_finish equ *
         lm    r0,r14,SVAregs         restore reg 0-14
         ltr   r15,r15                generate CC
         br    r14                    return
         ltorg ,
         drop  r2                     reset ECB map
         drop  r7                     reset EVB map
         drop  r12                    reset base address
         eject ,
***********************************************************************
*                                                                     *
*   Entry name -     CBTREXXC                                         *
*                                                                     *
*   Function name  - cbcmd()                                          *
*                    Execute console command                          *
*                                                                     *
***********************************************************************
         SPACE 2
CBTREXXC @ENTRY breg=(r12),svainit=YES
         SPACE 2
         l     r8,efplarg             establish arg table entry
         l     r9,EFPLEVAL            address of EVALBLOCK pointer
         l     r9,0(r9)               establish EVALBLOCK structure
         l     r5,argtable_argstring_ptr pointer of argument
         icm   r3,b'1111',argtable_argstring_length length of argument
         bz    XC_error               no, handle error
         lr    r2,r3                  copy length to reg 2
         bctr  r3,0                   reduce 1 for ex
         ex    r3,*+4                 copy source to temp area
         mvc   SVAbuf80+2(*-*),0(r5)    <<executed>>
         sth   r2,SVAbuf80            put length in 1st halfword
         @call Get_auth               require authorization
         bnz   XC_unauth              leave if error
XC_start equ   *
         la    r2,SVAbuf80            locate cmd buffer
         xc    SVAword,SVAword        zap console id to 0
         mgcre text=(r2),mf=(E,SVA_lmgcre),                            +
               cmdflag=(NOHCPY),consid=SVAword
         l     r2,SVAkey              get saved key
         spka  0(r2)                  restore key
         modeset mf=(E,SVA_lmprob)    back to problem state
         la    r1,8                   true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(8),=cl8'ISSUED'
         xr    r15,r15                set RC = 0
         b     XC_finish              finish
XC_unauth equ  *
         cvd   r15,SVAdword           convert RC to packed decimal
         oi    SVAdword+7,x'0F'       change sign to ebcdic
         unpk  SVAword,SVAdword       convert to EBCDIC
         mvi   SVAword,c' '           blank 1st digit
         la    r1,16                  true length of result
         stcm  r1,b'1111',EVALBLOCK_EVLEN specify length of result
         mvc   EVALBLOCK_EVDATA(12),=cl12'UNAUTHORIZED'
         mvc   EVALBLOCK_EVDATA+12(4),SVAword
         xr    r15,r15                set RC = 0
         b     XC_finish              finish
XC_error equ   *
         la    r15,8                  set RC = 8
XC_finish equ  *
         @exit keepRC=YES
         space ,
         cbtinsva base=CBTREXXC       SVA initializer
         space ,
*
*  +------------------------------------------------------------+
*  | Access zCBT Dataarea                                       |
*  | --------------------                                       |
*  |   Retrieve token-paired to find address of COM in common   |
*  |   storage area (CSA).                                      |
*  |                                                            |
*  |   Input:                                                   |
*  |         n/a                                                |
*  |                                                            |
*  |   Output:                                                  |
*  |                                                            |
*  |        Reg 11  - Address of COM area                       |
*  |                  (applicable only when RC in reg 15 is 0)  |
*  |        Reg 15  - Return code                               |
*  |                                                            |
*  |                                                            |
*  +------------------------------------------------------------+
*
         ds    0h
Access_zCBT equ *
         stm   r0,r15,SVAregs           save all regs
         la    r12,Access_zCBT-CBTREXXC    calculate offset
         slr   r15,r12                  calc base address
         lr    r12,r15                  establish addressability
         ago   .acc001
         space ,
*------------lock-resource--------------------
         mvc   SVAmajor,=cl8'ZCBTSSI'   resource major name
         mvc   SVAminor,=cl8'COMMAREA'  resource minor name
         @call Enqueue_system           lock system
*------------lock-resource--------------------
         space ,
.acc001  anop
         la    r1,IEANT_SYSTEM_LEVEL
         st    r1,SVAword               set share level
         mvc   SSI_shrname1,=cl8'&DERSHRID' specify entity name
         mvc   SSI_shrname2,=cl8'&DERCOMMX' specify entity type
         xc    SSI_shrtoken,SSI_shrtoken clear token
         xc    SSI_rcode,SSI_rcode      clear Rcode
         Call  IEANTRT,(SVAword,SSI_shrname,SSI_shrtoken,SSI_rcode),   +
               VL,MF=(E,SVA_calllist)
         ago   .acc002
         space ,
*------------unlock-resource------------------
         mvc   SVAmajor,=cl8'ZCBTSSI'   resource major name
         mvc   SVAminor,=cl8'COMMAREA'  resource minor name
         @call Dequeue_system           unlock system
*------------unlock-resource------------------
         space ,
.acc002  anop
         mvc   SVAregs+4*11(4),SSI_comcb place COM addr in r11 slot
         mvc   SVAregs+4*15(4),SSI_rcode place RC addr in r11 slot
         mvi   RX_jobtype,RX_job_job    assume initiated job
         l     r5,PSAAOLD               current ASCB address
         icm   r4,15,ASCBJBNI-ASCB(r5)  get jobname address
         bnz   Access_zCBT_done         go this way if exist
         mvi   RX_jobtype,RX_job_stc    must be started/mounted/logged
         icm   r4,15,ASCBJBNS-ASCB(r5)  get STC name address
         iazxjsab READ,ascb=(r5),jobid=RX_jobid
         ltr   r15,r15                  success?
         bnz   Access_zCBT_done         go this way if failed
         mvc   RX_jobtype,RX_jobid      take 1st byte of jobid
Access_zCBT_done equ *
         mvc   RX_jobname,0(r4)         copy job/user name
         lm    r0,r15,SVAregs           restore all regs
         ltr   r15,r15                  generate CC
         br    r14                      return
         eject ,
* +---------------------------------------------------+
* | Enqueue/Dequeue Services Pool                     |
* | -----------------------------                     |
* |                                                   |
* |   *  Before issueing ENQ, accummulate its         |
* |      occurrences with similar major and minor     |
* |      names                                        |
* |                                                   |
* |   *  After issueing DEQ, reduces its occurrences  |
* |      count for with similar major and minor       |
* |      names                                        |
* |                                                   |
* +---------------------------------------------------+
         space ,
* +-----------------------------------+
* | Lock Global Resource              |
* +-----------------------------------+
         ds    0h
Enqueue_system equ *
         stm   r0,r15,SVArecsv2        save all regs
         la    r12,Enqueue_system-CBTREXXC  calculate offset from base
         slr   r15,r12                 calculate base address
         lr    r12,r15                 establish base addressability
*------------lock-system-resource--------------------
         aif   (&derzos).sysenqz
         enq   (SVAmajor,SVAminor,E,8,SYSTEM), lock the resource       +
               ret=NONE,mf=(E,SVA_enq)
         ago   .sysenq
.sysenqz anop
         enq   (SVAmajor,SVAminor,E,8,SYSTEM), lock the resource       +
               ret=NONE,linkage=SYSTEM,mf=(E,SVA_enq)
.sysenq  anop
*------------lock-systm-resource--------------------
         b     Locking_done
         space ,
* +-----------------------------------+
* | Unlock Global Resource            |
* +-----------------------------------+
         ds    0h
Dequeue_system equ *
         stm   r0,r15,SVArecsv2        save all regs
         la    r12,Dequeue_system-CBTREXXC  calculate offset from base
         slr   r15,r12                 calculate base address
         lr    r12,r15                 establish base addressability
*------------unlock-system-resource------------------
         aif   (&derzos).sysdeqz
         deq   (SVAmajor,SVAminor,8,SYSTEM), release the resource      +
               ret=NONE,mf=(E,SVA_deq)
         ago   .sysdeq
.sysdeqz anop
         deq   (SVAmajor,SVAminor,8,SYSTEM), release the resource      +
               ret=NONE,linkage=SYSTEM,mf=(E,SVA_deq)
.sysdeq  anop
*------------unlock-system-resource------------------
         b     UnLocking_done
         space ,
* +-----------------------------------+
* | Lock Local Resource               |
* +-----------------------------------+
         ds    0h
Enqueue_local equ *
         stm   r0,r15,SVArecsv2        save all regs
         la    r12,Enqueue_local-CBTREXXC  calculate offset from base
         slr   r15,r12                 calculate base address
         lr    r12,r15                 establish base addressability
*------------------lock-local-resouce----------------
         aif   (&derzos).locenqz
         enq   (SVAmajor,SVAminor,E,8,STEP),  enqueue for it           +
               ret=NONE,mf=(E,SVA_enq)
         ago   .locenq
.locenqz anop
         enq   (SVAmajor,SVAminor,E,8,STEP),  enqueue for it           +
               ret=NONE,linkage=SYSTEM,mf=(E,SVA_enq)
.locenq  anop
*------------------lock-local-resouce-----------------
         b     Locking_done
         space ,
* +-----------------------------------+
* | Unlock Local Resource             |
* +-----------------------------------+
         ds    0h
Dequeue_local equ *
         stm   r0,r15,SVArecsv2        save all regs
         la    r12,Dequeue_local-CBTREXXC  calculate offset from base
         slr   r15,r12                 calculate base address
         lr    r12,r15                 establish base addressability
*------------------unlock-local-resouce---------------
         aif   (&derzos).locdeqz
         deq   (SVAmajor,SVAminor,8,STEP),  release the resource       +
               ret=NONE,mf=(E,SVA_deq)
         ago   .locdeq
.locdeqz anop
         deq   (SVAmajor,SVAminor,8,STEP),  release the resource       +
               ret=NONE,linkage=SYSTEM,mf=(E,SVA_deq)
.locdeq  anop
*------------------unlock-local-resouce---------------
         space ,
UnLocking_done equ *
Locking_done equ *
         lm    r0,r14,SVArecsv2        restore reg 0-14
         br    r14                     return
         space ,
*
*  +--------------------------------------------------------------+
*  |  Hexadecimal EBCDIC Editor                                   |
*  |  -------------------------                                   |
*  |    Input  -  SVAinword   - binary fullword                   |
*  |    Output -  SVAoutdbwd  - hex EBCDIC printable text         |
*  |                                                              |
*  +--------------------------------------------------------------+
         ds    0h
Edit_hex equ   *
         stm   r0,r15,SVArecsv2        save all regs
         la    r12,Edit_hex-CBTREXXC   calc offset from Retry1
         slr   r15,r12                 calc base address
         lr    r12,r15                 establish addressability
         @edithex input=SVAinword,length=8,output=SVAoutdbwd
         lm    r0,r15,SVArecsv2        restore all regs
         br    r14
         ltorg ,
         drop  r12                    reset base address
*
         SPACE 2
*--------------------------------------*
*  zCBT data area                      *
*--------------------------------------*
         CBTSVA   ,                    Save area
         CBTCOM   ,                    Common communication area
         CBTEVB   ,                    Event definition control block
         CBTEOT   ,                    End-of-task info control block
         SPACE 2
*--------------------------------------*
*  Rexx data area and control block    *
*--------------------------------------*
         IRXARGTB                      Argument table entry map
         IRXPARMB                      Parameter block map
         IRXEVALB                      Evalblock map
Evalblock_length equ *-Evalblock
Evalblock_dwords equ (*-Evalblock+7)/8
EVCTLEN  EQU   Evalblock_EVDATA-Evalblock
         IRXEFPL
         SPACE 2
*--------------------------------------*
*  System data area                    *
*--------------------------------------*
         CVT   DSECT=YES
         IHAECB   ,
         IHAEPIE  ,
         IHAASCB  ,
         IHAASSB  ,
         IHAPSA   ,
         IHASTCB  ,
         IAZJSAB  ,
         IKJTCB   ,
         IEANTASM ,
         IHASDWA  ,
         END
