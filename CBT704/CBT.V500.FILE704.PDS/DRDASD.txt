//DRDASD JOB (PPTM,,1,1,,STD),'ASM DRDASD',
//            CLASS=D,NOTIFY=&SYSUID,
//            MSGCLASS=X,COND=(4,LT)
//*
//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)
//*SMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,RENT)
//SYSIN     DD *
*---------------------------------------------------------------------*
*                                                                     *
* NAME:        DRDASD                                                 *
*                                                                     *
* FUNCTION:    CALL UCBSCAN MACRO TO GET DASD DEVICES.  USE THE       *
*              OBTAIN MACRO TO GATHER INFO ABOUT THE VOLUMES VTOC     *
*              (INDEX VS NON-INDEX, ETC.).  USE THE LSPACE MACRO TO   *
*              GET FREE SPACE INFORMATION.  ALLOCATE THE VTOC FOR     *
*              EACH ONLINE VOLUME AND GET THE SPACE (AND LOCATION)    *
*              INFORMATION ABOUT THE VTOC FROM THE DATA EXTENT BLOCK  *
*              THAT IS BUILT AT OPEN OF THE DD.  PACKAGE ALL OF THIS  *
*              DATA UP AND OUTPUT IT TO THE TERMINAL USING THE        *
*              PUTLINE MACRO SO THAT REXX CAN CAPTURE IT.             *
*                                                                     *
* SYNTAX:      DRDASD                                                 *
*                                                                     *
*---------------------------------------------------------------------*
* LINK EDIT INFORMATION:     NOT REENTRANT                            *
*---------------------------------------------------------------------*
* RETURN CODES: ONLY IF AN ERROR OCCURS IN THE UCBSCAN MACRO.  ALL    *
*   OTHER ERRORS ARE RETURNED AS $E ERROR MESSAGES                    *
*---------------------------------------------------------------------*
* AUTHOR:      ROB JOHNS - AMERICAN NATIONAL PROPERTY AND CASUALTY    *
*---------------------------------------------------------------------*
* HISTORY:                                                            *
*                                                                     *
*        03/09/01  -  CREATED                                         *
*        01/02/04  -  WHEN WHE SWITCHED TO 64-BIT MODE IN Z/OS,       *
*                     SOMETHING WENT WRONG.  I STILL HAVE NO IDEA     *
*                     WHAT WENT WRONG, BUT I HAD TO REWRITE A COUPLE  *
*                     OF PARTS.  I'M A DBA(SYSADM) NOT A SYSPROG, SO  *
*                     GIVE ME A BREAK!                                *
*---------------------------------------------------------------------*
DRDASD         AMODE 24         *
DRDASD         RMODE 24         *
DRDASD         CSECT

******************************************************************
* STANDARD LINKAGE IS COPIED                                     *
******************************************************************
*              COPY $$ENTER
********************************  STORE CALLER'S REGISTERS
         STM   14,12,12(13)               STORE 14-12 AT 12 OFF 13
         BALR  12,0                       LOAD 12 WITH CURRENT ADDR
         USING *,12                       ADDRESSABILITY FOR 12
**********************************************************************
         GETMAIN RC,LV=72,LOC=BELOW       GET 72 BYTES FOR SAVE (18F)
         LTR   15,15                      TEST RETURN CODE IN R15
         BZ    PASSROB                    BRANCH IF TEST ZERO

         WTO   '<$$ENTER> - BAD GETMAIN FOR REGISTER STORAGE'
         LM    14,12,12(13)               RELOAD REGISTERS
         L     15,=F'12'                  SET RETURN CODE
         BR    14                         BRANCH BACK TO CALLER
PASSROB  DS    0H
**********************************************************************
         ST    13,4(,1)                    STORE CALLERS AT 4 OFF MINE
         ST    1,8(,13)                    STORE MINE AT 8 OFF CALLERS
         LR    13,1                        LOAD REGISTER 13 WITH MINE

               B      GET_STORAGE          * SKIP OVER CONSTANTS
               DC     C'DRDASD_&SYSDATE._&SYSTIME.'


******************************************************************
* GO GET SOME STORAGE TO WORK WITH                               *
******************************************************************
GET_STORAGE    DS    0H
               GETMAIN RU,LV=WSPACEL,LOC=BELOW
               LTR   15,15                  * TEST THE RC FROM GETMAIN
               BZ    GOODGET                * IF ZERO THEN CONTINUE

               WTO   '<DRDASD> - BAD GETMAIN FOR VARIABLE STORAGE'
               B     EXIT_DRDASD

GOODGET        DS    0H
               LR    R8,R1             * SAVE ADDRESS OF STORAGE AREA
               USING WSPACE,R8         * ADDR STORAGE W/ WSPACE DSECT


******************************************************************
* USE ADDRESS OF WSPACE PLUS DISPLACEMENTS TO ADDRESS OTHER      *
* GETMAIN'D STORAGE USING DSECTS GENERATED BY A MACRO            *
******************************************************************
               USING LSPACE_DATA,WSPACE+LSPACE_D_DISP
               USING LSPACE_PARM,WSPACE+LSPACE_P_DISP


******************************************************************
* GET THE ADDRESS OF THE ENVIRONMENT BLOCK FROM OLD REGISTER 0   *
******************************************************************
               L     R6,4(,R13)        * GET ADDRESS OF CALLERS SAVE
               L     R4,20(,R6)        * LOAD OLD REG 0 INTO REG 5


******************************************************************
* GET THE ADDRESS OF THE WORK BLOCK EXTENTION                    *
******************************************************************
               USING ENVBLOCK,R4        * ADDRESS THE ENVIRONMENT BLOCK
               L     R4,ENVBLOCK_WORKBLOK_EXT * LOAD R4 WITH THE ADDR
*                                             * OF THE WORK BLOCK EXT
               DROP  R4


******************************************************************
* GET THE ADDRESS OF THE COMMAND PROCESSOR PARM LIST             *
******************************************************************
               USING WORKBLOK_EXT,R4    * ADDRESS THE REXX WORK BLOCK
               L     R4,WORKEXT_CPPLPTR * LOAD ADDRESS OF THE CPPL
               DROP  R4


******************************************************************
* GET THE ADDRESS OF THE USER PROFILE TABLE WHICH IS STORED IN   *
* THE COMMAND PROCESSOR PARAMETER LIST                           *
******************************************************************
               USING CPPL,R4            * ADDRESS THE CPPL
               L     R3,CPPLUPT         * LOAD ADDRESS OF THE UPT


******************************************************************
* GET THE ADDRESS OF THE EVENT CONTROL TABLE                     *
******************************************************************
               L     R4,CPPLECT         * LOAD ADDRESS OF THE ECT
               DROP  R4

               ST    R3,UPTADDR         * STORE UPT ADDRESS FOR LATER
               ST    R4,ECTADDR         * STORE ECT ADDRESS FOR LATER


******************************************************************
* INITIALIZE THE PUTLINE DATA AREAS                              *
******************************************************************
               MVC   ECBADS(4),=F'0'

               MVC   PUTBLOK(4),=X'00000000'
               MVC   PUTBLOK+4(4),=A(0)
               MVC   PUTBLOK+8(4),=A(0)

               MVC   TEXTOLD(4),=F'1'    * NOT "OLD", BUT "O.L.D."
               LA    R3,TEXTMSG1
               ST    R3,TEXTOLD+4

               MVC   TEXTMSG1(2),=H'76'

               MVC   TEXTMSG1+2(2),=H'0'

               MVC   TEXTMESG(1),=X'40'      * SET 1ST BYTE TO A SPACE
               MVC   TEXTMESG+1(71),TEXTMESG * MOVES OCCUR LEFT 2 RIGHT

               MVC   IOPLADS(16),=4F'0'      * THIS IS THE I/O PARM
*                                            * LIST THAT THE PUTLINE
*                                            * MACRO USES


********************************************************************
* FIRST TIME IN, INITIALIZE THE VALUES FOR THE LSPACE LOGIC.  THE  *
* CODE TO DO THIS ACTUALLY RESIDES WHERE THE OTHER LSPACE LOGIC IS.*
********************************************************************
LSPACE_INITS   DS    0H
               BAL   R9,INIT_LSPACE          * THERE AND BACK AGAIN


******************************************************************
* FIRST TIME IN, INITIALIZE THE VALUES FOR THE DSCB LOGIC.  THE  *
* CODE TO DO THIS ACTUALLY RESIDES WHERE THE OTHER DSCB LOGIC IS.*
******************************************************************
DSCB_INITS     DS    0H
               BAL   R9,INIT_DSCB_AREA       * THERE AND BACK AGAIN


******************************************************************
* FIRST TIME, AND IF THE HARDWARE CONFIGURATION HAS CHANGED, USE *
* THIS SECTION TO INITIALIZE BEFORE CALLING UCBSCAN MACRO        *
******************************************************************
* MESSAGES PUTLINE'D ARE PRECEEDED (THIS IS NOT NECESSARY FOR    *
* THE PUTLINE MACRO TO WORK) BY A MESSAGE TYPE IDENTIFIER.       *
* $D-DATA $I-INFORMATIONAL $W-WARNING $E-ERROR                   *
* JUST SOMETHING TO MAKE LIFE EASIER FOR ME ON THE OUTSIDE       *
******************************************************************
NEW_CONFIG     DS    0H
               MVC   TEXTMESG+1(28),=C'$ICONFIGURATION NEW DRDASD'
               BAL   R9,WRITE_DRDASD
               XC    UCB_WORK,UCB_WORK          * SET ALL X'00'
               XC    CONFIG_TOKEN,CONFIG_TOKEN  * SET ALL X'00'


******************************************************************
* UCB SCAN MACRO WILL RETURN COPIES OF THE DYNAMIC AND STATIC    *
* UCBS THAT ARE OUT THERE.  DID NOT USE THE DCE AREA IN THIS     *
******************************************************************
NEXT_UCB       DS    0H
               MVC   CALLED_MACRO(7),=C'UCBSCAN'

*  +------------------------------------------------------------------+
*  |    UCBSCAN MACRO IS DOCUMENTED IN MVS PROGRAMMING: ASSEMBLER     |
*  |                    SERVICES REFERENCE, VOLUME 2                  |
*  +------------------------------------------------------------------+
              UCBSCAN COPY,                 * GET COPY OF UCB          +
               WORKAREA=UCB_WORK,           * 100 BYTES INIT 1ST TIME  +
               UCBAREA=UCB_COMMON,          * 48 BYTES FOR UCB COMMON  +
               CMXTAREA=UCB_COM_EXT,        * 32 BYTES FOR UCB COM EXT +
               UCBPAREA=UCB_PRE_EXT,        * 48 BYTES FOR UCB PRE EXT +
               DEVNCHAR=DEV_NUMBER,         * 4 BYTE RECEIVES DEV NUM  +
               DEVN=0,                      * START W/1ST UCB          +
               DYNAMIC=YES,                 * INCLUDE DYN AND STATIC   +
               RANGE=ALL,                   * 3 AND 4 DIGIT DEVICE NUM +
               NONBASE=YES,                 * BASE & NONBASE EXPOSURES +
               UNBOUND_ALIAS=YES,           * ???????????????????????  +
               DEVCLASS=ALL,                * ALL DEVICES ARE INCLUDED +
               IOCTOKEN=CONFIG_TOKEN,       * I/O CONFIG. TOKEN 48BYTE +
               PLISTVER=IMPLIED_VERSION,    * ONLY USE NECESSARY VER   +
               RETCODE=RETURN_CODE,         * STORAGE FOR RETURN CODE  +
               RSNCODE=REASON_CODE          * STORAGE FOR REASON CODE

               L     R10,RETURN_CODE        * SAVE RETURN CODE
               B     *+4(R10)               * BRANCH TO CURRENT ADDRESS
*                                           * + 4 BYTES + RETURN CODE
*                                           * VALUE.

* I DID THE RC CHECKING THIS WAY SIMPLY BECAUSE IT SEEMED ENTERTAINING
               B     UCBSCAN_GOOD
               B     DRDASD_OKAY
               B     DRDASD_ERROR
               B     NEW_CONFIG             * HARDWARE CONFIG CHANGED
               B     DRDASD_ERROR
               B     DRDASD_ERROR
               B     DRDASD_ERROR


******************************************************************
* LOOKS LIKE WE RECEIVED A UCB.  MAKE SURE THAT IT IS A DASD UCB *
******************************************************************
UCBSCAN_GOOD   DS    0H
               USING UCBOB,UCB_COMMON  * EST FOR UCBOB IN IEFUCBOB
               TM    UCBTBYT3,UCB3DACC * TEST BYTE 3 - BIT 0 FOR DASD
               BZ    NEXT_UCB          * IF OFF, GO GET NEXT UCB

CHECK_STATUS   DS    0H
               TM    UCBSTAT,UCBONLI   * IS THE VOLUME ONLINE?
               BZ    NEXT_UCB          * NO - GO GET THE NEXT UCB
               B     BUILD_LINE1       * YES - OUTPUT SOME INFO
*                                      * AFTER SKIPPING THE OUTPUT
*                                      * LINE DEFINITIONS BELOW

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; D='XXXX';
********************************************************************
LINE1          DS    0H
               DC    CL5' $DV='
L1V            EQU   *-LINE1+1
               DC    XL8'7DE7E7E7E7E7E77D'
               DC    CL4'; D='
L1D            EQU   *-LINE1+1
               DC    XL6'7DE7E7E7E77D'
LINE1_LEN      EQU   *-LINE1

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; FC=XXXXXXXXXXXXXXXX; FT=XXXXXXXXXXXXXXXX
********************************************************************
LINE2A         DS    0H
               DC    CL5' $DV='
L2AV           EQU   *-LINE2A+1
               DC    XL8'7DE7E7E7E7E7E77D'
               DC    CL5'; FC='
L2AFC          EQU   *-LINE2A
               DC    CL16'XXXXXXXXXXXXXXXX'
               DC    CL5'; FT='
L2AFT          EQU   *-LINE2A
               DC    CL16'XXXXXXXXXXXXXXXX'
LINE2A_LEN     EQU   *-LINE2A

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; FE=XXXXXXXXXXXXXXXX;
********************************************************************
LINE2B         DS    0H
               DC    CL5' $DV='
L2BV           EQU   *-LINE2B+1
               DC    XL8'7DE7E7E7E7E7E77D'
               DC    CL5'; FE='
L2BFE          EQU   *-LINE2B
               DC    CL16'XXXXXXXXXXXXXXXX'
LINE2B_LEN     EQU   *-LINE2B

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; LC=XXXXXXXXXXXXXXXX; LT=XXXXXXXXXXXXXXXX
********************************************************************
LINE2C         DS    0H
               DC    CL5' $DV='
L2CV           EQU   *-LINE2C+1
               DC    XL8'7DE7E7E7E7E7E77D'
               DC    CL5'; LC='
L2CLC          EQU   *-LINE2C
               DC    CL16'XXXXXXXXXXXXXXXX'
               DC    CL5'; LT='
L2CLT          EQU   *-LINE2C
               DC    CL16'XXXXXXXXXXXXXXXX'
LINE2C_LEN     EQU   *-LINE2C

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; VIX='X'; VIXS='X'; SMSM='X'
********************************************************************
LINE3          DS    0H
               DC    CL5' $DV='
L3V            EQU   *-LINE3+1
               DC    XL8'7DE7E7E7E7E7E77D'
               DC    CL6'; VIX='
L3VIX          EQU   *-LINE3+1
               DC    XL3'7DE77D'
               DC    CL7'; VIXS='
L3VIXS         EQU   *-LINE3+1
               DC    XL3'7DE77D'
               DC    CL7'; SMSM='
L3SMSM         EQU   *-LINE3+1
               DC    XL3'7DE77D'
LINE3_LEN      EQU   *-LINE3

********************************************************************
*            1         2         3         4         5         6
*  0123456789012345678901234567890123456789012345678901234567890123
*   $DV='XXXXXX'; SC=XXXX; ST=XXXX; EC=XXXX; ET=XXXX; VT=XXXX
********************************************************************
LINE4          DS    0H
               DC    CL5' $DV='
L4V            EQU   *-LINE4+1
               DC    XL8'7DE7E7E7E7E7E77D'
L4SC           EQU   *-LINE4+5
L4ST           EQU   *-LINE4+14
               DC    CL19'; SC=XXXX; ST=XXXX;'
L4EC           EQU   *-LINE4+4
L4ET           EQU   *-LINE4+13
L4VT           EQU   *-LINE4+22
               DC    CL26' EC=XXXX; ET=XXXX; VT=XXXX'
LINE4_LEN      EQU   *-LINE4


********************************************************************
* WRITE OUT THE INFO THAT YOU GATHER FROM THE UCB                  *
********************************************************************
BUILD_LINE1    DS    0H
               MVC   TEXTMESG(LINE1_LEN),LINE1 * MOVE LINE1 TEXT TO OUT

               MVC   STORE_VOLSER,UCBVOLI        * STORE VOLSER 4 LATER
               MVC   TEXTMESG+L1V(6),UCBVOLI     * VOLSER TO OUTLINE
               MVC   TEXTMESG+L1D(4),DEV_NUMBER  * DEVICE ADDR TO OUT

               BAL   R9,WRITE_DRDASD           * WRITE OUTPUT
               B     DO_LSPACE                 * INIT IS "CALLED" ONLY
*                                              * SO SKIP IT!


**********************************************************************
* USE THE LSPACE MACRO TO GET THE FREE SPACE INFO AND BUILD THE NEXT *
* LINE OF OUTPUT.                                                    *
**********************************************************************
* IT SEEMED MORE PLEASING TO ME TO KEEP THE LSPACE STUFF TOGETHER *
* BUT THIS STUFF ONLY NEEDS TO BE EXECUTED ONCE... SO, I BRANCH   *
* TO IT IN THE SECTION WHERE I AM INITIALIZING THINGS AND THEN    *
* RETURN TO THE ADDRESS IN REGISTER 9 (USE BAL R9 TO CALL)        *
*******************************************************************
INIT_LSPACE    DS    0H
               XC    LSPACE_PARM,LSPACE_PARM  * SET ALL X'00'

               MVC   LSPAPLID(4),=C'LSPA'   * LSPA IN FIRST 4 BYTES
               MVC   LSPANGTH(2),=X'001B'   * LENGTH OF LSPA AREA
               OI    LSPAFLAG,LSPADATA      * SET FLAG TO "DATA"
*                    LSPARSVD(1) - RESERVED
               OI    LSPASFID,LSPASF06      * SET "READ VOL LABEL"
*                                           * IN SUBFUNCTION ID


               LA    R6,UCB_COMMON  * LOAD ADDRESS OF OUR UCB COPY
               ST    R6,LSPAUCB     * LSPACE USES THIS TO FIND UCB COPY

               LA    R6,LSPACE_DATA    * LOAD ADDRESS OF DATA AREA
               ST    R6,LSPAFRSP       * LSPACE RETURNS DATA TO IT

               BR    R9                * RETURN TO WHERE WE CAME FROM


**********************************************************************
* USE THE LSPACE MACRO TO RETURN THE FREE SPACE INFO TO OUR DATA AREA*
**********************************************************************
DO_LSPACE      DS    0H
               MVC   CALLED_MACRO(7),=C'LSPACE '

* SUBFUNCTION CODE IS SET TO PROCESS COMPLETE X'00' AFTER SUCCESSFUL
* EXECUTION
               OI    LSPASFID,LSPASF06   * SET "READ VOL LABEL"

*  +------------------------------------------------------------------+
*  |     LSPACE MACRO IS DOCUMENTED IN DFSMSDFP ADVANCED SERVICES     |
*  +------------------------------------------------------------------+
               LSPACE MF=(E,LSPACE_PARM)

               CLC   LSPAERCD,=X'00'  * RETURN CODE IS RETURNED IN THE
*                                     * LSPACE PARMS AREA WE PROVIDED
               BNE   NO_SPACE         * IF THIS FAILED, GO MAKE A NOTE

* EACH OF THE VALUES RETURNED BY LSPACE WERE IN 4 BYTE BINARY NUMERIC
* FIELDS.  THIS MEANS WE HAVE TO CONVERT TO DECIMAL AND UNPACK THEM
* AND "OR" THE SIGN BEFORE WE CAN MAKE THEM PRINTABLE.
               MVC   TEXTMESG(LINE2A_LEN),LINE2A * INIT OUTPUT W/ LINE2
               MVC   TEXTMESG+L2AV(6),STORE_VOLSER   * VOLSER TO OUTPUT
               L     R3,LSPDTCYL
               BAL   R9,CNVTF2D_CHAR
               MVC   TEXTMESG+L2AFC(16),STORE_AREA16 * TOTAL FREE CYL
               L     R3,LSPDTTRK
               BAL   R9,CNVTF2D_CHAR
               MVC   TEXTMESG+L2AFT(16),STORE_AREA16 * ADDITIONAL TRKS
               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO
*                                                    * LINE2A

               MVC   TEXTMESG(LINE2B_LEN),LINE2B * INIT OUTPUT W/ LINE2
               MVC   TEXTMESG+L2BV(6),STORE_VOLSER   * VOLSER TO OUTPUT
               L     R3,LSPDNEXT
               BAL   R9,CNVTF2D_CHAR
               MVC   TEXTMESG+L2BFE(16),STORE_AREA16 * NUM FREE EXTENTS
               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO
*                                                    * LINE2B

               MVC   TEXTMESG(LINE2C_LEN),LINE2C * INIT OUTPUT W/ LINE2
               MVC   TEXTMESG+L2CV(6),STORE_VOLSER   * VOLSER TO OUTPUT
               L     R3,LSPDLCYL
               BAL   R9,CNVTF2D_CHAR
               MVC   TEXTMESG+L2CLC(16),STORE_AREA16 * LARGEST CYLS
               L     R3,LSPDLTRK
               BAL   R9,CNVTF2D_CHAR
               MVC   TEXTMESG+L2CLT(16),STORE_AREA16 * ADDL LRGST TRKS
               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO
*                                                    * LINE2B

               B     END_CNVTF2D            * BRANCH AROUND SUBROUTINE


******************************************************************
* THIS IS A SUBROUTINE THAT IS CALLED REPEATEDLY AND THEN WILL   *
* BE BRANCHED AROUND.  IT CONVERTS A BINARY FULL WORD INTO A     *
* DOUBLE WORD CHARACTER STRING.  LOAD R3 WITH THE VALUE TO BE    *
* CONVERTED AND BAL R9,CNVTF2D_CHAR TO USE IT.  THE UNPACKED     *
* CHARACTER 16 BYTE NUMBER WILL BE FOUND IN STORE_AREA16.        *
******************************************************************
CNVTF2D_CHAR DS      0H
* CONVERT 4 BYTE BINARY TO 8 BYTE SIGNED DECIMAL
               CVD   R3,STORE_AREA8
* UNPACK 8 BYTE DECIMAL INTO 16 BYTE CHARACTER WITH SIGN IN FIRST
* HALF OF LAST BYTE
               UNPK  STORE_AREA16(16),STORE_AREA8(8)
* "OR" THE LAST BYTE WITH 1111 0000 TO CHANGE THE SIGN (NON-PRINTABLE)
* SO THAT THE LAST BYTE WILL BE A PRINTABLE (F?) CHARACTER
               OI    STORE_AREA16+15,X'F0'

               BR    R9           * BRANCH BACK TO THE CALLER
END_CNVTF2D  DS     0H


               B     GET_FORMAT4      * SKIP PAST THE INIT ROUTINE FOR
*                                     * DSCB PROCESSING WHICH WAS
*                                     * BAL'D TO IN INIT SECTION ABOVE

NO_SPACE       DS    0H
               MVC   TEXTMESG(3),=C' $W'           * MESG TYPE WARNING
               MVC   TEXTMESG+6(6),STORE_VOLSER    * VOLSER TO OUTPUT
               MVC   TEXTMESG+14(12),=C'LSPACE_DATA='
               MVC   TEXTMESG+26(36),LSPACE_DATA   * OUTPUT RETURN DATA
*                                                  * WHEN THERE IS AN
*                                                  * ERROR, RETURN DATA
*                                                  * CONTAINS MESSAGE
*                                                  * FROM LSPACE MACRO
               BAL   R9,WRITE_DRDASD               * WRITE OUT TEXT
* WRJOHN - SHOULD PROBABLY ERROR OUT HERE
               B     GET_FORMAT4      * SKIP PAST THE INIT ROUTINE FOR
*                                     * DSCB PROCESSING WHICH WAS
*                                     * BAL'D TO IN INIT SECTION ABOVE


******************************************************************
* IT SEEMED MORE PLEASING TO ME TO KEEP THE DSCB STUFF TOGETHER, *
* BUT THIS STUFF ONLY NEEDS TO BE EXECUTED ONCE... SO, I BRANCH  *
* TO IT IN THE SECTION WHERE I AM INITIALIZING THINGS AND THEN   *
* RETURN TO THE ADDRESS IN REGISTER 9 (USE BAL R9 TO CALL)       *
******************************************************************
INIT_DSCB_AREA DS    0H
               MVC   DSCBABC(4),DSCBABC_MVC  * MOVE 1ST 4 BYTES TO OUR
*                                            * STORAGE
               LA    R6,DSABC                * LOAD DSNAME ADDRESS
               ST    R6,DSCBABC+4            * STORE IN OUR PARMS
               LA    R6,STORE_VOLSER         * LOAD ADDR OF VOLSER
               ST    R6,DSCBABC+8            * STORE IN OUR PARMS
               LA    R6,DSCB_WORK            * LOAD ADDR OF WORK AREA
               ST    R6,DSCBABC+12           * STORE IN OUR PARMS

               MVC   DSABC(1),=X'04'         * INIT DSNAME TO ALL X'04'
               MVC   DSABC+1(43),DSABC

               BR    R9                      * BRANCH TO RETURN ADDRESS


******************************************************************
* USE THE OBTAIN MACRO TO GET THE FORMAT 4 DSCB FOR A VOLUME     *
******************************************************************
GET_FORMAT4    DS    0H
               OBTAIN DSCBABC                * READ DSCB FOR DATA
               LTR   R15,R15        * LOAD AND TEST RETURN CODE
               BZ    DSCB_LINE      * IF RC0 THEN CONTINUE

*              * IF IT FAILED, ISSUE A WARNING MESSAGE
               LR    R10,R15                 * MOVE RETURN CODE
               LA    R6,DRDASD_RC            * LOAD ADDRESS OF RC TEXT
               L     R6,0(R10,R6)            * LOAD R6 WITH 4 BYTES AT
*                                            * 0 OFF OF R6+RC
               MVC   TEXTMESG+1(2),=C'$W'
               MVC   TEXTMESG+3(6),STORE_VOLSER
               MVC   TEXTMESG+11(28),=C'DSCB FORMAT4 OBTAIN FAILED- '
               ST    R6,TEXTMESG+40          * STORE RC TEXT
               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG

               B     ALLOC_VOLUME            * SKIP DSCB LINE OUTPUT
*                                            * AND GO ALLOCATE VTOC


******************************************************************
* USE THE FORMAT 4 DSCB TO GET INFO ABOUT THE VOLUME             *
******************************************************************
DSCB_LINE      DS    0H

               MVC   TEXTMESG(LINE3_LEN),LINE3 * MOVE LINE3 TEXT TO OUT
               MVC   TEXTMESG+L3V(6),STORE_VOLSER

               USING FORMAT4,DSCB_WORK       * MAP THE FORMAT 4 DSCB

*              ******************************************
*              * DOES THIS VOLUME HAVE AN INDEXED VTOC? *
*              ******************************************
               MVC   TEXTMESG+L3VIX(1),=C'Y' * DEFAULT TO YES
               TM    DS4VTOCI,DS4IVTOC        * INDEXED VTOC?
               BO    VTOC_IX_STATUS           * YES - TAKE DEFAULT

               MVC   TEXTMESG+L3VIX(1),=C'N' * SET TO VALUE OF NO


VTOC_IX_STATUS DS    0H
*              *************************************
*              * HAS THE VTOC INDEX BEEN DISABLED? *
*              *************************************
               MVC   TEXTMESG+L3VIXS(1),=C'D' * DEFAULT TO DISABLED
               TM    DS4VTOCI,DS4DVTOC        * INDEXED VTOC DISABLED?
               BO    SMS_MANAGED              * YES - BRANCH

               MVC   TEXTMESG+L3VIXS(1),=C'E' * SET TO VALUE OF ENABLED

SMS_MANAGED    DS    0H
*              ******************************************
*              * IS THIS VOLUME UNDER SMS CONTROL?      *
*              ******************************************
               MVC   TEXTMESG+L3SMSM(1),=C'N' * DEFAULT TO NON-SMS
               TM    DS4SMSFG,DS4SMS          * NON-SMS VOLUME?
               BZ    DSCB_WRITE               * ALL ZEROS = DEFAULT IT

*              * EITHER BIT 0 OR BIT 1 OR BOTH ARE ON *
               MVC   TEXTMESG+L3SMSM(1),=C'Y' * SET SMS DEFAULT TO YES
               TM    DS4SMSFG,DS4SMS          * ARE BITS 0 AND 1 ON?
               BO    DSCB_WRITE               * YES - LEAVE VALUE Y

*              * EITHER BIT 0 OR BIT 1 IS ON, BUT NOT BOTH *
               MVC   TEXTMESG+L3SMSM(1),=C'I' * SET SMS DEFAULT TO INIT
               TM    DS4SMSFG,DS4SMSCV        * IS BIT 1 ON?
               BO    DSCB_WRITE               * YES - KEEP VALUE 'I'

*              * DON'T KNOW WHAT BIT 0 ONLY MEANS (RESERVED) *
               MVC   TEXTMESG+L3SMSM(1),=C'?' * STATUS IS UNKNOWN TO ME


DSCB_WRITE     DS    0H
               BAL   R9,WRITE_DRDASD         * WRITE THE DSCB LINE


******************************************************************
* ALLOCATE THE VTOC ON THE VOLUME SO THAT WE CAN EXAMINE THE     *
* DATA EXTENT BLOCK THAT IS CREATED AT DCB OPEN                  *
******************************************************************
ALLOC_VOLUME   DS    0H
               MVC   CALLED_MACRO(7),=C'DYNALLC'
               MVC   VOLSER+6(6),STORE_VOLSER
               MVC   UNIT+6(4),=C'DISK'
               LA    R1,ALOC
               MVC   ALOCTP,=A(VTOCALOC)
               MVC   ALOCVC,=AL1(1)
               DYNALLOC
               LTR   R15,R15
               BZ    ALOCOK
               MVC   TEXTMESG+1(2),=C'$W'
               MVC   TEXTMESG+3(6),STORE_VOLSER
               MVC   TEXTMESG+11(28),=C'DYNALLOC FAILED FOR VOLUME- '
               ST    R6,TEXTMESG+40          * STORE RC TEXT
               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG
               B     AFTER_DYNALLOC          * SKIP VTOC ALLOC LOGIC


***********************************************************************
* OKAY, NOW WE NEED TO PREPARE THE JOB FILE CONTROL BLOCK FOR THIS    *
* DCB BEFORE WE OPEN IT.                                              *
***********************************************************************
ALOCOK         DS    0H
*              **************************************************
*              * THIS MACRO MOVES A JFCB INTO THE USER SUPPLIED *
*              * AREA SPECIFIED ON THE EXLST= PARM OF THE DCB   *
*              **************************************************
               RDJFCB VTOC
               LTR   R15,R15
               BZ    DD_OKAY
               MVC   TEXTMESG+1(2),=C'$W'
               MVC   TEXTMESG+3(6),STORE_VOLSER
               MVC   TEXTMESG+11(24),=C'JFCB PROCESSING FAILED- '
               ST    R6,TEXTMESG+36          * STORE RC TEXT
               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG
               B     UNALLOC                 * GO UNALLOC THE DCB
DD_OKAY  DS    0H
               LA    R5,JFCBAREA * POINTED TO BY THE RDJFLIST AREA
               USING INFMJFCB,R5 * DEFINED IN THE IEFJFCBN MACRO
               MVI   JFCBDSNM,X'04'
               MVC   JFCBDSNM+1(43),JFCBDSNM
               OPEN  (VTOC,(INPUT)),TYPE=J
* WRJOHN CHECK RETURN CODE? - SEE IF THIS REALLY WORKS...
               LTR   R15,R15
               BZ    CHEK4DEB
               MVC   TEXTMESG+1(2),=C'$W'
               MVC   TEXTMESG+3(6),STORE_VOLSER
               MVC   TEXTMESG+11(24),=C'OPEN FAILED FOR VOLUME- '
               ST    R6,TEXTMESG+36          * STORE RC TEXT
               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG
               B     UNALLOC                 * GO UNALLOC THE DCB

CHEK4DEB       DS    0H
               LA    R6,VTOC
               USING IHADCB,R6
               L     R6,DCBDEBAD
               DROP  R6
               USING DEBBASIC,R6
               LA    R6,DEBBASND
               DROP  R6
               MVC   TEXTMESG(LINE4_LEN),LINE4   * INIT OUTPUT W/ LINE4
               MVC   TEXTMESG+L4V(6),STORE_VOLSER * VOLSER TO OUTPUT
               USING DEBDASD,R6

               LH    R7,DEBSTRCC                 * LOAD HALF BIN 2 REG
               CVD   R7,CVD_AREA                 * CNVT 2 PACKED 4 BYTE
               UNPK  CHAR_AREA(4),CVD_AREA(8)    * UNPACK INTO 8 CHAR
               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN
               MVC   TEXTMESG+L4SC(4),CHAR_AREA  * VTOC STARTING CYL

               LH    R7,DEBSTRHH
               CVD   R7,CVD_AREA
               UNPK  CHAR_AREA(4),CVD_AREA(8)
               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN
               MVC   TEXTMESG+L4ST(4),CHAR_AREA  * VTOC STARTING TRK

               LH    R7,DEBENDCC
               CVD   R7,CVD_AREA
               UNPK  CHAR_AREA(4),CVD_AREA(8)
               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN
               MVC   TEXTMESG+L4EC(4),CHAR_AREA  * VTOC ENDING CYL

               LH    R7,DEBENDHH
               CVD   R7,CVD_AREA
               UNPK  CHAR_AREA(4),CVD_AREA(8)
               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN
               MVC   TEXTMESG+L4ET(4),CHAR_AREA  * VTOC ENDING TRK

               LH    R7,DEBNMTRK
               CVD   R7,CVD_AREA
               UNPK  CHAR_AREA(4),CVD_AREA(8)
               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN
               MVC   TEXTMESG+L4VT(4),CHAR_AREA  * VTOC TOTAL TRKS

               BAL   R9,WRITE_DRDASD
               DROP  R6

CLOSE          DS    0H
               CLOSE VTOC
UNALLOC        DS    0H
               LA    R1,ALOC
               MVC   ALOCTP,=A(VTOCULOC)
               MVC   ALOCVC,=AL1(2)
               DYNALLOC
               LTR   R15,R15
               BZ    AFTER_DYNALLOC
               LR    R10,R15
               MVC   TEXTMESG+1(29),=C'$EUNABLE TO DEALLOCATE VOLUME'
               BAL   R9,WRITE_DRDASD
               B     DRDASD_ERROR

AFTER_DYNALLOC DS    0H
               B     NEXT_UCB  * GO BACK TO THE TOP OF THE LOOP


******************************************************************
* USE THE PUTLINE MACRO TO SEND THE DATA LINE TO THE TERMINAL    *
******************************************************************
WRITE_DRDASD DS      0H

               L     R3,UPTADDR   * HAD TROUBLE WITH USING SYMBOLICS
               L     R4,ECTADDR   * HAD TROUBLE WITH USING SYMBOLICS

              PUTLINE PARM=PUTBLOK,         * ADDR OF PUTLINE PARM BLK +
               UPT=(3),                     * ADDR OF USER PROF TABLE  +
               ECT=(4),                     * ADDR OF ENV CNTL TABLE   +
               ECB=ECBADS,                  * ADDR OF EVENT CNTL BLOCK +
               OUTPUT=(TEXTOLD,TERM,SINGLE,INFOR),                     +
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +
               MF=(E,IOPLADS)               * EXEC AND IO PARM LIST

               MVC   TEXTMESG(1),=X'40'      * SET 1ST BYTE TO A SPACE
               MVC   TEXTMESG+1(71),TEXTMESG * MOVES OCCUR LEFT 2 RIGHT

               BR    R9           * NORMALLY, ADDR OF NEXT_UCB


******************************************************************
* AN ERROR OCCURED DURING PROCESSING                             *
******************************************************************
DRDASD_ERROR DS      0H
               MVC   TEXTMESG+1(25),=C'$EERROR - BAD RETURN FROM'
               MVC   TEXTMESG+27(7),CALLED_MACRO

               LA    R3,DRDASD_RC          * LOAD ADDRESS OF RC TEXT
               L     R3,0(R10,R3)          * LOAD R3 WITH 4 BYTES AT
*                                          * 0 OFF OF R3+RC
               ST    R3,TEXTMESG+36        * STORE RC TEXT
               BAL   R9,WRITE_DRDASD       * WRITE ERROR MESSAGE

               L     R10,REASON_CODE       * LOAD REASON CODE
               LA    R3,DRDASD_RE          * LOAD ADDR OF RC TEXT AREA
               LA    R3,0(R10,R3)          * LOAD ADDRESS OF 1 BYTE
*                                          * REASON @ 0 OFF OF R10+R3
               MVC   TEXTMESG+40(1),0(R3)  * MOVE REASON TO TEXTMESG
               BAL   R9,WRITE_DRDASD       * WRITE ERROR MESSAGE

               LA    R10,0                 * SET RC TO ZERO
               B     EXIT_DRDASD


******************************************************************
* SUCCESSFULL END OF PROGRAM                                     *
******************************************************************
DRDASD_OKAY    DS    0H
               MVC   TEXTMESG+1(19),=C'$ISUCCESSFUL DRDASD'
               BAL   R9,WRITE_DRDASD
               LA    R10,0
               B     EXIT_DRDASD


******************************************************************
* SET RC, RELOAD CALLERS REGS AND BRANCH BACK TO CALLER          *
******************************************************************
EXIT_DRDASD    DS    0H
               LR    R15,R10

*              COPY $$EXIT
EXITPROG DS    0H
         L     13,4(,13)             LOAD ADDR OF CALLERS SAVE AREA
         L     14,12(,13)            LOAD REGISTER 14 FROM 12 OFF
         LM    0,12,20(13)           LOAD REG0-12 FROM 20 OFF
         BR    14                    RETURN TO CALLER

*              COPY $$REGS
**********************************************************************
*                                 EQUATE THE WORLD AS WE KNOW IT
R0       EQU   00
GETADDR  EQU   01  <----- GETMAIN STORAGE ADDRESS RETURNS HERE
R1       EQU   01  <----- GETMAIN STORAGE ADDRESS RETURNS HERE
R2       EQU   02
R3       EQU   03
R4       EQU   04
R5       EQU   05
R6       EQU   06
R7       EQU   07
R8       EQU   08
R9       EQU   09
R10      EQU   10
R11      EQU   11
BASE1    EQU   12 <----- BASE REGISTER OF CSECT
R12      EQU   12 <----- BASE REGISTER OF CSECT
SAVEAREA EQU   13 <----- ADDRESS OF MY SAVE AREA FOR CALLERS
R13      EQU   13 <----- ADDRESS OF MY SAVE AREA FOR CALLERS
PSW      EQU   14 <----- PROGRAM STATUS WORD
R14      EQU   14 <----- PROGRAM STATUS WORD
RTNCODE  EQU   15 <----- RETURN CODES GO HERE
R15      EQU   15 <----- RETURN CODES GO HERE
**********************************************************************


******************************************************************
* RETURN CODE TEXTS                                              *
******************************************************************
DRDASD_RC      DS    0F
DRDASD_RC0     DC    CL4'RC00'
DRDASD_RC4     DC    CL4'RC04'
DRDASD_RC8     DC    CL4'RC08'
DRDASD_RC12    DC    CL4'RC12'
DRDASD_RC16    DC    CL4'RC16'
DRDASD_RC20    DC    CL4'RC20'
DRDASD_RC24    DC    CL4'RC24'

DRDASD_RE      DS    0F
DRDASD_RE0     DC    CL1'0'
DRDASD_RE1     DC    CL1'1'
DRDASD_RE2     DC    CL1'2'
DRDASD_RE3     DC    CL1'3'
DRDASD_RE4     DC    CL1'4'
DRDASD_RE5     DC    CL1'5'
DRDASD_RE6     DC    CL1'6'
DRDASD_RE7     DC    CL1'7'
DRDASD_RE8     DC    CL1'8'
DRDASD_RE9     DC    CL1'9'
DRDASD_REA     DC    CL1'A'
DRDASD_REB     DC    CL1'B'
DRDASD_REC     DC    CL1'C'
DRDASD_RED     DC    CL1'D'
DRDASD_REE     DC    CL1'E'
DRDASD_REF     DC    CL1'F'


******************************************************************
* BUILD THE AREAS NEEDED TO USE THE OBTAIN MACRO... TO KEEP IT   *
* REENTRANT, I BUILD THEM HERE AT COMPILE TIME WITH THE CAMLST   *
* MACRO AND MOVE THE AREA TO STORAGE AT RUN TIME WHERE I WILL    *
* POPULATE IT WITH THE CORRECT ADDRESSES.                        *
******************************************************************
DSCBABC_MVC    CAMLST SEARCH,DSABC_MVC,VOLNUM_MVC,DSCB_WORK_MVC
DSABC_MVC      DS F       * DATASET NAME AREA
VOLNUM_MVC     DS F       * ADDRESS OF THE STORED VOLSER (CHAR 6)
DSCB_WORK_MVC  DS F       * ADDRESS OF OUR 144 BYTE WORK AREA


ALOC           DC    A(X'80000000'+ALOCRB)
ALOCRB         DC    AL1(20)
ALOCVC         DC    AL1(1)
               DC    AL2(0)
ALOCER         DC    AL2(0)
ALOCIN         DC    AL2(0)
ALOCTP         DC    A(0)
               DC    A(0)
               DC    A(0)
DDNX           DC    XL2'1',XL2'1',AL2(8),CL8'VTOC'
DISP           DC    XL2'4',XL2'1',XL2'1',XL1'8'
UNIT           DC    XL2'15',XL2'1',AL2(4),CL4' '
VOLSER         DC    XL2'10',XL2'1',AL2(6),CL6' '
VTOCALOC       CALL  ,(DDNX,DISP,UNIT,VOLSER),VL,MF=L
VTOCULOC       CALL  ,(DDNX),VL,MF=L
VTOC          DCB DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,              +
               MACRF=E,EODAD=CLOSE,EXLST=RDJFLIST
* VTOC   DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,
*              MACRF=(R),EODAD=CLOSE,EXLST=RDJFLIST
RDJFLIST       DC    X'07',AL3(JFCBAREA)
JFCBAREA       DC    176X'0'
* ROB TEST SNAP DCB
SNAPDCB  DCB   DDNAME=SNAP,DSORG=PS,MACRF=W,RECFM=VBA,LRECL=125,       *
               BLKSIZE=882
* ROB TEST SNAP
ROBSNAP        DC    CL7'VOLSER='
               DS    0F
ROBSNAP_VOLSER DS    CL6
               DS    0F
               DC    CL7'UCBCOM='
               DS    0F
ROBSNAP_UCB    DS    XL48
               DS    0F
               DC    CL7'LSPACE='
               DS    0F
ROBSNAP_DATA   DS    CL(40)
ROBSNAP_END    EQU   *


******************************************************************
* THE FOLLOWING IS ACTUALLY THE AREA THAT WILL BE USED TO MAP    *
* OUR STORAGE AREA THAT WE REQUEST IN THE BEGINNING OF THE CSECT *
******************************************************************
WSPACEL        DC    A(4096)
WSPACE         DSECT
UPTADDR        DS    A
ECTADDR        DS    A
ECBADS         DS    F            * FULL WORD VALUE F'0'
*              DS    0F           * FULL WORD BOUNDRY (DONT NEED?)
PUTBLOK        DS    XL4          * 4 BYTES VALUE X'00000000'
               DS    A            * ADDRESS VALUE A(0)
               DS    A            * ADDRESS VALUE A(0)
TEXTOLD        DS    F            * NUMBER OF MESSAGES VALUE F'1'
               DS    A            * ADDRESS OF TEXTMSG1
TEXTMSG1       DS    H            * LENGTH OF TEXTMSG1 & MESG H'76'
               DS    H            * HALF WORD (DISPLACEMENT) VALUE H'0'
TEXTMESG       DS    CL72         * 72 BYTE MESSAGE AREA
IOPLADS        DS    4F           * 4 FULL WORDS VALUE 4F'0'
               DS    0F
UCB_COMMON     DS    XL48
UCB_COM_EXT    DS    XL32
UCB_PRE_EXT    DS    XL48
DEV_NUMBER     DS    XL4
DEV_ADDR       DS    H
CONFIG_TOKEN   DS    XL48
RETURN_CODE    DS    F
REASON_CODE    DS    F
UCB_WORK       DS    XL100

CALLED_MACRO   DS    CL9
STORE_VOLSER   DS    CL6
DSCBABC        DS    4F
DSABC          DS    CL44    * DSNAME IS ALL X'04' FOR FORMAT 4 DSCB
DSCB_WORK      DS    140C    * 140 BYTE WORK AREA FOR DSCB

CVD_AREA       DS    F
UNPK_AREA      DS    D
CHAR_AREA      DS    F
STORE_AREA8    DS    CL8
STORE_AREA16   DS    CL16
VOLDAT_DISP    EQU *-WSPACE
LSPACE_VOLDAT  DS    0F
               DS    CL40         * THIS APPEARS TO BE CL36, BUT I
*                                 * ADDED 4 JUST TO BE SAFE
LSPACE_D_DISP  EQU   *-WSPACE
LSPACE_DATA    LSPACE MF=(D,DATA)
               EJECT
LSPACE_P_DISP  EQU   *-WSPACE
* USE THE MF=D FORM OF THE LSPACE MACRO TO CREATE THE PARMS DSECT
LSPACE_PARM    LSPACE MF=D
               EJECT

*SPACEL        EQU   *-WSPACE

* MAPPING MACRO FOR THE REXX ENVIRONMENT BLOCK
               IRXENVB
               EJECT
* MAPPING MACRO FOR THE REXX WORK BLOCK EXTENTION
               IRXWORKB
               EJECT
* MAPPING MACRO FOR THE COMMAND PROCESSOR PARAMETER LIST (CPPL)
               IKJCPPL
               EJECT
* MAPPING MACRO FOR UNIT CONTROL BLOCKS (UCB)
               IEFUCBOB
               EJECT
* MAPPING MACRO FOR THE DSCB FORMAT 4 (NO DSECT PROVIDED BY MACRO)
FORMAT4        DSECT
               IECSDSL1 4
               EJECT


*******************************************************************
* MAPPING MACROS FOR DYNALLOC PROCESSING AREAS
*******************************************************************

* MAPPING MACRO FOR JOB FILE CONTROL BLOCK
JFCB           DSECT
               IEFJFCBN
               EJECT

* MAPPING MACRO FOR THE DATA CONTROL BLOCK
DCBDSECT       DCBD DEVD=DA,DSORG=PS
               EJECT

* MAPPING MACRO FOR THE DATA EXTENT BLOCK
DEBDSECT       IEZDEB LIST=YES
               EJECT

               END
/*
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=SYS0.DRDASD.SOURCE
//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(15,15),RLSE),DISP=(,PASS)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),
//            DISP=(,PASS),DCB=BLKSIZE=3200
//*
//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)
//SYSLMOD  DD DISP=SHR,DSN=SYS0.DRDASD.LOADLIB(DRDASD)
//SYSPRINT DD SYSOUT=*
