{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012628000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE704.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE704.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\t'", "DS1TRBAL": "b'\\xa3:'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xdb\\x00\\n\\x04\\xdb\\x00\\x0e\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04D\\x00\\x00\\x01\\x05\\x04?\\x01\\x05\\x04?\"X\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf8@@@'", "ispf": {"version": "04.68", "flags": 0, "createdate": "2005-02-12T00:00:00", "modifydate": "2005-02-12T22:58:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-468"}, "text": "REGULAR CBT TAPE - VERSION 468    FILE:  704\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT468.FILE704\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,239 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/12/05    22:58:49    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE704": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04D\\x00\\x00\\x01\\x05\\x04?\\x01\\x05\\x04?\"X\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf8@@@'", "ispf": {"version": "04.68", "flags": 0, "createdate": "2005-02-12T00:00:00", "modifydate": "2005-02-12T22:58:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "CBT-468"}, "text": "//***FILE 704 is from Rob Johns and contains a program called       *   FILE 704\n//*           DRDASD which can help you to keep track of the        *   FILE 704\n//*           status of all the disk packs that are attached to     *   FILE 704\n//*           each LPAR.  Member README will tell you how to        *   FILE 704\n//*           interpret the data from the DRDASD program.           *   FILE 704\n//*                                                                 *   FILE 704\n//*           email:  rob.johns@anpac.com                           *   FILE 704\n//*                                                                 *   FILE 704\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DRDASD": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x042\\x1f\\x01\\x042\\x1f\\x10\\x19\\x03\\xe3\\x03\\xe3\\x00\\x00\\xd9\\xd1\\xd6\\xc8\\xd5\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-11-16T00:00:00", "modifydate": "2004-11-16T10:19:00", "lines": 995, "newlines": 995, "modlines": 0, "user": "RJOHNS"}, "text": "//DRDASD JOB (PPTM,,1,1,,STD),'ASM DRDASD',\n//            CLASS=D,NOTIFY=&SYSUID,\n//            MSGCLASS=X,COND=(4,LT)\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n//*SMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,RENT)\n//SYSIN     DD *\n*---------------------------------------------------------------------*\n*                                                                     *\n* NAME:        DRDASD                                                 *\n*                                                                     *\n* FUNCTION:    CALL UCBSCAN MACRO TO GET DASD DEVICES.  USE THE       *\n*              OBTAIN MACRO TO GATHER INFO ABOUT THE VOLUMES VTOC     *\n*              (INDEX VS NON-INDEX, ETC.).  USE THE LSPACE MACRO TO   *\n*              GET FREE SPACE INFORMATION.  ALLOCATE THE VTOC FOR     *\n*              EACH ONLINE VOLUME AND GET THE SPACE (AND LOCATION)    *\n*              INFORMATION ABOUT THE VTOC FROM THE DATA EXTENT BLOCK  *\n*              THAT IS BUILT AT OPEN OF THE DD.  PACKAGE ALL OF THIS  *\n*              DATA UP AND OUTPUT IT TO THE TERMINAL USING THE        *\n*              PUTLINE MACRO SO THAT REXX CAN CAPTURE IT.             *\n*                                                                     *\n* SYNTAX:      DRDASD                                                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n* LINK EDIT INFORMATION:     NOT REENTRANT                            *\n*---------------------------------------------------------------------*\n* RETURN CODES: ONLY IF AN ERROR OCCURS IN THE UCBSCAN MACRO.  ALL    *\n*   OTHER ERRORS ARE RETURNED AS $E ERROR MESSAGES                    *\n*---------------------------------------------------------------------*\n* AUTHOR:      ROB JOHNS - AMERICAN NATIONAL PROPERTY AND CASUALTY    *\n*---------------------------------------------------------------------*\n* HISTORY:                                                            *\n*                                                                     *\n*        03/09/01  -  CREATED                                         *\n*        01/02/04  -  WHEN WHE SWITCHED TO 64-BIT MODE IN Z/OS,       *\n*                     SOMETHING WENT WRONG.  I STILL HAVE NO IDEA     *\n*                     WHAT WENT WRONG, BUT I HAD TO REWRITE A COUPLE  *\n*                     OF PARTS.  I'M A DBA(SYSADM) NOT A SYSPROG, SO  *\n*                     GIVE ME A BREAK!                                *\n*---------------------------------------------------------------------*\nDRDASD         AMODE 24         *\nDRDASD         RMODE 24         *\nDRDASD         CSECT\n\n******************************************************************\n* STANDARD LINKAGE IS COPIED                                     *\n******************************************************************\n*              COPY $$ENTER\n********************************  STORE CALLER'S REGISTERS\n         STM   14,12,12(13)               STORE 14-12 AT 12 OFF 13\n         BALR  12,0                       LOAD 12 WITH CURRENT ADDR\n         USING *,12                       ADDRESSABILITY FOR 12\n**********************************************************************\n         GETMAIN RC,LV=72,LOC=BELOW       GET 72 BYTES FOR SAVE (18F)\n         LTR   15,15                      TEST RETURN CODE IN R15\n         BZ    PASSROB                    BRANCH IF TEST ZERO\n\n         WTO   '<$$ENTER> - BAD GETMAIN FOR REGISTER STORAGE'\n         LM    14,12,12(13)               RELOAD REGISTERS\n         L     15,=F'12'                  SET RETURN CODE\n         BR    14                         BRANCH BACK TO CALLER\nPASSROB  DS    0H\n**********************************************************************\n         ST    13,4(,1)                    STORE CALLERS AT 4 OFF MINE\n         ST    1,8(,13)                    STORE MINE AT 8 OFF CALLERS\n         LR    13,1                        LOAD REGISTER 13 WITH MINE\n\n               B      GET_STORAGE          * SKIP OVER CONSTANTS\n               DC     C'DRDASD_&SYSDATE._&SYSTIME.'\n\n\n******************************************************************\n* GO GET SOME STORAGE TO WORK WITH                               *\n******************************************************************\nGET_STORAGE    DS    0H\n               GETMAIN RU,LV=WSPACEL,LOC=BELOW\n               LTR   15,15                  * TEST THE RC FROM GETMAIN\n               BZ    GOODGET                * IF ZERO THEN CONTINUE\n\n               WTO   '<DRDASD> - BAD GETMAIN FOR VARIABLE STORAGE'\n               B     EXIT_DRDASD\n\nGOODGET        DS    0H\n               LR    R8,R1             * SAVE ADDRESS OF STORAGE AREA\n               USING WSPACE,R8         * ADDR STORAGE W/ WSPACE DSECT\n\n\n******************************************************************\n* USE ADDRESS OF WSPACE PLUS DISPLACEMENTS TO ADDRESS OTHER      *\n* GETMAIN'D STORAGE USING DSECTS GENERATED BY A MACRO            *\n******************************************************************\n               USING LSPACE_DATA,WSPACE+LSPACE_D_DISP\n               USING LSPACE_PARM,WSPACE+LSPACE_P_DISP\n\n\n******************************************************************\n* GET THE ADDRESS OF THE ENVIRONMENT BLOCK FROM OLD REGISTER 0   *\n******************************************************************\n               L     R6,4(,R13)        * GET ADDRESS OF CALLERS SAVE\n               L     R4,20(,R6)        * LOAD OLD REG 0 INTO REG 5\n\n\n******************************************************************\n* GET THE ADDRESS OF THE WORK BLOCK EXTENTION                    *\n******************************************************************\n               USING ENVBLOCK,R4        * ADDRESS THE ENVIRONMENT BLOCK\n               L     R4,ENVBLOCK_WORKBLOK_EXT * LOAD R4 WITH THE ADDR\n*                                             * OF THE WORK BLOCK EXT\n               DROP  R4\n\n\n******************************************************************\n* GET THE ADDRESS OF THE COMMAND PROCESSOR PARM LIST             *\n******************************************************************\n               USING WORKBLOK_EXT,R4    * ADDRESS THE REXX WORK BLOCK\n               L     R4,WORKEXT_CPPLPTR * LOAD ADDRESS OF THE CPPL\n               DROP  R4\n\n\n******************************************************************\n* GET THE ADDRESS OF THE USER PROFILE TABLE WHICH IS STORED IN   *\n* THE COMMAND PROCESSOR PARAMETER LIST                           *\n******************************************************************\n               USING CPPL,R4            * ADDRESS THE CPPL\n               L     R3,CPPLUPT         * LOAD ADDRESS OF THE UPT\n\n\n******************************************************************\n* GET THE ADDRESS OF THE EVENT CONTROL TABLE                     *\n******************************************************************\n               L     R4,CPPLECT         * LOAD ADDRESS OF THE ECT\n               DROP  R4\n\n               ST    R3,UPTADDR         * STORE UPT ADDRESS FOR LATER\n               ST    R4,ECTADDR         * STORE ECT ADDRESS FOR LATER\n\n\n******************************************************************\n* INITIALIZE THE PUTLINE DATA AREAS                              *\n******************************************************************\n               MVC   ECBADS(4),=F'0'\n\n               MVC   PUTBLOK(4),=X'00000000'\n               MVC   PUTBLOK+4(4),=A(0)\n               MVC   PUTBLOK+8(4),=A(0)\n\n               MVC   TEXTOLD(4),=F'1'    * NOT \"OLD\", BUT \"O.L.D.\"\n               LA    R3,TEXTMSG1\n               ST    R3,TEXTOLD+4\n\n               MVC   TEXTMSG1(2),=H'76'\n\n               MVC   TEXTMSG1+2(2),=H'0'\n\n               MVC   TEXTMESG(1),=X'40'      * SET 1ST BYTE TO A SPACE\n               MVC   TEXTMESG+1(71),TEXTMESG * MOVES OCCUR LEFT 2 RIGHT\n\n               MVC   IOPLADS(16),=4F'0'      * THIS IS THE I/O PARM\n*                                            * LIST THAT THE PUTLINE\n*                                            * MACRO USES\n\n\n********************************************************************\n* FIRST TIME IN, INITIALIZE THE VALUES FOR THE LSPACE LOGIC.  THE  *\n* CODE TO DO THIS ACTUALLY RESIDES WHERE THE OTHER LSPACE LOGIC IS.*\n********************************************************************\nLSPACE_INITS   DS    0H\n               BAL   R9,INIT_LSPACE          * THERE AND BACK AGAIN\n\n\n******************************************************************\n* FIRST TIME IN, INITIALIZE THE VALUES FOR THE DSCB LOGIC.  THE  *\n* CODE TO DO THIS ACTUALLY RESIDES WHERE THE OTHER DSCB LOGIC IS.*\n******************************************************************\nDSCB_INITS     DS    0H\n               BAL   R9,INIT_DSCB_AREA       * THERE AND BACK AGAIN\n\n\n******************************************************************\n* FIRST TIME, AND IF THE HARDWARE CONFIGURATION HAS CHANGED, USE *\n* THIS SECTION TO INITIALIZE BEFORE CALLING UCBSCAN MACRO        *\n******************************************************************\n* MESSAGES PUTLINE'D ARE PRECEEDED (THIS IS NOT NECESSARY FOR    *\n* THE PUTLINE MACRO TO WORK) BY A MESSAGE TYPE IDENTIFIER.       *\n* $D-DATA $I-INFORMATIONAL $W-WARNING $E-ERROR                   *\n* JUST SOMETHING TO MAKE LIFE EASIER FOR ME ON THE OUTSIDE       *\n******************************************************************\nNEW_CONFIG     DS    0H\n               MVC   TEXTMESG+1(28),=C'$ICONFIGURATION NEW DRDASD'\n               BAL   R9,WRITE_DRDASD\n               XC    UCB_WORK,UCB_WORK          * SET ALL X'00'\n               XC    CONFIG_TOKEN,CONFIG_TOKEN  * SET ALL X'00'\n\n\n******************************************************************\n* UCB SCAN MACRO WILL RETURN COPIES OF THE DYNAMIC AND STATIC    *\n* UCBS THAT ARE OUT THERE.  DID NOT USE THE DCE AREA IN THIS     *\n******************************************************************\nNEXT_UCB       DS    0H\n               MVC   CALLED_MACRO(7),=C'UCBSCAN'\n\n*  +------------------------------------------------------------------+\n*  |    UCBSCAN MACRO IS DOCUMENTED IN MVS PROGRAMMING: ASSEMBLER     |\n*  |                    SERVICES REFERENCE, VOLUME 2                  |\n*  +------------------------------------------------------------------+\n              UCBSCAN COPY,                 * GET COPY OF UCB          +\n               WORKAREA=UCB_WORK,           * 100 BYTES INIT 1ST TIME  +\n               UCBAREA=UCB_COMMON,          * 48 BYTES FOR UCB COMMON  +\n               CMXTAREA=UCB_COM_EXT,        * 32 BYTES FOR UCB COM EXT +\n               UCBPAREA=UCB_PRE_EXT,        * 48 BYTES FOR UCB PRE EXT +\n               DEVNCHAR=DEV_NUMBER,         * 4 BYTE RECEIVES DEV NUM  +\n               DEVN=0,                      * START W/1ST UCB          +\n               DYNAMIC=YES,                 * INCLUDE DYN AND STATIC   +\n               RANGE=ALL,                   * 3 AND 4 DIGIT DEVICE NUM +\n               NONBASE=YES,                 * BASE & NONBASE EXPOSURES +\n               UNBOUND_ALIAS=YES,           * ???????????????????????  +\n               DEVCLASS=ALL,                * ALL DEVICES ARE INCLUDED +\n               IOCTOKEN=CONFIG_TOKEN,       * I/O CONFIG. TOKEN 48BYTE +\n               PLISTVER=IMPLIED_VERSION,    * ONLY USE NECESSARY VER   +\n               RETCODE=RETURN_CODE,         * STORAGE FOR RETURN CODE  +\n               RSNCODE=REASON_CODE          * STORAGE FOR REASON CODE\n\n               L     R10,RETURN_CODE        * SAVE RETURN CODE\n               B     *+4(R10)               * BRANCH TO CURRENT ADDRESS\n*                                           * + 4 BYTES + RETURN CODE\n*                                           * VALUE.\n\n* I DID THE RC CHECKING THIS WAY SIMPLY BECAUSE IT SEEMED ENTERTAINING\n               B     UCBSCAN_GOOD\n               B     DRDASD_OKAY\n               B     DRDASD_ERROR\n               B     NEW_CONFIG             * HARDWARE CONFIG CHANGED\n               B     DRDASD_ERROR\n               B     DRDASD_ERROR\n               B     DRDASD_ERROR\n\n\n******************************************************************\n* LOOKS LIKE WE RECEIVED A UCB.  MAKE SURE THAT IT IS A DASD UCB *\n******************************************************************\nUCBSCAN_GOOD   DS    0H\n               USING UCBOB,UCB_COMMON  * EST FOR UCBOB IN IEFUCBOB\n               TM    UCBTBYT3,UCB3DACC * TEST BYTE 3 - BIT 0 FOR DASD\n               BZ    NEXT_UCB          * IF OFF, GO GET NEXT UCB\n\nCHECK_STATUS   DS    0H\n               TM    UCBSTAT,UCBONLI   * IS THE VOLUME ONLINE?\n               BZ    NEXT_UCB          * NO - GO GET THE NEXT UCB\n               B     BUILD_LINE1       * YES - OUTPUT SOME INFO\n*                                      * AFTER SKIPPING THE OUTPUT\n*                                      * LINE DEFINITIONS BELOW\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; D='XXXX';\n********************************************************************\nLINE1          DS    0H\n               DC    CL5' $DV='\nL1V            EQU   *-LINE1+1\n               DC    XL8'7DE7E7E7E7E7E77D'\n               DC    CL4'; D='\nL1D            EQU   *-LINE1+1\n               DC    XL6'7DE7E7E7E77D'\nLINE1_LEN      EQU   *-LINE1\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; FC=XXXXXXXXXXXXXXXX; FT=XXXXXXXXXXXXXXXX\n********************************************************************\nLINE2A         DS    0H\n               DC    CL5' $DV='\nL2AV           EQU   *-LINE2A+1\n               DC    XL8'7DE7E7E7E7E7E77D'\n               DC    CL5'; FC='\nL2AFC          EQU   *-LINE2A\n               DC    CL16'XXXXXXXXXXXXXXXX'\n               DC    CL5'; FT='\nL2AFT          EQU   *-LINE2A\n               DC    CL16'XXXXXXXXXXXXXXXX'\nLINE2A_LEN     EQU   *-LINE2A\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; FE=XXXXXXXXXXXXXXXX;\n********************************************************************\nLINE2B         DS    0H\n               DC    CL5' $DV='\nL2BV           EQU   *-LINE2B+1\n               DC    XL8'7DE7E7E7E7E7E77D'\n               DC    CL5'; FE='\nL2BFE          EQU   *-LINE2B\n               DC    CL16'XXXXXXXXXXXXXXXX'\nLINE2B_LEN     EQU   *-LINE2B\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; LC=XXXXXXXXXXXXXXXX; LT=XXXXXXXXXXXXXXXX\n********************************************************************\nLINE2C         DS    0H\n               DC    CL5' $DV='\nL2CV           EQU   *-LINE2C+1\n               DC    XL8'7DE7E7E7E7E7E77D'\n               DC    CL5'; LC='\nL2CLC          EQU   *-LINE2C\n               DC    CL16'XXXXXXXXXXXXXXXX'\n               DC    CL5'; LT='\nL2CLT          EQU   *-LINE2C\n               DC    CL16'XXXXXXXXXXXXXXXX'\nLINE2C_LEN     EQU   *-LINE2C\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; VIX='X'; VIXS='X'; SMSM='X'\n********************************************************************\nLINE3          DS    0H\n               DC    CL5' $DV='\nL3V            EQU   *-LINE3+1\n               DC    XL8'7DE7E7E7E7E7E77D'\n               DC    CL6'; VIX='\nL3VIX          EQU   *-LINE3+1\n               DC    XL3'7DE77D'\n               DC    CL7'; VIXS='\nL3VIXS         EQU   *-LINE3+1\n               DC    XL3'7DE77D'\n               DC    CL7'; SMSM='\nL3SMSM         EQU   *-LINE3+1\n               DC    XL3'7DE77D'\nLINE3_LEN      EQU   *-LINE3\n\n********************************************************************\n*            1         2         3         4         5         6\n*  0123456789012345678901234567890123456789012345678901234567890123\n*   $DV='XXXXXX'; SC=XXXX; ST=XXXX; EC=XXXX; ET=XXXX; VT=XXXX\n********************************************************************\nLINE4          DS    0H\n               DC    CL5' $DV='\nL4V            EQU   *-LINE4+1\n               DC    XL8'7DE7E7E7E7E7E77D'\nL4SC           EQU   *-LINE4+5\nL4ST           EQU   *-LINE4+14\n               DC    CL19'; SC=XXXX; ST=XXXX;'\nL4EC           EQU   *-LINE4+4\nL4ET           EQU   *-LINE4+13\nL4VT           EQU   *-LINE4+22\n               DC    CL26' EC=XXXX; ET=XXXX; VT=XXXX'\nLINE4_LEN      EQU   *-LINE4\n\n\n********************************************************************\n* WRITE OUT THE INFO THAT YOU GATHER FROM THE UCB                  *\n********************************************************************\nBUILD_LINE1    DS    0H\n               MVC   TEXTMESG(LINE1_LEN),LINE1 * MOVE LINE1 TEXT TO OUT\n\n               MVC   STORE_VOLSER,UCBVOLI        * STORE VOLSER 4 LATER\n               MVC   TEXTMESG+L1V(6),UCBVOLI     * VOLSER TO OUTLINE\n               MVC   TEXTMESG+L1D(4),DEV_NUMBER  * DEVICE ADDR TO OUT\n\n               BAL   R9,WRITE_DRDASD           * WRITE OUTPUT\n               B     DO_LSPACE                 * INIT IS \"CALLED\" ONLY\n*                                              * SO SKIP IT!\n\n\n**********************************************************************\n* USE THE LSPACE MACRO TO GET THE FREE SPACE INFO AND BUILD THE NEXT *\n* LINE OF OUTPUT.                                                    *\n**********************************************************************\n* IT SEEMED MORE PLEASING TO ME TO KEEP THE LSPACE STUFF TOGETHER *\n* BUT THIS STUFF ONLY NEEDS TO BE EXECUTED ONCE... SO, I BRANCH   *\n* TO IT IN THE SECTION WHERE I AM INITIALIZING THINGS AND THEN    *\n* RETURN TO THE ADDRESS IN REGISTER 9 (USE BAL R9 TO CALL)        *\n*******************************************************************\nINIT_LSPACE    DS    0H\n               XC    LSPACE_PARM,LSPACE_PARM  * SET ALL X'00'\n\n               MVC   LSPAPLID(4),=C'LSPA'   * LSPA IN FIRST 4 BYTES\n               MVC   LSPANGTH(2),=X'001B'   * LENGTH OF LSPA AREA\n               OI    LSPAFLAG,LSPADATA      * SET FLAG TO \"DATA\"\n*                    LSPARSVD(1) - RESERVED\n               OI    LSPASFID,LSPASF06      * SET \"READ VOL LABEL\"\n*                                           * IN SUBFUNCTION ID\n\n\n               LA    R6,UCB_COMMON  * LOAD ADDRESS OF OUR UCB COPY\n               ST    R6,LSPAUCB     * LSPACE USES THIS TO FIND UCB COPY\n\n               LA    R6,LSPACE_DATA    * LOAD ADDRESS OF DATA AREA\n               ST    R6,LSPAFRSP       * LSPACE RETURNS DATA TO IT\n\n               BR    R9                * RETURN TO WHERE WE CAME FROM\n\n\n**********************************************************************\n* USE THE LSPACE MACRO TO RETURN THE FREE SPACE INFO TO OUR DATA AREA*\n**********************************************************************\nDO_LSPACE      DS    0H\n               MVC   CALLED_MACRO(7),=C'LSPACE '\n\n* SUBFUNCTION CODE IS SET TO PROCESS COMPLETE X'00' AFTER SUCCESSFUL\n* EXECUTION\n               OI    LSPASFID,LSPASF06   * SET \"READ VOL LABEL\"\n\n*  +------------------------------------------------------------------+\n*  |     LSPACE MACRO IS DOCUMENTED IN DFSMSDFP ADVANCED SERVICES     |\n*  +------------------------------------------------------------------+\n               LSPACE MF=(E,LSPACE_PARM)\n\n               CLC   LSPAERCD,=X'00'  * RETURN CODE IS RETURNED IN THE\n*                                     * LSPACE PARMS AREA WE PROVIDED\n               BNE   NO_SPACE         * IF THIS FAILED, GO MAKE A NOTE\n\n* EACH OF THE VALUES RETURNED BY LSPACE WERE IN 4 BYTE BINARY NUMERIC\n* FIELDS.  THIS MEANS WE HAVE TO CONVERT TO DECIMAL AND UNPACK THEM\n* AND \"OR\" THE SIGN BEFORE WE CAN MAKE THEM PRINTABLE.\n               MVC   TEXTMESG(LINE2A_LEN),LINE2A * INIT OUTPUT W/ LINE2\n               MVC   TEXTMESG+L2AV(6),STORE_VOLSER   * VOLSER TO OUTPUT\n               L     R3,LSPDTCYL\n               BAL   R9,CNVTF2D_CHAR\n               MVC   TEXTMESG+L2AFC(16),STORE_AREA16 * TOTAL FREE CYL\n               L     R3,LSPDTTRK\n               BAL   R9,CNVTF2D_CHAR\n               MVC   TEXTMESG+L2AFT(16),STORE_AREA16 * ADDITIONAL TRKS\n               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO\n*                                                    * LINE2A\n\n               MVC   TEXTMESG(LINE2B_LEN),LINE2B * INIT OUTPUT W/ LINE2\n               MVC   TEXTMESG+L2BV(6),STORE_VOLSER   * VOLSER TO OUTPUT\n               L     R3,LSPDNEXT\n               BAL   R9,CNVTF2D_CHAR\n               MVC   TEXTMESG+L2BFE(16),STORE_AREA16 * NUM FREE EXTENTS\n               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO\n*                                                    * LINE2B\n\n               MVC   TEXTMESG(LINE2C_LEN),LINE2C * INIT OUTPUT W/ LINE2\n               MVC   TEXTMESG+L2CV(6),STORE_VOLSER   * VOLSER TO OUTPUT\n               L     R3,LSPDLCYL\n               BAL   R9,CNVTF2D_CHAR\n               MVC   TEXTMESG+L2CLC(16),STORE_AREA16 * LARGEST CYLS\n               L     R3,LSPDLTRK\n               BAL   R9,CNVTF2D_CHAR\n               MVC   TEXTMESG+L2CLT(16),STORE_AREA16 * ADDL LRGST TRKS\n               BAL   R9,WRITE_DRDASD                 * WRITE SPACE INFO\n*                                                    * LINE2B\n\n               B     END_CNVTF2D            * BRANCH AROUND SUBROUTINE\n\n\n******************************************************************\n* THIS IS A SUBROUTINE THAT IS CALLED REPEATEDLY AND THEN WILL   *\n* BE BRANCHED AROUND.  IT CONVERTS A BINARY FULL WORD INTO A     *\n* DOUBLE WORD CHARACTER STRING.  LOAD R3 WITH THE VALUE TO BE    *\n* CONVERTED AND BAL R9,CNVTF2D_CHAR TO USE IT.  THE UNPACKED     *\n* CHARACTER 16 BYTE NUMBER WILL BE FOUND IN STORE_AREA16.        *\n******************************************************************\nCNVTF2D_CHAR DS      0H\n* CONVERT 4 BYTE BINARY TO 8 BYTE SIGNED DECIMAL\n               CVD   R3,STORE_AREA8\n* UNPACK 8 BYTE DECIMAL INTO 16 BYTE CHARACTER WITH SIGN IN FIRST\n* HALF OF LAST BYTE\n               UNPK  STORE_AREA16(16),STORE_AREA8(8)\n* \"OR\" THE LAST BYTE WITH 1111 0000 TO CHANGE THE SIGN (NON-PRINTABLE)\n* SO THAT THE LAST BYTE WILL BE A PRINTABLE (F?) CHARACTER\n               OI    STORE_AREA16+15,X'F0'\n\n               BR    R9           * BRANCH BACK TO THE CALLER\nEND_CNVTF2D  DS     0H\n\n\n               B     GET_FORMAT4      * SKIP PAST THE INIT ROUTINE FOR\n*                                     * DSCB PROCESSING WHICH WAS\n*                                     * BAL'D TO IN INIT SECTION ABOVE\n\nNO_SPACE       DS    0H\n               MVC   TEXTMESG(3),=C' $W'           * MESG TYPE WARNING\n               MVC   TEXTMESG+6(6),STORE_VOLSER    * VOLSER TO OUTPUT\n               MVC   TEXTMESG+14(12),=C'LSPACE_DATA='\n               MVC   TEXTMESG+26(36),LSPACE_DATA   * OUTPUT RETURN DATA\n*                                                  * WHEN THERE IS AN\n*                                                  * ERROR, RETURN DATA\n*                                                  * CONTAINS MESSAGE\n*                                                  * FROM LSPACE MACRO\n               BAL   R9,WRITE_DRDASD               * WRITE OUT TEXT\n* WRJOHN - SHOULD PROBABLY ERROR OUT HERE\n               B     GET_FORMAT4      * SKIP PAST THE INIT ROUTINE FOR\n*                                     * DSCB PROCESSING WHICH WAS\n*                                     * BAL'D TO IN INIT SECTION ABOVE\n\n\n******************************************************************\n* IT SEEMED MORE PLEASING TO ME TO KEEP THE DSCB STUFF TOGETHER, *\n* BUT THIS STUFF ONLY NEEDS TO BE EXECUTED ONCE... SO, I BRANCH  *\n* TO IT IN THE SECTION WHERE I AM INITIALIZING THINGS AND THEN   *\n* RETURN TO THE ADDRESS IN REGISTER 9 (USE BAL R9 TO CALL)       *\n******************************************************************\nINIT_DSCB_AREA DS    0H\n               MVC   DSCBABC(4),DSCBABC_MVC  * MOVE 1ST 4 BYTES TO OUR\n*                                            * STORAGE\n               LA    R6,DSABC                * LOAD DSNAME ADDRESS\n               ST    R6,DSCBABC+4            * STORE IN OUR PARMS\n               LA    R6,STORE_VOLSER         * LOAD ADDR OF VOLSER\n               ST    R6,DSCBABC+8            * STORE IN OUR PARMS\n               LA    R6,DSCB_WORK            * LOAD ADDR OF WORK AREA\n               ST    R6,DSCBABC+12           * STORE IN OUR PARMS\n\n               MVC   DSABC(1),=X'04'         * INIT DSNAME TO ALL X'04'\n               MVC   DSABC+1(43),DSABC\n\n               BR    R9                      * BRANCH TO RETURN ADDRESS\n\n\n******************************************************************\n* USE THE OBTAIN MACRO TO GET THE FORMAT 4 DSCB FOR A VOLUME     *\n******************************************************************\nGET_FORMAT4    DS    0H\n               OBTAIN DSCBABC                * READ DSCB FOR DATA\n               LTR   R15,R15        * LOAD AND TEST RETURN CODE\n               BZ    DSCB_LINE      * IF RC0 THEN CONTINUE\n\n*              * IF IT FAILED, ISSUE A WARNING MESSAGE\n               LR    R10,R15                 * MOVE RETURN CODE\n               LA    R6,DRDASD_RC            * LOAD ADDRESS OF RC TEXT\n               L     R6,0(R10,R6)            * LOAD R6 WITH 4 BYTES AT\n*                                            * 0 OFF OF R6+RC\n               MVC   TEXTMESG+1(2),=C'$W'\n               MVC   TEXTMESG+3(6),STORE_VOLSER\n               MVC   TEXTMESG+11(28),=C'DSCB FORMAT4 OBTAIN FAILED- '\n               ST    R6,TEXTMESG+40          * STORE RC TEXT\n               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG\n\n               B     ALLOC_VOLUME            * SKIP DSCB LINE OUTPUT\n*                                            * AND GO ALLOCATE VTOC\n\n\n******************************************************************\n* USE THE FORMAT 4 DSCB TO GET INFO ABOUT THE VOLUME             *\n******************************************************************\nDSCB_LINE      DS    0H\n\n               MVC   TEXTMESG(LINE3_LEN),LINE3 * MOVE LINE3 TEXT TO OUT\n               MVC   TEXTMESG+L3V(6),STORE_VOLSER\n\n               USING FORMAT4,DSCB_WORK       * MAP THE FORMAT 4 DSCB\n\n*              ******************************************\n*              * DOES THIS VOLUME HAVE AN INDEXED VTOC? *\n*              ******************************************\n               MVC   TEXTMESG+L3VIX(1),=C'Y' * DEFAULT TO YES\n               TM    DS4VTOCI,DS4IVTOC        * INDEXED VTOC?\n               BO    VTOC_IX_STATUS           * YES - TAKE DEFAULT\n\n               MVC   TEXTMESG+L3VIX(1),=C'N' * SET TO VALUE OF NO\n\n\nVTOC_IX_STATUS DS    0H\n*              *************************************\n*              * HAS THE VTOC INDEX BEEN DISABLED? *\n*              *************************************\n               MVC   TEXTMESG+L3VIXS(1),=C'D' * DEFAULT TO DISABLED\n               TM    DS4VTOCI,DS4DVTOC        * INDEXED VTOC DISABLED?\n               BO    SMS_MANAGED              * YES - BRANCH\n\n               MVC   TEXTMESG+L3VIXS(1),=C'E' * SET TO VALUE OF ENABLED\n\nSMS_MANAGED    DS    0H\n*              ******************************************\n*              * IS THIS VOLUME UNDER SMS CONTROL?      *\n*              ******************************************\n               MVC   TEXTMESG+L3SMSM(1),=C'N' * DEFAULT TO NON-SMS\n               TM    DS4SMSFG,DS4SMS          * NON-SMS VOLUME?\n               BZ    DSCB_WRITE               * ALL ZEROS = DEFAULT IT\n\n*              * EITHER BIT 0 OR BIT 1 OR BOTH ARE ON *\n               MVC   TEXTMESG+L3SMSM(1),=C'Y' * SET SMS DEFAULT TO YES\n               TM    DS4SMSFG,DS4SMS          * ARE BITS 0 AND 1 ON?\n               BO    DSCB_WRITE               * YES - LEAVE VALUE Y\n\n*              * EITHER BIT 0 OR BIT 1 IS ON, BUT NOT BOTH *\n               MVC   TEXTMESG+L3SMSM(1),=C'I' * SET SMS DEFAULT TO INIT\n               TM    DS4SMSFG,DS4SMSCV        * IS BIT 1 ON?\n               BO    DSCB_WRITE               * YES - KEEP VALUE 'I'\n\n*              * DON'T KNOW WHAT BIT 0 ONLY MEANS (RESERVED) *\n               MVC   TEXTMESG+L3SMSM(1),=C'?' * STATUS IS UNKNOWN TO ME\n\n\nDSCB_WRITE     DS    0H\n               BAL   R9,WRITE_DRDASD         * WRITE THE DSCB LINE\n\n\n******************************************************************\n* ALLOCATE THE VTOC ON THE VOLUME SO THAT WE CAN EXAMINE THE     *\n* DATA EXTENT BLOCK THAT IS CREATED AT DCB OPEN                  *\n******************************************************************\nALLOC_VOLUME   DS    0H\n               MVC   CALLED_MACRO(7),=C'DYNALLC'\n               MVC   VOLSER+6(6),STORE_VOLSER\n               MVC   UNIT+6(4),=C'DISK'\n               LA    R1,ALOC\n               MVC   ALOCTP,=A(VTOCALOC)\n               MVC   ALOCVC,=AL1(1)\n               DYNALLOC\n               LTR   R15,R15\n               BZ    ALOCOK\n               MVC   TEXTMESG+1(2),=C'$W'\n               MVC   TEXTMESG+3(6),STORE_VOLSER\n               MVC   TEXTMESG+11(28),=C'DYNALLOC FAILED FOR VOLUME- '\n               ST    R6,TEXTMESG+40          * STORE RC TEXT\n               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG\n               B     AFTER_DYNALLOC          * SKIP VTOC ALLOC LOGIC\n\n\n***********************************************************************\n* OKAY, NOW WE NEED TO PREPARE THE JOB FILE CONTROL BLOCK FOR THIS    *\n* DCB BEFORE WE OPEN IT.                                              *\n***********************************************************************\nALOCOK         DS    0H\n*              **************************************************\n*              * THIS MACRO MOVES A JFCB INTO THE USER SUPPLIED *\n*              * AREA SPECIFIED ON THE EXLST= PARM OF THE DCB   *\n*              **************************************************\n               RDJFCB VTOC\n               LTR   R15,R15\n               BZ    DD_OKAY\n               MVC   TEXTMESG+1(2),=C'$W'\n               MVC   TEXTMESG+3(6),STORE_VOLSER\n               MVC   TEXTMESG+11(24),=C'JFCB PROCESSING FAILED- '\n               ST    R6,TEXTMESG+36          * STORE RC TEXT\n               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG\n               B     UNALLOC                 * GO UNALLOC THE DCB\nDD_OKAY  DS    0H\n               LA    R5,JFCBAREA * POINTED TO BY THE RDJFLIST AREA\n               USING INFMJFCB,R5 * DEFINED IN THE IEFJFCBN MACRO\n               MVI   JFCBDSNM,X'04'\n               MVC   JFCBDSNM+1(43),JFCBDSNM\n               OPEN  (VTOC,(INPUT)),TYPE=J\n* WRJOHN CHECK RETURN CODE? - SEE IF THIS REALLY WORKS...\n               LTR   R15,R15\n               BZ    CHEK4DEB\n               MVC   TEXTMESG+1(2),=C'$W'\n               MVC   TEXTMESG+3(6),STORE_VOLSER\n               MVC   TEXTMESG+11(24),=C'OPEN FAILED FOR VOLUME- '\n               ST    R6,TEXTMESG+36          * STORE RC TEXT\n               BAL   R9,WRITE_DRDASD         * WRITE RETURN CODE MESG\n               B     UNALLOC                 * GO UNALLOC THE DCB\n\nCHEK4DEB       DS    0H\n               LA    R6,VTOC\n               USING IHADCB,R6\n               L     R6,DCBDEBAD\n               DROP  R6\n               USING DEBBASIC,R6\n               LA    R6,DEBBASND\n               DROP  R6\n               MVC   TEXTMESG(LINE4_LEN),LINE4   * INIT OUTPUT W/ LINE4\n               MVC   TEXTMESG+L4V(6),STORE_VOLSER * VOLSER TO OUTPUT\n               USING DEBDASD,R6\n\n               LH    R7,DEBSTRCC                 * LOAD HALF BIN 2 REG\n               CVD   R7,CVD_AREA                 * CNVT 2 PACKED 4 BYTE\n               UNPK  CHAR_AREA(4),CVD_AREA(8)    * UNPACK INTO 8 CHAR\n               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN\n               MVC   TEXTMESG+L4SC(4),CHAR_AREA  * VTOC STARTING CYL\n\n               LH    R7,DEBSTRHH\n               CVD   R7,CVD_AREA\n               UNPK  CHAR_AREA(4),CVD_AREA(8)\n               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN\n               MVC   TEXTMESG+L4ST(4),CHAR_AREA  * VTOC STARTING TRK\n\n               LH    R7,DEBENDCC\n               CVD   R7,CVD_AREA\n               UNPK  CHAR_AREA(4),CVD_AREA(8)\n               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN\n               MVC   TEXTMESG+L4EC(4),CHAR_AREA  * VTOC ENDING CYL\n\n               LH    R7,DEBENDHH\n               CVD   R7,CVD_AREA\n               UNPK  CHAR_AREA(4),CVD_AREA(8)\n               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN\n               MVC   TEXTMESG+L4ET(4),CHAR_AREA  * VTOC ENDING TRK\n\n               LH    R7,DEBNMTRK\n               CVD   R7,CVD_AREA\n               UNPK  CHAR_AREA(4),CVD_AREA(8)\n               OI    CHAR_AREA+3,X'F0'           * REMOVE 4 BIT SIGN\n               MVC   TEXTMESG+L4VT(4),CHAR_AREA  * VTOC TOTAL TRKS\n\n               BAL   R9,WRITE_DRDASD\n               DROP  R6\n\nCLOSE          DS    0H\n               CLOSE VTOC\nUNALLOC        DS    0H\n               LA    R1,ALOC\n               MVC   ALOCTP,=A(VTOCULOC)\n               MVC   ALOCVC,=AL1(2)\n               DYNALLOC\n               LTR   R15,R15\n               BZ    AFTER_DYNALLOC\n               LR    R10,R15\n               MVC   TEXTMESG+1(29),=C'$EUNABLE TO DEALLOCATE VOLUME'\n               BAL   R9,WRITE_DRDASD\n               B     DRDASD_ERROR\n\nAFTER_DYNALLOC DS    0H\n               B     NEXT_UCB  * GO BACK TO THE TOP OF THE LOOP\n\n\n******************************************************************\n* USE THE PUTLINE MACRO TO SEND THE DATA LINE TO THE TERMINAL    *\n******************************************************************\nWRITE_DRDASD DS      0H\n\n               L     R3,UPTADDR   * HAD TROUBLE WITH USING SYMBOLICS\n               L     R4,ECTADDR   * HAD TROUBLE WITH USING SYMBOLICS\n\n              PUTLINE PARM=PUTBLOK,         * ADDR OF PUTLINE PARM BLK +\n               UPT=(3),                     * ADDR OF USER PROF TABLE  +\n               ECT=(4),                     * ADDR OF ENV CNTL TABLE   +\n               ECB=ECBADS,                  * ADDR OF EVENT CNTL BLOCK +\n               OUTPUT=(TEXTOLD,TERM,SINGLE,INFOR),                     +\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     +\n               MF=(E,IOPLADS)               * EXEC AND IO PARM LIST\n\n               MVC   TEXTMESG(1),=X'40'      * SET 1ST BYTE TO A SPACE\n               MVC   TEXTMESG+1(71),TEXTMESG * MOVES OCCUR LEFT 2 RIGHT\n\n               BR    R9           * NORMALLY, ADDR OF NEXT_UCB\n\n\n******************************************************************\n* AN ERROR OCCURED DURING PROCESSING                             *\n******************************************************************\nDRDASD_ERROR DS      0H\n               MVC   TEXTMESG+1(25),=C'$EERROR - BAD RETURN FROM'\n               MVC   TEXTMESG+27(7),CALLED_MACRO\n\n               LA    R3,DRDASD_RC          * LOAD ADDRESS OF RC TEXT\n               L     R3,0(R10,R3)          * LOAD R3 WITH 4 BYTES AT\n*                                          * 0 OFF OF R3+RC\n               ST    R3,TEXTMESG+36        * STORE RC TEXT\n               BAL   R9,WRITE_DRDASD       * WRITE ERROR MESSAGE\n\n               L     R10,REASON_CODE       * LOAD REASON CODE\n               LA    R3,DRDASD_RE          * LOAD ADDR OF RC TEXT AREA\n               LA    R3,0(R10,R3)          * LOAD ADDRESS OF 1 BYTE\n*                                          * REASON @ 0 OFF OF R10+R3\n               MVC   TEXTMESG+40(1),0(R3)  * MOVE REASON TO TEXTMESG\n               BAL   R9,WRITE_DRDASD       * WRITE ERROR MESSAGE\n\n               LA    R10,0                 * SET RC TO ZERO\n               B     EXIT_DRDASD\n\n\n******************************************************************\n* SUCCESSFULL END OF PROGRAM                                     *\n******************************************************************\nDRDASD_OKAY    DS    0H\n               MVC   TEXTMESG+1(19),=C'$ISUCCESSFUL DRDASD'\n               BAL   R9,WRITE_DRDASD\n               LA    R10,0\n               B     EXIT_DRDASD\n\n\n******************************************************************\n* SET RC, RELOAD CALLERS REGS AND BRANCH BACK TO CALLER          *\n******************************************************************\nEXIT_DRDASD    DS    0H\n               LR    R15,R10\n\n*              COPY $$EXIT\nEXITPROG DS    0H\n         L     13,4(,13)             LOAD ADDR OF CALLERS SAVE AREA\n         L     14,12(,13)            LOAD REGISTER 14 FROM 12 OFF\n         LM    0,12,20(13)           LOAD REG0-12 FROM 20 OFF\n         BR    14                    RETURN TO CALLER\n\n*              COPY $$REGS\n**********************************************************************\n*                                 EQUATE THE WORLD AS WE KNOW IT\nR0       EQU   00\nGETADDR  EQU   01  <----- GETMAIN STORAGE ADDRESS RETURNS HERE\nR1       EQU   01  <----- GETMAIN STORAGE ADDRESS RETURNS HERE\nR2       EQU   02\nR3       EQU   03\nR4       EQU   04\nR5       EQU   05\nR6       EQU   06\nR7       EQU   07\nR8       EQU   08\nR9       EQU   09\nR10      EQU   10\nR11      EQU   11\nBASE1    EQU   12 <----- BASE REGISTER OF CSECT\nR12      EQU   12 <----- BASE REGISTER OF CSECT\nSAVEAREA EQU   13 <----- ADDRESS OF MY SAVE AREA FOR CALLERS\nR13      EQU   13 <----- ADDRESS OF MY SAVE AREA FOR CALLERS\nPSW      EQU   14 <----- PROGRAM STATUS WORD\nR14      EQU   14 <----- PROGRAM STATUS WORD\nRTNCODE  EQU   15 <----- RETURN CODES GO HERE\nR15      EQU   15 <----- RETURN CODES GO HERE\n**********************************************************************\n\n\n******************************************************************\n* RETURN CODE TEXTS                                              *\n******************************************************************\nDRDASD_RC      DS    0F\nDRDASD_RC0     DC    CL4'RC00'\nDRDASD_RC4     DC    CL4'RC04'\nDRDASD_RC8     DC    CL4'RC08'\nDRDASD_RC12    DC    CL4'RC12'\nDRDASD_RC16    DC    CL4'RC16'\nDRDASD_RC20    DC    CL4'RC20'\nDRDASD_RC24    DC    CL4'RC24'\n\nDRDASD_RE      DS    0F\nDRDASD_RE0     DC    CL1'0'\nDRDASD_RE1     DC    CL1'1'\nDRDASD_RE2     DC    CL1'2'\nDRDASD_RE3     DC    CL1'3'\nDRDASD_RE4     DC    CL1'4'\nDRDASD_RE5     DC    CL1'5'\nDRDASD_RE6     DC    CL1'6'\nDRDASD_RE7     DC    CL1'7'\nDRDASD_RE8     DC    CL1'8'\nDRDASD_RE9     DC    CL1'9'\nDRDASD_REA     DC    CL1'A'\nDRDASD_REB     DC    CL1'B'\nDRDASD_REC     DC    CL1'C'\nDRDASD_RED     DC    CL1'D'\nDRDASD_REE     DC    CL1'E'\nDRDASD_REF     DC    CL1'F'\n\n\n******************************************************************\n* BUILD THE AREAS NEEDED TO USE THE OBTAIN MACRO... TO KEEP IT   *\n* REENTRANT, I BUILD THEM HERE AT COMPILE TIME WITH THE CAMLST   *\n* MACRO AND MOVE THE AREA TO STORAGE AT RUN TIME WHERE I WILL    *\n* POPULATE IT WITH THE CORRECT ADDRESSES.                        *\n******************************************************************\nDSCBABC_MVC    CAMLST SEARCH,DSABC_MVC,VOLNUM_MVC,DSCB_WORK_MVC\nDSABC_MVC      DS F       * DATASET NAME AREA\nVOLNUM_MVC     DS F       * ADDRESS OF THE STORED VOLSER (CHAR 6)\nDSCB_WORK_MVC  DS F       * ADDRESS OF OUR 144 BYTE WORK AREA\n\n\nALOC           DC    A(X'80000000'+ALOCRB)\nALOCRB         DC    AL1(20)\nALOCVC         DC    AL1(1)\n               DC    AL2(0)\nALOCER         DC    AL2(0)\nALOCIN         DC    AL2(0)\nALOCTP         DC    A(0)\n               DC    A(0)\n               DC    A(0)\nDDNX           DC    XL2'1',XL2'1',AL2(8),CL8'VTOC'\nDISP           DC    XL2'4',XL2'1',XL2'1',XL1'8'\nUNIT           DC    XL2'15',XL2'1',AL2(4),CL4' '\nVOLSER         DC    XL2'10',XL2'1',AL2(6),CL6' '\nVTOCALOC       CALL  ,(DDNX,DISP,UNIT,VOLSER),VL,MF=L\nVTOCULOC       CALL  ,(DDNX),VL,MF=L\nVTOC          DCB DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,              +\n               MACRF=E,EODAD=CLOSE,EXLST=RDJFLIST\n* VTOC   DCB   DDNAME=VTOC,DSORG=PS,RECFM=U,KEYLEN=44,BLKSIZE=96,\n*              MACRF=(R),EODAD=CLOSE,EXLST=RDJFLIST\nRDJFLIST       DC    X'07',AL3(JFCBAREA)\nJFCBAREA       DC    176X'0'\n* ROB TEST SNAP DCB\nSNAPDCB  DCB   DDNAME=SNAP,DSORG=PS,MACRF=W,RECFM=VBA,LRECL=125,       *\n               BLKSIZE=882\n* ROB TEST SNAP\nROBSNAP        DC    CL7'VOLSER='\n               DS    0F\nROBSNAP_VOLSER DS    CL6\n               DS    0F\n               DC    CL7'UCBCOM='\n               DS    0F\nROBSNAP_UCB    DS    XL48\n               DS    0F\n               DC    CL7'LSPACE='\n               DS    0F\nROBSNAP_DATA   DS    CL(40)\nROBSNAP_END    EQU   *\n\n\n******************************************************************\n* THE FOLLOWING IS ACTUALLY THE AREA THAT WILL BE USED TO MAP    *\n* OUR STORAGE AREA THAT WE REQUEST IN THE BEGINNING OF THE CSECT *\n******************************************************************\nWSPACEL        DC    A(4096)\nWSPACE         DSECT\nUPTADDR        DS    A\nECTADDR        DS    A\nECBADS         DS    F            * FULL WORD VALUE F'0'\n*              DS    0F           * FULL WORD BOUNDRY (DONT NEED?)\nPUTBLOK        DS    XL4          * 4 BYTES VALUE X'00000000'\n               DS    A            * ADDRESS VALUE A(0)\n               DS    A            * ADDRESS VALUE A(0)\nTEXTOLD        DS    F            * NUMBER OF MESSAGES VALUE F'1'\n               DS    A            * ADDRESS OF TEXTMSG1\nTEXTMSG1       DS    H            * LENGTH OF TEXTMSG1 & MESG H'76'\n               DS    H            * HALF WORD (DISPLACEMENT) VALUE H'0'\nTEXTMESG       DS    CL72         * 72 BYTE MESSAGE AREA\nIOPLADS        DS    4F           * 4 FULL WORDS VALUE 4F'0'\n               DS    0F\nUCB_COMMON     DS    XL48\nUCB_COM_EXT    DS    XL32\nUCB_PRE_EXT    DS    XL48\nDEV_NUMBER     DS    XL4\nDEV_ADDR       DS    H\nCONFIG_TOKEN   DS    XL48\nRETURN_CODE    DS    F\nREASON_CODE    DS    F\nUCB_WORK       DS    XL100\n\nCALLED_MACRO   DS    CL9\nSTORE_VOLSER   DS    CL6\nDSCBABC        DS    4F\nDSABC          DS    CL44    * DSNAME IS ALL X'04' FOR FORMAT 4 DSCB\nDSCB_WORK      DS    140C    * 140 BYTE WORK AREA FOR DSCB\n\nCVD_AREA       DS    F\nUNPK_AREA      DS    D\nCHAR_AREA      DS    F\nSTORE_AREA8    DS    CL8\nSTORE_AREA16   DS    CL16\nVOLDAT_DISP    EQU *-WSPACE\nLSPACE_VOLDAT  DS    0F\n               DS    CL40         * THIS APPEARS TO BE CL36, BUT I\n*                                 * ADDED 4 JUST TO BE SAFE\nLSPACE_D_DISP  EQU   *-WSPACE\nLSPACE_DATA    LSPACE MF=(D,DATA)\n               EJECT\nLSPACE_P_DISP  EQU   *-WSPACE\n* USE THE MF=D FORM OF THE LSPACE MACRO TO CREATE THE PARMS DSECT\nLSPACE_PARM    LSPACE MF=D\n               EJECT\n\n*SPACEL        EQU   *-WSPACE\n\n* MAPPING MACRO FOR THE REXX ENVIRONMENT BLOCK\n               IRXENVB\n               EJECT\n* MAPPING MACRO FOR THE REXX WORK BLOCK EXTENTION\n               IRXWORKB\n               EJECT\n* MAPPING MACRO FOR THE COMMAND PROCESSOR PARAMETER LIST (CPPL)\n               IKJCPPL\n               EJECT\n* MAPPING MACRO FOR UNIT CONTROL BLOCKS (UCB)\n               IEFUCBOB\n               EJECT\n* MAPPING MACRO FOR THE DSCB FORMAT 4 (NO DSECT PROVIDED BY MACRO)\nFORMAT4        DSECT\n               IECSDSL1 4\n               EJECT\n\n\n*******************************************************************\n* MAPPING MACROS FOR DYNALLOC PROCESSING AREAS\n*******************************************************************\n\n* MAPPING MACRO FOR JOB FILE CONTROL BLOCK\nJFCB           DSECT\n               IEFJFCBN\n               EJECT\n\n* MAPPING MACRO FOR THE DATA CONTROL BLOCK\nDCBDSECT       DCBD DEVD=DA,DSORG=PS\n               EJECT\n\n* MAPPING MACRO FOR THE DATA EXTENT BLOCK\nDEBDSECT       IEZDEB LIST=YES\n               EJECT\n\n               END\n/*\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS0.DRDASD.SOURCE\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(15,15),RLSE),DISP=(,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n//            DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DISP=SHR,DSN=SYS0.DRDASD.LOADLIB(DRDASD)\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JCL1": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x05\\x03\\x9f\\x01\\x05\\x03\\x9f\\x11C\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-08T00:00:00", "modifydate": "2005-02-08T11:43:50", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSADM"}, "text": "//DRDASDTS JOB (PAOZ,,100,100),ROB,CLASS=D,MSGCLASS=X,\n//  REGION=4M,NOTIFY=&SYSUID,COND=(4,LT) TYPRUN=HOLD\n//*\n//STEP10   EXEC PGM=IKJEFT01\n//STEPLIB  DD  DSN=SYS0.DRDASD.LOADLIB,DISP=SHR\n//SYSEXEC  DD  DSN=TEST.REXX.CNTL,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD *\n    T1\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JCL2": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x05\\x03\\x9f\\x01\\x05\\x03\\x9f\\x126\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-08T00:00:00", "modifydate": "2005-02-08T12:36:52", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSADM"}, "text": "//DRDASDTS JOB (PAOZ,,100,100),ROB,CLASS=D,MSGCLASS=X,\n//  REGION=4M,NOTIFY=&SYSUID,COND=(4,LT) TYPRUN=HOLD\n//*\n//STEP10   EXEC PGM=IKJEFT01\n//STEPLIB  DD  DSN=SYS0.DRDASD.LOADLIB,DISP=SHR\n//SYSEXEC  DD  DSN=SYS0.DRDASD.TEXT,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//OUTFILE  DD  SYSOUT=*\n//SYSTSIN  DD *\n    R1\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "README": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00&\\x01\\x05\\x03\\x8f\\x01\\x05\\x03\\x9f\\x12F\\x00u\\x00p\\x00\\t\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-02-07T00:00:00", "modifydate": "2005-02-08T12:46:26", "lines": 117, "newlines": 112, "modlines": 9, "user": "SYSADM"}, "text": "To use the DRDASD asm mod, you will need a couple of REXX execs.\n\nFirst you need an exec that calls the assembly mod:\n\nWe will call this guy T2.  He is located in my PDS SYS0.DRDASD.TEXT(T2)\n/*REXX*/\n    call 'DRDASD'\n    ReturnCode = RC\n    return ReturnCode\n\nThat will do just fine.  Second, you need an exec that will call the\nexec that calls the assembly mod.  In this example, it simply displays\nthe results returned and does not interpret them and format a nice\nreport, but that isn't too tough to do as the results are REXX\nstatements that can be interpreted:\n\nWe will call this guy T1.  He is located in my PDS TEST.REXX.CNTL(T1)\n/*REXX*/\n    x = outtrap('OutArray.',,'NOCONCAT')\n    call 'T2'\n    x = outtrap('OFF')\n    do i = 1 to OutArray.0\n       say OutArray.i\n    end\nexit\n\n\nThese two execs, in combination with the DRDASD asm mod, should report\non all of the DASD that is online to that LPAR.  Here is the JCL needed\nto run it and some stuff back.  The DRDASD asm mod is in\nSYS0.DRDASD.LOADLIB in my shop.  You will find this JCL in member JCL1\nof this PDS.\n\n//DRDASDTS JOB (PAOZ,,100,100),ROB,CLASS=D,MSGCLASS=X,\n//  REGION=4M,NOTIFY=&SYSUID,COND=(4,LT) TYPRUN=HOLD\n//*\n//STEP10   EXEC PGM=IKJEFT01\n//STEPLIB  DD  DSN=SYS0.DRDASD.LOADLIB,DISP=SHR\n//SYSEXEC  DD  DSN=TEST.REXX.CNTL,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD *\n    T1\n//*\n\nThe output from this job should look something like this:\n\n$ICONFIGURATION NEW DRDASD\n$DV='DB2S01'; D='1001'\n$DV='DB2S01'; FC=0000000000000615; FT=0000000000000345\n$DV='DB2S01'; FE=0000000000000079\n$DV='DB2S01'; LC=0000000000000097; LT=0000000000000006\n$DV='DB2S01'; VIX='Y'; VIXS='E'; SMSM='N'\n$DV='DB2S01'; SC=0000; ST=0003; EC=0002; ET=0002; VT=0030\n$DV='HSM001'; D='1003'\n$DV='HSM001'; FC=0000000000001017; FT=0000000000000056\n$DV='HSM001'; FE=0000000000000015\n$DV='HSM001'; LC=0000000000000712; LT=0000000000000000\n$DV='HSM001'; VIX='Y'; VIXS='E'; SMSM='N'\n$DV='HSM001'; SC=1300; ST=0000; EC=1306; ET=0014; VT=0105\n$DV='DB2D04'; D='104B'\n$DV='DB2D04'; FC=0000000000000488; FT=0000000000000020\n$DV='DB2D04'; FE=0000000000000007\n$DV='DB2D04'; LC=0000000000000261; LT=0000000000000000\n$DV='DB2D04'; VIX='Y'; VIXS='E'; SMSM='Y'\n$DV='DB2D04'; SC=0000; ST=0001; EC=0007; ET=0000; VT=0105\n$DV='DB2D07'; D='104C'\n$DV='DB2D07'; FC=0000000000001008; FT=0000000000000005\n$DV='DB2D07'; FE=0000000000000003\n$DV='DB2D07'; LC=0000000000000619; LT=0000000000000000\n$DV='DB2D07'; VIX='Y'; VIXS='E'; SMSM='Y'\n$DV='DB2D07'; SC=0000; ST=0001; EC=0004; ET=0000; VT=0060\n$DV='MVSRS3'; D='2581'\n$DV='MVSRS3'; FC=0000000000002470; FT=0000000000000016\n$DV='MVSRS3'; FE=0000000000000006\n$DV='MVSRS3'; LC=0000000000002470; LT=0000000000000000\n$DV='MVSRS3'; VIX='N'; VIXS='E'; SMSM='N'\n$DV='MVSRS3'; SC=0000; ST=0001; EC=0003; ET=0000; VT=0045\n$DV='MQP001'; D='2582'\n$DV='MQP001'; FC=0000000000007189; FT=0000000000000014\n$DV='MQP001'; FE=0000000000000005\n$DV='MQP001'; LC=0000000000006782; LT=0000000000000000\n$DV='MQP001'; VIX='N'; VIXS='E'; SMSM='N'\n$DV='MQP001'; SC=0000; ST=0001; EC=0005; ET=0014; VT=0089\n$DV='PUBP02'; D='2583'\n$DV='PUBP02'; FC=0000000000009971; FT=0000000000000009\n$DV='PUBP02'; FE=0000000000000003\n$DV='PUBP02'; LC=0000000000009971; LT=0000000000000000\n$DV='PUBP02'; VIX='Y'; VIXS='E'; SMSM='N'\n$DV='PUBP02'; SC=0000; ST=0001; EC=0006; ET=0000; VT=0090\n$ISUCCESSFUL DRDASD\n\nTo interpret this stuff, first, any time you see\n$ICONFIGURATION NEW DRDASD, start over.  At that point, there has been\na change in the configuration and the DRDASD mod started over reading\nthe dynamic UCBs from the top.  There are 3 types of message.\n$I - informational, $W - Warning, $E - Error and $D - Data.\nIf you have a $D message, strip the first 2 characters off and\ninterpret the line to use the REXX variables.  The variables can\nbe interpreted as follows: V is volser, D is device, FC is free\ncylinders, FT is free tracks, FE is free extents, LC is largest\ncontiguous free cylinders, LT is largest contiguous tracks (add\nthis to LC * 15 if you want total largest contiguous tracks), VIX\nis VTOC index (yes or no), VIXS is VTOC index status (enabled or\ndisabled), SMSM is SMS managed (yes or no), SC is absolute starting\ncylinder for the VTOC, ST is absolute starting track for the VTOC,\nEC is absolute ending cylinder for the VTOC, ET is extra terrestrial,\nkidding, absolute ending track for VTOC, and VT is the total VTOC\nallocation in tracks.\n\nJCL2 of this PDS executes exec R1 which calls T2 to get DRDASD to run.\nThe results are returned and interpreted into variables and a basic\nformated report is created in and sent to DD OUTFILE.\n\nYou can email me with questions at rob.johns@anpac.com\nThanks Sam!\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "R1": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x07\\x01\\x05\\x03\\x9f\\x01\\x05\\x03\\x9f\\x12C\\x00I\\x00I\\x00\\n\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2005-02-08T00:00:00", "modifydate": "2005-02-08T12:43:07", "lines": 73, "newlines": 73, "modlines": 10, "user": "SYSADM"}, "text": "/*REXX*/\n    x = outtrap('OutArray.',,'NOCONCAT')\n    call 'T2'\n    x = outtrap('OFF')\n   /* okay, not that isn't in an array, queue up the statements in */\n   /* the datastack after you strip off of the $D                  */\n    \"NEWSTACK\"\n    do i = 1 to OutArray.0\n       if word(OutArray.i,1) = '$ICONFIGURATION' then do\n          \"DELSTACK\"\n          \"NEWSTACK\"\n       end\n       if substr(OutArray.i,1,2) = '$D' then do\n          x = substr(OutArray.i,3)\n          interpret x\n          if pos('D=',OutArray.i) > 0 then do\n             queue 'Volume Serial:' V '    Device:' D\n          end\n          if pos('FC=',OutArray.i) > 0 then do\n             FC = strip(FC,'L','0')\n             if FC = '' then FC = 0\n             FT = strip(FT,'L','0')\n             if FT = '' then FT = 0\n             queue '   Free Cylinders:' FC '    Free Tracks:' FT\n          end\n          if pos('FE=',OutArray.i) > 0 then do\n             FE = strip(FE,'L','0')\n             if FE = '' then FE = 0\n             queue '   Free Extents:' FE\n          end\n          if pos('LC=',OutArray.i) > 0 then do\n             LC = strip(LC,'L','0')\n             if LC = '' then LC = 0\n             LT = strip(LT,'L','0')\n             if LT = '' then LT = 0\n             queue '   Largest Cylinders:' LC,\n                   '   Largest Tracks:' LT\n          end\n          if pos('VIX=',OutArray.i) > 0 then do\n             x = '   Indexed VTOC:'\n             z = 'No'\n             if VIX = 'Y' then z = 'Yes'\n             x = x z '   Index Status:'\n             z = 'Disabled'\n             if VIXS = 'E' then z = 'Enabled'\n             x = x z '   SMS Managed:'\n             z = 'No'\n             if SMSM = 'Y' then z = 'Yes'\n             x = x z\n             queue x\n          end\n          if pos('SC=',OutArray.i) > 0 then do\n             queue '   VTOC Starting Cylinder:' SC,\n                   '   Ending Cylinder:' EC\n             queue '        Starting Track   :' ST,\n                   '   Ending Track   :' ET\n             queue '        Size in Tracks   :' VT\n          end\n       end\n    end\n\n    /* queue an eof */\n    queue\n\n    /* write to our DD statement */\n    \"EXECIO * DISKW OUTFILE (FINIS\"\n    if RC \u00ac= 0 then do\n       say 'Failed to write to DD OUTFILE'\n       \"DELSTACK\"\n       return RC\n    end\n    \"DELSTACK\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T1": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x05\\x03\\x9f\\x01\\x05\\x03\\x9f\\x11C\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-08T00:00:00", "modifydate": "2005-02-08T11:43:15", "lines": 8, "newlines": 8, "modlines": 0, "user": "SYSADM"}, "text": "/*REXX*/\n    x = outtrap('OutArray.',,'NOCONCAT')\n    call 'T2'\n    x = outtrap('OFF')\n    do i = 1 to OutArray.0\n       say OutArray.i\n    end\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "T2": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x05\\x03\\x9f\\x01\\x05\\x03\\x9f\\x11B\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-08T00:00:00", "modifydate": "2005-02-08T11:42:40", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYSADM"}, "text": "/*REXX*/\n    call 'DRDASD'\n    ReturnCode = RC\n    return ReturnCode\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT704/FILE704.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT704", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}