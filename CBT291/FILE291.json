{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011649000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE291.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE291.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x06'", "DS1TRBAL": "b'xv'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xfb\\x00\\n\\x01\\xfb\\x00\\x0e\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x12/\\x01\\x05\\x12/\\x08#\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-05-02T00:00:00", "modifydate": "2005-05-02T08:23:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-469"}, "text": "REGULAR CBT TAPE - VERSION 469    FILE:  291\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT469.FILE291\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,399 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/02/05    08:23:06    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ARTICLE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x970\\x0f\\x00\\x970\\x0f\\x19\\x13\\x01;\\x01;\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf9\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-10-27T00:00:00", "modifydate": "1997-10-27T19:13:00", "lines": 315, "newlines": 315, "modlines": 0, "user": "FILE291"}, "text": "              Large System Instruction Timings\n\n                   By Richard N. Hevener\n\nWhen I first began working with large IBM computers back in the\nmid-1970's, one of my colleagues had a treasured card listing\ninstruction timings for an ancient RCA machine, not one of ours.\nBut we still sometimes used the card as a guide to coding because\nIBM would never reveal how long instructions took to execute on\ntheir machines.  The situation has become much more complex since\nthen, depending not just on fundamentals like storage access and\ncache size but also on esoteric matters like look-ahead for\ninstruction set-up.  But I have always felt that some useful\nmeasurement should be possible, and over the years as we acquired\nnew machines, I performed some crude analysis just to see, for\nexample, if it took longer to perform computations with LA (Load\nAddress) than with AR (Add Register) (generally not), if addition\nwere faster than subtraction (no), if multiplication were faster\nthan division (emphatically yes), or if fixed-point arithmetic were\nfaster than floating-point (only sometimes).\n\nLate in 1996, I decided to try to obtain much more complete results\nby testing in a controlled environment every general and\nfloating-point instruction I could find that didn't involve storage\naccess.  This article presents the results of that research.  I\ndiscovered several items that surprised me and also confirmed many\nothers that I had long suspected.\n\nI believe my results will be of intrinsic interest and value to\nold-dog Assembler programmers.  Those who program in third generation\nlanguages such as COBOL, C, PL/I, and FORTRAN may find the results\nquite useful as well, because statements in those languages translate\nfairly directly into machine code.  Indeed, all these languages\nprovide a mechanism for obtaining Assembly language listings of\nprograms if one is in doubt about exactly what machine code is\ngenerated.  Armed with a knowledge of relative timings, one can\nfrequently enhance execution speed of key programs and subroutines,\nboth old and new.  It certainly doesn't hurt to have a general idea\nof timings in mind for any sort of programming.\n\nMy reason for excluding instructions that access storage is the\ngreat variability involved in memory retrieval under different\nconditions.  I believe my results may safely be used as an\nindication of relative execution speed for all types of\ninstructions, however, as long as one keeps in mind that there are\nmany variables.  Register-to-register instructions, on the other\nhand, exhibit little fluctuation in the test processes explained\nbelow, with one exception:  certain instructions apparently take\ntwice as long to execute under peculiar circumstances, depending on\nload module size and alignment of instructions within the module\n(position of the stars?).  Indeed, I will give an example of\nprograms that can be made to consume 50% more CPU time by adding or\ndeleting a single unused byte at the end.  To me, this behavior is\nas fascinating as an exotic zoo beast.\n\nMy work was performed on an IBM 9672-R53 Parallel Enterprise Server\nrunning MVS/ESA 4.2.2 and using IBM's High Level Assembler 1.2.0.  I\nobtained comparable results under VM/ESA 1.2.0 using Assembler H\n2.1.0.  Under both operating systems, in all cases I built and\nexecuted load modules, as opposed to loading and executing object\nmodules.\n\nMy method for measuring instruction timings is to record the value\nof the CPU timer both before and after a loop involving a single\nRR-Format instruction (or other instruction not involving storage\naccess).  Subtracting these timer values and dividing by the number\nof loop iterations reveals how long a single iteration takes on\naverage, say T.  Now the process of looping itself involves a\ncertain amount of overhead, so it is necessary to determine the\noverhead value first and subtract it from T to get the actual\nexecution time for the instruction being measured.  Experimentally,\nthere is some variation from one run to another, but the results are\nsurprisingly uniform.  In my experience 50,000 loop iterations is\nsufficient to stabilize measurements fairly well.  One run of this\nmany iterations, including determining the overhead for the loop and\ntesting all 68 instructions, one after another, takes less than one\nsecond of CPU time, including assembly and link.  See Figure 1 for\nthe general layout of the program.\n\nI must digress for a moment to explain the exotic anomaly mentioned\nabove, because we want to eliminate it as an effect in measuring\ncomparison timings.  It arises as follows:  Whenever the target of a\nBCT loop is a four byte instruction, the loop takes one cycle\n(approx. 12 nanoseconds on our machine) longer to execute if and\nonly if one of the following two situations occurs:  EITHER 1) the\nload module length ends in 0, and the loop target is aligned on\nhexadecimal E in the program listing; OR 2) the load module length\nends in 8, and the loop target is aligned on hexadecimal 6 in the\nprogram listing.  Of course, all load modules have length ending in\neither 0 or 8 and all instructions are aligned on even-numbered\nbytes, so this behavior occurs on average for 1/8 of all BCT loops\nwhose target is a four byte instruction, at least in the cases I\nhave studied.\n\nTo keep the anomaly from occurring on the overhead loop itself, I\ninclude the instruction CNOP 0,4 shortly before it.  This guarantees\nthat the four byte BCT instruction, its own target, will be aligned\non a full word, hence on neither 6 nor E.  I also include the same\nCNOP instruction before each of the test loops for four byte\ninstructions: NOP, DXR, IPM, LA, and each of the eight shift\ninstructions.  This prevents an abnormal effect on execution times.\n\nAs I did not want to introduce variations due to storage access, I\ncoded several instructions so only registers, not storage, would be\naccessed.  For example, all of my branching tests involve register 0\nto suppress the branch.  The only test I ran of BC uses NOP to\nforestall branching.  I also initialize floating-point registers\nappropriately to prevent exponent overflow and general and\nfloating-point registers to prevent divide exceptions.\n\nThe results of my testing are presented in Figure 2.  This figure is\nnot a \"picture\" of output from the program in figure 1, but it is\nderived directly from that output.  (Picoseconds are converted to\nnanoseconds, for example.)  One key point that my research revealed\nis that the timings, while they vary a little from run to run\n(generally less than 5%), do not depend on the actual contents of\nregisters or on variables such as how many bits are shifted.\n\nI would like to mention several points specifically.  In this\nsummary \"float\" means either single or double precision floating\npoint, which are equivalent in execution speed.  Addition and\nsubtraction are equivalent in all cases.  For addition, float takes\n5 times as long as fixed.  For multiplication and division, float is\nactually somewhat faster than fixed.  Fixed-point multiplication\ntakes 7 times as long as addition.  Floating-point multiplication\nand addition are equivalent.  For both fixed and float, division\nconsumes about 3.5 times as much CPU as multiplication.  However,\nextended precision float addition, takes twice as long as normal\nfloat, multiplication takes about 3 times as long, and division is a\nreal killer, taking 13 times as long as normal float division, which\nitself is no speed demon!  In fact, at 235 cycles DXR is by far the\nworst performing instruction, taking about 10 times as long as its\nnearest competitor, DR.  Despite the admonitions in the IBM\nPrinciples of Operation manual, BALR and BASR perform equally well,\nas does BR versus all other BCR instructions.  One surprise to me\nwas that while LR, LTR, and LDR are equivalent, LTDR takes 5 times\nas long as the others.  I have touched above on only a few of the\npoints one may glean from Figure 2.  I encourage you to examine this\nfigure closely and perform additional tests if you are either\ncurious or suspicious.\n\nIn Figure 3 I provide source code for a program that illustrates the\nBCT anomaly I have spoken of.  Alignment of the key instruction in\none of the loops will be on 6 and in the other on E.  Whenever the\ntest instruction is four bytes long, you should see a difference of\nabout one cycle in execution time.  LA, for example, will appear to\ntake about 12 nanoseconds in one loop and about 24 in the other,\nafter subtracting 24 nanoseconds for loop overhead.  The same strong\neffect is observable for NOP or any of the eight shift instructions.\nI happened on this behavior purely by accident, and it took me quite\na while to pin down the exact conditions when it occurs (explained\nabove).  It is possible, of course, that the looping itself is the\nsource of the abnormality rather than the instruction being executed\nin the loop, but the additional CPU time consumed is very real.\nWhatever the reason for it, to the best of my knowledge the\nphenomenon occurs only under the conditions I have stated.\n\nFigure 4 gives a program that clearly illustrates the additional CPU\ntime used as a result of the anomaly.  The idea is to align the BCT\ninstruction on E and make the length of the program an exact odd\nmultiple of 8, whence the load module length will also end in 8.\nCall this program P1.  Observe that P1 does not satisfy either of\nconditions 1) or 2) above.  Now add a byte at the end of P1 to\nobtain P2, thereby increasing the load module length so it ends in\n0.  Condition 1) is now fulfilled, and CPU time for P2 vs. P1 will\nincrease by 50%.  Add 7 more bytes to P2 to get P3, with module\nlength still ending in 0.  CPU time won't change much, because\ncondition 1) is still met.  Now add just one more byte to P3,\nobtaining P4.  Its module length will end in 8 again, like P1, so\nCPU time will drop back.  Thus, we have one program where adding an\nunused byte increases CPU time by 50% (P1 vs. P2) and another where\ndeleting an unused byte has the same effect (P4 vs. P3).  By\nincreasing the number of loop iterations, for example, you can cause\nP1 and P4 to take 2 minutes of CPU and P2 and P3 to take 3 minutes!\nThis amazes me.\n\nI have been unable to get IBM to address this peculiar behavior at\nall, though they have given me the distinct impression that they are\naware of it, without precisely admitting this.  The behavior appears\nto be independent of operating system.  I suspect but am not certain\nthat the anomaly has been present for many generations of IBM\nequipment.\n\nAs a final disclaimer, I should perhaps state that results may vary\nin your environment.  I would be very interested, though, in hearing\nof any marked differences in relative execution speed of\ninstructions on either alternative IBM equipment or on compatible\nmachines (Hitachi and Amdahl).  I am particularly interested, too,\nin whether the abnormality I have dwelt on is manifested on other\nmachines.\n\nI hope that I have shed some much needed light on instruction\ntimings in the mainframe world.  As we have seen, there are some\narcane phenomena present, but by and large the timings for RR-Format\ninstructions are remarkably stable and can be used to make informed\ncoding decisions.\n\nFigure 1:  Key Elements of Main Timing Program\nSee TIMINGSP member.\n\nFigure 2:  Approximate Instruction Timings in Nanoseconds\n\nOverhead  24\nAR        12\nALR       12\nAXR      120\nADR       60\nAER       60\nAWR       60\nAUR       60\nNR        12\nBALR      24\nBASR      24\nBASSM     24\nBSM       24\nBR        12\nBNOR      12\nNOP       12\nBCTR      12\nCR        12\nCDR       60\nCER       60\nCLR       12\nDR       272\nDXR     2820\nDDR      216\nDER      216\nXR        12\nHDR       60\nHER       60\nIPM      252\nLR        12\nLDR       12\nLER       12\nLA        12\nLTR       12\nLTDR      60\nLTER      60\nLCR       12\nLCDR      60\nLCER      60\nLNR       12\nLNDR      60\nLNER      60\nLPR       12\nLPDR      60\nLPER      60\nLRDR      60\nLRER      60\nMR        84\nMXR      168\nMXDR      72\nMDR       60\nMER       60\nOR        12\nSPM      108\nSLDA      12\nSLDL      12\nSLA       12\nSLL       12\nSRDA      12\nSRDL      12\nSRA       12\nSRL       12\nSR        12\nSLR       12\nSXR      120\nSDR       60\nSER       60\nSWR       60\nSUR       60\n\nFigure 3:  Key Elements of Program to Illustrate Anomaly\n\n* SAME AS PROGRAM IN FIGURE 1 DOWN TO SAMPLE TESTS.\n         MVC   LINE+1(5),=CL5'LA 1'\n         CNOP  2,8            ALIGN NEXT LA ON 6 OR E\n         BAS   R10,PRELOOP\nLP       LA    R2,0\n         BCT   R4,LP\n         BAS   R10,PSTLOOP\n         MVC   LINE+1(5),=CL5'LA 2'\n         NOPR  0              ALIGN NEXT LA ON E OR 6\n         BAS   R10,PRELOOP\nLP1      LA    R2,0\n         BCT   R4,LP1\n         BAS   R10,PSTLOOP\n* REST OF PROGRAM SAME AS FIGURE 1.\n\nFigure 4:  Base Program to Illustrate How Tiny Changes Can Greatly\n           Affect CPU Time\n\nP1       CSECT\n* INSERT STANDARD LINKAGE.\n         L     R4,NLP         NUMBER OF TIMES TO LOOP\n         CNOP  6,8            ALIGN BCT ON 6 OR E\n* INSERT TWO 'NOP 0' INSTR. IF NEC. TO ALIGN BCT ON E.\nB        BCT   R4,B\n* INSERT STANDARD RETURN.\nNLP      DC    F'1E8'         TAKES LESS THAN 5 SEC.\n* ALTER NEXT INSTR. IF NEC. SO PGM. LEN. IS AN EXACT ODD MULTIPLE 0F 8.\n* FURTHER MODIFY IT TO OBTAIN OTHER PGMS. AS EXPLAINED IN THE TEXT.\n         DS    4X\n         END   P1\n\nBrief Biography\n\nNaSPA member Richard Hevener works as a Senior Systems Programmer at\nthe University of South Carolina, Division of Libraries and\nInformation Systems.  He deals with both MVS and VM and has\nprogrammed in a wide variety of computer languages for over 20\nyears.  He also has a Ph.D. in mathematics from Princeton and taught\nfor a number of years at the university level.  His e-mail address\nis rick.hevener@sc.edu.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE291": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04E\\x00\\x00\\x01\\x05\\x12/\\x01\\x05\\x12/\\x08\"\\x009\\x009\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf9@@@'", "ispf": {"version": "04.69", "flags": 0, "createdate": "2005-05-02T00:00:00", "modifydate": "2005-05-02T08:22:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "CBT-469"}, "text": "//***FILE 291 is from Rick Hevener of the University of South       *   FILE 291\n//*           Carolina, and contains a program to measure CPU       *   FILE 291\n//*           instruction execution speed.  This program is         *   FILE 291\n//*           supposed to be a bit better than others of its        *   FILE 291\n//*           type (I think).  Included in this file, is an         *   FILE 291\n//*           article from Technical Support magazine which         *   FILE 291\n//*           describes how this program works, and what kind       *   FILE 291\n//*           of results you can obtain, using it.                  *   FILE 291\n//*                                                                 *   FILE 291\n//*     The program in TIMINGSP may be used to test timings of      *   FILE 291\n//*     a large number of instructions on mainframe IBM or          *   FILE 291\n//*     plug-compatible computers.  The method involves             *   FILE 291\n//*     cycling through a loop 25,000 times with 11                 *   FILE 291\n//*     instructions per cycle; the overhead for the loop is        *   FILE 291\n//*     subtracted.  One may easily modify the above numeric        *   FILE 291\n//*     parameters.  The only macros required are in                *   FILE 291\n//*     SYS1.MACLIB.  Execution time for the program is             *   FILE 291\n//*     approx. 0.5 sec. on the University of South Carolina's      *   FILE 291\n//*     2066-0X2 machine.                                           *   FILE 291\n//*                                                                 *   FILE 291\n//*     The original program is in member TIMINGSO.  It             *   FILE 291\n//*     employed 50,000 cycles per loop with only one               *   FILE 291\n//*     instruction per cycle.  That program and its results        *   FILE 291\n//*     are described in the following article, which is            *   FILE 291\n//*     reproduced here in member $ARTICLE:                         *   FILE 291\n//*                                                                 *   FILE 291\n//*     Richard N. Hevener, \"Large System Instruction Timings,\"     *   FILE 291\n//*     \"Technical Support,\" Vol. 5, No. 8, pp. 14-18, August,      *   FILE 291\n//*     1997.                                                       *   FILE 291\n//*                                                                 *   FILE 291\n//*     In Sep., 1999, Jim Melnyk of Great-West Life sent me an     *   FILE 291\n//*     e-mail inquiring about some peculiar results he had         *   FILE 291\n//*     obtained using the original program.  He had gotten         *   FILE 291\n//*     negative times for certain instructions on a 9672-RC6.      *   FILE 291\n//*     After several attempts, I was able to modify the            *   FILE 291\n//*     program to achieve reasonable timings on both that          *   FILE 291\n//*     machine and a 9672-R55 that Jim later discovered also       *   FILE 291\n//*     produced spurious results.  He also tested on a             *   FILE 291\n//*     9672-R24, obtaining output consistent with the original     *   FILE 291\n//*     program, as I did on U.S.C.'s 9672-R53.  I would like       *   FILE 291\n//*     to acknowledge Jim's assistance in testing various          *   FILE 291\n//*     versions of the program on his three machines.  I would     *   FILE 291\n//*     also like to thank him for suggesting that I employ a       *   FILE 291\n//*     loop macro to facilitate changes.                           *   FILE 291\n//*                                                                 *   FILE 291\n//*     In Aug., 2002, Charlie Hottel of the Washington, D.C.,      *   FILE 291\n//*     area raised some questions about the rather complicated     *   FILE 291\n//*     computational shifting in the program.  Thanks to           *   FILE 291\n//*     Charlie for suggesting a revision (and slight               *   FILE 291\n//*     simplification) to prevent a possible 0C9.                  *   FILE 291\n//*                                                                 *   FILE 291\n//*     My contact information may be found near the beginning      *   FILE 291\n//*     of TIMINGSP.                                                *   FILE 291\n//*                                                                 *   FILE 291\n//*     Rick Hevener (retired, formerly of University of South      *   FILE 291\n//*     Carolina) Columbia, S.C.  2005-04-27                        *   FILE 291\n//*                                                                 *   FILE 291\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMINGSD": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x002\\x00\\x97)\\x9f\\x01\\x05\\x11\\x7f\\x00\\x00\\x00&\\x00\\r\\x00\\x00\\xc3\\xf0\\xf2\\xf7\\xf8@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1997-10-26T00:00:00", "modifydate": "2005-04-27T00:00:32", "lines": 38, "newlines": 13, "modlines": 0, "user": "C0278"}, "text": "The program in TIMINGSP may be used to test timings of a large number of\ninstructions on mainframe IBM or plug-compatible computers.  The method\ninvolves cycling through a loop 25,000 times with 11 instructions per\ncycle; the overhead for the loop is subtracted.  One may easily modify\nthe above numeric parameters.  The only macros required are in\nSYS1.MACLIB.  Execution time for the program is approx. 0.5 sec. on the\nUniversity of South Carolina's 2066-0X2 machine.\n\nThe original program is in member TIMINGSO.  It employed 50,000 cycles\nper loop with only one instruction per cycle.  That program and its\nresults are described in the following article, which is reproduced here\nin member $ARTICLE:\n\nRichard N. Hevener, \"Large System Instruction Timings,\" \"Technical\nSupport,\" Vol. 5, No. 8, pp. 14-18, August, 1997.\n\nIn Sep., 1999, Jim Melnyk of Great-West Life sent me an e-mail inquiring\nabout some peculiar results he had obtained using the original program.\nHe had gotten negative times for certain instructions on a 9672-RC6.\nAfter several attempts, I was able to modify the program to achieve\nreasonable timings on both that machine and a 9672-R55 that Jim later\ndiscovered also produced spurious results.  He also tested on a\n9672-R24, obtaining output consistent with the original program, as I\ndid on U.S.C.'s 9672-R53.  I would like to acknowledge Jim's assistance\nin testing various versions of the program on his three machines.  I\nwould also like to thank him for suggesting that I employ a loop macro\nto facilitate changes.\n\nIn Aug., 2002, Charlie Hottel of the Washington, D.C., area raised some\nquestions about the rather complicated computational shifting in the\nprogram.  Thanks to Charlie for suggesting a revision (and slight\nsimplification) to prevent a possible 0C9.\n\nMy contact information may be found near the beginning of TIMINGSP.\n\nRick Hevener (retired, formerly of University of South Carolina)\nColumbia, S.C.\n2005-04-27\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMINGSO": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97)o\\x00\\x97)o\\t5\\x02h\\x02h\\x00\\x00\\xc3\\xf0\\xf2\\xf7\\xf8@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-10-23T00:00:00", "modifydate": "1997-10-23T09:35:00", "lines": 616, "newlines": 616, "modlines": 0, "user": "C0278"}, "text": "TMTRIAL  TITLE 'Test execution speed of all RR-instructions.'\n* Rick Hevener, USC Computer Annex, 514 Main St., Columbia SC 29208\n* Phone 803-777-2430; E-mail rick.hevener@sc.edu\n* Program written in December, 1996.\n         SPACE 2\n         PRINT OFF\n         SPACE 1\n         MACRO\n&NAME    REGEQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nF0       EQU   0\nF2       EQU   2\nF4       EQU   4\nF6       EQU   6\n         MEND\n         PRINT ON,NOGEN\n         SPACE 3\nTMTRIAL  CSECT\nTMTRIAL  AMODE 24\nTMTRIAL  RMODE 24\n         REGEQU\n         PRINT GEN\n         B     104(,R15)      BRANCH TO STM\n         DC    AL1(27),CL27'TMTRIAL  &SYSDATE &SYSTIME'\n         USING *,R13          TELL ASSEMBLER ABOUT FUTURE BASE REGISTER\n         DC    18F'0'         SAVE AREA\n         STM   R14,R12,12(R13)     STORE REGISTERS IN OLD SAVE AREA\n         LA    R15,32(,R15)   NEW SAVE AREA ADDRESS\n         ST    R15,8(,R13)    FORWARD  LINKAGE (NEW IN OLD)\n         ST    R13,4(,R15)    BACKWARD LINKAGE (OLD IN NEW)\n         LR    R13,R15        ESTABLISH BASE REGISTER AS NEW SA ADDR\n         SPACE 1\n         OPEN  (PRINT,OUTPUT)\n         SPACE 1\n         XC    TMO,TMO        TMO = 0 FOR OVERHEAD LOOP\n         MVI   LINE,C' '\n         MVC   LINE+1(LL),LINE\n         MVC   LINE(19),=CL19'0      picoseconds:'\n         LA    R6,1\n         LD    F4,ONE\n         LD    F6,ONE+8\n         L     R5,NLP         NUMBER OF TIMES TO LOOP\n         SPACE 1\n         STIMER TASK,BINTVL=LONGTIME\n         SPACE 1\n* LOOP TO OBTAIN OVERHEAD TIME.\n         MVC   LINE+1(5),=CL5'Base'\n         CNOP  0,4            ALIGN BCT ON FULL WORD\n         BAS   R10,PRELOOP\n         SPACE 1\nB        BCT   R4,B\n         BAS   R10,PSTLOOP\n         ST    R9,TMO         SAVE LOOP OVERHEAD TIME\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'AR'\n         BAS   R10,PRELOOP\nAR       AR    R2,R6\n         BCT   R4,AR\n         BAS   R10,PSTLOOP\n*         B     DONE\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'ALR'\n         BAS   R10,PRELOOP\nALR      ALR   R2,R6\n         BCT   R4,ALR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         LDR   F2,F6\n         MVC   LINE+1(5),=CL5'AXR'\n         BAS   R10,PRELOOP\nAXR      AXR   F0,F4\n         BCT   R4,AXR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'ADR'\n         BAS   R10,PRELOOP\nADR      ADR   F0,F4\n         BCT   R4,ADR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'AER'\n         BAS   R10,PRELOOP\nAER      AER   F0,F4\n         BCT   R4,AER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'AWR'\n         BAS   R10,PRELOOP\nAWR      AWR   F0,F4\n         BCT   R4,AWR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'AUR'\n         BAS   R10,PRELOOP\nAUR      AUR   F0,F4\n         BCT   R4,AUR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'NR'\n         BAS   R10,PRELOOP\nNR       NR    R2,R6\n         BCT   R4,NR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BALR'\n         BAS   R10,PRELOOP\nBALR     BALR  R2,0\n         BCT   R4,BALR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BASR'\n         BAS   R10,PRELOOP\nBASR     BASR  R2,0\n         BCT   R4,BASR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BASSM'\n         BAS   R10,PRELOOP\nBASSM    BASSM R2,0\n         BCT   R4,BASSM\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BSM'\n         BAS   R10,PRELOOP\nBSM      BSM   R2,0\n         BCT   R4,BSM\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BR'\n         BAS   R10,PRELOOP\nBR       BR    0\n         BCT   R4,BR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BNOR'\n         BAS   R10,PRELOOP\nBNOR     BNOR  0\n         BCT   R4,BNOR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'NOP'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nNOP      NOP   0\n         BCT   R4,NOP\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'BCTR'\n         BAS   R10,PRELOOP\nBCTR     BCTR  R2,0\n         BCT   R4,BCTR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'CR'\n         BAS   R10,PRELOOP\nCR       CR    R2,R6\n         BCT   R4,CR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SDR   F0,F0\n         MVC   LINE+1(5),=CL5'CDR'\n         BAS   R10,PRELOOP\nCDR      CDR   F0,F4\n         BCT   R4,CDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SER   F0,F0\n         MVC   LINE+1(5),=CL5'CER'\n         BAS   R10,PRELOOP\nCER      CER   F0,F4\n         BCT   R4,CER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'CLR'\n         BAS   R10,PRELOOP\nCLR      CLR   R2,R6\n         BCT   R4,CLR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         LR    R3,R6\n         MVC   LINE+1(5),=CL5'DR'\n         BAS   R10,PRELOOP\nDR       DR    R2,R6\n         BCT   R4,DR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         LDR   F2,F6\n         MVC   LINE+1(5),=CL5'DXR'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nDXR      DXR   F0,F4\n         BCT   R4,DXR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'DDR'\n         BAS   R10,PRELOOP\nDDR      DDR   F0,F4\n         BCT   R4,DDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'DER'\n         BAS   R10,PRELOOP\nDER      DER   F0,F4\n         BCT   R4,DER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'XR'\n         BAS   R10,PRELOOP\nXR       XR    R2,R6\n         BCT   R4,XR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'HDR'\n         BAS   R10,PRELOOP\nHDR      HDR   F0,F4\n         BCT   R4,HDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'HER'\n         BAS   R10,PRELOOP\nHER      HER   F0,F4\n         BCT   R4,HER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'IPM'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nIPM      IPM   R2\n         BCT   R4,IPM\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LR'\n         BAS   R10,PRELOOP\nLR       LR    R2,R6\n         BCT   R4,LR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LDR'\n         BAS   R10,PRELOOP\nLDR      LDR   F0,F4\n         BCT   R4,LDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LER'\n         BAS   R10,PRELOOP\nLER      LER   F0,F4\n         BCT   R4,LER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LA    R1,4095\n         MVC   LINE+1(5),=CL5'LA'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nLA       LA    R2,4095(R6,R1)\n         BCT   R4,LA\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LTR'\n         BAS   R10,PRELOOP\nLTR      LTR   R2,R6\n         BCT   R4,LTR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LTDR'\n         BAS   R10,PRELOOP\nLTDR     LTDR  F0,F4\n         BCT   R4,LTDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LTER'\n         BAS   R10,PRELOOP\nLTER     LTER  F0,F4\n         BCT   R4,LTER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LCR'\n         BAS   R10,PRELOOP\nLCR      LCR   R2,R6\n         BCT   R4,LCR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LCDR'\n         BAS   R10,PRELOOP\nLCDR     LCDR  F0,F4\n         BCT   R4,LCDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LCER'\n         BAS   R10,PRELOOP\nLCER     LCER  F0,F4\n         BCT   R4,LCER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LNR'\n         BAS   R10,PRELOOP\nLNR      LCR   R2,R6\n         BCT   R4,LNR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LNDR'\n         BAS   R10,PRELOOP\nLNDR     LNDR  F0,F4\n         BCT   R4,LNDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LNER'\n         BAS   R10,PRELOOP\nLNER     LNER  F0,F4\n         BCT   R4,LNER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LPR'\n         BAS   R10,PRELOOP\nLPR      LPR   R2,R6\n         BCT   R4,LPR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LPDR'\n         BAS   R10,PRELOOP\nLPDR     LPDR  F0,F4\n         BCT   R4,LPDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LPER'\n         BAS   R10,PRELOOP\nLPER     LPER  F0,F4\n         BCT   R4,LPER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LRDR'\n         BAS   R10,PRELOOP\nLRDR     LRDR  F0,F4\n         BCT   R4,LRDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'LRER'\n         BAS   R10,PRELOOP\nLRER     LRER  F0,F4\n         BCT   R4,LRER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LR    R3,R6\n         MVC   LINE+1(5),=CL5'MR'\n         BAS   R10,PRELOOP\nMR       MR    R2,R6\n         BCT   R4,MR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         LDR   F2,F6\n         MVC   LINE+1(5),=CL5'MXR'\n         BAS   R10,PRELOOP\nMXR      MXR   F0,F4\n         BCT   R4,MXR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'MXDR'\n         BAS   R10,PRELOOP\nMXDR     MXDR  F0,F4\n         BCT   R4,MXDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'MDR'\n         BAS   R10,PRELOOP\nMDR      MDR   F0,F4\n         BCT   R4,MDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'MER'\n         BAS   R10,PRELOOP\nMER      MER   F0,F4\n         BCT   R4,MER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'OR'\n         BAS   R10,PRELOOP\nOR       OR    R2,R6\n         BCT   R4,OR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'SPM'\n         BAS   R10,PRELOOP\nSPM      SPM   R2\n         BCT   R4,SPM\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SLDA'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSLDA     SLDA  R2,63\n         BCT   R4,SLDA\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SLDL'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSLDL     SLDL  R2,63\n         BCT   R4,SLDL\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SLA'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSLA      SLA   R2,63\n         BCT   R4,SLA\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SLL'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSLL      SLL   R2,63\n         BCT   R4,SLL\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SRDA'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSRDA     SRDA  R2,63\n         BCT   R4,SRDA\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SRDL'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSRDL     SRDL  R2,63\n         BCT   R4,SRDL\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SRA'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSRA      SRA   R2,63\n         BCT   R4,SRA\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVC   LINE+1(5),=CL5'SRL'\n         CNOP  0,4\n         BAS   R10,PRELOOP\nSRL      SRL   R2,63\n         BCT   R4,SRL\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'SR'\n         BAS   R10,PRELOOP\nSR       SR    R2,R6\n         BCT   R4,SR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         SR    R2,R2\n         MVC   LINE+1(5),=CL5'SLR'\n         BAS   R10,PRELOOP\nSLR      SLR   R2,R6\n         BCT   R4,SLR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         LDR   F2,F6\n         MVC   LINE+1(5),=CL5'SXR'\n         BAS   R10,PRELOOP\nSXR      SXR   F0,F4\n         BCT   R4,SXR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'SDR'\n         BAS   R10,PRELOOP\nSDR      SDR   F0,F4\n         BCT   R4,SDR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'SER'\n         BAS   R10,PRELOOP\nSER      SER   F0,F4\n         BCT   R4,SER\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LDR   F0,F4\n         MVC   LINE+1(5),=CL5'SWR'\n         BAS   R10,PRELOOP\nSWR      SWR   F0,F4\n         BCT   R4,SWR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         LER   F0,F4\n         MVC   LINE+1(5),=CL5'SUR'\n         BAS   R10,PRELOOP\nSUR      SUR   F0,F4\n         BCT   R4,SUR\n         BAS   R10,PSTLOOP\n         SPACE 1\n         MVI   LINE,C' '\n         MVC   LINE+1(LL),LINE\n         MVC   LINE(24),=CL24'0**** NORMAL PROGRAM END'\n         BAS   R11,PUTPRINT\n         SPACE 1\n*DONE     DS    0H\n         CLOSE (PRINT)\n         SPACE 1\n         L     R13,4(,R13)    OLD SAVE AREA ADDRESS\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         SR    R15,R15        RC = 0\n         BR    R14            RETURN\n         SPACE 2\nPRELOOP  LR    R4,R5          NUMBER OF TIMES TO LOOP\n         BAS   R11,CPUTIMER   TIME BEFORE LOOP\n         BR    R10\n         SPACE 2\nPSTLOOP  LM    R8,R9,TM       SAVE TIME BEFORE LOOP\n         BAS   R11,CPUTIMER   TIME AFTER LOOP\n         SPACE 1\n* COMPUTE ELAPSED TIME.\n         SL    R9,TM+4\n         BC    3,PSTLOOPA\n         SPACE 1\n         BCTR  R8,0           BORROW\n         SPACE 1\nPSTLOOPA SL    R8,TM\n         SPACE 1\n* MAKE R8-R9 < 2**31.\n         LNR   R2,R6          # OF SHIFTS = -1 (SET UP FOR LOOP)\n         SLDL  R8,2           RECOVER ONE OF THESE IN LOOP, ONE AFTER\n         SPACE 1\nPSTLOOPB AR    R2,R6          # = # + 1\n         SRDL  R8,1\n         LTR   R8,R8\n         BNZ   PSTLOOPB\n         SPACE 1\n         SRDL  R8,1           NOW R8-R9 < 2**31\n         SPACE 1\n         M     R8,=F'1E6'     CONVERT MICROSEC. TO PICOSEC.\n* RESTORE SHIFTS, MAKING BIT 51 = 1 PICOSEC.\n         SLDL  R8,0(R2)\n* PREVENT 0C9, MAKING BIT 57 = 1 PICOSEC.\n         SRDL  R8,6\n         DR    R8,R5          ELAPSED TIME / LOOP ITERATIONS\n         SRL   R9,6           PICOSEC.\n         SPACE 1\n         S     R9,TMO         SUBTRACT LOOP OVERHEAD TIME\n         SPACE 1\n* WRITE OUT THE NUMBER.\n         CVD   R9,WORK\n         MVC   LINE+19+1(LPTRN),PTRN\n         LA    R1,LINE+19+1+LPTRN-1\n         EDMK  LINE+19+1(LPTRN),WORK+2\n         BNM   PSTLOOPC\n         SPACE 1\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         SPACE 1\nPSTLOOPC DS    0H\n         BAS   R11,PUTPRINT\n         BR    R10\n         SPACE 2\nPUTPRINT PUT   PRINT,LINE\n         BR    R11\n         SPACE 2\nCPUTIMER CPUTIMER MIC,TM\n         BR    R11\n         DROP  R13\n         PRINT NOGEN\n         SPACE 3\n         LTORG\n         SPACE 1\nPRINT    DCB   MACRF=PM,DSORG=PS,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\n         SPACE 1\nONE      DC    L'1'\nNLP      DC    F'5E4'\nLONGTIME DC    F'2E9'\nPTRN     DC    X'40',9X'20',X'2120'\nLPTRN    EQU   *-PTRN\n         SPACE 1\nTM       DS    D\nWORK     DS    D\nTMO      DS    F\nLINE     DS    CL121\nLL       EQU   L'LINE-1\n         SPACE 1\n         END   TMTRIAL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIMINGSP": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00(\\x01\\x05\\x11\\x0f\\x01\\x05\\x12\\x1f\\x19B\\x01i\\x01d\\x01i\\xc3\\xf0\\xf2\\xf7\\xf8@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-04-20T00:00:00", "modifydate": "2005-05-01T19:42:28", "lines": 361, "newlines": 356, "modlines": 361, "user": "C0278"}, "text": "TIMINGS  TITLE 'Test execution speed of various instructions.'\n*\n* Rick Hevener, 3615 Devereaux Rd., Columbia, S.C. 29205;\n* ph. 803-254-2083; e-mail rick.hevener@sc.edu .\n*\n* Program written in December, 1996.\n*\n* October, 1999:  for 9672-R55 and RC6 put several instr. inside each\n* loop, align each loop on DWD; employ LOOP macro (sugg. by Jim\n* Melnyk); add SQDR, SQER; make numerous cosmetic changes; file 291 on\n* CBT tape (e-mail to and from Sam Golob).\n*\n* 2001-02-16:  add inline GOBK, HEXO, INIT macros; correct test section\n* for displaying results of CPUTIMER; make a few cosmetic changes.\n*\n* 2002-07-01:  change NCY from 5000 to 25000 for Z800.\n*\n* 2002-08-24:  prevent 0C9 by shifting 12 places before division,\n* instead of 9 before and 3 after (sugg. by Charlie Hottel).\n*\n* 2005-05-01:  modify some comments; revise LOOP macro; NOGEN it; add\n* NOPR.\n*\n         SPACE 2\n         PRINT OFF\n         SPACE 1\n         MACRO\n&NAME    GOBK  &RC=0,&SR1=N\n&NAME    L     R13,4(,R13)         Old save area address\n         AIF   ('&SR1' NE 'Y').CKRC\n         ST    R1,24(,R13)         Store R1 in old save area\n.CKRC    AIF   ('&RC'(1,1) NE '(').NOTREG\n         ST    &RC(1),16(,R13)     Store return code in old save area\n         LM    R14,R12,12(R13)     Restore registers\n         AGO   .RETURN\n.NOTREG  LM    R14,R12,12(R13)     Restore registers\n         LA    R15,&RC             Load return code\n.RETURN  BR    R14                 Return\n         MEND\n         SPACE 1\n         MACRO\n&NAME    HEXO  &REG,&ADDR\n&NAME    ST    R1,24(,R13)\n         ST    &REG,16(,R13)\n         LA    R1,&ADDR\n         UNPK  15(9,R13),16(5,R13)\n         TR    15(8,R13),D&SYSNDX-240\n         MVC   0(8,R1),15(R13)\n         L     R1,24(,R13)\n         B     D&SYSNDX+16\nD&SYSNDX DC    C'0123456789ABCDEF'\n         MEND\n         SPACE 1\n         MACRO\n&NAME    INIT  &L\n&ID      SETC  '&SYSECT'\n         AIF   ('&NAME' EQ '' AND '&L' NE 'PLI').STD\n&ID      SETC  '&NAME'\n         ENTRY &NAME               Establish entry point\n         AIF   ('&L' NE 'PLI').STDE\n         DS    0D                  Align so save area is on DWORD\n         DC    CL9'&SYSDATC',CL6'&SYSTIME',CL8'&ID',X'8' Eye catcher\n&NAME    STM   R14,R11,12(R13)     Store registers in old save area\n         BAS   R15,88(,R15)        New save area address\n         USING *,R13               Tell assembler about future base\n         DC    20F'0'              Save area\n         AGO   .LINK\n.STDE    DS    0D                  Align so save area is on DWORD\n.STD     ANOP\n&NAME    B     104(,R15)           Branch to STM\n         DC    X'8',CL9'&ID',CL9'&SYSDATC',CL9'&SYSTIME' Eye catcher\n         USING *,R13               Tell assembler about future base\n         DC    18F'0'              Save area\n         STM   R14,R12,12(R13)     Store registers in old save area\n         LA    R15,32(,R15)        New save area address\n.LINK    ST    R15,8(,R13)         Forward linkage (new in old)\n         ST    R13,4(,R15)         Backward linkage (old in new)\n         LR    R13,R15             Est. base register as new SA addr.\n         MEND\n         SPACE 1\n         MACRO\n&N       LOOP  &I,&OPA\n.* If no label is supplied when this macro is invoked, the instruction\n.* name (&I) will be used as the branch label for the loop.\n&L       SETC  '&I'\n         AIF   ('&N' EQ '').A\n&L       SETC  '&N'\n.A       MVC   L0108,=CL08'&L'\n         CNOP  4,8                 Align loop below on double word\n         BAS   R11,CPUTIMER        Time before loop\n         SPACE 1\n&L       DS    0H\n         AIF   (K'&OPA LE 2).C\n&OPB     SETC  '&OPA'(2,K'&OPA-2)\n&C       SETA  NINST\n.B       &I    &OPB\n&C       SETA  &C-1\n         AIF   (&C GT 0).B\n.C       BCT   R4,&L\n         BAS   R10,PSTLOOP         Post-loop processing\n         MEND\n         SPACE 1\n         MACRO\n&NAME    REGEQU &FL=N\n&I       SETA  0\n.L       ANOP\nR&I      EQU   &I\n         AIF   ('&FL' NE 'Y' OR &I GT 6 OR &I NE &I/2*2).C\nF&I      EQU   &I\n.C       ANOP\n&I       SETA  &I+1\n         AIF   (&I LT 16).L\n         MEND\n         PRINT ON,NOGEN\n         SPACE 3\nTIMINGS  CSECT\nTIMINGS  AMODE 24\nTIMINGS  RMODE 24\n         SPACE 1\n         REGEQU FL=Y\n         PRINT GEN\nNCY      EQU   025000              NUMBER OF CYCLES PER LOOP\nNINST    EQU   11                  NUMBER OF INSTR. PER CYCLE\n         SPACE 1\n         USING *+32+4096,R12       Get ready for 2nd base reg.\n         INIT  ,\n         SPACE 1\n         LA    R12,2048(,R13)      Set up 2nd base reg.\n         LA    R12,2048(,R12)\n         SPACE 1\n* Initialize registers that will not be changed.\n         L     R5,NCYA             NUMBER OF CYCLES PER LOOP\n         LA    R6,1\n         LD    F4,ONE\n         LD    F6,ONE+8\n         SPACE 1\n         OPEN  (PRINT,OUTPUT)\n         SPACE 1\n         MVC   L00,SPACES          CLEAR LINE\n         MVC   L0041,=CL41'1TIMINGS Version 2.08'\n         BAS   R11,PUTPRINT        WRITE HEADER\n         SPACE 1\n         MVC   L0041,=CL41'0Number of cycles per loop:'\n         LR    R9,R5               NUMBER OF CYCLES PER LOOP\n         BAS   R10,PSTLOOPD        WRITE OUT THE NUMBER\n         SPACE 1\n         MVC   L0041,=CL41'0Number of instructions per cycle:'\n         LA    R9,NINST            NUMBER OF INSTR. PER CYCLE\n         BAS   R10,PSTLOOPD        WRITE OUT THE NUMBER\n*                                  AND SET THINGS UP FOR FIRST LOOP\n         SPACE 1\n         MVC   L00,SPACES          CLEAR LINE\n         BAS   R11,PUTPRINT        WRITE A BLANK LINE\n         SPACE 1\n         MVC   L1012,=CL12'picoseconds:' SET UP FOR LOOPS\n         SPACE 1\n         STIMER TASK,BINTVL=LONGTIME\n         SPACE 1\n         PRINT NOGEN\nOVERHEAD LOOP  ,                   OBTAIN CYCLE OVERHEAD TIME\n* The cycle overhead time will be subtracted from the time per cycle\n* for each of the loops below.\n         LOOP  AR,(R2,R6)\n         LOOP  ALR,(R2,R6)\n*         B     DONE\n         LOOP  AXR,(F0,F4)\n         LOOP  ADR,(F0,F4)\n         LOOP  AER,(F0,F4)\n         LOOP  AWR,(F0,F4)\n         LOOP  AUR,(F0,F4)\n         LOOP  NR,(R2,R6)\n         LOOP  BALR,(R2,R0)\n         LOOP  BASR,(R2,R0)\n         LOOP  BASSM,(R2,R0)\n         LOOP  BSM,(R2,R0)\n         LOOP  BR,(R0)\n         LOOP  BNOR,(R0)\n         LOOP  NOPR,(R0)\n         LOOP  NOP,(0)\n         LOOP  BCTR,(R2,R0)\n         LOOP  CR,(R2,R6)\n         LOOP  CDR,(F0,F4)\n         LOOP  CER,(F0,F4)\n         LOOP  CLR,(R2,R6)\n         LOOP  DR,(R2,R6)\n         LOOP  DXR,(F0,F4)\n         LOOP  DDR,(F0,F4)\n         LOOP  DER,(F0,F4)\n         LOOP  XR,(R2,R6)\n         LOOP  HDR,(F0,F4)\n         LOOP  HER,(F0,F4)\n         LOOP  IPM,(R2)\n         LOOP  LR,(R2,R6)\n         LOOP  LDR,(F0,F4)\n         LOOP  LER,(F0,F4)\n         LOOP  LA,(R2,4095(R6,R2))\n         LOOP  LTR,(R2,R6)\n         LOOP  LTDR,(F0,F4)\n         LOOP  LTER,(F0,F4)\n         LOOP  LCR,(R2,R6)\n         LOOP  LCDR,(F0,F4)\n         LOOP  LCER,(F0,F4)\n         LOOP  LNR,(R2,R6)\n         LOOP  LNDR,(F0,F4)\n         LOOP  LNER,(F0,F4)\n         LOOP  LPR,(R2,R6)\n         LOOP  LPDR,(F0,F4)\n         LOOP  LPER,(F0,F4)\n         LOOP  LRDR,(F0,F4)\n         LOOP  LRER,(F0,F4)\n         LOOP  MR,(R2,R6)\n         LOOP  MXR,(F0,F4)\n         LOOP  MXDR,(F0,F4)\n         LOOP  MDR,(F0,F4)\n         LOOP  MER,(F0,F4)\n         LOOP  OR,(R2,R6)\n         LOOP  SPM,(R2)\n         LOOP  SLDA,(R2,63)\n         LOOP  SLDL,(R2,63)\n         LOOP  SLA,(R2,63)\n         LOOP  SLL,(R2,63)\n         LOOP  SRDA,(R2,63)\n         LOOP  SRDL,(R2,63)\n         LOOP  SRA,(R2,63)\n         LOOP  SRL,(R2,63)\n         LOOP  SQDR,(F0,F4)\n         LOOP  SQER,(F0,F4)\n         LOOP  SR,(R2,R6)\n         LOOP  SLR,(R2,R6)\n         LOOP  SXR,(F0,F4)\n         LOOP  SDR,(F0,F4)\n         LOOP  SER,(F0,F4)\n         LOOP  SWR,(F0,F4)\n         LOOP  SUR,(F0,F4)\n         PRINT GEN\n         SPACE 1\n*DONE     DS    0H\n         MVC   L00,SPACES          CLEAR LINE\n         MVC   L0041,=CL41'0**** Normal program end'\n         BAS   R11,PUTPRINT\n         SPACE 1\n         CLOSE (PRINT)\n         SPACE 1\n         GOBK  ,\n         SPACE 2\nCPUTIMER CPUTIMER MIC,TM           BIT 51 = 1 MICROSEC.\n         BR    R11\n         SPACE 2\nPSTLOOP  LM    R8,R9,TM            SAVE TIME BEFORE LOOP\n         BAS   R11,CPUTIMER        TIME AFTER LOOP\n         SPACE 1\n* Begin test section\n*         MVC   L00SV,L00           Save line\n*         MVC   L00,SPACES          Clear line\n*         BAS   R7,HEXO             Display time before loop\n*         STM   R8,R9,TMH           Save time before loop\n*         LM    R8,R9,TM            Time after loop\n*         BAS   R7,HEXO             Display time after loop\n*         LM    R8,R9,TMH           Restore time before loop\n*         MVC   L00,L00SV           Restore line\n*         B     HEXOA\n*HEXO     DS    0H\n*         HEXO  R8,L00+01\n*         HEXO  R9,L00+10\n*         BAS   R11,PUTPRINT\n*         BR    R7\n*TMH      DS    2F\n*L00SV    DS    CL121\n*HEXOA    DS    0H\n* End test section\n         SPACE 1\n* COMPUTE ELAPSED TIME.\n         SL    R9,TM+4\n         BC    3,PSTLOOPA\n         SPACE 1\n         BCTR  R8,0                BORROW\n         SPACE 1\nPSTLOOPA SL    R8,TM\n         SPACE 1\n* Make R8-R9 < 2**31 for multiplication below.\n* Set up for next loop.\n         LNR   R2,R6               # of net right shifts = -1\n* Perform left shift of 2; one will be restored inside next loop,\n* other one just after it.\n         SLDL  R8,2\n         SPACE 1\nPSTLOOPB AR    R2,R6               # = # + 1\n         SRDL  R8,1\n         LTR   R8,R8               R8-R9 < 2**32?\n         BNZ   PSTLOOPB\n         SPACE 1\n         SRDL  R8,1                Now R8-R9 < 2**31\n         SPACE 1\n         M     R8,=F'1E6'          CONVERT MICROSEC. TO PICOSEC.\n* RESTORE SHIFTS, MAKING BIT 51 = 1 PICOSEC.\n         SLDL  R8,0(R2)\n* Make bit 63 = 1 picosec.; do this before division to prevent 0C9.\n         SRDL  R8,12\n         DR    R8,R5               ELAPSED TIME / CYCLES\n         SPACE 1\n         CLC   L0108,=CL08'OVERHEAD' DOING OVERHEAD LOOP?\n         BNE   PSTLOOPC\n         ST    R9,TMO              SAVE CYCLE OVERHEAD TIME\n         B     PSTLOOPD\n         SPACE 1\nPSTLOOPC DS    0H\n         S     R9,TMO              SUBTRACT CYCLE OVERHEAD TIME\n         LA    R2,NINST            NUMBER OF INSTR. PER CYCLE\n         LR    R8,R9               GET READY FOR DIVISION\n         SRDA  R8,32\n         DR    R8,R2               TIME PER INSTR.\n         SPACE 1\n* WRITE OUT THE NUMBER.\nPSTLOOPD DS    0H\n         CVD   R9,WORK\n         MVC   L41LP,PTRN\n         LA    R1,L41LP+LPTRN-1\n         EDMK  L41LP,WORK+2\n         BNM   PSTLOOPE\n         SPACE 1\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         SPACE 1\nPSTLOOPE DS    0H\n         BAS   R11,PUTPRINT\n* Set things up for next loop.\n         LR    R4,R5               NUMBER OF CYCLES PER LOOP\n         SR    R2,R2               SET UP REGS FOR COMPUTATIONS\n         LR    R3,R6\n         LDR   F0,F4\n         LDR   F2,F6\n         BR    R10\n         SPACE 2\nPUTPRINT PUT   PRINT,L00\n         BR    R11\n         DROP  R13,R12\n         SPACE 3\n         LTORG\n         SPACE 1\n         PRINT NOGEN\nPRINT    DCB   MACRF=PM,DSORG=PS,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\n         SPACE 1\nONE      DC    L'1'\nLONGTIME DC    F'2E9'\nNCYA     DC    A(NCY)              NUMBER OF CYCLES PER LOOP\n* Pattern for editing integers follows:\nPTRN     DC    X'404020206B2020206B2020206B202120'\nLPTRN    EQU   *-PTRN\nSPACES   DC    CL121' '\n         SPACE 1\nTM       DS    D\nWORK     DS    D\nTMO      DS    F\nL00      DS    CL121\nL0041    EQU   L00+00,41\nL0108    EQU   L00+01,08\nL1012    EQU   L00+10,12\nL41LP    EQU   L00+41,LPTRN\n         SPACE 1\n         END   TIMINGS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT291/FILE291.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT291", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}