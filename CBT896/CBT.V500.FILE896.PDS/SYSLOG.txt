./ ADD NAME=$README  0105-90123-90124-0817-000075-000009-000000-$A1238
This file contains an ISPF Dialog and the related SYS1.PROCLIB member
(LOGWTR) for managing your system log data sets (aka. SYSLOG).

There is a Rockwell TSO command used that you should replace with your
own code that extracts the current center name.  This command is
SHOWTSO.

This file should be processed by IEBUPDTE and will create the following
members:

     $README  -  what you are currently reading
     EXEC     -  member which is input to IEBUPDTE with a target of
                 a REXX procedure library
     LOGSCAND -  documentation for the LOGSCAN utility
     MSGS     -  member which is input to IEBUPDTE with a target of
                 your ISPF Messages library
     PANELS   -  member which is input to IEBUPDTE with a target of
                 your ISPF Panels library
     PROCLIB  -  member which is input to IEBUPDTE with a target of
                 your SYS1.PROCLIB library
     SKELS    -  member which is input to IEBUPDTE with a target of
                 your ISPF Skeleton library
     SOURCE   -  member which is input to IEBUPDTE with a target of
                 your an assembler source library

Note that members:  EXEC, MSGS, PANELS, SKELS and SOURCE must be edited to
change +/ to ./ prior to processing by IEBUPDTE.

Rockwell dependencies (things you have to look out for and change when
you install this code):

The EXEC is dependent upon the naming convention of your SYSLOG data
sets.  We use ASYSLOG.center.Ddate.Ttime as we sometimes have the SYSLOG
from multiple centers at one location.

The PROCLIB member LOGWTR is our started task that we use to 'cut' the
SYSLOG into a data set.  You should change the high level index to match
the EXEC and update it for the center name you choose or modify it along
with the EXEC to ignore the center name.  The LOGWTR started task is
called here by our automation tool everytime that the SYSLOG is
'chopped' by intercepting message IEE043I.

The use of LOGSCAN, an IBM service aid, is supported.  However the source
is not available.  See file LOGSCAN.BIN for a binary unload of the
load library.  Reload using the command:

  "SEND LOGSCAN.BIN  LOGSCAN.XMIT"

Then issue the TSO Recieve command against this file:

  "RECEIVE INDS(LOGSCAN.XMIT)"

----------------------------------------------------------------------------

Below is a brief description of the SYSLOG dialog process:

 Scan SYSLOG data sets via ISPF Browse or LOGSCAN service aid

 This EXEC provides access to cataloged SYSLOG data sets. It is
 assumed that an external writer will copy SYSLOG data from JES to an
 online data set. The name must be of the form ASYSLOG.Dyyddd.Thhmm
 or ASYSLOG.center.Dyyddd.Thhmm, where yyddd is the current julian
 date, and hhmm is the current time. Center is a center name or NJE
 node name, etc. There may be multiple data sets for one day. The
 tutorial assumes that 31 days will be kept. DFHSM is supported.

 The EXEC extracts all data set names beginning with ASYSLOG and
 builds an ISPF table using the date and time. The user may then
 select one or more of these data sets for processing by ISPF browse
 or the LOGSCAN service aid.

 The EXEC may be invoked as %SYSLOG or %SYSLOG CNTR(center).

 See the tutorial for additional information.

./ ADD NAME=EXEC     0101-90123-92223-1308-000677-000636-000000-$A1238
+/ ADD NAME=SYSLOG
/*********************************REXX**********************************
*                                                                      *
* Scan SYSLOG data sets via ISPF Browse or LOGSCAN service aid         *
*                                                                      *
* This EXEC provides access to cataloged SYSLOG data sets. It is       *
* assumed that an external writer will copy SYSLOG data from JES to an *
* online data set. The name must be of the form ASYSLOG.Dyyddd.Thhmm   *
* or ASYSLOG.center.Dyyddd.Thhmm, where yyddd is the current julian    *
* date, and hhmm is the current time. Center is a center name or NJE   *
* node name, etc. There may be multiple data sets for one day. The     *
* tutorial assumes that 31 days will be kept. DFHSM is supported.      *
*                                                                      *
* The EXEC extracts all data set names beginning with ASYSLOG and      *
* builds an ISPF table using the date and time. The user may then      *
* select one or more of these data sets for processing by ISPF browse  *
* or the LOGSCAN service aid.                                          *
*                                                                      *
* The EXEC may be invoked as %SYSLOG or %SYSLOG CNTR(center).          *
*                                                                      *
* See the tutorial for additional information.                         *
*                                                                      *
* Douglas H. Adams                                                     *
* Mail Code 110-SH28                                                   *
* Rockwell Internation Corporation                                     *
* 2201 Seal Beach Boulevard                                            *
* P. O. Box 2215                                                       *
* Seal Beach, California 90740-1515                                    *
*                                                                      *
* (213) 797-2618                                                       *
*                                                                      *
* April 16, 1990                                                       *
*                                                                      *
* June  14, 1991  Corrected for SMS entries in LISTCAT  Michael Theys  *
* Oct   17, 1991  Corrected for LISTDSI IRX0275E msg    Michael Theys  *
* Jan   03, 1992  Corrected day-of-week for 1992        Michael Theys  *
*                                                                      *
***********************************************************************/

Signal on novalue
If trace() == "N"
Then trace Off

If sysvar("SYSISPF") ¬== "ACTIVE"
Then do
   Parse source . . name .
   "ISPSTART CMD(%"name")"
   Exit
   End

/***********************************************************************
* Main program                                                         *
***********************************************************************/
Arg "(" cntr ")" .
LOGSCAN_output? = 0
Call data_set_list
Address ISPEXEC
Call data_set_table
"TBTOP   SYSLOG"
"TBQUERY SYSLOG ROWNUM(ROWNUM)"
"VGET    ZSCREEND"
If zscreend = 27
Then zscreend = 24
"TBSKIP  SYSLOG NUMBER("rownum-zscreend+6") NOREAD"
"TBDISPL SYSLOG PANEL(LOGLIST) CSRROW("rownum") AUTOSEL(NO)",
               "POSITION(CRP)"
Tbdispl_rc = rc
Do while tbdispl_rc < 8
   Tdtop = ztdtop
   "VGET (ZVERB ZSCROLLN)"
   Call commands
   "TBTOP SYSLOG"
   Select
      When zverb == "UP"
      Then number = tdtop-zscrolln
      When zverb == "DOWN"
      Then number = min(tdtop+zscrolln,mult)
      Otherwise number = tdtop
      End
   "TBSKIP  SYSLOG NUMBER("number") NOREAD"
   "TBDISPL SYSLOG PANEL(LOGLIST) CSRROW("crp") AUTOSEL(NO)",
                  "POSITION(CRP)"
   Tbdispl_rc = rc
   End
"TBEND SYSLOG"
Call "MSG" "OFF"
Address TSO "FREE FILE(SYSIN LOG PRINT)"
Call "MSG" "ON"
Exit 4

/***********************************************************************
* Obtain a list of syslog data set names                               *
***********************************************************************/
Data_set_list:

If cntr == ""
Then "SHOWTSO CENTER=CNTR"
If substr(cntr,1,3) == "WCC"
Then center = "."cntr
Else center = ""
Call "OUTTRAP" "LISTCAT.","*"
"LISTCAT LEVEL(ASYSLOG"center") CATALOG('ASYSLOG') VOLUME"
If rc ¬= 0
Then do
   Do i = 1 to listcat.0; Say listcat.i; End
   Exit 8
   End
Call "OUTTRAP" "OFF"
Return

/***********************************************************************
* Build table of syslog data sets                                      *
***********************************************************************/
Data_set_table:

"TBCREATE SYSLOG NOWRITE REPLACE NAMES(ACTION DSNAME STATUS",
                                      "SDAYNAME SDATE SJDATE STIME",
                                      "EDAYNAME EDATE EJDATE ETIME)"
"TBVCLEAR SYSLOG"
          /*     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec */
Parse value "  0  31  59  90 120 151 181 212 243 273 304 334 365",
            "  0  31  60  91 121 152 182 213 244 274 305 335 366",
      with  days.0.0  days.1.0  days.2.0  days.3.0  days.4.0,
                      days.5.0  days.6.0  days.7.0  days.8.0,
                      days.9.0  days.10.0 days.11.0 days.12.0,
            days.0.1  days.1.1  days.2.1  days.3.1  days.4.1,
                      days.5.1  days.6.1  days.7.1  days.8.1,
                      days.9.1  days.10.1 days.11.1 days.12.1 .
/*Parse value "Sun    Mon    Tue    Wed    Thu    Fri    Sat   ", */
/*      with   name.0 name.1 name.2 name.3 name.4 name.5 name.6 . */
Parse value "Sat    Sun    Mon    Tue    Wed    Thu    Fri   ",
      with   name.0 name.1 name.2 name.3 name.4 name.5 name.6 .

#_Asyslog_files = 0
Do I = 1 to listcat.0
  If substr(listcat.I,1,7) = 'NONVSAM'
  Then #_Asyslog_files = #_Asyslog_files + 1
End
Mult = #_Asyslog_files

Old_ddd = ""

i = 1
do while(i <= listcat.0 )
   Parse var listcat.i "ASYSLOG" +0 dsname 1,
         "ASYSLOG" ".D" +2  yy +2 ddd ".T" +2  hh +2 mm +2 .
   If ddd == old_ddd
   Then parse value "" with edayname edate ejdate
   Else do
      Leap_year? = yy//4 = 0
      Do month = 1 to 12 while ddd > days.month.leap_year?; End
      Previous_month = month-1
      Day = ddd-days.previous_month.leap_year?
      /* This gives Saturday for Friday 01/03/92 */
      Weekday = (trunc(yy*365.25)+ddd)//7
      Edayname = name.weekday
      /* BEGIN of M.Theys Dayname calculation */
      mon = month
      year = 1900 + yy
      If mon <= 2 Then Do /* Jan,Feb to mon=13,14 for formula */
        mon = mon + 12
        year = year - 1
      End
    d# = (day+(2*mon)+((3*(mon+1))%5)+year+(year%4)-(year%100)+(year%400)+2)//7
      Edayname = name.d#  /* 0=Sat,1=Sun,...5=Thu,6=Fri */
      /* END of M.Theys Dayname calculation */
      Edate = format(month,2)"/"format(day,2)
      Ejdate = yy"."ddd
      End
   Etime = format(hh,2)":"mm
   J = I+4
   If word(listcat.J,1) == 'SMSDATA'
   Then do /* SMSdata entry */
     J = i+8
     incr = 9
   End
   Else do /* non SMSdata entry */
     J = i+5
     incr = 6
   End
   Parse var listcat.j "VOLSER------------" volser .
   If volser == "MIGRAT"
   Then status = "Migrated"
   Else status = ""
   "TBADD SYSLOG MULT("mult")"
   If ddd ¬== old_ddd
   Then do
      Old_ddd = ddd
      Sdayname = edayname
      Sdate = edate
      Sjdate = ejdate
      End
   Stime = etime
   i = i + incr
   End
Drop listcat.
Return

/***********************************************************************
* Process commands                                                     *
***********************************************************************/
Commands:

Do i = 1 to ztdsels
   "TBPUT SYSLOG"
   If i < ztdsels
   Then "TBDISPL SYSLOG POSITION(CRP)"
   End
If zverb = ""
Then do
   Msg = ""
   Call find_commands
   If msg == ""
   Then call process_commands
   Else "SETMSG MSG("msg")"
   End
Return

/***********************************************************************
* Find all line commands                                               *
***********************************************************************/
Find_commands:

"TBTOP SYSLOG"
Action = "A"
"TBSCAN SYSLOG ARGLIST(ACTION) CONDLIST(GE) ROWID(ROWID)"
Tbscan_rc = rc
Command = action
Dsname.0 = 0
Select
   When command == "B" | command == "L" | command == "R"
   Then call single_line_commands
   When command == "BB" | command == "LL" | command == "RR"
   Then call block_line_commands
   Otherwise nop
   End
Return

/***********************************************************************
* Process selected rows                                                *
***********************************************************************/
Process_commands:

"CONTROL DISPLAY SAVE"
Select
   When command == "B" | command == "BB"
   Then call browse
   When command == "L" | command == "LL"
   Then call logscan
   When command == "R" | command == "RR"
   Then call recall("NOWAIT")
   Otherwise nop
   End
"CONTROL DISPLAY RESTORE"
Return

/***********************************************************************
* Flag selected rows with an asterisk                                  *
***********************************************************************/
Flag_selected_rows:

"TBTOP SYSLOG"
Do i = 1 to dsname.0
   "TBSKIP SYSLOG ROW("row.i")"
   Action = "*"
   "TBPUT SYSLOG"
   End
Return

/***********************************************************************
* Build array of data sets selected by B or L line command             *
***********************************************************************/
Single_line_commands:

Do i = 1 by 1 while tbscan_rc = 0
   If action ¬== command then do
      Msg = "LOG000"
      Leave i
      End
   Dsname.0 = i
   Dsname.i = dsname
   Row.i = rowid
   Action = "A"
   "TBSCAN SYSLOG ARGLIST(ACTION) CONDLIST(GE) ROWID(ROWID)"
   Tbscan_rc = rc
   End
Return

/***********************************************************************
* Build array of data sets selected by BB or LL line command           *
***********************************************************************/
Block_line_commands:

#commands = 0
Tbskip_rc = 0
Do i = 1 by 1 while tbskip_rc = 0
   If action ¬== command & action >> "A"
   Then do
      Msg = "LOG000"
      Leave i
      End
   If #commands <= 1
   Then do
      Dsname.0 = i
      Dsname.i = dsname
      Row.i = rowid
      End
   If action == command
   Then #commands = #commands+1
   "TBSKIP SYSLOG ROWID(ROWID)"
   Tbskip_rc = rc
   End
If #commands ¬= 2 & msg == ""
Then msg = "LOG001"
Return

/***********************************************************************
* Browse syslog data sets                                              *
***********************************************************************/
Browse:

If ¬ recall("WAIT")
Then return
If dsname.0 = 1
Then do
   "CONTROL ERRORS RETURN"
   "BROWSE DATASET('"dsname.1"')"
   If rc ¬= 0
   Then "SETMSG MSG("zerrmsg")"
   "CONTROL ERRORS CANCEL"
   End
Else do
   Dslist = ""
   Do i = 1 to dsname.0
      Dslist = dslist "'"dsname.i"'"
      End
   Address TSO "ALLOCATE FILE(SYSLOG) DSNAME("dslist") REUSE"
   "SELECT PGM(BRSYSLOG)"
   Address TSO "FREE FILE(SYSLOG)"
   End
Call flag_selected_rows
Return

/***********************************************************************
* Invoke LOGSCAN for selected data sets                                *
***********************************************************************/
Logscan:

LOGSCAN_processed_rows? = 0
Call open_LOGSCAN_table
If ¬ LOGSCAN_output?
Then do
   Listdsi_rc = listdsi("LOGSCAN.LIST")
   If listdsi_rc < 16
   Then  LOGSCAN_output? = sysused ¬= 0
   End
Ztdret = "DOWN"
"TBTOP   LOGSCAN"
"TBSKIP  LOGSCAN"
"TBDISPL LOGSCAN PANEL(LOGSCAN)"
Logscan_rc = rc
Do while logscan_rc < 8
   Call LOGSCAN_commands
   If ztdadd == "YES"
   Then "TBDISPL LOGSCAN"
   Else do
      "TBTOP   LOGSCAN"
      "TBSKIP  LOGSCAN NUMBER("ztdtop") NOREAD"
      "TBDISPL LOGSCAN PANEL(LOGSCAN)"
      End
   Logscan_rc = rc
   End
"TBBOTTOM LOGSCAN POSITION(ROWNUM) NOREAD"
Do while rownum > 4 & type = ""
   "TBDELETE LOGSCAN"
   "TBSKIP   LOGSCAN NUMBER(0) POSITION(ROWNUM) NOREAD"
   End
"TBSAVE LOGSCAN LIBRARY(ISPPROF)"
If LOGSCAN_processed_rows?
Then call flag_selected_rows
Return

/***********************************************************************
* Create or open LOGSCAN parameter table                               *
***********************************************************************/
Open_LOGSCAN_table:

"TBSTATS LOGSCAN STATUS1(STATUS1) STATUS2(STATUS2) LIBRARY(ISPPROF)"
Select
   When status1 = 2
   Then do
      "TBCREATE LOGSCAN WRITE LIBRARY(ISPPROF) SHARE",
                       "NAMES(TYPE PARM MARGIN1 MARGIN2 DATA)"
      "TBVCLEAR LOGSCAN"
      Parse value "" with time1 time2
      Parse value "ON" "DATA" "Example",
            with  caps type   data
      "TBADD LOGSCAN SAVE(CAPS TIME1 TIME2) MULT(4)"
      "TBVCLEAR LOGSCAN"
      Do 3; "TBADD LOGSCAN"; End
      "TBSAVE LOGSCAN LIBRARY(ISPPROF) PAD(100)"
      End
   When status2 = 1
   Then do
      "TBOPEN LOGSCAN WRITE LIBRARY(ISPPROF) SHARE"
      "TBSKIP LOGSCAN"
      End
   Otherwise nop
   End
Return

/***********************************************************************
* Process LOGSCAN commands                                             *
***********************************************************************/
LOGSCAN_commands:

Save_caps = caps
Save_time1 = time1
Save_time2 = time2

Do ztdsels
   If caps == "ON"
   Then data = translate(data)
   First = left(data,1)
   Last = right(data,1)
   If first ¬== last | datatype(first,"alphanumeric")
   Then select
      When pos("'",data) = 0
      Then data = "'"data"'"
      When pos('"',data) = 0
      Then data = '"'data'"'
      Otherwise data = "FF"x || data || "FF"x
      End
   "TBPUT LOGSCAN"
   If ztdsels > 1
   Then "TBDISPL LOGSCAN"
   End

"TBTOP LOGSCAN"
"TBSKIP LOGSCAN"
Caps = save_caps
Time1 = save_time1
Time2 = save_time2
"TBPUT LOGSCAN SAVE(CAPS TIME1 TIME2)"

If ztdadd == "YES"
Then do
   If ztdscrp = 0
   Then do
      "TBQUERY LOGSCAN ROWNUM(ROWNUM)"
      Ztdscrp = rownum + ztdamt - ztdsize + 1
      End
   "TBBOTTOM LOGSCAN NOREAD"
   "TBVCLEAR LOGSCAN"
   Do ztdamt
      "TBADD LOGSCAN MULT("ztdamt")"
      End
   End

Select
   When zcmd == "" & ztdadd = "NO"
   Then "SETMSG MSG(LOG005)"
   When zcmd = 1
   Then call LOGSCAN_foreground
   When zcmd = 2
   Then call LOGSCAN_batch
   When zcmd = 3
   Then call LOGSCAN_print
   When zcmd = 4
   Then call LOGSCAN_browse
   When zcmd = 5
   Then call LOGSCAN_clear
   Otherwise nop
   End
Return

/***********************************************************************
* Execute LOGSCAN in the foreground                                    *
***********************************************************************/
LOGSCAN_foreground:

If ¬ recall("WAIT")
Then return
"FTOPEN TEMP"
"FTINCL LOG"
"FTCLOSE"
"VGET (ZTEMPF)"
Address TSO "ALLOCATE FILE(SYSIN) DATASET('"ztempf"') REUSE"
If listdsi_rc < 16
Then address TSO "ALLOCATE FILE(PRINT) DATASET(LOGSCAN.LIST) OLD REUSE"
Else address TSO "ALLOCATE FILE(PRINT) DATASET(LOGSCAN.LIST) NEW REUSE",
                 "RECFM(F B) LRECL(133) BLKSIZE(23408)",
                 "SPACE(1,1) CYLINDERS"
Dslist = ""
Do i = 1 to dsname.0
   Dslist = dslist "'"dsname.i"'"
   End
Address TSO "ALLOCATE FILE(LOG) DATASET("dslist") SHR REUSE"
"CONTROL DISPLAY LOCK"
"DISPLAY PANEL(LOGWAIT)"
Address TSO "CALL 'SYS1.MVSSERV(LOGSCAN)'"
LOGSCAN_output? = 1
"CONTROL ERRORS RETURN"
"BROWSE DATASET(LOGSCAN.LIST)"
If rc ¬= 0
Then "SETMSG MSG("zerrmsg")"
"CONTROL ERRORS CANCEL"
LOGSCAN_processed_rows? = 1
Return

/***********************************************************************
* Execute LOGSCAN in batch                                             *
***********************************************************************/
LOGSCAN_batch:

"DISPLAY PANEL(LOGJCL)"
If rc > 0
Then return
"FTOPEN TEMP"
"FTINCL LOGJCL"
"FTCLOSE"
"VGET (ZTEMPF)"
Call "OUTTRAP" "SUBMIT.","*"
Address TSO "SUBMIT '"ztempf"'"
If rc = 0 & submit.0 = 1
Then do
   Parse var submit.1 "JOB" jobname "(" .
   Message = submit.1
   "SETMSG MSG(LOG002)"
   End
Else do i = 1 to submit.0
   Say submit.i
   End
Call "OUTTRAP" "OFF"
Drop submit.
LOGSCAN_processed_rows? = 1
Return

/***********************************************************************
* Print LOGSCAN data set                                               *
***********************************************************************/
LOGSCAN_print:

If ¬ LOGSCAN_output?
Then do
   "SETMSG MSG(LOG006)"
   Return
   End
"DISPLAY PANEL(LOGPRINT)"
If rc > 0
Then return
Printds = "PR" "DATASET(LOGSCAN.LIST)" "SYSOUT("logclass")",
          "COPIES("logcopy")" "OUTDES("logfdef")" "PAGELEN("logpage")"
If logtitle == "YES"
Then printds = printds "TITLE"
Else printds = printds "NOTITLE"
If logdest ¬== ""
Then printds = printds "DEST("logdest")"
Select
   When logline1 ¬== "" & logline2 ¬== ""
   Then printds = printds "LINES("logline1":"logline2")"
   When logline1 ¬== ""
   Then printds = printds "LINES("logline1")"
   Otherwise nop
   End
Address TSO printds
If rc < 8
Then "SETMSG MSG(LOG003)"
Else "SETMSG MSG(LOG004)"
Return

/***********************************************************************
* Browse LOGSCAN data set                                              *
***********************************************************************/
LOGSCAN_browse:

If ¬ LOGSCAN_output?
Then do
   "SETMSG MSG(LOG006)"
   Return
   End
"CONTROL ERRORS RETURN"
"BROWSE DATASET(LOGSCAN.LIST)"
If rc ¬= 0
Then "SETMSG MSG("zerrmsg")"
"CONTROL ERRORS CANCEL"
Return

/***********************************************************************
* Clear LOGSCAN table                                                  *
***********************************************************************/
LOGSCAN_clear:

"TBBOTTOM LOGSCAN POSITION(ROWNUM) NOREAD"
Do while rownum > 4
   "TBDELETE LOGSCAN"
   "TBSKIP   LOGSCAN NUMBER(0) POSITION(ROWNUM) NOREAD"
   End
"TBVCLEAR LOGSCAN"
Do while rownum > 1
   "TBPUT  LOGSCAN"
   "TBSKIP LOGSCAN NUMBER(-1) POSITION(ROWNUM) NOREAD"
   End
"TBGET LOGSCAN SAVENAME(SAVE) NOREAD"
Parse value "" with time1 time2
"TBPUT  LOGSCAN SAVE"save
"TBSAVE LOGSCAN LIBRARY(ISPPROF)"
Return

/***********************************************************************
* Recall migrated data sets                                            *
***********************************************************************/
Recall:

Parse arg type  /* WAIT or NOWAIT */
Recall_ok? = 1
"TBTOP SYSLOG"
Do i = 1 to dsname.0
   "TBSKIP SYSLOG ROW("row.i")"
   If action == "R" | action == "RR"
   Then action = ""
   If status == "Migrated" | status == "Recalled"
   Then do
      Call listdsi "'"dsname.i"' NORECALL"
      Online? = sysreason = 0
      Migrated? = sysreason = 9 | sysreason = 25
      If migrated?
      Then do
         If type == "WAIT"
         Then do
            "CONTROL DISPLAY LOCK"
            "DISPLAY PANEL(LOGHRECA)"
            End
         Address TSO "HRECALL '"dsname.i"'" type "EXTENDRC"
         Recalled? = rc = 0
         Hsm_rc = rc/65536
         Hsm_reason = rc//65536
         Attention? = hsm_rc = 100
         End
      Else parse value "1       0         0         0         ",
                 with   online? migrated? recalled? attention?
      Select
         When online? | (migrated? & recalled? & type == "WAIT")
         Then do  /* data set online */
            Status = ""
            "TBPUT SYSLOG"
            End
         When type == "NOWAIT"
         Then do  /* asynchronous recall */
            Status = "Recalled"
            "TBPUT SYSLOG"
            Recall_ok? = 0
            End
         When migrated? & attention?
         Then do  /* recall in progress */
            Status = "Recalled"
            "TBPUT SYSLOG"
            "SETMSG MSG(LOG008)"
            Recall_ok? = 0
            End
         Otherwise
            "SETMSG MSG(LOG007)"
            Recall_ok? = 0
         End
      End
   End i
Return recall_ok?

/***********************************************************************
* Trap uninitialized variables                                         *
***********************************************************************/
Novalue:

Say "Uninitialized variable in line" sigl":"
Say sourceline(sigl)
Trace "?Results"
Nop
./ ADD NAME=LOGSCAND 0100-90124-90124-0808-000479-000479-000000-$A1238
:h2.LOGSCAN
.sp 2
.fo off
                           A Service Aid Program
            To print certain information or a certain time period
                            from the system log.
       ------------------ Installation suggestions -------------------
             link the object deck to AOST.LOAD or a user library,
             using the following JCL.
        //LINK EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL',REGION=128K
        //SYSLMOD DD DSN=AOST.LOAD(LOGSCAN),DISP=SHR
        //SYSLIN DD *
                 ---- Put object deck here ----
        /*
        //SYSUT1 DD DSN=&&TEMP,UNIT=SYSDA,SPACE=(1024,(50,20))
        //SYSPRINT DD SYSOUT=A
             You may want to use a cataloged procedure for LOGSCAN.
             Here is a sample proc that allows a canned routine
             to be concatenated to the control card input.
             Assume that the pds which contains the routines has
             a member null which has no records.
        //LOGSCAN PROC DSN=' ',DISP='SHR,PASS',ROUTINE=NULL
        //A       EXEC PGM=LOGSCAN
        //SYSIN   DD   DDNAME=SYSIN
        //        DD   DSN=SYS1.LOGSCAN(&ROUTINE),DISP=SHR
        //LOG     DD   DSN=&DSN,DISP=(&DISP)
        //PRINT   DD   SYSOUT=A
             If you anticipate using LOGSCAN from a TSO
             terminal, see below for an example of a
             CLIST which will invoke LOGSCAN.
             The default blocksize for the print data set can be
             altered permanently by zapping location x'20' to the
             halfword value desired. -  VER 0020 07CB
             To help identify the date of a log data set, LOGSCAN
             recognizes the date from message IEE102I as it appears
             in the log from a JES3/MVS system.  A record is printed
             the first time this message is found and each time the
             date changes.  To utilize this feature on other types of
             systems, add a message that will be issued periodically
             in this format -          IEE102I hh.mm.ss yy.ddd
             where the message id begins in the 40th position,
             or zap location x'22' to the position of 'IEE102I'
             in your log (relative to 1). This is a halfword value
             in hexadecimal. -  VER 0022 0028
             (for an unmodified JES2 system this would be the 25th
             position, or x'19'. - REP 0022 0019)
             if your log has its timestamps in a position other than
             those mentioned on page 4, you may zap the halfword
             value of its position (relative to 1) into
             location x'24'. -  VER 0024 0001
:h3.LOGSCAN         JCL
        //JOBNAME  JOB
        //A        EXEC PGM=LOGSCAN
        //PRINT DD SYSOUT=A                         (PRINTED OUTPUT)
        //LOG   DD DISP=SHR,DSN=SYSLOG              (LOG DATA SET)
        //SYSIN DD *                                (CONTROL DATA SET)
             This JCL is sufficient to scan the current system log
             when one data set is empty.  (This will not work for an
             MVS system log.  Specify a data set created by an
             external writer.)  Examples of other uses appear
             on page 9.
:h3.Input         Data Sets
             LOGSCAN will process fixed, fixed blocked, variable
             and variable blocked data with LRECL not larger than
             133, or undefined records with BLKSIZE not larger
             than 133.  As a convenience, LOGSCAN will accept
             records up to 255 bytes long, but only the first
             133 bytes can be scanned, printed or punched.
             LOGSCAN strips the first byte from input records
             if print control characters are indicated
             in the JCL or the data set label.  The record
             descriptor word is removed from variable records.
             The control data set is fixed or fixed blocked with
             LRECL of 80.  Unlike data sets can be concatenated.
:h3.Output         Data Sets
             Print output is RECFM=FB,LRECL=133.  A BLKSIZE of 1995
             is assumed unless otherwise specified in the JCL as a
             multiple of 133.  The output is always single-spaced.
             The print data set contains a listing of the control
             statements used, the records selected, and statistics
             about the number of records processed. The statistics
             kept are total records read from the log data set,
             the number within the specified time and sequence
             numbers, and the number finally selected.  An identifier
             is printed each time a new date is obtained from message
             IEE102I (MVS activity message) or IAT3100 (JES3 restart).
             The statistics do not include these records.
             Punch output is provided if //PUNCH DD IS INCLUDED IN THE
             JCL for a step.  Recfm is FB, and LRECL is assumed to be
             80 unless specified in the JCL.  Blksize is assumed to
             be the same as LRECL unless it is specified in the JCL.
             Records longer than the LRECL are truncated.  Only
             selected records are included in this data set.
:h3.Performance         Considerations
             LOGSCAN may be executed on OS/360 or OS/VS systems.
             The amount of CPU time used varies greatly, depending on
             the size of the data set being processed, the number of
             data type control statements, the range of time
             specified, and use of the margin control card.  If the
             position of a desired message is known, a margin card
             can be used to compare that one position instead of
             comparing 133 positions.  This also can prevent unwanted
             records from being printed.  If several data type cards
             are being used with a large data set, judicious use of
             the time card can reduce the run time considerably.
:h3.Condition         Codes
             The following condition codes are returned by LOGSCAN
        0 - normal run
        1 - no output because no records matched the argument
        2 - empty data set
        4 - data set LRECL larger than 255
        8 - control card had syntax error
       12 - required dd card missing
:h3.Parms
             The parm field on the EXEC card or in the TSO call
             statement may be used to override the default values for
             the location of the timestamps and the location of
             message IEE102I within the log records, as well as to
             indicate a TSO session.
        T=ppp   (where ppp is the position of the first character of
             the timestamp) can be used when the timestamp is 6 to 8
             digits long, but does not appear in position 1.
        I=ppp   (where ppp is the position where message IEE102I would
             start) can be used if message IEE102I appears in the log,
             but does not start in position 40.
             For example, the following statement -
        CALL 'AOST.LOAD(LOGSCAN)' 'TSO,T=16,I=25'
             Indicates that control statements are being entered from
             a terminal, that the timestamp is to be found in
             position 16 instead of 1, and that message IEE102I is to
             be found in position 25 instead of 40.
:h3.Control         Cards
             All control cards are optional except that at least
             a time card or sequence card or one or more data type
             cards is required.  Statements may begin in any column.
        TIME=hhmm,hhmm
             Specifies the beginning and end of the desired period.
             If used with data type cards, only records within this
             time will be scanned for the specified data.
             The last time card read is effective for the entire step.
             HHMM must be four digits, with leading zeros if needed.
             If the beginning time is greater than the ending time,
             it is assumed that a time period spanning midnight
             is desired.  The program processes records up to the
             end of the data set, so records from more than one
             day may be produced.  LOGSCAN recognizes time stamps
             of 6 to 8 digits starting in position 1 or 2 of
             each record or in the format hh.mm.ss starting in
             position 6.  Records without time stamps are handled
             according to the most recent time-stamped record.
        MARGIN=sss,eee
             Sets limits of the scan, if desired.  Default is 1,133.
             This sets the range of positions the first character
             of data must be found in.  As many margin cards as
             desired can be used.  Each one is effective for all
             data type cards following it until reset by another
             margin card.  Sss and eee can be one to three digits
             with values between 1 and 133.  If eee is omitted, it is
             assumed to be the same as sss, I.E. Only one position.
             A forms ruler may be used with a sample of a data set
             for exact margin determination, since control characters
             and record descriptor words are removed before
             processing, and only data is scanned.
        DATA='--character string--',WORD
        OR=                        ,ABBR
        AND=
        NOT=
             Used to select or exclude records with certain data.
             The WORD parameter, if used, requires the matching data
             to be surrounded by blanks or punctuation. This is useful
             when using a short search argument such as a job number
             or device number which could also appear as part of an
             unrelated name, to reduce unwanted output.  Characters
             other than letters, numbers, and national characters are
             considered to be punctuation.  The ABBR parameter
             requires the matching data to be preceded by a blank
             or punctuation.  This would be desired, for example,
             when searching for a certain message prefix.  If neither
             parameter is specified, matching data will be selected
             even if it is embedded in a longer name.
             Any character can be used in lieu of the apostrophes,
             provided the first one immediately follows the equal
             sign, and the character is not included in the data.
             NOT= causes a record with that data to be omitted.
             AND= requires a record to match the data from this card
             as well as previous card(s).  Any number of data type
             cards may be used.  If AND= or NOT= cards are used in
             an argument, they must follow all OR= and DATA= cards
             in that argument.  DATA= can be use interchangeably
             with OR=.
        SAVE
             or
        SAVE2
             or
        PRINT
             or
        NEXT
             or
        SKIP
             or
        / (Begin a new search argument)
             See complex search arguments below for explanation
             of these six control statements.
        * -----Comment-----
             A card beginning with an asterisk can contain comments.
             Comments may also appear in any control card if they are
             separated from the operands by one or more blanks.
        GO
             When entering control statements from a TSO terminal,
             go may be used instead of /* when all statements have
             been entered.  This keeps the SYSIN data set open and
             allows the program to request omitted control statements.
        NOPRINT
             If this statement is used, selected records will not
             appear in the print data set.  It could be used when
             selecting a large number of records for output to the
             punch data set, or for counting types of records.
        SET ssssssss=vvvvvvvvvvvv
             see symbolic variables below for explanation
             of this statement.
:h3.Sequence         Control
             An additional control statement is provided for use
             with data sets which have sequence numbers but not
             a time stamp.  It would be used for the same purpose
             as the TIME= control card would be for the system log.
             Any or all of the five keywords may appear in this
             statement in any order, but all keywords must appear in
             the same card, and only the last statement of this type
             is effective.
        START=xxxxxxxx
             Code a value from 0 to 99999999.  Sequence numbers
             below this value will not be printed.
        STOP=yyyyyyyy
             Code a value from 0 to 99999999. Sequence numbers
             above this value will not be printed.
        COLUMN=ccc
             Code a value from 1 to 133. This defines the position of
             the sequence field in the records.
        LENGTH=n
             Code a value from 1 to 8.  This is the length of
             the sequence field.
        TYPE=hex
             Should be specified if the data to be compared is
             hexadecimal representation, such as hex addresses at the
             left side of a formatted dump.  Otherwise the fields
             will be compared using ebcdic collating sequence.
             If any keyword is omitted or misspelled, the
             following defaults are assumed -
                  START     hexadecimal zeros
                  STOP      hexadecimal f's
                  COLUMN    73
                  LENGTH    8
                  TYPE      char
             Leading zeros are not necessary.  The column value and
             the start and stop values will have their high-order
             characters truncated or padded with zeros if they
             are longer or shorter than the specified length.
             Special characters, except commas and blanks,
             may be used in the start and stop values, if TYPE=hex
             is not specified.
:h3.Complex         Search Arguments
             In any search argument which contains more than one
             type of control card, OR= cards can be considered as
             paired with the preceding control card and evaluated
             before the and= cards.  The following set of control
             cards,
                  DATA='a'
                  DATA='b'
                  AND='c'
             Would be evaluated as (a or b) and c.
             To allow an argument such as a or (b and c) another
             control card is used.  A statement consisting of a slash
             causes LOGSCAN to begin a new search argument.  If a
             record is not selected under the first argument, it will
             still be printed if it qualifies under another argument.
             Therefore a slash card can be considered to represent
             an or between two parenthesized expressions in a
             complex search argument.  A or (b and c) would be
             accomplished by
                  DATA='a'
                  /
                  DATA='b'
                  AND='c'
             (a and b) or (c and d) would be represented by
                  DATA='a'
                  AND='b'
                  /
                  DATA='c'
                  AND='d'
             (a or b) and (c or d) would have to be rearranged as
             (a and c) or (a and d) or (b and c) or (b and d)
                  DATA='a'
                  AND='c'
                  /
                  DATA='a'
                  AND='d'
                  /
                  DATA='b'
                  AND='c'
                  /
                  DATA='b'
                  AND='d'
             The save control statement is a variation of the card
             beginning with a slash. It defines the end of an argument
             and also indicates that any record selected using that
             argument is not to be printed until a record is selected
             under another argument ending with a slash.  The saved
             record will be printed before the new record.  The saved
             record will not be printed again, but other records found
             under that search argument will be saved and processed
             in the same way.  Only the last saved record will be
             printed before the record from another argument.
             The SAVE2 statement provides the ability to save another
             type of record without affecting the record saved using
             the SAVE statement.  If records have been saved for
             both arguments, the SAVE2 record will always be printed
             after the SAVE record, regardless of the order of their
             occurence in the original data set.
             The PRINT control statement causes records selected
             under that argument to be printed without affecting
             any record which has been saved.  Note that use of this
             statement may cause records to be printed in a different
             order than the original, because a record may have been
             saved before which will not be printed until a record
             is selected using an argument which ends with a slash
             card.
             The NEXT statement causes a record to be printed only
             if it is the first one after a record selected
             using an argument which ends with a slash card.
             The SKIP statement causes records to be ignored.  This
             can be used to thin out records and reduce the need for
             many NOT= statements in subsequent arguments.
             A SLASH control statement is assumed for the last
             argument in the control data set unless a SAVE or SAVE2
             or PRINT or NEXT or SKIP statement is used.  Records are
             processed according to the first argument which they
             match.  If a record would be selected under more than one
             argument and it is desired that it always be printed,
             save and next arguments should be coded last.
             Since the statements in the following group are mutually
             exclusive in the same argument, only the last one coded
             will be honored if they appear consecutively:
             - SAVE SAVE2 PRINT NEXT SKIP -
:h3.Examples
             The following job step will print all scheduler
             messages for a one hour period from a system log that
             has been copied to a cataloged gdg tape.  Assume that
             on this system all OS/VS messages begin in position 25
             of the system log records.
        //A EXEC PGM=LOGSCAN
        //PRINT DD SYSOUT=A
        //LOG DD DSN=HISTORY.SYSVLOG(-3),DISP=SHR
        //SYSIN DD *
         TIME=2145,2245
         MARGIN=25
         DATA='IEF',ABBR
        /*
             The following will print a condensed version of a
             superzap dump showing only lines containing VOLSTAT
             SVC instructions and the CSECTS in which they are found.
        //A EXEC PGM=AMASPZAP
        //SYSLIB DD DSN=SYS1.LPALIB,DISP=SHR
        //SYSPRINT DD DSN=&&TEMP,UNIT=SYSDA,DISP=(NEW,PASS),
        // SPACE=(TRK,(10,10)),DCB=(RECFM=FBA,LRECL=121,BLKSIZE=1210)
        //SYSIN DD *
         DUMPT IEFW21SD ALL
        //B EXEC PGM=LOGSCAN
        //PRINT DD SYSOUT=A
        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)
        //SYSIN DD *
         DATA='0A5B',WORD
         /
         MARGIN=76
         DATA='CSECT'
         SAVE
        /*
             The following step will print all references to
             a certain register name, except in comment statements,
             from a member of a macro library.  Only a certain range
             of sequence numbers is of interest.
        //A EXEC PGM=LOGSCAN
        //PRINT DD SYSOUT=A
        //LOG DD DSN=SYS1.AMODGEN(IECINT),DISP=SHR
        //SYSIN DD *
         START=48000000,STOP=52000000
         MARGIN=16,66
         DATA='UCBREG',WORD
         MARGIN=1
         NOT='*'
        /*
             The following will print all references to volume DLIB01
             for a 16-day period from an accumulated LOGREC history
             data set.  MDR records will be skipped.
        //EVENT EXEC PGM=IFCEREP1,
        // PARM=('EVENT,HIST,ACC=N,TABSIZE=500K',
        // 'DATE=(78276,78291),LINECT=60')
        //EREPPT   DD DCB=BLKSIZE=6384,DISP=(,PASS),UNIT=SYSDA,
        // DSN=&&TEMP,SPACE=(TRK,(500,250),RLSE)
        //TOURIST  DD SYSOUT=A,DCB=BLKSIZE=1995
        //DIRECTWK DD UNIT=(SYSDA,2),SPACE=(CYL,(50,20))
        //ACCIN    DD DSN=LOGREC.HISTORY(-0),DISP=SHR
        //SCAN EXEC PGM=LOGSCAN
        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)
        //PRINT DD SYSOUT=A
        //SYSIN DD *
         DATA='DLIB01'
         MARGIN=22
         NOT='MDR-DAS'
         /
         MARGIN=1
         DATA='DATE'
         SAVE
             The following will print a list of all members of a load
             library that contain CSECTS assembled by VS1 assembler
             version 1.01.
        //IDRLIST EXEC PGM=AMBLIST,REGION=180K
        //SYSLIB DD DSN=SYS1.TELCMLIB,DISP=SHR
        //SYSPRINT DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSDA,
        // SPACE=(CYL,(5,5)),DCB=BLKSIZE=6413
        //SYSIN DD *
         LISTIDR OUTPUT=ALL
        //SCAN EXEC PGM=LOGSCAN
        //PRINT DD SYSOUT=A
        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)
        //SYSIN DD *
         MARGIN=24
         DATA='5741'
         MARGIN=49
         AND='01.01'
         /
         MARGIN=10
         DATA='------'
         SAVE
         DATA='MEMBER'
         SAVE2
:h3.TSO
             To facilitate the use of LOGSCAN from a terminal,
             specify 'TSO' in the parm field when calling the program.
             This will bypass the listing of control statements as
             they are entered, and will cause prompting messages at
             the start of the run and permit re-entering invalid
             control statements.
             The following CLIST can be added as a member of the
             sysproc data set and used as a command to invoke LOGSCAN.
        PROC 1 DATASETNAME
        ALLOCATE FILE(LOG) DATASET(&DATASETNAME.) SHR
        ALLOCATE FILE(PRINT) DATASET(*)
        ALLOCATE FILE(SYSIN) DATASET(*)
        CALL 'AOST.LOAD(LOGSCAN)' 'TSO'
:h3.Symbolic         Variables
             The use of symbolic variables in a canned routine
             allows frequently used routines to be easily modified.
             The symbolic variables in the procedure are defined as
             one- to eight-character names preceded by an ampersand.
             The first character must be alphabetic, and the following
             characters may be alphanumeric.  If the field following
             the symbol is alphanumeric, the symbol must be terminated
             with a period.  If a period is desired following the
             symbol, two periods must be coded.  Default values for
             the symbols can be established by providing set
             statements in the procedure.  Only the first definition
             of a symbolic value is effective, so the default value
             coded in the procedure will be ignored if a set statement
             is provided by the user.  The SET statement must appear
             before the statement(s) where the value is to be changed.
             The format of the SET statement is:
                  SET ssssssss=vvvvvvvvvvvv
             where ssssssss is the symbolic name without the ampersand
             and vvvvvvvvvvvv is the variable data to replace it.
             The variable data may not contain blanks, although
                  SET ssssssss=
             may be used to nullify the symbol.
             For example, the following statements -
                  SET MARG1=27
                  SET MARG2=,44
                  SET MARG2=
                  MARGIN=&MARG1&MARG2     START AT POSITION &MARG1..
             Would be evaluated as
                  MARGIN=27,44    START AT POSITION 27.
./ ADD NAME=MSGS
+/ ADD NAME=LOG00    0100-90106-90106-1544-00018-00014-00000-$A1019
LOG000 'Command conflict' .ALARM = YES
'When multiple line commands are used they must all be the same'
LOG001 'Command conflict ' .ALARM = YES
'There must be exactly two BB, LL, or RR line commands'
LOG002 '&JOBNAME submitted'
'&MESSAGE'
LOG003 'Print successful'
'LOGSCAN output successfully printed'
LOG004 'Print failed'
'Attempt to print LOGSCAN output failed'
LOG005 'Enter option' .ALARM = YES
'Enter one of the listed options'
LOG006 'No LOGSCAN output'
'No output exists from foreground execution of LOGSCAN'
LOG007 'Recall failed'
'HRECALL failed: rc=&HSMRC, reason=&HSMREAS, dsname=&DSNAME'
LOG008 'Recall wait terminated'
'SYSLOG data set &DSNAME is being recalled asynchronously'
./ ADD NAME=PANELS
+/ ADD NAME=LOGHRECA 0100-90106-90106-1542-00008-00008-00000-$A1019
%------------------------- Recall of SYSLOG Data Set --------------------------%
%                                                                              %
%                                                                              %
+SYSLOG data set &DSNAME is being recalled by DFHSM.
+
+You may press your attention key to terminate waiting. The recall will then
+proceed asynchronously.
)End
+/ ADD NAME=LOGJCL   0100-90064-90078-1754-00041-00030-00000-$A1019
%-------------------------- Submit Batch LOGSCAN Job --------------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+Copies           %===>_Z  +                     (1-255)
+Sysout class     %===>_Z+                       (A-Z,0-9)
+Destination      %===>_LOGDEST +                (Overrides your default)
+Output descriptor%===>_LOGOUT  +                (Duplex, Simplex, or Tumble)
+
+
+JOB Statement Information:
+
+  mask //jobname  JOB 'Name      MailDptGrp*DivAcct              lllfffp   ',
+ %===>_ZLLGJOB1
+  mask //             TIME=nnnn
+ %===>_ZLLGJOB2
+ %===>_ZLLGJOB3
+ %===>_ZLLGJOB4
)Init

 .ZVARS = '(LOGCOPY LOGCLASS)'
 .HELP = LOGTUT4
 &ZCMD = &Z
 If (&LOGCOPY = &Z) &LOGCOPY = 1
 If (&LOGCLASS = &Z) &LOGCLASS = A
 If (&LOGOUT = &Z) &LOGOUT = DUPLEX

)Proc

 Ver (&LOGCOPY,nonblank,num)
 Ver (&LOGCOPY,range,1,255)
 Ver (&LOGCLASS,nonblank,list,
      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9)
 Ver (&LOGDEST,name)
 &LOGOUT = trans(trunc(&LOGOUT,1) D,DUPLEX S,SIMPLEX T,TUMBLE *,*)
 Ver (&LOGOUT,list,DUPLEX,SIMPLEX,TUMBLE)
 Ver (&ZLLGJOB1,nonblank)
 Ver (&ZLLGJOB2,nonblank)
 Vput (LOGCOPY,LOGCLASS,LOGDEST,LOGOUT,
       ZLLGJOB1,ZLLGJOB2,ZLLGJOB3,ZLLGJOB4) profile

)End
+/ ADD NAME=LOGLIST  0100-90053-90106-1409-00027-00025-00000-$A1019
)Attr

 ! Type(input) intens(high) caps(on) pad('_') just(left)
 @ Type(output) intens(low) caps(off) just(asis)
 $ Type(text) intens(high) caps(off) color(turq) hilite(uscore)

)Body
%------------------- SYSLOG Console Message Logs for &CNTR --------------------%
%Command ===>_ZCMD                                            %Scroll ===>_AMNT%
%Actions: B,BB=Browse L,LL=LOGSCAN R,RR=Recall; Press HELP (&HELP) for details %
$Action+$Starting Date   $Time +    $Ending Date     $Time +    $Status  +
)Model
+ !Z +  @Z  @Z    @Z     @Z    +    @Z  @Z    @Z     @Z    +    @STATUS
)Init

 .ZVARS = '(ACTION SDAYNAME SDATE SJDATE STIME EDAYNAME EDATE EJDATE ETIME)'
 .CURSOR = ACTION
 .HELP = LOGTUT0

 &ZCMD = &Z
 &HELP = pfk(help)

)PROC

 If (&ZTDSELS ^= 0000) ver (&ACTION,list,B,BB,L,LL,R,RR)

)End
+/ ADD NAME=LOGPRINT 0100-90071-90074-1907-00040-00048-00000-$A1019
%---------------------------- Print LOGSCAN Output ----------------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+First line number%===>_LOGLINE1+
+Last line number %===>_LOGLINE2+
+Titles/page #    %===>_LOGTITLE                    (YES or NO)
+Page length      %===>_Z   +                       (6-4095)
+Copies           %===>_Z  +                        (1-255)
+Sysout class     %===>_Z+                          (A-Z,0-9)
+Destination      %===>_LOGDEST +                   (Overrides your default)
+Form definition  %===>_LOGFDEF +                   (Simplex, Duplex, or Tumble)
)Init

 .ZVARS = '(LOGPAGE LOGCOPY LOGCLASS)'
 .HELP = LOGTUT4
 &ZCMD = &Z
 If (&LOGTITLE = &Z) &LOGTITLE = NO
 If (&LOGPAGE = &Z) &LOGPAGE = 60
 If (&LOGCOPY = &Z) &LOGCOPY = 1
 If (&LOGCLASS = &Z) &LOGCLASS = A
 If (&LOGFDEF = &Z) &LOGFDEF = DUPLEX

)Proc

 Ver (&LOGLINE1,num)
 Ver (&LOGLINE2,num)
 &LOGTITLE = TRANS(TRUNC(&LOGTITLE,1) Y,YES N,NO *,*)
 Ver (&LOGTITLE,nonblank,list,YES,NO)
 Ver (&LOGPAGE,nonblank,num)
 Ver (&LOGPAGE,range,6,4095)
 Ver (&LOGCOPY,nonblank,num)
 Ver (&LOGCOPY,range,1,255)
 Ver (&LOGCLASS,nonblank,list,
      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9)
 Ver (&LOGDEST,name)
 &LOGFDEF = trans(trunc(&LOGFDEF,1) S,SIMPLEX D,DUPLEX T,TUMBLE *,*)
 Ver (&LOGFDEF,list,DUPLEX,SIMPLE,TUMBLE)
 Vput (LOGTITLE,LOGPAGE,LOGCOPY,LOGCLASS,LOGDEST,LOGFDEF) profile

)End
+/ ADD NAME=LOGSCAN  0100-90059-90081-1545-00048-00037-00000-$A1019
)Attr

 _ Type(input) caps(on)  intens(high)
 [ Type(input) caps(off) intens(high)
 ^ Type(text)  skip(on)  intens(low)

)Body
%--------------- Scan SYSLOG Console Message Log(s) Via LOGSCAN ---------------%
%Option ===>_ZCMD                                             %Scroll ===>_AMNT%
%Options:  1=Foreground  2=Batch  3=Print  4=Browse  5=Clear                   %
+
+Caps (ON or OFF)%===>_Z  ^                                     (Translate data)
+Starting time   %===>_Z   ^        Ending time %===>_Z   ^     (hhmm)
+
)Model
+DATA, OR, AND, NOT, /%===>_TYPE^   WORD, ABBR  %===>_PARM^
+Left margin          %===>_Z  ^    Right margin%===>_Z  ^      (1-126)
+Data%===>[DATA
+
)Init

 .ZVARS = '(CAPS TIME1 TIME2 MARGIN1 MARGIN2)'
 .CURSOR = ZCMD
 .HELP = LOGTUT4
 &ZCMD = &Z

)Proc

 Ver (&ZCMD,num)
 Ver (&ZCMD,range,1,5)
 If  (&ZCMD ^= &Z)
     Ver (&TIME1,pict,nnnn)
     Ver (&TIME2,pict,nnnn)
     &CAPS = trans(trunc(&CAPS,2) ON,ON OF,OFF *,*)
     Ver (&CAPS,nonblank,list,ON,OFF)
 If  (&ZTDSELS ^= 0000)
     &TYPE = trans(trunc(&TYPE,1) D,DATA O,OR A,AND N,NOT '/','/' *,*)
     If (&DATA ^= &Z) ver (&TYPE,nonblank)
     Ver (&TYPE,list,DATA,OR,AND,NOT,'/')
     &PARM = trans(trunc(&PARM,1) W,WORD A,ABBR *,*)
     Ver (&PARM,list,WORD,ABBR)
     Ver (&MARGIN1,num)
     Ver (&MARGIN1,range,1,126)
     Ver (&MARGIN2,num)
     Ver (&MARGIN2,range,1,126)
     If  (&TYPE = DATA,OR,AND,NOT)  ver (&DATA,NONBLANK)

)End
+/ ADD NAME=LOGTUT0  0100-90072-90106-1418-00031-00001-00000-$A1019
%TUTORIAL --------------- SYSLOG Console Message Logs ---------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%                                                                              %
%SYSLOG+is a chronological log of operator console messages.
+31 days of SYSLOG data sets are maintained.
+
+The data sets may be browsed directly, or records with specific contents may be
+selected with the LOGSCAN program.
+
+The following topics are presented in sequence, or may be selected by number:
+
%1+List of available SYSLOG data sets
%2+Format and contents of SYSLOG records
%3+Browsing SYSLOG
%4+Selecting SYSLOG records via LOGSCAN
%5+Recalling migrated SYSLOG data sets
)Init

 &ZUP = LOGTUT0

)Proc

 &ZSEL = TRANS(&ZCMD 1,LOGTUT1
                     2,LOGTUT2
                     3,LOGTUT3
                     4,LOGTUT4
                     5,LOGTUT5
                     ' ',' '
                     *,?)

)End
+/ ADD NAME=LOGTUT1  0100-90073-90074-1418-00029-00029-00000-$A1019
)Attr

 $ Type(text) intens(high) color(pink) hilite(uscore)

)Body
%TUTORIAL --------------- SYSLOG Console Message Logs ---------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%                                                                              %
+The initial SYSLOG panel lists all available SYSLOG data sets. Data sets are
+kept for 31 days, but there will generally be more than 31 data sets. You may
+scroll through this list and select one or more data sets.
+
+SYSLOG is initially a private sysout data set which belongs to the operating
+system. The WRITELOG (W) operator command closes the data set, queues it for
+output, and opens a new one. An external writer then allocates a new online
+data set and copies the sysout data to it.
+
+The WRITELOG command is issued automatically on a periodic basis. It may also
+be issued manually at any time. In addition, a new SYSLOG data set is started
+whenever an IPL occurs.
+
$WARNING!+Occasionally multiple sysout data sets are queued. The external writer
+will combine them all into a single data set, but they may be out of
+chronological order. This can also cause the date/time display to be wrong.
)Init

 &ZUP = LOGTUT0

)End
+/ ADD NAME=LOGTUT2  0100-90074-90074-1945-00031-00030-00000-$A1019
%TUTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%
+Most SYSLOG records are written by JES3 as follows:
+   ccc  nnnnnnnn yyddd hhmmsst ia <prefix> message
+
+Before JES3 is initialized SYSLOG records are written by MVS as follows:
+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message
+   t                                                    message
+   t                                   lid              message
+
+Not all messages are logged:
+  . The CONSOLxx member of SYS1.PARMLIB controls which messages are logged.
+  . Logging may be prevented for individual messages via the MCSFLAG=NOCPY
+    parameter on the WTO macro, and the MLG=NO parameter on the JES3 MESSAGE
+    macro.  These parameters are used primarily for security related messages.
+
+
+The following topics are presented in sequence, or may be selected by number:
+
%1+JES3 SYSLOG format
%2+MVS SYSLOG format
)Init

 &ZUP = LOGTUT0

)Proc

 &ZSEL = TRANS(&ZCMD 1,LOGTUT2A 2,LOGTUT2B ' ',' ' *,?)

)End
+/ ADD NAME=LOGTUT2A 0100-90073-90074-1428-00025-00028-00000-$A1019
)Body default($[_)
$TUTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL$
$Command ===>_ZCMD                                                             $
$                                                                              $
[JES3 SYSLOG records have the following format:
[   ccc  nnnnnnnn yyddd hhmmsst ia <prefix> message
$ccc[      Console destination class
$nnnnnnnn[ Console name
$yyddd[    Julian date
$hhmmsst[  Time stamp: hours, minutes, seconds, tenths of a second
$i[        Warning indicator as follows:
[            $blank[   Normal output
[            $%[       Minimum track space situation
[            $=[       Marginal track space situation
[            $<[       Minimum JSAM buffer situation
$a[        Action prefix character as follows:
[            $blank[ Normal message
[            $+[       JES3 command input
[            $-[       MVS command input
[            $*[       Operator action required
[            $&[       Suppressed message (does not appear on any console)
$prefix[   sysname R= jobname
[            $sysname[ Name of the main processor which issued the message
[            $jobname[ The job name of the issuing program
)End
+/ ADD NAME=LOGTUT2B 0100-90073-90074-1431-00025-00025-00000-$A1019
%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%
+MVS SYSLOG records have the following format:
+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message
+   t                                                    message
+   t                                   lid              message
+
%t+         Record type:
+             %D+ Data line of a multiple-line message
+             %E+ End line  or data-end line of a multiple-line message
+             %L+ Label line of a multiple-line message
+             %M+ First line of a multiple-line message
+             %N+ Single-line message that does not require a reply
+             %O+ Operator LOG command
+             %S+ Continuation of a single-line message
+             %W+ Single-line message that requires a reply
+             %X+ A log entry that is not from a LOG command or system message
+
+                           (Press ENTER to continue)
)Init

 &ZCONT = LOGTUT2C

)End
+/ ADD NAME=LOGTUT2C 0100-90073-90074-1432-00028-00024-00000-$A1019
%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%
+MVS SYSLOG record format continued:
+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message
+   t                                                    message
+   t                                   lid              message
+
%c+            Indicates whether the line was generated because of a command:
+                %C+     Command input
+                %R+     Command response
+                %I+     Command issued internally; job id is name of issuer
+                %blank+ Neither command input nor command response
+
%rrrrrrr+      Hexadecimal representation of the routing codes
+
%sysname+      System name from the IEASYSxx member of SYS1.PARMLIB
+
%yyddd+        Julian date
+
%hh:mm:ss.th+  Time stamp: hours, minutes, seconds, hundredths of a second
+
+                           (Press ENTER to continue)
)Init

 &ZCONT = LOGTUT2D

)End
+/ ADD NAME=LOGTUT2D 0100-90073-90074-1435-00022-00025-00000-$A1019
%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%
%Command ===>_ZCMD                                                             %
%
+MVS SYSLOG record format continued:
+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message
+   t                                                    message
+   t                                   lid              message
+
%ident+    If "c" is blank, then the%job identifier+
+          If "c" is C or R, then one of the following:
+            %nn+       A 2-digit console ID
+            %MASTER+   A message sent to the master console
+            %INTERNAL+ An internally generated command
+            %INSTREAM+ A command read from the input stream
+            %blanks+   The source or destination could not be determined
+
%lid+      Multiple-line ID for the second and succeeding lines of a
+          multiple-line message. In the first line, this field appears after
+          the message text.
+
%msgflags+ &   indicates message was suppressed
)End
+/ ADD NAME=LOGTUT3  0100-90074-90074-1226-00019-00019-00000-$A1019
%------------------------- Browsing SYSLOG Data Sets --------------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+One or more SYSLOG data sets may be browsed by specifying the%B+or%BB+line
+command(s) on the initial SYSLOG panel.
+
+If you specify a single data set, normal ISPF browse is used.
+
+More than one data set may be specified by multiple%B+commands or a pair of%BB+
+commands.  When you specify multiple data sets they are concatenated.  This
+means, for example, that a FIND command can cross data set boundaries.
+Currently performance will be poor if you scroll backwards. The current
+technique requires closing the data sets, reopening them from the beginning,
+and reading forward to the desired record.
)Init

 &ZUP = LOGTUT0

)End
+/ ADD NAME=LOGTUT4  0100-90074-90078-1800-00028-00013-00000-$A1019
%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+One or more data sets may be processed by LOGSCAN by specifying the%L+or%LL+
+line command(s) on the initial SYSLOG panel.
+
+When you specify multiple data sets they are concatenated.
+
%Options:+%1+Execute LOGSCAN in the foreground and browse the output
+         %2+Submit a batch job to execute LOGSCAN
+         %3+Print output previously generated by LOGSCAN (option 1)
+         %4+Browse output previously generated by LOGSCAN (option 1)
+         %5+Clear all LOGSCAN parameters to blank
+
%Caps:+   %ON+translates the data fields (see below) to uppercase.
+         %OFF+allows use of lowercase data fields.
+
%Starting time/Ending time:+Specifies the beginning and ending time period to
+         be selected. The time period may be specified alone, or may be used
+         to limit the records scanned via data fields (see below).
+
+                           (Press ENTER to continue)
)Init

 &ZUP = LOGTUT0
 &ZCONT = LOGTUT4A

)End
+/ ADD NAME=LOGTUT4A 0100-90074-90074-1433-00027-00027-00000-$A1019
%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+DATA, OR, AND, NOT, / ===>         WORD, ABBR   ===>
+Left margin           ===>         Right margin ===>           (1-126)
+Data ===>
+
%DATA:+select records with the specified "data".
%OR:+  select records specified via DATA%or+via another OR%or+with the
+      specified "data". DATA and OR are equivalent.
%AND:+ select records specified via DATA or OR%and+with the specified "data".
%NOT:+ exclude records with the specified "data".
+Note: all DATAs and ORs are evaluated before, and must precede, all ANDs and
+      NOTs.
%/:+   begins a new search argument. Each set of arguments between slashes is
+      applied separately. If a record is not selected under one argument, it
+      may be selected under another argument.
+
%WORD:+requires the record "data" to be surrounded by blanks or punctuation.
%ABBR:+requires the record "data" to be preceded by a blank or punctuation.
+
+                           (Press ENTER to continue)
)Init

 &ZCONT = LOGTUT4B

)End
+/ ADD NAME=LOGTUT4B 0100-90074-90074-1940-00019-00020-00000-$A1019
%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+DATA, OR, AND, NOT, / ===>         WORD, ABBR   ===>
+Left margin           ===>         Right margin ===>           (1-126)
+Data ===>
+
%Left margin:+ is the first character position to be scanned.
%Right margin:+is the last character position to be scanned. If omitted, it is
+              defaulted to the "left margin".
+Note: once specified, margins apply to all subsequent search parameters until
+      respecified.
+
%Data:+specifies the data to be searched for. It should be surrounded by
+matching special characters.  If not, the data will be automatically surrounded
+by single or double quote marks.
+
+You can create as many search parameters as you wish. Simply scroll down.
)End
+/ ADD NAME=LOGTUT5  0100-90106-90106-1436-00020-00020-00000-$A1019
%-------------------- Recalling Migrated SYSLOG Data Sets ---------------------%
%Command ===>_ZCMD                                                             %
%                                                                              %
+SYSLOG data sets which have not been referenced for some time will be
+automatically migrated to tape.
+
+If you refer to one of these data sets via Browse or LOGSCAN it will be
+automatically recalled. However you will have to wait for the recall to
+complete. You may use your attention key to terminate the wait condition (the
+recall will eventually complete).
+
+Alternatively, you may recall one or more migrated SYSLOG data sets
+asynchronously by specifying the%R+or%RR+line command(s) on the initial SYSLOG
+panel. The recall will complete without requiring you to wait. You will receive
+a message when the recall is complete.
)Init

 &ZUP = LOGTUT0

)End
+/ ADD NAME=LOGWAIT  0100-90064-90072-1728-00013-00010-00000-$A1019
%------------------------ LOGSCAN Foreground Execution ------------------------%
%                                                                              %
%                                                                              %
+The LOGSCAN program is now scanning the selected SYSLOG console message log(s).
+
+
+You can reduce the CPU time required by specifying:
+    starting and ending time;
+    left and right margin.
+
+
+LOGSCAN always reads all records, even if time limits are specified.
)End
./ ADD NAME=PROCLIB  0100-90123-90123-1253-000006-000006-000000-$A1238
//LOGWTR  PROC NODE=WCC1
//IEFPROC EXEC PGM=IASXWR00,PARM=PX,PERFORM=45
//IEFRDER  DD  DSNAME=ASYSLOG.&NODE..D&D..T&T,
//             DISP=(NEW,CATLG,CATLG),
//             DCB=(BLKSIZE=23476,LRECL=136,RECFM=VB),
//             LABEL=RETPD=31,UNIT=SYSCC,SPACE=(CYL,(15,15),RLSE)
./ ADD NAME=SKELS
+/ ADD NAME=LOG      0101-90106-90123-1323-00020-00014-00000-$A1238
*  &ZUSER  &ZTIME  &ZMONTH/&ZDAY/&ZJDATE
)SET RANGE = 0
)DOT SYSLOG
)SEL &ACTION = L ] &ACTION = LL ] &RANGE = 1
)SEL &ACTION = LL
)SET RANGE = &RANGE + 1
)ENDSEL
*  DSNAME: &DSNAME
)ENDSEL
)ENDDOT
<TIME=&TIME1,&TIME2]>
)DOT LOGSCAN
)SEL &TYPE = DATA ] &TYPE = OR ] &TYPE = AND ] &TYPE = NOT
<MARGIN=&MARGIN1]><,&MARGIN2]>
&TYPE=&DATA<,&PARM]>
)ENDSEL
)SEL &TYPE = /
/
)ENDSEL
)ENDDOT
+/ ADD NAME=LOGJCL   0101-90061-90123-1323-00031-00016-00000-$A1238
)TB 13
&ZLLGJOB1
&ZLLGJOB2
&ZLLGJOB3
&ZLLGJOB4
)SEL &LOGOUT = SIMPLEX
//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010110
)ENDSEL
)SEL &LOGOUT = DUPLEX
//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010111
)ENDSEL
)SEL &LOGOUT = TUMBLE
//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010112
)ENDSEL
//LOGSCAN  EXEC PGM=LOGSCAN
//STEPLIB   DD  DSNAME=SYS1.MVSSERV,DISP=SHARE
//PRINT     DD  SYSOUT=&LOGCLASS<,DEST=&LOGDEST]><,COPIES=&LOGCOPY]>
)SET DDNAME = LOG
)SET RANGE = 0
)DOT SYSLOG
)SEL &ACTION = L ] &ACTION = LL ] &RANGE = 1
)SEL &ACTION = LL
)SET RANGE = &RANGE + 1
)ENDSEL
//&DDNAME  !DD  DSNAME=&DSNAME,DISP=SHARE
)SET DDNAME = &Z
)ENDSEL
)ENDDOT
//SYSIN     DD  *
)IM LOG
/*
./ ADD NAME=SOURCE
+/ ADD NAME=BRSYSLOG 0100-90055-90058-1649-00160-00109-00000-$A1019
BRSYSLOG TITLE 'BROWSE CONCATENATED SYSLOG DATA SETS'
***********************************************************************
*        INVOKE ISPF BRIF TO BROWSE CONCATENATED SYSLOG DATA SETS
***********************************************************************
BRSYSLOG CSECT
BRSYSLOG AMODE 31
BRSYSLOG RMODE 24
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*              WORKING STORAGE
***********************************************************************
WORKAREA DSECT
SAVE     DS    18F                 SAVE AREA
SAVE2    DS    18F                 SAVE AREA FOR READ ROUTINE
LASTREC# DS    F                   NUMBER OF LAST RECORD REQUESTED
LASTREC  DS    0CL136              LAST RECORD REQUESTED
LASTRECL DS    2HL2
LASTRECD DS    CL132
SYSLOG   DCB   DDNAME=SYSLOG,                                          *
               DSORG=PS,                                               *
               EODAD=0,                                                *
               MACRF=GM
DMLIST   OPEN  (,),MF=L,MODE=31
BRIFPARM CALL  ,(,,,,,,),MF=L      BRIF PARAMETERS
DATA     DS    A                   DIALOG DATA AREA
WORKSIZE EQU   *-WORKAREA          SIZE OF WORK AREA
         EJECT
***********************************************************************
*              INITIALIZATION
***********************************************************************
BRSYSLOG CSECT
         SAVE  (14,12)             SAVE REGISTERS
         USING *,R15
         MODID
         DROP  R15
         LR    R12,R15             SET BASE REGISTER
         USING BRSYSLOG,R12
         GETMAIN RU,LV=WORKSIZE,LOC=(BELOW,ANY)  GET WORKING STORAGE
         ST    R1,8(R13)           CHAIN SAVE AREAS
         ST    R13,4(R1)
         LR    R13,R1
         USING WORKAREA,R13
         XC    LASTREC#,LASTREC#   LAST RECORD NUMBER = 0
         XC    DMLIST,DMLIST
         OI    DMLIST,X'80'        SET END OF LIST
         MVC   SYSLOG(DCBSIZE),DUMMY  COPY DCB TO WORKING STORAGE
***********************************************************************
*              MAINLINE CODE
***********************************************************************
         LA    R10,SYSLOG
         OPEN  ((R10),(INPUT,REREAD)),MODE=31,MF=(E,DMLIST)
         LTR   R15,R15             IS RETURN CODE NORMAL?
         BNZ   RETURN              NO, ERROR
         LA    R2,SAVE2            PARM FOR READ ROUTINE
         ST    R2,DATA
         LA    R2,DATA
         LINK  EP=ISPLINK,                                             *
               PARAM=(BRIF,@,RECFM,LRECL,ROUTINE,@,(R2)),VL=1,         *
               MF=(E,BRIFPARM)
         LR    R2,R15              SAVE BRIF RETURN CODE
         CLOSE MODE=31,MF=(E,DMLIST)
         LR    R15,R2              RESTORE BRIF RETURN CODE
***********************************************************************
*              TERMINATION
***********************************************************************
RETURN   EQU   *
         LR    R1,R13              UNCHAIN SAVE AREAS
         L     R13,4(R1)
         LR    R2,R15              SAVE RETURN CODE
         FREEMAIN RU,LV=WORKSIZE,A=(1)  FREE WORKING STORAGE
         LR    R15,R2              RESTORE RETURN CODE
         RETURN (14,12),RC=(15)    RETURN
         DROP  R12
         DROP  R13
         EJECT
***********************************************************************
*              BRIF READ ROUTINE
***********************************************************************
READ_ROUTINE EQU *
         SAVE  (14,12)             SAVE REGISTERS
         LR    R12,R15             SET BASE
         USING READ_ROUTINE,R12
         LM    R2,R5,0(R1)         LOAD PARAMETERS
*                                  R2 -> RECORD DATA READ
*                                  R3 -> LENGTH OF RECORD READ
*                                  R4 -> RECORD NUMBER
*                                  R5 -> BRIF DIALOG DATA PARM (DATA)
         L     R5,0(,R5)           R5 -> SAVE2
         ST    R13,4(R5)           CHAIN SAVE AREAS
         ST    R5,8(R13)
         LR    R13,R5
         USING SAVE2,R13
         CLC   LASTREC#,0(R4)      IS LAST RECORD NUMBER < NEW?
         BL    CONTINUE            YES, BRANCH
         CLOSE MODE=31,MF=(E,DMLIST)
         OPEN  MODE=31,MF=(E,DMLIST)
         XC    LASTREC#,LASTREC#   SET LAST RECORD NUMBER TO ZERO
CONTINUE EQU   *
         LA    R15,GET             POINT TO AMODE 24 CODE
         BASSM R11,R15             AND BRANCH TO IT
         LA    R0,LASTRECD         STORE ADDRESS OF RECORD
         ST    R0,0(,R2)
         LH    R0,LASTRECL         STORE LENGTH OF RECORD
         S     R0,=F'4'
         ST    R0,0(,R3)
         L     R13,4(R13)          UNCHAIN SAVE AREAS
         RETURN (14,12),RC=(15)    RETURN
         EJECT
***********************************************************************
*              BRIF READ ROUTINE AMODE 24 CODE
***********************************************************************
GET      EQU   *
         L     R6,LASTREC#         GET NUMBER OF LAST RECORD
         GET   SYSLOG,LASTREC      GET A RECORD
         A     R6,=F'1'            INCREMENT RECORD NUMBER
         ST    R6,LASTREC#
         C     R6,0(,R4)           IS THIS THE RECORD REQUESTED?
         BL    GET                 NO, BRANCH
         SR    R15,R15             RETURN CODE = 0 (NORMAL)
         BSM   0,R11               RETURN TO AMODE 31 CODE
EODAD    EQU   *
         ST    R6,0(,R4)           STORE NUMBER OF RECORD
         CLOSE MODE=31,MF=(E,DMLIST)  CLOSE SYSLOG
         OPEN  MODE=31,MF=(E,DMLIST)  OPEN SYSLOG
         XC    LASTREC#,LASTREC#   SET LAST RECORD NUMBER TO ZERO
         LA    R15,8               RETURN CODE = 8 (END OF FILE)
         BSM   0,R11               RETURN TO AMODE 31 CODE
         DROP  R12
         DROP  R13
         EJECT
***********************************************************************
*              CONSTANTS
***********************************************************************
DUMMY    DCB   DDNAME=SYSLOG,                                          *
               DSORG=PS,                                               *
               EODAD=EODAD,                                            *
               MACRF=GM
DCBSIZE  EQU   *-DUMMY             SIZE OF DCB
@        DC    CL8' '              BLANK
BRIF     DC    CL8'BRIF'           NAME OF BRIF ISPF SERVICE
LRECL    DC    F'136'              LOGICAL RECORD LENGTH
RECFM    DC    CL8'V'              RECORD FORMAT
ROUTINE  DC    A(READ_ROUTINE)     BRIF READ ROUTINE
         END   BRSYSLOG
