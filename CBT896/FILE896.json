{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013326000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2645370, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE896.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE896.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00*\\x04'", "DS1TRBAL": "b'\\x9f\\x1c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\x82\\x00\\x06\\x08\\x85\\x00\\x03\\x00+'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00\\x13\\x01\\x13#/\\x01\\x13#/\\x15P\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-08-20T00:00:00", "modifydate": "2013-08-20T15:50:13", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-487"}, "text": "REGULAR CBT TAPE - VERSION 487    FILE:  896\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE896\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 26 MEMBERS COUNTED; CUMULATIVE SIZE IS 24,772 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/20/13    15:50:13    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE896": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00\\x02\\x01\\x13#/\\x01\\x13#/\\x15P\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-08-20T00:00:00", "modifydate": "2013-08-20T15:50:02", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT-487"}, "text": "//***FILE 896 is from SHARE in 1993 and contains an assortment of   *   FILE 896\n//*           miscellaneous TSO tools of various flavors.  I found  *   FILE 896\n//*           them on an old archive and prepared them for the      *   FILE 896\n//*           CBT collection, because many of them seemed very      *   FILE 896\n//*           useful and interesting, even today.  It seems like    *   FILE 896\n//*           we still need the same stuff.  So here it is.         *   FILE 896\n//*                                                                 *   FILE 896\n//*           Some of this stuff may be elsewhere (in some version) *   FILE 896\n//*           on the CBT Tape, but some of this may not be there,   *   FILE 896\n//*           anywhere.                                             *   FILE 896\n//*                                                                 *   FILE 896\n//*       email:  sbgolob@cbttape.org   or  sbgolob@attglobal.net   *   FILE 896\n//*                                                                 *   FILE 896\n//*       Members in this PDS:                                      *   FILE 896\n//*                                                                 *   FILE 896\n//*        CALCR      01.00    1993/03/09 12:00    749  REXX        *   FILE 896\n//*        COMPRESS   01.00    1990/11/08 12:00    252  REXX        *   FILE 896\n//*        CURSRPWR   01.00    1992/08/11 12:00     76  CLIST       *   FILE 896\n//*        DDN        01.00    1990/11/08 12:00   2080  PDS         *   FILE 896\n//*        DFHSM      01.00    1991/08/08 12:00    583  PDS         *   FILE 896\n//*        DISPHOST   01.00    1991/08/20 12:00     53  REXX        *   FILE 896\n//*        GETSMFID   01.00    1992/08/06 12:00      6  REXX        *   FILE 896\n//*        GOPHER     01.00    1993/03/16 12:00  10951  ASM         *   FILE 896\n//*        IPCS       01.00    1992/03/04 12:00    237  REXX        *   FILE 896\n//*        LOGSCAN    01.00    1990/05/05 12:00     97  LOADMOD     *   FILE 896\n//*        PRINTDS    01.00    1992/08/11 12:00    128  CLIST       *   FILE 896\n//*        RXTRY      01.00    1991/08/09 12:00    103  REXX        *   FILE 896\n//*        SCHTP21    01.00    1992/08/11 12:00     39  MESSAGE     *   FILE 896\n//*        SCHTP210   01.00    1992/08/11 12:00     36  PANEL       *   FILE 896\n//*        SCH0P000   01.00    1992/08/11 12:00     68  PANEL       *   FILE 896\n//*        SCH0P200   01.00    1992/08/11 12:00    163  PANEL       *   FILE 896\n//*        SCRHELP    01.00    1989/02/23 12:00    569  HELP        *   FILE 896\n//*        SHOW       01.00    1992/12/08 12:00   3295  ASM         *   FILE 896\n//*        SYSLOG     01.00    1992/08/10 12:00   1977  REXXES      *   FILE 896\n//*        XMITVM     01.00    1992/08/27 12:00    194  REXX        *   FILE 896\n//*        XPROC      01.00    1992/06/02 12:00   2572  ASM         *   FILE 896\n//*        XPROC#     01.00    1992/06/02 12:00    254  HELP        *   FILE 896\n//*        XWRITEN#   01.00    1993/03/16 12:00     51  HELP        *   FILE 896\n//*        XWRITENR   01.00    1993/03/16 12:00    187  ASM         *   FILE 896\n//*                                                                 *   FILE 896\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CALCR": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x8f\\x00\\x93\\x06\\x8f\\x12\\x00\\x02\\xed\\x02\\xed\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-09T00:00:00", "modifydate": "1993-03-09T12:00:00", "lines": 749, "newlines": 749, "modlines": 0, "user": "REXX"}, "text": "/*  REXX calculator and storage dumper.  Read the disclaimer at end.*/\n /*  Make sure this does not become line numbered (if RECFM=F) or else\n     the HELP information will be overlayed.    Version 1.19         */\n   NUMERIC DIGITS 30\n   arg !!temp1\n   call INITIALIZE\n   interpret \"trace\" result\n   signal on error\n   if address() = 'TSO' | address() = 'MVS' then signal on failure\n   signal on syntax\nREADY:\n   SAY 'Ready for commands.  Use \"EXIT\" to exit. Use \"HELP\" for help.'\n   DO UNTIL !!curr1 = 'EXIT'\n     pull !!curr1\n     if !!back then do\n       say\n       say  !!curr1\n       say\n     end\n     PARSE VAR !!curr1 !!do !!rest\n     SELECT\n       WHEN !!do = 'LET' THEN\n         call WHENLET\n       WHEN !!do = 'SAY' | !!do = 'DO' THEN\n         INTERPRET !!curr1\n       WHEN !!do = 'REXX' then\n         INTERPRET !!rest\n       WHEN !!curr1 = 'EXIT' THEN\n         iterate\n       WHEN !!curr1 = 'END' THEN\n         !!curr1= 'EXIT'\n       WHEN !!curr1 = '' THEN\n         if !!back then !!curr1 = 'EXIT'\n       WHEN !!do = 'DELETE' then\n         call WHENDELETE\n       WHEN !!curr1 = 'SORT' then\n         call WHENSORT\n       WHEN !!curr1 = 'VARTABLE' then\n         call WHENVARTABLE\n       WHEN !!do = 'DUMP' then\n         call WHENDUMP\n       WHEN !!do = 'TIMESTAMP' then\n         call WHENTIME\n       WHEN !!do = 'HELP' THEN\n         CALL WHENHELP\n       WHEN !!do = 'VERBOSE' THEN\n         CALL WHENVERBOSE\n       WHEN !!curr1 = \"NEG\" THEN\n         do\n           !!neg = !!true\n          say \"Hex display of negative values will be in 2's complement\"\n         end\n       WHEN !!curr1 = \"POS\" THEN\n         do\n           !!neg = \\!!true\n           say \"Hex display will be absolute value of decimal number\"\n         end\n       WHEN !!curr1 = \"TRACE\" THEN\n         TRACE ?i\n       WHEN !!do = 'TRACE' THEN\n         INTERPRET !!curr1\n       OTHERWISE\n         call WHENOTHERWISE\n     END   /* of SELECT */\n   END /* of main loop */\n   EXIT 0\nWHENOTHERWISE:\n   interpret \"!!!CURR = \" !!curr1\n   if datatype(!!!curr,'N') then\n     do\n       curr = !!!curr/1\n       !!!curr=HEXFMT(curr)\n     end\n   if length(!!!curr) > 78 then !!dunder = \">\"\n   else !!dunder = \"\"\n   !!!curr = left(!!!curr,78) || !!dunder\n   if !!!curr \\= ' ' then say !!!curr\n   return 0\nHEXFMT:\n   procedure expose !!max !!min !!minfrac !!hexmax !!neg !!verbose\n   curr = arg(1)\n   if abs(curr) <= !!hexmax then\n     do\n       temp = trunc(curr)\n       temp = abs(temp)\n       if !!neg & curr<0 then temp = d2x(!!hexmax + 1 - temp)\n       else temp = D2X(temp)\n       tempx = RIGHT(temp,16,'0')\n       tempx = insert(' ',tempx,8)\n     end\n   else\n     tempx = copies(' ',17)\n   return TEMPX comma(CURR)\nCOMMA: /* put commas into number and format it correctly */\n   procedure expose !!max !!min  !!minfrac !!verbose\n   curr = arg(1)\n   select\n     when abs(curr) < !!minfrac & curr \\= 0 then\n       return format(curr,,,,16)\n     when curr > !!max then\n       return ' ' || format(curr,,29,,20)\n     when curr < -1*!!max/10 then  /* neg numbers have xtra char */\n       return format(curr,,29,,19)\n     when abs(curr) < !!min then\n       return format(curr,,29,,20)\n     otherwise\n       nop\n   end /* of select */\n   int = trunc(curr)\n   fraction = curr - int\n   if int = '' then int = 0\n   int = format(int,20)\n   /*  17 = 20-3  */\n   do i = 17 to 1 by -3 while datatype(substr(int,i,1),'N')\n     int = insert(',',int,i)\n   end\n   int = right(int,26) /* 26 = 20 + int(20-1/3) */\n   select\n     when fraction = '' then nop\n     when fraction = 0 then fraction = ''\n     otherwise nop\n   end   /* of select */\n   if length(fraction) > 0 then do\n     parse var fraction . '.' fraction\n     fraction = '.'fraction\n   end /* of IF */\n   if int = 0 then\n     if curr < 0 then int = right('-0',26)\n   ret = int || fraction\n   return ret\nH:\nX:\n   PROCEDURE EXPOSE !!verbose\n   ARG TEMP\n   RETURN X2D(TEMP)\nS:            /* signed hex number */\n   PROCEDURE EXPOSE !!verbose\n   arg temp\n   neg = verify(left(temp,1),'89ABCDEFabcdef')\n   if neg = 0 then do\n     len = length(temp)\n     two = 1 || copies('0',len) /* 2**n greater than temp */\n     two = x2d(two)\n     return -1*(two-x2d(temp))\n   end\n   else return x2d(temp)\nB:  /* binary numbers */\n   procedure expose !!verbose\n   arg temp\n   temp = strip(temp)\n   temp = strip(temp,'L','0')\n   if verify(temp,'01 ') > 0 then do\n     say 'Binary numbers are made up of zeros and ones'\n     return 0\n   end\n   power = 1\n   value = 0\n   do i = length(temp) to 1 by -1\n     temp2 = substr(temp,i,1)\n     if temp2 = 1 then\n       value = value + power\n     if temp2 \\= ' ' then\n       power = power * 2\n   end\n   return value\nWHENLET:\n   INTERPRET !!rest\n   parse var !!rest !!variable '=' !!rest\n   if !!rest \\= '' then do /* if '=' in command */\n     !!variable = strip(!!variable)\n     if symbol(!!variable) = 'VAR' then do\n       if datatype(value(!!variable),'N') then do\n         curr = value(!!variable)\n         curr = curr / 1\n         result = hexfmt(curr)\n         if length(result) > 78 then !!dunder = \">\"\n         else !!dunder = \"\"\n         say left(result,78) || !!dunder\n       end /* of if datatype ... */\n       !!temp = !!vartble.!!variable\n       if !!temp = 0 then do\n         !!varnum = !!varnum + 1\n         !!vartble.!!varnum = !!variable\n         !!vartble.!!variable = !!varnum\n       end /* of if !!temp ... */\n     end /* of if symbol ... */\n   end /* of if !!rest ... */\n   return 0\nWHENVARTABLE:\n   do !!x = 1 to !!varnum\n     if !!vartble.!!x = !!deleted then iterate\n     !!curr = value(!!vartble.!!x)\n     if datatype(!!curr,'N') then do\n       result=left(hexfmt(!!curr),54)\n       say result !!vartble.!!x\n     end\n     else do\n       say left(!!curr,54) !!vartble.!!x\n     end\n   end\n   return 0\nWHENDUMP:\n   parse var !!rest !!address !!len\n   interpret '!!address =' !!address\n   !!address = value(!!address)\n   if length(!!len) > 0 then do\n     interpret '!!len = ' !!len\n     !!len = value(!!len)\n   end\n   call dump !!address !!len\n   return 0\nWHENSORT:\n   do !!i = 1 to !!varnum-1\n     do !!j = !!i+1 to !!varnum\n       if !!vartble.!!i > !!vartble.!!j then do\n         !!x = !!vartble.!!i\n         !!vartble.!!i = !!vartble.!!j\n         !!vartble.!!j = !!x\n       end /* of IF */\n     end /* of do !!j */\n     !!y = !!vartble.!!i\n     !!vartble.!!y = !!i\n   end /* of !!i */\n   do !!i = !!varnum to 1 by -1 while !!vartble.!!i = !!deleted\n   end\n   !!varnum = !!i\n   !!y = !!vartble.!!i\n   !!vartble.!!y = !!i\n   return 0\nWHENDELETE:\n   !!var1 = strip(!!rest)\n   DO WHILE !!var1 \\= ''\n     parse var !!var1 !!variable !!var1\n     !!temp = !!vartble.!!variable\n     if !!temp = 0 then do\n       say 'Variable \"'!!variable'\" is not in the table'\n     end\n     else do\n       !!vartble.!!temp = !!deleted\n       !!vartble.!!variable = 0\n       interpret 'drop' !!variable\n     end\n   end /* of DO WHILE */\n   return 0\nWHENTIME:\n   parse var !!rest !!stamp !!gmt !!dec\n   interpret '!!stamp =' !!stamp\n   if !!gmt = '' then !!gmt = 'GMT'\n   if !!dec = '' then !!dec = 'DECIMAL'\n   call 'IEBTIM' !!stamp ' ' !!gmt ' ' !!dec\n   return\nFRAC:\n   PROCEDURE EXPOSE !!verbose\n   ARG curr\n   temp = curr-trunc(curr)\n   temp = temp / 1\n   return temp\ndump2:   /*  display dump format of up to 16 bytes of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 16\n   address = d2x(address)\n   temp = storage(address,len)\n   temp2 = left(c2x(temp),32)\n   temp2 = insert(' ',temp2,24)\n   temp2 = insert('  ',temp2,16)\n   temp2 = insert(' ',temp2,8)\n   temp = \"|\" left(temp,16) \"|\" temp2 \"|\"\n   TEMP = RIGHT(address,8,'0') \"   \" temp\n   return temp\nBIN16:  /*  return printable form of a number converted to binary */\nBIT16:  /*  return printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose !!hexmax !!neg\n   i=arg(1)\n   j = bin(i,16)\n   return j\nBIN:   /*  say printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose !!hexmax !!neg\n   a = trunc(arg(1))\n   if !!neg & a<0 then a = d2x(!!hexmax + 1 + a)\n   else a = D2X(abs(a))\n   b = arg(2)\n   if b = '' then b = 0\n   b = min(b,16)\n   if b > length(a) then a = right(a,b,0)\n   if length(a) > 16 then\n     do\n       say 'truncated to rightmost 16 hex digits'\n       a = right(a,16,0)\n     end\n   if length(a)//2 \\=0 then a = '0' || a\n   b = ' '\n   do i = 0 to length(a)/2\n     do j = 1 to 2\n       b = b || '  ' || substr(a,2*i+j,1) || ' '\n     end /* do j */\n     b = b || ' '\n     if i = 3 then b = b || '   '\n   end\n   say left(b,79)\n   x=!!bit(a)\n   if datatype(x,'N') then\n     do\n       say x\n       return ' '\n     end\n   else\n     return !!bit(a)\n!!BIT:  /*  return printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose\n   a = arg(1)\n   lena = min(length(a),16)\n   if lena//2 \\= 0 then do\n     lena = lena + 1\n     a = '0' || a\n   end\n   bin! = ''\n   do i = 1 to 9 by 8\n     do j = i to i+6 by 2 while j < lena\n       digit = substr(a,j,2)\n       do k = 7 to 0 by -1\n         if and1(2**k,x2d(digit)) = 0 then bin! = bin! || 0\n         else bin! = bin! || 1\n       end /* of do k */\n       bin! = bin! || ' '\n     end  /* of do j */\n     bin! = bin! || '   '\n   end  /* of do i */\n   return bin!\nOR:     /*  return 2 values logically ORed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitor(i,j,'0'x)\n   return c2d(k)\nXOR:    /*  return 2 values logically XORed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitxor(i,j,'0'x)\n   return c2d(k)\nAND:    /*  return 2 values logically ANDed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitand(i,j,'0'x)\n   return c2d(k)\nNOT:    /*  return one's complement of a number */\n   PROCEDURE EXPOSE !!verbose\n   i = arg(1)\n   j = x2d(copies('F',16))\n   k = xor(i,j)\n   return k\nAND1:    /*  return 2 1-digit values logically ANDed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),1)\n   j = right(d2c(arg(2)),1)\n   k = bitand(i,j,'0'x)\n   return c2d(k)\ndump:   /*  display dump format of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 16\n   lastgroup = address + len - 16\n   do i= address by 16 while i <= lastgroup\n     say dump2(i)\n   end\n   len = len//16\n   if len > 0 then say dump2(i len)\n   return 0\nstg:   /*  return dec value of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 4\n   address = d2x(address)\n   temp = storage(address,len)\n   temp = c2d(temp)\n   return temp\nC:  /* Combination function */\n   PROCEDURE expose !!!. !!verbose\n   first = arg(1)\n   second = arg(2)\n   if \\datatype(first,'W') | \\datatype(second,'W') then\n     return 'Combination function requires whole numbers'\n   if first < second then\n     return 'First argument must be no less than the second'\n   return format(!(first)/( !(second) * !(first-second) ),,0)\n!:  /* Factorial */\n   PROCEDURE expose !!!. !!verbose\n   NUMBER = ARG(1)\n   select\n     when datatype(!!!.number,'N') then\n       nop\n     when \\datatype(number,'W') | number < 0 then\n       !!!.number = ,\n           'Factorial function requires non-negative whole numbers.'\n     otherwise\n       nop\n   end /* of select */\n   if !!!.number \\= '!!!.'number then return !!!.number\n   if number > 40 then\n     do\n       nminus40 = number - 40\n       !!!.nminus40 = !(nminus40)\n     end\n   nminus1 = number - 1\n   !!!.number = number * !(nminus1)\n   return !!!.number\n   /*  The structure of \"!\" is this so that the restriction of 250\n       levels of nesting will allow maximum factorial computation. */\nCLOCK:\nFROMHMS:\n   PROCEDURE EXPOSE !!verbose\n   tod = ARG(1)\n   parse var tod hh '.' mm '.' ss\n   if ss = '' then do\n     ss = mm\n     mm = hh\n     hh = 0\n   end\n   if ss = '' then do\n     ss = mm\n     mm = 0\n   end\n   if ss > 59 | mm > 59 then\n     say 'value greater than 59 in minutes or seconds - possible error'\n   return ss + (60* (mm + 60*hh))\nUNCLOCK:\nTOHMS:\n   PROCEDURE EXPOSE !!verbose\n   tod = ARG(1)\n   hh = tod % (60*60)\n   tod = tod - hh*60*60\n   mm = tod % 60\n   ss = tod - mm*60\n   if hh < 10 then hcolon = \"0\"\n   else hcolon = \"\"\n   if mm < 10 then mcolon = \".0\"\n   else mcolon = \".\"\n   if ss < 10 then scolon = \".0\"\n   else scolon = \".\"\n   return  hcolon || hh || mcolon || mm || scolon || ss\nWHENVERBOSE:\n   PROCEDURE EXPOSE !!rest !!verbose !!false !!true\n   push !!rest\n   pull rest  /* now in upper case */\n   if abbrev('OFF',rest,1) then\n     do\n       !!verbose = !!false\n       say 'VERBOSE error messages are off.'\n     end\n   else\n     do\n       !!verbose = !!true\n       say 'VERBOSE error messages are on.'\n     end\n   return\nWHENHELP:\n   PROCEDURE EXPOSE CURR !!rest !!verbose\n   push !!rest\n   pull rest  /* now in upper case */\n   select\n     when abbrev('FUNCTIONS',rest,1) then\n       call helpfunc\n     when abbrev('TIME',rest,1) | abbrev('CLOCK',rest,1) then\n       call helptime\n     when abbrev('DUMP',rest,1) | abbrev(\"STORAGE\",rest,1) ,\n          | rest=\"STG\" then\n       call helpdump\n     when abbrev('REXX',rest,1) | abbrev('LOOP',rest,1) | rest='DO' then\n       call helprexx\n     when abbrev('TABLE',rest,1) then\n       call helptable\n     when abbrev('NUMBERS',rest,1) then\n       call helpnumber\n     otherwise\n       call helpgenl\n   end /* of select */\n   return\nHELPGENL:\nsay '    This is a decimal and hexadecimal calculator.  You can type in a      '\nsay 'number or an expression, and the result will be displayed in both decimal '\nsay 'and hex.  Positive hex numbers are typed as either \"H(nnnnn)\" or          '\nsay '\"X(nnnnn)\".  Signed hex numbers are typed as \"S(nnnnn)\".  The value       '\nsay 'displayed is always in the variable \"CURR\".  All values are kept in       '\nsay 'decimal for internal use.  The hex value displayed for each is re-computed'\nsay 'each time from the integer part of the actual value (note: integer part,  '\nsay 'not rounded).                                                             '\nsay '    Values can be displayed in binary by either of BIN(var-name) or       '\nsay 'BIN16(var-name).  BIN is a variable length display, and BIN16 is fixed    '\nsay 'length.                                                                   '\nsay '    You can set variables by using the keyword \"LET\" as in:  \"LET A = CURR'\nsay '+ 5\" which would set \"A\" to 5 more than the currently displayed value.  If'\nsay 'executed now, A would be set to' curr+5 || '.'\nsay '    You can turn on extra information in case of error with the VERBOSE   '\nsay 'command and turn it back off with \"VERBOSE OFF\".                          '\nsay '    For further help enter HELP with an operand of:                       '\nsay 'FUNCTIONS, CLOCK, DUMP, NUMBERS, TABLE, or REXX.                          '\nsay '                                                                          '\nsay '    You exit this facility by typing \"END\" or \"EXIT\".                     '\n    return\nHELPFUNC:\nsay 'Here is how to get help for commands and functions you can use:           '\nsay '                                                                          '\n  temp = left('Function   Help operand ',25)\n  say temp || '  ' || temp || '  ' || temp\n  say ' '\n  queue '!           NUMBERS '\n  queue 'AND         NUMBERS '\n  queue 'B           NUMBERS '\n  queue 'BIN         NUMBERS '\n  queue 'BIN16       NUMBERS '\n  queue 'C           NUMBERS '\n  queue 'DELETE      TABLE '\n  queue 'DO          REXX '\n  queue 'DUMP        DUMP '\n  queue 'END         (none) '\n  queue 'EXIT        (none) '\n  queue 'FACTORIAL   NUMBERS '\n  queue 'FRAC        NUMBERS '\n  queue 'FROMHMS     CLOCK '\n  queue 'H           NUMBERS '\n  queue 'LET         (none) '\n  queue 'NEG         NUMBERS '\n  queue 'NOT         NUMBERS '\n  queue 'OR          NUMBERS '\n  queue 'POS         NUMBERS '\n  queue 'REXX        REXX '\n  queue 'S           NUMBERS '\n  queue 'SAY         REXX '\n  queue 'SORT        TABLE '\n  queue 'STG         DUMP '\n  queue 'TIMESTAMP   CLOCK '\n  queue 'TOHMS       CLOCK '\n  queue 'TRACE       REXX '\n  queue 'TRUNC       NUMBERS '\n  queue 'VARTABLE    TABLE '\n  queue 'VERBOSE     (none) '\n  queue 'X           NUMBERS '\n  queue 'XOR         NUMBERS '\n  queue ' '  /* this space before the null is important */\n  queue ''\n  do i = 1\n    parse pull msg.i\n    if msg.i == '' then leave i\n    msg.i = left(msg.i,25)\n  end\n  max=i - i//3   /* max is greatest multiple of 3 <= i */\n  long = max/3\n  do i = 1 to long\n    j = i + long\n    k = j + long\n    say msg.i || '  ' || msg.j || '  ' || msg.k\n  end\nsay '                                                                          '\nsay '    You exit this facility by typing \"END\" or \"EXIT\".                     '\n    return\nHELPTABLE:\nsay '    You can list all variables you have set with the VARTABLE command,    '\nsay ' sort the variable names alphabetically with the SORT command, and delete '\nsay ' variables with \"DELETE var-names\".                                       '\n    return\nHELPNUMBER:\nsay '    This is a decimal and hexadecimal calculator.  You can type in a      '\nsay 'number or an expression, and the result will be displayed in both decimal '\nsay 'and hex.  Positive hex numbers are typed as \"H(nnnnn)\".  Signed hex       '\nsay 'numbers are typed as \"S(nnnnn)\".  Binary numbers are typed as \"B(nnnnn)\"; '\nsay 'nnnnn is made up of zeros and ones, and blanks are ignored.  The value    '\nsay 'displayed is always in the variable \"CURR\".  All values are kept in       '\nsay 'decimal for internal use.  The hex value displayed for each is re-computed'\nsay 'each time from the integer part of the actual value (note: integer part,  '\nsay 'not rounded).                                                             '\nsay '    Values can be displayed in binary by either of BIN(var-name) or       '\nsay 'BIN16(var-name).  BIN is a variable length display, and BIN16 is fixed    '\nsay 'length.                                                                   '\nsay '    You can do logical bit operations on numbers with AND, OR, NOT, and   '\nsay 'XOR. An example of the syntax is \"AND(5,6)\" which will yield 4.           '\nsay '    FRAC will return the fractional part of a value, while TRUNC will     '\nsay 'return the integer part.                                                  '\nsay '    \"!(n)\" will return n factorial and \"C(m,n)\" will return               '\nsay 'combination(m,n) which is also known as \"m choose n\" and is the number of '\nsay 'ways of picking a subset of n objects from m objects.  These are used in  '\nsay 'probability and statistics.                                               '\nsay \"    NEG will cause negative hex values to print in 2's complement, until  \"\nsay 'you use POS to print the absolute value of hex numbers.                   '\n   return\nHELPREXX:\nsay '    You can perform any valid REXX command by prefixing the command with  '\nsay ' \"REXX\".  SAY, DO and TRACE are also recognized without having to prefix  '\nsay ' the command with \"REXX\".  (Note: TRACE with no operands will be          '\nsay ' interpreted as TRACE ?I).                                                '\nsay '    There is a primitive looping capability in that you can code any      '\nsay ' command with \"DO\" and it will also be interpreted as a REXX command.  You'\nsay ' could print the cubes of 1-12 with the command                           '\nsay '      \"do i = 1 to 12; queue i**3; end\"                                   '\nsay ' The semicolon is a REXX command seperator and must be used if you are    '\nsay ' entering multiple REXX commands on one line.                             '\n   return\nHELPTIME:\nsay '     You can print a number of seconds as HH.MM.SS with the function      '\nsay ' TOHMS(number). You can convert from HH.MM.SS to a decimal number of      '\nsay ' seconds with FROMHMS(HH.MM.SS). If there is only one period, FROMHMS     '\nsay ' assumes you are entering MM.SS; with no periods it assumes SS only. These'\nsay ' functions are useful for clock arithmetic.                               '\nsay '     TOHMS(FROMHMS(05.04.03)-FROMHMS(4.5.6) will yield 00.58.57 showing   '\nsay ' 58 minutes and 57 seconds between 04:05:06 and 05:04:03.                 '\nsay '                                                                          '\nsay '     TIMESTAMP will call the external routine IEBTIM which displays a     '\nsay ' timestamp (such as is used in VSAM) in date and time format.  IEBTIM     '\nsay ' assumes that the number coming in is HEX unless otherwise specified;     '\nsay ' TIMESTAMP will otherwise specify for you unless you use other operands.  '\nsay ' SYNTAX:                                                                  '\nsay '      TIMESTAMP value    GMT | gmtval     HEX                             '\nsay '        value is any value.  If it is a hex value, you must code both GMT '\nsay '        or gmtval and HEX (these are positional operands).  GMT (default) '\nsay \"        will only work on MVS.  It tells IEBTIM to check the system's GMT \"\nsay '        offset and compute based upon that.  Otherwise you can put the GMT'\nsay '        offset value in.'\nsay '        EXAMPLES:'\nsay 'TIMESTAMP A401CA8B80240000 gmt hex       TIMESTAMP 11817949597696000000 '\nsay 'TIMESTAMP A401CA8B80240000 0   hex       TIMESTAMP 11817949597696000000  0'\n\n   return\nHELPDUMP:\nsay '    \"STG(n)\" will return the 4 bytes at location n.  \"DUMP n\" will format '\nsay 'a dump of data at location n.  You can also code \"DUMP n length\" where    '\nsay 'length is the number of bytes to dump.  An example to print the CVT prefix'\nsay 'area (an MVS area):                                                       '\nsay '  let a = stg(16)    (or let a = stg(h(10))                               '\nsay '  dump a-40 40                                                            '\nsay 'An example to print the current LPALST concatenation (MVS):               '\nsay '                                                                          '\nsay '  let cvt= stg(16)                                                        '\nsay '  let cvte=stg(cvt+h(4ac))                                                '\nsay '  let lpat=stg(cvte+h(38))                                                '\nsay '  let numdsn = stg(lpat+7 1)    note optional length on stg               '\nsay '  dump lpat numdsn*45+9                                                   '\nsay '  let name = lpat+9                                                       '\nsay '  do i = name by 45 for numdsn; say storage(d2x(i),44); end               '\nsay ' '\nsay 'Note:  These functions may only be available under MVS.'\n   return\nSYNTAX:\n   sigl2 = sigl\n   !!temp = 'SYNTAX'\n   !!temp2 = \"SYNTAX error\" rc\n   signal ERRRTN\nERROR:\n   sigl2 = sigl\n   !!temp = 'ERROR' rc\n   !!temp2 = !!temp\n   signal ERRRTN\nFAILURE:\n   sigl2 = sigl\n   !!temp = 'FAILURE' rc\n   !!temp2 = !!temp\n   signal ERRRTN\nERRRTN:\n   if !!inproc = '!!INPROC' then do\n     if !!verbose then do\n       say !!temp2 'in procedure (at line' sigl2')- ignored'\n       say 'Error' rc 'means \"' || errortext(rc) || '\"'\n       say 'Line' sigl2 'is:'\n       return strip(sourceline(sigl2),'T')\n     end\n     else return !!temp2 'in procedure (at line' sigl2')- ignored'\n   end\n   else do\n     say !!temp2 'in command (at line' sigl2')- ignored'\n     if !!verbose then do\n       say 'Error' rc 'means \"' || errortext(rc) || '\"'\n       say 'Line' sigl2 'is:'\n       say sourceline(sigl2)\n     end\n     interpret 'signal on' !!temp\n     signal ready\n   end\nINITIALIZE:\n   DO WHILE !!TEMP1 \\= ''\n     PARSE VAR !!TEMP1 !!TEMP2 !!TEMP1\n     INTERPRET !!TEMP2\n   END\n   IF DEBUG = 'TRACE' THEN TRACE ?i\n   ELSE IF DEBUG \\= \"DEBUG\" THEN TRACE i\n   CURR=0\n   !!hexmax = x2d(copies('f',16))\n   !!max = 99999999999999999999\n   !!min = -9999999999999999999\n   !!minfrac = 10**-33  /* smallest number I'll express without\n                           going to scientific notation  */\n   DROP debug\n   !!varnum = 0\n   !!vartble. = 0\n   !!deleted = x2c(fffffe) /* delete variable value */\n   !!true = 0=0\n   !!false= \\!!true\n   !!verbose = !!false\n   !!!.0 = 1\n   !!!.1 = 1\n   !!temp = address()\n   !!inproc = 'NO'  /* are we in a 'procedure'? */\n   !!neg = !!false  /* all hex numbers are positive */\n   SELECT\n     WHEN !!temp = 'TSO' then\n       do\n         if sysvar('SYSENV') = 'FORE' then\n           !!back = !!false\n         else\n           !!back = !!true\n         !cvt = stg(16)\n       end\n     WHEN !!temp = 'MVS' then\n       do\n         !!back = !!true\n         !cvt = stg(16)\n       end\n     OTHERWISE  /* eg under 'CMS' or pc-rexx */\n       !!back = !!false\n   END   /* of SELECT */\n   return trace()\n /*  Written by Art Tansky at\n       Sungard\n       Suite 600\n       401 N. Broad St.\n       Philadelphia, PA 19108\n\n       Phone:  (215) 351-1323\n\n     If you find any bugs or have any suggestions for improvements or\n     additions, you can contact me at the address and phone number\n     above.  Please do not distribute modified versions of this code.\n     DO NOT REMOVE THE DISCLAIMER!\n\n  DISCLAIMER Disclaimer DISCLAIMER disclaimer DISCLAIMER Disclaimer:\n\n  This code has worked at Sungard.  There is no guarantee that the\n  code will work anywhere else.  Neither Sungard nor the author may be\n  held reponsible for any damage caused by this code.\n\n\n\n  Version 1.19 updates:\n    Use ! instead of # as some REXX implementations do not allow #.\n    Use \\ for not instead of a not sign for same above reasons.\n    Put 1st line comment in column 1 because OS/2 REXX requires it.\n    Replace \"upper\" with a push and pull because not all REXX's have\n      the \"upper\" command.\n\n */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPRESS": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x901/\\x00\\x901/\\x12\\x00\\x00\\xfc\\x00\\xfc\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-11-08T00:00:00", "modifydate": "1990-11-08T12:00:00", "lines": 252, "newlines": 252, "modlines": 0, "user": "REXX"}, "text": "This file contains an ISPF Edit Macro called Compress:\n\nA new REXX exec, %COMPRESS, is now available to compress a partitioned\ndata set. The exec may be used either as an ISPF Edit macro or as a TSO\ncommand.\n\nThe exec is particularly useful as an Edit macro when an X37 abend\noccurs when you use the END or SAVE command. To use it, simply enter:\n\n   ===> %COMPRESS\n\nBelow is the REXX Procedure.  Place it into your REXX library\naccessed by ISPF.\n\n/***********************************************************************\n*                                                                      *\n* COMPRESS ISPF Edit macro or TSO command                              *\n*                                                                      *\n* When used as an Edit macro the current data set is compressed and no *\n* parameters are allowed.                                              *\n*                                                                      *\n* When used as a TSO command, the following parameters are supported.  *\n*                                                                      *\n* Positional command parameter (required):                             *\n*    dataset         specifies the dataset to be compressed.           *\n*                                                                      *\n* Keyword command parameters (optional):                               *\n*    LIST|NOLIST     (default LIST) specifies listing member names.    *\n*    TRIM|NOTRIM     (default NOTRIM) specifies releasing unused space *\n*                    via the TRIM command.                             *\n*    OLD|SHR         (default OLD) specifies the disposition of the    *\n*                    data set to be compressed.                        *\n*    PRINT(*|dsname) (default *) specifies where the listing is to be  *\n*                    placed (* specifies the terminal).                *\n*    SPACE(tracks)   (default 0) specifies the amount of unused space  *\n*                    which is not to be released by TRIM.              *\n*                                                                      *\n* Unsupported but tolerated parameters:                                *\n*    IEBCOPY, NEW                                                      *\n*                                                                      *\n*                                                                      *\n* Douglas H. Adams                                                     *\n* Mail Code 110-SH28                                                   *\n* Rockwell International Corporation                                   *\n* 2201 Seal Beach Boulevard                                            *\n* P. O. Box 2515                                                       *\n* Seal Beach, California 90740-1515                                    *\n*                                                                      *\n* (213) 797-2618                                                       *\n*                                                                      *\n* November 8, 1990                                                     *\n*                                                                      *\n***********************************************************************/\n\nSignal on novalue\nTrace \"Off\"\nArg parameters\n\n/***********************************************************************\n* Call appropriate interface (Edit macro or TSO command)               *\n***********************************************************************/\nParse source . . . . . . . address_space .\nSelect\n   When address_space == \"ISPF\"\n   Then do\n      Address ISPEXEC \"CONTROL ERRORS RETURN\"\n      ADDRESS ISREDIT \"MACRO (PARM)\"\n      Select\n         When rc = 0\n         Then call EDIT_interface\n         When rc = 20\n         Then call TSO_interface\n         Otherwise result = 16\n         End\n      End\n   When address_space == \"TSO/E\"\n   Then call TSO_interface\n   Otherwise\n      Say \"COMPRESS must be used under TSO\"\n      Result = 16\n   End\n\nExit result\n\n/***********************************************************************\n* Edit macro interace                                                  *\n***********************************************************************/\nEDIT_interface:\n\nAddress ISPEXEC\nIf parm \u00ac== \"\"\nThen do\n   Zedsmsg = \"Parameters invalid\"\n   Zedlmsg = \"The COMPRESS edit macro does not allow parameters\"\n   \"SETMSG MSG(ISRZ001)\"\n   Return 16\n   End\n\"ISREDIT (DATASET) = DATASET\"\nDataset = \"'\"dataset\"'\"\n\"LMINIT DATAID(DATAID) DATASET(\"dataset\") ENQ(EXCLU)\"\nIf rc \u00ac= 0\nThen do\n   \"SETMSG MSG(ISRZ002)\"\n   Return 12\n   End\n\"LMCOMP DATAID(\"dataid\")\"\nIf rc \u00ac= 0\nThen \"SETMSG MSG(ISRZ002)\"\nElse do\n   Zedsmsg = \"Compress successful\"\n   Zedlmsg = \"Compress of\" dataset \"was successful\"\n   \"SETMSG MSG(ISRZ000)\"\n   End\n\"LMFREE DATAID(\"dataid\")\"\nReturn 1\n\n/***********************************************************************\n* TSO interface                                                        *\n***********************************************************************/\nTSO_interface:\n\n/*---------------------------------------------------------------------*\n* Initialize parameter processing                                      *\n*---------------------------------------------------------------------*/\nKeyword. = 0\nValue. = \"\"\nParse value \"IEBCOPY LIST NEW NOLIST NOTRIM OLD PRINT SHR SPACE TRIM\",\n      with   k.1     k.2  k.3 k.4    k.5    k.6 k.7   k.8 k.9   k.10\nParse value \"1       1    2   3      3      1   1     2   2     1   \",\n      with   l.1     l.2  l.3 l.4    l.5    l.6 l.7   l.8 l.9   l.10\nParse value \"* 0\",\n      with value.print value.space\nParameters = translate(parameters,,\",\")\n/*---------------------------------------------------------------------*\n* Process positional parameter (data set name)                         *\n*---------------------------------------------------------------------*/\nParse var parameters dataset parameters\nDo while dataset = \"\"\n   Say \"Enter data set name -\"\n   Parse external dataset .\n   End\n/*---------------------------------------------------------------------*\n* Process keyword parameters                                           *\n*---------------------------------------------------------------------*/\nDo while parameters \u00ac== \"\"\n   Parse var parameters parameter parameters\n   Parse var parameter keyword \"(\" value \")\" .\n   Do i = 1 to 10 until abbrev(k.i,keyword,l.i)\n      End i\n   If i > 10\n   Then do\n      Call message \"Invalid parameter\",,\n                    parameter \"is invalid or ambiguous\"\n      Return 16\n      End\n   Else do\n      Keyword = k.i\n      Keyword.keyword = 1\n      If value \u00ac== \"\"\n      Then value.keyword = value\n      End\n   End\n/*---------------------------------------------------------------------*\n* Allocate data sets                                                   *\n*---------------------------------------------------------------------*/\nIf listdsi(dataset) > 4\nThen do\n   Call message \"\",sysmsglvl2\n   Return 16\n   End\nIf keyword.shr\nThen \"ALLOCATE FILE(THATSIT) DATASET(\"dataset\") SHR REUSE\"\nElse \"ALLOCATE FILE(THATSIT) DATASET(\"dataset\") OLD REUSE\"\nSelect\n   When value.print == \"*\" & address_space == \"TSO/E\"\n   Then \"ALLOCATE FILE(SYSPRINT) DATASET(*) REUSE\"\n   When value.print == \"*\" & address_space == \"ISPF\"\n   Then \"ALLOCATE FILE(SYSPRINT) UNIT(SYSVIO) REUSE NEW\",\n                 \"SPACE(1 1) TRACKS\"\n   When sysdsn(value.print) == \"OK\"\n   Then \"ALLOCATE FILE(SYSPRINT) DATASET(\"value.print\") REUSE OLD\"\n   Otherwise \"ALLOCATE FILE(SYSPRINT) DATASET(\"value.print\") REUSE NEW\",\n                      \"SPACE(1 1) TRACKS\"\n   End\n\"ALLOCATE FILE(SYSUT3) UNIT(SYSVIO) REUSE NEW SPACE(1 1) CYLINDERS\"\n\"ALLOCATE FILE(SYSUT4) UNIT(SYSVIO) REUSE NEW SPACE(1 1) CYLINDERS\"\n\"ALLOCATE FILE(SYSIN) UNIT(SYSVIO) REUSE NEW SPACE(1) TRACK\",\n         \"RECFM(F) LRECL(80) BLKSIZE(80)\"\n/*---------------------------------------------------------------------*\n* Compress                                                             *\n*---------------------------------------------------------------------*/\nSysin.1 = \" COPY OUTDD=THATSIT,INDD=THATSIT\"\nIf keyword.nolist\nThen sysin.1 = sysin.1\",LIST=NO\"\n\"EXECIO 1 DISKW SYSIN (STEM SYSIN. FINIS)\"\n\"TSOEXEC PGMCALL IEBCOPY\"\nRc_TSOEXEC = rc\nSelect\n   When rc = 0\n   Then nop\n   When rc = 4\n   Then call message \"Return code\" syscmdrc,,\n                     \"Return code is\" syscmdrc\n   When rc = 12\n   Then call message \"Abend code\" sysabnrc,,\n                     \"Abend code is\" sysabncd\", reason code is\" sysabnrc\n   Otherwise call message \"TSOEXEC failed\",,\n                          \"TSOEXEC return code is\" rc\n   End\n/*---------------------------------------------------------------------*\n* Browse compress output                                               *\n*---------------------------------------------------------------------*/\nIf address_space == \"ISPF\"\nThen do\n   Address ISPEXEC \"LMINIT DATAID(DATAID) DDNAME(SYSPRINT)\"\n   Address ISPEXEC \"BROWSE DATAID(\"dataid\")\"\n   Address ISPEXEC \"LMFREE DATAID(\"dataid\")\"\n   End\n/*---------------------------------------------------------------------*\n* Trim                                                                 *\n*---------------------------------------------------------------------*/\nIf rc_TSOEXEC = 0 & keyword.trim\nThen \"TRIM\" dataset \"SPACE(\"value.space\")\"\n/*---------------------------------------------------------------------*\n* Free files                                                           *\n*---------------------------------------------------------------------*/\n\"FREE FILE(THATSIT SYSIN SYSPRINT SYSUT3 SYSUT4)\"\n\"ALLOCATE FILE(SYSIN) DATASET(*)\"\n\"ALLOCATE FILE(SYSPRINT) DATASET(*)\"\n\nReturn rc_TSOEXEC\n\n/***********************************************************************\n* Issue message                                                        *\n***********************************************************************/\nMessage:\n\nParse arg zedsmsg,zedlmsg\nIf address_space == \"ISPF\"\nThen address ISPEXEC \"SETMSG MSG(ISRZ001)\"\nElse say zedsmsg zedlmsg\nReturn\n\n/***********************************************************************\n* Trap uninitialized variables                                         *\n***********************************************************************/\nNovalue:\n\nSay \"Uninitialized variable in line\" sigl\":\"\nSay sourceline(sigl)\nTrace \"?Results\"\nNop\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CURSRPWR": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00L\\x00L\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "CLIST"}, "text": "/* ----------------------------------------------------------------- */\n/*                                                                   */\n/* Ref:  \"Enterprise Systems Journal\", March, 1992, article titled   */\n/*       \"Cursor Power for MVS/TSO\", by Andrew Brundell, page 10.    */\n/*                                                                   */\n/* With corrections by William J. Smith, Charles Schwab & Co., Inc.  */\n/* 101 Montgomery Street, 5th Floor, San Francisco, CA  94104-4122.  */\n/*                                                                   */\n/* This ISPF/PDF edit macro provides the user with the capability of */\n/* 'scavenging' screen data for a data set name and passing it to    */\n/* PDS/E for subsequent MEMLIST processing.  In essence, this macro  */\n/* provides the user with a crude form of \"mousing\" around the 3270  */\n/* keyboard.                                                         */\n/*                                                                   */\n/* All lines of code with the exception of the PDS/E, EDIT, or       */\n/* BROWSE service invocation, provide the basic algorithm for use as */\n/* a standard means by which to extract the information pointed to   */\n/* by the cursor.                                                    */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\nISREDIT MACRO NOPROCESS\nCONTROL END(ENDO)\nISPEXEC CONTROL ERRORS RETURN\nISREDIT (CL,CC) = CURSOR\nIF &CC = 0 THEN +\n  EXIT CODE(0)\n\n\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/* Since a data set name is to be extracted, the delimiter variable, */\n/* &DELIM, should only contain those characters that could never     */\n/* form part of a data set name (e.g. spaces, braces, etc.).         */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\n\nSET &DELIM = &NRSTR( ~`!%\u00ac*-_=+|\\{\u00a2\u00a6};:\"'<,>?/)\nISREDIT (LINE) = LINE .ZCSR\nISREDIT (END) = LRECL\nSET &START = 1\n\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/* Return the line the cursor rests on using the LINE macro          */\n/* directive and the length of the line using (the record length).   */\n/* Using a simple scan loop, each character is examined first back   */\n/* from the cursor column and then forward until a character from    */\n/* the delimiter string is found in each direction.  When each       */\n/* string limit is found, the scan loop is shortcut, resulting in    */\n/* the start and end positions of the data of interest. Extract the  */\n/* data set name using SUBSTR and pass it to the respective ISPF     */\n/* service, TSO command processor, CLIST, or REXX EXEC.              */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\n\nDO I= &CC TO &START BY -1\n  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN +\n    SET &START = &I + 1\nENDO\n\nDO I= &CC TO &END\n  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN +\n    SET &END = &I - 1\nENDO\n\nIF &START > &END THEN +\n  EXIT CODE(0)\nSET &WORD = &SUBSTR(&START:&END,&NRSTR(&LINE))\n\nISPEXEC SELECT CMD(LP '&WORD' ML :)    /* Pass data set name to PDS  */\n/* ISPEXEC BROWSE DATASET('&WORD')     <=== Make a suitable choice   */\n/* ISPEXEC EDIT   DATASET('&WORD')     <=== for your installation.   */\n\nIF &LASTCC > 0 THEN +\n  ISPEXEC SETMSG MSG(&ZERRMSG)\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDN": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x901/\\x00\\x901/\\x12\\x00\\x08 \\x08 \\x00\\x00\\xd7\\xc4\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-11-08T00:00:00", "modifydate": "1990-11-08T12:00:00", "lines": 2080, "newlines": 2080, "modlines": 0, "user": "PDS"}, "text": "./ ADD NAME=$README  0101-90213-90214-1550-00048-00046-00000-$A1238\nThis data set contains an set of ISPF Commands that allow the ISPF\nuser to view data sets and optionally data sets with a specified\nmember that are allocated to a specified DDname.\n\nNOTE:  DDLIST is noted as being reentrant, but the RDJFCB must\n       first be changed to a list form which I have not yet had\n       time to do yet.\n\nSome basics first:\n\nThis file is in IEBUPDTE format and contains the following members\nafter being processed by IEBUPDTE:\n\n   $README  -  What you are reading now\n   ASM      -  The Assembler source for the DDLIST program\n               (I have unnumbered this to reduce the file size\n                for data transfer)\n   EXEC     -  The basic Rexx procedures used by the ISPF Commands\n               and a few others for sample purposes\n   MACROS   -  A few macros required to assemble DDLIST\n   PANELS   -  The ISPF Panels used by the ISPF Commands\n\nEach of these members, other than $README, must be edited by you to\nchange \"+/\" to \"./\" before processing them using IEBUPDTE into unique\ndata sets.\n\nYou must then use ISPF 3.9 to update your ISPCMDS ISPF Commands Table\nto add the following:\n\n     Verb      T  Action\n                     Description\n'''' DDALL     0  SELECT CMD(%DDLIST &ZPARM) NEWAPPL(ISR)\n                     PROCESS DDNAME OR DDNAME(MBR) FROM ANYWHERE           (A)\n'''' DDBR      0  SELECT CMD(%DDLIST &ZPARM BROWSE) NEWAPPL(ISR)\n                     BROWSE DDNAME OR DDNAME(MBR) FROM ANYWHERE            (A)\n'''' DDED      0  SELECT CMD(%DDLIST &ZPARM EDIT) NEWAPPL(ISR)\n                     EDIT   DDNAME OR DDNAME(MBR) FROM ANYWHERE            (A)\n\nIf you have any questions, comments or improvements to offer contact\nme at:\n\n               Lionel Dyck\n               Rockwell International\n               M/C 110-SH28\n               P.O. Box 2515\n               Seal Beach Blvd.\n               Seal Beach,  Ca 90740\n               (213) 797-1125\n\n               IBMLINK:   HONE81(ROK2027)\n               SHARECON:  LDYCK\n               VMSHARE:   $TS\n./ ADD NAME=ASM      0100-90214-90214-1549-00536-00536-00000-$A1238\n+/ ADD NAME=DDLIST   0104-90212-90213-0736-00535-00696-00243-$A1238\n*---------------------------------------------------------------------*\n*                                                                     *\n* Name:        DDNQUERY                                               *\n*                                                                     *\n* Function:    Return to REXX variables all dsnames for a ddname and  *\n*              if a member name is passed then only those dsnames.    *\n*                                                                     *\n* Syntax:      X=DDNQUERY(STEM,DDNAME)                                *\n*              X=DDNQUERY(STEM,DDNAME,MEMBER)                         *\n*                                                                     *\n*              Where:                                                 *\n*                                                                     *\n*              STEM (with a period) into which the data set name      *\n*              is to be placed.                                       *\n*                                                                     *\n*              STEM.0 will contain a count                            *\n*                                                                     *\n*              DDNAME is the ddname whose data sets are to be         *\n*              placed into REXX variables.                            *\n*                                                                     *\n*              MEMBER is a specific member in a data set that must    *\n*              exist for the data set to be eligible to be placed     *\n*              into a variable.                                       *\n*                                                                     *\n*              Defaults:                                              *\n*                                                                     *\n*              STEM:     DDNQUERY.                                    *\n*              DDNAME:   none                                         *\n*              MEMBER:   none                                         *\n*                        If blank then all data sets will be used     *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Link Edit information:     REENTRANT                                *\n*---------------------------------------------------------------------*\n* Return Codes:                                                       *\n*                                                                     *\n*         0    processing has completed successfully                  *\n*         4    no data sets have the requested member                 *\n*         8    invalid parm                                           *\n*        12    DDNAME requested is not allocated                      *\n*        16    ARL is invalid returned by RDJFCB                      *\n*        20    no parm provided                                       *\n*        24    IRXEXCOM bad return code                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Author:      Lionel Dyck                                            *\n*              Rockwell International                                 *\n*              Mail Code 110-SH28                                     *\n*              P.O. Box 2515                                          *\n*              2201 Seal Beach Blvd.                                  *\n*              Seal Beach, California 90740                           *\n*              (213) 797-1125                                         *\n*---------------------------------------------------------------------*\n* HISTORY:                                                            *\n*                                                                     *\n*        07/20/90  -  Creation                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nDDLIST   AMODE 31\nDDLIST   $PROLOG R12,LV=4000\n         USING WORK,R13\n         EJECT\n*---------------------------------------------------------------------*\n*        PROCESS THE INPUT PARAMETER LIST                             *\n*---------------------------------------------------------------------*\n         LR    R5,R0               -> ENVIRONMENT BLOCK\n         ST    R5,ENVBADDR         Save Environment Block Address\n         USING ENVBLOCK,R5\n         L     R5,ENVBLOCK_IRXEXTE -> EXTERNAL VECTOR TABLE\n         DROP  R5\n         USING IRXEXTE,R5\n         L     R5,IRXEXCOM         LOAD IRXEXCOM EPA\n         ST    R5,EXCOM            SAVE IRXEXCOM EPA\n         DROP  R5\n         LR    R4,R1               -> EFPL\n         USING EFPL,R4             ESTABLISH ADDRESSABILITY TO EFPL\n         L     R5,EFPLEVAL         -> EVAL BLOCK ADDRESS POINTER\n         L     R5,0(0,R5)          -> EVAL BLOCK\n         ST    R5,EVALADDR         SAVE IT'S ADDRESS\n         L     R4,EFPLARG          -> ARGUMENT LIST\n         DROP  R4\n*\n         LTR   R4,R4               ANY ARGUMENT LIST ?\n         BZ    EXIT20              YES\n*\n         MVC   STEM,BLANKS         INITIALIZE THE STEM VALUE\n         MVC   DDNAME,BLANKS       INITIALIZE THE DDNAME VALUE\n         MVC   MEMBER,BLANKS       INITIALIZE THE MEMBER VALUE\n*\n         USING ARGTABLE_ENTRY,R4   ESTABLISH ADDRESSABILITY TO ARG\n         CLC   =8X'FF',ARGTABLE_ARGSTRING_PTR  ANY REAL ARGUMENTS\n         BE    EXIT20              NO - SO EXIT\n         L     R2,ARGTABLE_ARGSTRING_PTR    -> ARGUMENT\n         L     R3,ARGTABLE_ARGSTRING_LENGTH LOAD LENGTH\n         BCTR  R3,R0               LESS 1 FOR MVC\n         EX    R3,MOVESTEM         MOVE THE STEM\n         LA    R1,STEM             -> Stem\n         AR    R1,R3               Get Stem suffix offset\n         LA    R1,1(R1)            Add back the 1 lost during mvc\n         ST    R1,STEMSUFX         Now Save the Offset\n         LA    R3,1(R3)            Add 1 to len            *LBD 07/90*\n         ST    R3,STEMLEN          and save length         *LBD 07/90*\n         LA    R4,ARGTABLE_NEXT\n*\n         CLC   =8X'FF',ARGTABLE_ARGSTRING_PTR  ANY DDNAME ?\n         BE    EXIT8               NO - SO EXIT\n         L     R2,ARGTABLE_ARGSTRING_PTR    -> ARGUMENT\n         L     R3,ARGTABLE_ARGSTRING_LENGTH LOAD LENGTH\n         BCTR  R3,R0               LESS 1 FOR MVC\n         LTR   R3,R3\n         BM    EXIT8               NO DDNAME\n         EX    R3,MOVEDDN          MOVE DDNAME\n         LA    R4,ARGTABLE_NEXT\n*\n         CLC   =8X'FF',ARGTABLE_ARGSTRING_PTR  ANY MEMBER ?\n         BE    START               NO - SO CONTINUE\n         L     R2,ARGTABLE_ARGSTRING_PTR    -> ARGUMENT\n         L     R3,ARGTABLE_ARGSTRING_LENGTH LOAD LENGTH\n         BCTR  R3,R0               LESS 1 FOR MVC\n         LTR   R3,R3\n         BM    START               MEMBER\n         EX    R3,MOVEMEM          MOVE MEMBER\n         ST    R3,MEMLNGTH         Save member length\n         EJECT\n*---------------------------------------------------------------------*\n*        INITIALIZE ALL WORK AREAS FROM OUR CONSTANTS                 *\n*---------------------------------------------------------------------*\nSTART    DS    0H\n         OC    DDNAME(8),BLANKS    INSURE UPPER CASE\n         OC    MEMBER(8),BLANKS    INSURE UPPER CASE\n         OC    STEM(80),BLANKS     INSURE UPPER CASE\n*\n         MVC   ARLSTRT(XRLL),MODLARL\n         MVC   WORKDCB(MODLDCBL),MODLDCB\n         MVC   WORKDDN(8),DDNAME   SET UP DDNAME\n         SR    R8,R8               ZERO STEM COUNTER\n         SPACE 2\n*---------------------------------------------------------------------*\n*        PROCESS THE JFCBS FOR THE SPECFIED DDNAME                    *\n*---------------------------------------------------------------------*\n* NOW READ THE JFCB FOR ALL DSNAMES\n         LA    R4,ARLSTRT\n         ST    R4,JFCBEXIT\n         MVI   JFCBEXIT,X'93'\n         LA    R4,JFCBEXIT\n         ST    R4,WORKDCB+36\n         LA    R2,WORKDCB\n         RDJFCB ((R2))\n         LTR   R15,R15             OK ?\n         BNZ   EXIT12              NO - GET OUT OF HERE\n*---------------------------------------------------------------------*\n*        RDJFCB IS NOW COMPLETE - NOW PROCESS ALL JFCBS               *\n*---------------------------------------------------------------------*\n         ICM   R9,X'F',ARLAREA    GET AND TEST ADDR OF ARL\n         BZ    EXIT16             NO ARL AVAILABLE\n         CLI   ARLRCODE,0         TEST RDJFCB REASON CODE\n         BNE   EXIT16             NOT AVAILABLE\n         LH    R3,ARLRTRVD        # OF RETRIEVED DATA SETS\nDSNLP    DS    0H\n         LA    R10,4(R9)\n         USING INFMJFCB,R10\n         MVC   RDSN,BLANKS\n         MVC   RDSN(44),JFCBDSNM   MOVE DSNAME\n         DROP  R10\nDOADD    DS    0H\n         CLI   MEMBER,C' '         ANY MEMBER ?\n         BE    DOADDIT             NO\n         BAS   R10,DOBLDL\n         LTR   R15,R15             MEMBER FOUND\n         BNZ   BCT                 NO - SKIP ADD\nDOADDIT  DS    0H\n         BAS   R10,ADD\nBCT      DS    0H\n         LH    R5,0(R9)           LOAD DATA LENGTH\n         AR    R9,R5              BUMP POINTER\n         BCT   R3,DSNLP           CONTINUE\n         SPACE 2\n*---------------------------------------------------------------------*\n*        ALL JFCBS PROCESSED - FREE ARL, SET STEM.0 AND EXIT          *\n*---------------------------------------------------------------------*\n         CVD   R8,DWK\n         MVC   COUNT(4),=X'F0202021'\n         ED    COUNT(4),DWK+6\n         MVC   RDSN,BLANKS\n         MVC   RDSN(3),COUNT+1\n         L     R4,STEMSUFX\n         MVC   0(3,R4),BLANKS\n         MVI   0(R4),C'0'          Set stem.0\n         OI    FLAG,X'10'          Set final flag\n         L     R1,STEMLEN          Load stem. length       *LBD 07/90*\n         LA    R1,1(R1)            Add 1                   *LBD 07/90*\n         ST    R1,STEMLENV         Save for SHVBLOCK       *LBD 07/90*\n         BAS   R10,SETVAR\n         L     R6,ARLAREA         -> GETMAIN'D ARL AREA\n         L     R7,ARLPOOL         LOAD POOL AND LEN\n         FREEMAIN R,A=(6),LV=(7)\n         B     EXIT0\n         EJECT\n*---------------------------------------------------------------------*\n*        1.  DETERMINE IF A MEMBER NAME WAS SPECIFIED AND IF SO DO    *\n*            A BLDL TO SEE IF THE DATA SET CONTAINS SAID MEMBER.      *\n*        2.  IF NO MEMBER SPECIFIED OR THE MEMBER WAS FOUND BY BLDL   *\n*            DO A STEM UPDATE                                         *\n*        3.  RETURN FOR THE NEXT DSNAME                               *\n*---------------------------------------------------------------------*\nADD      DS    0H\n         CLI   MEMBER,C' '         ANY MEMBER ?\n         BE    SETVAR              NO - SKIP MEMBER BUILD\n         LA    R4,RDSN+45          -> END OF DSNAME\nFEND     DS    0H\n         CLI   0(R4),C' '          END OF DSNAME ?\n         BNE   GEND                YES - GOT IT\n         BCT   R4,FEND             NO - SEARCH FOR IT\nGEND     DS    0H                  AT LAST REAL CHARACTER OF DSNAME\n         LA    R4,1(R4)            -> FIRST BLANK\n         MVI   0(R4),C'('          MOVE IN LEFT PAREN\n         LA    R4,1(R4)            -> NEXT BLANK\n         L     R1,MEMLNGTH         Load MVC Length of Member\n         EX    R1,MVCMEM           And move it\n         LA    R4,1(R4)            NEXT CHARACTER\n         AR    R4,R1               Add MVC Length\n         MVI   0(R4),C')'          FILL IN END PAREN\n         LA    R4,1(R4)            Bump by 1\n         LA    R1,RDSN             -> Start of DSN\n         SR    R4,R1               Get DSN Length\n         ST    R4,DSNLNGTH         Save Length\n         EJECT\nSETVAR   DS    0H\n         MVC   EXCOM1,=CL8'IRXEXCOM'\n         XC    EXCOM2,EXCOM2\n         LA    R7,EXCOM4\n         USING SHVBLOCK,R7\n         TM    FLAG,X'10'          Final flag ?\n         BO    SETFINAL            Yes\n         AH    R8,=H'01'           ADD 1 TO COUNTER\n         CVD   R8,DWK\n         MVC   COUNT(4),=X'F0202021'\n         ED    COUNT(4),DWK+6\n*\n         L     R4,STEMSUFX\n         MVC   0(3,R4),BLANKS\n         LA    R1,COUNT+1         -> blank fill character\n         LA    R2,2               set loop counter\nCNTLP    DS    0H\n         CLI   0(R1),C'0'          is it higher than 0\n         BH    CNTMVC              yes - now move it\n         LA    R1,1(,R1)           no  - bump pointer\n         BCT   R2,CNTLP\nCNTMVC   DS    0H\n         EX    R2,MOVECNT\n         LA    R2,1(R2)            Bump count              *LBD 07/90*\n         A     R2,STEMLEN          Add current Stem length *LBD 07/90*\n         ST    R2,STEMLENV         And save it             *LBD 07/90*\n*\nSETFINAL DS    0H\n         XC    SHVNEXT,SHVNEXT     ZERO CHAIN POINTER\n         XC    SHVCODES,SHVCODES   ZERO CODES\n         MVI   SHVCODE,C'S'        SET VARIABLE USING Direct method\n         LA    R4,RDSN             ADDRESS OF STEM VALUE\n         ST    R4,SHVVALA          SAVE ADDRESS OF STEM VALUE\n         LA    R4,STEM             ADDRESS OF STEM NAME\n         ST    R4,SHVNAMA          SAVE ADDRESS OF STEM NAME\n         MVC   SHVNAML,STEMLENV    Set the stem.nnn length *LBD 07/90*\n*\n         CLI   MEMBER,C' '         Any Member ?\n         BE    NOMEM               Yes - skip this section\n         MVC   SHVVALL,DSNLNGTH    Set Length\n         B     DOEXCOM\nNOMEM    DS    0H\n         LA    R4,RDSN+45          -> end of dsname\nVALL     DS    0H\n         CLI   0(R4),C' '          Last character ?\n         BNE   SVALL               YES - SAVE LENGTH\n         BCT   R4,VALL             INCREMENT\n         B     VALL                AND KEEP LOOPING\nSVALL    DS    0H\n         LA    R4,1(R4)            Add 1 back\n         LA    R5,RDSN             -> RDSN START\n         SR    R4,R5               SUBTRACT FOR LENGTH\n         ST    R4,SHVVALL          SAVE LENGTH\n*\nDOEXCOM  DS    0H\n         OI    FLAG,X'01'          SET ADD FLAG\n         LA    R1,EXCOM1\n         ST    R1,EXADDR1\n         LA    R1,EXCOM2\n         ST    R1,EXADDR2\n         ST    R1,EXADDR3\n         LA    R1,EXCOM4\n         ST    R1,EXADDR4\n         OI    EXADDR4,X'80'       SET HIGH FLAG\n         LA    R1,EXADDR1\n         L     R15,EXCOM           -> IRXEXCOM MODULE\n         L     R0,ENVBADDR         -> Environment Block\n         BASR  R14,R15\n         BR    R10                 RETURN TO CALLER\n         DROP  R7\n         EJECT\n*---------------------------------------------------------------------*\n*        PERFORM THE BLDL OPERATION ON THE SPECIFIC DATA SET NAME     *\n*        TO DETERMINE IF THE REQUESTED MEMBER EXISTS.                 *\n*                                                                     *\n*        TO DO THIS:                                                  *\n*              1.  DYNAMICALLY ALLOCATE THE DATA SET                  *\n*              2.  OPEN THE DATA SET                                  *\n*              3.  DO THE BLDL                                        *\n*              4.  CLOSE AND FREE THE DATA SET                        *\n*              5.  RETURN TO THE CALLER WITH RESULT CODE              *\n*---------------------------------------------------------------------*\nDOBLDL   DS    0H\n         MVC   WORKDCB(MODLDCBL),MODLDCB\n         MVC   BLDLIST,MODBLIST\n         MVC   BLDLNAME,MEMBER     SET MEMBER FOR BLDL\n         MVC   S99RBPTR(DYNLEN),PRIMS99R\n         MVC   DYNDSN,RDSN         -> DSN\n         LA    R4,DYNDSNAM\n         ST    R4,TXTPTRS\n         LA    R4,DYNDDNAM\n         ST    R4,TXT2\n         LA    R4,DYNSTAT\n         ST    R4,TXT3\n         OI    TXT3,X'80'          SET LAST PARM FLAG\n         MVC   DSNLEN,=AL2(44)     SET ITS LENGTH\n         LA    R4,S99RB\n         ST    R4,S99RBPTR\n         OI    S99RBPTR,X'80'\n         LA    R4,TXTPTRS\n         ST    R4,S99TXTPP\n         LA    R1,S99RBPTR\n         SVC   99                  ** DO THE DYNAMIC ALLOCATION\n         MVC   WORKDDN,RETDDN      SETUP DDNAME INTO DCB\n         LA    R2,WORKDCB          -> DCB FOR OPEN\n         OPEN  ((R2))              DO THE OPEN\n         BLDL  (R2),BLDLIST        DO THE BLDL\n         LR    R7,R15              SAVE RC\n         CLOSE ((R2),FREE)         CLOSE AND FREE IT\n         LR    R15,R7              RESET RETURN CODE\n         BR    R10                 RETURN TO CALLER\n         EJECT\n*---------------------------------------------------------------------*\n*        ALL OF THE EXIT ROUTINES FOLLOW                              *\n*---------------------------------------------------------------------*\nSETRC    DS    0H\n         L     R11,EVALADDR\n         USING EVALBLOCK,R11\n         MVC   EVALBLOCK_EVLEN(4),=A(2)\n         MVC   EVALBLOCK_EVDATA(2),RC\n         DROP  R11\n         $EPILOG 0                 ALL OK\n*---------------------------------------------------------------------*\nEXIT0    DS    0H\n         TM    FLAG,X'01'\n         BZ    EXIT4               NO ROWS ADDED TO THE TABLE\n         MVC   RC,=C'00'           SET RC TO ZERO\n         B     SETRC\nEXIT4    DS    0H\n         MVC   RC,=C'04'           SET RC\n         B     SETRC\nEXIT8    DS    0H\n         MVC   RC,=C'08'           SET RC\n         B     SETRC\nEXIT12   DS    0H\n         MVC   RC,=C'12'           SET RC\n         B     SETRC\nEXIT16   DS    0H\n         MVC   RC,=C'16'           SET RC\n         B     SETRC\nEXIT20   DS    0H\n         MVC   RC,=C'20'           SET RC\n         B     SETRC\nEXIT24   DS    0H\n         MVC   RC,=C'24'           SET RC\n         B     SETRC\n         EJECT\n*---------------------------------------------------------------------*\n*        EXECUTED INSTRUCTIONS                                        *\n*---------------------------------------------------------------------*\nMOVESTEM MVC   STEM(0),0(R2)       ** EXECUTED\nMOVEDDN  MVC   DDNAME(0),0(R2)     ** EXECUTED\nMOVEMEM  MVC   MEMBER(0),0(R2)     ** EXECUTED\nMOVECNT  MVC   0(0,R4),0(R1)       ** Executed\nMVCMEM   MVC   0(0,R4),MEMBER      ** Executed\n         SPACE 2\n*---------------------------------------------------------------------*\n*        LITERAL POOL                                                 *\n*---------------------------------------------------------------------*\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\nBLANKS   DC    CL80' '\nMODBLIST DS    0D                  BLDL MODEL LIST\n         DC    255X'00'\n         ORG   MODBLIST\n         DC    AL2(01)\n         DC    AL2(100)\n         DC    CL8' '\n         DC    XL3'0'\n         DC    X'0'\n         DC    X'0'\n         DC    X'0'\n         DC    XL62'0'\n         ORG   ,\n         EJECT\nDALDSNAM EQU   X'0002'\nDALSTATS EQU   X'0004'\nDALRTDDN EQU   X'0055'\n*\nPRIMS99R DS    0F\n         DC    X'80',AL3(0)        AL3(S99RB)\n*\n         DC    AL1(20),X'01',XL2'E000'   S99RB\n         DC    XL2'00'\n         DC    XL2'00'\n         DC    A(0)                A(TXTPTRS)\n         DC    F'0'\n         DC    XL4'00'\n*\n         DC    A(0)                TXTPTRS A(DYNDSNAM)\n         DC    A(0)                A(DYNDDNAM)\n         DC    X'80',AL3(0)        AL3(DYNSTAT)\n*\n         DC    AL2(DALDSNAM),AL2(1)  DYNDSNAM\n         DC    AL2(0)\n         DC    CL44' '\n         DC    AL2(DALRTDDN),AL2(1,8)  DYNDDNAM\n         DC    CL8' '\n         DC    AL2(DALSTATS),AL2(1,1)   DYNSTAT\n         DC    X'08'               SHR STATUS\n         EJECT\nMODLDCB  DCB   DSORG=PO,DDNAME=WORKDDN,MACRF=R,                        X\n               EXLST=0\nMODLDCBL EQU   *-MODLDCB\n         EJECT\nSMDLDCB  DCB   DSORG=PS,DDNAME=NISPFDD,MACRF=PM,RECFM=VB,LRECL=255,    X\n               BLKSIZE=6233\nSMDLDCBL EQU   *-SMDLDCB\n         EJECT\nMODLARL  IHAARL DSECT=NO,PREFIX=XRL\nXRLL     EQU   *-MODLARL\n         EJECT\n*---------------------------------------------------------------------*\n*        WORK AREA DSECTS                                             *\n*---------------------------------------------------------------------*\nWORK     DSECT\nSAVE     DS    18F\nDWK      DS    D\nEVALADDR DS    F\nEXCOM    DS    A                   ADDRESS OF IRXEXCOM LOAD MODULE\nENVBADDR DS    A                   Environment Block Address\nDDNAME   DS    CL8                 PASSED DDNAME\nRDSN     DS    CL56                room for dsn(member)\nMEMBER   DS    CL8                 PASSED MEMBER NAME\nMEMLNGTH DS    F\nDSNLNGTH DS    F\nLEN      DS    H                   LENGTH OF DSN WITH OR W/O MEMBER\nSTEM     DS    CL80\nSTEMSUFX DS    F                   -> STEM SUFFIX LOCATION\nSTEMLEN  DS    F                   Length of stem.\nSTEMLENV DS    F                   Length of stem. plus suffix\nCOUNT    DS    CL4                 COUNTER\nRC       DS    XL2                 RETURN CODE\nFLAG     DS    X                   STATUS FLAG\n*                                  00 IS NULL\n*                                  01 AT LEAST 1 ADD PERFORMED\n*                                  10 final flag\n         SPACE\nS99RBPTR DS    F\n*\nS99RB    DS    AL1(20),X'01',XL2'E000'\nS99ERROR DS    XL2'00'\nS99INFO  DS    XL2'00'\nS99TXTPP DS    A(0)                A(TXTPTRS)\n         DS    F'0'\nS99FLAG2 DS    XL4'00'\n*\nTXTPTRS  DS    A(0)                A(DYNDSNAM)\nTXT2     DS    A(0)                A(DYNDDNAM)\nTXT3     DS    X'80',AL3(0)        AL3(DYNSTAT)\n*\nDYNDSNAM DS    AL2(DALDSNAM),AL2(1)\nDSNLEN   DS    AL2(0)\nDYNDSN   DS    CL44' '\nDYNDDNAM DS    AL2(DALRTDDN),AL2(1,8)\nRETDDN   DS    CL8' '\nDYNSTAT  DS    AL2(DALSTATS),AL2(1,1)\n         DS    X'08'               SHR STATUS\nDYNLEN   EQU   *-S99RBPTR\n*\n         SPACE 1\nEXADDRS  DS    0D\nEXADDR1  DS    A(EXCOM1)\nEXADDR2  DS    A(EXCOM2)\nEXADDR3  DS    A(EXCOM2)\nEXADDR4  DS    A(EXCOM4)\nEXCOM1   DS    CL8                 CL8'IREXCOM'\nEXCOM2   DS    A                   0 (used for exaddr2/3)\nEXCOM4   DS    XL32                SHVBLOCK DATA (USING SHVBLOCK)\n         SPACE 1\nBLDLIST  DS    0D\n         DS    CL255\n         ORG   BLDLIST\n         DS    AL4\nBLDLNAME DS    CL8\nTTR      DS    XL3\nK        DS    X\nZ        DS    X\nC        DS    X\nUSERDATA DS    XL62\n         ORG   ,\n         EJECT\nWORKDCB  DCB   DSORG=PO,DDNAME=WORKDDN,MACRF=R,                        X\n               EXLST=0\nWORKDDN  EQU   WORKDCB+40,8\n         SPACE 2\nJFCBEXIT DS    0H\n         DS    F\n         EJECT\nARLSTRT  IHAARL DSECT=NO\n         EJECT\n         IEFJFCBN LIST=YES\n         EJECT\n         IRXEFPL DSECT=YES\n         EJECT\n         IRXARGTB\n         EJECT\n         IRXSHVB\n         EJECT\n         IRXEVALB\n         EJECT\n         IRXEXTE\n         EJECT\n         IRXENVB\n         END   ,\n./ ADD NAME=EXEC                                   02AUG90 15.53.14\n+/ ADD NAME=DDINFO   0102-90176-90195-1534-00106-00109-00000-$A1238\n/* rexx */\n\n/* ***************************************************************\n    This Rexx procedure will use the LISTDSI function of REXX to\n    display information about a data set.\n\n    This is an ISPF Command and the syntax is:\n\n    LISTDSI\n    or\n    LISTDSI  data.set.name\n\n    Additional options are NODIR\n                           VOLUME(volser)\n\n    This was originally written by Mike Theys using TSO/E R3 Clist\n    and has been converted to Rexx by Lionel Dyck.\n\n    Panels used are:  DDINFO or DDINFO2\n*************************************************************** */\n\narg dsn opt\n\nif wordpos(\"NODIR\",opt) > 0 then nodir = \"NODIR\"\n                            else nodir = \"\"\n\nif wordpos(\"DEBUG\",opt) > 0 then trace i\n                            else trace off\n\nif pos(\"VOLUME(\",opt) > 0 then do\n   parse var opt with \"VOLUME(\" volume \")\"\n   end\n\npanel = \"DDINFO\"\n\nAddress ISPEXEC\n\n\"VGET (VLDSISVN) PROFILE\"\n\nldv = vldsisvn\nif ldv = \"yes\" then panel = \"DDINFO2\"\n\nldsidsn = \" \"\n\nif dsn = \"!\" then dsn = \"\"\nelse do\n  l = length(dsn)\n  if l > 2 then\n    if substr(dsn,1,1) = \"!\" then ldsidsn = substr(dsn,2,l-1)\n                             else ldsidsn = dsn\n     end\n\ndo forever\nif nodir = \"NODIR\" then do\n  parse value \"\" with ldsivdir ldsiadir ldsiudir ldsimems\nend\nelse ldsivdir = \"DIRECTORY\"\n\n\nif length(volume) > 0 then ldsivvol = volume\n                       else ldsivvol = \"\"\n\nldsilock = \"LOCK\"\n\nif length(ldsidsn) > 0 then do\n  x = listdsi(ldsidsn ldsivdir)\n   ldsirc   =  rc\n   ldsifdsn = sysdsname\n   ldsivol  = sysvolume\n   ldsiunit = sysunit\n   ldsidorg = sysdsorg\n   ldsircfm = sysrecfm\n   ldsilrcl = syslrecl\n   ldsibsiz = sysblksize\n   ldsikeyl = syskeylen\n   ldsistyp = sysunits\n   ldsialoc = sysalloc\n   ldsiused = sysused\n   ldsiprim = sysprimary\n   ldsisdry = sysseconds\n   ldsiexts = sysextents\n   ldsicdte = syscreate\n   ldsildte = sysrefdate\n   ldsixdte = sysexdate\n   ldsipswd = syspassword\n   ldsiracf = sysracfa\n   ldsichng = sysupdated\n   ldsitpcv = systrkscyl\n   ldsibptv = sysblkstrk\n   ldsiadir = sysadirblk\n   ldsiudir = sysudirblk\n   ldsimems = sysmembers\n   ldsireas = sysreason\n   ldsiem1  = sysmsglvl1\n   ldsiem2  = sysmsglvl2\n  if ldsirc = 0 & ldsireas = 0 then do\n    ldsiem1  =  \"\"\n    ldsiem2  = \"\"\n  end\n  if length(volume) = 0\n    then ldsistat = sysdsn(ldsidsn))\n    else ldsistat = \"\"\nend\n\"DISPLAY PANEL(\"panel\")\"\n if rc > 0 then exit\nend\n+/ ADD NAME=DDLIST   0102-90213-90214-1508-00324-00291-00000-$A1238\n/* ---------------------  rexx procedure  ---------------------- */\n/* Name:     DDLIST                                              */\n/*                                                               */\n/* Function: To provide to the TSO ISPF User the ability from    */\n/*           an ISPF Command to display a selection menu of all  */\n/*           data sets for a specified ddname, and optionally    */\n/*           to only display those data sets with a specified    */\n/*           member name.                                        */\n/*                                                               */\n/* Syntax:   %DDLIST ddname(member) option                       */\n/*                                                               */\n/*           Where:                                              */\n/*                                                               */\n/*           ddname    is the ddname from which the data sets    */\n/*                     will be selected.                         */\n/*                                                               */\n/*                     Special DDNAME values of LINKLIST or      */\n/*                     LPALIST will process the data sets        */\n/*                     allocated to the current active           */\n/*                     LINK list or LPA list.                    */\n/*                                                               */\n/*           member    is optional and will restrict the display */\n/*                     to just those data sets with that member  */\n/*                                                               */\n/*           option:   BROWSE - use DDNBR table display panel    */\n/*                              and \"S\" = Browse                 */\n/*                     EDIT   - use DDNED table display panel    */\n/*                              and \"S\" = Edit                   */\n/*                     default is to use the DDNALL table panel  */\n/*                                                               */\n/*           Required:  ddname                                   */\n/*                                                               */\n/* Author:    Lionel B. Dyck                                     */\n/*            Rockwell International                             */\n/*            P.O. Box 2515                                      */\n/*            Seal Beach, California 90740                       */\n/*            (213) 797-1125                                     */\n/*            IBMLINK:  ROK2027                                  */\n/*                                                               */\n/* History:                                                      */\n/*                                                               */\n/*            07/31/90 - Lionel Dyck                             */\n/*            If option Browse or Edit specified and only 1      */\n/*            data set matches display criteria then enter       */\n/*            Browse or Edit directly.                           */\n/*                                                               */\n/*            07/03/90 - Lionel Dyck                             */\n/*            Remove option X and add P option to invoke the     */\n/*            PDS Dialog via the PDS TSO Command.                */\n/*                                                               */\n/*            06/26/90 - Lionel Dyck                             */\n/*            Updated to support special ddnames of              */\n/*            LINKLIST and LPALIST.  Subroutine to               */\n/*            identify these data sets copied from               */\n/*            Dave ALcock of Rockwell International              */\n/*                                                               */\n/*            06/22/90 - Lionel Dyck                             */\n/*            Updated to support ? for tutorial panels           */\n/*                                                               */\n/*            06/21/90 - Lionel Dyck                             */\n/*            creation of this Rexx procedure.                   */\n/*                                                               */\n/* ------------------------------------------------------------- */\n\narg opt\n\nAddress ISPEXEC\n\nif length(opt) = 0 then do\n   zedsmsg = \"\"\n   xx = sysvar(sysicmd)\n   zedlmsg = \"A DDNAME must be specified when executing the\" xx \"dialog\"\n   \"SETMSG MSG(ISRZ000)\"\n   exit\n   end\n\n\npanel   = \"DDALL\"\ndefcmd  = \"BROWSE\"\ndefcmdd = \"Browse\"\n\nw1 = word(opt,1)\nif words(opt) > 1 then do\n                        w2 = word(opt,2)\n                        select\n                              when w2      = \"BROWSE\" then do\n                                   panel   = \"DDBR\"\n                                   defcmd  = \"BROWSE\"\n                                   defcmdd = \"Browse\"\n                                   end\n                              when w2      = \"EDIT\" then do\n                                   panel   = \"DDED\"\n                                   defcmd  = \"EDIT\"\n                                   defcmdd = \"Edit\"\n                                   end\n                              otherwise nop;\n                        end\nend\n\nif w1 = \"?\" then do\n                 select\n                 when panel = \"DDALL\" then panel = \"$DDALL\"\n                 when panel = \"DDBR\"  then panel = \"$DDBR\"\n                 when panel = \"DDED\"  then panel = \"$DDED\"\n                 end\n                 do until rc > 0\n                     \"DISPLAY PANEL(\"panel\")\"\n                     end\n                 exit\n                 end\n\nparse var w1 ddname \"(\" member \")\"\n\nif ddname = \"LINKLIST\" | ddname = \"LPALIST\" then call special\n\n\"VGET (ZSCREEN)\"\n\ntable = \"DT\"zscreen||random()\n\n\"CONTROL ERRORS RETURN\"\n\n\"TBCREATE\" table \"NAMES(WDSN ACT) NOWRITE REPLACE\"\n\ndsn.0 = 0\n\nx=ddlist(\"dsn.\",ddname,member)\n\nreturn_code = x\n\ndo i = 1 to dsn.0\n   wdsn = dsn.i\n   ISPEXEC \"TBADD\" table\n   end\n\nif ddname = \"LINKLIST\" | ddname = \"LPALIST\" then\n      Address TSO \"FREE F(\"ddname\")\"\n\nzedsmsg = \"\"\nzedlmsg = \"\"\n\nselect\n  when return_code = 0 then call doit\n  when return_code = 4 then do\n       \"TBEND\" table\n       zedlmsg = \"No data sets matched the selection criteria\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  when return_code = 8 then do\n       \"TBEND\" table\n       zedlmsg = \"Invalid parm passed to the DDLIST program\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  when return_code = 12 then do\n       \"TBEND\" table\n       if ddname = \"EDIT\" then do\n          zedlmsg = \"DDED Requires that a DDNAME be specified\"\n          end\n       if ddname = \"BROWSE\" then do\n          zedlmsg = \"DDBR Requires that a DDNAME be specified\"\n          end\n       if zedlmsg = \"\" then\n          zedlmsg = \"The requested DDNAME:\" ddname \"is not currently allocated\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  when return_code = 16 then do\n       \"TBEND\" table\n       zedlmsg = \"The ARL returned by the RDJFCB macro is invalid\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  when return_code = 20 then do\n       \"TBEND\" table\n       zedlmsg = \"No parm was passed to the DDLIST program\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  when return_code = 24 then do\n       \"TBEND\" table\n       zedlmsg = \"The requested ISPF Table\" table \"was not open\"\n       \"SETMSG MSG(ISRZ000)\"\n       end\n  otherwise\n       say \"Invalid return code from DDLIST of\" return_code\nend\nexit return_code\n\ndoit:\nparse value \"0 0\" with lc crp\n\nif w2 = \"EDIT\" | w2 = \"BROWSE\" then do\n   \"TBQUERY\" table \"ROWNUM(\"rownum\")\"\n     if rownum = 1 then do\n                      \"TBTOP\" table\n                      \"TBSKIP\" table \"NUMBER(1)\"\n                      lc = 2\n                      sel = \"S\"\n                      end\nend\n\nDo until lc > 4\n   if lc = 0 then do\n                   sel = \"\"\n                   \"TBTOP\" table\n                   \"TBSKIP\" table \"NUMBER(\"crp\")\"\n                   \"TBDISPL\" table \"PANEL(\"panel\")\"\n                   end\n             else if lc = 4 then do\n                   sel = \"\"\n                   \"TBDISPL\" table\n                   end\n   lc = rc\n   crp = ztdtop\n   select\n        when sel = \"B\" then do\n                       \"BROWSE DATASET('\"wdsn\"')\"\n                       src = rc\n                       call bract\n                       call tbput\n                       end\n        when sel = \"S\" then do\n                       defcmd \"DATASET('\"wdsn\"')\"\n                       src = rc\n                       call sact\n                       call tbput\n                       end\n        when sel = \"E\" then do\n                       \"EDIT DATASET('\"wdsn\"')\"\n                       src = rc\n                       call edact\n                       call tbput\n                       end\n        when sel = \"P\" then do\n                       parse value wdsn with xdsn \"(\" mem \")\"\n                       if length(mem) > 0 then\n                          Address TSO \"PDSE '\"xdsn\"' ML\" mem\n                       else\n                          Address TSO \"PDSE '\"xdsn\"'\"\n                       act = \"PDS Command\"\n                       call tbput\n                       end\n        when sel = \"I\" then do\n                       Address TSO \"%DDNINFO '\"wdsn\"'\"\n                       act = \"Info\"\n                       call tbput\n                       end\n        when length(sel) = 0 then nop\n        otherwise           x = prompt(\"on\")\n                            Address TSO sel \"'\"wdsn\"'\"\n                            x = prompt(\"off\")\n                            act = sel\n                            call tbput\n        end\nend\n\"TBEND\" table\nreturn\n\ntbput:\n   \"TBPUT\" table\n   act = \"\"\n   return\n\nspecial:\n\nddn = \"\"\n\nif ddname = \"LPALIST\" then do\n/* REXX - List the current LPALST */\n@CVT    = STORAGE(10,4)                      /* L R1,CVTPTR             */\n@SMEXT  = STORAGE(D2X(C2D(@CVT)+1196),4)     /* L R1,CVTSMEXT-CVTMAP(R1 */\n@EPLPS  = STORAGE(D2X(C2D(@SMEXT)+56),4)     /* L R1,CVTEPLPS-CVTVSTGX( */\nLPAC    = C2D(STORAGE(D2X(C2D(@EPLPS)+4),4)) /* L R1,LPATCNT(R1)     */\n@EPLPS  = D2X(C2D(@EPLPS)+8)                 /* LA R1,LPATNTRY(R1)      */\ndo i = 1 TO LPAC\n   ddw = STORAGE(D2X(X2D(@EPLPS)+1),44)\n   ddn = ddn \"'\"strip(ddw)\"'\"\n   @EPLPS = D2X(X2D(@EPLPS)+45)              /* Bump to next 45 byte ent*/\n   end\n   call doalloc\n   return\nend\n\n\nif ddname = \"LINKLIST\" then do\n/* REXX - List the current LNKLST */\n@CVT    = STORAGE(10,4)                     /* L R1,CVTPTR             */\n@LLTA   = STORAGE(D2X(C2D(@CVT)+1244),4)    /* L R1,CVTLLTA-CVTMAP(R1) */\nLNKC    = C2D(STORAGE(D2X(C2D(@LLTA)+4),4)) /* L R1,LLTCOUNT(R1)     */\n@LLTA   = D2X(C2D(@LLTA)+8)                 /* LA R1,LLTENTRY(R1)      */\ndo i = 1 TO LNKC\n   ddw = storage(d2x(x2d(@llta)+1),44)\n   ddn = ddn \"'\"strip(ddw)\"'\"\n   @LLTA = D2X(X2D(@LLTA)+45)               /* Bump to next 45 byte ent*/\n   end\n   call doalloc\n   return\nend\n\nsact:\n     if defcmd = \"BROWSE\" then call bract\n                          else call edact\n     return\n\nbract:\n  select\n     when src = 12 then act = \"0 length data\"\n     when src = 14 then act = \"Member not found\"\n     when src = 16 then act = \"No members\"\n     when src = 20 then act = \"Severe error\"\n     otherwise act = \"Browse\"\n     end\n  return\n\nedact:\n  select\n     when src = 4  then act = \"Data not saved\"\n     when src = 14 then act = \"Member in use\"\n     when src = 16 then act = \"No members \"\n     when src = 20 then act = \"Severe error\"\n     otherwise act = \"Edit\"\n     end\n  return\n\ndoalloc:\n  x = msg(\"off\")\n  Address TSO \"ALLOC FILE(\"ddname\") DS(\"ddn\") SHR\"\n  return\n+/ ADD NAME=FREEALL  0102-90183-90183-0829-00045-00045-00000-$A1238\n/*  rexx  */\n\nx = outtrap(\"la.\",\"*\")\n\n\"LISTALC STATUS SYSNAMES\"\n\nx = outtrap(\"off\")\n\ndo i = 1 to la.0\n   if substr(la.i,1,1) = \"*\" then do\n             dsname = strip(substr(la.i,2,44))\n             i = i + 1\n             call freeit\n             iterate\n             end\n   if substr(la.i,1,1) \u00ac= \" \" then do\n             dsname = strip(substr(la.i,1,44))\n             i = i + 1\n             call freeit\n             end\n   end\n\n\nexit\n\nfreeit:\n   ddname = Strip(substr(la.i,3,8))\n   if length(ddname) = 0 then return\n      select\n        when ddname = \"SYSPROC\"  then return\n        when ddname = \"SYSEXEC\"  then return\n        when ddname = \"SYSHELP\"  then return\n        when ddname = \"TASKLIB$\" then return\n        when ddname = \"TASKLIB@\" then return\n        when ddname = \"SMPTLIB\"  then return\n        when ddname = \"SMPTABL\"  then return\n        when ddname = \"SUBCHKDD\" then return\n        when ddname = \"EDCHKDD\"  then return\n        when ddname = \"IPCMLIB\"  then return\n        when ddname = \"IPCPLIB\"  then return\n        when ddname = \"IPCTLIB\"  then return\n        when ddname = \"ISRCFIL\"  then return\n        otherwise \"FREE FILE(\"ddname\")\"\n        end\n   return\n+/ ADD NAME=KDDN     0109-90176-90206-1335-00067-00069-00000-$A1238\n/*  rexx  */\n\narg opts\n\nsignal on error\n\nda. = \"\"\ndd. = \"\"\nda.0 = 0\n\nif pos(\")\",opts) > 0 then do\n   parse var opts \"(\" words \")\" option\n   end\n   else do\n        words  = word(opts,1)\n        option = word(opts,2)\n        end\n\nc = words(words)\ndo i = 1 to c\n   dsn = strip(word(words,i))\n   if substr(dsn,1,1) = \"'\" then da.i = dsn\n      else da.i = sysvar(syspref)\".\"dsn\n   da.0 = da.0 + 1\n   end\n\nx = outtrap(\"la.\",\"*\")\n\n\"LISTALC STATUS SYSNAMES\"\n\nx = outtrap(\"off\")\n\nsortdd = \" \"\ncnt    = 0\nj = 1\n\ndo i = 1 to la.0\n   if substr(la.i,1,3) = \"--D\" then iterate i\n   if word(la.i,1)     = \"TERMFILE\" then iterate\n   if substr(la.i,1,5) \u00ac= \"     \" then do\n      dsname = word(la.i,1)\n      i = i + 1\n      if substr(la.i,3,1) \u00ac= \" \" then do\n                ddname = word(la.i,1)\n                cnt = 1\n                end\n                else cnt = cnt + 1\n      dd.j = dsname cnt ddname\n      j = j + 1\n      end\nend\n\ndo i = 1 to j-1\n   do k = 1 to da.0\n      if word(dd.i,1) = da.k then do\n         parse value dd.i with w1 w2 w3\n         say w1 \"Allocated to:\"\n         if w2 = 1 then say w3\n                   else say w3  w2 \"in Concatentation\"\n         end\n   end\nend\nexit\n\nerror:   say sourceline(sigl)\n         trace \"?Results\"\n         nop\n+/ ADD NAME=KDSN     0113-90173-90214-1212-00089-00037-00000-$A1238\n/*  Rexx Procedure to replace the KDSN TSO Command */\n\narg w1 option\n\nparse upper var w1 ddname \"(\" member \")\"\n\nif length(member) > 0 then do\n   say \"Member name is not allowed for the KDSN command\"\n   exit\n   end\n\nif wordpos(\"DEBUG\",option)   > 0 then trace ?a\nif wordpos(\"SAVE\",option)    > 0 then save = \"yes\"\nif wordpos(\"REPLACE\",option) > 0 then replace = \"yes\"\n\nif save = \"yes\" then do\n   if replace  = \"yes\" then do\n      say \"Error in KDSN options, both REPLACE and SAVE specified\"\n      exit\n      end\n   do cnt = 1 to 999 by 1\n     table = \"KDSN\"cnt\n     x = listdsi(table \"FILE\")\n     if (sysreason = 0) | (sysreason = 27) then iterate\n        else leave\n     end\n    \"ALLOC F(\"table\") UNIT(SYSVIO) SPACE(10,10) TRACKS\",\n           \"RECFM(V B) LRECL(60) BLKSIZE(0)\"\n\n    x = ddlist(\"kd.\",ddname)\n\n    return_code = x\n\n    if return_code > 0 then do\n       \"free f(\"table\")\"\n       signal exit\n       end\n    else do\n         t.0 = 1\n         t.1 = substr(ddname,1,8)\n         do i = 1 to kd.0\n         j = t.0 + 1\n         t.0 = j\n         t.j = kd.i\n         end\n         \"execio * diskw\" table \"(finis stem t.\"\n         end\n    exit\nend\nif replace = \"yes\" then do\n  if save = \"yes\" then do\n     say \"Error in KDSN options, both REPLACE and SAVE specified\"\n     exit\n  end\n   do cnt = 1 to 999 by 1\n     table = \"KDSN\"cnt\n     x = listdsi(table \"FILE\")\n     if (sysreason = 0) | (sysreason = 27) then\n        \"EXECIO * DISKR\" table \"(FINIS STEM tk.\"\n     if tk.1 = ddname then leave\n   end\n   dsname = \"\"\n   do i = 2 to tk.0\n       dsname = dsname\" '\"tk.i\"' \"\n   end\n   \"ALLOC F(\"ddname\") SHR REU DS(\"dsname\")\"\n   \"FREE  F(\"table\")\"\n   if rc <> \"0\" then signal exit\n   exit\nend\nelse do\n\n    x = ddlist(\"tk.\",ddname)\n\n    return_code = rc\n    if return_code = 4 then say substr(ddname,1,8) \"NOT ALLOCATED\"\n    if return_code > 4\n              then say substr(ddname,1,8) \"NOT ALLOCATED\"\n    if return_code > 0 then signal exit\n\n    say substr(ddname,1,8) \"ALLOCATED TO:\"\n\n    do i = 1 to tk.0\n       say tk.i\n       end\n\nend\nexit:\n exit 0\n+/ ADD NAME=KDSNA    0110-90173-90214-0933-00089-00037-00000-$A1238\n/*  Rexx Procedure to replace the KDSN TSO Command */\n\nparse arg w1 option\n\nparse upper var w1 ddname \"(\" member \")\"\n\ndo while option <> \"\"\n   parse upper value option with curopt option\n\n   select\n      when abbrev(curopt,deb) then trace ?a\n      when abbrev(curopt,sav) then save  = \"yes\"\n      when abbrev(curopt,rep) then replace = \"yes\"\n   end\nend\n\nif save = \"yes\" then do\n   if replace  = \"yes\" then do\n      say \"error in options, both replace and save specified\"\n      exit\n   end do\n   do cnt = 1 to 999 by 1\n     table = \"kdsn\"cnt\n     \"whatif \"table\" allocated\"\n     wf_rc = rc\n     if wf_rc <> 0 then leave\n   end\n    \"ALLOC F(\"table\") UNIT(SYSVIO) SPACE(10,10) TRACKS\",\n           \"RECFM(V B) LRECL(60) BLKSIZE(0)\"\n\n    if length(member) = 0 then\n       x = ddnlist(\"kd.\",\"ddname\")\n       else\n       x = ddnlist(\"kd.\",ddname,member)\n\n    return_code = x\n\n    if return_code > 0 then do\n     \"free f(\"table\")\"\n     signal exit\n    end\n    else do i = 1 to kd.0\n         if i = 1 then Queue substr(ddname,1,8)substr(member,1,8)\n                  else Queue   kd.i\n         if kd.0 < i then\n            \"execio 1 diskw\" table\n            else\n            \"execio 1 diskw\" table \"(finis\"\n         end\n    exit\nend\nif replace = \"yes\" then do\n  if save = \"yes\" then do\n     say \"error in options, both replace and save specified\"\n     exit\n  end\n   do cnt = 1 to 999 by 1\n     table = \"kdsn\"cnt\n     \"whatif \"table\" allocated\"\n     wf_rc = rc\n     if wf_rc = 0 then \"EXECIO * DISKR\" table \"(FINIS STEM tk.\"\n     if tk.1 = ddname then leave\n   end\n   do i = 2 to tk.0\n       dsname = dk.i\" \"\n   end\n   \"ALLOC F(\"DDNAME\") SHR REU DS(\"DSNAME\")\"\n   if rc <> \"0\" then signal exit\n   exit\nend\nelse do\n\n    x = ddlist(\"tk.\",ddname,member)\n\n    return_code = rc\n    if return_code = 4 then say substr(ddname,1,8) \"NOT ALLOCATED\"\n    if return_code > 4\n              then say substr(ddname,1,8) \"NOT ALLOCATED\"\n    if return_code > 0 then signal exit\n\n    say substr(ddname,1,8) \"ALLOCATED TO:\"\n\n    do i = 1 to tk.0\n       say tk.i\n       end\n\nend\nexit:\n nop\n+/ ADD NAME=KLIB     0105-90174-90213-1214-00029-00024-00000-$A1238\n/*  Rexx Procedure to replace the KLIB TSO Command */\n\narg w1 option\n\nparse var w1 ddname \"(\" member \")\"\n\nif length(member) > 0 then\n   x=ddlist(\"tk.\",ddname,member)\n   else\n   x=ddlist(\"tk.\",ddname)\n\nreturn_code = x\n\nselect\n  when return_code = 0 then signal doit\n  when return_code = 4 then\n         say ddname \" DATASETS SEARCHED -  \" member \"NOT FOUND\"\n  when return_code > 4 then\n       say substr(ddname,1,8)  \"NOT ALLOCATED\"\n  otherwise exit\nend\nexit\n\ndoit:\nsay \"FOUND IN:\"\n\ndo i = 1 to tk.0\n   say tk.i\n   end\n+/ ADD NAME=LA       0111-90169-90214-0705-00099-00060-00000-$A1238\n/*  rexx  */\n\nx = outtrap(\"la.\",\"*\")\n\n\"LISTALC STATUS SYSNAMES\"\n\nx = outtrap(\"off\")\n\nAddress ISPEXEC\n\n\"VGET ZSCREEN\"\ntable = \"LA\"zscreen||random()\n\n\"TBCREATE \" table ,\n        \"NAMES(DDNAME DSNAME VOLUME SORTDD) NOWRITE REPLACE\"\n\nsortdd = \" \"\ncnt    = 0\nj = 1\n\ndo i = 1 to la.0\n   if substr(la.i,1,3) = \"--D\" then iterate i\n   if word(la.i,1)     = \"TERMFILE\" then iterate\n   if substr(la.i,1,5) \u00ac= \"     \" then do\n      dsname = word(la.i,1)\n      if left(dsname,1) = \"*\" then dsname = substr(dsname,2,length(dsname)-1)\n      i = i + 1\n      if substr(la.i,3,1) \u00ac= \" \" then do\n                ddname = word(la.i,1)\n                cnt = 1\n                end\n                else cnt = cnt + 1\n      dd.j = dsname cnt ddname\n      j = j + 1\n      end\nend\n\ndo i = 1 to j-1\n   parse value dd.i with dsname cnt ddname\n   sortdd = ddname||cnt\n   if cnt > 1 then\n              ddname = \"\"\n   x = listdsi(\"'\"dsname\"'\")\n   volume = sysvolume\n   \"TBADD \" table\n   end\n\nlc = 0\ncrp = 0\n\n\"TBSORT\" table \"FIELDS(SORTDD C,A)\"\n\nDo until lc > 4\n   sel = \"\"\n   if lc = 0 then do\n                   \"TBTOP\" table\n                   \"TBSKIP\" table \"NUMBER(\"crp\")\"\n                   \"TBDISPL\" table \"PANEL(LA)\"\n                   end\n             else\n             \"TBDISPL\" table\n   lc = rc\n   crp = ztdtop\n\n   \"CONTROL ERRORS RETURN\"\n   select\n   when sel = \"B\" then \"BROWSE DATASET('\"dsname\"')\"\n   when sel = \"E\" then \"EDIT   DATASET('\"dsname\"')\"\n   when sel = \"F\" then do\n                       if length(ddname) > 0 then do\n                          x = msg(\"off\")\n                          Address TSO \"FREE FILE(\"ddname\")\"\n                          if rc = 0 then\n                             \"TBDELETE\" table\n                             else call domsg1\n                          end\n                          else call domsg2\n                          x = msg(\"on\")\n                       end\n   when sel = \"P\" then Address TSO \"PDSE '\"dsname\"'\"\n   otherwise nop;\n   end\nend  /* end of the do until loop */\n\n\"TBEND\" table\nexit\n\nDomsg1:\n  zedsmsg = \"\"\n  zedlmsg = \"Unable to FREE requested file\" ddname\n  \"SETMSG MSG(ISRZ000)\"\n  return\n\nDomsg2:\n  zedsmsg = \"\"\n  zedlmsg = \"You may not FREE a data set that\",\n            \"is part of a concatenation\" dsname\n  \"SETMSG MSG(ISRZ000)\"\n  return\n+/ ADD NAME=TSOTRAP  0100-90209-90209-1447-00047-00047-00000-$A1238\n/* ---------------------  rexx procedure  ---------------------- */\n/* Name:      TSOTRAP                                            */\n/*                                                               */\n/* Function:  This Rexx procedure will accept any TSO command    */\n/*            (including clists and other Rexx procedures)       */\n/*            that output to the terminal and trap the output    */\n/*            and then display the results using ISPF Browse.    */\n/*                                                               */\n/* Syntax:    %TSOTRAP tso-command options                       */\n/*                                                               */\n/* Author:    Lionel B. Dyck                                     */\n/*            Rockwell International                             */\n/*            P.O. Box 2515                                      */\n/*            Seal Beach, California 90740                       */\n/*            (213) 797-1125                                     */\n/*            IBMLINK:  ROK2027                                  */\n/*                                                               */\n/* History:   07/23/90 - Rexx procedure created.                 */\n/*                                                               */\n/* ------------------------------------------------------------- */\n\narg command\n\nif length(command) = 0 then do\n   say \"Error:  Use of TSOTRAP requires the specification of\"\n   say \"        a TSO command whose results will be captured\"\n   say \"        and displayed using ISPF Browse.\"\n   say \"        (e.g.  %TSOTRAP LISTC)\"\n   exit 12\n   end\n\nx = outtrap(\"trap.\",\"*\")\n\ncommand\n\nx= outtrap(\"off\")\n\nAddress ISPEXEC \"VGET (ZTEMPF)\"\n\ndd = \"TP\"random()\n\n\"ALLOC F(\"dd\") DS('\"ztempf\"') SHR\"\n\n\"EXECIO * DISKW\" dd \"(FINIS STEM trap.\"\n\nAddress ISPEXEC \"BROWSE DATASET('\"ztempf\"')\"\n\"FREE F(\"dd\")\"\n./ ADD NAME=MACROS   0101-90213-90213-1226-00165-00165-00000-$A1238\n+/   ADD NAME=$PROLOG\n         MACRO\n&LABEL   $PROLOG &LV=0,&GM=Y\n.**********************************************************************\n.*\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA\n.*                                             REG 10 IS BASE\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES\n.*\n.**********************************************************************\n         LCLA  &AA,&AB,&AC\n         GBLB  &PRORG\n         GBLC  &PROGM\n&AC      SETA  4096\n&LABEL   CSECT\n         B     32(R15)             BRANCH AROUND\n         DC    AL1(26)\n         DC    CL8'&LABEL'         CSECT NAME\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\n         CNOP  0,4                 ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING &LABEL,R12          INFORM ASSEMBLER\n         AIF   (&LV GT 4023).MERR\n         AIF   ('&GM' EQ 'N').NOGM\n&PROGM   SETC  'GETMAIN'\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER\n         AIF   (&LV+72 LE 256).XC2\n         AIF   (&LV+72 LE 512).XC1\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         AGO   .STORE\n.XC1     ANOP\n         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA\n         AGO   .STORE\n.XC2     ANOP\n         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA\n         AGO   .STORE\n.NOGM    ANOP\n         CNOP  0,4\n         LA    R1,SAVE&SYSNDX\n         B     *+76\nSAVE&SYSNDX DC 18F'0'\n.STORE   ANOP\n         ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R11             SET SAVEAREA POINTER\n         AIF   (N'&SYSLIST EQ 0).MEND\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG\n         DROP  R12                 DROP ASSUMED BASE REG\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER\n.SKIPIT  ANOP\n&AA      SETA  2\n.LOOP    ANOP\n         AIF   (&AA GT N'&SYSLIST).MEXIT\n&AB      SETA  &AA-1\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER\n&AC      SETA  &AC+4096\n&AA      SETA  &AA+1\n         AGO   .LOOP\n.MEXIT   ANOP\n         AIF   (&PRORG).MEX2\n         SPACE\n         $REGS\n         SPACE\n.MEX2    ANOP\n&AA      SETA  &LV+72\n         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'\n         MEXIT\n.MEND    ANOP\n         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'\n         AGO   .MEXIT\n.MERR    ANOP\n         MNOTE 12,'LV > 4023 - REQUEST IGNORED'\n         AGO   .MEXIT\n         MEND\n+/   ADD NAME=$EPILOG\n         MACRO\n&LABEL   $EPILOG &RC\n         GBLC  &PROGM\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         AIF   ('&PROGM' NE 'GETMAIN').NOFREE\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         AGO   .LM\n.NOFREE  ANOP\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n.LM      ANOP\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RC EQ 'O').SPEC\n         LA    R15,&RC             SET RETURN CODE\n.SPEC    ANOP\n         BR    R14                 RETURN TO CALLER\n         MEND\n+/   ADD NAME=$REGS\n         MACRO\n         $REGS\n         GBLB  &PRORG\n         AIF   (&PRORG).MEX2\n&PRORG   SETB  1\n SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n SPACE\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nREG5     EQU   5\nREG6     EQU   6\nREG7     EQU   7\nREG8     EQU   8\nREG9     EQU   9\nREG10    EQU   10\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\n SPACE\n.MEX2    ANOP\n       MEND\n./ ADD NAME=PANELS                                 02AUG90 15.53.14\n+/ ADD NAME=$DDALL   0106-90173-90184-1448-00034-00029-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   \u00ac type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ! type(output) intens(low ) caps(off) just(asis ) color(white)\n   | type(text  ) intens(high) color(white)\n   ` type(text) intens(low ) caps(off) just(asis ) color(turq)\n)Body\n+-------------------------% Data Set List for DDNAME +--------------------------\n%Command ===>_zcmd\n%\n`    The%DDALL`ISPF Dialog provides a selection list of all data sets\n`    currently allocated to a requested DDNAME.  Optionally it will\n`    display a selection list for just those data sets that contain a\n`    specified member.\n`\n`    Note:  DDnames of LINKLIST and LPALIST are reserved and will be used\n`           to display and or search the LINK or LPA list of data sets.\n`\n`    Valid selection options are:\n`         %B`to Invoke ISPF Browse     (%S`is an alias for %B`)\n`         %E`to Invoke ISPF Edit\n`         %I`for Information on the data set\n`         %P`to Invoke the PDS Dialog\n`\n`    Or any valid TSO command may be entered that accepts the data set name\n`    as the first parameter.\n`\n`    Syntax:%DDALL\u00acddname\n`        or:%DDALL\u00acddname(member)\n)Init\n)Proc\n)End\n+/ ADD NAME=$DDBR    0102-90173-90184-1448-00034-00031-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   \u00ac type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ! type(output) intens(low ) caps(off) just(asis ) color(white)\n   | type(text  ) intens(high) color(white)\n   ` type(text) intens(low ) caps(off) just(asis ) color(turq)\n)Body\n%Browse+------------------% Data Set List for DDNAME +--------------------------\n%Command ===>_zcmd\n%\n`    The%DDBR`ISPF Dialog provides a selection list of all data sets\n`    currently allocated to a requested DDNAME.  Optionally it will\n`    display a selection list for just those data sets that contain a\n`    specified member.\n`\n`    Note:  DDnames of LINKLIST and LPALIST are reserved and will be used\n`           to display and or search the LINK or LPA list of data sets.\n`\n`    Valid selection options are:\n`         %S`to Invoke ISPF Browse     (%B`is an alias for %S`)\n`         %E`to Invoke ISPF Edit\n`         %I`for Information on the data set\n`         %P`to Invoke the PDS Dialog\n`\n`    Or any valid TSO command may be entered that accepts the data set name\n`    as the first parameter.\n`\n`    Syntax:%DDBR\u00acddname\n`        or:%DDBR\u00acddname(member)\n)Init\n)Proc\n)End\n+/ ADD NAME=$DDED    0103-90173-90184-1448-00034-00031-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   \u00ac type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ! type(output) intens(low ) caps(off) just(asis ) color(white)\n   | type(text  ) intens(high) color(white)\n   ` type(text) intens(low ) caps(off) just(asis ) color(turq)\n)Body\n%Edit+--------------------% Data Set List for DDNAME +--------------------------\n%Command ===>_zcmd\n%\n`    The%DDED`ISPF Dialog provides a selection list of all data sets\n`    currently allocated to a requested DDNAME.  Optionally it will\n`    display a selection list for just those data sets that contain a\n`    specified member.\n`\n`    Note:  DDnames of LINKLIST and LPALIST are reserved and will be used\n`           to display and or search the LINK or LPA list of data sets.\n`\n`    Valid selection options are:\n`         %S`to Invoke ISPF Edit       (%E`is an alias for %S`)\n`         %B`to Invoke ISPF Browse\n`         %I`for Information on the data set\n`         %P`to Invoke the PDS Dialog\n`\n`    Or any valid TSO command may be entered that accepts the data set name\n`    as the first parameter.\n`\n`    Syntax:%DDED\u00acddname\n`        or:%DDED\u00acddname(member)\n)Init\n)Proc\n)End\n+/ ADD NAME=DDALL    0104-90172-90184-1447-00028-00027-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type( input) intens(high) caps(on ) just(left ) pad('_')\n   @ type(output) intens(high) caps(on ) just(left )\n   \u00ac type(output) intens(low ) caps(off) just(asis )\n)Body\n+---------------------%Data Sets Concatenated to:@ddname  +---------------------\n%Command ===>_zcmd                                            %Scroll ===>_amt +\n%\n+Valid Selections:%B+Browse %E+Edit %I+Info on Dataset %P+PDS %any TSO command+\n+\n%Cmd        Data Set Name                                     Status\n+\n)Model\n!z        +\u00acz                                                \u00acz\n)Init\n  .ZVARS = '(sel wdsn act)'\n  .help  = $DDALL\n  &amt = CSR\n)Reinit\n)Proc\n                                  /* Process )BODY fields here      */\n  If (&ztdsels \u00ac= 0000)           /* If user selected some rows ... */\n                                  /* ... process )MODEL fields here */\n  ver (&sel,nonblank)\n)End\n+/ ADD NAME=DDBR     0108-90172-90184-1447-00028-00026-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type( input) intens(high) caps(on ) just(left ) pad('_')\n   @ type(output) intens(high) caps(on ) just(left )\n   \u00ac type(output) intens(low ) caps(off) just(asis )\n)Body\n%Browse+--------------%Data Sets Concatenated to:@ddname  +---------------------\n%Command ===>_zcmd                                            %Scroll ===>_amt +\n%\n+Valid Selections:%S+Browse %E+Edit %I+Info on Dataset %P+PDS %any TSO command+\n+\n%Cmd        Data Set Name                                     Status\n+\n)Model\n!z        +\u00acz                                                \u00acz\n)Init\n  .ZVARS = '(sel wdsn act)'\n  .help  = $DDBR\n  &amt = CSR\n)Reinit\n)Proc\n                                  /* Process )BODY fields here      */\n  If (&ztdsels \u00ac= 0000)           /* If user selected some rows ... */\n                                  /* ... process )MODEL fields here */\n  ver (&sel,nonblank)\n)End\n+/ ADD NAME=DDED     0105-90172-90184-1447-00028-00027-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type( input) intens(high) caps(on ) just(left ) pad('_')\n   @ type(output) intens(high) caps(on ) just(left )\n   \u00ac type(output) intens(low ) caps(off) just(asis )\n)Body\n%Edit+----------------%Data Sets Concatenated to:@ddname  +---------------------\n%Command ===>_zcmd                                            %Scroll ===>_amt +\n%\n+Valid Selections:%S+Edit %B+Browse %I+Info on Dataset %P+PDS %any TSO command+\n+\n%Cmd        Data Set Name                                     Status\n+\n)Model\n!z        +\u00acz                                                \u00acz\n)Init\n  .ZVARS = '(sel wdsn act)'\n  .help  = $DDED\n  &amt = CSR\n)Reinit\n)Proc\n                                  /* Process )BODY fields here      */\n  If (&ztdsels \u00ac= 0000)           /* If user selected some rows ... */\n                                  /* ... process )MODEL fields here */\n  ver (&sel,nonblank)\n)End\n+/ ADD NAME=DDINFO   0125-88111-90181-1535-00099-00085-00000-$A1238\n)ATTR\n @ TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW)\n | TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   CAPS(OFF)\n \u00ac TYPE(OUTPUT) INTENS(HIGH) COLOR(RED)    CAPS(OFF)\n + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN)\n ! TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN)  CAPS(OFF)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n ~ TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n)BODY expand(\u00a6\u00a6) lmsg(ldsilmsg)\n%-\u00a6-\u00a6- ~LISTDSI: List Dataset Information% -\u00a6-\u00a6-\n%Command ===>_ZCMD                                          ~SYS variables?_LDV~\n+                                                           ~DirectoryInfo?_DYN~\n~DSNAME  ===>_LDSIDSN                                       ~\n~VOLUME  ===>_VOLUME+\n+Full dsname:@LDSIQDSN\n+Volume Serial Id:      @ldsivol          +Creation Date:           @ldsicdte\n+Unit Type of Volume:   @ldsiunit         +Last Referenced Date:    @ldsildte\n+Data Set Orgination:   @ldsidorg         +Expiration Date:         @ldsixdte\n+Record Format:         @ldsircfm         +OS Password Protection:  @ldsipswd\n+Logical Record Length: @ldsilrcl         +RACF Indication:         @ldsiracf\n+Block Size:            @ldsibsiz         +Change Status:           @ldsichng\n+Key Length:            @ldsikeyl         +Trks/Cyl for volume:     @ldsitpcv\n+Allocation space units:@ldsistyp         +Blks/Trk for volume:     @ldsibptv\n+Allocated Space:       @ldsialoc         !LDSIVDI1                 @ldsiadir\u00acZ\n+Allocation Used:       @ldsiused         !LDSIVDI2                 @ldsiudir\u00acZ\n+Primary Allocation:    @ldsiprim         !LDSIVDI3                 @ldsimems\u00acZ\n+Secondary Allocation:  @ldsisdry         +LISTDSI Return Code:     @ldsirc\n+Allocated Extents:     @ldsiexts         +LISTDSI Reason Code:     @ldsireas\n|ldsiem0                                          +\u00acLDSIXDER\n\u00acldsilmsg\n@ldsiem1\n@ldsiem2\n                          +Press%END+to Exit LISTDSI+\n)INIT\n .HELP = $LISTDSI\n &DYN = TRANS(&NODIR NODIR,NO ' ',YES *,NO)\n &LDV = TRANS(&LDV     YES,YES        *,NO)\n\n IF (&LDSILOCK  = LOCK)  .CURSOR = ZCMD  .ATTR(LDSIDSN) = 'TYPE(OUTPUT)'\n IF (&LDSILOCK \u00ac= LOCK)  .CURSOR = LDSIDSN\n\n IF (&LDSIVDIR = &Z)        &LDSIDIRZ = NOSHOW\n IF (&LDSIVDIR = DIRECTORY) &LDSIDIRZ =   SHOW\n IF (&LDSIDORG \u00ac= PO,POU)   &LDSIDIRZ = NOSHOW\n IF (&LDSIDORG = &Z)\n   IF (&LDSIDSN = &Z)       &LDSIDIRZ = SHOW\n\n IF (&LDSIDIRZ = NOSHOW,&Z)\n   &LDSIVDI1 = &Z\n   &LDSIVDI2 = &Z\n   &LDSIVDI3 = &Z\n\n IF (&LDSIDIRZ = SHOW)\n   &LDSIVDI1 = 'Directory Blks Allocated:'\n   &LDSIVDI2 = 'Directory Blks Used:'\n   &LDSIVDI3 = 'Number of Members:'\n\n IF (&LDSIFDSN  = &Z)     &LDSIQDSN = &Z\n IF (&LDSIFDSN \u00ac= &Z)     &LDSIQDSN = &LDSIFDSN   /* '''&LDSIFDSN''' */\n IF (&LDSISTAT  = OK)     &LDSIEM0  = &Z\n IF (&LDSISTAT \u00ac= OK)     &LDSIEM0  = '&LDSISTAT'\n\n &SHORT = &Z   &LONG = &Z\n\n IF (&LDSIRC =  4)\n   &LONG = 'Some dsn info is NOT avail. +\n            LISTDSI info (other that directory info) is valid.'\n   .MSG = SYS010\n\n IF (&LDSIRC = 16)\n   &LONG = 'SEVERE Error occured. +\n            NONE of displayed LISTDSI data can be considered valid.'\n   .MSG = SYS010\n\n .ZVARS = '(LDSIXD1,LDSIXD2,LDSIXD3)'\n\n &LDSIXD1 = &Z   &LDSIXD2 = &Z  &LDSIXD3 = &Z  &LDSIXDER = &Z\n\n IF (&LDSIDORG = PO,POU)\n   IF (&LDSIADIR = 0)\n     &LDSIXD1 = '*'  &LDSIXD2 = '*'  &LDSIXD3 = '*'\n     &LDSIXDER = '* Directory is unavailable.'\n\n)PROC\n\n VER (&LDSIDSN,NB,DSNAME)\n\n &LDV = TRANS(TRUNC(&LDV,1) Y,YES N,NO *,*)\n VER (&LDV,LIST,YES,NO)\n IF (&LDV = YES)    &PANEL = DDINFO2\n IF (&LDV = NO,&Z)  &PANEL = DDINFO\n\n &DYN = TRANS(TRUNC(&DYN,1) Y,YES N,NO *,*)\n VER (&DYN,LIST,YES,NO)\n IF (&DYN = YES)    &NODIR = &Z\n IF (&DYN = NO,&Z)  &NODIR = 'NODIR'\n\n &VLDSISVN = &LDV      VPUT (VLDSISVN) PROFILE\n)END\n+/ ADD NAME=DDINFO2  0126-88111-90181-1535-00099-00085-00000-$A1238\n)ATTR\n @ TYPE(OUTPUT) INTENS(HIGH) COLOR(YELLOW)\n | TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)   CAPS(OFF)\n \u00ac TYPE(OUTPUT) INTENS(HIGH) COLOR(RED)    CAPS(OFF)\n + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN)\n ! TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN)  CAPS(OFF)\n % TYPE(TEXT)   INTENS(HIGH) COLOR(WHITE)\n ~ TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n)BODY expand(\u00a6\u00a6) lmsg(ldsilmsg)\n%-\u00a6-\u00a6- ~LISTDSI: List Dataset Information% -\u00a6-\u00a6-\n%Command ===>_ZCMD                                          ~SYS variables?_LDV~\n+                                                           ~DirectoryInfo?_DYN~\n~DSNAME  ===>_LDSIDSN                                       ~\n~VOLUME  ===>_VOLUME+\n+SYSDSNAME:@LDSIQDSN\n+           SYSVOLUME:@ldsivol                         +SYSCREATE:@ldsicdte\n+             SYSUNIT:@ldsiunit                       +SYSREFDATE:@ldsildte\n+            SYSDSORG:@ldsidorg                        +SYSEXDATE:@ldsixdte\n+            SYSRECFM:@ldsircfm                      +SYSPASSWORD:@ldsipswd\n+            SYSLRECL:@ldsilrcl                         +SYSRACFA:@ldsiracf\n+          SYSBLKSIZE:@ldsibsiz                       +SYSUPDATED:@ldsichng\n+           SYSKEYLEN:@ldsikeyl                       +SYSTRKSCYL:@ldsitpcv\n+            SYSUNITS:@ldsistyp                       +SYSBLKSTRK:@ldsibptv\n+            SYSALLOC:@ldsialoc                       !LDSIVDI1   @ldsiadir\u00acZ\n+             SYSUSED:@ldsiused                       !LDSIVDI2   @ldsiudir\u00acZ\n+          SYSPRIMARY:@ldsiprim                       !LDSIVDI3   @ldsimems\u00acZ\n+          SYSSECONDS:@ldsisdry                     +LASTCC or RC:@ldsirc\n+          SYSEXTENTS:@ldsiexts                        +SYSREASON:@ldsireas\n|ldsiem0                                          +\u00acLDSIXDER\n\u00acldsilmsg\n@ldsiem1\n@ldsiem2\n                          +Press%END+to Exit LISTDSI+\n)INIT\n .HELP = $LISTDSI\n &DYN = TRANS(&NODIR NODIR,NO ' ',YES *,NO)\n &LDV = TRANS(&LDV     YES,YES        *,NO)\n\n IF (&LDSILOCK  = LOCK)  .CURSOR = ZCMD  .ATTR(LDSIDSN) = 'TYPE(OUTPUT)'\n IF (&LDSILOCK \u00ac= LOCK)  .CURSOR = LDSIDSN\n\n IF (&LDSIVDIR = &Z)        &LDSIDIRZ = NOSHOW\n IF (&LDSIVDIR = DIRECTORY) &LDSIDIRZ =   SHOW\n IF (&LDSIDORG \u00ac= PO,POU)   &LDSIDIRZ = NOSHOW\n IF (&LDSIDORG = &Z)\n   IF (&LDSIDSN = &Z)       &LDSIDIRZ = SHOW\n\n IF (&LDSIDIRZ = NOSHOW,&Z)\n   &LDSIVDI1 = &Z\n   &LDSIVDI2 = &Z\n   &LDSIVDI3 = &Z\n\n IF (&LDSIDIRZ = SHOW)\n   &LDSIVDI1 = 'SYSADIRBLK:              '\n   &LDSIVDI2 = 'SYSUDIRBLK:         '\n   &LDSIVDI3 = 'SYSMEMBERS:       '\n\n IF (&LDSIFDSN  = &Z)     &LDSIQDSN = &Z\n IF (&LDSIFDSN \u00ac= &Z)     &LDSIQDSN = &LDSIFDSN   /* '''&LDSIFDSN''' */\n IF (&LDSISTAT  = OK)     &LDSIEM0  = &Z\n IF (&LDSISTAT \u00ac= OK)     &LDSIEM0  = '&LDSISTAT'\n\n &SHORT = &Z   &LONG = &Z\n\n IF (&LDSIRC =  4)\n   &LONG = 'Some dsn info is NOT avail. +\n            LISTDSI info (other that directory info) is valid.'\n   .MSG = SYS010\n\n IF (&LDSIRC = 16)\n   &LONG = 'SEVERE Error occured. +\n            NONE of displayed LISTDSI data can be considered valid.'\n   .MSG = SYS010\n\n .ZVARS = '(LDSIXD1,LDSIXD2,LDSIXD3)'\n\n &LDSIXD1 = &Z   &LDSIXD2 = &Z  &LDSIXD3 = &Z  &LDSIXDER = &Z\n\n IF (&LDSIDORG = PO,POU)\n   IF (&LDSIADIR = 0)\n     &LDSIXD1 = '*'  &LDSIXD2 = '*'  &LDSIXD3 = '*'\n     &LDSIXDER = '* Directory is unavailable.'\n\n)PROC\n\n VER (&LDSIDSN,NB,DSNAME)\n\n &LDV = TRANS(TRUNC(&LDV,1) Y,YES N,NO *,*)\n VER (&LDV,LIST,YES,NO)\n IF (&LDV = YES)    &PANEL = DDINFO2\n IF (&LDV = NO,&Z)  &PANEL = DDINFO\n\n &DYN = TRANS(TRUNC(&DYN,1) Y,YES N,NO *,*)\n VER (&DYN,LIST,YES,NO)\n IF (&DYN = YES)    &NODIR = &Z\n IF (&DYN = NO,&Z)  &NODIR = 'NODIR'\n\n &VLDSISVN = &LDV      VPUT (VLDSISVN) PROFILE\n)END\n+/ ADD NAME=LA       0103-90176-90176-0642-00025-00026-00000-$A1238\n)Attr Default(%+_)\n/* % type(text  ) intens(high)              Defaults displayed for */\n/* + type(text  ) intens(low )                   information only  */\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type( input) intens(high) caps(on ) just(left ) pad('_')\n   \u00ac type(output) intens(low ) caps(off) just(left )\n)Body\n+-------------------% List of Currently Allocated Data Set +--------------------\n%Command ===>_zcmd                                            %Scroll ===>_amt +\n%\n+Selection Options: %B+Browse %E+Edit %F+Free %P+PDS/E\n+\n%Sel      DDname    Volume    Dsname\n+\n)Model\n!z+      \u00acz        \u00acz        \u00acz\n)Init\n  .ZVARS = '(sel ddname volume dsname)'\n  &amt = CSR\n)Reinit\n)Proc\n                                  /* Process )BODY fields here      */\n  If (&ztdsels \u00ac= 0000)           /* If user selected some rows ... */\n                                  /* ... process )MODEL fields here */\n)End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFHSM": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"\\x0f\\x00\\x91\"\\x0f\\x12\\x00\\x02G\\x02G\\x00\\x00\\xd7\\xc4\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-08T00:00:00", "modifydate": "1991-08-08T12:00:00", "lines": 583, "newlines": 583, "modlines": 0, "user": "PDS"}, "text": "./ ADD NAME=$README\nDISCLAIMER\n----------\n\nThis code is supplied on an as-is basis.  No warranty is provided.  Use at your\nown risk!  I will try to answer questions though.\n\n                  Bill Horton\n                  Tennessee Eastman Company\n                  Building 284\n                  Kingsport, TN 37662-1973\n\n                  (615) 229-3388\n\nINTRODUCTION\n------------\n\nThis dialog may be used to recover a dataset which has been backed up using\nIBM's DFHSM.  Syntax:\n\n  %VRECOV {LEVEL(level) DSN(dsname) QUIET}\n\n  where \"level\" is the dsname level to be recovered.  If LEVEL is specified,\n  the dialog will generate a list of all datasets matching the specified level,\n  from which the dataset to be recovered can be selected.\n\n  \"dsname\" is the fully qualified name of a dataset to be recovered.  If DSN is\n  specified, the dialog will generate a list of backup version of the datasets\n  from which the desired version can be selected.\n\n  QUIET turns off the \"progress\" messages normally displayed by the dialog.\n\nIf neither LEVEL nor DSN is specified, the dialog will prompt for a dataset\nname/level.\n\nThe dialog may be invoked for a particular dataset by entering:\n\n  %RECOV dsname\n\n  where \"dsname\" is the same as above.\n\nTo invoke the dialog from ISPF 3.4, enter \"%recov\" on the line which\nhas the dataset you want to recover.\n\nINSTALLATION INSTRUCTIONS\n-------------------------\n\n1. Create a PDS from the IEBUPDTE source, if desired, using JCL similar to:\n\n//IEBUPDTE JOB (91004,8),'name       ',CLASS=A,NOTIFY=userid\n//        EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=$\n//SYSUT2   DD  DSN=userid.VRECOV.CNTL,UNIT=SYSDA,SPACE=(TRK,(5,3,45)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=23440),\n//             DISP=(NEW,CATLG)\n//SYSIN    DD  *\n<- the downloaded PC file ->\n/*\n\n2. Copy the message member TECZ00 to your ISPF message library.\n\n3. Copy the panel members VRECOV0-5 to your ISPF panel library.\n\n4. Copy the CLISTs member RECOV and VRECOV to your TSO CLIST library.\n\n5. If desired, create a menu panel entry and / or  ISPF command table entry to\n   invoke the dialog.\n\n./ ADD NAME=VRECOV0\n)BODY EXPAND(\\\\)\n%-\\-\\  RECOVER BACKED UP DATASET  \\-\\-T\n%Command ==>_ZCMD\n+\n Enter complete or partial dataset name below.  DFHSM backup datasets will be\n displayed, from which you can select the source for recover.\n\n   Dataset name%===>_VHSMDD                                        +\n\n     Examples:       ISPF.PROFILE  --> &ZUSER..ISPF.PROFILE                    +\n                     PROCS*        --> datasets beginning &ZPREFIX..PROCS      +\n                     'PABC.DATA'   --> PABC.DATA                               +\n                     *             --> all datasets beginning &ZPREFIX         +\n)INIT\n VGET (VHSMDD) PROFILE\n)PROC\n VER(&VHSMDD,NB)\n IF (.RESP = ENTER)\n   VPUT (VHSMDD) PROFILE\n)END\n./ ADD NAME=VRECOV1\n)ATTR\n @ TYPE(OUTPUT) INTENS(HIGH)\n \u00a2 TYPE(OUTPUT) INTENS(LOW)\n)BODY\n%------------------------  RECOVER BACKED UP DATASET  -------------------------T\n%Command ==>_XCMD                                               %Scroll ==>_VHSS\n+\n D to delete all backup copies of dataset\n S to select dataset for recover\n%|+\n%|                                                          Earliest  Latest\n%V      Dataset Name                              Versions  Backup    Backup\n)MODEL\n_Z\u00a2Z   \u00a2Z                                            \u00a2Z    \u00a2Z        \u00a2Z       +\n)INIT\n  &VARS = '(HSEL VHSMDONE VHSMDSN VHSMNOV VHSM1ST VHSMLAST)'\n  &VHSS = CSR\n  &HSEL = ' '\n)END\n./ ADD NAME=VRECOV2\n)ATTR\n @ TYPE(OUTPUT) INTENS(HIGH)\n \u00a2 TYPE(OUTPUT) INTENS(LOW)\n)BODY EXPAND(\\\\)\n%RECOVER &VHSMDSN \\-\\-T\n%Command ==>_XCMD                                               %Scroll ==>_VHSS\n+\n%D+to%delete+the generation from backup\n%S+to%select+the generation for recover\n%|+\n%|+\n%V Date     Volume Generation  Version  Cataloged?  Action taken\n)MODEL\n_Z\u00a2Z       \u00a2Z     +   \u00a2Z  +     \u00a2Z  +     \u00a2Z  +    \u00a2Z                          +\n)INIT\n  &VARS = '(DSEL VHSMDATE VHSMVOL VHSMGEN VHSMVER VHSMCAT VHSMACT)'\n  &VHSS = CSR\n  &DSEL = ' '\n)END\n./ ADD NAME=VRECOV3\n)BODY EXPAND(\\\\)\n%-\\-\\  RECOVER BACKED UP DATASET  \\-\\-T\n%Command ==>_ZCMD\n+\n Enter/verify recover parameters for &VHSMDSN                                  +\n which was backed up &D as generation &G:                                      +\n\n   Target volume   %===>_TOVOL +(Original volume was &V)                       +\n\n   New dataset name%===>_NDSN                                          +\n\n   Replace existing dataset?%===>_REP+\n)INIT\n &D = &VHSMDATE\n &G = &VHSMGEN\n &V = &VHSMVOL\n)PROC\n VER(&TOVOL,NAME)\n VER(&NDSN,DSNAME)\n VER(&REP,LIST,YES,NO)\n)END\n./ ADD NAME=VRECOV4\n)ATTR\n @ TYPE(TEXT) INTENS(HIGH) HILITE(REVERSE) COLOR(GREEN)\n \u00a6 TYPE(TEXT) INTENS(HIGH) HILITE(REVERSE) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n%-\\-\\  DELETE BACKUP GENERATION  \\-\\-T\n%Command ==>_ZCMD\n+\n Backup generation of &VHSMDSN to be deleted:                                  +\n\n   Generation     ===> &VHSMGEN+\n\n   Version        ===> &VHSMVER+\n\n   Date backed up ===> &VHSMDATE+\n\n   Source volume  ===> &VHSMVOL+\n\n Press the\u00a6Enter+key to delete the backup version\n Press the@End+key to keep the backup version\n)PROC\n VER(&TOVOL,NAME)\n VER(&NDSN,DSNAME)\n VER(&REP,LIST,YES,NO)\n)END\n./ ADD NAME=VRECOV5\n)ATTR\n @ TYPE(TEXT) INTENS(HIGH) HILITE(REVERSE) COLOR(GREEN)\n \u00a6 TYPE(TEXT) INTENS(HIGH) HILITE(REVERSE) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n%-\\-\\  DELETE ALL BACKUP GENERATIONS  \\-\\-T\n%Command ==>_ZCMD\n+\n   Dataset ===> &VHSMDSN                                    +\n\n Press the\u00a6Enter+key to delete%all+backup generations\n Press the@End+key to keep the backup generations\n)END\n./ ADD NAME=RECOV\n         PROC 1 DSN DEBUG\n         %VRECOV DSN(&DSN) &DEBUG\n./ ADD NAME=VRECOV\n         PROC 0 LEVEL(NONE) DSN(NONE) WAIT QUIET DEBUG\n\n         /*-----------------------------------------------------------*/\n         /* CLIST VRECOV                                              */\n         /*                                                           */\n         /* THIS CLIST IS DESIGNED TO BE INVOKED FROM ISPF OPTION 3.4 */\n         /* TO RECOVER A DATASET VIA DFHSM.                           */\n         /*                                                           */\n         /*-----------------------------------------------------------*/\n\n         IF &DEBUG = DEBUG THEN CONTROL LIST CONLIST SYMLIST MSG\n\n         /* GENERATE DSNAME FOR OUTPUT OF HLIST */\n\n         ISPEXEC VGET (ZSCREEN,ZPREFIX)\n         SET ODS = SCREEN&ZSCREEN..DFHSM.LIST\nINIT:    CONTROL NOMSG NOFLUSH\n         DELETE &ODS\n\n         /* INVOKE DFDSS HLIST COMMAND TO GET */\n         /* LIST OF BACKED UP DATASETS        */\n\n         IF &LEVEL \u00ac= NONE +\n         THEN DO\n           SET OPTS = LEVEL(&LEVEL)\n           SET MODE = LEVEL\n           END\n\n         ELSE IF &DSN \u00ac= NONE +\n         THEN DO\n           SET OPTS = DSN('&DSN')\n           SET MODE = DSN\n           END\n\n         ELSE DO\n\n           ISPEXEC DISPLAY PANEL(VRECOV0)\n           IF &LASTCC > 0 THEN EXIT\n\n           IF &SYSINDEX(&STR(*),&VHSMDD) > 0 THEN DO   /* USE \"LEVEL\" */\n\n             SET L = &LENGTH(&STR(&VHSMDD))\n\n             IF &L = 1 THEN SET OPTS = LEVEL(&ZPREFIX)\n\n             ELSE IF &SUBSTR(1:1,&VHSMDD) = &STR(') THEN SET OPTS = +\n             &STR(LEVEL(&SUBSTR(2:&L-2,&VHSMDD))\n\n             ELSE SET OPTS = LEVEL(&ZPREFIX..&SUBSTR(1:&L-1,&VHSMDD))\n\n             SET MODE = LEVEL\n\n             END                                       /* USE \"LEVEL\" */\n\n           ELSE DO                                       /* USE \"DSN\" */\n\n             SET OPTS = DSN(&VHSMDD)\n             SET MODE = DSN\n\n             END                                         /* USE \"DSN\" */\n\n           END\n\n         IF &QUIET \u00ac= QUIET THEN DO\n           SET TECSMSG =\n           SET TECLMSG = DFHSM HLIST COMMAND IN PROGRESS\n           ISPEXEC CONTROL DISPLAY LOCK\n           ISPEXEC DISPLAY MSG(TECZ000)\n           END\n\n         HLIST &OPTS ODS(&ODS) BCDS\n\n         IF &QUIET \u00ac= QUIET THEN DO\n           SET TECSMSG =\n           SET TECLMSG = OUTPUT FROM HLIST COMMAND NOW BEING SCANNED\n           ISPEXEC CONTROL DISPLAY LOCK\n           ISPEXEC DISPLAY MSG(TECZ000)\n           END\n\n         /* CREATE MAIN ISPF TABLE TO HOLD LIST OF DATASETS */\n\n         ISPEXEC TBCREATE VHSMBACK NOWRITE KEYS(VHSMDSN) +\n         NAMES(VHSMNOV VHSMVER VHSMLAST VHSM1ST VHSMTABL VHSMDONE)\n         SET VHSMDSN  =\n         SET VHSMDONE =\n         SET VHSMVER  = 0\n         SET VHSMNOV  = 0\n         SET VHSMLAST = &STR(00/00/00)\n         SET VHSM1ST  = &STR(99/12/31)\n\n         /* ALLOCATE AND OPEN DFHSM OUTPUT DATASET */\n\n         ISPEXEC LMINIT DATAID(LMHSMLST) DATASET(&ODS)\n         ISPEXEC LMOPEN DATAID(&LMHSMLST)\n\n         /* READ FIRST RECORD */\n\n         ISPEXEC LMGET  DATAID(&LMHSMLST) DATALOC(X) MODE(INVAR) +\n           DATALEN(LX) MAXLEN(133)\n         SET GCC = &LASTCC\n         SET VHSMNO = 0\n         SET READ_MORE = LOOKING\n\n         /* READ UNTIL END OF BCDS SECTION (\"----- END OF \") IS FOUND */\n\n         DO WHILE (&GCC = 0 AND &READ_MORE \u00ac= NO)\n\n           /* LOOK FOR BEGINNING OF BCDS SECTION */\n\n           IF &SUBSTR(31:36,&X) = BACKUP +\n           THEN SET READ_MORE = YES\n\n           IF &READ_MORE = YES THEN DO\n\n             /* LOOK FOR NEW DATASET */\n\n             IF &SUBSTR(2:10,&X) = &STR(DSNAME = ) THEN DO\n\n               IF &VHSMNO > 0 THEN DO\n                 ISPEXEC TBADD VHSMBACK\n                 SET VHSMDSN  =\n                 SET VHSMVER  = 0\n                 SET VHSMNOV  = 0\n                 SET VHSMLAST = &STR(00/00/00)\n                 SET VHSM1ST  = &STR(99/12/31)\n                 END\n\n               SET VHSMNO = &VHSMNO + 1\n               SET VHSMDSN = &SUBSTR(11:54,&X)\n               SET VHSMTABL = VHSM&VHSMNO\n               ISPEXEC TBCREATE &VHSMTABL KEYS(VHSMVER) +\n               NAMES(VHSMDSN VHSMVOL VHSMDATE VHSMCAT VHSMGEN VHSMACT)\n               END\n\n             /* LOOK FOR DATASET DETAIL LINE */\n\n             ELSE IF &SUBSTR(2:5,&X) = &Z AND &SUBSTR(6:6,&X) \u00ac= &Z +\n             AND &SUBSTR(6:13,&X) \u00ac= &STR(BACKUP V) +\n             AND &READ_MORE = YES THEN DO\n\n               /* SET SECONDARY TABLE VARIABLES */\n\n               SET VHSMNOV = &VHSMNOV + 1\n\n               SET VHSMVER = &SUBSTR(89:91,&X)\n\n               SET VHSMVOL = &SUBSTR(60:65,&X)\n\n               SET VHSMDATE = &STR(&SUBSTR(68:75,&X))\n\n               IF &STR(&VHSMDATE) > &STR(&VHSMLAST) +\n               THEN SET VHSMLAST = &STR(&VHSMDATE)\n\n               IF &STR(&VHSMDATE) < &STR(&VHSM1ST) +\n               THEN SET VHSM1ST  = &STR(&VHSMDATE)\n\n               IF &SUBSTR(78:80,&X) = YES +\n               THEN SET VHSMCAT = YES\n               ELSE SET VHSMCAT = NO\n\n               SET VHSMGEN = &SUBSTR(83:85,&X)\n\n               SET VHSMACT =\n\n               /* CREATE SECONDARY TABLE ENTRY */\n\n               ISPEXEC TBADD &VHSMTABL\n\n               END\n\n             /* LOOK FOR END OF BCDS SECTION */\n\n             ELSE IF &SUBSTR(2:14,&X) = &STR(----- END OF ) +\n             AND &READ_MORE = YES THEN DO\n               ISPEXEC TBADD VHSMBACK\n               SET READ_MORE = NO\n               END\n\n             END\n\n           /* READ NEXT RECORD */\n\n           ISPEXEC LMGET  DATAID(&LMHSMLST) DATALOC(X) MODE(INVAR) +\n           DATALEN(LX) MAXLEN(133)\n           SET GCC = &LASTCC\n           END\n\n         /* ALL RECORDS READ AND TABLES BUILT */\n         /* DISCARD DFHSM REPORT DATASET */\n\n         ISPEXEC LMCLOSE DATAID(&LMHSMLST)\n         ISPEXEC LMFREE  DATAID(&LMHSMLST)\n\n         IF &VHSMNO = 0 THEN DO\n           SET TECSMSG = NOT BACKED UP\n           SET TECLMSG = NO DATASET MATCHING SEARCH CRITERIA IS +\n                         BACKED UP IN DFHSM\n           ISPEXEC SETMSG MSG(TECZ001)\n           ISPEXEC TBEND VHSMBACK\n           EXIT\n           END\n\n         /* DISPLAY MAIN TABLE */\n\n         ISPEXEC TBTOP   VHSMBACK\n         SET D1CC = 0\n         IF &MODE = LEVEL +\n         THEN DO\n           ISPEXEC TBDISPL VHSMBACK PANEL(VRECOV1)\n           SET D1CC = &LASTCC\n           END\n\n         /* CONTINUE DISPLAYING MAIN TABLE UNTIL END OR RETURN KEY */\n\n         DO WHILE (&D1CC < 8)\n\n           IF &ZTDSELS > 0 OR &MODE \u00ac= LEVEL THEN DO\n\n             IF &HSEL = S +\n             OR &MODE \u00ac= LEVEL THEN DO /* S LINE COMMAND - MAIN TABLE */\n\n               IF &MODE = LEVEL +\n               THEN ISPEXEC CONTROL DISPLAY SAVE\n\n               /* DISPLAY SELECTED SECONDARY TABLE */\n\n               ISPEXEC TBTOP &VHSMTABL\n               ISPEXEC TBDISPL &VHSMTABL PANEL(VRECOV2)\n               SET D2CC = &LASTCC\n\n               /* SPECIFIC DATASET SELECTED FOR ACTION */\n\n               IF &ZTDSELS > 0 THEN DO\n\n                 IF &DSEL = S THEN DO     /* S LINE COMMAND - DS LIST */\n\n                   SET TOVOL =\n                   SET NDSN =\n                   SET REP = NO\n\n                   ISPEXEC DISPLAY PANEL(VRECOV3)\n\n                   IF &LASTCC = 0 THEN DO\n\n                     SET OPTS =\n                     IF &REP = YES THEN SET OPTS = REPLACE\n\n                     IF &VHSMCAT \u00ac= YES +\n                     THEN SET OPTS = &STR(&OPTS FROMVOLUME(&VHSMVOL))\n\n                     IF &NDSN \u00ac= &Z +\n                     THEN SET OPTS = &STR(&OPTS NEWNAME(&NDSN))\n\n                     IF &TOVOL \u00ac= &VHSMVOL AND &TOVOL \u00ac= &Z +\n                     THEN SET OPTS = +\n                     &STR(&OPTS TOVOLUME(&TOVOL) UNIT(3380))\n\n                     CONTROL MSG\n                     SET D = &VHSMDSN\n                     SET G = &VHSMGEN\n                     SET SYSOUTTRAP = 1\n                     HRECOVER '&D' GENERATION(&G) &OPTS\n\n                     IF &LENGTH(&SYSOUTLINE1) >= 8 THEN DO\n                       SET TECSMSG =\n                       SET TECLMSG = &SYSOUTLINE1\n                       IF &SUBSTR(1:8,&TECLMSG) = ARC1007I +\n                       THEN ISPEXEC SETMSG MSG(TECZ000)\n                       ELSE ISPEXEC SETMSG MSG(TECZ001)\n                       END\n\n                     IF &DEBUG \u00ac= DEBUG THEN CONTROL NOMSG\n                     SET VHSMACT  = &STR(RECALL REQUESTED)\n                     ISPEXEC TBMOD &VHSMTABL\n                     SET VHSMDONE = &STR(*SEL)\n                     ISPEXEC TBMOD VHSMBACK\n\n                     END\n\n                   END                    /* S LINE COMMAND - DS LIST */\n\n                 ELSE IF &DSEL = D THEN DO/* D LINE COMMAND - DS LIST */\n\n                   ISPEXEC DISPLAY PANEL(VRECOV4)\n\n                   IF &LASTCC = 0 THEN DO\n\n                     SET OPTS = VERSIONS(&VHSMVER)\n\n                     IF &VHSMCAT \u00ac= YES +\n                     THEN SET OPTS = &STR(&OPTS FROMVOLUME(&VHSMVOL))\n\n                     CONTROL MSG\n                     SET D = &VHSMDSN\n                     SET SYSOUTTRAP = 1\n                     HBDELETE '&D' &OPTS\n\n                     IF &LENGTH(&SYSOUTLINE1) >= 8 THEN DO\n                       SET TECSMSG =\n                       SET TECLMSG = &SYSOUTLINE1\n                       IF &SUBSTR(1:8,&TECLMSG) = ARC1007I +\n                       THEN ISPEXEC SETMSG MSG(TECZ000)\n                       ELSE ISPEXEC SETMSG MSG(TECZ001)\n                       END\n\n                     IF &DEBUG \u00ac= DEBUG THEN CONTROL NOMSG\n                     SET VHSMACT  = &STR(DELETE REQUESTED)\n                     ISPEXEC TBMOD &VHSMTABL\n                     SET VHSMDONE = 1DEL\n                     ISPEXEC TBMOD VHSMBACK\n\n                     END\n\n                   END                    /* D LINE COMMAND - DS LIST */\n\n                 SET DSEL =\n\n                 END\n\n               IF &MODE = LEVEL +\n               THEN ISPEXEC CONTROL DISPLAY RESTORE\n               ELSE SET D1CC = 8\n\n               END                     /* S LINE COMMAND - MAIN TABLE */\n\n             ELSE IF &HSEL = D THEN DO /* D LINE COMMAND - MAIN TABLE */\n\n               ISPEXEC DISPLAY PANEL(VRECOV5)\n\n               IF &LASTCC = 0 THEN DO\n\n                 CONTROL MSG\n                 SET D = &VHSMDSN\n                 SET SYSOUTTRAP = 1\n                 HBDELETE '&D'\n\n                 SET TECSMSG =\n                 SET TECLMSG = &SYSOUTLINE1\n                 IF &SUBSTR(1:8,&TECLMSG) = ARC1007I +\n                 THEN ISPEXEC SETMSG MSG(TECZ000)\n                 ELSE ISPEXEC SETMSG MSG(TECZ001)\n\n                 IF &DEBUG \u00ac= DEBUG THEN CONTROL NOMSG\n                 SET VHSMDONE = &STR(&DEL)\n                 ISPEXEC TBMOD VHSMBACK\n\n                 END\n\n               END                     /* D LINE COMMAND - MAIN TABLE */\n\n             SET HSEL =\n\n             END\n\n           IF &D1CC = 4 THEN DO\n             ISPEXEC TBDISPL VHSMBACK\n             SET D1CC = &LASTCC\n             END\n           ELSE IF &D1CC < 8 THEN DO\n             ISPEXEC TBDISPL VHSMBACK PANEL(VRECOV1)\n             SET D1CC = &LASTCC\n             END\n\n           END\n\n         /* GET TO TOP OF MAIN TABLE, SKIP THROUGH EACH ROW, CLOSING  */\n         /* SECONDARY TABLES.                                         */\n\n         ISPEXEC TBTOP VHSMBACK\n         ISPEXEC TBSKIP VHSMBACK\n         SET SCC = &LASTCC\n         DO WHILE (&SCC = 0)\n           ISPEXEC TBEND &VHSMTABL\n           ISPEXEC TBSKIP VHSMBACK\n           SET SCC = &LASTCC\n           END\n\n         /* CLOSE MAIN TABLE */\n\n         ISPEXEC TBEND VHSMBACK\n\n         IF &LEVEL = NONE AND &DSN = NONE THEN GOTO INIT\n\n         EXIT\n./ ADD NAME=TECZ00\nTECZ000  '&TECSMSG' .ALARM = NO\n'&TECLMSG'\n\nTECZ001  '&TECSMSG' .ALARM = YES\n'&TECLMSG'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPHOST": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91#/\\x00\\x91#/\\x12\\x00\\x005\\x005\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-20T00:00:00", "modifydate": "1991-08-20T12:00:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "REXX"}, "text": " /* REXX DHOST - Displays the current host command table             */\n /*------------------------------------------------------------------*/\n /* Get the current ASCB address.                                    */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  ascbad = c2x(storage('224',4))\n /*------------------------------------------------------------------*/\n /* Get the current ASXB address.                                    */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  ascbasxb = d2x(x2d(ascbad)+x2d('6c'))\n  asxbad = c2x(storage(ascbasxb,4))\n /*------------------------------------------------------------------*/\n /* Get the current LWA (Logon Work Area) address.                   */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  asxblwa = d2x(x2d(asxbad)+x2d('14'))\n  lwaad = c2x(storage(asxblwa,4))\n /*------------------------------------------------------------------*/\n /* Get the current ECT (Environment Control Table) address.         */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  lwapect = d2x(x2d(lwaad)+x2d('20'))\n  ectad = c2x(storage(lwapect,4))\n /*------------------------------------------------------------------*/\n /* Get the current REXX environment control block address.          */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  ectenvbk = d2x(x2d(ectad)+x2d('30'))\n  envbkad = c2x(storage(ectenvbk,4))\n  say 'Environment Block Address='envbkad\n /*------------------------------------------------------------------*/\n /* Get the parmblock address.                                       */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  pabkadad = d2x(x2d(envbkad)+16)\n  pabkad = c2x(storage(pabkadad,4))\n /*------------------------------------------------------------------*/\n /* Get the host command environment table header address.           */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  sbcmtbadad = d2x(x2d(pabkad)+20)\n  sbcmtbad = c2x(storage(sbcmtbadad,4))\n /*------------------------------------------------------------------*/\n /* Get the number of entries in the table.                          */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  hocmencnad = d2x(x2d(sbcmtbad)+8)\n  hocmencn = c2d(storage(hocmencnad,4))\n /*------------------------------------------------------------------*/\n /* Loop through the entries displaying each one in character        */\n /* and in printable hex.                                            */\n /*-+----1----+----2----+----3----+----4----+----5----+----6----+----*/\n  hocmenad = c2x(storage(sbcmtbad,4))\n  do i = 1 to hocmencn                /* for each used entry...     */\n     hocmen = storage(hocmenad,32)    /* extract the entry          */\n     say hocmen\n     say c2x(hocmen)\n     SAY\n     hocmenad = d2x(x2d(hocmenad)+32) /* point to next entry        */\n  end                                 /* end of used entry loop     */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETSMFID": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92!\\x9f\\x00\\x92!\\x9f\\x12\\x00\\x00\\x06\\x00\\x06\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-06T00:00:00", "modifydate": "1992-08-06T12:00:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "REXX"}, "text": " /* REXX GETSMFID - Displays the current system's SMFID              */\n  numeric digits 10\n  cvt = c2d(storage('10',4))\n  cvtsmca = c2d(storage(d2x(cvt+x2d('c4')),4))\n  smcasid = storage(d2x(cvtsmca+x2d('10')),4)\n  say \"Currnet SMF ID:\" smcasid\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GOPHER": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x07_\\x00\\x93\\x07_\\x12\\x00*\\xc7*\\xc7\\x00\\x00\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-16T00:00:00", "modifydate": "1993-03-16T12:00:00", "lines": 10951, "newlines": 10951, "modlines": 0, "user": "ASM"}, "text": "//JOBNAME  JOB ACCOUNT,'NAME'\n//*------------------------------------------------------------------*/\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*------------------------------------------------------------------*/\n//*\n//* MVS GOPHER client\n//*\n//* Author:  Steve Bacher <seb1525@mvs.draper.com>\n//*\n//* Date:  July, 1992\n//*\n//*--------------------------------------------------------------------\n//*\n//* This job creates the GOPHER distribution libraries (PDS's).\n//*\n//* Run this JCL to create the PDS's, after customizing to suit.\n//* (Obviously, put in a good JOB statement first.)\n//* To customize the JCL, change the defaults on the //GGLOAD PROC\n//* statement to your liking, particularly the PREFIX default.\n//* You might also want to change the final qualifiers of the PDS's\n//* created - to do this, find the // EXEC GGLOAD statements and\n//* change the value of the TO parameter.\n//*\n//* See the $$README file (of the CNTL PDS, first in this stream)\n//* for the rest of the installation instructions.\n//*\n//GGLOAD  PROC CLS='*',BS='6160',U='3380',V='',\n//             TRK1='30',TRK2='10',DIR='35',RLSE='RLSE',\n//             PREFIX='GOPHER.INSTALL.'\n//*\n//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD   SYSOUT=&CLS\n//SYSUT2   DD   DISP=(NEW,CATLG,DELETE),DSN=&PREFIX.&TO,\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=&BS),\n//         SPACE=(TRK,(&TRK1,&TRK2,&DIR),&RLSE),UNIT=&U,VOL=SER=&V\n//*\n//         PEND\n//CNTL     EXEC GGLOAD,TRK1='4',TO='CNTL'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=$$README,SSI=010C0017\n\n------------------------------------------------------------------------\n\n Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992\n\n MVS Gopher Server originally by Shawn Hart (Univ. of Delaware).\n\n This software is provided on an \"AS IS\" basis.  All warranties,\n including the implied warranties of merchantability and fitness,\n are expressly denied.\n\n Provided this copyright notice is included, this software may\n be freely distributed and not offered for sale.\n\n Changes or modifications may be made and used only by the maker\n of same, and not further distributed.  Such modifications should\n be mailed to the author for consideration for addition to the\n software and incorporation in subsequent releases.\n\n------------------------------------------------------------------------\n\n MVS Gopher Client\n\n Author:          Steve Bacher <seb1525@mvs.draper.com>\n\n MVS Gopher Server\n\n Author:          Shawn Hart   <shawn.hart@mvs.udel.edu>\n Enhancements:    Steve Bacher <seb1525@mvs.draper.com>\n Customizations:  Lou Joseph   <CWMY5C@IRISHMVS.CC.ND.EDU>\n\n------------------------------------------------------------------------\n\n Contents of PDS's belonging to Gopher distribution:\n\n Member     PDS Type    Description\n\n $$README   CNTL        This file\n ACCESS     CNTL        Sample server access file\n ALLOAD     CNTL        JCL to allocate GOPHER load library\n COMPILEC   CNTL        JCL to compile and link C source for client\n COMPILES   CNTL        JCL to compile and link C source for server\n GOPHERD    CNTL        JCL to run the GOPHER server in batch (No TSO)\n GOPHERT    CNTL        JCL to run the GOPHER server in batch (w. TSO)\n HELP       CNTL        TSO Help for Gopher client (with XPROC support)\n HELQ       CNTL        TSO Help for Gopher client (without XPROC)\n INSTALLC   CNTL        How to install the GOPHER MVS client\n INSTALLS   CNTL        How to install the GOPHER MVS server\n MENU       CNTL        Initial Gopher server menu\n GOPHER     CLIST       Exec by which users invoke the Gopher client\n NNMFIUCV   CLIST       Exec to check for multiple socket applications\n GGM...     PANEL       ISPF regular panels\n GG...      H           C headers for compilation\n GG...      C           C source for compilation\n ABOUT...   ABOUT       \"About This Gopher\" text\n\n--------------------------------------------------------------------\n\nWhere to Go from Here:\n\n To install the GOPHER MVS client, read member INSTALLC.\n\n To install the GOPHER MVS server, read member INSTALLS.\n\nNote:\n\n You may install only the client, only the server, or both the\n client and the server.  It is purely up to what your needs are.\n\n--------------------------------------------------------------------\n\nChanges:\n\n 10/19/92 - Improvements in initial startup and GOPHERRC customization\n 12/07/92 - Customizations to support SNS/TCPAccess\n\n--------------------------------------------------------------------\n\n Questions?  Comments?  Suggestions?  Gripes?  Please email to...\n\n Steve Bacher      <seb@draper.com> or <seb1525@mvs.draper.com>\n\n./   ADD NAME=ACCESS,SSI=01020059\n!\n! Format of entries:\n!\n! filename (fully qualified, all uppercase, no quotes)\n! can be \"DD:DDNAME\" or \"EXEC:EXECNAME\"\n!\n! followed by names of hosts which are authorized to access the data.\n! If no host name list is present, all hosts are authorized\n!\n! You may specify the same file name more than once, if you need\n! more lines to put host names on.\n!\n! Individual PDS members must be specified separately.  A PDS without\n! a member name establishes access only to the PDS directory.\n!\n! Note that the default directory MUST be in this table.\n!\n! Also note that in the case of EXECs, the EXEC must live in the\n! library allocated to GGEXEC in the Gopher server JCL.\n!\n! *** ANY DATA SET REFERENCED BY ANY EXEC IN THAT LIBRARY IS FULLY\n! *** ACCESSIBLE TO GOPHER REGARDLESS OF THIS TABLE!  USE THIS TABLE\n! *** TO GOVERN CONTROL TO THE EXEC ITSELF!!!\n\n!\n! below is default directory spec, which MUST be in this table\n!\nDD:GGGOPHER\n\n!\n! Use the following for \"About This Gopher\".\n! (Change the PDS name to match your installation.)\n! Free free to specify the name of your MVS client host(s)\n! for information pertinent to MVS only.  mvs1 and mvs2 are examples.\n!\nDD:GGABOUT\nGOPHER.ABOUT(ABOUT)\nGOPHER.ABOUT(ABOUTC)                              mvs1 mvs2\nGOPHER.ABOUT(ABOUTCD)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTCF)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTCO)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTCQ)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTCS)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSC)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSL)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSM)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSR)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSW)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCSX)                            mvs1 mvs2\nGOPHER.ABOUT(ABOUTCX)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTS)                              mvs1 mvs2\nGOPHER.ABOUT(ABOUTSA)                             mvs1 mvs2\nGOPHER.ABOUT(ABOUTW)\nGOPHER.ABOUT(FAQ)\n\n!\n! Here's how to do REXX execs.  Note - no arguments, only exec names\n!\nEXEC:CHECKLST                     client1 client2 mvs\nEXEC:WAISDIR\nEXEC:WAISLIST\nEXEC:WAISSRCH\n\nANY.PUBLIC.SEQ.DS\nANY.SEMI.PUBLIC.SEQ.DS            goodclient1 goodclient2\nANY.SEMI.PUBLIC.SEQ.DS            goodclient3 goodclient4\n\n! PDS without member name provides access to directory only\n! All member names must be explicitly listed to be accessible.\n\nANY.PUBLIC.PDS\nANY.PUBLIC.PDS(MEMBER1)\nANY.PUBLIC.PDS(MEMBER2)\nANY.PUBLIC.PDS(MEMBER3)\nANY.PUBLIC.PDS(MEMBER4)\n\n\nANY.SEMI.PUBLIC.PDS               goodclient1 goodclient2\nANY.SEMI.PUBLIC.PDS               goodclient3 goodclient4\nANY.SEMI.PUBLIC.PDS(MEMBER1)      goodclient1\nANY.SEMI.PUBLIC.PDS(MEMBER2)      goodclient2\nANY.SEMI.PUBLIC.PDS(MEMBER3)      goodclient3\nANY.SEMI.PUBLIC.PDS(MEMBER4)      goodclient4\n\n./   ADD NAME=ALLOAD,SSI=01010051\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*\n//* Allocate GOPHER load library before install\n//*\n//GGALLOC PROC BS='6233',U='3380',V='',\n//             PRI='100',SEC='100',DIR='35'\n//*\n//IEFBR14  EXEC PGM=IEFBR14\n//ALLOCDD  DD   DISP=(NEW,CATLG,DELETE),DSN=&LIB,\n//         DCB=(RECFM=U,BLKSIZE=&BS),\n//         SPACE=(&BS,(&PRI,&SEC,&DIR)),UNIT=&U,VOL=SER=&V\n//*\n//         PEND\n//*\n//* The following step allocates the load library from which the\n//* executable program will be run.  If you intend to place the\n//* executable into an existing library, you can skip this step.\n//* Otherwise, the name must match the name used on the LOADLIB\n//* parameter of the GGLINK procedure in the COMPILE JCL.\n//*\n//* If you want separate libraries for the client and the server,\n//* just dup this step and give 'em different lib names.\n//*\n//ALLOC1   EXEC GGALLOC,PRI=50,SEC=50,DIR=35,\n//         LIB='GOPHER.LOAD'\n//*\n./   ADD NAME=COMPILEC\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Compile some or all GOPHER C/370 sources to make the SYSLIN input\n//* to the linkedit of the executable Gopher load module(s).\n//*\n//GGCC   PROC MEMBER=,\n//            SRCLIB='GOPHER.C',                 GOPHER C source PDS\n//            HDRLIB='GOPHER.H',                 GOPHER C headers PDS\n//            COMMHDR='TCPIP.COMMMAC',           C/370 TCP/IP headers\n//            C370HDR='SYS1.EDCHDRS',            C/370 standard headers\n//            SYSMSGS='SYS1.EDCMSGS',            C/370 messages file\n//            SYSMSGM='EDCMSGE',                 C/370 message member\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            CPARMS='SOURCE EXPMAC NOAGGR NOXREF', Compile parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//CCOMP     EXEC PGM=EDCCOMP,PARM='MARGINS(1,72) &TEST &CPARMS'\n//SYSMSGS   DD DISP=SHR,DSN=&SYSMSGS(&SYSMSGM)\n//SYSIN     DD DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//SYSLIB    DD DISP=SHR,DSN=&COMMHDR\n//          DD DISP=SHR,DSN=&C370HDR\n//USERLIB   DD DISP=SHR,DSN=&HDRLIB\n//SYSLIN    DD DSN=&&LOADSET,UNIT=&VIOUNIT,DISP=(MOD,PASS),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSCPRT   DD SYSOUT=&OUTCLAS\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4    DD DSN=&&SYSUT4,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT6    DD DSN=&&SYSUT6,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7    DD DSN=&&SYSUT7,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8    DD DSN=&&SYSUT8,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9    DD DSN=&&SYSUT9,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10   DD SYSOUT=&OUTCLAS\n//*\n//         PEND\n//*\n//*********************************************************************\n//*\n//* Linkedit an executable Gopher load module.\n//*\n//* Note: If C/370 V1R2 or higher, and you have therefore accepted\n//*       the \"#define FETCH\" in the GG header, you may delete\n//*       the line that includes the ISPLINK library.\n//*\n//* Note: If TCP/IP V2 or higher, remove the PASCAL link libraries\n//*       from the JCL and the AMPZMVSB card from the control deck.\n//*\n//GGLINK PROC LOADLIB='GOPHER.LOAD',             Executable load library\n//            PLIBASE='SYS1.PLIBASE',            PL/1   link library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            COMMTXT='TCPIP.COMMTXT',           TCP/IP link library\n//            PASRUN3='SYS1.PAS.SAMPRUN3',       PASCAL link library\n//            PASRUN1='SYS1.PAS.SAMPRUN1',       PASCAL link library\n//            PASMSG1='SYS1.PAS.SAMPMSG1',       PASCAL link library\n//            ISPLINK='ISP.V3R2M0.ISPLLIB',      ISPLINK link library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSLIB    DD DISP=SHR,DSN=&PLIBASE\n//          DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//          DD DISP=SHR,DSN=&COMMTXT\n//          DD DISP=SHR,DSN=&PASRUN3  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&PASRUN1  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&PASMSG1  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&ISPLINK  if C/370 V1R1 with #undef FETCH\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//GGCLIENT EXEC GGCC,MEMBER=GGCLIENT\n//GGMALLOC EXEC GGCC,MEMBER=GGMALLOC\n//GGMBRIFC EXEC GGCC,MEMBER=GGMBRIFC\n//GGMBRIFR EXEC GGCC,MEMBER=GGMBRIFR\n//GGMCLRTX EXEC GGCC,MEMBER=GGMCLRTX\n//GGMCONN  EXEC GGCC,MEMBER=GGMCONN\n//GGMCSO   EXEC GGCC,MEMBER=GGMCSO\n//GGMDFAIL EXEC GGCC,MEMBER=GGMDFAIL\n//GGMDIR   EXEC GGCC,MEMBER=GGMDIR\n//GGMDISC  EXEC GGCC,MEMBER=GGMDISC\n//GGMDISPL EXEC GGCC,MEMBER=GGMDISPL\n//GGMDUMP  EXEC GGCC,MEMBER=GGMDUMP\n//GGMESRVR EXEC GGCC,MEMBER=GGMESRVR\n//GGMFREEM EXEC GGCC,MEMBER=GGMFREEM\n//GGMGETDS EXEC GGCC,MEMBER=GGMGETDS\n//GGMGETM  EXEC GGCC,MEMBER=GGMGETM\n//GGMGOFOR EXEC GGCC,MEMBER=GGMGOFOR\n//GGMGSRVL EXEC GGCC,MEMBER=GGMGSRVL\n//GGMIERR  EXEC GGCC,MEMBER=GGMIERR\n//GGMIGET  EXEC GGCC,MEMBER=GGMIGET\n//GGMISPF  EXEC GGCC,MEMBER=GGMISPF\n//GGMIVGET EXEC GGCC,MEMBER=GGMIVGET\n//GGMIVPUT EXEC GGCC,MEMBER=GGMIVPUT\n//GGMMTFER EXEC GGCC,MEMBER=GGMMTFER\n//GGMOUTS  EXEC GGCC,MEMBER=GGMOUTS\n//GGMOUTTX EXEC GGCC,MEMBER=GGMOUTTX\n//GGMPMSG  EXEC GGCC,MEMBER=GGMPMSG\n//GGMPROC  EXEC GGCC,MEMBER=GGMPROC\n//GGMPTX   EXEC GGCC,MEMBER=GGMPTX\n//GGMSOCKT EXEC GGCC,MEMBER=GGMSOCKT\n//GGMSOPT  EXEC GGCC,MEMBER=GGMSOPT\n//GGMSSRVR EXEC GGCC,MEMBER=GGMSSRVR\n//GGMTNET  EXEC GGCC,MEMBER=GGMTNET\n//GGMTSO   EXEC GGCC,MEMBER=GGMTSO\n//GGMTYPE  EXEC GGCC,MEMBER=GGMTYPE\n//GGMUNALC EXEC GGCC,MEMBER=GGMUNALC\n//GGMVTX   EXEC GGCC,MEMBER=GGMVTX\n//GGMWAIS  EXEC GGCC,MEMBER=GGMWAIS\n//GGMWHOIS EXEC GGCC,MEMBER=GGMWHOIS\n//GGMXTX   EXEC GGCC,MEMBER=GGMXTX\n//*\n//* Link GOPHER load module. Like SMP/E, expect return code 8 when\n//* doing this from scratch.  Additional one-or-two-module links\n//* will just replace the corresponding parts of the load module.\n//*\n//GGLINK EXEC GGLINK\n//LKED.SYSLIN DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//            DD *\n INCLUDE SYSLMOD(GGCLIENT)            if included first time, RC = 8\n INCLUDE SYSLIB(AMPZMVSB)             include if TCP/IP V1 only\n ENTRY   CEESTART\n NAME    GGCLIENT(R)\n/*\n./   ADD NAME=COMPILES,SSI=01060050\n//JOBNAME  JOB ACCOUNT,'NAME'\n//*                                                                  */\n//* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n//*                                                                  */\n//* This software is provided on an \"AS IS\" basis.  All warranties,  */\n//* including the implied warranties of merchantability and fitness, */\n//* are expressly denied.                                            */\n//*                                                                  */\n//* Provided this copyright notice is included, this software may    */\n//* be freely distributed and not offered for sale.                  */\n//*                                                                  */\n//* Changes or modifications may be made and used only by the maker  */\n//* of same, and not further distributed.  Such modifications should */\n//* be mailed to the author for consideration for addition to the    */\n//* software and incorporation in subsequent releases.               */\n//*                                                                  */\n//*********************************************************************\n//*\n//* Compile some or all GOPHER C/370 sources to make the SYSLIN input\n//* to the linkedit of the executable Gopher load module.\n//*\n//GGCC   PROC MEMBER=,\n//            SRCLIB='GOPHER.C',                 GOPHER C source PDS\n//            HDRLIB='GOPHER.H',                 GOPHER C headers PDS\n//            COMMHDR='TCPIP.COMMMAC',           C/370 TCP/IP headers\n//            C370HDR='SYS1.EDCHDRS',            C/370 standard headers\n//            SYSMSGS='SYS1.EDCMSGS',            C/370 messages file\n//            SYSMSGM='EDCMSGE',                 C/370 message member\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            CPARMS='SOURCE EXPMAC NOAGGR NOXREF', Compile parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//CCOMP     EXEC PGM=EDCCOMP,PARM='MARGINS(1,72) &TEST &CPARMS'\n//SYSMSGS   DD DISP=SHR,DSN=&SYSMSGS(&SYSMSGM)\n//SYSIN     DD DISP=SHR,DSN=&SRCLIB(&MEMBER)\n//SYSLIB    DD DISP=SHR,DSN=&COMMHDR\n//          DD DISP=SHR,DSN=&C370HDR\n//USERLIB   DD DISP=SHR,DSN=&HDRLIB\n//SYSLIN    DD DSN=&&LOADSET,UNIT=&VIOUNIT,DISP=(MOD,PASS),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSCPRT   DD SYSOUT=&OUTCLAS\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT4    DD DSN=&&SYSUT4,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSUT6    DD DSN=&&SYSUT6,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT7    DD DSN=&&SYSUT7,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT8    DD DSN=&&SYSUT8,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)\n//SYSUT9    DD DSN=&&SYSUT9,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//   SPACE=(32000,(30,30)),DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)\n//SYSUT10   DD SYSOUT=&OUTCLAS\n//*\n//         PEND\n//*\n//*********************************************************************\n//*\n//* Linkedit the executable Gopher load modules.\n//*\n//* Note: If TCP/IP V2 or higher, remove the PASCAL link libraries\n//*       from the JCL and the AMPZMVSB card from the control deck.\n//*\n//GGLINK PROC LOADLIB='GOPHER.LOAD',             Executable load library\n//            EDCBASE='SYS1.SEDCBASE',           C/370  link library\n//            IBMBASE='SYS1.SIBMBASE',           PL/1+C common library\n//            COMMTXT='TCPIP.COMMTXT',           TCP/IP link library\n//            PASRUN3='SYS1.PAS.SAMPRUN3',       PASCAL link library\n//            PASRUN1='SYS1.PAS.SAMPRUN1',       PASCAL link library\n//            PASMSG1='SYS1.PAS.SAMPMSG1',       PASCAL link library\n//            IKJLINK='SYS1.LINKLIB',            IKJEFF18 link library\n//            VIOUNIT=VIO,                       Temporary disk unit\n//            OUTCLAS='*',                          SYSOUT class\n//            LPARMS='LIST,LET,MAP',                Linkedit parameters\n//            TEST=TEST                             TEST or NOTEST\n//*\n//LKED      EXEC PGM=IEWL,PARM='AMODE(31),&TEST,&LPARMS'\n//SYSPRINT  DD SYSOUT=&OUTCLAS\n//SYSLIB    DD DISP=SHR,DSN=&EDCBASE\n//          DD DISP=SHR,DSN=&IBMBASE\n//          DD DISP=SHR,DSN=&COMMTXT\n//          DD DISP=SHR,DSN=&PASRUN3  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&PASRUN1  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&PASMSG1  if TCP/IP V1 only\n//          DD DISP=SHR,DSN=&IKJLINK  if C/370 V1R1 with #undef FETCH\n//SYSLMOD   DD DISP=SHR,DSN=&LOADLIB\n//SYSUT1    DD DSN=&&SYSUT1,UNIT=&VIOUNIT,DISP=(NEW,DELETE),\n//          SPACE=(32000,(30,30))\n//*\n//         PEND\n//*\n//GGMALLOC EXEC GGCC,MEMBER=GGMALLOC\n//GGMDFAIL EXEC GGCC,MEMBER=GGMDFAIL\n//GGMUNALC EXEC GGCC,MEMBER=GGMUNALC\n//GGMOUTS  EXEC GGCC,MEMBER=GGMOUTS\n//GGMPROC  EXEC GGCC,MEMBER=GGMPROC\n//GGSTASK  EXEC GGCC,MEMBER=GGSTASK\n//*\n//* Link GOPHER subtask module.  Like SMP/E, expect return code 8\n//* doing this from scratch.  Additional one-or-two-module links\n//* will just replace the corresponding parts of the load module.\n//*\n//* If recompiling the entire load module, you may want to delete\n//* the previous one from the SYSLMOD library first, or remove the\n//* INCLUDE SYSLMOD card from the JCL below.\n//*\n//GGLINKT EXEC GGLINK\n//LKED.SYSLIN DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//            DD *\n INCLUDE SYSLMOD(GGSTASK)             if included first time, RC = 8\n INCLUDE SYSLIB(AMPZMVSB)             include if TCP/IP V1 only\n INCLUDE SYSLIB(IUCVFORC)\n INCLUDE SYSLIB(EDCMTFS)\n ENTRY   CEESTART\n NAME    GGSTASK(R)\n/*\n//GGMMTFER EXEC GGCC,MEMBER=GGMMTFER\n//GGSERVER EXEC GGCC,MEMBER=GGSERVER\n//*\n//* Link GOPHER server module.  Like SMP/E, expect return code 8\n//* doing this from scratch.  Additional one-or-two-module links\n//* will just replace the corresponding parts of the load module.\n//*\n//* If recompiling the entire load module, you may want to delete\n//* the previous one from the SYSLMOD library first, or remove the\n//* INCLUDE SYSLMOD card from the JCL below.\n//*\n//GGLINKS EXEC GGLINK\n//LKED.SYSLIN DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//            DD *\n INCLUDE SYSLMOD(GGSERVER)            if included first time, RC = 8\n INCLUDE SYSLIB(AMPZMVSB)             include if TCP/IP V1 only\n ENTRY   CEESTART\n NAME    GGSERVER(R)\n/*\n./   ADD NAME=GOPHERD,SSI=01060032\n//GOPHERD  PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         EXECLIB='GOPHER.EXEC',\n//         ACCESS='GOPHER.ACCESS',\n//         ABOUT='GOPHER.ABOUT',\n//         MENU='GOPHER.MENU',\n//         GPARM=\n//*\n//*********************************************************************\n//*                                                                   *\n//* GOPHER daemon, by Shawn Hart (U.Del.) and Steve Bacher (D.Lab.)   *\n//*                                                                   *\n//* Straight batch (no TSO access)                                    *\n//*                                                                   *\n//*********************************************************************\n//*\n//GOPHERD  EXEC PGM=&MODULE,PARM='&GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//GGEXEC   DD   DISP=SHR,DSN=&EXECLIB\n//SYSTSPRT DD   UNIT=SYSVIO,SPACE=(TRK,(100,100)),RECFM=VBA,LRECL=255\n//SYSERR   DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGABOUT  DD   DISP=SHR,DSN=&ABOUT\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n./   ADD NAME=GOPHERT,SSI=01040057\n//GOPHERD  PROC MODULE=GGSERVER,\n//         STEPLIB='GOPHER.LOAD',\n//         EXECLIB='GOPHER.EXEC',\n//         ACCESS='GOPHER.ACCESS',\n//         ABOUT='GOPHER.ABOUT',\n//         MENU='GOPHER.MENU',\n//         GPARM=\n//*\n//*********************************************************************\n//*                                                                   *\n//* GOPHER daemon, by Shawn Hart (U.Del.) and Steve Bacher (D.Lab.)   *\n//*                                                                   *\n//*********************************************************************\n//*\n//GOPHERD  EXEC PGM=IKJEFT01,DYNAMNBR=128,REGION=8M,\n//         PARM='&MODULE &GPARM'\n//STEPLIB  DD   DISP=SHR,DSN=&STEPLIB\n//GGEXEC   DD   DISP=SHR,DSN=&EXECLIB\n//SYSTSPRT DD   UNIT=SYSVIO,SPACE=(TRK,(100,100)),RECFM=VBA,LRECL=255\n//SYSERR   DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//SYSIN    DD   DUMMY\n//GGDEBUG  DD   SYSOUT=*\n//GGABOUT  DD   DISP=SHR,DSN=&ABOUT\n//GGACCESS DD   DISP=SHR,DSN=&ACCESS\n//GGGOPHER DD   DISP=SHR,DSN=&MENU\n./   ADD NAME=HELP,SSI=01000051\n)F Function -\n\n GOPHER is a distributed document delivery service, or, more generally,\n a networked information retrieval service.  It allows you to access\n numerous types of data on various hosts in a transparent fashion.\n GOPHER presents you with a hierarchical display of information sources\n which are accessed via a client/server communications link.\n\n There are GOPHER clients for all common hardware platforms.  The MVS\n version runs as an ISPF dialog application.\n\n When you use the GOPHER client, information about your use of GOPHER\n is stored in a data set called GOPHERRC.  If you don't have one,\n GOPHER will create it for you.\n\n For more information on customizing your GOPHER environment, get\n into Gopher and select \"About This GOPHER\".\n\n)I GOPHLOC          - local GOPHER help goes in member GOPHLOC\n\n)X Syntax -\n\n   %GOPHER\n              LOCAL\n              SERVER(hostname)\n              PATH(pathname)\n              PORT(portnumber)\n              DESCRIPTION(text)\n              FORCE\n              DEBUG\n              TEST\n\n   Required:  none\n\n)O Operands -\n\n))LOCAL\n\n              Specify LOCAL if you want to enter GOPHER in \"serverless\"\n              mode - i.e. start up with your private GOPHER menu.\n              Specifying LOCAL accomplishes two things:\n\n               (1) It sets the server to \"-\", meaning local access.\n                   Therefore, you must also provide a path, either\n                   via the PATH operand or via a \"localmenu:\" spec\n                   in your GOPHERRC file.\n\n               (2) It allows you to use GOPHER even if there are\n                   other TCP/IP socket applications active elsewhere\n                   in your TSO session.  However, it will not allow\n                   you to connect to any GOPHER servers, even if you\n                   have a local menu item that points to one.\n\n              For information on how to set up GOPHER menus, get into\n              GOPHER and select \"About This Gopher\".\n\n))SERVER(hostname)\n\n              The host name (or IP address) of a Gopher server.\n              If this is not given, GOPHER looks in your GOPHERRC\n              to find what server to connect to.  If it can't find\n              an appropriate specification, you will have to enter\n              a server name on the startup panel.\n\n              A server name of a single minus sign (-) is a special\n              case, signifying local (serverless) access to your\n              own private GOPHER data.  In this case, you must tell\n              GOPHER where your menu is, either via the PATH operand\n              or in the GOPHERRC file.\n\n))PATH(pathname)\n\n              The path name to be passed to the Gopher server, or\n              used in local access as your initial menu.  Although\n              the exact interpretation of the pathname string varies\n              depending on the server, both the MVS server and the\n              local GOPHER access feature interpret the pathname\n              as the FULLY QUALIFIED WITHOUT QUOTES name of an MVS\n              data set containing a gopher menu.  For information\n              about the format of a gopher menu, see operand MENU.\n\n))PORT(portnumber)\n\n              You should never need to specify this field unless\n              someone has set up a special kind of Gopher server\n              that requires a unique port number.\n\n))DESCRIPTION(text)\n\n              A text string giving the heading to be displayed for\n              the initial directory of Gopher goodies.  Normally\n              either the Gopher server or the Gopher client will\n              have a default value for this, or you can specify\n              a description of your liking in your GOPHERRC file.\n\n))FORCE\n\n              GOPHER tries to determine if there is a TCP/IP socket\n              application active elsewhere in your TSO environment\n              before starting up, to prevent TCP/IP errors.  If it\n              tells you that there is another client active but in\n              truth there is none and you know it, you can use the\n              FORCE keyword to make GOPHER proceed whether it finds\n              this to be the case or not.\n\n              Using the LOCAL operand is one way to avoid this entire\n              scenario.  However, that won't allow you to access any\n              Gopher servers on the network.\n\n))DEBUG\n\n              Set debugging mode on.  You must preallocate a file to\n              ddname GGDEBUG for this to work.  This can be allocated\n              to the terminal or a log file.  When debug mode is on,\n              messages describing memory allocation and deallocation\n              and GOPHER queries sent are dumped to the debug file.\n\n))TEST\n\n              Activate C/370 interactive test (INSPECT).  GOPHER must\n              have been compiled with the TEST option for this to be\n              effective.  Note that you can also issue the TEST command\n              inside GOPHER to get to INSPECT, again provided that\n              GOPHER was compiled with the TEST option.\n\n./   ADD NAME=HELQ,SSI=01000025\n)F Function -\n\n GOPHER is a distributed document delivery service, or, more generally,\n a networked information retrieval service.  It allows you to access\n numerous types of data on various hosts in a transparent fashion.\n GOPHER presents you with a hierarchical display of information sources\n which are accessed via a client/server communications link.\n\n There are GOPHER clients for all common hardware platforms.  The MVS\n version runs as an ISPF dialog application.\n\n When you use the GOPHER client, information about your use of GOPHER\n is stored in a data set called GOPHERRC.  If you don't have one,\n GOPHER will create it for you.\n\n For more information on customizing your GOPHER environment, get\n into Gopher and select \"About This GOPHER\".\n\n)I GOPHLOC          - local GOPHER help goes in member GOPHLOC\n\n)X Syntax -\n\n   %GOPHER\n              LOCAL\n              FORCE\n              DEBUG\n              TEST\n\n   Required:  none\n\n)O Operands -\n\n))LOCAL\n\n              Specify LOCAL if you want to enter GOPHER in \"serverless\"\n              mode - i.e. start up with your private GOPHER menu.\n              Specifying LOCAL accomplishes two things:\n\n               (1) It sets the server to \"-\", meaning local access.\n                   Therefore, you must also provide a path via a\n                   \"localmenu:\" spec in your GOPHERRC file.\n\n               (2) It allows you to use GOPHER even if there are\n                   other TCP/IP socket applications active elsewhere\n                   in your TSO session.  However, it will not allow\n                   you to connect to any GOPHER servers, even if you\n                   have a local menu item that points to one.\n\n              For information on how to set up GOPHER menus, get into\n              GOPHER and select \"About This Gopher\".\n\n))FORCE\n\n              GOPHER tries to determine if there is a TCP/IP socket\n              application active elsewhere in your TSO environment\n              before starting up, to prevent TCP/IP errors.  If it\n              tells you that there is another client active but in\n              truth there is none and you know it, you can use the\n              FORCE keyword to make GOPHER proceed whether it finds\n              this to be the case or not.\n\n              Using the LOCAL operand is one way to avoid this entire\n              scenario.  However, that won't allow you to access any\n              Gopher servers on the network.\n\n))DEBUG\n\n              Set debugging mode on.  You must preallocate a file to\n              ddname GGDEBUG for this to work.  This can be allocated\n              to the terminal or a log file.  When debug mode is on,\n              messages describing memory allocation and deallocation\n              and GOPHER queries sent are dumped to the debug file.\n\n))TEST\n\n              Activate C/370 interactive test (INSPECT).  GOPHER must\n              have been compiled with the TEST option for this to be\n              effective.  Note that you can also issue the TEST command\n              inside GOPHER to get to INSPECT, again provided that\n              GOPHER was compiled with the TEST option.\n\n./   ADD NAME=INSTALLC,SSI=01070035\n\n Directions for Installing the GOPHER MVS Client\n\n Assuming the PDS's have been created:\n\n 1. Customize the ALLOAD and COMPILEC JCL members to reflect your\n local conventions.  Note:  If you intend to place the executable into\n an existing library, you can suppress that part of the ALLOAD JCL.\n The name of the data set created must match across both members.\n\n 2. Customize the GGUSER header file as shown by the comments therein.\n Note in particular the defines for your TCP/IP and your C compiler.\n There are changes to the linkedit JCL that are related to these.\n\n 3.  Customize the GOPHER exec to define the names of the MVS libraries\n to contain the panel and load library members.  The load library must\n be the one specified in the ALLOAD JCL, if you are creating it anew.\n Observe the comments relating to the use of LIBDEF and ISPF APPLIDs.\n\n It is in the GOPHER exec that you will also customize the name of the\n default Gopher server.  Note that the user's GOPHERRC file gets built\n from the contents of this exec.\n\n Note that if you install one of the REXX execs, you must also install\n the NNMFIUCV exec in the same library.  This exec implements a rude\n check for an existing TCP/IP socket application (e.g. another GOPHER)\n in a different PIE MultiTSO session.  It prevents your users from\n crashing TCP/IP, so it is highly recommended that you make use of it.\n\n 4. If you are running ISPF Version 2 or earlier, edit the GOPHER panels\n whose names begin \"GGMP...\".  These are popups, and will not work\n under ISPF Version 2 unless you change the )BODY line.  Remove the\n WINDOW(...) parameter from the )BODY line of each panel so that the\n line just says )BODY or )BODY EXPAND(``), as the case may be.\n\n Now, to install:\n\n 5. Submit the ALLOAD JCL to allocate the load library from which the\n executable program will be run.  If you intend to place the executable\n into an existing library, you can skip this step, but you should make\n sure that there is no previous load module named GGCLIENT in the load\n library of your choice before you proceed.\n\n 6. Submit the COMPILEC JCL to compile all the C sources and create\n the executable Gopher load module.\n\n The first time you run this you can expect a return code of 8 from\n the linkedit.  Like SMP/E, this is OK if the only reason is an IEW0342\n because the \"INCLUDE SYSLMOD(GGCLIENT)\" did not find an existing load\n module.  If you get IEW0132 (unresolved external reference) or\n IEW0241 (ESD type definition conflict), your linkedit went awry.\n Don't use the resultant load module.  Check the libraries you\n specified on the link step to see what went wrong.\n\n In the future, if you have to recompile individual modules, you can use\n the same JCL to compile only those modules, and the link will include\n the new modules in the existing executable load module.\n\n *********************************************************************\n\n IMPORTANT:  If you are running TCP/IP V2R2 or higher on MVS, you must\n change the following library names in the compile and link JCL:\n\n   TCPIP.COMMMAC   should be changed to  TCPIP.SEZACMAC\n   TCPIP.COMMTXT   should be changed to  TCPIP.SEZACMTX\n\n If you are using SNS/TCPAccess, use these library names, or\n whatever names are defined at your installation:\n\n   TCPIP.COMMMAC   should be changed to  SNSTCP.V110.H\n   TCPIP.COMMTXT   should be changed to  SNSTCP.V110.CILIB\n\n *********************************************************************\n\n Note:  If you have defined C370V1 in the GGUSER header file, you must\n also include the system linklist load library or libraries containing\n ISPLINK, ISPEXEC and IKJEFF18 when linking.  Otherwise you may delete\n the lines from the linkedit JCL that reference them.\n\n Note:  You need not include the PASCAL libraries or the AMPZMVSB\n module if you are using TCP/IP Version 2 or higher, in which case\n you must also define TCPIPV2 in the GGUSER headerfile.\n\n 7. Copy all the members of the panel PDS into the ISPF panel library\n specified in the GOPHER exec.\n\n 8. Copy one of the help members (HELP or HELQ) from the CNTL PDS into\n your local TSO HELP library under the name GOPHER.  You may also\n create an additional HELP member called GOPHLOC containing\n information local to your site, if you wish.\n\n Which CNTL member should you use?  If you don't have XPROC, use HELQ.\n If you do have XPROC, use HELP.  You will have to modify your GOPHER\n clist either way.  If you don't have XPROC, you should get it,\n because you can specify more options on Gopher if you do.  You can\n get XPROC via USC's \"MVS network server\" code distribution service.\n For more information about this, send an email message to\n SERVICE@MVSA.USC.EDU - or SERVICE@USCMVSA, which will normally give\n better results if you have a BITNET (NJE) return address.\n\n 9. Create the \"About This Gopher\" PDS from the ABOUT PDS.  This has\n all the text users should see when they select the \"About This Gopher\"\n item from the MVS client.  It also contains all the documentation you\n need about setting up the client and the server, as well as creating\n menus and REXX execs for use with MVS Gopher.  You may have already\n done this as part of the server install, but it should also be\n available from the client in \"local\" (serverless) mode, so that is\n why I mention it here.\n\n--------------------------------------------------------------------\n\n Note:  Make sure that the C/370 run time library is available,\n either in the system link list or in the ISPLLIB concatenation,\n before attempting to run GOPHER.\n\n If the C/370 runtime library is not in the link list or otherwise\n available to ISPF at execution time, you may arrange for it to be\n allocated via LIBDEF in the GOPHER exec (I haven't tried this).\n\n./   ADD NAME=INSTALLS,SSI=01080018\n\n Directions for Installing the GOPHER MVS Server\n\n Assuming the PDS's have been created:\n\n 1. Customize the ALLOAD and COMPILES JCL members to reflect your\n local conventions.  Note:  If you intend to place the executable into\n an existing library, you can suppress that part of the ALLOAD JCL.\n The name of the data set created must match across both members.\n\n 2. Customize the GGUSER header file as shown by the comments therein.\n Note in particular the defines for your TCP/IP and your C compiler.\n There are changes to the linkedit JCL that are related to these.\n\n Now, to install:\n\n 3. Submit the ALLOAD JCL to allocate the load library from which the\n executable program will be run.  If you intend to place the executable\n into an existing library, you can skip this step, but you should make\n sure that there is no previous load module named GGSERVER or GGSTASK\n in the load library of your choice before you proceed.\n\n 4. Submit the COMPILES JCL to compile all the C sources and create\n the executable Gopher load modules.\n\n The first time you run this you can expect return codes of 8 from\n the linkedit.  Like SMP/E, this is OK if the only reason is an IEW0342\n because the \"INCLUDE SYSLMOD(...)\" did not find an existing load\n module.  If you get IEW0132 (unresolved external reference) or\n IEW0241 (ESD type definition conflict), your linkedit went awry.\n Don't use the resultant load module.  Check the libraries you\n specified on the link step to see what went wrong.\n\n In the future, if you have to recompile individual modules, you can use\n the same JCL to compile only those modules, and the link will include\n the new modules in the existing executable load module.\n\n *********************************************************************\n\n IMPORTANT:  If you are running TCP/IP V2R2 or higher on MVS, you must\n change the following library names in the compile and link JCL:\n\n   TCPIP.COMMMAC   should be changed to  TCPIP.SEZACMAC\n   TCPIP.COMMTXT   should be changed to  TCPIP.SEZACMTX\n\n If you are using SNS/TCPAccess, use these library names, or\n whatever names are defined at your installation:\n\n   TCPIP.COMMMAC   should be changed to  SNSTCP.V110.H\n   TCPIP.COMMTXT   should be changed to  SNSTCP.V110.CILIB\n\n *********************************************************************\n\n Note:  If you have defined C370V1 in the GGUSER header file, you must\n also include the system linklist load library containing IKJEFF18\n when linking.  Otherwise you may delete the line from the linkedit\n JCL that references it.\n\n Note:  You need not include the PASCAL libraries or the AMPZMVSB\n module if you are using TCP/IP Version 2 or higher, in which case\n you must also define TCPIPV2 in the GGUSER headerfile.\n\n 5. Create the \"About This Gopher\" PDS from the ABOUT PDS.  This has\n all the text users should see when they select the \"About This Gopher\"\n item from the MVS client.  It also contains all the documentation you\n need about setting up the client and the server, as well as creating\n menus and REXX execs for use with MVS Gopher.  You may have already\n done this as part of the client install.\n\n *** NOTE: In member MENU, you must change the line that reads\n \"PATH=GOPHER.ABOUT.PDS(ABOUT)\" to reflect the actual name of your\n ABOUT PDS.  If you are using an earlier distribution of the MVS\n Gopher server that has the line PATH=DD:GGABOUT(ABOUT), then you\n must change that as well, because that won't work to get additional\n PDS members as the user climbs down the Gopher tree.\n\n 6. Create your Gopher access file.  See the instructions in the\n \"About This Gopher\" PDS for the format.\n\n 7. Create the MVS Gopher started task JCL from either of the samples\n given in GOPHERD and GOPHERT.  The GOPHERT is recommended so that you\n can use REXX execs that issue TSO commands, but you may not want to\n use this for security reasons.  Either way, customize liberally.\n\n Started task parameters:\n\n MODULE=GGSERVER            the Gopher server load module in STEPLIB\n STEPLIB='GOPHER.LOAD'      the load library containing the above\n EXECLIB='GOPHER.EXEC'      the PDS containing server REXX execs\n ACCESS='GOPHER.ACCESS'     the installation access file (sequential)\n ABOUT='GOPHER.ABOUT'       the PDS containing \"About This Gopher\" info\n MENU='GOPHER.MENU'         the initial gopher menu (sequential)\n GPARM=                     the server parameters (e.g. -d for debug)\n\n Note: if you specify GPARM='-D', a GGDEBUG DD must be included.\n\n--------------------------------------------------------------------\n\n Note:  Make sure that the C/370 run time library is available,\n either in the system link list or in the STEPLIB concatenation,\n before attempting to run GOPHER.\n\n./   ADD NAME=MENU,SSI=01020056\ngopher_menu\n\nTYPE=FILE\nNAME=About This Gopher\nPATH=GOPHER.ABOUT.PDS(ABOUT)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Library/Information Services\nPATH=SYS0008.GOPHER.LIBRARY(LIBRS)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=TELNET\nNAME=UDINFO - University of Delaware Information\nHOST=UDINFO.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=Network and System Services Computer Systems\nPATH=SYS0008.GOPHER.DIR(UDTELNET)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=Weather Across the Country\nPATH=1/Weather\nHOST=mermaid.micro.umn.edu\nPORT=150\nEND\n\nTYPE=DIRECTORY\nNAME=Other Gopher and Information Servers\nPATH=1/Other Gopher and Information Servers\nHOST=gopher.micro.umn.edu\nEND\n\nTYPE=DIRECTORY\nNAME=How to use BITNET LISTSERV Servers\nPATH=SYS0008.GOPHER.DIR(LISTSERV)\nHOST=MVS.UDEL.EDU\nEND\n\nTYPE=DIRECTORY\nNAME=University of Delaware Newspapers\nPATH=SYS0008.GOPHER.DIR(PAPERS)\nHOST=MVS.UDEL.EDU\nEND\n\n/*\n./ ENDUP\n?!\n//ABOUT    EXEC GGLOAD,TRK1='5',TO='ABOUT'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=ABOUT,SSI=01040045\ngopher_menu\n\nTYPE=FILE\nNAME=What Is Gopher?\nPATH=(ABOUTW)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Gopher FAQ (Frequently Asked Questions) List\nPATH=(FAQ)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Using The Gopher MVS Client\nPATH=(ABOUTC)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Administering the Gopher MVS Server\nPATH=(ABOUTS)\nHOST=+\nEND\n\n\n./   ADD NAME=ABOUTC,SSI=01030000\ngopher_menu\n\nTYPE=FILE\nNAME=Overview - Using Gopher on MVS\nPATH=(ABOUTCO)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Directory Mode - Viewing a Gopher Directory\nPATH=(ABOUTCD)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=File Mode - Browsing a Gopher File\nPATH=(ABOUTCF)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Query Mode - Executing a Gopher Query\nPATH=(ABOUTCQ)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=Extracting Gopher Text\nPATH=(ABOUTCX)\nHOST=+\nEND\n\nTYPE=DIRECTORY\nNAME=Customizing Your Gopher Startup\nPATH=(ABOUTCS)\nHOST=+\nEND\n\n\n./   ADD NAME=ABOUTCD,SSI=01000031\nThis text has not been written yet.\n./   ADD NAME=ABOUTCF,SSI=01000042\nThis text has not been written yet.\n./   ADD NAME=ABOUTCO,SSI=01000013\nThe following is modified from Allan Tuchman's XGOPHER help.\n\nGopher on MVS is an ISPF dialog interface to the Gopher\ninformation delivery system from the University of Minnesota.\n\nThe initial panel asks you to specify the name of the Gopher server\nhost.  Normally you leave the other input fields alone.\n\nYou may also specify a hostname of \"-\", which means that you want\nto use your own private Gopher data without going through a server.\nWhen you do this, you must provide the path name to your private\ntop-level menu (data set name, FULLY QUALIFIED, WITHOUT QUOTES).\n\nAssuming that the top-level path points to a valid Gopher menu,\nthe initial display will show the top level directory of\ngopher information available.  Selecting an item from this\nlist will fetch the contents of a file, subdirectory, or\nother information.  The directory display may be updated to\nshow the new subdirectory.\n\nTo select an item, type \"S\" in front of it and press ENTER.\nThis puts you into ISPF BROWSE mode on the text of the item.\nYou may also type \"Q\" in front of an item to see it in text format\neven if it is a directory.  If you have retrieved an item, you may\ntype \"E\" in front of it to extract it into a file - but you may\ndo this more easily via the EXTract command from within BROWSE.\n\nSome gopher file types are not supported by the current client.\nThese will not appear on your menus.  Furthermore, you may not\nbe permitted to access some items, depending upon the server\nand the host from which you are trying to access them.  These\nrestrictions do not apply to local mode, where you can access\nanything that you have local permission to read.\n\nThe Gopher MVS client is written by Steve Bacher at Draper Laboratory\n(copyright 1992).\n\n./   ADD NAME=ABOUTCQ,SSI=01000047\nThis text has not been written yet.\n./   ADD NAME=ABOUTCS,SSI=01030002\ngopher_menu\n\nType=FILE\nName=Customizing Your Gopher Startup\nPath=(ABOUTCSC)\nHost=+\nEnd\n\nType=FILE\nName=What Happens When You Start Up Gopher\nPath=(ABOUTCSW)\nHost=+\nEnd\n\nType=FILE\nName=Requesting Local (Serverless) Access\nPath=(ABOUTCSL)\nHost=+\nEnd\n\nType=FILE\nName=The GOPHERRC File\nPath=(ABOUTCSR)\nHost=+\nEnd\n\nType=FILE\nName=Defining GOPHER Menus\nPath=(ABOUTCSM)\nHost=+\nEnd\n\nType=FILE\nName=REXX Exec Interface\nPath=(ABOUTCSX)\nHost=+\nEnd\n\n./   ADD NAME=ABOUTCSC,SSI=01010046\n\n=======================================================================\n\n Customizing Your Gopher Startup\n\n=======================================================================\n\n When you use the GOPHER client, information about your use of GOPHER\n is stored in a data set called GOPHERRC.  If you don't have one,\n GOPHER will create it for you.\n\n Your default startup menu will contain a single item pointing to a\n GOPHER server on MVS, whether such a server is available or not.\n However, you can ask GOPHER to display a different startup menu for\n you.  This startup menu may have entries for the GOPHER server\n on MVS and one for your own private (local) data, which is accessed\n without querying a server.\n\n To get GOPHER to set up a different startup menu, you must edit the\n GOPHERRC file.  Note that you may set up the GOPHER startup menu to\n include a pointer to your local data - but you have to create that\n local data in order to use it.\n\n Editing the GOPHERRC file should be easy.  Just follow the\n instructions in the comments of the file itself.  For information\n about the contents of GOPHERRC, see the HELP for operand GOPHERRC.\n\n./   ADD NAME=ABOUTCSL,SSI=01000056\n\n=======================================================================\n\n Requesting Local (Serverless) Access\n\n=======================================================================\n\n The LOCAL operand on the GOPHER command is a convenient way of\n requesting \"local\" serverless mode.  Specify LOCAL on the GOPHER\n command if you want to enter GOPHER in \"serverless\" mode - i.e.\n start up with your private GOPHER menu.  Specifying LOCAL\n accomplishes two things:\n\n  (1) It sets the server to \"-\", meaning local access.  Therefore, you\n      must also provide a path, either via the PATH operand on the\n      GOPHER command or via a \"localmenu:\" spec in your GOPHERRC file,\n      so that GOPHER knows where to look for your private data.  The\n      path is a data set name, FULLY QUALIFIED WITHOUT QUOTES.\n\n  (2) It allows you to use GOPHER even if there are other TCP/IP socket\n      applications active elsewhere in your TSO session.  However, it\n      will not allow you to connect to any GOPHER servers, even if you\n      have a local menu item that points to one.\n\n If you do not specify a server and there is no specification in\n your GOPHERRC file for one, then GOPHER will display a startup\n ISPF panel asking you to specify a server name and, optionally,\n a path name.  (Don't touch the port number!)\n./   ADD NAME=ABOUTCSM,SSI=01030019\n\n=======================================================================\n\n Defining Gopher Menus\n\n=======================================================================\n\n This is a description of how to define GOPHER menus that can be used\n either for your own private data or by the GOPHER server administrator\n on MVS to define publicly accessible data.\n\n Bear in mind that the menu may be used to specify data meaningful to\n a server other than MVS.  Therefore, the descriptions here should be\n interpreted in two ways:\n\n (1) how to define MVS-resident information resources\n\n (2) how to request information resources from other GOPHER servers\n\n------------------------------------------------------------------------\n\n How To Define MVS-Resident Information Resources\n\n The Gopher server (and the Gopher client, in \"local\" mode) determines\n how to return information to the client via menus.  These menus are\n plain MVS data sets with a particular structure.\n\n An MVS gopher menu is a sequential data set or PDS member with the\n following format:\n\n * the first line contains the string GOPHER_MENU\n   (in upper, lower or mixed case)\n\n * the rest of the file contains blocks of information like this:\n\n   TYPE=type\n   NAME=name\n   PATH=path\n   HOST=host\n   PORT=port\n   END\n\n   For compatibility with earlier versions of the MVS Gopher server,\n   the following are also accepted:\n\n   DISPLAY=      is equivalent to NAME=\n   SELECTOR=     is equivalent to PATH=\n\n   Explanations\n\n   TYPE=type\n\n   The type of Gopher entity (FILE, DIRECTORY, INDEX, etc.).\n   In other words, one of the following:\n\n   FILE      - the item is an MVS data set with text to be displayed.\n               The path name is the file name or a REXX exec spec.\n   DIRECTORY - the item is another Gopher directory.\n               The path name is the file name or a REXX exec spec.\n   INDEX     - the item is a full text search item, which means that\n               the client will query the user for a search string\n               which will be passed to the server along with the\n               pathname.  For the MVS server.  it only makes sense for\n               the pathname to be a REXX exec specification.  The path\n               and the user's string are given to the host, which\n               returns a menu of selections.  See also WHOIS.\n   TELNET    - the item is a Telnet server.\n               The path name is ignored.  The port number should be\n               omitted or set to 0, unless an alternate TELNET port\n               is required by the server referenced by HOST.\n   WHOIS     - the item is a \"whois\" query.  This is similar to the\n               INDEX type, except that the server returns a file\n               rather than a menu.  This is not (yet) an official\n               part of the Gopher protocol, though it does appear in\n               certain (patched) versions of other implementations.\n\n   NAME=name\n\n   The descriptive string that will appear in the Gopher client's\n   display of menu selections for this item.  Make this as human as\n   possible.  Case is preserved.\n\n   PATH=path\n\n   The pathname to be passed to the Gopher server to retrieve the\n   item.  See below for a fuller description.\n\n   HOST=host\n\n   The name of the Gopher server host that will process the request.\n   See below for a fuller description.\n\n   PORT=port\n\n   The TCP/IP port to connect to.  For Gopher, this should always be\n   port 70 (except for a TELNET type, whose port defaults to the\n   standard TELNET port if zero or omitted).  If this is omitted, then\n   the default port number is taken.\n\n   END\n\n   Required to keep menu entries separate.\n\n Comment lines may be freely included, starting with '#' in\n the first column of data.\n\nMore about Path Names\n\n Note that the format of a path depends on which Gopher server is\n going to be processing the entry, as defined by the HOST= field.\n If the entry is going to a different Gopher server, then the\n pathname format depends on that server.  For example, a Unix server\n would expect a Unix file name with a slash.\n\n A path name for the MVS Gopher may be one of the following:\n\n * A fully qualified MVS data set name, without quotes, identifying\n   a sequential text data set or PDS member.  If TYPE=FILE, this is\n   text.  If TYPE=DIRECTORY, this is a gopher menu as described above.\n\n * A fully qualified MVS data set name, without quotes, identifying a\n   PDS (no member).  This causes the MVS Gopher server to return a\n   list of member names of the PDS in Gopher directory format.  This\n   is valid only with TYPE=DIRECTORY.  Member aliases are included in\n   the resulting list.\n\n * A member name enclosed in parentheses.  This is treated as\n   a full PDS member.  In other words, the MVS Gopher server will use\n   the name of the PDS in which the menu itself was found.\n   This allows you to move PDS's full of Gopher menus around without\n   having to worry about changing all the path names.  This happens\n   only when the menu itself is a PDS member and the host is the\n   same as the local host (MVS for the server, - for local mode).\n   Specifying HOST=+ is recommended for this.\n\n * A string \"DD:ddname\" or \"DD:ddname(member)\", identifying a file by\n   MVS ddname a la C/370.  Valid with either TYPE=FILE or\n   TYPE=DIRECTORY, so the ddname can point to text or a menu.\n   However, if the ddname happens to be allocated to a PDS, it does\n   NOT work like a directory above - it's just illegal and will\n   probably cause lossage.\n\n   Each member is treated as a Gopher FILE.  The NAME field is\n   set to the member name.  If you want to do anything fancier\n   than this, you will have to construct your own Gopher menu.\n\n * A string \"EXEC:execname args\", which specifies the name of a\n   REXX exec to be executed to return the data.  Valid with any\n   and all types.  To learn more about how to make use of this\n   feature, please go back to the \"About This Gopher\" tree and\n   read up on using REXX execs with MVS Gopher.\n\n   If you are using your own private GOPHER data via local access\n   and you want to run REXX execs, you must have a \"localexec:\"\n   line in your GOPHERRC file identifying your REXX exec library.\n\nMore About Host Names\n\n You may find that some Gopher servers insist on appending the\n network's domain name to local server hostnames.  You should check\n with your network gurus to make sure that this will work with your\n TCP/IP host lookup.  The MVS server will accept hostnames either\n with or without the domain name appended - this applies to the\n specification of hostnames in the Gopher access table as well -\n but other Gopher servers may not.\n\nTwo special cases:\n\n A plus sign (HOST=+) means that the host is the same host as the one\n that is looking at the directory entry - i.e. the server that is\n serving up this menu.  The Gopher server simply plugs in its own host\n name at that point.  This is NOT part of the Gopher protocol, but\n merely a server hack.\n\n A minus sign (HOST=-) means that access to this item will be in\n \"local\" (serverless) mode.  This is recognized only by the MVS Gopher\n client.  It means that the client will do the retrieval itself,\n without asking a server to do it.\n\n The directory-processing code, when invoked in \"local mode\", will\n treat HOST=+ as HOST=- since the current host is the local mode\n operation in that case.  Therefore, using HOST=+ is recommended\n so that one can port one's local GOPHER menus to the public server\n at some point.\n\n A REXX exec that generates menus dynamically can use - as a hostname,\n but not +.\n\n------------------------------------------------------------------------\n\n How To Request Information Resources From Other GOPHER Servers\n\nRather than describe the standard format of a Gopher menu here,\nI recommend that you go to your nearest Unix box and type\n\n  man gopherd\n\nThat should tell you all you need to know about Unix gopher servers.\nIf your gopher server is on some other kind of machine, then go find\nthe documentation for that machine's Gopher menus.\n\nThe purpose of the above exercise is primarily to determine the format\nof a path name understood by a given Gopher server.  Once you know that,\nyou can build a Gopher menu the MVS Gopher will understand, according to\nthe format described in the top section.  Set the host to point to\nthe other Gopher server, who will interpret the other items in the menu.\n\n------------------------------------------------------------------------\n\nDynamic Generation of GOPHER Menus\n\n If you want to be able to generate a Gopher menu dynamically,\n you can do this via the REXX interface.  You also must understand\n the Gopher protocol.  A Gopher menu is really a text representation\n of the actual protocol, which goes like this:\n\n filetype -tab- name -tab- path -tab- host -tab- port\n\n where -tab- is the EBCDIC (on MVS) or ASCII (on other box) tab\n character, and filetype is a single character.  The filetypes\n supported by the MVS Gopher server are:\n\n 0 - flat file\n 1 - directory\n 2 - error\n 7 - index\n 8 - TELNET\n w - whois (experimental)\n\n A REXX exec that wants to generate a Gopher menu must output lines\n in this format.  For more information, go back to the Gopher tree\n for \"About This Gopher\" and look up information on the REXX interface.\n\n./   ADD NAME=ABOUTCSR,SSI=01010039\n\n=======================================================================\n\n The GOPHERRC File\n\n=======================================================================\n\n When you use the GOPHER client, you need a file called GOPHERRC\n which stores information about your use of GOPHER.  If you don't\n have one, GOPHER will create it for you.  The file initially\n contains:\n\n    the initial path/name/host/port specification, which tells\n    GOPHER what to display on startup.  By default this is the\n    standard GOPHER server info on MVS.  However, you can add\n    to your GOPHERRC a specification for local GOPHER by\n    editing GOPHERRC and activating one of the following:\n\n    - the other \"initial:\" spec which points to your own startup menu,\n      overriding the one you'd get otherwise\n\n    - the localmenu: and localexec: lines.\n\n    localmenu: is equivalent to specifying an alternate initial:\n    spec of host=- (dash) and path=localmenu_name.  When you use\n    the LOCAL operand of the GOPHER command, localmenu: is what\n    GOPHER looks for as the pathname if you don't provide one on\n    the command.\n\n    localexec: is required if you want to use your own library of\n    GOPHER rexx execs.  This is valid for LOCAL access only.\n\n    Some option defaults are stored in the GOPHERRC file.\n    Note that this is not yet implemented.\n\n    The GOPHER client will store bookmarks (as you create them)\n    at the end of your GOPHERRC file.  Note that this feature\n    is not yet implemented.\n\n    If you have a newly created GOPHERRC file, you can read the\n    comments to guide you in customizing the file.\n./   ADD NAME=ABOUTCSW,SSI=01000034\n\n=======================================================================\n\n What Happens When You Start Up GOPHER?\n\n=======================================================================\n\n What you see when you start up GOPHER depends on what you have\n specified, either on the command line or in the GOPHERRC file.\n In general, command operands override GOPHERRC specifications.\n\n GOPHER does its thing by connecting to a Gopher server somewhere\n on your network.  If you do not specify otherwise, this server is\n assumed to be MVS (the host where you are running this client).\n The default GOPHERRC file specifies this as the server.\n The startup menu you see is the one defined by the administrator\n of that server.\n\n You can request a different server or a different startup menu,\n either by modifying the GOPHERRC file or by specifying command\n operands.  The SERVER operand tells GOPHER to get a startup menu\n from a different server, and the PATH operand tells GOPHER what\n startup menu to request (the contents of the path depend on what\n server you point to and what it's looking for, but it is typically\n the name of a file on that system that contains a Gopher menu).\n\n You can also use GOPHER to access your own private data by requesting\n \"local\" (serverless) mode.  A server name of a single dash \"-\" means\n local access.  In this case, you must provide a path name so that\n GOPHER knows where to look for your data.  The path name is the name\n of a data set containing your GOPHER menu - it must be FULLY QUALIFIED\n AND WITHOUT QUOTES.  The path name can be provided either as a command\n operand or in the GOPHERRC file.\n./   ADD NAME=ABOUTCSX,SSI=01020059\n=======================================================================\n\nREXX Exec Interface\n\n=======================================================================\n\nYou can request the MVS Gopher server (or the MVS Gopher client, in\n\"local\" (serverless) mode) to retrieve information dynamically by\nexecuting a REXX exec.  To request this, you define a menu entry\nwith the following PATH= field:\n\nPATH=EXEC:execname args\n\nIn the case of EXEC:, the REXX exec identified by \"execname\" is\nexecuted, along with the arguments \"args\" given.  For example:\n\nPATH=EXEC:MYEXEC ANY ARGS\n\nwill cause the MYEXEC exec to be executed with \"ANY ARGS\" as the\nsingle argument string.\n\nIf the TYPE is INDEX, the search string submitted by the user will be\nappended to the args separated by a blank.  The exec must be able to\ndeal with this.\n\nREXX Execs must be in a PDS allocated to DD GGEXEC.  This ddname\nneeds to be allocated in the Gopher server's JCL.  For local mode,\nthe GOPHER command will allocate the GGEXEC file to the REXX exec\nlibrary specified on the \"localexec:\" line in your GOPHERRC file,\nif you have activated it.  Otherwise you will not be able to use\nREXX execs in local mode.\n\nNote that you do not need the /* REXX */ comment at the beginning of\nREXX execs used by gopher (though it does not hurt to include it!)\nbecause they are invoked by the IRXEXEC facility and not the standard\nTSO CLIST/EXEC search.\n\nNow, how does the REXX exec return data to the Gopher server?\n\nFirst of all, it depends on the TYPE that the exec is expected\nto return, which has nothing to do with HOW the returning is done.\n\nSo, first let's talk about how the exec returns data, and then\nabout what it is expected to return.\n\nHow to return data\n\nThe REXX exec must return data by writing it to the SYSTSPRT DD.\nNote that this is where normal TSO output goes when a REXX exec\nis run in TSO batch.  However, since REXX execs are invoked by\nthe IRXEXEC interface by the Gopher server, to prevent dependency\non a TSO environment, this default behavior of REXX/TSO cannot\nbe relied upon.  Therefore, if you write a REXX exec to return\nGopher data, you must explicitly send the output to the SYSTSPRT\nddname.  The Gopher server makes sure that it can read this data.\n\nA typical approach is to queue all the output to the REXX data stack,\nqueue a final \"\" and then use EXECIO.  Be careful not to queue null\nlines in this case.  Be sure to protect the stack in case of lossage.\nExample:\n\n \"NEWSTACK\"\n do while more_data_to_get\n  some_data = get_some_data()\n  if some_data = \"\" then queue \" \"\n  else queue some_data\n end\n queue \"\"\n \"EXECIO * DISKW SYSTSPRT (FINIS)\"\n \"DELSTACK\"\n\nYou can also create a stem variable to hold the output, if you\nwant to avoid problems with null lines or nested stacks.  Example:\n\n do i = 1 to whatever\n   foo.i = get_some_data()\n end\n foo.0 = i\n \"EXECIO * DISKW SYSTSPRT (FINIS STEM FOO.)\"\n\nA downside is that if the REXX exec finds anomalous conditions\nor executes a TSO command that barfs, standard TSO command output\nwill probably get lost.  Therefore, try to use OUTTRAP to capture\ncommand output and test for error codes, and write all captured\noutput or error messages to SYSTSPRT in such a way as to allow\nthe client to see them (but not treat them as normal directory\ndata or whatever).\n\nA helpful hack is to use an EXECUTE exec to invoke other REXX\ncode or TSO commands that normally output via PUTLINE.  e.g.:\n\n/* REXX. Usage: EXECUTE exec args... */\n\n parse arg real_exec_command\n parse source sourceline\n if word(sourceline,7) = \"TSO\" then do\n  x = outtrap(\"LINE.\")\n  real_exec_command\n  arc = rc\n  x = outtrap(\"OFF\")\n  \"EXECIO * DISKW SYSTSPRT (FINIS STEM LINE.)\"\n end\n else do\n  real_exec_command\n  arc = rc\n end\n\n return arc\n\nI don't recommend this, though, because it's SLOW.\n\n\nIf the Gopher server is a TSO-in-batch job (i.e. EXEC PGM=IKJEFT01)\nthen you can issue TSO commands from the exec.  To get the output,\nthough, you need to use OUTTRAP around them.  If they issue TPUT's,\nyou are SOL.  If they are PL/1 programs that write to SYSPRINT, or\nFORTRAN or assembler, etc., allocate the SYSPRINT or FT06F001 or\nwhatever file to a temporary and copy the temporary to SYSTSPRT.  If\nit is a C/370 program that writes to stdout or stderr, you may be able\nto use redirection:\n\n   CALL 'THEIR.LOAD(CPROG)' 'args > DD:SYSTSPRT'\n\n for stdout\n\n   CALL 'THEIR.LOAD(CPROG)' 'args 2> DD:SYSTSPRT'\n\n for stderr\n\n (for multiple output, use >> instead of >)\n\n If gopher server is run straight batch rather than as a TSO job, then\n you cannot run REXX execs that require a TSO environment.\n\n One more important word:  Make sure that your SYSTSPRT file has a\n large enough LRECL to handle the REXX output.  If it is too short,\n the REXX output will get folded.  For TYPE=DIRECTORY in particular,\n this is disastrous.  Recommended JCL for executing the Gopher server\n may be found elsewhere in the installation materials, or your MVS\n system programmer has probably already installed a Gopher server in\n 'SYS1.PROCLIB' or the equivalent with the correct allocation.\n\nWhat it is expected to return\n\n OK - now the good stuff.  This depends on the TYPE on the menu entry\n that your exec is trying to fulfill.  Some gopher protocol basics:\n\n A Gopher menu is really a text representation of the actual protocol,\n which goes like this:\n\n filetype -tab- name -tab- path -tab- host -tab- port\n\n where -tab- is the EBCDIC (on MVS) or ASCII (on other box) tab\n character, and filetype is a single character.  The filetypes\n supported by the MVS Gopher server are:\n\n 0 - flat file\n 1 - directory\n 2 - error\n 7 - index\n 8 - TELNET\n w - whois (experimental)\n\n To generate the equivalent of a Gopher menu, you must output data\n in the above format.  Now for the details...\n\nTYPE=FILE\n\nJust return the straight data.  Try to avoid null lines because C/370\nbelieves they don't exist and will throw them away.  We hate this, but\nIBM is so hard to convince of reality sometimes...  Change all null\nlines to lines containing one blank as you write them out (you need to\ndo this anyway if you are queueing output on the stack for EXECIO) and\nyou will have no problems.\n\nTYPE=DIRECTORY\n\nYou must return lines that fit the gopher protocol format as above.\n\nFor example, if you want to generate a Gopher menu on the fly that\nis equivalent to this:\n\ntype=file\nname=This is my description\npath=some.gopher.path\nhost=sun1.sanjuan.com\nport=70\n\nthen you output a line that looks like this:\n\n  0This is my description!some.gopher.path!sun1.sanjuan.com!70\n\n(each ! is really a tab (EBCDIC hex 05) character)\n\nwhere \"0\" is the type (file in this example, but would be \"1\" for\ntype=directory, \"7\" for typeindex, etc.)\n\nHere's the REXX code that might do this:\n\nname = \"This is my description\"\npath = \"some.gopher.path\"\nhost = \"sun1.sanjuan.com\"\ntab  = '05'x\nport = 70\n\nqueue \"0\"||name||tab||path||tab||host||tab||port\n\nAssuming we write the queued lines to DD SYSTSPRT, as described.\n\nSpecifying the Right Host Name\n\nMost of the time you will probably want to generate a menu item\nthat points back to your MVS host, not some other host.  It may\neven redrive your selfsame REXX exec with new arguments.  And if\nthe exec was invoked in local (serverless) mode, you want the item\nto get driven in the same mode, probably.\n\nThe question is - what's the easiest way to identify what\nthe \"same server\" is?  One way is to hardcode the server name (e.g.\n\"MVS.DRAPER.COM\"), but this is not sufficiently general because:\n\n(1) the server name or location may change\n(2) you can't distribute the exec to other Gopher users\n(3) it won't work the same way in \"local mode\"\n\nSo, you need a way to know what the name of your selfsame host is.\nThe MVS Gopher server can use HOST=+, but you can't, as that isn't\npart of the Gopher protocol.  So what do you do?\n\nRecommendation:  call a function hostname() to return the current\nhost name.  So in the above code segment, you might have:\n\n host = hostname()\n\nWhat is that hostname() function anyway?\nWell, you create it.\nTake your Gopher exec library (please) and include an exec\ncalled HOSTNAME, which you set up to return the name\nof the host that you want to be the \"same host\".\n\nNote that a plus sign \"+\" will not work in this context.\nThe plus sign is a hack interpreted by the Gopher server\nwhen it sees it on a menu.  It is *not* part of the Gopher\nprotocol and therefore cannot be sent over.\n\nHowever, the minus sign \"-\" will work, as the Gopher client\nin local mode will interpret it at the protocol level\n(which DOES NOT IMPLY THAT IT IS A PART OF THE STANDARD\nGOPHER PROTOCOL, PROPOSED OR OTHERWISE - THIS IS JUST A\nLOCAL HACK MODIFICATION).\n\nAnyhow, what you ought to do is to have different Gopher\nexec libraries for local (i.e.private) use and public\nserver use.  The public server will have a HOSTNAME member\nthat says\n\n return \"MVS.DRAPER.COM\"\n\nor whatever the name of *YOUR* gopher server host is.\n\nYour private exec library should have a HOSTNAME member\nthat says\n\n  return \"-\"\n\nThis is the best I can come up with right now.  A future enhancement\nmay be to pass the hostname as the second arg to the REXX exec using\nthe IRXEXEC interface, e.g.\n\nparse arg execargs, hostname\n\nThen we could pass even more such arguments, like port, etc.\nBut that's all for now...\n\n\n./   ADD NAME=ABOUTCX,SSI=01000051\nThis text has not been written yet.\n./   ADD NAME=ABOUTS,SSI=01040038\ngopher_menu\n\nTYPE=FILE\nNAME=Creating MVS Gopher Menus\nPATH=(ABOUTCSM)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=MVS Gopher Access Table\nPATH=(ABOUTSA)\nHOST=+\nEND\n\nTYPE=FILE\nNAME=REXX Exec Interface\nPATH=(ABOUTCSX)\nHOST=+\nEND\n\n./   ADD NAME=ABOUTSA,SSI=01020004\n\n  Format of entries in the Gopher Access Table:\n\n  filename (fully qualified, all uppercase, no quotes)\n  can be \"DD:DDNAME\" or \"EXEC:EXECNAME\"\n\n  followed by names of hosts which are authorized to access the data.\n  If no host name list is present, all hosts are authorized\n\n  You may specify the same file name more than once, if you need\n  more lines to put host names on.\n\n  Individual PDS members must be specified separately.  A PDS without\n  a member name establishes access only to the PDS directory.\n\n  Note that the default directory MUST be in this table.\n\n  Also note that in the case of EXECs, the EXEC must live in the\n  library allocated to GGEXEC in the Gopher server JCL.\n\n  *** ANY DATA SET REFERENCED BY ANY EXEC IN THAT LIBRARY IS FULLY\n  *** ACCESSIBLE TO GOPHER REGARDLESS OF THIS TABLE!  USE THIS TABLE\n  *** TO GOVERN CONTROL TO THE EXEC ITSELF!!!\n\n./   ADD NAME=ABOUTW,SSI=01020053\nWhat is Gopher?\n\nFor more information, read the FAQ, posted to USENET newsgroups\ncomp.infosystems.gopher and news.answers every two weeks.\n\nThe information contained here is borrowed therefrom in large part.\n\nGopher is a client/server protocol for building a distributed\ninformation delivery service.  While providing a delivery vehicle for\nlocal information, Gopher also facilitates access to other Gopher and\ninformation servers on the Internet.\n\nGopher servers and clients can be obtained via anonymous ftp to\nboombox.micro.umn.edu.  Look in the directory /pub/gopher.\n\n     There are clients for the following systems.  For the latest\n     directory information, see the FAQ.\n\n      Unix Curses & Emacs\n      Xwindows\n      Macintosh Hypercard\n      Macintosh Application\n      DOS w/Clarkson Driver\n      NeXTstep\n      VM/CMS\n      VMS\n      MVS\n\n     There are also a number of public telnet login sites available.\n     See the FAQ for more information.\n\n     There are servers for the following systems.  For the latest\n     directory information, see the FAQ.\n\n       Unix\n       VMS\n       Macintosh\n       VM/CMS\n       MVS\n\n\nPapers and articles describing Gopher:\n\n     _The_Internet_Gopher_, \"ConneXions\", July 1992, Interop.\n\n     _Exploring_Internet_GopherSpace_ \"The Internet Society News\", v1n2 1992,\n\n     _The_Internet_Gopher_Protocol_, Proceedings of the Twenty-Third\n          IETF, CNRI, Section 5.3\n\n     _Internet_Gopher_, Proceedings of Canadian Networking '92\n\n     _The_Internet_Gopher_, INTERNET: Getting Started, SRI\n          International, Section 10.5.5\n\n     _Tools_help_Internet_users_discover_on-line_treasures, Computerworld,\n          July 20, 1992\n\n     Gopher will also be in two forthcoming O'Reilly Books:\n     \"Administrating TCP/IP, and The Whole Internet\"\n\n./   ADD NAME=FAQ,SSI=01020044\nXref: news.draper.com comp.infosystems.gopher:886 news.answers:2444\nNewsgroups: comp.infosystems.gopher,news.answers\nFrom: gopher@boombox.micro.umn.edu (UofMN Gopher Team)\nSubject: Gopher (comp.infosystems.gopher) Frequently Asked Questions (FAQ)\nFollowup-To: comp.infosystems.gopher\nSummary: Common Questions and Answers about the Internet Gopher, a\n        client/server protocol for making a world wide information\n        service, with many implementations.\nSender: news@news2.cis.umn.edu (Usenet News Administration)\nOrganization: University of Minnesota\nDate: Thu, 5 Nov 1992 21:29:00 GMT\n\nArchive-name: gopher-faq\nLast-modified: 1992/10/29\n\nCommon Questions and Answers about the Internet Gopher, a\nclient/server protocol for making a world wide information service,\nwith many implementations.  Posted to comp.infosystems.gopher and\nnews.answers every two weeks.\n\nThe most recent version of this FAQ can be gotten through gopher, or\nvia anonymous ftp:\n\npit-manager.mit.edu:/pub/usenet/news.answers/gopher-faq\n\nThose without FTP access should send e-mail to mail-server@rtfm.mit.edu\nwith \"send usenet/news.answers/finding-sources\" in the body to find out\nhow to do FTP by e-mail.\n\n\n\n-------------------------------------------------------------------\nQ0:  What is Gopher?\n\nA0:  The Internet Gopher client/server provides a distributed\n     information delivery system around which a world/campus-wide\n     information system (CWIS) can readily be constructed.   While\n     providing a delivery vehicle for local information,  Gopher\n     facilitates access to other Gopher and information servers\n     throughout the world.\n\n-------------------------------------------------------------------\nQ1:  Where can I get gopher?\n\nA1:  via anonymous ftp to boombox.micro.umn.edu.  Look in the directory\n     /pub/gopher\n\n--------------------------------------------------------------------\nQ2:  What do I need to access gopher?\n\nA2:  You will need a gopher \"client\" program that runs on your local PC\n     or workstation\n\n     There are clients for the following systems.  The directory\n     following the name is the location of the client on the anonymous\n     ftp site boombox.micro.umn.edu (134.84.132.2) in the directory\n     /pub/gopher.\n\n      Unix Curses & Emacs   :  /pub/gopher/Unix/gopher1.03.tar.Z\n      Xwindows              :  /pub/gopher/Unix/xgopher1.1a.tar.Z\n      Macintosh Hypercard   :  /pub/gopher/Mac_client/\n      Macintosh Application :  /pub/gopher/Macintosh-TurboGopher\n      DOS w/Clarkson Driver :  /pub/gopher/PC_client/\n      NeXTstep              :  /pub/gopher/NeXT/\n      VM/CMS                :  /pub/gopher/Rice_CMS/ or /pub/gopher/Vienna_CMS/\n      VMS                   :  /pub/gopher/VMS/\n      OS/2 2.0              :  /pub/gopher/os2/\n      MVS/XA                :  /pub/gopher/mvs\n\n     A Macintosh application, MacGopher is available via anonymous ftp\n     from ftp.cc.utah.edu:\n\n      Macintosh Application :  /pub/gopher/Macintosh\n\n     Another Macintosh application, \"GopherApp\" is available via\n     anonymous ftp from ftp.bio.indiana.edu:\n\n      Macintosh Application :  /util/gopher/gopherapp\n\n     A port of the UNIX curses client for DOS with PC/TCP is available\n     via anonymous ftp from oac.hsc.uth.tmc.edu:\n\n      DOS w/ PC/TCP         :  /public/dos/misc/dosgofer.exe\n\n     A port of the UNIX curses client for PC-NFS is available via\n     anonymous ftp from bcm.tmc.edu:\n\n      DOS w/ PC-NFS         : /nfs/gopher.exe\n\n     A beta version of the PC Gopher client for Novell's LAN Workplace\n     for DOS is available from lennon.itn.med.umich.edu\n\n      LWP for DOS           :  /gopher\n\n\n     All of the above clients can also be fetched via a gopher client\n     itself.  Put the following on a gopher server:\n\n       Type=1\n       Host=boombox.micro.umn.edu\n       Port=70\n       Path=\n       Name=Gopher Software Distribution.\n\n\n     Or point your gopher client at boombox.micro.umn.edu, port 70 and\n     look in the gopher directory.\n\n     There are also a number of public telnet login sites available.\n     The University of Minnesota operates one on the machine\n     \"consultant.micro.umn.edu\" (134.84.132.4) See Q3 for more\n     information about this.  It is recommended that you run the client\n     software instead of logging into the public telnet login sites.  A\n     client uses the custom features of the local machine (mouse,\n     scroll bars, etc.)  A local client is also faster.\n\n---------------------------------------------------------------------\nQ3:  Where are there publicly available logins for gopher.\n\nA3:  Here is a short list, use the site closest to you to minimize\n     network lag.\n\n     Non-tn3270 Public Logins:\n\n     Hostname                  IP#              Login   Area\n     ------------------------- ---------------  ------  -------------\n     consultant.micro.umn.edu  134.84.132.4     gopher  North America\n     gopher.uiuc.edu           128.174.33.160   gopher  North America\n     panda.uiowa.edu           128.255.40.201   panda   North America\n     gopher.sunet.se           192.36.125.2     gopher  Europe\n     info.anu.edu.au           150.203.84.20    info    Australia\n     gopher.chalmers.se        129.16.221.40    gopher  Sweden\n     tolten.puc.cl             146.155.1.16     gopher  South America\n     ecnet.ec                  157.100.45.2     gopher  Ecuador\n\n     tn3270 Public Logins:\n\n     Hostname                  IP#              Login   Area\n     ------------------------- ---------------  ------  -------------\n     pubinfo.ais.umn.edu       128.101.109.1    -none-  North America\n\n\n     It is recommended that you run the client software instead of\n     logging into the public login sites.  A client uses the\n     custom features of the local machine (mouse, scroll bars, etc.)\n     and is local client is also faster.\n\n---------------------------------------------------------------------\nQ4:  How can I add to the information in gopher?\n\nA4:  You can do this by running a gopher server.  Servers are available\n     for a number of systems.  Use anonymous ftp to\n     boombox.micro.umn.edu (134.84.132.2) and look in /pub/gopher.  The\n     following servers are available there:\n\n       Unix      : /pub/gopher/Unix/gopherxx.tar.Z\n       VMS       : /pub/gopher/VMS/\n       Macintosh : /pub/gopher/Mac_server/\n       VM/CMS    : /pub/gopher/Rice_CMS/ or /pub/gopher/Vienna_CMS/\n       MVS       : /pub/gopher/mvs/\n       DOS PC    : /pub/gopher/PC_server/\n\n\n     When you have your server ready you can publish it to the world by\n     sending e-mail to the maintainters of the \"Other gophers\" list:\n\n       gopher@boombox.micro.umn.edu\n\n---------------------------------------------------------------------\nQ5:  Who Develops Gopher Software?\n\nA5:  Gopher was originally developed in April 1991 by the University\n     of Minnesota Microcomputer, Workstation, Networks Center to help\n     our campus find answers to their computer questions.\n\n     It has since grown into a full-fledged World Wide Information\n     System used by a large number of sites in the world.\n\n     Many people have contributed to the project, too numerous to\n     count.\n\n     The people behind the much of the gopher software can be reached\n     via e-mail at gopher@boombox.micro.umn.edu, or via paper mail:\n\n      Internet Gopher Developers\n      100 Union St. SE #190\n      Minneapolis, MN 55455  USA\n\n---------------------------------------------------------------------\nQ6:  How can I set up a \"CSO\" phone book server?  Where is the software?\n\nA6:  CSO phone book servers are also known as \"qi\" servers.  The\n     software implementation can be gotten via anonymous ftp from\n     uxc.cso.uiuc.edu (128.174.5.50) as /pub/qi.tar.Z.  You may also\n     see this referred to as \"ph\", which is what most of the clients\n     are called.\n\n     There is also an archive of the mailing list for qi/ph software on\n     the same machine.  It's in /pub/info-ph.archive.\n\n     This software is supported by Steve Dorner <s-dorner@uiuc.edu>\n     Contact him for more information.\n\n-------------------------------------------------------------------\nQ7:  Why can't I access the University of Minnesota's UPI news?\n\nA7:  The University of Minnesota has a site license for UPI news, we\n     are not allowed to distribute it off of our campus.  We get our\n     UPI news from Clarinet.  For more information about getting UPI\n     news send mail to info@clarinet.com.  For information about\n     setting up your own gopher-UPI server search the gopher-news\n     archive for UPI.\n\n-------------------------------------------------------------------\nQ9:  What are the type characters for the different Gopher Objects?\n\nA9:  Normal IDs.\n\n     0       Item is a file\n     1       Item is a directory\n     2       Item is a CSO (qi) phone-book server\n     3       Error\n     4       Item is a BinHexed Macintosh file.\n     5       Item is DOS binary archive of some sort.\n     6       Item is a UNIX uuencoded file.\n     7       Item is an Index-Search server.\n     8       Item points to a text-based telnet session.\n     9       Item is a binary file!  Client must read until the connection\n                 closes.  Beware.\n     T       TN3270 connection.\n\n     Experimental IDs.\n\n     s       Sound type.  Data stream is a mulaw sound.\n     g       GIF type.\n     M       MIME type.  Item contains MIME data.\n     h       html type.\n     I       Image type.\n     i       \"inline\" text type (used by panda).\n\n-------------------------------------------------------------------\nQ10: When I do full-text searches I always get every document back, Why?\n\nA10: This is a problem occasionally encountered with Unix full-text\n     indexes.  It is caused by setting up the link incorrectly to a\n     gindexd port.\n\n     The Path= field should be *blank* when pointing to a gindexd\n     index.\n\n     Otherwise the client will send the path to the gindexd daemon,\n     which interprets everything as a keyword.  This path is\n     likely to contain a pathname that is common to all of the indexed\n     files.  Thus a search generates hits on everything.\n\n-------------------------------------------------------------------\nQ11: When I try to build the UNIX software I get an error from make:\n     \"Must be a separator on rules line #. Stop\"  Why?\n\nA11: This is a problem with older makes that don't understand the \"include\"\n     keyword.  One easy way to cope with this problem is compiling GNU\n     make, which does understand the include keyword.\n\n     If this is too difficult, remove the line:\n\n      include Makefile.config\n\n     from all the Makefiles and paste in a copy of Makefile.config at\n     the top of each Makefile.\n\n     Or, instead of pasting you can make the client/server by going\n     into the appropriate directory and typing:\n\n      make -f ../Makefile.config -f Makefile\n\n-------------------------------------------------------------------\nQ12: What is the relationship between Gopher and (WAIS, WWW, ftp)?\n\nA12: Gopher is intimately intertwined with these two other systems.\n     As shipped the Unix gopher server has the capability to:\n\n       - Search local WAIS indices.\n       - Query remote WAIS servers and funnel the results to gopher\n         clients.\n       - Query remote ftp sites and funnel the results to gopher\n         clients.\n       - Be queried by WWW (World Wide Web) clients (either using\n         built in gopher querying or using native http querying.\n\n-------------------------------------------------------------------\nQ13: Are papers or articles describing gopher available?\n\nA13: Gopher has a whole chapter devoted to it in :\n\n     _The_Whole_Internet_, Ed Kroll, O'Reilly, 1992 (Editors note:\n                             ..Great book, go out and buy a bunch!)\n\n     Other references include:\n\n     _The_Internet_Gopher_, \"ConneXions\", July 1992, Interop.\n\n     _Exploring_Internet_GopherSpace_ \"The Internet Society News\", v1n2 1992,\n\n     (You can subscribe to the Internet Society News by sending e-mail to\n      isoc@nri.reston.va.us)\n\n     _The_Internet_Gopher_Protocol_, Proceedings of the Twenty-Third\n          IETF, CNRI, Section 5.3\n\n     _Internet_Gopher_, Proceedings of Canadian Networking '92\n\n     _The_Internet_Gopher_, INTERNET: Getting Started, SRI\n          International, Section 10.5.5\n\n     _Tools_help_Internet_users_discover_on-line_treasures, Computerworld,\n          July 20, 1992\n\n     _TCP/IP_Network_Administration_, O'Reilly.\n\n      Balakrishan, B. (Oct 1992)\n        \"SPIGopher: Making SPIRES databases accessible through the\n      Gopher protocol\".  SPIRES Fall '92 Workshop, Chapel Hill, North\n      Carolina.\n\n-------------------------------------------------------------------\nQ14: On a DECstation I get the error message \"/etc/svc.conf no such file\n     or directory\" when running the gopherd server, why?\n\nA14: This is caused by the chroot() call in gopherd.  It can be easily\n     fixed by running gopherd with the -c option.\n\n     Alternatively you can copy /etc/svc.conf into a directory named\n     \"etc\" inside the gopher-data directory.\n-------------------------------------------------------------------\nQ15: The boolean searching terms don't work for my full-text index, why?\n\nA15: This is probably because the searching is being provided by WAIS.\n     WAIS opts to return all documents that contain a search phrase\n     within certain limits.  WAIS searches do return the documents with\n     the highest \"score\" at the top, those documents will have the\n     closest relevance.\n-------------------------------------------------------------------\nQ16: When linking the Unix gopher server with WAIS I get undefined symbols,\n     such as:\n\n         log_file_name\n         logfile\n         PrintStatus\n         find_value\n         Sources\n         NumSources\n\nA17: This happens if you make gopherd before linking in the WAIS ir/ui\n     directories.  The fix is to \"make clean\" or remove\n     gopherd/{waisgopher.o,Waisindex.o} and then remake gopherd.  Or\n     link the ir/ui directories first.\n-------------------------------------------------------------------\nQ18: Why don't my WAIS indexes work?  I never get anything back for searches.\n     or Why do I get \"Dangling file\" error messages in my logfile?\n\nA18: The problem could be in the server.  The server should be run\n     using the -c option if you want WAIS to work.  Another solution is to\n     patch the WAIS code so that it doesn't check the files on the disk.\n     Search the gopher-news archive for \"dangling\".  This will turn up a\n     single document with the patch.\n\n-------------------------------------------------------------------\nQ19: My gopher server doesn't work under inetd, why?\n\nA19: It could be that your inetd server only supports a limited amount\n     of arguments.  For instance, the maximum number of arguments to an\n     inetd server is 5.  You can get around this by combining arguments: i.e.\n\n       gopherd -I -c\n\n     becomes:\n\n       gopherd -Ic\n\n     You may also leave the port specifier off of the command line.\n     The gopher server automagically finds out the port it's running on.\n\n-------------------------------------------------------------------\nQ20: This is not a bug report, just a curiousity. I managed to install\n     gopher on my PC, more or less by myself, which is a pretty good\n     accomplishment, for someone who hasn't installed hardly anything on a\n     PC. I then proceeded to load my PC/TCP kernel, ETHDRV, and try to\n     start up gopher. It said it couldn't initialize that stack(?). I have\n     to load this whenever I use PC/TCP. Incredibly, when I did not load\n     ETHDRV, Gopher came up immediately and telneted to our local server.\n     How does it know what kernel to load?\n\nA20 Dr. Science says,\n\n     The Internet Gopher program is not actually computer program at\n     all, but a collection of magical incantations handed down from Dark\n     Age conjurors.  It works by sending magical \"demons\" through the air,\n     which scour the world for information, and then return to cast\n     illusions containing the answer.\n\n     When you use the Gopher, your computer isn't actually doing\n     anything at all.  Instead, these demons have mesmirized you with an\n     evil magical spell, which was invoked by the pattern of\n     finger-movements peculiar to the typing of the letters G-O-P-H-E-R on\n     your keyboard.  This spell transmits demonic information directly to\n     your brain.\n\n     Scientists aren't certain of the long-term effects of demonic\n     mesmirization, although former presidents have suffered only minor\n     medical side-effects from it.  Indeed, since Magic and Science are\n     usually opposed to each other, most Scientists are usually\n     close-minded about such issues, and will usually respond with some\n     vacuous non-answer about \"packet drivers\", \"stacks\", and other such\n     jargon.\n\n     Unlike conventional scientists, Dr. Science is very open-minded and\n     is willing to deal with such issues in a frank and honest manner.\n     This is why people come to him with questions, and why they've learned\n     to rely on and live by his answers.\n\n     Dr. Science\n         \"I'm not a real doctor;  I have a Master's Degree....  in SCIENCE!\"\n\n:-) :-) :-) :-)\nThere's always room for a little humor in a FAQ..\n-------------------------------------------------------------------\nQ21: Help!  I have PC-NFS and want to use the PC-Gopher client.  How?\n\nA21: Use a piece of software called PKTMUX, available at fine ftp\n     sites everywhere.  This will let you use any packet driver\n     application.\n\n     Or, aquire a client that supports PC-NFS.  See Q2.\n-------------------------------------------------------------------\nQ22: How do I nuke a hung TCP connection?  I can't restart my UNIX\n     gopher server unless I get rid of it, and I don't want to reboot!\n\nA22:\n\nHere is an example of using dbx to change a socket from CLOSING to\nCLOSED.\n\n # netstat -A|grep CLOSING\n c4bc5100 tcp        0     11  mymachine.gopher 129.89.8.4.70  CLOSING\n # dbx -k /vmunix /dev/mem\n ...\n (dbx) 0xc4bc5100+8/1X                  -- display contents of PCB+8\n c4bc5108:   00000007\n (dbx) assign 0xc4bc5108=0              -- zero it\n 0\n (dbx) q\n\nAfter a minute or two, the CLOSED socket should disappear.\n-------------------------------------------------------------------\nQ23: Is there somewhere I can retrieve a list of announced gopher\n     links?  I'd like to keep a local, up-to-date list of available gopher\n     holes without requiring our users to gopher to umn just to scan\n     GopherSpace.\n\nA23: In the Unix client/server distribution is a perl script called\n     \"gopherdist\". Gopherdist can fetch the contents of any point in\n     GopherSpace.\n\n     To dump the contents of all the North American links from\n     gopher.tc.umn.edu do the following:\n\n     % gopherdist gopher.tc.umn.edu 70 \"1/Other Gopher and Information\n       Servers/North America\" > .Links\n--\n | Paul Lindner | lindner@boombox.micro.umn.edu   | Slipping into madness\n |              | Computer & Information Services | is good for the sake\n | Gophermaster | University of Minnesota         | of comparision.\n///// / / /    /////// / / / /  /  /  /   /      //// / / / /  /  /  /   /\n\n\n./ ENDUP\n?!\n//C        EXEC GGLOAD,TRK1='14',TO='C'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=GGCLIENT,SSI=01180054\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#ifdef SASC\n#pragma  runopts(EXECOPS)\n#else\n#pragma  runopts(heap(8k,8k,anywhere,))\n#pragma  runopts(nospie,nostae)\n#endif\n\n#pragma  csect(code,  \"GG@LIENT\")\n#pragma  csect(static,\"GG$LIENT\")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nstatic char copyright_notice[] =\n   \"Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992   \\n\\\n                                                                    \\n\\\n    GOPHER server due to Shawn Hart at the University of Delaware.  \\n\\\n                                                                    \\n\\\n    This software is provided on an 'AS IS' basis.  All warranties, \\n\\\n    including the implied warranties of merchantability and fitness,\\n\\\n    are expressly denied.                                           \\n\\\n                                                                    \\n\\\n    Provided this copyright notice is included, this software may   \\n\\\n    be freely distributed and not offered for sale.                 \\n\\\n                                                                    \\n\\\n    Changes or modifications may be made and used only by the maker \\n\\\n    of same, and not further distributed.  Such modifications should\\n\\\n    be mailed to the author for consideration for addition to the   \\n\\\n    software and incorporation in subsequent releases.\";\n\n/*********************************************************************/\n\n#ifdef I370\nchar * _style = \"tso:\";\n#endif\n\n/*********************************************************************/\n\nstatic Bool\ngo_for_it(gp,ip)\nstruct ggcb            *gp;\nstruct gopherinfo      *ip;\n{\n char                   temp   [32];\n\n (void)GGMivget(gp,\"GGHOST \",ip->host,sizeof(ip->host));\n (void)GGMivget(gp,\"GGPATH \",ip->path,sizeof(ip->path));\n (void)GGMivget(gp,\"GGDESC \",ip->desc,sizeof(ip->desc));\n (void)GGMivget(gp,\"GGPORT \",temp    ,sizeof(temp)    );\n ip->type = INITIAL_TYPE;\n if (!*ip->path) strcpy(ip->path,INITIAL_PATH);\n if (!*ip->host) strcpy(ip->host,INITIAL_HOST);\n if (!*ip->desc) strcpy(ip->desc,INITIAL_DESC);\n ip->port = atoi(temp);\n if (ip->port == 0) ip->port = INITIAL_PORT;\n\n return GGMgofor(gp,ip,FALSE);\n\n}\n\n/*********************************************************************/\n\nint\nmain(argc,argv)\nint      argc;\nchar   **argv;\n\n{\n struct ggcb            *gp;\n struct gopherinfo      *ip;\n char                   *p;\n int                     i;\n int                     exit_return_code;\n Bool                    bypass_startup;\n struct ggcb             gg;\n char                    zerrsm [25];\n char                    zerrlm [73];\n\n exit_return_code = 0;\n\n memset(&gg,0,sizeof(struct ggcb));\n\n gp = &gg;\n\n /* set up top-level gopherinfo structure */\n\n GETMAIN(ip, struct gopherinfo, 1, \"top-level gopherinfo struct\");\n if (!ip) {\n   fprintf(stderr,\"Not enough memory to start up GOPHER\\n\");\n   exit(16);\n }\n\n memset(ip,0,sizeof(struct gopherinfo));\n\n gp->ginfo = ip;\n\n gp->test_mode  = FALSE;\n gp->debug_mode = FALSE;\n gp->local_mode = FALSE;\n bypass_startup = FALSE;\n\n for (i = 1; i < argc; i++) {\n   p = argv[i];\n   if (*p == '-') {\n     while (*++p) {\n       switch (toupper(*p)) {\n         case 'T':  gp->test_mode  = TRUE;    break;\n         case 'D':  gp->debug_mode = TRUE;    break;\n         case 'L':  gp->local_mode = TRUE;    break;\n         case 'Q':  bypass_startup = TRUE;    break;\n         default: fprintf(stderr,\"GGMVS: Bad parameter flag %c\\n\", *p);\n                  exit_return_code = 8;\n       }\n     }\n   }\n   else {\n     fprintf(stderr,\"GGMVS: Bad parameter string %s\\n\",p);\n     exit_return_code = 8;\n   }\n }\n\n if (gp->test_mode) __ctest(NULL);\n\n if (gp->debug_mode) {\n   if (!(gp->debug_file = fopen(\"dd:ggdebug\",\"w\"))) {\n     perror(\"debug file (DD GGDEBUG)\");\n     exit_return_code = 4;\n   }\n }\n else gp->debug_file = NULL;\n\n gp->thdr.first_text_line = NULL;\n\n GGMclrtx(gp,NULL);               /* Clear text       */\n GGMclrtx(gp,ip);                 /* Clear text       */\n\n gp->g_bytes_returned = 0;\n gp->g_buf_index      = -1;\n\n /* Determine the local path name. Done in GGMCONN when needed now */\n\n strcpy(gp->ggserver,\"\");\n gp->connected_to_server   = FALSE;\n gp->closing_connection    = FALSE;\n gp->reconnect_in_progress = FALSE;\n gp->receiving_text        = FALSE;\n\n GETMAIN(gp->server_buf,    char,SERVER_BUF_MSGSIZE+4,\"server buffer\");\n GETMAIN(gp->client_buf,    char,CLIENT_BUF_MSGSIZE+4,\"client buffer\");\n GETMAIN(gp->gopher_command,char,CLIENT_BUF_MSGSIZE+4,\"gopher command\");\n\n#ifdef FETCH\n\n gp->isplink_pointer = (int (*) ())fetch(\"ISPLINK\");\n gp->ispexec_pointer = (int (*) ())fetch(\"ISPEXEC\");\n\n#endif\n\n if (!GGMispf(gp,\"CONTROL ERRORS RETURN\")) exit_return_code = 20;\n\n else {\n\n   exit_return_code = 0;\n\n   /* not done yet:  set up command and selection code tables */\n\n   GGMsopt(gp,OPTION_ALL);      /* set options */\n\n   if (bypass_startup) {\n     (void)GGMispf(gp,\"VGET (GGHOST GGPATH GGDESC GGPORT) PROFILE\");\n     (void)go_for_it(gp,ip);\n   }\n   else {\n     (void)GGMivput(gp,\"ZCMD \"    ,\"\",-1);\n     while (GGMdispl(gp,\"GGM     \") == 0\n         && !gp->quit\n         && !go_for_it(gp,ip)) ;\n   }\n }\n\n if (gp->setmsg) {\n   (void)GGMivget(gp,\"ZERRSM \",zerrsm, sizeof(zerrsm));\n   (void)GGMivget(gp,\"ZERRLM \",zerrlm, sizeof(zerrlm));\n   fprintf(stderr,\"%s: %s\\n\",zerrsm,zerrlm);\n   gp->setmsg = FALSE;\n }\n\n if (gp->connected_to_server) {\n   GGMdisc(gp);                 /* disconnect from news server */\n }\n\n FREEMAIN(gp->gopher_command,\"gopher command\");\n FREEMAIN(gp->server_buf,    \"server buffer\");\n FREEMAIN(gp->client_buf,    \"client buffer\");\n FREEMAIN(gp->ginfo,         \"top-level gopherinfo struct\");\n\n #define FINAL_CLOSE(A,B) \\\n   if (A) { \\\n            if (fclose(A) < 0) fprintf(stderr,B); \\\n          }\n\n FINAL_CLOSE(gp->debug_file, \"Error closing debug file\\n\");\n\n exit(exit_return_code);\n}\n\n./   ADD NAME=GGMALLOC,SSI=01030039\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ALLOC\")\n#pragma  csect(static,\"GG$ALLOC\")\n#include \"gg.h\"\n\n/****** Allocate a data set. *****************************************/\n\nenum data_set_type\nGGMalloc(dsname,ddname,wanted_type,nitems)\nchar                      *dsname;\nchar                      *ddname;\nenum data_set_type         wanted_type;\nint                        nitems;\n{\n int                       i;\n int                       rc;\n char                     *cp;\n enum data_set_type        return_type;\n Bool                      try_new;\n short                     primary_allocation   ;\n short                     secondary_allocation ;\n short                     directory_blocks     ;\n short                     dsorg                ;\n __S99parms                stuff99; /* No \"struct\", despite manual */\n TEXTUNIT                 *tu [17];\n TEXTUNIT                  tu_dsn;\n TEXTUNIT                  tu_ddn;\n TEXTUNIT                  tu_member;\n TEXTUNIT                  tu_stat;\n TEXTUNIT                  tu_disp;\n TEXTUNIT                  tu_perm;\n TEXTUNIT                  tu_rtddn;\n TEXTUNIT                  tu_rtorg;\n TEXTUNIT                  tu_block;\n TEXTUNIT                  tu_prime;\n TEXTUNIT                  tu_sec;\n TEXTUNIT                  tu_dir;\n TEXTUNIT                  tu_recfm;\n TEXTUNIT                  tu_lrecl;\n TEXTUNIT                  tu_blksz;\n TEXTUNIT                  tu_dsorg;\n char                     *lparp;\n char                     *rparp;\n char                      dsnseq [81];\n char                      member [81];\n char                      what_to_open[81];\n FILE                     *mfile;\n\n try_new = FALSE;\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n strcpy(member,\"\");\n strcpy(dsnseq,dsname);\n lparp = strchr(dsnseq,'(');\n rparp = strchr(dsnseq,')');\n if (lparp && rparp && (lparp < rparp) && (*(rparp+1) == '\\0')) {\n   *lparp = '\\0';            /* makes dsnseq the seq part only */\n   *rparp = '\\0';            /* turns member into a string     */\n   strcpy(member, lparp+1);\n   wanted_type = PDS;\n }\n\n for (;;) {\n\n   stuff99.__S99RBLN   = 20;\n   stuff99.__S99VERB   = S99VRBAL;\n   stuff99.__S99FLAG1  = S99NOCNV << 8;\n   stuff99.__S99ERROR  = 0;\n   stuff99.__S99INFO   = 0;\n   stuff99.__S99TXTPP  = tu;\n   stuff99.__S99FLAG2  = 0;\n\n   i = 0;\n\n   tu[i++] = &tu_dsn;\n\n   tu_dsn.key        = DALDSNAM;\n   tu_dsn.num        = 1;\n   tu_dsn.ent.len    = strlen(dsnseq);\n   strcpy(tu_dsn.ent.prm,dsnseq);\n   for (cp=tu_dsn.ent.prm; *cp; cp++) *cp = toupper(*cp);\n\n   tu[i++] = &tu_stat;\n\n   tu_stat.key      = DALSTATS;\n   tu_stat.num      = 1;\n   tu_stat.ent.len  = 1;\n   *tu_stat.ent.prm = (try_new ? NEW : SHR);\n\n   tu[i++] = &tu_disp;\n\n   tu_disp.key      = DALNDISP;\n   tu_disp.num      = 1;\n   tu_disp.ent.len  = 1;\n   *tu_disp.ent.prm = (try_new ? CATLG : KEEP);\n\n   tu[i++] = &tu_rtorg;\n\n   tu_rtorg.key     = DALRTORG;\n   tu_rtorg.num     = 1;\n   tu_rtorg.ent.len = 2;\n\n   if (*member) {\n\n     tu[i++] = &tu_member;\n\n     tu_member.key     = DALMEMBR;\n     tu_member.num     = 1;\n     tu_member.ent.len = strlen(member);\n     strcpy(tu_member.ent.prm,member);\n     for (cp=tu_member.ent.prm; *cp; cp++) *cp = toupper(*cp);\n\n   }\n\n   if (ddname && *ddname) {\n\n     tu[i++] = &tu_ddn;\n\n     tu_ddn.key     = DALDDNAM;\n     tu_ddn.num     = 1;\n     tu_ddn.ent.len = strlen(ddname);\n     strcpy(tu_ddn.ent.prm,ddname);\n     for (cp=tu_ddn.ent.prm; *cp; cp++) *cp = toupper(*cp);\n\n     tu[i++] = &tu_perm;\n\n     tu_perm.key     = DALPERMA;\n     tu_perm.num     = 0;\n   }\n   else {\n\n     tu[i++] = &tu_rtddn;\n\n     tu_rtddn.key     = DALRTDDN;\n     tu_rtddn.num     = 1;\n     tu_rtddn.ent.len = 8;\n     memset(tu_rtddn.ent.prm,' ',8);\n\n   }\n\n   if (try_new) {\n\n     switch (wanted_type) {\n       case PDS:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = ((short)nitems/(12*36)+1) * 36;\n                 dsorg                = DSORG_PO;\n                 break;\n       case SEQ:\n       default:\n                 primary_allocation   = (short)nitems;\n                 secondary_allocation = primary_allocation;\n                 directory_blocks     = 0;\n                 dsorg                = DSORG_PS;\n                 break;\n     }\n\n     tu[i++] = &tu_block;\n\n     tu_block.key     = DALBLKLN;\n     tu_block.num     = 1;\n     tu_block.ent.len = 3;\n     memset(tu_block.ent.prm,0,3);\n     *(short *)(tu_block.ent.prm+1) = 6233;\n\n     tu[i++] = &tu_prime;\n\n     tu_prime.key     = DALPRIME;\n     tu_prime.num     = 1;\n     tu_prime.ent.len = 3;\n     memset(tu_prime.ent.prm,0,3);\n     *(short *)(tu_prime.ent.prm+1) = primary_allocation;\n\n     tu[i++] = &tu_sec;\n\n     tu_sec.key     = DALSECND;\n     tu_sec.num     = 1;\n     tu_sec.ent.len = 3;\n     memset(tu_sec.ent.prm,0,3);\n     *(short *)(tu_sec.ent.prm+1) = secondary_allocation;\n\n     tu[i++] = &tu_dir;\n\n     tu_dir.key     = DALDIR;\n     tu_dir.num     = 1;\n     tu_dir.ent.len = 3;\n     memset(tu_dir.ent.prm,0,3);\n     *(short *)(tu_dir.ent.prm+1) = directory_blocks;\n\n     tu[i++] = &tu_recfm;\n\n     tu_recfm.key        = DALRECFM;\n     tu_recfm.num        = 1;\n     tu_recfm.ent.len    = 1;\n     *tu_recfm.ent.prm   = RECFM_VB;\n\n     tu[i++] = &tu_lrecl;\n\n     tu_lrecl.key        = DALLRECL;\n     tu_lrecl.num        = 1;\n     tu_lrecl.ent.len    = 2;\n     *(short *)tu_lrecl.ent.prm   = 259;\n\n     tu[i++] = &tu_blksz;\n\n     tu_blksz.key        = DALBLKSZ;\n     tu_blksz.num        = 1;\n     tu_blksz.ent.len    = 2;\n     *(short *)tu_blksz.ent.prm   = 6233;\n\n     tu[i++] = &tu_dsorg;\n\n     tu_dsorg.key        = DALDSORG;\n     tu_dsorg.num        = 1;\n     tu_dsorg.ent.len    = 2;\n     *(short *)tu_dsorg.ent.prm   = dsorg;\n\n   }\n\n   tu[i] = (void *)0x80000000;\n\n   rc = svc99(&stuff99);\n\n   if (rc == 0) {\n     if (!(ddname && *ddname)) {\n       memcpy(ddname,(char *)tu_rtddn.ent.prm,8);\n       *(ddname+8) = ' ';\n       *(strchr(ddname,' ')) = '\\0';\n     }\n     switch (tu_rtorg.ent.prm[0]) {\n       case 0x40:  return_type = SEQ; break;\n       case 0x02:  return_type = PDS; break;\n       default:    return_type = UNK; break;\n     }\n     if (wanted_type == SEQ && return_type != SEQ) {\n       fprintf(stderr,\"%s: not a sequential data set\\n\",dsname);\n     }\n     if (wanted_type == PDS && return_type != PDS) {\n       fprintf(stderr,\"%s: not a partitioned data set\\n\",dsname);\n     }\n     if (return_type == PDS && *member) return SEQ;\n     else return return_type;\n   }\n   else if (!try_new && nitems != 0 && stuff99.__S99ERROR == 0x1708) {\n    try_new = TRUE;\n    continue;\n   }\n   else {\n     GGMdfail(rc,&stuff99);\n     return UNK;\n   }\n }\n}\n\n./   ADD NAME=GGMBRIFC,SSI=01020028\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@BRIFC\")\n#pragma  csect(static,\"GG$BRIFC\")\n#include \"gg.h\"\n\n/****** BRIF primary command function. *******************************/\n\nint\nGGMbrifc(numptr,dialog_data_ptr)\nint                  *numptr;\nvoid                 *dialog_data_ptr;\n{\n Rstruc ggcb         *gp = *(Rstruc ggcb **)dialog_data_ptr;\n Rstruc gopherinfo   *ip = gp->ginfo;\n struct gopherinfo   *ip1;\n char                 zcmd[80];\n char                 command[80];\n char                 operand[80];\n char                *p;\n int                  opoff;\n\n /*\n  * For commands which are supposed to terminate the current BRIF\n  * (like NEXT and PREV), we return an invalid return code, which\n  * is documented to make BRIF itself return with a code of 16,\n  * which we treat as a normal end.\n  */\n\n (void)GGMivget(gp,\"ZCMD \",zcmd,sizeof(zcmd));\n strcpy(command,\"\");\n strcpy(operand,\"\");\n if (1 <= sscanf(zcmd,\"%s %n\",&command,&opoff)) {\n   for (p=command;*p;p++) *p = toupper(*p);\n   if ((EQUAL(command,\"EXTRACT\") ||  EQUAL(command,\"EXT\")))  {\n     if (!ip) (void)GGMivput(gp,\"GGTNUM \",\"\",-1);\n     gp->extract_file = NULL;\n     (void)GGMispf(gp,\"CONTROL DISPLAY SAVE\");\n     (void)GGMxtx(gp,ip);                        /* Extract text */\n     (void)GGMispf(gp,\"CONTROL DISPLAY RESTORE\");\n     return 0;\n   }\n   else\n   if (EQUAL(command,\"PRT\")) {\n     (void)GGMispf(gp,\"CONTROL DISPLAY SAVE\");\n     GGMptx(gp,ip);            /* Print text */\n     (void)GGMispf(gp,\"CONTROL DISPLAY RESTORE\");\n     return 0;\n   }\n   else\n   if (EQUAL(command,\"QUIT\")) {\n     gp->quit = TRUE;\n     return 1;\n   }\n   else {\n     ERR1(\n          \"The only non-BROWSE commands available are EXTract and PRT.\"\n         );\n     return 12;\n   }\n }\n\n return 4; /* ISPF-PDF should handle the command */\n\n}\n\n./   ADD NAME=GGMBRIFR,SSI=01000032\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@BRIFR\")\n#pragma  csect(static,\"GG$BRIFR\")\n#include \"gg.h\"\n\n/****** BRIF read function. ******************************************/\n\nint\nGGMbrifr(dataptr,lenptr,recnoptr,dialog_data_ptr)\nchar                **dataptr;\nint                  *lenptr;\nint                  *recnoptr;\nvoid                 *dialog_data_ptr;\n{\n Rstruc textline     *tp;\n Rstruc ggcb         *gp;\n Rstruc texthdr      *thp;\n        int           return_value;\n        int           current_recno;\n        int           i;\n\n gp             = *(struct ggcb **)dialog_data_ptr;\n thp            = gp->brifp;\n current_recno  = *recnoptr;\n return_value   = 0;\n tp             = NULL;\n\n if (current_recno == 99999999) {    /* scroll down max request */\n   tp = NULL;\n }\n else if (thp->current_text_line != NULL &&\n          current_recno == gp->brif_previous_recno+1) {\n   tp = thp->current_text_line->next;\n   while (tp && tp->text_length < 0) tp = tp->next;\n }\n else {\n   for (i = 0, tp = thp->first_text_line; tp; tp = tp->next) {\n     if (tp->text_length >= 0) {\n       if (++i >= current_recno) break;\n     }\n   }\n }\n\n if (tp == NULL) {\n   *recnoptr = thp->text_line_count;\n   return_value = 8;\n }\n else {\n   thp->current_text_line = tp;\n   *dataptr = tp->tab_expanded_text;\n   *lenptr  = tp->tab_expanded_text_length;\n   return_value = 0;\n }\n\n gp->brif_previous_recno = current_recno;\n\n return return_value;\n\n}\n\n./   ADD NAME=GGMCLRTX,SSI=01000031\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CLRTX\")\n#pragma  csect(static,\"GG$CLRTX\")\n#include \"gg.h\"\n\n/****** Clear text. **************************************************/\n\nvoid\nGGMclrtx(gp,ip)\nRstruc ggcb           *gp;\nRstruc gopherinfo     *ip;\n\n{\n Rstruc texthdr       *thp;\n Rstruc textline      *tp1;\n Rstruc textline      *tp2;\n\n /* If info is not specified, use main ggcb, else info's text */\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n tp1=thp->first_text_line;\n while (tp1) {\n  tp2 = tp1->next;\n  FREEMAIN(tp1,\"text line\");\n  tp1 = tp2;\n }\n\n thp->text_body_line    = NULL;\n thp->first_text_line   = NULL;\n thp->current_text_line = NULL;\n thp->last_text_line    = NULL;\n thp->text_line_count   = 0;\n thp->text_max_length   = 0;\n thp->text_max_tab_expanded_length   = 0;\n\n return;\n\n}\n\n./   ADD NAME=GGMCONN,SSI=010D0008\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CONN \")\n#pragma  csect(static,\"GG$CONN \")\n#include \"gg.h\"\n\n/****** Internet address formatter. **********************************/\n\nstatic void\nformat_ip_address(ia,is)\nIPADDRESS   ia;\nchar       *is;\n{\n char *cp = (char *)&ia;\n\n sprintf(is,\"%d.%d.%d.%d\",*cp,*(cp+1),*(cp+2),*(cp+3));\n return;\n}\n\n/****** Get client hostname and IP address. **************************/\n\nstatic Bool\nget_client_hostname(gp)\nRstruc ggcb *gp;\n{\n struct hostent    *client_hp;\n int                gethostnamerc;\n int                hostlen;\n int                domslen;\n\n gethostnamerc = gethostname(gp->client_hostname,MAXHOSTNAMELEN);\n if (gethostnamerc < 0) {\n   fprintf(stderr,\"GGMVS: gethostname() failed, don't know my name\\n\");\n   return FALSE;\n }\n\n#ifdef APPEND_DOMAIN_NAME_TO_SELF\n\n hostlen = strlen(gp->client_hostname);\n domslen = sizeof(MY_DOMAIN_SUFFIX) - 1;\n if (hostlen <= domslen ||\n     memcmp(gp->client_hostname+hostlen-domslen,\n            MY_DOMAIN_SUFFIX, domslen)) {\n   strncat(gp->client_hostname,MY_DOMAIN_SUFFIX,domslen);\n }\n\n#endif\n\n uppercase_in_place(gp->client_hostname);\n\n client_hp = gethostbyname(gp->client_hostname);\n if (!client_hp) {\n   fprintf(stderr,\"GGMVS: gethostbyname() failed, can't get my name\\n\");\n   return FALSE;\n }\n\n strcpy(gp->ggclient,gp->client_hostname);\n strcpy(gp->client_hostname, client_hp->h_name);\n gp->client_ip_address = *(IPADDRESS *)client_hp->h_addr;\n\n return TRUE ;\n\n}\n\n/****** Connect to news server. **************************************/\n\nBool\nGGMconn(gp)\nRstruc ggcb *gp;\n{\n char              *lp;\n char              *cp;\n struct recvstruct *R;\n struct hostent    *server_hp;\n struct sockaddr_in bindsock;       /* socket used by bind           */\n struct sockaddr_in consock;        /* socket used by connect        */\n int                bindsocklen;    /* size of bind socket           */\n int                consocklen;     /* size of connect socket        */\n int                bindrc;         /* the return code from bind     */\n int                connrc;         /* the return code from connect  */\n int                ip_part_1;\n int                ip_part_2;\n int                ip_part_3;\n int                ip_part_4;\n char               tempdsn[L_tmpnam];\n\n if (gp->connected_to_server) {\n   GGMdisc(gp);                /* Disconnect from news server */\n }\n\n gp->closing_connection = FALSE;\n\n if (!*gp->ggserver) {\n   ERR1(\n  \"No host server defined in Gopher menu,  Cannot make a connection.\"\n       );\n   return FALSE;\n }\n\n uppercase_in_place(gp->ggserver);\n\n /* If server is \"local hack\", then establish local mode,\n  * open temporary file and return.\n  */\n\n if (!strcmp(gp->ggserver, LOCAL_HOST_FROB)) {\n\n   if (gp->ginfo->port != GOPHER_PORT_NUMBER) {\n     ERR3(\"Server name %s is permitted only with port number %d.\",\n          LOCAL_HOST_FROB, GOPHER_PORT_NUMBER);\n     return FALSE;\n   }\n\n   GETMAIN(gp->recvp,struct recvstruct, 1, \"local recv struct\");\n   if (!gp->recvp) {\n     CRIT1(\"Can't get memory for local host struct\");\n     return FALSE;\n   }\n   R = gp->recvp;\n   memset(R,0,sizeof(struct recvstruct));\n\n   if (!tmpnam(tempdsn)) {\n     CRIT1(\"Can't create temporary file for local access\");\n     return FALSE;\n   }\n\n   /* Create temporary file for writing and reading. */\n\n   R->outfp = fopen(tempdsn,\"w+,type=memory\");\n   if (!R->outfp) {\n     perror(tempdsn);\n     CRIT1(\"Can't open temporary file for local access\");\n     return FALSE;\n   }\n\n   gp->connected_to_server = TRUE;\n   gp->time_to_go_home     = FALSE;\n   gp->connection_broken   = FALSE;\n\n   GGMesrvr(gp);\n\n   return TRUE;\n }\n\n /* Disallow network connections if started up in local mode. */\n\n if (gp->local_mode) {\n   ERR1(\"Network connections are not allowed in local mode.\");\n   return FALSE;\n }\n\n /* Determine the local path name. Do only if making net conn. */\n\n if (!*gp->client_hostname) {\n\n   if (!get_client_hostname(gp)) return FALSE;\n\n }\n\n /* Get server name and address.  */\n\n if (strchr(gp->ggserver,'.') &&\n     gp->ggserver[strspn(gp->ggserver,\".0123456789\")] == '\\0') {\n   ip_part_1 = ip_part_2 = ip_part_3 = ip_part_4 = 32767;\n   strcpy(gp->server_hostname, gp->ggserver);\n   sscanf(gp->ggserver,\"%d.%d.%d.%d\",&ip_part_1,\n                                     &ip_part_2,\n                                     &ip_part_3,\n                                     &ip_part_4);\n   if (ip_part_1 > 255 ||\n       ip_part_2 > 255 ||\n       ip_part_3 > 255 ||\n       ip_part_4 > 255) {\n     ERR2(\"Syntax error in server network address: %s\", gp->ggserver);\n     return FALSE;\n   }\n   gp->server_ip_address = (IPADDRESS) ((ip_part_1 << 24) +\n                                        (ip_part_2 << 16) +\n                                        (ip_part_3 <<  8) +\n                                        (ip_part_4      ));\n }\n else {\n   server_hp = gethostbyname(gp->ggserver);\n   if (!server_hp) {\n     ERR2(\n\"Unknown host %s - gethostbyname() could not resolve the server name.\",\n          gp->ggserver);\n     return FALSE;\n   }\n   strcpy(gp->server_hostname, server_hp->h_name);\n   gp->server_ip_address = *(IPADDRESS *)server_hp->h_addr;\n }\n\n format_ip_address(gp->server_ip_address, gp->server_ip_addrstr);\n format_ip_address(gp->client_ip_address, gp->client_ip_addrstr);\n\n (void)GGMivput(gp,\"GGSERVER \",gp->ggserver,-1);\n (void)GGMivput(gp,\"GGSERVIP \",gp->server_ip_addrstr,-1);\n (void)GGMivput(gp,\"GGCLIENT \",gp->ggclient,-1);\n (void)GGMivput(gp,\"GGCLIEIP \",gp->client_ip_addrstr,-1);\n\n consock.sin_family       = AF_INET;\n consock.sin_port         = htons(gp->ginfo->port);\n consock.sin_addr.s_addr  = gp->server_ip_address;\n\n bindsock.sin_family      = AF_INET;\n bindsock.sin_port        = 0;\n#ifdef SNSTCPIP\n bindsock.sin_addr.s_addr = INADDR_ANY;\n#else\n bindsock.sin_addr.s_addr = gp->client_ip_address;\n#endif\n\n gp->socknum = socket(AF_INET, SOCK_STREAM, 0);\n if (gp->socknum < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP error: socket() failed to make socket for server %s.\",\n        gp->ggserver);\n   return FALSE;\n }\n\n bindsocklen = sizeof(bindsock);\n bindrc = Bind(gp->socknum, &bindsock, bindsocklen);\n if (bindrc < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP error: bind() failed to bind socket for server %s.\",\n        gp->ggserver);\n   return FALSE;\n }\n\n (void)GGMispf(gp,\"CONTROL DISPLAY LOCK\");\n (void)GGMispf(gp,\"DISPLAY PANEL(GGMLCONN)\");\n\n if (gp->debug_file) {\n   fprintf(gp->debug_file,\n           \"Client %s (%s) connecting to GOPHER server on %s (%s)\\n\",\n           gp->client_hostname,\n           gp->client_ip_addrstr,\n           gp->server_hostname,\n           gp->server_ip_addrstr);\n }\n\n consocklen = sizeof(consock);\n connrc = Connect(gp->socknum, &consock, consocklen);\n\n if (connrc < 0) {\n   REPORT_TCP_ERROR(gp->ggserver);\n   ERR2(\"TCP/IP failure: connect() failed to connect to server %s.\",\n        gp->ggserver);\n   return FALSE;\n }\n\n gp->connected_to_server = TRUE;\n gp->time_to_go_home     = FALSE;\n gp->connection_broken   = FALSE;\n\n /* Clean up any stray responses from server. */\n\n GGMesrvr(gp);                             /* End server read */\n\n return TRUE;\n\n}\n\n./   ADD NAME=GGMCSO,SSI=01000040\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@CSO\")\n#pragma  csect(static,\"GG$CSO\")\n#include \"gg.h\"\n\n/****** Gopher CSO interface. ************************************/\n\nBool\nGGMcso(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;        /* ignored */\n{\n char              *lp;\n Bool               got_some;\n char               ggcsoq[256];\n int                e_index_i;\n char               e_index_c[10];\n char               sep[80] =\n                              \"--------------------\";\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n\n strcpy(ggcsoq,\"\");\n\n GGMispf(gp,\"VGET (GGCSOQ) PROFILE\");\n\n if (GGMdispl(gp,\"GGMPCSO \") > 0) return FALSE;\n\n GGMivget(gp,\"GGCSOQ \",ggcsoq, sizeof(ggcsoq));\n\n /***** set up query command to server ****** start ******************/\n\n strcpy(gp->gopher_command,\"query \");\n if (!*ip->path)\n     strcpy(gp->gopher_command + 6, ggcsoq);\n else\n     sprintf(gp->gopher_command + 6,\"%s\\t%s\",ip->path,ggcsoq);\n strcat(gp->gopher_command,\" return all\");\n\n /***** set up query command to server ****** end   ******************/\n\n gp->ginfo = ip;\n gp->receiving_text = FALSE;\n\n if (!GGMconn(gp)) return FALSE;   /* Connect to gopher server      */\n\n if (!GGMsockt(gp)) return FALSE;  /* Send socket command to server */\n\n GGMclrtx(gp,ip);                  /* Clear text */\n\n gp->receiving_text = TRUE;\n got_some = FALSE;\n e_index_i = 2;\n sprintf(e_index_c,\":%u:\",e_index_i);\n do {\n   if (GGMgsrvl(gp,&lp,FALSE)) {          /* Get server line */\n     if (lp) {\n       if (strstr(lp,e_index_c) != NULL) { /* if new entry */\n         (void)GGMouttx(gp,sep,ip);        /* Output separator */\n         ++e_index_i;                      /* Increment index  */\n         sprintf(e_index_c,\":%u:\",e_index_i);\n       }\n       got_some = TRUE;\n       (void)GGMouttx(gp,lp,ip);          /* Output text line */\n       if (lp[0] != '-' && strncmp(lp,\"200\",3) >= 0) break;\n     }\n   }\n } while (lp);                            /* until no more lines */\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n /* Send quit command        */\n\n gp->receiving_text = FALSE;\n\n strcpy(gp->gopher_command,\"quit\");\n\n if (!GGMsockt(gp)) return FALSE;  /* Send socket command to server */\n\n /* Read Bye message         */\n\n gp->receiving_text = TRUE;\n\n (void)GGMgsrvl(gp,&lp,FALSE);            /* Get server line */\n\n if (gp->connected_to_server) {\n   (void)GGMdisc(gp);              /* Disconnect from gopher server */\n }\n\n GGMvtx(gp,ip,as_file);  /* display text from CSO server */\n\n return TRUE;\n\n}\n\n./   ADD NAME=GGMDFAIL,SSI=01000005\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DFAIL\")\n#pragma  csect(static,\"GG$DFAIL\")\n#include \"gg.h\"\n\n/****** Retrieve allocation failure messages. ************************/\n\nvoid\nGGMdfail(rc,p99)\nint            rc;\n__S99parms    *p99;\n{\n int           zero = 0;\n unsigned int  dfid = 0x40320000;\n struct {\n         short first_level_msg_len;\n         short first_level_msg_offset;\n         char  first_level_msg[251];\n         short second_level_msg_len;\n         short second_level_msg_offset;\n         char  second_level_msg[251];\n        }      dfbuffer;\n\n static int (*ikjeff18_pointer)() = NULL;\n\n#ifndef FETCH\n extern int *ikjeff18();\n#endif\n\n if (!ikjeff18_pointer) {\n#ifdef FETCH\n   ikjeff18_pointer = (int (*)())fetch(\"IKJEFF18\");\n#else\n   ikjeff18_pointer = (int (*)())ikjeff18;\n#endif\n }\n\n dfbuffer.first_level_msg_len = 4;\n dfbuffer.second_level_msg_len = 4;\n\n if (ikjeff18_pointer) {\n   if ((*ikjeff18_pointer)(p99,&rc,&zero,&dfid,&zero,&dfbuffer)) {\n     fprintf(stderr,\"IKJEFF18 returned a nonzero return code\\n\");\n   }\n   if (dfbuffer.first_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg_len-4,\n                    dfbuffer.first_level_msg);\n   }\n   if (dfbuffer.second_level_msg_len > 0) {\n     fprintf(stderr,\"%*.*s\\n\",\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg_len-4,\n                    dfbuffer.second_level_msg);\n   }\n }\n else {\n#ifdef FETCH\n   fprintf(stderr,\"GGMVS: Cannot fetch IKJEFF18\\n\");\n#else\n   fprintf(stderr,\"Cannot call IKJEFF18, not linked with GGMVS\\n\");\n#endif\n }\n return;\n}\n\n./   ADD NAME=GGMDIR,SSI=012B0041\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DIR  \")\n#pragma  csect(static,\"GG$DIR  \")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nstatic Bool\nvalid_code(c)\nchar       c;\n{\n\n switch (c) {\n   case GOPHER_FILE:\n   case GOPHER_DIRECTORY:\n   case GOPHER_TELNET:\n   case GOPHER_TN3270:\n   case GOPHER_WAIS:\n   case GOPHER_WHOIS:\n   case GOPHER_CSO:\n                           return TRUE;\n   default:                return FALSE;\n  }\n\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_s_selection(gp,ip)\nRstruc ggcb           *gp;\nRstruc gopherinfo     *ip;\n{\n\n GGMgofor(gp,ip,FALSE);\n\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_e_selection(gp,ip)\nRstruc ggcb           *gp;\nRstruc gopherinfo     *ip;\n{\n\n if (ip->thdr.first_text_line) {\n   GGMxtx(gp,ip);\n   return TRUE;\n }\n else {\n   ERR1(\"Extract must be preceded by Select.\");\n   return FALSE;\n }\n}\n\n/*********************************************************************/\n\nstatic Bool\nprocess_q_selection(gp,ip)\nRstruc ggcb           *gp;\nRstruc gopherinfo     *ip;\n{\n\n GGMgofor(gp,ip,TRUE);\n\n return TRUE;\n}\n\n/*********************************************************************/\n\nstatic Bool\ndisplay_dynamic_area(gp,ip,infoarray,entrycount)\nRstruc ggcb           *gp;\nRstruc gopherinfo     *ip;\nRstruc gopherinfo     *infoarray;\nint                    entrycount;\n{\n struct gopherinfo    *iap;\n int                   depth;\n int                   ggglvl;\n int                   dynsize;\n int                   topitem;\n int                   bottomitem;\n int                   last_item_selected;\n int                   dti;\n int                   gii;\n int                   l;\n int                   prc;\n int                   command_index;\n int                   zscrolln;\n Bool                  selection_processed_ok;\n Bool                  command_processed_ok;\n Bool                  is_max;\n char                 *gggdyna;\n char                 *rowp;\n char                 *cp;\n char                  gggcmd     [72];\n char                  zverb       [9];\n char                  zscrolla    [9];\n char                  command    [COMMANDSIZE];\n char                  ggghead    [81];\n char                  rowmessage [81];\n\n /* Get depth of dynamic area (number of rows to display on screen) */\n\n (void)GGMispf(gp,\n       \"PQUERY PANEL(GGMDIR) AREANAME(GGGDYNA) DEPTH(GGGDEPTH)\");\n if (gp->ispfrc != 0) return FALSE;\n depth = GGMiget(gp,\"GGGDEPTH \");\n\n /* Get storage for ISPF dynamic area variable to be constructed. */\n\n dynsize = 80*depth;\n GETMAIN(gggdyna, char, dynsize+1, \"GGGDYNA buffer\");\n if (!gggdyna) return FALSE;\n\n /* Loop displaying the panel until END pressed. */\n\n topitem = 0;\n last_item_selected = -1;\n strcpy(gggcmd,\"\");\n\n do {\n\n /* Fill in the dynamic area with rows, one for each gopher item. */\n\n   memset(gggdyna,' ',dynsize);\n\n   for (dti = 0,       gii = topitem,     rowp = gggdyna;\n        dti < depth && gii < entrycount;\n        dti++,         gii++,             rowp += 80) {\n     iap = &infoarray[gii];\n     rowp[ 0] = DATAIN_HIGH;             /* selection code attribute */\n     rowp[ 1] = ' ';                     /* selection code field     */\n     rowp[ 2] = DATAOUT_GREEN;           /* icon attribute           */\n     memcpy(&rowp[ 3],GGMtype(iap->type),9);\n     rowp[12] = DATAOUT_HIGH;            /* description attribute    */\n     l = strlen(iap->desc);\n     memcpy(&rowp[13],iap->desc,l > 67 ? 67 : l);\n   }\n\n   if (rowp < gggdyna + dynsize) {\n     rowp[0] = DATAOUT_HIGH;\n     memset(&rowp[1], '-',79);\n   }\n\n   bottomitem = gii - 1;\n\n   if (topitem > bottomitem) strcpy(rowmessage,\"\");\n   else sprintf(rowmessage, \" %d-%d of %d\",\n                       topitem + 1, bottomitem + 1, entrycount);\n\n   memset(ggghead,' ',79);\n   ggghead[79] = '\\0';\n   strcpy(ggghead,\"GOPHER - \");\n   strncpy(ggghead+9,ip->desc,70);\n   *strchr(ggghead,'\\0') = ' ';\n   memcpy(ggghead+79-strlen(rowmessage),rowmessage,strlen(rowmessage));\n\n   (void)GGMivput(gp,\"GGGHEAD \",ggghead,79);\n   (void)GGMivput(gp,\"GGGDYNA \",gggdyna, dynsize);\n   (void)GGMivput(gp,\"GGGCMD \" ,gggcmd,  -1);\n\n   prc = GGMdispl(gp,\"GGMDIR  \");\n   if (prc > 8) break;\n\n   (void)GGMivget(gp,\"GGGDYNA \" , gggdyna,  dynsize);\n   (void)GGMivget(gp,\"ZVERB \"   , zverb,    sizeof(zverb));\n   (void)GGMivget(gp,\"ZSCROLLA \", zscrolla, sizeof(zscrolla));\n   zscrolln = GGMiget(gp,\"ZSCROLLN \");\n   ggglvl   = GGMiget(gp,\"GGGLVL \");\n   last_item_selected = -1;\n\n   /* Process selections. */\n\n   for (gii = topitem,         rowp = gggdyna;\n        gii <= bottomitem;\n        gii++,                 rowp += 80) {\n     iap = &infoarray[gii];\n     switch (rowp[1]) {\n       case ' ':  continue;\n       case 's':\n       case 'S':  selection_processed_ok = process_s_selection(gp,iap);\n                  break;\n       case 'e':\n       case 'E':  selection_processed_ok = process_e_selection(gp,iap);\n                  break;\n       case 'q':\n       case 'Q':  selection_processed_ok = process_q_selection(gp,iap);\n                  break;\n       default:\n        ERR1(\"Unknown selection code.  Type one of the listed codes.\");\n                  selection_processed_ok = FALSE;\n                  break;\n     }\n     if (selection_processed_ok) last_item_selected = gii;\n     if (gp->quit) break;\n   }\n\n   /* Process command if any. */\n\n   strcpy(gggcmd,\"\");\n\n   (void)GGMivget(gp,\"GGGCMD \",gggcmd,sizeof(gggcmd));\n\n   if (*gggcmd) {\n\n     memset(command,' ',COMMANDSIZE);\n     command_index = 0;\n     for (cp = gggcmd; *cp && !isspace(*cp); cp++) {\n       if (cp >= gggcmd+COMMANDSIZE) {\n         ERR1(\"Invalid command name.\");\n         command_processed_ok = FALSE;\n       }\n       command[command_index++] = toupper(*cp);\n     }\n     while (*cp && isspace(*cp)) cp++;\n\n     if (memcmp(command,\"QUIT    \",8) == 0) {\n       gp->quit = TRUE;\n     }\n     else {\n       ERR2(\"Unknown command name: %8.8s\",command);\n     }\n     command_processed_ok = FALSE;\n\n     if (command_processed_ok) strcpy(gggcmd,\"\");\n\n   }\n\n   if (gp->quit) break;\n\n   if (last_item_selected >= 0 && gp->autoscroll) {\n     topitem = last_item_selected;\n   }\n\n   /* Process scroll request if any. */\n\n   is_max = EQUAL(zscrolla,\"MAX\");\n   if      (EQUAL(zverb,\"DOWN\")) {\n     if (is_max) topitem = entrycount - ggglvl;\n     else        topitem += zscrolln;\n   }\n   else if (EQUAL(zverb,\"UP\")) {\n     if (is_max) topitem = 0;\n     else        topitem -= zscrolln;\n   }\n   else if (EQUAL(zverb,\"RETURN\")) {\n     gp->quit = TRUE;\n     break;\n   }\n   if (topitem < 0)\n       topitem = 0;\n   if (topitem > entrycount)\n       topitem = entrycount;\n\n } while (prc == 0);\n\n return;\n\n}\n\n/****** Gopher a directory. ******************************************/\n\nBool\nGGMdir(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;\n{\n int                entrycount;\n int                i;\n int                copysize;\n char               typechar;\n char               savechar;\n char              *p;\n char              *q;\n char              *r;\n struct textline   *tp;\n struct gopherinfo *infoarray;\n struct gopherinfo *iap;\n char               temp[16];\n\n if (as_file) {\n   GGMvtx(gp,ip,as_file);  /* if as a file, display text as is */\n   return TRUE;\n }\n\n /* The text chain contains the data from the server, which should be\n  * in the following format:\n  *\n  * nDescription^Path^foo^bar\n  *\n  * where the \"n\" in the beginning is a digit and ^ means a tab char.\n  *\n  * Logic:\n  *\n  * Build an array of gopherinfo structs from the text records.\n  *\n  * Display them as an ISPF dynamic area pseudotable.\n  *\n  * Let the user select them, and run GGMgofor on each one\n  * with a struct gopherinfo built from the contents.\n  *\n  */\n\n /* Determine size of array of gopherinfo structs.  This is equal to\n  * the number of text records with a valid code in the first byte.\n  */\n\n entrycount = 0;\n for (tp = ip->thdr.first_text_line; tp; tp = tp->next) {\n   if (valid_code(tp->text[0])) entrycount++;\n }\n\n if (entrycount == 0) {\n   ERR1(\"There seems to be no information in this directory.\\n\");\n   return FALSE;\n }\n\n /* Allocate an array of structs to hold the stuff. */\n\n GETMAIN(infoarray, struct gopherinfo, entrycount,\"gopherinfo array\");\n\n if (!infoarray) {\n   ERR2(\"Not enough memory for %d gopher directory entries\\n\",\n        entrycount);\n   return FALSE;\n }\n\n /* Build the array entries. */\n\n iap = infoarray;\n for (tp = ip->thdr.first_text_line; tp; tp = tp->next) {\n   typechar = tp->text[0];\n   if (valid_code(typechar)) {\n     r = &tp->text[tp->text_length];\n     savechar = *r;\n     *r = '\\t';\n     memset(iap,0,sizeof(struct gopherinfo));\n     iap->port = GOPHER_PORT_NUMBER;\n     iap->type = (gophertype)typechar;\n     p = &tp->text[1];\n     q = strchr(p,'\\t');\n     copysize = sizeof(iap->desc)-1;\n     if (copysize > q-p) copysize = q-p;\n     memcpy(iap->desc,p,copysize);\n     if (q < r) {\n       p = q+1;\n       q = strchr(p,'\\t');\n       copysize = sizeof(iap->path)-1;\n       if (copysize > q-p) copysize = q-p;\n       memcpy(iap->path,p,copysize);\n       if (q < r) {\n         p = q+1;\n         q = strchr(p,'\\t');\n         copysize = sizeof(iap->host)-1;\n         if (copysize > q-p) copysize = q-p;\n         memcpy(iap->host,p,copysize);\n         if (q < r) {\n           p = q+1;\n           q = strchr(p,'\\t');\n           memset(temp,0,sizeof(temp));\n           copysize = sizeof(temp)-1;\n           if (copysize > q-p) copysize = q-p;\n           memcpy(temp,p,copysize);\n           iap->port = atoi(temp);\n         }\n       }\n     }\n     *r = savechar;\n     iap++;\n   }\n }\n\n if (gp->debug_mode) {\n   for (iap = infoarray, i = entrycount; i > 0; iap++, i--) {\n     fprintf(gp->debug_file,\"GGMdir: type = %d\\n\",iap->type);\n     fprintf(gp->debug_file,\"GGMdir: port = %d\\n\",iap->port);\n     fprintf(gp->debug_file,\"GGMdir: path = %s\\n\",iap->path);\n     fprintf(gp->debug_file,\"GGMdir: host = %s\\n\",iap->host);\n     fprintf(gp->debug_file,\"GGMdir: desc = %s\\n\",iap->desc);\n     fprintf(gp->debug_file,\"\\n\");\n   }\n }\n\n display_dynamic_area(gp,ip,infoarray,entrycount);\n\n FREEMAIN(infoarray,\"gopherinfo array\");\n\n return TRUE;\n}\n\n./   ADD NAME=GGMDISC,SSI=01050033\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DISC \")\n#pragma  csect(static,\"GG$DISC \")\n#include \"gg.h\"\n\n/****** Disconnect from gopher server. ********************************/\n\nvoid\nGGMdisc(gp)\nRstruc ggcb        *gp;\n{\n int                closerc;\n struct recvstruct *R;\n\n /* If local mode, close temporary file and return. */\n\n if ((R=gp->recvp)) {\n   if (R->outfp) {\n     if (fclose(R->outfp) < 0) {\n       CRIT1(\"Error closing local mode temporary file\");\n     }\n     R->outfp = NULL;\n   }\n\n   gp->connected_to_server   = FALSE;\n\n   FREEMAIN(gp->recvp,\"local mode recv struct\");\n   gp->recvp = NULL;\n   return;\n }\n\n gp->reconnect_in_progress = FALSE;\n gp->closing_connection    = TRUE;\n\n if (gp->connection_broken) {\n   if (gp->debug_file) {\n     fprintf(gp->debug_file,\n  \"Client %s (%s) connection with gopher server on %s (%s) was lost\\n\",\n          gp->client_hostname,\n          gp->client_ip_addrstr,\n          gp->server_hostname,\n          gp->server_ip_addrstr);\n   }\n   gp->connected_to_server   = FALSE;\n }\n else {\n\n   /* In case of some kind of protocol error, don't let things hang. */\n\n   GGMesrvr(gp);         /* End server read */\n\n   if (gp->debug_file) {\n     fprintf(gp->debug_file,\n      \"Client %s (%s) disconnecting from gopher server on %s (%s)\\n\",\n          gp->client_hostname,\n          gp->client_ip_addrstr,\n          gp->server_hostname,\n          gp->server_ip_addrstr);\n   }\n\n   (void)GGMivput(gp,\"GGSOLDER \",gp->server_hostname,-1);\n   (void)GGMivput(gp,\"GGSOLDIP \",gp->server_ip_addrstr,-1);\n   (void)GGMispf(gp,\"CONTROL DISPLAY LOCK\");\n   (void)GGMispf(gp,\"DISPLAY PANEL(GGMLDISC)\");\n\n   /* In case of some kind of protocol error, don't let things hang. */\n\n   GGMesrvr(gp);                   /* End server read */\n\n   gp->connected_to_server   = FALSE;\n\n   TCP_DEBUG_ON;\n   closerc = close(gp->socknum);\n   TCP_DEBUG_OFF;\n\n   if (closerc < 0) {\n     ERR2(\"TCP/IP error: close() failed to disconnect from server %s.\",\n          gp->ggserver);\n   }\n }\n\n return;\n}\n\n./   ADD NAME=GGMDISPL,SSI=01010001\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DISPL\")\n#pragma  csect(static,\"GG$DISPL\")\n#include \"gg.h\"\n\n#ifdef FETCH\n#define VL_BIT(X) ((unsigned int)(X) | 0x80000000)\n#else\n#define VL_BIT(X) (X)\n#endif\n\n/****** Display ISPF panel. ******************************************/\n\nint\nGGMdispl(gp,pan8)\nRstruc ggcb    *gp;\nchar           *pan8;\n{\n\n if (gp->setmsg) {\n   gp->ispfrc = ISPLINK(\"DISPLAY \", pan8, VL_BIT(\"ISRZ002 \"));\n }\n else {\n   gp->ispfrc = ISPLINK(\"DISPLAY \", VL_BIT(pan8));\n }\n\n if (gp->ispfrc > 8) GGMierr(gp);   /* display ISPF error */\n\n gp->setmsg = FALSE;\n\n return gp->ispfrc;\n}\n\n./   ADD NAME=GGMDUMP,SSI=01000036\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@DUMP \")\n#pragma  csect(static,\"GG$DUMP \")\n#include \"gg.h\"\n\n/****** Dump some data. **********************************************/\n\nvoid\nGGMdump(struct ggcb *gp, char *label, char *p,int r)\n{\n int i;\n\n if (!gp->debug_file) return;\n\n if (r == -2) {\n   fprintf(gp->debug_file,\"%s:  %d\\n\",label,(int)p);\n   return;\n }\n\n if (r == -1) r = strlen(p);\n\n fprintf(gp->debug_file,\"%s:   (%d characters)\\n\",label,r);\n for (i=0;i<77;i++) fprintf(gp->debug_file,\"-\");\n fprintf(gp->debug_file,\"\\n\");\n for (i=0;i<r;i++) {\n   char c = *(p+i);\n   if (isprint(c))  fprintf(gp->debug_file,\"%c\",c);\n   else             fprintf(gp->debug_file,\"<0x%2.2x>\",c);\n }\n fprintf(gp->debug_file,\"\\n\");\n for (i=0;i<77;i++) fprintf(gp->debug_file,\"-\");\n fprintf(gp->debug_file,\"\\n\");\n\n return;\n\n}\n\n./   ADD NAME=GGMESRVR,SSI=01030044\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ESRVR\")\n#pragma  csect(static,\"GG$ESRVR\")\n#include \"gg.h\"\n\n/****** End server read. *********************************************/\n\nvoid\nGGMesrvr(gp)\nRstruc ggcb  *gp;\n{\n char       *lp;\n Bool        found_more_server_data = FALSE;\n\n GGMclrtx(gp,NULL);                    /* Clear text */\n\n if (gp->recvp) return;                /* Skip if non-socket */\n\n do {\n\n   if (GGMgsrvl(gp,&lp,FALSE)) {       /* Get server line */\n     if (lp) {\n       found_more_server_data = TRUE;\n       (void)GGMouttx(gp,lp,NULL);     /* Output text line */\n     }\n   }\n\n } while (lp);\n\n if (found_more_server_data) {\n   ERR1(\n\"More data was returned by the GOPHER server than GOPHER expected.\"\n       );\n   GGMvtx(gp,NULL,TRUE);              /* View text */\n }\n\n return;\n}\n\n./   ADD NAME=GGMFREEM,SSI=01000001\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@FREEM\")\n#pragma  csect(static,\"GG$FREEM\")\n#include \"gg.h\"\n\n/****** Free memory. *************************************************/\n\nvoid\nGGMfreem(gp,stuff,whatfor)\nRstruc ggcb    *gp;\nchar           *stuff;\nchar           *whatfor;\n{\n\n free(stuff);\n\n if (gp->debug_file) {\n   fprintf(gp->debug_file,\"GGMfreem: freed memory for %s\\n\", whatfor);\n }\n return;\n\n}\n\n./   ADD NAME=GGMGETDS,SSI=01020011\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GETDS\")\n#pragma  csect(static,\"GG$GETDS\")\n#include \"gg.h\"\n\n#define DUMMY_FILE_POINTER_FOR_PDS  (FILE *)(-1)\n\n/****** Prompt user for the name of a data set to extract into. ******/\n\nFILE *\nGGMgetds(gp,ep)\nRstruc ggcb         *gp;\nRstruc extraction   *ep;\n{\n FILE               *xfp;\n Bool                asked_for;\n char                ggexdsn[65];    /* data set name for extraction */\n char                ggexapp [4];    /* YES or NO for append mode    */\n char                ggextab [4];    /* YES or NO for tab expansion  */\n char                ggexblk [4];    /* YES or NO for blank after sep*/\n char                ggexsep[81];    /* Separator line (optional)    */\n char                ggexan1[16];    /* From article number          */\n char                ggexan2[16];    /* To   article number          */\n char                ggexpmp [9];    /* PDS member name prefix       */\n char                ddname  [9];\n char                member  [9];\n char                pdspec [32];\n char                quoted_dsname [67];\n char                formatted_number [11];\n\n /* Display panel asking for data set name into which to extract. */\n\n xfp = NULL;\n asked_for = TRUE;\n\n (void)GGMispf(gp,\"ADDPOP\");\n\n while (xfp == NULL) {\n\n   /* Keep asking for a dsname until one works or END pressed. */\n\n   if (GGMdispl(gp,ep->panelname) > 0) {\n     asked_for = FALSE;\n     xfp = NULL;\n     break;\n   }\n\n   (void)GGMivget(gp,\"GGEXDSN \",ggexdsn,sizeof(ggexdsn));\n   (void)GGMivget(gp,\"GGEXTAB \",ggextab,sizeof(ggextab));\n   (void)GGMivget(gp,\"GGEXAN1 \",ggexan1,sizeof(ggexan1));\n   (void)GGMivget(gp,\"GGEXAN2 \",ggexan2,sizeof(ggexan2));\n   if (ep->mode == PDS) {\n     (void)GGMivget(gp,\"GGEXPMP \",ggexpmp,sizeof(ggexpmp));\n   }\n   else {\n     (void)GGMivget(gp,\"GGEXAPP \",ggexapp,sizeof(ggexapp));\n     (void)GGMivget(gp,\"GGEXBLK \",ggexblk,sizeof(ggexblk));\n     (void)GGMivget(gp,\"GGEXSEP \",ggexsep,sizeof(ggexsep));\n   }\n\n   if (ep->mode == PDS) {\n\n     ep->appending = FALSE;\n     ep->blanking  = FALSE;\n     strcpy(ep->separator,\"\");\n     strcpy(ep->ddname,\"\");\n     strcpy(ep->member_prefix,ggexpmp);\n\n     /* Note: panel forces fully-qualified name to pass to allocate */\n\n     /* check if the PDS already exists */\n\n     if (ggexdsn[0] != '\\'') {\n       strcpy(quoted_dsname,\"'\");\n       strcat(quoted_dsname,ggexdsn);\n       strcat(quoted_dsname,\"'\");\n     }\n     else strcpy(quoted_dsname,ggexdsn);\n\n     /* Check if PDS already exists. */\n\n     if (gp->warn_overwrite) {\n       xfp = fopen(quoted_dsname,\"r\");\n       if (xfp) {\n         (void)fclose(xfp);\n         xfp = NULL;\n         if (GGMdispl(gp,\"GGMPEXPW\") > 0) {\n           WARN1(\"Operation cancelled, because you pressed END.\");\n           break;\n         }\n       }\n     }\n\n     if (GGMalloc(ggexdsn,ep->ddname,PDS,ep->count) != PDS) {\n       ERR2(\"Allocation failed for data set %s.\", ggexdsn);\n       xfp = NULL;\n       continue;\n     }\n     strcpy(ep->dsname,    ggexdsn);\n   }\n   else {\n     strcpy(ep->separator, ggexsep);\n     strcpy(ep->dsname,    ggexdsn);\n     ep->appending = (ggexapp[0] == 'Y');\n     ep->blanking  = (ggexblk[0] == 'Y');\n   }\n\n   ep->tab_expanding = (ggextab[0] == 'Y');\n   if (*ggexan1) ep->from_number = atoi(ggexan1);\n   else          ep->from_number = 0;\n   if (*ggexan2) ep->to_number   = atoi(ggexan2);\n   else          ep->to_number   = INT_MAX;\n\n   /* check if the dataset already exists */\n   /* (Wonder if this will compile.  Have fun, \"cc\"...) */\n\n   if (ep->appending ? gp->warn_append : gp->warn_overwrite) {\n     xfp = fopen(ggexdsn,\"r\");\n     if (xfp) {\n       (void)fclose(xfp);\n       xfp = NULL;\n       if (GGMdispl(gp,\"GGMPEXOW\") > 0) {\n         WARN1(\"Operation cancelled, because you pressed END.\");\n         break;\n       }\n     }\n   }\n\n   if (ep->mode == PDS) {\n     xfp = DUMMY_FILE_POINTER_FOR_PDS;\n     break;\n   }\n\n   xfp = OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(ggexdsn,ep->appending);\n\n   if (!xfp) {\n     perror(ggexdsn);\n     ERR2(\"Cannot open data set %s.\", ep->dsname);\n   }\n }\n\n (void)GGMispf(gp,\"REMPOP\");\n\n return xfp;\n\n}\n\n./   ADD NAME=GGMGETM,SSI=01000052\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GETM \")\n#pragma  csect(static,\"GG$GETM \")\n#include \"gg.h\"\n\n/****** Get memory. **************************************************/\n\nvoid\nGGMgetm(gp,pointer,howmuch,whatfor)\nRstruc ggcb    *gp;\nchar          **pointer;\nint             howmuch;\nchar           *whatfor;\n{\n\n *pointer = (char *)malloc(howmuch);\n\n if (*pointer == NULL) {\n   fprintf(stderr,\"GGMgetm: Cannot obtain %d bytes of memory for %s\\n\",\n                  howmuch,whatfor);\n }\n else if (gp->debug_file) {\n   fprintf(gp->debug_file,\"GGMgetm: got %d bytes of memory for %s\\n\",\n                           howmuch,whatfor);\n }\n return;\n\n}\n\n./   ADD NAME=GGMGOFOR,SSI=011A0004\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GOFOR\")\n#pragma  csect(static,\"GG$GOFOR\")\n#include \"gg.h\"\n\n/********************************************************************/\n\nstatic Bool\nconnect_to_gopher_server(gp,ip,is_cr_needed)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                is_cr_needed;\n{\n char              *lp;\n Bool               got_some;\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n strcpy(gp->gopher_command,ip->path);   /* Specify command to issue */\n gp->ginfo = ip;\n gp->receiving_text = FALSE;\n\n if (!GGMconn(gp)) return FALSE;   /* Connect to gopher server      */\n\n if (!GGMsockt(gp)) return FALSE;  /* Send socket command to server */\n\n GGMclrtx(gp,ip);                  /* Clear text */\n\n gp->receiving_text = TRUE;\n\n got_some = FALSE;\n do {\n   if (GGMgsrvl(gp,&lp,is_cr_needed)) {   /* Get server line */\n     if (lp) {\n       got_some = TRUE;\n       (void)GGMouttx(gp,lp,ip);          /* Output text line */\n     }\n   }\n } while (lp);                            /* until no more lines */\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/****** Gopher it. ***************************************************/\n\nBool\nGGMgofor(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;\n{\n Bool               con;\n Bool               cr;\n Bool             (*fun)(struct ggcb *,struct gopherinfo *,Fool);\n\n   /* (1) send initial path string to initial host\n    * (2) get back data from host\n    * (3) if it is a gopher directory, then do:\n    *      - display \"table\" of items\n    *      - for each item selected, call GGMgofor recursively\n    *     else browse the file data\n    * (4) bye\n    */\n\n if (gp->debug_mode) {\n   fprintf(gp->debug_file,\"GGMgofor: type = %d\\n\",ip->type);\n   fprintf(gp->debug_file,\"GGMgofor: port = %d\\n\",ip->port);\n   fprintf(gp->debug_file,\"GGMgofor: path = %s\\n\",ip->path);\n   fprintf(gp->debug_file,\"GGMgofor: host = %s\\n\",ip->host);\n   fprintf(gp->debug_file,\"GGMgofor: desc = %s\\n\",ip->desc);\n }\n\n switch (ip->type) {\n   case GOPHER_FILE:     fun = GGMvtx;   con = TRUE;  cr = TRUE; break;\n   case GOPHER_DIRECTORY:fun = GGMdir;   con = TRUE;  cr = TRUE; break;\n   case GOPHER_TELNET:   fun = GGMtnet;  con = FALSE; cr = TRUE; break;\n   case GOPHER_TN3270:   fun = GGMtnet;  con = FALSE; cr = TRUE; break;\n   case GOPHER_WAIS:     fun = GGMwais;  con = FALSE; cr = TRUE; break;\n   case GOPHER_WHOIS:    fun = GGMwhois; con = FALSE; cr = TRUE; break;\n   case GOPHER_CSO:      fun = GGMcso;   con = FALSE; cr = FALSE;break;\n   default:\n        ERR2(\"Sorry, access via %s not supported\", GGMtype(ip->type));\n        return FALSE;\n }\n\n if (con) {\n   if (!connect_to_gopher_server(gp,ip,cr)) return FALSE;\n }\n\n /* Insure no connection is active once we do the real thing. */\n\n if (gp->connected_to_server) {\n   (void)GGMdisc(gp);              /* Disconnect from gopher server */\n }\n\n return (fun)(gp,ip,as_file);\n}\n\n./   ADD NAME=GGMGSRVL,SSI=01110001\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@GSRVL\")\n#pragma  csect(static,\"GG$GSRVL\")\n#include \"gg.h\"\n\n/****** Input one character from the server. *************************/\n\nstatic int\nsocket_getchar(gp)\nRstruc ggcb  *gp;\n{\n int         readrc;\n\n if (gp->g_buf_index == -1 ||\n     gp->g_buf_index >= gp->g_bytes_returned - 1) {\n   gp->g_buf_index = -1;\n   if (gp->dont_read) return(SOCKET_NO_MORE);\n   else {\n     TCP_DEBUG_ON;\n     readrc = read(gp->socknum, gp->g_buf, READ_BYTES);\n     TCP_DEBUG_OFF;\n     if (readrc == -1) {\n       gp->connection_broken = TRUE;\n       return SOCKET_GETCHAR_ERROR;\n     }\n     else if (readrc == 0) {\n       gp->connection_broken = FALSE;\n       return SOCKET_READ_NOTHING;\n     }\n     else {\n#ifdef MVS\n       ASCII_TO_EBCDIC(gp->g_buf,readrc);\n#endif\n       gp->g_bytes_returned = readrc;\n     }\n   }\n }\n return gp->g_buf[++gp->g_buf_index];\n}\n\n/****** Input one data line at a time from the server. ***************/\n\nstatic enum socket_retval\nsocket_from_server(gp)\nRstruc ggcb *gp;\n{\n char       *s_buf;\n int         s_bytes;\n int         s_buf_index;\n int         character;\n int         previous_character;\n\n s_buf   = gp->server_buf;\n s_bytes = SERVER_BUF_MSGSIZE;\n\n /* Get characters from the server until CRLF is reached. */\n\n s_buf_index = 0;\n previous_character = -1;\n for (;;) {\n   character = socket_getchar(gp);\n   /*\n   if (character == LINE_FEED && previous_character == CARRIAGE_RETURN)\n      break;\n   */\n   if (character == LINE_FEED) break;\n   if (character == SOCKET_GETCHAR_ERROR)  return(SERVER_READ_ERROR);\n   if (character == SOCKET_NO_MORE)        return(SERVER_NO_MORE);\n   if (character == SOCKET_READ_NOTHING)   return(SERVER_READ_NOTHING);\n   previous_character = character;\n   if (s_buf_index >= s_bytes) {\n     fprintf(stderr,\"Error: gp->server_buf overflowed.\\n\");\n     fprintf(stderr,\n             \"More than %d bytes collected without CR/LF seen.\\n\",\n             s_bytes);\n     if (gp->debug_file) {\n       GGMdump(gp,\"Data collected so far\",gp->server_buf,s_bytes);\n     }\n     return(SERVER_BUFFER_ERROR);\n   }\n   if (character == '\\0') {\n     fprintf(stderr,\n\"Warning: null character found in data from server, changed to blank\\n\"\n            );\n     character = ' ';\n   }\n   s_buf[s_buf_index++] = (unsigned char)character;\n }\n s_buf[s_buf_index] = '\\0';\n return(SERVER_READ_OK);\n}\n\n/****** Get server line. *********************************************/\n\nBool\nGGMgsrvl(gp,pointer,is_cr_needed)\nRstruc ggcb  *gp;\nchar        **pointer;\nFool          is_cr_needed;\n{\n char              *sbufp;\n char              *p;\n int                scan_count;\n Bool               something_to_print;\n struct recvstruct *R;\n\n *pointer = NULL;\n\n /* If local mode, read from temporary file until EOF. */\n\n if ((R=gp->recvp)) {\n   if (!R->outfp) {\n     CRIT1(\"Can't read data locally, non-socket not connected\\n\");\n     return FALSE;\n   }\n   fgets(gp->server_buf, SERVER_BUF_MSGSIZE, R->outfp);\n   if (ferror(R->outfp)) {\n     CRIT1(\"Error reading local non-socket data\\n\");\n     gp->time_to_go_home = TRUE;\n     return FALSE;\n   }\n   if (feof(R->outfp)) return FALSE;\n   if ((p=strchr(gp->server_buf,'\\n'))) *p = '\\0';\n   *pointer = gp->server_buf;\n   return TRUE;\n }\n\n if (!gp->receiving_text) return TRUE;\n\n if (gp->server_finished_replying) gp->dont_read = TRUE;\n\n switch (socket_from_server(gp)) {\n   case SERVER_READ_OK:      break;\n   case SERVER_READ_NOTHING: gp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_READ_ERROR:   ERR2(\n     \"Lost server connection.  Failure reading data from server %s.\",\n                                  gp->ggserver);\n                             gp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_BUFFER_ERROR: ERR2(\n \"Read error.  No linefeed character found in data from server %s.\",\n                                  gp->ggserver);\n                             gp->time_to_go_home = TRUE;\n                             break;\n   case SERVER_NO_MORE:      gp->server_has_something_pending = FALSE;\n                             break;\n }\n\n if (gp->time_to_go_home == TRUE) return FALSE;\n if (gp->dont_read == TRUE &&\n     gp->server_has_something_pending == FALSE) return TRUE;\n\n something_to_print = TRUE;\n\n sbufp = gp->server_buf;\n\n if (gp->sending_text) {\n   if (*sbufp == '.') {\n     switch (*(sbufp+1)) {\n        case CARRIAGE_RETURN:\n        case LINE_FEED:\n        case '\\0':\n                  gp->server_finished_replying = TRUE;\n                  something_to_print = FALSE;\n                  break;\n        case '.':\n                  break;\n        default:\n                  GGMdump(gp,\"Warning, bad period in line from server\",\n                          sbufp,strlen(sbufp));\n                  break;\n     }\n   }\n }\n\n gp->sending_text = TRUE;\n\n if (something_to_print) {\n   /* Last character of output buffer is a CR without LF. */\n   p = sbufp + strlen(sbufp)-1;\n   if (p >= sbufp) {\n     if (*p == CARRIAGE_RETURN) *p = '\\0';\n     else if (is_cr_needed) {\n       /* Last character of output buffer had better be a LF. */\n       if (gp->debug_file) {\n         fprintf(gp->debug_file,\n   \"Warning: No carriage return in data from server (%d bytes):\\n%s\\n\",\n               strlen(sbufp), sbufp);\n       }\n       CRIT2(\n\"Carriage return expected but not seen in data from server %s.\",\n             gp->ggserver);\n     }\n     *(p+1) = '\\0';\n   }\n   *pointer = sbufp;\n }\n\n if (gp->time_to_go_home) return FALSE;\n else return TRUE;\n}\n\n./   ADD NAME=GGMIERR,SSI=01000000\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IERR \")\n#pragma  csect(static,\"GG$IERR \")\n#include \"gg.h\"\n\n/****** ISPF error handler. ******************************************/\n\nvoid\nGGMierr(gp)\nRstruc ggcb *gp;\n{\n char        errbuf[] = \"DISPLAY PANEL(ISPTERM)\";\n int         errlen;\n\n errlen = strlen(errbuf);\n switch (ISPEXEC(&errlen,errbuf)) {\n   case  0:\n   case  4:\n   case  8:\n           return;\n   default:\n           fprintf(stderr,\n\"\\n*** Severe ISPF error, cannot even display ISPTERM error panel.\\n\");\n           fprintf(stderr,\n\"\\n*** Return code from ISPF service is %d\\n\",gp->ispfrc);\n           return;\n }\n}\n\n./   ADD NAME=GGMIGET,SSI=01000045\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IGET \")\n#pragma  csect(static,\"GG$IGET \")\n#include \"gg.h\"\n\n/****** Retrieve the value of an ISPF variable into an integer. ******/\n\nint\nGGMiget(gp,varname)\nRstruc ggcb *gp;\nchar        *varname;\n{\n char        varbuf[16];\n int         vcopy_length;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"GGMiget: no blank passed in var name\\n\");\n   return FALSE;\n }\n\n vcopy_length = sizeof(varbuf);\n\n gp->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (gp->ispfrc) {\n   case  0:\n           varbuf[vcopy_length] = '\\0';\n           return atoi(varbuf);\n   case  8:\n           return 0;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return 0;\n   default:\n           GGMierr(gp);   /* handle ISPF error */\n           return 0;\n }\n}\n\n./   ADD NAME=GGMISPF,SSI=01010021\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@ISPF \")\n#pragma  csect(static,\"GG$ISPF \")\n#include \"gg.h\"\n\n/****** Call ISPF service. *******************************************/\n\nBool\nGGMispf(gp,ispfbuf)\nRstruc ggcb *gp;\nchar        *ispfbuf;\n{\n int         ispflen;\n\n ispflen = strlen(ispfbuf);\n gp->ispfrc = ISPEXEC(&ispflen,ispfbuf);\n if (gp->ispfrc > 8) {\n\n   /* Ignore ADDPOP and REMPOP errors, especially if they are due to\n      ISPF V3 not being active. */\n\n   if (gp->ispfrc == 20\n    && gp->debug_mode == FALSE\n    && ispflen >= 6\n    && (memcmp(ispfbuf,\"ADDPOP\",6) == 0\n     || memcmp(ispfbuf,\"REMPOP\",6) == 0)) {\n     return TRUE;\n   }\n\n   GGMierr(gp);             /* handle ISPF error */\n   return FALSE;\n }\n return TRUE;\n}\n\n./   ADD NAME=GGMIVGET,SSI=01000024\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IVGET\")\n#pragma  csect(static,\"GG$IVGET\")\n#include \"gg.h\"\n\n/****** Retrieve the value of an ISPF variable. **********************/\n\nBool\nGGMivget(gp,varname,varbuf,varbuflen)\nRstruc ggcb *gp;\nchar        *varname;\nchar        *varbuf;\nint          varbuflen;\n{\n int         vcopy_length;\n\n if (!strchr(varname,' ')) {\n   fprintf(stderr,\"GGMivget: no blank passed in var name\\n\");\n   return FALSE;\n }\n\n /*\n  * If varbuflen is negative, that means that the value is not to be\n  * treated as a C string, and the null character is not to be\n  * appended to the resulting value.  This is used for hex values\n  * (like addresses) that are stored in ISPF table row variables.\n  */\n\n if (varbuflen < 0)  vcopy_length = -varbuflen;\n else vcopy_length = varbuflen;\n\n /* Note that on entry, vcopy_length is an integer that contains\n    the length of the buffer.  On return it is updated to the length\n    of the value returned.  Since we have to stick a null character\n    on the end of it for C, the actual buffer passed must be at least\n    one character longer than the length as defined to ISPF.\n */\n\n gp->ispfrc = ISPLINK(\"VCOPY\",varname,&vcopy_length,varbuf,\"MOVE\");\n switch (gp->ispfrc) {\n   case  0:\n           if (varbuflen >= 0)\n              varbuf[vcopy_length] = '\\0';\n           return TRUE;\n   case  8:\n           strcpy(varbuf,\"\");\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to get %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           GGMierr(gp);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./   ADD NAME=GGMIVPUT,SSI=01000024\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@IVPUT\")\n#pragma  csect(static,\"GG$IVPUT\")\n#include \"gg.h\"\n\n/****** Set the value of an ISPF variable. ***************************/\n\nBool\nGGMivput(gp,varname,varbuf,varlen)\nRstruc ggcb *gp;\nchar        *varname;\nchar        *varbuf;\nint          varlen;\n{\n int         vreplace_length;\n\n vreplace_length = (varlen<0 ? strlen(varbuf) : varlen);\n\n gp->ispfrc = ISPLINK(\"VREPLACE\",varname,&vreplace_length,varbuf);\n switch (gp->ispfrc) {\n   case  0:\n           return TRUE;\n   case 16:\n           fprintf(stderr,\n                   \"Error: ISPF variable buffer too short to put %s\\n\",\n                   varname);\n           return FALSE;\n   default:\n           GGMierr(gp);   /* handle ISPF error */\n           return FALSE;\n }\n}\n\n./   ADD NAME=GGMMTFER,SSI=01030000\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@MTFER\")\n#pragma  csect(static,\"GG$MTFER\")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nvoid\nGGMmtfer(\n         int          retcode,\n         char        *kind)\n{\n char    *ermsg;\n\n switch (retcode) {\n   case MTF_OK:\n        ermsg = NULL;\n        break;\n   case EINACTIVE:\n        ermsg = \"MTF is inactive\";\n        break;\n   case ESUBCALL:\n        ermsg = \"The MTF call was issued from a subtask\";\n        break;\n   case EWRONGOS:\n        ermsg = \"MTF is not supported under CMS, IMS, CICS, or DB2\";\n        break;\n   case EACTIVE:\n        ermsg = \"MTF has already been initialized and is active\";\n        break;\n   case ENAME2LNG:\n        ermsg = \"The parallel module name is longer than 8 characters\";\n        break;\n   case ETASKNUM:\n        ermsg = \"The number of tasks specified is invalid\";\n        break;\n   case ENOMEM:\n        ermsg = \"Insufficient storage for MTF internal areas\";\n        break;\n   case EMODFIND:\n        ermsg = \"The parallel load module was not found\";\n        break;\n   case EMODREAD:\n        ermsg = \"The parallel load module was not sucessfully read\";\n        break;\n   case EMODFMT:\n        ermsg = \"The parallel load module format is invalid\";\n        break;\n   case EAUTOALC:\n        ermsg = \"Automatic allocation of standard stream DD failed\";\n        break;\n   case ETASKFAIL:\n        ermsg = \"The attempt to attach task(s) has failed\";\n        break;\n   case ETASKABND:\n        ermsg = \"One or more subtasks have abnormally terminated\";\n        break;\n   case EBADLNKG:\n        ermsg = \"TSCHED has been invoked via invalid linkage\";\n        break;\n   case ETASKID:\n        ermsg = \"The task ID specified is not valid\";\n        break;\n   case EENTRY:\n        ermsg = \"The parallel function was not in the parallel module\";\n        break;\n   default:\n        ermsg = \"Unknown MTF error\";\n        break;\n }\n\n if (ermsg) {\n   fprintf(stderr,\"GGSERVER: %s error code %d:\\n %s\\n\",\n                  kind, retcode, ermsg);\n }\n\n return;\n\n}\n\n./   ADD NAME=GGMOUTS,SSI=01050059\n\n /********************************************************************/\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@MOUTS\")\n#pragma  csect(static,\"GG$MOUTS\")\n\n#include \"gg.h\"\n/*\n ***********************************************************************\n *                                                                     *\n * This is a Gopher server routine that outputs data to a socket.      *\n *                                                                     *\n * If the \"socket\" is actually a file pointer, then output is          *\n * written to the file pointer.                                        *\n *                                                                     *\n ***********************************************************************\n */\n\n/*=================================================================*/\n\nBool\nGGMouts(struct recvstruct *R,\n        char              *text)\n{\n int                len;\n int                reallen;\n Bool               rc;\n char               outbuf[515];  /* hold an output character string */\n\n if (R->outfp) {                    /* if using non-socket interface */\n   if (fputs(text,R->outfp) < 0) {\n     fprintf(stderr,\"Error writing to output file\\n\");\n     return FALSE;\n   }\n   if (fputc('\\n',R->outfp) < 0) {\n     fprintf(stderr,\"Error writing to output file\\n\");\n     return FALSE;\n   }\n   return TRUE;\n }\n\n if (text == NULL) {\n   outbuf[0] = '.';\n   len = 1;\n }\n else {\n   len = strlen(text);\n   if (len >= sizeof(outbuf)-3) len = sizeof(outbuf)-3;\n   if (text[0] == '.') {\n     outbuf[0] = '.';\n     memcpy(outbuf+1,text,len);\n     len++;\n   }\n   else {\n     memcpy(outbuf,text,len);\n   }\n }\n outbuf[len  ] = CARRIAGE_RETURN;\n outbuf[len+1] = LINE_FEED;\n outbuf[len+2] = '\\0';\n reallen = len + 2;\n\n#ifdef SNSTCPIP\n EBCDIC_TO_ASCII(outbuf,reallen);\n#else\n ebdtoasc(outbuf);\n#endif\n\n rc = TRUE;\n\n if (R->outlen + reallen > sizeof(R->sockbuf)) {\n\n   if (write(R->sockfd,R->sockbuf,R->outlen) < 0) {\n     REPORT_TCP_ERROR(\"SEND\");\n     rc = FALSE;\n   }\n   R->outlen = 0;\n }\n\n memcpy(R->sockbuf + R->outlen, outbuf, reallen);\n R->outlen += reallen;\n\n if (text == NULL) {  /* flush socket */\n   if (write(R->sockfd,R->sockbuf,R->outlen) < 0) {\n     REPORT_TCP_ERROR(\"SEND\");\n     rc = FALSE;\n   }\n }\n return rc;\n}\n\n./   ADD NAME=GGMOUTTX,SSI=01010057\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@OUTTX\")\n#pragma  csect(static,\"GG$OUTTX\")\n#include \"gg.h\"\n\n/****** Output a line of text retrieved from the server. *************/\n\nstruct textline *\nGGMouttx(gp,line,ip)\nRstruc ggcb         *gp;\nchar                *line;\nRstruc gopherinfo   *ip;\n\n{\n struct texthdr     *thp;\n struct textline    *tp;\n short              line_length;\n short              total_text_length;\n short              tab_expansion_length;\n Bool               tabs_present;\n char              *p;\n char              *q;\n char              *t;\n int                e;\n int                u;\n\n static char        tab_expansion_buffer[8*TEXT_BYTES];\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n /* If line starts with double period, make it a single period. */\n\n if (ip && memcmp(line,\"..\",2) == 0) line++;\n\n /* Add this line to the current queue of server text lines. */\n\n /* First, expand tabs in the line. */\n\n line_length = strlen(line);\n t = strchr(line,'\\t');\n if (t == NULL) {\n   tabs_present = FALSE;\n   total_text_length = line_length + 1;\n }\n else {                                   /* expand tabs */\n   tabs_present = TRUE;\n   p = line;\n   q = line + line_length;\n   e = 0;\n   memset(tab_expansion_buffer,' ',sizeof(tab_expansion_buffer));\n   while (TRUE) {\n     u = t-p;\n     if (u > 0) {\n       memcpy(tab_expansion_buffer+e,p,u);\n       e += u;\n     }\n     if (t == q) break;\n     e = e / 8 * 8 + 8;\n     p = t+1;\n     t = strchr(p,'\\t');\n     if (t == NULL) t = q;\n   }\n   tab_expansion_length = e;\n   tab_expansion_buffer[tab_expansion_length] = '\\0';\n   total_text_length = line_length + tab_expansion_length + 1;\n }\n\n GETMAIN(tp, char, offsetof(struct textline, text) + total_text_length,\n                   \"text line\");\n\n if (tp == NULL) {\n   ERR1(\"There is not enough virtual storage to process server text.\");\n   return NULL;\n }\n\n tp->next = NULL;\n tp->text_length = line_length;\n strcpy(tp->text,line);\n if (tabs_present) {\n   tp->tab_expanded_text_length = tab_expansion_length;\n   tp->tab_expanded_text = tp->text + line_length;\n   strcpy(tp->tab_expanded_text,tab_expansion_buffer);\n }\n else {\n   tp->tab_expanded_text_length = line_length;\n   tp->tab_expanded_text = tp->text;\n }\n\n if (thp->last_text_line == NULL) {\n   thp->first_text_line   = tp;\n   thp->text_body_line    = tp;\n   thp->current_text_line = tp;\n }\n else thp->last_text_line->next = tp;\n\n thp->last_text_line = tp;\n thp->text_line_count++;\n\n if (thp->text_max_length < tp->text_length)\n     thp->text_max_length = tp->text_length;\n if (thp->text_max_tab_expanded_length < tp->tab_expanded_text_length)\n     thp->text_max_tab_expanded_length = tp->tab_expanded_text_length;\n\n return tp;\n\n}\n\n./   ADD NAME=GGMPMSG,SSI=01000057\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#define  SUPPRESS_V_DECLARATION\n#pragma  csect(code,  \"GG@PMSG \")\n#pragma  csect(static,\"GG$PMSG \")\n#include \"gg.h\"\n\n/****** Set an ISPF message, or write to SYSOUT if batch mode. *******/\n\nvoid\nGGMpmsg(gp,msgtype,msghelp,msgformat) /* also ... for sprintf args */\nRstruc ggcb *gp;\nint          msgtype;\nchar        *msghelp;\nchar        *msgformat;\n{\n va_list     argp;\n char       *cp;\n char        zerrsm    [25];\n char        zerrhm     [9];\n char        zerralrm   [4];\n char        zerrlm    [73];\n char        buf      [257];\n\n va_start(argp,msgformat);\n vsprintf(buf,msgformat,argp);\n va_end(argp);\n\n cp = strchr(buf,';');\n if (cp) {\n  *cp = '\\0';\n  strncpy(zerrsm,buf, sizeof(zerrsm));\n  strncpy(zerrlm,cp+1,sizeof(zerrlm));\n }\n else {\n  strcpy(zerrsm,\"\");\n  strncpy(zerrlm,buf,sizeof(zerrlm));\n }\n\n zerrsm[sizeof(zerrsm)-1] = '\\0';\n zerrlm[sizeof(zerrlm)-1] = '\\0';\n\n if (msghelp) strcpy(zerrhm, msghelp);\n else         strcpy(zerrhm, \"*\"    );\n\n switch (msgtype) {\n   case NOTIFY_MSG:    strcpy(zerralrm,\"NO \"); break;\n   case WARNING_MSG:\n   case CRITICAL_MSG:\n   default:            strcpy(zerralrm,\"YES\"); break;\n }\n\n (void)GGMivput(gp,\"ZERRSM \",  zerrsm,   -1);\n (void)GGMivput(gp,\"ZERRLM \",  zerrlm,   -1);\n (void)GGMivput(gp,\"ZERRHM \",  zerrhm,   -1);\n (void)GGMivput(gp,\"ZERRALRM \",zerralrm, -1);\n\n if (gp->brifp) {\n   (void)GGMispf(gp,\"SETMSG MSG(ISRZ002)\");\n }\n else {\n   gp->setmsg = TRUE;\n }\n\n return;\n}\n\n./   ADD NAME=GGMPROC,SSI=01160000\n\n /********************************************************************/\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@MPROC\")\n#pragma  csect(static,\"GG$MPROC\")\n\n#pragma  linkage(IRXEXEC,OS)\n\n#include \"gg.h\"\n\n/**********************************************************************\n *                                                                    *\n * Changes: 02/17/93 Fixed memcmp logic in append-domain-name code.   *\n *                                                                    *\n **********************************************************************/\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine cleans up a token.  It converts all chars to     */\n/*   upper case and removes any leading spaces. Note that the      */\n/*   string is assumed to be null terminated.                      */\n/*                                                                 */\n/*       INPUT    token          pointer to token string.          */\n/*       OUTPUT   *token         string upcased, blanks removed.   */\n/*******************************************************************/\n\nstatic char *\nuppercase_and_trim_leading_space(char *token)\n{\n\n uppercase_in_place(token);\n\n return token + strspn(token,\" \");\n};\n\n/*=================================================================*/\n\n/****************************************************/\n/* This routine \"cleans\" a string by removing the   */\n/* leading spaces and trailing spaces+non-printable */\n/* characters.                                      */\n/****************************************************/\n\nstatic char *\ntrim_leading_and_trailing_space(char *string)\n{\nchar *str;\nchar *ptr;\n\n /*  first clean up the beginning of the string... */\n\n str = string + strspn(string,\" \\t\");\n\n /*    now look at the end of the string... */\n\n ptr = str+strlen(str)-1;\n while (!isgraph(*ptr) && ptr >=str) ptr--;\n *(ptr+1)=0;\n\n return str;\n}\n\n/*=================================================================*/\n\n/****************************************************/\n/* This routine \"cleans\" an output line by removing */\n/* trailing spaces and non-printable characters.    */\n/****************************************************/\n\nstatic void\ntrim_trailing_space(char *string)\n{\n char *ptr;\n\n ptr = string;\n\n /*  look at the end of the string... */\n\n ptr = string+strlen(string)-1;\n while (isgraph(*ptr)==0 && ptr >=string) ptr--;\n *(ptr+1)=0;\n}\n\n/*=================================================================*/\n\nstatic void\ngbarf(struct recvstruct *R,\n      char              *message)\n{\n char        temp[257];\n\n /* the number should be 3 (ERROR) but some clients may not show it\n  *             |\n  *             |\n  *             |\n  *             V\n  */\n sprintf(temp, \"1Sorry, %s.\\t0\\t0\\t0\", message);\n\n (void)GGMouts(R,temp);\n\n return;\n}\n\n/*=================================================================*/\n\nstatic Bool\ninsure_my_name(struct recvstruct *R)\n{\n int                hostlen;\n int                domslen;\n\n /* Determine the local path name, if not already set. */\n\n if (!*R->myname) {\n   if (gethostname(R->myname,MAXHOSTNAMELEN) < 0) {\n     fprintf(stderr,\"GOPHER:gethostname() failed, can't get my name\\n\");\n     gbarf(R,\"the GOPHER server had an attack of amnesia\");\n     return FALSE;\n   }\n\n#ifdef APPEND_DOMAIN_NAME_TO_SELF\n\n   hostlen = strlen(R->myname);\n   domslen = sizeof(MY_DOMAIN_SUFFIX) - 1;\n   if (hostlen <= domslen ||\n       memcmp(R->myname+hostlen-domslen, MY_DOMAIN_SUFFIX, domslen)) {\n     strncat(R->myname,MY_DOMAIN_SUFFIX,domslen);\n   }\n\n#endif\n\n   uppercase_in_place(R->myname);\n\n   fprintf(stderr,\"Local hostname set to '%s'\\n\",R->myname);\n\n }\n\n return TRUE;\n\n}\n\n/*=================================================================*/\n\nstatic Bool\nauthorized_file(struct recvstruct *R)\n{\n char    *cp;\n FILE    *afp;\n int      n;\n int      hostcount;\n Bool     rc;\n char     filetest[RBUFSIZE];\n char     accline [RBUFSIZE];\n char     accfile [RBUFSIZE];\n char     acchost [RBUFSIZE];\n\n /* If non-socket interface, bypass the authorization check. */\n\n if (R->outfp) return TRUE;\n\n /* Check that the server is allowed to return data from the file\n  * specified in R->fileptr.  Note that this could be the name of\n  * an exec.  The name will be (dataset), EXEC:execname, or DD:file\n  * - we look at only the first part, whitespace-delimited.\n  * Entries in the file authorization table look as above.\n  */\n\n rc = FALSE;\n filetest[0] = '\\0';\n sscanf(R->fileptr,\"%s\",filetest);\n\n /* Read authorization file. */\n\n afp = fopen(ACCESS_TABLE,\"r\");\n if (!afp) {\n   perror(ACCESS_TABLE);\n   fflush(stderr);\n   return FALSE;\n }\n\n for (;;) {\n   fgets(accline, sizeof(accline), afp);\n   if (ferror(afp)) {\n     fprintf(stderr,\"Error reading access table %s\\n\",ACCESS_TABLE);\n     fflush(stderr);\n     break;\n   }\n   if (feof(afp)) break;\n   /* format of line is: filename machine(s) */\n   uppercase_in_place(accline);\n   cp = accline;                      /* Start scan pointer         */\n   *accfile = '\\0';                   /* Clear access file name     */\n   sscanf(cp,\"%s %n\",accfile,&n);     /* Get file name, bump scan   */\n   if (!strcmp(filetest,accfile)) {   /* If file name matches       */\n     hostcount = 0;                   /* Clear access host count    */\n     for (;;) {                       /* Loop over access host ids  */\n       cp += n;                       /* Bump to next word in file  */\n       *acchost = '\\0';               /* Clear word before scanf    */\n       sscanf(cp,\"%s %n\",acchost,&n); /* Get next word, bump scan   */\n       if (!*acchost) break;          /* exit loop if no more hosts */\n       hostcount++;                   /* increment access host count*/\n       if (!strcmp(R->hostname,acchost)\n        || !strcmp(R->hosttest,acchost)) { /* if hostname matches */\n         rc = TRUE;                        /* access is allowed   */\n         break;\n       }\n     }\n     if (!rc) {                       /* If no matching host found  */\n       if (hostcount == 0) rc = TRUE; /* if no access hosts, say OK */\n     }\n     if (rc) break;                   /* if access OK, finished     */\n\n     /* If access is not permitted, we keep checking because\n      * there may be more than one entry in the access table\n      * for this file, so that many host names can be given.\n      */\n\n   }\n }\n\n (void)fclose(afp);\n\n if (!rc) {\n   fprintf(stderr,\"Not authorized from %s: '%s'\\n\",\n                  R->hosttest, filetest);\n }\n\n fflush(stderr);\n\n return rc;\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*            This routine determines what type of gopher file     */\n/*            we've opened.  We'll return the file type to the     */\n/*            caller.                                              */\n/*                                                                 */\n/*            INPUT:   ident   pointer to first line of file       */\n/*                                                                 */\n/*            OUTPUT:   MENU   file type is a menu                 */\n/*                      FILE   file type is a file                 */\n/*                      INDEX  file type is an INDEX (not done)    */\n/*******************************************************************/\n\nstatic char\ngetftype(char *ident)\n{\n int   x;                              /* loop counter */\n char  buffer[RBUFSIZE];\n char *bufptr;\n\n /**********/\n /*   first, convert the string to upper case...   */\n /*********/\n strcpy(buffer,ident);\n bufptr = uppercase_and_trim_leading_space(buffer);\n\n /**********/\n /*   return the type of file.                     */\n /*********/\n\n if(strcmp(bufptr,MENUIDENT)==0) return(MENU);\n if(strcmp(bufptr,INDEXIDENT)==0) return(INDEX);\n\n /**********/\n /*   don't know, so assume it's a \"file\" file...    */\n /*********/\n\n return(GFILE);\n\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*            This routine figures out what type of parm line      */\n/*            the current line is.  We'll return the token         */\n/*            type to the caller.                                  */\n/*                                                                 */\n/*            INPUT:   buffer  pointer to first line of file       */\n/*                       (Note: string must be null terminated!    */\n/*            OUTPUT:   Type of token.  (See in include file...)   */\n/*******************************************************************/\n\nstatic int\nmenukeywd(char  *buffer,\n          char  *token,\n          char  *operand)\n{\n int             x;                              /* loop counter */\n char           *tokval;\n char           *oprval;\n char           *tokptr;\n char            tokstr[256];\n\n strcpy(tokstr,buffer);\n tokval=strtok(tokstr,\"=\");\n oprval=strtok(NULL,\"\");\n strcpy(token,tokval);\n strcpy(operand,oprval);\n tokptr = uppercase_and_trim_leading_space(token);\n\n /*********/\n /*  now look at the tokens to see if we have a weener... */\n /*********/\n\n if(strcmp(tokptr,TOKTYPE)==0) return(TYPETOK);\n if(strcmp(tokptr,TOKNAME)==0) return(NAMETOK);\n if(strcmp(tokptr,TOKPATH)==0) return(PATHTOK);\n if(strcmp(tokptr,TOKHOST)==0) return(HOSTTOK);\n if(strcmp(tokptr,TOKPORT)==0) return(PORTTOK);\n if(strcmp(tokptr,TOKEND)==0) return(ENDTOK);\n\n /* for back compatibility with the old MVS GOPHER server */\n\n if(strcmp(tokptr,TOKDISPLAY)==0) return(DISPLAYTOK);\n if(strcmp(tokptr,TOKSELECT)==0) return(SELECTTOK);\n\n return(COMMENTTOK);\n\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*       This routine reads a line from the specified file.        */\n/*       if a read error occurs, an error message is printed and   */\n/*       FALSE is returned.                                        */\n/*                                                                 */\n/*       INPUT   buffer      pointer to buffer to place line       */\n/*               readfile    file structure to read from           */\n/*                                                                 */\n/*       OUTPUT  buffer      line that was read from the file      */\n/*               TRUE        read worked ok                        */\n/*               FALSE       read failed!                          */\n/*******************************************************************/\n\nstatic Bool\nreadaline(struct recvstruct *R)\n{\n\n memset(R->buffer,0,RBUFSIZE);\n fread(R->buffer,RBUFSIZE,1,R->readfile);\n if (ferror(R->readfile)) {\n   /* perror(\"FREAD\"); */\n   fprintf(stderr,\"GGSTASK: Error reading file\\n\");\n   return(FALSE);\n }\n trim_trailing_space(R->buffer); /* Remove trailing whitespace */\n return(TRUE);\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine sends a file to the calling client.              */\n/*   It assumes the file is a text formatted file.                 */\n/*   INPUT:   buffer    pointer to the already read line...        */\n/*            readfile  file we're going to read from..            */\n/*            maxlen    size of the buffer.                        */\n/*            sockfd    socket descriptor for client.              */\n/*                                                                 */\n/*   OUTPUT:   send the file to the client                         */\n/*******************************************************************/\nstatic void\nsendafile(struct recvstruct *R)\n{\n int            x;\n char          *moveit;\n\n /*******/\n /*   send the first line (cause we already read it) */\n /*******/\n\n if (!GGMouts(R,R->buffer)) return;\n\n /*******/\n /*   get the rest of the lines of the file and send them... */\n /*******/\n\n for (;;) {\n   if (!readaline(R)) {\n     (void)GGMouts(R,\"<<<*** I/O ERROR ON MVS FILE ***>>>\");\n     return;\n   }\n   if (feof(R->readfile)) break;\n   if (!GGMouts(R,R->buffer)) return;\n }\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine formats a menu file into gopher data & sends it  */\n/*   to the client.                                                */\n/*   INPUT:   buffer    pointer to the already read line...        */\n/*            readfile  file we're going to read from..            */\n/*            maxlen    size of the buffer.                        */\n/*            sockfd    socket descriptor for client               */\n/*                                                                 */\n/*   OUTPUT:   send the menu to the client                         */\n/*******************************************************************/\n\n#define MENU_STUFF_SIZE GOPHER_DESC_LENGTH + \\\n                        GOPHER_PATH_LENGTH + \\\n                        GOPHER_HOST_LENGTH + 20\n\nstatic void\nsendamenu(struct recvstruct *R)\n{\n char           *moveit;\n char           *operptr;\n char           *typeoftype;             /*pointer for strtok   */\n char           *cp;\n int             kindotoken;\n int             x;                         /* loop counter */\n char            token   [133];\n char            operand [133];\n char            outbuf  [MENU_STUFF_SIZE];\n struct menuitem menu;\n\n memset(&menu,0,sizeof menu );\n for (;;) {\n   if (!readaline(R)) break;\n   if (feof(R->readfile)) break;\n   if (!*R->buffer) continue;\n   kindotoken = menukeywd(R->buffer,token,operand);\n   switch(kindotoken) {\n     case TYPETOK:\n          operptr = uppercase_and_trim_leading_space(operand);\n          typeoftype = strtok(operptr,\" \");\n          if (strlen(typeoftype) == 1)      menu.type = *typeoftype;\n          else\n          if (EQUAL(typeoftype,TYPEFILE))   menu.type = GFILE;\n          else\n          if (EQUAL(typeoftype,TYPEMENU))   menu.type = MENU;\n          else\n          if (EQUAL(typeoftype,TYPEINDEX))  menu.type = INDEX;\n          else\n          if (EQUAL(typeoftype,TYPETELNET)) menu.type = TELNET;\n          else\n          if (EQUAL(typeoftype,TYPETN3270)) menu.type = TN3270;\n          else\n          if (EQUAL(typeoftype,TYPEWHOIS))  menu.type = WHOIS;\n          else                              menu.type = ERROR;\n          break;\n     case NAMETOK:\n     case DISPLAYTOK:\n          strncpy(menu.desc,     operptr, sizeof(menu.desc));\n          break;\n     case PATHTOK:\n     case SELECTTOK:\n          strncpy(menu.select,   operptr, sizeof(menu.select));\n          break;\n     case HOSTTOK:\n          if (EQUAL(operptr,IDENT_HOST_FROB)) {  /* HOST=+  */\n            if (insure_my_name(R)) {\n              strncpy(menu.hostname, R->myname, sizeof(menu.hostname));\n            }\n          }\n          else {\n            strncpy(menu.hostname, operptr, sizeof(menu.hostname));\n          }\n          break;\n     case PORTTOK:\n          if (EQUAL(operptr,IDENT_HOST_FROB)) {  /* PORT=+  */\n            menu.port = SERV_TCP_PORT;\n          }\n          else {\n            menu.port=atoi(operptr);\n          }\n          break;\n     case ENDTOK:\n          if (menu.port == 0) {\n            switch (menu.type) {\n              case TELNET: break;\n              case TN3270: break;\n              default:     menu.port = GOPHER_PORT_NUMBER; break;\n            }\n          }\n          /* If host is local and path is in the form \"(member)\",\n           * and current dsname is a PDS, then use same PDS:\n           * i.e. turn PATH=(FOOBAR) into PATH=AA.BB.CC(FOOBAR)\n           */\n          if (*R->myname\n           && EQUAL(menu.hostname,R->myname)\n           && *menu.select == '('        /* ) */\n           && (cp = strchr(R->dsname,'(' /* ) */ ))) {\n            memcpy(outbuf, R->dsname, (cp-R->dsname));\n            strcpy(outbuf+(cp-R->dsname), menu.select);\n            strncpy(menu.select, outbuf, sizeof(menu.select));\n          }\n          if (*menu.desc && *menu.hostname) {\n            sprintf(outbuf,\"%c%s\\t%s\\t%s\\t%d\",\n                           menu.type,menu.desc,\n                           menu.select,menu.hostname,menu.port);\n            if (!GGMouts(R,outbuf)) return;\n          }\n          fflush(stdout);\n          memset(&menu,0,sizeof menu );\n          break;\n     default:\n          break;\n       }\n   }\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_directory(struct recvstruct *R)\n{\n FILE              *dirfile;\n int                i;\n short              block_count;\n short              bump_amount;\n Bool               reject;\n Bool               no_more;\n char              *cp;\n char              *mp;\n char               dirblk  [256];\n char               pdsspec [256];\n char               entry   [256];\n\n /* The local path name is required for this function. */\n\n if (!insure_my_name(R)) return FALSE;\n\n if ((dirfile=fopen(R->buffer,\"rb,recfm=u,lrecl=256\")) == NULL) {\n   perror(R->buffer);\n   printf(\"Can't open PDS directory:%s\\n\",R->dsname);\n   gbarf(R,\"the GOPHER server can't open the directory\");\n   return(FALSE);\n }\n\n while (!feof(dirfile)) {\n\n   no_more = FALSE;\n\n   do {\n     memset(dirblk,0x00,256);\n     fread(dirblk,256,1,dirfile);\n     if (feof(dirfile)) break;\n     if (ferror(dirfile)) {\n       printf(\"Can't read PDS directory:%s\\n\", R->fileptr);\n       gbarf(R,\"the GOPHER server can't read the directory\");\n       fclose(dirfile);\n       return FALSE;\n     }\n     mp = dirblk;\n     block_count = *(short *)mp - 2;   /* # bytes in dir block */\n     mp += 2;                        /* addr of dir block data */\n     while (block_count > 0) {\n       if (memcmp(mp,\"\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",8)==0) break;\n       reject = FALSE;\n       /*\n        * Uncomment this if you want to skip aliases.\n        * It is recommended that you let aliases through, since\n        * they often have better names (e.g. TSO HELP files)\n        *\n        * if ((mp[11] & 0x80) != 0) {\n        *   fprintf(stderr,\"Skipping alias:  %-8.8s\\n\",mp);\n        *   reject = TRUE;\n        * }\n        */\n       if (!reject) {\n         strcpy(pdsspec, R->dsname);\n         cp = strchr(pdsspec, '\\0');\n         *(cp++) = '(';\n         for (i = 0; i < 8 && mp[i] != ' '; cp++, i++) *cp = mp[i];\n         *(cp++) = ')';\n         *cp = '\\0';\n         sprintf(entry,\"0%8.8s\\t%s\\t%s\\t%d\",\n                       mp, pdsspec, R->myname, SERV_TCP_PORT);\n         (void)GGMouts(R,entry);\n       }\n       bump_amount = 12 + ((mp[11] & 0x1f) * 2);\n       mp += bump_amount;\n       block_count -= bump_amount;\n     }\n   } while(!no_more);\n\n }\n\n fclose(dirfile);\n return TRUE;\n}\n\n/*=================================================================*/\n\nstatic Bool\nget_flat_file(struct recvstruct *R)\n{\n int                x;            /* loop counter*/\n int                numread;      /* number of items read... */\n char               filetype;     /* type of file we're dealing with*/\n\n if ((R->readfile=fopen(R->buffer,\"rb,type=record\")) == NULL) {\n   perror(R->buffer);\n   printf(\"INVALID! requested:%s\\n\",R->fileptr);\n   gbarf(R,\"the GOPHER server couldn't open the file\");\n   return(FALSE);\n }\n\n /************/\n /*  get the first line and see what type of file we've got.      */\n /************/\n\n if (readaline(R) && !feof(R->readfile)) {\n\n   filetype=getftype(R->buffer);\n\n  /************/\n  /*  Now let's go do whatever we need to for this file type.    */\n  /************/\n\n   switch(filetype) {\n     case MENU:\n                 sendamenu(R);\n                 break;\n     case GFILE:\n     default:\n                 sendafile(R);\n                 break;\n   }\n\n }\n\n if(fclose(R->readfile) < 0) {\n   /* perror(\"PROCESS CLOSE\"); */\n   fprintf(stderr,\"GGSTASK: Error closing file %s\\n\",R->fileptr);\n   gbarf(R,\"the GOPHER server couldn't close the file\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/*=================================================================*/\n\n#define PARAMETER   unsigned int\n#define LASTPARM(X) ((unsigned int)(X) | 0x80000000)\n\n\nstatic Bool\nget_exec_data(struct recvstruct *R)\n{\n char              *command;\n char              *commandargs;\n unsigned int       bitflags;\n int                rexxrc;\n int                irxexecrc;\n int                commandlength;\n int                scan_count;\n int                i;\n Bool               rc;\n int              (*irxexec)();\n FILE              *fp;\n char               exectest[RBUFSIZE];\n PARAMETER          parameter[11];\n struct {\n                         /* repeat this block for each argument */\n         char      *argstring_ptr;\n         int        argstring_length;\n                         /* end repeat this block for each argument */\n         int        argstring_end;\n        }           arguments;\n\n struct {\n         char       acryn[8];       /* \"IRXEXECB\" */\n         int        length;\n         int        reserved1;\n         char       member[8];\n         char       ddname[8];\n         char       subcom[8];\n         char      *dsnptr;\n         int        dsnlen;\n        }           execblk;\n\n  /*\n   * Menu item should look like this:\n   *\n   * exec:rexxname any args\n   *\n   * The exec should write output to SYSTSPRT.  Normal TSO command\n   * output will be captured by the SYSTSPRT allocation only if\n   * the Gopher server is run as a batch job.\n   *\n   * If this was sent by the client with a type 7 or type w, then\n   * additional args will appear at the end delimited by a space.\n   */\n\n irxexec = NULL;\n rc = TRUE;\n scan_count = 0;\n\n if (R->wargptr) {\n   commandlength = strlen(R->fileptr) + strlen(R->wargptr) + 4;\n   command = (char *)malloc(commandlength);\n   if (!command) {\n     printf(\"Cannot allocate %d bytes of memory for exec\\n\",\n            commandlength);\n     gbarf(R,\"the GOPHER server ran out of memory\");\n     return FALSE;\n   }\n   else sprintf(command,\"%s %s\",R->fileptr,R->wargptr);\n }\n else {\n   commandlength = 0;\n   command = R->fileptr;\n }\n\n *exectest = '\\0';\n sscanf(command, \"%s %n\", exectest, &scan_count);\n if (strlen(exectest) > 8) {\n   gbarf(R,\"name of exec is too long\");\n   return FALSE;\n }\n commandargs = command + scan_count;\n\n if (rc) {\n   irxexec = (int(*)())fetch(\"IRXEXEC\");\n   if (!irxexec) {\n     printf(\"Cannot fetch IRXEXEC\\n\");\n     rc = FALSE;\n   }\n }\n\n /* Give the exec an empty SYSTSPRT file to write into.\n  * Then when we read it we can see only what was added.\n  * Since IRXEXEC doesn't close SYSTSPRT, we can't remove it\n  * and reallocate it.\n  */\n\n if (rc) {\n   fp = fopen(\"DD:SYSTSPRT\",\"w\");\n   if (!fp) {\n     perror(\"DD:SYSTSPRT\");\n     printf(\"Cannot open SYSTSPRT to prepare for REXX exec\\n\");\n     rc = FALSE;\n   }\n\n   /* Open for write + close = clear it out */\n\n   else if (fclose(fp) < 0) {\n     printf(\"Cannot close SYSTSPRT to prepare for REXX exec\\n\");\n     rc = FALSE;\n   }\n }\n\n /* Set up parameters for IRXEXEC:\n  *\n  * Param 1  -  address of EXECBLK\n  * Param 2  -  address of arguments\n  * Param 3  -  bitflags\n  * Param 4  -  address of INSTBLK\n  * Param 5  -  address of CPPL\n  * Param 6  -  address of EVALBLOCK\n  * Param 7  -  address of 8-byte work area\n  * Param 8  -  address of user field\n  * Param 9  -  address of environment block\n  * Param 10 -  return code\n  *\n  */\n\n if (rc) {\n\n   /* set up exec block */\n\n   memset (&execblk, 0, sizeof(execblk));\n   execblk.length = sizeof(execblk);\n   memcpy (execblk.acryn, \"IRXEXECB\", 8);\n   strncpy(execblk.member,exectest,8);\n   for (i=0;i<8;i++) {\n     if (execblk.member[i] == '\\0')\n         execblk.member[i] = ' ';\n   }\n   /* We may have just clobbered this, so do this after... */\n\n   memcpy (execblk.ddname, REXX_EXEC_LIBRARY_DDNAME, 8);\n   memcpy (execblk.subcom, REXX_EXEC_SUBCOM,     8);\n\n   /* set up arguments  */\n\n   arguments.argstring_ptr    = commandargs;\n   arguments.argstring_length = strlen(commandargs);\n   arguments.argstring_end    = 0xffffffff;\n\n   /* Invoke the rexx exec */\n\n   if (!R->outfp) printf(\"Executing:%s\\n\", command);\n\n#define INVOKE_EXEC_AS_COMMAND            (unsigned int)0x80000000\n#define INVOKE_EXEC_AS_EXTERNAL_FUNCTION  (unsigned int)0x40000000\n#define INVOKE_EXEC_AS_SUBROUTINE         (unsigned int)0x20000000\n#define RETURN_EXTENDED_RETURN_CODES      (unsigned int)0x10000000\n\n   rexxrc = 0;\n   bitflags = (unsigned int)(INVOKE_EXEC_AS_COMMAND +\n                             RETURN_EXTENDED_RETURN_CODES);\n\n   parameter[ 1] =   (PARAMETER)&execblk;\n   parameter[ 2] =   (PARAMETER)&arguments;\n   parameter[ 3] =   (PARAMETER)bitflags;\n   parameter[ 4] =   (PARAMETER)NULL;  /* no INSTBLK */\n   parameter[ 5] =   (PARAMETER)NULL;  /* no CPPL    */\n   parameter[ 6] =   (PARAMETER)NULL;  /* no eval block */\n   parameter[ 7] =   (PARAMETER)NULL;  /* no work area */\n   parameter[ 8] =   (PARAMETER)NULL;  /* no user field, last parm */\n   parameter[ 9] =   (PARAMETER)NULL;  /* no environment block */\n   parameter[10] =   (PARAMETER)0;     /* return code */\n\n   irxexecrc = (*irxexec) (\n                           &parameter[1],\n                           &parameter[2],\n                           &parameter[3],\n                           &parameter[4],\n                           &parameter[5],\n                           &parameter[6],\n                           &parameter[7],\n                           LASTPARM(&parameter[8]), /* old REXX */\n                           &parameter[9],\n                           LASTPARM(&parameter[10]) /* new REXX */\n                          );\n\n   if (irxexecrc != 0) {\n     fprintf(stderr,\"Return code from IRXEXEC is %d\\n\", irxexecrc);\n     gbarf(R,\"the Gopher server was unable to run the exec\");\n     rc = FALSE;\n   }\n   else {\n\n     rexxrc = parameter[10];\n\n     if (!R->outfp) printf(\"Return code from exec is %d\\n\", rexxrc);\n\n     /* Read what the exec wrote. */\n\n     strcpy(R->buffer,\"DD:SYSTSPRT\");\n     R->fileptr = R->buffer;\n     rc = get_flat_file(R);\n\n   }\n\n }\n\n else {\n     gbarf(R,\"the GOPHER server had a problem with the exec\");\n }\n\n if (irxexec) release((void (*)())irxexec);\n\n if (commandlength > 0) free(command);\n\n return rc;\n\n}\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*   This routine Processes the file the user requested.           */\n/*   If it's a menu, we'll form a menu line, if it's a             */\n/*   file, we'll just send it as is.                               */\n/*                                                                 */\n/*   INPUT:   filename  pointer to the file name to open           */\n/*            sockfd    socket descriptor for the client           */\n/*                                                                 */\n/*   OUTPUT:   print \"gopher\" lines.                               */\n/*             TRUE  - file printed ok.                            */\n/*             FALSE - Error reading or writing                    */\n/*******************************************************************/\n\nBool\nGGMproc(struct recvstruct *R)\n{\n int                x;            /* loop counter*/\n int                numread;      /* number of items read... */\n int                hacksize;     /* length of hack prefix before : */\n Bool               rc;           /* return value */\n enum data_set_type dstype;       /* SEQ, PDS or UNK */\n char              *p;\n char              *q;\n char              *tabptr;\n char              *colonptr;\n char               ddname    [  9];\n char               hackprefix[ 17];\n\n *ddname     = '\\0';\n *hackprefix = '\\0';\n\n /************/\n /*  First, strip off any \"bad\" characters from the arguments. */\n /************/\n\n /*\n  * Break the argument up into one or two pieces delimited by tab.\n  */\n\n R->fileptr = R->buffer;        /* filename passed in buffer */\n\n tabptr = strchr(R->fileptr,'\\t');\n if (tabptr) {\n   *tabptr = '\\0';\n   R->fileptr = trim_leading_and_trailing_space(R->fileptr);\n   R->wargptr = trim_leading_and_trailing_space(tabptr+1);\n }\n else {\n   R->fileptr = trim_leading_and_trailing_space(R->fileptr);\n   R->wargptr = NULL;\n }\n\n if (!*R->fileptr) {\n   R->fileptr = DEFAULT_DIRECTORY;\n }\n\n /* If first character is numeric, assume it's a gopher type.\n  * Later we will actually support different types...\n  */\n\n switch (*R->fileptr) {\n   case '0':\n   case '1':\n   case '2':\n   case '3':\n   case '4':\n   case '5':\n   case '6':\n   case '7':\n   case '8':\n   case '9':  R->fileptr++; break;\n   default:                 break;\n }\n\n if (!R->outfp) printf(\"%s: requested:%s;\\n\",R->hostname,R->fileptr);\n\n /*\n  * Process special hacks here.\n  *\n  * For example, if the file name begins with \"exec:\", then\n  * execute the specified REXX exec.\n  *\n  * Hackless names are processed as files.  \"dd:\" is not a\n  * special hack but the normal C/370 DDname reference.\n  *\n  */\n\n colonptr = strchr(R->fileptr,':');\n if (colonptr) {\n   hacksize = colonptr - R->fileptr;\n   if (hacksize > 0 && hacksize < sizeof(hackprefix)) {\n     for (p = hackprefix, q = R->fileptr;\n          hacksize > 0;\n          p++, q++, hacksize--) *p = toupper(*q);\n     *p = '\\0';\n   }\n }\n\n if (EQUAL(hackprefix,\"EXEC\")) {\n  /*\n   * REXX exec, which must reside in SYSEXEC DD.\n   */\n   if (!authorized_file(R)) {\n     gbarf(R,\"the GOPHER server won't run the exec for you\");\n     rc = FALSE;\n   }\n   else {\n     R->fileptr = colonptr + 1;  /* point to exec itself */\n     rc = get_exec_data(R);\n   }\n }\n else\n if (EQUAL(hackprefix,\"DD\")) {\n  /*\n   * C/370 style ddname.  Assume sequential file - cannot be a PDS\n   * because I don't feel like trying to determine that right now.\n   */\n   if (!authorized_file(R)) {\n     gbarf(R,\"the GOPHER server won't read the DD for you\");\n     rc = FALSE;\n   }\n   else {\n     strcpy(R->buffer,R->fileptr); /* still points to \"DD:xxxxxxxx\" */\n     dstype = SEQ;\n     rc = get_flat_file(R);\n   }\n }\n else {\n   /* Regular file name without \":\" hack, or with invalid \":\" hack.\n    * Check to see that the file name is on our \"official\" list.\n    */\n   if (!authorized_file(R)) {\n     gbarf(R,\"the GOPHER server won't let you see the file\");\n     rc = FALSE;\n   }\n   else {\n\n   /* Dynamically allocate data set and use generated ddname.\n    * Note that we have to allocate the data set name to a ddname and\n    * then open the ddname to prevent C/370 from barfing on otherwise\n    * valid data set names like those with hyphens in them.  But this\n    * also lets us determine if the data set is sequential or a PDS.\n    */\n     strcpy(R->dsname,R->fileptr);\n     dstype = GGMalloc(R->dsname,ddname,UNK,0);\n     sprintf(R->buffer,\"DD:%s\",ddname);\n     switch (dstype) {\n       case SEQ: rc = get_flat_file(R); break;\n       case PDS: rc = get_directory(R); break;\n       default:\n               printf(\"INVALID! requested:%s\\n\",R->fileptr);\n               gbarf(R,\"the GOPHER server couldn't allocate the file\");\n               rc = FALSE;\n     }\n   }\n }\n\n GGMunalc(ddname);  /* free the ddname if set */\n\n if (!rc) {\n   fflush(stdout);\n   fflush(stderr);\n }\n\n return rc;\n\n}\n\n./   ADD NAME=GGMPTX,SSI=01000029\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@PTX  \")\n#pragma  csect(static,\"GG$PTX  \")\n#include \"gg.h\"\n\n/****** Print the lines of server text. ******************************/\n\nvoid\nGGMptx(gp,ip)\nRstruc ggcb         *gp;\nRstruc gopherinfo   *ip;\n{\n FILE               *pfp;\n struct texthdr     *thp;\n struct textline    *tp;\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n pfp = stdout;\n\n /* Article must be specified (cannot be null). */\n\n for (tp=thp->first_text_line;tp;tp=tp->next) {\n   if (tp->text_length >= 0) {\n     char *p = tp->tab_expanded_text;\n     while (*p) {\n       if isprint(*p) fprintf(pfp,\"%c\",*p);\n       else fprintf(pfp,\"?\");\n       p++;\n     }\n     fprintf(pfp,\"\\n\");\n   }\n }\n fprintf(pfp,\"\\n\");\n\n return;\n\n}\n\n./   ADD NAME=GGMSOCKT,SSI=010B0052\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SOCKT\")\n#pragma  csect(static,\"GG$SOCKT\")\n#include \"gg.h\"\n\n/****** Output one data line for the server. *************************/\n\nBool\nGGMsockt(gp)\nRstruc ggcb        *gp;\n{\n int                gopher_bytes;\n int                writrc;\n char              *s_buf;\n Bool               procok;\n struct recvstruct *R;\n\n /* Before sending a request to the server, do a cleanup operation\n  * to make sure that no more responses are coming from the server.\n  */\n\n GGMesrvr(gp);           /* End server read */\n\n /* If local mode, call server subtask processor with command. */\n\n if ((R=gp->recvp)) {\n   if (!R->outfp) {\n     CRIT1(\"Can't send data locally, non-socket not connected\");\n     return FALSE;\n   }\n   strncpy(R->buffer, gp->gopher_command, sizeof(R->buffer)-1);\n   strcpy(R->myname, LOCAL_HOST_FROB);  /* used by PDS feature */\n\n   /* allocate SYSTSPRT file, used by REXX EXEC interface */\n\n   if (GGMtso(\n     \"ALLOC FI(SYSTSPRT) T SP(100 100) REL REU DEL\"\n     \" RECFM(V B) LRECL(1024) BLKSIZE(32760)\"\n             ) != 0) {\n     fprintf(stderr,\n       \"Warning: Cannot allocate temporary SYSTSPRT file.\\n\");\n     fprintf(stderr,\n       \"         Some interfaces may not work properly.\\n\");\n   }\n\n   procok = GGMproc(R);\n\n   /* free SYSTSPRT file, used by REXX EXEC interface */\n\n   (void)GGMunalc(\"SYSTSPRT\");\n\n   /* Prepare to read from the beginning of the file */\n\n   if (fseek(R->outfp, 0, SEEK_SET) != 0) {\n     CRIT1(\"Can't reposition to start of local file\");\n     return FALSE;\n   }\n   return procok;\n }\n\n gopher_bytes = strlen(gp->gopher_command);\n\n memcpy(gp->client_buf,gp->gopher_command,gopher_bytes);\n gp->client_buf[gopher_bytes]   = CARRIAGE_RETURN;\n gp->client_buf[gopher_bytes+1] = LINE_FEED;\n\n if (gp->receiving_text &&\n     gopher_bytes == 1  &&\n     gp->client_buf[0] == '.') {\n   gp->receiving_text = FALSE;\n }\n\n if (gp->debug_mode)\n    GGMdump(gp,\"Writing to server\",gp->client_buf,gopher_bytes+2);\n\n#ifdef MVS\n EBCDIC_TO_ASCII(gp->client_buf,gopher_bytes+2);\n#endif\n\n writrc = write(gp->socknum, gp->client_buf, gopher_bytes+2);\n if (writrc < 0) {\n   gp->connection_broken = TRUE;\n   CRIT2(\"TCP/IP error: write() failed to send data to server %s.\",\n         gp->ggserver);\n   return FALSE;\n }\n\n /* Prepare server for read. */\n\n gp->server_has_something_pending = TRUE;\n gp->server_finished_replying     = FALSE;\n gp->sending_text                 = FALSE;\n gp->dont_read                    = FALSE;\n\n return TRUE;\n}\n\n./   ADD NAME=GGMSOPT,SSI=01000036\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SOPT \")\n#pragma  csect(static,\"GG$SOPT \")\n#include \"gg.h\"\n\n#define BOOLOPTSET(A,B,C) \\\n   switch (A[0]) { \\\n     case  'n': \\\n     case  'N':   B = FALSE; break; \\\n     case  'y': \\\n     case  'Y':   B = TRUE; break; \\\n     case '\\0': \\\n     default:     B = C; break; \\\n   }\n\n/****** Set options that are stored in ISPF profile. *****************/\n\nvoid\nGGMsopt(gp,which)\nRstruc ggcb        *gp;\nenum user_option    which;\n{\n int                arrows;\n char               ggextpow[  4];\n char               ggextpap[  4];\n char               ggscroll[  4];\n\n if (which == OPTION_ALL) {\n   GGMispf(gp, \"VGET (GGMUPDTF GGEXTPOW GGEXTPOP GGSCROLL) PROFILE\");\n }\n\n if (which == OPTION_ALL || which == OPTION_OTHER) {\n\n   (void)GGMivget(gp,\"GGEXTPOW \", ggextpow, sizeof(ggextpow));\n   (void)GGMivget(gp,\"GGEXTPAP \", ggextpap, sizeof(ggextpap));\n\n   BOOLOPTSET(ggextpow, gp->warn_overwrite,              TRUE);\n   BOOLOPTSET(ggextpap, gp->warn_append,                 TRUE);\n\n }\n\n if (which == OPTION_ALL || which == OPTION_VIEW) {\n\n   (void)GGMivget(gp,\"GGSCROLL \", ggscroll, sizeof(ggscroll));\n\n   BOOLOPTSET(ggscroll, gp->autoscroll, TRUE);\n\n }\n\n return;\n}\n\n./   ADD NAME=GGMSSRVR,SSI=01010032\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@SSRVR\")\n#pragma  csect(static,\"GG$SSRVR\")\n#include \"gg.h\"\n\n/****** Start server read. *******************************************/\n\nvoid\nGGMssrvr(gp)\nRstruc ggcb  *gp;\n{\n\n gp->server_has_something_pending = TRUE;\n gp->server_finished_replying     = FALSE;\n gp->sending_text                 = FALSE;\n gp->dont_read                    = FALSE;\n\n return;\n\n}\n\n./   ADD NAME=GGMTNET,SSI=01050009\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TNET \")\n#pragma  csect(static,\"GG$TNET \")\n#include \"gg.h\"\n\n/****** Gopher TELNET interface. *************************************/\n\nBool\nGGMtnet(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;\n{\n int                tsorc;\n char               tsocmd[256];\n\n if (as_file) {\n   ERR1(\"TELNET interface cannot be viewed as a file.\");\n   return FALSE;\n }\n\n GGMispf(gp,\"CONTROL DISPLAY LINE\");\n\n fprintf(stderr,\"Note: Login as user: %s\\n\\n\", ip->path);\n\n if (ip->port==0) sprintf(tsocmd,\"%s %s\",TELNET_COMMAND_NAME,ip->host);\n else sprintf(tsocmd,\"%s %s %d\",TELNET_COMMAND_NAME,ip->host,ip->port);\n\n if ((tsorc = GGMtso(tsocmd)) != 0) {\n   ERR3(\"%s command returned code %d\", TELNET_COMMAND_NAME, tsorc);\n }\n\n GGMispf(gp,\"CONTROL DISPLAY REFRESH\");\n\n return TRUE;\n}\n\n./   ADD NAME=GGMTSO,SSI=01000051\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n /********************************************************************/\n /*                                                                  */\n /* Thanks to Michael Van Norman for this code.                      */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TSO  \")\n#pragma  csect(static,\"GG$TSO  \")\n#include \"gg.h\"\n\n#pragma linkage(ikjeftsr,OS)\n\n#define _IKJEFTSR_FLAGS_AUTH        0x00000000\n#define _IKJEFTSR_FLAGS_COMMAND     0x00000001\n#define _IKJEFTSR_FLAGS_DUMP        0x00000100\n#define _IKJEFTSR_FLAGS_NODUMP      0x00000000\n#define _IKJEFTSR_FLAGS_PROGRAM     0x00000002\n#define _IKJEFTSR_FLAGS_UNAUTH      0x00010000\n\n/****** Issue TSO command. *******************************************/\n\nint\nGGMtso(command)\nchar        *command;\n{\n int         flags         = _IKJEFTSR_FLAGS_COMMAND +\n                             _IKJEFTSR_FLAGS_UNAUTH;\n int         commandLength = strlen(command);\n int         rc            = 0;\n int         returnCode    = 0;\n int         reasonCode    = 0;\n int         abendCode     = 0;\n\n static int (*ikjeftsr)() = NULL;\n\n if (!ikjeftsr) {\n   int tsoEntryAddress;\n\n   tsoEntryAddress = 0x00000010;    /* Address of CVT */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n   tsoEntryAddress += 0x9C;/*       /* Offset of TVT in CVT */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n   tsoEntryAddress += 0x10;/*       /* TSVTASF-TSVT (from IKJTSVT) */\n   tsoEntryAddress = *(int *)(tsoEntryAddress);\n   ikjeftsr = (int (*)())(tsoEntryAddress);\n }\n\n if (!ikjeftsr) {\n   fprintf(stderr,\n           \"Cannot execute TSO commands, can't fetch IKJEFTSR.\\n\");\n   return -2;\n }\n\n rc = (*ikjeftsr)(&flags, command, &commandLength,\n                          &returnCode, &reasonCode,\n                          (int *)((int)(&abendCode) | 0x80000000));\n\n if (rc != 0) {\n   if (rc > 4) {\n     fprintf(stderr,\"Command failed:%s\\n\",command);\n     if (rc == 20 && reasonCode == 40)\n          fprintf(stderr,\"Command was not found.\\n\");\n     else fprintf(stderr,\n             \"rc=%d,returncode=%d,reasoncode=%d,abendcode=%8.8x\\n\",\n             rc, returnCode, reasonCode, abendCode);\n   }\n   if (abendCode != 0) rc = -1;\n   else rc = returnCode;\n }\n\n return rc;\n}\n\n./   ADD NAME=GGMTYPE,SSI=01040025\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@TYPE \")\n#pragma  csect(static,\"GG$TYPE \")\n#include \"gg.h\"\n\n/*********************************************************************/\n\nchar *\nGGMtype(gophertype t)\n{\n\n switch (t) {\n   case GOPHER_FILE:        return \"File     \";\n   case GOPHER_DIRECTORY:   return \"Directory\";\n   case GOPHER_CSO:         return \"Cso      \";\n   case GOPHER_ERROR:       return \"Error    \";\n   case GOPHER_MAC_BINHEX:  return \"Binhex   \";\n   case GOPHER_DOS_BINARCH: return \"Binarch  \";\n   case GOPHER_UUENCODE:    return \"Uuencode \";\n   case GOPHER_WAIS:        return \"Index    \";\n   case GOPHER_TELNET:      return \"Telnet   \";\n   case GOPHER_TN3270:      return \"TN3270   \";\n   case GOPHER_BINARY:      return \"Binary   \";\n   case GOPHER_REDUNDANT:   return \"Redundant\";\n   case GOPHER_WHOIS:       return \"Whois    \";\n   default:                 return \"Unknown  \";\n }\n}\n\n./   ADD NAME=GGMUNALC,SSI=01000040\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@UNALC\")\n#pragma  csect(static,\"GG$UNALC\")\n#include \"gg.h\"\n\n/****** Unallocate a data set. ***************************************/\n\nBool\nGGMunalc(ddname)\nchar         *ddname;\n{\n __S99parms   stuff99;   /* The manual has it wrong.  No \"struct\". */\n int          rc;\n char        *cp;\n TEXTUNIT    *tu [2];\n TEXTUNIT     tu_ddn;\n TEXTUNIT     tu_una;\n\n if (!ddname ||\n     !*ddname) return TRUE;   /* if no ddname to free, do nothing */\n\n memset((char *)&stuff99,0,sizeof(__S99parms));\n\n stuff99.__S99RBLN   = 20;\n stuff99.__S99VERB   = S99VRBUN;\n stuff99.__S99FLAG1  = 0;\n stuff99.__S99ERROR  = 0;\n stuff99.__S99INFO   = 0;\n stuff99.__S99TXTPP  = tu;\n stuff99.__S99FLAG2  = 0;\n\n tu[0] = &tu_ddn;\n tu[1] = &tu_una;\n *(int *)&tu[1] |= 0x80000000;\n\n tu_ddn.key     = DUNDDNAM;\n tu_ddn.num     = 1;\n tu_ddn.ent.len = strlen(ddname);\n strcpy(tu_ddn.ent.prm,ddname);\n\n tu_una.key     = DUNUNALC;\n tu_una.num     = 0;\n\n for (cp=tu_ddn.ent.prm; *cp; cp++) *cp = toupper(*cp);\n\n rc = svc99(&stuff99);\n\n if (rc == 0) return TRUE;\n else if (stuff99.__S99ERROR == 0x0438) /* not freed, is not allocated*/\n         return TRUE;\n else {\n   GGMdfail(rc,&stuff99);\n   return FALSE;\n }\n}\n\n./   ADD NAME=GGMVTX,SSI=01050014\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@VTX  \")\n#pragma  csect(static,\"GG$VTX  \")\n#include \"gg.h\"\n\n/****** BRIF fakeout. ************************************************/\n\nstatic void\nfake_out_for_brif(fpp,codebuf)\nvoid **fpp;\nchar  *codebuf;\n\n#ifndef I370\n\n/* The purpose of this is to put a wrapper around the actual\n   function pointed to by the argument, so that FORTRAN-style\n   return codes (in register 0) get put into register 15.\n\n   Source code:\n\n         USING *,15\n         ST    14,save_14\n         L     15,realcode\n         DROP  15\n         BALR  14,15\n         USING *,14\n         L     14,save_14\n         DROP  14\n         LR    15,0\n         BR    14\n         SPACE 1\nsave_14  DS    F\nrealcode DS    F\n\n *** Warning: As written, this fake-out code is not reentrant. ***\n\n*/\n\n{\n static char fake_out_code[32] = {\n                               0x50,0xE0,0xF0,0x14,0x58,0xF0,0xF0,0x18,\n                               0x05,0xEF,0x58,0xE0,0xE0,0x0A,0x18,0xF0,\n                               0x07,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,\n                               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n                                 };\n\n memcpy(codebuf,fake_out_code,32);\n memcpy(codebuf+0x18,(char *)fpp,4);\n\n#else\n\n/* The purpose of this is to put a wrapper around the actual\n   function pointed to by the argument, so that the C Runtime\n   Anchor Block pointer (in register 12) can be saved/restored.\n*/\n\n{\n#define FAKE_BUF_SIZE 48               /*                             */\n static short fake_out_code[FAKE_BUF_SIZE/2] =\n {                                     /*     USING *,15              */\n  0x50C0,0xF020,                       /* +00 ST    14,save_12        */\n  0x50E0,0xF024,                       /* +04 ST    12,save_14        */\n  0x58C0,0xF02C,                       /* +08 L     12,crab           */\n  0x58F0,0xF028,                       /* +0C L     15,realcode       */\n                                       /*     DROP  15                */\n  0x58F0,0xF000,                       /* +10 L     15,0(,15)         */\n  0x05EF,                              /* +14 BALR  14,15             */\n                                       /*     USING *,14              */\n  0x58C0,0xE00A,                       /* +16 L     12,save_12        */\n  0x58E0,0xE00E,                       /* +1A L     14,save_14        */\n                                       /*     DROP  14                */\n  0x07FE,                              /* +1E BR    14                */\n  0x0000,0x0000,                       /* +20 save_12                 */\n  0x0000,0x0000,                       /* +24 save_14                 */\n  0x0000,0x0000,                       /* +28 realcode                */\n  0x0000,0x0000                        /* +2C crab                    */\n };\n\n memcpy( codebuf, fake_out_code, FAKE_BUF_SIZE );\n memcpy( codebuf+0x28, (char *)fpp, 4 );\n _ldregs( R2, codebuf+0x2C  ),         /* get -> crab in fakeout buff */\n _code  ( 0, 0x50C0, 0x2000 );         /* save -> CRAB                */\n\n#endif\n\n *fpp = (void *)codebuf;\n\n return;\n\n}\n\n/****** Print text lines. ********************************************/\n\nstatic void\nprint_text_lines(fp,textp)\nFILE              *fp;\nstruct textline   *textp;\n{\n struct textline  *tp;\n char             *p;\n\n for (tp=textp; tp; tp=tp->next) {\n   if (tp->text_length >= 0) {\n     p = tp->tab_expanded_text;\n     while (*p) {\n       if isprint(*p) fprintf(fp,\"%c\",*p);\n       else fprintf(fp,\"?\");\n       p++;\n     }\n     fprintf(fp,\"\\n\");\n   }\n }\n fprintf(fp,\"\\n\");\n\n return;\n}\n\n/****** View the lines of text retrieved from the server. ************/\n\nBool\nGGMvtx(gp,ip,as_file)\nRstruc ggcb         *gp;\nRstruc gopherinfo   *ip;\nFool                 as_file;  /* ignored */\n{\n int                brif_max_reclen;\n int                i;\n char              *p;\n char              *q;\n struct texthdr    *texthdrp;\n void              *dialog_data_ptr;\n void              *read_function_ptr;\n void              *command_function_ptr;\n char               read_fakeout_buffer    [32];\n char               command_fakeout_buffer [32];\n char               brif_title             [81];\n\n texthdrp = (ip ? &ip->thdr : &gp->thdr);\n\n if (gp->brifp) {\n   printf(\"Cannot use ISPF BROWSE now, displaying in line mode:\\n\\n\");\n   print_text_lines(stdout,texthdrp->first_text_line);\n   return TRUE;\n }\n\n gp->brifp = texthdrp;\n\n gp->brif_previous_recno = -1;\n\n if (!ip) sprintf(brif_title, \"GopherServer:%s \",gp->ggserver);\n else {\n   /* BRIF doesn't like blanks in the title */\n   for (p=ip->desc,q=brif_title,i=sizeof(brif_title)-1;\n        i > 0 && *p;\n        p++,q++,i--) {\n     *q = (*p == ' ' ? '_' : *p);\n   }\n   *q = ' ';\n   *(q+1) = '\\0';\n }\n\n brif_max_reclen      = gp->brifp->text_max_tab_expanded_length;\n dialog_data_ptr      = (void *)gp;\n read_function_ptr    = (void *)&GGMbrifr;\n command_function_ptr = (void *)&GGMbrifc;\n\n fake_out_for_brif(&read_function_ptr,read_fakeout_buffer);\n fake_out_for_brif(&command_function_ptr,command_fakeout_buffer);\n\n if (gp->test_mode) {\n   printf(\"Here are the %d lines BRIF should be displaying:\\n\\n\",\n          gp->brifp->text_line_count);\n   print_text_lines(stdout,gp->brifp->first_text_line);\n   gp->brifp = NULL;\n   return TRUE;\n }\n\n if (gp->setmsg) {\n   (void)GGMispf(gp,\"SETMSG MSG(ISRZ002)\");\n   gp->setmsg = FALSE;\n }\n\n gp->ispfrc = ISPLINK(\"BRIF \",\n                      brif_title,\n                      \"V \",              /* variable record format */\n                      &brif_max_reclen,\n                      &read_function_ptr,\n                      &command_function_ptr,\n                      &dialog_data_ptr,\n                      \"        \",        /* use IBM's   browse panel */\n                      \"        \",        /* no format */\n                      \"NO \");            /* default sbcs data */\n\n gp->brifp = NULL;\n\n switch (gp->ispfrc) {\n   case  0:\n           break;\n   case 12:\n ERR1(\"There is no data returned from the gopher host to be browsed.\");\n           break;\n   case 16:\n           break;\n   default:\n           GGMierr(gp);   /* handle ISPF error */\n           break;\n }\n\n return TRUE;\n}\n\n./   ADD NAME=GGMWAIS,SSI=01080054\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@WAIS \")\n#pragma  csect(static,\"GG$WAIS \")\n#include \"gg.h\"\n\n/****** Gopher WAIS interface. *************************************/\n\nBool\nGGMwais(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;\n{\n char              *lp;\n char               ggwaisq[256];\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n\n strcpy(ggwaisq,\"\");\n\n GGMispf(gp,\"VGET (GGWAISQ) PROFILE\");\n\n if (GGMdispl(gp,\"GGMPWAIS\") > 0) return FALSE;\n\n GGMivget(gp,\"GGWAISQ \",ggwaisq, sizeof(ggwaisq));\n\n if (!*ip->path) strcpy(gp->gopher_command, ggwaisq);\n else            sprintf(gp->gopher_command,\"%s\\t%s\",ip->path,ggwaisq);\n\n gp->ginfo = ip;\n gp->receiving_text = FALSE;\n\n if (!GGMconn(gp)) return FALSE;   /* Connect to gopher server      */\n\n if (!GGMsockt(gp)) return FALSE;  /* Send socket command to server */\n\n GGMclrtx(gp,ip);                  /* Clear text */\n\n gp->receiving_text = TRUE;\n\n do {\n   if (GGMgsrvl(gp,&lp,TRUE)) {           /* Get server line */\n     if (lp) {\n       (void)GGMouttx(gp,lp,ip);          /* Output text line */\n     }\n   }\n } while (lp);                            /* until no more lines */\n\n if (gp->time_to_go_home) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n if (gp->connected_to_server) {\n   (void)GGMdisc(gp);              /* Disconnect from gopher server */\n }\n\n GGMdir(gp,ip,as_file); /* display entries returned from WAIS server */\n\n return TRUE;\n\n}\n\n./   ADD NAME=GGMWHOIS,SSI=01030030\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@WHOIS\")\n#pragma  csect(static,\"GG$WHOIS\")\n#include \"gg.h\"\n\n/****** Gopher WHOIS/FINGER interface. *****************************/\n\nBool\nGGMwhois(gp,ip,as_file)\nRstruc ggcb        *gp;\nRstruc gopherinfo  *ip;\nFool                as_file;        /* ignored */\n{\n char              *lp;\n Bool               got_some;\n char               ggwhoisq[256];\n\n strcpy(gp->ggserver,ip->host);     /* Specify server to connect to */\n\n strcpy(ggwhoisq,\"\");\n\n GGMispf(gp,\"VGET (GGWHOISQ) PROFILE\");\n\n if (GGMdispl(gp,\"GGMPWHOI\") > 0) return FALSE;\n\n GGMivget(gp,\"GGWHOISQ \",ggwhoisq, sizeof(ggwhoisq));\n\n if (!*ip->path) strcpy(gp->gopher_command, ggwhoisq);\n else            sprintf(gp->gopher_command,\"%s\\t%s\",ip->path,ggwhoisq);\n\n gp->ginfo = ip;\n gp->receiving_text = FALSE;\n\n if (!GGMconn(gp)) return FALSE;   /* Connect to gopher server      */\n\n if (!GGMsockt(gp)) return FALSE;  /* Send socket command to server */\n\n GGMclrtx(gp,ip);                  /* Clear text */\n\n gp->receiving_text = TRUE;\n got_some = FALSE;\n do {\n   if (GGMgsrvl(gp,&lp,TRUE)) {           /* Get server line */\n     if (lp) {\n       got_some = TRUE;\n       (void)GGMouttx(gp,lp,ip);          /* Output text line */\n     }\n   }\n } while (lp);                            /* until no more lines */\n\n if (!got_some) {\n   WARN2(\"No data available from server %s.\\n\",gp->ggserver);\n   return FALSE;\n }\n\n if (gp->connected_to_server) {\n   (void)GGMdisc(gp);              /* Disconnect from gopher server */\n }\n\n GGMvtx(gp,ip,as_file);  /* display text from WHOIS/FINGER server */\n\n return TRUE;\n\n}\n\n./   ADD NAME=GGMXTX,SSI=01050051\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GG@XTX  \")\n#pragma  csect(static,\"GG$XTX  \")\n#include \"gg.h\"\n\n/****** Extract the lines of server text into a data set. ************/\n\nBool\nGGMxtx(gp,ip)\nRstruc ggcb         *gp;\nRstruc gopherinfo   *ip;\n{\n FILE               *xfp;\n struct texthdr     *thp;\n struct textline    *tp;\n struct extraction  *ep;\n int                 l;\n char               *cp;\n char                formatted_number [11];\n struct extraction   the_extraction;\n\n thp = (ip ? &ip->thdr : &gp->thdr);\n\n /* Set article data for message. */\n\n if (ip) {\n   sprintf(formatted_number,\"%d\",ip->type);\n   (void)GGMivput(gp,\"GGTNUM \",  formatted_number, -1);\n   (void)GGMivput(gp,\"GGTSUBJ \", ip->desc,         -1);\n }\n\n if (gp->extract_file) {\n   (void)GGMispf(gp,\"CONTROL DISPLAY LOCK\");\n   (void)GGMispf(gp,\"DISPLAY PANEL(GGMLEXN2)\");\n   xfp = gp->extract_file;\n }\n else {\n\n   ep = &the_extraction;\n   memset(ep,0,sizeof(struct extraction));\n   ep->mode = SEQ;\n   strcpy(ep->panelname,\"GGMPEXDS\");\n\n   if (!((xfp=GGMgetds(gp,ep)))) return FALSE;\n\n   gp->extract_tab_expanding          = ep->tab_expanding;\n   gp->extract_appending              = ep->appending;\n   gp->extract_blank_before_separator = ep->blanking;\n   gp->extract_separator_line         = ep->separator;\n }\n\n /* If append mode, and a separator line was specified, use it. */\n\n gp->extract_write_error = FALSE;\n gp->extract_close_error = FALSE;\n\n while (gp->extract_appending && gp->extract_separator_line &&\n        *gp->extract_separator_line) {\n   if (fprintf(xfp,\"%s\\n\",gp->extract_separator_line) < 0) {\n     gp->extract_write_error = TRUE; break;\n   }\n   if (gp->extract_blank_before_separator) {\n     if (fprintf(xfp,\"\\n\") < 0) {\n       gp->extract_write_error = TRUE; break;\n     }\n   }\n   break;\n }\n for (tp = thp->first_text_line;\n      tp && !gp->extract_write_error;\n      tp = tp->next) {\n   if (tp->text_length == 0) {\n     if (fputc('\\n',xfp) == EOF) {\n       gp->extract_write_error = TRUE; break;\n     }\n   }\n   else if (tp->text_length > 0) {\n     if (gp->extract_tab_expanding) {\n       cp = tp->tab_expanded_text;\n       l  = tp->tab_expanded_text_length;\n     }\n     else {\n       cp = tp->text;\n       l  = tp->text_length;\n     }\n     for (; l > 0; cp += 251, l -= 251) {\n       fwrite(cp,(l>251 ? 251 : l),1,xfp);\n       if (ferror(xfp)) {\n         gp->extract_write_error = TRUE; break;\n       }\n       if (fputc('\\n',xfp) == EOF) {\n         gp->extract_write_error = TRUE; break;\n       }\n     }\n   }\n }\n\n if (!gp->extract_write_error && ferror(xfp))\n    gp->extract_write_error = TRUE;\n\n if (!gp->extract_appending || !gp->extract_file) {\n   if (fclose(xfp) < 0) {\n     /* perror(nnexdsn); */\n     ERR2(\"An error occurred closing data set %s.\", ep->dsname);\n     gp->extract_close_error = TRUE;\n     return FALSE;\n   }\n }\n\n if (!gp->extract_file) {\n   if (gp->extract_write_error) {\n     ERR2(\"An error occurred writing to data set %s.\", ep->dsname);\n     gp->extract_write_error = TRUE;\n   }\n   else if (ip) {\n     WARN2(\"Current item extracted into file %s.\",\n            ep->dsname);\n   }\n   else {\n     WARN2(\"Displayed text has been extracted into file %s.\",\n            ep->dsname);\n   }\n }\n if (gp->extract_write_error) return FALSE;\n else return TRUE;\n}\n\n./   ADD NAME=GGSERVER,SSI=01240010\n/*\n ***********************************************************************\n *                                                                     *\n * GOPHER server, based on the simple TCP/IP server from Shawn Hart at *\n * the University of Delaware.                                         *\n *                                                                     *\n ***********************************************************************\n *\n *  This server follows the GOPHER protocols defined by UMN.\n *  For more information, see the ANONYMOUS FTP site at\n *  BOOMBOX.MICRO.UMN.EDU.\n *\n ***********************************************************************\n *\n * November 1992 - parameters may be passed to the server:\n *\n * -d              run in debug mode\n *\n ***********************************************************************\n *\n * December 1992 - support for SNS/TCPAccess compilation\n *\n ***********************************************************************\n */\n\n#pragma  csect(code,  \"GG@ERVER\")\n#pragma  csect(static,\"GG$ERVER\")\n#include \"gg.h\"                 /* All system file includes needed. */\n\n/********************************************************************/\n\nstatic int\ntcpsetup(int          port,\n         int          qlen,\n         FILE        *debugfp)\n{\n int                  tinitrc;             /* loop counter*/\n int                  sockfd;              /* loop counter*/\n int                  x;                   /* loop counter*/\n struct linger        l;                   /* linger for setsockopt */\n struct sockaddr_in   server;          /*server address information */\n\n /*    initialize the MTF  environment.                   */\n\n if (debugfp) {\n   fprintf(debugfp,\"tinit...\\n\");\n   fflush(debugfp);\n }\n\n tinitrc = tinit(\"GGSTASK\", MTF_TASKS);\n\n if (tinitrc != MTF_OK) {\n   GGMmtfer(tinitrc, \"TINIT\");\n   return -1;\n }\n\n /*       open a TCP socket...                            */\n\n if (debugfp) {\n   fprintf(debugfp,\"socket...\\n\");\n   fflush(debugfp);\n }\n\n if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n   REPORT_TCP_ERROR(\"SOCKET - \");\n   return -1;\n };\n\n /*  set the linger option on so we wait for data to be sent... */\n\n l.l_onoff  =  1;\n l.l_linger =100;           /* wait 100 seconds before giving up */\n\n if (debugfp) {\n   fprintf(debugfp,\"setsockopt (%d, SO_LINGER)...\\n\",sockfd);\n   fflush(debugfp);\n }\n\n if (setsockopt(sockfd,SOL_SOCKET,SO_LINGER,(char *)&l,sizeof(l))\n     < 0) {\n   REPORT_TCP_ERROR(\"SETSOCKOPT - \");\n   return -1;\n }\n\n /*    now bind our local address so that the client can send to us */\n\n memset((char *)&server, 0, sizeof(server));\n server.sin_family           =   AF_INET;\n server.sin_addr.s_addr      =   INADDR_ANY;\n server.sin_port             =   htons(port);\n\n if (debugfp) {\n   fprintf(debugfp,\"bind (%d)...\\n\",sockfd);\n   fflush(debugfp);\n }\n\n if (Bind(sockfd, &server, sizeof(server)) < 0) {\n   REPORT_TCP_ERROR(\"BIND - \");\n   return -1;\n }\n\n /*    now set length of the connection queue... */\n\n if (debugfp) {\n   fprintf(debugfp,\"listen (sockfd=%d, qlen=%d)...\\n\",sockfd,qlen);\n   fflush(debugfp);\n }\n\n if (listen(sockfd,qlen) != 0) {\n   REPORT_TCP_ERROR(\"LISTEN -\");\n   return -1;\n }\n\n return sockfd;\n\n}\n\n\n/********************************************************************/\n/*\n*   This routine waits for an exception on the socket.  When one\n*   occurs (by a subtask's \"TAKESOCKET\"!) we'll close our (the main\n*   task's) connection to it.\n*\n*               INPUT   s   pointer to socket descripter.\n*               OUTPUT  rc  -1 = connection timed out...\n*                            0 = an excption occured!\n*/\n/********************************************************************/\n\n#ifdef SNSTCPIP\n\nstatic int\nclosesock(int              newsockfd,\n          FILE            *debugfp)\n{\n if (debugfp) {\n   fprintf(debugfp,\"close (%d)...\\n\",newsockfd);\n   fflush(debugfp);\n }\n\n if (close(newsockfd) < 0) REPORT_TCP_ERROR(\"CLOSE -\");\n return 0;\n}\n\n#else\n\nstatic int\nclosesock(int              newsockfd,\n          FILE            *debugfp)\n{\n int                       temps;\n struct sockaddr           clientaddress;\n int                       addrlen;\n int                       maxfdpl;\n struct fd_set             readmask;\n struct fd_set             writmask;\n struct fd_set             exepmask;\n int                       rc;\n struct timeval            time;\n\n temps = newsockfd;\n time.tv_sec = CONNECT_TIME_OUT;\n time.tv_usec = 0;\n maxfdpl = temps + 1;\n\n FD_ZERO(&readmask);\n FD_ZERO(&writmask);\n FD_ZERO(&exepmask);\n FD_SET(temps, &exepmask);\n\n if (debugfp) {\n   fprintf(debugfp,\"select (maxfdpl=%d)...\\n\",maxfdpl);\n   fflush(debugfp);\n }\n\n rc = select(maxfdpl, &readmask, &writmask, &exepmask, &time);\n\n if (rc < 0) {\n   REPORT_TCP_ERROR(\"SELECT - \");\n   return rc;\n }\n else {\n   if (rc == 0) fprintf(stdout,\"The GIVESOCKET timed out!\\n\");\n\n   if (debugfp) {\n     fprintf(debugfp,\"close (%d)...\\n\",newsockfd);\n     fflush(debugfp);\n   }\n\n   if (close(newsockfd) < 0) REPORT_TCP_ERROR(\"CLOSE -\");\n   return rc;\n }\n}\n\n#endif\n\n/********************************************************************/\n/*\n*       This routine starts a subtask, passing control of a socket\n*       to it.  It then waits for the subtask to take the socket and\n*       then closes the socket.\n*\n*       INPUT: newsockfd - socket descriptor to give to subtask.\n*/\n/********************************************************************/\n\nstatic Bool\nspawn(\n      int          newsockfd,\n      FILE        *debugfp)\n{\n int               tschedrc;\n#ifdef SNSTCPIP\n unsigned long     token;\n#else\n struct clientid   clid;\n char              mysname[8];\n#endif\n\n if (debugfp) {\n   fprintf(debugfp,\"getclientid...\\n\");\n   fflush(debugfp);\n }\n\n#ifdef SNSTCPIP\n\n token = closepass(newsockfd);\n if (debugfp) {\n   fprintf(debugfp,\"token = %X\\n\",token);\n   fflush(debugfp);\n }\n\n#else\n\n memset(&clid,0,sizeof(clid));\n if(getclientid(AF_INET,&clid) < 0) {\n   REPORT_TCP_ERROR(\"GETCLIENTID\");\n   return FALSE;\n }\n\n if (debugfp) {\n   fprintf(debugfp,\"client name = %8.8s, subtaskname = %8.8s\\n\",\n                   clid.name, clid.subtaskname);\n   fflush(debugfp);\n }\n\n clid.domain = AF_INET;\n memcpy(mysname,clid.subtaskname,8);\n memcpy(clid.subtaskname,\"        \",8);\n\n if (debugfp) {\n   fprintf(debugfp,\"givesocket (%d)...\\n\",newsockfd);\n   fflush(debugfp);\n }\n\n if(givesocket(newsockfd,&clid) != 0) {\n   REPORT_TCP_ERROR(\"GIVESOCKET\");\n   return FALSE;\n }\n memcpy(clid.subtaskname,mysname,8);\n\n if (debugfp) {\n   fprintf(debugfp,\"client name = %8.8s, subtaskname = %8.8s\\n\",\n                   clid.name, clid.subtaskname);\n   fflush(debugfp);\n }\n\n#endif\n\n if (debugfp) {\n   fprintf(debugfp,\"tsched...\\n\");\n   fflush(debugfp);\n }\n\n tschedrc = tsched(MTF_ANY,\"GGSRECV\",\n#ifdef SNSTCPIP\n                           token,\n#else\n                           newsockfd,\n                           clid,\n#endif\n                           (debugfp ? 1 : 0));\n\n if (debugfp) {\n   fprintf(debugfp,\"tsched completed...rc=%d\\n\",tschedrc);\n   fflush(debugfp);\n }\n\n if (tschedrc != 0) {\n   GGMmtfer(tschedrc,\"TSCHED\");\n   return FALSE;\n }\n\n if (closesock(newsockfd,debugfp) < 0) {\n   REPORT_TCP_ERROR(\"close socket\");\n   return FALSE;\n }\n\n return TRUE;\n\n}\n\n/******************************************************************/\n\nint\nmain(int            argc,\n         char     **argv)\n{\n int                trc;               /* return code */\n int                x;                 /* loop counter*/\n int                sockfd;            /* connection socket...*/\n int                newsockfd;         /* new connection socket...*/\n int                clientlen;         /* new connection socket...*/\n int                i;\n char              *p;\n FILE              *debugfp;\n struct sockaddr_in client;            /* client address information */\n#ifndef SNSTCPIP\n struct clientid    clid;              /* client info for givesocket */\n#endif\n char               buffer[255];       /* buffer for input/output*/\n\n/******************************************************************/\n/* Process server parameters.                                     */\n/******************************************************************/\n\n debugfp = NULL;\n\n for (i = 1; i < argc; i++) {\n   p = argv[i];\n   if (*p == '-') {\n     while (*++p) {\n       switch (toupper(*p)) {\n         case 'D':  debugfp = fopen(\"dd:ggdebug\",\"w\");\n                    break;\n         default:   break;\n       }\n     }\n   }\n }\n\n/******************************************************************/\n/*         set up the connection to the socket...                 */\n/******************************************************************/\n\n sockfd = tcpsetup(SERV_TCP_PORT,TCP_QUEUE_LENGTH,debugfp);\n if (sockfd < 0) {\n   fprintf(stdout,\"Could not set up the TCP/IP environment!\\n\");\n   exit(16);\n }\n\n/******************************************************************/\n/*         Now loop, waiting for a connection request.            */\n/******************************************************************/\n\n clientlen = sizeof(client);\n x = 0;\n for (;;) {\n\n   if (debugfp) {\n     fprintf(debugfp,\"accept (%d)...\\n\",sockfd);\n     fflush(debugfp);\n   }\n\n   if ((newsockfd=Accept(sockfd,&client,&clientlen)) == -1) {\n     REPORT_TCP_ERROR(\"ACCEPT - \");\n     exit(8);\n   }\n   if (debugfp) {\n     fprintf(debugfp,\"newsockfd=%d...\\n\",newsockfd);\n     fflush(debugfp);\n   }\n\n   x++;\n   if (!spawn(newsockfd,debugfp)) {\n     fprintf(stdout,\"spawn failed for socket %d\\n\",newsockfd);\n     exit(8);\n   }\n   else {\n     if (debugfp) {\n       fprintf(debugfp,\"spawn OK for socket %d\\n\",newsockfd);\n       fflush(debugfp);\n     }\n   }\n }\n\n/******************************************************************/\n/*         Wait for all pending tasks to complete (should never   */\n/*         run, since I haven't added PURGE support yet...)       */\n/*         then shut down subtasks.                               */\n/******************************************************************/\n\n if (debugfp) {\n   fprintf(debugfp,\"tsyncro...\\n\");\n   fflush(debugfp);\n }\n\n trc = tsyncro(MTF_ALL);\n if (trc != 0) {\n   GGMmtfer(trc,\"TSYNCRO\");\n }\n\n if (debugfp) {\n   fprintf(debugfp,\"tterm...\\n\");\n   fflush(debugfp);\n }\n\n trc = tterm();\n if (trc != 4) {\n   GGMmtfer(trc,\"TTERM\");\n   exit(8);\n }\n\n if (debugfp) fclose(debugfp);\n\n exit(0);\n\n}\n./   ADD NAME=GGSTASK,SSI=01630058\n\n /********************************************************************/\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n#pragma  csect(code,  \"GGSTASK \")\n#pragma  csect(static,\"GG$TASK \")\n\n#include \"gg.h\"\n\n/*=================================================================*/\n\n/*******************************************************************/\n/*                                                                 */\n/*    this is a debugging routine;  it looks at the status of a    */\n/*    socket.                                                      */\n/*******************************************************************/\n\nstatic void\nlookatsocket(int sockfd)\n{\n int             rc;                       /* return code */\n int             length;                   /* length variable */\n int             option;\n int             x;\n struct linger   l;                        /* linger structure */\n char            buffer[RBUFSIZE];\n\n length = sizeof(l);\n if (Getsockopt(sockfd,SOL_SOCKET, SO_LINGER,&l,&length)==0) {\n   printf(\"l_onoff=%d\\n\",l.l_onoff);\n   printf(\"l_linger=%d\\n\",l.l_linger);\n }\n else REPORT_TCP_ERROR(\"GETSOCKOPT\");\n\n length = sizeof(option);\n if (Getsockopt(sockfd,SOL_SOCKET, SO_ERROR,&option,&length)==0) {\n   printf(\"so_error=%d\\n\",option);\n }\n else REPORT_TCP_ERROR(\"GETSOCKOPT\");\n\n if (fcntl(sockfd,F_SETFL,FNDELAY)!=0) REPORT_TCP_ERROR(\"FCNTL\");\n\n length = recv(sockfd,buffer,sizeof(buffer)-1,0);\n if (length == -1) {\n   if (errno != EWOULDBLOCK) REPORT_TCP_ERROR(\"recv\");\n }\n else {\n   buffer[sizeof(buffer)-1] = 0;\n   printf(\"buffer =%s\\n\",buffer);\n   for (x=0;x<length;x++) printf(\"%x \",buffer[x]);\n   printf(\"\\n\");\n }\n\n}\n\n/*******************************************************************/\n\n/**************************************************************/\n/*    this routine processes the data once a connection       */\n/*    has been accepted.  It just takes the data sent by the  */\n/*    client and prints it to sysprint, then sends it back    */\n/*    to the client.                                          */\n/*                                                            */\n/*             INPUT:   newsockfd  - socket descriptor        */\n/*                      clid       - takesocket structure...  */\n/**************************************************************/\n\nvoid\nGGSrecv(\n#ifdef SNSTCPIP\n unsigned long      token,\n#else\n int                newsockfd,\n struct clientid    clid,\n#endif\n int                is_debug\n       )\n{\n struct recvstruct *R;\n struct hostent    *hostentp;\n char              *bufptr;   /* pointer into buffer strings         */\n char              *hp;\n char             **halias;\n int                retcode;  /* return code                         */\n int                len;      /* length of the buffer we're sent     */\n int                x;        /* loop counter                        */\n int                addrlen;  /* length of client address socket     */\n int                hostlen;\n int                domslen;\n struct sockaddr_in clientaddress; /* address of client              */\n struct recvstruct  r;\n time_t             timeval;\n struct tm         *tmp;\n char               outbuf[RBUFSIZE];  /* hold an output string */\n char               timestamp[20];\n\n memset(&r, 0, sizeof(struct recvstruct));\n R = &r;\n\n#ifdef SNSTCPIP\n\n if (is_debug) {\n   fprintf(stdout,\"openold (token=%X)...\\n\",token);\n   fflush(stdout);\n }\n s0skcfg.exitfunc = NULL; /* Set exit address to NULL */\n R->sockfd = openold(token);\n if (is_debug) {\n   fprintf(stdout,\"sockfd from openold is %d\\n\", R->sockfd);\n   fflush(stdout);\n }\n if(R->sockfd < 0) {\n   REPORT_TCP_ERROR(\"OPENOLD\");\n   fflush(stderr);\n   return;\n }\n\n#else\n\n if (is_debug) {\n   fprintf(stdout,\"takesocket (newsockfd=%d)...\\n\",newsockfd);\n   fprintf(stdout,\"name is %8.8s, subtaskname is %8.8s\\n\",\n                  clid.name,clid.subtaskname);\n   fflush(stdout);\n }\n\n R->sockfd = takesocket(&clid,newsockfd);\n if (is_debug) {\n   fprintf(stdout,\"sockfd from takesocket is %d\\n\", R->sockfd);\n   fflush(stdout);\n }\n if(R->sockfd < 0) {\n   REPORT_TCP_ERROR(\"TAKESOCKET\");\n   return;\n }\n\n#endif\n\n time(&timeval);\n tmp = localtime(&timeval);\n sprintf(timestamp,\"%2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\",\n         tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_year,\n         tmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n\n if (is_debug) {\n   fprintf(stdout,\"getpeername...\\n\");\n   fflush(stdout);\n }\n\n addrlen = sizeof(clientaddress);\n if(Getpeername(R->sockfd,&clientaddress,&addrlen)!=0) {\n   REPORT_TCP_ERROR(\"GETPEERNAME\");\n   printf(\"could not determine client address for socket %d\\n\",\n          R->sockfd);\n }\n\n /* Try to get the name of the client host. */\n\n strcpy(R->hostname,\"{UNKNOWN HOST NAME}\");\n\n if (is_debug) {\n   fprintf(stdout,\"gethostbyaddr...\\n\");\n   fflush(stdout);\n }\n\n hostentp = Gethostbyaddr(&clientaddress.sin_addr,\n                          sizeof(clientaddress.sin_addr),\n                          AF_INET);\n\n if (hostentp && hostentp->h_name) {\n   memcpy(&R->clienthostent, hostentp, sizeof(struct hostent));\n   strcpy(R->hostname,hostentp->h_name);\n   uppercase_in_place(R->hostname);\n }\n\n strcpy(R->hosttest,R->hostname);\n\n hostlen = strlen(R->hosttest);\n domslen = sizeof(MY_DOMAIN_SUFFIX) - 1;\n if (hostlen > domslen) {\n   hp = R->hosttest + hostlen - domslen;\n   if (!memcmp(hp, MY_DOMAIN_SUFFIX, domslen)) {\n     *hp = '\\0';\n   }\n }\n\n printf(\"%s Connection from %s (%s, aka %s).  Socket %d\\n\",\n        timestamp,\n        inet_ntoa(clientaddress.sin_addr), R->hostname, R->hosttest,\n        R->sockfd);\n\n /* This still doesn't do anything.\n  *\n  * if (hostentp && hostentp->h_name) {\n  *   memcpy(&R->clienthostent, hostentp, sizeof(struct hostent));\n  *   for (halias = R->clienthostent.h_aliases; *halias; halias++) {\n  *     printf(\"  Host alias:'%s'\\n\",*halias);\n  *   }\n  * }\n  */\n\n R->buffer[0] = '\\0';\n bufptr = R->buffer;\n\n/***********************/\n/*  NOTE:  sometimes, if timing is right, RECV can return a 0 length */\n/* record when a connection is closed by the client!!  below is a   */\n/* hack to check for a 0 length record, and then terminate this     */\n/* connection if we got one.                                        */\n/***********************/\n\n#define RECV_SIZE       (sizeof(R->buffer)-1)\n\n for (;;) {\n\n   if (is_debug) {\n     fprintf(stdout,\"recv (sock=%d,size=%d)...\\n\",R->sockfd,RECV_SIZE);\n     fflush(stdout);\n   }\n\n   if ((len=recv(R->sockfd,outbuf,RECV_SIZE,0)) <= 0) {\n     REPORT_TCP_ERROR(\"RECV - \");\n     printf(\"%s tcp error! len=%d\\n\",R->hostname, len);\n     break;\n   }\n\n   *(outbuf+(len))=0;    /*make sure it's null terminated...*/\n   /* printf(\"len=%d;\",len); */\n   ASCII_TO_EBCDIC(outbuf,len);\n   if (strlen(R->buffer) + strlen(outbuf) >= sizeof(R->buffer)) {\n     printf(\"\\nError: More than %d bytes seen without CRLF\\n\",\n            sizeof(R->buffer)-1);\n     len = 0;\n     break;\n   }\n   strcat(R->buffer,outbuf);\n   bufptr=R->buffer+(strlen(R->buffer)-2);\n   if (*bufptr == CARRIAGE_RETURN && *(bufptr+1) == LINE_FEED) break;\n }\n\n /* Note: no \\n required, data line already has CRLF in it */\n fprintf(stderr,\"%s %s Client data:%s\",\n                timestamp, R->hostname, R->buffer);\n\n if (len < 0) return;\n else if (len == 0) {\n   (void)GGMouts(R,\n  \"1Sorry, the GOPHER server couldn't hear you.  Try again.\\t0\\t0\\t0\");\n }\n else (void)GGMproc(R);\n\n (void)GGMouts(R,NULL);          /* send terminating dot */\n\n fflush(stdout);\n fflush(stderr);\n\n#ifdef DEBUGMTF\n lookatsocket(R->sockfd);\n#endif\n\n if (is_debug) {\n   fprintf(stdout,\"close (%d)...\\n\",R->sockfd);\n   fflush(stdout);\n }\n\n if(close(R->sockfd)<0) REPORT_TCP_ERROR(\"CLOSE - \");\n\n}\n./ ENDUP\n?!\n//CLIST    EXEC GGLOAD,TRK1='4',TO='CLIST'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=GOPHER,SSI=010F0028\n/* REXX. GOPHER client.  */\n\n/* *** Customize the following lines for your installation.\n * If ggmpanel is set to \"\", it will not be LIBDEF'd.\n */\n\nggmprefix      = \"GOPHER\"\nggmpanelsuffix = \"PANELS\"\nggmloadsuffix  = \"LOAD\"\nggmlmod        = \"GGCLIENT\"\nggmpanel       = ggmprefix\".\"ggmpanelsuffix\nggmload        = ggmprefix\".\"ggmloadsuffix\nggmappl        = \"\"                     /* ISPF applid (e.g. ISR)  */\nggmdefaulthost = \"gopher.micro.umn.edu\" /* to initialize GOPHERRC  */\ngophermeister  = \"\"              /* TSOid of Gopher's Big Brother  */\nxprocavailable = 0               /* set to 1 if XPROC is available */\n\ntrace off\nsignal on novalue\nstacked   = 0\nlibdeffed = 0\nparse arg args\n\"ISPQRY\"\nif rc > 0 then do\n parse source . . execname . execds .\n if execds = \"?\" then\n  icmd = \"%\"execname args\n else\n  icmd = \"EX '\"execds\"(\"execname\")'\" quote(args)\n call startispf ggmappl, icmd\n exit\nend\n\nif xprocavailable then do\n\n save_prompt = prompt(\"ON\")\n \"XPROC 0 TEST DEBUG FORCE LOCAL SERVER() PORT() PATH() DESCRIPTION()\"\n if rc <> 0 then exit rc\n call prompt save_prompt\n\nend\n\nelse do /* XPROC not available */\n\n server = \"\"\n port = 70\n path  =\n description =\n local =\n force =\n test  =\n debug =\n uargs = translate(args)\n if wordpos(\"LOCAL\",uargs) > 0 then local = \"LOCAL\"\n if wordpos(\"FORCE\",uargs) > 0 then force = \"FORCE\"\n if wordpos(\"TEST\" ,uargs) > 0 then test  = \"TEST\"\n if wordpos(\"DEBUG\",uargs) > 0 then debug = \"DEBUG\"\n\nend\n\nsignal on failure\nsignal on halt\n\ncall check_for_other_socket_app\ncall read_gopherrc\ncall validate_operands\ncall libdef\ncall let_me_know\ncall ggm_dialog\ncall unlibdef\n\ncleanup:\nif libdeffed then call unlibdef\nif stacked then \"DELSTACK\"\nexit\nerror:failure:halt:say \"GOPHER: Severe lossage.\"\nsay \"Statement:\" sourceline(sigl)\nexit\n\n/*********************************************************************/\n\nvalidate_operands:\n\n/*\n * Logic that determines what to display on startup:\n * If gopherrc file does not exist, create it from default\n * (default has everything commented out except for a\n *  one-item \"initial\" menu pointing to the MVS server)\n * Read gopherrc (in case operands need fields therein)\n * Command operands override gopherrc specs:\n * if LOCAL given then server = \"-\", see below for SERVER(-)\n * if SERVER(host) given then startup host=SERVER, path=PATH, etc.\n *  (no gopherrc referenced)\n * if SERVER(-) given then either PATH must be given or\n *  the gopherrc's localmenu: must be given,\n *  otherwise look at gopherrc\n *   if LOCAL given and initial: present then extract startup menu\n *    but remember that there will be no server access possible\n *   else nothing given, this is an error, barf\n * if no SERVER, look at gopherrc:\n *   if initial: given then extract startup menu from there\n *   else if localmenu: given then use that menu (SERVER=-)\n *   else nothing given, display ISPF panel asking for host/path\n */\n\nif local = \"LOCAL\" then do\n if server <> \"\" then do\n  say \"GOPHER: SERVER cannot be specified when LOCAL is specified.\"\n  exit 12\n end\n server = \"-\"\nend\n\nggpath = \"\"\ngghost = \"\"\nggport = port\nggdesc = description\n\nif server <> \"\" then do\n if server = \"-\" then do\n  gghost = server\n  if path <> \"\" then do\n   ggpath = path\n  end\n  else if localmenu <> \"\" then do\n   ggpath = localmenu\n   if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n  end\n  else if local = \"LOCAL\" & initial <> \"\" then do\n   gghost = \"\"\n   call use_initial_spec\n   if gghost <> \"-\" then do\n    say \"Gopher: Cannot determine path for local access.\"\n    say \"        Either specify PATH(pathname), activate\"\n    say \"        the localmenu: line in GOPHERRC, or set\"\n    say \"        the initial: line in GOPHERRC for local access.\"\n    exit 12\n   end\n  end\n  else do\n   say \"Gopher: Cannot determine path for local access.\"\n   say \"        Either specify PATH(pathname) or activate\"\n   say \"        the localmenu: or initial: line in GOPHERRC.\"\n   exit 12\n  end\n end\n else do\n  gghost = server\n  ggpath = path\n  ggdesc = description\n  ggport = port\n  nop  /* use provided server, host, path, etc. */\n end\nend\nelse do       /* no server given on command */\n if localmenu <> \"\" then do\n  gghost = \"-\"\n  ggpath = localmenu\n  if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n end\n else if initial <> \"\" then do\n  call use_initial_spec\n end\n else do\n  /* this is nominally illegal, but should cause gopher to\n     display the hackish startup menu */\n  gghost = \"\"\n  ggpath = \"\"\n end\nend\n\nreturn\n\n/*********************************************************************/\n\nuse_initial_spec:\n\n if initial = \"*temp*\" then do\n  /* we're eventually not going to do it this way really */\n  /* initial_type is ignored - only \"DIRECTORY\" is valid anyway */\n  if initial_name <> \"\" & ggdesc = \"\" then ggdesc = initial_name\n  if initial_host <> \"\" & gghost = \"\" then gghost = initial_host\n  if initial_path <> \"\" & ggpath = \"\" then ggpath = initial_path\n  if initial_port <> \"\" & ggport = \"\" then ggport = initial_port\n end\n else do\n  ggpath = initial\n  if ggdesc = \"\" then ggdesc = \"Local Private Gopher Menu\"\n end\n\nreturn\n\n/*********************************************************************/\n\nread_gopherrc:\n\nlocalmenu = \"\"\nlocalexec = \"\"\ninitial   = \"\"\ninitial_type = \"\"\ninitial_name = \"\"\ninitial_host = \"\"\ninitial_path = \"\"\ninitial_port = \"\"\nnew_gopherrc = 0\ngopherrc = \"'\"userid()\".GOPHERRC'\"\ngopherdcb = \"RECFM(V B) LRECL(255) BLKSIZE(6233) DSORG(PS)\"\ngopherrc_status = sysdsn(gopherrc)\nselect\n when gopherrc_status = \"OK\" then nop\n when gopherrc_status = \"DATASET NOT FOUND\" then do\n  address TSO \"ALLOC DA(\"gopherrc\") T SP(1 1)\" gopherdcb\n  if rc <> 0 then do\n   say \"Error: Cannot create\" gopherrc\n   exit rc\n  end\n  new_gopherrc = 1\n end\n otherwise do\n  say \"Error: Cannot access\" gopherrc\":\" gopherrc_status\n  exit 16\n end\nend\n\naddress TSO \"ALLOC FI(GOPHERRC) DA(\"gopherrc\") OLD REU\"\nif rc <> 0 then exit rc\n\nif new_gopherrc = 0 then do\n \"EXECIO * DISKR GOPHERRC (FINIS STEM GOPHERRC.)\"\n execiorc = rc\n if execiorc <> 0 then do\n  say \"Error: Cannot read\" gopherrc\n  address TSO \"FREE FI(GOPHERRC)\"\n  exit execiorc\n end\n if gopherrc.0 = 0 then new_gopherrc = 1\nend\n\nif new_gopherrc then call initialize_gopherrc\n\naddress TSO \"FREE FI(GOPHERRC)\"\n\ncollecting_initial = 0\ndo i = 1 to gopherrc.0\n gline = gopherrc.i\n if gline = \"\" then iterate\n if left(gline,1) = '#' then iterate\n parse var gline ghead \":\" gtext\n ghead = translate(strip(ghead,\"B\"))\n gtext = strip(gtext,\"B\")\n if collecting_initial then do\n  parse var gline ghead \"=\" gtext\n  ghead = translate(strip(ghead,\"B\"))\n  gtext = strip(gtext,\"B\")\n  select\n   when ghead = \"TYPE\" then initial_type = gtext\n   when ghead = \"NAME\" then initial_name = gtext\n   when ghead = \"PATH\" then initial_path = gtext\n   when ghead = \"HOST\" then initial_host = gtext\n   when ghead = \"PORT\" then initial_port = gtext\n   when ghead = \"END\"  then do\n    collecting_initial = 0\n    initial = \"*temp*\"\n   end\n   otherwise do\n    say \"Error in \"gopherrc\": INITIAL: not terminated by END\"\n    say \"Line where error was detected:\"\n    say gline\n    exit 8\n   end\n  end\n end\n else select\n  when ghead = \"LOCALMENU\" then localmenu = gtext\n  when ghead = \"LOCALEXEC\" then localexec = gtext\n  when ghead = \"INITIAL\"   then do\n   if gtext = \"\" then collecting_initial = 1\n   else initial = gtext\n  end\n  otherwise do\n   say \"Warning, gopherrc field ignored:\" ghead\n  end\n end\nend\n\nreturn\n\n/*********************************************************************/\n\nggm_dialog:\n\nvputvars = \"GGHOST GGPORT GGPATH GGDESC\"\n\nif vputvars <> \"\" then do\n address ISPEXEC \"VPUT (\"vputvars\") PROFILE\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\n\nparm = \"\"\nif test  = \"TEST\"  then parm = parm \"-t\"\nif debug = \"DEBUG\" then parm = parm \"-d\"\nif local = \"LOCAL\" then parm = parm \"-l\"\nif gghost <> \"\"    then parm = parm \"-q\"\n\nzerrmsg = \"\"\nzerrsm  = \"\"\nzerrlm  = \"\"\n\nif ggmappl = \"\" then applsource = \"\"\nelse applsource = \"NEWAPPL(\"ggmappl\") PASSLIB\"\n\nif ggmload = \"\" then selstring = \"PGM(\"ggmlmod\") PARM(\"parm\")\"\nelse selstring = \"CMD(CALL '\"ggmload\"(\"ggmlmod\")'\" quote(parm)\")\"\n\naddress ISPEXEC \"SELECT\" applsource selstring\n\nif rc <> 0 then say \"Return code from\" ggmlmod \"program is\" rc\n\naddress ISPEXEC \"VGET (ZERRSM ZERRLM)\"\nif zerrsm <> \"\" then do\n say zerrmsg\":\" zerrsm\n say zerrlm\nend\n\nreturn\n\n/*********************************************************************/\n\nlibdef:\nif ggmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET ID('\"ggmpanel\"')\"\n if rc <> 0 then do; call ispf_error rc; exit rc; end\nend\nif localexec <> \"\" then do\n address TSO \"ALLOC FI(GGEXEC) SHR REU DA('\"localexec\"')\"\n if rc <> 0 then exit rc\nend\nlibdeffed = 1\nreturn\n\n/*********************************************************************/\n\nunlibdef:\nif localexec <> \"\" then do\n address TSO \"FREE FI(GGEXEC)\"\nend\nif ggmpanel <> \"\" then do\n address ISPEXEC \"LIBDEF ISPPLIB DATASET\"\n if rc <> 0 then call ispf_error rc\nend\nlibdeffed = 0\nreturn\n\n/*********************************************************************/\n\ninitialize_gopherrc:\n\n say \"Initializing new GOPHERRC file...\"\n do i = sigl while sourceline(i) <> \"_BEGIN_\"\n end\n gx = 0\n do i = i+1 by 1\n  gline = sourceline(i)\n  if gline = \"_END_\" then leave\n  gpos = pos(\"ggmdefaulthost\",gline)\n  if gpos > 0 then do\n   gline = substr(gline,1,gpos-1) || ggmdefaulthost\n  end\n  gx = gx + 1\n  gopherrc.gx = gline\n end\n gopherrc.0 = gx\n \"EXECIO * DISKW GOPHERRC (FINIS STEM GOPHERRC.)\"\n say \"New GOPHERRC file initialized.\"\n\nreturn\n\n/*\n\n_BEGIN_\n#\n#\n# Default \"gopherrc\" file, created by the MVS Gopher client.\n#\n# Uncomment desired fields by removing the initial \"# \" from them.\n#\n# Beware - the Gopher client may update this file with bookmarks.\n#          You can delete it at any time and it will be recreated\n#          from the default settings, but you'll lose your bookmarks.\n#\n######################################################################\n#\n# If you want local (serverless) gopher access, then use the following\n# lines, specifying full qualified (no quotes) data set names:\n#\n# localmenu: name_of_initial_gopher_menu\n# localexec: name_of_pds_of_rexx_execs\n#\n# Specifying localmenu: is equivalent to specifying an initial: section\n# with host set to \"-\" and path set to the value of localmenu.\n#\n# You cannot use your own REXX execs, however, unless you specify\n# localexec: as above.  You don't need one to use the other, though.\n#\n######################################################################\n#\n# The following is used by the Gopher client at startup to determine\n# how the initial menu will appear.\n#\n# You may want to change the host to the one appropriate for your site.\n#\ninitial:\n#\nType=DIRECTORY\nName=Primary (Root) Gopher Menu\nPath=\nHost=ggmdefaulthost\nPort=70\nEnd\n#\n# Alternatively, if you want your own private Gopher data:\n#\n# initial:\n#\n# Type=0\n# Name=My Own Private Gopherhole\n# Path=userid.GOPHER.MENU\n# Host=-\n# End\n#\n# In which case you should create a data set called userid.GOPHER.MENU\n# (or whatever name you choose that appears in the \"Path=\" line above)\n# that looks like this.  (NOT in the gopherrc file!)\n#\n#\n# gopher_menu\n#\n# TYPE=DIRECTORY\n# NAME=Public GOPHER Server at ggmdefaulthost\n# PATH=\n# HOST=ggmdefaulthost\n# END\n#\n# TYPE=DIRECTORY\n# NAME=Private GOPHER\n# PATH=userid.ANOTHER.GOPHER.MENU\n# HOST=-\n# END\n#\n# and then you need yet another menu, similar in format to this one,\n# in userid.ANOTHER.GOPHER.MENU.  Get the idea?\n#\n######################################################################\n#\n# These fields may be used by the Gopher client for local purposes\n# in the future.  Currently they are ignored.\n#\n# Printercmd: lpr\n# Telnetcmd: telnet\n# Mailcmd: mail\n# Playcmd: play -v 40 -\n# TN3270cmd: tn3270\n# MIMEcmd: metamail -p\n#\n######################################################################\n_END_\n\n*/\n\n/*********************************************************************/\n\ncheck_for_other_socket_app:\n\n if local = \"LOCAL\" then return\n\n call nnmfiucv      /* FIND IUCVMULT in another PIE MultiTSO session */\n\n if result = 0 then return\n\n say,\n \"A TCP/IP socket application appears active in another PIE session.\"\n if force = \"FORCE\" then do\n  say \"Proceeding anyhow, because you said FORCE.\"\n  return\n end\n say \"To proceed at this point would be potentially disastrous.\"\n say \"If you want to use GOPHER anyway, use one of these operands:\"\n say \"  FORCE  -  if I'm mistaken and it's really safe to make a\"\n say \"            TCP/IP connection.\"\n say \"  LOCAL  -  if you just want local (serverless) access.\"\n say \"Terminating.\"\n\nexit 16\n\n/*********************************************************************/\n\nispf_error: parse arg ispfrc\n\nsay \"GOPHER: ISPF dialog service error detected on line\" sigl\nsay sourceline(sigl)\nsay\nsay zerrmsg\":\" zerrsm\nsay zerrlm\nsay\n\nreturn ispfrc\n\n/*********************************************************************/\n\n/*\n * The following function starts ISPF from READY mode.\n * Beware:  splitting the screen starts up an identical copy of the\n *          application, which may not be desirable.\n */\n\nstartispf: parse arg startappl, startcmd\nif startappl = \"\" then,\n \"ISPSTART CMD(\"startcmd\")\"\nelse,\n \"ISPSTART NEWAPPL(\"startappl\") CMD(\"startcmd\")\"\nreturn\n\n/* The following function implements Big Brother mode. */\n\nlet_me_know:\nif gophermeister = \"\" | gophermeister = userid() then return\nparse source . . execname . execds .\ncall outtrap \"X.\"\naddress TSO,\n \"SEND\" quote(execds\"(\"execname\")\" date(\"U\") time()\" \"),\n        \"U(\"gophermeister\") LOGON\"\ncall outtrap \"OFF\"\nreturn\n\n/* The following function enquotes a string. */\n\nquote: parse arg string\nix = 1\ndo forever\n ix = pos(\"'\",string,ix)\n if ix = 0 then return \"'\"string\"'\"\n string = insert(\"'\",string,ix)\n ix=ix+2\nend\n\n./   ADD NAME=NNMFIUCV,SSI=01000017\n/* REXX.  This exec scans the job pack queues for IUCVMULT and returns\n * with an error code if IUCVMULT is already loaded under a\n * different TCB. This can only happen under PIE MultiTSO or a\n * similar product that makes multiple job step TCB's.\n */\n\ntrace off\nsignal on novalue\n\nsearch_name = \"IUCVMULT\"\ncount = 0\nfoundtcb. = \"\"\ncurrent_tcb  = getword24(\"21C\")\ncurrent_job_step_tcb = getword24(current_tcb,\"7C\")\ncurrent_ascb = getword24(\"224\")\ncurrent_asxb = getword31(current_ascb,\"6C\")\nfirst_tcb    = getword24(current_asxb,\"4\")\ntcb = first_tcb\nmotherflag = 0\ndo forever\n if motherflag = 0 then do\n  call process\n  daughter_tcb = getword24(tcb,\"88\")\n  if daughter_tcb \\= \"00000000\" then do\n   tcb = daughter_tcb\n   iterate\n  end\n end\n motherflag = 0\n sister_tcb = getword24(tcb, \"80\")\n if sister_tcb \\= \"00000000\" then do\n  tcb = sister_tcb\n  iterate\n end\n mother_tcb = getword24(tcb, \"84\")\n if mother_tcb \\= \"00000000\" then do\n  tcb = mother_tcb\n  motherflag = 1\n  iterate\n end\n leave\nend\n\nif count = 0 then return 0\nproblem = 0\ndo i = 1 to count\n if foundtcb.i = current_job_step_tcb then do\n  /*\n  say search_name \"is already loaded under current TCB at \"foundtcb.i\".\"\n  */\n end\n else do\n  /*\n  say search_name \"is loaded under different TCB at \"foundtcb.i\".\"\n  */\n  problem = 1\n end\nend\n\nif problem = 1 then return 1\n\nelse return 0\n\nprocess:\n\n jpq = getword31(tcb,\"2C\")\n cde = jpq\n do while cde \\= \"00000000\"\n  cde_contents = storage(cde,32)\n  cde_name = substr(cde_contents,9,8)\n  cde_epa  = substr(cde_contents,9,8)\n  if search_name = cde_name then do\n   count = count + 1\n   foundtcb.count = tcb\n  end\n  cde = getword31(cde,\"0\")\n end\n\nreturn\n\ngetword31: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn c2x(storage(d2x(temp1+temp2),4))\n\ngetword24: parse arg addr, offset\ntemp1 = x2d(addr)\nif offset = \"\" then temp2 = 0\nelse temp2 = x2d(offset)\nreturn \"00\"c2x(storage(d2x(temp1+temp2+1),3))\n\n./ ENDUP\n?!\n//H        EXEC GGLOAD,TRK1='4',TO='H'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=GG,SSI=013F0021\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* --------------------- \"gg.h\" include member --------------------- */\n\n#pragma linkage(GGMbrifr,FORTRAN)\n#pragma linkage(GGMbrifc,FORTRAN)\n#pragma linkage(ispexec,OS)\n#pragma linkage(isplink,OS)\n#pragma linkage(ikjeff18,OS)\n\n/****** Installation-customized defines. *****************************/\n\n#include \"gguser.h\"\n\n#ifndef  C370V1\n#ifndef  C370V2\n#ifndef  SASC\n install_error_neither_C370V1_C370V2_nor_SASC_was_defined;\n#endif\n#endif\n#endif\n\n#ifndef  TCPIPV1\n#ifndef  TCPIPV2\n#ifndef  SNSTCPIP\n install_error_neither_TCPIPV1_TCPIPV2_nor_SNSTCPIP_was_defined;\n#endif\n#endif\n#endif\n\n#define  MVS\n\n/****** Clean up compiler warnings BEFORE time.h gets 'em ************/\n\n#ifndef  SASC\n#define  localtime            LOCALTIM\n#endif\n\n/****** Include all header files that are necessary. *****************/\n\n#ifndef SNSTCPIP\n#include <manifest.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <sys/ioctl.h>\n#include <tcperrno.h>\n#include <fcntl.h>\n#endif\n\n#include <sys/socket.h>\n#include <netdb.h>\n#include <sys/uio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <time.h>\n\n#ifdef SNSTCPIP\n#include <acs.h>\n#include <inet.h>\n#include <sockcfg.h>\n#include <serrno.h>\n#endif\n\n#ifndef  SASC\n#include <ctest.h>\n#endif\n\n#ifdef   SASC\n#include \"ggsasc.h\"\n#endif\n\n#undef ENOMEM\n\n#include <mtf.h>\n\n/****** Version-dependent stuff **************************************/\n\n#ifdef   C370V1\n#undef   FETCH\n#endif\n\n#ifdef   C370V2\n#define  FETCH\n#endif\n\n#ifdef   TCPIPV1\n#define  TCP_DEBUG            tcp_debug\n#endif\n\n#ifdef   TCPIPV2\n#define  TCP_DEBUG            sock_debug\n#endif\n\n#ifdef   SNSTCPIP\n#define  TCP_DEBUG            /* I don't know how to debug in SNS */\n#undef   DEBUG\n#endif\n\n#ifdef   DEBUG\n#define  TCP_DEBUG_ON         TCP_DEBUG(1)\n#define  TCP_DEBUG_OFF        TCP_DEBUG(0)\n#else\n#define  TCP_DEBUG_ON         /* */\n#define  TCP_DEBUG_OFF        /* */\n#endif\n\n/****** Preprocessor bookkeeping *************************************/\n\n#define  Bool                 char\n#define  Fool                 unsigned int /* for function arguments */\n#ifndef  TRUE\n#define  TRUE                 1\n#endif\n#ifndef  FALSE\n#define  FALSE                0\n#endif\n\n#define  COMMANDSIZE          12\n\n#define  GOPHER_FILE          '0'\n#define  GOPHER_DIRECTORY     '1'\n#define  GOPHER_CSO           '2'\n#define  GOPHER_ERROR         '3'\n#define  GOPHER_MAC_BINHEX    '4'\n#define  GOPHER_DOS_BINARCH   '5'\n#define  GOPHER_UUENCODE      '6'\n#define  GOPHER_WAIS          '7'\n#define  GOPHER_TELNET        '8'\n#define  GOPHER_TN3270        'T'\n#define  GOPHER_BINARY        '9'\n#define  GOPHER_REDUNDANT     '+'\n#define  GOPHER_WHOIS         'w'\n\n#define  READ_BYTES           1024\n#define  SERVER_BUF_MSGSIZE   1024\n#define  CLIENT_BUF_MSGSIZE   1024\n#define  TEXT_BYTES           1024\n#define  INTERNET_SIZE        256\n#define  RBUFSIZE             256\n#define  OUTBUFSIZE           1024\n\n#define  GOPHER_PORT_NUMBER   70\n#define  GOPHER_HOST_LENGTH   MAXHOSTNAMELEN\n#define  GOPHER_PATH_LENGTH   512\n#define  GOPHER_DESC_LENGTH   256\n\n#define  SOCKET_GETCHAR_ERROR (-1)\n#define  SOCKET_NO_MORE       (-2)\n#define  SOCKET_READ_NOTHING  (-3)\n\n#define  NO_VALUE             (-1)\n\n#define  Rstruc               register struct\n\n#define  EQUAL                !strcmp\n#define  UNEQUAL              strcmp\n\n#define  CARRIAGE_RETURN      ('\\r')\n\n#ifdef   MVS\n#ifdef   I370\n#define  LINE_FEED            (0x15)\n#else\n#define  LINE_FEED            (0x25)\n#endif\n#else\n#define  LINE_FEED            (0x0a)\n#endif\n\n#ifdef   MVS\n#ifdef   SNSTCPIP\n#define  EtoA                 etoa\n#define  AtoE                 atoe\n#else\n#ifdef   I370\n#define  EtoA                 htoncs\n#define  AtoE                 ntohcs\n#else\n#define  EtoA(x)              ebcdictoascii[x]\n#define  AtoE(x)              asciitoebcdic[x]\n#define  ebcdictoascii        ebcdicto\n#define  asciitoebcdic        asciitoe\n#endif\n#endif\n#endif\n\n#ifdef SNSTCPIP\n#define EBCDIC_TO_ASCII(A,B) EtoA(A,B)\n#define ASCII_TO_EBCDIC(A,B) AtoE(A,B)\n#else\n#define EBCDIC_TO_ASCII(A,B) {int _i; \\\n                              for (_i=0; _i<(B); ++_i) \\\n                                  (A)[_i] = EtoA((A)[_i]); \\\n                             }\n#define ASCII_TO_EBCDIC(A,B) {int _i; \\\n                              for (_i=0; _i<(B); ++_i) \\\n                                  (A)[_i] = AtoE((A)[_i]); \\\n                             }\n#endif\n\n#ifdef TCPIPV1\n#define REPORT_TCP_ERROR(A)  /* */\n#endif\n\n#ifdef TCPIPV2\n#define REPORT_TCP_ERROR(A)  tcperror(A)\n#endif\n\n#ifdef SNSTCPIP\n#define REPORT_TCP_ERROR(A)  fprintf(stderr,\\\n                                    \"\\nTCP error on %s: errno = %d\\n\",\\\n                                    A,GET_ERRNO)\n#endif\n\n#ifdef SNSTCPIP\n#define Accept(A,B,C)        accept((A),(struct sockaddr *)(B),(C))\n#define Bind(A,B,C)          bind((A),(struct sockaddr *)(B),(C))\n#define Connect(A,B,C)       connect((A),(struct sockaddr *)(B),(C))\n#define Gethostbyaddr(A,B,C) gethostbyaddr((char *)(A),(B),(C))\n#define Getpeername(A,B,C)   getpeername((A),(struct sockaddr *)(B),(C))\n#define Getsockopt(A,B,C,D,E) getsockopt((A),(B),(C),(char *)(D),(E))\n#define EWOULDBLOCK          (ESWOULDBLOCK+s0skcfg.errnobase)\n#else\n#define Accept               accept\n#define Bind                 bind\n#define Connect              connect\n#define Gethostbyaddr        gethostbyaddr\n#define Getpeername          getpeername\n#define Getsockopt           getsockopt\n#endif\n\n#ifdef   FETCH\n#define  ISPLINK              (gp->isplink_pointer)\n#define  ISPEXEC              (gp->ispexec_pointer)\n#else\n#define  ISPLINK              isplink\n#define  ISPEXEC              ispexec\n#endif\n\n#define  DATAOUT_LOW          0x01\n#define  DATAOUT_HIGH         0x02\n#define  DATAIN_LOW           0x03\n#define  DATAIN_HIGH          0x04\n#define  DATAOUT_BLUE         DATAOUT_LOW\n#define  DATAOUT_GREEN        0x05\n#define  DATAOUT_PINK         0x06\n#define  DATAOUT_RED          0x07\n#define  DATAOUT_TURQ         0x08\n#define  DATAOUT_WHITE        DATAOUT_HIGH\n#define  DATAOUT_YELLOW       0x09\n#define  DATAIN_BLUE          0x0a\n#define  DATAIN_GREEN         DATAIN_LOW\n#define  DATAIN_PINK          0x0b\n#define  DATAIN_RED           DATAIN_HIGH\n#define  DATAIN_TURQ          0x0c\n#define  DATAIN_WHITE         0x0d\n#define  DATAIN_YELLOW        0x0e\n\n#define  S99VRBAL  0x01             /* ALLOCATION                    */\n#define  S99VRBUN  0x02             /* UNALLOCATION                  */\n#define  S99VRBCC  0x03             /* CONCATENATION                 */\n#define  S99VRBDC  0x04             /* DECONCATENATION               */\n#define  S99VRBRI  0x05             /* REMOVE IN-USE                 */\n#define  S99VRBDN  0x06             /* DDNAME ALLOCATION             */\n#define  S99VRBIN  0x07             /* INFORMATION RETRIEVAL         */\n#define  S99NOCNV  0x40             /* ALLOC FUNCTION-DO NOT USE AN  */\n                                    /* EXISTING ALLOCATION TO SATISFY*/\n                                    /* THE REQUEST                   */\n#define  DALDDNAM   0x0001          /* DDNAME                        */\n#define  DALDSNAM   0x0002          /* DSNAME                        */\n#define  DALMEMBR   0x0003          /* MEMBER NAME                   */\n#define  DALSTATS   0x0004          /* DATA SET STATUS               */\n#define  DALNDISP   0x0005          /* DATA SET DISPOSITION          */\n#define  DALBLKLN   0x0009          /* BLOCK LENGTH                  */\n#define  DALPRIME   0x000a          /* PRIMARY SPACE ALLOCATION      */\n#define  DALSECND   0x000b          /* SECONDARY SPACE ALLOCATION    */\n#define  DALDIR     0x000c          /* DIRECTORY BLOCK ALLOCATION    */\n#define  DALBLKSZ   0x0030          /* DCB BLOCKSIZE                 */\n#define  DALDSORG   0x003c          /* DATA SET ORGANIZATION         */\n#define  DALLRECL   0x0042          /* DCB LOGICAL RECORD LENGTH     */\n#define  DALRECFM   0x0049          /* DCB RECORD FORMAT             */\n#define  DALPERMA   0x0052          /* PERMANENTLY ALLOCATED ATTRIB  */\n#define  DALRTDDN   0x0055          /* RETURN DDNAME                 */\n#define  DALRTDSN   0x0056          /* RETURN DSNAME                 */\n#define  DALRTORG   0x0057          /* RETURN D.S. ORGANIZATION      */\n#define  DUNDDNAM   0x0001          /* DDNAME                        */\n#define  DUNDSNAM   0x0002          /* DSNAME                        */\n#define  DUNUNALC   0x0007          /* UNALLOC OPTION                */\n\n#define  SHR        0x08\n#define  NEW        0x04\n#define  MOD        0x02\n#define  OLD        0x01\n#define  KEEP       0x08\n#define  DELETE     0x04\n#define  CATLG      0x02\n#define  UNCATLG    0x01\n#define  RECFM_F    0x80\n#define  RECFM_V    0x40\n#define  RECFM_U    0xc0\n#define  RECFM_D    0x20\n#define  RECFM_T    0x20\n#define  RECFM_B    0x10\n#define  RECFM_S    0x08\n#define  RECFM_A    0x04\n#define  RECFM_M    0x02\n#define  RECFM_FB   (RECFM_F | RECFM_B)\n#define  RECFM_VB   (RECFM_V | RECFM_B)\n#define  DSORG_PS   0x4000\n#define  DSORG_PO   0x0200\n\n\n/****** Data and structure definitions. ******************************/\n\ntypedef struct _textunit     TEXTUNIT;\ntypedef unsigned int         IPADDRESS;\ntypedef char                 gophertype;\n\nenum socket_retval  {\n                     SERVER_READ_OK,\n                     SERVER_READ_ERROR,\n                     SERVER_BUFFER_ERROR,\n                     SERVER_NO_MORE,\n                     SERVER_READ_NOTHING\n                    };\n\nenum data_set_type  {\n                     PDS,\n                     SEQ,\n                     UNK\n                    };\n\nenum user_option    {\n                     OPTION_ALL,\n                     OPTION_VIEW,\n                     OPTION_OTHER\n                    };\n\nstruct textline    {\n                    struct textline    *next;\n                    short               text_length;\n                    short               tab_expanded_text_length;\n                    char               *tab_expanded_text;\n                    char                text[1];  /* dummy */\n                   };\n\nstruct texthdr     {\n                    int                   text_line_count;\n                    struct textline      *text_body_line;\n                    short                 text_max_length;\n                    short                 text_max_tab_expanded_length;\n                    struct textline      *first_text_line;\n                    struct textline      *current_text_line;\n                    struct textline      *last_text_line;\n                   };\n\nstruct cmddesc   {\n                  char    command_name[COMMANDSIZE];\n                  Bool    (*command_processor)();\n                 };\n\nstruct seldesc   {\n                  char    selection_code;\n                  Bool    (*selection_processor)();\n                 };\n\nstruct tabledesc {\n                  char   *command_variable;\n        struct cmddesc   *first_cmddesc;\n        struct seldesc   *first_seldesc;\n                 };\n\nstruct _textunit {\n                  unsigned short         key;\n                  unsigned short         num;\n                  struct {\n                          unsigned short len;\n                          char           prm[80];\n                         }               ent;\n                 };\n\nstruct extraction {\n                   int                   from_number;\n                   int                   to_number;\n                   int                   count;\n                   enum data_set_type    mode;\n                   Bool                  appending;\n                   Bool                  blanking;\n                   Bool                  tab_expanding;\n                   char                  panelname     [9];\n                   char                  dsname       [65];\n                   char                  separator    [81];\n                   char                  member_prefix [9];\n                   char                  ddname        [9];\n                  };\n\nstruct gopherinfo {\n                   gophertype            type;\n                   int                   port;\n                   struct texthdr        thdr;\n                   char                  path [GOPHER_PATH_LENGTH+1];\n                   char                  host [GOPHER_HOST_LENGTH+1];\n                   char                  desc [GOPHER_DESC_LENGTH+1];\n                  };\n\nstruct recvstruct {\n    int             sockfd;   /* socket descriptor for socket call */\n    int             outlen;\n    FILE           *outfp;    /* used by local (non-socket) interface*/\n    char           *fileptr;\n    char           *wargptr;\n    FILE           *readfile;                 /* declare the file... */\n    struct hostent  clienthostent;\n    char            myname  [MAXHOSTNAMELEN+1];\n    char            hostname[MAXHOSTNAMELEN+1];  /* client host name */\n    char            hosttest[MAXHOSTNAMELEN+1];  /* client host name */\n    char            buffer  [RBUFSIZE]; /* client's character string */\n    char            dsname  [RBUFSIZE];\n    char            sockbuf [OUTBUFSIZE];    /* socket output buffer */\n   };\n\nstruct menuitem {\n    char          type;                  /* type of record to send   */\n    char          desc     [GOPHER_DESC_LENGTH+1];\n    char          select   [GOPHER_PATH_LENGTH+1];\n    char          hostname [GOPHER_HOST_LENGTH+1];\n    int           port;                  /* host port to connect to  */\n   };\n\nstruct ggcb {\n             char    *server_buf;\n             char    *client_buf;\n             char    *gopher_command;\n  struct recvstruct  *recvp;\n             char    *extract_separator_line;\n#ifdef FETCH\n              int   (*isplink_pointer)();\n              int   (*ispexec_pointer)();\n#endif\n              int     ispfrc;\n              int     socknum;\n              int     g_bytes_returned;\n              int     g_buf_index;\n              int     brif_previous_recno;\n             FILE    *debug_file;\n             FILE    *extract_file;\n   struct texthdr    *brifp;\n   struct texthdr     thdr;\n   struct gopherinfo *ginfo;\n             Bool     test_mode;\n             Bool     debug_mode;\n             Bool     quit;\n             Bool     time_to_go_home;\n             Bool     server_has_something_pending;\n             Bool     server_finished_replying;\n             Bool     sending_text;\n             Bool     receiving_text;\n             Bool     local_mode;\n             Bool     dont_read;\n             Bool     connected_to_server;\n             Bool     connection_broken;\n             Bool     closing_connection;\n             Bool     reconnect_in_progress;\n             Bool     extract_tab_expanding;\n             Bool     extract_appending;\n             Bool     extract_blank_before_separator;\n             Bool     extract_write_error;\n             Bool     extract_close_error;\n             Bool     warn_overwrite;\n             Bool     warn_append;\n             Bool     setmsg;\n             Bool     autoscroll;\n        IPADDRESS     client_ip_address;\n        IPADDRESS     server_ip_address;\n             char     ggserver            [MAXHOSTNAMELEN+1];\n             char     ggclient            [MAXHOSTNAMELEN+1];\n             char     client_hostname     [MAXHOSTNAMELEN+1];\n             char     client_ip_addrstr   [16];\n             char     server_hostname     [MAXHOSTNAMELEN+1];\n             char     server_ip_addrstr   [16];\n             char     g_buf               [READ_BYTES];\n            };\n\n#ifdef MVS\n#ifndef I370\nextern char                 ebcdictoascii[];\nextern char                 asciitoebcdic[];\n#endif\n#endif\n\n#ifndef FETCH\nextern int                  isplink();\nextern int                  ispexec();\n#endif\n\n#define  NOTIFY_MSG   1\n#define  WARNING_MSG  2\n#define  CRITICAL_MSG 3\n\n#define  WARN1(X)           GGMpmsg(gp,NOTIFY_MSG,NULL,X)\n#define  WARN2(X,Y)         GGMpmsg(gp,NOTIFY_MSG,NULL,X,Y)\n#define  WARN3(X,Y,Z)       GGMpmsg(gp,NOTIFY_MSG,NULL,X,Y,Z)\n#define  WARN4(X,Y,Z,W)     GGMpmsg(gp,NOTIFY_MSG,NULL,X,Y,Z,W)\n#define  ERR1(X)            GGMpmsg(gp,WARNING_MSG,NULL,X)\n#define  ERR2(X,Y)          GGMpmsg(gp,WARNING_MSG,NULL,X,Y)\n#define  ERR3(X,Y,Z)        GGMpmsg(gp,WARNING_MSG,NULL,X,Y,Z)\n#define  ERR4(X,Y,Z,W)      GGMpmsg(gp,WARNING_MSG,NULL,X,Y,Z,W)\n#define  CRIT1(X)           GGMpmsg(gp,CRITICAL_MSG,NULL,X)\n#define  CRIT2(X,Y)         GGMpmsg(gp,CRITICAL_MSG,NULL,X,Y)\n#define  CRIT3(X,Y,Z)       GGMpmsg(gp,CRITICAL_MSG,NULL,X,Y,Z)\n\n#define  GETMAIN(Ptr,Typ,Siz,For) \\\n         GGMgetm(gp,(char **)&(Ptr),(sizeof(Typ))*(Siz),For)\n\n#define  FREEMAIN(Ptr,For)    if (Ptr) {GGMfreem(gp,(char *)Ptr,For);}\n\n#ifndef I370\n\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)  \\\n         fopen((F),\"w,recfm=vb,lrecl=259,blksize=6233\")\n\n#define  OPEN_TEXT_FILE_FOR_APPEND(F)  \\\n         fopen((F),\"a,recfm=vb,lrecl=259,blksize=6233\")\n\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         fopen((F),(B) ? \"a,recfm=vb,lrecl=259,blksize=6233\"  \\\n                       : \"w,recfm=vb,lrecl=259,blksize=6233\")\n\n#else\n\n#define  OPEN_TEXT_FILE_FOR_WRITE(F)  \\\n         afopen((F),\"w\",\"seq\",\"recfm=v,lrecl=255,blksize=6233\")\n\n#define  OPEN_TEXT_FILE_FOR_APPEND(F)  \\\n         afopen((F),\"a\",\"seq\",\"recfm=v,lrecl=255,blksize=6233\")\n\n#define  OPEN_TEXT_FILE_FOR_WRITE_OR_APPEND(F,B)  \\\n         afopen((F),(B)?\"a\":\"w\",\"seq\",\"recfm=v,lrecl=255,blksize=6233\")\n\n#endif\n\n#define ebdtoasc(C) {char *__cp;\\\n                     for(__cp = C;*__cp;__cp++) *__cp = EtoA(*__cp);}\n\n#define asctoebd(C) {char *__cp;\\\n                     for(__cp = C;*__cp;__cp++) *__cp = AtoE(*__cp);}\n\n#define uppercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = toupper(*__cp);}\n\n#define lowercase_in_place(C) {char *__cp;\\\n                     for(__cp=C;*__cp;__cp++) *__cp = tolower(*__cp);}\n\n\n/****** Procedure and function declarations. *************************/\n\nextern enum data_set_type  GGMalloc(char *, char *, enum data_set_type,\n                                                                  int);\nextern int                 GGMbrifr(char **, int *, int *, void *);\nextern int                 GGMbrifc(int *, void *);\nextern void                GGMbtext(struct ggcb *, struct texthdr *,\n                                                               FILE *);\nextern void                GGMclrtx(struct ggcb *,struct gopherinfo *);\nextern Bool                GGMconn (struct ggcb *);\nextern char               *GGMcopy (struct ggcb *, char *);\nextern Bool                GGMcso  (struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern void                GGMdfail(int,__S99parms *);\nextern Bool                GGMdir  (struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern void                GGMdisc (struct ggcb *);\nextern int                 GGMdispl(struct ggcb *, char *);\nextern void                GGMdump (struct ggcb *,char *, char *, int);\nextern void                GGMesrvr(struct ggcb *);\nextern void                GGMfreem(struct ggcb *,char *,char *);\nextern FILE               *GGMgetds(struct ggcb *,struct extraction *);\nextern void                GGMgetm (struct ggcb *,char **,int,char *);\nextern Bool                GGMgofor(struct ggcb *,struct gopherinfo *,\n                                                                Fool);\nextern Bool                GGMgsrvl(struct ggcb *, char **, Fool);\nextern void                GGMierr (struct ggcb *);\nextern int                 GGMiget (struct ggcb *, char *);\nextern void                GGMimsg (struct ggcb *, char *);\nextern Bool                GGMispf (struct ggcb *, char *);\nextern Bool                GGMivget(struct ggcb *, char *, char *,int);\nextern Bool                GGMivput(struct ggcb *, char *, char *,int);\nextern void                GGMmtfer(int, char*);\nextern struct textline    *GGMouttx(struct ggcb *, char *,\n                                                  struct gopherinfo *);\nextern Bool                GGMouts (struct recvstruct *, char *);\nextern Bool                GGMproc (struct recvstruct *);\nextern void                GGMrbfm (struct ggcb *);\nextern void                GGMrperr(struct ggcb *);\nextern Bool                GGMsockt(struct ggcb *);\nextern void                GGMsopt (struct ggcb *,enum user_option);\nextern char               *GGMstrlc(char *, char *);\nextern Bool                GGMtnet (struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern int                 GGMtso  (char *);\nextern char               *GGMtype (gophertype);\nextern Bool                GGMunalc(char *);\nextern Bool                GGMvtx  (struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern Bool                GGMwais (struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern Bool                GGMwhois(struct ggcb *,struct gopherinfo *,\n                                                                 Fool);\nextern Bool                GGMxlist(struct ggcb *,char *);\nextern Bool                GGMxtx  (struct ggcb *,struct gopherinfo *);\n\n#ifndef SUPPRESS_V_DECLARATION\nextern void                GGMpmsg (struct ggcb *,int,char *,char *,\n                                                                  ...);\n#endif\n\n./   ADD NAME=GGSASC,SSI=01000043\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* SAS modifications due to Dale Ingold at SAS Institute, Inc.      */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"ggsasc.h\" include member ------------------- */\n\n#ifdef SASC\n\n#define I370\n\n#include <dynam.h>\n\n#define FETCH\n\n __inline void (*fetch( const char *modname ))()\n {\n   void (*fpp)();\n\n   loadm( modname, &fpp );\n   return( fpp );\n }\n\n __inline int (*release( void (*fpp)() ))\n {\n   unloadm( fpp );\n   return( 0 );\n }\n\n\n#ifndef __SVC99\n\n  #define __SVC99  1\n\n  #include <code.h>\n\n  struct __S99struc\n    {\n      unsigned char   __S99RBLN;  /* length of request block..20      */\n      unsigned char   __S99VERB;  /* verb code                        */\n      unsigned short  __S99FLAG1; /* FLAGS1 field of SVC99 Req Block  */\n      unsigned short  __S99ERROR; /* error code field                 */\n      unsigned short  __S99INFO;  /* information reason code          */\n      void           *__S99TXTPP; /* address of text unit pointer list*/\n      int             __reserved; /* reserved..will always be 0       */\n      unsigned int    __S99FLAG2; /* FLAGS2 field..can only be filled */\n                                  /* in by APF authorized programs    */\n    };\n\n  typedef struct __S99struc __S99parms;\n\n  __inline int svc99(__S99parms* svc99parmlist)\n    { return( (_ldregs(R1, &svc99parmlist),\n               _code(0, 0x0a63),\n               _stregs(R15) ) );\n    }\n\n#endif\n\n#define FALSE 0\n#define TRUE  1\n\n#include <lcio.h>\n\n#define  MAXHOSTNAMELEN     64\n\n#define  __ctest(X)  fprintf(stderr,\\\n                     \"GGMVS: CTEST is not supported by this compiler.\")\n\n#endif\n\n./   ADD NAME=GGUSER,SSI=01180036\n\n /********************************************************************/\n /*                                                                  */\n /* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992    */\n /*                                                                  */\n /* GOPHER server due to Shawn Hart at the University of Delaware.   */\n /*                                                                  */\n /* This software is provided on an \"AS IS\" basis.  All warranties,  */\n /* including the implied warranties of merchantability and fitness, */\n /* are expressly denied.                                            */\n /*                                                                  */\n /* Provided this copyright notice is included, this software may    */\n /* be freely distributed and not offered for sale.                  */\n /*                                                                  */\n /* Changes or modifications may be made and used only by the maker  */\n /* of same, and not further distributed.  Such modifications should */\n /* be mailed to the author for consideration for addition to the    */\n /* software and incorporation in subsequent releases.               */\n /*                                                                  */\n /********************************************************************/\n\n/* ------------------- \"gguser.h\" include member ------------------- */\n\n/* Include file for locally customized values. */\n\n/* Define levels of C/370 and TCP/IP.  This controls support for\n * fetching of non-C load modules and socket error reporting.\n */\n\n/* #define  C370V1    /* define this if C/370 Version 1 */\n   #define  C370V2    /* define this if C/370 Version 2 or higher */\n/* #define  SASC      /* define this if SAS/C compiler */\n\n/* #define  TCPIPV1   /* define this if TCP/IP Version 1 */\n   #define  TCPIPV2   /* define this if TCP/IP Version 2 or higher */\n/* #define  SNSTCPIP  /* define this if SNS/TCPAccess    */\n\n/* Define the following defaults for your installation. */\n/* Use XTELNET if you like the CSOCK package from UCLA. */\n\n   #define  TELNET_COMMAND_NAME     \"TELNET\"\n/* #define  TELNET_COMMAND_NAME     \"XTELNET\" */\n\n/* Define this if the server host name set by the \"+\" frob\n * should have the domain name appended.  Note that this will\n * affect how the hostname needs to be specified for a\n * Path=(pdsmember) specification - it must match the local host\n * the way it is generated here.  Of course, host=+ will do it anyway.\n */\n\n   #define  APPEND_DOMAIN_NAME_TO_SELF\n/* #undef   APPEND_DOMAIN_NAME_TO_SELF */\n\n/*\n * Turn on for TCP-level debugging output (you probably don't want to\n * unless your TCP/IP stuff is really broken and I can't help you).\n */\n\n/* #define DEBUG       */\n   #undef  DEBUG\n\n/*\n * Turn on for MTF-level debugging output.\n */\n\n/* #define DEBUGMTF    */\n   #undef  DEBUGMTF\n\n/* Server and MTF stuff. */\n\n/* #define  MTF_TASKS           8 */\n#define  MTF_TASKS           1  /* lest REXX multitasking lossage */\n#define  TCP_QUEUE_LENGTH   20\n#define  SERV_TCP_PORT      70\n#define  CONNECT_TIME_OUT   60\n#define  DEFAULT_DIRECTORY  \"DD:GGGOPHER\"\n#define  ACCESS_TABLE       \"DD:GGACCESS\"\n#define  MY_DOMAIN_SUFFIX   \".DRAPER.COM\"\n\n/* note: could get MY_DOMAIN_SUFFIX from TCPIP startup - what call? */\n\n/* Client stuff. */\n\n#define  INITIAL_TYPE   GOPHER_DIRECTORY\n#define  INITIAL_PORT   GOPHER_PORT_NUMBER\n#define  INITIAL_PATH   \"\"\n#define  INITIAL_HOST   \"MVS.DRAPER.COM\"\n#define  INITIAL_DESC   \"Root\"\n\n/* Server and client stuff. */\n\n#define  IDENT_HOST_FROB    \"+\"\n#define  LOCAL_HOST_FROB    \"-\"\n\n/********************************************************************/\n/*  The following defines the module name for the MTF subtask.      */\n/********************************************************************/\n\n#define GOPHER_PARALLEL_TASK \"GGSTASK\"\n\n/********************************************************************/\n/*  following are \"gopher\" record types.   */\n/********************************************************************/\n\n#define  GFILE    '0'\n#define  MENU     '1'\n#define  ERROR    '2'\n#define  INDEX    '7'\n#define  TELNET   '8'\n#define  TN3270   'T'\n#define  WHOIS    'w'\n\n/********************************************************************/\n/* following are MVS file type identifiers.  They must appear at the\n   beginning of the file they're identifying.                        */\n/********************************************************************/\n\n#define  MENUIDENT    \"GOPHER_MENU\"\n#define  INDEXIDENT   \"GOPHER_INDEX\"\n\n/********************************************************************/\n/*  following are tokens for menu GOPHER identifiers.    */\n/********************************************************************/\n\n#define  TOKTYPE      \"TYPE\"\n#define  TYPETOK      0\n#define  TOKNAME      \"NAME\"\n#define  NAMETOK      1\n#define  TOKPATH      \"PATH\"\n#define  PATHTOK      2\n#define  TOKHOST      \"HOST\"\n#define  HOSTTOK      3\n#define  TOKPORT      \"PORT\"\n#define  PORTTOK      4\n#define  TOKEND       \"END\"\n#define  ENDTOK       5\n#define  TOKCOMMENT   \"*\"\n#define  COMMENTTOK   6\n\n#define  TOKDISPLAY   \"DISPLAY\"\n#define  DISPLAYTOK   7\n#define  TOKSELECT    \"SELECTOR\"\n#define  SELECTTOK    8\n\n/********************************************************************/\n/*  types of   \"types\" - operands of the TYPE keyword in directories.*/\n/********************************************************************/\n\n#define  TYPEFILE    \"FILE\"\n#define  TYPEMENU    \"DIRECTORY\"\n#define  TYPEINDEX   \"INDEX\"\n#define  TYPETELNET  \"TELNET\"\n#define  TYPETN3270  \"TN3270\"\n#define  TYPEWHOIS   \"WHOIS\"\n\n/********************************************************************/\n/*  used by the REXX Interface                                      */\n/********************************************************************/\n\n  /* Be sure to include all 8 bytes, including blanks, in below */\n\n#define  REXX_EXEC_LIBRARY_DDNAME   \"GGEXEC  \"\n#define  REXX_EXEC_SUBCOM           \"        \"\n\n./ ENDUP\n?!\n//PANELS   EXEC GGLOAD,TRK1='4',TO='PANELS'\n//SYSIN    DD DATA,DLM='?!'\n./   ADD NAME=GGM,SSI=01060053\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ^ TYPE(INPUT) INTENS(HIGH) COLOR(GREEN) CAPS(OFF)\n ! TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Client -`-`-\n%COMMAND ===>_ZCMD\n+\n%Gopher server host name+(or IP address) %===>_GGHOST\n+\n%Initial path%===>^GGPATH\n%Port number %===>_GGPORT\n+\n+Note:  You may specify a dash%-+as the Gopher server host name if\n        you want to use your own private Gopher data without making\n        a connection to a server.  If you do, you must specify the\n        name of your private Gopher menu in the initial path.\n        This name must be UNQUOTED AND FULLY QUALIFIED.\n        Alternatively, you may allocate your initial Gopher menu\n        to file GGGOPHER.\n\n        Any menu entries must also specify a dash in the host field;\n        otherwise they will require server access, as usual.\n\n        To use the REXX interface, you must allocate file GGEXEC to\n        your library of Gopherable REXX execs.\n\n+Press!END+key to leave this menu.\n)INIT\n &ZCMD = &Z\n IF (&GGPORT = &Z) &GGPORT = 70\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER (&GGHOST,NB)\n VER (&GGPORT,NUM)\n VPUT (GGHOST GGPATH GGPORT) PROFILE\n)END\n./   ADD NAME=GGMDIR,SSI=01020021\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ~ TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n ^ TYPE(INPUT) INTENS(HIGH)  CAPS(OFF) JUST(LEFT)\n ! TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(YELLOW)\n # TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(RIGHT) COLOR(BLUE)\n @ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(RIGHT) COLOR(PINK)\n ? TYPE(OUTPUT) INTENS(LOW)  CAPS(OFF) JUST(LEFT)  COLOR(TURQ) PAD('.')\n |  AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n \\  AREA(DYNAMIC) EXTEND(OFF) SCROLL(OFF)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 03 TYPE(DATAIN)  INTENS(LOW)\n 04 TYPE(DATAIN)  INTENS(HIGH)\n 05 TYPE(DATAOUT) COLOR(GREEN)\n 06 TYPE(DATAOUT) COLOR(PINK)\n 07 TYPE(DATAOUT) COLOR(RED)\n 08 TYPE(DATAOUT) COLOR(TURQ)\n 09 TYPE(DATAOUT) COLOR(YELLOW)\n 0A TYPE(DATAIN)  COLOR(BLUE)\n 0B TYPE(DATAIN)  COLOR(PINK)\n 0C TYPE(DATAIN)  COLOR(TURQ)\n 0D TYPE(DATAIN)  COLOR(WHITE)\n 0E TYPE(DATAIN)  COLOR(YELLOW)\n)BODY EXPAND(``)\n%&GGGHEAD\n%COMMAND ===>~GGGCMD                                          %SCROLL ===>^GAMT+\n+\n+%S+Select%Q+Query%E+Extract\n -------------------------------------------------------------------------------\n|GGGDYNA                                                                       |\n)INIT\n IF (&GAMT = &Z) &GAMT = CSR\n)PROC\n &GGGLVL = LVLINE(GGGDYNA)\n VPUT (GAMT) PROFILE\n)END\n./   ADD NAME=GGMLCONN,SSI=01000059\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ^ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+             Client name: &GGCLIENT    Client IP address:  &GGCLIEIP\n+\n+\n+             Connection is in progress for Gopher server at:\n              &GGSERVER (&GGSERVIP)\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./   ADD NAME=GGMLDISC,SSI=01000024\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ^ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+\n+         Disconnection is in progress from the Gopher server at:\n          &GGSOLDER (&GGSOLDIP)\n+\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./   ADD NAME=GGMLEXN2,SSI=01000018\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ^ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n+Description: &GGTSUBJ\n+\n+Extracting to: &GGEXDSN\n+&MEMSTUFF\n+\n                                 % Please wait.\n+\n)INIT\n IF (&GGEXMEM = &Z) &MEMSTUFF = &Z\n ELSE               &MEMSTUFF = 'Member: &GGEXMEM'\n)PROC\n)END\n./   ADD NAME=GGMLRCON,SSI=01000048\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n ^ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(PINK)\n # TYPE(TEXT) INTENS(LOW)  COLOR(TURQ)\n \\ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n ! TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n $ TYPE(TEXT) INTENS(LOW)  COLOR(GREEN)\n ~ TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY EXPAND(``)\n%-`-`-  MVS Gopher Server Connection -`-`-\n+\n        +Connection has apparently been lost to the Gopher server at:\n        &GGSERVER (&GGSERVIP)\n+\n                +Reconnection to the server is in progress.\n+\n                                 % Please wait.\n+\n+\n)INIT\n)PROC\n)END\n./   ADD NAME=GGMPCSO,SSI=01000011\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>^ZCMD\n+\n+Enter name to search for:\n+\n%===>^GGCSOQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'CSO Nameserver User Name Search'\n &END = PFK(END)\n .CURSOR = GGCSOQ\n)PROC\n IF  (&ZCMD ^= &Z) .MSG = ISPZ001\n VER (&GGCSOQ,NB)\n VPUT (GGCSOQ) PROFILE\n)END\n./   ADD NAME=GGMPEXDS,SSI=01000044\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,16)\n+\n%Command ===>^ZCMD\n+\n%&SUBJECT\n+\n+Save to data set ===>_GGEXDSN\n+Expand tab characters?       ===>_Z  +\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>^Z                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract text'\n &SUBJECT = '&GGTSUBJ'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./   ADD NAME=GGMPEXNG,SSI=01000027\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>^ZCMD\n+\n+Save to data set ===>_GGEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>^Z                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract item listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./   ADD NAME=GGMPEXNP,SSI=01000026\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,14)\n+\n%Command ===>^ZCMD\n+\n+Data set name%===>_GGEXPDS\n+Member prefix%===>_GGEXPMP + (item number appended - default is%#+)\n\n+Note: The dataset must be a PDS (old or new) with RECFM=VB and LRECL=259.\n\n+Expand tab characters?      %===>_Z  +\n\n+From item number%===>_GGEXAN1         + (blank for first item in table)\n+To   item number%===>_GGEXAN2         + (blank for last item in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of items to PDS members'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXPDS GGEXPMP GGEXTAB) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n IF (&GGEXPMP = &Z) &GGEXPMP = '#'\n &GGEXAN1 = &Z\n &GGEXAN2 = &Z\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n VER(&GGEXPDS,NB,DSNAME)\n &TEMP1 = TRUNC(&GGEXPDS,1)\n &TEMP2 = .TRAIL\n IF (&TEMP1 = '''')\n  &GGEXDSN = TRUNC(&TEMP2,'''')\n ELSE\n  &GGEXDSN = '&ZPREFIX..&GGEXPDS'\n  VER(&GGEXPMP,NB,NAME)\n VER(&GGEXAN1,NUM)\n VER(&GGEXAN2,NUM)\n VPUT (GGEXPDS GGEXPMP GGEXTAB) PROFILE\n)END\n./   ADD NAME=GGMPEXNS,SSI=01000057\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY EXPAND(``) WINDOW(77,17)\n+\n%Command ===>^ZCMD\n+\n+Data set name%===>_GGEXSEQ\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n+\n+Expand tab characters?      %===>_Z  +\n+\n+Append to end of data set?  %===>_Z  +\n+Blank line after separator? %===>_Z  +\n+Separator line before each item (leave blank for none):\n+>^Z                                                                       +<\n\n+From item number%===>_GGEXAN1         + (blank for first item in table)\n+To   item number%===>_GGEXAN2         + (blank for last item in table)\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXTAB GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = ZCMD\n &ZWINTTL = 'Log text of items to sequential file'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXSEQ GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXTAB = TRANS(&GGEXTAB Y,YES N,NO ' ',NO)\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n &GGEXAN1 = &Z\n &GGEXAN2 = &Z\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER(&GGEXSEQ,NB,DSNAME)\n &GGEXDSN = &GGEXSEQ\n &GGEXTAB = TRUNC(&GGEXTAB,1)\n VER(&GGEXTAB,NB,LIST,Y,N)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VER(&GGEXAN1,NUM)\n VER(&GGEXAN2,NUM)\n VPUT (GGEXSEQ GGEXTAB GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./   ADD NAME=GGMPEXNT,SSI=01000035\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,10)\n+\n%Command ===>^ZCMD\n+\n+Move cursor to choice (or type%S+next to choice) and press%ENTER+to select:\n+\n_A%1+- List%titles+of items in table\n_B%2+- Log %text  +of items to%sequential file+\n_C%3+- Log %text  +of items to%members of PDS+\n+\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .CURSOR = ZCMD\n &ZWINTTL = 'Extract Gopher items - titles or text'\n &END = PFK(END)\n &ZCMD = &Z\n &A = &Z\n &B = &Z\n &C = &Z\n)PROC\n VER(&ZCMD,LIST,1,2,3)\n IF (&ZCMD ^= &Z)\n  &GGCHOICE = TRANS(&ZCMD 1 1 2 2 3 3 * ?)\n ELSE\n  &TEMP = '&A/&B/&C'\n  IF (&TEMP = '//')\n   &GGCHOICE = TRANS(.CURSOR A 1 B 2 C 3 * ?)\n  ELSE\n   &GGCHOICE = TRANS(&TEMP  'S//' 1\n                            '1//' 1\n                            '/S/' 2\n                            '/2/' 2\n                            '//S' 3\n                            '//3' 3\n                               * ?\n                   )\n)END\n./   ADD NAME=GGMPEXN1,SSI=01000007\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(77,14)\n+\n%Command ===>^ZCMD\n+\n+Save to data set ===>_GGEXDSN\n\n+(Note: Data set will be RECFM=VB, LRECL=259, BLKSIZE=6233.)\n\n+Append to end of data set?   ===>_Z  +\n+Blank line after separator?  ===>_Z  +\n+Separator line between items (append mode only...blank for none):\n+>^Z                                                                       +<\n\n+Press%&END (END)+to cancel the extract request.\n)INIT\n .ZVARS = '(GGEXAPP GGEXBLK GGEXSEP)'\n .CURSOR = GGEXDSN\n &ZWINTTL = 'Extract Gopher item listing'\n &END = PFK(END)\n &ZCMD = &Z\n VGET (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n &GGEXAPP = TRANS(&GGEXAPP Y,YES N,NO ' ',NO)\n &GGEXBLK = TRANS(&GGEXBLK Y,YES N,NO ' ',NO)\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n VER(&GGEXDSN,NB,DSNAME)\n &GGEXAPP = TRUNC(&GGEXAPP,1)\n VER(&GGEXAPP,NB,LIST,Y,N)\n &GGEXBLK = TRUNC(&GGEXBLK,1)\n VER(&GGEXBLK,NB,LIST,Y,N)\n VPUT (GGEXDSN GGEXAPP GGEXBLK GGEXSEP) PROFILE\n)END\n./   ADD NAME=GGMPEXOW,SSI=01000030\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>^ZCMD\n+\n+Dataset already exists:\n+\n%&GGEXDSN\n+\n+Press%ENTER+to%&ACTION\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .ALARM = YES\n &ZWINTTL = 'Extract To Existing Data Set'\n &END = PFK(END)\n &APP = TRUNC(&GGEXAPP,1)\n IF (&APP = Y) &ACTION = 'append to the end of the data set.'\n ELSE          &ACTION = 'overwrite the current data set.'\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n)END\n./   ADD NAME=GGMPEXPW,SSI=01000053\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,13)\n+\n%Command ===>^ZCMD\n+\n+Paritioned dataset already exists:\n+\n%&GGEXDSN\n+\n+If member names are generated that match existing members\n+of this PDS, they will be%overwritten.+\n+\n+Press%ENTER+to proceed to use this PDS.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n .ALARM = YES\n &ZWINTTL = 'Extract To Members of Existing PDS'\n &END = PFK(END)\n)PROC\n IF (&ZCMD ^= &Z) .MSG = ISPZ001\n)END\n./   ADD NAME=GGMPWAIS,SSI=01020012\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>^ZCMD\n+\n+Enter index search query:\n+\n%===>^GGWAISQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'GOPHER Full Text Index Search'\n &END = PFK(END)\n .CURSOR = GGWAISQ\n)PROC\n IF  (&ZCMD ^= &Z) .MSG = ISPZ001\n VER (&GGWAISQ,NB)\n VPUT (GGWAISQ) PROFILE\n)END\n./   ADD NAME=GGMPWHOI,SSI=01000019\n)ATTR\n/*                                                                   /*\n/* Copyright (c) The Charles Stark Draper Laboratory, Inc., 1992     /*\n/*                                                                   /*\n/* This software is provided on an \"AS IS\" basis.  All warranties,   /*\n/* including the implied warranties of merchantability and fitness,  /*\n/* are expressly denied.                                             /*\n/*                                                                   /*\n/* Provided this copyright notice is included, this software may     /*\n/* be freely distributed and not offered for sale.                   /*\n/*                                                                   /*\n/* Changes or modifications may be made and used only by the maker   /*\n/* of same, and not further distributed.  Such modifications should  /*\n/* be mailed to the author for consideration for addition to the     /*\n/* software and incorporation in subsequent releases.                /*\n/*                                                                   /*\n       ^   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(58,10)\n+\n%Command ===>^ZCMD\n+\n+Enter name to search for:\n+\n%===>^GGWHOISQ\n\n+Press%ENTER+to submit search request.\n+Press%&END (END)+to cancel the request.\n+\n)INIT\n &ZWINTTL = 'WHOIS/FINGER User Name Search'\n &END = PFK(END)\n .CURSOR = GGWHOISQ\n)PROC\n IF  (&ZCMD ^= &Z) .MSG = ISPZ001\n VER (&GGWHOISQ,NB)\n VPUT (GGWHOISQ) PROFILE\n)END\n./ ENDUP\n?!\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPCS": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x06O\\x00\\x92\\x06O\\x12\\x00\\x00\\xed\\x00\\xed\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-04T00:00:00", "modifydate": "1992-03-04T12:00:00", "lines": 237, "newlines": 237, "modlines": 0, "user": "REXX"}, "text": "  /*--  Rexx  ---------------------------------------------------*/\n  /*                                                             */\n  /* The following is the REXX exec that appears in the          */\n  /* SHARE 78 session:                                           */\n  /*                                                             */\n  /*     MVSE:  IPCS/REXX Support                                */\n  /*     Session O387                                            */\n  /*                                                             */\n  /*     Jim Campbell                                            */\n  /*     IBM                                                     */\n  /*     Enterprise Systems                                      */\n  /*     Poughkeepsie, New York                                  */\n  /*                                                             */\n  /* (C) Copyright IBM Corporation 1992                          */\n  /*                                                             */\n  /* The following terms, used in the referenced presentation,   */\n  /* are trademarks of the IBM Corporation:                      */\n  /*                                                             */\n  /* 1.  MVS/ESA                                                 */\n  /* 2.  Enterprise Systems Architecture/390                     */\n  /* 3.  MVS/SP                                                  */\n  /*                                                             */\n  /* Note that this sample source is provided for tutorial       */\n  /* purposes only.  A complete handling of error conditions has */\n  /* not been shown or attempted, and this source has not been   */\n  /* submitted to formal IBM testing. This source is distributed */\n  /* on an 'as is' basis without any warranties either expressed */\n  /* or implied.                                                 */\n  /*                                                             */\n  /*-------------------------------------------------------------*/\n  address IPCS               /* Set IPCS as the permanent host\n                                command environment.             */\n  storage. = ''              /* Clear the stem variable at the\n                                beginning of the exec.           */\n  /*-------------------------------------------------------------*/\n  /*  Determine the address of the CVT                           */\n  /*-------------------------------------------------------------*/\n  cvtaddr  = obtain_data(    /* Invoke Obtain_Data, passing:     */ ,\n                 0,          /*   Address of the data in dump    */ ,\n                 x2d('10'),  /*   Offset to desired field        */ ,\n                 4)          /*   Amount of storage to retrieve  */\n  /*-------------------------------------------------------------*/\n  /*  Determine the address of ATAB in the CVTUSER field.        */\n  /*-------------------------------------------------------------*/\n  cvtuser  = obtain_data(    /* Invoke Obtain_Data, passing:     */ ,\n                 cvtaddr,    /*   Address of the data in dump    */ ,\n                 x2d('CC'),  /*   Offset to desired field        */ ,\n                 4)          /*   Amount of storage to retrieve  */\n  /*-------------------------------------------------------------*/\n  /*  Verify the ATAB identifier is as expected.                 */\n  /*-------------------------------------------------------------*/\n  ATAB_id  = x2c(            /* Convert Obtained data to char    */ ,\n               obtain_data(  /*   Data to obtain follows         */ ,\n                 cvtuser,    /*     Address of the dump data     */ ,\n                 0,          /*     Starting at offset zero      */ ,\n                 4))         /*     For four bytes               */\n  if ATAB_id /= 'ATAB' Then signal ATAB_Access_Error\n\n  /*-------------------------------------------------------------*/\n  /*  Determine the number of application elements.              */\n  /*  Ensure there is at least one.                              */\n  /*-------------------------------------------------------------*/\n  ATAB_cnt = x2d(            /* Convert to Decimal for arithmetic*/ ,\n               obtain_data(  /*   Data to retrieve from dump:    */ ,\n                 cvtuser,    /*      Cvtuser address the block   */ ,\n                 4,          /*      Offset four is count field  */ ,\n                 4))         /*      Obtain four bytes           */\n  if ATAB_cnt < 1 Then signal ATAB_Error\n  /*-------------------------------------------------------------*/\n  /*  Access and format elements in the table.                   */\n  /*-------------------------------------------------------------*/\n  Oline = 'Application table data entries:'\n  Call Put                   /* Display Output line              */\n\n  do i = 1 to ATAB_cnt       /*>For each application element     */\n    /*-----------------------------------------------------------*/\n    /*  Calculate offset into application table.                 */\n    /*-----------------------------------------------------------*/\n    this_offset = 8 +        /* 8 bytes past the header    plus  */ ,\n                  1 +        /* 1 byte  past the 1st len   plus  */ ,\n                 (16*        /* 16 bytes for each entry    times */ ,\n                   (i-1))    /* the current entry in the table   */\n    /*-----------------------------------------------------------*/\n    /*  Access and format element from the table.                */\n    /*-----------------------------------------------------------*/\n    ATAB_dat = x2c(          /* Convert Obtained data to char    */ ,\n               obtain_data(  /*   Data to obtain follows         */ ,\n                cvtuser,     /*     Starting address in dump     */ ,\n                this_offset, /*     Starting at offset zero      */ ,\n                15))         /*     For FIFTEEN bytes            */\n    Oline = ' ' || ATAB_dat  /* Data to display                  */\n    Call  Put                /* Display output line              */\n  end                        /*<For each application element     */\n\n  /*-------------------------------------------------------------*/\n  /*  Normal end of the exec...                                  */\n  /*-------------------------------------------------------------*/\n  EPILOG:  nop\n    retc = 0                 /* Set return code of zero          */\n    signal exit              /* Leave the exec                   */\n\n  /*-------------------------------------------------------------*/\n  /*  Abnormal end of the exec...                                */\n  /*-------------------------------------------------------------*/\n  ATAB_Access_Error:  nop\n    Oline = 'Error accessing the ATAB data.'\n    Call Put                 /* Display Output line              */\n    retc = 16                /* Set return code showing error    */\n    signal exit              /* Leave the exec                   */\n  ATAB_Error:  nop\n    Oline = 'No elements in the application table.'\n    Call Put                 /* Display Output line              */\n    retc = 16                /* Set return code showing error    */\n    signal exit              /* Leave the exec                   */\n  /*-------------------------------------------------------------*/\n  /*  Label for Obtain_Data subroutine...                        */\n  /*-------------------------------------------------------------*/\n  Access_Error:  nop\n    Oline = 'IPCS EVALUATE unable to access data.'\n    Call Put                 /* Display Output line              */\n    retc = 16                /* Set return code showing error    */\n    signal exit              /* Leave the exec                   */\n  /*-------------------------------------------------------------*/\n  /*  Label for Put subroutine...                                */\n  /*-------------------------------------------------------------*/\n  Put_Error:  nop\n    retc = 16                /* Set return code showing error    */\n    signal exit              /* Leave the exec                   */\n  /*-------------------------------------------------------------*/\n  /*  Exit the exec now.                                         */\n  /*-------------------------------------------------------------*/\n  Exit: exit retc\n  Put: procedure expose Oline\n  /*-------------------------------------------------------------*/\n  /* Function:  Put                                              */\n  /*                                                             */\n  /*            Invoke the IPCS NOTE subcommand to transmit      */\n  /*            data to the terminal, IPCS print file or both,   */\n  /*            depending on the IPCS message routing default.   */\n  /*                                                             */\n  /* Input:     Data to transmit.                                */\n  /*                                                             */\n  /* Output:    Data is transmitted.                             */\n  /*-------------------------------------------------------------*/\n\n  \"NOTE '\"Oline\"' ASIS\"\n  if rc > 0 then Signal Put_Error\n  return                     /* Return to caller from subrtn     */\n\n    Obtain_Data: procedure expose storage.\n    /*-----------------------------------------------------------*/\n    /* Function:  Obtain_Data                                    */\n    /*                                                           */\n    /*            Retrieve data from the dump.  Invoke the IPCS  */\n    /*            EVALUATE subcommand as necessary to access     */\n    /*            512-byte blocks of data from the IPCS dump     */\n    /*            source and store the data in variable          */\n    /*            \"storage.\"  Callers of Obtain_Data must        */\n    /*            request storage from the same address space.   */\n    /*                                                           */\n    /* Input:     Description of data to access:                 */\n    /*                                                           */\n    /*            Hex address of data.                           */\n    /*            Decimal position from the hex address of the   */\n    /*             first byte to access.                         */\n    /*            Decimal length of the data to access.          */\n    /*                                                           */\n    /* Output:    Requested data is returned.                    */\n    /*-----------------------------------------------------------*/\n\n    arg hex_address , dec_position , dec_length\n    trace off        /* Suppress display of unsuccessful storage\n                                 fetches once PF3 has been hit   */\n    Numeric digits(10)\n    ipcs_eval_limit = 512     /* The maximum number of bytes that\n                                 the IPCS EVALUATE subcommand can\n                                 access per invocation           */\n    page_size = 4096          /* The size of a storage page      */\n    first_index  = dec_position % ipcs_eval_limit /* Determine the\n                                 first 512 byte increment        */\n    last_index  = (dec_position+dec_length) % ipcs_eval_limit /*\n                                 Determine the last 512 byte\n                                 increment                       */\n    buffer = ''\n    do i= first_index to last_index /* For each 512 increment    */\n     if storage.hex_address.i = '' then do\n\n     /*----------------------------------------------------------*/\n     /* If the data has not yet been accessed, access it.        */\n     /*----------------------------------------------------------*/\n\n          hex_address_dot = ,\n            hex_address||.    /* Indicate for IPCS that it is an\n                                 address                         */\n         \"EVALUATE\"   hex_address_dot ,\n                 \"POSITION(\"i*ipcs_eval_limit\")\" ,\n                 \"LENGTH(\"ipcs_eval_limit\")\" ,\n                 \"REXX(STORAGE(X))\" /* Access the data by invoking\n                                 the IPCS EVALUATE subcommand    */\n         if rc > 0 then do\n\n         /*------------------------------------------------------*/\n         /* If 512 bytes of data could not be accessed, determine*/\n         /* if the data spans across a page.  If it does, attempt*/\n         /* to access the data that resides in the first page.   */\n         /*------------------------------------------------------*/\n\n           address = x2d(hex_address)+i*ipcs_eval_limit\n           new_length=page_size-(address//page_size)\n           if new_length=0 | new_length >= ipcs_eval_limit then\n             signal Access_Error\n           \"EVALUATE\"   hex_address_dot ,\n                   \"POSITION(\"i*ipcs_eval_limit\")\" ,\n                   \"LENGTH(\"new_length\")\" ,\n                   \"REXX(STORAGE(X))\" /* Access the data by invoking\n                                 the IPCS EVALUATE subcommand    */\n           if rc > 0 then signal Access_Error\n         end\n         storage.hex_address.i = x   /* Save the data in a\n                                 variable so that it only needs to\n                                 be accessed once                */\n     end\n     buffer = buffer||storage.hex_address.i /* Augment the buffer\n                                 with the current data           */\n    end                       /* For each 512 increment          */\n    return_offset = (dec_position-first_index*ipcs_eval_limit)*2+1\n    return_length = dec_length*2\n    if return_offset-1 + return_length > length(buffer) then\n\n    /*-----------------------------------------------------------*/\n    /* Do not attempt to return more than what is in the buffer. */\n    /*-----------------------------------------------------------*/\n\n       signal Access_Error\n    return  substr(buffer,return_offset,return_length) /* Return\n                                 the appropriate data from the\n                                 buffer                          */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGSCAN": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x12_\\x00\\x90\\x12_\\x12\\x00\\x00a\\x00a\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd4\\xd6\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-05T00:00:00", "modifydate": "1990-05-05T12:00:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "LOADMOD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PRINTDS": {"ttr": 6664, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00\\x80\\x00\\x80\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "CLIST"}, "text": "PROC 0 DEBUG\n\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/* -----------------------------------                               */\n/* TSO/E PRINTDS ISPF DIALOG FRONT-END                               */\n/* -----------------------------------                               */\n/*                                                                   */\n/* - UPDATED 10SEP90, WILLIAM SMITH, CHARLES SCHWAB TECH. SERVICES   */\n/*   . TESTED WITH ISPF AND ISPF/PDF 3.1 AND MVS/ESA TSO/E 2.1.1     */\n/*   . STREAMLINED PROCESSING BY ELIMINATING REDUNDANT/UNNECESSARY   */\n/*     PANEL AND CLIST PROCESSING LOGIC                              */\n/*                                                                   */\n/* - UPDATED 20NOV89, WILLIAM SMITH, CHARLES SCHWAB TECH. SERVICES   */\n/*   . ORIGINALLY WRITTEN AS AN ISPF DIALOG MANAGER FRONT-END FOR    */\n/*     USE WITH \"VTAM PRINTER SUPPORT\"; UPDATED AND MODIFIED TO      */\n/*     FRONT-END THE TSO/E 'PRINTDS' COMMAND PROCESSOR               */\n/*   . TESTED WITH ISPF AND ISPF/PDF 3.1 AND MVS/XA TSO/E 2.1.0      */\n/*                                                                   */\n/* ------------------------------------                              */\n/* RETURN CODES FOR THE PRINTDS COMMAND                              */\n/* ------------------------------------                              */\n/*                                                                   */\n/*   0  PROCESSING SUCCESSFUL                                        */\n/*   4  PROCESSING COMPLETED, BUT A WARNING MESSAGE HAS BEEN         */\n/*      ISSUED.                                                      */\n/*   8  THE INPUT, OUTPUT, OR SYSOUT DATA SET COULD NOT BE USED.     */\n/*  12  AN ERROR OCCURRED DURING THE PROCESSING OF THE PRINTDS       */\n/*      COMMAND.                                                     */\n/*  16  THE INSTALLATION EXIT REQUESTED TERMINATION OF THE PRINTDS   */\n/*      COMMAND.                                                     */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\n\nIF &DEBUG = DEBUG THEN +\n   CONTROL MSG NOFLUSH CONLIST SYMLIST LIST\nELSE +\n   CONTROL NOMSG NOFLUSH NOLIST\n\n/* ----------------------------------------------------------------- */\n/* SET INITIAL SWITCHES, AND DISPLAY THE PANEL FOR THE FIRST TIME.   */\n/* ----------------------------------------------------------------- */\n\nISPEXEC CONTROL ERRORS RETURN\nSET &ERRORSW = OFF\n\nISPEXEC DISPLAY PANEL(SCH0P200)\nSET &RC = &LASTCC\n\n/* ----------------------------------------------------------------- */\n/* PROCESS THE FIELDS OF THE PANEL AND GENERATE THE PRINTDS COMMAND  */\n/* AS MANY TIMES AS REQUIRED.  REDISPLAY THE PANEL AFTER EACH DATA   */\n/* SET IS PROCESSED.                                                 */\n/* ----------------------------------------------------------------- */\n\nDO WHILE &RC = 0\n\n/* ----------------------------------------------------------------- */\n/* ESTABLISH AN ERROR EXIT FOR THE PRINTDS COMMAND.  IF PRINTDS      */\n/* SHOULD GENERATE A RETURN CODE > 0, (S013 - MISSING MEMBER, NON-   */\n/* EXISTANT DATA SET, I/O ERROR, ETC.,), DISPLAY A MESSAGE THAT      */\n/* PRINTDS FAILED AND THEN RE-DISPLAY THE PRINTDS OPTIONS PANEL.     */\n/* ----------------------------------------------------------------- */\n\n  CONTROL MSG\n  ERROR +\n    DO\n      SET &PRTRC = &LASTCC\n      IF &PRTRC > 0 THEN +\n        SET &ERRORSW = ON\n      RETURN\n    END\n\n/* ----------------------------------------------------------------- */\n\n  PRINTDS &DSNAME +\n          &DEST +\n          &COPIES +\n          &PRINTOPT +\n          &SYSOUT +\n          &FORMS +\n          &TITLE +\n          &OUTDES +\n          &FCB +\n          &WRITER +\n          &SPACING +\n          &PAGELEN +\n          &TMARGIN +\n          &BMARGIN +\n          &OPTIONS\n\n/* ----------------------------------------------------------------- */\n/* TERMINATE THE ERROR EXIT UPON RETURN.  IF THE ERROR EXIT WAS      */\n/* TAKEN, RE-DISPLAY THE PANEL TO ALLOW THE USER TO CORRECT THE      */\n/* FIELD(S) IN ERROR, DISPLAY AN ERROR MESSAGE, AND EXIT IF REQUEST- */\n/* ED BY THE USER.                                                   */\n/*                                                                   */\n/* OTHERWISE, THE USER'S PARAMETERS SHOULD BE PROCESSED, A MESSAGE   */\n/* LOGGED, AND AN INFORMATIONAL MESSAGE DISPLAYED THAT PRINTDS HAS   */\n/* SUCCESSFULLY COMPLETED ITS PROCESSING.                            */\n/* ----------------------------------------------------------------- */\n\n  ERROR OFF\n  IF &ERRORSW = ON THEN +\n    DO\n      ISPEXEC DISPLAY CURSOR(DSN) MSG(SCHP020C)\n      SET &RC = &LASTCC\n      IF &RC >= 8 THEN +\n        DO\n          ISPEXEC SETMSG MSG(SCHP020A)\n          EXIT\n        END\n      ELSE +\n        SET &ERRORSW = OFF\n    END\n  ELSE +\n    DO\n      CONTROL NOMSG\n      ISPEXEC LOG MSG(SCHP020B)\n      ISPEXEC DISPLAY CURSOR(DSN) MSG(SCHP029)\n      SET &RC = &LASTCC\n      IF &RC >= 8 THEN +\n        DO\n          ISPEXEC SETMSG MSG(SCHP020A)\n          EXIT\n        END\n    END\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXTRY": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\"\\x1f\\x00\\x91\"\\x1f\\x12\\x00\\x00g\\x00g\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-08-09T00:00:00", "modifydate": "1991-08-09T12:00:00", "lines": 103, "newlines": 103, "modlines": 0, "user": "REXX"}, "text": "/*********************************REXX**********************************\n*                                                                      *\n* Interactive REXX instruction execution.                              *\n*                                                                      *\n***********************************************************************/\n\n   Parse source . . REXXTRY_name_of_exec .\n   Parse arg REXXTRY_argument_string\n\n   If abbrev(\"?\",REXXTRY_argument_string)\n   Then do\n      Say REXXTRY_name_of_exec,\n      \"allows you to interactively execute REXX instructions -\"\n      Say \"each instruction string is executed when you hit Enter.\"\n      End\n\n   If REXXTRY_argument_string == \"?\"\n   Then do\n      Say \"You may also specify a REXX statement directly on the call\"\n      Say \"for immediate execution.\"\n      Exit\n      End\n\n   Trace \"Off\"\n   Call on error\n   Call on failure\n   Signal on novalue\n   Signal on syntax\n   Signal on halt\n   If sysvar(\"SYSISPF\") = \"ACTIVE\"\n   Then address ISPEXEC \"CONTROL ERRORS RETURN\"\n   Drop rc\n\n   If REXXTRY_argument_string \u00ac= \"\"\n   Then do\n      Interpret REXXTRY_argument_string\n      Exit\n      End\n   Else say \"To end enter \"\"Exit\"\".\"\n\nLoop:\n   Do forever\n      Parse external REXXTRY_external_string\n      If REXXTRY_external_string \u00ac= \"\"\n      Then interpret REXXTRY_external_string\n      Else say REXXTRY_name_of_exec\": enter a REXX instruction\"\n      End\n\nError:\n   REXXTRY_current_trace_option = trace(\"Off\")\n   Say condition(\"Condition name\") \"return code\" rc\n   Say condition(\"Description\")\n   If symbol(\"ZERRSM\") == \"VAR\"\n   Then do\n      Say zerrsm\n      Say zerrlm\n      Drop zerrsm zerrlm\n      End\n   Trace value REXXTRY_current_trace_option\n   Return\n\nFailure:\n   REXXTRY_current_trace_option = trace(\"Off\")\n   Say condition(\"Condition name\") \"return code\" rc\n   Say condition(\"Description\")\n   Trace value REXXTRY_current_trace_option\n   Return\n\nNovalue:\n   REXXTRY_current_trace_option = trace(\"Off\")\n   Say Condition(\"Condition name\"),\n      \"for variable\" condition(\"Description\")\n   If REXXTRY_argument_string = \"\"\n   Then do\n      Say REXXTRY_external_string\n      Signal on novalue\n      Trace value REXXTRY_current_trace_option\n      Signal loop\n      End\n   Else do\n      Say REXXTRY_argument_string\n      Exit\n      End\n\nSyntax:\n   REXXTRY_current_trace_option = trace(\"Off\")\n   Say condition(\"Condition name\") \"error\" rc\":\" errortext(rc)\n   If REXXTRY_argument_string = \"\"\n   Then do\n      Say REXXTRY_external_string\n      Signal on syntax\n      Trace value REXXTRY_current_trace_option\n      Signal loop\n      End\n   Else do\n      Say REXXTRY_argument_string\n      Exit\n      End\n\nHalt:\n   Trace \"Off\"\n   Say condition(\"Condition name\") condition(\"Description\")\n   Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHTP21": {"ttr": 6670, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00\\'\\x00\\'\\x00\\x00\\xd4\\xc5\\xe2\\xe2\\xc1\\xc7\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 39, "newlines": 39, "modlines": 0, "user": "MESSAGE"}, "text": "SCHP020  'Data set name required'     .TYPE=WARNING  .WINDOW=RESP\n'Enter the name of one or more valid non-VSAM data sets to be printed.'\n\nSCHP021  'Enter printer location'     .TYPE=WARNING  .WINDOW=RESP\n'Enter a local or remote location or device where data is to be printed.'\n\nSCHP022  'Enter valid copy count'     .TYPE=WARNING  .WINDOW=RESP\n'Specify a hardcopy output count in the range of 1 to 255 copies.'\n\nSCHP023  'Enter PDS print option'     .TYPE=WARNING  .WINDOW=RESP\n'Specify which portion of a partitioned data set is to be printed.'\n\nSCHP024  'Enter a TITLE option'       .TYPE=WARNING  .WINDOW=RESP\n'Specify \"N\" to suppress printing of the header; printing is the default.'\n\nSCHP025  'Invalid spacing option'     .TYPE=WARNING  .WINDOW=RESP\n'Specify \"C\" for cntl.chars., \"S\" = single, \"D\" = double, \"T\" = triple.'\n\nSCHP026  'Invalid page length'        .TYPE=WARNING  .WINDOW=RESP\n'Enter a page length in the range of 6 to 4095 lines per page.'\n\nSCHP027  'Invalid top margin'         .TYPE=WARNING  .WINDOW=RESP\n'Enter valid number of lines to be left blank at the top of the page.'\n\nSCHP028  'Invalid bottom margin'      .TYPE=WARNING  .WINDOW=RESP\n'Enter valid number of lines to be left blank at the bottom of the page.'\n\nSCHP029  'Data set printed'           .TYPE=NOTIFY   .WINDOW=NORESP\n'&DSN. has been queued for output processing.'\n\nSCHP020A 'PRINTDS terminated'         .TYPE=NOTIFY   .WINDOW=NORESP\n'PRINTDS was terminated via the END or RETURN command.'\n\nSCHP020B 'TSO     - PRINTDS'          .TYPE=NOTIFY   .WINDOW=NORESP\n'&DSN. queued for output processing, DEST=&DESTID..'\n\nSCHP020C 'PRINTDS has failed'         .TYPE=CRITICAL .WINDOW=RESP\n'PRINTDS has failed, RC=&PRTRC, or encountered errors during printing.'\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHTP210": {"ttr": 6672, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00$\\x00$\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n % TYPE(TEXT)  INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n + TYPE(TEXT)  INTENS(LOW)  COLOR(TURQ)  SKIP(ON)\n _ TYPE(INPUT) INTENS(HIGH) COLOR(WHITE) CAPS(ON) JUST(LEFT)\n \u00a6 TYPE(TEXT)  INTENS(LOW)  COLOR(BLUE)\n @ TYPE(TEXT)  INTENS(HIGH) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n@TUTORIAL\u00ac\\-\\ @TSO/E PRINTDS Hardcopy Output Panel\u00ac \\-\\\n%COMMAND ===>_ZCMD                                                             +\n+\n@                 ------------------------------------------------\n@                 |   \u00a6Foreground Printing Using TSO/E PRINTDS  @|\n@                 ------------------------------------------------\n\n+  The TSO/E PRINTDS Hardcopy Output Panel provides the TSO/E user with a\n   panel-driven facility to easily produce hardcopy output through foreground\n   copying.  Printing is accomplished by using ISPF dialog manager services\n   to build a TSO/E PRINTDS command from the options specified by the user in\n   the body of the PRINTDS panel.\n\n   The panel provides many of the most frequently used PRINTDS options.  A\n   non-VSAM data set name and a printer destination are all that is required\n   to initiate printing.  The print data is placed on the spool for printing\n   by either JES2/3 or VTAM Printer Support (VPS).\n\n   Range verification for various PRINTDS panel options is provided by the\n   PRINTDS dialog.  If an option is not available on the panel, the\n   \"Miscellaneous options\" may be used.  Note, however, that no range\n   verification is provided with this option.  The keyword is appended to the\n   PRINTDS command as it is entered on the panel.\n\n)PROC\n   &ZUP   = SCH0P200\n   &ZCONT = SCHTP220\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCH0P000": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00D\\x00D\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n  $ TYPE(TEXT)  INTENS(HIGH) COLOR(PINK)\n  \u00a2 TYPE(TEXT)  INTENS(HIGH) COLOR(GREEN)\n  _ TYPE(INPUT) INTENS(HIGH) COLOR(WHITE)\n  % TYPE(TEXT)  INTENS(HIGH) COLOR(WHITE)\n  \u00ac TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n  + TYPE(TEXT)  INTENS(LOW)  COLOR(TURQ)\n  ~ TYPE(TEXT)  INTENS(LOW)  COLOR(PINK)\n  \u00a6 TYPE(TEXT)  INTENS(HIGH) COLOR(BLUE)\n  @ TYPE(TEXT)  INTENS(HIGH) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n\u00ac\\-\\ @The Publisher's Workbench\u00ac \\-\\\n%COMMAND ===>_ZCMD                                                             +\n%\n\u00ac   1 @SCRIPT/VS 4.0 -+Document Composition Facility 4.0\n\u00ac   2 @PRINTDS       -+TSO/E PRINTDS Hardcopy Output Generation\n\u00ac   3 @GDDM/PGF      -+Graphical Data Display Manager/Presentation Graphics\n\u00ac   4 @LINGO         -+Text analysis, proofreader, and dictionary system\n\u00ac   5 @VPS Utilities -+VTAM Printer Support Monitor and Control Facility\n%\n\u00ac   6 @FLSF          -+Font Library Service Facility (SC33-6166)\n\u00ac   7 @OGL           -+Overlay Generation Language~(*)\n\u00ac   8 @PMF           -+Print Management Facility using APL2 (SH35-0059)\n\u00ac   9 @PPFA          -+Page Printer Formatting Aid~(*)\n\u00ac  10 @PSAF          -+Print Services Access Facility (S544-3100)\n%\n+Enter Session Manager Mode%===>_ZSMG+  (YES or NO)\n%\n~  (*)+- product implementation scheduled for future date\n%\n%\n\u00a6Press the\u00acEND KEY\u00a6to terminate the Publisher's Workbench+\n%\n)INIT\n  .CURSOR  = ZCMD\n  &ZHTOP   = ISR00003                   /* TUTORIAL TABLE OF CONTENTS */\n  &ZHINDEX = ISR91000                   /* TUTORIAL INDEX - 1ST PAGE  */\n  VGET (ZSESS) PROFILE\n  IF (&ZSESS = 'Y')\n    &ZSMG = TRANS(TRUNC(&ZSMMODE,1),Y,YES,*,NO)\n  IF (&ZSESS = 'N')\n    &ZSMG = NO\n\n)PROC\n  &ZPRIM = NO\n  &ZSMG = TRUNC(&ZSMG,1)\n  VER (&ZSMG,NB,LIST,Y,N)\n  &ZSM = TRANS(TRUNC(&ZSMG,1),Y,YES,N,NO)\n  &ZSMMODE = TRANS(TRUNC(&ZSM,1),Y,Y,N,N)\n  VPUT (ZSM,ZSMG,ZSMMODE) PROFILE\n  IF (.RESP = END) &ZSMG = NO\n\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n/*               0,'CMD(%DCFC001) NEWAPPL(DCF1) NEWPOOL' */\n                 1,'PGM(ISRFPR) PARM((SCH0P100) 1) NEWPOOL'\n                 2,'CMD(%SCH0P200)'\n/*               3,'PANEL(ADM@PRIM)' */\n                 3,'PANEL(SCH0P300)'\n                 4,'PANEL(LGOE01)'\n                 5,'PANEL(VPS@PRIM)'\n                 6,'PANEL(AFLPTASK)'\n/*               7,' '          */\n                 8,'CMD(%PMF)'\n/*               9,'CMD(%SCH0P900)' */\n                10,'CMD(%AFPRINT)'\n               ' ',' '\n                 *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCH0P200": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"O\\x00\\x92\"O\\x12\\x00\\x00\\xa3\\x00\\xa3\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-11T00:00:00", "modifydate": "1992-08-11T12:00:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "PANEL"}, "text": ")ATTR DEFAULT(%+_)\n % TYPE(TEXT)  INTENS(HIGH) COLOR(WHITE)\n \u00ac TYPE(TEXT)  INTENS(HIGH) COLOR(RED)\n + TYPE(TEXT)  INTENS(LOW)  COLOR(TURQ)  SKIP(ON)\n _ TYPE(INPUT) INTENS(HIGH) COLOR(WHITE) CAPS(ON) JUST(LEFT)\n \u00a6 TYPE(TEXT)  INTENS(LOW)  COLOR(BLUE)\n @ TYPE(TEXT)  INTENS(HIGH) COLOR(YELLOW)\n)BODY EXPAND(\\\\)\n\u00ac\\-\\ @TSO/E PRINTDS Hardcopy Output Panel\u00ac \\-\\\n%COMMAND ===>_ZCMD\n%\n\u00a6Enter data set name%===>_Z                                                    +\n\u00a6Output print destination   %===>_Z                +(LOCAL, R/RM/RMTnnnn, Unnnn)\n\u00a6Number of copies to print  %===>_Z  +              (1-255 copies, default = 1)\n%\n\u00a6Members, directory, or all %===>_Z        +        (A=All/D=Directry/M=Members)\n\u00a6Output print class         %===>_Z+                (Default=U or A-Z and 1-9)\n\u00a6Forms identification name  %===>_Z       +         (Default=STD.)\n%\n\u00a6PRINTDS header desired     %===>_Z+                (N=NO to suppress TITLE)\n\u00a6OUTPUT JCL descriptor name %===>_Z       +         (Max. of 8 alpha-num chars)\n%\n\u00a6FCB or image name          %===>_Z   +             (1-4 alpha or numeric chars)\n\u00a6External writer name       %===>_Z       +         (1-8 alpha or numeric chars)\n\u00a6Carriage control present   %===>_Z     +           (Cchar,Single,Double,Triple)\n%\n\u00a6Page length                %===>_Z   +             (Default=60, Range: 6-4095)\n\u00a6Top margin spacing         %===>_Z   +             (Default=0,  Range: 0-4094)\n\u00a6Bottom margin spacing      %===>_Z   +             (Default=0,  Range: 0-4094)\n\u00a6\n\u00a6Miscellaneous options%===>_Z                                                  +\n%\n)INIT\n  .HELP    = SCHTP210\n  .ZVARS   = '(DSN,DESTID,COUNT,PDSINFO,CLASS,FORMNAME,HEADER,OUTPUT,+\n               FCBID,XWTR,CARGCNTL,PL,TM,BM,OPTIONS)'\n  .CURSOR  = DSN\n\n  IF (&DESTID = ' ')     /* DEFAULT OUTPUT ROUTING DEST = CS01 (SFO) */\n    &DESTID = CS01       /* DON'T INITIALIZE UNLESS FIELD IS BLANK   */\n\n  &COUNT   = 1           /* DEFAULT HARDCOPY OUTPUT COPY COUNT = 1   */\n  &PDSINFO = ALL         /* DEFAULT PDS PRINT OPTION DIRECTORY & MEM */\n\n  IF (&CLASS = ' ')      /* DEFAULT OUTPUT ROUTING DEST = CS01 (SFO) */\n    &CLASS = U           /* DON'T INITIALIZE UNLESS FIELD IS BLANK   */\n\n)REINIT\n  IF (&FORMS \u00ac= ' ')     /* ALL KEYWORD OPERANDS ON THE PRINTDS CMD  */\n    &FORMS = &Z          /* MUST BE RESET TO NULLS IF THERE IS A VER */\n                         /* FAILURE OR MSG GENERATED.  OTHERWISE, A  */\n  IF (&TITLE \u00ac= ' ')     /* KEYWORD MAY BE GENERATED AS A RESULT OF  */\n    &TITLE = &Z          /* NORMAL )PROC STATEMENT PROCESSING THAT   */\n  IF (&OUTDES \u00ac= ' ')    /* IS NOT WANTED.                           */\n    &OUTDES = &Z\n\n  IF (&FCB \u00ac= ' ')\n    &FCB = &Z\n  IF (&WRITER \u00ac= ' ')\n    &WRITER = &Z\n  IF (&SPACING \u00ac= ' ')\n    &SPACING = &Z\n\n  IF (&PAGELEN \u00ac= ' ')\n    &PAGELEN = &Z\n  IF (&TMARGIN \u00ac= ' ')\n    &TMARGIN = &Z\n  IF (&BMARGIN \u00ac= ' ')\n    &BMARGIN = &Z\n\n)PROC\n  VER (&DSN,NB,MSG=SCHP020)\n  &DSNAME  = 'DATASET(&DSN)'\n  VER (&DESTID,NB,MSG=SCHP021)\n  &DEST = 'DEST(&DESTID)'\n\n  IF (&COUNT \u00ac= ' ')\n    VER (&COUNT,RANGE,1,255,MSG=SCHP022)\n    &COPIES = 'COPIES(&COUNT)'\n  ELSE\n    &COPIES = 'COPIES(1)'\n\n  IF (&PDSINFO \u00ac= ' ')\n    &PRINTOPT = TRANS(TRUNC(&PDSINFO,1)\n                A,ALL D,DIRECTORY M,MEMBERS *,? MSG=SCHP023)\n  ELSE\n    &PRINTOPT = 'ALL'\n  IF (&CLASS \u00ac= ' ')\n    &SYSOUT = 'CLASS(&CLASS)'\n  ELSE\n    &SYSOUT = 'CLASS(U)'\n  IF (&FORMNAME \u00ac= ' ')\n    &FORMS = 'FORMS(&FORMNAME)'\n\n  IF (&HEADER \u00ac= ' ')\n    VER (&HEADER,LIST,N,MSG=SCHP024)\n    &TITLE = TRANS(&HEADER N,'NOTITLE')\n  IF (&OUTPUT \u00ac= ' ')\n    &OUTDES = 'OUTDES(&OUTPUT)'\n\n  IF (&FCBID \u00ac= ' ')\n    &FCB = 'FCB(&FCBID)'\n  IF (&XWTR \u00ac= ' ')\n    &WRITER = 'WRITER(&XWTR)'\n  IF (&CARGCNTL \u00ac= ' ')\n    &SPACING = TRANS(TRUNC(&CARGCNTL,1)\n               C,CCHAR S,SINGLE D,DOUBLE T,TRIPLE MSG=SCHP025)\n\n  IF (&PL \u00ac= ' ')\n    VER (&PL,RANGE,6,4095,MSG=SCHP026)\n    &PAGELEN = 'PAGELEN(&PL) '\n  IF (&TM \u00ac= ' ')\n    VER (&TM,RANGE,0,4094,MSG=SCHP027)\n    &TMARGIN = 'TMARGIN(&TM) '\n  IF (&BM \u00ac= ' ')\n    VER (&BM,RANGE,0,4094,MSG=SCHP028)\n    &BMARGIN = 'BMARGIN(&BM) '\n\n)END\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/* -----------------------------------                               */\n/* TSO/E PRINTDS ISPF DIALOG FRONT-END                               */\n/* -----------------------------------                               */\n/*                                                                   */\n/* - UPDATED 22APR91, WILLIAM SMITH, CHARLES SCHWAB TECH. SERVICES   */\n/*   . COPYRIGHT, 1991, WILLIAM SMITH, CHARLES SCHWAB & COMPANY,     */\n/*     101 MONTGOMERY, DEPT. OSVS, 5TH FLOOR, SAN FRANCISCO, CA,     */\n/*     94104-4122, (415) 627-7607                                    */\n/*   . ALL RIGHTS RESERVED                                           */\n/*                                                                   */\n/* - UPDATED 20SEP90, WILLIAM SMITH, CHARLES SCHWAB TECH. SERVICES   */\n/*   . ADDED LOGIC IN THE INIT SECTION TO PREVENT AUTOMATIC          */\n/*     INITIALIZATION OF DESTID AND CLASS.  THESE VALUES MAY BE      */\n/*     PASSED TO THIS DIALOG BY ANOTHER USING 'CONTROL NONDISPLAY'   */\n/*     THROUGH THE SHARED POOL.  THE OLD LOGIC PREVENTED THE PASSED  */\n/*     VALUES FROM BEING PROPERLY DISPLAYED AND USED.                */\n/*                                                                   */\n/* - UPDATED 10SEP90, WILLIAM SMITH, CHARLES SCHWAB TECH. SERVICES   */\n/*   . TESTED WITH ISPF AND ISPF/PDF 3.1 AND MVS/ESA TSO/E 2.1.1     */\n/*   . STREAMLINED PROCESSING BY ELIMINATING REDUNDANT/UNNECESSARY   */\n/*     PANEL AND CLIST PROCESSING LOGIC                              */\n/*                                                                   */\n/* - WRITTEN 20NOV89, WILLIAM SMITH, OSVS TECHNICAL SERVICES         */\n/*   . ORIGINALLY WRITTEN AS AN ISPF DIALOG MANAGER FRONT-END FOR    */\n/*     USE WITH \"VTAM PRINTER SUPPORT\"; UPDATED AND MODIFIED TO      */\n/*     FRONT-END THE TSO/E 'PRINTDS' COMMAND PROCESSOR               */\n/*   . TESTED WITH ISPF AND ISPF/PDF 3.1 AND MVS/XA TSO/E 2.1.0      */\n/*                                                                   */\n/* ------------------------------------                              */\n/* RETURN CODES FOR THE PRINTDS COMMAND                              */\n/* ------------------------------------                              */\n/*                                                                   */\n/*   0  PROCESSING SUCCESSFUL                                        */\n/*   4  PROCESSING COMPLETED, BUT A WARNING MESSAGE HAS BEEN         */\n/*      ISSUED.                                                      */\n/*   8  THE INPUT, OUTPUT, OR SYSOUT DATA SET COULD NOT BE USED.     */\n/*  12  AN ERROR OCCURRED DURING THE PROCESSING OF THE PRINTDS       */\n/*      COMMAND.                                                     */\n/*  16  THE INSTALLATION EXIT REQUESTED TERMINATION OF THE PRINTDS   */\n/*      COMMAND.                                                     */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRHELP": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x05O\\x00\\x89\\x05O\\x12\\x00\\x029\\x029\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-02-23T00:00:00", "modifydate": "1989-02-23T12:00:00", "lines": 569, "newlines": 569, "modlines": 0, "user": "HELP"}, "text": "./ ADD NAME=SCRHELP  0100-88314-88314-1937-00568-00564-00000-AFP\n*---------------------------------------------------------------------*\n*                                                                     *\n* Component:  MVS/TSO SCRIPT/VS Help Library Member                   *\n*                                                                     *\n* Copyright:  None                                                    *\n*                                                                     *\n* Product:    5748-XX9                                                *\n*             IBM Document Composition Facility (DCF)                 *\n*             MVS/TSO Interactive Interface     (SCRIPT/VS)           *\n*                                                                     *\n* Status:     DCF 3.2                                                 *\n*             November 1988                                           *\n*                                                                     *\n* Source:     This information was copied from IBM Publications:      *\n*                                                                     *\n*             Document Composition Facility SCRIPT/VS User's          *\n*             Guide Release 3.2 (S544-3191-00)                        *\n*                                                                     *\n*             and                                                     *\n*                                                                     *\n*             Document Composition Facility SCRIPT/VS Language        *\n*             Reference Release 3.2 (SH35-0070-05)                    *\n*                                                                     *\n* Change Activity:                                                    *\n*                                                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Note:  This is what we have wanted from IBM for years and never     *\n*        gotten.                                                      *\n*---------------------------------------------------------------------*\n)F Function -\n\n   The DCF text formatter, SCRIPT/VS, processes documents marked up with\n   its own control words or Generalized Markup Language (GML) tags.  GML\n   tags are a shorthand text markup used to describe document parts or\n   elements which may be used instead of explicit SCRIPT/VS control\n   words.  SCRIPT/VS formats documents for printing on IBM Page\n   Printers, PostScript devices (configured to accept 8-bit ASCII), IBM\n   Line Printers, or any printer functionally equivalent at the\n   data-stream level.\n\n)X Syntax -\n\n   SCRIPT file-id or ?\n          BIND(bind) / BIND(obind ebind)\n          CHARS(font1,...)\n          CONTINUE / NOCONT\n          CTF\n          DDUT / NODDUT\n          DEST(printer-name)\n          DEVICE(device-type)\n          FILE(data set name)\n          FONTLIB(data set name)\n          FPASSES(n) / TWOPASS\n          INDEX\n          LIB(data set name)\n          MESSAGE( DELAY ID TRACE)\n          NOSPIE\n          NOWAIT\n          NUMBER\n          PAGE(PROMPT) / PAGE(FROM nn TO nn) / PAGE(FROM nn FOR n)\n                         PAGE(FROM nnn ONLY) / PAGE(nn TO nn)\n          PRINT(copies,class,fcb,ucs)\n          PROFILE(data set name) / NOPROF\n          PSOUT(ASCII) / PSOUT(EBCDIC)\n          QUIET\n          SEARCH(data set name)\n          SEGLIB(data set name) / NOSEGLIB\n          SPELLCHK\n          STOP\n          SYOFF / SYON\n          SYSVAR(x value .... x value)\n          TERM\n          UNFORMAT\n          UPCASE\n\n   Defaults: TERM\n             PROFILE(PROFILE)\n             LIB('SCRIPT.R32.MACLIB')\n             NOCONT\n             NODDUT\n             SYOFF\n\n  Mutually exclusive options:  PROFILE and NOPROF\n                               CTF, FILE, PRINT and TERM\n                               CONTINUE, NOCONT\n                               SEGLIB, NOSEGLIB\n                               DDUT and NODDUT\n                               SYON and SYOFF\n                               TWOPASS and FPASSES\n\n)O Operands -\n\n))file-id   - is the name of the primary input file.  When the input\n              file contains imbedded or appended files, file-id names\n              the primary or master file; the imbedded and appended\n              files are named with control words in the master file.\n              The format of the file-id is:\n\n              Specified file-id    ]    Actual file-id\n              _____________________________________________\n              A                    ]    userid.A.TEXT\n              A.TEXT               ]    userid.A.TEXT\n              DOC(CHAP1)           ]    userid.DOC.TEXT(CHAP1)\n              'ABC.D.EF'           ]    'ABC.D.EF'\n              (CHAP2)              ]    userid.TEXT(CHAP2)\n\n              A file-id of ? will cause SCRIPT/VS to display a list\n              of all the valid command options.\n\n))BIND      - The BIND option causes SCRIPT/VS to shift the formatted\n              output of each page to the right side of the paper.\n              The BIND option is specified as:\n\n              BIND(obind  ebind)\n               or\n              BIND(bind)\n\n              You can specify a binding for odd-numbered paged (obind)\n              and a different binding for even-numbered pages (ebind).\n              Binding values can be given in any valid space unit.\n\n              Note: you can override these values with the .PM control\n              word.\n\n              Abbreviation: B\n\n))CHARS     - The CHARS option identifies the fonts to be used and is\n              specified as:\n\n              CHARS(font1,font2,....)\n\n              For page devices, you specify an 8 character font\n              identifier.  A maximum of 31 fonts can be specified. If\n              you do not specify the CHARS option, the default font\n              specified for the logical device is used.  In either\n              case, the first font specified or implied becomes the\n              initial font.\n\n              When formatting for page printers the FONTLIB option is\n              used to identify the host system font library containing\n              the fonts to be used.\n\n              Abbreviation: CH\n\n))CONTINUE  - The CONTINUE options allows processing to continue after\n              SCRIPT/VS detects an error condition and issues an error\n              message.  When SCRIPT/VS encounters an error that is too\n              severe for processing to continue, it stops processing\n              even when CONTINUE is specified.\n\n              It is specified as:\n\n              CONTINUE\n\n              Abbreviation: CO\n\n))CTF       - Prepare output in STAIRS/VS Condensed Text Format The CTF\n              option is specified as:\n\n              CTF\n\n              This option specifies that the document be prepared as\n              input for the STAIRS/VS licensed program.  SCRIPT/VS\n              output is placed in Condensed Text Format blocks and\n              written to a file named userid.DSMUTCTF.TEXT.  The\n              STAIRS logical device is assumed when this option is\n              requested and the CTF option is ignored if any other\n              logical device is specified.\n\n              Abbreviation: CT\n\n))DDUT      - Enable SCRIPT/VS Utility File Retention. The DDUT option\n              is specified as:\n\n              DDUT\n\n              This option allows the redefinition of SCRIPT/VT utility\n              files to non-utility file names using the .DD (Define\n              Data File-id) control word.\n\n              Abbreviation: DD\n\n))DEST      - Name a remote output station\n\n              DEST(printer-name)\n\n              This option is used to specify the name of a printer at\n              which the formatted output is to be printed.  The\n              printer-name may be from one to eight characters.\n\n              Abbreviation: DES\n\n))DEVICE    - The DEVICE option allows the user to identify the type\n              of output device for which the document will be formatted.\n              The DEVICE option is specified as:\n\n              DEVICE(device-type)\n\n              Some of the valid device types are:\n\n              Logical   ]   Real   ] Lines/ ]                    ] Line\n              Device    ]   Device ] Inch   ] Bind ] Width ] Len ] Len\n              ----------]----------]--------]------]-------]-----]-----\n              TERM      ]  3270    ]   6    ]  2   ]  132  ] 11i ]  6i\n              1403N6    ]  1403    ]   6    ]  1i  ]  8.5i ] 11i ]  6i\n              1403N8    ]  1403    ]   8    ]  1i  ]  8.5i ] 11i ]  6i\n              1403W6    ]  1403    ]   6    ]  1i  ] 13.5i ]8.5i ]  6i\n              3800N6    ]  3800    ]   6    ]  1i  ]  8.5i ] 10i ]  6i\n              3800N8    ]  3800    ]   8    ]  1i  ]  8.5i ] 10i ]  6i\n              3800N12   ]  3800    ]  12    ]  1i  ]  8.5i ] 10i ]  6i\n              38PPN     ]  3800-3  ]   *    ]  1i  ]  8.5i ] 10i ]  6i\n              3820A     ]  3820 #  ]   *    ]  1i  ]  8.5i ] 11i ]  6i\n              3820A90   ]  3820 #  ]   *    ]  1i  ]   11i ]8.5i ]  6i\n              4250A     ]  4250    ]   *    ]  1i  ]  8.5i ] 11i ]  6i\n\n              * = line per inch determined by font selection\n              # = 3820 is also specified when the output device is a\n                  3812, 3827 or 3835.\n\n              Abbreviation: DEV\n\n))FILE      - The FILE option directs the formatted output document to a\n              direct access file.  If the DEVICE option is not also\n              specified, the 1403W6 logical device is assumed.  The\n              FILE option is specified as:\n\n              FILE(file-id)\n\n              where file-id is a fully or partially qualified data set\n              name.  The full name will be determined as follows based\n              on the input file data set name:\n\n              - line devices - \"TEXT\" is replaced with \"LIST\"\n              - 4250 devices - \"TEXT\" is replaced with \"LIST4250\"\n              - 38PP devices - \"TEXT\" is replaced with \"LIST38PP\"\n              - 3820 devices - \"TEXT\" is replaced with \"LIST3820\"\n\n              For example when DEV(3820A) is specified:\n\n              Specified file-id    ]    Actual file-id\n              _____________________________________________\n              'DOC.OUT'            ]    DOC.OUT\n              DOC.OUT              ]    userid.DOC.OUT.LIST3820\n              DOC.LIST             ]    userid.DOC.LIST3820\n              DOC.TEXT             ]    userid.DOC.LIST3820\n              CHAP2                ]    userid.LIST3820(CHAP2)\n\n              Abbreviation: FI\n\n))FONTLIB   - The FONTLIB option specifies the font library to be used\n              when formatting for page printers and PostScript devices.\n              The FONTLIB option is specified as:\n\n              FONTLIB(data set name)\n\n              Note that this option should not be required to be\n              specified as it should default to the correct font library\n              based upon the specified logical device type.\n\n              Abbreviation: FO\n\n))FPASSES   - The FPASSES option specifies the number of formatting\n              passes SCRIPT/VS performs when processing an input file.\n              These passes process all control words, but output occurs\n              only after the last pass.  FPASSES and TWOPASS are\n              mutually exclusive.  The FPASSES option is specified as:\n\n              FPASSES(n)\n\n              where n is the number of formatting passes SCRIPT/VS\n              performs.\n\n              Abbreviation: FP\n\n))INDEX     - The INDEX option enables the .PI (Put Index) control word\n              or the GML Tag :INDEX.  The INDEX option is specified as:\n\n              INDEX\n\n              Abbreviation: I\n\n))LIB       - The LIB option specifies the library SCRIPT/VS will search\n              for a definition of the symbols and macros not defined\n              within the input file.  The LIB option is specified as:\n\n              LIB(data set name)\n\n              If more than one library is required then omit this option\n              and preallocate ddname SCRPTLIB prior to invoking\n              SCRIPT/VS.\n\n              Abbreviation: L\n\n))MESSAGE   - The MESSAGE option controls the amount and timing of the\n              information SCRIPT/VS provides with error messages.  The\n              MESSAGE option is specified as:\n\n              MESSAGE ( DELAY ID TRACE )\n\n              DELAY requests that SCRIPT/VS not display messages while a\n              document is being displayed or printed.  SCRIPT/VS will\n              append the messages to the end of the formatted output.\n\n              ID causes SCRIPT/VS to include the error message\n              identifier along with the error messages.\n\n              TRACE causes SCRIPT/VS to list the sequence of imbedded\n              files.\n\n              These options can each be abbreviated as a single\n              character.\n\n              Note:  the MESSAGE option should always be specified\n                     before any other command option.\n\n              Abbreviation: M\n\n))NOCONT    - The NOCONT option ends processing after SCRIPT/VS\n              encounters an error condition and issues an error message.\n              This is the default.  The NOCONT option is specified as:\n\n              NOCONT\n\n              Abbreviation: NOC\n\n))NODDUT    - The NODDUT option disallows the redefinition of SCRIPT/VS\n              utility files to non-utility file names using the .DD\n              (Define Data File-id) control word.  This is the default.\n              The NODDUT option is specified as:\n\n              NODDUT\n\n              Abbreviation: NOD\n\n))NOPROF    - The NOPROF option requests that SCRIPT/VS not imbed a a\n              profile document.  The NOPROF option is specified as:\n\n              NOPROF\n\n              Abbreviation: NOP\n\n))NOSEGLIB  - The NOSEGLIB option overrides the SEGLIB option and\n              specifies that no host system segment library should be\n              accessed.  The NOSEGLIB option is specified as:\n\n              NOSEGLIB\n\n              Abbreviation: NOSE\n\n))NOSPIE    - The NOSPIE option requests that SCRIPT/VS not establish a\n              programming interrupt exit.  The NOSPIE option is\n              specified as:\n\n              NOSPIE\n\n              Abbreviation: NOSP\n\n))NOWAIT    - The NOWAIT option causes SCRIPT/VS to send output to your\n              terminal without first prompting you to adjust the paper.\n              NOWAIT is the normal mode for output to all output devices\n              except a typewriter terminal.  The NOWAIT option is\n              specified as:\n\n              NOWAIT\n\n              Abbreviation: NOW\n\n))NUMBER    - The NUMBER option, for line devices, causes SCRIPT/VS to\n              print the file-id and line number of the last line read\n              when a formatted output line is printed.  The formatter\n              reads ahead and since the number printed is that of the\n              last input line read, the number printed may or may not\n              correspond to the input line number of the text printed in\n              the output line.  The NUMBER option is ignored for page\n              printers and PostScript devices. The NUMBER option is\n              specified as:\n\n              NUMBER\n\n              Abbreviation: NU\n\n))PAGE      - The PAGE option allows you to print pages of formatted\n              output selectively.  The page number need not be an\n              integer; you can use the .PN (Page Numbering Model)\n              control word to establish decimal, alphabetic, and Roman\n              numeral page numbers, and attach a prefix to each page\n              number.  The first eight characters of the page number you\n              specify with the PAGE option is the character string that\n              SCRIPT/VS compares to the current page number symbol.  The\n              PAGE option has several formats, and any number of page\n              range specifications can be included in the PAGE option.\n\n              Valid forms of the page range specification are:\n\n              PROMPT\n              (FROM) frompage (TO) topage\n              (FROM) frompage FOR n-pages\n              (FROM) page ONLY\n\n              Examples of valid page option specifications:\n\n              PAGE(FROM 10 TO 15)\n              PAGE(7 8)\n              PAGE(2 TO 5)\n              PAGE(FROM 94.1 FOR 3 99 ONLY)\n              PAGE(viii ONLY 93 TO *)\n\n              An asterisk (*) specified as frompage is interpreted\n              as the current page; an asterisk specified as topage\n              means the last page in the document.\n\n              Abbreviation: PA\n\n))PRINT     - The PRINT option causes SCRIPT/VS to send the output\n              document to a printer.  If the DEVICE option is not\n              specified, SCRIPT/VS assumes the 1403W6 logical device\n              type.  The PRINT option is specified as:\n\n              PRINT(copies,class,fcb,ucs)\n\n              copies is the number of copies desired, and defaults\n              to \"1\".\n\n              class is the SYSOUT class, and defaults to \"A\".\n\n              fcb is the forms control buffer name.\n\n              ucs is the universal character set.\n\n              Abbreviation: PRI\n\n))PROFILE   - The PROFILE option names the file that SCRIPT/VS is to\n              use as the profile for the document being formatted.  A\n              profile can contain frequently used symbol and macro\n              definitions, GML application processing functions, and\n              text appropriate for many documents.  The PROFILE option\n              is specified as:\n\n              PROFILE(data set name)\n\n              Abbreviation: PRO\n\n))PSOUT     - The PSOUT option specifies whether SCRIPT/VS generates\n              PostScript output in ASCII or EBCDIC when a PostScript\n              device is specified with the DEVICE option.  PSOUT is\n              specified as:\n\n              PSOUT(ASCII)\n                 or\n              PSOUT(EBCDIC)\n\n              Abbreviation: PS\n\n))QUIET     - The QUIET option causes SCRIPT/VS to suppress (not\n              display) the version identification message that is\n              otherwise typed or displayed as a response to the SCRIPT\n              command.  The QUIET option is specified as:\n\n              QUIET\n\n              Abbreviation: Q\n\n))SEARCH    - The SEARCH option causes SCRIPT/VS to search the specified\n              library or partitioned data set for imbedded or appended\n              files.  The SEARCH option is specified as:\n\n              SEARCH(data set name)\n\n              Abbreviation: SEA\n\n))SEGLIB    - The SEGLIB option specifies the library SCRIPT/VS is to\n              reference for page segments during the formatting process\n              when it encounters the .SI (Segment Include) control word.\n\n              SEGLIB(data set name)\n\n              Abbreviation: SEG\n\n))SPELLCHK  - The SPELLCHK option causes SCRIPT/VS to verify the\n              spelling of the words in the input document.  The SPELLCHK\n              option is specified as:\n\n              SPELLCHK\n\n              Abbreviation: SP\n\n))STOP      - The STOP option causes SCRIPT/VS to wait for you to\n              press the return (enter) key before starting to type\n              each page.  Use this option when printing your output\n              document on separate sheets of paper at a typewriter\n              terminal.  The STOP option is specified as:\n\n              STOP\n\n              Abbreviation: ST\n\n))SYOFF     - The SYOFF option, which is the default, disables the .SY\n              (System Command) control word.  The SYOFF option is\n              specified as:\n\n              SYOFF\n\n              Abbreviation: SYOF\n\n\n))SYON      - The SYON option enables the .SY (System Command) control\n              word.  The SYON option is specified as:\n\n              SYON\n\n              Abbreviation: SYON\n\n))SYSVAR    - The SYSVAR option allows you to pass information to\n              SCRIPT/VS as symbols defined when you issue the\n              SCRIPT command.  The SYSVAR option is specified as:\n\n              SYSVAR (x value ... y value)\n\n              Each 'x value' pair causes the symbol &SYSVARx to be set\n              to the 'value'.  'x' is any alphameric character\n              identifying the token.  'Value' is any alphameric string\n              of up to eight characters, and cannot contain imbedded\n              blanks or parenthesis.  Note: the 'value' is always\n              translated to upper case.\n\n              Abbreviation: SYS\n\n))TERM      - The TERM option causes SCRIPT/VS to send the output\n              document to your terminal.  If the DEVICE option is not\n              specified, SCRIPT/VS assumes the logical device TERM and\n              displays the document on your terminal.  The TERM option\n              is specified as:\n\n              TERM\n\n              Abbreviation: TE\n\n))TWOPASS   - The TWOPASS option causes SCRIPT/VS to process the input\n              file in two passes.  Both passes process all control\n              words, but output occurs only on the second pass.  TWOPASS\n              and FPASSES are mutually exclusive, therefore the last one\n              specified is the one that takes effect.  The TWOPASS\n              option is specified as:\n\n              TWOPASS\n\n              Abbreviation: TW\n\n))UNFORMAT  - The UNFORMAT option generally lists only those input lines\n              that are processed by SCRIPT/VS.  For example, input lines\n              that are bypassed because of a .GO (Goto) control word or\n              a .CS (Conditional Section) control word are not shown in\n              the unformatted listing.  Note:  the UNFORMAT option is\n              ignored for page printers and PostScript devices.  The\n              UNFORMAT option is specified as:\n\n              UNFORMAT\n\n              Abbreviation: UN\n\n))UPCASE    - The UPCASE option causes SCRIPT/VS to convert, for the\n              formatted output document only, all lowercase letters\n              to uppercase.  The UPCASE option is specified as:\n\n              UPCASE\n\n              Abbreviation: UP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOW": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x924?\\x00\\x924?\\x12\\x00\\x0c\\xdf\\x0c\\xdf\\x00\\x00\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-12-08T00:00:00", "modifydate": "1992-12-08T12:00:00", "lines": 3295, "newlines": 3295, "modlines": 0, "user": "ASM"}, "text": "./ ADD NAME=ASM\n>< ADD NAME=IKJCT44B 0100-92115-92118-1606-000141-000120-000000-$A1019\nIKJCCT4B TITLE 'ROCKWELL CLIST BUILT-IN FUNCTION EXIT'\n***********************************************************************\n*        Rockwell CLIST Built-in Function Exit\n*\n*        CLIST Function &SYSXSHOW Interface to SHOW\n*\n*        Use: refer to &SYSXSHOW(id), where \"id\" is a valid value for\n*        the SHOW routine.\n*        \"id\" may be a constant or a variable, and may be either\n*        uppercase or lowercase.\n*\n*\n*        Douglas H. Adams\n*        Mail code 110-SE28\n*        Information Systems Center\n*        Rockwell International Corporation\n*        2201 Seal Beach Boulevard\n*        P. O. Box 2515\n*        Seal Beach, California 90740-1515\n*\n*        (310) 797-2618\n*\n*        April 24, 1992\n*\n***********************************************************************\n         PUNCH ' ALIAS IKJCT44B'\nIKJCCT4B CSECT\nIKJCCT4B AMODE 31\nIKJCCT4B RMODE ANY\n         EJECT\n***********************************************************************\n*                                  EXIT PARAMETERS\n***********************************************************************\nPARMS    DSECT                     PARAMETERS PASSED TO EXIT\nPCBUF    DS    A                   COMMAND BUFFER\nPNCBUF   DS    A                   NEW COMMAND BUFFER\nPUPT     DS    A                   USER PROFILE TABLE\nPECT     DS    A                   ENVIRONMENTAL CONTROL TABLE\nPPSCB    DS    A                   PROTECTED STEP CONTROL BLOCK\nPCOMM    DS    A                   EXIT-TO-EXIT COMMUNICATION WORD\nPREASON  DS    A                   EXIT REASON CODE\n         DS    A                   RESERVED\n         DS    A                   RESERVED\nPNAME    DS    A                   NAME OF BUILT-IN FUNCTION\nPARG     DS    A                   ARGUMENT OF BUILT-IN FUNCTION\nPRESULT  DS    A                   256 BYTE ANSWER AREA\nPALTLEN  DS    A                   ALTERNATE BUFFER LENGTH\n*\nPARMENT  DSECT                     PARAMETER ENTRY\nKEY      DS    XL4                 TYPE OF ENTRY\nLENGTH   DS    F                   LENGTH OF DATA\nDATA     DS    A                   DATA OR ADDRESS OF DATA\n         EJECT\n***********************************************************************\n*                                  WORK AREA FOR REENTRANCE\n***********************************************************************\nWORKAREA DSECT\nSAVE     DS    18F                 SAVE AREA\nID       DS    CL8\nCALL     CALL  ,(ID,ILENGTH,,),MF=L  SHOW PARAMETERS\nWORKSIZE EQU   *-WORKAREA\n***********************************************************************\n*                                  INITIALIZATION\n***********************************************************************\nIKJCCT4B CSECT\n         USING IKJCCT4B,15\n         SAVE  (14,12)             SAVE REGISTERS\n         MODID\n         DROP  15\n         LR    12,15               SET BASE REGISTER\n         USING IKJCCT4B,12\n         LR    2,1                 SAVE PARAMETER POINTER\n         USING PARMS,2\n         LA    0,WORKSIZE          GET WORK AREA SIZE\n         GETMAIN RU,LV=(0)         GET WORKAREA STORAGE\n         XC    0(WORKSIZE,1),0(1)  CLEAR WORK AREA\n         ST    1,8(,13)            CHAIN SAVE AREAS\n         ST    13,4(,1)\n         LR    13,1\n         USING WORKAREA,13\n***********************************************************************\n*                                  GET FUNCTION VALUE\n***********************************************************************\n         L     3,PNAME             POINT TO FUNCTION NAME ENTRY\n         USING PARMENT,3\n         L     4,LENGTH            GET LENGTH OF FUNCTION  NAME\n         C     4,=A(L'SYSXSHOW)    CORRECT LENGTH?\n         BNE   ERROR1              NO, BRANCH\n         L     5,DATA              POINT TO FUNCTION NAME\n         CLC   SYSXSHOW,0(5)       CORRECT NAME?\n         BNE   ERROR1              NO, BRANCH\n         L     3,PARG              POINT TO ARGUMENT ENTRY\n         ICM   4,15,LENGTH         GET LENGTH OF ARGUMENT\n         BNP   ERROR2              NULL OR NEGATIVE, BRANCH\n         C     4,=F'8'             IS ARG TOO BIG?\n         BH    ERROR2              YES, BRANCH\n         MVC   ID,=CL8' '          SET ID TO BLANKS\n         BCTR  4,0                 GET MACHINE LENGTH OF ID\n         L     5,DATA              POINT TO ID\n         EX    4,MVC               MOVE ARG TO ID\n         L     3,PRESULT           POINT TO RESULT ENTRY\n         LA    4,LENGTH            POINT TO LENGTH OF RESULT\n         L     5,DATA              POINT TO RESULT\n         ICM   15,15,=V(SHOW)      GET ENTRY POINT OF SHOW\n         BZ    LINK                BRANCH IF NOT RESOLVED\n         CALL  (15),(ID,ILENGTH,(5),(4)),VL,MF=(E,CALL)\n         B     TESTRET             GO TEST RETURN CODE\nLINK     EQU   *\n         LINK  EP=SHOW,PARAM=(ID,ILENGTH,(5),(4)),VL=1,MF=(E,CALL)\nTESTRET  EQU   *\n         LTR   15,15               SUCCESSFUL?\n         BZ    RETURN              YES, BRANCH\n         BNZ   ERROR2              NO, BRANCH\n***********************************************************************\n*                                  TERMINATION\n***********************************************************************\n         EJECT\nERROR1   EQU   *\n         LA    15,8                NOT A SUPPORTED FUNCTION\nERROR2   EQU   *\n         LA    15,12               EXIT PROCESSING UNSUCCESSFUL\n*                                  CLIST PROCESSING ISSUES MESSAGE\nRETURN   EQU   *\n         LR    2,15                SAVE RETURN CODE\n         LA    0,WORKSIZE          GET WORKAREA SIZE\n         LR    1,13                UNCHAIN SAVE AREAS\n         L     13,4(,1)\n         FREEMAIN RU,LV=(0),A=(1)  FREE WORK AREA STORAGE\n         LR    15,2                RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)    RETURN\n*\nMVC      MVC   ID(0),0(5)          EXECUTED\n         DROP  13\n         DROP  12\n         EJECT\n***********************************************************************\n*                                  DATA\n***********************************************************************\nSYSXSHOW DC    C'SYSXSHOW'         NAME OF FUNCTION\nILENGTH  DC    F'256'              CLIST RESULT LENGTH\n         END\n>< ADD NAME=IRXFLOC  0100-92114-92115-1615-000044-000026-000000-$A1019\nIRXFLOC  TITLE 'ROCKWELL REXX FUNCTION PACKAGE DIRECTORY'\n***********************************************************************\n*        Rockwell REXX Function Package Directory\n*\n*        See macro IRXFPDIR for the format of this module.\n*\n*\n*        Douglas H. Adams\n*        Mail code 110-SE28\n*        Information Systems Center\n*        Rockwell International Corporation\n*        2201 Seal Beach Boulevard\n*        P. O. Box 2515\n*        Seal Beach, California 90740-1515\n*\n*        (310) 797-2618\n*\n*        April 24, 1992\n*\n***********************************************************************\n         PUNCH ' ALIAS IRXFLOC'\nIRXFLOC  CSECT\nIRXFLOC  AMODE 31\nIRXFLOC  RMODE ANY\n         EJECT\n         IRXFPDIR                  REXX FUNCTION PACKAGE DIRECTORY\n         EJECT\nIRXFLOC  CSECT\nHEADER   DC    CL8'IRXFPACK'       STRING IDENTIFYING DIRECTORY\n         DC    A(ENTRIES-HEADER)   LENGTH OF HEADER\n         DC    A((END-ENTRIES)/32) NUMBER OF ROWS IN DIRECTORY\n         DC    F'0'                WORD OF ZEROS\n         DC    A(FPCKDIR_NEXT-FPCKDIR_ENTRY)  LENGTH OF DIRECTORY ENTRY\n*\nENTRIES  EQU   *\n*\n         DC    CL8'SHOWREXX'       NAME USED IN EXEC\n         DC    V(SHOWREXX)         ADDRESS OF PRELOADED CODE\n         DC    F'0'                RESERVED FIELD\n         DC    CL8' '              NAME OF ENTRY POINT\n         DC    CL8' '              DD FROM WHICH TO LOAD ENTRY POINT\n*\nEND      EQU   *\n         END\n>< ADD NAME=SHOW     0147-90107-92118-1530-001517-000743-001171-$A1019\nSHOW     TITLE 'SHOW - EXTRACT INFORMATION FROM SYSTEM CONTROL BLOCKS'\n***********************************************************************\n*\n*        How to Use This Program.\n*\n*        The SHOW routine provides the caller with character string\n*        information extracted from system control blocks. Numeric and\n*        bit information is converted to character string format.\n*\n*        Entry linkage:\n*              CALL SHOW,(ID,ILENGTH,VALUE,OLENGTH),VL\n*\n*        Parameters:\n*              ID      - Character string. Input.  An 8 character\n*                        identifier for the information requested by\n*                        the caller, padded with blanks if necessary.\n*\n*              ILENGTH - Full word binary. Input.  The length of the\n*                        VALUE character string provided by the caller.\n*                        The VALUE will be padded with trailing blanks\n*                        or truncated if necessary. A maximum of 32767\n*                        is supported.\n*\n*              VALUE   - Character string. Output.  The returned\n*                        information specified by ID. The caller must\n*                        provide a receiving character string of\n*                        sufficient length.\n*\n*              OLENGTH - Full word binary. Output.  The actual length\n*                        of the value requested. This may be less than\n*                        or greater than ILENGTH.\n*\n*        Return codes:\n*               0 - Normal completion\n*               4 - VALUE truncated, insufficient length\n*               8 - ID not found\n*              12 - Too few arguments\n*              16 - System control block failed validity check\n*\n*\n*        Douglas H. Adams          Lionel B. Dyck\n*               Mail Code 110-SE28\n*               Information Systems Center\n*               Rockwell International Corporation\n*               2201 Seal Beach Boulevard\n*               P. O. Box 2515\n*               Seal Beach, California 90740-1515\n*\n*        (310) 797-2618            (310) 797-1125\n*\n*               April 24, 1992\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n* Supported arguments are:                                 *LBD 02/84*\n*                                                          *LBD 02/84*\n* ID        ILENGTH Description                            *DHA 04/92*\n*----------------------------------------------------------------------\n* ACCT       11     Rockwell Job Card Account (with FDS #) *LBD 06/89*\n* ACCTNO      8     Rockwell Job Card Account (no FDS #)   *LBD 02/84*\n* ACCTNO#     8     Rockwell ACF2 User's Account (no FDS #)*LBD 12/86*\n* ACF2ACCT   40     ACF2 User's Default Accounting Field   *LBD 02/84*\n* BCPFMID     8     Basic Control Program FMID             *DHA 04/92*\n* BCPLEVEL    8     Basic Control Program Product Name     *LBD 04/91*\n* CENTER      8     Rockwell Center Name                   *LBD 05/84*\n* COMPMAIL    4     Rockwell ACF2 User's Computer Mail Code*LBD 06/86*\n* CPU         8     System Name from SYS1.PARMLIB(IEASYSxx)*LBD 06/89*\n* CPUMODEL    4     CPU Model (e.g., 3090)                 *DHA 04/92*\n* CPUSER    112     CPU Serial(s) (Maximum 16)             *DHA 04/92*\n* CPUVER      2     CPU Version                            *DHA 04/92*\n* CRTCD       2     Rockwell Job Card CRT Code             *LBD 02/84*\n* DEPT        3     Rockwell ACF2 User's Department        *LBD 02/84*\n* DEST        8     TSO User's Default Destination         *LBD 03/84*\n* DFPLEVEL    5     Data Facility Product Level            *LBD 04/91*\n* FDS         3     Rockwell Job Card FDS #                *LBD 02/84*\n* FDS#        4     Rockwell ACF2 User's FDS #             *LBD 12/86*\n* FRAMES      3     Rockwell Job Card CRT Frame Limit      *LBD 02/84*\n* GROUP       3     Rockwell ACF2 User's Group (in Dept)   *LBD 02/84*\n* GRP         3     Rockwell ACF2 User's Group (in Dept)   *DHA 04/92*\n* HOMEDIV     4     Rockwell ACF2 User's Home Division     *LBD 10/90*\n* JOBFUNC     2     Rockwell ACF2 User's Job Function Code *LBD 10/84*\n* JOBNAME     8     Job Name                               *LBD 02/84*\n* LINES       8     Rockwell Job Card FORTRAN Line Limit   *LBD 02/84*\n* LOC         4     Rockwell ACF2 User's Physical Location *LBD 02/84*\n* MAIL        8     Rockwell ACF2 User's Mail Code         *LBD 02/84*\n* NAME       20     ACF2 User's Name                       *LBD 02/84*\n* OPSYS       7     Operating System (MVS/xxx)              *LBD 05/89*\n* OS          3     Operating System (xxx)                  *LBD 07/89*\n* OSLEV       3     Operating System (xxx)                  *LBD 07/89*\n* OSREL       4     Operating System Release Number        *LBD 03/84*\n* PHONE      12     ACF2 User's Phone Number               *LBD 02/84*\n* REFERVOL    6     Volume Serial of Dataset userid.REFER  *DHA 04/92*\n* SHOWLEV    14     Level of SHOW (Date and Time)           *LBD 04/91*\n* SYSNAME     8     System Name from SYS1.PARMIB(IEASYSxx) *LBD 03/84*\n* TERMINAL    8     Terminal ID                            *LBD 02/84*\n* TSOOPER     6     TSO OPERATOR Authority (YES or NO)      *LBD 06/89*\n* TSOUNIT     8     TSO User's Default Unit Name           *LBD 03/87*\n* UID        24     Rockwell ACF2 User's UID String         *LBD 06/89*\n* USERID      8     User ID                                *LBD 02/84*\n*----------------------------------------------------------------------\n* The following are derived from control blocks or fields\n* which are not official IBM programming interfaces. Use\n* them at your own risk.\n*\n* ID        ILENGTH Description                            *DHA 04/92*\n*----------------------------------------------------------------------\n* BDTNODE     8     MVS/BDT Node Name                      *LBD 06/84*\n* CLPA        3     CLPA Specified at last IPL (YES or NO) *DHA 04/92*\n* CVIO        3     CVIO Specified at IPL (YES or NO)      *DHA 04/92*\n* IPLDATE     8     Last IPL Date                          *DHA 04/92*\n* IPLTIME    10     Last IPL Time                          *DHA 04/92*\n* JOBID       8     Job ID (JOBnnnnn)                      *LBD 12/89*\n* LPAR        3     Logical Partition Mode (YES or NO)     *DHA 04/92*\n* PRTY        2     Job Scheduling Priority                 *LBD 07/89*\n* REALSTOR   17     Real Storage Available at Last IPL     *DHA 04/92*\n* REGION     17     Region Size (nK)                      *LBD 07/85*\n* SMFID       4     SMF ID from SYS1.PARMLIB(SMFPRMxx)      *LBD 06/89*\n* SMS         3     Status of SMS (ON or OFF)              *LBD 01/91*\n* SWA         5     SWA Location (ABOVE or BELOW)          *LBD 04/91*\n* SYSID       4     System ID from SYS1.PARMLIB(SMFPRMxx)  *LBD 03/84*\n* SYSRES      6     System Residence Volume Serial         *DHA 04/92*\n* VERID      16     Installation System Version (CVTVERID) *LBD 03/84*\n***********************************************************************\n         EJECT\n***********************************************************************\n*        Assembly Parameters                               *DHA 04/92*\n***********************************************************************\n         GBLC  &SYSSPLV            SPLEVEL                 *DHA 04/92*\n         SPLEVEL SET               SET MVS/SP VERSION      *DHA 04/92*\n&ACF2    SETB  1                   0 = NO ACF2             *DHA 04/92*\n&JES3    SETB  1                   0 = NO JES3             *DHA 04/92*\n&ROCKWELL SETB 1                   0 = NO ROCKWELL         *DHA 04/92*\n         EJECT\n***********************************************************************\n*\n*        How to Modify This Program.\n*\n*        This program has been designed to be easy to modify.  It\n*        consists of 6 sections:\n*              (1) Macro definitions\n*              (2) Control block definitions (DSECTs)\n*              (3) Work area definitions (DSECT)\n*              (4) Initialization\n*              (5) VALUE determination\n*              (6) Termination\n*\n*        Modifications will normally be done in section 2 and section\n*        5.  A modification may also require changes to section 3.\n*        Sections 4 and 6 are designed to minimize the amount of code\n*        required in section 5.\n*\n*        The functions  performed by the sections are:\n*\n*              1. The SHOW macro. There must be a SHOW macro call in\n*                 section 5 for each ID. The syntax is:\n*                    id SHOW <BLOCK=block,FIELD=field><,WORK={YES|NO}>\n*                 Required:  id.\n*                 Defaults:  BLOCK=0,FIELD=0,WORK=NO.\n*                 id     is the ID name.\n*                 BLOCK  is the name of an area containing a character\n*                        string is to be copied to VALUE.  This is\n*                        usually the name of a control block defined by\n*                        a DSECT, but it may be a name in the work\n*                        area (WORKAREA) or the name of a constant\n*                        defined by a DC within this module.\n*                 FIELD  is the name of the character string to be\n*                        copied to VALUE.  This defines the offset from\n*                        BLOCK and the length of the character string.\n*                 WORK   specifies whether or not a GETMAIN should be\n*                        issued for a work area.\n*\n*              2. Control block DSECTs.  Macro calls needed to define\n*                 control blocks should be placed here.\n*\n*              3. Work area definitions. An optional 4K work area may\n*                 be requested via the SHOW macro to allow reentrant\n*                 coding. It is RMODE 24.  The work area begins with a\n*                 standard 18 word save area, pointed to by register\n*                 13.  If an ID requires a work area, an ORG WORKORG\n*                 should be used and unique set of DS and EQU\n*                 instructions should be defined.\n*\n*              4. Initialization. This section should not be modified.\n*                 It obtains and validity checks the parameters.  It\n*                 then initializes the caller's output area to blanks\n*                 (for a length of ILENGTH) and sets OLENGTH to zero.\n*                 Next it determines which ID was requested.  If the ID\n*                 requires a work area, it issues a GETMAIN.  Finally,\n*                 it branches to the appropriate code in section 5.\n*                 The following registers are set and must not be\n*                 changed:\n*                    R8   Pointer to SHOW table entry\n*                    R9   Pointer to OLENGTH\n*                    R10  Pointer to VALUE\n*                    R11  Value of ILENGTH\n*                    R12  Base register\n*                    R13  Pointer to save area and optional work area.\n*                         If no work area was obtained, the save area\n*                         is that of SHOW's caller.\n*\n*              5. Determination of the requested VALUE. The code\n*                 receives control with RMODE 24 and AMODE 31. It must\n*                 be reentrant.  There must be SHOW macro for each ID\n*                 in this section. When multiple IDs refer to different\n*                 fields within a specific control block, they should\n*                 be grouped together with the same BLOCK value and\n*                 different FIELD values. The code following the SHOW\n*                 macro(s) must find the appropriate BLOCK value and\n*                 point to it with register 1.  The BLOCK value may be\n*                 a control block, the work area, or a constant within\n*                 this module. The code must then branch to label\n*                 FOUND.  Control blocks should be validity checked. If\n*                 they fail, the code should branch to label INVALID.\n*                 Normally, the length of FIELD is determined at\n*                 assembly time. If the length must be determined\n*                 dynamically, the code should load the length into\n*                 register 2 and branch to label FOUNDLEN.\n*\n*              6. Termination.  This section should not be modified.\n*                 When reached at label FOUND, it loads the length from\n*                 the SHOW macro FIELD definition. This is bypassed if\n*                 label FOUNDLEN is used. The code then strips off\n*                 leading and trailing blanks and nulls and move the\n*                 result to the caller's VALUE. If ILENGTH is\n*                 insufficient the VALUE is truncated.\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n*\n*        Section 1 - Macro Definitions\n*\n***********************************************************************\n         MACRO\n&ID      SHOW  &BLOCK=0,           SHOW IDENTIFIER/CONTROL BLOCK       *\n               &FIELD=0,           FIELD WITHIN CONTROL BLOCK          *\n               &WORK=NO            WORK AREA NEEDED?       *DHA 04/90*\n.*********************************************************************\n.*       &ID    Specifies the external identifier used by the caller.\n.*       &BLOCK Specifies the control block containing the required\n.*              information.\n.*       &FIELD Specifies the control block field which corresponds\n.*              the external identifier. Note the length of field is\n.*              obtained from the control block definition.\n.*       &WORK  Specifies whether or not a GETMAIN should be issued\n.*              for a work area.\n.*********************************************************************\n         GBLA  &SHOWN              NUMBER OF TABLE ENTRIES\n         GBLC  &SHOWID(100)        IDS (PADDED WITH BLANKS)\n         GBLC  &SHOWBLK(100)       BLOCKS (PADDED WITH BLANKS)\n         GBLC  &SHOWFLD(100)       FIELDS (PADDED WITH BLANKS)\n         GBLB  &SHOWWORK(100)      WORK AREA REQUIRED      *DHA 04/90*\n&ID      DS    0H\n&SHOWN            SETA &SHOWN+1    NUMBER OF IDS\n&SHOWID(&SHOWN)   SETC '&ID'       SAVE ID\n&SHOWBLK(&SHOWN)  SETC '&BLOCK'    SAVE BLOCK\n&SHOWFLD(&SHOWN)  SETC '&FIELD'    SAVE FIELD\n&SHOWWORK(&SHOWN) SETB ('&WORK' EQ 'YES')                  *DHA 04/90*\n         MEND\n         EJECT\n***********************************************************************\n         MACRO\n&NAME    SHOWTBL &END              GENERATE SHOW ID TABLE\n         GBLA  &SHOWN              NUMBER OF TABLE ENTRIES\n         GBLC  &SHOWID(100)        IDS (PADDED WITH BLANKS)\n         GBLC  &SHOWBLK(100)       BLOCKS (PADDED WITH BLANKS)\n         GBLC  &SHOWFLD(100)       FIELDS (PADDED WITH BLANKS)\n         GBLB  &SHOWWORK(100)      WORK AREA REQUIRED      *DHA 04/90*\n         LCLA  &I,&L\n         LCLC  &N\n         SPACE\nSHOWENT  DSECT                     SHOW TABLE\nSHOWID   DS    CL8                 ID (FIXED LENGTH)\nSHOWFLD  DS    Y                   OFFSET OF CONTROL BLOCK FIELD\nSHOWRTN  DS    Y                   OFFSET TO EXECUTABLE ROUTINE\nSHOWFLDL DS    H                   LENGTH OF CONTROL BLOCK FIELD\nSHOWFLAG DS    X                   FLAGS                   *DHA 04/90*\nSHOWWORK EQU   X'01'               WORK AREA REQUIRED      *DHA 04/90*\n         DS    X                   PAD                     *DHA 04/90*\nSHOWSIZE DS    0XL(*-SHOWENT)      SIZE OF TABLE ENTRY\n         SPACE\n&SYSECT  CSECT\n         SPACE\n         DS    0D\n         SHOWSORT 1,&SHOWN         SORT ID'S\n&N       SETC  '&NAME'             NAME START OF TABLE\n.LOOP    ANOP\n&I       SETA  &I+1                INCREMENT INDEX\n         AIF   (&I GT &SHOWN).END  END OF TABLE?\n         AIF   (&I LT &SHOWN).GEN  STILL WITHIN TABLE?\n&N       SETC  '&END'              NAME END OF TABLE\n.GEN     ANOP\n&N       DC    CL8'&SHOWID(&I)'              ID\n         DC    Y(&SHOWFLD(&I)-&SHOWBLK(&I))  OFFSET OF FIELD\n         DC    Y(&SHOWID(&I)-&SYSECT)        OFFSET TO ROUTINE\n         DC    AL2(L'&SHOWFLD(&I))           LENGTH OF FIELD\n         DC    X'&SHOWWORK(&I)'              FLAGS\n         DC    X'00'\n&N       SETC  ''                  NULLIFY NAME FIELD\n         AGO   .LOOP               LOOP FOR NEXT ID\n.END     SPACE\n         MEND\n         EJECT\n***********************************************************************\n         MACRO\n         SHOWSORT &M,&N            SORT ID'S\n         GBLB  &SHOWWORK(100)      WORK AREA REQUIRED      *DHA 04/90*\n         GBLC  &SHOWID(100)        IDS (PADDED WITH BLANKS)\n         GBLC  &SHOWBLK(100)       BLOCKS (PADDED WITH BLANKS)\n         GBLC  &SHOWFLD(100)       FIELDS (PADDED WITH BLANKS)\n         LCLA  &I,&J,&F,&TEMPA\n         LCLB  &TEMPB                                      *DHA 04/90*\n         LCLC  &X,&TEMPC,&XI,&XJ\n         AIF   (&M GE &N).SORTED   IS THIS SEGMENT SORTED?\n&I       SETA  &M                  INITIALIZE START OF SEGMENT\n&J       SETA  &N                  INITIALIZE END OF SEGMENT\n&F       SETA  (&M+&N)/2           GET MIDDLE OF SEGMENT\n&X       SETC  '&SHOWID(&F)'.(8-K'&SHOWID(&F))' '  GET MIDDLE ELEMENT\n.UP      ANOP                      SEARCH FOR OUT OF PLACE ELEMENT\n&XI      SETC  '&SHOWID(&I)'.(8-K'&SHOWID(&I))' '  GET UPPER ELEMENT\n         AIF   ('&X' LE '&XI').DOWN  HIGH ELEMENT FOUND?\n&I       SETA  &I+1                INCREMENT INDEX\n         AGO   .UP                 LOOP FOR NEXT ELEMENT\n.DOWN    ANOP                      SEARCH FOR OUT OF PLACE ELEMENT\n&XJ      SETC  '&SHOWID(&J)'.(8-K'&SHOWID(&J))' '  GET LOWER ELEMENT\n         AIF   ('&X' GE '&XJ').CHANGE  LOW ELEMENT FOUND?\n&J       SETA  &J-1                DECREMENT INDEX\n         AGO   .DOWN               LOOP FOR NEXT ELEMENT\n.CHANGE  AIF   (&I GT &J).SPLIT    IS SEGMENT NOW SPLIT?\n&TEMPC       SETC '&SHOWID(&I)'    EXCHANGE ID ELEMENTS\n&SHOWID(&I)  SETC '&SHOWID(&J)'\n&SHOWID(&J)  SETC '&TEMPC'\n&TEMPC       SETC '&SHOWBLK(&I)'   EXCHANGE BLOCK ELEMENTS\n&SHOWBLK(&I) SETC '&SHOWBLK(&J)'\n&SHOWBLK(&J) SETC '&TEMPC'\n&TEMPC       SETC '&SHOWFLD(&I)'   EXCHANGE FIELD ELEMENTS\n&SHOWFLD(&I) SETC '&SHOWFLD(&J)'\n&SHOWFLD(&J) SETC '&TEMPC'\n&TEMPB       SETB (&SHOWWORK(&I))  EXCHANGE FLAG ELEMENTS  *DHA 04/90*\n&SHOWWORK(&I) SETB (&SHOWWORK(&J))                         *DHA 04/90*\n&SHOWWORK(&J) SETB (&TEMPB)                                *DHA 04/90*\n&I       SETA  &I+1                INCREMENT LOW INDEX\n&J       SETA  &J-1                DECREMENT HIGH INDEX\n         AIF   (&I LT &J).UP       IS SEGMENT NOW SPLIT?\n.SPLIT   ANOP                      SORT SEGMENTS RECURSIVELY\n         SHOWSORT &M,&J            SORT UPPER SEGMENT\n         SHOWSORT &I,&N            SORT LOWER SEGMENT\n.SORTED  MEND\n         EJECT\n***********************************************************************\n*\n*        Section 2 - Control Block Definitions\n*\n***********************************************************************\n         PUNCH ' ENTRY SHOW'\nSHOW     CSECT\nSHOW     AMODE 31                                          *DHA 04/90*\nSHOW     RMODE 24                  For RMODE 24 callers    *DHA 04/90*\n*----------------------------------------------------------------------\n*                                  ACF2 Control Blocks     *DHA 04/92*\n*----------------------------------------------------------------------\n         AIF   (NOT &ACF2).ACF2A                           *DHA 04/92*\n         ACCVT                     ACF2 CVT                *LBD 02/84*\n         EJECT\n         ACFASVT                   ACF2 Address Space      *LBD 02/84*\n*                                  Vector Table\n         EJECT\n         ACUCB                     ACF2 Address Space C. B.*LBD 02/84*\n         EJECT\nACUID    ACUID                     ACF2 UID String         *DHA 04/90*\n         LIDREC DSECT=YES          ACF2 Logon ID Record    *LBD 02/84*\nLIDACCT# EQU   LIDACCT+3,4                                 *LBD 02/84*\n.ACF2A   ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*                                  JES3 Control Blocks     *DHA 04/92*\n*----------------------------------------------------------------------\n         AIF   (NOT &JES3).JES3A                           *DHA 04/92*\n         IATYUSVT                  BDT User Subsystem     *LBD 06/84*\n*                                  Vector Table\n.JES3A   ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*                                  Rockwell Control Blocks *DHA 04/92*\n*----------------------------------------------------------------------\n         AIF   (NOT &ROCKWELL).ROCKWELL1                   *DHA 04/92*\n         RATYJCD                   Rockwell JOB Card\nFDSACCT  EQU   ABFDS,11            Rockwell Account Number  *LBD 06/89*\n         EJECT\n         RCVT                      Rockwell CVT            *DHA 04/92*\n.ROCKWELL1 ANOP                                            *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*                                  MVS Control Blocks      *DHA 04/92*\n*----------------------------------------------------------------------\n         CVT   DSECT=YES,PREFIX=YES,LIST=YES  CVT          *LBD 03/84*\n         EJECT\n         IEESMCA                   SMF Control table       *LBD 03/84*\n         EJECT\nIEFAJCTB DSECT\n         IEFAJCTB                  Job Control Table\n         EJECT\n         IEFJESCT                  JES Communication Table*LBD 06/84*\n         EJECT\n         IEFJSCVT                  Subsystem CVT          *LBD 06/84*\n         EJECT\n         IEFJSSIB ,                Subsystem ID Block      *LBD 12/89*\n         EJECT\nIEFTIOT1 DSECT                                             *DHA 04/92*\n         IEFTIOT1                  Task Input/Output Table *DHA 04/92*\n         EJECT\nIEFUCBOB DSECT                                             *DHA 04/92*\n         IEFUCBOB                  Unit Control Block      *DHA 04/92*\n         EJECT\n         IEZBITS                   Bit Definitions        *LBD 06/84*\n         EJECT\n         IEZJSCB                   Job Step Control Block\n         EJECT                                            *\n         IHAACEE                   Accessor Environment    *DHA 04/92*\n*                                  Element                 *DHA 04/92*\n         EJECT\n         IHAASCB                   Address Space C. B.     *LBD 08/85*\n         EJECT                                            *\n         IHAASXB                   Address Space Extension *DHA 04/92*\n*                                  Block                   *DHA 04/92*\n         EJECT\n         IHADFA ,                  Data Facilities Area    *LBD 01/91*\n         EJECT\n         IHALDA                    Local Data Area         *LBD 08/85*\n         EJECT                                            *\n         IHAPCCA                   Physical Configuration  *DHA 04/92*\n*                                  Communication Area      *DHA 04/92*\nVERSION  EQU   PCCACPID,2          CPU VERSION             *DHA 04/92*\n         EJECT\n         IHAPCCAT                  Physical Configuration  *DHA 04/92*\n*                                  Communication Area      *DHA 04/92*\n*                                  Vector Table            *DHA 04/92*\n         EJECT\n         IHAPSA LIST=YES           Prefixed Save Area\n         EJECT\n         IHASCCB                   Service Call C.B.       *DHA 04/92*\n         EJECT\n         IKJPSCB                   TSO Protected Step C.B. *DHA 04/92*\n         EJECT\n         IKJTCB LIST=YES           Task Control Block\n         EJECT                                            *\n*        ILRASMVT                  Asm Vector Table        *DHA 04/92*\nASMVT    DSECT                                             *DHA 04/92*\nASMFLAG1 DS    B                   ASM Global flag field 1 *DHA 04/92*\nASMFLAG2 DS    B                   ASM Global flag field 2 *DHA 04/92*\nASMQUICK EQU   B'00001000'         Quick Start (no CLPA)   *DHA 04/92*\nASMWARM  EQU   B'00000100'         Warm Start (no CVIO)    *DHA 04/92*\n         EJECT\n         REGEQU                    Registers\n         EJECT\n***********************************************************************\n*\n*        Parameter Definitions\n*\n***********************************************************************\nPARMS    DSECT\nAID      DS    A                   A(ID)\nAILENGTH DS    A                   A(ILENGTH)\nAVALUE   DS    A                   A(VALUE)\nAOLENGTH DS    A                   A(OLENGTH)\nPARM1    DSECT                     FIRST PARAMETER\nID       DS    CL8                 IDENTIFIER\nPARM2    DSECT                     SECOND PARAMETER\nILENGTH  DS    F                   INPUT LENGTH OF VALUE\nPARM3    DSECT                     THIRD PARAMETER\nVALUE    DS    CL256               VALUE ASSOCIATED WITH IDENTIFIER\nPARM4    DSECT                     THIRD PARAMETER\nOLENGTH  DS    F                   OUTPUT LENGTH OF VALUE\n         EJECT\n***********************************************************************\n*\n*        Section 3 - Work Area for Reentrance\n*\n***********************************************************************\nWORKAREA DSECT                     GETMAIN AREA            *DHA 04/90*\nSAVEAREA DS    18F                 SAVE AREA               *DHA 04/90*\n*----------------------------------------------------------------------\n*                                                          *DHA 04/90*\n*        Origin for Individual Work Areas                  *DHA 04/90*\n*                                                          *DHA 04/90*\n*        Each ID which requires a work area should begin   *DHA 04/90*\n*        with an ORG WORKORG.                              *DHA 04/90*\n*                                                          *DHA 04/90*\n*----------------------------------------------------------------------\nWORKORG  EQU   *                                           *DHA 04/90*\n*----------------------------------------------------------------------\n*        CPU MODEL NUMBER CONVERSION                       *DHA 04/92*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/92*\nMODEL    DS    CL4                 UNPACKED MODEL NUMBER   *DHA 04/92*\n*----------------------------------------------------------------------\n*        PRTY CONVERSION                                   *DHA 04/90*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/90*\nPRTYDWK  DS    D                   DOUBLE WORD WORKAREA    *DHA 04/90*\nPRTYEDIT DS    0CL4                                        *DHA 04/90*\n         DS    C' ',X'20'          PAD CHAR + EXTRA DIGIT  *DHA 04/90*\nPRTYVAL  DS    XL2'2120'           PRTY                    *DHA 04/90*\n*----------------------------------------------------------------------\n*        REGION SIZE CONVERSION                            *DHA 04/90*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/90*\nREGDWK   DS    D                DOUBLE WORD WORKAREA       *LBD 08/85*\nREGSIZE  DS    0CL17               REGION SIZE             *DHA 04/92*\nREGEDIT  DS    0CL16               REGION EDIT PATTERN     *DHA 04/90*\n         DS    C' ',13X'20',X'2120',C'K'                   *DHA 04/92*\n*----------------------------------------------------------------------\n*        IKJEHCIR CATALOG INFO ROUTINE PARAMETER LIST      *DHA 04/90*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/90*\nCIRPARM  DS    0D                                          *DHA 04/90*\nCIROPT   DS    X'04'               ENTRY CODE (VOLUME INFO)*DHA 04/90*\n         DS    2X                                          *DHA 04/90*\nCIRLOCRC DS    X                   LOCATE RETURN CODE      *DHA 04/90*\nCIRSRCH  DS    A(REFERDSN)         ADDRESS OF SEARCH ARG.  *DHA 04/90*\nCIRCVOL  DS    A(0)                ADDRESS OF CVOL ID      *DHA 04/90*\nCIRWA    DS    A(AREALN)           ADDRESS OF WORK AREA    *DHA 04/90*\nCIRSAVE  DS    A(SAVE)             ADDRESS OF SAVE AREA    *DHA 04/90*\nCIRPSWD  DS    A(0)                ADRESS OF PASSWORD      *DHA 04/90*\n*                                                          *DHA 04/90*\nREFERDSN DS    CL44'USERID.REFER'  CIR DSNAME              *DHA 04/90*\n*        CIRWA WORK AREA                                   *DHA 04/90*\nAREALN   DS    Y(DATASIZE)         LENGTH OF WORK AREA     *DHA 04/90*\nDATALIN  DS    H                   LENGTH OF DATA RETURNED *DHA 04/90*\nDATA     DS    X                   NUMBER OF VOLUMES       *DHA 04/90*\nDEVTYP   DS    XL4                 DEVICE TYPE             *DHA 04/90*\nVOLSER   DS    CL6                 VOLUME SERIAL NUMBER    *DHA 04/90*\nFILESEQ  DS    XL2                 FILE SEQUENCE NUMBER    *DHA 04/90*\n         DS    12X'FF'             END OF LIST             *DHA 04/90*\nDATASIZE EQU   *-AREALN            SIZE OF VOLUME WORK AREA*DHA 04/90*\n*                                                          *DHA 04/90*\nSAVE     DS    18F                 CIR SAVE AREA           *DHA 04/90*\n*----------------------------------------------------------------------\n*        DFPLEVEL CONVERSION                               *DHA 04/92*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/92*\nDFPLEV   DS    CL5                 DFP LEVEL               *DHA 04/92*\n*----------------------------------------------------------------------\n*        IPL DATE CONVERSION                               *DHA 04/92*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/92*\nT001BL   DS    0XL24                   MONTH TABLE\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\nW001X    DC    F'00'\nMX001M   DC    PL2'00'                 MONTH WORK AREA\nR1001ST  DC    F'00'                   REGISTER SAVE AREA FOR REG\nYR001X   DC    PL2'00'                 YEAR WORK AREA\nDYXX     DC    PL2'00'                 DAY WORK AREA\nXDATE    DS    0CL8                                        *DHA 04/92*\nXM1      DC    CL2'  '                 MONTH O/P AREA\nXMD1     DC    C'/'\nXD1      DC    CL2'  '                 DAY O/P AREA\nXDY1     DC    C'/'\nXY1      DC    CL2'  '                 YEAR O/P AREA\n*----------------------------------------------------------------------\n*        IPL TIME CONVERSION                               *DHA 04/92*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/92*\n@DWORD   DS    D\n@TWORK   DS    CL6\n@TIME    DS    0CL10\n@HRS     DS    CL4\n         DC    C'.'\n@MIN     DS    CL2\n         DC    C'.'\n@SEC     DS    CL2\n*----------------------------------------------------------------------\n*        REAL STORAGE SIZE CONVERSION                      *DHA 04/92*\n*----------------------------------------------------------------------\n         ORG   WORKORG                                     *DHA 04/92*\nREALDEC  DS    D                                           *LBD 08/85*\nREALSIZE DS    0CL17               REAL STORAGE SIZE       *DHA 04/92*\nREALEDIT DS    0CL16               EDIT PATTERN            *DHA 04/90*\n         DS    C' ',13X'20',X'2120',C'M'                   *DHA 04/92*\n*----------------------------------------------------------------------\n*        CPU SERIAL NUMBERS                                *DHA 04/92*\n*----------------------------------------------------------------------\nSERIAL   DS    0CL6                A CPU SERIAL            *DHA 04/92*\nSERIALS  DS    CL(7*16)            ALL CPU SERIALS         *DHA 04/92*\n         ORG   WORKORG                                     *DHA 04/92*\n*----------------------------------------------------------------------\n*        END OF INDIVIDUAL WORK AREAS                      *DHA 04/90*\n*----------------------------------------------------------------------\n         ORG   ,                                           *DHA 04/90*\n         EJECT\n***********************************************************************\n*\n*        Section 4 - Initialization\n*\n*              Input:  R1 -> PARMS.\n*              Output: VALUE = blanks.\n*                      OLENGTH = 0.\n*                      R8 -> SHOW table entry.\n*                      R9 -> OLENGTH.\n*                      R10 -> VALUE.\n*                      R11 = ILENGTH.\n*                      R12 = base register.\n*                      R13 -> WORKAREA/SAVEAREA if requested.\n*\n***********************************************************************\nSHOW     CSECT\n         USING PSA,R0              APPLIES TO ENTIRE MODULE*DHA 04/92*\n         USING *,R15\n         USING PARMS,R1\n         BSM   R14,0               SAVE AMODE              *DHA 04/90*\n         SAVE  (14,12)             SAVE REGISTERS\n         MODID ,                   MODULE IDENTIFICATION\n         DROP  R15\n         LR    R12,R15             R12 = BASE REGISTER\n         USING SHOW,R12\n         SR    R8,R8               NO TABLE ENTRY YET      *DHA 04/92*\n         LR    R9,R1              SAVE R1                   *LBD 06/89*\n         XABSM MODE=31            ENTER 31-BIT MODE         *LBD 06/89*\n         LR    R1,R9              RELOAD R1                 *LBD 06/89*\n         TM    AID,X'80'           IS ID LAST PARAMETER?\n         BO    ARGERROR            YES, ERROR\n         TM    AILENGTH,X'80'      IS ILENGTH LAST PARAMETER?\n         BO    ARGERROR            YES, ERROR\n         TM    AVALUE,X'80'        IS VALUE LAST PARAMETER?\n         BO    ARGERROR            YES, ERROR\n         L     R9,AOLENGTH         R9 -> OLENGTH\n         USING OLENGTH,R9\n         XC    OLENGTH,OLENGTH     OLENGTH = 0 IN CASE OF ERROR\n         L     R10,AVALUE          R10 -> VALUE\n         USING VALUE,R10\n         L     R11,AILENGTH        R11 -> ILENGTH\n         USING ILENGTH,R11\n         ICM   R11,15,ILENGTH      R11 = ILENGTH\n         DROP  R11\n         BNP   TRUNCATE            ERROR IF ILENGTH <= 0\n         LA    R2,VALUE            POINT TO TARGET         *DHA 04/92*\n         LR    R3,R11              GET LENGTH OF TARGET    *DHA 04/92*\n         LA    R5,C' '             PAD BYTE = BLANK        *DHA 04/92*\n         SLL   R5,24               SOURCE LENGTH = 0       *DHA 04/92*\n         MVCL  R2,R4               SET VALUE TO BLANKS     *DHA 04/92*\n         L     R14,AID             R14 -> ID\n         USING ID,R14\n         DROP  R1                                          *DHA 04/92*\n         EJECT\n***********************************************************************\n*        Determine whether ID is in table.\n*              A binary search is made to determine whether the ID\n*              in the internal table.  If so, a branch is\n*              made to the appropriate routine.\n*              A 4K GETMAIN is done if required.           *DHA 04/90*\n***********************************************************************\n         LM    R14,R15,ID          GET ID                  *DHA 04/92*\n         DROP  R14\n         O     R14,=CL4' '         INSURE UPPERCASE        *DHA 04/92*\n         O     R15,=CL4' '                                 *DHA 04/92*\n         SR    R4,R4               CLEAR FOR DIVISION\n         LA    R6,L'SHOWSIZE       GET +LENGTH OF TABLE ENTRY\n         LNR   R2,R6               GET -LENGTH OF TABLE ENTRY\n         LA    R3,SHOWTBL          POINT TO LOW END OF TABLE\n         LA    R7,SHOWTBLE         POINT TO HIGH END OF TABLE\nLOOP     DS    0H\n         LR    R5,R7               HIGH END OF TABLE\n         SR    R5,R3               HIGH-LOW\n         SRL   R5,1                (HIGH-LOW)/2\n         DR    R4,R6               ((HIGH-LOW)/2)/SHOWSIZE\n         MR    R4,R6               (((HIGH-LOW)/2)/SHOWSIZE)*SHOWSIZE\n         AR    R5,R3               POINT TO MIDDLE ENTRY IN TABLE\n         USING SHOWENT,R5\n         CL    R14,SHOWID          COMPARE LEFT HALF OF ID *DHA 04/90*\n         BL    LOW                 LOW: BRANCH             *DHA 04/92*\n         BH    HIGH                HIGH: BRANCH\n         CL    R15,SHOWID+4        COMPARE RIGHT HALF OF ID*DHA 04/92*\n         BE    EQUAL               EQUAL: BRANCH\n         BH    HIGH                HIGH: BRANCH            *DHA 04/92*\nLOW      DS    0H\n         LR    R7,R5               POINT HIGH AT MIDPOINT\n         BXH   R7,R2,LOOP          MINUS TESTED ENTRY; HIGH > LOW?\n         CR    R7,R3               ELSE HIGH = LOW?\n         BE    LOOP\n         B     NOID                NO, ERROR (NOT MATCHED)\n*\nHIGH     DS    0H\n         LR    R3,R5               POINT LOW AT MIDPOINT\n         BXLE  R3,R6,LOOP          PLUS TESTED ENTRY; LOW <= HIGH?\n         B     NOID                NO, ERROR (NOT MATCHED)\n*\nEQUAL    DS    0H\n         LR    R8,R5               POINT TO SHOW ENTRY     *DHA 04/90*\n         DROP  R5                                          *DHA 04/90*\n         USING SHOWENT,R8                                  *DHA 04/90*\n         LH    R6,SHOWRTN          GET BRANCH DISPLACEMENT *DHA 04/92*\n         TM    SHOWFLAG,SHOWWORK   WORK AREA NEEDED?       *DHA 04/90*\n         BZ    SHOW(R6)            NO, BRANCH TO PROCESS ID*DHA 04/92*\n         GETMAIN RU,LV=4096,BNDRY=PAGE,LOC=(BELOW,ANY)     *DHA 04/90*\n         LR    R2,R1               R2 -> WORKAREA          *DHA 04/92*\n         LA    R3,2048             R3 = 2048*2 = 4096 =    *DHA 04/92*\n         SLL   R3,1                     TARGET LENGTH      *DHA 04/92*\n*                                  R4 IRRELEVANT           *DHA 04/92*\n         SR    R5,R5               R5 = 0 = PAD/LENGTH     *DHA 04/92*\n         MVCL  R2,R4               ZERO OUT WORKAREA       *DHA 04/92*\n         ST    R13,4(,R1)          CHAIN SAVE AREAS        *DHA 04/90*\n         ST    R1,8(R13)           ...                     *DHA 04/90*\n         LR    R13,R1              ...                     *DHA 04/90*\n         B     SHOW(R6)            BRANCH TO PROCESS ID    *DHA 04/92*\n         EJECT\n***********************************************************************\n*\n*        Section 5 - Determination of the requested VALUE\n*\n*              Input:  R0 -> Prefixed Save Area (PSA)\n*                      R8 -> SHOW TABLE ENTRY.\n*                      R9 -> OLENGTH.\n*                      R10 -> VALUE.\n*                      R11 = ILENGTH.\n*                      R12 = base register.\n*                      R13 -> WORKAREA/SAVEAREA if requested.\n*              Output: R1 -> BLOCK (beginning of control block).\n*                      Optionally, R2 = length of FIELD.\n*                      R8 -> SHOW TABLE ENTRY.\n*                      R9 -> OLENGTH.\n*                      R10 -> VALUE.\n*                      R11 = ILENGTH.\n*                      R12 = base register.\n*                      R13 -> WORKAREA/SAVEAREA if requested.\n*\n***********************************************************************\n*----------------------------------------------------------------------\n*                  Assembly date/time\n*----------------------------------------------------------------------\nSHOWLEV  SHOW  BLOCK=SHOWDATE,FIELD=SHOWDATE               *DHA 04/92*\n         LA    R1,SHOWDATE         R1 -> SHOWDATE          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\nSHOWDATE DS    0CL14               SHOW ASSEMBLY           *DHA 04/92*\n         DC    CL8'&SYSDATE'         DATE                  *DHA 04/92*\n         DC    C' '                    AND                 *LBD 04/91*\n         DC    CL5'&SYSTIME'             TIME              *LBD 04/91*\n         EJECT\n*----------------------------------------------------------------------\n*                   Volume Serial of Data Set userid.REFER\n*----------------------------------------------------------------------\nREFERVOL SHOW  BLOCK=WORKAREA,FIELD=VOLSER,WORK=YES        *LBD 03/87*\n         USING WORKAREA,R13                                *DHA 04/92*\n         MVC   REFERDSN,=CL44' '   CLEAR CIR DSNAME        *DHA 04/90*\n         L     R1,PSATOLD          POINT TO CURRENT TCB    *DHA 04/92*\n         USING TCB,R1                                      *DHA 04/92*\n         L     R1,TCBTIO           POINT TO TIOT           *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING TIOT1,R1                                    *DHA 04/92*\n         MVC   REFERDSN(8),TIOCNJOB MOVE USER-ID           *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         LA    R1,REFERDSN         -> DSN                  *LBD 03/87*\n         LA    R2,7                MAX SEARCH              *LBD 03/87*\nUSERLP1  DS    0H                                          *LBD 03/87*\n         LA    R1,1(R1)            INCR R1                 *LBD 03/87*\n         CLI   1(R1),C' '          END OF USERID           *LBD 03/87*\n         BE    MOVREFER                                    *LBD 03/87*\n         BCT   R2,USERLP1                                  *LBD 03/87*\nMOVREFER MVC   1(7,R1),=CL7'.REFER'                        *LBD 03/87*\n         MVI   CIROPT,X'04'        RETRIEVE VOLUME INFO    *DHA 04/90*\n         LA    R0,REFERDSN         POINT TO DSNAME         *DHA 04/90*\n         ST    R0,CIRSRCH          ADDRESS OF SEARCH ARG.  *DHA 04/90*\n         XC    CIRCVOL,CIRCVOL     CLEAR CVOL ADDRESS      *DHA 04/90*\n         LA    R0,AREALN           POINT TO WORK AREA      *DHA 04/90*\n         ST    R0,CIRWA            ADDRESS OF WORK AREA    *DHA 04/90*\n         LA    R0,SAVE             POINT TO CIR SAVE AREA  *DHA 04/90*\n         ST    R0,CIRSAVE          ADDRESS OF SAVE AREA    *DHA 04/90*\n         XC    CIRPSWD,CIRPSWD     CLEAR PASSWORD ADDRESS  *DHA 04/90*\n         LA    R0,DATASIZE         GET LENGTH OF WORK AREA *DHA 04/90*\n         STH   R0,AREALN           LENGTH OF WORK AREA     *DHA 04/90*\n         CALLTSSR EP=IKJEHCIR,     CALL CATALOG INFO RTN.  *DHA 04/90* *\n               MF=(E,CIRPARM)                              *DHA 04/90*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/90*\n         B     FOUND               AND LEAVE               *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\n         EJECT\n         EJECT\n*----------------------------------------------------------------------\n*        ACUID    - ACF2 UID String\n*----------------------------------------------------------------------\n         AIF   (NOT &ACF2).ACF2B                           *DHA 04/92*\nUID      SHOW  BLOCK=ACUID,FIELD=ACUID                     *DHA 04/90*\n         ACFINCVT R6,NONE=INVALID                          *LBD 02/84*\n         USING ACCVT,R6            ADDRESSABILITY          *LBD 02/84*\n         ACFGUCB R7,NONE=INVALID,INLINE=YES                *DHA 04/92*\n         USING ACUCB,R7                                     *LBD 06/89*\n         L     R1,ACUUIDP          R1 -> ACUID              *LBD 06/89*\n         DROP  R6,R7                                        *LBD 06/89*\n         B     FOUND                                       *DHA 04/90*\n.ACF2B   ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        CVT      - Communications Vector Table Prefix\n*----------------------------------------------------------------------\nCPUMODEL SHOW  BLOCK=MODEL,FIELD=MODEL,WORK=YES            *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *DHA 04/92*\n         LA    R0,CVTMAP-CVTFIX    GET LENGTH OF CVT PREFIX*DHA 04/92*\n         SR    R1,R0               POINT TO CVTFIX         *DHA 04/92*\n         USING CVTFIX,R1\n         MVC   MODEL,=X'21202020'  GET EDIT PATTERN        *DHA 04/92*\n         ED    MODEL,CVTMDL        EDIT MODEL              *DHA 04/92*\n         DROP  R1\n         LA    R1,MODEL            R1 -> MODEL             *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        CVT      - Communications Vector Table Prefix\n*----------------------------------------------------------------------\nBCPFMID  SHOW  BLOCK=CVTFIX,FIELD=CVTPRODI                 *DHA 04/92*\nBCPLEVEL SHOW  BLOCK=CVTFIX,FIELD=CVTPRODN                 *LBD 04/91*\nOSREL    SHOW  BLOCK=CVTFIX,FIELD=CVTRELNO                 *LBD 03/84*\nSYSNAME  SHOW  BLOCK=CVTFIX,FIELD=CVTSNAME                 *LBD 03/84*\nVERID    SHOW  BLOCK=CVTFIX,FIELD=CVTVERID                 *LBD 03/84*\n         L     R1,CVTPTR           POINT TO CVT            *LBD 03/84*\n         LA    R0,CVTMAP-CVTFIX    GET LENGTH OF CVT PREFIX*DHA 04/92*\n         SR    R1,R0               R1 -> CVTFIX            *DHA 04/92*\n         B     FOUND                                       *DHA 04/90*\n         EJECT\n*----------------------------------------------------------------------\n*        CVT      - Communications Vector Table\n*----------------------------------------------------------------------\nCPU      SHOW  BLOCK=CVTMAP,FIELD=CVTSNAME                 *DHA 04/90*\n         L     R1,CVTPTR           R1 -> CVTMAP             *LBD 06/89*\n         B     FOUND                                       *DHA 04/90*\n         EJECT\n*----------------------------------------------------------------------\n*        CVT      - Communications Vector Table\n*----------------------------------------------------------------------\nOPSYS    SHOW  BLOCK=MVSOSLEV,FIELD=MVS                    *DHA 04/90*\nOS       SHOW  BLOCK=MVSOSLEV,FIELD=OSLEVEL                *DHA 04/90*\nOSLEV    SHOW  BLOCK=MVSOSLEV,FIELD=OSLEVEL                *DHA 04/90*\n         L     R3,CVTPTR                                   *DHA 04/90*\n         USING CVTMAP,R3                                   *DHA 04/90*\n         LA    R1,MVS370           R1 -> MVSOSLEV (370)    *DHA 04/90*\n         AIF   (&SYSSPLV EQ 1).OS                          *DHA 04/92*\n         TM    CVTDCB,CVTMVSE     XA IF ON                  *LBD 05/89*\n         BZ    FOUND                                       *DHA 04/90*\n         LA    R1,MVSXA            R1 -> MVSOSLEV (XA)     *DHA 04/90*\n         AIF   (&SYSSPLV EQ 2).OS                          *DHA 04/92*\n         TM    CVTOSLV0,CVTXAX    TEST FOR ESA              *LBD 05/89*\n         BZ    FOUND                                        *DHA 04/92*\n         LA    R1,MVSESA           R1 -> MVSOSLEV (ESA)    *DHA 04/90*\n.OS      ANOP                                              *DHA 04/92*\n         B     FOUND                                       *DHA 04/90*\n         DROP  R3                                          *DHA 04/90*\nMVSOSLEV DSECT                                             *DHA 04/92*\nMVS      DS    0CL7                MVS/XXX                 *DHA 04/92*\n         DS    CL4                 MVS/                    *DHA 04/92*\nOSLEVEL  DS    CL3                 XXX (370, XA, ESA)      *DHA 04/92*\nSHOW     CSECT                                             *DHA 04/92*\nMVSESA   DC    CL7'MVS/ESA'                                 *LBD 05/89*\nMVSXA    DC    CL7'MVS/XA'                                  *LBD 05/89*\nMVS370   DC    CL7'MVS/370'                                 *LBD 05/89*\n         EJECT\n*----------------------------------------------------------------------\n*        CVT      - Communications Vector Table\n*----------------------------------------------------------------------\nREALSTOR SHOW  BLOCK=WORKAREA,FIELD=REALSIZE,WORK=YES      *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R1                                   *DHA 04/92*\n         L     R2,CVTRLSTG         REAL STORAGE AT IPL (K) *DHA 04/92*\n         SRL   R2,10               CONVERT KILO TO MEG     *DHA 04/92*\n         CVD   R2,REALDEC          CONVERT TO DECIMAL      *DHA 04/92*\n         MVC   REALSIZE,REALPTRN   COPY EDIT PATTERN       *DHA 04/92*\n         ED    REALEDIT,REALDEC    EDIT VALUE              *DHA 04/92*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\nREALPTRN DC    C' ',13X'20',X'2120',C'M'                   *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEESMCA  - SMF Control Table\n*----------------------------------------------------------------------\nSMFID    SHOW  BLOCK=SMCABASE,FIELD=SMCASID                *LBD 06/89*\nSYSID    SHOW  BLOCK=SMCABASE,FIELD=SMCASID                *LBD 03/84*\n         L     R1,CVTPTR           POINT TO CVT            *LBD 03/84*\n         USING CVTMAP,R1                                   *LBD 03/84*\n         L     R1,CVTSMCA          R1 -> SMCABASE          *LBD 03/84*\n         DROP  R1                                          *DHA 04/92*\n         USING SMCABASE,R1                                 *DHA 04/92*\n         CLC   SMCASMCA,=C'SMCA'   VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         DROP  R1                                          *LBD 03/84*\n         B     FOUND                                       *DHA 04/90*\n         EJECT\n*----------------------------------------------------------------------\n*        IEESMCA  - SMF Control Table - IPL Date\n*----------------------------------------------------------------------\nIPLDATE  SHOW  BLOCK=WORKAREA,FIELD=XDATE,WORK=YES         *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R1                                   *DHA 04/92*\n         L     R1,CVTSMCA          R1 -> SMCABASE          *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING SMCABASE,R1                                 *DHA 04/92*\n         CLC   SMCASMCA,=C'SMCA'   VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         L     R1,SMCAIDTE         R1 = IPL DATE           *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         MVC   T001BL,T001BLC          INITIALIZE TABLE    *DHA 04/92*\n         ZAP   MX001M,=P'01'           INITIALIZE MONTH\n         ZAP   T001BL+2(2),=P'28'      INITIALIZE FEB\n         ST    R1,R1001ST              STORE JULIAN DATE\n         XC    W001X,W001X             ZERO WORK AREA\n         MVC   W001X+3(1),R1001ST+1    MOVE YEAR INTO WORK\n         L     R1,W001X                LOAD YEAR INTO REGISTER\n         SLL   R1,4                    SHIFT LEFT 1/2 BYTE\n         ST    R1,W001X                STORE YEAR INTO WORK AGAIN\n         OI    W001X+3,X'0F'           CONVERT YEAR INTO PACKED FORMAT\n         ZAP   YR001X,W001X            SAVE YEAR\n         DP    W001X,=P'04'            DIVIDE YEAR BY 4\n         CP    W001X+2(2),=P'00'       IF REMAINDER THEN LEAP YEAR\n         BNE   XNOLEAPX                NOT A LEAP YEAR\n         ZAP   T001BL+2(2),=P'29'      SET MONTH 2 EQUAL TO 29 DAYS\nXNOLEAPX LA    1,T001BL                SET POINTER TO MONTH TABLE\n         L     2,=F'02'                SET COUNTER\n         LA    3,MX001M-1              SET POINTER TO END OF TABLE\nXCPR01   CP    R1001ST+2(2),0(2,1)     COMPARE DAYS TO MONTH DABLE\n         BNH   XDATEX                  LESS THAN TABLE\n         AP    MX001M,=P'01'           INCRIMENT MONTH COUNTER\n         SP    R1001ST+2(2),0(2,1)     SUB TABLE DAY FORM JULIAN DAY\n         BXLE  1,2,XCPR01              CONTINUE SCAN\nXDATEX   ZAP   DYXX,R1001ST+2(2)       SET DAY\n         UNPK  W001X,DYXX              UNPACK DAY\n         OI    W001X+3,X'F0'           RESET SIGN\n         MVC   XD1(2),W001X+2          MOVE DAY TO O/P AREA\n         UNPK  W001X,MX001M            UNPACK MONTH\n         OI    W001X+3,X'F0'           RESET SIGN\n         MVC   XM1(2),W001X+2          MOVE MONTH TO O/P AREA\n         UNPK  W001X,YR001X            UNPACK YEAR\n         OI    W001X+3,X'F0'           RESER SIGN\n         MVC   XY1(2),W001X+2          MOVE YEAR TO O/P AREA\n         MVI   XMD1,C'/'                                   *DHA 04/92*\n         MVI   XDY1,C'/'                                   *DHA 04/92*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\nT001BLC  DS    0XL24                   MONTH TABLE\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         EJECT\n*----------------------------------------------------------------------\n*        IEESMCA  - SMF Control Table - IPL Time\n*----------------------------------------------------------------------\nIPLTIME  SHOW  BLOCK=WORKAREA,FIELD=@TIME,WORK=YES         *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R1                                   *DHA 04/92*\n         L     R1,CVTSMCA          R1 -> SMCABASE          *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING SMCABASE,R1                                 *DHA 04/92*\n         CLC   SMCASMCA,=C'SMCA'   VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         L     R7,SMCAITME         R1 = IPL TIME           *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         MVI   @HRS+4,C'.'\n         MVI   @MIN+2,C'.'\n         SR    R6,R6                    CLEAR R6\n         D     R6,=F'100'               DIVIDE OUT 100TH SEC\n         SR    R6,R6\n         D     R6,=F'60'                DIVIDE OUT SECONDS\n         LR    R5,R6                    STORE SEC IN R5\n         SR    R6,R6\n         D     R6,=F'60'                DIVIDE OUT MINUTES\n         CVD   R7,@DWORD                CVD\n         MVC   @TWORK,@TPAT               &\n         ED    @TWORK,@DWORD+5            EDIT\n         MVC   @HRS,@TWORK+2              @HRS\n         CVD   R6,@DWORD                CVD\n         MVC   @TWORK,@TPAT               &\n         ED    @TWORK,@DWORD+5            EDIT\n         MVC   @MIN,@TWORK+4             @MIN\n         CVD   R5,@DWORD                CVD\n         MVC   @TWORK,@TPAT               &\n         ED    @TWORK,@DWORD+5            EDIT\n         MVC   @SEC,@TWORK+4              SEC\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\n@TPAT    DC    X'402020212020'\n         EJECT\n*----------------------------------------------------------------------\n*        IEFAJCTB - Job Control Table (Priority)\n*----------------------------------------------------------------------\nPRTY     SHOW  BLOCK=WORKAREA,FIELD=PRTYVAL,WORK=YES       *DHA 04/90*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,PSATOLD          R1 -> CURRENT TASK CONTROL BLOCK\n         USING TCB,R1\n         L     R1,TCBJSCB          R1 -> JOB STEP CONTROL BLOCK\n         DROP  R1                                          *DHA 04/92*\n         USING IEZJSCB,R1\n         L     R1,JSCBJCT          R1 -> JOB CONTROL TABLE\n         DROP  R1                                          *DHA 04/92*\n         USING INJMJCT-16,R1\n         CLI   JCTIDENT,JCTID      VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         IC    R2,JCTJPRTY         LOAD JOB PRIORITY       *DHA 04/90*\n         DROP  R1                                          *DHA 04/92*\n         SRDL  R2,4                EXTRACT PRIORITY        *DHA 04/90*\n         SRL   R3,32-4             POSITION FOR DIVISION   *DHA 04/90*\n         CVD   R3,PRTYDWK          CONVERT TO DECIMAL      *DHA 04/90*\n         MVC   PRTYEDIT,=X'40202120'  EDIT PATTERN         *DHA 04/90*\n         ED    PRTYEDIT,PRTYDWK+6  CONVERT TO EBCDIC       *DHA 04/90*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/90*\n         B     FOUND                                       *DHA 04/90*\n         DROP  R13                                         *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFAJCTB - Job Control Table (SWA)\n*----------------------------------------------------------------------\nSWA      SHOW  BLOCK=SWASTAT,FIELD=SWASTAT                 *DHA 04/92*\n         L     R4,PSATOLD         -> TCB                   *DHA 04/92*\n         USING TCB,R4                                      *DHA 04/92*\n         L     R4,TCBJSCB           -> JSCB                *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\n         USING IEZJSCB,R4                                  *DHA 04/92*\n         L     R4,JSCBJCT               -> JCT             *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\n         USING INJMJCT-16,R4                               *DHA 04/92*\n         CLI   JCTIDENT,JCTID      VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         LA    R1,SWAABOVE         R1 -> SWASTAT (ABOVE)   *DHA 04/92*\n         TM    JCTSTAT2,JCTSWAUP   IS SWA ABOVE THE LINE?  *DHA 04/92*\n         BO    FOUND               YES, BRANCH             *DHA 04/92*\n         LA    R1,SWABELOW         R1 -> SWASTAT (BELOW)   *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\nSWASTAT  DS    0CL5                SWA STATUS              *DHA 04/92*\nSWAABOVE DC    CL5'ABOVE'                                  *DHA 04/92*\nSWABELOW DC    CL5'BELOW'                                  *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFJESCT - JES Communication Table Extension\n*----------------------------------------------------------------------\n         AIF   (&SYSSPLV LT 3).SMS                         *DHA 04/92*\nSMS      SHOW  BLOCK=SMSSTAT,FIELD=SMSSTAT                 *DHA 04/92*\n         L     R2,CVTPTR           POINT TO CVT            *LBD 01/91*\n         USING CVTMAP,R2                                   *LBD 01/91*\n         L     R2,CVTJESCT         POINT TO JES CONTROL TBL*LBD 01/91*\n         DROP  R2                                          *DHA 04/92*\n         USING JESCT,R2                                    *LBD 01/91*\n         L     R2,JESCTEXT         POINT JESCT EXTENSION   *LBD 01/91*\n         DROP  R2                                          *DHA 04/92*\n         USING JESPEXT,R2                                  *LBD 01/91*\n         CLC   JESSID,=C'JESPEXT'  CHECK VALIDITY          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         LA    R1,SMSON            R1 -> SMSSTAT (ON)      *DHA 04/92*\n         CLC   JESSMSIB,=F'0'     SMS ENABLED ?            *LBD 01/91*\n         BNE   FOUND               YES, BRANCH             *DHA 04/92*\n         LA    R1,SMSOFF           R1 -> SMSSTAT (OFF)     *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R2                                          *LBD 01/91*\nSMSSTAT  DS    0CL3                SMS STATUS              *DHA 04/92*\nSMSON    DC    CL3'ON'                                     *DHA 04/92*\nSMSOFF   DC    CL3'OFF'                                    *DHA 04/92*\n.SMS     ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFJSCVT - BDT Subsystem Communications Vector Table\n*----------------------------------------------------------------------\n         AIF   (NOT &JES3).JES3B                           *DHA 04/92*\nBDTNODE  SHOW  BLOCK=USVTBGN,FIELD=USVTNDID               *LBD 06/84*\n         L     R1,CVTPTR                                  *LBD 06/84*\n         USING CVTMAP,R1                                  *LBD 07/84*\n         L     R1,CVTJESCT             -> JESCT           *LBD 06/84*\n         DROP  R1                                          *DHA 04/92*\n         USING JESCT,R1                                   *LBD 07/84*\n         L     R7,JESSSCT              -> SSCVT           *LBD 06/84*\n         USING SSCTBEGN,R7                                *LBD 06/84*\nDONODE   DS    0H                                         *LBD 06/84*\n         CLC   SSCTSNAM,=C'JES3'  JES3 ?                    *LBD 02/88*\n         BE    NSSCT              YES - SKIP                *LBD 02/88*\n         CLC   SSCTSUSE,=F'0'     NULL SSCTSUSE ?           *LBD 02/88*\n         BE    NSSCT              YES                       *LBD 02/88*\n         L     R1,SSCTSUSE                                *LBD 06/84*\n         CLC   =C'USVT',0(R1)          BDT USVT ?         *LBD 07/84*\n         BNE   NSSCT                   NO - KEEP LOOKING  *LBD 07/84*\n         USING USVTBGN,R1                                 *LBD 06/84*\nUSVTDEF  EQU   BIT2               * SYMBOL REMOVED OZ80124 *LBD 12/85*\n         TM    USVTFLGS,USVTDEF        DEFAULT BDT        *LBD 06/84*\n         BZ    NSSCT                   NO - KEEP GOING    *LBD 06/84*\n         B     FOUND                                      *LBD 06/84*\nNSSCT    DS    0H                                         *LBD 06/84*\n         ICM   R7,15,SSCTSCTA      POINT TO NEXT SSCVT    *DHA 04/92*\n         BNZ   DONODE              BRANCH IF PRESENT      *LBD 06/84*\n         B     INVALID             BRANCH IF END OF CHAIN   *DHA 04/92*\n         DROP  R1,R7                                      *LBD 06/84*\n.JES3B   ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFJSSIB - Subsystem Identification Block\n*----------------------------------------------------------------------\nJOBID    SHOW  BLOCK=SSIBEGIN,FIELD=SSIBJBID               *LBD 12/89*\n         L     R1,PSATOLD         -> CURRENT TCB WORD LIST *LBD 12/89*\n         USING TCB,R1                                      *LBD 12/89*\n         L     R1,TCBJSCB         -> JSCB                  *LBD 12/89*\n         DROP  R1                                          *DHA 04/92*\n         USING IEZJSCB,R1                                  *LBD 12/89*\n         L     R1,JSCBSSIB        -> SSIBEGIN              *LBD 12/89*\n         DROP  R1                                          *DHA 04/92*\n         USING SSIBEGIN,R1                                 *LBD 12/89*\n         CLC   SSIBID,=C'SSIB'    VALIDITY CHECK           *LBD 12/89*\n         BNE   INVALID                                     *LBD 12/89*\n         DROP  R1                                          *LBD 12/89*\n         B     FOUND                                       *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFTIOT1 - Task Input/Output Table                *DHA 04/92*\n*----------------------------------------------------------------------\nJOBNAME  SHOW  BLOCK=TIOT1,FIELD=TIOCNJOB                  *DHA 04/92*\n         L     R1,PSATOLD          POINT TO CURRENT TCB    *DHA 04/92*\n         USING TCB,R1                                      *DHA 04/92*\n         L     R1,TCBTIO           R1 -> TIOT1             *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IEFUCBOB - System Residence UCB                   *DHA 04/92*\n*----------------------------------------------------------------------\nSYSRES   SHOW  BLOCK=UCBOB,FIELD=UCBVOLI                   *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R1                                   *DHA 04/92*\n         L     R1,CVTSYSAD         R1 -> UCBOB             *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IHAACEE  - Accessor Environment Element           *DHA 04/92*\n*----------------------------------------------------------------------\nTERMINAL SHOW  BLOCK=ACEE,FIELD=ACEETRID                   *DHA 04/92*\nUSERID   SHOW  BLOCK=ACEE,FIELD=ACEEUSRI                   *DHA 04/92*\n         L     R1,PSAAOLD          POINT TO ASCB           *DHA 04/92*\n         USING ASCB,R1                                     *DHA 04/92*\n         L     R1,ASCBASXB         POINT TO ASXB           *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING ASXB,R1                                     *DHA 04/92*\n         L     R1,ASXBSENV         R1 -> ACEE              *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING ACEE,R1                                     *DHA 04/92*\n         CLC   ACEEACEE,=C'ACEE'   VALIDITY CHECK          *DHA 04/92*\n         BE    FOUND                                       *DHA 04/92*\n         BNE   INVALID                                     *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IHADFA   - Data Facilities Area\n*----------------------------------------------------------------------\nDFPLEVEL SHOW  BLOCK=WORKAREA,FIELD=DFPLEV,WORK=YES        *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R1,CVTPTR           POINT TO CVT            *LBD 04/91*\n         USING CVTMAP,R1\n         L     R1,CVTDFA             POINT TO DFA          *LBD 04/91*\n         DROP  R1                                          *DHA 04/92*\n         USING DFA,R1\n         CLC   DFAACRON,=C'DFA '   CHECK VALIDITY          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         MVC   DFPLEV,DFPLEVPT     MOVE EDIT PATTERN       *DHA 04/92*\n         ED    DFPLEV,DFAREL          EDIT DFP LEVEL       *DHA 04/92*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R1\n         DROP  R13                                         *DHA 04/92*\nDFPLEVPT DC    X'214B204B20'       EDIT PATTERN            *LBD 04/91*\n         EJECT\n*----------------------------------------------------------------------\n*        IHALDA   - Local Data Area\n*----------------------------------------------------------------------\nREGION   SHOW  BLOCK=WORKAREA,FIELD=REGSIZE,WORK=YES       *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R2,PSAAOLD          -> TO MY ASCB           *DHA 04/92*\n         USING ASCB,R2                                     *LBD 08/85*\n         L     R2,ASCBLDA       -> LDA                     *LBD 08/85*\n         DROP  R2                                          *LBD 08/85*\n         USING LDA,R2                                      *LBD 08/85*\n         CLC   LDAID,=C'LDA '      VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF INVALID       *DHA 04/92*\n         L     R2,LDAREGRQ        REGION REQUESTED -XA-    *LBD 12/85*\n         DROP  R2                                          *LBD 08/85*\n         SRL   R2,10               REGION/1K               *LBD 08/85*\n         CVD   R2,REGDWK                                   *LBD 08/85*\n         MVC   REGSIZE,REGPTRN     COPY EDIT PATTERN + K   *DHA 04/92*\n         ED    REGEDIT,REGDWK      CONVERT TO EBCDIC       *DHA 04/92*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/90*\nREGPTRN  DC    C' ',13X'20',X'2120',C'K'                   *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IHAPCCA  - Physical Configuration Communication Area\n*----------------------------------------------------------------------\nCPUVER   SHOW  BLOCK=PCCA,FIELD=VERSION                    *DHA 04/92*\n         L     R3,CVTPTR                                   *DHA 04/92*\n         USING CVTMAP,R3                                   *DHA 04/92*\n         L     R3,CVTPCCAT         POINT TO PCCAVT\n         DROP  R3                                          *DHA 04/92*\n         USING PCCAVT,R3\n         LA    R6,L'PCCAT00P       LENGTH OF ENTRY         *DHA 04/92*\n         LA    R7,PCCAT15P         POINT TO LAST ENTRY     *DHA 04/92*\nCPUMOD1  EQU   *                                           *DHA 04/92*\n         ICM   R1,15,PCCAVT        R1 -> PCCA              *DHA 04/92*\n         BNZ   CPUMOD2             BRANCH IF IT EXISTS     *DHA 04/92*\n         BXLE  R3,R6,CPUMOD1       LOOP TO NEXT ENTRY      *DHA 04/92*\n         B     INVALID             BRANCH IN NO ENTRY      *DHA 04/92*\nCPUMOD2  EQU   *                                           *DHA 04/92*\n         USING PCCA,R1                                     *DHA 04/92*\n         CLC   PCCAPCCA,=C'PCCA'   VALID PCCA?             *DHA 04/92*\n         BE    FOUND               YES, FOUND              *DHA 04/92*\n         BNE   INVALID             NO, INVALID             *DHA 04/92*\n         DROP  R3                                          *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IHAPCCA  - Physical Configuration Communication Area\n*----------------------------------------------------------------------\nCPUSER   SHOW  BLOCK=WORKAREA,FIELD=SERIALS,WORK=YES       *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         L     R3,CVTPTR                                   *DHA 04/92*\n         USING CVTMAP,R3                                   *DHA 04/92*\n         L     R3,CVTPCCAT         POINT TO PCCAVT\n         DROP  R3                                          *DHA 04/92*\n         USING PCCAVT,R3\n         LA    R6,L'PCCAT00P       LENGTH OF ENTRY         *DHA 04/92*\n         LA    R7,PCCAT15P         POINT TO LAST ENTRY     *DHA 04/92*\n         LA    R1,SERIALS          POINT TO CPU SERIALS    *DHA 04/92*\nCPUSER1  EQU   *                                           *DHA 04/92*\n         ICM   R2,15,PCCAVT        R2 -> PCCA              *DHA 04/92*\n         BZ    CPUSER2             BRANCH IF NO ENTRY      *DHA 04/92*\n         USING PCCA,R2                                     *DHA 04/92*\n         CLC   PCCAPCCA,=C'PCCA'   VALID PCCA?             *DHA 04/92*\n         BNE   INVALID             NO, BRANCH              *DHA 04/92*\n         MVC   0(L'SERIAL,R1),PCCACPID+2  MOVE CPU SERIAL  *DHA 04/92*\n         LA    R1,L'SERIAL+1(,R1)  POINT TO NEXT SLOT      *DHA 04/92*\nCPUSER2  EQU   *                                           *DHA 04/92*\n         BXLE  R3,R6,CPUSER1       LOOP TO NEXT ENTRY      *DHA 04/92*\n         LA    R1,WORKAREA         R1 -> WORKAREA          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\n         DROP  R3                                          *DHA 04/92*\n         DROP  R13                                         *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IHASCCB  - Service Call Control Block             *DHA 04/92*\n*----------------------------------------------------------------------\nLPAR     SHOW  BLOCK=LPARSTAT,FIELD=LPARSTAT               *DHA 04/92*\n         L     R4,CVTPTR          -> CVT                    *LBD 11/88*\n         USING CVTMAP,R4                                   *DHA 04/92*\n         ICM   R4,15,CVTSCPIN        -> SCCP                *LBD 11/88*\n         BZ    INVALID            NO SCCP                   *LBD 11/88*\n         DROP  R4                                          *DHA 04/92*\n         USING SCCB,R4                                      *LBD 11/88*\n         LA    R1,LPARYES          R1 -> LPARSTAT (YES)    *DHA 04/92*\n         TM    SCCBCON1,SCCBBFY   LPAR MODE ?               *LBD 11/88*\n         BO    FOUND                                       *DHA 04/92*\n         LA    R1,LPARNO           R1 -> LPARSTAT (NO)     *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\nLPARSTAT DS    0CL3                                        *DHA 04/92*\nLPARYES  DC    CL3'YES'                                    *DHA 04/92*\nLPARNO   DC    CL3'NO'                                     *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IKJPSCB  - TSO Protected Step Control Block\n*----------------------------------------------------------------------\nDEST     SHOW  BLOCK=PSCB,FIELD=PSCBDEST                   *DHA 04/92*\nTSOUNIT  SHOW  BLOCK=PSCB,FIELD=PSCBGPNM                   *DHA 04/92*\n         L     R1,PSATOLD          -> TCB                  *DHA 04/92*\n         USING TCB,R1                                      *DHA 04/92*\n         L     R1,TCBJSCB          -> JSCB                 *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         USING IEZJSCB,R1                                  *DHA 04/92*\n         L     R1,JSCBPSCB         R1 -> PSCB              *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        IKJPSCB  - TSO Protected Step Control Block (OPER)\n*----------------------------------------------------------------------\nTSOOPER  SHOW  BLOCK=OPERAUTH,FIELD=OPERAUTH               *DHA 04/92*\n         L     R4,PSATOLD          -> TCB                  *DHA 04/92*\n         USING TCB,R4                                      *DHA 04/92*\n         L     R4,TCBJSCB          -> JSCB                 *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\n         USING IEZJSCB,R4                                  *DHA 04/92*\n         L     R4,JSCBPSCB         -> PSCB                 *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\n         USING PSCB,R4                                     *DHA 04/92*\n         LA    R1,NOOPER           R1 -> OPERAUTH (NOOPER) *DHA 04/90*\n         TM    PSCBATR1,PSCBCTRL   OPERATOR AUTHORITY?     *DHA 04/92*\n         BZ    FOUND               NO                      *DHA 04/92*\n         LA    R1,OPER             R1 -> OPERAUTH (OPER)   *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R4                                          *DHA 04/92*\nOPERAUTH DS    0CL6                TSO OPERATOR AUTHORITY  *DHA 04/92*\nOPER     DC    CL6'OPER'                                   *DHA 04/92*\nNOOPER   DC    CL6'NOOPER'                                 *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        ILRASMVT - CLPA (Not Quick Start)                 *DHA 04/92*\n*----------------------------------------------------------------------\nCLPA     SHOW  BLOCK=CLPASTAT,FIELD=CLPASTAT               *DHA 04/92*\n         L     R2,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R2                                   *DHA 04/92*\n         L     R2,CVTASMVT         POINT TO ASMVT          *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\n         USING ASMVT,R2                                    *DHA 04/92*\n         LA    R1,CLPAYES          R1 -> CLPASTAT (YES)    *DHA 04/92*\n         TM    ASMFLAG2,ASMQUICK   QUICK START?            *DHA 04/92*\n         BZ    FOUND               NO, CLPA                *DHA 04/92*\n         LA    R1,CLPANO           R1 -> CLPASTAT (NO)     *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\nCLPASTAT DS    0CL3                CLPA STATUS             *DHA 04/92*\nCLPAYES  DC    CL3'YES'                                    *DHA 04/92*\nCLPANO   DC    CL3'NO'                                     *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        ILRASMVT - CVIO (Not Warm Start)                  *DHA 04/92*\n*----------------------------------------------------------------------\nCVIO     SHOW  BLOCK=CVIOSTAT,FIELD=CVIOSTAT               *DHA 04/92*\n         L     R2,CVTPTR           POINT TO CVT            *DHA 04/92*\n         USING CVTMAP,R2                                   *DHA 04/92*\n         L     R2,CVTASMVT         POINT TO ASMVT          *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\n         USING ASMVT,R2                                    *DHA 04/92*\n         LA    R1,CVIOYES          R1 -> CVIOSTAT (YES)    *DHA 04/92*\n         TM    ASMFLAG2,ASMWARM    WARM START?             *DHA 04/92*\n         BZ    FOUND               NO, CVIO                *DHA 04/92*\n         LA    R1,CVIONO           R1 -> CVIOSTAT (NO)     *DHA 04/92*\n         B     FOUND                                       *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\nCVIOSTAT DS    0CL3                CVIO STATUS             *DHA 04/92*\nCVIOYES  DC    CL3'YES'                                    *DHA 04/92*\nCVIONO   DC    CL3'NO'                                     *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        LIDREC   - ACF2 Logon ID Record\n*----------------------------------------------------------------------\n         AIF   (NOT &ACF2).ACF2C                           *DHA 04/92*\nACCTNO#  SHOW  BLOCK=LIDREC,FIELD=LIDACCT#                 *LBD 12/86*\nACF2ACCT SHOW  BLOCK=LIDREC,FIELD=LIDACCT                  *LBD 02/84*\nCOMPMAIL SHOW  BLOCK=LIDREC,FIELD=LIDUMAIL                 *LBD 06/86*\nDEPT     SHOW  BLOCK=LIDREC,FIELD=LIDDEPT                  *LBD 02/84*\nFDS#     SHOW  BLOCK=LIDREC,FIELD=LIDFDS#                  *LBD 12/86*\nGROUP    SHOW  BLOCK=LIDREC,FIELD=LIDGRP                   *DHA 04/92*\nGRP      SHOW  BLOCK=LIDREC,FIELD=LIDGRP                   *DHA 04/92*\nHOMEDIV  SHOW  BLOCK=LIDREC,FIELD=LIDHMED                  *LBD 10/90*\nJOBFUNC  SHOW  BLOCK=LIDREC,FIELD=LIDJOBF                 *LBD 10/84*\nLOC      SHOW  BLOCK=LIDREC,FIELD=LIDLOCAT                 *LBD 02/84*\nMAIL     SHOW  BLOCK=LIDREC,FIELD=LIDMAILC                 *LBD 02/84*\nNAME     SHOW  BLOCK=LIDREC,FIELD=LIDNAME                  *LBD 02/84*\nPHONE    SHOW  BLOCK=LIDREC,FIELD=LIDPHONE                 *LBD 02/84*\n         ACFINCVT R6,NONE=INVALID                          *LBD 02/84*\n         USING ACCVT,R6           ADDRESSABILITY           *LBD 02/84*\n         ACFGUCB R7,NONE=INVALID,INLINE=YES                *DHA 04/92*\n         DROP  R6                                          *LBD 02/84*\n         USING ACUCB,R7                                    *LBD 02/84*\n         L     R1,ACULRECP         R1 -> LIDREC            *LBD 02/84*\n         DROP  R7                                          *LBD 02/84*\n         B     FOUND                                       *DHA 04/92*\n.ACF2C   ANOP                                              *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        RATYJCD  - Rockwell ACT Accounting Field\n*----------------------------------------------------------------------\n         AIF   (NOT &ROCKWELL).ROCKWELL2                   *DHA 04/92*\nACCT     SHOW  BLOCK=ABSTART,FIELD=FDSACCT                 *LBD 06/89*\nACCTNO   SHOW  BLOCK=ABSTART,FIELD=ABACCTNO                *LBD 02/84*\nCRTCD    SHOW  BLOCK=ABSTART,FIELD=ABCRTCD\nFDS      SHOW  BLOCK=ABSTART,FIELD=ABFDS                   *LBD 02/84*\nFRAMES   SHOW  BLOCK=ABSTART,FIELD=ABFRAMES\nLINES    SHOW  BLOCK=ABSTART,FIELD=ABLINES\n         L     R1,PSATOLD          R1 -> CURRENT TASK CONTROL BLOCK\n         USING TCB,R1\n         L     R1,TCBJSCB          R1 -> JOB STEP CONTROL BLOCK\n         DROP  R1                                          *DHA 04/92*\n         USING IEZJSCB,R1\n         L     R1,JSCBJCT          R1 -> JOB CONTROL TABLE\n         DROP  R1                                          *DHA 04/92*\n         USING INJMJCT-16,R1\n         ICM   R1,B'0111',JCTACTAD R1 -> ACCOUNT CONTROL TABLE\n         DROP  R1                                          *DHA 04/92*\n         USING IEFAACTB-16,R1\n         CLI   ACTIDENT,ACTID      VALIDITY CHECK          *DHA 04/92*\n         BNE   INVALID             BRANCH IF FAILURE\n         CLI   ACTACCNT,ABSIZE     VALIDITY CHECK\n         BNE   INVALID             BRANCH IF FAILURE\n         LA    R1,ACTACCNT+1       R1 -> ABSTART\n         DROP  R1\n         B     FOUND                                       *LBD 02/84*\n.ROCKWELL2 ANOP                                            *DHA 04/92*\n         EJECT\n*----------------------------------------------------------------------\n*        RCVT     - Rockwell Communications Vector Table\n*----------------------------------------------------------------------\n         AIF   (NOT &ROCKWELL).ROCKWELL3                   *DHA 04/92*\nCENTER   SHOW  BLOCK=RCVT,FIELD=RCVTHOME                   *DHA 04/90*\n         L     R1,CVTPTR           POINT TO CVT            *LBD 04/84*\n         USING CVTMAP,R1                                   *LBD 04/84*\n         ICM   R1,15,CVTUSER      R1 -> RCVT               *DHA 04/92*\n         DROP  R1                                          *LBD 04/84*\n         BZ    INVALID             BRANCH IF ABSENT        *DHA 04/92*\n         USING RCVT,R1                                     *DHA 04/92*\n         CLC   RCVTID,=C'RCVT'     VALID?                  *DHA 04/92*\n         BE    FOUND               YES, BRANCH             *DHA 04/92*\n         BNE   INVALID             NO, BRANCH              *DHA 04/92*\n         DROP  R1                                          *DHA 04/92*\n.ROCKWELL3 ANOP                                            *DHA 04/92*\n         EJECT                                            *\n***********************************************************************\n*\n*        Section 6 - Termination\n*\n*              Strip leading and trailing blanks and nulls from VALUE.\n*              Store length in OVALUE.\n*              Insure ILENGTH is not exceeded.\n*              Move requested information to VALUE.\n*\n***********************************************************************\nFOUND    DS    0H                                          *LBD 02/84*\n         LH    R2,SHOWFLDL         R2 = OLENGTH            *DHA 04/92*\nFOUNDLEN DS    0H                                          *DHA 04/90*\n         LTR   R2,R2               NULL STRING?            *DHA 04/92*\n         BZ    STORE               YES, BRANCH             *DHA 04/92*\n         AH    R1,SHOWFLD          R1 -> REQUESTED SUBFIELD\nLEADING  DS    0H                                          *DHA 04/92*\n         TM    0(R1),X'FF'-C' '    LEADING BLANK OR NULL?  *DHA 04/92*\n         BNZ   TRAILING            NO, BRANCH              *DHA 04/92*\n         LA    R1,1(,R1)           YES, INCREMENT POINTER  *DHA 04/92*\n         BCT   R2,LEADING          DECREMENT LENGTH        *DHA 04/92*\n         B     NORMAL              BRANCH, NULL STRING     *DHA 04/92*\nTRAILING DS    0H                                          *DHA 04/92*\n         LR    R3,R2               R3 = LENGTH             *DHA 04/92*\n         BCTR  R3,0                R3 = LENGTH-1           *DHA 04/92*\n         LA    R4,0(R3,R1)         POINT TO LAST BYTE      *DHA 04/92*\n         TM    0(R4),X'FF'-C' '    TRAILING BLANK OR NULL? *DHA 04/92*\n         BNZ   STORE               NO, BRANCH              *DHA 04/92*\n         BCT   R2,TRAILING         DECREMENT LENGTH        *DHA 04/92*\nSTORE    DS    0H                                          *DHA 04/92*\n         ST    R2,OLENGTH          STORE OLENGTH\n         LA    R4,VALUE            POINT TO TARGET         *DHA 04/92*\n         LR    R5,R11              GET LENGTH OF TARGET    *DHA 04/92*\n         LR    R6,R1               POINT TO SOURCE         *DHA 04/92*\n         LR    R7,R2               GET LENGTH OF SOURCE    *DHA 04/92*\n         ICM   R7,8,=C' '          PAD = BLANK             *DHA 04/92*\n         MVCL  R4,R6               COPY SOURCE TO TARGET   *DHA 04/92*\n         BNL   NORMAL              NORMAL RETURN           *DHA 04/92*\n         BL    TRUNCATE            BRANCH, TRUNCATION      *DHA 04/92*\n         EJECT\n***********************************************************************\n*        RETURN\n***********************************************************************\nINVALID  DS    0H                  VALIDITY CHECK FAILED\n         LA    R15,16              RETURN CODE = 16\n         B     RETURN\nARGERROR DS    0H                  CALLER ARGUMENT LIST ERROR\n         LA    R15,12              RETURN CODE = 12\n         B     RETURN\nNOID     DS    0H                  ID NOT FOUND\n         LA    R15,8               RETURN CODE = 8\n         B     RETURN\nTRUNCATE DS    0H                  VALUE TRUNCATED\n         LA    R15,4               RETURN CODE = 4\n         B     RETURN\nNORMAL   DS    0H                  NORMAL COMPLETION\n         SR    R15,R15             RETURN CODE = 0\nRETURN   DS    0H\n         LTR   R8,R8               DOES TABLE ENTRY EXIST? *DHA 04/92*\n         BZ    RETURN1             NO, BRANCH              *DHA 04/90*\n         TM    SHOWFLAG,SHOWWORK   WAS GETMAIN ISSUED?     *DHA 04/90*\n         BZ    RETURN1             NO, BRANCH              *DHA 04/90*\n         LR    R2,R15              SAVE RETURN CODE        *DHA 04/90*\n         LR    R1,R13              UNCHAIN SAVE AREAS      *DHA 04/90*\n         L     R13,4(R1)           ...                     *DHA 04/90*\n         FREEMAIN RU,LV=4096,A=(1) FREE WORK AREA          *DHA 04/90*\n         LR    R15,R2              RESTORE RETURN CODE     *DHA 04/90*\nRETURN1  DS    0H                                          *DHA 04/90*\n         L     14,12(13,0)        RESTORE REGISTER 14      *LBD 12/89*\n         LM    0,12,20(13)        RESTORE THE REGISTERS    *LBD 12/89*\n         BSM   0,14               RETURN TO THE CALLER     *LBD 12/89*\n*                                                          *DHA 04/92*\n         DROP  R9\n         DROP  R10\n         DROP  R12\n         DROP  R0                                          *DHA 04/92*\n         EJECT\n***********************************************************************\n*        ID TABLE\n*              ENTRIES ARE FORMED BY SHOW MACRO CALLS IN THE PRECEDING\n*              ACTION ROUTINES.  THE TABLE IS USED BY THE BINARY SEARCH\n*              CODE IN THE PROLOG TO THE ACTION ROUTINES.\n***********************************************************************\nSHOWTBL  SHOWTBL SHOWTBLE\n         EJECT\n         END   SHOW\n>< ADD NAME=SHOWREXX 0100-92112-92115-1920-000171-000088-000000-$A1019\nSHOWREXX TITLE 'REXX FUNCTION INTERFACE TO SHOW'\n***********************************************************************\n*        REXX Function Interface to SHOW\n*\n*        Use: refer to SHOWREXX(id) or CALL SHOWREXX id,\n*        where \"id\" is a constant or variable which has a valid value\n*        for SHOW. \"id\" may be lowercase or uppercase.\n*\n*\n*\n*        Douglas H. Adams\n*        Mail code 110-SE28\n*        Information Systems Center\n*        Rockwell International Corporation\n*        2201 Seal Beach Boulevard\n*        P. O. Box 2515\n*        Seal Beach, California 90740-1515\n*\n*        (310) 797-2618\n*\n*        April 24, 1992\n*\n***********************************************************************\n         PUNCH ' ALIAS SHOWREXX'\nSHOWREXX CSECT\nSHOWREXX AMODE 31\nSHOWREXX RMODE ANY\n         EJECT\n         IRXEFPL                   REXX EXTERNAL FUNCTIONS PARM LIST\n         EJECT\n         IRXARGTB                  REXX ARGUMENT TABLE\n         EJECT\n         IRXENVB                   REXX ENVIRONMENT BLOCK\n         EJECT\n         IRXEVALB                  REXX EVALUATION BLOCK\n         EJECT\n         IRXEXTE                   REXX VECTOR OF EXTERNAL ENTRY POINTS\n         EJECT\n***********************************************************************\n*                                  WORK AREA FOR REENTRANCE\n***********************************************************************\nWORKAREA DSECT\nSAVE     DS    18F\nID       DS    CL8                 FUNCTION ARGUMENT\nCALL     CALL  ,(ID,ILENGTH,,),MF=L  SHOW PARAMETERS\nWORKSIZE EQU   *-WORKAREA\n         EJECT\n***********************************************************************\n*                                  INITIALIZATION\n***********************************************************************\nSHOWREXX CSECT\n         USING SHOWREXX,15\n         SAVE  (14,12)             SAVE REGISTER\n         MODID                     IDENTIFICATION\n         DROP  15\n         LR    12,15               SET BASE REGISTER\n         USING SHOWREXX,12\n         LR    10,0                SAVE ENVBLOCK POINTER\n         USING ENVBLOCK,10\n         LR    2,1                 SAVE EFPL POINTER\n         USING EFPL,2\n         LA    0,WORKSIZE          GET WORKAREA SIZE\n         GETMAIN RU,LV=(0)         GET WORKAREA STORAGE\n         USING WORKAREA,1\n         XC    WORKAREA(WORKSIZE),WORKAREA  CLEAR WORKAREA\n         ST    1,8(,13)            CHAIN SAVE AREAS\n         ST    13,SAVE+4\n         LR    13,1\n         DROP  1\n         USING WORKAREA,13\n***********************************************************************\n*                                  GET FUNCTION VALUE\n***********************************************************************\n         L     3,EFPLARG           POINT TO ARGUMENT TABLE\n         USING ARGTABLE_ENTRY,3\n         L     4,EFPLEVAL          POINT TO A(EVALUATION BLOCK)\n         L     4,0(,4)             POINT TO EVALUATION BLOCK\n         USING EVALBLOCK,4\n         L     5,ARGTABLE_ARGSTRING_PTR     POINT TO ARG\n         ICM   6,15,ARGTABLE_ARGSTRING_LENGTH  GET LENGTH OF ARG\n         BZ    ERROR3              NULL, BRANCH\n         BM    ERROR2              MISSING, BRANCH\n         C     6,=F'8'             IS ARG TOO BIG?\n         BH    ERROR3              YES, BRANCH\n         ICM   7,15,ARGTABLE_NEXT  IS THERE A SECOND ARG?\n         BNM   ERROR1              YES, BRANCH\n         MVC   ID,=CL8' '          SET ID TO BLANKS\n         BCTR  6,0                 GET MACHINE LENGTH OF ARG\n         EX    6,MVC               MOVE ARG TO ID\n         LA    7,EVALBLOCK_EVLEN   POINT TO OUTPUT LENGTH\n         LA    8,EVALBLOCK_EVDATA  POINT TO OUTPUT RESULT\n         ICM   15,15,=V(SHOW)      GET ENTRY POINT OF SHOW\n         BZ    LINK                BRANCH IF NOT RESOLVED\n         CALL  (15),(ID,ILENGTH,(8),(7)),VL,MF=(E,CALL)\n         B     TESTRET             GO TEST RETURN CODE\nLINK     EQU   *\n         LINK  EP=SHOW,PARAM=(ID,ILENGTH,(8),(7)),VL=1,MF=(E,CALL)\nTESTRET  EQU   *\n         LTR   15,15               SUCCESSFUL?\n         BZ    RETURN              YES, BRANCH\n         C     15,=F'8'            ID NOT SUPPORTED?\n         BE    ERROR3              YES, BRANCH\n         BNE   ERROR4              NO, OTHER ERROR\n***********************************************************************\n*                                  ERROR MESSAGE PROCESSING\n***********************************************************************\nERROR1   EQU   *\n         LA    1,ERRMSG1           MULTIPLE ARGUMENTS\n         B     ERRORSAY\nERROR2   EQU   *\n         LA    1,ERRMSG2           NO ARGUMENT\n         B     ERRORSAY\nERROR3   EQU   *\n         LA    1,ERRMSG3           UNSUPPORTED ARGUMENT\n         B     ERRORSAY\nERROR4   EQU   *\n         LA    1,ERRMSG4           INVALID ENVIRONMENT\n         B     ERRORSAY\nERRORSAY EQU   *\n         LR    0,10                POINT TO ENVIRONMENT BLOCK\n         L     15,ENVBLOCK_IRXEXTE POINT TO ENTRY POINT VECTOR\n         USING IRXEXTE,15\n         CLC   IRXEXTE_ENTRY_COUNT,=A((IRXSAY-IRXEXTE)/4) IRXSAY EXIST?\n         BL    RETURN              NO, BRANCH\n         L     15,IRXSAY           POINT TO SAY ROUTINE\n         DROP  15\n         CALL  (15),MF=(E,(1))     CALL IRXSAY\n         LA    15,4                UNSUCCESSFUL RETURN CODE\n***********************************************************************\n*                                  TERMINATION\n***********************************************************************\nRETURN   EQU   *\n         LR    1,13                POINT TO WORKAREA\n         L     13,SAVE+4           UNCHAIN SAVE AREAS\n         LR    2,15                SAVE RETURN CODE\n         LA    0,WORKSIZE          GET WORKAREA SIZE\n         FREEMAIN RU,LV=(0),A=(1)  FREE WORKAREA\n         LR    15,2                RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)    RETURN\n         EJECT\n***********************************************************************\n*                                  ERROR MESSAGES\n***********************************************************************\nERRMSG1  CALL  ,(WRITEERR,ERRPTR1,ERRLEN1),VL,MF=L\nERRPTR1  DC    A(ERRTXT1)\nERRLEN1  DC    A(L'ERRTXT1)\nERRTXT1  DC    C'Muliple arguments are not allowed for the SHOW functio*\n               n.'\n*\nERRMSG2  CALL  ,(WRITEERR,ERRPTR2,ERRLEN2),VL,MF=L\nERRPTR2  DC    A(ERRTXT2)\nERRLEN2  DC    A(L'ERRTXT2)\nERRTXT2  DC    C'No arguments were specified for the SHOW function.'\n*\nERRMSG3  CALL  ,(WRITEERR,ERRPTR3,ERRLEN3),VL,MF=L\nERRPTR3  DC    A(ERRTXT3)\nERRLEN3  DC    A(L'ERRTXT3)\nERRTXT3  DC    C'This ID is not supported for SHOW processing.'\n*\nERRMSG4  CALL  ,(WRITEERR,ERRPTR4,ERRLEN4),VL,MF=L\nERRPTR4  DC    A(ERRTXT4)\nERRLEN4  DC    A(L'ERRTXT4)\nERRTXT4  DC    C'Invalid environment detected by SHOW.'\n         EJECT\n***********************************************************************\n*                                  DATA\n***********************************************************************\nMVC      MVC   ID(0),0(5)          EXECUTED\nILENGTH  DC    F'250'              REXX EVALBLOCK_EVDATA LENGTH\nWRITEERR DC    CL8'WRITEERR'\n         END\n>< ADD NAME=SHOWSPF  0103-85344-92115-1618-000388-000368-000029-$A1019\nSHOWSPF  TITLE 'INFORMATION EXTRACTION SPF COMMAND'\n***********************************************************************\n*\n*              INFORMATION EXTRACTION SPF COMMAND\n*\n*        THIS IS AN INTERFACE TO THE INFORMATION EXTRACTION ROUTINE\n*        FOR SPF CLISTS UNDER SPF. IT IS INVOKED AS FOLLOWS:\n*\n*              ISPEXEC SELECT PGM(SHOWSPF) PARM(ID,NAME)\n*              ISPEXEC VGET NAME SHARED\n*\n*        ID   - MUST BE A VALID IDENTIFIER FOR THE SHOW ROUTINE.\n*        NAME - WILL BE USED TO CREATE A VARIABLE IN THE\n*               SPF SHARED VARIABLE POOL. THE VARIABLE WILL BE SET TO\n*               THE VALUE CORRESPONDING TO THE SHOW INDENTIFIER.\n*\n*\n*        Douglas H. Adams\n*        Mail Code 110-SE28\n*        Information Systems Center\n*        Rockwell International Corporation\n*        2201 Seal Beach Boulevard\n*        P. O. Box 2515\n*        Seal Beach, California 90740-1515\n*\n*        (310) 797-2618\n*\n*        April 24, 1992\n*\n***********************************************************************\n         PUNCH ' ALIAS SHOWSPF'\nSHOWSPF  CSECT\nSHOWSPF  AMODE 31\nSHOWSPF  RMODE ANY\n         EJECT\n         REGEQU ,                  REGISTER EQUATES\n         EJECT\n***********************************************************************\n*              PARAMETER\n***********************************************************************\nPARM     DSECT\nPARMSIZE DS    H                   LENGTH OF PARAMETER STRING\nPARMVAL  DS    CL100               PARAMETER CHARACTER STRING\n         EJECT\n***********************************************************************\n*              WORKING STORAGE\n***********************************************************************\nWORK     DSECT                     WORK AREA\nSAVE     DS    18F                 SAVE AREA\nNAMELIST DS    C'('                ISPLINK VPUT NAME LIST\nNAME     DS    CL8                 ISPLINK VPUT VARIABLE NAME\nNAMEEND  DS    C')'                END OF NAME LIST\nID       DS    CL8                 SHOW IDENTIFIER\nILENGTH  DS    A(L'VALUE)          SHOW VALUE INPUT LENGTH\nVALUE    DS    CL256               SHOW VALUE\nOLENGTH  DS    F                   SHOW VALUE OUTPUT LENGTH\nCALLSHOW CALL  ,                   CALL SHOW                           *\n               (ID,                ID                                  *\n               ILENGTH,            ILENGTH                             *\n               VALUE,              VALUE                               *\n               OLENGTH),           OLENGTH                             *\n               VL,                                                     *\n               MF=L\nDEFINE   CALL  ,                   CALL ISPLINK                        *\n               (,                  'VDEFINE'                           *\n               NAMELIST,           NAMELIST                            *\n               VALUE,              VALUE                               *\n               ,                   'CHAR'                              *\n               OLENGTH),           OLENGTH                             *\n               VL,                                                     *\n               MF=L\nDELETE   CALL  ,                   CALL ISPLINK                        *\n               (,                  'VDELETE'                           *\n               NAMELIST),          NAMELIST                            *\n               VL,                                                     *\n               MF=L\nPUT      CALL  ,                   CALL ISPLINK                        *\n               (,                  'VPUT'                              *\n               NAMELIST,           NAMELIST                            *\n               ),                  'SHARED'                            *\n               VL,                                                     *\n               MF=L\nWORKSIZE DS    0XL(*-WORK)         LENGTH OF WORK AREA\n         EJECT\n***********************************************************************\n*              INITIALIZATION\n***********************************************************************\nSHOWSPF  CSECT\n         USING SHOWSPF,R15\n         SAVE  (14,12)             SAVE REGISTERS\n         MODID ,                   IDENTIFICATION\n         DROP  R15\n         LR    R12,R15             R12 = BASE REGISTER\n         USING SHOWSPF,R12\n         L     R11,0(R1)           R11 -> PARM\n         USING PARM,R11\n         LA    R0,L'WORKSIZE       R0 = LENGTH OF WORK AREA\n         GETMAIN R,LV=(0)          GET MAIN STORAGE FOR WORK AREA\n         LR    R2,R1               R2 -> STORAGE\n         LA    R3,L'WORKSIZE       R3 = LENGTH OF STORAGE\n         SR    R5,R5               R5 = 0\n         MVCL  R2,R4               CLEAR WORK AREA\n         ST    R13,4(R1)           CHAIN SAVE AREAS\n         ST    R1,8(R13)           ...\n         LR    R13,R1              R13 -> WORKING STORAGE\n         USING WORK,R13\n         MVI   ID,C' '             ID = BLANK\n         MVC   ID+1(L'ID-1),ID     ...\n         MVI   NAME,C' '           NAME = BLANK\n         MVC   NAME+1(L'NAME-1),NAME ...\n         MVI   NAMELIST,C'('       NAMELIST = (NAME)\n         MVI   NAMEEND,C')'        ...\n         LA    R0,L'VALUE          ILENGTH = LENGTH OF VALUE\n         ST    R0,ILENGTH          ...\n         EJECT\n***********************************************************************\n*              PARSE PARAMETER STRING VIA SYNTAX MATRIX\n***********************************************************************\n*----------------------------------------------------------------------\n*        POINT TO BEGINNING OF INPUT STRING.\n*        POINT TO INITIAL ROW OF SYNTAX MATRIX.\n*----------------------------------------------------------------------\n         LH    R6,PARMSIZE         R6 = SIZE OF PARM FIELD\n         BNP   ARGERROR            BRANCH IF MISSING\n         BCTR  R6,0                R6 = SIZE - 1\n         LA    R1,PARMVAL          R1 -> PARAMETER STRING\n         BCTR  R1,0                R1 -> STRING - 1 FOR TRT\n         SR    R2,R2               R2 = 0 FOR TRT\n         LA    R4,MATRIX           R4 -> INITIAL MATRIX ROW\n*----------------------------------------------------------------------\n*        POINT TO NEXT INPUT CHARACTER\n*----------------------------------------------------------------------\nNEXT     DS    0H                  SCAN FOR NEXT PARAMETER\n         LA    R7,PARAMETR         R7 -> TRT TABLE FOR PARAMETER\nPOINT    DS    0H                  POINT TO NEXT INPUT CHARACTER\nCOMA2##  DS    0H                  COMMA AFTER DELIMITING BLANK\n         LTR   R6,R6               END OF PARAMETER STRING?\n         BM    PROCESS             YES, BRANCH\n         LA    R5,1(R1)            R5 -> NEXT INPUT CHARACTER\n*----------------------------------------------------------------------\n*        SCAN FOR NEXT SIGNIFICANT CHARACTER IN INPUT STRING.\n*        TRANSLATE CHARACTER TO ITS CATEGORY (MATRIX COLUMN NUMBER).\n*        CHECK FOR END OF PARAMETER STRING.\n*        OBTAIN MATRIX ELEMENT USING CURRENT ROW AND COLUMN.\n*        USE THAT ELEMENT AS NEW MATRIX ROW NUMBER.\n*        BRANCH TO ACTION ROUTINE INDEXED BY THAT ELEMENT.\n*----------------------------------------------------------------------\n         EX    R6,TRT              R1 -> DELIMITING CHARACTER\n*                                  R2 = MATRIX COLUMN NUMBER\n         BNZ   SET                 END OF INPUT STRING?\n         LA    R1,2(R6,R1)         R1 -> END OF INPUT STRING + 1\n         LA    R2,ENDOS            R2 = ENDING MATRIX COLUMN NUMBER\nSET      DS    0H\n         BCTR  R6,0                R6 = REMAINING LENGTH\n         AR    R6,R5               ...\n         SR    R6,R1               ...\n         SR    R3,R3               R3 = 0\n         IC    R3,0(R2,R4)         R3 = MATRIX ELEMENT\n         LR    R4,R3               R4 = NEW MATRIX ROW NUMBER\n         MH    R4,=Y(L'MATRIX)     R4 = NUMBER * MATRIX ROW LENGTH\n         LA    R4,MATRIX(R4)       R4 -> NEW MATRIX ROW\n         SLL   R3,2                R3 = BRANCH INDEX\n         B     ACTION(R3)          GO TO ACTION ROUTINE\n*\nTRT      TRT   1(0,R1),0(R7)       EXECUTED\n*----------------------------------------------------------------------\n*        BRANCH TABLE TO ACTION ROUTINES.\n*----------------------------------------------------------------------\nACTION   DS    0H\n         B     ABEND               SHOULD NEVER GET HERE\n         B     PARM1##             FIRST PARAMETER\n         B     BLNK1##             BLANK DELIMITING FIRST PARAMETER\n         B     COMA1##             COMMA DELIMITING FIRST PARAMETER\n         B     COMA2##             COMMA AFTER DELIMITING BLANK\n         B     PARM2##             SECOND PARAMETER\n         B     BLNK2##             BLANK DELIMITING SECOND PARAMETER\n         B     ENDP1##             END OF SECOND PARAMETER\n         B     ENDP2##             END OF PARAMETER STRING\n         B     DELIM##             DELIMITER ERROR\n         B     ABEND##             LOGIC ERROR\n         EJECT\n***********************************************************************\n*              TAKE ACTION BASED ON SYNTACTIC SIGNIFICANCE\n***********************************************************************\nPARM1##  DS    0H                  FIRST PARAMETER\nPARM2##  DS    0H                  SECOND PARAMETER\n         LR    R9,R1               R9 -> PARAMETER\n         LA    R7,DELIMITR         R7 -> TRT TABLE FOR DELIMITER\n         B     POINT               POINT TO NEXT INPUT CHARACTER\n*----------------------------------------------------------------------\nBLNK1##  DS    0H                  BLANK DELIMITING FIRST PARAMETER\nCOMA1##  DS    0H                  COMMA DELIMITING FIRST PARAMETER\n         LR    R8,R1               R8 = LENGTH OF FIELD SCANNED - 1\n         SR    R8,R9               ...\n         BCTR  R8,0                ...\n         C     R8,=A(L'ID-1)       IS LENGTH OF PARAMETER > ID?\n         BH    ARGERROR            YES, BRANCH\n         EX    R8,MVCID            MOVE ID TO WORKING STORAGE\n         B     NEXT                SCAN FOR PARAMETER\n*\nMVCID    MVC   ID(0),0(R9)         EXECUTED\n*----------------------------------------------------------------------\nENDP1##  DS    0H                  END OF SECOND PARAMETER\nBLNK2##  DS    0H                  BLANK DELIMITING SECOND PARAMETER\n         LR    R8,R1               R8 = LENGTH OF FIELD SCANNED - 1\n         SR    R8,R9               ...\n         BCTR  R8,0                ...\n         C     R8,=A(L'NAME-1)     IS LENGTH OF PARAMETER > NAME?\n         BH    ARGERROR            YES, BRANCH\n         EX    R8,MVCNAME          MOVE NAME TO WORKING STORAGE\n         B     NEXT                SCAN FOR PARAMETER\n*\nMVCNAME  MVC   NAME(0),0(R9)       EXECUTED\n         EJECT\n***********************************************************************\nENDP2##  DS    0H                  END OF PARAMETER STRING\nPROCESS  DS    0H                  PROCESS PARAMETERS\n         ICM   R15,15,=V(SHOW)     POINT TO SHOW ROUTINE\n         BZ    LINK                BRANCH IF NOT RESOLVED  *DHA 04/92*\n         CALL  (15),               INVOKE SHOW                         *\n               (ID,                IDENTIFIER FOR INFORMATION REQUESTED*\n               ILENGTH,            LENGTH PROVIDED FOR VALUE           *\n               VALUE,              INFORMATION REQUESTED               *\n               OLENGTH),           LENGTH OF INFORMATION PROVIDED      *\n               VL,                                                     *\n               MF=(E,CALLSHOW)\n         B     TESTRET             GO TEST RETURN CODE     *DHA 04/92*\nLINK     DS    0H                                          *DHA 04/92*\n         LINK  EP=SHOW,                                    *DHA 04/92* *\n               (ID,                IDENTIFIER FOR INFORMATION REQUESTED*\n               ILENGTH,            LENGTH PROVIDED FOR VALUE           *\n               VALUE,              INFORMATION REQUESTED               *\n               OLENGTH),           LENGTH OF INFORMATION PROVIDED      *\n               VL=1,                                                   *\n               MF=(E,CALLSHOW)\nTESTRET  DS    0H                                          *DHA 04/92*\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   SHOWERR             BRANCH IF ERROR\n         CALL  ISPLINK,            DEFINE FUNCTION VARIABLE            *\n               (=C'VDEFINE',       'VDEFINE'                           *\n               NAMELIST,           (VARIABLE-NAME)                     *\n               VALUE,              VALUE                               *\n               =C'CHAR',           'CHAR'                              *\n               OLENGTH),           VARIABLE-LENGTH                     *\n               VL,                                                     *\n               MF=(E,DEFINE)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ISPERROR            BRANCH IF ERROR\n         CALL  ISPLINK,            COPY TO SHARED VARIABLE             *\n               (=C'VPUT',          'VPUT'                              *\n               NAMELIST,           (VARIABLE-NAME)                     *\n               =C'SHARED'),        'SHARED'                            *\n               VL,                                                     *\n               MF=(E,PUT)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ISPERROR            BRANCH IF ERROR\n         CALL  ISPLINK,            DELETE FUNCTION VARIABLE            *\n               (=C'VDELETE',       'VDELETE'                           *\n               NAMELIST),          (VARIABLE-NAME)                     *\n               VL,                                                     *\n               MF=(E,DELETE)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ISPERROR            BRANCH IF ERROR\n         B     NORMAL              NORMAL RETURN\n         EJECT\n***********************************************************************\n*              TERMINATION\n***********************************************************************\nSHOWERR  DS    0H                  SHOW ERROR\nISPERROR DS    0H                  SPF ERROR\n         LR    R2,R15              SAVE RETURN CODE\n         B     RETURN\nDELIM##  DS    0H                  DELIMITER ERROR\n         LA    R2,20               RETURN CODE = 20\n         B     RETURN\nARGERROR DS    0H                  CALLER ARGUMENT LIST ERROR\n         LA    R2,12               RETURN CODE = 12\n         B     RETURN\nNORMAL   DS    0H                  NORMAL COMPLETION\n         SR    R2,R2               RETURN CODE = 0\nRETURN   DS    0H\n         LA    R0,L'WORKSIZE       R0 = LENGTH OF WORK AREA\n         LR    R1,R13              R1 -> DYNAMIC STORAGE\n         L     R13,SAVE+4          R13 -> PREVIOUS SAVE AREA\n         FREEMAIN R,LV=(0),A=(1)   FREE MAIN STORAGE FOR WORK AREA\n         LR    R15,R2              R15 = RETURN CODE\n         RETURN (14,12),RC=(15)    RETURN TO CALLER\n*\nABEND##  ABEND 0,DUMP              LOGIC ERROR\n*\n         DROP  R11\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n*              PARSE TABLES\n***********************************************************************\n*----------------------------------------------------------------------\n*        CATEGORIES OF CHARACTERS:\n*              TRANSLATE-AND-TEST TABLE VALUES;\n*              MATRIX COLUMN NUMBERS.\n*----------------------------------------------------------------------\nFIELD    EQU   0                   VALID CHARACTERS BETWEEN DELIMITERS\nBLANK    EQU   1  ' '              BLANK\nALPHA    EQU   2  $#@ A-Z          ALPHABETIC AND NATIONAL\nNUMBR    EQU   3  0-9              NUMERIC\nCOMMA    EQU   4  ,                COMMA\nENDOS    EQU   5                   END OF STRING\nOTHER    EQU   6                   ANY OTHER CHARACTER\n*----------------------------------------------------------------------\n*        CORRESPONDENCE BETWEEN CHARACTERS AND CATEGORIES:\n*              SCAN FOR START OF PARAMETER\n*              TRANSLATE-AND-TEST TABLE\n*----------------------------------------------------------------------\nPARAMETR DS    0CL256\n         DC    64AL1(OTHER)\n         DC      AL1(FIELD)  ' '   BLANK\n         DC    26AL1(OTHER)\n         DC      AL1(ALPHA)  $     NATIONAL\n         DC    15AL1(OTHER)\n         DC      AL1(COMMA)  ,     COMMA\n         DC    15AL1(OTHER)\n         DC     2AL1(ALPHA)  #@    NATIONAL\n         DC    68AL1(OTHER)\n         DC     9AL1(ALPHA)  A-I   ALPHABETIC\n         DC     7AL1(OTHER)\n         DC     9AL1(ALPHA)  J-R   ALPHABETIC\n         DC     8AL1(OTHER)\n         DC     8AL1(ALPHA)  S-Z   ALPHABETIC\n         DC     6AL1(OTHER)\n         DC    10AL1(NUMBR)  0-9   NUMERIC\n         DC     6AL1(OTHER)\n*----------------------------------------------------------------------\n*        CORRESPONDENCE BETWEEN CHARACTERS AND CATEGORIES:\n*              SCAN FOR DELIMITER BETWEEN PARAMETERS\n*              TRANSLATE-AND-TEST TABLE\n*----------------------------------------------------------------------\nDELIMITR DS    0CL256\n         DC    64AL1(OTHER)\n         DC      AL1(BLANK)  ' '   BLANK\n         DC    26AL1(OTHER)\n         DC      AL1(FIELD)  $     NATIONAL\n         DC    15AL1(OTHER)\n         DC      AL1(COMMA)  ,     COMMA\n         DC    15AL1(OTHER)\n         DC     2AL1(FIELD)  #@    NATIONAL\n         DC    68AL1(OTHER)\n         DC     9AL1(FIELD)  A-I   ALPHABETIC\n         DC     7AL1(OTHER)\n         DC     9AL1(FIELD)  J-R   ALPHABETIC\n         DC     8AL1(OTHER)\n         DC     8AL1(FIELD)  S-Z   ALPHABETIC\n         DC     6AL1(OTHER)\n         DC    10AL1(FIELD)  0-9   NUMERIC\n         DC     6AL1(OTHER)\n*----------------------------------------------------------------------\n*        SYNTACTIC SIGNIFICANCE:\n*              MATRIX ROW NUMBERS;\n*              ACTION INDEX NUMBERS.\n*----------------------------------------------------------------------\nBEGIN    EQU   0                   BEGINNING OF INPUT STRING\nPARM1    EQU   1                   FIRST PARAMETER\nBLNK1    EQU   2                   BLANK DELIMITING FIRST PARAMETER\nCOMA1    EQU   3                   COMMA DELIMITING FIRST PARAMETER\nCOMA2    EQU   4                   COMMA AFTER DELIMITING BLANK\nPARM2    EQU   5                   SECOND PARAMETER\nBLNK2    EQU   6                   BLANK DELIMITING SECOND PARAMETER\nENDP1    EQU   7                   END OF SECOND PARAMETER\nENDP2    EQU   8                   END OF PARAMETER STRING\nDELIM    EQU   9                   DELIMITER ERROR\nABEND    EQU   10                  LOGIC ERROR\n*----------------------------------------------------------------------\n*        CORRESPONDENCE BETWEEN CHARACTER CATEGORIES AND SYNTACTIC\n*        SIGNIFICANCE:\n*              NEW MATRIX ROW NUMBERS;\n*              ACTION INDEXES.\n*----------------------------------------------------------------------\nMATRIX   DS    0XL6,AL1\n*                  BLANK ALPHA NUMBR COMMA ENDOS OTHER\nBEGIN#   DC    AL1(ABEND,PARM1,DELIM,DELIM,DELIM,DELIM)\nPARM1#   DC    AL1(BLNK1,PARM1,PARM1,COMA1,DELIM,DELIM)\nBLNK1#   DC    AL1(ABEND,PARM2,DELIM,COMA2,DELIM,DELIM)\nCOMA1#   DC    AL1(ABEND,PARM2,DELIM,DELIM,DELIM,DELIM)\nCOMA2#   DC    AL1(ABEND,PARM2,DELIM,DELIM,DELIM,DELIM)\nPARM2#   DC    AL1(BLNK2,PARM2,PARM2,DELIM,ENDP1,DELIM)\nBLNK2#   DC    AL1(ABEND,DELIM,DELIM,DELIM,ENDP2,DELIM)\n         EJECT\n         END   ,\n>< ADD NAME=SHOWTSO  0133-85354-92115-1618-000293-000134-000293-$A1019\n         TITLE 'SHOWTSO - SET CLIST VARIABLES WITH SHOW INFO'\n***********************************************************************\n*  NAME:     SHOWTSO                                                  *\n*  FUNCTION: TO INVOKE THE SHOW UTILITY AND CREATE TSO/E CLIST        *\n*            VARIABLES WITH INFORMATION FROM ACF2 AND SYSTEM CONTROL  *\n*            BLOCKS FOR USE BY A TSO/E CLIST.                         *\n*                                                                     *\n*  SYNTAX:   SHOWTSO OPERAND(S)                                       *\n*                                                                     *\n*  NOTE:       OPERANDS MAY BE SPECIFIED SINGLY OR IN PAIR SEPERATED  *\n*              BY AN EQUAL SIGN.   IF AN OPERAND IS NOT EQUATED WITH  *\n*              ANOTHER NAME BY AN '=' THEN THE OPERAND VALUE IS ALSO  *\n*              THE NAME OF THE CLIST VARIABLE TO BE GENERATED.        *\n*              IF AN OPERAND IS SPECIFIED AS OPERAND=NAME THEN THE    *\n*              SPECIFIED NAME WILL BE THE NAME OF THE CLIST VARIABLE. *\n*                                                                     *\n*  OPERANDS:   ALL SUPPORTED VALUES OF THE SHOW PROGRAM.              *\n*                                                                     *\n*  DEPENDENCIES:  TSO/E AND THE SHOW PROGRAM.                         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* AUTHOR:      LIONEL DYCK                DOUGLAS H. ADAMS            *\n*              ROCKWELL INTERNATIONAL                                 *\n*              2201 SEAL BEACH BLVD.                                  *\n*              PO BOX 2515                                            *\n*              SEAL BEACH, CALIF  90740                               *\n*              MAIL CODE 110-SE28                                     *\n*              PHONE (310) 797-1125       (310) 797-2618              *\n*              COMNET 797-1125                                        *\n*                                                                     *\n***********************************************************************\n         EJECT                                             *LBD 12/85*\n         PUNCH ' ALIAS SHOWTSO'                            *DHA 04/92*\nSHOWTSO  CSECT                                             *DHA 04/92*\nSHOWTSO  AMODE 31                                          *DHA 04/92*\nSHOWTSO  RMODE ANY                                         *DHA 04/92*\n         REGEQU                                            *DHA 04/92*\n         EJECT                                             *DHA 04/92*\n************************************************************DHA 04/92*\n*              WORK AREA FOR REENTRANCE                    *DHA 04/92*\n************************************************************DHA 04/92*\nWORKAREA DSECT                                             *DHA 04/92*\nSAVE     DS    18F                                         *DHA 04/92*\nIOPLADS  DS    4F                                          *DHA 04/92*\nECBADS   DS    F                                           *DHA 04/92*\n         DS    0F                                          *DHA 04/92*\nPUTBLOK  PUTLINE MF=L              PUTLINE PTPB            *DHA 04/92*\n         BITSW DOIT,END,ERR                                *DHA 04/92*\nSHOWEPA  DS    A                   EPA OF SHOW             *DHA 04/92*\nOPERANDS DS    CL256               INPUT PARAMETERS        *DHA 04/92*\nILENGTH  DS    A                   SHOW INPUT LENGTH       *DHA 04/92*\nVALUE    DS    CL256               SHOW OUTPUT VALUE       *DHA 04/92*\nVALUELEN DS    F                   SHOW OUTPUT LENGTH      *DHA 04/92*\nNAMELEN  DS    F                   LENGTH OF VARIABLE NAME *DHA 04/92*\nVALUEPTR DC    A(VALUE)            A(VARIABLE VALUE)       *DHA 04/92*\nNAMEPTR  DC    A(CLSTNAME)         A(VARIABLE NAME)        *DHA 04/92*\n*                                                          *DHA 04/92*\nOLDCEMSG DS    F'2'                PUTLINE OLD             *DHA 04/92*\nACEMSG   DS    A(CEMSG)            A(PRIMARY MESSAGE)      *DHA 04/92*\nACLSTLEN DS    A(CLSTLEN)          A(TEXT INSERT)          *DHA 04/92*\nCLSTLEN  DS    Y(L'CLSTNAME)       TEXT LENGTH             *DHA 04/92*\nCLSTOFF  DS    Y(CEMSGNM)          TEXT OFFSET             *DHA 04/92*\nCLSTNAME DS    CL8                 NAME OF CLIST VAR       *DHA 04/92*\n*                                                          *DHA 04/92*\nOLDSEMSG DS    F'2'                PUTLINE OLD             *DHA 04/92*\nASEMSG   DS    A(SEMSG)            A(PRIMARY MESSAGE)      *DHA 04/92*\nASHOWLEN DS    A(SHOWLEN)          A(TEXT INSERT)          *DHA 04/92*\nSHOWLEN  DS    Y(L'SHOWNAME)       TEXT LENGTH             *DHA 04/92*\nSHOWOFF  DS    Y(SEMSGNM)          TEXT OFFSET             *DHA 04/92*\nSHOWNAME DS    CL8                 NAME OF SHOW VALUE      *DHA 04/92*\n*                                                          *DHA 04/92*\nCALLSHOW CALL  ,(SHOWNAME,ILENGTH,VALUE,VALUELEN),VL,MF=L  *DHA 04/92*\nCALLVACC CALL  ,(ECODE,NAMEPTR,NAMELEN,VALUEPTR,VALUELEN,  *DHA 04/92* *\n               TOKEN),VL,MF=L                              *DHA 04/92*\nWORKSIZE EQU   *-WORKAREA                                  *DHA 04/92*\n         EJECT                                             *DHA 04/92*\nSHOWTSO  CSECT                                             *DHA 04/92*\n         USING *,R15                                       *DHA 04/92*\n         MODID ,                                           *DHA 04/92*\n         SAVE  (14,12)             SAVE REGISTERS          *DHA 04/92*\n         LR    R12,R15                                     *DHA 04/92*\n         DROP  R15                                         *DHA 04/92*\n         USING SHOWTSO,R12                                 *DHA 04/92*\n         LR    R11,R1              SAVE PARM ADDRESS       *DHA 04/92*\n         GETMAIN RU,LV=WORKSIZE    GET WORK AREA           *DHA 04/92*\n         LR    R2,R1               ZERO OUT WORK AREA      *DHA 04/92*\n         L     R3,=A(WORKSIZE)                             *DHA 04/92*\n         SR    R5,R5                                       *DHA 04/92*\n         MVCL  R2,R4                                       *DHA 04/92*\n         ST    R13,4(R1)           CHAIN SAVE AREAS        *DHA 04/92*\n         ST    R1,8(R13)                                   *DHA 04/92*\n         LR    R13,R1                                      *DHA 04/92*\n         USING WORKAREA,R13                                *DHA 04/92*\n         LA    R2,IOPLADS          POINT TO IOPL           *DHA 04/92*\n         USING IOPL,R2                                     *DHA 04/92*\n         L     R3,4(,R11)          COPY A(UPT)             *DHA 04/92*\n         ST    R3,IOPLUPT                                  *DHA 04/92*\n         L     R3,12(,R11)         COPY A(ECT)             *DHA 04/92*\n         ST    R3,IOPLECT                                  *DHA 04/92*\n         L     R3,ECBADS           POINT TO ECB            *DHA 04/92*\n         ST    R3,IOPLECB                                  *DHA 04/92*\n         DROP  R2                                          *DHA 04/92*\n         EJECT\n         L     R3,0(,R11)          -> COMMAND BUFFER       *DHA 04/92*\n         LH    R1,2(R3)           LOAD OFFSET TO 1ST OPER\n         LH    R2,0(R3)           LOAD LENGTH\n         SR    R2,R1              GET LEN\n         SH    R2,=H'04'          LESS HEADER\n         LA    R3,4(R3)           -> PAST HEADER\n         AR    R3,R1              -> 1ST OPERAND\n         BCTR  R2,R0              LESS 1 FOR MVC            *LBD 05/89*\n         EX    R2,MOVEOPER        MOVE OPERANDS\n         EJECT\n         ICM   R0,15,=V(SHOW)      GET POINTER TO SHOW     *DHA 04/92*\n         BNZ   STSHOW              BRANCH IF RESOLVED      *DHA 04/92*\n         LOAD  EP=SHOW\nSTSHOW   DS    0H                                          *DHA 04/92*\n         ST    R0,SHOWEPA\n         OC    OPERANDS,BLANKS    SET UPPER CASE\n         LA    R5,OPERANDS\n         LR    R7,R5\n         AR    R7,R2              -> END OF DATA\n         MVC   CLSTNAME,BLANKS    INITIALIZE CLSTNAME\n         MVC   SHOWNAME,BLANKS    INITIALIZE SHOWNAME\n         LA    R4,SHOWNAME\nLOOP1    DS    0H\n         IFON  END,EXIT\n         CLI   0(R5),C'='         START OF CLIST NAME ?\n         BE    LOOPP              YES\n         CLI   0(R5),C' '         BLANK\n         BE    INCR2              YES\n         MVC   0(1,R4),0(R5)      MOVE CHAR OF NAME\n         LA    R4,1(R4)\n         SETON DOIT\nINCR     DS    0H\n         LA    R5,1(R5)           BUMP R5\n         CR    R5,R7              AT END ?\n         BNH   LOOP1              NO\n         IFON  DOIT,PROCESS\n         SETON END\n         B     EXIT\nINCR2    DS    0H\n         IFON  DOIT,PROCESS\n         B     INCR\n         EJECT\nLOOPP    DS    0H\n         LA    R4,CLSTNAME\n         B     INCR\n         EJECT\nPROCESS  DS    0H\n         SETOF DOIT\n         CLI   CLSTNAME,C' '\n         BNE   SKMV\n         MVC   CLSTNAME,SHOWNAME\nSKMV     DS    0H\n         LA    R1,SHOWNAME+7      -> END OF SHOWNAME\n         LA    R2,8               SET LEN\nSCKLEN   CLI   0(R1),C' '         END OF DSN\n         BNE   SETLEN\n         BCTR  R1,R0              LESS 1\n         BCT   R2,SCKLEN\nSETLEN   ST    R2,NAMELEN\n         LA    R1,L'VALUE\n         ST    R1,ILENGTH\n         L     R15,SHOWEPA         SHOW ENTRY POINT\n         LA    R8,SHOWNAME         SHOW VALUE NAME         *DHA 04/92*\n         LA    R9,ILENGTH          SHOW INPUT LENGTH       *DHA 04/92*\n         LA    R10,VALUE           SHOW OUTPUT VALUE       *DHA 04/92*\n         LA    R11,VALUELEN        SHOW OUTPUT LENGTH      *DHA 04/92*\n         CALL  (15),((R8),(R9),(R10),(R11)),VL,            *DHA 04/92* *\n               MF=(E,CALLSHOW)                             *DHA 04/92*\n         CH    R15,=H'04'\n         BNH   SETVAR\n         LA    R0,2                NUMBER OF MSG SEGMENTS  *DHA 04/92*\n         ST    R0,OLDSEMSG                                 *DHA 04/92*\n         LA    R0,SEMSG            A(PRIMARY MESSAGE)      *DHA 04/92*\n         ST    R0,ASEMSG                                   *DHA 04/92*\n         LA    R0,SHOWLEN          A(TEXT INSERT)          *DHA 04/92*\n         ST    R0,ASHOWLEN                                 *DHA 04/92*\n         LA    R0,L'SHOWNAME       TEXT LENGTH             *DHA 04/92*\n         STH   R0,SHOWLEN                                  *DHA 04/92*\n         LA    R0,SEMSGNM          TEXT OFFSET             *DHA 04/92*\n         STH   R0,SHOWOFF                                  *DHA 04/92*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(OLDSEMSG),           *DHA 04/92* *\n               MF=(E,IOPLADS)                              *DHA 04/92*\n         SETON ERR\n         LA    R4,SHOWNAME\n         MVC   CLSTNAME,BLANKS\n         MVC   SHOWNAME,BLANKS\n         B     INCR\n         EJECT\nSETVAR   DS    0H\n         SPACE 1\n         CLC   CLSTNAME,SHOWNAME  SAME NAME ?\n         BE    DOCLST             YES\n         LA    R1,CLSTNAME+7\n         LA    R2,8\nVLP1     CLI   0(R1),C' '         LAST SIGNIFICANT CHAR\n         BNE   SETVLP1\n         BCTR  R1,R0\n         BCT   R2,VLP1\nSETVLP1  ST    R2,NAMELEN\n         SPACE 1\nDOCLST   DS    0H                                          *LBD 12/85*\n         L     R15,CVTPTR       -> CVT\n         USING CVTMAP,R15\n         L     R15,CVTTVT         ACCESS THE TSVT\n         DROP  R15\n         USING TSVT,R15\n         TM    TSVTVACC,X'80'     31-BIT ADDRESS ?          *LBD 12/88*\n         BZ    CALLPTGT           NO                        *LBD 12/88*\n         L     R1,BIT31           LOAD 31-BIT ADDRESS       *LBD 12/88*\n         BSM   R0,R1              SET MODE TO 31-BIT        *LBD 12/88*\nBIT31    DC    A(CALLPTGT+X'80000000')                      *LBD 12/88*\nCALLPTGT DS    0H                                           *LBD 12/88*\n         L     R15,TSVTVACC\n         DROP  R15\n*\n         LA    R0,CLSTNAME         A(VARIABLE NAME)        *DHA 04/92*\n         ST    R0,NAMEPTR                                  *DHA 04/92*\n         LA    R0,VALUE            A(VARIABLE VALUE)       *DHA 04/92*\n         ST    R0,VALUEPTR                                 *DHA 04/92*\n         LA    R8,NAMEPTR          A(VARIABLE NAME)        *DHA 04/92*\n         LA    R9,NAMELEN          LENGTH OF VARIABLE      *DHA 04/92*\n         LA    R10,VALUEPTR        A(VARIABLE VALUE)       *DHA 04/92*\n         LA    R11,VALUELEN        LENGTH OF VARIABLE VALUE*DHA 04/92*\n         CALL  (15),(ECODE,(R8),(R9),(R10),(R11),TOKEN),   *DHA 04/92* *\n               VL,MF=(E,CALLVACC)                          *DHA 04/92*\n         LA    R1,LTR2            LOAD R1 WITH 24-BIT ADDR  *LBD 12/88*\n         BSM   R0,R1              AND RETURN TO 24-BIT      *LBD 12/88*\nLTR2     LTR   R15,R15\n         BZ    RET\n         LA    R0,2                NUMBER OF MSG SEGMENTS  *DHA 04/92*\n         ST    R0,OLDCEMSG                                 *DHA 04/92*\n         LA    R0,CEMSG            A(PRIMARY MESSAGE)      *DHA 04/92*\n         ST    R0,ACEMSG                                   *DHA 04/92*\n         LA    R0,CLSTLEN          A(TEXT INSERT)          *DHA 04/92*\n         ST    R0,ACLSTLEN                                 *DHA 04/92*\n         LA    R0,L'CLSTNAME       TEXT LENGTH             *DHA 04/92*\n         STH   R0,CLSTLEN                                  *DHA 04/92*\n         LA    R0,CEMSGNM          TEXT OFFSET             *DHA 04/92*\n         STH   R0,CLSTOFF                                  *DHA 04/92*\n         PUTLINE PARM=PUTBLOK,OUTPUT=(OLDCEMSG),           *DHA 04/92* *\n               MF=(E,IOPLADS)                              *DHA 04/92*\n         SETON ERR\nRET      LA    R4,SHOWNAME\n         MVC   CLSTNAME,BLANKS\n         MVC   SHOWNAME,BLANKS\n         MVC   VALUE,BLANKS\n         B     INCR\n         EJECT\nEXIT     DS    0H\n         ICM   R0,15,=V(SHOW)      GET POINTER TO SHOW     *DHA 04/92*\n         BNZ   NODELETE            BRANCH IF RESOLVED      *DHA 04/92*\n         DELETE EP=SHOW\nNODELETE DS    0H                                          *DHA 04/92*\n         SR    R15,R15\n         IFOFF ERR,EXIT0\n         LA    R15,8\nEXIT0    DS    0H\n         LR    R1,R13              UNCHAIN SAVE AREAS      *DHA 04/92*\n         L     R13,4(,R1)                                  *DHA 04/92*\n         FREEMAIN RU,LV=WORKSIZE,A=(1)  FREE WORKAREA      *DHA 04/92*\n         RETURN (14,12),RC=0                               *DHA 04/92*\nMOVEOPER MVC   OPERANDS(0),0(R3)  ***** EXECUTED\n         DROP  R13                                         *DHA 04/92*\n         DROP  R12                                         *DHA 04/92*\n         EJECT\n         LTORG\n         SPACE 2\nCEMSG    DC    AL2(CEMSGL),AL2(0)\nCEMSGTXT DC    C' ERROR SETTING CLIST VARIABLE '\nCEMSGNM  EQU   *-CEMSGTXT\nCEMSGL   EQU   *-CEMSG\n         SPACE 1\nSEMSG    DC    AL2(SEMSGL),AL2(0)\nSEMSGTXT DC    C' INVALID INFORMATION REQUEST FOR VALUE '\nSEMSGNM  EQU   *-SEMSGTXT\n         DC    C' SEE HELP FOR VALID KEYWORD OPTIONS'\nSEMSGL   EQU   *-SEMSG\n         SPACE 2\nBLANKS   DC    CL256' '\nECODE    DC    A(TSVEUPDT)      ENTRY CODE\nTOKEN    DC    F'0'\n         EJECT\n         IKJTSVT\n         EJECT\n         IKJIOPL ,\n         EJECT\n         CVT   DSECT=YES,LIST=YES\n         END\n./ ADD NAME=EXEC\n>< ADD NAME=RSHOWTSO\n/*REXX******************************************************************\n*                                                                      *\n* Display system information from various sources:                     *\n*                                                                      *\n*    SHOWREXX function                                                 *\n*    RATJESUP command (JES3)                                           *\n*    REXX (miscellaneous instructions)                                 *\n*    SYSVAR function (REXX/TSO)                                        *\n*    ISPF (VGET service)                                               *\n*                                                                      *\n* Douglas H. Adams                                                     *\n* Mail Code 110-SE28                                                   *\n* Rockwell International Corporation                                   *\n* 2201 Seal Beach Boulevard                                            *\n* P. O. Box 2515                                                       *\n* Seal Beach, California 90740-1515                                    *\n*                                                                      *\n* Internet:  $A1019@WCC1A.Rockwell.Com                                 *\n*                                                                      *\n* (310) 797-2618                                                       *\n*                                                                      *\n* October 30, 1992                                                     *\n*                                                                      *\n***********************************************************************/\n\nTrace \"Off\"\n\"NEWSTACK\"\nAddress ISPEXEC\n\"TBCREATE RSHOWTSO NAMES(ID VALUE) NOWRITE REPLACE\"\n\n/***********************************************************************\n* Obtain data via SHOWREXX function                                    *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from SHOW \",80,\"*\"),70)\n\"TBADD RSHOWTSO MULT(125)\"\n\nQueue \"ACCT\"\nQueue \"ACCTNO\"\nQueue \"ACCTNO#\"\nQueue \"ACF2ACCT\"\nQueue \"BCPFMID\"\nQueue \"BCPLEVEL\"\nQueue \"CENTER\"\nQueue \"COMPMAIL\"\nQueue \"CPU\"\nQueue \"CPUMODEL\"\nQueue \"CPUSER\"\nQueue \"CPUVER\"\nQueue \"CRTCD\"\nQueue \"DEPT\"\nQueue \"DEST\"\nQueue \"DFPLEVEL\"\nQueue \"FDS\"\nQueue \"FDS#\"\nQueue \"FRAMES\"\nQueue \"GROUP\"\nQueue \"GRP\"\nQueue \"HOMEDIV\"\nQueue \"JOBFUNC\"\nQueue \"JOBNAME\"\nQueue \"LINES\"\nQueue \"LOC\"\nQueue \"MAIL\"\nQueue \"NAME\"\nQueue \"OPSYS\"\nQueue \"OS\"\nQueue \"OSLEV\"\nQueue \"OSREL\"\nQueue \"PHONE\"\nQueue \"REFERVOL\"\nQueue \"SHOWLEV\"\nQueue \"SYSNAME\"\nQueue \"TERMINAL\"\nQueue \"TSOOPER\"\nQueue \"TSOUNIT\"\nQueue \"UID\"\nQueue \"USERID\"\n\nDo queued()\n   Parse pull id .\n   Value = showrexx(id)\n   \"TBADD RSHOWTSO\"\n   End\n\n/***********************************************************************\n* Obtain data via SHOWREXX function (not supported by IBM)             *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from SHOW (Unsupported by IBM) \",,\n        80,\"*\"),70)\n\"TBADD RSHOWTSO MULT(120)\"\n\nQueue \"BDTNODE\"\nQueue \"CLPA\"\nQueue \"CVIO\"\nQueue \"IPLDATE\"\nQueue \"IPLTIME\"\nQueue \"JOBID\"\nQueue \"LPAR\"\nQueue \"PRTY\"\nQueue \"REALSTOR\"\nQueue \"REGION\"\nQueue \"SMFID\"\nQueue \"SMS\"\nQueue \"SWA\"\nQueue \"SYSID\"\nQueue \"SYSRES\"\nQueue \"VERID\"\n\nDo queued()\n   Parse pull id .\n   Value = showrexx(id)\n   \"TBADD RSHOWTSO\"\n   End\n\n/***********************************************************************\n* Obtain data from JES3 via RATJESUP                                   *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from JES3/RATJESUP \",80,\"*\"),70)\n\"TBADD RSHOWTSO\"\n\nDo n = 1 to 6\n   Id = \"MAIN\"n\n   \"SELECT CMD(RATJESUP\" id\")\"\n   If rc = 4\n   Then leave\n   Value = d2c(rc,4)\n   Suffix = \"system\" substr(value,2,1) ,\n            word(\"? ASP global local\",pos(substr(value,3,1),\"AGL\")+1) ,\n            word(\"? IPLed notIPLed\",pos(right(value,1),\"INU\")+1)\n   Value = value \"(\"strip(suffix)\")\"\n   \"TBADD RSHOWTSO\"\n   End\n\nId = \"RC\"\n\"SELECT CMD(RATJESUP)\"\nValue = rc \"(\"word(\"global local down ?\",min(rc/4+1,4))\")\"\n\"TBADD RSHOWTSO\"\n\nId = \"VER\"\n\"SELECT CMD(RATJESUP VER)\"\nValue = rc \"(version \"left(rc,1)\".\"substr(rc,2,1)\".\"right(rc,1)\")\"\n\"TBADD RSHOWTSO\"\n\n/***********************************************************************\n* Obtain data from REXX                                                *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from REXX \",80,\"*\"),70)\n\"TBADD RSHOWTSO\"\n\nParse value date(\"B\")\";\"date(\"C\")\";\"date(\"D\")\";\" ||,\n            date(\"E\")\";\"date(\"J\")\";\"date(\"M\")\";\" ||,\n            date(\"N\")\";\"date(\"O\")\";\"date(\"S\")\";\" ||,\n            date(\"U\")\";\"date(\"W\")\";\"             ||,\n            time(\"C\")\";\"time(\"H\")\";\"time(\"L\")\";\" ||,\n            time(\"M\")\";\"time(\"N\")\";\"time(\"S\"),\n      with  dateb \";\" datec \";\" dated \";\" datee \";\" datej \";\" datem \";\",\n            daten \";\" dateo \";\" dates \";\" dateu \";\" datew \";\",\n            timec \";\" timeh \";\" timel \";\" timem \";\" timen \";\" times\n\nId = \"DATE(B)\"\nValue = dateb \"(\"comma(dateb) \"days since January 1, 0001)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(C)\"\nValue = datec \"(\"comma(datec),\n        \"days since January 1,\" left(date(\"Standard\"),2)\"00)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(D)\"\nValue = dated \"(days since January 1,\" left(date(\"Standard\"),4)\")\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(E)\"\nValue = datee \"(dd/mm/yy)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(J)\"\nValue = datej \"(yyddd)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(M)\"\nValue = datem\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(N)\"\nValue = daten\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(O)\"\nValue = dateo \"(yy/mm/dd)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(S)\"\nValue = dates \"(yyyymmdd)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(U)\"\nValue = dateu \"(mm/dd/yy)\"\n\"TBADD RSHOWTSO\"\n\nId = \"DATE(W)\"\nValue = datew\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(C)\"\nValue = timec\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(H)\"\nValue = timeh \"(hours since midnight)\"\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(L)\"\nValue = timel \"(hh:mm:ss.uuuuuu)\"\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(M)\"\nValue = timem \"(\"comma(timem) \"minutes since midnight)\"\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(N)\"\nValue = timen \"(hh:mm:ss)\"\n\"TBADD RSHOWTSO\"\n\nId = \"TIME(S)\"\nValue = times \"(\"comma(times) \"seconds since midnight)\"\n\"TBADD RSHOWTSO\"\n\nId = \"USERID\"\nValue = userid()\n\"TBADD RSHOWTSO\"\n\nParse version value\nId = \"VERSION\"\n\"TBADD RSHOWTSO\"\n\n/***********************************************************************\n* Obtain data from REXX/TSO SYSVAR function                            *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from REXX/TSO SYSVAR \",80,\"*\"),70)\n\"TBADD RSHOWTSO\"\n\nQueue \"SYSCPU\" \"seconds\"\nQueue \"SYSHSM\"\nQueue \"SYSLRACF\"\nQueue \"SYSLTERM\" \"lines\"\nQueue \"SYSPREF\"\nQueue \"SYSPROC\"\nQueue \"SYSRACF\"\nQueue \"SYSSRV\" \"service units\"\nQueue \"SYSTSOE\"\nQueue \"SYSUID\"\nQueue \"SYSWTERM\" \"columns\"\n\nDo queued()\n   Parse pull id suffix\n   Value = strip(sysvar(id))\n   If wordpos(id,\"SYSHSM SYSLRACF SYSTSOE\") \u00ac= 0\n   Then suffix = \"version\" left(value,1)\".\"format(substr(value,2,2)) ||,\n                 \".\"right(value,1) suffix\n   If id == \"SYSSRV\"\n   Then suffix = comma(value) suffix\n   If suffix \u00ac= \"\"\n   Then value = value \"(\"strip(suffix)\")\"\n   \"TBADD RSHOWTSO\"\n   End\n\n/***********************************************************************\n* Obtain data from ISPF via VGET                                       *\n***********************************************************************/\nId = copies(\"*\",8)\nValue = right(center(\" Information from ISPF \",80,\"*\"),70)\n\"TBADD RSHOWTSO\"\n\nQueue \"ZACCTNUM\"\nQueue \"ZCOLORS\"\nQueue \"ZDATE\"\nQueue \"ZDAY\"\nQueue \"ZENVIR\"\nQueue \"ZHILITE\"\nQueue \"ZJDATE\"\nQueue \"ZKEYS\"\nQueue \"ZLOGON\"\nQueue \"ZMONTH\"\nQueue \"ZPDFREL\"\nQueue \"ZPREFIX\"\nQueue \"ZSCREEND\" \"rows\"\nQueue \"ZSCREENW\" \"columns\"\nQueue \"ZSCRMAXD\" \"rows\"\nQueue \"ZSCRMAXW\" \"columns\"\nQueue \"ZSTDYEAR\"\nQueue \"ZSYSID\"\nQueue \"ZTERM\"\nQueue \"ZTIME\"\nQueue \"ZUSER\"\nQueue \"ZYEAR\"\n\nDo queued()\n   Parse pull id suffix\n   \"VGET\" id\n   Value = value(id)\n   If datatype(value,\"W\") & left(value,1) == \"0\" & suffix \u00ac== \"\"\n   Then suffix = format(value) suffix\n   If id == \"ZENVIR\"\n   Then suffix = left(value,8)\"/\"strip(substr(value,9,8))\"/\" || ,\n                 substr(value,17)\n   If suffix \u00ac= \"\"\n   Then value = value \"(\"strip(suffix)\")\"\n   \"TBADD RSHOWTSO\"\n   End\n\n/***********************************************************************\n* Clean up and display information                                     *\n***********************************************************************/\nAddress TSO \"DELSTACK\"\n\"TBTOP RSHOWTSO\"\n\"TBDISPL RSHOWTSO PANEL(RSHOWTSO)\"\nDo while rc = 0\n   \"CONTROL DISPLAY SAVE\"\n   \"TBSKIP RSHOWTSO NUMBER(\"ztdtop\") NOREAD\"\n   Parse upper var zcmd command id .\n   If abbrev(\"LOCATE\",command)\n   Then do\n      If id = \"\"\n      Then id = save_id\n      Else do\n         Id = id\"*\"\n         Save_id = id\n         \"TBTOP RSHOWTSO\"\n         End\n      \"TBSCAN RSHOWTSO ARGLIST(ID) NOREAD\"\n      If rc = 8\n      Then \"TBSKIP RSHOWTSO NUMBER(\"ztdtop\") NOREAD\"\n      End\n   \"CONTROL DISPLAY RESTORE\"\n   \"TBDISPL RSHOWTSO PANEL(RSHOWTSO)\"\n   End\n\n/***********************************************************************\n* Terminate                                                            *\n***********************************************************************/\nExit\n\n/***********************************************************************\n* Insert commas into numbers (nnnnnnnnn -> nnn,nnn,nnn)                *\n***********************************************************************/\nComma:\nReturn right(translate(\"12304560789\",\",\"right(arg(1),9),\"0123456789\"),,\n       (length(arg(1))*4-1)%3)\n./ ADD NAME=HELP\n>< ADD NAME=SHOWREXX 0100-92118-92118-1259-000018-000019-000000-$A1019\n)F Function -\n   SHOWREXX is a REXX function, similar to SYSVAR, which returns\n   information about MVS, TSO/E, your ACF2 profile, etc.\n)X Syntax -\n   SHOWREXX(id)\n\n   Required  - id\n   Default   - none\n   Example 1 - Value = showrexx(\"acct\")\n   Example 2 - Id = \"acct\"\n               Value = showrexx(id)\n)O Operands -\n)P id - is a keyword which specifies the information desired. It may be\n        specified in uppercase or lowercase. An error in the argument\n        will cause a syntax error with an error code of 40. A message\n        will also be issued.\n)I SHOWUSER\n)I SYSSHOW\n>< ADD NAME=SHOWSPF  0100-92118-92118-1259-000024-000019-000000-$A1019\n)F Function -\n   SHOWSPF is a an ISPF program which returns information about MVS,\n   TSO/E, your ACF2 profile, etc.\n)X Syntax -\n   ISPEXEC SELECT PGM(SHOWSPF) PARM(id,value)\n\n   Required - id\n              value\n   Default  - none\n   Example  - ISPEXEC SELECT PGM(SHOWSPF) PARM(ACCT,VALUE)\n              VGET VALUE\n   Return codes -\n               0: Normal completion.\n               8: Id not recognized.\n              12: Argument length error.\n              16: System control block failed validity check.\n              20: Argument syntax error.\n)O Operands -\n)P id - is a keyword which specifies the information desired. It may be\n        specified in uppercase or lowercase.\n)P value - is the name of an ISPF variable to receive the specified\n           information.\n)I SHOWUSER\n)I SYSSHOW\n>< ADD NAME=SHOWTSO  0100-92118-92118-1300-000018-000064-000000-$A1019\n)F Function -\n   SHOWTSO is a TSO command which returns information about MVS, TSO/E,\n   your ACF2 profile, etc.\n)X Syntax -\n  SHOWTSO {id | id=value | id id ... | id=value id=value ...}\n\n   Required  - id\n   Default   - none\n   Example 1 - SHOWTSO ACCT\n   Example 2 - SHOWTSO ACCT=VALUE\n)O Operands -\n)P id - is a keyword which specifies the information desired. It may be\n        specified in uppercase or lowercase.\n)P value - is the name of a CLIST or REXX variable to receive the value\n           specified by id. If value is omitted, the variable name is\n           the same as id.\n)I SHOWUSER\n)I SYSSHOW\n>< ADD NAME=SHOWUSER 0100-92118-92118-1554-000052-000057-000000-$A1019\n\n  The following keywords are supported for id:\n\n))ACCT        -     Rockwell Job Card Account (with FDS #)\n))ACCTNO      -     Rockwell Job Card Account (no FDS #)\n))ACCTNO#     -     Rockwell ACF2 User's Account (no FDS #)\n))ACF2ACCT    -     ACF2 User's Default Accounting Field\n))BCPFMID     -     Basic Control Program FMID\n))BCPLEVEL    -     Basic Control Program Product Name\n))CENTER      -     Rockwell Center Name\n))COMPMAIL    -     Rockwell ACF2 User's Computer Mail Code\n))CPU         -     System Name from SYS1.PARMLIB(IEASYSxx)\n))CPUMODEL    -     CPU Model (e.g., 3090)\n))CPUSER      -     CPU Serial(s) (Maximum 16)\n))CPUVER      -     CPU Version\n))CRTCD       -     Rockwell Job Card CRT Code\n))DEPT        -     Rockwell ACF2 User's Department\n))DEST        -     TSO User's Default Destination\n))DFPLEVEL    -     Data Facility Product Level\n))FDS         -     Rockwell Job Card FDS #\n))FDS#        -     Rockwell ACF2 User's FDS #\n))FRAMES      -     Rockwell Job Card CRT Frame Limit\n))GROUP       -     Rockwell ACF2 User's Group (in Dept)\n))GRP         -     Rockwell ACF2 User's Group (in Dept)\n))HOMEDIV     -     Rockwell ACF2 User's Home Division\n))JOBFUNC     -     Rockwell ACF2 User's Job Function Code\n))JOBNAME     -     Job Name\n))LINES       -     Rockwell Job Card FORTRAN Line Limit\n))LOC         -     Rockwell ACF2 User's Physical Location\n))MAIL        -     Rockwell ACF2 User's Mail Code\n))NAME        -     ACF2 User's Name\n))OPSYS       -     Operating System (MVS/xxx)\n))OS          -     Operating System (xxx)\n))OSLEV       -     Operating System (xxx)\n))OSREL       -     Operating System Release Number\n))PHONE       -     ACF2 User's Phone Number\n))REFERVOL    -     Volume Serial of Dataset userid.REFER\n))SHOWLEV     -     Level of SHOW (Date and Time)\n))SYSNAME     -     System Name from SYS1.PARMIB(IEASYSxx)\n))TERMINAL    -     Terminal ID\n))TSOOPER     -     TSO OPERATOR Authority (YES or NO)\n))TSOUNIT     -     TSO User's Default Unit Name\n))UID         -     Rockwell ACF2 User's UID String\n))USERID      -     User ID\n  ---------------------------------------------------------------------\n  The following information is derived from control blocks or fields\n  which IBM does not consider programming interfaces. This information\n  may therefore be unavailable in the future.\n  ---------------------------------------------------------------------\n))JOBID       -     Job ID (JOBnnnnn)\n))PRTY        -     Job Scheduling Priority\n))REGION      -     Region Size (nK)\n>< ADD NAME=SYSSHOW  0100-92118-92118-1554-000017-000017-000000-$A1019\n  ---------------------------------------------------------------------\n  The following information is for systems programmers only. The\n  information is not officially available.\n  ---------------------------------------------------------------------\n))BDTNODE     -     MVS/BDT Node Name\n))CLPA        -     CLPA Specified at last IPL (YES or NO)\n))CVIO        -     CVIO Specified at IPL (YES or NO)\n))IPLDATE     -     Last IPL Date\n))IPLTIME     -     Last IPL Time\n))LPAR        -     Logical Partition Mode (YES or NO)\n))REALSTOR    -     Real Storage Available at Last IPL\n))SMFID       -     SMF ID from SYS1.PARMLIB(SMFPRMxx)\n))SMS         -     Status of SMS (ON or OFF)\n))SWA         -     SWA Location (ABOVE or BELOW)\n))SYSID       -     System ID from SYS1.PARMLIB(SMFPRMxx)\n))SYSRES      -     System Residence Volume Serial\n))VERID       -     Installation System Version (CVTVERID)\n>< ADD NAME=SYSXSHOW 0100-92118-92118-1300-000018-000019-000000-$A1019\n)F Function -\n   &SYSXSHOW is a CLIST function which returns information about MVS,\n   TSO/E, your ACF2 profile, etc.\n)X Syntax -\n   &SYSXSHOW(id)\n\n   Required  - id\n   Default   - none\n   Example 1 - SET &VALUE = &SYSXSHOW(ACCT)\n   Example 2 - SET &ID = ACCT\n               SET &VALUE = &SYSXSHOW(&ID)\n)O Operands -\n)P id - is a keyword which specifies the information desired. It may be\n        specified in uppercase or lowercase. An error in the argument\n        will cause an ERROR condition with a return code of 604. A\n        message will also be issued.\n)I SHOWUSER\n)I SYSSHOW\n./ ADD NAME=LINK\n INCLUDE OBJECT(SHOW)\n INCLUDE OBJECT(IKJCT44B)\n INCLUDE OBJECT(IRXFLOC)\n INCLUDE OBJECT(SHOWREXX)\n INCLUDE OBJECT(SHOWSPF)\n INCLUDE OBJECT(SHOWTSO)\n NAME SHOW(R)\n./ ADD NAME=MACROS\n>< ADD NAME=BITSW\n         MACRO\n&LABEL   BITSW   &BIT0,&BIT1,&BIT2,&BIT3,&BIT4,&BIT5,&BIT6,&BIT7,&DSECT\n         LCLC  &#\n&#       SETC  '#'\n         AIF   ('&BIT0' EQ '').A\n&BIT0    EQU   *  .          BIT 0.\n&BIT0&#  EQU   128  .        1... ....      BIT POSITION\n.A       AIF   ('&BIT1' EQ '').B\n&BIT1    EQU   *  .          BIT 1.\n&BIT1&#  EQU   64  .         .1.. ....      BIT POSITION\n.B       AIF   ('&BIT2' EQ '').C\n&BIT2    EQU   *  .          BIT 2.\n&BIT2&#  EQU   32  .         ..1. ....      BIT POSITION\n.C       AIF   ('&BIT3' EQ '').D\n&BIT3    EQU   *  .          BIT 3.\n&BIT3&#  EQU   16  .         ...1 ....      BIT POSITION\n.D       AIF   ('&BIT4' EQ '').E\n&BIT4    EQU   *  .          BIT 4.\n&BIT4&#  EQU   8  .          .... 1...      BIT POSITION\n.E       AIF   ('&BIT5' EQ '').F\n&BIT5    EQU   *  .          BIT 5.\n&BIT5&#  EQU   4  .          .... .1..      BIT POSITION\n.F       AIF   ('&BIT6' EQ '').G\n&BIT6    EQU   *  .          BIT 6.\n&BIT6&#  EQU   2  .          .... ..1.      BIT POSITION\n.G       AIF   ('&BIT7' EQ '').H\n&BIT7    EQU   *  .          BIT 7.\n&BIT7&#  EQU   1  .          .... ...1      BIT POSITION\n.H       ANOP\n         AIF   ('&DSECT' EQ '').I\n&LABEL   DS    XL1  .        BIT BYTE.\n         SPACE\n         MEXIT\n.I       ANOP\n&LABEL   DC    XL1'0' .      BIT BYTE.\n         SPACE\n         MEND\n>< ADD NAME=IFOFF\n         MACRO\n&LABEL   IFOFF &BIT,&BROF,&BRON\n         LCLB  &BL121,&BL122\n         LCLC  &#\n&#       SETC  '#'\n         AIF   ('&BIT' NE '').A\n         MNOTE 1,'OPERAND 1 MISSING - NO GENERATION'\n         MEXIT\n.A       ANOP\n&BL121   SETB  ('&BRON' NE '')\n&BL122   SETB  ('&BROF' NE '')\n         AIF   (&BL121 OR &BL122).AA\n         MNOTE 1,'NO TRANSFER ADDRESS'\n         MEXIT\n.AA      ANOP\n&LABEL   TM    &BIT,&BIT&#  .          TEST FOR BIT.\n         AIF   (NOT &BL122).OTHER\n         BZ    &BROF  .                BRANCH NOT ON.\n         AIF   (&BL121).OTHER\n         SPACE\n         MEXIT\n.OTHER   BO    &BRON  .                BRANCH ON.\n         SPACE\n         MEND\n>< ADD NAME=IFON\n         MACRO\n&LABEL   IFON  &BIT,&BRYES,&BRNO\n         LCLB  &BL121,&BL122\n         LCLC  &#\n&#       SETC  '#'\n         AIF   ('&BIT' NE '').A\n         MNOTE 1,'OPERAND 1 MISSING - NO GENERATION'\n         MEXIT\n.A       ANOP\n&BL121   SETB  ('&BRYES' NE '')\n&BL122   SETB  ('&BRNO' NE '')\n         AIF   (&BL121 OR &BL122).AA\n         MNOTE 1,'NO TRANSFER ADDRESS'\n         MEXIT\n.AA      ANOP\n&LABEL   TM    &BIT,&BIT&#  .          TEST FOR BIT.\n         AIF   (NOT &BL121).TAKNO\n         BO    &BRYES  .               BRANCH ON.\n         AIF   (&BL122).TAKNO\n         SPACE\n         MEXIT\n.TAKNO   ANOP\n         BZ    &BRNO  .                BRANCH NOT ON.\n         SPACE\n         MEND\n>< ADD NAME=REGEQU   0100-82323-82323-1417-000021-000021-000000-$A1238\n         MACRO\n         REGEQU\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n***********************************************************************\n         MEND\n>< ADD NAME=SETOF\n         MACRO\n&LABEL   SETOF &A,&B,&C,&D,&E,&F,&G,&H,&I,&J,&K,&L,&M,&N,&O,&P\n         LCLA  &NU\n         LCLC  &VALUE\n         LCLC  &#\n&#       SETC  '#'\n         AIF   ('&A' NE '').OK\n         MNOTE 5,'MISSING OPERANDS - NO GEN'\n         MEXIT\n.OK      AIF   ('&LABEL' EQ '').B1\n&LABEL   EQU   *\n.B1      ANOP\n&NU      SETA  N'&SYSLIST\n.CHK     AIF   ('&NU' NE '0').LOOP\n         SPACE\n         MEXIT\n.LOOP    ANOP\n&VALUE   SETC  '&SYSLIST(&NU)'\n         NI    &SYSLIST(&NU),255-&VALUE&#\n&NU      SETA  &NU-1\n         AGO   .CHK\n         MEND\n>< ADD NAME=SETON\n         MACRO\n&LABEL   SETON &A,&B,&C,&D,&E,&F,&G,&H,&I,&J,&K,&L,&M,&N,&O,&P\n         LCLA  &NU\n         LCLC  &VALUE\n         LCLC  &#\n&#       SETC  '#'\n         AIF   ('&A' NE '').OK\n         MNOTE 5,'MISSING OPERANDS - NO GEN'\n         MEXIT\n.OK      AIF   ('&LABEL' EQ '').B1\n&LABEL   EQU   *\n.B1      ANOP\n&NU      SETA  N'&SYSLIST\n.CHK     AIF   ('&NU' NE '0').LOOP\n         SPACE\n         MEXIT\n.LOOP    ANOP\n&VALUE   SETC  '&SYSLIST(&NU)'\n         OI    &SYSLIST(&NU),&VALUE&#\n&NU      SETA  &NU-1\n         AGO   .CHK\n         MEND\n>< ADD NAME=XABSM    0100-89168-89168-1749-000019-000019-000000-$A1238\n         MACRO\n&LAB     XABSM &MODE=24\n         AIF   ('&LAB' EQ '').NOLAB CHECK FOR LABEL\n&LAB     DS    0H                  MVS/XA SET MODE MACRO\n.NOLAB   ANOP\n         AIF   ('&MODE' EQ '31').XAON\n         AIF   ('&MODE' EQ '24').XAOFF\n         MNOTE 8,'MODE &MODE INVALID'\n.XAON    ANOP                      GO TO 31 BIT MODE\n         CNOP  2,4                 FORCE FULL WORD ALIGNMENT\n         LA    R1,*+14 .              POINT TO AMODE = 31 CODE\n         O     R1,*+6 .               TURN ON AMODE = 31 BIT\n         BSM   0,R1 .                 BRANCH TO AMODE = 31 CODE\n         DC    X'80000000'         AMODE = 31 BIT\n         AGO   .MACEND\n.XAOFF   LA    R1,*+6 .               POINT TO AMODE = 24 CODE\n         BSM   0,R1 .                 BRANCH TO AMODE = 24 CODE\n.MACEND  ANOP\n         MEND\n./ ADD NAME=PANELS\n>< ADD NAME=$SHOWTSO 0100-92303-92304-1113-000022-000020-000000-$A1019\n%Tutorial -------------------- System Information -------------------- Tutorial%\n%Command ===>_zcmd                                                             %\n%                                                                              %\n+System information obtained from SHOW, JES3, REXX, and ISPF is displayed.\n+\n+There is a separator line for the information from each of these sources.\n+The information is displayed in columns:\n+   Column one contains the keyword used to obtain the information.\n+   Column two contains the information exactly as obtained.\n+   Column three may contain a brief explanation and/or formatted version of the\n+   information.\n+\n+You may scroll through the information or use the%LOCATE+command.\n+\n+The LOCATE command syntax is:\n+   %LOCATE keyword+\n+\n+The LOCATE command may be repeated by issuing it without a keyword:\n+   %LOCATE+\n+\n+Any abbreviation of LOCATE or \"keyword\" is accepted.\n)End\n>< ADD NAME=RSHOWTSO 0132-89180-92304-1207-000013-000036-000000-$A1019\n)Attr\n @ type(output) intens(high) color(turq)   caps(off)\n + type(output) intens(low)  color(yellow)\n % type(text)   intens(high) color(white)\n)Body\n%----------------------------- System Information -----------------------------%\n%Command ===>_zcmd                                             %Scroll ===>_amt\n)Model\n+id      @value\n)Init\n &zcmd = &z\n .help = $showtso\n)End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSLOG": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\"?\\x00\\x92\"?\\x12\\x00\\x07\\xb9\\x07\\xb9\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc5\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-10T00:00:00", "modifydate": "1992-08-10T12:00:00", "lines": 1977, "newlines": 1977, "modlines": 0, "user": "REXXES"}, "text": "./ ADD NAME=$README  0105-90123-90124-0817-000075-000009-000000-$A1238\nThis file contains an ISPF Dialog and the related SYS1.PROCLIB member\n(LOGWTR) for managing your system log data sets (aka. SYSLOG).\n\nThere is a Rockwell TSO command used that you should replace with your\nown code that extracts the current center name.  This command is\nSHOWTSO.\n\nThis file should be processed by IEBUPDTE and will create the following\nmembers:\n\n     $README  -  what you are currently reading\n     EXEC     -  member which is input to IEBUPDTE with a target of\n                 a REXX procedure library\n     LOGSCAND -  documentation for the LOGSCAN utility\n     MSGS     -  member which is input to IEBUPDTE with a target of\n                 your ISPF Messages library\n     PANELS   -  member which is input to IEBUPDTE with a target of\n                 your ISPF Panels library\n     PROCLIB  -  member which is input to IEBUPDTE with a target of\n                 your SYS1.PROCLIB library\n     SKELS    -  member which is input to IEBUPDTE with a target of\n                 your ISPF Skeleton library\n     SOURCE   -  member which is input to IEBUPDTE with a target of\n                 your an assembler source library\n\nNote that members:  EXEC, MSGS, PANELS, SKELS and SOURCE must be edited to\nchange +/ to ./ prior to processing by IEBUPDTE.\n\nRockwell dependencies (things you have to look out for and change when\nyou install this code):\n\nThe EXEC is dependent upon the naming convention of your SYSLOG data\nsets.  We use ASYSLOG.center.Ddate.Ttime as we sometimes have the SYSLOG\nfrom multiple centers at one location.\n\nThe PROCLIB member LOGWTR is our started task that we use to 'cut' the\nSYSLOG into a data set.  You should change the high level index to match\nthe EXEC and update it for the center name you choose or modify it along\nwith the EXEC to ignore the center name.  The LOGWTR started task is\ncalled here by our automation tool everytime that the SYSLOG is\n'chopped' by intercepting message IEE043I.\n\nThe use of LOGSCAN, an IBM service aid, is supported.  However the source\nis not available.  See file LOGSCAN.BIN for a binary unload of the\nload library.  Reload using the command:\n\n  \"SEND LOGSCAN.BIN  LOGSCAN.XMIT\"\n\nThen issue the TSO Recieve command against this file:\n\n  \"RECEIVE INDS(LOGSCAN.XMIT)\"\n\n----------------------------------------------------------------------------\n\nBelow is a brief description of the SYSLOG dialog process:\n\n Scan SYSLOG data sets via ISPF Browse or LOGSCAN service aid\n\n This EXEC provides access to cataloged SYSLOG data sets. It is\n assumed that an external writer will copy SYSLOG data from JES to an\n online data set. The name must be of the form ASYSLOG.Dyyddd.Thhmm\n or ASYSLOG.center.Dyyddd.Thhmm, where yyddd is the current julian\n date, and hhmm is the current time. Center is a center name or NJE\n node name, etc. There may be multiple data sets for one day. The\n tutorial assumes that 31 days will be kept. DFHSM is supported.\n\n The EXEC extracts all data set names beginning with ASYSLOG and\n builds an ISPF table using the date and time. The user may then\n select one or more of these data sets for processing by ISPF browse\n or the LOGSCAN service aid.\n\n The EXEC may be invoked as %SYSLOG or %SYSLOG CNTR(center).\n\n See the tutorial for additional information.\n\n./ ADD NAME=EXEC     0101-90123-92223-1308-000677-000636-000000-$A1238\n+/ ADD NAME=SYSLOG\n/*********************************REXX**********************************\n*                                                                      *\n* Scan SYSLOG data sets via ISPF Browse or LOGSCAN service aid         *\n*                                                                      *\n* This EXEC provides access to cataloged SYSLOG data sets. It is       *\n* assumed that an external writer will copy SYSLOG data from JES to an *\n* online data set. The name must be of the form ASYSLOG.Dyyddd.Thhmm   *\n* or ASYSLOG.center.Dyyddd.Thhmm, where yyddd is the current julian    *\n* date, and hhmm is the current time. Center is a center name or NJE   *\n* node name, etc. There may be multiple data sets for one day. The     *\n* tutorial assumes that 31 days will be kept. DFHSM is supported.      *\n*                                                                      *\n* The EXEC extracts all data set names beginning with ASYSLOG and      *\n* builds an ISPF table using the date and time. The user may then      *\n* select one or more of these data sets for processing by ISPF browse  *\n* or the LOGSCAN service aid.                                          *\n*                                                                      *\n* The EXEC may be invoked as %SYSLOG or %SYSLOG CNTR(center).          *\n*                                                                      *\n* See the tutorial for additional information.                         *\n*                                                                      *\n* Douglas H. Adams                                                     *\n* Mail Code 110-SH28                                                   *\n* Rockwell Internation Corporation                                     *\n* 2201 Seal Beach Boulevard                                            *\n* P. O. Box 2215                                                       *\n* Seal Beach, California 90740-1515                                    *\n*                                                                      *\n* (213) 797-2618                                                       *\n*                                                                      *\n* April 16, 1990                                                       *\n*                                                                      *\n* June  14, 1991  Corrected for SMS entries in LISTCAT  Michael Theys  *\n* Oct   17, 1991  Corrected for LISTDSI IRX0275E msg    Michael Theys  *\n* Jan   03, 1992  Corrected day-of-week for 1992        Michael Theys  *\n*                                                                      *\n***********************************************************************/\n\nSignal on novalue\nIf trace() == \"N\"\nThen trace Off\n\nIf sysvar(\"SYSISPF\") \u00ac== \"ACTIVE\"\nThen do\n   Parse source . . name .\n   \"ISPSTART CMD(%\"name\")\"\n   Exit\n   End\n\n/***********************************************************************\n* Main program                                                         *\n***********************************************************************/\nArg \"(\" cntr \")\" .\nLOGSCAN_output? = 0\nCall data_set_list\nAddress ISPEXEC\nCall data_set_table\n\"TBTOP   SYSLOG\"\n\"TBQUERY SYSLOG ROWNUM(ROWNUM)\"\n\"VGET    ZSCREEND\"\nIf zscreend = 27\nThen zscreend = 24\n\"TBSKIP  SYSLOG NUMBER(\"rownum-zscreend+6\") NOREAD\"\n\"TBDISPL SYSLOG PANEL(LOGLIST) CSRROW(\"rownum\") AUTOSEL(NO)\",\n               \"POSITION(CRP)\"\nTbdispl_rc = rc\nDo while tbdispl_rc < 8\n   Tdtop = ztdtop\n   \"VGET (ZVERB ZSCROLLN)\"\n   Call commands\n   \"TBTOP SYSLOG\"\n   Select\n      When zverb == \"UP\"\n      Then number = tdtop-zscrolln\n      When zverb == \"DOWN\"\n      Then number = min(tdtop+zscrolln,mult)\n      Otherwise number = tdtop\n      End\n   \"TBSKIP  SYSLOG NUMBER(\"number\") NOREAD\"\n   \"TBDISPL SYSLOG PANEL(LOGLIST) CSRROW(\"crp\") AUTOSEL(NO)\",\n                  \"POSITION(CRP)\"\n   Tbdispl_rc = rc\n   End\n\"TBEND SYSLOG\"\nCall \"MSG\" \"OFF\"\nAddress TSO \"FREE FILE(SYSIN LOG PRINT)\"\nCall \"MSG\" \"ON\"\nExit 4\n\n/***********************************************************************\n* Obtain a list of syslog data set names                               *\n***********************************************************************/\nData_set_list:\n\nIf cntr == \"\"\nThen \"SHOWTSO CENTER=CNTR\"\nIf substr(cntr,1,3) == \"WCC\"\nThen center = \".\"cntr\nElse center = \"\"\nCall \"OUTTRAP\" \"LISTCAT.\",\"*\"\n\"LISTCAT LEVEL(ASYSLOG\"center\") CATALOG('ASYSLOG') VOLUME\"\nIf rc \u00ac= 0\nThen do\n   Do i = 1 to listcat.0; Say listcat.i; End\n   Exit 8\n   End\nCall \"OUTTRAP\" \"OFF\"\nReturn\n\n/***********************************************************************\n* Build table of syslog data sets                                      *\n***********************************************************************/\nData_set_table:\n\n\"TBCREATE SYSLOG NOWRITE REPLACE NAMES(ACTION DSNAME STATUS\",\n                                      \"SDAYNAME SDATE SJDATE STIME\",\n                                      \"EDAYNAME EDATE EJDATE ETIME)\"\n\"TBVCLEAR SYSLOG\"\n          /*     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec */\nParse value \"  0  31  59  90 120 151 181 212 243 273 304 334 365\",\n            \"  0  31  60  91 121 152 182 213 244 274 305 335 366\",\n      with  days.0.0  days.1.0  days.2.0  days.3.0  days.4.0,\n                      days.5.0  days.6.0  days.7.0  days.8.0,\n                      days.9.0  days.10.0 days.11.0 days.12.0,\n            days.0.1  days.1.1  days.2.1  days.3.1  days.4.1,\n                      days.5.1  days.6.1  days.7.1  days.8.1,\n                      days.9.1  days.10.1 days.11.1 days.12.1 .\n/*Parse value \"Sun    Mon    Tue    Wed    Thu    Fri    Sat   \", */\n/*      with   name.0 name.1 name.2 name.3 name.4 name.5 name.6 . */\nParse value \"Sat    Sun    Mon    Tue    Wed    Thu    Fri   \",\n      with   name.0 name.1 name.2 name.3 name.4 name.5 name.6 .\n\n#_Asyslog_files = 0\nDo I = 1 to listcat.0\n  If substr(listcat.I,1,7) = 'NONVSAM'\n  Then #_Asyslog_files = #_Asyslog_files + 1\nEnd\nMult = #_Asyslog_files\n\nOld_ddd = \"\"\n\ni = 1\ndo while(i <= listcat.0 )\n   Parse var listcat.i \"ASYSLOG\" +0 dsname 1,\n         \"ASYSLOG\" \".D\" +2  yy +2 ddd \".T\" +2  hh +2 mm +2 .\n   If ddd == old_ddd\n   Then parse value \"\" with edayname edate ejdate\n   Else do\n      Leap_year? = yy//4 = 0\n      Do month = 1 to 12 while ddd > days.month.leap_year?; End\n      Previous_month = month-1\n      Day = ddd-days.previous_month.leap_year?\n      /* This gives Saturday for Friday 01/03/92 */\n      Weekday = (trunc(yy*365.25)+ddd)//7\n      Edayname = name.weekday\n      /* BEGIN of M.Theys Dayname calculation */\n      mon = month\n      year = 1900 + yy\n      If mon <= 2 Then Do /* Jan,Feb to mon=13,14 for formula */\n        mon = mon + 12\n        year = year - 1\n      End\n    d# = (day+(2*mon)+((3*(mon+1))%5)+year+(year%4)-(year%100)+(year%400)+2)//7\n      Edayname = name.d#  /* 0=Sat,1=Sun,...5=Thu,6=Fri */\n      /* END of M.Theys Dayname calculation */\n      Edate = format(month,2)\"/\"format(day,2)\n      Ejdate = yy\".\"ddd\n      End\n   Etime = format(hh,2)\":\"mm\n   J = I+4\n   If word(listcat.J,1) == 'SMSDATA'\n   Then do /* SMSdata entry */\n     J = i+8\n     incr = 9\n   End\n   Else do /* non SMSdata entry */\n     J = i+5\n     incr = 6\n   End\n   Parse var listcat.j \"VOLSER------------\" volser .\n   If volser == \"MIGRAT\"\n   Then status = \"Migrated\"\n   Else status = \"\"\n   \"TBADD SYSLOG MULT(\"mult\")\"\n   If ddd \u00ac== old_ddd\n   Then do\n      Old_ddd = ddd\n      Sdayname = edayname\n      Sdate = edate\n      Sjdate = ejdate\n      End\n   Stime = etime\n   i = i + incr\n   End\nDrop listcat.\nReturn\n\n/***********************************************************************\n* Process commands                                                     *\n***********************************************************************/\nCommands:\n\nDo i = 1 to ztdsels\n   \"TBPUT SYSLOG\"\n   If i < ztdsels\n   Then \"TBDISPL SYSLOG POSITION(CRP)\"\n   End\nIf zverb = \"\"\nThen do\n   Msg = \"\"\n   Call find_commands\n   If msg == \"\"\n   Then call process_commands\n   Else \"SETMSG MSG(\"msg\")\"\n   End\nReturn\n\n/***********************************************************************\n* Find all line commands                                               *\n***********************************************************************/\nFind_commands:\n\n\"TBTOP SYSLOG\"\nAction = \"A\"\n\"TBSCAN SYSLOG ARGLIST(ACTION) CONDLIST(GE) ROWID(ROWID)\"\nTbscan_rc = rc\nCommand = action\nDsname.0 = 0\nSelect\n   When command == \"B\" | command == \"L\" | command == \"R\"\n   Then call single_line_commands\n   When command == \"BB\" | command == \"LL\" | command == \"RR\"\n   Then call block_line_commands\n   Otherwise nop\n   End\nReturn\n\n/***********************************************************************\n* Process selected rows                                                *\n***********************************************************************/\nProcess_commands:\n\n\"CONTROL DISPLAY SAVE\"\nSelect\n   When command == \"B\" | command == \"BB\"\n   Then call browse\n   When command == \"L\" | command == \"LL\"\n   Then call logscan\n   When command == \"R\" | command == \"RR\"\n   Then call recall(\"NOWAIT\")\n   Otherwise nop\n   End\n\"CONTROL DISPLAY RESTORE\"\nReturn\n\n/***********************************************************************\n* Flag selected rows with an asterisk                                  *\n***********************************************************************/\nFlag_selected_rows:\n\n\"TBTOP SYSLOG\"\nDo i = 1 to dsname.0\n   \"TBSKIP SYSLOG ROW(\"row.i\")\"\n   Action = \"*\"\n   \"TBPUT SYSLOG\"\n   End\nReturn\n\n/***********************************************************************\n* Build array of data sets selected by B or L line command             *\n***********************************************************************/\nSingle_line_commands:\n\nDo i = 1 by 1 while tbscan_rc = 0\n   If action \u00ac== command then do\n      Msg = \"LOG000\"\n      Leave i\n      End\n   Dsname.0 = i\n   Dsname.i = dsname\n   Row.i = rowid\n   Action = \"A\"\n   \"TBSCAN SYSLOG ARGLIST(ACTION) CONDLIST(GE) ROWID(ROWID)\"\n   Tbscan_rc = rc\n   End\nReturn\n\n/***********************************************************************\n* Build array of data sets selected by BB or LL line command           *\n***********************************************************************/\nBlock_line_commands:\n\n#commands = 0\nTbskip_rc = 0\nDo i = 1 by 1 while tbskip_rc = 0\n   If action \u00ac== command & action >> \"A\"\n   Then do\n      Msg = \"LOG000\"\n      Leave i\n      End\n   If #commands <= 1\n   Then do\n      Dsname.0 = i\n      Dsname.i = dsname\n      Row.i = rowid\n      End\n   If action == command\n   Then #commands = #commands+1\n   \"TBSKIP SYSLOG ROWID(ROWID)\"\n   Tbskip_rc = rc\n   End\nIf #commands \u00ac= 2 & msg == \"\"\nThen msg = \"LOG001\"\nReturn\n\n/***********************************************************************\n* Browse syslog data sets                                              *\n***********************************************************************/\nBrowse:\n\nIf \u00ac recall(\"WAIT\")\nThen return\nIf dsname.0 = 1\nThen do\n   \"CONTROL ERRORS RETURN\"\n   \"BROWSE DATASET('\"dsname.1\"')\"\n   If rc \u00ac= 0\n   Then \"SETMSG MSG(\"zerrmsg\")\"\n   \"CONTROL ERRORS CANCEL\"\n   End\nElse do\n   Dslist = \"\"\n   Do i = 1 to dsname.0\n      Dslist = dslist \"'\"dsname.i\"'\"\n      End\n   Address TSO \"ALLOCATE FILE(SYSLOG) DSNAME(\"dslist\") REUSE\"\n   \"SELECT PGM(BRSYSLOG)\"\n   Address TSO \"FREE FILE(SYSLOG)\"\n   End\nCall flag_selected_rows\nReturn\n\n/***********************************************************************\n* Invoke LOGSCAN for selected data sets                                *\n***********************************************************************/\nLogscan:\n\nLOGSCAN_processed_rows? = 0\nCall open_LOGSCAN_table\nIf \u00ac LOGSCAN_output?\nThen do\n   Listdsi_rc = listdsi(\"LOGSCAN.LIST\")\n   If listdsi_rc < 16\n   Then  LOGSCAN_output? = sysused \u00ac= 0\n   End\nZtdret = \"DOWN\"\n\"TBTOP   LOGSCAN\"\n\"TBSKIP  LOGSCAN\"\n\"TBDISPL LOGSCAN PANEL(LOGSCAN)\"\nLogscan_rc = rc\nDo while logscan_rc < 8\n   Call LOGSCAN_commands\n   If ztdadd == \"YES\"\n   Then \"TBDISPL LOGSCAN\"\n   Else do\n      \"TBTOP   LOGSCAN\"\n      \"TBSKIP  LOGSCAN NUMBER(\"ztdtop\") NOREAD\"\n      \"TBDISPL LOGSCAN PANEL(LOGSCAN)\"\n      End\n   Logscan_rc = rc\n   End\n\"TBBOTTOM LOGSCAN POSITION(ROWNUM) NOREAD\"\nDo while rownum > 4 & type = \"\"\n   \"TBDELETE LOGSCAN\"\n   \"TBSKIP   LOGSCAN NUMBER(0) POSITION(ROWNUM) NOREAD\"\n   End\n\"TBSAVE LOGSCAN LIBRARY(ISPPROF)\"\nIf LOGSCAN_processed_rows?\nThen call flag_selected_rows\nReturn\n\n/***********************************************************************\n* Create or open LOGSCAN parameter table                               *\n***********************************************************************/\nOpen_LOGSCAN_table:\n\n\"TBSTATS LOGSCAN STATUS1(STATUS1) STATUS2(STATUS2) LIBRARY(ISPPROF)\"\nSelect\n   When status1 = 2\n   Then do\n      \"TBCREATE LOGSCAN WRITE LIBRARY(ISPPROF) SHARE\",\n                       \"NAMES(TYPE PARM MARGIN1 MARGIN2 DATA)\"\n      \"TBVCLEAR LOGSCAN\"\n      Parse value \"\" with time1 time2\n      Parse value \"ON\" \"DATA\" \"Example\",\n            with  caps type   data\n      \"TBADD LOGSCAN SAVE(CAPS TIME1 TIME2) MULT(4)\"\n      \"TBVCLEAR LOGSCAN\"\n      Do 3; \"TBADD LOGSCAN\"; End\n      \"TBSAVE LOGSCAN LIBRARY(ISPPROF) PAD(100)\"\n      End\n   When status2 = 1\n   Then do\n      \"TBOPEN LOGSCAN WRITE LIBRARY(ISPPROF) SHARE\"\n      \"TBSKIP LOGSCAN\"\n      End\n   Otherwise nop\n   End\nReturn\n\n/***********************************************************************\n* Process LOGSCAN commands                                             *\n***********************************************************************/\nLOGSCAN_commands:\n\nSave_caps = caps\nSave_time1 = time1\nSave_time2 = time2\n\nDo ztdsels\n   If caps == \"ON\"\n   Then data = translate(data)\n   First = left(data,1)\n   Last = right(data,1)\n   If first \u00ac== last | datatype(first,\"alphanumeric\")\n   Then select\n      When pos(\"'\",data) = 0\n      Then data = \"'\"data\"'\"\n      When pos('\"',data) = 0\n      Then data = '\"'data'\"'\n      Otherwise data = \"FF\"x || data || \"FF\"x\n      End\n   \"TBPUT LOGSCAN\"\n   If ztdsels > 1\n   Then \"TBDISPL LOGSCAN\"\n   End\n\n\"TBTOP LOGSCAN\"\n\"TBSKIP LOGSCAN\"\nCaps = save_caps\nTime1 = save_time1\nTime2 = save_time2\n\"TBPUT LOGSCAN SAVE(CAPS TIME1 TIME2)\"\n\nIf ztdadd == \"YES\"\nThen do\n   If ztdscrp = 0\n   Then do\n      \"TBQUERY LOGSCAN ROWNUM(ROWNUM)\"\n      Ztdscrp = rownum + ztdamt - ztdsize + 1\n      End\n   \"TBBOTTOM LOGSCAN NOREAD\"\n   \"TBVCLEAR LOGSCAN\"\n   Do ztdamt\n      \"TBADD LOGSCAN MULT(\"ztdamt\")\"\n      End\n   End\n\nSelect\n   When zcmd == \"\" & ztdadd = \"NO\"\n   Then \"SETMSG MSG(LOG005)\"\n   When zcmd = 1\n   Then call LOGSCAN_foreground\n   When zcmd = 2\n   Then call LOGSCAN_batch\n   When zcmd = 3\n   Then call LOGSCAN_print\n   When zcmd = 4\n   Then call LOGSCAN_browse\n   When zcmd = 5\n   Then call LOGSCAN_clear\n   Otherwise nop\n   End\nReturn\n\n/***********************************************************************\n* Execute LOGSCAN in the foreground                                    *\n***********************************************************************/\nLOGSCAN_foreground:\n\nIf \u00ac recall(\"WAIT\")\nThen return\n\"FTOPEN TEMP\"\n\"FTINCL LOG\"\n\"FTCLOSE\"\n\"VGET (ZTEMPF)\"\nAddress TSO \"ALLOCATE FILE(SYSIN) DATASET('\"ztempf\"') REUSE\"\nIf listdsi_rc < 16\nThen address TSO \"ALLOCATE FILE(PRINT) DATASET(LOGSCAN.LIST) OLD REUSE\"\nElse address TSO \"ALLOCATE FILE(PRINT) DATASET(LOGSCAN.LIST) NEW REUSE\",\n                 \"RECFM(F B) LRECL(133) BLKSIZE(23408)\",\n                 \"SPACE(1,1) CYLINDERS\"\nDslist = \"\"\nDo i = 1 to dsname.0\n   Dslist = dslist \"'\"dsname.i\"'\"\n   End\nAddress TSO \"ALLOCATE FILE(LOG) DATASET(\"dslist\") SHR REUSE\"\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(LOGWAIT)\"\nAddress TSO \"CALL 'SYS1.MVSSERV(LOGSCAN)'\"\nLOGSCAN_output? = 1\n\"CONTROL ERRORS RETURN\"\n\"BROWSE DATASET(LOGSCAN.LIST)\"\nIf rc \u00ac= 0\nThen \"SETMSG MSG(\"zerrmsg\")\"\n\"CONTROL ERRORS CANCEL\"\nLOGSCAN_processed_rows? = 1\nReturn\n\n/***********************************************************************\n* Execute LOGSCAN in batch                                             *\n***********************************************************************/\nLOGSCAN_batch:\n\n\"DISPLAY PANEL(LOGJCL)\"\nIf rc > 0\nThen return\n\"FTOPEN TEMP\"\n\"FTINCL LOGJCL\"\n\"FTCLOSE\"\n\"VGET (ZTEMPF)\"\nCall \"OUTTRAP\" \"SUBMIT.\",\"*\"\nAddress TSO \"SUBMIT '\"ztempf\"'\"\nIf rc = 0 & submit.0 = 1\nThen do\n   Parse var submit.1 \"JOB\" jobname \"(\" .\n   Message = submit.1\n   \"SETMSG MSG(LOG002)\"\n   End\nElse do i = 1 to submit.0\n   Say submit.i\n   End\nCall \"OUTTRAP\" \"OFF\"\nDrop submit.\nLOGSCAN_processed_rows? = 1\nReturn\n\n/***********************************************************************\n* Print LOGSCAN data set                                               *\n***********************************************************************/\nLOGSCAN_print:\n\nIf \u00ac LOGSCAN_output?\nThen do\n   \"SETMSG MSG(LOG006)\"\n   Return\n   End\n\"DISPLAY PANEL(LOGPRINT)\"\nIf rc > 0\nThen return\nPrintds = \"PR\" \"DATASET(LOGSCAN.LIST)\" \"SYSOUT(\"logclass\")\",\n          \"COPIES(\"logcopy\")\" \"OUTDES(\"logfdef\")\" \"PAGELEN(\"logpage\")\"\nIf logtitle == \"YES\"\nThen printds = printds \"TITLE\"\nElse printds = printds \"NOTITLE\"\nIf logdest \u00ac== \"\"\nThen printds = printds \"DEST(\"logdest\")\"\nSelect\n   When logline1 \u00ac== \"\" & logline2 \u00ac== \"\"\n   Then printds = printds \"LINES(\"logline1\":\"logline2\")\"\n   When logline1 \u00ac== \"\"\n   Then printds = printds \"LINES(\"logline1\")\"\n   Otherwise nop\n   End\nAddress TSO printds\nIf rc < 8\nThen \"SETMSG MSG(LOG003)\"\nElse \"SETMSG MSG(LOG004)\"\nReturn\n\n/***********************************************************************\n* Browse LOGSCAN data set                                              *\n***********************************************************************/\nLOGSCAN_browse:\n\nIf \u00ac LOGSCAN_output?\nThen do\n   \"SETMSG MSG(LOG006)\"\n   Return\n   End\n\"CONTROL ERRORS RETURN\"\n\"BROWSE DATASET(LOGSCAN.LIST)\"\nIf rc \u00ac= 0\nThen \"SETMSG MSG(\"zerrmsg\")\"\n\"CONTROL ERRORS CANCEL\"\nReturn\n\n/***********************************************************************\n* Clear LOGSCAN table                                                  *\n***********************************************************************/\nLOGSCAN_clear:\n\n\"TBBOTTOM LOGSCAN POSITION(ROWNUM) NOREAD\"\nDo while rownum > 4\n   \"TBDELETE LOGSCAN\"\n   \"TBSKIP   LOGSCAN NUMBER(0) POSITION(ROWNUM) NOREAD\"\n   End\n\"TBVCLEAR LOGSCAN\"\nDo while rownum > 1\n   \"TBPUT  LOGSCAN\"\n   \"TBSKIP LOGSCAN NUMBER(-1) POSITION(ROWNUM) NOREAD\"\n   End\n\"TBGET LOGSCAN SAVENAME(SAVE) NOREAD\"\nParse value \"\" with time1 time2\n\"TBPUT  LOGSCAN SAVE\"save\n\"TBSAVE LOGSCAN LIBRARY(ISPPROF)\"\nReturn\n\n/***********************************************************************\n* Recall migrated data sets                                            *\n***********************************************************************/\nRecall:\n\nParse arg type  /* WAIT or NOWAIT */\nRecall_ok? = 1\n\"TBTOP SYSLOG\"\nDo i = 1 to dsname.0\n   \"TBSKIP SYSLOG ROW(\"row.i\")\"\n   If action == \"R\" | action == \"RR\"\n   Then action = \"\"\n   If status == \"Migrated\" | status == \"Recalled\"\n   Then do\n      Call listdsi \"'\"dsname.i\"' NORECALL\"\n      Online? = sysreason = 0\n      Migrated? = sysreason = 9 | sysreason = 25\n      If migrated?\n      Then do\n         If type == \"WAIT\"\n         Then do\n            \"CONTROL DISPLAY LOCK\"\n            \"DISPLAY PANEL(LOGHRECA)\"\n            End\n         Address TSO \"HRECALL '\"dsname.i\"'\" type \"EXTENDRC\"\n         Recalled? = rc = 0\n         Hsm_rc = rc/65536\n         Hsm_reason = rc//65536\n         Attention? = hsm_rc = 100\n         End\n      Else parse value \"1       0         0         0         \",\n                 with   online? migrated? recalled? attention?\n      Select\n         When online? | (migrated? & recalled? & type == \"WAIT\")\n         Then do  /* data set online */\n            Status = \"\"\n            \"TBPUT SYSLOG\"\n            End\n         When type == \"NOWAIT\"\n         Then do  /* asynchronous recall */\n            Status = \"Recalled\"\n            \"TBPUT SYSLOG\"\n            Recall_ok? = 0\n            End\n         When migrated? & attention?\n         Then do  /* recall in progress */\n            Status = \"Recalled\"\n            \"TBPUT SYSLOG\"\n            \"SETMSG MSG(LOG008)\"\n            Recall_ok? = 0\n            End\n         Otherwise\n            \"SETMSG MSG(LOG007)\"\n            Recall_ok? = 0\n         End\n      End\n   End i\nReturn recall_ok?\n\n/***********************************************************************\n* Trap uninitialized variables                                         *\n***********************************************************************/\nNovalue:\n\nSay \"Uninitialized variable in line\" sigl\":\"\nSay sourceline(sigl)\nTrace \"?Results\"\nNop\n./ ADD NAME=LOGSCAND 0100-90124-90124-0808-000479-000479-000000-$A1238\n:h2.LOGSCAN\n.sp 2\n.fo off\n                           A Service Aid Program\n            To print certain information or a certain time period\n                            from the system log.\n       ------------------ Installation suggestions -------------------\n             link the object deck to AOST.LOAD or a user library,\n             using the following JCL.\n        //LINK EXEC PGM=IEWL,PARM='XREF,LET,LIST,NCAL',REGION=128K\n        //SYSLMOD DD DSN=AOST.LOAD(LOGSCAN),DISP=SHR\n        //SYSLIN DD *\n                 ---- Put object deck here ----\n        /*\n        //SYSUT1 DD DSN=&&TEMP,UNIT=SYSDA,SPACE=(1024,(50,20))\n        //SYSPRINT DD SYSOUT=A\n             You may want to use a cataloged procedure for LOGSCAN.\n             Here is a sample proc that allows a canned routine\n             to be concatenated to the control card input.\n             Assume that the pds which contains the routines has\n             a member null which has no records.\n        //LOGSCAN PROC DSN=' ',DISP='SHR,PASS',ROUTINE=NULL\n        //A       EXEC PGM=LOGSCAN\n        //SYSIN   DD   DDNAME=SYSIN\n        //        DD   DSN=SYS1.LOGSCAN(&ROUTINE),DISP=SHR\n        //LOG     DD   DSN=&DSN,DISP=(&DISP)\n        //PRINT   DD   SYSOUT=A\n             If you anticipate using LOGSCAN from a TSO\n             terminal, see below for an example of a\n             CLIST which will invoke LOGSCAN.\n             The default blocksize for the print data set can be\n             altered permanently by zapping location x'20' to the\n             halfword value desired. -  VER 0020 07CB\n             To help identify the date of a log data set, LOGSCAN\n             recognizes the date from message IEE102I as it appears\n             in the log from a JES3/MVS system.  A record is printed\n             the first time this message is found and each time the\n             date changes.  To utilize this feature on other types of\n             systems, add a message that will be issued periodically\n             in this format -          IEE102I hh.mm.ss yy.ddd\n             where the message id begins in the 40th position,\n             or zap location x'22' to the position of 'IEE102I'\n             in your log (relative to 1). This is a halfword value\n             in hexadecimal. -  VER 0022 0028\n             (for an unmodified JES2 system this would be the 25th\n             position, or x'19'. - REP 0022 0019)\n             if your log has its timestamps in a position other than\n             those mentioned on page 4, you may zap the halfword\n             value of its position (relative to 1) into\n             location x'24'. -  VER 0024 0001\n:h3.LOGSCAN         JCL\n        //JOBNAME  JOB\n        //A        EXEC PGM=LOGSCAN\n        //PRINT DD SYSOUT=A                         (PRINTED OUTPUT)\n        //LOG   DD DISP=SHR,DSN=SYSLOG              (LOG DATA SET)\n        //SYSIN DD *                                (CONTROL DATA SET)\n             This JCL is sufficient to scan the current system log\n             when one data set is empty.  (This will not work for an\n             MVS system log.  Specify a data set created by an\n             external writer.)  Examples of other uses appear\n             on page 9.\n:h3.Input         Data Sets\n             LOGSCAN will process fixed, fixed blocked, variable\n             and variable blocked data with LRECL not larger than\n             133, or undefined records with BLKSIZE not larger\n             than 133.  As a convenience, LOGSCAN will accept\n             records up to 255 bytes long, but only the first\n             133 bytes can be scanned, printed or punched.\n             LOGSCAN strips the first byte from input records\n             if print control characters are indicated\n             in the JCL or the data set label.  The record\n             descriptor word is removed from variable records.\n             The control data set is fixed or fixed blocked with\n             LRECL of 80.  Unlike data sets can be concatenated.\n:h3.Output         Data Sets\n             Print output is RECFM=FB,LRECL=133.  A BLKSIZE of 1995\n             is assumed unless otherwise specified in the JCL as a\n             multiple of 133.  The output is always single-spaced.\n             The print data set contains a listing of the control\n             statements used, the records selected, and statistics\n             about the number of records processed. The statistics\n             kept are total records read from the log data set,\n             the number within the specified time and sequence\n             numbers, and the number finally selected.  An identifier\n             is printed each time a new date is obtained from message\n             IEE102I (MVS activity message) or IAT3100 (JES3 restart).\n             The statistics do not include these records.\n             Punch output is provided if //PUNCH DD IS INCLUDED IN THE\n             JCL for a step.  Recfm is FB, and LRECL is assumed to be\n             80 unless specified in the JCL.  Blksize is assumed to\n             be the same as LRECL unless it is specified in the JCL.\n             Records longer than the LRECL are truncated.  Only\n             selected records are included in this data set.\n:h3.Performance         Considerations\n             LOGSCAN may be executed on OS/360 or OS/VS systems.\n             The amount of CPU time used varies greatly, depending on\n             the size of the data set being processed, the number of\n             data type control statements, the range of time\n             specified, and use of the margin control card.  If the\n             position of a desired message is known, a margin card\n             can be used to compare that one position instead of\n             comparing 133 positions.  This also can prevent unwanted\n             records from being printed.  If several data type cards\n             are being used with a large data set, judicious use of\n             the time card can reduce the run time considerably.\n:h3.Condition         Codes\n             The following condition codes are returned by LOGSCAN\n        0 - normal run\n        1 - no output because no records matched the argument\n        2 - empty data set\n        4 - data set LRECL larger than 255\n        8 - control card had syntax error\n       12 - required dd card missing\n:h3.Parms\n             The parm field on the EXEC card or in the TSO call\n             statement may be used to override the default values for\n             the location of the timestamps and the location of\n             message IEE102I within the log records, as well as to\n             indicate a TSO session.\n        T=ppp   (where ppp is the position of the first character of\n             the timestamp) can be used when the timestamp is 6 to 8\n             digits long, but does not appear in position 1.\n        I=ppp   (where ppp is the position where message IEE102I would\n             start) can be used if message IEE102I appears in the log,\n             but does not start in position 40.\n             For example, the following statement -\n        CALL 'AOST.LOAD(LOGSCAN)' 'TSO,T=16,I=25'\n             Indicates that control statements are being entered from\n             a terminal, that the timestamp is to be found in\n             position 16 instead of 1, and that message IEE102I is to\n             be found in position 25 instead of 40.\n:h3.Control         Cards\n             All control cards are optional except that at least\n             a time card or sequence card or one or more data type\n             cards is required.  Statements may begin in any column.\n        TIME=hhmm,hhmm\n             Specifies the beginning and end of the desired period.\n             If used with data type cards, only records within this\n             time will be scanned for the specified data.\n             The last time card read is effective for the entire step.\n             HHMM must be four digits, with leading zeros if needed.\n             If the beginning time is greater than the ending time,\n             it is assumed that a time period spanning midnight\n             is desired.  The program processes records up to the\n             end of the data set, so records from more than one\n             day may be produced.  LOGSCAN recognizes time stamps\n             of 6 to 8 digits starting in position 1 or 2 of\n             each record or in the format hh.mm.ss starting in\n             position 6.  Records without time stamps are handled\n             according to the most recent time-stamped record.\n        MARGIN=sss,eee\n             Sets limits of the scan, if desired.  Default is 1,133.\n             This sets the range of positions the first character\n             of data must be found in.  As many margin cards as\n             desired can be used.  Each one is effective for all\n             data type cards following it until reset by another\n             margin card.  Sss and eee can be one to three digits\n             with values between 1 and 133.  If eee is omitted, it is\n             assumed to be the same as sss, I.E. Only one position.\n             A forms ruler may be used with a sample of a data set\n             for exact margin determination, since control characters\n             and record descriptor words are removed before\n             processing, and only data is scanned.\n        DATA='--character string--',WORD\n        OR=                        ,ABBR\n        AND=\n        NOT=\n             Used to select or exclude records with certain data.\n             The WORD parameter, if used, requires the matching data\n             to be surrounded by blanks or punctuation. This is useful\n             when using a short search argument such as a job number\n             or device number which could also appear as part of an\n             unrelated name, to reduce unwanted output.  Characters\n             other than letters, numbers, and national characters are\n             considered to be punctuation.  The ABBR parameter\n             requires the matching data to be preceded by a blank\n             or punctuation.  This would be desired, for example,\n             when searching for a certain message prefix.  If neither\n             parameter is specified, matching data will be selected\n             even if it is embedded in a longer name.\n             Any character can be used in lieu of the apostrophes,\n             provided the first one immediately follows the equal\n             sign, and the character is not included in the data.\n             NOT= causes a record with that data to be omitted.\n             AND= requires a record to match the data from this card\n             as well as previous card(s).  Any number of data type\n             cards may be used.  If AND= or NOT= cards are used in\n             an argument, they must follow all OR= and DATA= cards\n             in that argument.  DATA= can be use interchangeably\n             with OR=.\n        SAVE\n             or\n        SAVE2\n             or\n        PRINT\n             or\n        NEXT\n             or\n        SKIP\n             or\n        / (Begin a new search argument)\n             See complex search arguments below for explanation\n             of these six control statements.\n        * -----Comment-----\n             A card beginning with an asterisk can contain comments.\n             Comments may also appear in any control card if they are\n             separated from the operands by one or more blanks.\n        GO\n             When entering control statements from a TSO terminal,\n             go may be used instead of /* when all statements have\n             been entered.  This keeps the SYSIN data set open and\n             allows the program to request omitted control statements.\n        NOPRINT\n             If this statement is used, selected records will not\n             appear in the print data set.  It could be used when\n             selecting a large number of records for output to the\n             punch data set, or for counting types of records.\n        SET ssssssss=vvvvvvvvvvvv\n             see symbolic variables below for explanation\n             of this statement.\n:h3.Sequence         Control\n             An additional control statement is provided for use\n             with data sets which have sequence numbers but not\n             a time stamp.  It would be used for the same purpose\n             as the TIME= control card would be for the system log.\n             Any or all of the five keywords may appear in this\n             statement in any order, but all keywords must appear in\n             the same card, and only the last statement of this type\n             is effective.\n        START=xxxxxxxx\n             Code a value from 0 to 99999999.  Sequence numbers\n             below this value will not be printed.\n        STOP=yyyyyyyy\n             Code a value from 0 to 99999999. Sequence numbers\n             above this value will not be printed.\n        COLUMN=ccc\n             Code a value from 1 to 133. This defines the position of\n             the sequence field in the records.\n        LENGTH=n\n             Code a value from 1 to 8.  This is the length of\n             the sequence field.\n        TYPE=hex\n             Should be specified if the data to be compared is\n             hexadecimal representation, such as hex addresses at the\n             left side of a formatted dump.  Otherwise the fields\n             will be compared using ebcdic collating sequence.\n             If any keyword is omitted or misspelled, the\n             following defaults are assumed -\n                  START     hexadecimal zeros\n                  STOP      hexadecimal f's\n                  COLUMN    73\n                  LENGTH    8\n                  TYPE      char\n             Leading zeros are not necessary.  The column value and\n             the start and stop values will have their high-order\n             characters truncated or padded with zeros if they\n             are longer or shorter than the specified length.\n             Special characters, except commas and blanks,\n             may be used in the start and stop values, if TYPE=hex\n             is not specified.\n:h3.Complex         Search Arguments\n             In any search argument which contains more than one\n             type of control card, OR= cards can be considered as\n             paired with the preceding control card and evaluated\n             before the and= cards.  The following set of control\n             cards,\n                  DATA='a'\n                  DATA='b'\n                  AND='c'\n             Would be evaluated as (a or b) and c.\n             To allow an argument such as a or (b and c) another\n             control card is used.  A statement consisting of a slash\n             causes LOGSCAN to begin a new search argument.  If a\n             record is not selected under the first argument, it will\n             still be printed if it qualifies under another argument.\n             Therefore a slash card can be considered to represent\n             an or between two parenthesized expressions in a\n             complex search argument.  A or (b and c) would be\n             accomplished by\n                  DATA='a'\n                  /\n                  DATA='b'\n                  AND='c'\n             (a and b) or (c and d) would be represented by\n                  DATA='a'\n                  AND='b'\n                  /\n                  DATA='c'\n                  AND='d'\n             (a or b) and (c or d) would have to be rearranged as\n             (a and c) or (a and d) or (b and c) or (b and d)\n                  DATA='a'\n                  AND='c'\n                  /\n                  DATA='a'\n                  AND='d'\n                  /\n                  DATA='b'\n                  AND='c'\n                  /\n                  DATA='b'\n                  AND='d'\n             The save control statement is a variation of the card\n             beginning with a slash. It defines the end of an argument\n             and also indicates that any record selected using that\n             argument is not to be printed until a record is selected\n             under another argument ending with a slash.  The saved\n             record will be printed before the new record.  The saved\n             record will not be printed again, but other records found\n             under that search argument will be saved and processed\n             in the same way.  Only the last saved record will be\n             printed before the record from another argument.\n             The SAVE2 statement provides the ability to save another\n             type of record without affecting the record saved using\n             the SAVE statement.  If records have been saved for\n             both arguments, the SAVE2 record will always be printed\n             after the SAVE record, regardless of the order of their\n             occurence in the original data set.\n             The PRINT control statement causes records selected\n             under that argument to be printed without affecting\n             any record which has been saved.  Note that use of this\n             statement may cause records to be printed in a different\n             order than the original, because a record may have been\n             saved before which will not be printed until a record\n             is selected using an argument which ends with a slash\n             card.\n             The NEXT statement causes a record to be printed only\n             if it is the first one after a record selected\n             using an argument which ends with a slash card.\n             The SKIP statement causes records to be ignored.  This\n             can be used to thin out records and reduce the need for\n             many NOT= statements in subsequent arguments.\n             A SLASH control statement is assumed for the last\n             argument in the control data set unless a SAVE or SAVE2\n             or PRINT or NEXT or SKIP statement is used.  Records are\n             processed according to the first argument which they\n             match.  If a record would be selected under more than one\n             argument and it is desired that it always be printed,\n             save and next arguments should be coded last.\n             Since the statements in the following group are mutually\n             exclusive in the same argument, only the last one coded\n             will be honored if they appear consecutively:\n             - SAVE SAVE2 PRINT NEXT SKIP -\n:h3.Examples\n             The following job step will print all scheduler\n             messages for a one hour period from a system log that\n             has been copied to a cataloged gdg tape.  Assume that\n             on this system all OS/VS messages begin in position 25\n             of the system log records.\n        //A EXEC PGM=LOGSCAN\n        //PRINT DD SYSOUT=A\n        //LOG DD DSN=HISTORY.SYSVLOG(-3),DISP=SHR\n        //SYSIN DD *\n         TIME=2145,2245\n         MARGIN=25\n         DATA='IEF',ABBR\n        /*\n             The following will print a condensed version of a\n             superzap dump showing only lines containing VOLSTAT\n             SVC instructions and the CSECTS in which they are found.\n        //A EXEC PGM=AMASPZAP\n        //SYSLIB DD DSN=SYS1.LPALIB,DISP=SHR\n        //SYSPRINT DD DSN=&&TEMP,UNIT=SYSDA,DISP=(NEW,PASS),\n        // SPACE=(TRK,(10,10)),DCB=(RECFM=FBA,LRECL=121,BLKSIZE=1210)\n        //SYSIN DD *\n         DUMPT IEFW21SD ALL\n        //B EXEC PGM=LOGSCAN\n        //PRINT DD SYSOUT=A\n        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)\n        //SYSIN DD *\n         DATA='0A5B',WORD\n         /\n         MARGIN=76\n         DATA='CSECT'\n         SAVE\n        /*\n             The following step will print all references to\n             a certain register name, except in comment statements,\n             from a member of a macro library.  Only a certain range\n             of sequence numbers is of interest.\n        //A EXEC PGM=LOGSCAN\n        //PRINT DD SYSOUT=A\n        //LOG DD DSN=SYS1.AMODGEN(IECINT),DISP=SHR\n        //SYSIN DD *\n         START=48000000,STOP=52000000\n         MARGIN=16,66\n         DATA='UCBREG',WORD\n         MARGIN=1\n         NOT='*'\n        /*\n             The following will print all references to volume DLIB01\n             for a 16-day period from an accumulated LOGREC history\n             data set.  MDR records will be skipped.\n        //EVENT EXEC PGM=IFCEREP1,\n        // PARM=('EVENT,HIST,ACC=N,TABSIZE=500K',\n        // 'DATE=(78276,78291),LINECT=60')\n        //EREPPT   DD DCB=BLKSIZE=6384,DISP=(,PASS),UNIT=SYSDA,\n        // DSN=&&TEMP,SPACE=(TRK,(500,250),RLSE)\n        //TOURIST  DD SYSOUT=A,DCB=BLKSIZE=1995\n        //DIRECTWK DD UNIT=(SYSDA,2),SPACE=(CYL,(50,20))\n        //ACCIN    DD DSN=LOGREC.HISTORY(-0),DISP=SHR\n        //SCAN EXEC PGM=LOGSCAN\n        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)\n        //PRINT DD SYSOUT=A\n        //SYSIN DD *\n         DATA='DLIB01'\n         MARGIN=22\n         NOT='MDR-DAS'\n         /\n         MARGIN=1\n         DATA='DATE'\n         SAVE\n             The following will print a list of all members of a load\n             library that contain CSECTS assembled by VS1 assembler\n             version 1.01.\n        //IDRLIST EXEC PGM=AMBLIST,REGION=180K\n        //SYSLIB DD DSN=SYS1.TELCMLIB,DISP=SHR\n        //SYSPRINT DD DSN=&&TEMP,DISP=(,PASS),UNIT=SYSDA,\n        // SPACE=(CYL,(5,5)),DCB=BLKSIZE=6413\n        //SYSIN DD *\n         LISTIDR OUTPUT=ALL\n        //SCAN EXEC PGM=LOGSCAN\n        //PRINT DD SYSOUT=A\n        //LOG DD DSN=&&TEMP,DISP=(OLD,DELETE)\n        //SYSIN DD *\n         MARGIN=24\n         DATA='5741'\n         MARGIN=49\n         AND='01.01'\n         /\n         MARGIN=10\n         DATA='------'\n         SAVE\n         DATA='MEMBER'\n         SAVE2\n:h3.TSO\n             To facilitate the use of LOGSCAN from a terminal,\n             specify 'TSO' in the parm field when calling the program.\n             This will bypass the listing of control statements as\n             they are entered, and will cause prompting messages at\n             the start of the run and permit re-entering invalid\n             control statements.\n             The following CLIST can be added as a member of the\n             sysproc data set and used as a command to invoke LOGSCAN.\n        PROC 1 DATASETNAME\n        ALLOCATE FILE(LOG) DATASET(&DATASETNAME.) SHR\n        ALLOCATE FILE(PRINT) DATASET(*)\n        ALLOCATE FILE(SYSIN) DATASET(*)\n        CALL 'AOST.LOAD(LOGSCAN)' 'TSO'\n:h3.Symbolic         Variables\n             The use of symbolic variables in a canned routine\n             allows frequently used routines to be easily modified.\n             The symbolic variables in the procedure are defined as\n             one- to eight-character names preceded by an ampersand.\n             The first character must be alphabetic, and the following\n             characters may be alphanumeric.  If the field following\n             the symbol is alphanumeric, the symbol must be terminated\n             with a period.  If a period is desired following the\n             symbol, two periods must be coded.  Default values for\n             the symbols can be established by providing set\n             statements in the procedure.  Only the first definition\n             of a symbolic value is effective, so the default value\n             coded in the procedure will be ignored if a set statement\n             is provided by the user.  The SET statement must appear\n             before the statement(s) where the value is to be changed.\n             The format of the SET statement is:\n                  SET ssssssss=vvvvvvvvvvvv\n             where ssssssss is the symbolic name without the ampersand\n             and vvvvvvvvvvvv is the variable data to replace it.\n             The variable data may not contain blanks, although\n                  SET ssssssss=\n             may be used to nullify the symbol.\n             For example, the following statements -\n                  SET MARG1=27\n                  SET MARG2=,44\n                  SET MARG2=\n                  MARGIN=&MARG1&MARG2     START AT POSITION &MARG1..\n             Would be evaluated as\n                  MARGIN=27,44    START AT POSITION 27.\n./ ADD NAME=MSGS\n+/ ADD NAME=LOG00    0100-90106-90106-1544-00018-00014-00000-$A1019\nLOG000 'Command conflict' .ALARM = YES\n'When multiple line commands are used they must all be the same'\nLOG001 'Command conflict ' .ALARM = YES\n'There must be exactly two BB, LL, or RR line commands'\nLOG002 '&JOBNAME submitted'\n'&MESSAGE'\nLOG003 'Print successful'\n'LOGSCAN output successfully printed'\nLOG004 'Print failed'\n'Attempt to print LOGSCAN output failed'\nLOG005 'Enter option' .ALARM = YES\n'Enter one of the listed options'\nLOG006 'No LOGSCAN output'\n'No output exists from foreground execution of LOGSCAN'\nLOG007 'Recall failed'\n'HRECALL failed: rc=&HSMRC, reason=&HSMREAS, dsname=&DSNAME'\nLOG008 'Recall wait terminated'\n'SYSLOG data set &DSNAME is being recalled asynchronously'\n./ ADD NAME=PANELS\n+/ ADD NAME=LOGHRECA 0100-90106-90106-1542-00008-00008-00000-$A1019\n%------------------------- Recall of SYSLOG Data Set --------------------------%\n%                                                                              %\n%                                                                              %\n+SYSLOG data set &DSNAME is being recalled by DFHSM.\n+\n+You may press your attention key to terminate waiting. The recall will then\n+proceed asynchronously.\n)End\n+/ ADD NAME=LOGJCL   0100-90064-90078-1754-00041-00030-00000-$A1019\n%-------------------------- Submit Batch LOGSCAN Job --------------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+Copies           %===>_Z  +                     (1-255)\n+Sysout class     %===>_Z+                       (A-Z,0-9)\n+Destination      %===>_LOGDEST +                (Overrides your default)\n+Output descriptor%===>_LOGOUT  +                (Duplex, Simplex, or Tumble)\n+\n+\n+JOB Statement Information:\n+\n+  mask //jobname  JOB 'Name      MailDptGrp*DivAcct              lllfffp   ',\n+ %===>_ZLLGJOB1\n+  mask //             TIME=nnnn\n+ %===>_ZLLGJOB2\n+ %===>_ZLLGJOB3\n+ %===>_ZLLGJOB4\n)Init\n\n .ZVARS = '(LOGCOPY LOGCLASS)'\n .HELP = LOGTUT4\n &ZCMD = &Z\n If (&LOGCOPY = &Z) &LOGCOPY = 1\n If (&LOGCLASS = &Z) &LOGCLASS = A\n If (&LOGOUT = &Z) &LOGOUT = DUPLEX\n\n)Proc\n\n Ver (&LOGCOPY,nonblank,num)\n Ver (&LOGCOPY,range,1,255)\n Ver (&LOGCLASS,nonblank,list,\n      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9)\n Ver (&LOGDEST,name)\n &LOGOUT = trans(trunc(&LOGOUT,1) D,DUPLEX S,SIMPLEX T,TUMBLE *,*)\n Ver (&LOGOUT,list,DUPLEX,SIMPLEX,TUMBLE)\n Ver (&ZLLGJOB1,nonblank)\n Ver (&ZLLGJOB2,nonblank)\n Vput (LOGCOPY,LOGCLASS,LOGDEST,LOGOUT,\n       ZLLGJOB1,ZLLGJOB2,ZLLGJOB3,ZLLGJOB4) profile\n\n)End\n+/ ADD NAME=LOGLIST  0100-90053-90106-1409-00027-00025-00000-$A1019\n)Attr\n\n ! Type(input) intens(high) caps(on) pad('_') just(left)\n @ Type(output) intens(low) caps(off) just(asis)\n $ Type(text) intens(high) caps(off) color(turq) hilite(uscore)\n\n)Body\n%------------------- SYSLOG Console Message Logs for &CNTR --------------------%\n%Command ===>_ZCMD                                            %Scroll ===>_AMNT%\n%Actions: B,BB=Browse L,LL=LOGSCAN R,RR=Recall; Press HELP (&HELP) for details %\n$Action+$Starting Date   $Time +    $Ending Date     $Time +    $Status  +\n)Model\n+ !Z +  @Z  @Z    @Z     @Z    +    @Z  @Z    @Z     @Z    +    @STATUS\n)Init\n\n .ZVARS = '(ACTION SDAYNAME SDATE SJDATE STIME EDAYNAME EDATE EJDATE ETIME)'\n .CURSOR = ACTION\n .HELP = LOGTUT0\n\n &ZCMD = &Z\n &HELP = pfk(help)\n\n)PROC\n\n If (&ZTDSELS ^= 0000) ver (&ACTION,list,B,BB,L,LL,R,RR)\n\n)End\n+/ ADD NAME=LOGPRINT 0100-90071-90074-1907-00040-00048-00000-$A1019\n%---------------------------- Print LOGSCAN Output ----------------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+First line number%===>_LOGLINE1+\n+Last line number %===>_LOGLINE2+\n+Titles/page #    %===>_LOGTITLE                    (YES or NO)\n+Page length      %===>_Z   +                       (6-4095)\n+Copies           %===>_Z  +                        (1-255)\n+Sysout class     %===>_Z+                          (A-Z,0-9)\n+Destination      %===>_LOGDEST +                   (Overrides your default)\n+Form definition  %===>_LOGFDEF +                   (Simplex, Duplex, or Tumble)\n)Init\n\n .ZVARS = '(LOGPAGE LOGCOPY LOGCLASS)'\n .HELP = LOGTUT4\n &ZCMD = &Z\n If (&LOGTITLE = &Z) &LOGTITLE = NO\n If (&LOGPAGE = &Z) &LOGPAGE = 60\n If (&LOGCOPY = &Z) &LOGCOPY = 1\n If (&LOGCLASS = &Z) &LOGCLASS = A\n If (&LOGFDEF = &Z) &LOGFDEF = DUPLEX\n\n)Proc\n\n Ver (&LOGLINE1,num)\n Ver (&LOGLINE2,num)\n &LOGTITLE = TRANS(TRUNC(&LOGTITLE,1) Y,YES N,NO *,*)\n Ver (&LOGTITLE,nonblank,list,YES,NO)\n Ver (&LOGPAGE,nonblank,num)\n Ver (&LOGPAGE,range,6,4095)\n Ver (&LOGCOPY,nonblank,num)\n Ver (&LOGCOPY,range,1,255)\n Ver (&LOGCLASS,nonblank,list,\n      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,0,1,2,3,4,5,6,7,8,9)\n Ver (&LOGDEST,name)\n &LOGFDEF = trans(trunc(&LOGFDEF,1) S,SIMPLEX D,DUPLEX T,TUMBLE *,*)\n Ver (&LOGFDEF,list,DUPLEX,SIMPLE,TUMBLE)\n Vput (LOGTITLE,LOGPAGE,LOGCOPY,LOGCLASS,LOGDEST,LOGFDEF) profile\n\n)End\n+/ ADD NAME=LOGSCAN  0100-90059-90081-1545-00048-00037-00000-$A1019\n)Attr\n\n _ Type(input) caps(on)  intens(high)\n [ Type(input) caps(off) intens(high)\n ^ Type(text)  skip(on)  intens(low)\n\n)Body\n%--------------- Scan SYSLOG Console Message Log(s) Via LOGSCAN ---------------%\n%Option ===>_ZCMD                                             %Scroll ===>_AMNT%\n%Options:  1=Foreground  2=Batch  3=Print  4=Browse  5=Clear                   %\n+\n+Caps (ON or OFF)%===>_Z  ^                                     (Translate data)\n+Starting time   %===>_Z   ^        Ending time %===>_Z   ^     (hhmm)\n+\n)Model\n+DATA, OR, AND, NOT, /%===>_TYPE^   WORD, ABBR  %===>_PARM^\n+Left margin          %===>_Z  ^    Right margin%===>_Z  ^      (1-126)\n+Data%===>[DATA\n+\n)Init\n\n .ZVARS = '(CAPS TIME1 TIME2 MARGIN1 MARGIN2)'\n .CURSOR = ZCMD\n .HELP = LOGTUT4\n &ZCMD = &Z\n\n)Proc\n\n Ver (&ZCMD,num)\n Ver (&ZCMD,range,1,5)\n If  (&ZCMD ^= &Z)\n     Ver (&TIME1,pict,nnnn)\n     Ver (&TIME2,pict,nnnn)\n     &CAPS = trans(trunc(&CAPS,2) ON,ON OF,OFF *,*)\n     Ver (&CAPS,nonblank,list,ON,OFF)\n If  (&ZTDSELS ^= 0000)\n     &TYPE = trans(trunc(&TYPE,1) D,DATA O,OR A,AND N,NOT '/','/' *,*)\n     If (&DATA ^= &Z) ver (&TYPE,nonblank)\n     Ver (&TYPE,list,DATA,OR,AND,NOT,'/')\n     &PARM = trans(trunc(&PARM,1) W,WORD A,ABBR *,*)\n     Ver (&PARM,list,WORD,ABBR)\n     Ver (&MARGIN1,num)\n     Ver (&MARGIN1,range,1,126)\n     Ver (&MARGIN2,num)\n     Ver (&MARGIN2,range,1,126)\n     If  (&TYPE = DATA,OR,AND,NOT)  ver (&DATA,NONBLANK)\n\n)End\n+/ ADD NAME=LOGTUT0  0100-90072-90106-1418-00031-00001-00000-$A1019\n%TUTORIAL --------------- SYSLOG Console Message Logs ---------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n%SYSLOG+is a chronological log of operator console messages.\n+31 days of SYSLOG data sets are maintained.\n+\n+The data sets may be browsed directly, or records with specific contents may be\n+selected with the LOGSCAN program.\n+\n+The following topics are presented in sequence, or may be selected by number:\n+\n%1+List of available SYSLOG data sets\n%2+Format and contents of SYSLOG records\n%3+Browsing SYSLOG\n%4+Selecting SYSLOG records via LOGSCAN\n%5+Recalling migrated SYSLOG data sets\n)Init\n\n &ZUP = LOGTUT0\n\n)Proc\n\n &ZSEL = TRANS(&ZCMD 1,LOGTUT1\n                     2,LOGTUT2\n                     3,LOGTUT3\n                     4,LOGTUT4\n                     5,LOGTUT5\n                     ' ',' '\n                     *,?)\n\n)End\n+/ ADD NAME=LOGTUT1  0100-90073-90074-1418-00029-00029-00000-$A1019\n)Attr\n\n $ Type(text) intens(high) color(pink) hilite(uscore)\n\n)Body\n%TUTORIAL --------------- SYSLOG Console Message Logs ---------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+The initial SYSLOG panel lists all available SYSLOG data sets. Data sets are\n+kept for 31 days, but there will generally be more than 31 data sets. You may\n+scroll through this list and select one or more data sets.\n+\n+SYSLOG is initially a private sysout data set which belongs to the operating\n+system. The WRITELOG (W) operator command closes the data set, queues it for\n+output, and opens a new one. An external writer then allocates a new online\n+data set and copies the sysout data to it.\n+\n+The WRITELOG command is issued automatically on a periodic basis. It may also\n+be issued manually at any time. In addition, a new SYSLOG data set is started\n+whenever an IPL occurs.\n+\n$WARNING!+Occasionally multiple sysout data sets are queued. The external writer\n+will combine them all into a single data set, but they may be out of\n+chronological order. This can also cause the date/time display to be wrong.\n)Init\n\n &ZUP = LOGTUT0\n\n)End\n+/ ADD NAME=LOGTUT2  0100-90074-90074-1945-00031-00030-00000-$A1019\n%TUTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%\n+Most SYSLOG records are written by JES3 as follows:\n+   ccc  nnnnnnnn yyddd hhmmsst ia <prefix> message\n+\n+Before JES3 is initialized SYSLOG records are written by MVS as follows:\n+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message\n+   t                                                    message\n+   t                                   lid              message\n+\n+Not all messages are logged:\n+  . The CONSOLxx member of SYS1.PARMLIB controls which messages are logged.\n+  . Logging may be prevented for individual messages via the MCSFLAG=NOCPY\n+    parameter on the WTO macro, and the MLG=NO parameter on the JES3 MESSAGE\n+    macro.  These parameters are used primarily for security related messages.\n+\n+\n+The following topics are presented in sequence, or may be selected by number:\n+\n%1+JES3 SYSLOG format\n%2+MVS SYSLOG format\n)Init\n\n &ZUP = LOGTUT0\n\n)Proc\n\n &ZSEL = TRANS(&ZCMD 1,LOGTUT2A 2,LOGTUT2B ' ',' ' *,?)\n\n)End\n+/ ADD NAME=LOGTUT2A 0100-90073-90074-1428-00025-00028-00000-$A1019\n)Body default($[_)\n$TUTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL$\n$Command ===>_ZCMD                                                             $\n$                                                                              $\n[JES3 SYSLOG records have the following format:\n[   ccc  nnnnnnnn yyddd hhmmsst ia <prefix> message\n$ccc[      Console destination class\n$nnnnnnnn[ Console name\n$yyddd[    Julian date\n$hhmmsst[  Time stamp: hours, minutes, seconds, tenths of a second\n$i[        Warning indicator as follows:\n[            $blank[   Normal output\n[            $%[       Minimum track space situation\n[            $=[       Marginal track space situation\n[            $<[       Minimum JSAM buffer situation\n$a[        Action prefix character as follows:\n[            $blank[ Normal message\n[            $+[       JES3 command input\n[            $-[       MVS command input\n[            $*[       Operator action required\n[            $&[       Suppressed message (does not appear on any console)\n$prefix[   sysname R= jobname\n[            $sysname[ Name of the main processor which issued the message\n[            $jobname[ The job name of the issuing program\n)End\n+/ ADD NAME=LOGTUT2B 0100-90073-90074-1431-00025-00025-00000-$A1019\n%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%\n+MVS SYSLOG records have the following format:\n+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message\n+   t                                                    message\n+   t                                   lid              message\n+\n%t+         Record type:\n+             %D+ Data line of a multiple-line message\n+             %E+ End line  or data-end line of a multiple-line message\n+             %L+ Label line of a multiple-line message\n+             %M+ First line of a multiple-line message\n+             %N+ Single-line message that does not require a reply\n+             %O+ Operator LOG command\n+             %S+ Continuation of a single-line message\n+             %W+ Single-line message that requires a reply\n+             %X+ A log entry that is not from a LOG command or system message\n+\n+                           (Press ENTER to continue)\n)Init\n\n &ZCONT = LOGTUT2C\n\n)End\n+/ ADD NAME=LOGTUT2C 0100-90073-90074-1432-00028-00024-00000-$A1019\n%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%\n+MVS SYSLOG record format continued:\n+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message\n+   t                                                    message\n+   t                                   lid              message\n+\n%c+            Indicates whether the line was generated because of a command:\n+                %C+     Command input\n+                %R+     Command response\n+                %I+     Command issued internally; job id is name of issuer\n+                %blank+ Neither command input nor command response\n+\n%rrrrrrr+      Hexadecimal representation of the routing codes\n+\n%sysname+      System name from the IEASYSxx member of SYS1.PARMLIB\n+\n%yyddd+        Julian date\n+\n%hh:mm:ss.th+  Time stamp: hours, minutes, seconds, hundredths of a second\n+\n+                           (Press ENTER to continue)\n)Init\n\n &ZCONT = LOGTUT2D\n\n)End\n+/ ADD NAME=LOGTUT2D 0100-90073-90074-1435-00022-00025-00000-$A1019\n%1UTORIAL ----------------- Format of SYSLOG Records ----------------- TUTORIAL%\n%Command ===>_ZCMD                                                             %\n%\n+MVS SYSLOG record format continued:\n+   tcrrrrrrr sysname yyddd hh:mm:ss.th ident  msgflags  message\n+   t                                                    message\n+   t                                   lid              message\n+\n%ident+    If \"c\" is blank, then the%job identifier+\n+          If \"c\" is C or R, then one of the following:\n+            %nn+       A 2-digit console ID\n+            %MASTER+   A message sent to the master console\n+            %INTERNAL+ An internally generated command\n+            %INSTREAM+ A command read from the input stream\n+            %blanks+   The source or destination could not be determined\n+\n%lid+      Multiple-line ID for the second and succeeding lines of a\n+          multiple-line message. In the first line, this field appears after\n+          the message text.\n+\n%msgflags+ &   indicates message was suppressed\n)End\n+/ ADD NAME=LOGTUT3  0100-90074-90074-1226-00019-00019-00000-$A1019\n%------------------------- Browsing SYSLOG Data Sets --------------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+One or more SYSLOG data sets may be browsed by specifying the%B+or%BB+line\n+command(s) on the initial SYSLOG panel.\n+\n+If you specify a single data set, normal ISPF browse is used.\n+\n+More than one data set may be specified by multiple%B+commands or a pair of%BB+\n+commands.  When you specify multiple data sets they are concatenated.  This\n+means, for example, that a FIND command can cross data set boundaries.\n+Currently performance will be poor if you scroll backwards. The current\n+technique requires closing the data sets, reopening them from the beginning,\n+and reading forward to the desired record.\n)Init\n\n &ZUP = LOGTUT0\n\n)End\n+/ ADD NAME=LOGTUT4  0100-90074-90078-1800-00028-00013-00000-$A1019\n%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+One or more data sets may be processed by LOGSCAN by specifying the%L+or%LL+\n+line command(s) on the initial SYSLOG panel.\n+\n+When you specify multiple data sets they are concatenated.\n+\n%Options:+%1+Execute LOGSCAN in the foreground and browse the output\n+         %2+Submit a batch job to execute LOGSCAN\n+         %3+Print output previously generated by LOGSCAN (option 1)\n+         %4+Browse output previously generated by LOGSCAN (option 1)\n+         %5+Clear all LOGSCAN parameters to blank\n+\n%Caps:+   %ON+translates the data fields (see below) to uppercase.\n+         %OFF+allows use of lowercase data fields.\n+\n%Starting time/Ending time:+Specifies the beginning and ending time period to\n+         be selected. The time period may be specified alone, or may be used\n+         to limit the records scanned via data fields (see below).\n+\n+                           (Press ENTER to continue)\n)Init\n\n &ZUP = LOGTUT0\n &ZCONT = LOGTUT4A\n\n)End\n+/ ADD NAME=LOGTUT4A 0100-90074-90074-1433-00027-00027-00000-$A1019\n%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+DATA, OR, AND, NOT, / ===>         WORD, ABBR   ===>\n+Left margin           ===>         Right margin ===>           (1-126)\n+Data ===>\n+\n%DATA:+select records with the specified \"data\".\n%OR:+  select records specified via DATA%or+via another OR%or+with the\n+      specified \"data\". DATA and OR are equivalent.\n%AND:+ select records specified via DATA or OR%and+with the specified \"data\".\n%NOT:+ exclude records with the specified \"data\".\n+Note: all DATAs and ORs are evaluated before, and must precede, all ANDs and\n+      NOTs.\n%/:+   begins a new search argument. Each set of arguments between slashes is\n+      applied separately. If a record is not selected under one argument, it\n+      may be selected under another argument.\n+\n%WORD:+requires the record \"data\" to be surrounded by blanks or punctuation.\n%ABBR:+requires the record \"data\" to be preceded by a blank or punctuation.\n+\n+                           (Press ENTER to continue)\n)Init\n\n &ZCONT = LOGTUT4B\n\n)End\n+/ ADD NAME=LOGTUT4B 0100-90074-90074-1940-00019-00020-00000-$A1019\n%-------------------- Selecting SYSLOG Records Via LOGSCAN --------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+DATA, OR, AND, NOT, / ===>         WORD, ABBR   ===>\n+Left margin           ===>         Right margin ===>           (1-126)\n+Data ===>\n+\n%Left margin:+ is the first character position to be scanned.\n%Right margin:+is the last character position to be scanned. If omitted, it is\n+              defaulted to the \"left margin\".\n+Note: once specified, margins apply to all subsequent search parameters until\n+      respecified.\n+\n%Data:+specifies the data to be searched for. It should be surrounded by\n+matching special characters.  If not, the data will be automatically surrounded\n+by single or double quote marks.\n+\n+You can create as many search parameters as you wish. Simply scroll down.\n)End\n+/ ADD NAME=LOGTUT5  0100-90106-90106-1436-00020-00020-00000-$A1019\n%-------------------- Recalling Migrated SYSLOG Data Sets ---------------------%\n%Command ===>_ZCMD                                                             %\n%                                                                              %\n+SYSLOG data sets which have not been referenced for some time will be\n+automatically migrated to tape.\n+\n+If you refer to one of these data sets via Browse or LOGSCAN it will be\n+automatically recalled. However you will have to wait for the recall to\n+complete. You may use your attention key to terminate the wait condition (the\n+recall will eventually complete).\n+\n+Alternatively, you may recall one or more migrated SYSLOG data sets\n+asynchronously by specifying the%R+or%RR+line command(s) on the initial SYSLOG\n+panel. The recall will complete without requiring you to wait. You will receive\n+a message when the recall is complete.\n)Init\n\n &ZUP = LOGTUT0\n\n)End\n+/ ADD NAME=LOGWAIT  0100-90064-90072-1728-00013-00010-00000-$A1019\n%------------------------ LOGSCAN Foreground Execution ------------------------%\n%                                                                              %\n%                                                                              %\n+The LOGSCAN program is now scanning the selected SYSLOG console message log(s).\n+\n+\n+You can reduce the CPU time required by specifying:\n+    starting and ending time;\n+    left and right margin.\n+\n+\n+LOGSCAN always reads all records, even if time limits are specified.\n)End\n./ ADD NAME=PROCLIB  0100-90123-90123-1253-000006-000006-000000-$A1238\n//LOGWTR  PROC NODE=WCC1\n//IEFPROC EXEC PGM=IASXWR00,PARM=PX,PERFORM=45\n//IEFRDER  DD  DSNAME=ASYSLOG.&NODE..D&D..T&T,\n//             DISP=(NEW,CATLG,CATLG),\n//             DCB=(BLKSIZE=23476,LRECL=136,RECFM=VB),\n//             LABEL=RETPD=31,UNIT=SYSCC,SPACE=(CYL,(15,15),RLSE)\n./ ADD NAME=SKELS\n+/ ADD NAME=LOG      0101-90106-90123-1323-00020-00014-00000-$A1238\n*  &ZUSER  &ZTIME  &ZMONTH/&ZDAY/&ZJDATE\n)SET RANGE = 0\n)DOT SYSLOG\n)SEL &ACTION = L ] &ACTION = LL ] &RANGE = 1\n)SEL &ACTION = LL\n)SET RANGE = &RANGE + 1\n)ENDSEL\n*  DSNAME: &DSNAME\n)ENDSEL\n)ENDDOT\n<TIME=&TIME1,&TIME2]>\n)DOT LOGSCAN\n)SEL &TYPE = DATA ] &TYPE = OR ] &TYPE = AND ] &TYPE = NOT\n<MARGIN=&MARGIN1]><,&MARGIN2]>\n&TYPE=&DATA<,&PARM]>\n)ENDSEL\n)SEL &TYPE = /\n/\n)ENDSEL\n)ENDDOT\n+/ ADD NAME=LOGJCL   0101-90061-90123-1323-00031-00016-00000-$A1238\n)TB 13\n&ZLLGJOB1\n&ZLLGJOB2\n&ZLLGJOB3\n&ZLLGJOB4\n)SEL &LOGOUT = SIMPLEX\n//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010110\n)ENDSEL\n)SEL &LOGOUT = DUPLEX\n//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010111\n)ENDSEL\n)SEL &LOGOUT = TUMBLE\n//DUPLEX OUTPUT DEFAULT=YES,JESDS=ALL,FORMDEF=010112\n)ENDSEL\n//LOGSCAN  EXEC PGM=LOGSCAN\n//STEPLIB   DD  DSNAME=SYS1.MVSSERV,DISP=SHARE\n//PRINT     DD  SYSOUT=&LOGCLASS<,DEST=&LOGDEST]><,COPIES=&LOGCOPY]>\n)SET DDNAME = LOG\n)SET RANGE = 0\n)DOT SYSLOG\n)SEL &ACTION = L ] &ACTION = LL ] &RANGE = 1\n)SEL &ACTION = LL\n)SET RANGE = &RANGE + 1\n)ENDSEL\n//&DDNAME  !DD  DSNAME=&DSNAME,DISP=SHARE\n)SET DDNAME = &Z\n)ENDSEL\n)ENDDOT\n//SYSIN     DD  *\n)IM LOG\n/*\n./ ADD NAME=SOURCE\n+/ ADD NAME=BRSYSLOG 0100-90055-90058-1649-00160-00109-00000-$A1019\nBRSYSLOG TITLE 'BROWSE CONCATENATED SYSLOG DATA SETS'\n***********************************************************************\n*        INVOKE ISPF BRIF TO BROWSE CONCATENATED SYSLOG DATA SETS\n***********************************************************************\nBRSYSLOG CSECT\nBRSYSLOG AMODE 31\nBRSYSLOG RMODE 24\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*              WORKING STORAGE\n***********************************************************************\nWORKAREA DSECT\nSAVE     DS    18F                 SAVE AREA\nSAVE2    DS    18F                 SAVE AREA FOR READ ROUTINE\nLASTREC# DS    F                   NUMBER OF LAST RECORD REQUESTED\nLASTREC  DS    0CL136              LAST RECORD REQUESTED\nLASTRECL DS    2HL2\nLASTRECD DS    CL132\nSYSLOG   DCB   DDNAME=SYSLOG,                                          *\n               DSORG=PS,                                               *\n               EODAD=0,                                                *\n               MACRF=GM\nDMLIST   OPEN  (,),MF=L,MODE=31\nBRIFPARM CALL  ,(,,,,,,),MF=L      BRIF PARAMETERS\nDATA     DS    A                   DIALOG DATA AREA\nWORKSIZE EQU   *-WORKAREA          SIZE OF WORK AREA\n         EJECT\n***********************************************************************\n*              INITIALIZATION\n***********************************************************************\nBRSYSLOG CSECT\n         SAVE  (14,12)             SAVE REGISTERS\n         USING *,R15\n         MODID\n         DROP  R15\n         LR    R12,R15             SET BASE REGISTER\n         USING BRSYSLOG,R12\n         GETMAIN RU,LV=WORKSIZE,LOC=(BELOW,ANY)  GET WORKING STORAGE\n         ST    R1,8(R13)           CHAIN SAVE AREAS\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING WORKAREA,R13\n         XC    LASTREC#,LASTREC#   LAST RECORD NUMBER = 0\n         XC    DMLIST,DMLIST\n         OI    DMLIST,X'80'        SET END OF LIST\n         MVC   SYSLOG(DCBSIZE),DUMMY  COPY DCB TO WORKING STORAGE\n***********************************************************************\n*              MAINLINE CODE\n***********************************************************************\n         LA    R10,SYSLOG\n         OPEN  ((R10),(INPUT,REREAD)),MODE=31,MF=(E,DMLIST)\n         LTR   R15,R15             IS RETURN CODE NORMAL?\n         BNZ   RETURN              NO, ERROR\n         LA    R2,SAVE2            PARM FOR READ ROUTINE\n         ST    R2,DATA\n         LA    R2,DATA\n         LINK  EP=ISPLINK,                                             *\n               PARAM=(BRIF,@,RECFM,LRECL,ROUTINE,@,(R2)),VL=1,         *\n               MF=(E,BRIFPARM)\n         LR    R2,R15              SAVE BRIF RETURN CODE\n         CLOSE MODE=31,MF=(E,DMLIST)\n         LR    R15,R2              RESTORE BRIF RETURN CODE\n***********************************************************************\n*              TERMINATION\n***********************************************************************\nRETURN   EQU   *\n         LR    R1,R13              UNCHAIN SAVE AREAS\n         L     R13,4(R1)\n         LR    R2,R15              SAVE RETURN CODE\n         FREEMAIN RU,LV=WORKSIZE,A=(1)  FREE WORKING STORAGE\n         LR    R15,R2              RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)    RETURN\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n*              BRIF READ ROUTINE\n***********************************************************************\nREAD_ROUTINE EQU *\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             SET BASE\n         USING READ_ROUTINE,R12\n         LM    R2,R5,0(R1)         LOAD PARAMETERS\n*                                  R2 -> RECORD DATA READ\n*                                  R3 -> LENGTH OF RECORD READ\n*                                  R4 -> RECORD NUMBER\n*                                  R5 -> BRIF DIALOG DATA PARM (DATA)\n         L     R5,0(,R5)           R5 -> SAVE2\n         ST    R13,4(R5)           CHAIN SAVE AREAS\n         ST    R5,8(R13)\n         LR    R13,R5\n         USING SAVE2,R13\n         CLC   LASTREC#,0(R4)      IS LAST RECORD NUMBER < NEW?\n         BL    CONTINUE            YES, BRANCH\n         CLOSE MODE=31,MF=(E,DMLIST)\n         OPEN  MODE=31,MF=(E,DMLIST)\n         XC    LASTREC#,LASTREC#   SET LAST RECORD NUMBER TO ZERO\nCONTINUE EQU   *\n         LA    R15,GET             POINT TO AMODE 24 CODE\n         BASSM R11,R15             AND BRANCH TO IT\n         LA    R0,LASTRECD         STORE ADDRESS OF RECORD\n         ST    R0,0(,R2)\n         LH    R0,LASTRECL         STORE LENGTH OF RECORD\n         S     R0,=F'4'\n         ST    R0,0(,R3)\n         L     R13,4(R13)          UNCHAIN SAVE AREAS\n         RETURN (14,12),RC=(15)    RETURN\n         EJECT\n***********************************************************************\n*              BRIF READ ROUTINE AMODE 24 CODE\n***********************************************************************\nGET      EQU   *\n         L     R6,LASTREC#         GET NUMBER OF LAST RECORD\n         GET   SYSLOG,LASTREC      GET A RECORD\n         A     R6,=F'1'            INCREMENT RECORD NUMBER\n         ST    R6,LASTREC#\n         C     R6,0(,R4)           IS THIS THE RECORD REQUESTED?\n         BL    GET                 NO, BRANCH\n         SR    R15,R15             RETURN CODE = 0 (NORMAL)\n         BSM   0,R11               RETURN TO AMODE 31 CODE\nEODAD    EQU   *\n         ST    R6,0(,R4)           STORE NUMBER OF RECORD\n         CLOSE MODE=31,MF=(E,DMLIST)  CLOSE SYSLOG\n         OPEN  MODE=31,MF=(E,DMLIST)  OPEN SYSLOG\n         XC    LASTREC#,LASTREC#   SET LAST RECORD NUMBER TO ZERO\n         LA    R15,8               RETURN CODE = 8 (END OF FILE)\n         BSM   0,R11               RETURN TO AMODE 31 CODE\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n*              CONSTANTS\n***********************************************************************\nDUMMY    DCB   DDNAME=SYSLOG,                                          *\n               DSORG=PS,                                               *\n               EODAD=EODAD,                                            *\n               MACRF=GM\nDCBSIZE  EQU   *-DUMMY             SIZE OF DCB\n@        DC    CL8' '              BLANK\nBRIF     DC    CL8'BRIF'           NAME OF BRIF ISPF SERVICE\nLRECL    DC    F'136'              LOGICAL RECORD LENGTH\nRECFM    DC    CL8'V'              RECORD FORMAT\nROUTINE  DC    A(READ_ROUTINE)     BRIF READ ROUTINE\n         END   BRSYSLOG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMITVM": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92$\\x0f\\x00\\x92$\\x0f\\x12\\x00\\x00\\xc2\\x00\\xc2\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-08-27T00:00:00", "modifydate": "1992-08-27T12:00:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "REXX"}, "text": "00000100/* ---------------------  rexx procedure  ---------------------- */\n00000300/* Name:      XMITVM                                             */\n00000400/*                                                               */\n00000500/* Function:  Transmit a message to VM in PROFS format           */\n00000600/*                                                               */\n00000700/* Syntax:    %XMITVM node.userid option.....                    */\n00000800/*                                                               */\n00000900/*            where option(s) are:                               */\n00001000/*                                                               */\n00001100/*            MSGDS data-set-name                                */\n00001200/*              specifies the data set that contains the         */\n00001300/*              message                                          */\n00001400/*                                                               */\n00001500/*            MSGDD ddname                                       */\n00001600/*              specifies the DDname that contains the           */\n00001700/*              message                                          */\n00001800/*                                                               */\n00001900/*            NOTIFY                                             */\n00002000/*            NONOTIFY                                           */\n00002100/*              indicates whether an acknowledgement is being    */\n00002200/*              requested                                        */\n00002300/*                                                               */\n00002400/*            SUBJECT 'subject for message'                      */\n00002500/*              specifies the subject that PROFS will see in     */\n00002600/*              message table                                    */\n00002700/*                                                               */\n00002800/*            NOMSG                                              */\n00002900/*              indicates that not confirmation message of       */\n00003000/*              transmission is to occur.                        */\n00003100/*                                                               */\n00003200/* Author:    Lionel B. Dyck                                     */\n00003300/*            Rockwell International                             */\n00003400/*            P.O. Box 2515                                      */\n00003500/*            Seal Beach, California 90740                       */\n00003600/*            (310) 797-1125                                     */\n00003700/*            IBMLINK:  ROK2027                                  */\n00003800/*                                                               */\n00003900/* History:   09/21/90:  Lionel B. Dyck                          */\n00004000/*            creation                                           */\n00004100/*                                                               */\n00004200/* ------------------------------------------------------------- */\n00004300\n00004400parse arg address options\n00004500\n00004600msgid = sysvar(sysicmd)\n00004700\n00004800if pos(\".\",address) = 0 then do\n00004900   say msgid \"Invalid address (\"address\") was specified\"\n00005000   say msgid \"The address must be of the format node.userid\"\n00005100   signal exit8\n00005200   end\n00005300\n00005400upper_options = options\n00005500upper upper_options\n00005600\n00005703parse value \"\" with dsn ddn subj notify msg\n00005800\n00005900if wordpos(\"MSGDS\",upper_options) > 0 then do\n00006000   pw = wordpos(\"MSGDS\",upper_options)\n00006100   if ddn = \"\" then\n00006200               dsn = word(upper_options,pw+1)\n00006300               else do\n00006400               say msgid \"Both MSGDS and MSGDD were specified,\"\n00006500               say msgid \"please correct your options and try again.\"\n00006600               exit 8\n00006700               end\n00006800   end\n00007903\n00008000if wordpos(\"MSGDD\",upper_options) > 0 then do\n00008100   pw = wordpos(\"MSGDD\",upper_options)\n00008200   if dsn = \"\" then\n00008300               ddn = word(upper_options,pw+1)\n00008400               else do\n00008500               say msgid \"Both MSGDS and MSGDD were specified,\"\n00008600               say msgid \"please correct your options and try again.\"\n00008700               exit 8\n00008800               end\n00008900   end\n00009000\n00009100if wordpos(\"NONOTIFY\",upper_options) > 0 then do\n00009200   if notify = \"\" then\n00009300                  notify = \"off\"\n00009400                  else do\n00009500                  say msgid \"Notify and NoNotify were both specified.\"\n00009600                  say msgid \"Notify is being used as the default.\"\n00009700                  end\n00009800   end\n00009900\n00010000if wordpos(\"NOTIFY\",upper_options) > 0 then do\n00010100   if notify = \"\" then\n00010200                  notify = \"on\"\n00010300                  else do\n00010400                  say msgid \"Notify and NoNotify were both specified.\"\n00010500                  say msgid \"Notify is being used as the default.\"\n00010600                  end\n00010700   end\n00010800\n00010900if wordpos(\"NOMSG\",upper_options) > 0 then msg = \"off\"\n00011000\n00011100if wordpos(\"SUBJECT\",upper_options) > 0 then do\n00011200   pw = wordpos(\"SUBJECT\",upper_options)\n00011300   pc = wordindex(upper_options,pw)\n00011400   sopt = overlay(\"SUBJECT\",options,pc,7)\n00011500   options = sopt\n00011600   parse value options with x \"SUBJECT\" \"'\" subject \"'\" more\n00011700   end\n00011800\n00011900if dsn = \"\" & ddn = \"\" then do\n00012000   say msgid \"Neither the MSGDS or MSGDD were specified.\"\n00012100   say msgid \"Command terminating - try again.\"\n00012200   signal exit8\n00012300   end\n00012400\n00012500workdd = \"XMDD\"random()\n00012600indd   = \"XMDD\"random()\n00012700\n00012800\"ALLOC F(\"workdd\") SYSOUT(B) DEST(\"address\")\",\n00012900      \"RECFM(F B) LRECL(80) BLKSIZE(80)\"\n00013000\n00013100if dsn = \"\" then indd = ddn\n00013200\n00013300if ddn = \"\" then\n00013400   \"ALLOC F(\"indd\") DS(\"dsn\") SHR\"\n00013500\n00013600\"EXECIO * DISKR\" indd \"(FINIS STEM in.\"\n00013700if ddn = \"\" then \"FREE F(\"indd\")\"\n00013800\n00013900/* ------------------------------------------------------------- */\n00014000/* Fix up the PROFS Header record                                */\n00014100/* ------------------------------------------------------------- */\n00014200\n00014300\"SHOWTSO CENTER\"\n00014400\n00014603userid = sysvar(sysuid)\n00014700\n00014800parse value address with tonode \".\" toid\n00014900\n00015000upper tonode toid\n00015100\n00015200header = \" MSG:FROM:\" left(userid,8)\"--\"left(center,8) \"TO:\",\n00015300           left(toid,8)\"--\"left(tonode,18)date('u') time()\n00015400\n00015500new_header = overlay(x2c('FE'),header,1)\n00015600header = new_header\n00015700\n00015800if notify = \"on\" then do\n00015900    new_header = overlay(x2c('01'),header,80)\n00016000    header = new_header\n00016100    end\n00016200\n00016300/* ------------------------------------------------------------- */\n00016400/* Fix up the PROFS Trailer record                               */\n00016500/* ------------------------------------------------------------- */\n00016600trailer = left(\" \",6)left(sendsubj,65)\n00016700\n00016800new_trailer = overlay(x2c('FFFF00000011'),trailer,1)\n00016900trailer = overlay(x2c('000000000000000000'),new_trailer,72)\n00017000\n00017100if subject = \"\" then subject = \"No Subject\"\n00017200\n00017300new_trailer = overlay(subject,trailer,7,65)\n00017400trailer = new_trailer\n00017500\n00017600out.  = \"\"\n00017700out.0 = 1\n00017800\n00017900out.1 = header\n00018000do i = 1 to in.0\n00018100   out.0 = out.0 + 1\n00018200   n = out.0\n00018300   out.n = in.i\n00018400   end\n00018500out.0 = out.0 + 1\n00018600n = out.0\n00018700out.n = trailer\n00018800\n00018900\"EXECIO * DISKW\" workdd \"(FINIS STEM out.\"\n00019000\"FREE F(\"workdd\")\"\n00019100\n00019200if msg = \"\" then\n00019300   say \"Message successfully transmitted to:\" address\n00019400\n00019500exit 0\n00019600\n00019700exit8:\n00019800   say msgid \" \"\n00019900   say msgid \"Syntax is: \"\n00020000   say msgid \"%XMITVM node.userid\"\n00020100   say msgid \"        MSGDS data-set-name   or\"\n00020200   say msgid \"        MSGDD ddname\"\n00020300   say msgid \"        NOTIFY or NONOTIFY\"\n00020400   say msgid \"        SUBJECT 'subject text' \"\n00021000   exit 8\n00030000   end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPROC": {"ttr": 9477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15O\\x00\\x92\\x15O\\x12\\x00\\n\\x0c\\n\\x0c\\x00\\x00\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-02T00:00:00", "modifydate": "1992-06-02T12:00:00", "lines": 2572, "newlines": 2572, "modlines": 0, "user": "ASM"}, "text": "         TITLE 'XPROC copyright notice'\n***********************************************************************\n*                                                                     *\n*   Copyright (c) 1989 The Charles Stark Draper Laboratory, Inc.      *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n         TITLE 'XPROC macros'\n         MACRO\n&SYM     ERROR &MSG,&FLUSH=YES\n&SYM     L     R1,=A(&MSG)         Get address of error message\n         LA    R0,L'&MSG           Get length of error message\n         BAL   R14,PUTLINE         Display error message\n         AIF   ('&FLUSH' EQ 'NO').MEND\n         B     FLUSHIT             Fail\n.MEND    MEND\n         TITLE 'XPROC - CLIST-style command line parser for REXX'\n***********************************************************************\n*                                                                     *\n* XPROC    - CLIST-style command line parser for REXX                 *\n*                                                                     *\n* Author:  S. Bacher 06/89                                            *\n*                                                                     *\n* Syntax:  XPROC {inputvar} number {positional-parameter-variables}*  *\n*                                  {keyword-and-maybe-value-specs}*   *\n*                                                                     *\n*        where: \"inputvar\" is a valid CLIST/REXX variable name        *\n*               and the part of the command that follows \"inputvar\"   *\n*               looks exactly like the syntax of the CLIST \"PROC\"     *\n*               statement.                                            *\n*                                                                     *\n* Example: /* REXX */                                                 *\n*          PARSE ARG OPERANDS                                         *\n*          \"XPROC OPERANDS 2 FILE DSN VOL() SHR COUNT(1) KEY('A B')\"  *\n*                                                                     *\n*          Note that everything, including \"inputvar\", must be quoted *\n*          under REXX to prevent substitution.                        *\n*                                                                     *\n* Function:  To parse the value of a string (accessed as \"inputvar\")  *\n*            according to the PROC-style specifications and place     *\n*            the results in REXX variables.  If \"inputvar\" is         *\n*            omitted, the argument to the REXX exec is parsed.        *\n*                                                                     *\n* Return codes:                                                       *\n*                                                                     *\n* 0 - normal operation                                                *\n* 12 - error(s) occurred, prompting not possible                      *\n*                                                                     *\n* Note:  This can be used in CLISTs as well.  One use might be to     *\n*        parse a non-command-buffer line, e.g. edit macro text.       *\n*                                                               #TSO147\n* Change activity:                                              #TSO147\n*                                                               #TSO147\n* 10/24/89 - SEB1525 - Bug fix when bigger keyword area needed. #TSO147\n* 01/30/91 - SEB1525 - Extended to permit the specification of        *\n*                      options via the syntax keyword/option.         *\n*                      First option so supported is lowercase.        *\n* 04/13/92 - SEB1525 - Bug fix when prototype has quoted data.  #TSO159\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2    Miscellaneous uses\nR3       EQU   3    Used by SCAN and PUTLINE; other temporary uses\nR4       EQU   4    Positional parameter info\nR5       EQU   5    Positional parameter info\nR6       EQU   6    Keyword count\nR7       EQU   7    Address of IKJPARS PDL answer area\nR8       EQU   8    Used to loop through parameters\nR9       EQU   9    Dynamic base register\nR10      EQU   10   Static base register\nR11      EQU   11   Static base register\nR12      EQU   12   Static base register\nR13      EQU   13   Save area pointer\nR14      EQU   14\nR15      EQU   15\n         SPACE 1\nXPROC    CSECT\nXPROC    AMODE 31\nXPROC    RMODE ANY\n         SAVE  (14,12),,XPROC_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING XPROC,R12\n         LA    R11,4095(,R12)\n         USING XPROC+4095,R11\n         LA    R10,4095(,R11)\n         USING XPROC+4095+4095,R10\n*\n* Allocate storage to hold work area plus copies of positional and\n* keyword parameters.  Since the maximum length required to hold\n* all the parameters is obviously the length of the command buffer,\n* use that as the amount to add.\n*\n         LR    R2,R1               Save input parameter address\n         LA    R4,SIZDATD            Get length of basic workarea\n         L     R3,CPPLCBUF-CPPL(,R2) Point to command buffer\n         AH    R4,0(,R3)             Add length of command buffer\n         LR    R0,R4\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R9,R13\n         USING DATD,R9\n         ST    R4,DATDLEN          Save length of getmained area\n         LA    R0,WORDCOPY         Point to variable area\n         ST    R0,WORDPTR          Save address of it\n         MVC   CPPL(16),0(R2)      Set up our copy of CPPL\n         MVC   IOPLUPT,CPPLUPT     Pointer TO UPT\n         MVC   IOPLECT,CPPLECT     Pointer TO ECT\n         LA    R0,ECB\n         ST    R0,IOPLECB          Pointer to user's ECB\n         MVC   PTLIST(LENPUTL),MPTLIST Set up PUTLINE list form\n         LA    R0,1                Define 1 message segment\n         LA    R1,MSGHDR\n         STM   R0,R1,OLD           Make PUTLINE output line descriptor\n*                                  Initialize other data areas\n         STM   R11,R12,MYBASES     Base registers used in PARSE exits\n         MVI   FLAGS,X'00'         Clear flags\n         XR    R0,R0               Make a zero\n         ST    R0,APOSD\n         ST    R0,LPOSD\n         ST    R0,AKEYD\n         ST    R0,LKEYD\n         ST    R0,AKEYE\n         ST    R0,POSCOUNT\n         ST    R0,KEYCOUNT\n         ST    R0,PWADDR\n         ST    R0,PWLEN\n         ST    R0,VBUFADDR\n         ST    R0,VBUFLEN\n         ST    R0,ARGADDR\n         ST    R0,ARGLEN\n*\n         EJECT\n*\n***********************************************************************\n*\n* First, set things up so that SCAN can start scanning.  On entry to\n* the command, CPPLCBUF points to the command buffer.  Halfword 1 is\n* the length of the buffer plus 4, and halfword 2 is the offset of the\n* first operand (if any) past the command name in the buffer (set by\n* TSO's call to IKJSCAN).\n*\n***********************************************************************\n*\n         L     R2,CPPLCBUF\n         LR    R1,R2\n         AH    R1,0(,R2)\n         ST    R1,SCANEPTR         Save end of command buffer\n         LA    R1,4(,R2)\n         AH    R1,2(,R2)\n         ST    R1,SCANPTR          Initialize scan pointer\n         XR    R0,R0\n         ST    R0,PARCOUNT         Initialize parenthesis count\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for first operand - must be input variable name *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN            Return R15 -> arg\n         B     NOOPERANDS          No value\n         B     ARG1OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG1OK   DS    0H\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Validate first argument as a variable name so that it can be used   *\n* to retrieve CLIST/REXX variable value.                              *\n*                                                                     *\n* We may not really have to do that here - just verify that it's not  *\n* a positional count.  If it is a positional count, set the address   *\n* and length of the input variable to zero (extension to XPROC will   *\n* get value to parse from REXX argument string in that case).         *\n*                                                                     *\n***********************************************************************\n*\n         LR    R3,R1               Save address\n         LR    R4,R2               Save length\n         CH    R2,=H'256'          If it's too long for EX instruction\n         BH    ERROR_FIRST_ARG     then first arg is invalid\n         BCTR  R2,0                Reduce for execute\n         EX    R2,TRTPOSCT         Scan for numerics\n         BNZ   NOTPOSCOUNT         If any non-numerics, not a count\n         XR    R0,R0               Else make a zero\n         ST    R0,PVARADDR         Clear address of the variable\n         ST    R0,PVARLEN          Clear length of the variable\n         B     ISACOUNT            Process this as the pos parm count\n         SPACE 1\nNOTPOSCOUNT DS 0H                  Not a count - assume a variable name\n         LR    R14,R3              Get address of variable name\n         LA    R1,PVAR             Point to place to build var name\n         ST    R1,PVARADDR         Save address of the variable\n         ST    R4,PVARLEN          Save length of the variable\n         BCTR  R4,0                Reduce for execute\n         EX    R4,MVCWORD          Move word to PVAR\n         EX    R4,UPWORD           Translate to uppercase\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Scan command buffer for next operand - must be count of positionals *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R14,SCAN\n         B     NOPOSCOUNT          No value\n         B     ARG2OK              Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nARG2OK   DS    0H                  We have what should be a count...\n         LR    R3,R1               Get address of argument\n         LR    R4,R2               Get length of argument\nISACOUNT DS    0H                  Here for first non-alpha arg...\n*\n***********************************************************************\n*                                                                     *\n* Validate this argument as a number so that it can be used to count  *\n* the number of positional parameters.                                *\n*                                                                     *\n***********************************************************************\n*\n         BCTR  R4,0                Reduce for execute\n         CH    R4,=H'7'            If positional count more than 8 digs\n         BH    BADPOSCOUNT         then invalid value\n         EX    R4,TRTPOSCT         Scan for numerics\n         BNZ   BADPOSCOUNT         If any non-numerics, invalid value\n         EX    R4,PACKIT           Convert to numeric\n         CVB   R0,DOUBLE           Get binary value\n         ST    R0,POSCOUNT         Store positional parameter count\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* We are about to start collecting all parameter names, both          *\n* positional and keyword.  While we do this, we determine how much    *\n* space will be needed for IKJPARS control blocks.                    *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(min(name,234))) *\n*   For each keyword with a value:   66 + (2 * length(min(name,237))) *\n*                                       + length(name)                *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,7                Set PCL amount to initial value\n         ST    R0,PCLLEN\n         XR    R0,R0               Set quoted-value-strings length\n         ST    R0,QVALLEN\n         LA    R0,8                Set PDL initial total length\n         ST    R0,PDLLEN\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for as many positional parameters   *\n* as we have defined.                                                 *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R5,15,POSCOUNT      Get count of positional parameters\n         BZ    NOPOZZES            If zero, no positional parameters\n         MH    R5,=Y(POSDDATL)     Get total length to acquire\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15             If GETMAIN failed,\n         BNZ   BADPOSCOUNT         then positional count too big\n         ST    R1,APOSD            Save address of this area\n         ST    R5,LPOSD            Save length of this area\n         LR    R4,R1               Address first entry in area\n         USING POSDDATA,R4\n*\n***********************************************************************\n*                                                                     *\n* Loop (positional-parameter-count) times, collecting variable names. *\n*                                                                     *\n***********************************************************************\n*\n         NI    FLAGS,255-FLAGPOSD  Not currently processing anything\n         NI    FLAGS,255-FLAGKEYD\n         XR    R0,R0               Zero out error fields\n         ST    R0,LASTADDR\n         ST    R0,LASTLEN\n         ST    R0,LASTAREA\n         L     R8,POSCOUNT         Get count of positional parameters\nPPLOOP   DS    0H                  R5 contains count of parms to get\n         BAL   R14,SCAN            Get a positional parame\n         B     PPMISSING           No value\n         B     PPADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     PPLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     PPSLASH             \"/\" found\n         SPACE 1\nPPLP     DS    0H                  \"(\" found when a positional expected\n         C     R8,POSCOUNT         If no pos. parms found yet\n         BE    ERROR_NO_WANT_LP    then this is truly an error; else\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec not allowed\n         SPACE 1\nPPSLASH  DS    0H                  \"/\" found when a positional expected\n         BAL   R14,DOOPTS          Process options\n         B     PPLOOP\n         SPACE 1\nPPADD    DS    0H                  Add a positional parameter\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nCDPPLOOP DS    0H                  Loop to check for duplicates\n         CR    R2,R4               until we hit current PP slot\n         BNL   CDPPLEND\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   CDPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nCDPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         B     CDPPLOOP\nCDPPLEND DS    0H                  End loop to check for duplicates\n         LA    R2,1(,R15)          Get length\n         ST    R1,POSDADDR         Save address of this pos. parm.\n         ST    R2,POSDLEN          Save length of this pos. parm.\n         XR    R0,R0               Clear other fields\n         ST    R0,POSDPCEA\n         MVI   POSDFLGS,0\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         OI    FLAGS,FLAGPOSD      Say currently processing positional\n         NI    FLAGS,255-FLAGKEYD\n*\n* PCE length for positional param: 56 + (2 * length(min(name,234)))\n* PDE length for positional param: 8\n*\n         LR    R15,R2              Get length of positional parm name\n         CH    R15,=H'234'         If longer than 255-21\n         BNH   *+8                 then\n         LA    R15,255-21           set length to 255-21\n         ST    R15,POSDMAXL        Store this length\n         SLA   R15,1               2 * length(min(name,234))\n         LA    R15,56(,R15)        56 + (2 * length(min(name,234)))\n         ST    R15,POSDPCEL        Set length of PCE for this parameter\n         A     R15,PCLLEN          Accumulate PCL length\n         ST    R15,PCLLEN\n         LA    R1,8                Length of PDE for positional = 8\n         A     R1,PDLLEN           Accumulate PDL length\n         ST    R1,PDLLEN\n         LA    R4,POSDDATL(,R4)    Bump pointer\n         BCT   R8,PPLOOP           Loop until count exhausted\n         SPACE 1\nNOPOZZES DS    0H                  Here if no positional parameters\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Get storage to hold information for keyword and value parameters.   *\n* We don't know how much we'll need yet, so we'll get a chunk of it   *\n* and hope for the best.                                              *\n*                                                                     *\n***********************************************************************\n*\n         L     R5,KEYDINCR         Get estimated initial length\n         GETMAIN RC,LV=(R5),LOC=ANY Get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,AKEYD            Save address of this area\n         ST    R5,LKEYD            Save length of this area\n         XR    R4,R4               Start things off\n         USING KEYDDATA,R4\n         LA    R0,0(R1,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n*\n***********************************************************************\n*                                                                     *\n* Loop collecting keywords and keyword/value pairs.                   *\n*                                                                     *\n***********************************************************************\n*\n         XR    R6,R6               Clear keyword count\nKVLOOP   DS    0H\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVEND               No more\n         B     KVADD               Unquoted name\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVLP                \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVSLASH             \"/\" found\n         SPACE 1\nKVLP     DS    0H                  \"(\" found when a keyword expected\n         LTR   R6,R6               If we've seen keyword parms already\n         BNZ   ERROR_NO_WANT_LP    then this is truly an error\n         ICM   R0,15,POSCOUNT      Else if no positional parameters\n         BZ    ERROR_NO_WANT_LP    then this is truly an error.  Else,\n*                                  (future extension, but error now)\n         L     R3,LASTADDR         Get address of last processed P.P.\n         L     R2,LASTLEN          Get length of last processed P.P.\n         B     ERROR_PP_WITH_LP    say value spec w/p.p. not allowed\n         SPACE 1\nKVSLASH  DS    0H                  \"/\" found when a keyword expected\n         BAL   R14,DOOPTS          Process options\n         B     KVLOOP\n         SPACE 1\nKVADD    DS    0H                  Add a keyword parameter\n         OI    FLAGS,FLAGKEYD      Say we're currently processing\n         NI    FLAGS,255-FLAGPOSD  keyword/value parameters\n         LTR   R4,R4               If we haven't got any keywords yet\n         BNZ   KVNZ                then\n         L     R4,AKEYD             point to first entry in area\n         B     KVA                  and do our stuff.\nKVNZ     DS    0H                  Else...\n         LA    R4,KEYDDATL(,R4)    Bump pointer\n         C     R4,AKEYE            If this takes us past end of buffer\n         BL    KVA                 then...                      #TSO147\n         STM   R1,R2,SCANRES       Store result of scan\n         L     R5,LKEYD             get length of current area\n         A     R5,KEYDINCR          increment it\n         GETMAIN RC,LV=(R5),LOC=ANY get storage\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         LR    R2,R1               Address of new key area\n         LR    R0,R2               Address of new key area\n         L     R14,AKEYD           Address of old key area\n         L     R1,LKEYD            Length of old key area\n         LR    R15,R1              Length of old key area\n         MVCL  R0,R14              Move old key data to new key data\n         LR    R4,R0               Point to slot in new key area\n         L     R1,AKEYD            Address of old key area\n         L     R0,LKEYD            Length of old key area\n         FREEMAIN RC,LV=(0),A=(1)  Free the old key area\n         ST    R2,AKEYD            Save address of new area\n         ST    R5,LKEYD            Save length of new area\n         LA    R0,0(R2,R5)         Point to end of area\n         ST    R0,AKEYE            Save address of end\n         LM    R1,R2,SCANRES       Load results of scan\nKVA      DS    0H\n*\n* Check parameter for validity, and (if it's OK) make uppercase copy\n* of it in our area.\n*\n         CH    R2,=H'255'          If too long\n         BH    ERROR_PARM_TOO_LONG then error\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         EX    R15,VERIFYP         Check syntax of parameter\n         BNZ   ERROR_PARM_INVALID  If bad, error\n         CLI   0(R14),C'0'         Must not begin with numeric\n         BNL   ERROR_PARM_INVALID  If bad, error\n         L     R1,WORDPTR          Get next available word slot\n         EX    R15,MVCWORD         Move word to slot\n         EX    R15,UPWORD          Translate to uppercase\n         LA    R0,1(R15,R1)        Update slot pointer\n         ST    R0,WORDPTR          for next time\n*\n* Check for duplicates. R1 -> new word, R15 = length-1\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    KVPPLEND            If none, don't check 'em, obviously\n         L     R2,APOSD            Get address of first positional\n         LA    R0,1(,R15)          Get true length\nKVPPLOOP DS    0H                  Loop to check for duplicates\n         C     R0,POSDLEN-POSDDATA(,R2)\n         BNE   KVPPNEXT            If lengths don't match, continue\n         L     R14,POSDADDR-POSDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVPPNEXT LA    R2,POSDDATL(,R2)    Else continue\n         BCT   R8,KVPPLOOP         until no more positionals\nKVPPLEND DS    0H                  End loop to check for duplicates\n*                                  Now check against keywords so far\n         LTR   R8,R6               Get count of keywords\n         BZ    KVKWLEND            If none so far, don't check 'em\n         L     R2,AKEYD            Get address of first keyword\n         LA    R0,1(,R15)          Get true length\nKVKWLOOP DS    0H                  Loop to check for duplicates\n         C     R0,KEYWORDL-KEYDDATA(,R2)\n         BNE   KVKWNEXT            If lengths don't match, continue\n         L     R14,KEYWORDA-KEYDDATA(,R2) Point to old parameter\n         EX    R15,COMPWORD        If values are equal,\n         BE    ERROR_PARM_DUPLICATE then error\nKVKWNEXT LA    R2,KEYDDATL(,R2)    Else continue\n         BCT   R8,KVKWLOOP         until no more keywords\nKVKWLEND DS    0H                  End loop to check for duplicates\n         LA    R6,1(,R6)           Increment keyword count\n         LA    R2,1(,R15)          Get length\n         ST    R1,KEYWORDA         Save address of this pos. parm.\n         ST    R2,KEYWORDL         Save length of this pos. parm.\n         ST    R4,LASTAREA         Save for option/error processing\n         ST    R1,LASTADDR         Save for option/error processing\n         ST    R2,LASTLEN          Save for option/error processing\n         XR    R0,R0               Clear other keyword/value fields\n         ST    R0,KEYDVALA\n         ST    R0,KEYDVALL\n         ST    R0,KEYDPCEA\n         ST    R0,KEYDPCEL\n         ST    R0,KEYDMAXL\n         ST    R0,KEYSUBOF\n         MVI   KEYFLAGS,0\nKVOLOOP  DS    0H\n*\n* Now get the next thing, which might be a parenthesized default value\n* or a slashed keyword processing option\n*\n         BAL   R14,SCAN            Get a keyword parameter\n         B     KVFINEND            No more\n         B     KVFINADD            Unquoted name, it's another keyword\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     KVVALUE             \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     KVOPTION            \"/\" found\n         SPACE 1\nKVOPTION DS    0H                  We (probably) have a /option...\n         BAL   R14,DOOPTS          Process options\n         B     KVOLOOP\n         SPACE 1\nKVVALUE  DS    0H                  We (probably) have a value...\n         SPACE 1\n*\n* Scan for the value (can be any kind of string).\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVNULL              End of buffer, value is null\n         B     KVWORD              Unquoted name, it's a value\n         B     KVSTRING            Quoted string found, it's a value\n         B     KVERROR             \"(\" found, should never happen\n         B     KVNULL              \")\" found, value is null\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVWORD   DS    0H                  Unquoted word is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVSTRING DS    0H                  Quoted string is the value\n         ST    R1,KEYDVALA         Store address of default value\n         ST    R2,KEYDVALL         Store length of default value\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         OI    KEYFLAGS,KEYFQUOT   Indicate it's a quoted string\n         B     KVGETRP             Go get right paren\n         SPACE 1\nKVGETRP  DS    0H                  Time to terminate the value...\n*\n* Scan for the right parenthesis that ends the value spec\n*\n         BAL   R14,SCAN            Get a value string\n         B     KVFINEND            End of buffer\n         B     KVEXTRA             Unquoted name, shouldn't be there\n         B     KVEXTRA             Quoted string, shouldn't be there\n         B     KVERROR             \"(\" found, should never happen\n         B     KVFINLOP            \")\" found, OK, continue looping\n         B     KVERROR             \"/\" found, should never happen\n         SPACE 1\nKVEXTRA  DS    0H\n*                                  (future extension, but for now)\n         LR    R3,R1               Get address of extraneous data\n******** LR    R2,R2               Get length of extraneous data\n         LA    R1,MSG_EXTRANEOUS   Ignore extraneous info\n         LA    R0,L'MSG_EXTRANEOUS\n         BAL   R14,PUTLINE\n         B     KVGETRP             Keep looking for that right paren\n         SPACE 1\nKVNULL   DS    0H\n         OI    KEYFLAGS,KEYFDVAL   Indicate a default value present\n         LA    R14,KVLOOP          (but it's null)\n         B     KVACCUM             Accumulate length, then get next KW\n         SPACE 1\nKVFINLOP DS    0H                  End keyword(value), another follows\n         LA    R14,KVLOOP          Proceed to KVLOOP after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINADD DS    0H                  End this keyword, another follows\n         LA    R14,KVADD           Proceed to KVADD after doing...\n         B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVFINEND DS    0H                  End this keyword, no more follow\n         LA    R14,KVEND           Proceed to KVEND after doing...\n******** B     KVACCUM             accumulation for this keyword\n         SPACE 1\nKVACCUM  DS    0H\n*\n*   Calculate PCE and PDE lengths for keyword parameter\n*   For each keyword with a value:\n*     66 + (2 * length(min(name,237))) + length(name)\n*   For each keyword without value:\n*     11 + length(name)\n*\n* We're going to use the same storage to build unquoted values of\n* keywords, so add that length in too.\n*\n         STM   R1,R2,SCANRES       Save results of scan\n         L     R15,KEYWORDL        Get length of keyword name\n         TM    KEYFLAGS,KEYFDVAL   If a value specified\n         BNO   PCKWNVAL            then...\n         CH    R15,=H'237'         min(name,237)\n         BNH   *+8\n         LA    R15,237\n         ST    R15,KEYDMAXL        Save this length\n         SLA   R15,1               2 * length(min(name,237))\n         LA    R15,66(,R15)        66 + (2 * length(min(name,237)))\n         A     R15,KEYWORDL        66 + ... + length(name)\n         LA    R1,8                Accumulate PDL length for subfield\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         TM    KEYFLAGS,KEYFQUOT   If value is quoted string\n         BNO   PCKWNEXT            then...\n         L     R1,KEYDVALL          accumulate value length\n         A     R1,QVALLEN\n         ST    R1,QVALLEN          (actual'll be less, but never more)\n         B     PCKWNEXT\nPCKWNVAL DS    0H                  No value specified...\n         LA    R15,11(,R15)        just 11 + length(name)\nPCKWNEXT DS    0H\n         ST    R15,KEYDPCEL        Save PCE length\n         A     R15,PCLLEN          Accumulate PCL length for keyword\n         ST    R15,PCLLEN\n         LA    R1,2                Accumulate PDL length for keyword\n         A     R1,PDLLEN\n         ST    R1,PDLLEN\n         LM    R1,R2,SCANRES       Load results of scan\n         BR    R14                 Go to KVADD or KVEND or KVLOOP\n         SPACE 1\nKVEND    DS    0H                  No more parameters of any kind\n         SPACE 1\n         ST    R6,KEYCOUNT         Save number of keywords\n         SPACE 1\n         EJECT\n***********************************************************************\n*                                                                     *\n* Prepare to build control blocks for IKJPARS for the parameters,     *\n* like so:                                                            *\n*                                                                     *\n*          IKJPARM                                                    *\n*                                                                     *\n*   For each positional parameter \"pp\":                               *\n*                                                                     *\n*          IKJIDENT 'POSITIONAL PARAMETER pp',                        *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,   /* only if /QUOTABLE option is specified */  *\n*                FIRST=ANY,OTHER=ANY,                                 *\n*                PROMPT='POSITIONAL PARAMETER pp'                     *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\";               *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv',SUBFLD=kvsubfld                               *\n*                                                                     *\n*   For each keyword parameter \"kw\" without a value:                  *\n*                                                                     *\n*          IKJKEYWD                                                   *\n*          IKJNAME 'kv'                                               *\n*                                                                     *\n*   For each keyword parameter \"kv\" with a value \"val\", as above:     *\n*                                                                     *\n* kvsubfld IKJSUBF                                                    *\n*          IKJIDENT 'VALUE FOR KEYWORD kv',                           *\n*                ASIS,   /* only if the /ASIS option is specified */  *\n*                CHAR,                                                *\n*                PROMPT='VALUE FOR KEYWORD kv'                        *\n*                                                                     *\n*          IKJENDP                                                    *\n*                                                                     *\n* Note that the default value from the specifications is not part of  *\n* the IKJPARS parameters.  Rather, the absence of the keyword is      *\n* detected after the call to PARSE and, at that point, the default    *\n* value is used if the terminal user did not provide one.             *\n*                                                                     *\n* Compute storage needed for the PCL (built by us):                   *\n*                                                                     *\n*   For initial overhead:            7                                *\n*   For each positional parameter:   56 + (2 * length(name))          *\n*   For each keyword with a value:   66 + (3 * length(name))          *\n*   For each keyword without value:  11 + length(name)                *\n*                                                                     *\n* Compute storage reserved for the PDL (built by IKJPARS):            *\n*                                                                     *\n*   For initial overhead:            8                                *\n*   For each positional parameter:   8                                *\n*   For each keyword:                2                                *\n*   For each value subfield:         8                                *\n*                                                                     *\n* We're going to use the same storage to build unquoted values of     *\n* keywords, so add that length in too.  Also, we want to include      *\n* storage for the final call to IKJCT441 to update all parameters.    *\n* How much storage is needed to build the parameter list:  9 words    *\n* for each parameter, plus 4 extra words = 13*4.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n* Get storage for the PCL plus dequoted value strings plus IKJCT441 PL\n*\n         L     R1,PDLLEN\n         LA    R1,7(,R1)           Round PDL length\n         N     R1,=X'FFFFFFF8'      up to doubleword boundary\n         ST    R1,PDLLEN           Store length of PDL\n         LA    R1,8\n         A     R1,QVALLEN          Quoted-string-length + fudge factor\n         ST    R1,QVALLEN          Store length of quoted-value area\n         A     R1,PCLLEN           Get length of PCL plus quoted area\n         L     R0,POSCOUNT         Get count of positional parameters\n         A     R0,KEYCOUNT         Add count of positional parameters\n         MH    R0,=Y(13*4)         Compute # of plists required\n         ST    R0,VUPLEN           Store length of IKJCTT41 parm list\n         AR    R0,R1               Add to total length\n         ST    R0,PWLEN            Store length of this area\n         GETMAIN RC,LV=(0),LOC=ANY Get it\n         LTR   R15,R15             If didn't get it, error\n         BNZ   GETMAIN_FAILURE\n         ST    R1,PWADDR           Save address thereof\n         LR    R4,R1               Initialize PCL entry pointer\n         LA    R5,8                Initialize PDL offset value\n         XR    R0,R0               Clear other PCE-related junk\n         ST    R0,FIRSTKEY\n         ST    R0,SUBTOSET\n*\n* Build the IKJPARM part of the PCL.\n*\n* PCE contents:  +0 (2)  Length of entire PCL\n*                +2 (2)  Length of PDL returned by PARSE\n*                +4 (2)  Offset in PDL to first IKJKEYWD PCE\n*                        (or to end-of-field indicator, i.e.\n*                        the x'0000' in an IKJSUBF or IKJENDP)\n*\n*        ...   ..,0(,R4)           Leave this unset for now...\n         L     R0,PDLLEN\n         STH   R0,2(,R4)           IKJPARM +2 (2) Length of PDL\n*        ...   ..,4(,R4)           Leave this unset for now...\n         LA    R4,6(,R4)           Bump past this PCE\n*\n* For each positional parameter, build an IKJIDENT PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 56 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 x000' (x = 1 if CHAR, else 0)\n*                +7 (1)  X'00' (FIRST=ANY)\n*                +8 (1)  X'00' (OTHER=ANY)\n*                +9 (2)  Length of 'POSITIONAL PARAMETER pp' + 4\n*                                  (25 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*                +* (1)  Length of 'POSITIONAL PARAMETER pp' - 1\n*                                  (20 + length(name))\n*                +* (*)  'POSITIONAL PARAMETER pp' (21 + length(name))\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    PBPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nPBPPLOOP DS    0H                  Loop to build PCE's\n         ST    R4,POSDPCEA-POSDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'10010100'   +0 (1) Flags\n         TM    POSDFLGS-POSDDATA(R2),POSDASIS If /ASIS option given\n         BZ    PBPPNASI                       then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PBPPAEND                       else\nPBPPNASI MVI   1(R4),B'00000000'   +1 (1) Flags\nPBPPAEND DS    0H\n         L     R14,POSDPCEL-POSDDATA(,R2) Get length of PCE\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         TM    POSDFLGS-POSDDATA(R2),POSDCHAR If /QUOTABLE option given\n         BZ    PBPPNCHA                       then\n         MVI   6(R4),B'00001000'   +6 (1) Flags\n         B     PBPPCEND                       else\nPBPPNCHA MVI   6(R4),B'00000000'   +6 (1) Flags\nPBPPCEND DS    0H\n         MVI   7(R4),X'00'         +7 (1) X'00' (FIRST=ANY)\n         MVI   8(R4),X'00'         +8 (1) X'00' (OTHER=ANY)\n         L     R15,POSDMAXL-POSDDATA(,R2) Get length of name for prompt\n         LA    R0,25(,R15)         21 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,13+21(,R4)       Point to where to move param name\n         BCTR  R15,0               Reduce length for execute\n         L     R1,POSDADDR-POSDDATA(,R2) Get address of parameter name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,21(,R15)         21 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(21,R4),=C'POSITIONAL PARAMETER '\n         LA    R4,1+21(,R4)        Point to where to move param name\n         EX    R15,MVCTOPCE        Move parameter name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,PBPPLOOP          until no more positionals\nPBPPLEND DS    0H                  End loop\n*\n* For each keyword parameter, build an IKJKEYWD PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0100 0000' (IKJKEYWD)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 6\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*\n* If the keyword has a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0100' (IKJNAME, has subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 7 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*                +* (2)  offset (plus 1) in PCL to subfield PCE\n*\n* A subfield will be built as well.  But not now.\n*\n* If the keyword doesn't have a value, build an IKJNAME PCE as follows:\n*\n* PCE contents:  +0 (1)  Flags:  B'0110 0000' (IKJNAME, no subfield)\n*                +1 (1)  Flags:  B'0000 0000'\n*                +2 (2)  Length of this PCE: 5 + length(name)\n*                +4 (1)  Length of keyword name minus 1\n*                +5 (*)  the keyword name\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PBKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPBKWLOOP DS    0H                  Loop to build PCE's\n*\n* Build IKJKEYWD PCE\n*\n         ICM   R0,15,FIRSTKEY      If this is first keyword\n         BNZ   *+8                 then\n         ST    R4,FIRSTKEY         set address of first keyword PCE\n         ST    R4,KEYDPCEA-KEYDDATA(,R2) Set address of PCE for this\n         MVI   0(R4),B'01000000'   +0 (1) Flags (IKJKEYWD)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         LA    R0,6\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         LA    R4,6(,R4)           Bump PCE pointer\n*\n* Build IKJNAME PCE, format of which depends if with value or not.\n*\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If a value specified\n         BNO   PBKWNVAL            then...\n         MVI   0(R4),B'01100100'   +0 (1) Flags (IKJNAME, has subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,7(,R15)                7 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n         ST    R4,KEYSUBOF-KEYDDATA(,R2) Save where to set subfield off\n*        ...   ...0(,R4)           Leave subfield offset out for now\n         LA    R4,2(,R4)           Bump to end of PCE\n         B     PBKWNEXT\nPBKWNVAL DS    0H                  No value specified...\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS was specified\n         BO    ERROR_ASIS_NEEDS_VAL           then error\n         MVI   0(R4),B'01100000'   +0 (1) Flags (IKJNAME, no subfield)\n         MVI   1(R4),B'00000000'   +1 (1) Flags\n         L     R15,KEYWORDL-KEYDDATA(,R2) Get length of parameter name\n         LA    R0,5(,R15)                5 + length(name)\n         STH   R0,2(,R4)           +2 (2) Length of this PCE\n         BCTR  R15,0               Length minus 1 for store & execute\n         STC   R15,4(,R4)          +4 (1) Length of keyword name - 1\n         LA    R4,5(,R4)           Point to where to move keyword name\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCE\n         LA    R4,1(R15,R4)        Bump past name\n******** LA    R4,0(,R4)           Bump to end of PCE\nPBKWNEXT DS    0H\n         LA    R5,2(,R5)           Increment PDE offset\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PBKWLOOP          until no more keywords\nPBKWLEND DS    0H                  End loop\n*\n* For each keyword parameter with a value, build subfield PCE's.\n*\n* Build an IKJSUBF PCE.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*                +1 (2)  Offset in PCL to next end-of-field indicator\n*                        (either the next IKJSUBF or the IKJENDP).\n*                        If the subfield had keywords, this would have\n*                        to point to the next IKJKEYWD PCE therein.\n*\n* Build an IKJIDENT PCE for the keyword value.\n*\n* PCE contents:  +0 (1)  Flags:  B'1001 0100' (IKJIDENT, PROMPT)\n*                +1 (1)  Flags:  B'0x00 0000' (x = 1 if ASIS, else 0)\n*                +2 (2)  Length of this PCE: 50 + 2*length(name)\n*                +4 (2)  Offset in PDL to PDE for this parameter\n*                +6 (1)  Flags:  B'0000 1000' (CHAR)\n*                +7 (1)  X'01' (FIRST= is not applicable)\n*                +8 (1)  X'01' (OTHER= is not applicable)\n*                +9 (2)  Length of 'VALUE FOR KEYWORD pp' + 4\n*                                  (22 + length(name))\n*                +B (2)  X'0012'\n*                +D (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*                +* (1)  Length of 'VALUE FOR KEYWORD pp' - 1\n*                                  (17 + length(name))\n*                +* (*)  'VALUE FOR KEYWORD pp' (18 + length(name))\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    PSKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nPSKWLOOP DS    0H                  Loop to build subfield PCE's\n         ICM   R14,15,KEYSUBOF-KEYDDATA(R2) Get where to put sub offset\n         BZ    PSNOSUB             If none, skip\n         LA    R0,1(,R4)           Get address of PCE we're building\n         S     R0,PWADDR           Convert to offset plus 1\n         STH   R0,0(,R14)          Set keyword PCE's subfield offset\n*\n* Build IKJSUBF PCE\n*\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PSNSUBST            to set, then\n         LR    R0,R4                get address of this IKJSUBF PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPSNSUBST DS    0H\n         ST    R4,SUBTOSET         Set address of subfield to set\n         MVI   0(R4),B'00000000'   +0 (1) Flags (end-of-field indicator\n*        ...   ...,1(,R4)          +1 (1) Offset of next SUBF or ENDP\n         LA    R4,3(,R4)           Bump PCE pointer\n         MVI   0(R4),B'10010100'   +0 (1) Flags (IKJIDENT, PROMPT)\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFASIS If /ASIS option given\n         BZ    PSNASIS                        then\n         MVI   1(R4),B'01000000'   +1 (1) Flags\n         B     PSNAEND                        else\nPSNASIS  MVI   1(R4),B'00000000'   +1 (1) Flags\nPSNAEND  DS    0H\n         L     R15,KEYDMAXL-KEYDDATA(,R2) Get length of name for prompt\n         LR    R14,R15\n         SLA   R14,1               2 * length(name)\n         LA    R14,50(,R14)        50 + (2 * length(name))\n         STH   R14,2(,R4)          +2 (2) Length of this PCE\n         STH   R5,4(,R4)           +4 (2) Offset in PDL to PDE for this\n         MVI   6(R4),B'00001000'   +6 (1) Flags (CHAR)\n         MVI   7(R4),X'01'         +7 (1) X'01' (FIRST=n/a)\n         MVI   8(R4),X'01'         +8 (1) X'01' (OTHER=n/a)\n         LA    R0,22(,R15)         18 + length(name) + 4\n         STH   R0,9(,R4)           +9 (2) Length of '...' + 4\n         MVC   11(2,R4),=X'0012'   +B (2) X'0012'\n         MVC   13(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,13+18(,R4)       Point to where to move keyword name\n         BCTR  R15,0               Length minus 1 for store & execute\n         L     R1,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R0,18(,R15)         18 + length(name) - 1\n         STC   R0,0(,R4)           Length of prompt data\n         MVC   1(18,R4),=C'VALUE FOR KEYWORD '\n         LA    R4,1+18(,R4)        Point to where to move keyword name\n         EX    R15,MVCTOPCE        Move keyword name to PCL\n         LA    R4,1(R15,R4)        Bump PCE pointer\n         LA    R5,8(,R5)           Increment PDE offset\nPSNOSUB  DS    0H\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,PSKWLOOP          until no more keywords\nPSKWLEND DS    0H                  End loop\n         SPACE 1\n*\n* Build the IKJENDP part of the PCL.\n*\n* PCE contents:  +0 (1)  Flags:  B'0000 0000' (end-of-field indicator)\n*\n         MVI   0(R4),B'00000000'   +0 (1) Flags\n         ICM   R1,15,SUBTOSET      If there's a previous IKJSUBF PCE\n         BZ    PENSUBST            to set, then\n         LR    R0,R4                get address of this IKJENDP PCE\n         S     R0,PWADDR            convert to offset\n         STH   R0,1(,R1)            set offset to next subfield\nPENSUBST DS    0H\n         ICM   R1,15,FIRSTKEY      If no keyword PCE built\n         BNZ   PEGOTKEY            then\n         ST    R4,FIRSTKEY          make this the one\nPEGOTKEY DS    0H\n         L     R15,PWADDR          Get address of start of PCE\n         L     R0,FIRSTKEY         Load offset of first key/or/etc.PCE\n         SR    R0,R15              Convert to offset\n         STH   R0,4(,R15)          Set offset in IKJPARM PCE\n         LA    R4,1(,R4)           Bump past this PCE\n         LR    R0,R4\n         S     R0,PWADDR           Convert to offset\n         ST    R0,PCLLEN           Set actual PCL length\n         L     R1,PWADDR           Get address of IKJPARM PCE\n         STH   R0,0(,R1)           IKJPARM +0 (2) Length of PCL\n         ST    R4,QOFF             Save address of where to build\n*                                   unquoted strings\n*\n* Note that unquoted strings won't be built until/unless we assign\n* default values from them after a successful parse of the arguments.\n*\n         EJECT\n*\n* Next steps:  If initial variable specified, use IKJCT441 to get its\n*              value.  Otherwise use REXX call to get at arguments.\n*              Make a command buffer out of this and call IKJPARS.\n*              If parsing successful, go thru each positional and\n*              keyword parameter, getting its value, and assign all\n*              the values using IKJCT441.\n*\n         ICM   R0,15,PVARADDR      Get address of first-arg variable\n         BZ    NOVAR               If none, try REXX arg call\n         ST    R0,CVNAMEA          Set address of variable name\n         L     R0,PVARLEN          Get length of first-arg variable\n         ST    R0,CVNAMEL          Set length of variable name\n         LA    R0,TSVERETR         Return variable value\n*                                  (create variable if doesn't exist)\n         ST    R0,CVENTRY          Set entry code\n         XR    R0,R0\n         ST    R0,CVVALUEA         Address of variable value\n         ST    R0,CVVALUEL         Length of variable value\n         ST    R0,CVTOKEN          Token\n         LA    R14,CVENTRY         Store into IKJCT441 parameter list\n         LA    R15,CVNAMEA\n         LA    R0,CVNAMEL\n         LA    R1,CVVALUEA\n         LA    R2,CVVALUEL\n         LA    R3,CVTOKEN\n         STM   R14,R3,CVPARMS\n         OI    CVPARM6,X'80'       Set VL bit\n         LA    R1,CVPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         CH    R15,=H'4'           Get return code\n         BNH   GETVAROK            If not 0 or 4, error\n         BAL   R14,ERROR_GETTING_VAR\n         B     FLUSHIT\n         SPACE 1\nNOVAR    DS    0H                  No variable, try REXX arg call\n         SPACE 1\n*\n***********************************************************************\n*                                                                     *\n* Invoke the IRXEXCOM routine to fetch the ARG information.           *\n*                                                                     *\n* Reference: TSO/E Version 2 REXX Reference, pp. 240-246              *\n*                                                                     *\n***********************************************************************\n*\n* Build the SHVBLOCK\n*\n* To store the argument value, we try using ARGWA, a 512-byte area\n* that is already part of our workarea, to avoid unnecessary GETMAINs.\n*\n* If that doesn't turn out to be big enough, we'll have to GETMAIN,\n* but it's best to avoid that.\n*\n         XC    SHVBLOCK(SHVBLEN),SHVBLOCK\n         MVI   SHVCODE,SHVPRIV     Fetch private information\n         LA    R1,L'ARGWA\n         ST    R1,SHVBUFL          Length of 'fetch' value buffer\n         LA    R1,ARGWA\n         ST    R1,SHVVALA          Address of value buffer\n         LA    R1,=C'ARG'          Name of thing to be fetched\n         ST    R1,SHVNAMA          Address of variable name\n         LA    R1,3                Length('ARG')\n         ST    R1,SHVNAML          Length of variable name\n         LA    R14,=CL8'IRXEXCOM'  IRXEXCOM parm 1\n         XR    R15,R15             IRXEXCOM parm 2\n         LR    R0,R15              Parm 3 must be same as Parm 2\n         LA    R1,SHVBLOCK         IRXEXCOM parm 4\n         STM   R14,R1,IRPARMS\n         OI    IRPARM4,X'80'\nRETRYIRX DS    0H\n         XR    R0,R0               Don't specify an environment block\n         LA    R1,IRPARMS          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTEXCO-TSVT(,R15) Get address of IRXEXCOM\n         BALR  R14,R15             Call REXX arg access routine\n         LTR   R15,R15             If rc zero\n         BZ    OKIRX               then OK\n         CH    R15,=Y(SHVTRUNC)    If value was truncated\n         BE    OOPSIRX             then need more room to hold value\n         B     ERROR_IRXEXCOM      Else error\nOOPSIRX  DS    0H                  Not enough room to hold value\n         ICM   R1,15,ARGADDR       Get address of arg buffer\n         BZ    NOARGYET            If nonzero, then...\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOARGYET DS    0H\n         LA    R0,1024             Increment arg len so far\n         A     R0,ARGLEN\n         ST    R0,ARGLEN\n         ST    R0,SHVBUFL          Reset length of fetch buffer\n         GETMAIN RC,LV=(0),LOC=ANY\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,ARGADDR\n         ST    R1,SHVVALA          Reset address of value buffer\n         B     RETRYIRX            Try again\nOKIRX    DS    0H                  Everything OK\n         MVC   CVVALUEL,SHVVALL    Set length of arg value\n         MVC   CVVALUEA,SHVVALA    Set address of arg value\n         SPACE 1\nGETVAROK DS    0H\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Build a fake command buffer containing the value of the variable,   *\n* for use by IKJPARS.  Format:                                        *\n* ___________________________________________________________________ *\n* |            |       |                                            | *\n* | valuelen+4 | zero  |  value text                                | *\n* |____________|_______|____________________________________________| *\n*                                                                     *\n***********************************************************************\n*\n         LA    R2,4                Get 4 + ...\n         A     R2,CVVALUEL             length of variable value\n         ST    R2,VBUFLEN          Save length\n         GETMAIN RC,LV=(R2),LOC=ANY Get a fake command buffer\n         LTR   R15,R15\n         BNZ   GETMAIN_FAILURE\n         ST    R1,VBUFADDR         Save address of fake command buffer\n         SLL   R2,16               Make buffer prefix\n         ST    R2,0(,R1)           Store into fake command buffer\n         LA    R2,4(,R1)           Address of fake command buffer text\n         L     R14,CVVALUEA        Address of variable value\n         L     R15,CVVALUEL        Length of variable value\n         LR    R3,R15              Length of fake command buffer text\n         MVCL  R2,R14              Move variable value to fake buffer\n*\n***********************************************************************\n*                                                                     *\n* Set up to call IKJPARS.                                             *\n*                                                                     *\n***********************************************************************\n*\n         XC    ANSWER,ANSWER       Clear PDL address field\n         MVC   PPLUPT,CPPLUPT      Address of UPT\n         MVC   PPLECT,CPPLECT      Address of ECT\n         LA    R14,ECB             Address of ECB\n         L     R15,PWADDR          Address of the PCL we built\n         LA    R0,ANSWER           Address of PARSE answer area\n         L     R1,VBUFADDR         Address of our fake command buffer\n         STM   R14,R1,PPLECB       Set rest of PPL\n         ST    R9,PPLUWA           User work area = \"DATD\"\n         ST    R9,PPLVEWA          (we don't use verify exit, but...)\n         SPACE 1\n         CALLTSSR EP=IKJPARS,MF=(E,PPL)\n         LTR   R15,R15\n         BNZ   ERROR_PARSE_FAILURE\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now that PARSE has successfully gotten values for all parameters,   *\n* go through them and retrieve their values, which will be used to    *\n* set variables via IKJCT441.                                         *\n*                                                                     *\n***********************************************************************\n*\n         L     R7,ANSWER           Get address of PDL\n         L     R5,PWADDR           Get address of PCL-et-al work area\n         A     R5,PCLLEN           Bump past PCL part\n         A     R5,QVALLEN          Bump past unquoted-string part\n         LA    R5,3(,R5)           Round up to\n         N     R5,=X'FFFFFFFC'      fullword boundary\n         ST    R5,VUPADDR          Save address of this plist\n*\n* Format of each block of IKJCT441 parameter list:\n*\n*  +00 -> Entry code (TSVEUPDT)\n*  +04 -> Address of variable name\n*  +08 -> Length of variable name\n*  +0C -> Address of variable value\n*  +10 -> Length of variable value\n*  +14 -> Token (zero, not used)\n*  +18 -> ECT (X'FFFFFFFF', not used)\n*  +1C -> Return code from IKJCT441\n*  +20 -> Address of next block of this parameter list or X'80000000'\n*  +24 ... not part of plist, but space to hold the address of value\n*  +28 ... not part of plist, but space to hold the length of value\n*  +2C ... not part of plist, but space to hold the return code\n*  +30 ... not part of plist, but space to hold the address of link\n*\n         XR    R0,R0\n         ST    R0,CVTOKEN\n         MVC   CVECT,=X'FFFFFFFF'\n         LA    R15,TSVEUPDT        Entry code = update variable\n         ST    R15,CVENTRY         Set entry code\n         L     R4,POSCOUNT         Get # of positionals\n         A     R4,KEYCOUNT           + # of keywords\n         BZ    NOUPDATE            If no parameters, no updating.\n         L     R15,VUPADDR         Get address of the plist\nBPLOOP   DS    0H\n         LR    R5,R15              Point to this element of parm list\n         LA    R15,CVENTRY\n         ST    R15,X'00'(,R5)      Parameter 1: entry code\n*                                  Set later...\n*        ST       ,X'04'(,R5)      Parameter 2: address of var name\n*                                  Set later...\n*        ST       ,X'08'(,R5)      Parameter 3: length of var name\n         LA    R15,X'24'(,R5)      Value address slot\n         ST    R15,X'0C'(,R5)      Parameter 4: address of var value\n         LA    R15,X'28'(,R5)      Value length slot\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         LA    R15,CVTOKEN         Dummy token\n         ST    R15,X'14'(,R5)      Parameter 6: token (not used)\n         LA    R15,CVECT           Dummy ECT\n         ST    R15,X'18'(,R5)      Parameter 7: ECT (not used)\n         LA    R15,X'2C'(,R5)      Return code slot\n         ST    R15,X'1C'(,R5)      Parameter 8: IKJCT441 return code\n         LA    R15,X'30'(,R5)      Link slot\n         ST    R15,X'20'(,R5)      Parameter 9: next element in list\n         LA    R15,X'34'(,R5)\n         ST    R15,X'30'(,R5)      Address of next plist block\n         OI    X'20'(R5),X'80'     Set VL bit\n         BCT   R4,BPLOOP           Continue\n         L     R0,=X'00000000'     At end,\n         ST    R0,X'30'(,R5)       clear last link pointer in list\n         L     R5,VUPADDR          Point to first plist block again\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through positional parameters, setting things up.            *\n*                                                                     *\n* Format of PDE for a positional parameter (IKJIDENT):                *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,POSCOUNT      Get count of positionals\n         BZ    BPPPLEND            If none, skip\n         L     R2,APOSD            Get address of first positional\nBPPPLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         LA    R15,POSDADDR-POSDDATA(,R2) Get address of param name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,POSDLEN-POSDDATA(,R2) Get length of param name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         L     R15,POSDPCEA-POSDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPPPPRES            then...\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPPPSET             else...\nBPPPPRES DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPPPSET  DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         LA    R2,POSDDATL(,R2)    Continue\n         BCT   R8,BPPPLOOP          until no more positionals\nBPPPLEND DS    0H                  End loop\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Now go through keyword parameters, setting things up.               *\n*                                                                     *\n* Format of PDE for a keyword parameter (IKJKEYWD):                   *\n*                                                                     *\n* +0 (2) Number (0 if not specified, 1 if specified)                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Format of PDE for a keyword value parameter (IKJIDENT):             *\n*                                                                     *\n* +0 (4) Pointer to the positional operand                            *\n* +4 (2) Length thereof                                               *\n* +6 (1) Flags                                                        *\n* +7 (1) Reserved                                                     *\n*                                                                     *\n* Meaning of flags:  0... ....  The operand is not present.           *\n*                    1... ....  The operand is present.               *\n*                    .xxx xxxx  Reserved bits.                        *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R8,15,KEYCOUNT      Get count of keywords\n         BZ    BPKWLEND            If none, skip\n         L     R2,AKEYD            Get address of first keyword\nBPKWLOOP DS    0H                  Loop to fill in IKJCT441 plist\n         ST    R2,SAVER2           Save register to protect from TRT's\n         LA    R15,KEYWORDA-KEYDDATA(,R2) Get address of keyword name\n         ST    R15,X'04'(,R5)      Parameter 2: address of var name\n         LA    R15,KEYWORDL-KEYDDATA(,R2) Get length of keyword name\n         ST    R15,X'08'(,R5)      Parameter 3: length of var name\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFDVAL If keyword(value),\n         BO    BPKWDVAL            then process value subfield\n*\n* Keyword without value is set to keyword name if specified, else null\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWWPRS            then...\n         XR    R15,R15              say it's set to a null value\n         ST    R15,X'24'(,R5)       set address of variable value\n         ST    R15,X'28'(,R5)       set length of variable value\n         B     BPKWNEXT            else...\nBPKWWPRS DS    0H                  (operand is present)\n         L     R14,X'04'(,R5)       get address of variable name\n         L     R15,X'08'(,R5)       get length of variable name\n         ST    R14,X'0C'(,R5)      Parameter 4: address of var value\n         ST    R15,X'10'(,R5)      Parameter 5: length of var value\n         B     BPKWNEXT\n         SPACE 1\nBPKWDVAL DS    0H                  Else keyword with a value specified\n*\n* Keyword with value:  If keyword is present, set from value subfield\n* (which must be present according to the PARS rules).  Otherwise,\n* set value from default from XPROC statement, unquoting if needed.\n*\n         L     R15,KEYDPCEA-KEYDDATA(,R2) Get address of PCE\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n         CLC   0(2,R1),=X'0000'    If keyword is not specified,\n         BNE   BPKWVPRS            then...\n         L     R14,KEYDVALA-KEYDDATA(,R2) get address of default value\n         L     R15,KEYDVALL-KEYDDATA(,R2) get length of default value\n         TM    KEYFLAGS-KEYDDATA(R2),KEYFQUOT If value is quoted,\n         BNO   BPKWVSET            then...\n*                                   unquote it\n         LA    R1,1(,R14)          Get address of quoted string + 1\n         LR    R3,R15              Get length of quoted string\n         SH    R3,=H'2'            minus 2 to get length between quotes\n         BZ    BPKWNULL            If '', set variable to null value\n         LR    R15,R1\n         LR    R14,R1              Save address of string input\n         ST    R14,SCANPTR\n         AR    R14,R3              Save address of end of it\n         ST    R14,SCANEPTR\n         L     R14,QOFF            Get where to build unquoted string\n         LA    R0,256              Make a constant value of 256\nBPGOTQL  CR    R3,R0               If length greater than 256\n         BNH   BPGOTQX             then...\n         TRT   0(256,R15),STBLQUOT  scan for \"'\"\n         BNZ   BPGOTQT              If we found it, go. Else\n         MVC   0(256,R14),0(R15)    copy unquoted data to area\n         AR    R14,R0               Increment output pointer by 256\n         AR    R15,R0               Increment input pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    BPGOTQL              Either continue scanning\n         B     BPGOTQE              or, if length zero, finished\nBPGOTQX  DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,BPGQTRT           Scan for \"'\"\n         BNZ   BPGOTQT              If found something, go\n         B     BPGOTQE              else end of string\nBPGOTQT  DS    0H                  Reached \"'\"\n         CLI   1(R1),C''''         Another \"'\" has to follow\n         BNE   0(0)                (else abend)\n         LR    R3,R1               Get length we just scanned\n         SR    R3,R15\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGQNMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,1(R14,R3)       Bump past it and following quote\n         LA    R15,2(,R1)          Bump to location past \"''\"\n         L     R3,SCANEPTR\n         SR    R3,R15              R3 := length remaining to scan\n         BP    BPGOTQL             If something left, continue scan\nBPGOTQE  DS    0H                  End of quoted string\n         L     R3,SCANEPTR\n         SR    R3,R15              Get length remaining to move\n         BZ    BPGENMV             If zero, skip move\n         EX    R3,BPGQMVC          Move data so far (R15 -> it)\nBPGENMV  DS    0H                  (including quote, so no BCTR)\n         LA    R14,0(R14,R3)       Bump past it\n         LR    R15,R14\n         S     R15,QOFF            Get length of unquoted string\n         L     R1,QOFF             Get address of unquoted string\n         ST    R14,QOFF            Update where to build next string\n         LR    R14,R1\n         B     BPKWDSET            Set address and length of string\nBPKWVSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\n         B     BPKWNEXT\nBPKWVPRS DS    0H                  (operand is present)\n         L     R15,KEYSUBOF-KEYDDATA(,R2) Get where subfield offset is\n         LH    R15,0(,R15)         Get offset+1 of IKJSUBF PCE\n         LA    R15,2(,R15)         Bump to associated IKJIDENT PCE\n         A     R15,PWADDR          Convert to address of subfield\n         LH    R1,4(,R15)          Get offset of PDE for this PCE\n         AR    R1,R7               Convert to address of PDE\n*\n* Note: Of course it's impossible for the operand not to be present\n*       under the current implementation.  But a future extension\n*       might make this possible.\n*\n         TM    6(R1),X'80'         If operand is not present,\n         BO    BPKWDPRS            then...\nBPKWNULL DS    0H\n         XR    R14,R14              say it's set to a null value\n         XR    R15,R15              say it's set to a null value\n         B     BPKWDSET            else...\nBPKWDPRS DS    0H                  (operand is present)\n         L     R14,0(,R1)           get address of value\n         LH    R15,4(,R1)           get length of value\nBPKWDSET DS    0H                  else (operand is present)\n         ST    R14,X'24'(,R5)      Set address of variable value\n         ST    R15,X'28'(,R5)      Set length of variable value\nBPKWNEXT DS    0H                  Continue\n         L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         L     R2,SAVER2           Restore register clobbered by TRT\n         LA    R2,KEYDDATL(,R2)    Continue\n         BCT   R8,BPKWLOOP          until no more positionals\nBPKWLEND DS    0H                  End loop\n*\n* Now call IKJCT441 to do all the variable updates.\n*\n         L     R1,VUPADDR          Point to parameter list\n         L     R15,X'10'               Get address of CVT\n         L     R15,CVTTVT-CVT(,R15)    Get address of TSO vector table\n         L     R15,TSVTVACC-TSVT(,R15) Get address of IKJCT441\n         BALR  R14,R15             Call variable access routine\n         L     R5,VUPADDR\nRCLOOP   DS    0H\n         LA    R5,0(,R5)           Clear VL bit if any\n         LTR   R5,R5\n         BZ    RCEND\n         L     R15,X'2C'(,R5)      Get return code set by IKJCT441\n         CH    R15,=H'4'           If return code\n         BNH   RCNEXT              If not 0 or 4, error\n         BAL   R14,ERROR_PUTTING_VAR\n         OI    FLAGS,FLAGPUTE\nRCNEXT   L     R5,X'20'(,R5)       Go to\n         L     R5,0(,R5)                 next element of param list\n         B     RCLOOP\nRCEND    DS    0H\n         TM    FLAGS,FLAGPUTE      If a variable update error,\n         BO    FLUSHIT             then flush\n         SPACE 1\nNOUPDATE DS    0H                  Here if no call to IKJCT441 needed\n         SPACE 1\n         B     RETURN0             Everything fine, return code(0)\n         EJECT\n*\nTRTPOSCT TRT   0(*-*,R3),NUMTBL    Executed: scan word for numerics\nPACKIT   PACK  DOUBLE(8),0(*-*,R3) Executed: convert word to decimal\nVERIFYP  TRT   0(*-*,R14),VERTBL   Executed: verify syntax of parameter\nMVCWORD  MVC   0(*-*,R1),0(R14)    Executed: move parameter to wordarea\nUPWORD   TR    0(*-*,R1),UPTBL     Executed: translate to uppercase\nCOMPWORD CLC   0(*-*,R1),0(R14)    Executed: compare parameters\nMVCTOPCE MVC   0(*-*,R4),0(R1)     Executed: move parameter name to PCE\nBPGQTRT  TRT   0(*-*,R15),STBLQUOT Executed: scan for \"'\" mark\nBPGQMVC  MVC   0(*-*,R14),0(R15)   Executed: copy unquoted data to area\n*\n         EJECT\n*\n***********************************************************************\n*                                                                     *\n* Various error conditions.                                           *\n*                                                                     *\n***********************************************************************\n*\nERROR_GETTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,CVNAMEL          Length of variable name\n         L     R3,CVNAMEA          Address of variable name\n         ERROR MSG_GETTING_VAR,FLUSH=NO\n         B     ERROR441\n         SPACE 1\nERROR_PUTTING_VAR DS 0H\n         ST    R14,E44114          Save return register\n         ST    R15,RC441           Save IKJCT441 return code\n         L     R2,X'08'(,R5)       -> Length of variable name\n         L     R2,0(,R2)           Length of variable name\n         L     R3,X'04'(,R5)       -> Address of variable name\n         L     R3,0(,R3)           Address of variable name\n         ERROR MSG_PUTTING_VAR,FLUSH=NO\n******** B     ERROR441\n         SPACE 1\nERROR441 DS    0H\n         XR    R2,R2               No additional information for...\n         XR    R3,R3\n         L     R4,RC441            Load IKJCT441 return code\n         CH    R4,=H'81'           Check IKJCT441 return code\n         BH    ERROR441_MISC       > 81\n         BE    ERROR441_RC81       = 81\n         B     *(R4)               Else branch based on return code\n         B     ERROR441_MISC       04: Variable cannot be rescanned\n*                                  (not treated as an error here)\n         B     ERROR441_RC08       08: Variable is a CLIST BIF\n         B     ERROR441_RC12       12: Variable is a CLIST label\n         B     ERROR441_RC16       16: Variable is unmodifiable\n         B     ERROR441_MISC       20: n/a\n         B     ERROR441_RC24       24: Variable is a CLIST subprocedure\n         B     ERROR441_MISC       28: n/a\n         B     ERROR441_RC32       32: GETMAIN/FREEMAIN failure\n         B     ERROR441_RC36       36: Variable length is invalid\n         B     ERROR441_RC40       40: Not in CLIST or REXX environment\n         B     ERROR441_MISC       44: invalid entry code\n         B     ERROR441_MISC       48: n/a\n         B     ERROR441_MISC       52: n/a\n         B     ERROR441_MISC       56: n/a\n         B     ERROR441_MISC       60: n/a\n         B     ERROR441_MISC       64: n/a\n         B     ERROR441_MISC       68: n/a\n         B     ERROR441_MISC       72: n/a\n         B     ERROR441_RC76       76: Variable is undefined &SYSX...\n         B     ERROR441_RC80       80: Variable name invalid for REXX\nERROR441_RC08 ERROR MSG_IKJCT441_RC08,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC12 ERROR MSG_IKJCT441_RC12,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC16 ERROR MSG_IKJCT441_RC16,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC24 ERROR MSG_IKJCT441_RC24,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC32 ERROR MSG_IKJCT441_RC32,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC36 ERROR MSG_IKJCT441_RC36,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC40 ERROR MSG_IKJCT441_RC40,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC76 ERROR MSG_IKJCT441_RC76,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC80 ERROR MSG_IKJCT441_RC80,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_RC81 ERROR MSG_IKJCT441_RC81,FLUSH=NO\n         L     R14,E44114\n         BR    R14\nERROR441_MISC DS 0H\n         CVD   R4,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IKJCT441_RC,FLUSH=NO\n         L     R14,E44114\n         BR    R14\n         SPACE 1\nNOOPERANDS DS  0H                  No input variable\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_OPERANDS\n         SPACE 1\nNOPOSCOUNT DS  0H                  No count of positional parameters\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_POS_COUNT\n         SPACE 1\nBADPOSCOUNT DS 0H                  Bad count of positional parameters\n         LA    R2,1(,R4)           Get length of bad data\n         ERROR MSG_BAD_POS_COUNT\n         SPACE 1\nERROR_NO_WANT_LP DS 0H             Left parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_LP\n         SPACE 1\nERROR_NO_WANT_RP DS 0H             Right parenthesis found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_RP\n         SPACE 1\nERROR_NO_WANT_QS DS 0H             Quoted string found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_QS\n         SPACE 1\nERROR_NO_WANT_SL DS 0H             Slash found, not wanted\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_NO_WANT_SL\n         SPACE 1\nPPMISSING DS   0H                  Positional parm not found, expected\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_TOO_FEW_PPARMS\n         SPACE 1\nERROR_PARM_TOO_LONG DS 0H\n         LA    R2,252              Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_PARM_TOO_LONG\n         SPACE 1\nERROR_PARM_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_INVALID\n         SPACE 1\nERROR_PARM_DUPLICATE DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_PARM_DUPLICATE\n         SPACE 1\nERROR_OPT_TOO_LONG DS 0H\n         LA    R2,L'OPTION         Display only up to maximum length\n         LR    R3,R1               Address of offending parameter\n         ERROR MSG_OPT_TOO_LONG\n         SPACE 1\nERROR_OPT_INVALID DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_INVALID\n         SPACE 1\nERROR_OPT_POS_ONLY DS 0H\n         LA    R2,1(,R15)          Length of offending parameter\n         LR    R3,R14              Address of offending parameter\n         ERROR MSG_OPT_POS_ONLY\n         SPACE 1\nERROR_ASIS_NEEDS_VAL DS 0H\n         L     R3,KEYWORDA-KEYDDATA(,R2)\n         L     R2,KEYWORDL-KEYDDATA(,R2)\n         ERROR MSG_ASIS_NEEDS_VAL\n         SPACE 1\nERROR_PP_WITH_LP DS 0H             Positional parm with left paren\n         ERROR MSG_PP_WITH_LP\n         SPACE 1\nERROR_FIRST_ARG DS 0H              Bad first argument\n         LR    R2,R4               Length of offending parameter\n         ERROR MSG_VAR_TOO_LONG\n         SPACE 1\nERROR_IRXEXCOM DS 0H               IRXEXCOM failed\n         C     R15,=F'-2'          Insufficient storage?\n         BE    GETMAIN_FAILURE\n         C     R15,=F'-1'          No valid REXX environment?\n         BE    ERROR_REXX_REQUIRED\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(3),DOUBLE(8)\n         OI    DOUBLE+2,X'F0'\n         LA    R2,3                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_IRXEXCOM_FAIL\n         SPACE 1\nERROR_REXX_REQUIRED DS 0H\n         XR    R2,R2\n         XR    R3,R3\n         ERROR MSG_REXX_REQUIRED\nERROR_PARSE_FAILURE DS 0H          IKJPARS failed\n         CH    R15,=H'4'\n         BE    FLUSHIT\n         CH    R15,=H'20'\n         BE    FLUSHIT\n         CH    R15,=H'32'\n         BE    FLUSHIT\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_PARSE_FAILURE\n         SPACE 1\nGETMAIN_FAILURE DS 0H              Insufficient storage\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_GETMAIN_FAIL\n         SPACE 1\nKVERROR  DS    0H                  This should never happen\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_KV_ERROR\n         SPACE 1\nFLUSHIT  DS    0H                  Return in failure\n         SPACE 1\n         TCLEARQ INPUT             Flush terminal input\n         MVC   FLUSH(LENFLUSH),MFLUSH Set up STACK list form\n         XC    ECB,ECB             Clear ECB and flush the input stack\n         STACK PARM=FLUSH,MF=(E,IOPL)\n         LTR   R15,R15             If STACK failed,\n         BZ    RETURN12            then...\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         LA    R2,2                Length of error code\n         LA    R3,DOUBLE           Address of error code\n         ERROR MSG_STACK_ERROR,FLUSH=NO\nRETURN12 DS    0H\n         LA    R2,12               Set return code to 12\n         B     RETURN\n         SPACE 1\nRETURN0  DS    0H                  Return with code 0\n         XR    R2,R2               Set return code to zero\n******** B     RETURN\n         SPACE 1\nRETURN   DS    0H                  R2 contains return code\n         SPACE 1\n         ICM   R1,15,PWADDR        If there was a parse work area\n         BZ    NOFREEPW            then free it\n         L     R0,PWLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPW DS    0H\n         SPACE 1\n         ICM   R1,15,VBUFADDR      If there was a fake command buffer\n         BZ    NOFREEVBUF          then free it\n         L     R0,VBUFLEN\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEVBUF DS  0H\n         SPACE 1\n         ICM   R1,15,ARGADDR       If there was an arg buffer\n         BZ    NOFREEARG           then free it\n         L     R0,ARGLEN           Get length\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEARG DS   0H\n         SPACE 1\n         ICM   R1,15,AKEYD         If there was a keyword/value area\n         BZ    NOFREEKEYD          then free it\n         L     R0,LKEYD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEKEYD DS  0H\n         SPACE 1\n         ICM   R1,15,APOSD         If there was a pos parm area,\n         BZ    NOFREEPOSD          then free it\n         L     R0,LPOSD\n         FREEMAIN RC,LV=(0),A=(1)\nNOFREEPOSD DS  0H\n         SPACE 1\n         IKJRLSA ANSWER            Free IKJPARS storage if any\n         SPACE 1\n         L     R0,DATDLEN          Get length of work area\n         LR    R1,R13              Get address of work area\n         L     R13,4(,R13)         Unchain save area\n         ST    R2,16(,R13)         Store return code in save area\n         FREEMAIN R,LV=(0),A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n***********************************************************************\n* Subroutines                                                         *\n***********************************************************************\n         EJECT\nDOOPTS   DS    0H                  Process options following \"/\"\n         SPACE 1\n         ST    R14,DOOPT14         Save return address\n         TM    FLAGS,FLAGPOSD+FLAGKEYD Must be processing either a\n         BZ    ERROR_NO_WANT_SL    positional or a keyword\n*\n* Process the option following the slash.\n*\n         BAL   R14,SCAN            Scan for option name\n         B     DOOPTRET            None, skip\n         B     OPTNAME             Unquoted name, process\n         B     ERROR_NO_WANT_QS    Quoted string found\n         B     ERROR_NO_WANT_LP    \"(\" found\n         B     ERROR_NO_WANT_RP    \")\" found\n         B     ERROR_NO_WANT_SL    \"/\" found\n         SPACE 1\nOPTNAME  DS    0H                  Option name found\n*\n* Validate option name and process it.\n*\n         CH    R2,=Y(L'OPTION)     If too long\n         BH    ERROR_OPT_TOO_LONG  then error\n         MVI   OPTION,C' '         Clear option field to blanks\n         MVC   OPTION+1(L'OPTION-1),OPTION\n         LR    R14,R1              Address\n         LR    R15,R2              Length\n         BCTR  R15,0               Reduce length for execute\n         LA    R1,OPTION           Point to place to move option name\n         EX    R15,MVCWORD         Move option name to option area\n         EX    R15,UPWORD          Translate to uppercase\n*\n* Time to process the options\n*\n         TM    FLAGS,FLAGPOSD      If currently processing positional\n         BO    DOOPTP              then check positional options\n         B     DOOPTK              else check keyword options\n         SPACE 1\nDOOPTP   DS    0H\n         L     R1,LASTAREA         Point to current PP area\n******** CLC   =C'OPTIONAL ',OPTION\n******** BE    DOOPTP_OPTIONAL\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTP_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    DOOPTP_CHAR\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTP_OPTIONAL DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDOPT\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_ASIS     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTP_CHAR     DS 0H\n         OI    POSDFLGS-POSDDATA(R1),POSDCHAR\n         B     DOOPTRET\n         SPACE 1\nDOOPTK   DS    0H\n         L     R1,LASTAREA         Point to current KV area\n         CLC   =C'ASIS ',OPTION\n         BE    DOOPTK_ASIS\n         CLC   =C'QUOTABLE ',OPTION\n         BE    ERROR_OPT_POS_ONLY\n         B     ERROR_OPT_INVALID   All other options are bad, error\n         SPACE 1\nDOOPTK_ASIS    DS 0H\n         OI    KEYFLAGS-KEYDDATA(R1),KEYFASIS\n         B     DOOPTRET\n         SPACE 1\nDOOPTRET DS    0H\n         L     R14,DOOPT14\n         BR    R14\n         EJECT\nSCAN     DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine scans the command buffer for operands.  It returns the *\n* address of the next operand in R1 and its length in R2 (when there  *\n* are no more operands, R1 and R2 are zeroed).  The operand may be a  *\n* name, a number, a parenthesis, or a quoted string. If it's a quoted *\n* string, it will be returned as is, quotes and all.                  *\n*                                                                     *\n* Return is as follows:                                               *\n*                                                                     *\n* To return address + 0  ... no value found                           *\n* To return address + 4  ... unquoted string found                    *\n* To return address + 8  ... quoted string found                      *\n* To return address + 12 ... left parenthesis found                   *\n* To return address + 16 ... right parenthesis found                  *\n*                                                                     *\n* SCANPTR -> area to scan; SCANEPTR -> end thereof                    *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,SCANPTR          Point to data to scan\n         XR    R2,R2               Clear TRT register\n         L     R3,SCANEPTR         Point to end of data to scan\n         SR    R3,R1               Get length of data to scan\n         LA    R0,256              Set up constant 256\n         LTR   R3,R3               If length is zero\n         BZ    SCANEND             then finished, return no value\nSCANLOOP DS    0H                  Do TRT for remaining length\n         CR    R3,R0               If length greater than 256\n         BNH   SCANLEFF            then...\n         TRT   0(256,R1),STBL0      scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n         AR    R1,R0                Else increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    SCANLOOP             Either continue scanning\n         B     SCANEND              or exit (no value), length now zero\nSCANLEFF DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,SCANTRT           Scan for important characters\n         BNZ   SCANGOT1             If we found something, process it\n******** B     SCANEND              If none found, exit in failure\nSCANEND  DS    0H                  Reached end of data\n         XR    R1,R1               Clear scanning registers\n         XR    R2,R2\n         BR    R14                 Return with no value\nSCANGOT1 DS    0H                  R1 -> something we found\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         B     *(R2)               R2 tells what kind it is\n         B     GOTWORD             4:  Found nonblank\n         B     GOTLP               8:  Found (\n         B     GOTRP               12: Found )\n         B     GOTSLASH            16: Found /\n         B     GOTQUOTE            20: Found '\n         SPACE 1\nGOTWORD  DS    0H                  Found a nonblank (word)\n*                                  R1 -> it, R3 = length to scan\n*\n* Scan for end-of-word\n*\n         LR    R15,R1              Save address of the word\nGOTWORDL CR    R3,R0               If length greater than 256\n         BNH   GOTWORDX            then...\n         TRT   0(256,R1),STBLWORD   scan for important characters\n         BNZ   GOTWORDT             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTWORDL             Either continue scanning\n         B     GOTWORDE             or go if length zero\nGOTWORDX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTWTRT           Scan for important characters\n         BNZ   GOTWORDT             If found something, go\n         L     R1,SCANEPTR          Else end of text = end of word\n         B     GOTWORDE\nGOTWORDT L     R3,SCANEPTR         R3 := length remaining to scan\n         SR    R3,R1               R1 -> character\n         B     *(R2)               Branch depending on R2\n         B     GOTWORDE            4:  Found whitespace, end of word\n         B     GOTWLP              8:  Found (\n         B     GOTWRP              12: Found )\n         B     GOTWS               16: Found /\n         SPACE 1\nGOTWORDE DS    0H                  Found whitespace or end of word\n         LR    R2,R1               Set length of word found\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     4(,R14)             Return to caller with unquoted word\nGOTWLP   DS    0H                  Found \"(\" in word\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         B     GOTWNEXT            Else process as constituent char\nGOTWRP   DS    0H                  Found a right parenthesis \")\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    GOTWORDE            If was zero, not nested, end of word\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BZ    GOTWORDE            If now zero, not nested, end of word\n         B     GOTWNEXT            Else process as constituent char\nGOTWS    DS    0H                  Found a slash \"/\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWNEXT            If inside (), treat as constituent\n         B     GOTWORDE            Else treat as end of word\n         SPACE 1\nGOTWNEXT LA    R1,1(,R1)           Bump text pointer\n         BCT   R3,GOTWORDL         Decrement count, scan if nonzero\n         B     GOTWORDE            end of word\n         SPACE 1\nGOTLP    DS    0H                  Found a left parenthesis \"(\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If count was nonzero, start of word\n         LA    R2,1(,R2)           Increment it\n         ST    R2,PARCOUNT\n         LA    R2,1                Else set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     12(,R14)            Return single left parenthesis\n         SPACE 1\nGOTRP    DS    0H                  Found a right parenthesis \")\"\n*                                  R1 -> it, R3 = length to scan\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BZ    SCANRETP            If was zero, not nested, return \")\"\n         BCTR  R2,0                Decrement count\n         ST    R2,PARCOUNT\n         LTR   R2,R2\n         BNZ   GOTWORD             If now nonzero, part of word\nSCANRETP DS    0H                  Return the parenthesis\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     16(,R14)            Return single right parenthesis\n         SPACE 1\nGOTQUOTE DS    0H                  Found a single quote \"'\"\n*                                  R1 -> it, R3 = length to scan\n         LR    R15,R1              Save address of the quoted string\n         LA    R1,1(,R1)           Bump past initial quote\n         BCT   R3,GOTQL            Decrement length to scan\n         B     ERRQUOTE            If nothing left, error\nGOTQL    CR    R3,R0               If length greater than 256\n         BNH   GOTQX               then...\n         TRT   0(256,R1),STBLQUOT   scan for \"'\"\n         BNZ   GOTQT                If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTQL                Either continue scanning\n         B     ERRQUOTE             or, if length zero, error\nGOTQX    DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTQTRT           Scan for \"'\"\n         BNZ   GOTQT                If found something, go\n         B     ERRQUOTE             Else error\nGOTQT    DS    0H                  Reached \"'\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         BNP   GOTQE               If zero, it's the ending quote\n         CLI   1(R1),C''''         If not \"''\"\n         BNE   GOTQE               then it's the ending quote\n         LA    R1,2(,R1)           Else bump past \"''\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    GOTQL               If something left, continue scan\n         B     ERRQUOTE            Else error\nGOTQE    DS    0H                  End of quoted string\n         LA    R1,1(,R1)           Bump past final quote mark\n         LR    R2,R1               Set length of string including \"'\"s\n         SR    R2,R15\n         ST    R1,SCANPTR          Set scan pointer for next scan\n         LR    R1,R15              Set pointer to found item\n         B     8(,R14)             Return quoted string to caller\n         SPACE 1\nGOTSLASH DS    0H                  Found a slash \"/\"\n*                                  R1 -> it, R3 = length to scan\n         CH    R3,=H'2'            If not enough room for \"/*\"\n         BL    GOTSL               then treat as real slash\n         CLI   1(R1),C'*'          If not \"/*\"\n         BNE   GOTSL               then treat as real slash\n         LA    R1,2(,R1)           Else start of comment: bump text ptr\n         SH    R3,=H'2'            Decrement length to scan\n         BNP   SCANEND             If nothing left, end of text\nGOTCOMML CR    R3,R0               If length greater than 256\n         BNH   GOTCOMMX            then...\n         TRT   0(256,R1),STBLCOMM   scan for \"*\"\n         BNZ   GOTCOMME             If we found it, go. Else\n         AR    R1,R0                Increment text pointer by 256\n         SR    R3,R0                Decrement length by 256\n         BP    GOTCOMML             Either continue scanning\n         B     SCANEND              or, if length zero, end of text\nGOTCOMMX DS    0H                  Else...\n         BCTR  R3,0                 Reduce length for execute\n         EX    R3,GOTCTRT           Scan for \"*\"\n         BNZ   GOTCOMME             If found something, go\n         B     SCANEND              Else end of text\nGOTCOMME DS    0H                   Reached an \"*\"\n         L     R3,SCANEPTR\n         SR    R3,R1               R3 := length remaining to scan\n         CH    R3,=H'2'            If not enough room for \"*/\"\n         BL    GOTCOMMC            then continue scanning for it\n         CLI   1(R1),C'/'          If not \"*/\"\n         BNE   GOTCOMMC            then continue scanning for it\n         LA    R1,2(,R1)           Else bump past \"*/\"\n         SH    R3,=H'2'            Decrement scan length\n         BP    SCANLOOP            If something left, continue scan\n         B     SCANEND             Else end of text\nGOTCOMMC DS    0H                  \"*\" but no \"/\"\n         LA    R1,1(,R1)           Bump past \"*\"\n         BCT   R3,GOTCOMML         Decrement length, continue if nzero\n         B     SCANEND             Else end of text\nGOTSL    DS    0H                  Found a slash \"/\" without a \"*\"\n         ICM   R2,15,PARCOUNT      Get parenthesis count\n         BNZ   GOTWORD             If inside (), treat as constituent\nRETSLASH DS    0H                  Else treat as single slash \"/\"\n         LA    R2,1                Set length to 1\n         LA    R15,1(,R1)          Set pointer past it\n         ST    R15,SCANPTR         Update scan pointer\n         B     20(,R14)            Return single slash\n         SPACE 1\nERRQUOTE DS    0H                  Mismatched quotes\n         XR    R2,R2               No accompanying data\n         XR    R3,R3               \" \" \"\n         ERROR MSG_QUOTE_ERROR\n         SPACE 1\nSCANTRT  TRT   0(*-*,R1),STBL0      (Executed instruction)\nGOTWTRT  TRT   0(*-*,R1),STBLWORD   (Executed instruction)\nGOTCTRT  TRT   0(*-*,R1),STBLCOMM   (Executed instruction)\nGOTQTRT  TRT   0(*-*,R1),STBLQUOT   (Executed instruction)\n         SPACE 1\nSTBL0    DC    256YL1(4)           Table to scan for good stuff\n         ORG   STBL0+C' '          Blank\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C','          Comma\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+X'05'         Tab\n         DC    YL1(0)              is whitespace\n         ORG   STBL0+C'('          Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBL0+C')'          Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBL0+C'/'          Slash\n         DC    YL1(16)             might be part of /*\n         ORG   STBL0+C''''         Quote\n         DC    YL1(20)             is special\n         ORG   ,\n         SPACE 1\nSTBLWORD DC    256YL1(0)           Table to scan for end of word\n         ORG   STBLWORD+C' '       Blank\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C','       Comma\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+X'05'      Tab\n         DC    YL1(4)              is whitespace\n         ORG   STBLWORD+C'('       Left parenthesis\n         DC    YL1(8)              is special\n         ORG   STBLWORD+C')'       Right parenthesis\n         DC    YL1(12)             is special\n         ORG   STBLWORD+C'/'       Slash\n         DC    YL1(16)             might be part of /*\n         ORG   ,\n         SPACE 1\nSTBLCOMM DC    256YL1(0)           Table to scan for \"*/\"\n         ORG   STBLCOMM+C'*'\n         DC    1YL1(1)\n         ORG   ,\n         SPACE 1\nSTBLQUOT DC    256YL1(0)           Table to scan for \"'\"\n         ORG   STBLQUOT+C''''\n         DC    1YL1(1)\n         ORG   ,\nVERTBL   DC    256YL1(1)           Table to verify parameter syntax\n         ORG   VERTBL+C'_'         Underscore is valid (?)\n         DC    YL1(0)               valid?\n         ORG   VERTBL+C'@'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'#'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'$'         National character is valid (?)\n         DC    YL1(0)\n         ORG   VERTBL+C'a'         Lower case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'j'\n         DC    9YL1(0)\n         ORG   VERTBL+C's'\n         DC    8YL1(0)\n         ORG   VERTBL+C'A'         Upper case alphabetics are valid\n         DC    9YL1(0)\n         ORG   VERTBL+C'J'\n         DC    9YL1(0)\n         ORG   VERTBL+C'S'\n         DC    8YL1(0)\n         ORG   VERTBL+C'0'         Numerics are valid (except 1st pos)\n         DC    10YL1(0)\n         ORG   ,\nUPTBL    DC    256YL1(*-UPTBL)     Table to translate to uppercase\n         ORG   UPTBL+C'a'\n         DC    C'ABCDEFGHI'\n         ORG   UPTBL+C'j'\n         DC    C'JKLMNOPQR'\n         ORG   UPTBL+C's'\n         DC    C'STUVWXYZ'\n         ORG   ,\n         EJECT\nPUTLINE  DS    0H\n*\n***********************************************************************\n*                                                                     *\n* This routine displays messages to the TSO user using the TSO        *\n* PUTLINE service routine.  At entry R1 contains the address of the   *\n* message to be displayed, and R0 contains the length of the message. *\n* R3 points to additional data to be displayed, and R2 is its length. *\n* If R1 is zero, the message has already been built in the workarea   *\n* MSGWA.  The message is assumed to begin with a message ID unless    *\n* the first character is blank, in which case the initial blank is    *\n* stripped off by PUTLINE anyhow.                                     *\n*                                                                     *\n***********************************************************************\n*\n         ST    R14,PUTL14          Save return register\n         LTR   R15,R0              Load length value\n         BNP   PUTLRET             If zero, don't do anything\n         BCTR  R15,0               Else reduce length for execute\n         LTR   R1,R1               If R1 is zero,\n         BZ    PUTIT               then message already set up.\n         EX    R15,MVCPUT          Else move message to work area\n         LTR   R2,R2               If additional data,\n         BZ    PUTIT               then\n         LA    R1,MSGWA+1(R15)      Point to end of message\n         CH    R2,=H'256'           (Use max length of 256)\n         BNH   *+8\n         LA    R2,256\n         BCTR  R2,0                 Reduce data length for execute\n         EX    R2,MVCPUT2           Move additional data to work area\n         LA    R15,1(R15,R2)        Add length of data to msg length\nPUTIT    DS    0H\n         LA    R15,5(,R15)         Restore length + 4 for header\n         SLL   R15,16              Shift length into left half of hdr\n         STCM  R15,15,MSGHDR       Put zeroes into right half of hdr\nPUTLINE_RETRY DS 0H\n         XC    ECB,ECB             Clear ECB\n         PUTLINE PARM=PTLIST,                                          X\n               MF=(E,IOPL),                                            X\n               OUTPUT=(OLD,TERM,SINGLE,INFOR)\n         LTR   R15,R15             If PUTLINE OK\n         BZ    PUTLRET             then return\n         CH    R15,=H'8'           Else if attention interrupt\n         BE    PUTLRET             then OK\n         CH    R15,=H'12'          Else if pending 2nd level message\n         BE    PUTL12              then OK\nPUTERROR DS    0H                  Else PUTLINE error\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(2),DOUBLE(8)\n         OI    DOUBLE+1,X'F0'\n         MVC   MSGWA+1(L'MSG_PUTLINE_FAILURE1),MSG_PUTLINE_FAILURE1\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1(2),DOUBLE\n         MVC   MSGWA+1+L'MSG_PUTLINE_FAILURE1+2(L'MSG_PUTLINE_FAILURE2)X\n               ,MSG_PUTLINE_FAILURE2\n         TPUT  MSGWA+1,L'MSG_PUTLINE_FAILURE1+2+L'MSG_PUTLINE_FAILURE2\n         LA    R1,MSGWA\n         LH    R0,MSGHDR\n         SH    R0,=H'4'\n         TPUT  (1),(0),R           Try to display original message\nPUTLRET  L     R14,PUTL14          Restore return register\n         BR    R14                 Return\n*\nPUTL12   DS    0H                  Try putting out pending 2nd level ms\n         XC    ECB,ECB             Clear ecb\n         PUTLINE PARM=PTLIST,MF=(E,IOPL),OUTPUT=(0,TERM,SINGLE,INFOR)\n         B     PUTLINE_RETRY\n*\nMVCPUT   MVC   MSGWA(*-*),0(R1)    Executed\nMVCPUT2  MVC   0(*-*,R1),0(R3)     Executed\n         EJECT\nMFLUSH   STACK MF=L,DELETE=ALL\nLENFLUSH EQU   *-MFLUSH\n*\nMPTLIST  PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\nLENPUTL  EQU   *-MPTLIST\n*\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n* Messages                                                            *\n***********************************************************************\n         SPACE 1\nMSG_NO_OPERANDS    DC C'XPROC001 No operands specified.'\nMSG_REXX_REQUIRED  DC C'XPROC002 Not in REXX: input variable required.'\nMSG_NO_POS_COUNT   DC C'XPROC003 Missing positional parameter count.'\nMSG_BAD_POS_COUNT  DC C'XPROC004 Invalid positional parameter count: '\nMSG_QUOTE_ERROR    DC C'XPROC005 Missing end quote.'\nMSG_NO_WANT_LP     DC C'XPROC006 \"(\" found where not expected.'\nMSG_NO_WANT_RP     DC C'XPROC007 \")\" found where not expected.'\nMSG_NO_WANT_QS     DC C'XPROC008 Quoted string in invalid position.'\nMSG_TOO_FEW_PPARMS DC C'XPROC009 Fewer positional parms than expected.'\nMSG_PP_WITH_LP     DC C'XPROC010 Value not allowed on positional: '\nMSG_PARM_TOO_LONG  DC C'XPROC011 Parameter name too long (> 255): '\nMSG_PARM_INVALID   DC C'XPROC012 Invalid syntax in parameter name: '\nMSG_PARM_DUPLICATE DC C'XPROC013 Duplicate parameter name: '\nMSG_EXTRANEOUS     DC C'XPROC014 Extraneous data ignored in value: '\nMSG_VAR_TOO_LONG   DC C'XPROC015 Variable name too long (> 256): '\nMSG_GETTING_VAR    DC C'XPROC016 Error accessing value of variable: '\nMSG_PUTTING_VAR    DC C'XPROC017 Error storing value of variable: '\nMSG_IKJCT441_RC    DC C'XPROC018 IKJCT441 return code is: '\nMSG_PARSE_FAILURE  DC C'XPROC019 PARSE service routine failure, code: '\nMSG_GETMAIN_FAIL   DC C'XPROC020 Not enough main storage to execute.'\nMSG_IRXEXCOM_FAIL  DC C'XPROC021 IRXEXCOM failure, error code: '\nMSG_STACK_ERROR    DC C'XPROC022 STACK service routine failure, code: '\nMSG_NO_WANT_SL     DC C'XPROC023 \"/\" found where not expected.'\nMSG_OPT_TOO_LONG   DC C'XPROC024 Option name too long: '\nMSG_OPT_INVALID    DC C'XPROC025 Invalid option name: '\nMSG_ASIS_NEEDS_VAL DC C'XPROC026 ASIS invalid with valueless keyword: '\nMSG_OPT_POS_ONLY   DC C'XPROC027 Option valid only for positional: '\n*\nMSG_KV_ERROR       DC C'XPROC999 Internal error in keyword value scan.'\n*\nMSG_PUTLINE_FAILURE1 DC C'*** XPROC: PUTLINE error code '\nMSG_PUTLINE_FAILURE2 DC C' trying to issue the following message:'\n*\nISMSG    DC    C'*** XPROC ignoring slash after this parameter: ' dummy\n         SPACE 1\n         EJECT\n***********************************************************************\n* Constants                                                           *\n***********************************************************************\n         SPACE 1\nKEYDINCR DC    A(100*KEYDDATL)     Initial & increment key area length\n         SPACE 1\nNUMTBL   DC    256YL1(1)           Table to validate numerics\n         ORG   NUMTBL+C'0'\n         DC    10YL1(0)\n         ORG   ,\n         EJECT\nMSG_IKJCT441_RC08 DC C'XPROC508 Variable is a CLIST built-in function.'\nMSG_IKJCT441_RC12 DC C'XPROC512 Variable is a CLIST label.'\nMSG_IKJCT441_RC16 DC C'XPROC516 CLIST variable cannot be updated.'\nMSG_IKJCT441_RC24 DC C'XPROC524 Variable is a CLIST subprocedure.'\nMSG_IKJCT441_RC32 DC C'XPROC532 GETMAIN or FREEMAIN storage failure.'\nMSG_IKJCT441_RC36 DC C'XPROC536 Variable name or value too long.'\nMSG_IKJCT441_RC40 DC C'XPROC540 No valid CLIST or REXX environment.'\nMSG_IKJCT441_RC76 DC C'XPROC576 Undefined &&SYSX CLIST variable.'\nMSG_IKJCT441_RC80 DC C'XPROC580 Variable name invalid for REXX.'\nMSG_IKJCT441_RC81 DC C'XPROC581 Internal REXX routine failure.'\n         EJECT\n***********************************************************************\n* Work area                                                           *\n***********************************************************************\n         SPACE 1\nDATD     DSECT ,                   Dynamically acquired work area\n         SPACE 1\nSAVEAREA DS    18F                 OS save area\nSAVE2    DS    18F                 Save area for PARSE exit routines\nDOUBLE   DS    D                   Conversion work area\nDATDLEN  DS    F                   Length of this work area\nPUTL14   DS    F                   Return register save\nE44114   DS    F                   Return register save\nDOOPT14  DS    F                   Return register save\nSAVER2   DS    A                   Save for TRT register\nMYBASES  DS    2A                  Base regs for IKJPARS exit routines\nSCANRES  DS    2A                  Used to save output from SCAN\nWORDPTR  DS    A                   Address of next slot for word copy\nPWADDR   DS    A                   Address of IKJPARS PCL area\nPWLEN    DS    F                   Length of IKJPARS PCL area\nPCLLEN   DS    F                   Actual length of the IKJPARS PCL\nQOFF     DS    A                   Address of quoted-value-string area\nQVALLEN  DS    F                   Length of quoted-value-string area\nVUPADDR  DS    F                   Address of IKJCT441 update parm list\nVUPLEN   DS    F                   Length of IKJCT441 update parm list\nPDLLEN   DS    F                   Length of the IKJPARS PDL\nVBUFADDR DS    A                   Address of fake command buffer\nVBUFLEN  DS    A                   Length of fake command buffer\nARGADDR  DS    A                   Address of ARG buffer\nARGLEN   DS    F                   Length of ARG buffer\nSCANPTR  DS    A                   Scanning pointer\nSCANEPTR DS    A                   Scanning end pointer\nPARCOUNT DS    F                   Parenthesis count\nPVARADDR DS    A                   Address of input variable name\nPVARLEN  DS    F                   Length of input variable name\nPOSCOUNT DS    F                   Positional parameter count\nKEYCOUNT DS    F                   Keyword count\nLASTAREA DS    A                   Address of last pos or key area\nLASTADDR DS    A                   Address of last processed thing\nLASTLEN  DS    F                   Length of last processed thing\nAPOSD    DS    A                   Address of positional parm area\nLPOSD    DS    A                   Length of positional parm area\nAKEYD    DS    A                   Address of keyword/value area\nLKEYD    DS    A                   Length of keyword/value area\nAKEYE    DS    A                   Address of end of keyword/value area\nFIRSTKEY DS    A                   Address of first IKJKEYWD PCE\nSUBTOSET DS    A                   Address of previous IKJSUBF PCE\nFLAGS    DS    X                   Flags\nFLAGPUTE EQU   B'10000000'         1 = error putting variable values\nFLAGPOSD EQU   B'01000000'         1 = currently processing positionals\nFLAGKEYD EQU   B'00100000'         1 = currently processing keywords\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n*\nECB      DS    F                   ECB for TSO routines\n*\nOLD      DS    0F                  PUTLINE output line descriptor\nOLDF1    DS    F'1'                Number of message segments\nOLDMSG   DS    A(*-*)              Address of the first message segment\n*\nMSGHDR   DS    F                   PUTLINE message header\nMSGWA    DS    CL512               PUTLINE message work area\nARGWA    DS    CL512               ARG message work area\n*\nFLUSH    STACK MF=L,DELETE=ALL\n*\nPTLIST   PUTLINE MF=L,OUTPUT=(0,TERM,SINGLE,INFOR)\n*\nCPPL     DS    0A\n***********************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF         *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1           *\n***********************************************************************\n*\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n*\nIOPL     DS    0A\n***********************************************************************\n*    THE I/O SERVICE ROUTINE PARAMETER LIST (IOPL) IS A LIST OF       *\n*    FULLWORD ADDRESSES PASSED BY THE INVOKER OF ANY I/O SERVICE      *\n*    ROUTINE TO THE APPROPRIATE SERVICE ROUTINE VIA REGISTER ONE.     *\n***********************************************************************\n*\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\n*\nPPL      DS    0A\n***********************************************************************\n*    THE PARSE PARAMETER LIST (PPL) IS A LIST OF ADDRESSES PASSED     *\n*    FROM THE INVOKER TO PARSE VIA REGISTER 1                         *\n***********************************************************************\n         SPACE\nPPLUPT   DS    A        PTR TO UPT\nPPLECT   DS    A        PTR TO ECT\nPPLECB   DS    A        PTR TO CP'S ECB\nPPLPCL   DS    A        PTR TO PCL\nPPLANS   DS    A        PTR TO ANS PLACE\nPPLCBUF  DS    A        PTR TO CMD BUFFER\nPPLUWA   DS    A        PTR TO USER WORK AREA (FOR VALIDITY CK RTNS)\nPPLVEWA  DS    A        PTR TO USER WORK AREA FOR VERIFY EXITS\n*\nANSWER   DS    F                   ANSWER AREA FOR PARSE\n         SPACE 1\nCVPARMS  DS    0F                  Variable access facility parm list\nCVPARM1  DS    A                   Parameter 1: entry code\nCVPARM2  DS    A                   Parameter 2: address of var name\nCVPARM3  DS    A                   Parameter 3: length of var name\nCVPARM4  DS    A                   Parameter 4: address of var value\nCVPARM5  DS    A                   Parameter 5: length of var value\nCVPARM6  DS    A                   Parameter 6: token (not used)\n*\nCVENTRY  DS    A                   Entry code\nCVNAMEA  DS    A                   Address of variable name\nCVNAMEL  DS    A                   Length of variable name\nCVVALUEA DS    A                   Address of variable value\nCVVALUEL DS    A                   Length of variable value\nCVTOKEN  DS    A                   Token (not used)\nCVECT    DS    A                   ECT (not used)\n*\nRC441    DS    F                   Return code from IKJCT441\n         SPACE 1\n         SPACE 1\nIRPARMS  DS    0F                  IRXEXCOM parameter list\nIRPARM1  DS    A                   Parameter 1: CL8'IRXEXCOM'\nIRPARM2  DS    A                   Parameter 2: same as parameter 3\nIRPARM3  DS    A                   Parameter 3: same as parameter 2\nIRPARM4  DS    A                   Parameter 4: SHVBLOCK\n*\n***********************************************************************\n*                                                                     *\n* Copied from 'SYS1.MACLIB(IRXSHVB)'.                                 *\n*                                                                     *\n***********************************************************************\n*\nSHVBLOCK DS    0D                     SHARED VARIABLE REQUEST BLOCK\nSHVNEXT  DS  A                        Chain pointer to next SHVBLOCK\nSHVUSER  DS  F                        Used during \"FETCH NEXT\"\n*                                      Contains length of buffer\n*                                      pointed to by SHVNAMA\nSHVCODES DS  0F\nSHVCODE  DS  CL1                      Function code - indicates type\n*                                      of variable access request\nSHVRET   DS  XL1                      Return codes\n         DS  H'0'                     Reserved (should be 0)\nSHVBUFL  DS  F                        Length of fetch value buffer\nSHVNAMA  DS  A                        Address of variable name\nSHVNAML  DS  F                        Length of variable name\nSHVVALA  DS  A                        Address of value buffer\nSHVVALL  DS  F                        Length of value buffer\n*                                      (Set on fetch)\nSHVBLEN  EQU *-SHVBLOCK               Length of SHVBLOCK\n         SPACE 1\n**********************************************************************/\n*   SHARED VARIABLE REQUEST BLOCK - function codes                   */\n**********************************************************************/\n         SPACE 1\nSHVFETCH EQU   C'F'            Copy value of shared variable\nSHVSTORE EQU   C'S'            Set variable from given value\nSHVDROPV EQU   C'D'            Drop variable\nSHVSYFET EQU   C'f'            Symbolic name retrieve\nSHVSYSET EQU   C's'            Symbolic name set\nSHVSYDRO EQU   C'd'            Symbolic name drop\nSHVNEXTV EQU   C'N'            Fetch \"next\" variable\nSHVPRIV  EQU   C'P'            Fetch private information\n         SPACE 1\n**********************************************************************/\n*        SHARED VARIABLE REQUEST BLOCK - return codes (SHVRET)       */\n**********************************************************************/\n        SPACE 1\nSHVCLEAN EQU   X'00'           Execution was OK\nSHVNEWV  EQU   X'01'           Variable did not exist\nSHVLVAR  EQU   X'02'           Last variable transferred (\"N\")\nSHVTRUNC EQU   X'04'           Truncation occurred for \"Fetch\"\nSHVBADN  EQU   X'08'           Invalid variable name\nSHVBADV  EQU   X'10'           Invalid value specified\nSHVBADF  EQU   X'80'           Invalid function code (SHVCODE)\n         SPACE 1\n**********************************************************************/\n*        R15 return codes                                            */\n**********************************************************************/\n         SPACE 1\nSHVRCOK  EQU    0              Entire Plist chain processed\nSHVRCINV EQU   -1              Invalid entry conditions\nSHVRCIST EQU   -2              Insufficient storage available\n         SPACE\n*\nPVAR     DS    CL256               Area to build input variable name\nOPTION   DS    CL16                Area to build option name\n         SPACE 1\nSIZDATD  EQU   *-DATD              Length of fixed part of work area\n         SPACE 1\nWORDCOPY EQU   *                   Area to put copies of keyword names\n         EJECT\nPOSDDATA DSECT ,                   Info on positional parameter specs\n         SPACE 1\n*                                  (POSCOUNT) occurrences of...\n*\nPOSDADDR DS    A                   Address of positional parameter name\nPOSDLEN  DS    A                   Length of positional parameter name\nPOSDPCEA DS    A                   Address of PCE for this parameter\nPOSDPCEL DS    A                   Length of PCE for this parameter\nPOSDMAXL DS    A                   Maximum length for prompting message\nPOSDFLGS DS    X                   Flags\nPOSDOPT  EQU   B'10000000'          1 = parameter is optional\nPOSDCHAR EQU   B'01000000'          1 = value is possibly-quoted string\nPOSDASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nPOSDDATL EQU   *-POSDDATA          Length of an occurrence\n         EJECT\nKEYDDATA DSECT ,                   Info on keyword/value specs\n         SPACE 1\n*                                  some # of occurrences of...\n*\nKEYWORDA DS    A                   Address of keyword\nKEYWORDL DS    A                   Length of keyword\nKEYDVALA DS    A                   Address of keyword's default value\nKEYDVALL DS    A                   Length of keyword's default value\nKEYDPCEA DS    A                   Address of PCE for this parameter\nKEYDPCEL DS    A                   Length of PCE for this parameter\nKEYDMAXL DS    A                   Maximum length for prompting message\nKEYSUBOF DS    A                   Where to store subfield offset\nKEYFLAGS DS    X                   Flags\nKEYFDVAL EQU   B'10000000'          1 = a default value was specified\nKEYFQUOT EQU   B'01000000'          1 = default value is quoted string\nKEYFASIS EQU   B'00100000'          1 = value is to be processed asis\n*        EQU   B'00010000'          Reserved\n*        EQU   B'00001000'          Reserved\n*        EQU   B'00000100'          Reserved\n*        EQU   B'00000010'          Reserved\n*        EQU   B'00000001'          Reserved\n         DS    0D                  Round to doubleword length\n         SPACE 1\nKEYDDATL EQU   *-KEYDDATA          Length of an occurrence\n         EJECT\n***********************************************************************\n* Macro expansions                                                    *\n***********************************************************************\n         SPACE 1\n         IKJTSVT\n         SPACE 1\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XPROC#": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15O\\x00\\x92\\x15O\\x12\\x00\\x00\\xfe\\x00\\xfe\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-02T00:00:00", "modifydate": "1992-06-02T12:00:00", "lines": 254, "newlines": 254, "modlines": 0, "user": "HELP"}, "text": "***********************************************************************\n*                                                                     *\n* Copyright (c) 1989, 1992 The Charles Stark Draper Laboratory, Inc.  *\n*                                                                     *\n*   This program is provided on an \"as is\" basis.  It may be freely   *\n*   distributed as long as it is not offered for commercial sale,     *\n*   and as long as this copyright notice is included.                 *\n*                                                                     *\n***********************************************************************\n*\n* XPROC 04/13/92 - SEB1525 - Version 2 - /quotable option added\n*\n)F FUNCTION -\n\n The XPROC command parses an argument string into positional and/or\n keyword parameters, similarly to the PROC statement of a CLIST.\n However, XPROC can be used inside a REXX exec to parse the argument\n to the exec, or inside a CLIST or REXX exec to process the value of\n a variable as if it were an argument string.\n\n The values of the parameters specified on the XPROC command cause the\n corresponding REXX or CLIST variables to be set, as they would in a\n CLIST PROC statement.\n\n The rules for entering parameters to be processed by the XPROC command\n are identical to those of the CLIST PROC statement - except that XPROC\n supports extensions to the CLIST PROC syntax by means of options\n preceded by the slash (\"/\") character.\n\n For more information on PROC syntax, consult a TSO/E CLIST manual.\n\n Notes: As for any TSO command, it is best to enclose the entire\n       XPROC command in \"double quotes\" when using it from REXX.\n       This includes the variable names.\n\n       When XPROC is used, prompting is not available by default\n       (unlike the PROC statement of a CLIST).  Therefore, it is\n       advisable to precede the call to XPROC with a statement that\n       activates prompting, e.g.\n\n       CALL PROMPT \"ON\"  /* for REXX  */\n       CONTROL PROMPT    /* for CLIST */\n\n       Also, if there is an error in the XPROC command, or the parsing\n       of the argument string fails, a REXX exec (or a CLIST with\n       CONTROL NOFLUSH active) will NOT be flushed, but will continue\n       to execute (with none of the parameters set).  Therefore, you\n       should check the value of RC (for REXX) or &LASTCC (for CLIST)\n       afterwards and EXIT if it is not zero.\n\n)X SYNTAX -\n\n XPROC  {input-variable}\n        positional-number\n        {positional-parameter{/option...} ...}\n        {keyword-parameter{/option...}{({default-value})}{/option...}}\n\n        The number of positional-parameters must be equal to the\n        value of positional-number (which must be a number).\n\n Required: positional-number\n\n Note that the syntax of XPROC is exactly identical to that of\n the PROC statement of CLIST language, except for the optional\n \"input-variable\" and the \"/option\" feature.\n\n Examples:\n\n  The following examples assume a REXX environment:\n\n  Example 1: Define one positional parameter (DATASET),\n             no keyword parameters:\n\n       \"XPROC 1 DATASET\"\n\n  Example 2: Define no positional parameters, and one keyword\n             parameter (TESTING) which has a null default value:\n\n       \"XPROC 0 TESTING\"\n\n  Example 3: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\":\n\n       \"XPROC 1 LIBRARY TRACE SYSOUT(A)\"\n\n  Example 4: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER) and a keyword (OWNER) with a default value of\n             the user's TSO prefix.  Note how we allow REXX to\n             generate the desired default value so it appears in\n             the XPROC command at execution time:\n\n       \"XPROC 3 LIBRARY TYPE MEMBER OWNER('\"SYSVAR(SYSPREF)\"')\"\n\n  Example 5: Define a positional parameter (NAME) and one keyword\n             parameter (TITLE) which has a null default value, and\n             one (SUBJECT) which has the default value \"None\".\n             The values of all three parameters will be processed\n             as is with respect to case.\n\n       XPROC 1 NAME/ASIS TITLE/ASIS() SUBJECT(None)/ASIS\n\n  The following examples work under REXX or CLIST (but be sure to\n  enclose the command in \"double quotes\" under REXX):\n\n  Example 6: Define a positional parameter (LIBRARY), one keyword\n             parameter (TRACE) which has a null default value, and\n             one (SYSOUT) which has the default value \"A\".  The\n             argument string to be parsed will be taken from the\n             value of the variable \"SYSDVAL\".\n\n       XPROC SYSDVAL 1 LIBRARY TRACE SYSOUT(A)\n\n  Example 7: Define three positional parameters (LIBRARY, TYPE and\n             MEMBER), and a keyword (MARK) with a default value of\n             the current time.  Note how we allow REXX to generate\n             the desired default value so it appears in the XPROC\n             command at execution time.  The argument string to be\n             parsed will be taken from the value of the variable\n             \"STRING\".\n\n       \"XPROC STRING 3 LIBRARY TYPE MEMBER MARK('\"TIME()\"')\"\n\n             Under CLIST, this could be coded as:\n\n       XPROC STRING 3 LIBRARY TYPE MEMBER MARK('&SYSTIME')\n\n             but note that &SYSTIME gets resolved BEFORE the XPROC\n             command executes.  This is the only type of situation\n             where an \"&\" is appropriate.\n\n)O OPERANDS -\n\n))input-variable\n\n   the NAME of a variable from which the argument string to be parsed\n   is to be extracted.  The name must conform to the rules for CLIST or\n   REXX variable names.  The specified variable must be set to the\n   argument string to be processed (no command name included) before\n   XPROC is invoked.\n\n   The input-variable name may be omitted in a REXX exec ONLY, in which\n   case the arguments to the REXX exec are accessed.  This provides the\n   same capability that the PROC statement of a CLIST would.\n\n))positional-number\n\n   a number (0 or greater) which specifies the number of positional\n   parameters that follow.  This is required.  If there are no\n   positional parameters, specify a 0.\n\n))positional-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   Underscores may be part of the name.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands in parameter names.  Ampersands in an XPROC command will\n   cause normal symbolic substitution in CLISTS; they will cause errors\n   under REXX.\n\n))keyword-parameter\n\n   A variable name consisting of alphameric and national characters,\n   of which the first cannot be numeric.  The length of this name must\n   be between 1 and 252 for CLISTs, and between 1 and 250 for REXX.\n   A default value in parentheses may optionally follow the parameter;\n   if there is no default value, the keyword takes on its own name as\n   a value if given by the caller, and a null string otherwise.\n\n   Note: Unlike the CLIST PROC statement, XPROC does not accept\n   ampersands (\"&\") in parameter names.  Ampersands in an XPROC command\n   will cause normal symbolic substitution in CLISTS; they will cause\n   errors under REXX.\n\n))default-value\n\n   Any character string, including the null string.  If it is present,\n   it must follow a valid keyword parameter and be enclosed in\n   parentheses (the right parenthesis may be omitted if this is at the\n   end of the command).  The value may be quoted (with single quotes,\n   with two quotes representing one) or unquoted; however, if it\n   contains any special characters (blanks, unbalanced parentheses,\n   etc.), it must be quoted.\n\n   If the caller provides an alternate value for the associated\n   keyword, the keyword takes on the that value; otherwise it takes on\n   the default value specified by XPROC.  Note that although () may be\n   specified in XPROC for a null string, a caller must type ('') to get\n   the same result.\n\n))option\n\n   Processing options may be associated with positional or keyword\n   parameters by specifying their names following the parameter name\n   delimited by a slash.  For example, assuming positional parameter\n   name PP and keyword parameter name KP, and option name OP1 and OP2,\n   the following are possible:\n\n   PP/OP1\n   KP/OP1\n   KP/OP1(default)\n   KP(default)/OP1\n   PP/OP1/OP2\n   KP/OP1(default)/OP2\n\n   The supported options at this time are ASIS and QUOTABLE.\n\n))ASIS\n\n   If the ASIS option is associated with a positional or keyword\n   parameter that takes a value, the value specified by the user\n   for that parameter is processed in case-retention mode.  In\n   other words, any lower-case characters present in the value\n   are kept as is.  This overrides the default behavior, which\n   converts all parameter values to uppercase (the only behavior\n   available via the PROC statement of CLIST).\n\n   The ASIS option is not valid for keyword parameters that do\n   not take a value (i.e. evaluate to themselves or null).\n\n   Note that default values in the XPROC prototype are always\n   processed asis, regardless of the presence of this option.\n\n   Examples: XPROC 1 NAME/ASIS\n             XPROC 0 TITLE/ASIS(default)\n             XPROC 0 TITLE(default)/ASIS\n\n))QUOTABLE\n\n   If the QUOTABLE option is associated with a positional parameter,\n   the value specified by the user for that parameter may be entered\n   as a quoted string.  In other words, embedded blanks or other\n   special characters may be entered if the string is enclosed in\n   single quotes by the user.  The quotes do not become part of the\n   resulting value; to pass in quotes, the user must provide doubled\n   quotes, similar to the way quotes are specified for keyword values.\n   This overrides the default behavior, which takes a\n   blank-or-comma-delimited string as the value of the positional\n   parameter, without honoring quotes specially.\n\n   Thus, you may define a CLIST or REXX exec that takes a syntax like:\n\n     MYCLIST 'hi there' 'how are you'\n\n   and have the strings entered as positional parameters.\n\n   The QUOTABLE option is valid only for positional parameters,\n   not keyword parameters.\n\n   Examples: XPROC 1 NAME/QUOTABLE\n             XPROC 3 NAME/ASIS/QUOTABLE ADDRESS/QUOTABLE CITY/ASIS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XWRITEN#": {"ttr": 10507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x07_\\x00\\x93\\x07_\\x12\\x00\\x003\\x003\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-16T00:00:00", "modifydate": "1993-03-16T12:00:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "HELP"}, "text": ")F  XWRITENR is a REXX external routine that functions like the WRITENR\n statement of CLIST language.  In other words, it writes the evaluated\n <expression> to the TSO terminal, without a carriage return.  This is\n available in TSO/E environments only.\n\n XWRITENR must be invoked via the REXX CALL instruction, in which case\n it places a return code (normally 0) in the RESULT variable.  If\n XWRITENR is invoked as a REXX function, it returns the return code\n as the value.  Exactly one argument must be specified; otherwise\n a return code of -2 is returned.\n\n In general, a call to XWRITENR should be followed by a statement\n that requests terminal input (PULL, PARSE PULL, or PARSE EXTERNAL).\n\n)X Syntax:\n            CALL XWRITENR <expression>\n\n Note:  Some hex control characters may be used in <expression> to\n        produce certain effects:\n\n  '24'x at the end of <expression> causes the keyboard to unlock\n  following the message; anything typed in the field where the\n  cursor is positioned is NOT DISPLAYED.  A PULL or PARSE EXTERNAL\n  instruction will pick up the entered data.  This is useful for\n  password prompts.\n\n  '15'x at the end of <expression> acts as a \"new line\" character,\n  so that the cursor is moved to the beginning of the next line.\n  In other words, this makes XWRITENR behave like SAY.  Normally\n  this is not useful, but it may be useful in conjunction with\n  3270 data stream orders.\n\n  Some 3270 data stream commands ('11'x for SBA, '1D'x for SF) may\n  be embedded in <expression>.  USE THESE WITH CAUTION!  If the\n  expression you want to display might contain invalid characters,\n  use TRANSLATE() to remove them before attempting to display with\n  XWRITENR, or use SAY instead.\n\n)O\n Example:\n\n  call xwritenr \"Enter name:\"\n  parse pull name\n  /* Would display: Enter name: _\n     where _ represents the cursor */\n\n  call xwritenr \"Enter password:\" || '24'X\n  parse pull password\n  /* Would display: Enter password: _\n     where _ represents the cursor.\n     The password would be entered in a print-inhibited input field. */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XWRITENR": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x07_\\x00\\x93\\x07_\\x12\\x00\\x00\\xbb\\x00\\xbb\\x00\\x00\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-16T00:00:00", "modifydate": "1993-03-16T12:00:00", "lines": 187, "newlines": 187, "modlines": 0, "user": "ASM"}, "text": "         TITLE 'XWRITENR - REXX external function to simulate WRITENR'\nXWRITENR CSECT\nXWRITENR AMODE ANY\nXWRITENR RMODE ANY\n         SPACE\n***********************************************************************\n*\n* Syntax:  call XWRITENR \"anything at all\"\n*\n***********************************************************************\n*                                                                *\n* Input:       (R1) = address of IRXEFPL parameter list:         *\n*                                                                *\n*              Offset:                                           *\n*               00 = Reserved                                    *\n*               04 = Reserved                                    *\n*               08 = Reserved                                    *\n*               0C = Reserved                                    *\n*               10 = Address of the parsed argument list         *\n*               14 = Address of the address of the EVALBLOCK     *\n*                                                                *\n******************************************************************\n*                                                                *\n* Output:      R15 = return code from PUTLINE                    *\n*                                                                *\n******************************************************************\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SAVE  (14,12),,XWRITENR_&SYSDATE._&SYSTIME\n         BALR  R12,0\n         USING *,R12\n         SPACE\n         L     R2,16(,R1)          R2 = address of parsed argument list\n         L     R6,20(,R1)          R6 = address of address of EVALBLOCK\n         L     R6,0(,R6)           R6 = address of EVALBLOCK\n         L     R4,4(,R2)           R4 = length of message\n         L     R5,0(,R2)           R5 = address of text of message\n         C     R5,=X'FFFFFFFF'     If number of arguments not 1\n         BE    ERROR               then error\n         L     R0,8(,R2)\n         C     R0,=X'FFFFFFFF'     If number of arguments not 1\n         BNE   ERROR               then error\n         LTR   R15,R4              If message length is zero\n         BZ    RETURN              then return code(zero)\n         LA    R0,DYSIZE           Get size of dynamic area w/o message\n         AR    R0,R4               Add length of message\n         GETMAIN R,LV=(0)          Get dynamic storage area\n         SPACE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING DYNAM,R13\n         SPACE\nLENOK    DS    0H\n         CH    R4,=H'256'          If message is 256 chars or less\n         BH    MOVELONG            then...\n         LR    R14,R4\n         BCTR  R14,0                decrement length for move\n         EX    R14,MOVEMSG          Move message to buffer\n         B     MSGMOVED            else...\nMOVELONG DS    0H\n         LA    R0,PUTBUF+4         Address of message destination\n         LR    R1,R4               Length of message destination\n         LR    R14,R5              Address of message source\n         LR    R15,R4              Length of message source\n         MVCL  R0,R14              Move message to buffer\nMSGMOVED DS    0H\n         LA    R14,4(,R4)         Add length of header\n         SLL   R14,16             Shift: 1st HWD = hdr, 2nd = no 2ndary\n         ST    R14,PUTBUF         Put in first 2 halfwords in header\n         SPACE\n         LA    R1,IOPLSP           Set up IOPL\n         USING IOPL,R1\n         SPACE\n         USING PSA,0\n         L     R8,PSATOLD           GET TCB ADDRESS\n         USING TCB,R8\n         L     R8,TCBJSCB           GET JSCB ADDRESS\n         USING IEZJSCB,R8\n         L     R8,JSCBACT           GET ADDRESS OF ACTIVE JSCB\n         L     R8,JSCBPSCB          GET ADDRESS OF PSCB\n         USING PSCB,R8\n         MVC   IOPLUPT,PSCBUPT      PUT UPT ADDRESS IN IOPL\n         L     R8,PSCBRLGB          GET ADDR OF RELOGON BUFFER\n         USING RLGB,R8\n         MVC   IOPLECT,RLGBECT      PUT ADDRESS OF ECT IN IOPL\n         SPACE\n         SR    R0,R0\n         ST    R0,ECB              Zero out ECB\n         ST    R0,IOPLIOPB         Zero out IOPL parm block address\n         LA    R0,ECB\n         ST    R0,IOPLECB          Finish up IOPL\n         MVC   PUTBLK(LPUTBLK),PUTMAST     Build PUTLINE MF=L\n         DROP  R1\n         EJECT\n         PUTLINE PARM=PUTBLK,OUTPUT=(PUTBUF,TERM,SINGLE,DATA),         +\n               TERMPUT=(ASIS),                                         +\n               MF=(E,(1))\n         EJECT\nENDIT    LR    R3,R15              Save return code\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         CVD   R3,DOUBLE           Return code\n         UNPK  16(2,R6),DOUBLE     Generate 2 digits\n         OI    17(R6),X'F0'\n         CLI   16(R6),C'0'         If first digit is 0\n         BNE   NOTZ                then\n         MVC   16(1,R6),17(R6)      make it a 1-digit number\n         MVI   17(R6),C' '\n         LA    R0,1                 set length to 1\n         ST    R0,8(,R6)            set EVLEN (in EVALBLOCK) to length\nNOTZ     DS    0H\n         LA    R0,DYSIZE           Get length of storage w/o message\n         AR    R0,R4               Add length of message\n         LA    R1,DYNAM            Get address of storage\n         L     R13,4(0,R13)\n         FREEMAIN R,LV=(0),A=(1)\nRETURN   DS    0H\n         RETURN (14,12),T,RC=0\n         SPACE 2\nERROR    DS    0H                  Here if wrong # of arguments\n         LA    R0,2\n         ST    R0,8(,R6)           Set EVLEN (in EVALBLOCK) to length\n         MVC   16(2,R6),=C'-2'     Return value\n         B     RETURN\n         SPACE 2\nMOVEMSG  MVC   PUTBUF+4(0),0(R5)\n         EJECT\nPUTMAST  PUTLINE MF=L\n         EJECT\nDYNAM    DSECT\n         SPACE\nSAVEAREA DS    9D\nDOUBLE   DS    D          Work area for conversions\n         SPACE\nPUTBLK   PUTLINE MF=L\nLPUTBLK  EQU   *-PUTBLK\n         SPACE\nIOPLSP   DS    4F        INPUT OUTPUT PARAMETER BLOCK\nECB      DS    F\n         SPACE\nPUTBUF   DS    F          MESSAGE HEADER\n         SPACE\n*                                  (Actual message buffer variable)\n         SPACE\nDYSIZE   EQU   *-DYNAM             Length of dynamic area w/o msg buf\n         EJECT\n*\n*  STORAGE DEFINITIONS:\n*\n         SPACE\n         IKJIOPL\n         SPACE\n         IKJCPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJECT\n         SPACE\n         IKJPSCB\n         EJECT ,\n         IHAPSA\n         EJECT ,\n         IKJTCB\n         EJECT ,\n         IEZJSCB\n         EJECT ,\n         IKJRLGB\n         EJECT\n         SPACE 5\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT896/FILE896.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT896", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}