{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012544000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE660.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE660.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x0e'", "DS1TRBAL": "b'@\\xf2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xb5\\x00\\x0c\\x04\\xb5\\x00\\x0e\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00R\\x01\\x14\\x03O\\x01\\x14\\x03O\\x14S\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-02-03T00:00:00", "modifydate": "2014-02-03T14:53:52", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-488"}, "text": "REGULAR CBT TAPE - VERSION 488    FILE:  660\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT488.FILE660\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 383 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/03/14    14:53:51    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE660": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00E\\x01\\x14\\x03O\\x01\\x14\\x03O\\x14S\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-02-03T00:00:00", "modifydate": "2014-02-03T14:53:45", "lines": 13, "newlines": 13, "modlines": 0, "user": "CBT-488"}, "text": "//***FILE 660 is from Gerhard Postpischil and contains a REXX exec  *   FILE 660\n//*           which runs other REXX execs through the REXX compiler *   FILE 660\n//*           (in a dry run) and checks them for errors.  This exec *   FILE 660\n//*           is called REXXER, and you run it as an edit macro,    *   FILE 660\n//*           while you're editing a REXX exec that you want to     *   FILE 660\n//*           check.  REXXER will run the compiler, and flag the    *   FILE 660\n//*           errors that are on each line, as message note lines.  *   FILE 660\n//*                                                                 *   FILE 660\n//*           You may have to change the dataset name of your       *   FILE 660\n//*           REXX compiler loadlib.                                *   FILE 660\n//*                                                                 *   FILE 660\n//*           email:  gerhard@postpischil.com                       *   FILE 660\n//*                                                                 *   FILE 660\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXER": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x04\\x02?\\x01\\x04\\x02?\\x10X\\x01f\\x01f\\x00\\x0f\\xd9\\xc5\\xe7\\xe7\\xc5\\xd9@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-01-23T00:00:00", "modifydate": "2004-01-23T10:58:17", "lines": 358, "newlines": 358, "modlines": 15, "user": "REXXER"}, "text": "/****REXX**********************************************************/\n/*                                                                */\n/*   invoked as :  REXXER from an EDIT or VIEW session only       */\n/*                                                                */\n/*  Invokes REXX Compiler, reads error messages, and places them  */\n/*  into the source listing.                                      */\n/*                                                                */\n/******************************************************************/\n/*                                                                */\n/*  Copyright 1997  Expert System Programming                     */\n/*  This program may be used at will except for profit, in        */\n/*  accordance with the GNU COPYLEFT provisions.                  */\n/*                                                                */\n/******************************************************************/\n/*                                                                */\n/*  CUSTOMIZATION: Find REXXLIB and set applicable compiler load  */\n/*                                                                */\n/******************************************************************/\n/*                                                                */\n/*  Maintenance:                                                  */\n/*                                                                */\n/*  1999/10/25 @g1  GYP  Fixed SCLM 013-18 error (unmodified mbr  */\n/*                       request - code in different library)     */\n/*  2003/10/25 @g2  GYP  Added SYSPRINT scan for external functs  */\n/*                       when no error - catch spelling errors.   */\n/*                       Fix empty file or pending command.       */\n/*                                                                */\n/******************************************************************/\n\"ISREDIT MACRO (string) PROCESS\"  /* ISPF - process changes first */\n  if RC=20 then do                /* from TSO?                    */\n              say \"REXXER must be invoked under ISPF EDIT or VIEW\"\n              exit 20\n              end\n        else do\n              UPPER string\n              if string=\"\" then string = \"*\" /* print current     */\n              end\n\n  msg_op = \"No problems\"          /* Preset for normal run        */\n  msg_rc = 0\n  msg_a1 = \"\"\n  msg_a2 = \"\"\n\n  dbug = 0                        /* Off debug and list switches  */\n  dlst = 0                        /* Off debug and list switches  */\n  dsnm = \"\"                       /* Provisionally use current ds */\n\nscanned = 0\ndo while scanned=0                /* Look for option overrides    */\n  PARSE VAR string w1 string\n  select;\n    when w1=\"\" then scanned = 1\n\n    when w1=\"DEBUG\" then dbug = 1\n    when w1=\"LIST\" then dlst = 1\n\n    when w1=\"TRACE\" then TRACE R\n\n    otherwise nop                 /* defer - may be misspelled ?  */\n    end\n end\n\nREXXLIB = \"FAN130.SFANLMD\"      /* My OS/390 2.10  REXX Load Library */\n/* REXXLIB = \"REXX.SFANLMD\" */  /* Preferred alias REXX Load Library */\n\nlc = SYSDSN(\"'\"REXXLIB\"'\")        /* Correct name in this system? */\nif lc\\=\"OK\" then do\n  msg_rc = 12\n  zedsmsg = \"No REXX loadlib\"\n  zedlmsg = \"Compiler library\" rexxlib \"unavailable : \"lc\n  \"ISPEXEC SETMSG MSG(ISRZ001)\"\n  signal Comm_Out\n  end  /* if lc */\n\n/*******************************************************************/\n/*                                                                 */\n/*  1) If the data in the current EDIT session were changed, then  */\n/*     we need to read the lines and build a SUBMIT SYSIN          */\n/*                                                                 */\n/*  2) If the underlying data set does not exist (happens when not */\n/*     saved yet, or in an SCLM or similar environment when not    */\n/*     changed), then we need to read the lines and build a SYSIN  */\n/*                                                                 */\n/*  The above fails when the data lines are longer than 255 bytes! */\n/*                                                                 */\n/*  Otherwise, build a SYSIN to point to the unchanged data set.   */\n/*                                                                 */\n/*******************************************************************/\n\"ISREDIT (CHF) = DATA_CHANGED\"\nif CHF=\"NO\" then do\n    \"ISREDIT (ds) = DATASET\"\n    if rc\\=0 then ds = \"\"\n    \"ISREDIT (mb) = MEMBER\"\n    if rc\\=0 then ds = \"\"\n    if ds\\=\"\" then dsnm = ds\n    if mb\\=\"\" & ds\\=\"\" then dsnm = dsnm\"(\"mb\")\"\n    if SYSDSN(\"'\"dsnm\"'\")\\=\"OK\" then dsnm = \"\"                   /*g1*/\n    end  /* if CHF */             /* data set unchanged & usable  */\n                                  /* when dsnm not null           */\ndrop CD.\nCD.0 = 0                          /* Avoid bad arith. conversion  */\nCD. = \"\"                          /* Stem holding SYSIN data      */\ncd_k = 0\n\nif dsnm=\"\" then do                /* Changed data - do it in-line */\n  \"ISREDIT (linef) = LINENUM .ZFIRST\"\n  \"ISREDIT (linel) = LINENUM .ZLAST\"\n  if datatype(linef,\"W\")\\=1 | datatype(linel,\"W\")\\=1 then do     /*@g2*/\n    msg_rc = 12                                                  /*@g2*/\n    zedsmsg = \"Untimely\"                                         /*@g2*/\n    zedlmsg = \"File is empty, pending A/B/C/M command\"           /*@g2*/\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"                                /*@g2*/\n    signal Comm_Out                                              /*@g2*/\n    end  /* datatype */                                          /*@g2*/\n                                                                 /*@g2*/\n  do i=linef to linel\n    \"ISREDIT (string) = LINE \"i\n    cd_k = cd_k+1\n    cd.cd_k = string\n    end  /* i */\n  end  /* dsnm */\n\nx = MSG(\"OFF\")                    /* Don't want any messages      */\naddress TSO\n\"FREE FI(SYSIN)\"                  /* Get rid of prior allocations */\n\"FREE FI(SYSTERM)\"\n\"FREE FI(SYSPRINT)\"\n\"FREE FI(SYSCEXEC)\"\n\"FREE FI(SYSPUNCH)\"\nx = MSG(\"ON\")\n\nif dsnm\\=\"\" then do               /* Use existing data set        */\n    \"ALLOCATE FI(SYSIN) DA('\"dsnm\"') SHR REUSE\"\n    arc = rc\n    end  /* then */\n  else do                         /* Otherwise allocate and write */\n    \"ALLOCATE FI(SYSIN) NEW DELETE TRACKS SPACE(1 1) REUSE\"||,\n      \" RECFM(V B)  LRECL(259)\"\n    arc = rc\n    if arc=0 then do\n      \"EXECIO * DISKW SYSIN (stem CD. FINIS\"\n      if rc\\=0 then do\n        msg_op = \"EXECIO DISKW\"   /* Tell user about ALLOC error  */\n        msg_rc = rc\n        msg_a1 = \"SYSIN\"\n        msg_a2 = \"\"\n        signal bad_exit\n        end  /* if rc */\n        drop CD.\n      end  /* if arc */\n    end  /* else dsnm=\"\" */\nif arc\\=0 then do\n  msg_op = \"ALLOC SYSIN\"   /* Tell user about ALLOC error  */\n  msg_rc = arc\n  msg_a1 = \"SYSIN\"\n  msg_a2 = \"\"\n  signal bad_exit\n  end  /* If rc */\n\n\"ALLOCATE FI(SYSTERM) NEW DELETE TRACKS SPACE(1 1) REUSE\"\n\"ALLOCATE FI(SYSPRINT) NEW DELETE TRACKS SPACE(15 15) REUSE\"     /*g2*/\n/* \"ALLOCATE FI(SYSPRINT) DUMMY REUSE\" ********OLD*********/     /*g2*/\n\"ALLOCATE FI(SYSPUNCH) DUMMY REUSE\"\n\"ALLOCATE FI(SYSCEXEC) DUMMY REUSE\"\n\nx = outtrap(\"REXXcall.\")\nREXX_parm = \"XREF TERM TRACE SLINE\"        /* Pass this parm to REXX */\n\"TSOEXEC CALL '\"REXXLIB\"(REXXCOMP)' '\"REXX_parm\"'\"\narc = rc\nx = outtrap(\"OFF\")\n    if arc<0 | arc>12 then do\n      msg_op = \"REXX COMPILE\"\n      msg_rc = arc\n      msg_a1 = \"Error\"\n      msg_a2 = \"\"\n      signal bad_exit\n      end\n\n\"EXECIO * DISKR SYSTERM  (stem Term. FINIS\"\n    if rc\\=0 then do\n      msg_op = \"EXECIO DISKR\"\n      msg_rc = rc\n      msg_a1 = \"SYSTERM\"\n      msg_a2 = \"\"\n      signal bad_exit\n      end\n\n\"ISREDIT RESET\"                   /* Remove old messages          */\n\ncurl = 0                          /* Line to position cursor on   */\nmsgl = 0                          /* Line to place error msg aftr */\nerrc = 0                          /* Error count                  */\nque# = 0                          /* Number of stacked error msgs */\ndrop stack.                       /* Error message                */\nstack. = \"\"                       /*               stack          */\ndrop exvar.                       /* External function            */\nexvar. = \"\"                       /*                   stack       g2*/\nexvars = 0                        /* Count of external functions   g2*/\nexvar1 = 0                        /* Count with single reference   g2*/\n\n/******* Now read the SYSTERM lines, and convert to messages *********/\nl = term.0\nif l>2 then k = 3                 /* Skip statistics              */\n       else k = 1                 /* Don't know                   */\n\ndo j=k to l                       /* Loop through SYSTERM lines   */\n  line = TERM.j                   /* Shortcut for stem lookups    */\n\n  select                          /* Handle msgs and continuation */\n    when left(strip(line),1)=\"|\"   & msgl>0 then do\n      text = substr(line,22)\n      x = Msg_Stack(text)\n      end  /* | */\n\n    when left(strip(line),3)=\"+++\" & msgl>0 then do\n      text = delword(line,1,1)\n      x = Msg_Stack(text)\n      if curl=0 then do\n          curl = msgl\n          curp = pos(\"|\",stack.1) /* Put cursor on bad character  */\n          end /* if curl */\n      end  /* +++ */\n\n    when datatype(word(line,1),\"W\")=1 then do  /* New message ?   */\n      call Msg_Write\n      if msgl\\=word(line,1) then errc = errc+1\n      msgl = word(line,1)\n      end  /* Line number */\n\n    otherwise nop                 /* What ever                    */\n\n  end  /* select */\n end  /* do j */\ncall Msg_Write   /* Final writes */\n\nif curl\\=0 then do                /* Set to display error count   */\n    if errc=1 then plural = \"\"\n              else plural = \"s\"\n    zedsmsg = errc\" error\"plural\" found\"\n    zedlmsg = errc\" error\"plural\" found\"\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n    \"ISREDIT CURSOR = \"curl curp\n    end  /* then */\n  else do                         /* No errs - orphan functions?  */\n    zedsmsg = \"No errors found\"\n    zedlmsg = \"No errors found\"\n    \"ISPEXEC SETMSG MSG(ISRZ000)\"\n\n/*********************************REXX******************************/\n/*                                                                 */\n/*  No errors found - now read SYSPRINT to check for external      */\n/*  references (could be misspelled when single use?)              */\n/*                                                                 */\n/*******************************************************************/\ndrop Term.                                                       /*g2*/\nTerm. = \"\"                                                       /*g2*/\n\"EXECIO * DISKR SYSPRINT (stem Term. FINIS\"                      /*g2*/\n    if rc\\=0 then do                                             /*g2*/\n      msg_op = \"EXECIO DISKR\"                                    /*g2*/\n      msg_rc = rc                                                /*g2*/\n      msg_a1 = \"SYSPRINT\"                                        /*g2*/\n      msg_a2 = \"\"                                                /*g2*/\n      signal bad_exit                                            /*g2*/\n      end  /* if rc */                                           /*g2*/\n                                                                 /*g2*/\n    qv1 = \" EXT \"                                                /*g2*/\n    qv2 = \"RTN \"                                                 /*g2*/\n    \"ISREDIT (linel) = LINENUM .ZLAST\"                           /*g2*/\n    do j=1 to term.0                                             /*g2*/\n      if pos(qv1||qv2,substr(Term.j,31))>0 then do               /*g2*/\n        line = Term.j                                            /*g2*/\n        exvars = exvars + 1                                      /*g2*/\n        ix = right(words(line)-3,7) || \" \"                       /*g2*/\n        exvar.exvars = ix || word(line,1)                        /*g2*/\n        if words(line)=4 then exvar1 = exvar1 + 1                /*g2*/\n        if length(word(line,1))=30 then do                       /*g2*/\n          ix = j + 1                                             /*g2*/\n          line = Term.ix                                         /*g2*/\n          if length(word(line,1))<31 & substr(line,32,8)=\"\" then /*g2*/\n            exvar.exvars = exvar.exvars || word(line,1)          /*g2*/\n          if length(word(line,1))=30 then do                     /*g2*/\n            ix = j + 2                                           /*g2*/\n            line = Term.ix                                       /*g2*/\n            if length(word(line,1))<31 & substr(line,32,8)=\"\" then\n              exvar.exvars = exvar.exvars || word(line,1)        /*g2*/\n            end  /* do length 3rd */                             /*g2*/\n          end  /* do length 2nd */                               /*g2*/\n        end  /* ext var */                                       /*g2*/\n      end  /* do */                                              /*g2*/\n    do ix=exvars to 1 by -1                                      /*g2*/\n      line = exvar.ix                                            /*g2*/\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      end  /* do */                                              /*g2*/\n    if exvars>0 then do                                          /*g2*/\n      line = right(\"Ref.Cnt\",7) || \" Name (max 63 chars)\"        /*g2*/\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      if exvar1>0 then do                                        /*g2*/\n        line = \"Please check spelling.\"                          /*g2*/\n        \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"            /*g2*/\n        end  /* exvar1 */                                        /*g2*/\n    line = center(exvars\" external references found in this program\",72)\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      curp = 1                                                   /*g2*/\n      \"ISREDIT CURSOR = \"linel curp                              /*g2*/\n      end  /* do exvars */                                       /*g2*/\n    end  /* else */                                              /*g2*/\n\nsignal Comm_Out\n\n\nBad_Exit:\n    zedsmsg = \"Processing error\"\n    zedlmsg = \"Processing error in \"msg_op\", code \"msg_rc||,\n       \", for \"msg_a1\". \"msg_a2\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\nsignal Comm_Out\n\nComm_Out:\nx = MSG(\"OFF\")\naddress TSO\nif dsnm\\=\"\" then \"FREE DA('\"dsnm\"')\"\n\"FREE FI(SYSIN)\"\n\"FREE FI(SYSTERM)\"\n\"FREE FI(SYSPRINT)\"\n\"FREE FI(SYSCEXEC)\"\n\"FREE FI(SYSPUNCH)\"\nx = MSG(\"ON\")\n\ntrace off\nexit msg_rc\n\n\n/**********************************************************************/\n/**                                                                  **/\n/**  MSG_STACK :  Save error messages                                **/\n/**                                                                  **/\n/**********************************************************************/\nMsg_Stack:\nque# = que# + 1\nstack.que# = arg(1)\nreturn que#\n\n\n/**********************************************************************/\n/**                                                                  **/\n/**  MSG_WRITE :  Insert error messages in proper sequence           **/\n/**                                                                  **/\n/**********************************************************************/\nMsg_Write:\ndo ix=que# to 1 by -1\n  text = stack.ix\n  \"ISREDIT LINE_AFTER \"msgl\" = MSGLINE (TEXT)\"\n  end\n\nque# = 0\ndrop stack.\nstack. = \"\"\nreturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT660/FILE660.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT660", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}