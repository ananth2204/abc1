An object's heritage

DEMO SOURCE CODE

demo: proc options( main );
dcl
   scricmd entry(ptr,fixed bin(15),char(*),fixed bin(31,0)) external,
                                  /* td(time & date) module interface*/
   1 tdi,
    2 tdsc fixed bin init(1),
    2 tdd   char(8),
    2 tdt   char(8),
   tdiptr ptr init(addr(tdi)),
   td entry(ptr) external,
   genv char(08) ext,
   hdr1 char(79) ext,
   cmdbuf char(79) ext,
   msg char(79) ext,
   docn char(8),
   (sr,er,sc,ex) fixed bin(15,0),
   (xhdr1,hdr2,hdr3) char(79),
   (@scr,@brw,@doc) ptr,
   plcmd char(1),
   pdata char(79),
   rc fixed bin(31,0),
   state char(1),
   USR char(08),
   tdtp fixed bin;
   genv='CICS';                   /* it is cics environment          */
   EXEC CICS ADDRESS EIB(DFHEIPTR);
   EXEC CICS INQUIRE              /* get the userid                  */
             TERMINAL(EIBTRMID) USERID(USR);
   if USR='' then do;call pliretc(8);return;end;
   tdsc = 0;
   call td(tdiptr);               /* get today's date                */
   tdsc = 1;                      /* on next call, get current time  */
   i = index(usr,' ');
   if i = 0 then i = 9;
   tdtp =38+i;
   hdr1 = 'docobj browse demo------'||substr(USR,1,i-1)||'---'||tdd
                                            ||(47)'-';
   xhdr1=hdr1;
   hdr2='list of all employees';
   hdr3='academic department';
                                  /* 'sr' start of row               */
                                  /* 'er' end   of row               */
                                  /* 'sc' start of column            */
                                  /* 'ec' end   of column            */
   sr=0;er=14;sc=0;ec=80;
   docn='DEMO';                   /* logical document name           */
                                  /* initialize document object      */
   call docinit(xhdr1,hdr2,hdr3,sr,er,sc,ec,docn,@scr,@brw,@doc,rc);
                                  /* install 'r' command             */
   call scricmd(@scr,2,'r refresh',rc);
   state='1';
   do while( state ^= '4');
                                  /* get current time                */
    d:call td(tdiptr);substr(xhdr1,tdtp,8)=tdt;
      call scruhdr(@scr,xhdr1,rc);/* update screen header            */
      call docdisp(@doc,rc);      /* display document                */
      if cmdbuf='E' then state='4';
      else do;
                                  /* retrieve line commands          */
         call scrrlcm(@scr,plcmd,rc);
         do while (rc=0);
            if plcmd='S' then do; /* execute 's_' select command     */
                                  /* query selection text            */
               call docqsel(@doc,pdata,rc);
               msg=pdata;go to d;
            end;
            else do;
               msg='invalid, choose one listed';go to d;
            end;
            call scrrlcm(@scr,plcmd,rc);
         end;
         call brwhcmd(@brw,rc);   /* handle browse   object commands */
                                  /* handle document object commands */
         if rc^=0 then call dochcmd(@doc,rc);
         if rc^=0 then do;        /* execute user installed commands */
            if cmdbuf='R' then do;
               call docterm(@doc,rc);
               call docinit(xhdr1,hdr2,hdr3,sr,er,sc,ec,docn,
               @scr,@brw,@doc,rc);
               call scricmd(@scr,2,'r refresh',rc);
               state='1';
            end;
            else if cmdbuf ^= '' then
                    msg = 'invalid, choose one listed';
            end;
         end;
      end;
      call docterm(@doc,rc);      /* terminate document object     */
      cmdbuf='';msg='';
      EXEC CICS SEND CONTROL ERASE;
      return;
   end demo;

DOCEXIT SOURCE

docexit: proc;
dcl
/*********************************************************************/
/* proc and function references                                      */
/*********************************************************************/
   addr builtin,
/*********************************************************************/
/* data structures                                                   */
/*********************************************************************/
   1 demodb_struc ctl,
    2 xsc    char(01),                 /* service call code          */
    2 xc     bit(1),                   /* commit flag                */
    2 xcount fixed bin(31,0),          /* record count               */
    2 xid    fixed bin(31,0),          /* 'ID'   column of table     */
    2 xname  char(40),                 /* 'NAME' column of table     */
/*********************************************************************/
/* global variables                                                  */
/*********************************************************************/
/* local variables                                                   */
/*********************************************************************/
   rc fixed bin(31,0),
   1 ws,
    2 wsid pic'9999999';
/*********************************************************************/
/* open the document.                                                */
/*********************************************************************/
docexi0: entry(pdocn,pne,prowlen,psd,rc);
dcl
                                       /* 'pdocn'   document name    */
                                       /* 'pne'     record count     */
                                       /* 'prowlen' length of record */
                                       /* 'psd'     start of data    */
   (pdocn) char(*),
   (pne,prowlen,psd) fixed bin(15,0);
   rc=0;
   select(pdocn);
      when ('DEMO') do;
           alloc demodb_struc;demodb_struc.xsc='1';
           call demobrw(addr(demodb_struc),rc);
           pne=demodb_struc.xcount;prowlen=48;psd=1;return;
           end;
      otherwise do;
           rc=4;return;
           end;
   end;
/*********************************************************************/
/* fetch the document record.                                        */
/*********************************************************************/
docexi1: entry(pdocn,prow,rc);
dcl
   (prow) char(*) var;
   rc=0;
   select(pdocn);
      when ('DEMO') do;
           demodb_struc.xsc='2';call demobrw(addr(demodb_struc),rc);
           wsid=xid;prow=wsid||' '||xname;
           return;
           end;
      otherwise do;
           rc=4;return;
           end;
   end;
/*********************************************************************/
/* close the document.                                               */
/*********************************************************************/
docexi2: entry(pdocn,rc);
   rc=0;
   select(pdocn);
      when ('DEMO') do;
           demodb_struc.xsc='3';
           demodb_struc.xc='1'b;call demobrw(addr(demodb_struc),rc);
           free demodb_struc;
           return;
           end;
      otherwise do;
           rc=4;return;
           end;
   end;
end docexit;

DEMODB SOURCE

demodb: proc;
/*********************************************************************/
/* sql related declarations                                          */
/*********************************************************************/
   EXEC SQL BEGIN DECLARE SECTION;
      dcl COUNT fixed bin(31,0);
      dcl ID    fixed bin(31,0);
      dcl NAME  char(40);
   EXEC SQL END DECLARE SECTION;
   EXEC SQL INCLUDE SQLCA;
   EXEC SQL WHENEVER SQLERROR goto sqlerr;
/*********************************************************************/
/* proc and function references                                      */
/*********************************************************************/
dcl
/*********************************************************************/
/* global variables                                                  */
/*********************************************************************/
   msg char(79) ext,
   genv char(08) ext,
/*********************************************************************/
/* local variables                                                   */
/*********************************************************************/
   rc bin fixed(31),
   1 ws,
    2 sqlrc pic 's999',
   @demodb ptr,
   1 demodb_struc based(@demodb),
    2 xsc    char(01),                 /* service call code          */
    2 xc     bit(1),                   /* commit flag                */
    2 xcount fixed bin(31,0),          /* record count               */
    2 xid    fixed bin(31,0),          /* 'ID'   column of table     */
    2 xname  char(40);                 /* 'NAME' column of table     */
/*********************************************************************/
/* local procs                                                       */
/*********************************************************************/
/* service procs                                                     */
/*********************************************************************/
demobrw: entry(@demodb,rc);
   rc=0;
   if xsc='1' then do;
      EXEC SQL
           SELECT COUNT(*)
           INTO  :COUNT
           FROM   OPRIMS.DEMO;
      if COUNT=0 then do;rc=1;return;end;
      xcount=COUNT;
      EXEC SQL DECLARE C01 CURSOR FOR
           SELECT ID,NAME
           FROM   OPRIMS.DEMO
           ORDER BY ID;
      EXEC SQL OPEN C01;
      return;
   end;
   if xsc='2' then do;
      EXEC SQL FETCH C01 INTO :ID,:NAME;
      if sqlcode^=0 then do;
         EXEC SQL CLOSE C01;
         rc=4;return;
      end;
      xid=ID;xname=NAME;
      return;
   end;
   if xsc='3' then do;
      EXEC SQL CLOSE C01;
      if xc then goto commit;
      return;
   end;
   rc=2;return;
/*********************************************************************/
/* handle commit and rollback                                        */
/*********************************************************************/
commit:
   if genv='CICS' then
      EXEC CICS SYNCPOINT;
   else
      EXEC SQL COMMIT WORK;
   return;
 rollb:
   if genv='CICS' then
      EXEC CICS SYNCPOINT ROLLBACK;
   else
      EXEC SQL ROLLBACK WORK;
   return;
/*********************************************************************/
/* handle sql error condition                                        */
/*********************************************************************/
sqlerr:
  sqlrc = SQLCODE;msg = sqlrc||' '||SQLERRM;
  EXEC SQL WHENEVER SQLERROR continue;
  if genv='CICS' then
     EXEC CICS SYNCPOINT ROLLBACK;
  else
     EXEC SQL ROLLBACK WORK;
  rc=8;
  return;
end demodb;

DOCOBJ SOURCE

docobj: proc;
dcl
/*********************************************************************/
/* external references                                               */
/*********************************************************************/
   strip entry(char(*) varying) returns(char(80) varying) external,
/*********************************************************************/
/* built-in function references                                      */
/*********************************************************************/
   (addr,translate) builtin,
/*********************************************************************/
/* global variables                                                  */
/*********************************************************************/
   msg char(79) ext,
   cmdbuf char(79) ext,
/*********************************************************************/
/* data structures                                                   */
/*********************************************************************/
   1 scr based(@scr),
     2 hdr1      char(79),
     2 hdr2      char(79),
     2 hdr3      char(79),
     2 fldn      fixed bin(15,0),
     2 lcmd_cnt  fixed bin(15,0),
     2 lcmd_ptr  fixed bin(15,0),
     2 lcmd      (15) char(01),
     2 texta     (22) char(79),
     2 ndr       fixed bin(15,0),
     2 sw        fixed bin(15,0),
     2 sr        fixed bin(15,0),
     2 er        fixed bin(15,0),
     2 sc        fixed bin(15,0),
     2 ec        fixed bin(15,0),
     2 w         fixed bin(15,0),
     2 cdr       fixed bin(15,0),
     2 h         fixed bin(15,0),
     2 @dmask    ptr,
     2 @protect  ptr,
     2 @scrpnl   ptr,
   1 brw based(@brw),
     2 @scr      ptr,
     2 ne        fixed bin(15,0),
     2 f         fixed bin(15,0),
     2 c         fixed bin(15,0),
     2 update    bit(1),
   @doc ptr,
   1 doc based(@doc),
     2 @brw      ptr,
     2 docn      char(08),
     2 rowlen    fixed bin(15,0),
     2 sd        fixed bin(15,0),
     2 ap        fixed bin(15,0),
     2 cmdbuf_o  char(79),
     2 @array    ptr,
   array (0:i) char(rowlen) var ctl,
/*********************************************************************/
/* local variables                                                   */
/*********************************************************************/
   rc    fixed bin(31,0),
   1 ws,
     2 (i,j)  fixed bin(15,0),
     2 k      fixed bin(15,0),
     2 is     pic '9999',
     2 varstr char(80) var,
     2 wrapp  bit(1),
     2 found  bit(1),
     2 uc     char(26) init('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
     2 lc     char(26) init('abcdefghijklmnopqrstuvwxyz')
  ;
/*********************************************************************/
/* local procs                                                       */
/*********************************************************************/
   retr: proc(j);
   dcl
      (j,k) fixed bin(15,0);
      do while (j>ap);
         do k=1 to 30 while(ap<ne);
            ap=ap+1;
            call docexi1(docn,array(ap),rc);
         end;
      end;
   end retr;
   find: proc;
      cmdbuf_o=cmdbuf;
      varstr=substr(cmdbuf,3);
      if varstr='' then msg='missing argument';
      else do;
         varstr=strip(varstr);j=f+1;wrapp='0'b;
       s:found='0'b;
         do i=j to ne while( ^found );
            call retr(i);
            array(0)=substr(array(i),sd);
            array(0)=translate(array(0),uc,lc);
            if index(array(0),varstr)>0 then do;
               found='1'b;
               f=i;
            end;
         end;
         if found then do;
            h=1;update='1'b;
            if wrapp then msg='wrapped...';
         end;
         else do;
            if f^=1 & ^wrapp then do;
               j=1;wrapp='1'b;goto s;
            end;
            msg='not found';
         end;
      end;
   end find;
/*********************************************************************/
/* service procs                                                     */
/*********************************************************************/
docinit: entry(phdr1,phdr2,phdr3,psr,per,psc,pec,pdocn,@pscr,@pbrw,
                                                              @doc,rc);
/*********************************************************************/
/* initialize                                                        */
/*********************************************************************/
dcl
   (phdr1,phdr2,phdr3) char(*),
   (psr,per,psc,pec,pne) fixed bin(15,0),
   (pdocn) char(*),
   (@pscr,@pbrw) ptr;
   rc=0;
   alloc doc;
   ap=0;
   docn=pdocn;
   cmdbuf_o='';
   call docexi0(docn,i,rowlen,sd,rc);
   if rc^=0 then do;free doc;return;end;
   alloc array;
   call brwinit(phdr1,phdr2,phdr3,psr,per,psc,pec,i,@brw,rc);
   @pscr=@scr;
   @pbrw=@brw;
   return;
docdisp: entry(@doc,rc);
/*********************************************************************/
/* display screen                                                    */
/*********************************************************************/
   rc=0;
   if update then do;
      update='0'b;
      cdr=min(ndr,ne-f+1);
      do i=1 to cdr;
         j=f+i-1;
         call retr(j);
         substr(texta(sw+sr+i),sc+1,w)=substr(array(j),sd);
      end;
      c=f+cdr-1;
   end;
   call scrdisp(@scr,rc);
   return;
docqse1: entry(@doc,pdata,rc);
/*********************************************************************/
/* query selection                                                   */
/*********************************************************************/
dcl
   (pdata) char(*);
   rc=0;
   pdata=array(f+lcmd_ptr-1);
   return;
dochcmd: entry(@doc,rc);
/*********************************************************************/
/* handle document commands                                          */
/*********************************************************************/
   rc=0;
   select( cmdbuf );
      when('=') do;               /* repeat command                  */
         cmdbuf=cmdbuf_o;cmdbuf_o='';
         call find;
      end;
      otherwise do;
                                  /* find a string                   */
         if substr(cmdbuf,1,2)='F ' then do;
            call find;
         end;
                                  /* unknown                         */
         else rc=4;
      end;
   end;
   return;
/*********************************************************************/
/* terminate                                                         */
/*********************************************************************/
docterm: entry(@doc,rc);
   rc=0;
   call docexi2(docn,rc);
   call brwterm(@brw,rc);
   free array;
   free doc;
   return;
end docobj;

BRWOBJ SOURCE

brwobj: proc;
/*********************************************************************/
/* external references                                               */
/*********************************************************************/
dcl
/*********************************************************************/
/* built-in function references                                      */
/*********************************************************************/
   (addr, min, max) builtin,
/*********************************************************************/
/* global variables                                                  */
/*********************************************************************/
   msg char(79) ext,
   cmdbuf char(79) ext,
/*********************************************************************/
/* data structures                                                   */
/*********************************************************************/
   1 scr based(@scr),
     2 hdr1      char(79),
     2 hdr2      char(79),
     2 hdr3      char(79),
     2 fldn      fixed bin(15,0),
     2 lcmd_cnt  fixed bin(15,0),
     2 lcmd_ptr  fixed bin(15,0),
     2 lcmd      (15) char(01),
     2 texta     (22) char(79),
     2 ndr       fixed bin(15,0),
     2 sw        fixed bin(15,0),
     2 sr        fixed bin(15,0),
     2 er        fixed bin(15,0),
     2 sc        fixed bin(15,0),
     2 ec        fixed bin(15,0),
     2 w         fixed bin(15,0),
     2 cdr       fixed bin(15,0),
     2 h         fixed bin(15,0),
     2 @dmask    ptr,
     2 @protect  ptr,
     2 @scrpnl   ptr,
   @brw ptr,
   1 brw based(@brw),
     2 @scr      ptr,
     2 ne        fixed bin(15,0),
     2 f         fixed bin(15,0),
     2 c         fixed bin(15,0),
     2 update    bit(1),
/*********************************************************************/
/* local variables                                                   */
/*********************************************************************/
   rc    fixed bin(31,0),
   1 ws,
     2 i      fixed bin(15,0),
     2 j      fixed bin(15,0),
     2 is     pic '9999',
     2 varstr char(79) var
   ;
/*********************************************************************/
/* local procs                                                       */
/*********************************************************************/
   up: proc;
      if h>1 then h=h-1;
      else do;
         if f>1 then do;
            f=f-1;
            update='1'b;
         end;
      end;
   end up;
   dwn: proc;
      if h<cdr then h=h+1;
      else do;
         if c<ne then do;
            f=f+1;
            update='1'b;
         end;
      end;
   end dwn;
   pgu: proc;
      if f>1 then do;
         f=max(f-ndr,1);
         update='1'b;
      end;
   end pgu;
   pgd: proc;
      if c<ne then do;
         f=min(f+ndr,ne);
         update='1'b;
      end;
   end pgd;
   hom: proc;
      h=1;
      fldn=0;
   end hom;
   end: proc;
      h=cdr;
      fldn=0;
   end end;
   cho: proc;
      h=1;f=1;
      update='1'b;
   end cho;
   cen: proc;
      if c=ne then h=cdr;
      else do;
         f=ne-ndr+1;
         update='1'b;
         h=ndr;
      end;
   end cen;
   gol: proc;
      varstr=substr(cmdbuf,3);
      if verify(varstr,' 0123456789')>0 then rc=4;
      else do;
         if varstr='' then msg='missing argument';
         else do;
            get string(varstr) edit(i) (f(5));
            if i<=0 then i=1;
            if i>ne then i=ne;
            f=i;h=1;update='1'b;
         end;
      end;
   end gol;
/*********************************************************************/
/* service procs                                                     */
/*********************************************************************/
brwinit: entry(phdr1,phdr2,phdr3,psr,per,psc,pec,pne,@brw,rc);
/*********************************************************************/
/* initialize                                                        */
/*********************************************************************/
dcl
   (phdr1,phdr2,phdr3) char(*),
   (psr,per,psc,pec,pne) fixed bin(15,0);
   rc=0;
   alloc brw;
   ne=pne;
   call scrinit(phdr1,phdr2,phdr3,psr,per,psc,pec,@scr,rc);
/* init variables                                                    */
   f=1;
   update='1'b;
   return;
brwhcmd: entry(@brw,rc);
/*********************************************************************/
/* handle browse commands                                            */
/*********************************************************************/
   rc=0;
   select( cmdbuf );
      when('I') do;               /* up_arrow key simulated by       */
         call up;                 /* placing cursor on first row and */
      end;                        /* pressing 'enter' key.           */
      when('J') do;               /* down_arrow key simulated by     */
         call dwn;                /* placing cursor on last row and  */
      end;                        /* pressing 'enter' key.           */
      when('D') do;               /* pg_up key                       */
         call pgu;
      end;
      when('U') do;               /* pg_down key                     */
         call pgd;
      end;
      when('K') do;               /* home key                        */
         call hom;
      end;
      when('L') do;               /* end key                         */
         call end;
      end;
      when('O') do;               /* ctrl_home key                   */
         call cho;
      end;
      when('M') do;               /* ctrl_end key                    */
         call cen;
      end;
      otherwise do;
                                  /* go to a location                */
         if substr(cmdbuf,1,2)='G ' then do;
            call gol;
         end;
                                  /* unknown                         */
         else rc=4;
      end;
   end;
   return;
brwterm: entry(@brw,rc);
/*********************************************************************/
/* terminate                                                         */
/*********************************************************************/
   rc=0;
   call scrterm(@scr,rc);
   free brw;
   return;
end brwobj;

SCROBJ SOURCE

scrobj: proc;
dcl
/*********************************************************************/
/* external references                                               */
/*********************************************************************/
   strip ext entry(char(*) varying) returns(char(80) varying),
/*********************************************************************/
/* built-in function references                                      */
/*********************************************************************/
   (addr,translate,length) builtin,
/*********************************************************************/
/* global variables                                                  */
/*********************************************************************/
   msg char(79) ext,
   cmdbuf char(79) ext,
/*********************************************************************/
/* data structures                                                   */
/*********************************************************************/
   @scr ptr,
   1 scr based(@scr),
     2 hdr1      char(79),
     2 hdr2      char(79),
     2 hdr3      char(79),
     2 fldn      fixed bin(15,0),
     2 lcmd_cnt  fixed bin(15,0),
     2 lcmd_ptr  fixed bin(15,0),
     2 lcmd      (15) char(01),
     2 texta     (22) char(79),
     2 ndr       fixed bin(15,0),
     2 sw        fixed bin(15,0),
     2 sr        fixed bin(15,0),
     2 er        fixed bin(15,0),
     2 sc        fixed bin(15,0),
     2 ec        fixed bin(15,0),
     2 w         fixed bin(15,0),
     2 cdr       fixed bin(15,0),
     2 h         fixed bin(15,0),
     2 @dmask    ptr,
     2 @protect  ptr,
     2 @scrpnl   ptr,
   dmask(38) char(1) based(@dmask),
   protect(38) char(1) based(@protect),
   1 scrpnl based(@scrpnl),
     2 lu0000(38) ptr,
     2 fence bit(32) init((32)'1'b),
/*********************************************************************/
/* local variables                                                   */
/*********************************************************************/
   rc    fixed bin(31,0),
   1 ws,
     2 aw    char(1) init('Y'),
     2 aud   char(1) init('N'),
     2 i     fixed bin(15,0),
     2 j     fixed bin(15,0),
     2 key   fixed bin(15,0),
     2 b     char(79) init((79)' '),
     2 uc    char(26) init('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
     2 lc    char(26) init('abcdefghijklmnopqrstuvwxyz'),
     2 wstr  char(80) var
   ;
/*********************************************************************/
/* local procs                                                       */
/*********************************************************************/
/* service procs                                                     */
/*********************************************************************/
scrinit: entry(phdr1,phdr2,phdr3,psr,per,psc,pec,@scr,rc);
/*********************************************************************/
/* initialize                                                        */
/*********************************************************************/
dcl
   (phdr1,phdr2,phdr3) char(*),
   (psr,per,psc,pec) fixed bin(15,0);
   rc=0;
   alloc scr;
   alloc dmask;
   alloc protect;
   alloc scrpnl;
/* init hdr vars                                                     */
   hdr1=phdr1;
   hdr2=phdr2;
   hdr3=phdr3;
/* set up screen                                                     */
   sw=4;
   lu0000(1) = addr(texta(1));
   lu0000(2) = addr(texta(2));
   lu0000(3) = addr(texta(3));
   lu0000(4) = addr(texta(4));
   do i = 1 to 14;
      lu0000(3+2*i) = addr(lcmd(i));
      lu0000(4+2*i) = addr(texta(i+4));
   end;
   lu0000(33) = addr(texta(19));
   lu0000(34) = addr(cmdbuf);
   lu0000(35) = addr(texta(20));
   lu0000(36) = addr(texta(21));
   lu0000(37) = addr(texta(22));
   lu0000(38) = addr(msg);
   texta = '';
   texta(1)  = hdr1;
   texta(2)  = hdr2;
   texta(3)  = hdr3;
   texta(19) = 'type a code';
   texta(20) = 'u up    o top      f find ''string''  s_select';
   texta(21) = 'd down  m bottom   = repeat find';
   texta(22) =                                                 e ';
/* init other variables                                         */
   sr=psr;er=per;sc=psc;ec=pec;
   ndr=er-sr-1;
   w=ec-sc-1;
   h=1;
   lcmd='';fldn=05;
   cmdbuf='';msg='';
   return;
scrdisp: entry(@scr,rc);
/*********************************************************************/
/* display screen                                                    */
/*********************************************************************/
   rc=0;
   do i=1 to cdr;
      protect(sw+sr*2+i*2-1)='N';
   end;
   do i=cdr+1 to ndr;
      texta(sw+sr+i)=substr(b,sc+1,w);
      protect(sw+sr*2+i*2-1)='Y';
   end;
   h=min(h,cdr);
   lcmd_ptr=0;1cmd_cnt=0;
   i=sw+1+sr*2;j=sw+sr*2+cdr*2-1;
   if fldn^=34 then do;
      if (fldn<i)|(fldn>j) then fldn=sw+sr*2+h*2-1;
   end;
   if (fldn>=i)&(fldn<=j) then h=(fldn-sw-sr*2+1)/2;
   dmask(sw+sr*2+h*2)=aw;
   if msg='' then cmdbuf='';
 d:call scrio('SCRPNL  ',scrpnl,protect,dmask,fldn,key);
   select (key);
      when (0) do;
         do i = 1 to 79 while(substr(cmdbuf,i,1) = ' ');
         end;
         if cmdbuf ^= ' ' &
            i > 1 then cmdbuf = substr(cmdbuf,i,79-i+1);
         cmdbuf=translate(cmdbuf,uc,lc);
      end;
      when (1)  cmdbuf='H';
      when (3)  cmdbuf='E';
      when (5)  cmdbuf='=';
      when (7)  cmdbuf='D';
      when (8)  cmdbuf='U';
      when (9)  cmdbuf='I';
      when (10) cmdbuf='J';
      when (11) cmdbuf='L';
      when (12) cmdbuf='K';
      otherwise do;msg='undefined key...';goto d;end;
   end;
   if cmdbuf ^= 'E' then do;
      dmask(sw+sr*2+h*2)=aud;msg = '';
   end;
   return;
scrrlcm: entry(@scr,plcmd,rc);
/*********************************************************************/
/* retrieve line commands                                            */
/*********************************************************************/
dcl
   (plcmd) char(*);
   rc=0;
   if lcmd_ptr>0 then lcmd(sr+lcmd_ptr)='';
 l:lcmd_ptr=lcmd_ptr+1;
   if lcmd_ptr<=cdr then do;
      if lcmd(sr+lcmd_ptr)^='' then do;
         lcmd_cnt=lcmd_cnt+1;
         plcmd=translate(lcmd(sr+lcmd_ptr),uc,lc);
         fldn=sw+sr*2+lcmd_ptr*2-1;
         return;
      end;
      go to 1;
   end;
   if (cmdbuf='')&(lcmd_cnt=0) then do;
      if (fldn=sw+1+sr*2) then do; cmdbuf='I';h=1;end;
      if (fldn=sw+sr*2+cdr*2-1) then do;cmdbuf='J';h=cdr;end;
   end;
   lcmd_ptr=0;lcmd_cnt=0;lcmd='';
   rc=4;
   return;
scruhdr: entry(@scr,phdr1,rc);
/*********************************************************************/
/* update hdr1 header                                                */
/*********************************************************************/
   rc=0;
   texta(1), hdr1=phdr1;
   return;
scricmd: entry(@scr,pfkey,pcmdstr,rc);
/*********************************************************************/
/* install new command                                               */
/*********************************************************************/
dcl
   pfkey     fixed bin(15),
   (pcmdstr) char(*);
   rc=0;
   wstr=pcmdstr;wstr=strip(wstr);i=length(wstr);
   substr(texta(22),1,i)=wstr;
   return;
scrterm: entry(@scr,rc);
/*********************************************************************/
/* terminate                                                         */
/*********************************************************************/
   rc=0;
   free scrpnl;
   free protect;
   free dmask;
   free scr;
   return;
end scrobj;

SCRIO SOURCE

scrio: proc(pname,dms,protect,dmask,fldn,key);
  %include SCRPNL;
  %include DFHAID;
  %include DFHBMSCA;
  dcl 1 xscrpnli based(addr(SCRPNLI)) unaligned,
        2 fill1 char(340),
        2 fill2(14),
          3 mlinesb1l fixed bin(15,0),
          3 mlinesb1f char(01),
          3 mlinesb1i char(01),
          3 mlinesb2l fixed bin(15,0),
          3 mlinesb2f char(01),
          3 mlinesb2i char(77);
  dcl 1 xscrpnlo based(addr(SCRPNLI)) unaligned,
        2 fill1 char(340),
        2 fill2(14),
          3 fill3     fixed bin(15,0),
          3 mlinesb1a char(01),
          3 mlinesb1o char(01),
          3 fill4     fixed bin(15,0),
          3 mlinesb2a char(01),
          3 mlinesb2o char(77);
  dcl pname char(8);              /* panel name                      */
  dcl (fldn,key,cursor) fixed bin(15,0);
  dcl 1 dms,
       2 dmslu(*) ptr,
       2 fence bit(32);
  dcl protect(*) char(*);
  dcl dmask(*) char(*);
  dcl (addr,translate) builtin;
  dcl (@b1,@b2) (14) ptr;
  dcl linesa  (04) char(79) based(dmslu(01));
  dcl linesb1 (14) char(01) based(@b1(01));
  dcl linesb2 (14) char(79) based(@b2(01));
  dcl linesc       char(79) based(dmslu(33));
  dcl linesd       char(79) based(dmslu(34));
  dcl linese  (03) char(79) based(dmslu(35));
  dcl linesf       char(79) based(dmslu(38));
  do i=1 to 14;
     @b1(i)=dmslu(3+2*i);
     @b2(i)=dmslu(4+2*i);
  end;
  EXEC CICS ADDRESS EIB(DFHEIPTR);
  cursor=trfncp(0,fldn);
  if key=9 then EXEC CICS SEND CONTROL ALARM;
/*********************************************************************/
/* display panel and wait for user's response                        */
/*********************************************************************/
  do i=1 to 4;
     MLINESAO(i)=linesa(i);
  end;
  do i=1 to 14;
     MLINESB1O(i)=linesb1(i);
     MLINESB2O(i)=linesb2(i);
  end;
  MLINESCO=linesc;
  MLINESDO=linesd;
  do i=1 to 3;
     MLINESEO(i)=linese(i);
  end;
  MLINESFO=linesf;
  call setpro(protect);call setbri(dmask);
  EXEC CICS SEND MAP('SCRPNL') CURSOR(CURSOR) ERASE;
  EXEC CICS RECEIVE MAP('SCRPNL') NOHANDLE;
  do i=1 to 14;
     linesb1(i)=MLINESB1I(i);
  end;
  linesd=MLINESDI;
/*********************************************************************/
/* check for user response and set cmd accordingly                   */
/*********************************************************************/
  key=0;
  select (EIBAID);
     when(DFHPF1 ,DFHPF13) key=1;
     when(DFHPF2 ,DFHPF14) key=2;
     when(DFHPF3 ,DFHPF15) key=3;
     when(DFHPF4 ,DFHPF16) key=4;
     when(DFHPF5 ,DFHPF17) key=5;
     when(DFHPF6 ,DFHPF18) key=6;
     when(DFHPF7 ,DFHPF19) key=7;
     when(DFHPF8 ,DFHPF20) key=8;
     when(DFHPF9 ,DFHPF21) key=9;
     when(DFHPF10,DFHPR22) key=10;
     when(DFHPF11,DFHPF23) key=11;
     when(DFHPF12,DFHPF24) key=12;
     otherwise;
  end;
/*********************************************************************/
/* find out cursor position                                          */
/*********************************************************************/
  cursor=EIBCPOSN;
  fldn=trfncp(1,cursor);
/*********************************************************************/
/* return back                                                       */
/*********************************************************************/
  return;
trfncp: proc(i,j) returns(fixed bin(15));
dcl (i,j,k) fixed bin(15),
    even bit(1);
begin;
    if i=0 then do;
       if (j<5) | (j>32) then do;
          if j<5 then i=(j-1)*80+1;
                 else i=(j-15)*80+1;
          return(i);
       end;
       i=j/2;i=2*i;
       if i=j then do;even='1'b;j=j-1;end;
              else even='0'b;
       i=40*j+120;
       if even then i=i+4;
               else i=i+1;
       return(i);
    end;
    i=0;k=j;do while (k>80);i=i+1;k=k-80;end;i=i+1;
    if (j<321) | (j>1364) then do;if j>1364 then i=i+14;return(i);end;
    if k=1 then i=2*i-5;
           else i=2*i-4;
    return(i);
end;
end trfncp;
setpro: proc(protect);
dcl (i,j,k) fixed bin(15),
    protect(*) char(*),
    even bit(1);
begin;
    do i=5 to 32;
       j=i/2;j=2*j;
       if i=j then do;even='1'b;j=i-1;end;
              else do;even='0'b;j=i;end;
       k=(j-3)/2;
       select (protect(i));
          when('y')
             if even then mlinesb2a(k)=dfhbmprf;
                     else mlinesb1a(k)=dfhbmprf;
          when('n')
             if even then mlinesb2a(k)=dfhbmfse;
                     else mlinesb1a(k)=dfhbmfse;
          otherwise;
       end;
    end;
end;
end setpro;
setbri: proc(dmask);
dcl (i,j,k) fixed bin(15),
    dmask(*) char(*),
    even bit(1);
begin;
    do i=5 to 32;
       j=i/2;j=2*j;
       if i=j then do;even='1'b;j=i-1;end;
              else do;even='0'b;j=i;end;
       k=(j-3)/2;
       select (dmask(i));
          when('y')
             if even then mlinesb2a(k)=dfhbmasb;
                     else mlinesb1a(k)=dfhbmasb;
          when('n')
             if even then mlinesb2a(k)=dfhbmpro;
                     else mlinesb1a(k)=dfhbmpro;
          otherwise;
       end;
    end;
end;
end setbri;
end scrio;

STRIP SUBROUTINE

strip: proc(str) returns(char(80) varying);
   dcl str char(*) varying,(i,j) fixed bin;
   i=verify(str,' ');if i=0 then return('');str=substr(str,i);
   j=length(str);do i=j to 1 by -1 while(substr(str,i,1)=' ');end;
   return(substr(str,1,i));
end;

TD SUBROUTINE

td: proc(tdiptr);
/*********************************************************************/
/* get the current time and today's date                             */
/*********************************************************************/
dcl
   tdiptr ptr,
   1 tdi based(tdiptr),
    2 tdsc fixed bin,
    2 tdd char(8),
    2 tdt char(8),
    2 utdt char(6),
   (day,month,year,hour,min,sec) char(2),
   ws_date_field char(6),
   ws_time_field char(9),
   (date, time) builtin;
begin;
   select (tdsc);
      /* set up date field */
      when (0) do;
           ws_date_field = date;
           year  = substr(ws_date_field,1,2);
           month = substr(ws_date_field,3,2);
           day   = substr(ws_date_field,5,2);
           tdd   = day||'/'||month||'/'||year;
           end;
      /* set up time field */
      when (1) do;
           ws_time_field = time;
           hour  = substr(ws_time_field,1,2);
           min   = substr(ws_time_field,3,2);
           sec   = substr(ws_time_field,5,2);
           tdt   = hour||':'||min||':'||sec;
           end;
      when (2) do;
           ws_time_field = time;
           hour  = substr(ws_time_field,1,2);
           min   = substr(ws_time_field,3,2);
           sec   = substr(ws_time_field,5,2);
           utdt  = hour||min||sec;
           end;
      otherwise;
   end;
end;
end td;

SCRPNL MAP

MAPSET   DFHMSD TYPE=MEMO I3820,MODE=INOUT,CTRL=(FREEKB,FRSET),LANG=PLI,
               STORAGE=AUTO,EXTATT=MAPONLY
SCRPNL   DFHMDI SIZE=(24,80)
MLINESA  DFHMDF POS=(01,01),LENGTH=79,OCCURS=04
MLIN011  DFHMDF POS=(05,01),LENGTH=01
MLIN012  DFHMDF POS=(05,03),LENGTH=77
MLIN021  DFHMDF POS=(06,01),LENGTH=01
MLIN022  DFHMDF POS=(06,03),LENGTH=77
MLIN031  DFHMDS POS=(07,01),LENGTH=01
MLIN032  DFHMDF POS=(07,03),LENGTH=77
MLIN041  DFHMDF POS=(08,01),LENGTH=01
MLIN042  DFHMDF POS=(08,03),LENGTH=77
MLIN051  DFHMDF POS=(09,01),LENGTH=01
MLIN052  DFHMDF POS=(09,03),LENGTH=77
MLIN061  DFHMDF POS=(10,01),LENGTH=01
MLIN062  DFHMDF POS=(10,03),LENGTH=77
MLIN071  DFHMDF POS=(11,01),LENGTH=01
MLIN072  DFHMDF POS=(11,03),LENGTH=77
MLIN081  DFHMDF POS=(12,01),LENGTH=01
MLIN082  DFHMDF POS=(12,03),LENGTH=77
MLIN091  DFHMDF POS=(13,01),LENGTH=01
MLIN092  DFHMDF POS=(13,03),LENGTH=77
MLIN101  DFHMDF POS=(14,01),LENGTH=01
MLIN102  DFHMDF POS=(14,03),LENGTH=77
MLIN111  DFHMDF POS=(15,01),LENGTH=01
MLIN112  DFHMDF POS=(15,03),LENGTH=77
MLIN121  DFHMDF POS=(16,01),LENGTH=01
MLIN122  DFHMDF POS=(16,03),LENGTH=77
MLIN131  DFHMDF POS=(17,01),LENGTH=01
MLIN132  DFHMDF POS=(17,03),LENGTH=77
MLIN141  DFHMDF POS=(18,01),LENGTH=01
MLIN142  DFHMDF POS=(18,03),LENGTH=77
MLINESC  DFHMDF POS=(19,01),LENGTH=79,
MLINESD  DFHMDF POS=(20,01),LENGTH=79,ATTRB=(BRT,IC,FSET)
MLINESE  DFHMDF POS=(21,01),LENGTH=79,OCCURS=03
MLINESF  DFHMDF POS=(24,01),LENGTH=79,ATTRB=(ASKIP,BRT)
         DFHMSD TYPE=FINAL
         END


Ilyas M Shaikh
Systems Programmer
KFUPM (Saudi Arabia)                                                               c Xephon 1995

