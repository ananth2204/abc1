A DFHSM monitor

The HSM$MON program was written because I always have
trouble finding the information I want in the output from
DFHSM's Query Active command. The program presented here
could form the basis of a much more complex DFHSM monitor.

HSM$MON interrogates DFHSM's control blocks and presents
the information that it finds in an ordered, easy to read fashion. It
displays DFHSM's status on an ISPF panel so split-screen is
possible when viewing the output.

THE DISPLAY

The first five lines show which DFHSM functions are 'held' or
'not held'. A green background means the function is 'not held'
while a red background signifies a 'held' function. The rest of the
lines are used to display as many Management Work Elements
(MWEs) as can be fitted on the screen (my next enhancement will
be to display all of the MWEs in a scrollable dynamic area).
DFHSM has six MWE queues. These queues are scanned and
displayed in this order: CSA queue, general queue, operator
queue, recall queue, migrate queue, and back-up/recover queue.

DESIGN

The design of HSM$MON posed an interesting problem. Since I
had to use Cross Memory Services to get the DFHSM control
blocks, the program had to run APF-authorized, but APF-
authorized programs cannot call ISPF services. This caused the
introduction of an SVC that turns APF authorization on and off as
required by the program. If you already have such an SVC
installed it can probably be used instead of the one supplied here
- change all of the calls to SVC 244 in modules HSM$MON2
and HSM$MON3 to suite your own SVC.

When link-editing the program modules do not use SET
CODE(1); also, an APF authorized library is not required.

Structure

The program comprises three modules and one SVC:

1      HSM$MON initializes the program environment and locates
      the DFHSM address space, the Queue Control Table (QCT),
      and then the Management Communication Vector Table
      (MCVT). After the first call its purpose is simply to refresh the
      copy of the MCVT. This module does not call the SVC.

2      HSM$MON2 initializes the ISPF variables, then formats the
      output display by looking at the MCVT and the MWE
      queues. Finally it displays the panel HSM$MON.
      HSM$MON2 has three calls to the SVC.

3      HSM$MON3 performs all cross memory calls. It is called
      by HSM$MON to get the MCVT and by HSM$MON2 to
      get the MWEs that reside in the DFHSM address space. It
      calls the SVC twice.

4      HSM$SVC may be installed as a type 3 SVC. Calling this
      SVC with register 0 set to X'00000001' will turn APF
      authorization on and X'00000002' will turn APF
      authorization off: any other value will have no effect.

Three DSECTs in the form of copy books are also provided to
map DFHSM control blocks. I have only provided enough
information in these DSECTs to cater for the current program's
requirements.

1      HSM$QCT maps the DFHSM (Version 2.6) QCT control
      block. This control block resides in the SQA and its address
      can be found in MVS's CVT if DFHSM is active.

2      HSM$MCVT maps the DFHSM (Version 2.6) MCVT
      control block. This control block resides in the DFHSM
      address space and its address is found in the QCT.

3      HSM$MWE  maps the DFHSM (Version 2.6) MWEs found
      in six chains. The CSA chain is anchored in the QCT: its
      MWEs reside in the CSA. The other five chains are anchored
      in the MCVT and reside in the DFHSM address space.

One ISPF panel is used, called HSM$PANL.

I suggest that the program modules are placed in a link-listed
library.

To execute HSM$MON under TSO ISPF use:

      TSO HSM$MON 'hsm-name'

where 'hsm-name' is the name of the DFHSM address space that
you wish to monitor.

Bibliography

IBM manuals

o      LY35-0098 DFHSM V2.6.0 Diagnosis Guide.

o      LY35-0105 DFHSM V2.6.0 Diagnosis Reference for Data
      Areas and Control Blocks.

HSM$MON SOURCE CODE

         TITLE    'DFHSM MONITOR PROGRAM'
         LCLC     &MODULE
&MODULE  SETC     'HSM$MON'
&MODULE  CSECT
&MODULE  AMODE    31
&MODULE  RMODE    24
         STM      R14,R12,12(R13)          SAVE REGISTERS
         LR       R12,R15
         USING    &MODULE,R12
         B        *+28
         DC       CL8'&MODULE'
         DC       CL8'&SYSDATE'
         DC       CL8'&SYSTIME'
         GETMAIN  R,LV=80                  GET A SAVEAREA
         ST       R13,4(R1)                BACKWARD CHAIN
         ST       R1,8(R13)                FORWARD CHAIN
         LR       R13,R1                   SWAP SAVE AREAS
         L        R1,4(R13)
         LM       R0,R1,20(R1)             RESTORE PARM REGISTERS
* LOAD HSM$MON MODULES
PAGE     EQU   4096
         L     R2,0(R1)
         XR    R3,R3
         ICM   R3,3,0(R2)
         BCTR  R3,0
         EX    R3,MOVENAME
         B     GETMAIN
MOVENAME MVC   HSMNAME(*-*),2(R2)
GETMAIN  GETMAIN R,LV=PAGE
         LR    R11,R1
         USING COMMAREA,R11
         LOAD  EP=HSM$MON2
         ST    R0,HSM$MN2@
         LOAD  EP=HSM$MON3
         ST    R0,HSM$MN3@
* GET ASID OF DFHSMD
         LA    R1,HSMNAME            POINT R1 TO NAME OF HSM A/S
         BAS   R14,ASVTSCAN          LOCATE HSM ASID
         LA    R1,4
         ST    R1,RET_CODE
         LTR   R4,R0                 R4 = HSM ASID
         BNZ   HSMACT                CAN'T FIND HSM
         TPUT  MSG1,20
         B     EXIT
HSMACT   ST    R0,SAVEASID           SAVE ASID OF HSM
         XR    R1,R1                 ZERO RETCODE
         ST    R1,RET_CODE
* LOCATE THE  QCT
         L     R1,X'10'              CVT X'10' OFFSET FROM PSA
         USING CVT,R1                ADDRESS CVT DSECT
         L     R2,CVTHSM             HSM QCT ADDRESS
         DROP  R1
         ST    R2,SAVEQCT            SAVE QCT ADDRESS
         USING QCT,R2                ADDRESS QCT DSECT
         L     R1,MQCTESD            GET ESD ADDRESS
         ST    R1,SAVEESD            SAVE ESD ADDRESS
         L     R1,MQCTMCVT           GET CVT ADDRESS
         ST    R1,SAVECVT            SAVE CVT ADDRESS
         DROP  R2
* GET COPY OF MVCT
LOOP     EQU   *
         XR    R7,R7                 CLEAR R7
         LA    R6,L'COMMMCVT         TOTAL LENGTH TO MOVE
         SRDL  R6,8                  DIVIDE BY 256
         SRL   R7,24                 REMAINDER
         LA    R6,1(R6)              ADD ONE TO R6
         LTR   R7,R7                 IF R7 NOT ZERO ADD ONE MORE TO R6
         BZ    CMX002
         LA    R6,1(R6)              ADD ONE TO R6
CMX002   EQU   *
         L     R1,SAVECVT            MCVT ADDRESS TO BE DISPLAYED
         LA    R2,COMMMCVT           PUT IN COMMAREA FOR MVCT
         LA    R3,256                MAX LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         LA    R5,L'COMMMCVT         TOTAL LENGTH TO MOVE
CMX005   CR    R5,R3                 IF R5 > R3 CHANGE R3 TO R5 VALUE
         BH    CMX001
         LR    R3,R5
CMX001   EQU   *
         BCT   R6,CMX003             SAFETY LOOP CONTROL
         B     CMX004                R6 HITS ZERO LEAVE
CMX003   EQU   *
* LINK TO HSM$MON3 TO DO X MEMORY TO DF/HSM
         L     R15,HSM$MN3@               +----------+
         BALR  R14,R15  =================>|          |
*                                         | HSM$MON3 |
*                       <=================|          |
         DS    0H                         +----------+
         LA    R1,256(R1)            INCREMENT FROM ADDRESS
         LA    R2,256(R2)            INCREMENT TO ADDRESS
         SR    R5,R3                 DECREMENT REMAINING DATA COUNT
         BNZ   CMX005
CMX004   EQU   *
* LINK TO HSM$MON2
         L     R15,HSM$MN2@               +----------+
         BALR  R14,R15  =================>|          |
*                                         | HSM$MON2 |
         LTR   R15,R15  <=================|          |
         BZ    LOOP                       +----------+
         ST    R15,RET_CODE
         B     EXIT
* PROGRAM EXIT
EXIT     EQU      *
         FREEMAIN R,LV=PAGE,A=(R11)  FREE COMMUNICATION AREA
         LR       R1,R13             SAVE R13 FOR FREEMAIN
         L        R13,4(R13)         GET CALLERS SAVE AREA
         FREEMAIN R,LV=80,A=(R1)     FREE SAVEAREA
         L        R15,RET_CODE       GET RETURN CODE
         L        R14,12(R13)        RESTORE R14
         LM       R0,R12,20(R13)     RESTORE R0-R12
         BSM      0,R14              RETURN
* SUB ROUTINE
*     ASVTSCAN: SCAN ASVT CHAIN FOR ACTIVE JOB
* ON ENTRY:      R1  - ADDR OF JOBNAME
* ON RETURN:     R0  - ASCB ASID NUMBER
*                R15 - 0000 JOBNAME ACTIVE
*                    - 0004 JOBNAME INACTIVE
ASVTSCAN EQU   *
         STM   R0,R15,SAVEREGS       SAVE REGS
         LR    R2,R1                 JOB NAME ADDR
* SCAN ASVT FOR JOBNAME
         L     R1,CVTPTR             CVT X'10' OFFSET FROM PSA
         L     R8,CVTASVT-CVTMAP(R1) ASVT ADDRESS
         USING ASVT,R8
         L     R3,ASVTMAXU           TOTAL ASVT ENTRIES (3 CHAINS)
* CHAIN THROUGH ASVTS
         LA    R7,ASVTENTY-4         R7 POINTS TO ASID ENTRY
NEXTASVT EQU   *
         LA    R7,4(R7)                   POINT TO NEXT ENTRY
         CLC   =X'80000000',0(R7)         END OF ASVT CHAIN (3 CHAINS)
         BE    ENTRYEND                   IF SO, CONTINUE
         TM    0(R7),ASVTAVAL             TEST IF ASID ASSIGNED
         BNZ   ENTRYEND                   IF NOT, CONTINUE SEARCH
* ASSIGNED ASVT ENTRY CONTAINS ASCB ADDRESS
         L     R6,0(R7)                   IF ASSIGNED, ASCB ADDRESS
         USING ASCB,R6
         CLC   =C'ASCB',ASCBASCB          ASCB HEADER
         BNE   ENTRYEND                   IF NOT, INVALID ASCB
* ASCBJBNI=JOBNAME ADDR (JOB)
* ASCBJBNS=JOBNAME ADDR (STC/TSU)
         L     R5,ASCBJBNI                JOB NAME ADDR
         CLC   =F'0',ASCBJBNI             JOB NAME ADDRESS (JOB)
         BNE   ASCBGO                     IF SO, PROCESS JOBNAME
         L     R5,ASCBJBNS                STC/TSU NAME ADDR
         CLC   =F'0',ASCBJBNS             JOBNAME ADDRESS (STC/TSU)
         BNE   ASCBGO                     IF SO, PROCESS JOBNAME
         B     ENTRYEND                   IF NOT, INVALID ASCB
ASCBGO   EQU   *
* CHECK FOR JOBNAME MATCH
         XR    R0,R0
         LH    R0,ASCBASID                ASCB ASID NUMBER
         XR    R15,R15                    FLAG JOB ACTIVE
         CLC   0(8,R2),0(R5)              COMPARE JOBNAMES
         BE    ASVTJOBE                   IF SO, CONTINUE
ENTRYEND EQU   *
         BCT   R3,NEXTASVT                AND CONTINUE LOOPING
         XR    R0,R0                      FLAG JOB INACTIVE
         L     R15,=F'4'                  FLAG JOB INACTIVE
* TSB RECONNECT
ASVTJOBE EQU   *
         LM    R1,R14,SAVEREGS+4          RESTORE REGS
         BSM   0,R14                      RETURN
         DROP  R6                         ASCB
         DROP  R8                         ASVT
* END OF SUB-ROUTINE ASVTSCAN
SAVEREGS DS    16F
RET_CODE DS    F
MSG1     DS   0CL20
HSMNAME  DC    CL8'        '
         DC    CL12' NOT ACTIVE.'
         LTORG
         COPY  HSM$COMM
         COPY  HSM$QCT
         IHAASVT
ASCB     DSECT
         IHAASCB
         CVT   DSECT=YES
         END

HSM$MON2 SOURCE CODE

         TITLE    'HSM MONITOR , SCREEN DRIVER MODULE     '
         LCLC     &MODULE
&MODULE  SETC     'HSM$MON2'
&MODULE  CSECT
&MODULE  AMODE    31
&MODULE  RMODE    24
         STM      R14,R12,12(R13)    SAVE REGISTERS
         LR       R12,R15
         USING    &MODULE,R12
         B        *+28
         DC       CL8'&MODULE'
         DC       CL8'&SYSDATE'
         DC       CL8'&SYSTIME'
         GETMAIN  R,LV=80            GET A SAVEAREA
         ST       R13,4(R1)          BACKWARD CHAIN
         ST       R1,8(R13)          FORWARD CHAIN
         LR       R13,R1             SWAP SAVE AREAS
         L        R1,4(R13)
         LM       R0,R1,20(R1)       RESTORE PARM REGISTERS
* FORMAT THE DISPLAY
         USING  COMMAREA,R11
         LR     R10,R11
         USING  ARCMCVT,R10          MAP IT USING MCVT
         TM     FLAG,ISPF            INITS DONE?
         BO     SKIPIT               SKIP THEM IF DONE
         OI     FLAG,ISPF            FLAG THEM AS DONE
* LOAD ISPLINK MODULE
         LOAD  EP=ISPLINK
         ST    R0,ISPLINK@           SAVE ENTRY POINT ADDRESS
         LA    R1,LINELIST
         L     R15,ISPLINK@
         BALR  R14,R15
SKIPIT   EQU    *
         LA    R8,NUMBER_OF_LINES
         LA    R9,LINE06
CLRLOOP  MVI   0(R9),C'"'
         MVI   1(R9),C' '
         MVC   2(78,R9),1(R9)
         LA    R9,80(R9)
         BCT   R8,CLRLOOP
         ST    R8,COUNTER            RESET COUNTER
         MVI     MIGAUTO,GREEN
         MVI     MIGCOMD,GREEN
         MVI     RECALL,GREEN
         MVI     RECALL2,GREEN
         MVI     RECALLT,GREEN
         MVI     BACKRECV,GREEN
         MVI     BACKUP,GREEN
         MVI     LOGGING,GREEN
         MVI     JOURNAL,GREEN
         MVI     AUDIT,GREEN
         MVI     LIST,GREEN
         MVI     REPORT,GREEN
         MVI     RECYCLE,GREEN
         MVI     SECSPMG,GREEN
         MVI     TAPECOPY,GREEN
         MVI     TAPEREPL,GREEN
         MVI     RECVTAPE,GREEN
         MVI     BACKAUTO,GREEN
         MVI     DUMP,GREEN
         MVI     DUMPAUTO,GREEN
         TM      MCVTFLG2,MCVTFHRS         RECALL
         BNO     *+8
         MVI     RECALL,RED
         TM      MCVTFLG3,MCVTFHBU         BACK-UP/RECOVER
         BNO     *+8
         MVI     BACKRECV,RED
         TM      MCVTFLG3,MCVTFHLG         LOGGING
         BNO     *+8
         MVI     LOGGING,RED
         TM      MCVTFLG3,MCVTFJRN         JOURNALLING
         BO      *+8
         MVI     JOURNAL,RED
         TM      MCVTLCFL,MCVTFHAU         AUDIT
         BNO     *+8
         MVI     AUDIT,RED
         TM      MCVTLCFL,MCVTFHLT         LIST
         BNO     *+8
         MVI     LIST,RED
         TM      MCVTLCFL,MCVTFHRP         REPORT
         BNO     *+8
         MVI     REPORT,RED
         TM      MCVTLCFL,MCVTFHRY         RECYCLE
         BNO     *+8
         MVI     RECYCLE,RED
         TM      MCVTFLG2,MCVTFHMG         COMMAND MIGRATION?
         BNO     *+8
         MVI     MIGCOMD,RED
         TM      MCVTFLG2,MCVTFHAM         AUTO MIGRATION?
         BNO     *+8
         MVI     MIGAUTO,RED
         TM      MCVTFLG2,MCVTFHAM         SECONDRY SPACE MGMT
         BNO     *+8
         MVI     SECSPMG,RED
         TM      MCVTFDIS,MCVTFCTH         TAPECOPY
         BNO     *+8
         MVI     TAPECOPY,RED
         TM      MCVTFDIS,MCVTFCUH         TAPEREPL
         BNO     *+8
         MVI     TAPEREPL,RED
         TM      MCVTBCFL,MCVTBFEN         BACK-UP
         BO      *+8
         MVI     BACKUP,RED
         TM      MCVTBCFL,MCVTFHAB         AUTO BACK-UP
         BNO     *+8
         MVI     BACKAUTO,RED
         TM      MCVTTAPE,MCVTFHTR         TAPE RECOVERY
         BNO     *+8
         MVI     RECVTAPE,RED
         TM      MCVTTAPE,MCVTFHTS         TAPE RECALL
         BNO     *+8
         MVI     RECALL2,RED
         TM      MCVTTAPE,MCVTFHT1         TSO RECALL
         BNO     *+8
         MVI     RECALLT,RED
         TM      MCVTFLG6,MCVTFHDV
         BNO     *+8
         MVI     DUMP,RED
         TM      MCVTFLG6,MCVTFADV
         BNO     *+8
         MVI     DUMPAUTO,RED
         LA    R9,LINE06                   POINT TO OUT AREA
         LA    R8,NUMBER_OF_LINES
         TM      MCVTFLG6,MCVTFBEV
         BNO     TESTN01
         MVC     0(24,R9),=C'#BACKUP HELD AT EOV'
         BCTR    R8,0
         LA      R9,80(R9)
TESTN01  EQU     *
         TM      MCVTFLG6,MCVTFBEV
         BNO     TESTN02
         MVC     0(24,R9),=C'#AUTO-BACKUP HELD AT EOV'
         BCTR    R8,0
         LA      R9,80(R9)
TESTN02  EQU     *
         TM      MCVTFLG6,MCVTFGEV
         BNO     TESTN03
         MVC     0(24,R9),=C'#RECOVER HELD AT EOV    '
         BCTR    R8,0
         LA      R9,80(R9)
TESTN03  EQU     *
         TM      MCVTFLG6,MCVTFHDI
         BNO     TESTN04
         MVC     0(24,R9),=C'#DUMP HELD AT EOD/S     '
         BCTR    R8,0
         LA      R9,80(R9)
TESTN04  EQU     *
         TM      MCVTFLG6,MCVTFADI
         BNO     TESTN05
         MVC     0(24,R9),=C'#AUTO DUMP HELD AT EOD/S'
         BCTR    R8,0
         LA      R9,80(R9)
TESTN05  EQU     *
*     CHECK MWE QUEUE IN CSA
         MVC   STATUS(14),=C' CSA QUEUE    '
         MVI   ATTRIB,YELLOW
         L     R7,MCVTQCT
         USING QCT,R7
         ICM   R2,15,MQCTMWEH
         DROP  R7
         BZ    NOMWES
         LA    R0,1
         SVC   244
         MODESET KEY=ZERO,MODE=SUP
         OI    FLAG,AUTHDONE         FLAG AUTHORIZED
NEXTMWE  EQU   *
         LR    R1,R2                 MWE ADDRESS TO R1
         BAL   R14,FORMAT_MWE
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         LA    R9,80(R9)             POINT TO NEXT LINE
         MVI   0(R9),C'"'
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY               LEAVE IF ZERO
         ICM   R2,15,0(R2)           ANOTHER MWE
         BNZ   NEXTMWE               LOOP IF THERE IS ONE CHAINED
         MODESET KEY=NZERO,MODE=PROB
         LA    R0,2
         SVC   244
         NI    FLAG,255-AUTHDONE     UNFLAG AUTHORIZED
NOMWES   EQU   *
*     CHECK GENERAL MWE QUEUE
         MVI   ATTRIB,TURQOISE
         MVC   STATUS(14),=C' GENERAL QUEUE'
         ICM   R1,15,MCVTMWEH
         BZ    NEXTT1
NEXTMWE1 LA    R2,COMMMWE            PUT IN COMMAREA FOR MWE
         LA    R3,256                TOTAL LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         L     R15,HSM$MN3@
         BALR  R14,R15               GO DO XMEM
         LR    R1,R2
         BAL   R14,FORMAT_MWE
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         LA    R9,80(R9)
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY
         ICM   R1,15,0(R2)
         BNZ   NEXTMWE1
NEXTT1   EQU   *
*     CHECK OPERATOR MWE QUEUE
         MVC   STATUS(14),=C' OPERATOR QUE '
         MVI   ATTRIB,RED
         ICM   R1,15,MCVTOPQH
         BZ    NEXTT2
NEXTMWE2 LA    R2,COMMMWE            PUT IN COMMAREA FOR MWE
         LA    R3,256                TOTAL LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         L     R15,HSM$MN3@
         BALR  R14,R15               GO DO XMEM
         LR    R1,R2
         BAL   R14,FORMAT_MWE
         LA    R9,80(R9)
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY
         ICM   R1,15,0(R2)
         BNZ   NEXTMWE2
NEXTT2   EQU   *
*     CHECK RECALL MWE QUEUE
         MVI   ATTRIB,RED
         MVC   STATUS(14),=C' RECALL QUEUE '
         ICM   R1,15,MCVTRSQH
         BZ    NEXTT3
NEXTMWE3 LA    R2,COMMMWE            PUT IN COMMAREA FOR MWE
         LA    R3,256                TOTAL LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         L     R15,HSM$MN3@          GET XMEM MODULE ADDRESS
         BALR  R14,R15               GO DO XMEM
         LR    R1,R2
         BAL   R14,FORMAT_MWE
         LA    R9,80(R9)
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY
         ICM   R1,15,0(R2)
         BNZ   NEXTMWE3
NEXTT3   EQU   *
*     CHECK MIGRATE MWE QUEUE
         MVI   ATTRIB,RED
         MVC   STATUS(14),=C' MIGRATE QUEUE'
         ICM   R1,15,MCVTMGQH
         BZ    NEXTT4
NEXTMWE4 LA    R2,COMMMWE            PUT IN COMMAREA FOR MWE
         LA    R3,256                TOTAL LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         L     R15,HSM$MN3@
         BALR  R14,R15               GO DO XMEM
         LR    R1,R2
         BAL   R14,FORMAT_MWE
         LA    R9,80(R9)
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         LA    R14,1(R14)
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY
         ICM   R1,15,0(R2)
         BNZ   NEXTMWE4
NEXTT4   EQU   *
*     CHECK BACK-UP/RECOVER MWE QUEUE
         MVI   ATTRIB,RED
         MVC   STATUS(14),=C' BACKUP/RECV Q'
         ICM   R1,15,MCVTBUQH
         BZ    NEXTT5
NEXTMWE5 LA    R2,COMMMWE            PUT IN COMMAREA FOR MWE
         LA    R3,256                TOTAL LENGTH TO MOVE
         L     R4,SAVEASID           GET SAVED ASID
         L     R15,HSM$MN3@
         BALR  R14,R15               GO DO XMEM
         LR    R1,R2
         BAL   R14,FORMAT_MWE
         LA    R9,80(R9)
         L     R14,COUNTER
         LA    R14,1(R14)
         ST    R14,COUNTER
         BCT   R8,*+8                DEC LINE COUNT
         B     DISPLAY
         ICM   R1,15,0(R2)
         BNZ   NEXTMWE5
NEXTT5   EQU   *
DISPLAY  EQU     *
         ICM   R14,15,COUNTER
         BNZ   SOME_MWES
         MVC   0(24,R9),=C'$ ALL MWE QUEUES - EMPTY'
         MVI   80(R9),GRN
SOME_MWES EQU  *
         TM    FLAG,AUTHDONE
         BZ    ISP2
         MODESET KEY=NZERO,MODE=PROB
         LA    R0,2                  REMOVE AUTHORIZED MODE
         SVC   244
         NI    FLAG,255-AUTHDONE        FLAG AUTH OFF
ISP2     LA    R1,VPUTLIST
         L     R15,ISPLINK@             ISPF VPUT
         BALR  R14,R15
         LA    R1,DISPLIST              ISPF DISPLAY
         L     R15,ISPLINK@
         BALR  R14,R15
         ST    R15,RETCODE              RESTORE R14
         LR    R1,R13                   SAVE R13 FOR FREEMAIN
         L     R13,4(R13)               GET CALLER'S SAVE AREA
         FREEMAIN R,LV=80,A=(R1)        FREE MY SAVEAREA
         L     R14,12(R13)              RESTORE R14
         L     R15,RETCODE              RESTORE R14
         LM    R0,R12,20(R13)           RESTORE R0-R12
         BR    R14                      RETURN
*  FORMAT MESSAGE FROM MWE INFO
*  THIS SUBROUTINE DOES NOT CHANGE ANY REGISTERS
*  REG 1 = MWE ADDRESS
*  REG 9 = 80 BYTE MESSAGE AREA
FORMAT_MWE EQU *
         USING MWE,R1
         CLI   MWEFUNC,STARTUP
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'STARTUP '
         CLI   MWEFUNC,SHUTDOWN
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'SHUTDOWN'
         CLI   MWEFUNC,MIGRATE
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'MIGRATE '
         CLI   MWEFUNC,RECALLF
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'RECALL  '
         CLI   MWEFUNC,RECOVER
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'RECOVER '
         CLI   MWEFUNC,BACKUPF
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'BACKUP  '
         CLI   MWEFUNC,READMCD
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'MCD READ'
         CLI   MWEFUNC,COMMAND
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'COMMAND '
         CLI   MWEFUNC,POSTMWE
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'MWE POST'
         CLI   MWEFUNC,PURGEMWE
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'MWEPURGE'
         CLI   MWEFUNC,DELETMDS
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'HDELETE '
         CLI   MWEFUNC,AGREGBKP
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'AGREGBKP'
         CLI   MWEFUNC,AGREGREC
         BNE   *+10
         MVC   FUNCTION(L'FUNCTION),=C'AGREGREC'
         MVC   USERID(L'USERID),MWEUID
         CLI   MWEFUNC,COMMAND
         BE    DOCOMD
         MVC   DSNAME(L'DSNAME),MWEDSN
         B     FORMAT_END
DOCOMD   ST    R6,SAVER6             SAVE R6
         XR    R6,R6                 CLEAR
         LH    R6,MWECMDL            GET LENGTH OF COMMAND+4
         MVC   DSNAME(L'DSNAME),BLANKS CLEAR OUTPUT AREA
         S     R6,=F'5'              CORRECT LENGTH FOR MVC & -4
         C     R6,=F'44'             I WILL MOVE EITHER THE ENTIRE
         BNH   FORSKIP               COMMAND OR 44 BYTES OF IT, WHICH
         LA    R6,44                 EVER IS SHORTER.
FORSKIP  EX    R6,MVC1               MOVE COMMAND
         L     R6,SAVER6             RESTORE R6
FORMAT_END EQU *
         MVC   0(L'MSGMWE,R9),MSGMWE
         BR    R14
MVC1     MVC   DSNAME(*-*),MWECMDT
         DROP  R1
*  LITERALS AND MESSAGES
MSGMWE   DS  0CL80
ATTRIB   DC   CL1' '
FUNCTION DC   CL8' '
         DC   CL1' '
DSNAME   DC   CL44' '
         DC   XL5'4086969940'        ' FOR '
USERID   DC   CL7' '
         DC   CL1' '
STATUS   DC   CL14'      '
FLAG     DC   XL1'00'
ISPF     EQU  B'00000001'
AUTHDONE EQU  B'00000010'
PAGE     EQU  4096
NUMBER_OF_LINES EQU 16
BLANKS   DC   CL44' '
COUNTER  DC   F'0'
SAVER6   DS   F
RETCODE  DS   F
ISPLINK@ DS   F
         LTORG
*    COLOURS FOR DYNAMIC DISPLAY
RED      EQU   C'{'   REVERSE
YELLOW   EQU   C'}'   REVERSE
GREEN    EQU   C'>'   REVERSE
WHITE    EQU   C'<'   REVERSE
TURQOISE EQU   C'@'   REVERSE
PINK     EQU   C'#'   REVERSE
BLUE     EQU   C'$'   REVERSE
WHT      EQU   C'"'   NORMAL
GRN      EQU   C'^'   NORMAL
*  ISPF STUFF
         DS   0D
DISPLIST DS   0CL24
         DC    AL4(DISP_VA)
         DC    AL4(DISP_VB+X'80000000')
DISP_VA  DC    CL8'DISPLAY '
DISP_VB  DC    CL8'HSM$PANL'
VPUTLIST DS   0CL24
         DC    AL4(VPUT_VA)
         DC    AL4(VPUT_VB+X'80000000')
VPUT_VA  DC    CL8'VPUT'
VPUT_VB  DC    CL8'LINE'
LINELIST DS   0CL48
         DC    AL4(LINE_VV)
         DC    AL4(LINE_VN)
         DC    AL4(LINE)
         DC    AL4(LINE_VT)
         DC    AL4(LINE_VL+X'80000000')
LINE_VL  DC    AL4(L'LINE)
LINE_VV  DC    CL8'VDEFINE'
LINE_VN  DC    CL8'LINE'
LINE_VT  DC    CL8'CHAR'
LINE     DS   0CL1680
LINE01   DS   0CL80
RECALL   DC    CL20'>      RECALL       '
MIGCOMD  DC    CL20'> COMMAND MIGRATION '
AUDIT    DC    CL20'>       AUDIT       '
LIST     DC    CL20'>       LIST        '
LINE02   DS   0CL80
RECALL2  DC    CL20'>  RECALL FROM ML2  '
MIGAUTO  DC    CL20'>  PRIMARY SP/MGMT  '
REPORT   DC    CL20'>      REPORT       '
RECYCLE  DC    CL20'>     RECYCLE       '
LINE03   DS   0CL80
RECALLT  DC    CL20'>  RECALL FOR TSO   '
SECSPMG  DC    CL20'> SECONDARY SP/MGMT '
BACKRECV DC    CL20'>  BACKUP && RECOVER '
BACKUP   DC    CL20'>     BACKUP        '
LINE04   DS   0CL80
BACKAUTO DC    CL20'>   AUTO BACKUP     '
RECVTAPE DC    CL20'>   TAPE RECOVERY   '
DUMP     DC    CL20'>      DUMP         ' DUMP
LOGGING  DC    CL20'>     LOGGING       '
LINE05   DS   0CL80
TAPEREPL DC    CL20'>   TAPE REPLACE    '
TAPECOPY DC    CL20'>    TAPE COPY      '
DUMPAUTO DC    CL20'>    AUTO-DUMP      ' AUTODUMP
JOURNAL  DC    CL20'>    JOURNALING     '
LINE06   DC  16CL80'"                   '
         COPY  HSM$COMM
         COPY  HSM$MCVT
         COPY  HSM$QCT
         COPY  HSM$MWE
         END

HSM$MON3 SOURCE CODE

         TITLE    'HSM$MON3: CROSS MEMORY MODULE'
         LCLC     &MODULE
* USE CROSS MEMORY TO HSM ASID
* ON ENTRY: R1 = ADDRESS OF DATA TO BE RETRIEVED
*           R2 = ADDRESS OF WHERE DATA IS TO BE STORED
*           R3 = LENGTH OF DATA TO BE MOVED (256 MAX)
*           R4 = ASID OF SECONDARY ADDRESS SPACE
&MODULE  SETC     'HSM$MON3'
&MODULE  CSECT
&MODULE  AMODE    31
&MODULE  RMODE    24
         STM      R14,R12,12(R13)          SAVE REGISTERS
         LR       R12,R15
         USING    &MODULE,R12
         B        *+28
         DC       CL8'&MODULE'
         DC       CL8'&SYSDATE'
         DC       CL8'&SYSTIME'
         GETMAIN  R,LV=80                  GET A SAVEAREA
         ST       R13,4(R1)                BACKWARD CHAIN
         ST       R1,8(R13)                FORWARD CHAIN
         LR       R13,R1                   SWAP SAVE AREAS
         L        R1,4(R13)
         LM       R0,R1,20(R1)             RESTORE PARM REGISTERS
         LR    R6,R1
         LR    R8,R2                       TARGET ADDR
*   GET THIS A/S AUTHORIZED
         LA    R0,1
         SVC   244
*   GET INTO SUPERVISOR STATE AND KEY ZERO
         MODESET KEY=ZERO,MODE=SUP
*   GET DATA FROM SECONDARY ADDRESS SPACE
         L     R1,=F'1'
         AXSET AX=(R1)                   CMS AX=1
         ESAR  R1                        CURRENT SECONDARY ASID
         LR    R7,R1                     SAVE SECONDARY ASID
         SSAR  R4                        SET SEC ASID TO HSM ASID
         XR    R0,R0                     PKM = KEY 0 (BITS 24-27)
         MVCP  0(R3,R8),0(R6),R0         MVC FROM HSM ASID
         SSAR  R7                        SET SEC ASID TO SAVED ASID
         XR    R1,R1
         AXSET AX=(R1)                   CMS AX=0
*   GET OUT OF KEY ZERO AND SUPERVISOR STATE
         MODESET KEY=NZERO,MODE=PROB
*   GET OUT OF AUTH MODE
         LA    R0,2
         SVC   244
*   EXIT CODE
         LR       R1,R13                 SAVE R13 FOR FREEMAIN
         L        R13,4(R13)             GET CALLER'S SAVE AREA
         FREEMAIN R,LV=80,A=(R1)         FREE MY SAVEAREA
         LM       R14,R12,12(R13)        RESTORE R14-R12
         XR       R15,R15                SET RETCODE
         BR       R14                    RETURN
         END      &MODULE

HSM$SVC SOURCE CODE

         TITLE 'IGC0024D - AUTHORIZATION SVC 244'
*      REG 0 = 00000001    REQUEST AUTHORIZATION ON
*      REG 0 = 00000002    REQUEST AUTHORIZATION OFF
*               ANYTHING ELSE IS IGNORED
IGC0024D CSECT
         USING IGC0024D,R6               SET ADDRESSABILITY
         LA    15,8                      ERROR RET CODE
         C     0,ONE                     REQUEST AUTH ON
         BLR   14                        LESS THAN 1 IGNORED
         C     0,TWO                     REQUEST AUTH OFF
         BHR   14                        MORE THAN 2 IGNORED
         USING TCB,4                     ADDRESS TCB
         L     4,TCBRBP                  GET RB POINTER FROM TCB
         ICM   4,7,RBLINKB-RBBASIC(4)    CHAIN DOWN TO NEXT HIGHEST RB
         LA    2,RBOPSW+1-RBBASIC(,4)    POINT TO OLD PSW
         XR    15,15                     SET RET CODE = 0
         BCT   0,PROBSTAT
         NI    0(2),255-RBOPSWPS         SWITCH INTO SUPERVISOR STATE
         BR    14                        RETURN
PROBSTAT OI    0(2),RBOPSWPS             SWITCH INTO PROBLEM STATE
         BR    14                        RETURN
ONE      DC    F'1'
TWO      DC    F'2'
         IKJTCB LIST=YES                 TCB MAPPING MACRO
         IHARB  LIST=YES             RB MAPPING MACRO
         END   IGC0024D

HSM$COMM COPY BOOK

* ------------------------------------------------------------------
*  COMMAREA 4096 BYTES      ADDRESSED BY R11
* ------------------------------------------------------------------
COMMAREA DSECT
COMMMCVT DS    CL1268
COMMESD  DS    CL2064
COMMMWE  DS    CL0288
         DS    CL0452
SAVEQCT  DS    F                     SAVED ADDRESS OF QCT
SAVECVT  DS    F                     SAVED ADDRESS OF MVCT IN HSM A/S
SAVEESD  DS    F                     SAVED ADDRESS OF ESD IN HSM A/S
SAVEASID DS    F                     SAVED A/S ID FOR HSM A/S
HSM$MN2@ DS    F                     ADDRESS OF HSM$MON2 MODULE
HSM$MN3@ DS    F                     ADDRESS OF HSM$MON3 MODULE

HSM$CVT COPY BOOK

* ------------------------------------------------------------------
*  MCVT DSECT
* ------------------------------------------------------------------
ARCMCVT  DSECT
MCVT     DS   0XL1268
MCVTFLGS DS   0XL4
MCVTFLG1 DS    XL1
*        EQU   B'10000000'           RESERVED
MCVTFNLG EQU   B'01000000'
MCVTFSLG EQU   B'00100000'
MCVTFPLG EQU   B'00010000'
MCVTF1FT EQU   B'00001000'
MCVTFOPB EQU   B'00000100'
MCVTFINI EQU   B'00000010'
MCVTFATL EQU   B'00000001'
MCVTFLG2 DS    XL1
MCVTFMTO EQU   B'10000000'
MCVTFHMG EQU   B'01000000'
MCVTFHRS EQU   B'00100000'
MCVTFMTC EQU   B'00010000'
MCVTFCDO EQU   B'00001000'
MCVTFLSW EQU   B'00000100'
MCVTFEMG EQU   B'00000010'
MCVTFSVC EQU   B'00000001'
MCVTFLG3 DS    XL1
MCVTFHBU EQU   B'10000000'
MCVTFPBU EQU   B'01000000'
MCVTFBTO EQU   B'00100000'
MCVTFHLG EQU   B'00010000'
MCVTFBTC EQU   B'00001000'
MCVTNOCI EQU   B'00000100'
MCVTFFTO EQU   B'00000010'
MCVTFMVF EQU   B'00000010'
MCVTFJRN EQU   B'00000001'
MCVTFLG4 DS    XL1
MCVTFJRO EQU   B'10000000'
MCVTFJCI EQU   B'01000000'
MCVTFMSP EQU   B'00100000'
MCVTFMIP EQU   B'00010000'
MCVTFREQ EQU   B'00001000'
MCVTFNOL EQU   B'00000100'
MCVTFDMJ EQU   B'00000010'
MCVTFTPS EQU   B'00000001'
MCVTQCT  DS    AL4
MCVTCSP  DS    XL2
MCVTFLG5 DS    XL1
MCVTFSID EQU   B'10000000'
MCVTCVBK EQU   B'01000000'
MCVTCMDB EQU   B'00100000'
MCVTMBKF EQU   B'00010000'
MCVTBBKF EQU   B'00001000'
MCVTOBKF EQU   B'00000100'
MCVTJBKF EQU   B'00000010'
MCVTMRFF EQU   B'00000001'
MCVTRV   DS    XL1
MCVTVERS EQU   B'01011000'  260     3 BITS VVV 3 BITS RRR 2 BITS MM
MCVTCEP  DS    AL4
MCVTCIBP DS    AL4
MCVTLDCB DS    AL4
MCVTLBUF DS    AL4
MCVTSMDS DS    XL2
MCVTDCMP DS    XL1
MCVTCOMP DS    XL1
MCVTLECB DS    AL4
MCVTMWEH DS    AL4
MCVTMWET DS    AL4
MCVTDBUG DS    XL2
MCVTDBMV EQU   B'10000000'
         ORG   MCVT+52
MCVTOPQH DS    F
         ORG   MCVT+60
MCVTRSQH DS    F
         ORG   MCVT+68
MCVTMGQH DS    F
         ORG   MCVT+200
MCVTMCFL DS    XL1
MCVTFSDP EQU   B'01000000'
MCVTFHAM EQU   B'00100000'
MCVTJ3WT EQU   B'00010000'
MCVTFINT EQU   B'00001000'
MCVTFGMR EQU   B'00000100'
MCVTFIMR EQU   B'00000010'
MCVTRCFL DS    XL1
MCVTFRCV EQU   B'10000000'
MCVTFRPV EQU   B'01000000'
MCVTFHRX EQU   B'00100000'
MCVTBCFL DS    XL1
MCVTBFEN EQU   B'01000000'
MCVTFHAB EQU   B'00100000'
MCVTBFGB EQU   B'00010000'
MCVTFBTI EQU   B'00001000'
MCVTLCFL DS    XL1
MCVTFHAU EQU   B'10000000'
MCVTFHLT EQU   B'01000000'
MCVTFHRP EQU   B'00100000'
MCVTFHRY EQU   B'00010000'
MCVTFCBD EQU   B'00000100'
MCVTFCBT EQU   B'00000010'
MCVTFHOP EQU   B'00000001'
         ORG   MCVT+284
MCVTBUQH DS    XL4
         ORG   MCVT+643
MCVTFDIS DS    XL1
MCVTFCTH EQU   B'01000000'           1=TAPECOPY HELD
MCVTFCUH EQU   B'00100000'           1=TAPEREPL HELD
         ORG   MCVT+976
MCVTTAPE DS    XL1
MCVTFHTR EQU   B'00100000'           1=TAPE RECOVER HELD
MCVTFHTS EQU   B'00010000'           1=TAPE RECALL HELD
MCVTFHT1 EQU   B'00001000'           1=TSO RECALL HELD
MCVTFLG6 DS    XL1
MCVTFBEV EQU   B'10000000'           1=BACKUP HELD AT EOV
MCVTFABV EQU   B'01000000'           1=AUTO BACKUP HELD AT EOV
MCVTFGEV EQU   B'00100000'           1=RECOVER HELD AT EOV
MCVTFHDI EQU   B'00010000'           1=DUMP HELD AT EOD/S
MCVTFADI EQU   B'00001000'           1=AUTO/DUMP HELD AT EOD/S
MCVTFHDV EQU   B'00000100'           1=DUMP HELD AT EOV
MCVTFADV EQU   B'00000010'           1=AUTO/DUMP HELD AT EOV
* --------------------  END OF MCVT  ---------------------

HSM$MWE COPY BOOK

MWE      DSECT
MWEFWD   DS    F                     FORWARD POINTER
MWEBWD   DS    F                     BACKWARD POINTER
         ORG   MWE+24
MWEFUNC  DS    XL1                   FUNCTION BYTE
STARTUP  EQU   X'01'
SHUTDOWN EQU   X'02'
RECALLF  EQU   X'03'
RECOVER  EQU   X'05'
MIGRATE  EQU   X'06'
BACKUPF  EQU   X'07'
READMCD  EQU   X'08'
COMMAND  EQU   X'09'                 EXECUTE A HSM COMMAND
POSTMWE  EQU   X'0A'
PURGEMWE EQU   X'0B'
DELETMDS EQU   X'0C'                 DELETE MIGRATED DATASET
AGREGBKP EQU   X'0D'                 AGGREGATE BACKUP
AGREGREC EQU   X'0E'                 AGGREGATE RECOVER
         ORG   MWE+28
MWEUID   DS    XL7
         ORG   MWE+140
MWECMDL  DS    XL2                   COMMAND LENGTH
MWECMDO  DS    XL2                   TSO OFFSET
MWECMDT  DS    XL44                  COMMAND TEXT
         ORG   MWE+148
MWEDSN   DS    XL44

HSM$QCT COPY BOOK

* ------------------------------------------------------------------
*  QCT DSECT
* ------------------------------------------------------------------
ARCMQCT  DSECT
QCT      DS   0XL108
MQCTECBP DS    XL4   +0              ADDRESS OF HSM ECB
MQCTFLGS DS   0XL4   +4              HSM STATUS FLAGS
MQCTFLG1 DS    XL1   +4
MQCTFACT EQU   B'10000000'
MQCTJES3 EQU   B'01000000'
MQCTFRCV EQU   B'00100000'
MQCTJ3WT EQU   B'00010000'
MQCTFRPV EQU   B'00001000'
MQCTFHRX EQU   B'00000100'
MQCTNOPM EQU   B'00000010'
MQCTFNOL EQU   B'00000001'
MQCTFLG2 DS    XL1   +5
MQCTFAPU EQU   B'10000000'
MQCTJ25T EQU   B'01000000'
MQCTFLG3 DS    XL1   +6              RESERVED
MQCTFLG4 DS    XL1   +7              RESERVED
MQCTASCB DS    XL4   +8              ADDRESS OF HSM ASCB
MQCTMWEH DS    XL4   +C
MQCTRWET DS    XL4  +10
MQCTRQN  DS    XL4  +14
MQCTVOLL DS    XL4  +18
MQCTPDEQ DS   0CL8  +1C
MQCTPOOL DS    XL4  +1C
MQCTPLT  DS    XL4  +20
MQCTMCVT DS    AL4  +24              ADDRESS OF MCVT CONTROL BLOCK
MQCTESD  DS    AL4  +28              ADDRESS OF ARCESD MODULE
MQCTID   DS    CL4  +2C              CL4'QCT*'
MQCTVRM  DS   0CL4  +30
MQCTVER  DS    CL2  +30
MQCTREL  DS    CL1  +32
MQCTMOD  DS    CL1  +33
MQCTCSHL DS    XL4  +34
MQCTCSCU DS    XL4  +38
MQCTCSIL DS    XL2  +3C
MQCTCSAL DS    XL2  +3E
MQCTCSNL DS    XL2  +40
         DS    XL2  +42
MQCTT571 DS    XL8  +44
MQCTT581 DS    XL8  +4C
MQCTVOLP DS   0XL8  +54
MQCTVPOL DS    XL4  +54
MQCTVPLT DS    XL4  +58
MQCTINTS DS    XL8  +5C
MQCTEXPT DS    XL4  +64
MQCTRES1 DS    XL4  +68              RESERVED
*      USED BY AGGREGATE BACK-UP & RECOVERY
MQCTTSAS DS 0XL120  +6C              15 X 8 BYTE ARRAY
MQCTMASP DS    XL4  +6C
MQCTRES2 DS    XL4  +70              RESERVED
* ---- END OF QCT DEFINITIONS ---------------------------------------

HSM$PANL PANEL

)ATTR  DEFAULT(%+_)
    < TYPE(DATAOUT) COLOR(WHITE)  HILITE(REVERSE) INTENS(HIGH)
    > TYPE(DATAOUT) COLOR(GREEN)  HILITE(REVERSE) INTENS(LOW)
    { TYPE(DATAOUT) COLOR(RED)    HILITE(REVERSE) INTENS(HIGH)
    } TYPE(DATAOUT) COLOR(YELLOW) HILITE(REVERSE) INTENS(LOW)
    @ TYPE(DATAOUT) COLOR(TURQ)   HILITE(REVERSE) INTENS(LOW)
    # TYPE(DATAOUT) COLOR(PINK)   HILITE(REVERSE) INTENS(LOW)
    $ TYPE(DATAOUT) COLOR(BLUE)   HILITE(REVERSE) INTENS(LOW)
    " TYPE(DATAOUT) COLOR(WHITE)                  INTENS(HIGH)
    ^ TYPE(DATAOUT) COLOR(GREEN)                  INTENS(LOW)
    ! TYPE(TEXT)    COLOR(WHITE)  HILITE(REVERSE) INTENS(HIGH)
    | AREA(DYNAMIC)
)BODY
+COMMAND%===>_ZCMD                                                            +
!      &ZTIME                       HSM MONITOR                     &ZDATE
|LINE                                                                          |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
|                                                                              |
)END


John Hastewell
Senior Systems Programmer
AAMI (Australia)                                                                    c Xephon 1994

