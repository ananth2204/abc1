A dynamic allocation parameter list
The DYNALC macro will generate information to perform a dynamic allocation in an
Assembler program.  It will generate the SVC 99 request block pointer, the
request block, text pointer lists, and individual text units.  It was written to
simplify coding the dynamic allocation parameter list and to avoid constant
trips to the SPL: Job Management manual.  It provides descriptive names for
fields so that a dummy set of parameters may be generated and other values may
be moved into these fields at a later time.  For each text unit field, the label
generated is the same as labels generated by the IEFZB4D2 macro except that the
DAL prefix is dropped and a suffix is added to make each label unique.  The
suffix is generated automatically by the macro or it may be specified by the
SUFFIX keyword.  The Assembler macro variable SYSNDX will be used to generate
unique suffixes for each invocation of the macro, which would make it impossible
to code MVC instructions into fields.  Therefore the SUFFIX parameter may be
used to generate your own unique suffixes so that you may reference field names.
The value coded for SUFFIX may not exceed 3 bytes.  The macro expansion also
provides names for SVC 99 error and information codes for interrogation after
the SVC 99 instruction has been issued.  The labels generated for the SVC 99
request block are the same as those generated by the IEFZB4D0 macro except the
S99 prefix is dropped and a unique suffix is added as described above.
This macro supports most of the common dynamic allocation text units as well as
a few unusual ones.  It is quite easy to add other text units by following the
simple logic of the macro.  The macro also supports de-allocation through the
DEALLOC keyword.  Dynamic concatenation and de-concatenation are not supported
but can be added with a little effort.
To use the macro, code the macro call and the values you desire.  Note that the
macro expands into control blocks only so it may not be imbedded in any
executable code.  To use the generated parameter list, load general purpose
register 1 with the address of the parameter list and issue the SVC 99
instruction.  Since SVC 99 uses register 15 to give back a return code, you may
interrogate it to check for successful completion.  If register 15 is non-zero,
you may then check the error and information codes from the SVC 99 request block
for further information as to the error encountered.
Figure 1 shows the structure of the SVC 99 parameter list.  Register 1 points to
a request block pointer that has the address of the request block.  The request
block has the verb type (in this case dynamic allocation or de-allocation) and a
pointer to a list of text unit pointers.  The text pointers list points to
individual text units with the last text pointer’s high order bit being turned
on to indicate the end of the text pointer list.  The individual text units
contain a key denoting the type of text unit (like VOLUME, UNIT, or DSNAME), the
length of the parameter and the actual parameter.  Any number of text units may
be built and included in the text pointer list, subject to the rules of
compatibility as specified in the SPL: Job Management manual, such as retention
period (RETPD), which is mutually exclusive to the expiration date (EXPDT), and
SYSOUT (SYSOU) keys.
THE MACRO SOURCE CODE
***      USAGE -THIS MACRO MAY BE USED  MULTIPLE TIMES IN ONE       ***
*              PROGRAM AND GENERATE UNIQUE LABELS VIA THE 'SUFFIX'    *
*              PARAMETER.  PRIOR TO ISSUING SVC 99 REGISTER 1 MUST    *
*              CONTAIN THE ADDRESS OF   THIS PARAMETER LIST.          *
*              EX. -      PARMLIB   DYNALC DSNAME=SYS1.PARMLIB        *
*                                   ... ANY OTHER CODE                *
*                                   LA  R1,PARMLIB                    *
*                                   SVC 99                            *
*                                   ... ANY OTHER CODE                *
*        DEFAULTS -THERE ARE NO DEFAULTS FOR ANY PARM.  THE ONLY      *
*              PARMETERS THAT WILL BE GENERATED FOR DYNAMIC           *
*              ALLOCATION ARE THE ONES THAT ARE SPECIFICALLY CODED.   *
*              THE TYPE OF CALL TO DYNAMIC ALLOCATION DEFAULTS TO     *
*              ALLOCATION.  BY CODING IN A VALUE FOR DEALLOC, THE     *
*              PARAMETERS WILL DEALLOCATE THE RESOURCE INSTEAD OF     *
*              ALLOCATING IT.                                         *
*        LABELS - LABELS HAVE BEEN PROVIDED FOR OFTEN USED FIELDS.    *
*              FOR SVC 99 RB POINTER, THE LABELS GENERATED ARE THE    *
*              IEFZB4D0 MACRO LABEL MINUS THE S99 PREFIX AND SUFFIXED *
*              BY A UNIQUE 3 BYTE VALUE (AUTOMATICALLY SUPPLIED OR AS *
*              SPECIFIED BY 'SUFFIX=XXX'.  FOR EACH TEXT UNIT FIELD,  *
*              THE LABELS GENERATED ARE THE IEFZB4D2 MACRO LABEL      *
***            MINUS THE DAL PREFIX AND SUFFIXED AS SPECIFIED ABOVE.***
         MACRO
&NAME    DYNALC                                                        X
               &DSNAME=,       DATASET NAME               (1-44 BYTES) X
               &DDNAME=,       DDNAME                      (1-8 BYTES) X
               &MEMBER=,       MEMBER NAME/GDG NUMBER        "    "    X
               &STATUS=,       DATASET STATUS        (OLD/MOD/NEW/SHR) X
               &NDISP=,        DATASET NORMAL DISP   (KEEP/DELETE/ETC) X
               &CDISP=,        DATASET COND. DISP      "     "     "   X
               &TYPSP=,        TYPE SPACE            (CYL/TRK/BLKSIZE) X
               &PRIME=,        PRIMARY SPACE REQUIREMENT (ANY NUMERIC) X
               &SECND=,        SECONDARY SPACE REQUIREMENT      "      X
               &DIR=,          DIRECTORY BLOCKS OR INDEX SPACE  "      X
               &RLSE=,         RELEASE UNUSED SPACE        (ANY VALUE) X
               &SPFRM=,        SPACE FORM            (ALX/MXIG/CONTIG) X
               &ROUND=,        ROUND BLOCKS TO CYLINDERS   (ANY VALUE) X
               &VOLSER=,       VOLUME SERIAL               (1-6 BYTES) X
               &VOLCNT=,       VOLUME COUNT                    (1-255) X
               &UNIT=,         UNIT TYPE                   (1-8 BYTES) X
               &MSVGP=,        MSVGP GROUP                   "    "    X
               &SYSOUT=,       SYSOUT CLASS              (A-Z/0-9/ETC) X
               &SPGNM=,        SYSOUT PGM NAME             (1-8 BYTES) X
               &FORM=,         SYSOUT FORM NAME              "    "    X
               &OUTLIM=,       SYSOUT OUTPUT LIMIT       (ANY NUMERIC) X
               &FREE=,         FREE AT CLOSE                   (CLOSE) X
               &COPIES=,       SYSOUT NUMBER OF COPIES         (1-255) X
               &LABEL=,        LABEL TYPE           (SL/NL/AL/BLP/ETC) X
               &DSSEQ=,        DATASET SEQUENCE NUMBER   (TAPE FILE #) X
               &PASPR=,        PASSWORD PROTECTION               (R/W) X
               &EXPDT=,        EXPIRATION DATE                 (YYDDD) X
               &RETPD=,        RETENTION PERIOD          (ANY NUMERIC) X
               &DUMMY=,        DUMMY DATASET               (ANY VALUE) X
               &DCBDS=,        DSNAME OF MODEL DSCB           (DSNAME) X
               &DCBDD=,        DDNAME OF MODEL DSCB           (DDNAME) X
               &BLKSIZE=,      BLOCKSIZE                 (ANY NUMERIC) X
               &DEN=,          TAPE DENSITY                  (1/2/3/4) X
               &DSORG=,        DATASET ORG.         (PO/PS/DA/POU/ETC) X
               &EROPT=,        ERROR OPTIONS             (ABE/SKP/ACC) X
               &KEYLEN=,       KEY LENGTH                (ANY NUMERIC) X
               &LRECL=,        LOGICAL RECORD LENGTH          "        X
               &OPTCD=,        OPTION CODE                   (B/W/C/Z) X
               &RECFM=,        RECORD FORMAT       (F/FB/VB/VBA/U/ETC) X
               &PASSWRD=,      PASSWORD                    (1-8 BYTES) X
               &PERM=,         PERM ALLOC                  (ANY VALUE) X
               &RETDD=,        RETURN DDNAME                    "      X
               &RETDS=,        RETURN DSNAME                    "      X
               &RETVOL=,       RETURN VOLSER                    "      X
               &FUNC=,         FOR PUNCH OUTPUT INTERPRETING       (I) X
               &SUFFIX=,       UNIQUE SUFFIX FOR LABELS    (MAX LEN=3) X
               &DEALLOC=       FOR DEALLOCATION            (ANY VALUE)
         LCLA  &A1,&A2,&A3
         LCLC  &X,&NM
         AIF   (T'&SUFFIX EQ 'O').SETSFX
         AIF   (K'&SUFFIX GT 3).SFXERR
&X       SETC  '&SUFFIX'
         AGO   .CONT
.SFXERR  MNOTE 8,'SUFFIX=&SUFFIX LONGER THAN 3 BYTES, FIRST THREE USED'
&X       SETC  '&SUFFIX'(1,3)
         AGO   .CONT
.SETSFX  ANOP
&X       SETC  '&SYSNDX'(2,3)
.CONT    ANOP
         AIF   (T'&NAME NE 'O').SETRB
         MNOTE 8,'REQUIRED LABEL MISSING ON MACRO CALL'
.SETRB   ANOP
&NAME    DC    A(DYNRB&X+X'80000000') POINTER TO REQUEST BLOCK
         AIF   (T'&DEALLOC EQ 'O').ALOCCHK
DYNRB&X  DC    AL1(20,2,0,0)       LENGTH, DEALLOC VERB, FLAGS1
         AGO   .ERINCHK
.ALOCCHK ANOP
DYNRB&X  DC    AL1(20,1,0,0)       LENGTH, ALLOC VERB, FLAGS1
.ERINCHK ANOP
ERROR&X  DC    AL2(0)              ERROR CODE
INFO&X   DC    AL2(0)              INFORMATION CODE
TUPTR&X  DC    A(TXTPP&X),AL4(0,0) TEXT UNIT POINTER, RSVD, FLAGS2
&A1      SETA  1
         AIF   (T'&DDNAME EQ 'O').DSNCHK
         AIF   (K'&DDNAME GT 8).DDNERR
TS&X&A1  DC    XL2'01',AL2(1,8)    DDNAME KEY, NUM, PARMLEN
DDNAM&X  DC    CL8'&DDNAME'        DDNAME FIELD
&A1      SETA  &A1+1
         AGO   .DSNCHK
.DDNERR  MNOTE 8,'DDNAME=&DDNAME GREATER THAN 8 BYTES'
.DSNCHK  AIF   (T'&DSNAME EQ 'O').MEMCHK
         AIF   (K'&DSNAME GT 44).DSNERR
TS&X&A1  DC    XL2'02',AL2(1,44)   DSNAME KEY, NUM, PARMLEN
DSNAM&X  DC    CL44'&DSNAME'       DSNAME FIELD
&A1      SETA  &A1+1
         AGO   .MEMCHK
.DSNERR  MNOTE 8,'DSNAME=&DSNAME GREATER THAN 44 BYTES'
.MEMCHK  AIF   (T'&MEMBER EQ 'O').STATCHK
         AIF   (K'&MEMBER GT 8).MEMERR
TS&X&A1  DC    XL2'03',AL2(1,8)    MEMBER/GDG KEY, NUM, PARMLEN
MEMBR&X  DC    CL8'&MEMBER'        MEMBER NAME/GDG LEVEL FIELD
&A1      SETA  &A1+1        AGO   .STATCHK
.MEMERR  MNOTE 8,'MEMBER=&MEMBER GREATER THAN 8 BYTES'
.STATCHK AIF   (T'&STATUS EQ 'O').NDSPCHK
TS&X&A1  DC    XL2'04',AL2(1,1)    DATASET STATUS KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&STATUS' NE 'OLD').STA1CHK  OLD = X'01'
STATS&X  DC    XL1'01'             CONSTANT FOR DISP=OLD
         AGO   .NDSPCHK
.STA1CHK AIF   ('&STATUS' NE 'MOD').STA2CHK  MOD = X'02'
STATS&X  DC    XL1'02'             CONSTANT FOR DISP=MOD
         AGO   .NDSPCHK
.STA2CHK AIF   ('&STATUS' NE 'NEW').STA3CHK  NEW = X'04'
STATS&X  DC    XL1'04'             CONSTANT FOR DISP=NEW
         AGO   .NDSPCHK
.STA3CHK AIF   ('&STATUS' NE 'SHR').STAERR   SHR = X'08'
STATS&X  DC    XL1'08'             CONSTANT FOR DISP=SHR
         AGO   .NDSPCHK
.STAERR  MNOTE 8,'STATUS=&STATUS INVALID'
.NDSPCHK AIF   (T'&NDISP EQ 'O').CDSPCHK
TS&X&A1  DC    XL2'05',AL2(1,1)    NORMAL DISP KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&NDISP' NE 'UNCATLG').NDS1CHK UNCATLG = X'01'
NDISP&X  DC    XL1'01'             CONSTANT FOR NORMAL DISP=UNCATLG
         AGO   .CDSPCHK
.NDS1CHK AIF   ('&NDISP' NE 'CATLG').NDS2CHK CATLG   = X'02'
NDISP&X  DC    XL1'02'             CONSTANT FOR NORMAL DISP=CATLG
         AGO   .CDSPCHK
.NDS2CHK AIF   ('&NDISP' NE 'DELETE').NDS3CHK DELETE = X'04'
NDISP&X  DC    XL1'04'             CONSTANT FOR NORMAL DISP=DELETE
         AGO   .CDSPCHK
.NDS3CHK AIF   ('&NDISP' NE 'KEEP').NDSERR   KEEP    = X'08'
NDISP&X  DC    XL1'08'             CONSTANT FOR NORMAL DISP=KEEP
         AGO   .CDSPCHK
.NDSERR  MNOTE 8,'NDISP=&NDISP INVALID'
.CDSPCHK AIF   (T'&CDISP EQ 'O').TSPCCHK
TS&X&A1  DC    XL2'06',AL2(1,1)    COND DISP KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&CDISP' NE 'UNCATLG').CDS1CHK UNCATLG = X'01'
CDISP&X  DC    XL1'01'             CONSTANT FOR COND DISP=UNCATLG
         AGO   .TSPCCHK
.CDS1CHK AIF   ('&CDISP' NE 'CATLG').CDS2CHK   CATLG   = X'02'
CDISP&X  DC    XL1'02'             CONSTANT FOR COND DISP=CATLG
         AGO   .TSPCCHK
.CDS2CHK AIF   ('&CDISP' NE 'DELETE').CDS3CHK  DELETE  = X'04'
CDISP&X  DC    XL1'04'             CONSTANT FOR COND DISP=DELETE
         AGO   .TSPCCHK
.CDS3CHK AIF   ('&CDISP' NE 'KEEP').CDSERR     KEEP    = X'08'
CDISP&X  DC    XL1'08'             CONSTANT FOR COND DISP=KEEP
         AGO   .TSPCCHK
.CDSERR  MNOTE 8,'CDISP=&CDISP INVALID'
.TSPCCHK AIF   (T'&TYPSP EQ 'O').PSPCCHK
         AIF   ('&TYPSP' NE 'TRK').TSP1CHK IF TYPE SPACE SPECIFICATION
TS&X&A1  DC    XL2'07',AL2(0)      TRACK SPACE KEY, NUM
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TSP1CHK AIF   ('&TYPSP' NE 'CYL').TSP2CHK  NOT TRK OR CYL THEN
TS&X&A1  DC    XL2'08',AL2(0)      CYLINDER SPACE KEY, NUM
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TSP2CHK AIF   (T'&TYPSP NE 'N').TYPERR
&A3      SETA  &TYPSP
         AIF   (&A3 GT 32768).TYPERR
TS&X&A1  DC    XL2'09',AL2(1,3)    BLOCK SPACE KEY, NUM, PARMLEN
BLKLN&X  DC    AL3(&TYPSP)         AVG BLOCK LENGTH FIELD
&A1      SETA  &A1+1
         AGO   .PSPCCHK
.TYPERR  MNOTE 8,'TYPSP=&TYPSP INVALID OR GREATER THAN 32768'
.PSPCCHK AIF   (T'&PRIME EQ 'O').DIRCCHK
         AIF   (T'&PRIME NE 'N').PSPCERR
TS&X&A1  DC    XL2'0A',AL2(1,3)    PRIME SPACE KEY, NUM, PARMLEN
PRIME&X  DC    AL3(&PRIME)         PRIMARY SPACE FIELD
&A1      SETA  &A1+1
         AGO   .SSPCCHK
.PSPCERR MNOTE 8,'PRIME=&PRIME INVALID'
.SSPCCHK AIF   (T'&SECND EQ 'O').DIRCCHK
         AIF   (T'&SECND NE 'N').SSPCERR
TS&X&A1  DC    XL2'0B',AL2(1,3)    SECONDARY SPACE, NUM, PARMLEN
SECND&X  DC    AL3(&SECND)         SECONDARY SPACE FIELD
&A1      SETA  &A1+1
         AGO   .DIRCCHK
.SSPCERR MNOTE 8,'SECND=&SECND INVALID'
.DIRCCHK AIF   (T'&DIR EQ 'O').RLSECHK
         AIF   (T'&DIR NE 'N').DIRCERR
TS&X&A1  DC    XL2'0C',AL2(1,3)    DIR SPACE KEY, NUM, PARMLEN
DIR&X    DC    AL3(&DIR)           DIR SPACE FIELD
&A1      SETA  &A1+1
         AGO   .RLSECHK
.DIRCERR MNOTE 8,'DIR=&DIR INVALID'
.RLSECHK AIF   (T'&RLSE EQ 'O').FMSPCHK
TS&X&A1  DC    XL2'0D',AL2(0)      RELEASE SPACE KEY, NUM
&A1      SETA  &A1+1
.FMSPCHK AIF   (T'&SPFRM EQ 'O').RNDCHK
TS&X&A1  DC    XL2'0E',AL2(1,1)    SPACE FORM KEY, NUM, PARMLEN
&A1      SETA  &A1+1
         AIF   ('&SPFRM' NE 'ALX').FMS1CHK
SPFRM&X  DC    XL1'02'             ALX SPACE FORM FIELD
         AGO   .RNDCHK
.FMS1CHK AIF   ('&SPFRM' NE 'MXIG').FMS2CHK
SPFRM&X  DC    XL1'04'             MXIG SPACE FORM FIELD
         AGO   .RNDCHK
.FMS2CHK AIF   ('&SPFRM' NE 'CONTIG').FMSERR
SPFRM&X  DC    XL1'02'             CONTIG SPACE FORM FIELD
         AGO   .RNDCHK
.FMSERR  ANOP
         MNOTE 8,'SPFRM=&SPFRM INVALID'
.RNDCHK  AIF   (T'&ROUND EQ 'O').VSERCHK
TS&X&A1  DC    XL2'0F',AL2(0)      ROUND KEY, NUM
&A1      SETA  &A1+1
.VSERCHK AIF   (T'&VOLSER EQ 'O').VLCNCHK
         AIF   (K'&VOLSER GT 6).VLSRERR
TS&X&A1  DC    XL2'10',AL2(1,6)    VOLSER KEY, NUM, PARMLEN
VLSER&X  DC    CL6'&VOLSER'        VOLUME SERIAL FIELD
&A1      SETA  &A1+1
         AGO   .VLCNCHK
.VLSRERR MNOTE 8,'VOLSER=&VOLSER GREATER THAN 6 BYTES'
.VLCNCHK AIF   (T'&VOLCNT EQ 'O').UNITCHK
         AIF   (T'&VOLCNT NE 'N').VLCERR
&A3      SETA  &VOLCNT
         AIF   (&A3 GT 255).VLCERR
TS&X&A1  DC    XL2'13',AL2(1,1)    VOLUME COUNT KEY, NUM, PARMLEN
VLCNT&X  DC    AL1(&VOLCNT)        VOLUME COUNT FIELD
&A1      SETA  &A1+1
         AGO   .UNITCHK
.VLCERR  MNOTE 8,'VOLCNT=&VOLCNT IS INVALID OR GREATER THAN 255'
.UNITCHK AIF   (T'&UNIT EQ 'O').SCLSCHK
TS&X&A1  DC    XL2'15',AL2(1,8)    UNIT TYPE KEY, NUM, PARMLEN
UNIT&X   DC    CL8'&UNIT'          UNIT TYPE FIELD
&A1      SETA  &A1+1
.SCLSCHK AIF   (T'&SYSOUT EQ 'O').SYSPCHK
TS&X&A1  DC    XL2'18',AL2(1,1)    SYSOUT CLASS KEY, NUM, PARMLEN
SYSOU&X  DC    CL1'&SYSOUT'        SYSOUT CLASS FIELD
&A1      SETA  &A1+1
.SYSPCHK AIF   (T'&SPGNM EQ 'O').FORMCHK
         AIF   (K'&SPGNM GT 8).SYSPERR
TS&X&A1  DC    XL2'19',AL2(1,8)    SYSOUT PGM KEY, NUM, PARMLEN
SPGNM&X  DC    CL8'&SPGNM'         SYSOUT PGM FIELD
&A1      SETA  &A1+1
         AGO   .FORMCHK
Bruce Bordonaro
System Software Manager
EDS (USA) © EDS 1988



























