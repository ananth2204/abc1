IOQ scanner (continued)

This month we conclude our look at an IOQ scanner with the
publication of the remaining components of the system
described in last month's issue.


VTOCX SOURCE CODE

*====================================================================*
*                   A T T R I B U T E S                              *
* VTOCX     AC(0),AMODE(24),RMODE(24)                                *
*====================================================================*
*            P R O G R A M  D E S C R I P T I O N                    *
* INVOCATION: Called as a REXX external function. It has three       *
*             functions. They can be invoked as follows:             *
*              1. handle = VTOCX('GETVTOC ')                         *
*              2. dsn = VTOCX('GETDSN  ',handle,cchh)                *
*              3. x = VTOCX('FREEVTOC',handle)                       *
*             Where: handle - is an address returned by VTOCX        *
*                    cchh   - is a hex word containing cchh on DASD. *
* FUNCTION  : The 1st invocation above will cause a VTOC of the      *
*             volser allocated to DDname VOLUME to be loaded         *
*             into storage. A 'handle' is returned, which must be    *
*             used for all subsequent calls for the same volser.     *
*             Before this invocation is made you must have allocated *
*             the volser to DDname VOLUME as follows:                *
*              ALLOC FI(VOLUME) DA(_a_temporary_dsn_) NEW DELETE +   *
*                    VOL(volser) UNIT(DASD)                          *
*             The 2nd invocation will return the dataset name        *
*             located at the specified CCHH on the DASD indicated by *
*             the 'handle'. (NOTE: The CCHH is compared to the 1st   *
*             3 extents of each dataset on the DASD - if the CCHH is *
*             not in up to 16 extents, then 'unknown dataset' is     *
*             returned - this code could be modified to compare CCHH *
*             with all extents of dataset.)                          *
*             The 3rd call will free up the storage associated       *
*             with the VTOC referenced via the specified 'handle'.   *
*====================================================================*
VTOCX    CSECT
         SAVE (14,12),,'VTOCX.&SYSDATE..IOQ External REXX Function'
         BALR R12,0
         USING *,R12
         LA   R2,SAVE                   ->My savearea
         ST   R13,4(R2)                 - Save caller's savearea addr
         ST   R2,8(R13)                 - My savearea addr in caller's
         LR   R13,R2                    ->My savearea
*               Mainline code                                        *
         LR  R7,R1                        Get the EFPL pointer
* Get 1st parameter (request)
         USING EFPL,R7
         L   R1,EFPLARG                 ->Argument list
         L   R2,0(R1)                   ->1st parameter addr
         L   R1,4(R1)                     Length of 1st parm
         C   R1,=F'8'                     Length of req = 8?
         BNE ERROR
         CLC GETVTOC,0(R2)                GETVTOC request?
         BE  GVTOC
         CLC GETDSN,0(R2)                 GETDSN request?
         BE  GDSN
         CLC FREVTOC,0(R2)                FREEVTOC request?
         BE  FVTOC
         B   ERROR
GVTOC    DS  0H
         GETMAIN R,LV=HANLEN              Get a handle area
         ST  R1,HANDLE                    Save the handle
         LR  R8,R1                        Get the handle area
         USING HANMAP,R8                  Map handle area
         LH  R1,=H'-1'
         STH R1,PARM1                     Set up parms for VTOCRD2
         LA  R3,PARM1
         LA  R4,PARM2
* Call VTOCRD2 to read requested DASD's VTOC into storage
         LINK EP=VTOCRD2,PARAM=((R3),(R4))    Link to VTOCRD2
         DROP R8
* Return the handle for the in-storage VTOC
         USING EFPL,R7
         L   R1,EFPLEVAL                      EVAL block addr pointer
         L   R7,0(R1)                         EVAL block addr
         DROP R7
         USING EVALBLOCK,R7                   Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'HANDLE)    Set the length
         LA   R1,L'HANDLE                     Get the length
         BCT  R1,*+10                         Dec and branch
         MVC  EVALBLOCK_EVDATA(0),HANDLE      Dummy move
         EX   R1,*-6                          Real move
         B   BYEBYE
FVTOC    DS  0H
* Get 2nd parameter (handle)
         USING EFPL,R7                    Address the EFPL
         L   R1,EFPLARG                   Get the arg list address
         L   R2,8(R1)                     Get the arg 2nd address
         L   R1,12(R1)                    Get the param length
         L   R8,0(R2)                     Keep the handle
         USING HANMAP,R8                  Map the handle
         L   R2,VTOCADDR                  Get address of area to free
         L   R3,TOTLEN                    Length of result area
         FREEMAIN R,LV=(R3),A=(R2)        Free the VTOC result area
         DROP R8
         FREEMAIN R,LV=HANLEN,A=(R8)      Free the handle area
* Return a value of zero - In-storage VTOC released
         USING EFPL,R7
         L   R1,EFPLEVAL                  EVAL block addr pointer
         L   R7,0(R1)                     EVAL block addr
         DROP R7
         USING EVALBLOCK,R7               Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'ZERO)  Set the length
         LA   R1,L'ZERO                   Get the length
         BCT  R1,*+10                     Dec and branch
         MVC  EVALBLOCK_EVDATA(0),ZERO    Dummy move
         EX   R1,*-6                      Real move
         B   BYEBYE
GDSN     DS  0H
* Get the 2nd parameter (handle)
         USING EFPL,R7                    Address the EFPL
         L   R1,EFPLARG                   Get the arg list address
         L   R2,8(R1)                     Get the 2nd arg address
         L   R1,12(R1)                    Get the param length
         L   R8,0(R2)                     Keep the handle
         USING HANMAP,R8                  Map the handle
* Get the 3rd parameter (CCHH)
         USING EFPL,R7                    Address the EFPL
         L   R1,EFPLARG                   Get the arg list address
         L   R2,16(R1)                    Get the 3rd arg addr
         L   R1,20(R1)                    Get the param length
         MVC CCHH,0(R2)                   Move in the CCHH value
* Search the VTOC for dataset that contains specified CCHH
         L    R3,VTOCADDR                 VTOC result area
         L    R4,VTOCOFF                  Offset to start of VTOC
         AR   R3,R4                       Actual address of VTOC
         L    R4,DSCBNUM                  Number of
LOOP     LA   R5,8(0,R3)                ->DSCB
         CLI  44(R5),X'F1'                Is it a FMT1 DSCB?
         BE   EXT1                        Yes, carry on
         CLI  44(R5),X'F4'                Is it a FMT4 (VTOC) DSCB?
         BNE  NEXT                        No, check next DSCB
EXT1     CLC  CCHH,107(R5)                Is cchh >= 1st ext start?
         BL   EXT2                        No, check with 2nd extent
         CLC  CCHH,111(R5)                Is cchh <= 1st ext end?
         BNH  FOUND                       Dataset found!
EXT2     CLC  CCHH,117(R5)                Is cchh >= 2nd ext start?
         BL   EXT3                        No, check with 3rd extent
         CLC  CCHH,121(R5)                Is cchh <= 2nd ext end?
         BNH  FOUND                       Dataset found!
EXT3     CLC  CCHH,127(R5)                Is cchh >= 3rd ext start?
         BL   CHKFMT3                     No, dataset not found
         CLC  CCHH,131(R5)                Is cchh <= 3rd ext end?
         BNH  FOUND                       Dataset found!
CHKFMT3  MVC  F3DSCB,135(R5)              Save PTR to F2/F3 DSCB
         CLC  F3DSCB,=X'0000000000'       Any PTR to F2/F3 DSCB?
         BE   NEXT                        No, dataset not found
*   Check any FMT3 DSCB for additional extents
         L    R6,VTOCADDR                 VTOC result area
         L    R9,VTOCOFF                  Offset to start of VTOC
         AR   R6,R9                       Actual address of VTOC
         L    R9,DSCBNUM                  Number of DSCBs
LOOP2    LR   R10,R6                    ->DSCB
         CLC  F3DSCB,0(R10)               Matching CCHHR?
         BNE  NEXT2                       No, Check with next DSCB
         CLI  52(R10),X'F3'               Is it a FMT3 DSCB?
         BNE  NEXT2                       No, Check next DSCB
EXT4     CLC  CCHH,14(R10)                Is cchh >= 4th ext start?
         BL   EXT5                        No, check with 5th extent
         CLC  CCHH,18(R10)                Is cchh <= 4th ext end?
         BNH  FOUND                       Dataset found!
EXT5     CLC  CCHH,24(R10)                Is cchh >= 5th ext start?
         BL   EXT6                        No, check with 6th extent
         CLC  CCHH,28(R10)                Is cchh <= 5th ext end?
         BNH  FOUND                       Dataset found!
EXT6     CLC  CCHH,34(R10)                Is cchh >= 6th ext start?
         BL   EXT7                        No, dataset not found
         CLC  CCHH,38(R10)                Is cchh <= 6th ext end?
         BNH  FOUND                       Dataset found!
EXT7     CLC  CCHH,44(R10)                Is cchh >= 7th ext start?
         BL   EXT8                          No, dataset not found
         CLC  CCHH,48(R10)                  Is cchh <= 7th ext end?
         BNH  FOUND                         Dataset found!
EXT8     CLC  CCHH,55(R10)                  Is cchh >= 8th ext start?
         BL   EXT9                          No, dataset not found
         CLC  CCHH,59(R10)                  Is cchh <= 8th ext end?
         BNH  FOUND                         Dataset found!
EXT9     CLC  CCHH,65(R10)                  Is cchh >= 9th ext start?
         BL   EXT10                         No, dataset not found
         CLC  CCHH,69(R10)                  Is cchh <= 9th ext end?
         BNH  FOUND                         Dataset found!
EXT10    CLC  CCHH,75(R10)                  Is cchh >= 10th ext start?
         BL   EXT11                         No, dataset not found
         CLC  CCHH,79(R10)                  Is cchh <= 10th ext end?
         BNH  FOUND                         Dataset found!
EXT11    CLC  CCHH,85(R10)                  Is cchh >= 11th ext start?
         BL   EXT12                         No, dataset not found
         CLC  CCHH,89(R10)                  Is cchh <= 11th ext end?
         BNH  FOUND                         Dataset found!
EXT12    CLC  CCHH,95(R10)                  Is cchh >= 12th ext start?
         BL   EXT13                         No, dataset not found
         CLC  CCHH,99(R10)                  Is cchh <= 12th ext end?
         BNH  FOUND                         Dataset found!
EXT13    CLC  CCHH,105(R10)                 Is cchh >= 13th ext start?
         BL   EXT14                         No, dataset not found
         CLC  CCHH,109(R10)                 Is cchh <= 13th ext end?
         BNH  FOUND                         Dataset found!
EXT14    CLC  CCHH,115(R10)                 Is cchh >= 14th ext start?
         BL   EXT15                         No, dataset not found
         CLC  CCHH,119(R10)                 Is cchh <= 14th ext end?
         BNH  FOUND                         Dataset found!
EXT15    CLC  CCHH,125(R10)                 Is cchh >= 15th ext start?
         BL   EXT16                         No, dataset not found
         CLC  CCHH,129(R10)                 Is cchh <= 15th ext end?
         BNH  FOUND                         Dataset found!
EXT16    CLC  CCHH,135(R10)                 Is cchh >= 16th ext start?
         BL   NEXT (Not NEXT2!)             No, dataset not found
         CLC  CCHH,139(R10)                 Is cchh <= 16th ext end?
         BNH  FOUND                         Dataset found!
NEXT2    DS   0H
         LA   R6,148(0,R6)                ->Next DSCB
         BCT  R9,LOOP2                      LOOP if more DSCBs
         B    NEXT (Not NEXT2!)             No, dataset not found
         DROP R8
* End of code to search match in FMT3 DSCB
FOUND    DS   0H
         CLI  44(R5),X'F4'                  Is it a FMT4 (VTOC) DSCB?
         BE   VTOCDSN                       Yes, indicate VTOC
         MVC  DSN,0(R5)                     Get dataset name
         B    RETDSN
VTOCDSN  MVC  DSN,VTOC                      Set DSN = VTOC'
         B    RETDSN
NEXT     DS   0H
         LA   R3,148(0,R3)              ->Next DSCB
         BCT  R4,LOOP                     LOOP if more DSCBs
NOTFND   MVC  DSN,NODSN                   CCHH not found
* Return the dataset name at CCHH supplied
RETDSN   DS   0H
         USING EFPL,R7
         L   R1,EFPLEVAL                  EVAL block addr pointer
         L   R7,0(R1)                     EVAL block addr
         DROP R7
         USING EVALBLOCK,R7               Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'DSN)   Set the length
         LA   R1,L'DSN                    Get the length
         BCT  R1,*+10                     Dec and branch
         MVC  EVALBLOCK_EVDATA(0),DSN     Dummy move
         EX   R1,*-6                      Real move
         B   BYEBYE
* Return request error message to calling REXX
ERROR    DS  0H
         USING EFPL,R7
         L   R1,EFPLEVAL                  EVAL block addr pointer
         L   R7,0(R1)                     EVAL block addr
         DROP R7
         USING EVALBLOCK,R7               Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'REQERR) Set the length
         LA   R1,L'REQERR                 Get the length
         BCT  R1,*+10                     Dec and branch
         MVC  EVALBLOCK_EVDATA(0),REQERR  Dummy move
         EX   R1,*-6                      Real move
*               Return to caller                                     *
BYEBYE   L   R13,SAVE+4                 ->Caller's savearea
         RETURN (14,12),RC=0            - RETURN WITH RC IN R15
*               Save/Workarea                                        *
*---------------------------------------- Register Savearea ---------*
SAVE     DS   0F
         DC   C'PL1 PSA NSA RET EP  R0  R1  R2  R3  '
         DC   C'R4  R5  R6  R7  R8  R9  R10 R11 R12 '
*---------------------------------------- Misc Constants ------------*
FREVTOC  DC   CL8'FREEVTOC'
GETVTOC  DC   CL8'GETVTOC '
GETDSN   DC   CL8'GETDSN  '
REQERR   DC   CL8'REQERR  '
NODSN    DC   CL44'*----Unknown-DS----* '
VTOC     DC   CL44'*----VTOC----* '
ZERO     DC   F'0'
HANDLE   DS   F                           Handle of this screen
CCHH     DS   F                           CCHH of required dataset
DSN      DS   CL44                        Dataset name
WORKAREA DS   D                           Workarea for pack
F3DSCB   DS   CL5                         Possible PTR to F2/F3 DSCB
         LTORG
*               Macros/DSECTs                                        *
HANMAP   DSECT
PARM1    DS   H                           Non-zero parm for VTOCRD2
PARM2    DS   0F                          Start of 2nd parm
VTOCADDR DS   F                           Address of VTOCRD2 result
VTOCOFF  DS   F                           Offset to VTOC in result
DSCBNUM  DS   F                           Number of count+DSCBs
TOTLEN   DS   F                           Length of result area
HANLEN       EQU *-HANMAP
         IRXEFPL
         IRXEVALB
         END


service routine to read requested VTOC into storage

         TITLE 'VTOCRD2 - READS THE VTOC OF DASD'
*====================================================================*
*                   A T T R I B U T E S                              *
* VTOCRD2  AC(0),AMODE(24),RMODE(24)                                 *
*            P R O G R A M  D E S C R I P T I O N                    *
* FUNCTION: This program dumps the VTOC on a CKD device a CYL at a   *
*           time. A 2 CYL VTOC can be read in about 1 sec. The data  *
*           can then be written to a PS file or kept in memory for   *
*           later use.                                               *
* INFO    : This program used ENQs on the VTOC. Hence, required APF  *
*           authorization. The ENQ code has been removed. This means *
*           that the VTOC may then be updated during read by some    *
*           other task.                                              *
*           The VTOC's extent info is obtained from the DEB. Instead,*
*           the F4 record could be read for the extent information,  *
*           but this wastes further I/O. (Open will read the F4      *
*           record to get this.) The F4 record also provides the     *
*           CCHHR of the last F1 record, but this is set to the last *
*           physical block if the VTOC is indexed. Since the program *
*           should encounter a non-indexed VTOC rarely, we don't get *
*           the F4 record but just read the VTOC straight away.      *
*           This program does not use the SET SECTOR command         *
*           available with later-model DASD, in order to make it more*
*           generic. The program can be called in two ways:          *
*            1. In batch, in which case no JCL PARM= info should be  *
*               supplied, or                                         *
*            2. As a subroutine, in which case the parmlist must be  *
*               of the following form:                               *
*                 R1->PTR0->Half-word (non-zero) value               *
*                     PTR1->4 full words, which at the end of the    *
*                           subroutines' execution will contain:     *
*                           WORD0:Addr in memory of the channel pgm  *
*                                 & dumped VTOC                      *
*                           WORD1:Length of offset w/in memory to    *
*                                 result (VTOC)                      *
*                           WORD2:Total num of (COUNT+DSCB) in       *
*                                 result area                        *
*                           WORD4:Length of result area              *
*               Any calling program should eventually FREEMAIN the   *
*               area pointed to by WORD0 and of a length determined  *
*               by adding WORD1+WORD3.                               *
* NOTE    : Count information is also included in the result area.   *
*           Each time you process a DSCB, you should remember that   *
*           the first 8 bytes are COUNT information. The next 140    *
*           bytes are the DSCB information.                          *
*====================================================================*
         TITLE 'VTOCRD2   - INITIALIZATION'
*--------------------------------------- SAVE AREA CHAINING ---------*
VTOCRD2  CSECT
         SAVE (14,12),,'VTOCRD2.&SYSDATE..IOQ VTOC read routine'
         BALR  R12,0
         USING *,R12
         LA    R11,SAVE                ->MY SAVEAREA
         ST    R13,4(R11)              - SAVE CALLER'S SAVEAREA ADDR
         ST    R11,8(R13)              - MY SAVEAREA ADDR IN CALLER'S
         LR    R13,R11                 ->MY SAVEAREA
         TITLE 'VTOCRD2 - MAINLINE CODE'
*--------------------------------------- INITIALIZE -----------------*
         L     R2,0(R1)                ->1ST PARMLIST POINTER
         LH    R2,0(R2)                - GET 1ST PARM
         LTR   R2,R2                   - IS IT ZERO ?
         BZ    OPENVTOC                - YES, GO OPEN VTOC
         L     R2,4(R1)                - ELSE, GET 2ND PARM
         ST    R2,RETURNSA             - SAVE ADDR OF 4-WORD SAVE AREA
         MVI   MEMYES,C'Y'             - IF ANY PARM PASSED, UPDATE
*                                 FLAG TO LEAVE DATA IN MEMORY ON EXIT
*--------------------------------------- OPENVTOC -------------------*
OPENVTOC RDJFCB VOLUME                 - READ JFCB INFO FOR DSN MOD
         MVI   JFCBAREA,X'04'
         MVC   JFCBAREA+1(43),JFCBAREA - SET DSN TO VTOC NAME
         OPEN  (VOLUME,(INPUT)),TYPE=J - OPEN WITH MODIFIED JFCB
         LTR   R15,R15                 - OPEN SUCCESSFUL ?
         BZ    GETCHAR                 - EXIT IF NOT
         LR    R2,R15                  - SAVE R15 TEMPORARILY
         WTO   'VTOC OPEN PROBLEM -- CHECK RETURN CODE',ROUTCDE=11
         LR    R15,R2                  - RESTORE R15
         B     EXIT1                   - EXIT PROGRAM
*--------------------------------------- GET DEVICE INFO ------------*
GETCHAR  DEVTYPE DDNAME,DEVRESLT,DEVTAB  GET DEVICE CHARACTERISTICS
         LTR   R15,R15                 - MACRO SUCCESSFUL ?
         BZ    MOVDINFO                - BRANCH IF SO
         LR    R2,R15                  - SAVE R15 TEMPORARILY
         WTO   'DEVTYPE MACRO ERROR -- CHECK RETURN CODE',ROUTCDE=11
         LR    R15,R2                  - RESTORE R15
         B     EXIT1                   - EXIT PROGRAM
MOVDINFO MVC   TRKINCYL(2),DEVRESLT+10 - GET # OF TRKS/CYL FOR DEVICE
*------------ GET 1ST EXTENT INFO FOR VTOC FROM DEB AND GET UCB ADDR *
GETDEB   LA    R2,VOLUME               ->VOLUME DCB
         USING IHADCB,R2
         L     R2,DCBDEBAD             ->DEB
         USING DEBBASIC,R2
         LA    R2,DEBBASND-DEBBASIC(R2)  POINT PAST END OF BASIC SECTN
         USING DEBDASD,R2
         MVC   UCBADDR(4),DEBUCBAD     - GET UCB ADDR
         MVC   STRTCC(8),DEBSTRCC      - GET START CYL/HEAD AND END
*                                        SAVE VOLSER INFO FROM UCB
         L     R4,UCBADDR              ->UCB
         USING UCBOB,R4
         MVC   RNAME,UCBVOLI           - GET VOLSER
*------------ CALC #VTOC RECORDS THAT FIT ON A TRACK OF THIS DEV TYPE *
TRKCALC# TRKCALC FUNCTN=TRKCAP,UCB=(R4),R=1,K=44,DD=96,REGSAVE=YES
         LTR   R15,R15                 - MACRO SUCCESSFUL ?
         BZ    TCOK                    - BRANCH IF SO
         LR    R2,R15                  - SAVE R15 TEMPORARILY
         WTO   'TRKCALC MACRO ERROR -- CHECK RETURN CODE',ROUTCDE=11
         LR    R15,R2                  - RESTORE R15
         B     EXIT1                   - EXIT PROGRAM
TCOK     STH   R0,RECINTRK             - SAVE #RECORDS/TRK
*--------------------------------------- CALC MEMORY REQUIREMENTS ---*
DEVOK    LH    R3,STRTCC               - GET STARTING CYL #
         LH    R4,ENDCC                - GET ENDING CYL #
         MH    R3,TRKINCYL             - MULTIPLY BY TRKS/CYL
         MH    R4,TRKINCYL             - MULTIPLY BY TRKS/CYL
         AH    R3,STRTHH               - ADD STARTING TRK #
         AH    R4,ENDHH                - ADD ENDING TRK #
         SR    R4,R3                   - SUB START TRK # FROM END TRK #
         LA    R4,1(R4)                - ADD 1 TO MAKE TOT # OF TRKS
         STH   R4,TOTTRACK             - SAVE TOT # TRKS FOR VTOC
         LH    R5,TRKINCYL             - MAX # OF TRKS IN CYL
         MH    R5,=H'24'               - MULTIPLY BY 3 CCWS (3*8) LEN
         AH    R5,=H'16'               - R5=BYTES NEEDED FOR CCWS
         LH    R6,TRKINCYL             - MAX # OF TRKS IN CYL
         MH    R6,=H'5'                - R6 * (# OF SRCHID= SEEK BYTES)
         AH    R6,=H'6'                - R6=BYTES NEEDED FOR SEEK DATA
         LH    R7,RECINTRK             - MAX # OF RECS IN TRK
         MH    R7,=H'148'              - R7 * (CKD SIZE)
         LA    R7,8(R7)                - RND UP TO/PAST MULTIPLE OF 8
         MH    R7,TOTTRACK             - R7=BYTES NEEDED FOR RESULT
         SR    R2,R2                   - ZERO R2
         AR    R2,R5                   - ADD CCW REQUIREMENT
         AR    R2,R6                   - ADD TRACK DATA REQUIREMENT
         AR    R2,R7                   - ADD SEEK DATA REQUIREMENT
         ST    R2,AMOUNT               - STORE TOTAL REQUIREMENT
         OI    AMOUNT,X'80'
         GETMAIN LC,LA=AMOUNT,A=MEMADDR,BNDRY=DBLWD GET STORAGE
         LTR   R15,R15
         BZ    ENQVTOC                 - IF OK, GO ENQ ON VTOC
         LR    R2,R15                  - SAVE R15 TEMPORARILY
         WTO   'GETMAIN MACRO ERROR -- CHECK RETURN CODE',ROUTCDE=11
         LR    R15,R2                  - RESTORE R15
         B     EXIT1                   - EXIT PROGRAM
*--------------------------------------- ENQ ON VTOC ----------------*
ENQVTOC  EQU   *
*--------------------------------------- BUILD CCWS -----------------*
BLDCCWS  L     R9,MEMADDR              ->CCW AREA
         LR    R10,R9
         AR    R10,R5                  ->SEEK INFO AREA
         LR    R11,R10
         AR    R11,R6                  ->RESULT AREA
         LH    R2,STRTCC               - GET START CYL#
         LH    R4,STRTHH               - GET START TRK#
CYLLOOP  MVC   SEEKADDR(3),=XL3'000000'  SET UP ABSOLUTE
         STCM  R2,3,SEEKADDR+3            MBBCCHHR
         STCM  R4,3,SEEKADDR+5              ADDRESS
         MVI   SEEKADDR+7,X'01'               FOR IOBLOCK
         CH    R2,ENDCC                - PAST ENDCC ?
         BH    NONELEFT                - BRANCH IF SO
         BE    LASTCYL                 - IF LAST THEN GET ENDHH
         LH    R3,TRKINCYL             - ELSE GET # TRKS/CYL
         BCTR  R3,R0                   - DEC TO GET HI TRACK #
         B     #TRACKS                 - GO CALC # TRKS IN THIS CYL
LASTCYL  LH    R3,ENDHH                - GET LAST (HI) TRK #
#TRACKS  SR    R3,R4                   - R3=HI T # - LO T # IN THIS CYL
         LA    R3,1(R3)                - ADJUST-- R3 NOW HAS # OF TRKS
         MVC   0(16,R9),SEEKCCHH       - MOVE SEEK CCWS
         STCM  R10,7,1(R9)             - SEEK DATA ADDR -> SEEK CYL
         STCM  R10,7,9(R9)             - SEEK DATA ADDR -> SEEK HEAD
         LA    R9,16(R9)               - INC CCW AREA POINTER
         MVC   0(2,R10),=H'0'          - CREATE 00
         STH   R2,2(R10)                          CC
         STH   R4,4(R10)                            HH
         LA    R10,6(R10)              - INC FOR SEEK ADDR DATA AREA
CCWLOOP  MVC   0(24,R9),SRCHREAD       - MOVE SEARCH,TIC AND READ CCWS
         MVI   SRCHREAD,X'B1'          - SWITCH SEARCH TO MULTI-TRACK
         STCM  R10,7,1(R9)             - CCHHR -> SRCH ID= CCW
         STCM  R9,7,9(R9)              - SRCH ID= -> TIC CCW
         STCM  R11,7,17(R9)            - RES AREA ADDR -> READ CCW
         STH   R2,0(R10)               - CREATE CC
         STH   R4,2(R10)                          HH
         MVI   4(R10),X'00'                         R SEEK DATA
         LH    R1,RECINTRK             - GET BLKS/TRK
         MH    R1,=H'148'              - R1 * CKD AMOUNT
         STH   R1,22(R9)               - RESULT LENGTH IN READ CCW
         LA    R4,1(R4)                - INC TRK #
         LA    R9,24(R9)               - INC CCW AREA POINTER
         LA    R10,5(R10)              - INC SEEK ADDR POINTER
         AR    R11,R1                  - ADD RES LEN TO RES AREA PTR
         BCT   R3,CCWLOOP              - LOOP TILL NO MORE TRKS IN CYL
         S     R9,=F'4'                - BACK UP TO LAST CCW FLAGS
         MVI   0(R9),X'00'             - TURN OFF COMMAND CHAIN BIT
         MVC   ECBX(4),=F'0'           - ZERO ECB
         MVC   CCWADDR(4),MEMADDR      - COPY ADDR OF CHAN PGM TO IOB
         EXCP  IOBX                    - EXECUTE CHAN PGM
         WAIT  ECB=ECBX                - WAIT FOR COMPLETION
         CLI   ECBX,X'7F'              - COMPLETION NORMAL ?
         BNE   IOBAD                   - NO, PRINT ECB AND CSW
IOOK     LA    R2,1(R2)                - INC CYL #
         MVI   SRCHREAD,X'31'          - SWITCH SEARCH TO SINGLE TRK
         SR    R4,R4                   - ZERO TRK #
         L     R9,MEMADDR              - RESET CCW PTR FOR NXT CHN PGM
         LR    R10,R9                  - RESET SEEK
         AR    R10,R5                         DATA POINTER
         B     CYLLOOP                 - CONT. READING CYLS TIL DONE
*--------------------------------------- I/O EXCP ERROR -------------*
IOBAD    EQU    *
* Translate ECBX code into hex and place in ECBERR
         B      *+28
HTR0018  DS     XL8
HTA0018  DS     CL15
         LA     1,HTR0018
         MVC    0(4,1),ECBX              Move input to work
         LA     2,HTA0018
         UNPK   0(15,2),HTR0018          Unpack the field
         TR     HTA0018,HEXTAB           Translate
         MVC    ECBERR,HTA0018           Move the output back
* Translate CSWINFO code into hex and place in CSWERR
         B      *+28
HTR0019  DS     XL8
HTA0019  DS     CL15
         LA     1,HTR0019
         MVC    0(4,1),CSWINFO           Move input to work
         LA     2,HTA0019
         UNPK   0(15,2),HTR0019          Unpack the field
         TR     HTA0019,HEXTAB           Translate
         MVC    CSWERR,HTA0019           Move the output back
         WTO   'EXCP I/O FAILURE -- ECB AND CSW ARE:',ROUTCDE=11
WTOCSW   WTO   'FFFFFFFF / FFFFFFFFFFFFFFFF',ROUTCDE=11
         ORG   WTOCSW+8
ECBERR   DS    CL8
         ORG   WTOCSW+19
CSWERR   DS    CL16
         ORG   *
*        DEQ   (QNAME,RNAME,6,SYSTEMS) - DEQ VTOC
         CLOSE (VOLUME)                - CLOSE VTOC
         B     EXIT                    - EXIT
*--------------------------------------- PROCESS IN-CORE VTOC -------*
NONELEFT EQU   *
*ONELEFT DEQ   (QNAME,RNAME,6,SYSTEMS) - DEQ VTOC
         CLOSE (VOLUME)                - CLOSE VTOC
MEMCHECK CLI   MEMYES,C'Y'             - VTOC DUMP TO REMAIN IN-CORE?
         BNE   PRINTOUT                - NO, GO PRINT IT
         L     R3,RETURNSA             ->RETURN SA ADDRESS
         L     R4,MEMADDR              ->MEMORY AREA ADDRESS
         AR    R5,R6                   - ADD CCW AND SEEK AREA SIZES
         LH    R6,TOTTRACK             - GET TOTAL # OF TRACKS
         MH    R6,RECINTRK             - R6 * (# DSCBS/TRK)
         STM   R4,R7,0(R3)             - SAVE RETURN PARAMERTES
         B     EXIT1                     AND EXIT
*--------------------------------------- PRINT DUMPED VTOC ----------*
PRINTOUT ABEND 999,DUMP
         OPEN  (PRINT,OUTPUT)          - OPEN PRINT FILE
         LTR   R15,R15
         BZ    GETMEMAD                - IF SO GET MEMORY ADDRESS
         LR    R2,R15                  - SAVE R15 TEMPORARILY
         WTO   'PRINT FILE OPEN PROBLEM, CHECK RETURN CODE',ROUTCDE=11
         FREEMAIN LU,LA=AMOUNT,A=MEMADDR
         LR    R15,R2                  - RESTORE R15
         B     EXIT1                   - EXIT PROGRAM
GETMEMAD L     R9,MEMADDR              - GET ADDR TO START OF CCWS
         AR    R9,R5                   ->PAST CCWS TO SEEK DATA
         AR    R9,R6                   ->PAST SEEK DATA TO RESULT
         LH    R11,TOTTRACK            - GET TOTAL # OF TRKS
TRKLOOP  LH    R10,RECINTRK            - GET # BLKS PER TRK
RECLOOP  PUT   PRINT,0,(R9)            - WRITE OUT 1 RECORD
         LA    R9,148(R9)              ->NEXT RECORD
         BCT   R10,RECLOOP             - CONT WRITING RECORDS
         BCT   R11,TRKLOOP             - CONT WRITING TRACKS
         CLOSE (PRINT)                 - CLOSE PRINT FILE
         TITLE 'VTOCRD2 - RETURN TO CALLER'
*--------------------------------------- FREE STORAGE ---------------*
EXIT     FREEMAIN LU,LA=AMOUNT,A=MEMADDR
*--------------------------------------- RETURN TO CALLER -----------*
EXIT1    L     R13,SAVE+4              ->CALLER'S SAVEAREA
         RETURN (14,12),RC=(15)        - RETURN WITH RC IN R15
         TITLE 'VTOCRD2 - DCB DEFINITIONS'
VOLUME   DCB   DSORG=PS,MACRF=E,DDNAME=VOLUME,EODAD=EXIT,RECFM=F,      X
               IOBAD=IOBX,DEVD=DA,EXLST=EXITLIST
PRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=PRINT,RECFM=FB,LRECL=148,      X
               BLKSIZE=14800
         TITLE 'VTOCRD2 - SAVE/WORKAREA'
*--------------------------------------- REGISTER SAVEAREA ----------*
SAVE     DS    0F
         DC    C'PL1 PSA NSA RET EP  R0  R1  R2  R3  '
         DC    C'R4  R5  R6  R7  R8  R9  R10 R11 R12 '
*--------------------------------------- MISC CONSTANTS -------------*
EXITLIST DS    0F
         DC    X'07',AL3(JFCBAREA)
JFCBAREA DS    CL176
STRTCC   DS    H                       - VTOC STARTING CYL ADDR
STRTHH   DS    H                       - VTOC STARTING HEAD ADDR
ENDCC    DS    H                       - VTOC ENDING CYL ADDR
ENDHH    DS    H                       - VTOC ENDING HEAD ADDR
TOTTRACK DS    H                       - TOTAL NUMBER OF VTOC TRACKS
AMOUNT   DS    F                       - AMOUNT OF STORAGE FOR GETMAIN
MEMYES   DC    C'N'                    - MEMORY RESIDENT FLAG FOR RET
*                                        MESSAGE GENERATION
RECINTRK DS    H                       - RECORDS IN A TRACK
TRKINCYL DS    H                       - TRACKS IN A CYL
ECBX     DS    F                       - ECB AREA
CSW2     DS    2F                      - DUPLICATE AREA FOR CSW INFO
IOBX     DS    0D
         DC    XL4'42000000'           - COMMAND CHAINING ON
         DC    A(ECBX)                 ->ECB ADDR
CSWINFO  DC    2F'0'                   - CHAN STATUS
CCWADDR  DS    A                       - CHAN PROGRAM ADDRESS
         DC    A(VOLUME)               - DCB ADDRESS
         DC    F'0'                    - USED BY SYSTEM
         DC    H'0'                    - FOR MAG TAPE
         DC    H'0'                    - USED BY SYSTEM
SEEKADDR DS    D                       - SEEK ADDR
SEEKCCHH DC    XL8'0B00000040000006'   - SEEK CYL CCW
         DC    XL8'1B00000040000006'   - SEEK HEAD CCW
SRCHREAD DC    XL8'3100000040000005'   - SEARCH MULTI-TRK ID=CCW
         DC    XL8'0800000040000001'   - TIC CCW
         DC    XL8'5E00000040000000'   - READ MULTIPLE C-K-D
DDNAME   DC    CL8'VOLUME  '           - DDNAME FOR DEVTYPE MACRO
DEVRESLT DS    5F                      - RESULT AREA FOR DEVTYPE MACRO
QNAME    DC    CL8'SYSVTOC'            - ENQ QNAME
RNAME    DS    CL6                     - ENQ RNAME
RETURNSA DS    F                       - ADDRESS OF CALLER'S 3 REG SA
MEMADDR  DS    F                       - ADDRESS OF GETMAINED MEMORY
UCBADDR  DS    F                       - UCB ADDRESS FROM DEB
* Define a 256 byte code table
HEXTAB     DC  X'00'
           ORG *+239
           DC  XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         LTORG
         TITLE 'VTOCRD2 - MACROS'
*--------------------------------------- DSECTS ---------------------*
         DCBD
         IEZDEB
         DSECT
         IEFUCBOB
         END


GETJOBN SOURCE CODE

*====================================================================*
*                   A T T R I B U T E S                              *
* GETJOBN  AC(0),AMODE(24),RMODE(24)                                 *
*            P R O G R A M  D E S C R I P T I O N                    *
* Returns JOBname associated with an ASID (REXX external function)   *
*====================================================================*
GETJOBN CSECT
         SAVE (14,12),,'GETJOBN.&SYSDATE..IOQ External REXX Function'
         BALR R12,0
         USING *,R12
         LA   R2,SAVE                   ->My savearea
         ST   R13,4(R2)                 - Save caller's savearea addr
         ST   R2,8(R13)                 - My savearea addr in caller's
         LR   R13,R2                    ->My savearea
*               Mainline code                                        *
         LR  R7,R1                        Get the EFPL pointer
* Get the 1st parameter (asid)
         USING EFPL,R7                    Address the EFPL
         L   R1,EFPLARG                   Get the arg list address
         L   R2,0(R1)                     Get the 1st arg addr
         L   R1,4(R1)                     Get the param length
         C   R1,TWO                       Length of asid = 2?
         BNE ERROR1
         ICM R3,B'0011',0(R2)
         STH R3,ASID
         LOCASCB ASID=ASID                Get address of ASCB
         LTR  R15,R15
         BNZ ERROR2
         USING ASCB,R1
         L   R3,ASCBJBNI                  Get Batch jobname
         LTR R3,R3                        If it's 0 get STC/TSU name
         BNZ MOVEJOBN
         L   R3,ASCBJBNS                  Get JOBNAME addr
MOVEJOBN MVC JOBNAME,0(R3)
* Return the jobname
         USING EFPL,R7
         L   R1,EFPLEVAL                  EVAL block addr pointer
         L   R7,0(R1)                     EVAL block addr
         DROP R7
         USING EVALBLOCK,R7               Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'JOBNAME) Set the length
         LA   R1,L'JOBNAME              Get the length
         BCT  R1,*+10                   Dec and branch
         MVC  EVALBLOCK_EVDATA(0),JOBNAME Dummy move
         EX   R1,*-6                    Real move
         B   BYEBYE
* Return 'bad parameter' messages to REXX
ERROR1   DS  0H
         USING EFPL,R7
         L   R1,EFPLEVAL                EVAL block address pointer
         L   R7,0(R1)                   EVAL block address
         DROP R7
         USING EVALBLOCK,R7             Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'REQERR1) Set the length
         LA   R1,L'REQERR1              Get the length
         BCT  R1,*+10                   Dec and branch
         MVC  EVALBLOCK_EVDATA(0),REQERR1 Dummy move
         EX   R1,*-6                    Real move
         B   BYEBYE
* Return 'bad asid' messages to REXX
ERROR2   DS  0H
         USING EFPL,R7
         L   R1,EFPLEVAL                EVAL block address pointer
         L   R7,0(R1)                   EVAL block address
         DROP R7
         USING EVALBLOCK,R7             Address EVAL block
         MVC  EVALBLOCK_EVLEN,=A(L'REQERR2) Set the length
         LA   R1,L'REQERR2              Get the length
         BCT  R1,*+10                   Dec and branch
         MVC  EVALBLOCK_EVDATA(0),REQERR2 Dummy move
         EX   R1,*-6                    Real move
*               Return to caller                                     *
BYEBYE   L   R13,SAVE+4                 ->Caller's savearea
         RETURN (14,12),RC=0            - RETURN WITH RC=0 IN R15
*               Save/Workarea                                        *
*---------------------------------------- Register Savearea ---------*
SAVE     DS   0F
         DC   C'PL1 PSA NSA RET EP  R0  R1  R2  R3  '
         DC   C'R4  R5  R6  R7  R8  R9  R10 R11 R12 '
*---------------------------------------- Misc Constants ------------*
REQERR1  DC   CL8'*PARMerr'
REQERR2  DC   CL8'*BADasid'
TWO      DC   F'2'
JOBNAME  DS   CL8
ASID     DS   H
         LTORG
*               Macros/DSECTs                                        *
         IHAASCB
         IRXEFPL
         IRXEVALB
         END


JCL for executing batch version of IOQ scanner

//ZZGDIOQB JOB (ZZ,GD,IOQ),'GBD * 010',MSGCLASS=D,CLASS=8,
//   NOTIFY=ZZGBD
//*--------------------------------------------------------------*
//* IOQBAT - Batch version of IOQ Scanner                        *
//*--------------------------------------------------------------*
//IOQSCAN  EXEC PGM=IKJEFT01,REGION=8M
//STEPLIB  DD DSN=<load_library_with_IOQ_external_functions>,DISP=SHR
//SYSPROC  DD DSN=<IOQ_REXX_exec_library>,DISP=SHR
//SYSUDUMP DD SYSOUT=B
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
  %IOQBAT PRM006 500
//*       VolSer Num_of_Loops_around_IOQ_chain_in_MVS


JCL to compile and link-edit Assembler source

//ZZGDASMC JOB (ZZ,GD,ACL),'10 * GHIAS',CLASS=1,MSGCLASS=D,
//        NOTIFY=ZZGBD,REGION=4M,TYPRUN=HOLD
//*-------------------------------------------------------------------*
//* JCL to ASMCL the IOQ REXX external function routines              *
//*-------------------------------------------------------------------*
//ACL      EXEC ASMHCL,PARM.L='LIST,LET,MAP',COND.L=(4,LT)
//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//         DD DSN=SYS1.AMODGEN,DISP=SHR
//C.SYSPRINT DD SYSOUT=A
//C.SYSIN  DD DSN=<source_library/member_name>,DISP=SHR
//L.SYSLMOD DD DSN=<load_library_name_for_external_functions>,DISP=SHR
//L.SYSPRINT DD SYSOUT=*
//L.SYSIN  DD *
  NAME VTOCX(R)
//* Same for GETJOBN and VTOCRD2


Ghias Din
Senior Technical Consultant
IMI Computing Ltd (UK)                                          c Xephon 1993

