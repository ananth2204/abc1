{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012249000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2586584, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE523.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2586584, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2586584, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE523.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00)\\x03'", "DS1TRBAL": "b'\\xb5\\x06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xe0\\x00\\x04\\x03\\xe3\\x00\\x00\\x00*'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$$$IX": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x02\\x03\\x8f\\x01\\x02\\x03\\x8f\\x00\\x00\\x00\\x0c\\x00\\x0b\\x00\\x00\\xe2\\xd4\\xc6\\xe2\\xd3\\xc3\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2002-02-07T00:00:00", "lines": 12, "newlines": 11, "modlines": 0, "user": "SMFSLCT"}, "text": "   SMFSLCT Index\n\n   The following is a one-line description of the contents of this\n  library:\n\n     $$$$$$IX - Index: this is it\n     $$$$$DOC - A brief overview of the SMFSLCT program\n     $$$$INST - Sample Assemble and Link JCL\n     $$$$SAMP - Sample execution JCL\n     $$$CHANG - Changes with this version\n     SMFSLCT  - Assembler source\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x02\\x03\\x8f\\x01\\x02\\x03\\x8f\\x00\\x00\\x00\\xe8\\x00\\xdc\\x00\\x00\\xe2\\xd4\\xc6\\xe2\\xd3\\xc3\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2002-02-07T00:00:00", "lines": 232, "newlines": 220, "modlines": 0, "user": "SMFSLCT"}, "text": "   This program will read SMF data (from the active MAN dataset or\n  output from IFASMFDP), and will select records according to user\n  specified criteria. Records can be selected by date and time,\n  by record type (and /or subtype), by Jobname, or by data at an\n  offset within the record. Records must meet date/time and\n  record type criteria before being eligible for selection, as\n  determined by Jobname and/or data specifications.\n\n   By default, any records selected from the input will be printed\n  to SYSPRINT, unless 'PRINT=NO' is specified in the SYSIN control\n  cards. If SYSUT2 is present, the selected input records will\n  also be written to it.\n\n   Multiple output files with different selection criteria can be\n  produced in one run of SMFSLCT. The output DDNames and selection\n  criteria are specified in the control cards in SYSIN.\n\n   This program was originally written in PL/1, and subsequently\n  converted to Assembler - the arcane format of the control cards was\n  maintained for compatability reasons.\n\n   Standard disclaimers apply - use at your own risk.\n\n  Attributes:\n      Re-entrant, Reuseable, Refreshable, Not Authorized,\n      AMODE(31), RMODE(ANY)\n\n  Input:\n      SYSUT1   - SMF dataset - either the output from IFASMFDP or\n                 one of the SYS1.MAN datasets. If this DDName is\n                 not allocated when the program is invoked, it will\n                 be dynamically allocated to the active SMF dataset.\n      SYSIN    - Control cards (see below).\n\n  Output:\n      SYSPRINT - Error messages, selected SMF records.\n      SYSUT2   - optional, selected SMF records.\n      anyname  - Optional, selected SMF records.\n\n\n                 C o n t r o l   C a r d s\n\n   Control cards are entered via SYSIN. Only columns 1-72 are\n  scanned, and the scan terminates with the first blank. Cont-\n  inuations are not allowed, but keywords can be specified more\n  than once. If a keyword that has a single value (ie, START=)\n  is specified more than once within an output group, or globally,\n  the last value specified is used.\n\n   OUTPUT=DDName\n      specifies the DDName of an output dataset. All subsequent\n                control statements, until the next \"OUTPUT=\"\n                statement or end-of-file, determine which input\n                records will be selected to this DDName. All\n                control statements appearing before an \"OUTPUT=\"\n                statement apply to all output DDNames, unless\n                specifically overridden by control statements\n                entered after the \"OUTPUT=\" statement.\n\n\n   START=yyddd-hhmmss\n         yyyyddd-hhmmss\n         TODAY-hhmmss\n         (TODAY-n)-hhmmss\n         YESTERDAY-hhmmss\n         THISWEEK-hhmmss\n         LASTWEEK-hhmmss\n         THISMONTH-hhmmss\n         LASTMONTH-hhmmss\n      specifies the date and time at which selection of input\n                records is to start. Defaults to 00000-000000 (ie\n                the start of the input file). The specification of\n                time (-hhmmss) is optional - if omitted, it defaults\n                to 00:00:00.00.\n                Dates using the 2-digit year format will default\n                to 20th century dates (i.e. 1900-1999).\n                YESTERDAY is equivalent to specifying (TODAY-1).\n                Note that a week starts on Monday, and ends on\n                Sunday. Thus, specifying START=LASTWEEK will start\n                selecting records from the Monday of the previous\n                week.\n\n   END=yyddd-hhmmss\n       yyyyddd-hhmmss\n       TODAY-hhmmss\n       (TODAY-n)-hhmmss\n       YESTERDAY-hhmmss\n       THISWEEK-hhmmss\n       LASTWEEK-hhmmss\n       THISMONTH-hhmmss\n       LASTMONTH-hhmmss\n      specifies the date and time at which selection if input\n                records is to stop. Defaults to 2699999-235959 (ie\n                the end of the input file). The specification of\n                time (-hhmmss) is optional - if omitted, it defaults\n                to 23:59:59.99.\n                Dates using the 2-digit year format will default\n                to 20th century dates (i.e. 1900-1999).\n                YESTERDAY is equivalent to specifying (TODAY-1).\n                Note that a week starts on Monday, and ends on\n                Sunday. Thus, specifying END=LASTWEEK will stop\n                selecting records on the Sunday of the previous\n                week.\n\n   PERIOD=hhmmss-hhmmss\n      specifies the start and stop time-of-day between which input\n                records will be eligible for selection. Records for\n                each day, as specified by start/end or defaulted,\n                falling outside these times will be ignored.\n                 The time can be specified as hh, hhmm or hhmmss;\n                the missing digits will default to 0.\n                 Defaults to \"PERIOD=000000-240000\".\n\n   WEEKENDS=IGNORE\n      specifies that SMF data generated on Saturday and Sunday will\n                be ignored.\n\n   INCLUDE=nn<(ss)>\n      specifies that record type nn should be selected. A subtype\n                ss can also be optionally included, in parentheses.\n                If more that one record type is coded on the\n                control card, the record types (and subtypes)\n                must be enclosed in parentheses.\n                Note that 'INCLUDE' is mutually exclusive with the\n                'EXCLUDE' keyword within an \"OUTPUT=\" definition,\n                or globally, if no \"OUTPUT=\" statement is present.\n\n   EXCLUDE=nn<(ss)>\n      specifies that record type nn should not be selected. A\n                subtype ss can optionally be included, in paren-\n                theses. If more than one record type is coded,\n                the record types (and subtypes) and subtypes must\n                be enclosed in parentheses.\n                Note that 'EXCLUDE' is mutually exclusive with the\n                'INCLUDE' keyword within an \"OUTPUT=\" definition,\n                or globally, if no \"OUTPUT=\" statement is present.\n\n   PRINT=NO\n   PRINT=EBCDIC\n         NO     specifies that selected records are not to be\n                printed on SYSPRINT. If an output ddname is\n                present, selected records will be written to it.\n         EBCDIC specifies that selected records are to be printed\n                on SYSPRINT in EBCDIC only (the default is dump\n                format). If an output ddname is present, the\n                selected records will be written to it.\n\n   SEQUENCE=YES\n                specifies that the input records are in date/time\n                sequence. If 'SEQUENCE=YES' is specified, SMFSLCT\n                will terminate as soon as a record with a date\n                stamp past the 'END=' date/time is encountered.\n                Normal SMFSLCT processing assumes that the input\n                records are not in sequence, and invokes\n                termination at end-of-file.\n\n   CHECKVBS=NO\n                specifies that no checking should be performed for\n                variable spanned segmentation errors. If this\n                is specified, QSAM will be used to read SYSUT1,\n                and invalid segment sequences will cause an S002\n                (or potentially other system) abend. The default\n                is that BSAM will be used to read VS or VBS files,\n                and invalid segments discarded.\n                Note that using BSAM requires more CPU time; where\n                the input file is known to be 'clean', specifying\n                CHECKVBS=NO will reduce the CPU time used by this\n                program.\n\n   JOBNAME=jjjjjjjj\n      specifies that all records (subject to \"INCLUDE\"/\"EXCLUDE\",\n                above), Job (or TSU or STC) jjjjjjjj should be\n                selected.\n                If more that one jobname is coded, the jobnames\n                should be enclosed in parentheses.\n                 If the last character in the jobname is an\n                asterisk, the characters preceeding the asterisk\n                considered a prefix, and all jobnames that match\n                the prefix will be selected.\n\n   DATA=xxx<,nn>\n      specifies the character string that must be present in the\n                input record before it will be selected.\n                DATA= indicates that the string xxx (specified\n                      either as a data(xxx...x), a character string\n                      (C'xxx...x) or a hex string(X'xxx...x)) must\n                      start at offset position nn (nn=0-32767,\n                      default=0), for the input record to be\n                      selected. Note that the offset must include\n                      the length of the RDW.\n\n   JOB/DATA=OR\n      specifies that the selection algorithm should select an\n                      input record if either the Jobname or data\n                      specifications are met. The default is that\n                      both Jobname and data criteria must be\n                      satisfied before a record will be selected.\n\n   STOPAFT=nnn\n      specifies that SMFSLCT is to terminate after selecting nnn\n                      records (nnn = 1 to 999999999). The default\n                      is to terminate when end-of-file is reached\n                      on input.\n\n   INEXIT=(member-name<,parm>)\n      specifies that SMFSLCT is to invoke member-name after\n                      each SMF record is read from the input, and\n                      after checking the date/time against \"START=\"\n                      and \"END=\", but before checking any other\n                      selection criteria.\n                      \"parm\" is an optional string that will be\n                      passed to the exit each time it is invoked.\n                      If present, the operands of INEXIT= must\n                      be enclosed in parentheses. Further, if parm\n                      contains a close parenthesis, it must be\n                      enclosed in quotes (as per IBM, if parm also\n                      contains a quote, it must be coded as two\n                      two consecutive quotes).\n\n   OUTEXIT=(member-name<,parm>)\n      specifies that SMFSLCT is to invoke member-name after\n                      an SMF record has been selected, but before\n                      the record is printed and/or written to the\n                      output file(s).\n                      \"parm\" is an optional string that will be\n                      passed to the exit each time it is invoked.\n                      If present, the operands of OUTEXIT= must\n                      be enclosed in parentheses. Further, if parm\n                      contains a close parenthesis, it must be\n                      enclosed in quotes (as per IBM, if parm also\n                      contains a quote, it must be coded as two\n                      two consecutive quotes).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$$INST": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x17o\\x01\\x01\\x17o\\x13\\x07\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xd4\\xc6\\xe2\\xd3\\xc3\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-25T00:00:00", "modifydate": "2001-06-25T13:07:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SMFSLCT"}, "text": "   The following is sample JCL to Assemble and Link (Bind?) SMFSLCT.\n  Note that the JCL statements for SYSIN (in the ASM Step) and\n  SYSLMOD (LKED Step) must be changed, and that a valid JOB statement\n  must be used.\n\n\n//SMFSLCTA JOB blah,blah\n//*\n//ASM     EXEC PGM=ASMA90,REGION=4M,\n//             PARM='NODECK,OBJECT,RENT,XREF(SHORT),NOALIGN'\n//SYSPRINT  DD SYSOUT=*\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1    DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=SYSALLDA,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN     DD DISP=SHR,DSN=source-program\n//*\n//LKED    EXEC PGM=HEWL,REGION=4M,COND=(0,LT),\n//             PARM='LIST,MAP,RENT,REUS,REFR'\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)\n//          DD DDNAME=SYSIN\n//SYSUT1    DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSLMOD   DD DISP=SHR,DSN=loadlib\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$$SAMP": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x17o\\x01\\x01\\x17o\\x13\\x07\\x00[\\x00[\\x00\\x00\\xe2\\xd4\\xc6\\xe2\\xd3\\xc3\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-25T00:00:00", "modifydate": "2001-06-25T13:07:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SMFSLCT"}, "text": "   The following are samples of the JCL and Control Cards used to\n  execute SMFSLCT, and a brief explanation of the effects of\n  the various control cards.\n\n\n  //SMFSLCT  JOB blah,blah\n  //STEP1   EXEC PGM=SMFSLCT,REGION=6M\n  //STEPLIB   DD DISP=SHR,DSN=if-required\n  //SYSPRINT  DD SYSOUT=*\n  //SYSIN     DD *\n  INCLUDE=70\n  STOPAFT=3\n  /*\n\n       SMFSLCT will read the active SMF datasets, and select the 1st\n       3 Type 70 records found. These records will be printed in\n       Dump format (hex and EBCDIC) on SYSPRINT.\n\n\n\n  //SMFSLCT  JOB blah,blah\n  //STEP1   EXEC PGM=SMFSLCT,REGION=6M\n  //STEPLIB   DD DISP=SHR,DSN=if-required\n  //SYSPRINT  DD SYSOUT=*\n  //SYSUT1    DD DISP=SHR,DSN=unloaded-man-file\n  //SYSUT2    DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),\n  //             DSN=output-file1,SPACE=(blah,blah)\n  //SYSIN     DD *\n  START=LASTWEEK\n  END=LASTWEEK\n  WEEKENDS=IGNORE\n  INCLUDE=(14,15)\n  DATA=C'SYS1.MACLIB',68\n  PRINT=NO\n  /*\n       SMFSLCT will read the SMF data allocated to SYSUT1, and select\n       Type 14 and 15 records (Data Set Close) that contain SYS1.MACLIB\n       in column 68 (the JFCBDSNM field), and that were created between\n       Monday and Friday of the previous week. Selected records will be\n       copied to SYSUT2, which will have the same DCB attributes as\n       SYSUT1 (since none were specified). The selected records will\n       not be printed.\n\n\n  //SMFSLCT  JOB blah,blah\n  //STEP1   EXEC PGM=SMFSLCT,REGION=6M\n  //STEPLIB   DD DISP=SHR,DSN=if-required\n  //SYSPRINT  DD SYSOUT=*\n  //SYSUT1    DD DISP=SHR,DSN=unloaded-man-file\n  //OUT1      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),\n  //             DSN=output-file1,SPACE=(blah,blah),\n  //             DCB=(blah,blah)\n  //OUT2      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),\n  //             DSN=output-file1,SPACE=(blah,blah),\n  //             DCB=(blah,blah)\n  //OUT3      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),\n  //             DSN=output-file1,SPACE=(blah,blah),\n  //             DCB=(blah,blah)\n  //SYSIN     DD *\n  START=87015,END=87017-170000\n  OUTPUT=OUT1\n   INCLUDE=(30(2),20,5)\n   JOBNAME=JOBONE\n   PRINT=NO\n  OUTPUT=OUT2\n   START=87013-081500,END=87013-170000\n   INCLUDE=34\n   JOBNAME=(TSO1,TSO2)\n  OUTPUT=OUT3\n   DATA=C'A B C',257\n   OUTEXIT=EXIT5\n  /*\n       SMFSLCT will read the unloaded MAN file specified by SYSUT1.\n       Note that if SYSUT1 were not specified, the active MAN\n       file would be read.\n       SMFSLCT will ignore any input records produced before\n       00:00:00 on 87.015, and terminate after finding a record\n       produced after 17:00:00 on 87.017.\n       For the output file specified by DDName OUT1:\n        Record types 5, 20, and 30 subtype 2, for Jobs with the\n        name \"JOBONE\" will be selected, but not printed.\n       For the output file specified by DDName OUT2:\n        Record type 34 for Jobs (TSO users) with the names \"TSO1\"\n        or \"TSO2\" will be selected, and printed.\n        The global date-time specification is overridden for this\n        output file only.\n       For the output file specified by DDName OUT3:\n        All records containing the character string \"A B C\" in\n        positions 257-261 (relative to 0, including the RDW) will\n        be selected and printed. The exit \"EXIT5\" will be invoked\n        for each record selected for \"OUT3\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$#DATE": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00#\\x01\\x152\\x1f\\x01\\x152\\x1f\\x14\\x13\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-11-17T00:00:00", "modifydate": "2015-11-17T14:13:23", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  523\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE523\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 24,459 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/17/15    14:13:22    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$CHANG": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x13\\x01\\x02\\x03\\x8f\\x01\\x151\\x9f\\x081\\x003\\x00\\x08\\x00\\x00\\xd9\\xe6\\xe2\\xe4\\xc8\\xd9@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2015-11-15T08:31:13", "lines": 51, "newlines": 8, "modlines": 0, "user": "RWSUHR"}, "text": "      1999/04/24 SDDA030 V1.1\n                 Added code to ignore records invalidly spanned\n                 in non-VSAM VBS input.\n                 Calculated DCB=NCP (BSAM), DCB=BUFNO (QSAM), or\n                 AMP=BUFSP (VSAM) so we can read a cylinder of\n                 input at a time (if input on DASD).\n                 Used MACRF=PM on output file(s), so VBS datasets\n                 can be created.\n                 Lives and executes in 31-bit mode.\n                 Used internal LIFO stack for dynamic storage\n                 Made Y2K compliant!\n      1999/07/22 SDDA030 V1.2\n                 Added Date conversion routines.\n                 Added new START=/END= date keywords.\n                 Added 24-bit EODAD for SYSIN, if required\n      1999/11/18 SDDA030 V1.3\n                 Moved SYSUT1 OPEN logic(?) to its own subroutine\n                 (I0010)\n                 Added comments\n\n      2002/02/07 SDDA030 V1.4\n                 Added stack below the line.\n                 Added new parms for exits as suggested by Dave\n                 Alcock.\n                 Added parms to INEXIT=/OUTEXIT= statements.\n                 Defaulted 2-digit years on START=/END= to the\n                 current century.\n                 Corrected S0C4 Abends when lots of record types\n                 or jobnames selected (Thanks to Paul\n                 Luttenberger).\n                 Changed RDJFCBs to SWAREQs.\n                 Corrected logic when setting DCB characteristics\n                 for new output datasets with no DCB spacified.\n                 Printed **VIO** for volser when appropriate.\n      2006/10/26 SDDA030 V1.5\n                 Fixed bug when printing record subtypes to be\n                 selected (thanks to BBordonaro).\n                 Corrected calculation of SYSPRINT LRECL (fixed\n                 check for CC) (thanks to Martin Samson).\n                 Corrected non-re-entrancy error with SYSUT1 EXLST\n                 (thanks to Martin Samson - again!).\n\n      2013-03-19 RWSUHR  V1.6\n                 Set return code to 8 if nothing is selected\n\n      2015-11-13 RWSUHR  V1.72 - @RWS\n                 Fixed an S0C7, when OUTPUT= was specified\n                 added assembly date and time and change person\n                 ID (ID of person who last changed this program)\n                 Roger W. Suhr (State of Indiana - IOT)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x07\\x07?\\x01\\x07\\x07?\\t \\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-14T00:00:00", "modifydate": "2007-03-14T09:20:30", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$NOTE2": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x12\\t\\x0f\\x01\\x12\\t\\x0f\\x177\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-03-30T00:00:00", "modifydate": "2012-03-30T17:37:47", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  SMFSLCT in file 523 of the CBT tape.\nFrom:     \"Gibson, Jamie\" <Jamie.Gibson@toysrus.com>\nDate:     Thu, 29 Mar 2012 08:35:35 -0400\nTo:       <sbgolob@cbttape.org>\n\nSam,\n\nWhen I updated to z/OS 1.13  I started getting an S0C7 abend in SMFSLCT.\n\n+IDI0002I Module SMFSLCT, CSECT SMFSLCT, offset X'54E0': Abend\n          S0C7-X'0' (Data Exception)\n\nMaking the following change to line 1785  resolved the problem:\n\n         AL    R0,=AL4(ODTE_Length)    plus len of 1 entry\n\nTo:\n\n         AL    R0,=AL4(ODTE_Length*2)    plus len of 2 entries\n\nJamie Gibson\n\n...\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE3": {"ttr": 536, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x13\\x05\\x1f\\x01\\x13\\x05\\x1f!\\x04\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-02-20T00:00:00", "modifydate": "2013-02-20T21:04:01", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  SMFSLCT in file 523 of the CBT tape.\nFrom:     \"James, Sterling\" <SSJames@dstsystems.com>\nDate:     2/20/2013 12:27 PM\nTo:       \"sbgolob@cbttape.org\" <sbgolob@cbttape.org>\n\nHello Sam,\n\nAfter upgrading to zOS 1.13, I started to get an S0C4 in SMFSLCT.\n\nAfter updating line 7470, it resolved the problem.\n\n          LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) Nbr entries\nTo\n          LH    R14,ODT_Entry_Count-OutDesc_Tbl(R1) Nbr entries\n\nThanks\nH. Sterling James\n\nSystems Administrative Consultant\nEnterprise Services\nDST Systems, Inc.\np 573.632.1022\np 314.506.8982\nc 816.564.2395\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE4": {"ttr": 770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00S\\x01\\x152\\x1f\\x01\\x152\\x1f\\x14\\x12\\x00h\\x00U\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2015-11-17T00:00:00", "modifydate": "2015-11-17T14:12:53", "lines": 104, "newlines": 85, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  SMFSLCT Program\nFrom:     \"Suhr, Roger\" <RSuhr@iot.IN.gov>\nDate:     11/15/2015 8:42 AM\nTo:       \"Sam Golob (sbgolob@cbttape.org)\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nI stumbled into an S0C7 ABEND when attempting to use the OUTPUT=\nstatements with SMFSLCT.  I was able to correct the program so it\nis working now and I made a few cosmetic modifications as well.\n\nCBT523   Paul Dion's SMFSLCT program\n\nI used an older copy to start with, so the changes introduced by\nSterling James ($$NOTE3) and Jamie Gibson ($$NOTE2) have been\nwiped out. (They referred to similar, or the same issues as I\nexperienced.)  (Please skip the code change notes to read further.)\n\n*-->>>  Note Below ...-----------------------------------------------*\nNote from Sam Golob: Change from Sterling James put back. Fixed an\n----                 obvious error, and the change should be there,\n                     hopefully in all versions.\n\n                     This is his change\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE DIDN'T FIND OUR ENTRY IN THE TABLE, SO WE WILL CREATE ONE.  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_ODT_Ptr           A(OUR TABLE)\n         L     R15,=AL4(ODTE_Length)  LENGTH OF ONE ENTRY\n         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R1)  (Correct code.)\n*        LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) (Serious error.)\n\n*-->>>  Note Above ...-----------------------------------------------*\n\n\n*--->>>> This is Roger Suhr's change, to override J.Gibson's change\n074820          L     R15,=AL4(ODTE_Length)  LENGTH OF ONE ENTRY\n074830          LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) Nbr entries\n074840          LA    R14,1(0,R14)           PLUS ONE FOR THE NEW ONE\n074850 *        MR    R14,R14                LENGTH OF ENTRIES @RWS 15-11-13\n074860          MR    R14,R15                LENGTH OF ENTRIES @RWS 15-11-13\n074870          LA    R15,ODT_Entry-OutDesc_Tbl(0,R15)   PLUS LEN OF HEADER\n*--->>>> This is Roger Suhr's change, to override J.Gibson's change\n\nThis works fine now for me here.\n\nFriday, November 13, 2015 (2015.317) 16:43:37.94                 SMFSLCT\n     Input Control Cards:\nSTART=20150101\nEND=20151031\nEXCLUDE=(2,3)\nPRINT=NO\nOUTPUT=TYPE30\nINCLUDE=30\nOUTPUT=TYPERMF\nINCLUDE=(70,71,72,73,74,75,76,77,78,79)\nOUTPUT=TYPE110\nINCLUDE=(110)\n\n SYSUT1   DSN: SFRH48.ISDPROD.SMFD.D151020.T164119.SORTED, Volser: 182781\n          DCB=(RECFM=VBS,LRECL=32756,BLKSIZE=32760,NCP=30)\n          Variable Spanned segments will be checked for consistency.\n          Input data not necessarily in sequence.\n\n TYPE30   DSN: SFRH48.SMF.TYPE30.DATA, Volser: SMSL11\n          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=27998)\n          No Date-Time criteria; all records will be eligible\n          Record Type 30 will be eligible\n          No Jobname criteria; all records will be eligible\n          No Data criteria; all records will be eligible\n\n TYPERMF  DSN: SFRH48.SMF.TYPERMF.DATA, Volser: SMSL07\n          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=27998)\n          No Date-Time criteria; all records will be eligible\n          Record Types 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 will be eligible\n          No Jobname criteria; all records will be eligible\n          No Data criteria; all records will be eligible\n\n TYPE110  DSN: SFRH48.SMF.TYPE110.DATA, Volser: SMSL34\n          DCB=(RECFM=VBS,LRECL=32760,BLKSIZE=27998)\n          No Date-Time criteria; all records will be eligible\n          Record Type 110 will be eligible\n          No Jobname criteria; all records will be eligible\n          No Data criteria; all records will be eligible\n\nFriday, November 13, 2015 (2015.317) 16:43:37.94                 SMFSLCT\n                    Date/Time of first record:     Tuesday, October 20,\n                    Date/Time of last record:      Tuesday, October 20,\n\nThank you\n\nRoger W. Suhr\nSr. MF Systems Administrator\nIndiana Office of Technology\n100 N. Senate Ave, IGCN-551\nIndianapolis, Indiana 46204\noffice 317-234-8132\nCell     563-581-9065\nFax     563-594-5255\nIOT_Logo_Horizontal_2014\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE523": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x16\\x01\\x152\\x1f\\x01\\x152\\x1f\\x14\\x13\\x00C\\x00C\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2015-11-17T00:00:00", "modifydate": "2015-11-17T14:13:16", "lines": 67, "newlines": 67, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 523 is from Paul Dion and contains an SMF record          *   FILE 523\n//*           selection program of great generality.  Records can   *   FILE 523\n//*           be pulled from the currently active SMF dataset, as   *   FILE 523\n//*           well as from SMF archive datasets.                    *   FILE 523\n//*                                                                 *   FILE 523\n//*           email:  pdion@canada.com                              *   FILE 523\n//*                                                                 *   FILE 523\n//*           Fixed by  R.W. Suhr          (see members $$NOTEx)    *   FILE 523\n//*           email:  RSuhr@iot.IN.gov                              *   FILE 523\n//*                                                                 *   FILE 523\n//*      SMFSLCT Index                                              *   FILE 523\n//*                                                                 *   FILE 523\n//*      The following is a one-line description of the             *   FILE 523\n//*      contents of this library:                                  *   FILE 523\n//*                                                                 *   FILE 523\n//*      $$$$$$IX - Index: this is it                               *   FILE 523\n//*      $$$$$DOC - A brief overview of the SMFSLCT program         *   FILE 523\n//*      $$$$INST - Sample Assemble and Link JCL                    *   FILE 523\n//*      $$$$SAMP - Sample execution JCL                            *   FILE 523\n//*      $$$CHANG - Changes with this version                       *   FILE 523\n//*      SMFSLCT  - Assembler source                                *   FILE 523\n//*                                                                 *   FILE 523\n//*                     S  M  F  S  L  C  T                         *   FILE 523\n//*                                                                 *   FILE 523\n//*       This program will read SMF data (from the MAN             *   FILE 523\n//*      datasets or output from IFASMFDP), and will select         *   FILE 523\n//*      records according to user specified criteria.              *   FILE 523\n//*      Records can be selected by date and time, by record        *   FILE 523\n//*      type (and /or subtype), by Jobname, or by data at an       *   FILE 523\n//*      offset within the record. Records must meet date/time      *   FILE 523\n//*      and record type criteria before being eligible for         *   FILE 523\n//*      selection, as determined by Jobname and/or data            *   FILE 523\n//*      specifications.                                            *   FILE 523\n//*                                                                 *   FILE 523\n//*       By default, any records selected from the input           *   FILE 523\n//*      will be printed to SYSPRINT, unless 'PRINT=NO' is          *   FILE 523\n//*      specified in the SYSIN control cards. If SYSUT2 is         *   FILE 523\n//*      present, the selected input records will also be           *   FILE 523\n//*      written to it.                                             *   FILE 523\n//*                                                                 *   FILE 523\n//*       Multiple output files with different selection            *   FILE 523\n//*      criteria can be produced in one run of SMFSLCT. The        *   FILE 523\n//*      output DDNames and selection criteria are specified        *   FILE 523\n//*      in the control cards in SYSIN.                             *   FILE 523\n//*                                                                 *   FILE 523\n//*       Two user-written exits can be used with SMFSLCT -         *   FILE 523\n//*      the first is given control after an SMF record is          *   FILE 523\n//*      read, and the second after an SMF record has been          *   FILE 523\n//*      selected.                                                  *   FILE 523\n//*                                                                 *   FILE 523\n//*      Input:                                                     *   FILE 523\n//*          SYSUT1   - SMF dataset - either the output from        *   FILE 523\n//*                     IFASMFDP or one of the SYS1.MAN             *   FILE 523\n//*                     datasets. If this DDName is not             *   FILE 523\n//*                     allocated, it will be dynamically           *   FILE 523\n//*                     allocated to the active SMF dataset.        *   FILE 523\n//*                                                                 *   FILE 523\n//*          SYSIN    - Control cards (see below).                  *   FILE 523\n//*                                                                 *   FILE 523\n//*      Output:                                                    *   FILE 523\n//*          SYSPRINT - Error messages, selected SMF records.       *   FILE 523\n//*          SYSUT2   - optional, selected SMF records.             *   FILE 523\n//*                                                                 *   FILE 523\n//*      Attributes:                                                *   FILE 523\n//*          Re-entrant, Reuseable, Refreshable, Not Authorized,    *   FILE 523\n//*          AMODE(31), RMODE(ANY)                                  *   FILE 523\n//*                                                                 *   FILE 523\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SMFSLCT": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x19\\x01\\x12\\x01\\x1f\\x01\\x152\\x1f\\x11\\x17.~.n.~\\xd9\\xe6\\xe2\\xe4\\xc8\\xd9@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2012-01-11T00:00:00", "modifydate": "2015-11-17T11:17:19", "lines": 11902, "newlines": 11886, "modlines": 11902, "user": "RWSUHR"}, "text": "         TITLE 'Assembly Variables'\n         LCLC  &VERSION                                  @RWS 15-11-13\n         LCLC  &CPERSON                                  @RWS 15-11-13\n&VERSION SETC  'V1.72'                                   @RWS 15-11-13\n&CPERSON SETC  'RWSUHR'                                  @RWS 15-11-13\n\n         LCLC  &ASMDT\n&ASMDT   SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\nSMFSLCT  TITLE 'Introduction'\n*********************************************************************\n*                                                                   *\n*                 S  M  F  S  L  C  T                               *\n*                                                                   *\n*   This program will read SMF data (from the MAN datasets or output*\n*  from IFASMFDP), and will select records according to user        *\n*  specified criteria. Records can be selected by date and time,    *\n*  by record type (and /or subtype), by Jobname, or by data at an   *\n*  offset within the record. Records must meet date/time and        *\n*  record type criteria before being eligible for selection, as     *\n*  determined by Jobname and/or data specifications.                *\n*                                                                   *\n*   By default, any records selected from the input will be printed *\n*  to SYSPRINT, unless 'PRINT=NO' is specified in the SYSIN control *\n*  cards. If SYSUT2 is present, the selected input records will     *\n*  also be written to it.                                           *\n*                                                                   *\n*   Multiple output files with different selection criteria can be  *\n*  produced in one run of SMFSLCT. The output DDNames and selection *\n*  criteria are specified in the control cards in SYSIN.            *\n*                                                                   *\n*   Two user-written exits can be used with SMFSLCT - the first     *\n*  is given control after an SMF record is read, and the second     *\n*  after an SMF record has been selected.                           *\n*                                                                   *\n*  Input:                                                           *\n*      SYSUT1   - SMF dataset - either the output from IFASMFDP or  *\n*                 one of the SYS1.MAN datasets. If this DDName is   *\n*                 not allocated, it will be dynamically allocated to*\n*                 the active SMF dataset.                           *\n*      SYSIN    - Control cards (see below).                        *\n*                                                                   *\n*  Output:                                                          *\n*      SYSPRINT - Error messages, selected SMF records.             *\n*      SYSUT2   - optional, selected SMF records.                   *\n*                                                                   *\n*  Attributes:                                                      *\n*      Re-entrant, Reuseable, Refreshable, Not Authorized,          *\n*      AMODE(31), RMODE(ANY)                                        *\n*                                                                   *\n*  Coding    : All data areas in Dynamic Storage have names starting*\n*   Notes       with '@'. One area of Dynamic Storage is acquired   *\n*               during initialization, and is used as a LIFO stack  *\n*               for dynamic storage.                                *\n*              Conversely, data areas within the program (and thus  *\n*               are read-only) have names that do not start with    *\n*               an '@'.                                             *\n*                                                                   *\n*              The names of the Routines (and non-data labels within*\n*               the routines) follow the pattern:                   *\n*                 xnnnn                                             *\n*               where x    is 1 or more alphabetic characters       *\n*                     nnnn is a numeric sequence number             *\n*                                                                   *\n*              Data in dynamic storage that are globally accessible *\n*               have names of the form:                             *\n*                @_anyname                                          *\n*              Data associated with a routine typically have names: *\n*                 x_anyname or @x_anyname                           *\n*               where 'x' is the alphabetic character associated    *\n*                         with the routine                          *\n*              Addressability to globally-accessible dynamic data is*\n*               via R12; local dynamic data is addressable via R13. *\n*                                                                   *\n*              Each routine establishes it's own base register(s),  *\n*               and has access only to it's own read-only variables.*\n*               Base registers are typically R11.                   *\n*                                                                   *\n*  Sample Installation JCL:                                         *\n*                                                                   *\n*  //SMFSLCTA JOB blah,blah                                         *\n*  //*                                                              *\n*  //ASM     EXEC PGM=ASMA90,REGION=4M,                             *\n*  //             PARM='NODECK,OBJECT,RENT,XREF(SHORT),NOALIGN'     *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB                          *\n*  //          DD DISP=SHR,DSN=SYS1.MODGEN                          *\n*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),      *\n*  //             UNIT=SYSALLDA                                     *\n*  //SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),           *\n*  //             UNIT=SYSALLDA,DISP=(MOD,PASS),                    *\n*  //             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB)              *\n*  //SYSIN     DD DISP=SHR,DSN=source-program                       *\n*  //*                                                              *\n*  //LKED    EXEC PGM=HEWL,REGION=4M,COND=(0,LT),                   *\n*  //             PARM='LIST,MAP,RENT,REUS,REFR'                    *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)                       *\n*  //          DD DDNAME=SYSIN                                      *\n*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND)       *\n*  //             UNIT=SYSALLDA                                     *\n*  //SYSLMOD   DD DISP=SHR,DSN=loadlib                              *\n*  //                                                               *\n*                                                                   *\n*  Change Log:                                                      *\n*      1999/04/24 SDDA030 V1.1                                      *\n*                 Added code to ignore records invalidly spanned    *\n*                 in non-VSAM VBS input.                            *\n*                 Calculated DCB=NCP (BSAM), DCB=BUFNO (QSAM), or   *\n*                 AMP=BUFSP (VSAM) so we can read a cylinder of     *\n*                 input at a time (if input on DASD).               *\n*                 Used MACRF=PM on output file(s), so VBS datasets  *\n*                 can be created.                                   *\n*                 Lives and executes in 31-bit mode.                *\n*                 Used internal LIFO stack for dynamic storage      *\n*                 Made Y2K compliant!                               *\n*      1999/07/22 SDDA030 V1.2                                      *\n*                 Added Date conversion routines.                   *\n*                 Added new START=/END= date keywords.              *\n*                 Added 24-bit EODAD for SYSIN, if required         *\n*      1999/11/18 SDDA030 V1.3                                      *\n*                 Moved SYSUT1 OPEN logic(?) to its own subroutine  *\n*                 (I0010)                                           *\n*                 Added comments                                    *\n*                                                                   *\n*      2002/02/07 SDDA030 V1.4                                      *\n*                 Added stack below the line.                       *\n*                 Added new parms for exits as suggested by Dave    *\n*                 Alcock.                                           *\n*                 Added parms to INEXIT=/OUTEXIT= statements.       *\n*                 Defaulted 2-digit years on START=/END= to the     *\n*                 current century.                                  *\n*                 Corrected S0C4 Abends when lots of record types   *\n*                 or jobnames selected (Thanks to Paul              *\n*                 Luttenberger).                                    *\n*                 Changed RDJFCBs to SWAREQs.                       *\n*                 Corrected logic when setting DCB characteristics  *\n*                 for new output datasets with no DCB spacified.    *\n*                 Printed **VIO** for volser when appropriate.      *\n*      2006/10/26 SDDA030 V1.5                                      *\n*                 Fixed bug when printing record subtypes to be     *\n*                 selected (thanks to BBordonaro).                  *\n*                 Corrected calculation of SYSPRINT LRECL (fixed    *\n*                 check for CC) (thanks to Martin Samson).          *\n*                 Corrected non-re-entrancy error with SYSUT1 EXLST *\n*                 (thanks to Martin Samson - again!).               *\n*                                                                   *\n*      2013-03-19 RWSUHR  V1.6                                      *\n*                 Set return code to 8 if nothing is selected       *\n*                                                                   *\n*      2015-10-21 RWSUHR  V1.7                                      *\n*                                                                   *\n*      2015-11-13 RWSUHR  V1.72 - @RWS                              *\n*                 Fixed an S0C7, when OUTPUT= was specified         *\n*                 added assembly date and time and change person    *\n*                 ID (ID of person who last changed this program)   *\n*                 Roger W. Suhr (State of Indiana - IOT)            *\n*                                                                   *\n*  Author:                                                          *\n*   All comments, criticisms and suggestions gratefully received.   *\n*     Paul Dion  (pdion@canada.com)                                 *\n*                                                                   *\n*********************************************************************\n         TITLE 'Control Cards'\n*********************************************************************\n*                                                                   *\n*                 C o n t r o l   C a r d s                         *\n*                                                                   *\n*   Control cards are entered via SYSIN. Only columns 1-72 are      *\n*  scanned, and the scan terminates with the first blank. Cont-     *\n*  inuations are not allowed, but keywords can be specified more    *\n*  than once. If a keyword that has a single value (ie, START=)     *\n*  is specified more than once within an output group, or globally, *\n*  the last value specified is used.                                *\n*                                                                   *\n*   OUTPUT=DDName                                                   *\n*      specifies the DDName of an output dataset. All subsequent    *\n*                control statements, until the next \"OUTPUT=\"       *\n*                statement or end-of-file, determine which input    *\n*                records will be selected to this DDName. All       *\n*                control statements appearing before an \"OUTPUT=\"   *\n*                statement apply to all output DDNames, unless      *\n*                specifically overridden by control statements      *\n*                entered after the \"OUTPUT=\" statement.             *\n*                                                                   *\n*   START=yyddd-hhmmss                                              *\n*         yyyyddd-hhmmss                                            *\n*         TODAY-hhmmss                                              *\n*         (TODAY-n)-hhmmss                                          *\n*         YESTERDAY-hhmmss                                          *\n*         THISWEEK-hhmmss                                           *\n*         LASTWEEK-hhmmss                                           *\n*         THISMONTH-hhmmss                                          *\n*         LASTMONTH-hhmmss                                          *\n*      specifies the date and time at which selection of input      *\n*                records is to start. Defaults to 00000-000000 (ie  *\n*                the start of the input file). The specification of *\n*                time (-hhmmss) is optional - if omitted, it def-   *\n*                aults to 00:00:00.00.                              *\n*                Dates using the 2-digit year format will default   *\n*                to dates in the current century.                   *\n*                YESTERDAY is equivalent to specifying (TODAY-1).   *\n*                Note that a week starts on Monday, and ends on     *\n*                Sunday. Thus, specifying START=LASTWEEK will start *\n*                selecting records from the Monday of the previous  *\n*                week.                                              *\n*                                                                   *\n*   END=yyddd-hhmmss                                                *\n*       yyyyddd-hhmmss                                              *\n*       TODAY-hhmmss                                                *\n*       (TODAY-n)-hhmmss                                            *\n*       YESTERDAY-hhmmss                                            *\n*       THISWEEK-hhmmss                                             *\n*       LASTWEEK-hhmmss                                             *\n*       THISMONTH-hhmmss                                            *\n*       LASTMONTH-hhmmss                                            *\n*      specifies the date and time at which selection if input      *\n*                records is to stop. Defaults to 2699999-235959 (ie *\n*                the end of the input file). The specification of   *\n*                time (-hhmmss) is optional - if omitted, it def-   *\n*                aults to 23:59:59.99.                              *\n*                Dates using the 2-digit year format will default   *\n*                to dates in the current century.                   *\n*                YESTERDAY is equivalent to specifying (TODAY-1).   *\n*                Note that a week starts on Monday, and ends on     *\n*                Sunday. Thus, specifying END=LASTWEEK will stop    *\n*                selecting records on the Sunday of the previous    *\n*                week.                                              *\n*                                                                   *\n*   PERIOD=hhmmss-hhmmss                                            *\n*      specifies the start and stop time-of-day between which input *\n*                records will be eligible for selection. Records for*\n*                each day, as specified by start/end or defaulted,  *\n*                falling outside these times will be ignored.       *\n*                 The time can be specified as hh, hhmm or hhmmss;  *\n*                the missing digits will default to 0.              *\n*                 Defaults to \"PERIOD=000000-240000\".               *\n*                                                                   *\n*   WEEKENDS=IGNORE                                                 *\n*      specifies that SMF data generated on Saturday and Sunday will*\n*                be ignored.                                        *\n*                                                                   *\n*   INCLUDE=nn<(ss)>                                                *\n*      specifies that record type nn should be selected. A subtype  *\n*                ss can also be optionally included, in parentheses.*\n*                If more that one record type is coded on the       *\n*                control card, the record types (and subtypes)      *\n*                must be enclosed in parentheses.                   *\n*                SMF Record Type 30 is used as a model to determine *\n*                the SubType location.                              *\n*                Note that 'INCLUDE' is mutually exclusive with the *\n*                'EXCLUDE' keyword within an \"OUTPUT=\" definition,  *\n*                or globally, if no \"OUTPUT=\" statement is present. *\n*                                                                   *\n*   EXCLUDE=nn<(ss)>                                                *\n*      specifies that record type nn should not be selected. A      *\n*                subtype ss can optionally be included, in paren-   *\n*                theses. If more than one record type is coded,     *\n*                the record types (and subtypes) and subtypes must  *\n*                be enclosed in parentheses.                        *\n*                Note that 'EXCLUDE' is mutually exclusive with the *\n*                'INCLUDE' keyword within an \"OUTPUT=\" definition,  *\n*                or globally, if no \"OUTPUT=\" statement is present. *\n*                                                                   *\n*   PRINT=NO                                                        *\n*   PRINT=EBCDIC                                                    *\n*         NO     specifies that selected records are not to be      *\n*                printed on SYSPRINT. If an output ddname is        *\n*                present, selected records will be written to it.   *\n*         EBCDIC specifies that selected records are to be printed  *\n*                on SYSPRINT in EBCDIC only (the default is dump    *\n*                format). If an output ddname is present, the       *\n*                selected records will be written to it.            *\n*                                                                   *\n*   SEQUENCE=YES                                                    *\n*                specifies that the input records are in date/time  *\n*                sequence. If 'SEQUENCE=YES' is specified, SMFSLCT  *\n*                will terminate as soon as a record with a date     *\n*                stamp past the 'END=' date/time is encountered.    *\n*                Normal SMFSLCT processing assumes that the input   *\n*                records are not in sequence, and invokes           *\n*                termination at end-of-file.                        *\n*                                                                   *\n*   CHECKVBS=NO                                                     *\n*                specifies that no checking should be performed for *\n*                variable spanned segmentation errors. If this      *\n*                is specified, QSAM will be used to read SYSUT1,    *\n*                and invalid segment sequences will cause an S002   *\n*                (or potentially other system) abend. The default   *\n*                is that BSAM will be used to read VS or VBS files, *\n*                and invalid segments discarded.                    *\n*                Note that using BSAM requires more CPU time; where *\n*                the input file is known to be 'clean', specifying  *\n*                CHECKVBS=NO will reduce the CPU time used by this  *\n*                program.                                           *\n*                                                                   *\n*   JOBNAME=jjjjjjjj                                                *\n*      specifies that all records (subject to \"INCLUDE\"/\"EXCLUDE\",  *\n*                above), Job (or TSU or STC) jjjjjjjj should be     *\n*                selected.                                          *\n*                If more that one jobname is coded, the jobnames    *\n*                should be enclosed in parentheses.                 *\n*                 If the last character in the jobname is an        *\n*                asterisk, the characters preceeding the asterisk   *\n*                considered a prefix, and all jobnames that match   *\n*                the prefix will be selected.                       *\n*                SMF Record Type 5 is used as a model to determine  *\n*                the location of the Jobname field.                 *\n*                                                                   *\n*   DATA=xxx<,nn>                                                   *\n*      specifies the character string that must be present in the   *\n*                input record before it will be selected.           *\n*                DATA= indicates that the string xxx (specified     *\n*                      either as a data(xxx...x), a character string*\n*                      (C'xxx...x) or a hex string(X'xxx...x)) must *\n*                      start at offset position nn (nn=0-32767,     *\n*                      default=0), for the input record to be       *\n*                      selected. Note that the offset must include  *\n*                      the length of the RDW.                       *\n*                                                                   *\n*   JOB/DATA=OR                                                     *\n*      specifies that the selection algorithm should select an      *\n*                      input record if either the Jobname or data   *\n*                      specifications are met. The default is that  *\n*                      both Jobname and data criteria must be       *\n*                      satisfied before a record will be selected.  *\n*                                                                   *\n*   STOPAFT=nnn                                                     *\n*      specifies that SMFSLCT is to terminate after selecting nnn   *\n*                      records (nnn = 1 to 999999999). The default  *\n*                      is to terminate when end-of-file is reached  *\n*                      on input.                                    *\n*                                                                   *\n*   INEXIT=(member-name<,parm>)                                     *\n*      specifies that SMFSLCT is to invoke member-name after        *\n*                      each SMF record is read from the input, and  *\n*                      after checking the date/time against \"START=\"*\n*                      and \"END=\", but before checking any other    *\n*                      selection criteria.                          *\n*                      \"parm\" is an optional string that will be    *\n*                      passed to the exit each time it is invoked.  *\n*                      If present, the operands of INEXIT= must     *\n*                      be enclosed in parentheses. Further, if parm *\n*                      contains a close parenthesis, it must be     *\n*                      enclosed in quotes (as per IBM, if parm also *\n*                      contains a quote, it must be coded as two    *\n*                      two consecutive quotes).                     *\n*                                                                   *\n*   OUTEXIT=(member-name<,parm>)                                    *\n*      specifies that SMFSLCT is to invoke member-name after        *\n*                      an SMF record has been selected, but before  *\n*                      the record is printed and/or written to the  *\n*                      output file(s).                              *\n*                      \"parm\" is an optional string that will be    *\n*                      passed to the exit each time it is invoked.  *\n*                      If present, the operands of OUTEXIT= must    *\n*                      be enclosed in parentheses. Further, if parm *\n*                      contains a close parenthesis, it must be     *\n*                      enclosed in quotes (as per IBM, if parm also *\n*                      contains a quote, it must be coded as two    *\n*                      two consecutive quotes).                     *\n*                                                                   *\n*  Example:                                                         *\n*  //SMFSLCT  JOB blah,blah                                         *\n*  //STEP1   EXEC PGM=SMFSLCT,REGION=6M                             *\n*  //STEPLIB   DD DISP=SHR,DSN=if-required                          *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSUT1    DD DISP=unloaded-man-file,DISP=SHR                   *\n*  //OUT1      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //OUT2      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //OUT3      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //SYSIN     DD *                                                 *\n*  START=87015,END=87017-170000                                     *\n*  OUTPUT=OUT1                                                      *\n*   INCLUDE=(30(2),20,5)                                            *\n*   JOBNAME=JOBONE                                                  *\n*   PRINT=NO                                                        *\n*  OUTPUT=OUT2                                                      *\n*   START=87013-081500,END=87013-170000                             *\n*   INCLUDE=34                                                      *\n*   JOBNAME=(TSO1,TSO2)                                             *\n*  OUTPUT=OUT3                                                      *\n*   DATA=C'A B C',257                                               *\n*   OUTEXIT=EXIT5                                                   *\n*  /*                                                               *\n*                                                                   *\n*       SMFSLCT will read the unloaded MAN file specified by SYSUT1.*\n*       Note that if SYSUT1 were not specified, the active MAN      *\n*       file would be read.                                         *\n*       SMFSLCT will ignore any input records produced before       *\n*       00:00:00 on 87.015, and terminate after finding a record    *\n*       produced after 17:00:00 on 87.017.                          *\n*       For the output file specified by DDName OUT1:               *\n*        Record types 5, 20, and 30 subtype 2, for Jobs with the    *\n*        name \"JOBONE\" will be selected, but not printed.           *\n*       For the output file specified by DDName OUT2:               *\n*        Record type 34 for Jobs (TSO users) with the names \"TSO1\"  *\n*        or \"TSO2\" will be selected, and printed.                   *\n*        The global date specification is overridden for this       *\n*        output file only.                                          *\n*       For the output file specified by DDName OUT3:               *\n*        All records containing the character string \"A B C\" in     *\n*        positions 257-261 (relative to 0, including the RDW) will  *\n*        be selected and printed. The exit \"EXIT5\" will be invoked  *\n*        for each record selected for \"OUT3\"                        *\n*                                                                   *\n*       Note that the selection criteria for the different output   *\n*       files are indented: this is for readability only - SMFSLCT  *\n*       ignores leading blanks.                                     *\n*                                                                   *\n*********************************************************************\n         TITLE 'Processing Overview'\n*********************************************************************\n*                                                                   *\n*          P r o c e s s i n g   O v e r v i e w                    *\n*                                                                   *\n*  Initialization.                                                  *\n*     SMFSLCT first opens SYSPRINT - if this file cannot be OPENed  *\n*    SMFSLCT terminates immediately. SYSIN statements (if present)  *\n*    are then read and interpreted. Assuming there were             *\n*    no control card errors, an OPEN is attempted for SYSUT1.       *\n*    If this fails, SYSUT1 is dynamically allocated to the active   *\n*    SMF file, and OPENed. Next, the JFCB for each output DDName is *\n*    read. If the output file is NEW, and DCB characteristics are   *\n*    not present in the JFCB, SMFSLCT assigns the RECFM, LRECL and  *\n*    BLKSIZE from SYSUT1 (if SYSUT1 is a VSAM dataset, RECFM=VBS,   *\n*    LRECL=32767, BLKSIZE=4096 are assigned as a default). If the   *\n*    output dataset is OLD or SHR, no DCB changes are made.         *\n*     If exits were specified, SMFSLCT 'LOAD's them, and saves      *\n*    their EP addresses.                                            *\n*                                                                   *\n*  Processing.                                                      *\n*     A record is read from SYSUT1, and, as long as it is not a dump*\n*    header or trailer (record type 2 or 3), it is checked against  *\n*    the start and stop times. If it is before the start time, the  *\n*    record is ignored, and the next record is read. If it is after *\n*    the stop time, termination is initiated.                       *\n*     After the start and stop time checks, the INEXIT (if present) *\n*    is invoked. If the exit indicates that this record should be   *\n*    selected (RC=4), all further checks are bypassed. If the exit  *\n*    indicates the record should be skipped (RC=8), the record is   *\n*    ignored. If the exit indicates that SMFSLCT should terminate,  *\n*    the stop date and time is set to 0, so that the next input     *\n*    record will cause termination to be invoked. If the exit is    *\n*    not present, or indicates that normal processing should cont-  *\n*    inue (RC=0), the selection criteria are checked.               *\n*     The first selection check is record type (INCLUDE=/EXCLUDE=). *\n*    If the record passes this check, the job name criteria         *\n*    (JOBNAME=) is checked. If the SMF record does not 'belong' to  *\n*    one of the Jobnames specified in the control cards (assuming   *\n*    that at least one Jobname was entered), the record is skipped, *\n*    unless JOB/DATA=OR was specified. If it was, or the SMF record *\n*    passed the Jobname check, the data criteria (DATA=) are exam-  *\n*    ined. If the data specified are present in the SMF record, the *\n*    record will be selected.                                       *\n*     Once an input record is selected, the output exit (OUTEXIT=), *\n*    if present, is invoked. This exit can indicate that the record *\n*    should be ignored (RC=8), that processing should terminate     *\n*    after this record (RC=12), or that normal processing should    *\n*    continue (RC=0).                                               *\n*     A selected record is first printed (unless PRINT=NO was       *\n*    specified in the control cards), either in the default dump    *\n*    format, or in EBCDIC only (PRINT=EBCDIC). Then, if output files*\n*    are open, the selected record is written to them. The output   *\n*    record length is checked against the input, and the input rec- *\n*    ord truncated or padded with blanks as appropriate. If the     *\n*    output RECFM is fixed, the SMF record is written without the   *\n*    RDW.                                                           *\n*                                                                   *\n*  Termination.                                                     *\n*     Termination is invoked either because an input SMF record's   *\n*    date and time is greater than the stop date and time, or       *\n*    because EOF was reached on the input file. The counters are    *\n*    printed, and all open files are closed. The exits are invoked  *\n*    one last time, and then deleted. All getmained storage is      *\n*    freed, and standard exit code is executed to return to OS.     *\n*                                                                   *\n*********************************************************************\n         TITLE 'User Exits'\n*********************************************************************\n*                                                                   *\n*     SMFSLCT has provision for two exits that will be invoked      *\n*    after a record is read, or a record is about to be written.    *\n*    Each exit receives the address of the SMF record as a parm.    *\n*    The exits can cause the SMF record to be selected or ignored   *\n*    (via the return codes), or can modify (or replace) the SMF     *\n*    record. The only restriction is that the record returned to    *\n*    SMFSLCT must remain a valid variable-length record.            *\n*                                                                   *\n*     SMFSLCT also provides to each exit a word of storage that the *\n*    exit can use in any manner whatsoever - SMFSLCT will not alter *\n*    the contents of this word (other than to initialize it to 0    *\n*    before the first invocation of the exit).                      *\n*                                                                   *\n*     The exits are LOADed at initialization, invoked via a BASR    *\n*    instruction at various points in the processing, and then      *\n*    DELETEd during termination. 'Global' exits (those that are     *\n*    named by INEXIT=/OUTEXIT= statements before any OUT= statement)*\n*    are LOADED only once; 'local' exits (those named after an      *\n*    OUT= statement, even if they are the same as the 'global'      *\n*    exits) are LOADed for each output statement. Thus, if an exit  *\n*    is not reusable, there may be multiple versions LOADed and     *\n*    invoked.                                                       *\n*                                                                   *\n*     The names of the exits are specified with the \"INEXIT=\" and   *\n*    \"OUTEXIT=\" control statement keywords (see above). The exits   *\n*    are invoked once for each output file, at 3 different points:  *\n*      Initialization: A(SMF Record) = 0                            *\n*                      Input count = -1                             *\n*      Processing    : A(SMF Record) > 0                            *\n*      Termination   : A(SMF Record) = 0                            *\n*                      Input Count >= 0                             *\n*                                                                   *\n*     The parms passed to the exits are the same for both INEXIT    *\n*    and OUTEXIT (all parameters reside below-the-line):            *\n*        R1 ---> A(SMF record) or 0                                 *\n*                                                                   *\n*                A(A word for the user)                             *\n*                  This word is 'output-file specific'; that is,    *\n*                  the same word will be passed to the INEXIT and   *\n*                  the OUTEXIT for the same output file (ie, when   *\n*                  the 6th parm, the address of the DDName, is      *\n*                  pointing to the same value). For different output*\n*                  files, a different word is passed.               *\n*                                                                   *\n*                A(HL2'length', parm as coded on the xxxEXIT=       *\n*                  statement. Note that the length is the length of *\n*                  the parm, and that any quotes surrounding the    *\n*                  parm have been removed)                          *\n*                                                                   *\n*                A(Fullword containing input count)                 *\n*                                                                   *\n*                A(Fullword containing output count)                *\n*                                                                   *\n*                A(DDName of output file)                           *\n*                                                                   *\n*                A(SYSPRINT routine. This routine can be invoked to *\n*                  cause SMFSLCT to write a record to SYSPRINT. If  *\n*                  this routine is invoked,                         *\n*                   R1 : A(2-word parmlist):                        *\n*                          A(Data to be printed)                    *\n*                          Length of data to be printed             *\n*                   R13: A(Standard 72-byte O/S save area)          *\n*                   R14: Return Address                             *\n*                   R15: EPA                                        *\n*                  This routine is also IDENTIFYed as SMFSLCTP, and *\n*                 so can be CALLed, LINKed, etc.                    *\n*                                                                   *\n*  INEXIT.                                                          *\n*     The input exit is specified using the \"INEXIT=\" control       *\n*    statement keyword, and is invoked after each SMF record is     *\n*    read and determined to be within the start and end times       *\n*    specified in the control cards (\"START=\", \"END=\"). The exit    *\n*    receives the address of the SMF record as a parm, and can      *\n*    modify the contents of the record, if required. If the exit    *\n*    wishes to replace the SMF record with another, the exit can    *\n*    change the address in the pointer to the SMF record so that it *\n*    points to a different area of storage, containing the new SMF  *\n*    record.                                                        *\n*     Note that the input exit is invoked (perhaps non-intuitively) *\n*    for each output file.                                          *\n*                                                                   *\n*     On Exit,                                                      *\n*        R15  =  0, Continue normal processing                      *\n*                4, Unconditionally select this record              *\n*                8, Ignore this record                              *\n*               12, Terminate SMFSLCT after this record             *\n*                                                                   *\n*  OUTEXIT.                                                         *\n*     The output exit is specified using the \"OUTEXIT=\" control     *\n*    statement keyword, and is invoked after an SMF record has been *\n*    selected (because it satisfied selection criteria, or it was   *\n*    unconditionally selected by the input exit). The exit          *\n*    receives the address of the SMF record as a parm, and can      *\n*    modify the contents of the record, if required. If the exit    *\n*    wishes to replace the SMF record with another, the exit can    *\n*    change the address in the pointer to the SMF record so that it *\n*    points to a different area of storage, containing the new SMF  *\n*    record.                                                        *\n*     On Exit,                                                      *\n*        R15  =  0, Continue normal processing                      *\n*                4, Unused                                          *\n*                8, Ignore this record                              *\n*               12, Terminate SMFSLCT after this record             *\n*                                                                   *\n*********************************************************************\n         TITLE 'STACK Macro'\n         MACRO\n&NAME    STACK &TYPE,&LOC=,&LEN=,&STACK=,&ADDR=\n         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN\n         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH01\n         AIF   ('&TYPE(1)' EQ 'POP').POP01\n         AIF   ('&TYPE(1)' EQ 'INIT').INIT01\n         AIF   ('&TYPE(1)' EQ 'TERM').TERM01\n         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'\n         AGO   .MEND\n.*\n.INIT01  ANOP\n         AIF   ('&LEN' EQ '').INITE01\n         AIF   ('&LEN'(1,1) NE '(').INIT02\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' NE  '1').INIT03\n         MNOTE 8,'LEN= register must be 0 or 2-15'\n         AGO   .MEND\n         AGO   .INIT03\n.INIT02  ANOP\n&LENREG  SETC  'R0'\n         LA    &LENREG,&LEN Length of Stack\n.INIT03  ANOP\n&LOCTN   SETC  '&LOC'\n         AIF   ('&LOC' NE '').INIT04\n&LOCTN   SETC  'ANY'\n.INIT04  ANOP\n         LA    R1,StackHdr_Length       Length of header\n         AR    &LENREG,R1               Bump length\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=&LOCTN                anywhere\n         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length\n         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)\n         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)\n         AIF   ('&STACK' EQ '').INIT99\n         AIF   ('&STACK'(1,1) EQ '(').INIT92\n         ST    R1,&STACK                Save Stack origin\n         AGO   .INIT99\n.INIT92  ANOP\n         LR    &STACK(1),R1             Load return register\n         AGO   .INIT99\n.INIT99  ANOP\n         AIF   (D'Stack).MEND\nStack               DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This is a LIFO stack that is used by various procedures in the  *\n*  program to acquire storage. The Stack is GETMAINed at the beg-   *\n*  inning of the program, and is typically used by procedures to    *\n*  acquire storage for local variables (i.e., variables that are    *\n*  used only within the procedures), although the main procedure    *\n*  also uses a stack area to store Global variables (i.e., those    *\n*  that are available throughout the program).                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nStackHdr            EQU   *           Start of Header\nStackHdr_StackLen   DS    FL4          Length of Stack\nStackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)\nStackHdr_Length     EQU   *-StackHdr  Length of Header\n\n&SYSECT  &SYSSTYP\n         AGO   .MEND\n.INITE01 ANOP\n         MNOTE 8,'LEN must be specified for STACK INIT'\n         AGO   .MEND\n.*\n.PUSH01  ANOP\n         AIF   ('&STACK' EQ '').PUSM02\n         AIF   ('&STACK'(1,1) NE '(').PUSH01A\n&STKREG  SETC  '&STACK(1)'\n         AGO   .PUSH02\n.PUSH01A ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.PUSH02  ANOP\n         AIF   ('&LEN' EQ '').PUSHE01\n         AIF   ('&LEN'(1,1) NE '(').PUSH03\n&LENREG  SETC  '&LEN(1)'\n         AGO   .PUSH04\n.PUSH03  ANOP\n&LENREG  SETC  'R0'\n.PUSH04  ANOP\n         LA    &LENREG,&LEN\n         LA    R1,7                     Make\n         AR    &LENREG,R1                a\n         SRL   &LENREG,3                 doubleword\n         SLL   &LENREG,3                 multiple\n         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         AR    R1,&LENREG               Bump by length requested\n         SLR   R1,&STKREG               Get Stack used\n         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?\n         BL    *+8                      No, OK\n         BAL   R14,0                    ABEND\n         ALR   R1,&STKREG               No, offset to address\n         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         SLR   R1,&LENREG               A(Start of storage area)\n         AIF   ('&ADDR' EQ '').MEND\n         AIF   ('&ADDR'(1,1) NE '(').PUSH92\n         LR    &ADDR(1),R1             Load return register\n         AGO   .MEND\n.PUSH92  ANOP\n         ST    R1,&ADDR                 Save Stack origin\n         AGO   .MEND\n.PUSHE01 ANOP\n         MNOTE 8,'LEN must be specified for STACK PUSH'\n         AGO   .MEND\n.PUSHE02 ANOP\n         MNOTE 8,'STACK must be specified for STACK PUSH'\n         AGO   .MEND\n.*\n.POP01   ANOP\n         AIF   ('&ADDR' EQ '').POPE01\n         AIF   ('&ADDR'(1,1) NE '(').POP02\n&ADDREG  SETC  '&ADDR(1)'\n         AGO   .POP02A\n.POP02   ANOP\n&ADDREG  SETC  'R0'\n         L     &ADDREG,&ADDR\n.POP02A  ANOP\n         AIF   ('&STACK' EQ '').POPE02\n         AIF   ('&STACK'(1,1) NE '(').POP03\n&STKREG  SETC  '&STACK(1)'\n         AGO   .POP04\n.POP03   ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.POP04   ANOP\n         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)\n         AGO   .MEND\n.POPE01  ANOP\n         MNOTE 8,'ADDR must be specified for STACK POP'\n         AGO   .MEND\n.POPE02  ANOP\n         MNOTE 8,'STACK must be specified for STACK POP'\n         AGO   .MEND\n.*\n.TERM01  ANOP\n         AIF   ('&STACK' EQ '').TERME02\n         AIF   ('&STACK'(1,1) NE '(').TERM03\n&STKREG  SETC  '&STACK(1)'\n         AGO   .TERM04\n.TERM03  ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.TERM04  ANOP\n         L     R0,StackHdr_StackLen-StackHdr(0,&STKREG) Length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(&STKREG),           starting here                 +\n               LENGTH=(0)                for this long\n         AGO   .MEND\n.TERME02 ANOP\n         MNOTE 8,'STACK must be specified for STACK TERM'\n         AGO   .MEND\n.*\n.MEND    ANOP\n         MEND\n         TITLE 'IBM DSECTs'\n         PUSH  PRINT\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IKJTCB\n         IEFTIOT1\n         IEESMCA\n         IEFJFCBN\n         DCBD  DSORG=PS\n         IHADCBE\n         IHADVA\n         IEFUCBOB DEVCLAS=DA,LIST=NO\n         IEFZB505 LOCEPAX=YES\n         IEFJESCT\n         IEFQMIDS\n         IFASMFR (0,5,30)\n         IFGACB\nSYSUT1_ACB_Length EQU   *-IFGACB      Length of ACB\n         IFGRPL\nSYSUT1_RPL_Length EQU   *-IFGRPL      Length of RPL\n         IEFZB4D0\n         IEFZB4D2\n         POP   PRINT\n         TITLE 'Local DSECTs'\nOutDesc_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Output Descriptor Table contains one entry for each output  *\n*  file specified (in the \"OUTPUT=\" control card). Each entry is    *\n*  initialized with the default parameters, and then modified with  *\n*  the parameters entered via control cards. The first entry con-   *\n*  tains the default parms, and is used as the \"global\" entry.      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nODT_SubPool_Nbr     EQU   0           Subpool for this table\nODT_Subp_Len        DS    0F          Length and Subpool of table\nODT_SubPool         DS    X            SubPool\nODT_Length          DS    FL3          Length\nODT_Entry_Count     DS    HL2         Nbr entries in the table\nODT_Entry           DS    0F          Table Entry\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Output Descriptor Entry. There is one entry for each output    *\n*   file (defined using the \"OUTPUT=\" statement), plus one entry    *\n*   (the first) used as a default entry.                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nODTE_DCB_Ptr        DS    AL4          A(Output DCB)\nODTE_DDName         DS    CL8          Associated DDName\nODTE_RTT_Ptr        DS    AL4          A(Record Type Table)\nODTE_JNT_Ptr        DS    AL4          A(JobName Table)\nODTE_DT_Ptr         DS    AL4          A(Data Table)\nODTE_Selected       DS    FL4          Nbr Records Selected\nODTE_StopAft        DS    FL4          Stop after selecting this many\nODTE_InExit         DS    CL8          Input Exit Name\nODTE_InExit_Ptr     DS    AL4          A(Input Exit)\nODTE_InExit_Data    DS    FL4          Input Exit Data Area\nODTE_InExit_Parm_Ptr DS   AL4          A(Parm data for InExit)\nODTE_OutExit        DS    CL8          Output Exit Name\nODTE_OutExit_Ptr    DS    AL4          A(Output Exit)\nODTE_OutExit_Data   DS    FL4          Output Exit Data Area\nODTE_OutExit_Parm_Ptr DS  AL4          A(Parm data for OutExit)\nODTE_LRECL          DS    HL2          Max Output Record Length\nODTE_StartDate      DS    PL4          Start Date\nODTE_StartTime      DS    FL4            and Time\nODTE_EndDate        DS    PL4          End Date\nODTE_EndTime        DS    FL4            and Time\nODTE_PeriodStart    DS    FL4          Period Start Time\nODTE_PeriodEnd      DS    FL4          Period End Time\n                    DS    X            Flag Byte\nODTE_Print_NO       EQU   *-1,X'80'     1... .... PRINT=NO Specified\nODTE_Print_EB       EQU   *-1,X'40'     .1.. .... PRINT=EBCDIC Spec\nODTE_JobData_OR     EQU   *-1,X'20'     ..1. .... JOB/DATA=OR\nODTE_Trunc          EQU   *-1,X'10'     ...1 .... Output Rec Truncated\nODTE_CopyOnly       EQU   *-1,X'08'     .... 1... No selection criteria\nODTE_Inactive       EQU   *-1,X'04'     .... .1.. Inactive Entry\nODTE_Ignore_Weekend EQU   *-1,X'02'     .... ..1. WEEKEND=IGNORE\n                    DS    X            Flag Byte\nODTE_No_Dflt_InExit EQU   *-1,X'80'     1... .... Do not use default\nODTE_No_Dflt_OutExit EQU  *-1,X'40'     .1.. .... Do not use default\n\nODTE_Output_Count_Table DS  256FL4     Selected count by record type\n\nODTE_Length         EQU   *-ODT_Entry  Entry Length\n\n\n\nJobName_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The JobName Table is built when it is determined that the user  *\n*  wishes to select input records by jobname. The table             *\n*  consists of a header portion (describing the table as a whole),  *\n*  and then one entry for each valid jobname control card found.    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nJNT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE\nJNT_Subpool         DS    X            SUBPOOL\nJNT_Length          DS    FL3          LENGTH\nJNT_Entry_Count     DS    HL2          NBR ENTRIES IN THE TABLE\nJNT_Entry           EQU   *            DATA ENTRY\nJNTE_JobName_Len    DS    X             EXECUTE LENGTH OF JOBNAME/PFX\nJNTE_JobName        DS    CL8           JOBNAME, PADDED WITH BLANKS\nJNTE_Length         EQU   *-JNT_Entry\n\n\n\nRecType_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   THE RECORD TABLE IS BUILT WHEN IT IS DETERMINED THAT THE USER   *\n*  WISHES TO INCLUDE OR EXCLUDE RECORDS BY RECORD TYPE. EACH ENTRY  *\n*  CONSISTS OF TWO BYTES, A RECORD TYPE AND A SUBTYPE. All entries  *\n*  are either 'INCLUDE's or 'EXCLUDE's, as indicated by a flag in   *\n*  the header of the table.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nRTT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE\nRTT_Subpool         DS    X            SUBPOOL\nRTT_Length          DS    FL3          LENGTH\nRTT_Entry_Count     DS    HL2         NBR ENTRIES IN TABLE\n                    DS    X           Flag byte\nRTT_Entry_Include   EQU   *-1,X'80'    1... .... INCLUDE=\nRTT_Entry_Exclude   EQU   *-1,X'40'    .1.. .... EXCLUDE=\n                    DS    X           Reserved\nRTT_Entry           EQU   *           RECORD TABLE ENTRY\nRTTE_RecType        DS    X            RECORD TYPE\n                    DS    X            Flag Byte\nRTTE_SubType_Present EQU  *-1,X'80'     1... .... Subtype present\nRTTE_SubType        DS    XL2          SUBTYPE\nRTTE_Length         EQU   *-RTT_Entry Entry length\n\n\n\nData_Tbl            DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Data Table is built when it is determined that the user     *\n*  wishes to select input records by data in the record. The table  *\n*  consists of a header portion (describing the table as a whole),  *\n*  and then one entry for each valid 'data' control statement       *\n*  found, containing:                                               *\n*                     - the offset at which the data must be found  *\n*                       before the record will be selected,         *\n*                     - the execute length of the data, and         *\n*                     - the data.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nDT_Subp_Len         DS    0F          LENGTH AND SUBPOOL OF TABLE\nDT_Subpool          DS    X            SUBPOOL\nDT_Length           DS    FL3          LENGTH\nDT_Entry_Count      DS    HL2         NBR ENTRIES IN THE TABLE\nDT_Entry            EQU   *           DATA ENTRY\nDTE_Offset          DS    HL2          OFFSET OF DATA\nDTE_Length          DS    X            EXECUTE LENGTH OF DATA\nDTE_Data            EQU   *            DATA\n\n\nBuffArea            DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Buffer Area is used only when SYSUT1 is VS or VBS, and      *\n*  non-VSAM. Under these circumstances, we use BSAM to read blocks  *\n*  of SYSUT1, and assemble the records ourselves, so we can discard *\n*  any invalidly-spanned segments.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nBuffArea_Next_Ptr   DS    AL4         A(Next Buffer Area)\nBuffArea_DECB_Ptr   DS    AL4         A(DECB - Below-the-Line)\nBuffArea_Offset     DS    FL4         Offset within BuffArea_IOArea\nBuffArea_Seg_Count  DS    FL4         Segment nbr in curr block\nBuffArea_IOArea     EQU   *           I/O Area for Read\nBuffArea_Hdr_Length EQU   *-BuffArea  Length of Header info\n\n\n\nDateConv_Area       DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This DSECT describes the Date Conversion parameters used to     *\n*  make SMF Dates and Times useable                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    X           Input Descriptor Flag\nDConv_Input_Julian  EQU   *-1,X'80'    1... .... Input in YYYY and DDD\nDConv_Input_Base    EQU   *-1,X'40'    .1.. .... Input in Base date\nDConv_Input_YYMMDD  EQU   *-1,X'20'    ..1. .... Input in YYYY,MM,DD\nDConv_Input_YYMonDD EQU   *-1,X'10'    ...1 .... Input in YYYY,Month,DD\nDConv_Input_SMFDate EQU   *-1,X'08'    .... 1... Input in SMFDate\nDConv_Input_Time    EQU   *-1,X'02'    .... ..1. Input in Time\nDConv_Input_hhmmss  EQU   *-1,X'01'    .... ...1 Input in hh, mm, ss\n\nDConv_Date_SMFDate  DS    PL4         SMF Date Stamp\nDConv_Date_YYYY     DS    HL2         Year (including century)\nDConv_Date_DDD      DS    HL2         Day-of-year\nDConv_Date_Base     DS    FL4         Days since Jan1,0001 (a la REXX)\nDConv_Date_MM       DS    XL1         Month number (1-12)\nDConv_Date_DD       DS    XL1         Day-of-month (1-31)\nDConv_Date_Month    DS    CL9         Month name (January, February ..)\nDConv_Date_Day      DS    CL9         Day Name (Monday, Tuesday, etc.)\nDConv_Date_DOW      DS    XL1         Day-of-week (Mon=0, Tue=1, etc.)\n\nDConv_Time          DS    FL4         Time (secs*100 since midnight)\nDConv_Time_hh       DS    XL1         Hours       (0-23)\nDConv_Time_mm       DS    XL1         Minutes     (0-59)\nDConv_Time_ss       DS    XL1         Seconds     (0-59)\nDConv_Time_tt       DS    XL1         Seconds/100 (0-99)\nDConv_Area_Length   EQU   *-DateConv_Area  Length of area\n\n         TITLE 'Global Dynamic Storage'\n@_Dynam  DSECT\n\n@_31Bit_Stack_Ptr   DS    AL4         A(Stack storage above-the-line)\n@_31Bit_Stack_Len   EQU   4096-StackHdr_Length  4K Stack\n\n@_24Bit_Stack_Ptr   DS    AL4         A(Stack storage below-the-line)\n@_24Bit_Stack_Len   EQU   2048-StackHdr_Length  2K Stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSPRINT-related info                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n@_SYSPRINT_DCB_Ptr  DS    AL4         A(SYSPRINT DCB)\n@_SYSPRINT_Rec_Ptr  DS    AL4         A(SYSPRINT RECORD)\n@_SYSPRINT_Rec_Len  DS    HL2         SYSPRINT RECORD LENGTH (LESS ASA)\n@_SYSPRINT_Y0010_Ptr DS   AL4         A(Copy of Y0010)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1-related info                                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_SYSUT1_DCB_Ptr    DS    AL4         A(SYSUT1 DCB)\n                    ORG   @_SYSUT1_DCB_Ptr\n@_SYSUT1_ACB_Ptr    DS    AL4         A(SYSUT1 ACB)\n                    ORG   ,\n@_SYSUT1_Rec_Ptr    DS    AL4         A(Input record)\n@_SYSUT1_AtL_Ptr    DS    AL4         A(Above-the-line storage)\n@_SYSUT1_BtL_Ptr    DS    AL4         A(Below-the-line storage)\n@_SYSUT1_Rec_Length DS    FL4         Input record length\n@_SYSUT1_BuffArea_Ptr DS  AL4         A(Current buffer area - BSAM)\n@_SYSUT1_PBlock_Count DS  FL4         Physical Block Count - BSAM\n                    ORG   @_SYSUT1_BuffArea_Ptr\n@_SYSUT1_RPL_Ptr    DS    AL4         A(SYSUT1 RPL - VSAM)\n                    ORG   ,\n\n                    DS    X           Flag byte\n@_SYSUT1_VSAM       EQU   *-1,X'80'    1... .... SYSUT1:  VSAM\n@_SYSUT1_QSAM       EQU   *-1,X'40'    .1.. .... SYSUT1:  QSAM\n@_SYSUT1_BSAM       EQU   *-1,X'20'    ..1. .... SYSUT1:  BSAM\n@_SYSUT1_Sequence   EQU   *-1,X'10'    ...1 .... Input is in sequence\n@_SYSUT1_NoVBSChk   EQU   *-1,X'08'    .... 1... No VBS checking\n@_SYSUT1_Seg_Error  EQU   *-1,X'01'    .... ...1 Segments dropped\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Output-related fields                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_ODT_Ptr           DS    AL4         A(Output Descriptor Table)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Counters and Date/Times                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_Line_Count        DS    HL2         LINE COUNT\n@_Page_Count        DS    PL2         PAGE COUNT\n@_Input_Count       DS    FL4         INPUT COUNTER\n\n@_Dump_Start_Date   DS    PL4         SMF Dump Start Date\n@_Dump_Start_Time   DS    FL4                    and Time\n@_Dump_End_Date     DS    PL4         SMF Dump End Date\n@_Dump_End_Time     DS    FL4                  and Time\n@_First_Rec_Date    DS    PL4         First Record Date\n@_First_Rec_Time    DS    FL4                  and Time\n@_Input_Rec_Date    DS    PL4         Current Record Date\n@_Input_Rec_Time    DS    FL4                    and Time\n\n@_Prev_Input_Rec_Date DS  PL4         Previous record date\n@_Prev_Input_Rec_DOW DS   X           Previous record Day-of-Week\n\n@_DateConv_Area     DS    CL(DConv_Area_Length)  Todays Date Info\n\n@_Input_Count_Table DS    256FL4      Input count by SMF Record Type\n\n         DS    0D                     ALIGNMENT\n@_DynLen EQU   *-@_Dynam               LENGTH OF STORAGE\n         TITLE 'Register Equates'\n         YREGS\n         TITLE 'A0010: Main Program Block'\nSMFSLCT  RMODE ANY\nSMFSLCT  AMODE 31\n\nSMFSLCT  RSECT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : A0010                                                  *\n*                                                                     *\n*  Abstract  : Main program loop:                                     *\n*               Perform Initialization                                *\n*               Do until SYSUT1 EOF, or all criteria satisfied        *\n*                 Read SYSIN                                          *\n*                 Do for each appropriate output                      *\n*                   Write to output                                   *\n*                 EndDo                                               *\n*               Perform Termination                                   *\n*                                                                     *\n*                                                                     *\n*  Inputs    : Files:                                                 *\n*               SYSUT1  : Input SMF File (Dynamically allocated if    *\n*                                         not present in JCL)         *\n*               SYSIN   : Control Cards                               *\n*               SYSPRINT: Listing                                     *\n*              Parms: N/A                                             *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   8 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nA0010    DS    0H\n         USING *,R15                  ASSIGN TEMPORARY BASE\n         SAVE  (14,12),T,'SMFSLCT &VERSION &ASMDT &SYSTIME &CPERSON'\n*                                                       @RWS 15-11-13\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING A0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some storage for our LIFO stack ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,=AL4(@_31Bit_Stack_Len) Get length of storage we need\n         STACK INIT,                    Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=ANY                   anywhere\n         LR    R2,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and get some room on it for the globally addressable       *\n*     variables ...                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@_DynLen,             this long                     +\n               STACK=(R2)                using this stack\n         LR    R12,R1                   Point to our storage\n\n         USING @_Dynam,R12              Assign a base\n\n         LA    R0,@_Dynam               A(Our storage)\n         LA    R1,@_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n\n         ST    R2,@_31Bit_Stack_Ptr     Save A(Stack)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and finally get an area on it for our local storage        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@A_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@A_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @A_DYNAM,R13             Assign a base\n         L     R15,@A_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the 24-bit stack                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,=AL4(@_24Bit_Stack_Len) Get length of storage we need\n         STACK INIT,                    Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R1,@_24Bit_Stack_Ptr     Save its address\n\n         L     R15,@A_Dynam+4           Get A(HSA)\n         LM    R0,R1,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Perform our Initialization Routines                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(B0010)        A(Initialization Routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                How did it go?\n         BNZ   A9000                  Not so well, exit\n\nA1000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Start of main program loop:                                    *\n*      Get an input record                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(C0010)        A(SYSUT1 Read routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                How did it go?\n         BNZ   A9000                  Not so well, exit\n         L     R1,@_SYSUT1_Rec_Ptr    OK, get A(Input Record)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Indicate that we haven't printed the record yet, in case it    *\n*   is selected more than once.                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @A_Rec_Printed,X'FF'-L'@A_Rec_Printed OFF Printed Flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go through the Output Descriptor Table, seeing if this record  *\n*   will satisfy any of the criteria.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         USING ODT_Entry,R10           and assign a base\n         OI    @A_All_Done,L'@A_All_Done Assume all ODTEs inactive\nA1010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is an active entry ...                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Inactive,L'ODTE_Inactive ACTIVE ENTRY?\n         BO    A1250                   NO, SKIP\n         NI    @A_All_Done,X'FF'-L'@A_All_Done Reset flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... check the date and time of the input record against the    *\n*   start and end date/time criteria.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_CopyOnly,L'ODTE_CopyOnly Any selection criteria?\n         BO    A1200                  No, select the record\n         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?\n         BE    A1040                  YES, SKIP DATE/TIME CHECK\n         CLI   SMF0RTY-SMFRCD0(R1),X'03' NO, DUMP TRAILER?\n         BE    A1040                  YES, SKIP DATE/TIME CHECK\n         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_StartDate CHECK DATE\n         BL    A1250                  DON'T WANT THIS ONE, SKIP\n         BH    A1020                  AFTER START DATE, SKIP TIME CHK\n         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME\n         C     R15,ODTE_StartTime     DO WE WANT THIS ONE?\n         BL    A1250                  NO, GET ANOTHER ONE\nA1020    DS    0H\n         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_EndDate PAST END?\n         BH    A1030                  YES, CHECK SEQUENCE\n         BL    A1040                  BEFORE END DATE, SKIP TIME CHK\n         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME\n         C     R15,ODTE_EndTime       BEFORE END TIME?\n         BNH   A1040                  YES, CONTINUE\nA1030    DS    0H\n         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?\n         BO    A1240                  YES, INACTIVATE THIS ENTRY\n         B     A1250                  NO, IGNORE THIS RECORD\nA1040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we are ignoring weekends, check it out                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend\n         BZ    A1060                  No, continue\n         CP    @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         BE    A1050                  Same date as prev, skip\n         XC    @A_DateConv_Area,@A_DateConv_Area No, clear Date area\n         MVC   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(R1) Move SMF Date\n         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate      Indicate SMF Date\n         LA    R1,@A_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Day-of-Week\n         L     R1,@_SYSUT1_Rec_Ptr   Restore A(Input Record)\n         ZAP   @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @_Prev_Input_Rec_DOW,@A_DateConv_Area+DConv_Date_DOW-Dat+\n               eConv_Area            Save Day-of-week\nA1050    DS    0H\n         CLI   @_Prev_Input_Rec_DOW,X'04' Is DOW greater than Friday?\n         BH    A1250                 Yes, ignore this record\nA1060    DS    0H\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Start and End Date/Times are OK, check against the Period      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,SMF0TME-SMFRCD0(R1) GET THE TIME OF THE SMF REC\n         C     R15,ODTE_PeriodStart   BEFORE PERIOD START?\n         BL    A1250                  YES, IGNORE IT\n         C     R15,ODTE_PeriodEnd     NO, AFTER PERIOD END?\n         BH    A1250                  YES, SKIP IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Invoke the User Exit INEXIT, if there is one.                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_InExit_Ptr Get A(Input Exit)\n         BZ    A1070                  None, skip\n         SLR   R0,R0                  Yes, flag as an Inexit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                Check return code\n         BZ    A1070                  OK, continue normally\n         CH    R15,=H'8'              Something else, check it out\n         BL    A1200                  Select this record\n         BE    A1250                  Ignore it\n         ZAP   ODTE_EndDate,=P'0'     Clear End Date and Time so we\n         XC    ODTE_EndTime,ODTE_EndTime finish after this record\nA1070    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check this record against any record types specified ...       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_RTT_Ptr Get A(Record Table)\n         BZ    A1130                  None, don't check it\n         LH    R14,RTT_Entry_Count-RecType_Tbl(R15) Get nbr entries\n         LA    R15,RTT_Entry-RecType_Tbl(R15) and point to the first\n         SLR   R4,R4                  Clear R4\n         SLR   R5,R5                  R5 too\nA1080    DS    0H\n         CLC   SMF0RTY-SMFRCD0(L'SMF0RTY,R1),RTTE_RecType-RTT_Entry(R15+\n               ) Is this our record?\n         BE    A1100                  Yes, skip\nA1090    DS    0H\n         LA    R15,RTTE_Length(R15)   No, A(Next entry in table)\n         BCT   R14,A1080              and try again\n         B     A1120                  Not our record, skip\nA1100    DS    0H\n         TM    RTTE_SubType_Present-RTT_Entry(R15),L'RTTE_SubType_Prese+\n               nt                     SubType present?\n         BNO   A1110                  No, found our record\n         CLC   SMF30STP-SMFRCD30(L'SMF30STP,R1),RTTE_SubType-RTT_Entry(+\n               R15)                   Yes, our subtype?\n         BNE   A1090                  No, try again\nA1110    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and include or exclude it as required                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr       Get A(Record Table)\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    A1250                  EXCLUDEing, skip\n         B     A1130                  No, continue\nA1120    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    This record is not in the Record Type Table - we must check the*\n*    exclude indicator to see what we should do with it.            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr       Get A(Record Table)\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    A1130                  Yes, include this record\n         B     A1250                  No, skip it\nA1130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check this record for JobName selection.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JobName Table)\n         BZ    A1170                  None, skip\n*        CLI   SMF30RTY-SMFRCD30(R1),70 RMF record?\n*        BL    A1140                  No, skip\n*        CLI   SMF30RTY-SMFRCD30(R1),79 Really?\n*        BNH   A1170                  Yes, skip jobname check\nA1140    DS    0H\n         LH    R14,JNT_Entry_Count-JobName_Tbl(R15) Nbr entries\n         LA    R15,JNT_Entry-JobName_Tbl(R15) And point to first\n         LA    R2,SMF5JBN-SMFRCD5(R1) A(JobName in SMF record)\n         CLI   SMF30RTY-SMFRCD30(R1),30 Type 30 record?\n         BNE   A1150                  No, skip\n         L     R2,SMF30IOF-SMFRCD30(R1) Yes, offset to ID section\n         AR    R2,R1                  and point to JobName\nA1150    DS    0H\n         SLR   R3,R3                   Clear EX register\n         IC    R3,JNTE_JobName_Len-JNT_Entry(R15) Len of JobName Mask\n         EX    R3,A9999               Check JobNameE\n         BNE   A1160                  Not us, skip\n         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?\n         BO    A1200                  Yes, Select this record\n         B     A1170                  No, go check Data Table\nA1160    DS    0H\n         LA    R15,JNTE_Length(R15)   A(Next Entry)\n         BCT   R14,A1150              and try again\n         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?\n         BNO   A1250                  No, skip this record\n         ICM   R15,B'1111',ODTE_DT_Ptr Yes, get A(Data Table)\n         BZ    A1250                  None, skip this record\nA1170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check for Data selection                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_DT_Ptr Get A(Data Table)\n         BZ    A1200                  None, select this record\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) Yes, get nbr entries\n         LA    R15,DT_Entry-Data_Tbl(R15) and point to the first\n         SLR   R3,R3                  Clear work register\nA1180    DS    0H\n         LH    R2,DTE_Offset-DT_Entry(R15) Offset of data\n         IC    R3,DTE_Length-DT_Entry(R15) EX length if data\n         LA    R4,0(R2,R3)            Offset of last char\n         CH    R4,SMF0LEN-SMFRCD0(R1) Is the record long enough?\n         BH    A1190                  No, data does not match\n         AR    R2,R1                  Yes, A(Offset)\n         EX    R3,A9998               Check the data\n         BE    A1200                  Found it, skip\nA1190    DS    0H\n         LA    R15,1+DTE_Data-DT_Entry(R3,R15) A(Next Entry)\n         BCT   R14,A1180              and check it\n         B     A1250                  Not found, skip this record\nA1200    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    This record has satisfied all the selection criteria for this  *\n*   output file, so invoke the user exit                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_OutExit_Ptr Get A(Output Exit)\n         BZ    A1210                  None, skip\n         LA    R0,1                   Yes, flag as an Outexit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         CH    R15,=H'8'              Check return code\n         BH    A1240                  Inactivate this ODT entry\n         BE    A1250                  Ignore the record\n\nA1210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Invoke D0010 to write to the output file ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R1,@A_D0010_Parm       Save A(SMF record)\n         ST    R10,@A_D0010_Parm+4    Save A(ODT Entry)\n\n         LA    R1,@A_D0010_Parm       A(Parm list)\n         L     R15,=AL4(D0010)        A(Selection routine)\n         BASR  R14,R15                Go select the record\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n\n         LTR   R15,R15                How did it go?\n         BNZ   A1250                  Not great, try next ODT\n\n         ICM   R15,B'1111',ODTE_StopAft Get Select Limit\n         BZ    A1220                  None, keep going\n         C     R15,ODTE_Selected      Yes, have we reached it?\n         BH    A1220                  Not yet, keep going\n         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry\nA1220    DS    0H\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and E0010 to print it, if required                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Print_NO,L'ODTE_Print_NO Should we print?\n         BO    A1250                  No, skip\n         TM    @A_Rec_Printed,L'@A_Rec_Printed Yes, already printed?\n         BO    A1250                  Yes, skip\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Skip a line (Print blanks)\n\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   0(7,R2),=X'4020206B202120'  Move mask\n         L     R15,@_Input_Count      Get input record count\n         CVD   R15,@A_DBLWD           Pack it\n         ED    0(7,R2),@A_DBLWD+5     Edit it\n         MVC   7(7,R2),=X'4020206B202120'  Move mask\n         L     R15,ODTE_Selected      Get selected count\n         CVD   R15,@A_DBLWD           Pack it\n         ED    7(7,R2),@A_DBLWD+5     Edit it\n         MVC   15(8,R2),=C'RecType:'  Move Record Type title\n         MVC   23(4,R2),=X'40202120'  Move mask\n         SLR   R15,R15                Clear work register\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         CVD   R15,@A_DBLWD           Pack it\n         ED    23(4,R2),@A_DBLWD+6     and put it in SYSPRINT rec\n         MVC   30(11,R2),=C'Date-Time: ' Move Date/Time heading\n\n         XC    @A_DateConv_Area,@A_DateConv_Area Clear Date area\n         ZAP   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)  Date\n         MVC   @A_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               SMF0TME-SMFRCD0(R1)            Time too\n         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @A_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@A_DateConv_Area     Point to Date Conversion area\n         ST    R15,@A_F0010_Parm     Save as 1st parm\n         LA    R15,41(0,R2)          A(Output area)\n         ST    R15,@A_F0010_Parm+4   Save as 2nd parm\n         LA    R15,@A_Return_Ptr     A(Return area)\n         ST    R15,@A_F0010_Parm+8   Save as 2nd parm\n         LA    R1,@A_F0010_Parm      A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n         L     R15,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)\n         LH    R15,ODT_Entry_Count-OutDesc_Tbl(R15) GET NBR ENTRIES\n         CH    R15,=H'1'              MORE THAN 1?\n         BNH   A1230                  NO, SKIP 'SELECTED BY' MSG\n         L     R2,@A_Return_Ptr       Point to end of Date/Time\n         MVC   1(13,R2),=C', selected to'  MOVE SELECTION HDG\n         MVC   15(L'ODTE_DDName,R2),ODTE_DDName MOVE DDNAME\nA1230    DS    0H\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n\n         ST    R1,@A_E0010_Parm       Save A(SMF record)\n         ST    R10,@A_E0010_Parm+4    Save A(ODT Entry)\n\n         LA    R1,@A_E0010_Parm       A(Parm list)\n         L     R15,=AL4(E0010)        A(Print routine)\n         BASR  R14,R15                Go print the record\n\n         OI    @A_Rec_Printed,L'@A_Rec_Printed Printed now\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n\n         B     A1250                  And continue\n\nA1240    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Flag this ODT Entry as Inactive                                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry\nA1250    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Point to the next ODT Entry, and check it out                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AL    R10,=AL4(ODTE_Length)  Bump entry pointer\n         BCT   R9,A1010               and keep going\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have finished processing all ODT Entries - if they are all  *\n*   inactive, we will terminate.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @A_All_Done,L'@A_All_Done All ODTs inactive?\n         BZ    A1000                  No, go get more input\n\n         DROP  R10                    Free ODTE Base register\n\n         SLR   R15,R15                Yes, all done\n         B     A9000                  and exit\nA9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Perform our Termination routines ...                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(Z0010)        A(Termination Routine)\n         BASR  R14,R15                Go do it\n\n         LR    R3,R15                 Save the return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... get rid of the 24-bit stack ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK TERM,                    Free the stack                 +\n               STACK=@_24Bit_Stack_Ptr   starting here\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... free up our local data area ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@A_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... then the global data area ...                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@_Dynam               A(Global storage)\n         L     R2,@_31Bit_Stack_Ptr     Rescue Stack pointer\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and finally, the stack itself.                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK TERM,                    Free the stack                 +\n               STACK=(2)                 starting here\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Restore callers registers, and return to caller.               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         L     R14,12(0,R13)            Restore Return address\n         LR    R15,R3                   Restore return code\n         LM    R0,R12,20(R13)           Restore remainder of registers\n         BSM   0,R14                    and return to caller\n\n\n         LTORG\n\n\nA9998 CLC      0(0,R2),DTE_Data-DT_Entry(R15)  Check data\nA9999 CLC      0(0,R2),JNTE_JobName-JNT_Entry(R15) Check JobName\n\n\n         LTORG\n\n@A_Dynam        DSECT               Local Variables\n@A_Save         DS    18F            O/S Style Save Area\n@A_DBLWD        DS    D\n@A_ParmList     DS    0F\n@A_D0010_Parm   DS    2AL4           Parms for D0010\n                ORG   @A_ParmList\n@A_E0010_Parm   DS    2AL4           Parms for E0010\n                ORG   @A_ParmList\n@A_F0010_Parm   DS    3AL4           Parms for F0010\n@A_Return_Ptr   DS    AL4             Return pointer from F0010\n                ORG\n                DS    X              Flag Byte\n@A_All_Done     EQU   *-1,X'80'       1... .... All ODTs inactive\n@A_Rec_Printed  EQU   *-1,X'40'       .1.. .... Record printed\n@A_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                DS    0D             Alignment\n@A_DynLen       EQU   *-@A_Dynam    Length\n\n         DROP  R11,R13\n\nSMFSLCT  RSECT\n         TITLE 'B0010: Initialization'\n\n         PUSH  USING\n\nB0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : B0010                                                  *\n*                                                                     *\n*  Abstract  : Initialization routine                                 *\n*               Allocate and initialize various contol blocks         *\n*               Interpret SYSIN Control Cards                         *\n*               OPEN all output files                                 *\n*               Print info about output files                         *\n*                                                                     *\n*                                                                     *\n*  Inputs    : Parms: N/A                                             *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              1999/11/18 SDDA030 V1.3                                *\n*                                 Added comments                      *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Corrected SOC4s, etc., when we      *\n*                                 overflowed SYSPRINT record when     *\n*                                 listing rectypes/jobnames.          *\n*                                 Invoked I0010 to OPEN SYSUT1.       *\n*                                 Used W0010 to get A(JFCB), rather   *\n*                                 that issue RDJFCB.                  *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING B0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@B_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@B_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @B_Dynam,R13             Assign a base\n         L     R15,@B_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Create our Output Descriptor Table, ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,ODT_Entry-OutDesc_Tbl Header length\n         AL    R0,=AL4(ODTE_Length)    plus len of 1 entry\n         ICM   R0,B'1000',=AL1(ODT_SubPool_Nbr) set up subpool\n         STORAGE OBTAIN,              Go get our storage               +\n               LENGTH=(0),             this long                       +\n               LOC=ANY                 anywhere\n         ST    R1,@_ODT_Ptr            Save A(Table)\n         ST    R0,ODT_SubPool-OutDesc_Tbl(R1) Save subpool, length\n         LA    R15,1                   Nbr entries\n         STH   R15,ODT_Entry_Count-OutDesc_Tbl(R1) Init it\n         LA    R0,ODT_Entry-OutDesc_Tbl(R1) Point to our entry\n         L     R1,=AL4(ODTE_Length)    Get its length\n         SLR   R14,R14                 no sending area\n         SLR   R15,R15                 or length\n         MVCL  R0,R14                  Clear our entry\n         L     R10,@_ODT_Ptr           A(Output Descriptor Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) Point to 1st entry\n\n         USING ODT_Entry,R10           Assign a base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and initialize the base (first) entry.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ZAP   ODTE_StartDate,=P'0'   Start Date = 00000\n         XC    ODTE_StartTime,ODTE_StartTime Start Time = 00:00:00\n         ZAP   ODTE_EndDate,=P'999999' End Date = 00365\n         MVC   ODTE_EndTime,=F'8640000' End Time = 24:00:00\n         XC    ODTE_PeriodStart,ODTE_PeriodStart Period Start\n         MVC   ODTE_PeriodEnd,=F'8640000' Period End\n         MVI   ODTE_InExit,C' '       CLEAR\n         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit Input and\n         MVC   ODTE_OutExit,ODTE_InExit      Output Exit names\n         SLR   R15,R15                   Clear work register\n         ST    R15,ODTE_DCB_Ptr          No DCB yet\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Initialize our variables.                                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ZAP   @_First_Rec_Date,=P'0' First Date = 00000\n         XC    @_First_Rec_Time,@_First_Rec_Time First Time = 00:00:00\n         ZAP   @_Dump_Start_Date,=P'999999' Dump Start Date = 00.365\n         MVC   @_Dump_Start_Time,=F'8640000' Dump Start Time = 24:00:00\n         ZAP   @_Dump_End_Date,=P'0'  Dump End Date = 00.000\n         XC    @_Dump_End_Time,@_Dump_End_Time Dump End Time = 00:00:00\n         ZAP   @_Prev_Input_Rec_Date,=P'0'\n         LA    R15,99                 Get High Line count\n         STH   R15,@_Line_Count        and save it\n         ZAP   @_Page_Count,=P'0'     Clear Page count\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the current date and time ...                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @B_Time,B_Time         Move L-Form of macro\n         TIME  DEC,                   Get time                         C\n               @B_TimeArea,            and return it here              C\n               LINKAGE=SYSTEM,         don't use the SVC               C\n               DATETYPE=YYYYDDD,       format of returned data         C\n               MF=(E,@B_TIME)          addr of macro list\n         XC    @_DateConv_Area,@_DateConv_Area Clear date conv area\n         XC    @B_DBLWD,@B_DBLWD      Clear work area\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and some info about it.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@B_TimeArea         Get HH\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_HH-DateConv_Area\n         IC    R0,@B_TimeArea+1       Get MM\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_MM-DateConv_Area\n         IC    R0,@B_TimeArea+2       Get SS\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_SS-DateConv_Area\n         IC    R0,@B_TimeArea+3       Get tt\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_tt-DateConv_Area\n         OI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DConv+\n               _Input_hhmmss          Indicate time in hhmmss\n\n         L     R15,@B_TimeArea+8      Get Date (0yyyyddd)\n         SLR   R14,R14                Clear work register\n         SLDL  R14,20                 R14 = yyyy\n         SLL   R14,4                  Make room for sign\n         ST    R14,@B_DBLWD+4         Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R14,@B_DBLWD           Binarize yyyy\n         STH   R14,@_DateConv_Area+DConv_Date_YYYY-DateConv_Area\n         SRL   R15,16                 R15 = ddd0\n         ST    R15,@B_DBLWD+4         Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R15,@B_DBLWD           Binarize ddd\n         STH   R15,@_DateConv_Area+DConv_Date_DDD-DateConv_Area\n         OI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,L'DConv+\n               _Input_Julian          Indicate date in YYYY and DDD\n\n         LA    R1,@_DateConv_Area    Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info about today\n\n         NI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,X'FF'-L+\n               'DConv_Input_hhmmss    Off the flag\n         NI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,X'FF'-L+\n               'DConv_Input_Julian    Off the flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Initialize SYSPRINT stuff                                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_DCB_Ptr   Clear A(SYSPRINT DCB)\n         OI    ODTE_Print_NO,L'ODTE_Print_NO Suppress headings\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go get a record\n         NI    ODTE_Print_NO,X'FF'-L'ODTE_Print_NO Reset no print flag\n         LTR   R15,R15                  OK?\n         BNZ   B8000                    No, exit with error\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check out SYSIN control cards                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr          A(Output Desc Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) A(default (1st) entry)\n         L     R15,=AL4(H0010)        A(SYSIN processor)\n         BASR  R14,R15                Go interpret SYSIN\n         LTR   R15,R15                How did we do?\n         BNZ   B8000                  Not great, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go allocate (if necessary) and OPEN SYSUT1                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT Routine)\n         BASR  R14,R15                A blank line\n         L     R15,=AL4(G0010)        A(SYSPRINT Routine)\n         BASR  R14,R15                and another\n\n         L     R15,=AL4(I0010)        A(SYSUT1 OPEN)\n         BASR  R14,R15                Go OPEN SYSUT1\n         LTR   R15,R15                How did we do?\n         BNZ   B8000                  Not great, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We seemed to interpret the SYSIN statements OK, and SYSUT1 is  *\n*   OK, so go and fix up the Output Descriptor Table:               *\n*        - if there is only one entry (ie, the default), make the   *\n*          output ddname = SYSUT2,                                  *\n*        - if there is more than one, propagate the default exit    *\n*          names, record type, jobname and data table pointer addrs,*\n*          and include and exclude flags from the default to the    *\n*          other entries, unless they were specified in the other   *\n*          entries. Additionally, inactivate the default entry.     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,1                 Set Input count\n         LNR   R15,R15                to -1 for any exits\n         ST    R15,@_Input_Count      we may invoke\n\n         L     R10,@_ODT_Ptr         A(Output Descriptor Table)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         CH    R9,=H'1'              ONLY ONE ENTRY?\n         BH    B0020                 NO, SKIP\n         MVC   ODTE_DDName,=CL8'SYSUT2' YES, DEFAULT TO SYSUT2\n         SLR   R15,R15               Clear work register\n         ST    R15,ODTE_DCB_Ptr      No DCB yet\n         B     B0120                 AND SKIP\nB0020    DS    0H\n         LR    R1,R10                             SAVE A(DEFAULT ENTRY)\n         OI    ODTE_Inactive,L'ODTE_Inactive      MAKE DEFAULT INACTIVE\n         MVC   @B_Default_InExit_Name,ODTE_InExit Save default name\n         MVC   @B_Default_InExit_Parm_Ptr,ODTE_InExit_Parm_Ptr\n         MVC   @B_Default_OutExit_Name,ODTE_OutExit  Save default name\n         MVC   @B_Default_OutExit_Parm_Ptr,ODTE_OutExit_Parm_Ptr\n         B     B0110\nB0030    DS    0H\n         CLI   ODTE_InExit,C' '      INPUT EXIT NAME BLANK?\n         BNE   B0040                 NO, SKIP\n         TM    ODTE_No_Dflt_InExit,L'ODTE_No_Dflt_Inexit Use default?\n         BO    B0040                 No, skip\n         MVC   ODTE_InExit,@B_Default_InExit_Name Yes, move default\n         MVC   ODTE_InExit_Parm_Ptr,@B_Default_InExit_Parm_Ptr\nB0040    DS    0H\n         CLI   ODTE_OutExit,C' '     OUTPUT EXIT NAME BLANK?\n         BNE   B0050                 NO, SKIP\n         TM    ODTE_No_Dflt_OutExit,L'ODTE_No_Dflt_Outexit Use default?\n         BO    B0050                 No, skip\n         MVC   ODTE_OutExit,@B_Default_OutExit_Name    Yes, DEFAULT\n         MVC   ODTE_OutExit_Parm_Ptr,@B_Default_OutExit_Parm_Ptr\nB0050    DS    0H\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TABLE) = 0?\n         BNZ   B0060                 NO, SKIP\n         MVC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R1) Yes, default\nB0060    DS    0H\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE) = 0?\n         BNZ   B0070                 NO, SKIP\n         MVC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R1) Yes, default\nB0070    DS    0H\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE) = 0?\n         BNZ   B0080                 NO, SKIP\n         MVC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R1) Yes, default\nB0080    DS    0H\n         TM    ODTE_Print_NO-ODT_Entry(R1),L'ODTE_Print_NO\n         BZ    B0090\n         OI    ODTE_Print_NO,L'ODTE_Print_NO Set flag\nB0090    DS    0H\n         TM    ODTE_Print_EB-ODT_Entry(R1),L'ODTE_Print_EB\n         BZ    B0100\n         OI    ODTE_Print_EB,L'ODTE_Print_EB Set flag\nB0100    DS    0H\n         TM    ODTE_JobData_OR-ODT_Entry(R1),L'ODTE_JobData_OR\n         BZ    B0110\n         OI    ODTE_JobData_OR,L'ODTE_JobData_OR Set flag\nB0110    DS    0H\n         AL    R10,=AL4(ODTE_Length) A(Next entry)\n         BCT   R9,B0030              AND DO IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    For each entry in the Output Descriptor Table ...              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nB0120    DS    0H\n         L     R10,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\nB0130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... get the attributes for the dataset                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Inactive,L'ODTE_Inactive INACTIVE ENTRY?\n         BO    B0220                  YES, SKIP DCB STUFF\n\n         LA    R0,B_SYSUT2_DCB_Length Length of DCB\n         STORAGE OBTAIN,              Get storage                      +\n               LENGTH=(0),             for the DCB                     +\n               LOC=BELOW               Below-the-line\n         MVC   0(B_SYSUT2_DCB_Length,R1),B_SYSUT2_DCB Move DCB\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R1),ODTE_DDName IN DCB\n         ST    R1,ODTE_DCB_Ptr        Save A(DCB)\n*                                                               *RWS17\n         L     R15,=AL4(W0010)        A(Get JFCB address routine)\n         BASR  R14,R15                Go get it\n         LTR   R15,R15                How did we do?\n         BNZ   B0200                  Not good, skip\n         LR    R3,R1                  OK, point to JFCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is a new dataset ...                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    JFCBIND2-INFMJFCB(R3),JFCNEW DISP=NEW or not specified?\n         BM    B0180                  NO, USE EXISTING STUFF\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... set up RECFM, LRECL and BLKSIZE if they were not           *\n*   specified                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,ODTE_DCB_Ptr        A(DCB)\n\n         IC    R15,JFCRECFM-INFMJFCB(R3) GET JFCB RECFM\n         TM    JFCRECFM-INFMJFCB(R3),JFCFMREC ANYTHING THERE?\n         BNZ   B0140                  YES, OK\n         L     R1,@_SYSUT1_DCB_Ptr    A(Input DCB)\n         IC    R15,DCBRECFM-IHADCB(R1) NO, GET RECFM FROM SYSUT1\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?\n         BZ    B0140                   NO, OK\n         IC    R15,=AL1(DCBRECV+DCBRECBR+DCBRECSB) YES, DEFAULT TO VBS\nB0140    DS    0H\n         STC   R15,DCBRECFM-IHADCB(R2) SAVE RECFM\n         TM    DCBRECFM-IHADCB(R2),DCBRECU RECFM=U?\n         BO    B0170                   YES, SKIP LRECL CHECK\n         BNZ   B0150                   NO, BUT SOME LRECL SPECIFIED\n         TM    JFCRECFM-INFMJFCB(R3),JFCUND JFCB RECFM = U?\n         BO    B0170                   YES, SKIP LRECL CHECK\nB0150    DS    0H\n         LH    R15,JFCLRECL-INFMJFCB(R3) GET JFCB LRECL\n         LTR   R15,R15                 IS THERE ONE?\n         BNZ   B0160                   YES, SKIP\n         L     R1,@_SYSUT1_DCB_Ptr     No, A(SYSUT1 DCB)\n         LH    R15,DCBLRECL-IHADCB(R1) NO, GET SYSUT1 LRECL\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?\n         BZ    B0160                   NO, OK\n         L     R15,=F'32760'           YES, DEFAULT LRECL=32760\nB0160    DS    0H\n         STH   R15,DCBLRECL-IHADCB(R2) Update OUTPUT LRECL\nB0170    DS    0H\n         LH    R15,JFCBLKSI-INFMJFCB(R3) GET JFCB BLKSIZE\n         LTR   R15,R15                 IS THERE ONE?\n         BNZ   B0180                   YES, SKIP\n         MVC   DCBBLKSI-IHADCB(L'DCBBLKSI,R2),DCBBLKSI-IHADCB(R1)\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS SYSUT1 VSAM?\n         BZ    B0180                   NO, OK\n         SLR   R15,R15                 YES, Use SDB\n         STH   R15,DCBBLKSI-IHADCB(R2) UPDATE SYSUT2\nB0180    DS    0H\n         L     R2,ODTE_DCB_Ptr            A(DCB)\n         MVC   @B_OPEN,B_OPEN             MOVE OPEN PARMS\n         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@B_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN IS IT OPEN?\n         BZ    B0200                  NO, SKIP\n         LH    R15,DCBLRECL-IHADCB(R2) YES, GET LRECL\n         TM    DCBRECFM-IHADCB(R2),DCBRECU IS RECFM = U?\n         BNO   B0190                  NO, OK\n         LH    R15,DCBBLKSI-IHADCB(R2) YES, GET BLKSIZE INSTEAD\nB0190    DS    0H\n         STH   R15,ODTE_LRECL         SAVE MAX OUTPUT LRECL\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go list some stuff about this file                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,ODTE_DCB_Ptr        A(DCB)\n         L     R15,=A(J0010)          A(Info format routine)\n         BASR  R14,R15                Go do it\n         B     B0210                  and skip\n\nB0200    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THE OUTPUT DCB COULD NOT BE OPENED - SAY SO.                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT LINE)\n         L     R15,ODTE_DCB_Ptr       A(DCB)\n         MVC   1(8,R1),DCBDDNAM-IHADCB(R15) MOVE DDNAME\n         MVC   9(40,R1),=C' DD statement not found; **U4090 ABEND**'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT OUR LINE\n         LA    R12,4090\n         ABEND (R12),DUMP\n\nB0210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   Assume this entry has no selection criteria (i.e., a straight   *\n*  copy). This flag will get reset each time we find (and print)    *\n*  some selection criteria.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    ODTE_CopyOnly,L'ODTE_CopyOnly  Assume no selection crit\n\n         LA    R1,ODT_Entry           Point to ODTE\n         L     R15,=AL4(L0010)        A(List routine)\n         BASR  R14,R15                Go do it\n\nB0220    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK TO SEE IF WE HAVE TO LOAD THE EXITS - IF WE DO, WE DO.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   ODTE_InExit,C' '       IS THERE AN INEXIT?\n         BE    B0270                  NO, SKIP\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?\n         BNE   B0230                  No, go load it\n         ICM   R0,B'1111',@B_Default_InExit_Ptr Yes, get A(Exit)\n         BNZ   B0240                  LOADed already, skip\nB0230    DS    0H\n         LA    R0,ODTE_InExit         NO, POINT TO IT\n         LOAD  EPLOC=(0),ERRET=B0260 AND GO GET IT\n         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?\n         BNE   B0240                  No, skip\n         ST    R0,@B_Default_InExit_Ptr Yes, save its address\nB0240    DS    0H\n         ST    R0,ODTE_InExit_Ptr     SAVE EPA\n\n         SLR   R1,R1                  Clear A(SMF Record)\n         SLR   R0,R0                  An InExit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         C     R15,=FL4'12'           How did it go?\n         BL    B0270                  OK, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive\n         B     B0360                  AND SKIP\n\nB0260    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'\n         MVC   10(L'ODTE_InExit,R1),ODTE_InExit MOVE EXIT NAME\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT\n         MVI   ODTE_InExit,C' '       Clear 1st byte of name\nB0270    DS    0H\n         CLI   ODTE_OutExit,C' '      IS THERE AN OUTEXIT?\n         BE    B0320                  NO, SKIP\n         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?\n         BNE   B0280                  No, go load it\n         ICM   R0,B'1111',@B_Default_OutExit_Ptr Yes, get A(Exit)\n         BNZ   B0290                  LOADed already, skip\nB0280    DS    0H\n         LA    R0,ODTE_OutExit        NO, POINT TO IT\n         LOAD  EPLOC=(0),ERRET=B0310 AND GO GET IT\n         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?\n         BNE   B0290                  No, skip\n         ST    R0,@B_Default_OutExit_Ptr Yes, save its address\nB0290    DS    0H\n         ST    R0,ODTE_OutExit_Ptr    SAVE EPA\n\n         SLR   R1,R1                  Clear A(SMF Record)\n         LA    R0,1                   An OutExit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         C     R15,=FL4'12'           How did it go?\n         BL    B0320                  OK, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive\n         B     B0360                  AND SKIP\n\nB0310    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'\n         MVC   10(L'ODTE_OutExit,R1),ODTE_OutExit MOVE EXIT NAME\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT\n         MVI   ODTE_OutExit,C' '      Clear 1st byte of name\nB0320    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we are ignoring weekends, adjust the start/stop times (if   *\n*   present), if they start or stop on weekends.                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?\n         BNO   B0360                 No, OK\n         NI    @B_Dates_Altered,X'FF'-L'@B_Dates_Altered Off our flag\n\n         CP    ODTE_StartDate,=P'0'  Any start date?\n         BE    B0330                 No, skip\n\n         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area\n         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_StartDate\n         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate        Indicate SMF Date\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         MVC   @B_StartDate_Base,@B_DateConv_Area+DConv_Date_Base-DateC+\n               onv_Area              Save start Basedate\n         MVC   @B_StartDate_DOW,@B_DateConv_Area+DConv_Date_DOW-DateCon+\n               v_Area                Save start DOW\n         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'\n         BNH   B0330                 Not starting on a weekend, skip\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         LA    R15,7                 DOW of the next Monday\n         SR    R15,R0                Number of days until Monday\n         A     R15,@B_StartDate_Base Bump base date\n         ST    R15,@B_StartDate_Base  and save it\n         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base Date\n         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+\n               -L'DConv_Input_SMFDate Off SMFDate flag\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         ZAP   ODTE_StartDate,@B_DateConv_Area+DConv_Date_SMFDate-DateC+\n               onv_Area(L'DConv_Date_SMFDate)  Update Start Date\n         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag\n\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   10(23,R1),=C'Start Date modified to '\n         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_StartTime               Time too\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base date\n         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@B_DateConv_Area     Point to Date Conversion area\n         ST    R15,@B_Parms          Save as 1st parm\n         LA    R15,33(0,R1)          A(Output area)\n         ST    R15,@B_Parms+4        Save as 2nd parm\n         LA    R15,@B_Return_Ptr     A(Return area)\n         ST    R15,@B_Parms+8        Save it\n         LA    R1,@B_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15               GO PRINT\n\n         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+\n               DConv_Input_Base      Off the flag\n         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+\n               DConv_Input_Time      Off the flag\nB0330    DS    0H\n         CP    ODTE_EndDate,=P'999999' Any End Date?\n         BE    B0340                 No, skip\n\n         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area\n         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_EndDate\n         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate        Indicate SMF Date\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         MVC   @B_EndDate_Base,@B_DateConv_Area+DConv_Date_Base-DateCon+\n               v_Area                Save End Basedate\n         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'\n         BNH   B0340                 Not ending on a weekend, skip\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         LA    R15,4                 DOW of the previous Friday\n         SR    R0,R15                Number of days after Friday\n         L     R15,@B_EndDate_Base   Get Base date\n         SR    R15,R0                Back up to Friday\n         ST    R15,@B_EndDate_Base   and save it\n         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base Date\n         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+\n               -L'DConv_Input_SMFDate Off SMFDate flag\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         ZAP   ODTE_EndDate,@B_DateConv_Area+DConv_Date_SMFDate-DateCon+\n               v_Area(L'DConv_Date_SMFDate) Update end date\n         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag\n\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   10(21,R1),=C'End Date modified to '\n         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_EndTime          Time too\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base            Indicate Base date\n         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time            Indicate SMF Time\n         LA    R15,@B_DateConv_Area  Point to Date Conversion area\n         ST    R15,@B_Parms          Save as 1st parm\n         LA    R15,31(0,R1)          A(Output area)\n         ST    R15,@B_Parms+4        Save as 2nd parm\n         LA    R15,@B_Return_Ptr     A(Return area)\n         ST    R15,@B_Parms+8        Save it\n         LA    R1,@B_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15               GO PRINT\n\n         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+\n               DConv_Input_Base      Off the flag\n         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+\n               DConv_Input_Time      Off the flag\nB0340    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If there is a StartDate and an EndDate, check the adjusted     *\n*   dates ...                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @B_Dates_Altered,L'@B_Dates_Altered  Did we do anything?\n         BNO   B0360                 No, skip\n         CP    ODTE_StartDate,=P'0'  Any start date?\n         BE    B0360                 No, skip\n         CP    ODTE_EndDate,=P'999999' Any End Date?\n         BE    B0360                 No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... to see if we have to select anything. For instance, a      *\n*   user may have specified:                                        *\n*      START=Saturday,END=Sunday,WEEKENDS=IGNORE                    *\n*   We will have adjusted the StartDate to Monday, and EndDate to   *\n*   the previous Friday. In this case, we inactivate the entry      *\n*   immediately.                                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@B_EndDate_Base   Get base date for End date\n         C     R15,@B_StartDate_Base Less than StartDate?\n         BNL   B0350                 No, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Yes, set inactive\n         B     B0360                and skip\nB0350    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we have adjusted the dates so that a weekend does not fall  *\n*   within the Start and End dates, we can turn off the 'Ignore     *\n*   Weekends' flag. This will save us some processing, since we     *\n*   won't have to figure out the Day-of-Week for each day.          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@B_EndDate_Base   Get base date for End date\n         S     R15,@B_StartDate_Base Get nbr days\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_StartDate_DOW   Get starting day-of-week\n         AR    R0,R15                Get DOW of last day\n         C     R0,=FL4'5'            Saturday or greater?\n         BNL   B0360                 Yes, skip\n         NI    ODTE_Ignore_Weekend,X'FF'-L'ODTE_Ignore_Weekend\n\nB0360    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    All done with this entry, check next                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n\n         AL    R10,=AL4(ODTE_Length)  A(Next ODT entry)\n         BCT   R9,B0130               GO PROCESS IT\n\n         DROP  R10                    Free ODT Entry base reg\n\n         SLR   R15,R15                Clear\n         ST    R15,@_Input_Count       Input count\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have finished going through the table, so print some        *\n*   blank lines ...                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  AND ANOTHER\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ...  and exit.                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                Clear return code\n         B     B9000                  and exit\n\n\n\nB8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Either SYSPRINT could not be opened, or we found an error in   *\n*   the SYSIN statements; set the return code, and exit             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  Error, set return code\n\nB9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@B_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nB_Time   TIME  LINKAGE=SYSTEM,MF=L\nB_Time_Length EQU *-B_Time\n\nB_SYSUT2_DCB DCB DDNAME=SYSUT2,MACRF=PM,DSORG=PS\nB_SYSUT2_DCB_Length EQU *-B_SYSUT2_DCB LENGTH OF SYSUT1 DCB\n\nB_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nB_OPEN_Length EQU  *-B_OPEN\n\n         POP   PRINT\n\n         LTORG\n@B_Dynam        DSECT                 Dynamic area for B\n@B_Save         DS    18F              O/S Style save area\n@B_DBLWD        DS    D                Work area\n@B_Parms        DS    3AL4             Parm area\n@B_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@B_StartDate_Base DS  FL4              Start Date in REXX Base format\n@B_StartDate_DOW  DS  XL1              Start Date Day-of-Week\n@B_EndDate_Base   DS  FL4              End Date in REXX Base format\n@B_Default_InExit_Name      DS  CL8         Default Exit Name\n@B_Default_InExit_Ptr       DS  AL4         A(EPA of default exit)\n@B_Default_InExit_Parm_Ptr  DS  AL4      A(Parm Ptr for InExit)\n@B_Default_OutExit_Name     DS  CL8        Default Exit Name\n@B_Default_OutExit_Ptr      DS  AL4        A(EPA of default exit)\n@B_Default_OutExit_Parm_Ptr DS  AL4     A(Parm Ptr for OutExit)\n\n                DS    X                Flag Byte\n@B_Dates_Altered EQU  *-1,X'80'         1... .... Start/End dates upd\n\n@B_MACRO        DS    0F               Macro area\n@B_OPEN         DS    CL(B_OPEN_Length) OPEN macro\n                ORG   @B_MACRO\n@B_Time         DS    CL(B_Time_Length) L-Form of Time\n@B_TimeArea     DS    CL16             Return area for Time\n                ORG   @B_MACRO\n@B_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                ORG\n                DS    0D               Alignment\n@B_DynLen       EQU   *-@B_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'C0000: Read the Input File'\n\n         PUSH  USING\n\nC0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : C0010                                                  *\n*                                                                     *\n*  Abstract  : SYSUT1 Read Routine:                                   *\n*               If SYSUT1 not OPEN                                    *\n*                 OPEN SYSUT1                                         *\n*               EndIf                                                 *\n*               Do until valid SMF record found                       *\n*                 Read SYSUT1                                         *\n*                 Check VBS Segmentation, if required                 *\n*               EndDo                                                 *\n*                                                                     *\n*  Inputs    : None                                                   *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              1999/11/18 SDDA030 V1.3                                *\n*                                 Moved SYSUT1 OPEN logic(?) to its   *\n*                                 own subroutine (I0010)              *\n*                                 Added comments                      *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Removed invocation of I0010 to OPEN *\n*                                 SYSUT1 (now done in B0010).         *\n*                                 Updated EODAD on 1st time through.  *\n*                                 Cleaned up SYSUT1 resources at EOD. *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING C0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@C_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@C_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @C_Dynam,R13             Assign a base\n         L     R15,@C_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is the first time in (@_Input_Count = 0) ...           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@_Input_Count Get input counter\n         BNZ   C0020                    Not 1st time in, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... go update the DCBE/ACB EODAD routine address               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?\n         BO    C0010E                 Yes, skip\n\n         L     R15,@_SYSUT1_DCB_Ptr   Yes, A(Input DCB)\n         L     R15,DCBDCBE-IHADCB(0,R15) A(DCBE)\n         LA    R0,C7000               A(EOD Routine)\n         ST    R0,DCBEEODA-DCBE(0,R15) Update DCBE EODAD\n         B     C0010Z                  and skip\nC0010E   DS    0H\n\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         LA    R3,@C_SYSUT1_EXLST_Ptr  A(RECEIVING AREA)\n         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             +\n               FIELDS=EXLST,            WE WANT THE LRECL              +\n               AREA=(3),                MOVED TO THIS AREA             +\n               LENGTH=L'@C_SYSUT1_EXLST_Ptr, for this long             +\n               MF=(G,@C_SHOWCB,C_SHOWCB_Length)\n\n         L     R2,@C_SYSUT1_EXLST_Ptr   A(EXLST area)\n         LA    R3,C7000               Get A(EOD Routine)\n         MODCB EXLST=(2),             Update SYSUT1 EXLST              +\n               EODAD=(3),               for EOD address                +\n               MF=(G,@C_MODCB,C_MODCB_Length)\n\nC0010Z   DS    0H\n         LA    R15,99                   Get High Line count\n         STH   R15,@_Line_Count          and save it\n\nC0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Read the Input File.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?\n         BZ    C0030                  No, skip\n         L     R1,@_SYSUT1_RPL_Ptr    Yes, A(RPL)\n         GET   RPL=(1)                and issue GET\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have just read a record from the active SMF file, in which  *\n*  the end will be marked by a special record, so we had better     *\n*  check for it. If this is it, we signal EOF.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_Rec_Ptr    A(INPUT RECORD)\n         LH    R15,SMF0LEN-SMFRCD0(R1) GET LENGTH\n         CH    R15,=H'14'             IS IT THE RIGHT LENGTH?\n         BNE   C0180                  NO, SKIP\n         CLC   =C'SMFEOFMARK',SMF0FLG-SMFRCD0(R1) YES, IS THIS IT?\n         BE    C7000                  YES, EOF\n         B     C0180                  NO, CONTINUE\nC0030    DS    0H\n\n         TM    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Is the input QSAM?\n         BNO   C0040                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The input file is QSAM - just read it normally                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,@_SYSUT1_Rec_Ptr    A(input record)\n         L     R1,@_SYSUT1_DCB_Ptr    POINT TO INPUT DCB\n         GET   (1),(0)                GO GET THE RECORD\n         B     C0180                  and skip\nC0040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are using BSAM to access the input file.                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs Off our flag\n         SLR   R15,R15                Clear work register\n         ST    R15,@C_SegErr_Seg_Count Clear nbr error segments\nC0050    DS    0H\n         L     R15,@_SYSUT1_Rec_Ptr   A(Record area)\n         SLR   R0,R0                  Clear work reg\n         ST    R0,0(0,R15)            Clear record length\n         STH   R0,@C_Seg_Count        Clear segment count\n         NI    @C_Last_Segment,X'FF'-L'@C_Last_Segment Off our flag\nC0060    DS    0H\n         L     R1,@_SYSUT1_BuffArea_Ptr Point to our buffer area\n         ICM   R15,B'1111',BuffArea_Offset-BuffArea(R1) Get offset\n         BNZ   C0070                  OK, skip\n         L     R1,BuffArea_DECB_Ptr-BuffArea(0,R1) None, A(DECB)\n         CHECK (1)                    Wait for I/O completion\n         L     R1,@_SYSUT1_BuffArea_Ptr Restore buffer pointer\n         LA    R15,4                  Buffer offset\n         ST    R15,BuffArea_Offset-BuffArea(0,R1) Update it\n         L     R15,@_SYSUT1_PBlock_Count Get Phys Blk Count\n         LA    R15,1(0,R15)           Bump it\n         ST    R15,@_SYSUT1_PBlock_Count and save it\n         LA    R15,1                  Initialize segment\n         ST    R15,BuffArea_Seg_Count-BuffArea(0,R1)  count\nC0070    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check that the next segment is valid, based on the segments    *\n*   that have come before. Segment Type bits:                       *\n*          X'00'  00 - Complete segment                             *\n*          X'01'  01 - 1st segment                                  *\n*          X'02'  10 - Last segment                                 *\n*          X'03'  11 - Intermediate segment                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@_SYSUT1_Rec_Ptr   A(Input record area)\n         LH    R0,0(0,R14)            Get current record length\n\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(I/O Area)\n         A     R15,BuffArea_Offset-BuffArea(0,R1) A(Next Segment)\n         TM    2(R15),X'01'           Last or only segment?\n         BNZ   C0080                  No, skip\n         OI    @C_Last_Segment,L'@C_Last_Segment Yes, set flag\nC0080    DS    0H\n         TM    2(R15),X'02'           1st or complete segment?\n         BZ    C0110                  Yes, skip\n         LTR   R0,R0                  No, have we processed a 1st?\n         BZ    C0090                  No, segment error\n         LR    R14,R15                A(Start of segment)\n         LH    R15,0(0,R14)           Segment length\n         SH    R15,=H'4'              less length of SDW\n         LA    R14,4(0,R14)           point past SDW\n         B     C0140                  OK, skip\nC0090    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Segment error - Intermediate or last segment without a 1st.       *\n*  If we are not in the middle of dropping segments, save some info   *\n*  about the start of the segmenting error.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?\n         BO    C0100                  Yes, skip\n         MVC   @C_SegErr_Init_PBlock,@_SYSUT1_PBlock_Count\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffarea)\n         L     R15,BuffArea_Seg_Count-BuffArea(0,R15)\n         ST    R15,@C_SegErr_Init_Seg  Save segment number\n         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date\n         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time\n         SLR   R15,R15                Number of segments\n         ST    R15,@C_SegErr_Seg_Count Clear segment count\n         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error\n         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error\nC0100    DS    0H\n         L     R15,@C_SegErr_Seg_Count Get segment count\n         LA    R15,1(0,R15)           Bump it\n         ST    R15,@C_SegErr_Seg_Count Save it\n\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         L     R15,BuffArea_Offset-BuffArea(0,R1) Offset next segment\n         LA    R15,BuffArea_IOArea-BuffArea(R15,R1) A(Next segment)\n         LH    R14,0(0,R15)           Get length of Segment\n         A     R14,8(0,R1)            Bump offset to next segment\n         ST    R14,8(0,R1)            Save it\n         NI    @C_Last_Segment,L'@C_Last_Segment Off our flag\n         B     C0150                  and skip\nC0110    DS    0H\n         LTR   R0,R0                  Are we in the middle of a rec?\n         BNZ   C0120                  Yes, error\n         LR    R14,R15                OK, A(Start of segment)\n         LH    R15,0(0,R14)           Segment length\n         MVC   @C_Init_PBlock,@_SYSUT1_PBlock_Count Save init PBlock\n         MVC   @C_Init_Seg,BuffArea_Seg_Count-BuffArea(R1) seg #\n         B     C0140                  and skip\nC0120    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Segment error - No ending segment                                 *\n*  If we are not in the middle of dropping segments, save some info   *\n*  about the start of the segmenting error.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?\n         BO    C0130                  Yes, skip\n         MVC   @C_SegErr_Init_PBlock,@C_Init_PBlock\n         MVC   @C_SegErr_Init_Seg,@C_Init_Seg\n         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date\n         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time\n         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error\nC0130    DS    0H\n         LH    R15,@C_Seg_Count       Segments in partial record\n         A     R15,@C_SegErr_Seg_Count Bump error count\n         ST    R15,@C_SegErr_Seg_Count Set error count\n\n         B     C0050                  Start again\nC0140    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   At this point, R0  = Current length of input record               *\n*                  R14 = A(Segment from SYSUT1)+4 (ie, past SDW)      *\n*                  R15 = Length of Segment                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LR    R1,R0                  Get current length\n         AR    R1,R15                 Get new total length\n         C     R1,@_SYSUT1_Rec_Length Will it be too long?\n         BH    C0120                  Yes, error\n         A     R0,@_SYSUT1_Rec_Ptr    No, A(Next free area)\n         LR    R1,R15                 Length to move\n         MVCL  R0,R14                 Move data to input area\n         L     R1,@_SYSUT1_Rec_Ptr    A(Start of input rec area)\n         SR    R0,R1                  Current length of input\n         STH   R0,0(0,R1)             Update RDW\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Input buffer area)\n         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(Start of block)\n         SR    R14,R15                Calculate new offset\n         ST    R14,BuffArea_Offset-BuffArea(0,R1) Save it\n         LH    R15,@C_Seg_Count       Get segments in curr rec\n         LA    R15,1(0,R15)           Bump it\n         STH   R15,@C_Seg_Count       Save it\nC0150    DS    0H\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         L     R14,BuffArea_Offset-BuffArea(0,R1) Get offset\n         CH    R14,BuffArea_IOArea-BuffArea(0,R15) Done the block?\n         BL    C0160                  No, skip\n         L     R2,@_SYSUT1_DCB_Ptr    A(SYSUT1 DCB)\n         L     R4,@_SYSUT1_BuffArea_Ptr A(buffer area)\n         L     R5,BuffArea_DECB_Ptr-BuffArea(0,R4) A(DECB)\n         MVC   0(C_READ_Length,R5),C_READ  Initialize DECB\n         LA    R6,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)\n         READ  (5),SF,(2),(6),'S',MF=E    Issue the read\n         SLR   R15,R15                Clear work register\n         ST    R15,BuffArea_Offset-Buffarea(0,R4) Clear offset\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Current buffer area)\n         L     R15,BuffArea_Next_Ptr-BuffArea(0,R15) A(Next)\n         ST    R15,@_SYSUT1_BuffArea_Ptr and save the address\nC0160    DS    0H\n         TM    @C_Last_Segment,L'@C_Last_Segment  All done?\n         BZ    C0060                  No, keep going\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Yes, segs skipped?\n         BZ    C0180                  No, OK\n\n         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Yes, set flag\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   2(3,R2),=C'***'        Move flag\n         MVC   5(7,R2),=X'4020206B202120' Segment count mask\n         L     R15,@C_SegErr_Seg_Count Get segments dropped\n         CVD   R15,@C_DBLWD           Pack it\n         ED    5(7,R2),@C_DBLWD+5     Edit it in\n         MVC   13(7,R2),=C'segment'   Start of literal\n         LA    R2,20(0,R2)            point to next character\n         C     R15,=FL4'1'            More than 1 segment?\n         BNH   C0170                  No, skip\n         MVI   0(R2),C's'             Yes, pluralize it\n         LA    R2,1(0,R2)             and bump output pointer\nC0170    DS    0H\n         MVC   0(26,R2),=C' dropped, from (PBlk:Seg) '\n         L     R15,@C_SegErr_Init_PBlock  Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  26(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    32(R2),X'F0'          Make it readable\n         MVI   33(R2),C':'           Move separator\n         L     R15,@C_SegErr_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  34(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    36(R2),X'F0'          Make it readable\n         MVC   37(15,R2),=C' to (PBlk:Seg) '\n         L     R15,@C_Init_PBlock    Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  52(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    58(R2),X'F0'          Make it readable\n         MVI   59(R2),C':'           Move separator\n         L     R15,@C_SegErr_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  60(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    62(R2),X'F0'          Make it readable\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   6(10,R2),=C'Data after'\n\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@C_SegErr_Init_Date  Date\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @C_SegErr_Init_Time            Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,17(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         LA    R2,6(0,R2)             Bump pointer\n\n         MVC   0(10,R2),=C'and before'\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         L     R1,@_SYSUT1_Rec_Ptr   A(Input record)\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               SMF0TME-SMFRCD0(R1)          Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,11(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R2,@C_Return_Ptr      A(Return area)\n         MVC   1(17,R2),=C' are unavailable.'\n\n         L     R15,=AL4(G0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs\n         B     C0180                  and skip\nC0180    DS    0H\n         L     R1,@_SYSUT1_Rec_Ptr    AND POINT TO OUR RECORD\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Bump the input counters                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_Input_Count      GET THE INPUT COUNTER\n         LA    R15,1(0,R15)           BUMP IT\n         ST    R15,@_Input_Count\n\n         SLR   R15,R15                Clear work regiater\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         SLL   R15,2                  times 4\n         LA    R15,@_Input_Count_Table(R15) A(Our counter)\n         L     R0,0(0,R15)            Get count\n         AL    R0,=FL4'1'             Bump it\n         ST    R0,0(0,R15)            Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SAVE THE DATE/TIME OF THE FIRST RECORD.                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?\n         BNE   C0200                  NO, SKIP\n         CP    @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) 1st?\n         BL    C0230                  NO, SKIP IT\n         BH    C0190                  YES, SAVE IT\n         L     R15,@_Dump_Start_Time  SAME DAY, GET PREV TIME\n         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE\n         BNH   C0230                  NOT EARLIEST, SKIP\nC0190    DS    0H\n         ZAP   @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) Save it\n         MVC   @_Dump_Start_Time,SMF0TME-SMFRCD0(R1)\n         B     C0230                  AND SKIP\nC0200    DS    0H\n         CLI   SMF0RTY-SMFRCD0(R1),X'03' DUMP TRAILER\n         BNE   C0220                  NO, SKIP\n         CP    @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) LATEST?\n         BH    C0230                  NO, SKIP IT\n         BL    C0210                  YES, SAVE IT\n         L     R15,@_Dump_End_Time    SAME DAY, GET PREV TIME\n         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE\n         BNL   C0230                  NOT EARLIEST, SKIP\nC0210    DS    0H\n         ZAP   @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @_Dump_End_Time,SMF0TME-SMFRCD0(R1)\n         B     C0230                  AND SKIP\nC0220    DS    0H\n         ZAP   @_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE\n         MVC   @_Input_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME\n         CP    @_First_Rec_Date,=P'0' HAVE WE FOUND THE FIRST DATE?\n         BNE   C0230                  YES,SKIP\n         ZAP   @_First_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE\n         MVC   @_First_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME\nC0230    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE'VE FINISHED WITH THIS RECORD, SO WE CLEAR THE RETURN CODE   *\n*   AND EXIT.                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                CLEAR THE RETURN CODE\n         B     C9000                  AND EXIT\nC7000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    END-OF-FILE EXIT FOR SYSUT1.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?\n         BNO   C7010                  No, skip\n         L     R15,@_SYSUT1_Rec_Ptr   Yes, A(SYSUT1 record)\n         LH    R15,0(0,R15)           Get length of record\n         LTR   R15,R15                Anything there?\n         BZ    C7010                  No, OK\n\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   2(3,R2),=C'***'        Move flag\n         MVC   5(7,R2),=X'4020206B202120' Segment count mask\n         LH    R15,@C_Seg_Count       Get segments dropped\n         CVD   R15,@C_DBLWD           Pack it\n         ED    5(7,R2),@C_DBLWD+5     Edit it in\n         MVC   12(35,R2),=C' segments dropped, from (PBlk:Seg) '\n         L     R15,@C_Init_PBlock  Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  47(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    53(R2),X'F0'          Make it readable\n         MVI   54(R2),C':'           Move separator\n         L     R15,@C_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  55(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    57(R2),X'F0'          Make it readable\n         MVC   58(21,R2),=C' to the end of SYSUT1'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   6(11,R2),=C'Data after '\n\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Input_Rec_Date     Date\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Input_Rec_Time               Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,17(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R2,@C_Return_Ptr      A(Return area)\n         MVC   1(17,R2),=C' are unavailable.'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs\n\nC7010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE SYSUT1 ...                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_DCB_Ptr     A(DCB or ACB)\n         MVC   @C_CLOSE,C_CLOSE        Move CLOSE parms\n         CLOSE ((2)),MODE=31,MF=(E,@C_CLOSE)   and CLOSE DCB/ACB\n\n         ICM   R1,B'1111',@_SYSUT1_Rec_Ptr  GET A(INPUT RECORD AREA)\n         BZ    C7020                  None, skip\n         L     R0,@_SYSUT1_Rec_Length YES, GET ITS LEN\n         LA    R15,7                  Make\n         AR    R0,R15                  a\n         SRL   R0,3                    doubleword\n         SLL   R0,3                    multiple\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_Rec_Ptr   No input record\nC7020    DS    0H\n         ICM   R1,B'1111',@_SYSUT1_AtL_Ptr A(Above-the-line storage)\n         BZ    C7030                  None, skip\n         L     R0,0(0,R1)             Get Subpool, length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_AtL_Ptr   No storage now\nC7030    DS    0H\n         ICM   R1,B'1111',@_SYSUT1_BtL_Ptr A(Below-the-line storage)\n         BZ    C7040                  None, skip\n         L     R0,0(0,R1)             Get Subpool, length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_BtL_Ptr   No storage now\n\nC7040    DS    0H\n         LA    R15,4                  SET THE RETURN CODE\n         B     C9000                  AND EXIT\n\nC9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@C_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         PUSH PRINT\n         PRINT NOGEN\n\n         READ  C_READ,SF,0,0,'S',MF=L\nC_READ_Length EQU  *-C_READ\n\nC_CLOSE    CLOSE (0),MODE=31,MF=L\nC_CLOSE_Length EQU   *-C_CLOSE\n\n         POP   PRINT\n\n         LTORG\n\n@C_Dynam              DSECT           Dynamic area for C\n@C_Save               DS   18F         O/S Style save area\n@C_DBLWD              DS   D           Work area\n@C_Return_Ptr         DS   AL4         A(Last byte formatted by F0010)\n@C_Seg_Count          DS   HL2         Nbr segs in curr record\n@C_Init_PBlock        DS   FL4         Phys Block of start of record\n@C_Init_Seg           DS   FL4         Seg # of start of record\n@C_SegErr_Init_PBlock DS   FL4         Phys Blk of start of seg err\n@C_SegErr_Init_Seg    DS   FL4         Segment# of start of seg err\n@C_SegErr_Init_Date   DS   PL4         Date of valid rec pre seg err\n@C_SegErr_Init_Time   DS   FL4         Time of valid rec pre seg err\n@C_SegErr_Seg_Count   DS   FL4         Nbr segments dropped\n                      DS   X           Flag byte\n@C_Last_Segment       EQU  *-1,X'80'    1... .... Last segment\n@C_Skipping_Segs      EQU  *-1,X'40'    .1.. .... Skipping Segments\n\n@C_Macro              DS   0F          Temp area for Macro L-Forms\n@C_EParms             EQU  *            Parms for E0010\n@C_EP_Input_Ptr       DS   AL4           A(INPUT AREA)\n@C_EP_Input_Len       DS   FL4           LEN OF INPUT AREA\n@C_EP_Input_Off       DS   FL4           CURRENT OFFSET\n@C_EP_Output_Ptr      DS   AL4           A(OUTPUT AREA)\n@C_EP_Output_Len      DS   FL4           OUTPUT AREA LENGTH\n@C_EP_Pr_Flag_Ptr     DS   AL4           A(Print flag)\n                      ORG  @C_Macro\n@C_DateConv_Area      DS   CL(DConv_Area_Length)  Date conversion area\n@C_FParms             DS   3AL4          Parms for F0010\n                      ORG  @C_Macro\n@C_SHOWCB             DS   CL(C_SHOWCB_Length) SHOWCB Macro\n@C_SYSUT1_EXLST_Ptr   DS   AL4           A(SYSUT1 EXLST)\n                      ORG  @C_Macro\n@C_MODCB              DS   CL(C_MODCB_Length) MODCB Macro\n                      ORG  @C_Macro\n@C_Close              DS   CL(C_CLOSE_Length)  Close macro\n\n                      ORG  ,\n                      DS   0D          Alignment\n@C_DynLen             EQU  *-@C_Dynam Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'D0000: Process selected record'\n\n         PUSH  USING\n\nD0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : D0010                                                  *\n*                                                                     *\n*  Abstract  : Write the selected input record to the output file(s). *\n*                                                                     *\n*  Inputs    : R1 ----> A(Input SMF record)                           *\n*                       A(ODTE entry)                                 *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING D0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@D_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@D_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @D_Dynam,R13             Assign a base\n         L     R15,@D_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  Off our flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the address of the SMF record, and the ODT Entry that      *\n*   selected it                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,0(0,R1)              A(SMF record)\n\n         L     R10,4(0,R1)              A(ODT Entry)\n         USING ODT_Entry,R10            Tell the assembler\n\n         LR    R1,R15                   Set up A(SMF record)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE SELECTED A RECORD. WE BUMP THE SELECTED COUNT, PRINT   *\n*   IT (IF REQUIRED) AND WRITE IT (IF REQUIRED) TO SYSUT2.          *\n*                                                                   *\n*   ON ENTRY, R1 = A(SELECTED RECORD)                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_Selected      GET SELECTED COUNT\n         LA    R15,1(0,R15)           BUMP IT\n         ST    R15,ODTE_Selected      AND SAVE IT\n\n         SLR   R15,R15                Clear work regiater\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         SLL   R15,2                  times 4\n         LA    R15,ODTE_Output_Count_Table(R15) A(Our counter)\n         L     R0,0(0,R15)            Get count\n         AL    R0,=FL4'1'             Bump it\n         ST    R0,0(0,R15)            Save it\n\n         ICM   R15,B'1111',ODTE_DCB_Ptr A(Output DCB)\n         BZ    D0110                  None, exit\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS DCB OPEN?\n         BZ    D0110                  NO, exit quick smart\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND WRITE IT TO THE OUTPUT, IF POSSIBLE.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_Rec_Ptr    SAVE A(INPUT RECORD)\n         ICM   R1,B'1111',ODTE_DCB_Ptr  A(Output DCB)\n         BZ    D9000                  None, skip\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN IS OUTPUT OPEN?\n         BZ    D9000                  NO, SKIP\n         LH    R3,SMF0LEN-SMFRCD0(R2) GET INPUT RECORD LEN\n         LH    R0,ODTE_LRECL          GET MAX OUTPUT RECORD LEN\n         TM    DCBRECFM-IHADCB(R1),DCBRECV OUTPUT RECFM=F?\n         BO    D0080                  NO, SKIP\n         LA    R2,4(0,R2)             YES, POINT PAST RDW\n         SH    R3,=H'4'                DECREMENT THE LENGTH\n         B     D0100                   and skip\nD0080    DS    0H\n         CR    R3,R0                  INPUT GREATER THAN MAX OUTPUT?\n         BNH   D0090                  NO, OK\n         TM    DCBRECFM-IHADCB(R1),DCBRECV+DCBRECSB RECFM=VS?\n         BO    D0090                  YES, SKIP\n         OI    ODTE_Trunc,L'ODTE_Trunc INDICATE TRUNCATION\n         STH   R0,SMF0LEN-SMFRCD0(R2) Update RDW temporarily\n         OI    @D_RDW_Updated,L'@D_RDW_Updated  and set our flag\nD0090    DS    0H\n         TM    DCBRECFM-IHADCB(R1),DCBRECU OUT RECFM = U?\n         BNO   D0100                  NO, SKIP\n         STH   R3,DCBLRECL-IHADCB(R1) YES, UPDATE LRECL\nD0100    DS    0H\n         LR    R0,R2                  A(Output record)\n         PUT   (1),(0)                Write output\n\n         TM    @D_RDW_Updated,L'@D_RDW_Updated  Did we change RDW?\n         BNO   D0110                  No, skip\n         STH   R3,SMF0LEN-SMFRCD0(R2) Yes, restore it\n         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  and off our flag\n\nD0110    DS    0H\n         SLR   R15,R15                Clear return code\n         B     D9000                  and exit\n\nD9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@D_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@D_Dynam        DSECT                 Dynamic area for D\n@D_Save         DS    18F              O/S Style save area\n                DS    X                Flag Byte\n@D_RDW_Updated  EQU   *-1,X'80'         1... .... Record length updated\n                DS    0D               Alignment\n@D_DynLen       EQU   *-@D_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10                    Free ODT Entry base\n         DROP  R11,R13\n         POP   USING\n         TITLE 'E0000: FORMAT RECORD FOR PRINT'\n\n         PUSH  USING\n\nE0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : E0010                                                  *\n*                                                                     *\n*  Abstract  : Print selected input record                            *\n*                                                                     *\n*  Inputs    : R1 ----> A(Input SMF record)                           *\n*                       A(ODTE entry)                                 *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING E0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@E_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@E_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @E_Dynam,R13             Assign a base\n         L     R15,@E_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Save the addresses of the input record, and of our ODT entry   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,0(0,R1)            Get A(Input record)\n         ST    R15,@E_Record_Ptr      Save it\n         L     R15,4(0,R1)            Get A(ODT Entry)\n         ST    R15,@E_ODTE_Ptr        Save it\n\n         L     R2,@E_Record_Ptr       A(Start of record)\nE0015    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Format the offset into the output record ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                 Get current posn in input rec\n         S     R15,@E_Record_Ptr      Convert to an offset\n         STH   R15,@E_DBLWD           Save it\n         MVI   @E_DBLWD+2,X'FE'       MAKE IT \"PACKED\"\n         L     R15,@_SYSPRINT_Rec_Ptr Get A(Output\n         LA    R15,18(0,R15)            area)\n         UNPK  0(5,R15),@E_DBLWD(3)   UNPACK IT\n         TR    0(5,R15),E_Hexnum      TRANSLATE TO HEX\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and set up some of our addresses                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R3,@_SYSPRINT_Rec_Ptr  A(Output\n         LA    R3,18(0,R3)              area)\n         L     R4,@E_Record_Ptr       Get length\n         AH    R4,SMF0LEN-SMFRCD0(R4)  of input record\n         SR    R4,R2                   remaining\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check to see if we are printing EBCDIC                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@E_ODTE_Ptr        A(Print flag)\n         TM    ODTE_Print_EB-ODT_Entry(R15),L'ODTE_Print_EB  EBCDIC?\n         BO    E0080                  Yes, go do it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are printing in Dump format (32 bytes per line) ...         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         C     R4,=F'32'              MORE THAN OUR MAX?\n         BNH   E0020                  NO, SKIP\n         L     R4,=F'32'              YES, ONLY PRINT 32\nE0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... with EBCDIC translation on the right-hand side             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVI   80(R3),C'*'            OPENING ASTERISK\n         SH    R4,=H'1'               EXECUTE LENGTH OF DATA\n         LA    R14,81(0,R3)           A(OUTPUT AREA)\n         EX    R4,E9996               MOVE TO EBCDIC AREA\n         EX    R4,E9997               TRANSLATE UNPRNTBL TO .\n         MVI   113(R3),C'*'           CLOSING ASTERISK\n         LA    R4,1(0,R4)             RESTORE LENGTH\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and hex data in groups of 4 bytes                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R3,6(0,R3)             A(START OF HEX DATA)\n         LA    R5,4                   GROUPS OF 4 BYTES EACH\nE0030    DS    0H\n         LA    R6,4                   DO 4 GROUPS\nE0040    DS    0H\n         CR    R4,R5                  CAN WE DO 4 BYTES?\n         BH    E0050                  YES, SKIP\n         LR    R5,R4                  NO, DO AS MANY AS WE CAN\nE0050    DS    0H\n         SH    R5,=H'1'               EXEC LEN OF DATA\n         LA    R14,@E_DBLWD           A(TARGET AREA)\n         EX    R5,E9996               MOVE TO DBLWD\n         LA    R15,@E_DBLWD(R5)       POINT TO LAST BYTE\n         MVI   1(R15),X'FE'           PUT IN SIGN\n         LA    R5,1(0,R5)             RESET LEN OF DATA\n         LR    R0,R5                  CALCULATE UNPACKED LEN =\n         SLL   R0,1                     = (R5 * 2)\n         LR    R15,R0                 PUT IN EXEC REGISTER\n         SLL   R15,4                  MAKE ROOM FOR PACKED LEN\n         OR    R15,R5                 GET PACKED LEN\n         EX    R15,E9999              UNPACK IT\n         LR    R14,R3                 A(OUTPUT AREA)\n         SRL   R15,4                  LENGTH OF OUTPUT ONLY\n         EX    R15,E9998              AND TRANSLATE IT\n         AR    R3,R0                  A(NEXT\n         LA    R3,1(0,R3)                    OUTPUT BYTE)\n         AR    R2,R5                  A(NEXT INPUT BYTE\n         SR    R4,R5                  NBR BYTES LEFT TO DO\n         BNP   E0100                  None, were finished this line\n         BCT   R6,E0040               DO NEXT GROUP OF 4\n         LA    R3,1(0,R3)             EXTRA BLANK IN THE MIDDLE\n         B     E0030                  AND DO ANOTHER GROUP OF 4\n\nE0080    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE SELECTED RECORD IN EBCDIC ONLY.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LH    R15,@_SYSPRINT_Rec_Len GET MAX LRECL\n         SH    R15,=H'24'             LESS STUFF WE HAVE USED\n         CR    R4,R15                 IS INPUT TOO LONG?\n         BNH   E0090                  NO, OK\n         LR    R4,R15                 YES, PRINT AS MUCH AS WE CAN\nE0090    DS    0H\n         LA    R14,6(0,R3)            A(OUTPUT AREA)\n         SH    R4,=H'1'               EXECUTE LENGTH OF DATA\n         EX    R4,E9996               MOVE TO EBCDIC AREA\n         EX    R4,E9997               TRANSLATE UNPRNTBL TO .\n         LA    R4,1(0,R4)             Restore length printed\n         AR    R2,R4                  Bump input pointer\nE0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The print line has been formatted, so print it ...             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Print our line\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and if there is more input record to format, do it.        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@E_Record_Ptr      Get A(Input record)\n         LR    R15,R2                 Calculate current\n         SR    R15,R14                 offset\n         CH    R15,SMF0LEN-SMFRCD0(R14)  Compare against record length\n         BNL   E9000                  All done, exit\n         B     E0015                  Keep going\nE9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@E_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nE9996    MVC   0(0,R14),0(R2)\nE9997    TR    0(0,R14),E_PrtTbl\nE9998    TR    0(0,R14),E_Hexnum\nE9999    UNPK  0(0,R3),@E_DBLWD(0)\n\nE_Hexnum EQU   *-239\n         DC    C' 0123456789ABCDEF'\n\nE_PrtTbl DC    C'................'        00-0F\n         DC    C'................'        10-1F\n         DC    C'................'        20-2F\n         DC    C'................'        30-3F\n         DC    C' ...........<(+]'        40-4F\n         DC    C'&&.........|$*);\u00ac'       50-5F\n         DC    C'-/.........,%_>?'        60-6F\n         DC    C'..........:#@''=\"'       70-7F\n         DC    C'.abcdefghi......'        80-8F\n         DC    C'.jklmnopqr......'        90-9F\n         DC    C'..stuvwxyz......'        A0-AF\n         DC    C'................'        B0-BF\n         DC    C'.ABCDEFGHI......'        C0-CF\n         DC    C'.JKLMNOPQR......'        DO-DF\n         DC    C'..STUVWXYZ......'        E0-EF\n         DC    C'0123456789......'        F0-FF\n\n         LTORG\n\n@E_Dynam        DSECT                 Dynamic area for E\n@E_Save         DS    18F              O/S Style save area\n@E_DBLWD        DS    D                Work area\n@E_Record_Ptr   DS    AL4              A(Input record)\n@E_ODTE_Ptr     DS    AL4              A(ODT Entry)\n                DS    0D               Alignment\n@E_DynLen       EQU   *-@E_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'F0000 - Format Date/Times for output'\n         PUSH  USING\n\nF0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : F0010                                                  *\n*                                                                     *\n*  Abstract  : Format Date/Time from DateConv area to printable       *\n*                                                                     *\n*  Inputs    : R1 ----> A(DateConv_Area)                              *\n*                       A(Start of output area)                       *\n*                       A(Word in which to return the address of      *\n*                         the last byte of formatted data)            *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error in conversion routine                   *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING F0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@F_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@F_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @F_Dynam,R13             Assign a base\n         L     R15,@F_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R9,0(0,R1)               A(Date conv area)\n         L     R8,4(0,R1)               A(Output area)\n         L     R15,8(0,R1)              Get A(return area)\n         ST    R15,@F_Return_Ptr        Save it\n\n         LR    R1,R9                    Point to DateConv area\n         L     R15,=A(K0010)            A(Date conversion routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  Did it work?\n         BNZ   F8010                    No, exit doing nothing\n\n         MVI   0(R8),C' '               OK, blank out\n         MVC   1(29,R8),0(R8)             our receiving area\n         USING DateConv_Area,R9         and assign a DateConv base\n\n         MVC   0(L'DConv_Date_Day,R8),DConv_Date_Day\n         LA    R8,L'DConv_Date_Day-1(0,R8) A(Last char)\nF0020    DS    0H\n         CLI   0(R8),C' '            End of Day name?\n         BNE   F0030                 Yes, skip\n         BCT   R8,F0020              No, try again\nF0030    DS    0H\n         MVI   1(R8),C','            Insert separator\n         MVC   3(L'DConv_Date_Month,R8),DConv_Date_Month  Month name\n         LA    R8,3+L'DConv_Date_Month-1(0,R8) A(Last char)\nF0040    DS    0H\n         CLI   0(R8),C' '            End of Month name?\n         BNE   F0050                 Yes, skip\n         BCT   R8,F0040              No, try again\nF0050    DS    0H\n         SLR   R0,R0                 Clear work reg\n         IC    R0,DConv_Date_DD      Get Day of month\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  1(3,R8),@F_DBLWD+6(2)  unpack it\n         MVI   1(R8),C' '            Clear spurious digit\n         LA    R8,2(0,R8)            point to 1st char\n         CLI   0(R8),C'0'            Leading 0?\n         BNE   F0060                 No, skip\n         MVC   0(1,R8),1(R8)         Yes, left align day\n         SH    R8,=H'1'              and adjust pointer\nF0060    DS    0H\n         OI    1(R8),X'F0'           Make it readable\n         MVI   2(R8),C','            Insert separator\n         LH    R0,DConv_Date_YYYY    Get year\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  3(5,R8),@F_DBLWD+5(3) Unpack it\n         MVI   3(R8),C' '            Clear spurious character\n         OI    7(R8),X'F0'           Make it readable\n         MVI   9(R8),C'('            Move separator\n         MVC   10(4,R8),4(R8)        Move YYYY\n         MVI   14(R8),C'.'           Move separator\n         LH    R0,DConv_Date_DDD     Get day of year\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  15(3,R8),@F_DBLWD+6(2) Unpack it\n         OI    17(R8),X'F0'          Make it readable\n         MVI   18(R8),C')'           Move close paren\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_hh      Get hours\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  19(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   19(R8),C' '           Clear spurious char\n         OI    21(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_mm      Get minutes\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  22(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   22(R8),C':'           Clear spurious char\n         OI    24(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_ss      Get seconds\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  25(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   25(R8),C':'           Clear spurious char\n         OI    27(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_tt      Get hundredths of seconds\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  28(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   28(R8),C'.'           Clear spurious char\n         OI    30(R8),X'F0'          Make it readable\n\n         LA    R8,30(0,R8)           A(Last byte of data)\n         L     R15,@F_Return_Ptr     A(Caller's area)\n         ST    R8,0(0,R15)           Save it for the caller\n\n         SLR   R15,R15               Clear return code\n         B     F9010                  and exit\nF8010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Error from Date conversion routine                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     F9010           and exit\n\nF9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@F_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         LTORG\n\n@F_Dynam        DSECT                 Dynamic area for F\n@F_Save         DS    18F              O/S Style save area\n@F_DBLWD        DS    D                Work area\n@F_Return_Ptr   DS    AL4              A(Return area)\n                DS    0D               Alignment\n@F_DynLen       EQU   *-@F_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R9                     Free DateConv_Area base\n         DROP  R11,R13\n         POP   USING\n         TITLE 'G0000: WRITE SYSPRINT'\n\n         PUSH  USING\n\nG0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : G0010                                                  *\n*                                                                     *\n*  Abstract  : Write SYSPRINT record, producing page titles if        *\n*              required                                               *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSPRINT not usable                           *\n*                                                                     *\n*  Notes     : If SYSPRINT is not OPEN, an attempt is made to OPEN it.*\n*              On exit, @SYSPRINT_Rec_Ptr is updated with the         *\n*                       address of the next SYSPRINT record area.     *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING G0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@G_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@G_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @G_Dynam,R13             Assign a base\n         L     R15,@G_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we havent opened our DCB yet, do so                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)\n         BNZ   G0030                    OK, skip\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=G_SYSPRINT_DCB_Length, this long                 +\n               LOC=BELOW                 below-the-line\n\n         ST    R1,@_SYSPRINT_DCB_Ptr    Save it\n         MVC   0(G_SYSPRINT_DCB_Length,R1),G_SYSPRINT_DCB\n\n         MVC   @G_Open,G_Open         Move OPEN parms\n         L     R2,@_SYSPRINT_DCB_Ptr  Point to the DCB\n         MVC   0(G_SYSPRINT_DCB_Length,R2),G_SYSPRINT_DCB\n         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@G_Open) and open it\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?\n         BZ    G8000                  No, exit quick smart\n         LH    R15,DCBLRECL-IHADCB(R2) Yes, get record length\n         TM    DCBRECFM-IHADCB(R2),DCBRECCC CC present?\n         BZ    G0020                  No, skip\n         SH    R15,=H'1'              Yes, decrement length\nG0020    DS    0H\n         STH   R15,@_SYSPRINT_Rec_Len Save data length of SYSPRINT\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n\nG0030    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE CURRENT SYSPRINT RECORD, CLEAR THE NEW RECORD AREA,  *\n*   AND BUMP THE LINE COUNT.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN  IS SYSPRINT OPEN?\n         BNO   G8000                  NO, EXIT\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)\n         LH    R15,@_Line_Count       Get current Line Count\n         LA    R15,1(0,R15)           Bump it\n         STH   R15,@_Line_Count       Save it\n         CH    R15,=H'60'             End of a page?\n         BL    G0050                  Not yet, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SKIP TO A NEW PAGE, AND PRINT THE HEADING.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R0,R1                  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         MVI   0(R1),C'1'             START A NEW PAGE\n         LA    R15,@_DateConv_Area    A(Info about today)\n         ST    R15,@G_Parms           Save it\n         LA    R15,1(0,R1)            A(Output area)\n         ST    R15,@G_Parms+4         Save it\n         LA    R15,@G_LastChar        A(Return area)\n         ST    R15,@G_Parms+8         Save it\n         LA    R1,@G_Parms            Point to parms\n         L     R15,=A(F0010)          A(Format routine)\n         BASR  R14,R15                Go do it\n         LH    R15,@_SYSPRINT_Rec_Len GET SYSPRINT RECORD LENGTH\n         A     R15,@_SYSPRINT_Rec_Ptr POINT PAST END OF RECORD\n         LA    R14,L'G_Hdg1PP+L'G_Hdg1P+1 LEN OF PAGE NUMBER STUFF\n         SR    R15,R14                OFFSET OF PAGE NBR STUFF\n         MVC   0(L'G_Hdg1PP+L'G_Hdg1P,R15),G_Hdg1PP MOVE IT\n         AP    @_Page_Count,=P'1'     BUMP PAGE COUNT\n         ED    G_Hdg1P-G_Hdg1PP(L'G_Hdg1P,R15),@_Page_Count EDIT IT IN\n         L     R14,@G_LastChar        A(Last char of Date/Time)\n         SR    R15,R14                Len of white space\n         LA    R14,L'G_Hdg1TITL       LEN OF TITLE\n         SR    R15,R14                GET DIFFERENCE\n         SRL   R15,1                  HALVE IT (IE, CENTRE TITLE)\n         A     R15,@G_LastChar        A(output area)\n         MVC   0(L'G_Hdg1TITL,R15),G_Hdg1TITL MOVE TITLE\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)\n         LA    R15,1                  SET RECORD COUNT\n         STH   R15,@_Line_Count       AND SAVE IT\n         TM    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO\n         BO    G0040                  NO, SKIP THESE HEADINGS\n         LR    R0,R1\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         LA    R15,X'40'\n         SLL   R15,24\n         LA    R14,L'G_Hdg2A\n         OR    R15,R14\n         LA    R14,G_Hdg2A\n         MVCL  R0,R14\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         LR    R0,R1\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         LA    R15,X'40'\n         SLL   R15,24\n         LA    R14,L'G_Hdg2B\n         OR    R15,R14\n         LA    R14,G_Hdg2B\n         MVCL  R0,R14\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer\n         LR    R0,R1                  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer\n         LA    R15,3                  SET RECORD COUNT\n         AH    R15,@_Line_Count       INCREMENT LINT COUNT\n         STH   R15,@_Line_Count       AND SAVE IT\nG0040    DS    0H\nG0050    DS    0H\n         L     R0,@_SYSPRINT_Rec_Ptr  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT)\n         TM    DCBRECFM-IHADCB(R15),DCBRECCC  ANY CONTROL CHAR?\n         BZ    G0060                  NO, SKIP\n         LA    R1,1(0,R1)             YES, POINT PAST IT\nG0060    DS    0H\n         ST    R1,@_SYSPRINT_Rec_Ptr  SAVE A(OUTPUT AREA)\n         SLR   R15,R15                Clear return code\n         B     G9000                  AND EXIT\nG8000    DS    0H\n         LA    R15,4                  Error opening SYSPRINT\n         B     G9000                  AND EXIT\nG9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Save the return code\n\n         LA    R1,@G_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nG_SYSPRINT_DCB DCB DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,        +\n               RECFM=FBA\nG_SYSPRINT_DCB_Length EQU *-G_SYSPRINT_DCB\n\nG_Open   OPEN  (0,INPUT),MODE=31,MF=L\nG_Open_Length EQU *-G_Open\n\nG_HDG1TITL DC  C'SMFSLCT &VERSION &ASMDT &SYSTIME - &CPERSON'\n*                                                       @RWS 15-11-13\nG_Hdg1PP DC    C'PAGE'\nG_Hdg1P  DC    X'40202120'            PAGE NUMBER MASK\n\nG_Hdg2A  DC    C'0  Input    Sel    Off-'\nG_Hdg2B  DC    C'   Count  Count     set  Data'\n\n         LTORG\n\n@G_Dynam        DSECT                 Dynamic area for G\n@G_Save         DS    18F              O/S Style save area\n                DS    0F               Alignment\n@G_Open         DS    CL(G_Open_Length)  Open parms\n@G_Parms        DS    3AL4             Parm area for F0010\n@G_LastChar     DS    AL4              Return area from F0010\n                DS    0D               Alignment\n@G_DynLen       EQU   *-@G_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'H0000: INTERPRET CONTROL CARDS'\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : H0010                                                  *\n*                                                                     *\n*  Abstract  : READ SYSIN control cards, and branch to interpretation *\n*              routines (Hx0010)                                      *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error in SYSIN Control Cards                  *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nH0010    DS    0H\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING H0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@H_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@H_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @H_Dynam,R13             Assign a base\n         L     R15,@H_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@H_rc                and clear return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    OPEN SYSIN.                                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   5(20,R1),=C'Input Control Cards:' MOVE HEADING\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT blank line\n         L     R1,@_SYSPRINT_Rec_Ptr  A(NEW SYSPRINT RECORD)\n         MVC   1(30,R1),=C'--- No Control Cards found ---'\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=H_SYSIN_DCB_Length,   this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         ST    R1,@H_SYSIN_DCB_Ptr    Save A(SYSIN DCB area)\n         MVC   @H_OPEN,H_OPEN         Move OPEN parms\n         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB\n         MVC   0(H_SYSIN_DCB_Length,R2),H_SYSIN_DCB Move DCB\n         MVC   @H_SYSIN_DCBE,H_SYSIN_DCBE Move SYSIN DCBE\n         LA    R15,@H_SYSIN_DCBE      Point to it\n         ST    R15,DCBDCBE-IHADCB(R2) Update address in DCB\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?\n         BZ    H9000                  NO, SKIP\n         TM    @H_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?\n         BO    H0020                  Yes, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   31-bit SAM is not supported for SYSIN. This typically happens     *\n*  when it is allocated to the terminal in a TSO session (the I/O     *\n*  seems to be OK, but the EOD handling gets in trouble). So ...      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... close the current DCB ...                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   @H_CLOSE,H_CLOSE       Move close parms\n         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB\n         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   0(H_SYSIN24_DCB_Length,R2),H_SYSIN24_DCB Move DCB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... and move the 24-bit EOD to below-the-line storage              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=H800024_Length,       this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         MVC   0(H800024_Length,R1),H800024_Start Move 24-bit EOD\n         O     R1,DCBEODAD-IHADCB(R2)     Set up\n         ST    R1,DCBEODAD-IHADCB(R2)      EODAD\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Open SYSIN                                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   @H_OPEN,H_OPEN           Move OPEN parms\n         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?\n         BZ    H9000                  NO, SKIP\n\nH0020    DS    0H\n         L     R10,@_ODT_Ptr          A(ODT Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\nH0030    DS    0H\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    Read a control card from SYSIN, and print it.                 *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         L     R1,@H_SYSIN_DCB_Ptr    A(SYSIN DCB)\n         GET   (1)                    READ A SYSIN RECORD\n         LR    R2,R1                  SAVE A(INPUT RECORD)\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         LH    R3,DCBLRECL-IHADCB(R15) GET SYSIN RECORD LENGTH\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         CH    R3,@_SYSPRINT_Rec_Len  CAN WE FIT SYSIN ON SYSPRINT?\n         BNH   H0040                  YES, SKIP\n         LH    R3,@_SYSPRINT_Rec_Len  NO, PUT AS MUCH AS WE CAN\nH0040    DS    0H\n         SH    R3,=H'1'               GET EXECUTE LENGTH\n         EX    R3,H9998               MOVE TO SYSPRINT RECORD\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                AND WRITE IT\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         LH    R3,DCBLRECL-IHADCB(R15) INPUT RECORD LENGTH\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    If it is a comment ('*' in Col 1), ignore it.                 *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         CLI   0(R2),C'*'             Is this a comment?\n         BE    H0030                  Yes, get another record\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    Otherwise, skip leading blanks.                               *\n*                                                                  *\n*------------------------------------------------------------------*\n\nH0050    DS    0H\n         CLI   0(R2),C' '             IS THIS A LEADING BLANK?\n         BNE   H0060                  NO, SKIP\n         LA    R2,1(0,R2)             YES, BUMP INPUT POINTER\n         BCT   R3,H0050               AND CHECK NEXT CHARACTER\n         B     H0030                  ALL BLANK, IGNORE IT\nH0060    DS    0H\n\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    At this point, R2 --> first non-blank character               *\n*                   R3 = nbr characters left on input record       *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         LA    R4,H_Keyword_Table     A(Keyword Table)\n         LA    R5,H_Keyword_Table_End A(End of Keyword Table)\nH0070    DS    0H\n         LA    R15,8                  Set return code, just in case\n         CR    R4,R5                  End of Table?\n         BNL   H0100                  Yes, skip\n         SLR   R15,R15                No, clear R15\n         IC    R15,H_Keyword_Len-H_Keyword_Table(R4) Get len of Keyword\n         CR    R15,R3                 Could this be it?\n         BNL   H0080                  No, check next keyword\n         EX    R15,H9999              Yes, is this it?\n         BE    H0090                  Yes, skip\nH0080    DS    0H\n         LA    R4,1+L'H_Keyword_Rtn+L'H_Keyword_Len(R15,R4)\n         B     H0070                  Check out next entry\nH0090    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have identified the keyword - point R2 to the start of the  *\n*   operand field, adjust the length remaining, and go process the  *\n*   keyword stuff.                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,1(R15,R2)           A(START OF OPERANDS)\n         ST    R2,@H_Parms            Save it\n         SR    R3,R15                 ADJUST LENGTH REMAINING\n         SH    R3,=H'1'               SET IT UP PROPERLY\n         BNP   H0100                  INVALID, SKIP\n         ST    R3,@H_Parms+4          Save it\n         ST    R10,@H_Parms+8         Save A(ODT Entry)\n         LA    R1,@H_Parms            A(Parameters)\n         L     R15,H_Keyword_Rtn-H_Keyword_Table(R4) A(Proc Rtn)\n         BASR  R14,R15                Go process keyword operands\n         LTR   R15,R15                OK?\n         BNZ   H0100                  No, error message\n\n         LM    R2,R3,@H_Parms         Reload our registers\n         L     R10,@H_Parms+8         A(Current ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are back: R2 --> next byte after operands, and              *\n*                 R3 = length remaining                             *\n*    If r2 is not pointing to a space, we have more keywords to     *\n*   look for; if not, we are finished with this record.             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LTR   R3,R3                  Anything left?\n         BNP   H0030                  No, go get next record\n         CLI   0(R2),C' '             Yes, are we done?\n         BE    H0030                  Yes, get next record\n         CLI   0(R2),C','             No, is it a separator?\n         LA    R15,4                  Set return code, just in case\n         BNE   H0100                  Not a separator, error\n         LA    R2,1(0,R2)             Yes, skip separator\n         BCT   R3,H0060               and check next keyword\n         LA    R15,4                  Non-blank last char, error\nH0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have found an error in the control cards - tell the user.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         C     R15,@H_rc              Is this the highest return code?\n         BNH   H0110                  No, skip\n         ST    R15,@H_rc              Yes, save it\nH0110    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         S     R2,DCBRECAD-IHADCB(R15) R2=Offset of error\n         LA    R2,1(R1,R2)            R2 = A(Column of error)\n         MVI   0(R2),C'?'             Move a flag\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go print it\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   5(55,R1),=C'Error detected above ''?'' - remainder of re*\n               cord ignored.'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go print it\n         B     H0030                  Read another record\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The following is the EOD exit when 31-bit SAM is not supported *\n*   for SYSIN. This code is moved to 24-bit storage, and is invoked *\n*   by SYSIN EOD. All it does is branch to out 'real' EOD routine,  *\n*   in 31-bit mode.                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nH800024_Start DS 0H                  Start of 24-bit EOD Routine\n         PUSH  USING                  Save current USINGs\n         DROP  ,                      No USINGs now\n         BALR  R15,0                  Load up our base\n         USING *,R15                  Tell the Assembler\n         L     R15,H800024_EOD        Get real EODAD\n         BSM   0,R15                  and go do it (in 31-bit mode)\nH800024_EOD DC AL4(X'80000000'+H8000) Real EODAD\n         DROP  R15                    Free up our base reg\nH800024_Length EQU *-H800024_Start   Length of 24-bit EOD Routine\n         POP   USING                  Restore USING environment\n\n\nH8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'Real' End-Of-File exit for SYSIN: Close SYSIN                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@H_SYSIN_DCB_Ptr A(SYSIN DCB)\n         BZ    H8020                  None, skip\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN SYSIN OPEN?\n         BZ    H8010                  No, better not close it\n         MVC   @H_CLOSE,H_CLOSE       Yes, move close parms\n         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB\n         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it\nH8010    DS    0H\n         L     R1,@H_SYSIN_DCB_Ptr    A(Below-the-line storage)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_24Bit_Stack_Ptr   on this stack\n\nH8020    DS    0H\n         B     H9000                  Exit\n\n\nH9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R3,@H_rc                 Rescue the return code\n\n         LA    R1,@H_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nH9998 MVC      0(0,R1),0(R2)          Move SYSIN record to SYSPRINT\nH9999 CLC      0(0,R2),H_Keyword-H_Keyword_Table(R4) Check keyword\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Table of command card Keywords, and A(Processing Routines).    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nH_Keyword_Table EQU  *\n*\nH_Keyword_Rtn   DC    AL4(HA0010)            A(PROCESSING ROUTINE)\nH_Keyword_Len   DC    AL1(5)                 EXECUTE LEN OF KEYWORD\nH_Keyword       DC    C'START='              KEYWORD\n*\n                DC    AL4(HA0010)            A(PROCESSING ROUTINE)\n                DC    AL1(3)                 EXECUTE LEN OF KEYWORD\n                DC    C'END='                KEYWORD\n\n                DC    AL4(HB0010)            A(PROCESSING ROUTINE)\n                DC    AL1(5)                 EXECUTE LEN OF KEYWORD\n                DC    C'PRINT='              KEYWORD\n\n                DC    AL4(HC0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'INCLUDE='            KEYWORD\n\n                DC    AL4(HC0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'EXCLUDE='            KEYWORD\n\n                DC    AL4(HD0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'JOBNAME='            KEYWORD\n\n                DC    AL4(HE0010)            A(PROCESSING ROUTINE)\n                DC    AL1(4)                 EXECUTE LEN OF KEYWORD\n                DC    C'DATA='               KEYWORD\n\n                DC    AL4(HF0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'JOB/DATA='           KEYWORD\n\n                DC    AL4(HG0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'STOPAFT='            KEYWORD\n\n                DC    AL4(HH0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'INEXIT='             KEYWORD\n\n                DC    AL4(HH0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'OUTEXIT='            KEYWORD\n\n                DC    AL4(HI0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'OUTPUT='             KEYWORD\n\n                DC    AL4(HJ0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'PERIOD='             KEYWORD\n\n                DC    AL4(HK0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'SEQUENCE='           KEYWORD\n\n                DC    AL4(HL0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'CHECKVBS='           KEYWORD\n\n                DC    AL4(HM0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'WEEKENDS='           KEYWORD\n\nH_Keyword_Table_End EQU *                END OF KEYWORD TABLE\n\n         PUSH  PRINT\n         PRINT NOGEN\nH_SYSIN_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,     +\n               DCBE=H_SYSIN_DCBE\nH_SYSIN_DCB_Length EQU *-H_SYSIN_DCB\n\nH_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=H8000\nH_SYSIN_DCBE_Length EQU  *-H_SYSIN_DCBE\n\nH_SYSIN24_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,   +\n               EODAD=0\nH_SYSIN24_DCB_Length EQU *-H_SYSIN24_DCB\n\nH_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nH_OPEN_Length  EQU   *-H_OPEN\nH_CLOSE  CLOSE (0),MODE=31,MF=L\nH_CLOSE_Length EQU   *-H_CLOSE\n         POP   PRINT\n\n         LTORG\n\n@H_Dynam        DSECT                 Dynamic area for H\n@H_Save         DS    18F              O/S Style save area\n@H_Parms        DS    3AL4             Parm area\n@H_rc           DS    FL4              Return code\n@H_SYSIN_DCB_Ptr DS   AL4              A(SYSIN DCB)\n@H_SYSIN_DCBE   DS    CL(H_SYSIN_DCBE_Length) Dynamic DCBE\n@H_Macros       DS    0F               Macro area\n@H_OPEN         DS    CL(H_OPEN_Length)\n                ORG   @H_Macros\n@H_CLOSE        DS    CL(H_CLOSE_Length)\n                ORG\n                DS    0D               Alignment\n@H_DynLen       EQU   *-@H_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHA0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'START='/'END=' Keyword Processor                              *\n*             Validate Date and Times specified                     *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Start/EndDate set           *\n*                      4 - ERROR FOUND                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HA0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HA_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HA_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HA_Dynam,R13            Assign a base\n         L     R15,@HA_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of START=/END= keyword                    *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         LR    R15,R2                   Point to chars\n         SH    R15,=HL2'2'               before operand\n         CLC   =C'T=',0(R15)            START=\n         BNE   HA0020                   No, must be END=\n         OI    @HA_Start_Proc,L'@HA_Start_Proc Yes, set flag\n         B     HA0030                   and skip\nHA0020   DS    0H\n         NI    @HA_Start_Proc,X'FF'-L'@HA_Start_Proc Off flag\n         B     HA0030                   and skip\nHA0030   DS    0H\n         OI    @HA_Date_Proc,L'@HA_Date_Proc SAY WE ARE DOING DATE\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check for our Date keywords                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         LA    R14,HA_Keyword_Table    A(Keyword Table)\n         LA    R15,HA_Keyword_Table_End A(End of Keyword Table)\nHA0040   DS    0H\n         CR    R14,R15                End of Table?\n         BNL   HA0070                 Yes, skip\n         SLR   R1,R1                  No, clear work register\n         IC    R1,HA_Keyword_Len-HA_Keyword_Table(R14) Get len of Kwd\n         CR    R1,R3                  Could this be it?\n         BNL   HA0050                 No, check next keyword\n         EX    R1,HA9999              Yes, is this it?\n         BE    HA0060                 Yes, skip\nHA0050   DS    0H\n         LA    R14,1+L'HA_Keyword_Rtn+L'HA_Keyword_Len(R1,R14)\n         B     HA0040                 Check out next entry\nHA0060   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have identified the keyword - initialize our DateConv area  *\n*   with the info we retrieved when we initialized (ie, Today) ...  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @HA_DateConv_Area,@_DateConv_Area\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and go process it.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,HA_Keyword_Rtn-HA_Keyword_Table(R14) A(Proc Rtn)\n         BR    R15                    Go process keyword operands\n\nHA0070   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    COMMON 'START='/'END=' KEYWORD PROCESSING                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nHA0080   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP THE TEMPORARY AREA WITH 0, AND POINT TO IT.             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @HA_TEMP(7),=C'0000000' PRIME RECEIVING AREA\n         LA    R4,@HA_TEMP            POINT TO IT\nHA0090   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND COUNT THE NUMERIC CHARACTERS IN THE OPERAND.               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HA0100                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, REALLY NUMERIC?\n         BH    HA0100                 NO, SKIP\n         MVC   0(1,R4),0(R2)          YES, MOVE THE CHARACTER\n         LA    R4,1(0,R4)             BUMP RECEIVING PTR\n         LA    R2,1(0,R2)             POINT TO NEXT CHAR\n         BCT   R3,HA0090              AND CHECK IT OUT\nHA0100   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE EITHER FOUND A NON-NUMERIC CHARACTER (IE, A SEPARATOR),*\n*   OR WE HAVE RUN OUT OF INPUT.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,@HA_TEMP            A(TEMP AREA)\n         SR    R4,R0                  GET CHARS IN INPUT\n         BNP   HA0140                 NO DATA, SKIP\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THE DATA SEEMS OK, SO WE WILL PACK IT.                         *\n*              R1   = A(START OF TARGET FIELDS)                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @HA_Time_Proc,L'@HA_Time_Proc ARE WE DOING TIME?\n         BO    HA0150                 YES, GO SET IT UP\n         CH    R4,=H'5'               NO, IS DATE 5 CHARS?\n         BNE   HA0110                 No, skip\n         PACK  @HA_DBLWD,@HA_TEMP(5)  YES, PACK IT\n         MVC   @HA_DBLWD+4(1),@_DateConv_Area+DConv_Date_SMFDate-DateCo+\n               nv_Area                Move current century\n         B     HA0120                 and skip\nHA0110   DS    0H\n         CH    R4,=H'7'               IS DATE 7 CHARS?\n         BNE   HA8000                 NO, ERROR\n         PACK  @HA_DBLWD,@HA_TEMP(7)  Yes, pack it\n         SP    @HA_DBLWD,=P'1900000'  Adjust for SMF Date convention\nHA0120   DS    0H\n         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?\n         BNO   HA0130                 No, must be END=\n         ZAP   ODTE_StartDate-ODT_Entry(L'ODTE_StartDate,R10),@HA_DBLWD+\n               +4(4)                  Save Start Date\n         B     HA0140                 And skip\nHA0130   DS    0H\n         ZAP   ODTE_EndDate-ODT_Entry(L'ODTE_EndDate,R10),@HA_DBLWD+4(4+\n               )                      Save End date\n         B     HA0140                 And skip\nHA0140   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW SEE IF WE HAVE ANY MORE TO DO.                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LTR   R3,R3                  ANY INPUT LEFT?\n         BZ    HA0180                 NO, WE'RE FINISHED\n         CLI   0(R2),C'-'             IS THIS THE DATE SEPARATOR?\n         BNE   HA0170                 NO, SKIP\n         TM    @HA_Date_Proc,L'@HA_Date_Proc WERE WE DOING THE DATE?\n         BNO   HA8000                 NO, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND THE DATE/TIME SEPARATOR, SO WE WILL GO DO THE    *\n*   TIME                                                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HA_Date_Proc,X'FF'-L'@HA_Date_Proc  Yes, Off Date flag\n         OI    @HA_Time_Proc,L'@HA_Time_Proc Now we are doing time\n         LA    R2,1(0,R2)             POINT OVER THE SEPARATOR\n         BCT   R3,HA0080              AND DO THE TIME\n         B     HA8000                 SEPARATOR BUT NO TIME, ERROR\nHA0150   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND THE TIME, SPECIFIED AS HHMMSS - WE MUST          *\n*   CONVERT IT TO SECONDS*100 SINCE MIDNIGHT                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         XC    @HA_DateConv_Area,@HA_DateConv_Area Clear Date area\n         PACK  @HA_DBLWD,@HA_TEMP(2)  PACK HH\n         CVB   R15,@HA_DBLWD          BINARIZE IT\n         STC   R15,@HA_DateConv_Area+DConv_Time_hh-DateConv_Area\n         PACK  @HA_DBLWD,@HA_TEMP+2(2) GET NBR MINUTES\n         CVB   R15,@HA_DBLWD          BINARIZE THEM\n         STC   R15,@HA_DateConv_Area+DConv_Time_mm-DateConv_Area\n         PACK  @HA_DBLWD,@HA_TEMP+4(2) PACK SECONDS\n         CVB   R15,@HA_DBLWD          BINARIZE THEM\n         STC   R15,@HA_DateConv_Area+DConv_Time_ss-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+\n               nv_Input_hhmmss       Indicate Time conversion\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get seconds since midnight\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         L     R15,@HA_DateConv_Area+DConv_Time-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?\n         BNO   HA0160                 No, must be END=\n         ST    R15,ODTE_StartTime-ODT_Entry(R10) Save Start Time\n         B     HA0170                 And skip\nHA0160   DS    0H\n         ST    R15,ODTE_EndTime-ODT_Entry(R10) Save End Time\n         B     HA0170                 And skip\nHA0170   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND A NON-NUMERIC CHARACTER - WE WILL EXIT, WITH     *\n*   THE RETURN CODE 0 IF IT IS A VALID SEPARATOR, 4 IF IT IS NOT.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C','             IS THIS A VALID SPEARATOR?\n         BE    HA0180                 YES, SKIP\n         CLI   0(R2),C' '             NO, TRY AGAIN\n         BNE   HA8000                 INVALID CHARACTER, ERROR\nHA0180   DS    0H\n         SLR   R15,R15                CLEAR RETURN CODE\n         B     HA9000                 AND EXIT\n\nHA1000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=TODAY                                                *\n*     On Entry, R2 = A(\"TODAY\")                                     *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"TODAY\"                          *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,5(0,R2)             Adjust pointer\n         SH    R3,=HL2'5'             Adjust chars remaining\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA2000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=(TODAY-n)                                            *\n*     On Entry, R2 = A(\"(TODAY-\")                                   *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"(TODAY-n)\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,7(0,R2)             Adjust pointer\n         SH    R3,=HL2'7'             Adjust chars remaining\n         BNP   HA8000                 Error, exit\n         LR    R14,R2                 Save A(start)\nHA2010   DS    0H\n         CLI   0(R2),C')'             Closing paren?\n         BE    HA2020                 Yes, skip\n         CLI   0(R2),C'0'             No, is it numeric?\n         BL    HA8000                 No, error\n         CLI   0(R2),C'9'             So far, is it really?\n         BH    HA8000                 No, error\n         LA    R2,1(0,R2)             Yes, bump pointer\n         BCT   R3,HA2010              and try again\n         B     HA8000                 No closing paren, error\nHA2020   DS    0H\n         LR    R15,R2                 A(closing paren)\n         SR    R15,R14                Length of numerics\n         BNP   HA8000                 Nothing, error\n         S     R15,=FL4'1'            EX length\n         EX    R15,HA2999             Pack it\n         CVB   R15,@HA_DBLWD          Binarize it\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SR    R14,R15                Adjust Base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         LA    R2,1(0,R2)            Point past closing paren\n         S     R3,=FL4'1'            Adjust length remaining\n         B     HA0120                 and exit\n\nHA2999   PACK  @HA_DBLWD,0(0,R14)     Pack offset from today\n\nHA3000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=YESTERDAY                                            *\n*     On Entry, R2 = A(\"YESTERDAY\"                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"YESTERDAY\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'1'            Adjust Base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA4000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=THISWEEK                                             *\n*     On Entry, R2 = A(\"THISWEEK\")                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"THISWEEK\"                       *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,8(0,R2)             Adjust pointer\n         SH    R3,=HL2'8'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15                Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA4010                 No, skip\n         SR    R14,R15                Yes, back up to Monday\n         B     HA4020                 and skip\nHA4010   DS    0H\n         LA    R0,6                   Day-of-week for Sunday\n         SR    R0,R15                 Nbr days until Sunday\n         AR    R14,R0                 Adjust base date\nHA4020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA5000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=LASTWEEK                                             *\n*     On Entry, R2 = A(\"LASTWEEK\")                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"LASTWEEK\"                       *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,8(0,R2)             Adjust pointer\n         SH    R3,=HL2'8'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'7'            Back up a week\n         SLR   R15,R15                Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA5010                 No, skip\n         SR    R14,R15                Yes, back up to Monday\n         B     HA5020                 and skip\nHA5010   DS    0H\n         LA    R0,6                   Day-of-week for Sunday\n         SR    R0,R15                 Nbr days until Sunday\n         AR    R14,R0                 Adjust base date\nHA5020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA6000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=THISMONTH                                            *\n*     On Entry, R2 = A(\"THISMONTH\")                                 *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"THISMONTH\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA6010                 No, skip\n         S     R15,=FL4'1'            Yes, nbr days past the 1st\n         SR    R14,R15                Back up to the 1st\n         B     HA6020                 and skip\nHA6010   DS    0H\n         LA    R0,27                  Minimum days-per-month-1\n         SR    R0,R15                 Nbr days until the 27th\n         AR    R14,R0                 Adjust base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R0,R0                  Clear work register\n         IC    R0,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area Get mon\nHA6012   DS    0H\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         A     R14,=FL4'1'            Bump a day\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         SLR   R15,R15               Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area\n         CR    R15,R0                Same month?\n         BE    HA6012                Yes, bump again\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'1'           Back up a day\nHA6020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA7000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=LASTMONTH                                            *\n*     On Entry, R2 = A(\"LASTMONTH\")                                 *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"LASTMONTH\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         SR    R14,R15                Last day of prev month\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA7020                 No, all done\n\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         SLR   R15,R15               Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         S     R15,=FL4'1'           Nbr days until the 1st\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SR    R14,R15               Back up to the 1st\nHA7020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA8000   DS    0H\n         LA    R15,4                  SET RETURN CODE\n         B     HA9000                 AND EXIT\nHA9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HA_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHA9999 CLC     0(0,R2),HA_Keyword-HA_Keyword_Table(R14) Check keyword\n\nHA_Time   TIME  LINKAGE=SYSTEM,MF=L\nHA_Time_Length EQU *-HA_Time\n\nHA_Keyword_Table EQU *\n\nHA_Keyword_Rtn  DC    AL4(HA1000)            A(PROCESSING ROUTINE)\nHA_Keyword_Len  DC    AL1(4)                 EXECUTE LEN OF KEYWORD\nHA_Keyword      DC    C'TODAY'               KEYWORD\n\n                DC    AL4(HA2000)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'(TODAY-'             KEYWORD\n\n                DC    AL4(HA3000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'YESTERDAY'           KEYWORD\n\n                DC    AL4(HA4000)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'THISWEEK'            KEYWORD\n\n                DC    AL4(HA5000)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'LASTWEEK'            KEYWORD\n\n                DC    AL4(HA6000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'THISMONTH'           KEYWORD\n\n                DC    AL4(HA7000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'LASTMONTH'           KEYWORD\n\nHA_Keyword_Table_End EQU *                END OF KEYWORD TABLE\n\n         LTORG\n\n@HA_Dynam       DSECT                 Dynamic area for HA\n@HA_Save        DS    18F              O/S Style save area\n@HA_DBLWD       DS    D                Work area\n@HA_TEMP        DS    CL7              Work area\n                DS    X                Flag Byte\n@HA_Start_Proc  EQU   *-1,X'80'         1... .... Processing START=\n@HA_Date_Proc   EQU   *-1,X'02'         .... ..1. Processing Date\n@HA_Time_Proc   EQU   *-1,X'01'         .... ...1 Processing Time\n@HA_Macros      DS    0F\n@HA_Time        DS    CL(HA_Time_Length) L-Form of Time\n@HA_TimeArea    DS    CL16             Return area for Time\n                ORG   @HA_Macros\n@HA_DateConv_Area DS  CL(DConv_Area_Length)\n                ORG\n                DS    0D               Alignment\n@HA_DynLen      EQU   *-@HA_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHB0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'PRINT=' Keyword PROCESSOR.                                    *\n*             VALID VALUES ARE:                                     *\n*                     \"NO\"     - DO NOT PRINT SELECTED RECORDS      *\n*                     \"EBCDIC\" - PRINT SELECTED RECORDS IN EBCDIC   *\n*                                ONLY                               *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Print_NO flag set           *\n*                      4 - ERROR FOUND                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HB0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HB_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HB_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HB_Dynam,R13            Assign a base\n         L     R15,@HB_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of PRINT= keyword                         *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HB8000                 NO, ERROR\n         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?\n         BNE   HB0020                 NO, skip\n         OI    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO YES, SET\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HB9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HB9000                 YES, SKIP\n         B     HB8000                 NO, ERROR\nHB0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"EBCDIC\" KEYWORD.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'6'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HB8000                 NO, ERROR\n         CLC   0(6,R2),=C'EBCDIC'     YES, IS THIS IT?\n         BNE   HB8000                 NO, ERROR\n         OI    ODTE_Print_EB-ODT_Entry(R10),L'ODTE_Print_EB YES, SET\n         LA    R2,6(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'6'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HB9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HB9000                 YES, SKIP\n         B     HB8000                 NO, ERROR\nHB8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HB9000                 AND EXIT\nHB9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HB_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HB_Dynam       DSECT                 Dynamic area for J\n@HB_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HB_DynLen      EQU   *-@HB_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\nHC0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'INCLUDE=/EXCLUDE=' Keyword Processor                          *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - All OK, ODTE_RTT_Ptr set                 *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HC0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HC_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HC_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HC_Dynam,R13            Assign a base\n         L     R15,@HC_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of INCLUDE=/EXCLUDE= keyword              *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n         LR    R15,R2                   Back up to start of\n         SH    R15,=HL2'8'               keyword\n         CLI   0(R15),C'I'              Include?\n         BNE   HC0020                   No, must be Exclude\n         NI    @HC_Exclude,X'FF'-L'@HC_Exclude OFF 'EXCLUDE' FLAG\n         B     HC0030                   and skip\nHC0020   DS    0H\n         OI    @HC_Exclude,L'@HC_Exclude Turn on Exclude flag\n         B     HC0030                   and skip\nHC0030   DS    0H\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK THAT BOTH INCLUDE AND EXCLUDE HAVE NOT BEEN SPECIFIED.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    HC0050                None, skip\n         TM    @HC_Exclude,L'@HC_Exclude Is this Exclude\n         BO    HC0040                 YES, SKIP\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=\n         B     HC0050                 AND CONTINUE\nHC0040   DS    0H\n         TM    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include\n         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=\nHC0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP OUR TRANSLATE TABLE TO LOOK FOR NUMERICS AND SEPARATORS.*\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVI   @HC_RecType,X'00'       Init Record type\n         XC    @HC_SubType,@HC_SubType   and sub-type\n         NI    @HC_Paren,X'FF'-L'@HC_Paren Off flag\n         NI    @HC_RecTyp,X'FF'-L'@HC_Rectyp Off flag\n         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present\n\n         MVI   @HC_TRTab,X'FE'        SET WHOLE TABLE TO\n         MVC   @HC_TRTab+1(L'@HC_TRTab-1),@HC_TRTab INVALID VALUES\n         MVI   @HC_TRTab+C'0',X'00'   NUMERICS ARE\n         MVC   @HC_TRTab+C'1'(9),@HC_TRTab+C'0' VALID\n         MVI   @HC_TRTab+C' ',X'01'   STOP ON A BLANK\n         MVI   @HC_TRTab+C',',X'01'        AND A COMMA\n         MVI   @HC_TRTab+C'(',X'01'        AND OPEN PARENS\n         MVI   @HC_TRTab+C')',X'01'        AND CLOSE PARENS\n         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp No rectype yet\n         NI    @HC_Paren,X'FF'-L'@HC_Paren No parens either\n         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?\n         BNE   HC0060                 NO, SKIP\n         OI    @HC_Paren,L'@HC_Paren  Yes, set our flag\n         LA    R2,1(0,R2)             POINT PAST IT\n         SH    R3,=H'1'               AND REDUCE LENGTH\nHC0060   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FIND NEXT SEPARATOR.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HC9998             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R5                 RESTORE A(START)\n         LR    R4,R1                 A(SEPARATOR)\n         SR    R4,R2                 R4 = LEN OF DATA\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, R2 = A(START OF DATA)                           *\n*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *\n*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HC8000                YES, SKIP\n         LTR   R4,R4                 ANY DATA THERE?\n         BNP   HC8000                NONE, ERROR\n         CH    R4,=H'3'              YES, IS IT TOO LONG?\n         BH    HC8000                YES, ERROR\n         LR    R15,R4                NO, GET LEN OF STRING\n         SH    R15,=H'1'             EXECUTE LENGTH\n         EX    R15,HC9999            PACK IT\n         CVB   R1,@HC_DBLWD          AND BINARIZE IT\n         LA    R15,0(R2,R4)          POINT TO SEPARATOR\n         TM    @HC_RecTyp,L'@HC_RecTyp HAVE WE ALREADY GOT RECTYPE?\n         BZ    HC0070                NO, SKIP\n         CLI   0(R15),C')'           YES, IS THIS END OF SUBTYPE?\n         BNE   HC8000                NO, ERROR\n         LA    R4,1(0,R4)            YES, BUMP PAST IT\n         STH   R1,@HC_SubType        SAVE SUBTYPE\n         OI    @HC_SubType_Present,L'@HC_SubType_Present Set flag\n         B     HC0080                AND SKIP\nHC0070   DS    0H\n         STC   R1,@HC_RecType        SAVE RECORD TYPE\n         CLI   0(R15),C'('           START OF SUBTYPE?\n         BNE   HC0080                NO, SKIP\n         OI    @HC_RecTyp,L'@HC_RecTyp YES, SAY WE HAVE RECORD TYPE\n         LA    R2,1(R2,R4)           POINT PAST OPEN PAREN\n         SR    R3,R4                 ADJUST LENGTH REMAINING\n         SH    R3,=H'1'                PROPERLY\n         B     HC0060                AND KEEP GOING\nHC0080   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, @HC_RecType CONTAINS THE RECORD TYPE,        *\n*                      @HC_SubType CONTAINS THE SUBTYPE             *\n*    AND WE GO TO FIND A FREE ENTRY IN THE RECTYPE TABLE            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,10                 INITIAL NBR ENTRIES IN TBL\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    HC0090                NONE, SKIP\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         L     R0,RTT_Subp_Len-RecType_Tbl(R15) GET LEN\n         SLL   R0,8                  GET RID OF\n         SRL   R0,8                    SUBPOOL\n         CR    R0,R1                 IS THE TABLE BIG ENOUGH?\n         BNL   HC0110                YES, GO INSERT ENTRY\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) NO, GET NBR ENTRIES\n         SLL   R1,1                  DOUBLE THEM\nHC0090   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EITHER THE RECORD TYPE TABLE DOESN'T EXIST, OR IT IS TOO       *\n*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *\n*    R1 CONTAINS THE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE. *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF ENTRIES\n         LA    R0,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HC_DBLWD          SAVE SUBPOOL AND LENGTH\n         ST    R1,@HC_DBLWD+4        SAVE A(TABLE)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Move the old table to the new, or just clear the table if      *\n*   there is no old table                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R0,R1                 A(New TABLE) IN R0\n         L     R1,@HC_DBLWD          LEN IN R1\n         SLR   R15,R15               Assume no old table\n         ICM   R14,B'1111',ODTE_RTT_Ptr GET A(OLD TABLE)\n         BZ    HC0095                NONE, SKIP\n         L     R15,RTT_Subp_Len-RecType_Tbl(R14) YES, GET CURR LEN\n         SLL   R15,8                 CLEAR OUT\n         SRL   R15,8                  SUBPOOL\nHC0095   DS    0H\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n\n         ICM   R1,B'1111',ODTE_RTT_Ptr  GET A(OLD TABLE)\n         BZ    HC0100                   None, skip\n         L     R0,RTT_Subp_Len-RecType_Tbl(R1) GET ITS LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHC0100   DS    0H\n         L     R15,@HC_DBLWD+4       A(NEW TABLE)\n         ST    R15,ODTE_RTT_Ptr      SAVE IT\n         MVC   RTT_Subp_Len-RecType_Tbl(L'RTT_Subp_Len,R15),@HC_DBLWD\n         LH    R0,RTT_Entry_Count-RecType_Tbl(R15)\n         LTR   R0,R0                 Are we creating table?\n         BNZ   HC0110                No, skip\n         TM    @HC_Exclude,L'@HC_Exclude Yes, are we EXCLUDEing?\n         BO    HC0105                Yes, skip\n         OI    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include\n         B     HC0110                and skip\nHC0105   DS    0H\n         OI    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\nHC0110   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND NOW INSERT THE RECORD TYPE AND SUBTYPE IN THE TABLE.       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr      A(RECORD TYPE TABLE)\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         AR    R1,R15                A(FREE ENTRY)\n         MVC   RTTE_RecType-RTT_Entry(L'RTTE_RecType,R1),@HC_RecType\n         NI    RTTE_SubType_Present-RTT_Entry(R1),X'FF'-L'RTTE_SubType_+\n               Present\n         TM    @HC_SubType_Present,L'@HC_SubType_Present SubType?\n         BNO   HC0120                No, skip\n         MVC   RTTE_SubType-RTT_Entry(L'RTTE_SubType,R1),@HC_SubType\n         OI    RTTE_SubType_Present-RTT_Entry(R1),L'RTTE_SubType_Presen+\n               t\nHC0120   DS    0H\n\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES\n         LA    R1,1(0,R1)            BUMP IT\n         STH   R1,RTT_Entry_Count-RecType_Tbl(R15) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP TO FIND THE NEXT SUBENTRY.                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AR    R2,R4                 A(SEPARATOR)\n         SR    R3,R4                 ADJUST LEN LEFT IN RECORD\n         SLR   R15,R15               CLEAR RETURN CODE\n         TM    @HC_Paren,L'@HC_Paren IS THE WHOLE MESS IN PARENS?\n         BZ    HC9000                NO, EXIT\n         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp YES, OFF FOUND FLAG\n         MVI   @HC_RecType,X'00'     CLEAR RECORD TYPE\n         XC    @HC_SubType,@HC_SubType AND SUBTYPE\n         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present\n         CLI   0(R2),C','            MORE RECORD TYPES?\n         BNE   HC0130                NO, SKIP\n         LA    R2,1(0,R2)            YES, BUMP PAST COMMA\n         SH    R3,=H'1'              ADJUST LENGTH\n         B     HC0060                AND TRY AGAIN\nHC0130   DS    0H\n         CLI   0(R2),C')'            IS THIS THE END?\n         BNE   HC8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST CLOSING PAREN\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         NI    @HC_Paren,X'FF'-L'@HC_Paren AND OFF PAREN FLAG\n         SLR   R15,R15               CLEAR RETURN CODE\n         B     HC9000                AND EXIT\nHC8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HC9000                AND EXIT\nHC9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HC_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHC9998 TRT     0(0,R5),@HC_TRTab     FIND ENDING CHARACTER\nHC9999 PACK    @HC_DBLWD,0(0,R2)     PACK RECORD TYPE/SUBTYPE\n\n         LTORG\n\n@HC_Dynam       DSECT                 Dynamic area for J\n@HC_Save        DS    18F              O/S Style save area\n@HC_DBLWD       DS    D                Work area\n@HC_RecType     DS    X                Record Type\n@HC_SubType     DS    HL2              Record Type 30 Subtype\n                DS    X                Flag Byte\n@HC_Paren       EQU   *-1,X'80'         1... ....  IN PARENTHESES\n@HC_RecTyp      EQU   *-1,X'40'         .1.. ....  RECTYPE FOUND\n@HC_Exclude     EQU   *-1,X'20'         ..1. ....  EXCLUDE SPECIFIED\n@HC_SubType_Present EQU *-1,X'10'       ...1 ....  SubType found\n@HC_TRTab       DS    XL256            Translate table\n                DS    0D               Alignment\n@HC_DynLen      EQU   *-@HC_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10                    ODT Entry base\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHD0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'JOBNAME=' Keyword Processor                                   *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_JNT_Ptr updated             *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HD0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HD_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HD_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HD_Dynam,R13            Assign a base\n         L     R15,@HD_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP OUR TRANSLATE TABLE TO STOP ON SEPARATORS.              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PARENTHESES FLAG\n         MVI   @HD_TRTab,X'00'        ANYTHING GOES IN A JOB NAME\n         MVC   @HD_TRTab+1(L'@HD_TRTab-1),@HD_TRTab\n         MVI   @HD_TRTab+C' ',X'01'   STOP ON A BLANK\n         MVI   @HD_TRTab+C',',X'01'        AND A COMMA\n         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?\n         BNE   HD0020                 NO, SKIP\n         OI    @HD_Paren,L'@HD_Paren  YES, SAY SO\n         LA    R2,1(0,R2)             POINT PAST IT\n         SH    R3,=H'1'               AND REDUCE LENGTH\n         MVI   @HD_TRTab+C')',X'01'   STOP ON CLOSE PAREN TOO\nHD0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FIND NEXT SEPARATOR.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HD9999             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R5                 RESTORE A(START)\n         LR    R4,R1                 A(SEPARATOR)\n         SR    R4,R2                 R4 = LEN OF DATA\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, R2 = A(START OF DATA)                           *\n*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *\n*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HD8000                YES, SKIP\n         LTR   R4,R4                 ANY DATA THERE?\n         BNP   HD8000                NONE, ERROR\n         CH    R4,=H'8'              YES, IS IT TOO LONG?\n         BH    HD8000                YES, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, R2 POINTS TO START OF JOBNAME,               *\n*                      R4 CONTAINS ITS LENGTH                       *\n*    AND WE GO TO FIND A FREE ENTRY IN THE JOBNAME TABLE            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,10                 INITIAL NBR ENTRIES IN TBL\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOB NAME TABLE)\n         BZ    HD0030                None, SKIP\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN\n         L     R0,JNT_Subp_Len-JobName_Tbl(R15) GET CURR LEN\n         SLL   R0,8                  GET RID OF\n         SRL   R0,8                    SUBPOOL\n         CR    R0,R1                 IS THE TABLE BIG ENOUGH?\n         BNL   HD0050                YES, GO INSERT ENTRY\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) NO, NBR ENTRIES\n         SLL   R1,1                  DOUBLE THEM\nHD0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EITHER THE JOB NAME TABLE DOESN'T EXIST, OR IT IS TOO          *\n*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *\n*    R1 CONTAINS THE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE. *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF ENTRIES\n         LA    R0,JNT_Entry-JobName_Tbl+7(0,R1) ADD TBL HEADER LEN\n         SRL   R0,3                  Make it a doubleword\n         SLL   R0,3                   multiple\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HD_JNT_Subp_Len   SAVE SUBPOOL AND LENGTH\n         ST    R1,@HD_JNT_Pointer    SAVE A(TABLE)\n         LR    R0,R1                 A(TABLE) IN R0\n         L     R1,@HD_JNT_Subp_Len   LEN IN R1\n         SLR   R14,R14               NOTHING IN R14\n         SLR   R15,R15               AND IN 15\n         MVCL  R0,R14                CLEAR THE TABLE\n         ICM   R14,B'1111',ODTE_JNT_Ptr GET A(OLD TABLE)\n         BZ    HD0040                None, SKIP\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THERE WAS AN OLD TABLE, SO WE HAVE TO COPY IT TO THE NEW TABLE *\n*    AREA, AND THEN FREE UP THE OLD ONE.                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,JNT_Subp_Len-JobName_Tbl(R14) YES, GET CURR LENGTH\n         SLL   R15,8                 CLEAR OUT\n         SRL   R15,8                  SUBPOOL\n         L     R0,@HD_JNT_Pointer    GET A(NEW TABLE)\n         LR    R1,R15                SAME LENGTH\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n         L     R1,ODTE_JNT_Ptr       GET A(OLD TABLE)\n         L     R0,JNT_Subp_Len-JobName_Tbl(R1) GET ITS LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHD0040   DS    0H\n         L     R15,@HD_JNT_Pointer   A(NEW TABLE)\n         ST    R15,ODTE_JNT_Ptr      SAVE IT\n         MVC   JNT_Subp_Len-JobName_Tbl(L'JNT_Subp_Len,R15),@HD_JNT_Sub+\n               p_Len\nHD0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND NOW INSERT THE JOB NAME IN THE TABLE.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN\n         AR    R1,R15                A(FREE ENTRY)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE ARE NOW POINTING AT A FREE ENTRY IN THE JOBNAME TABLE -     *\n*   IF THIS IS A PREFIX (IE, LAST CHAR IS AN '*'), CALCULATE THE    *\n*   EXECUTE LEN AND SAVE IT; OTHERWISE, USE 7 AS THE EXECUTE LEN.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R14,L'JNTE_JobName-1  DEFAULT EXECUTE LENGTH\n         LA    R15,0(R2,R4)          POINT PAST JOBNAME\n         SH    R15,=H'1'             BACK UP A CHARACTER\n         CLI   0(R15),C'*'           IS THIS JOBNAME A PREFIX?\n         BNE   HD0060                NO, SKIP\n         SH    R4,=H'1'              YES, DON'T INCLUDE THE ASTERISK\n         LR    R14,R4                GET\n         SH    R14,=H'1'              EXECUTE LENGTH\nHD0060   DS    0H\n         STC   R14,JNTE_JobName_Len-JNT_Entry(R1) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    MOVE THE JOBNAME/PREFIX TO THE TABLE.                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,JNTE_JobName-JNT_Entry(R1) A(JOBNAME FIELD)\n         LA    R1,L'JNTE_JobName     LEN OF JOBNAME FIELD\n         LR    R14,R2                A(JOBNAME)\n         LA    R15,C' '              PAD CHARACTER\n         SLL   R15,24                IN THE PROPER PLACE\n         OR    R15,R4                INSERT LENGTH\n         MVCL  R0,R14                MOVE JOBNAME\n         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES\n         LA    R1,1(0,R1)            BUMP IT\n         STH   R1,JNT_Entry_Count-JobName_Tbl(R15) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP TO FIND THE NEXT SUBENTRY.                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AR    R2,R4                 A(SEPARATOR)\n         CLI   0(R2),C'*'            WAS THIS A PREFIX?\n         BNE   HD0070                NO, SKIP\n         LA    R2,1(0,R2)            YES, SKIP PAST THE ASTERISK\nHD0070   DS    0H\n         SR    R3,R4                 ADJUST LEN LEFT IN RECORD\n         SLR   R15,R15               CLEAR RETURN CODE\n         TM    @HD_Paren,L'@HD_Paren DO WE HAVE PARENS AROUND NAMES?\n         BZ    HD9000                NO, EXIT\n         CLI   0(R2),C','            YES, MORE JOBNAMES?\n         BNE   HD0080                NO, ERROR\n         LA    R2,1(0,R2)            YES, BUMP PAST COMMA\n         SH    R3,=H'1'              ADJUST LENGTH\n         B     HD0020                AND TRY AGAIN\nHD0080   DS    0H\n         CLI   0(R2),C')'            CLOSING PAREN?\n         BNE   HD8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PAREN FLAG\n         B     HD9000                AND EXIT\nHD8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HD9000                AND EXIT\nHD9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HD_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHD9999 TRT     0(0,R5),@HD_TRTab     FIND ENDING CHARACTER\n\n         LTORG\n\n@HD_Dynam       DSECT                 Dynamic area for HD\n@HD_Save        DS    18F              O/S Style save area\n@HD_JNT_Pointer DS    AL4              A(JobName Table)\n@HD_JNT_Subp_Len DS   FL4              Subpool, length of JNT\n@HD_TRTab       DS    XL256            Translate table\n                DS    X                Flag byte\n@HD_Paren       EQU   *-1,X'80'         1... .... In parentheses\n                DS    0D               Alignment\n@HD_DynLen      EQU   *-@HD_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHE0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'DATA=' Keyword Processor                                      *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_DT_Ptr updated              *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HE0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HE_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HE_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HE_Dynam,R13            Assign a base\n         L     R15,@HE_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Set up our translate table.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HE_Quote,X'FF'-L'@HE_Quote Off Quote flag\n         NI    @HE_Hex,X'FF'-L'@HE_Hex    and hex flag\n         MVC   @HE_TRTab,HE_EBCDIC_TRTab MOVE EBCDIC TRAN TABLE\n\n         CH    R3,=H'1'               MORE THAN 1 CHARACTER LEFT?\n         BNH   HE0070                 NO, NOT A QUOTED STRING\n         CLI   0(R2),C''''            YES, START WITH A QUOTE?\n         BE    HE0020                 YES, SKIP\n         CLI   0(R2),C'\"'             NO, DOUBLE QUOTE?\n         BNE   HE0030                 NO, SKIP\nHE0020   DS    0H\n         SH    R2,=H'1'               BACK UP A BYTE\n         AH    R3,=H'1'               SET UP LENGTH\n         B     HE0040                 AND SKIP\nHE0030   DS    0H\n         CLI   1(R2),C''''            YES, SINGLE QUOTE?\n         BE    HE0040                 YES, SKIP\n         CLI   1(R2),C'\"'             NO, DOUBLE QUOTE?\n         BNE   HE0070                 NO, NO QUOTED STRING\nHE0040   DS    0H\n         OI    @HE_Quote,L'@HE_Quote    SAY WE'RE DOING A QUOTED STRING\n         CLI   0(R2),C'C'             CHARACTER STRING?\n         BE    HE0050                 YES, SKIP\n         CLI   0(R2),C'='             QUOTES WITH NO C OR H?\n         BE    HE0050                 YES, ASSUME CHARACTER DATA\n         CLI   0(R2),C'X'             NO, HEX STRING?\n         BNE   HE8000                 NO, ERROR\n         OI    @HE_Hex,L'@HE_Hex      YES, SAY SO\n         MVC   @HE_TRTab,HE_Hex_TRTab AND MOVE HEX CHARS TO TRANS TBL\n         B     HE0060                 SKIP\nHE0050   DS    0H\n         MVI   @HE_TRTab,X'00'        ANYTHING GOES\n         MVC   @HE_TRTab+1(L'@HE_TRTab-1),@HE_TRTab BETWEEN QUOTES\nHE0060   DS    0H\n         SLR   R0,R0                  CLEAR WORK REGISTER\n         IC    R0,1(0,R2)             GET SEPARATOR CHARACTER\n         LA    R15,@HE_TRTab          A(TRANSLATE TABLE)\n         AR    R15,R0                 A(CHARACTER IN TRAN TBL\n         MVI   0(R15),X'01'           STOP TRANSLATION THERE\n         LA    R2,2(0,R2)             POINT PAST FIRST SEPARATOR\n         SH    R3,=H'2'               AND ADJUST LENGTH\n         BNP   HE8000                 NOTHING LEFT, ERROR\nHE0070   DS    0H\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HE9997             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R1                 A(LAST CHARACTER)\n         SR    R1,R4                 GET LENGTH OF DATA\n         SR    R3,R1                 ADJUST LENGTH REMAINING\n         AH    R3,=H'1'               PROPERLY\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HE8000                YES, SKIP\n         LR    R4,R2                 NO, GET STARTING ADDRESS\n         SR    R4,R5                 GET LEN OF DATA\n         TM    @HE_Quote,L'@HE_Quote ARE WE DOING A QUOTED STRING?\n         BNO   HE0110                NO, SKIP\n         CH    R0,=H'1'              YES, DID WE GET A FINAL SEP?\n         BNE   HE8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              AND ADJUST LENGTH REMAINING\n         TM    @HE_Hex,L'@HE_Hex     ARE WE DOING HEX?\n         BZ    HE0110                NO, SKIP\n         STC   R4,@HE_DBLWD          YES, SAVE LENGTH\n         TM    @HE_DBLWD,X'01'       IS LENGTH AN EVEN NUMBER\n         BO    HE8000                NO, ERROR\n         SRL   R4,1                  GET LENGTH OF CONVERTED HEX\n         LR    R15,R5                A(START OF SOURCE)\n         LR    R14,R5                A(START OF TARGET DATA\nHE0080   DS    0H\n         LA    R0,X'FF'              WHEN R0 GOES NEGATIVE, WE HAVE\n         SLL   R0,16                   GOT ONE PACKED BYTE\nHE0090   DS    0H\n         CR    R15,R2                HAVE WE GONE FAR ENOUGH?\n         BNL   HE0110                YES, SKIP\n         IC    R1,0(0,R15)           GET BYTE OF SOURCE DATA\n         CLI   0(R15),C'0'           IS IT X'C1' - X'C6'?\n         BNL   HE0100                NO, OK\n         LA    R1,9(0,R1)            YES, CONVERT TO X'CA' - X'CF'\nHE0100   DS    0H\n         SLL   R1,28                 GET LOW NIBBLE AT TOP OF R1\n         SLDL  R0,4                  AND INTO R0\n         LA    R15,1(0,R15)          BUMP SOURCE PTR\n         LTR   R0,R0                 NO, HAVE WE DONE 2 SOURCE BYTES?\n         BNL   HE0090                NOT YET, CONTINUE\n         STC   R0,0(0,R14)           YES, SAVE HEX BYTE\n         LA    R14,1(0,R14)          BUMP DEST PTR\n         B     HE0080                AND CONTINUE\nHE0110   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, R2 = A(NEXT CHARACTER AFTER DATA)            *\n*                      R4 = LENGTH OF DATA,                         *\n*                      R5 = A(START OF DATA)                        *\n*    IF THE DATA WAS IN HEX (ENTERED AS X'123456'), IT HAS BEEN     *\n*   CONVERTED, AND R4 REFLECTS THE NEW LENGTH.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)\n         BZ    HE0140                None, GO GET ONE\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R15,DT_Entry-Data_Tbl(R15) AND POINT TO THE FIRST ONE\n         LTR   R14,R14               ARE THERE ANY ENTRIES?\n         BZ    HE0130                NO, SKIP\nHE0120   DS    0H\n         SLR   R1,R1                 CLEAR WORK REGISTER\n         IC    R1,DTE_Length-DT_Entry(R15) GET LEN OF DATA\n         LA    R15,DTE_Data-DT_Entry+1(R1,R15) A(NEXT ENTRY\n         BCT   R14,HE0120            AND GO TILL THE END\nHE0130   DS    0H\n         LA    R14,DTE_Data-DT_Entry(R4,R15) A(END OF OUR NEW ENT)\n         S     R14,ODTE_DT_Ptr       LENGTH OF UPDATED TABLE\n         L     R1,ODTE_DT_Ptr        A(TABLE)\n         L     R1,DT_Subp_Len-Data_Tbl(R1) GET CURRENT LENGTH\n         SLL   R1,8                  GET RID OF\n         SRL   R1,8                    SUBPOOL\n         CR    R1,R14                WILL OUR ENTRY FIT?\n         BNL   HE0170                YES, GO DO IT\nHE0140   DS    0H\n         LA    R0,128                DEFAULT SUBPOOL AND LENGTH\n         ICM   R1,B'1111',ODTE_DT_Ptr GET A(CURRENT TABLE)\n         BZ    HE0150                None, SKIP\n         L     R1,DT_Subp_Len-Data_Tbl(R1) YES, GET SUBPOOL, LEN\n         SLDL  R0,8                  PUT SUBPOOL IN R0\n         SLL   R1,1                  DOUBLE CURRENT LENGTH\n         SLDL  R0,24                 AND PUT IT IN R0 TOO\nHE0150   DS    0H\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HE_DT_Subp_Len    SAVE SUBPOOL, LENGTH\n         ST    R1,@HE_DT_Pointer     AND A(NEW TABLE)\n         LR    R0,R1                 A(OUR TABLE)\n         L     R1,@HE_DT_Subp_Len    SUBPOOL, LENGTH OF IT\n         SLL   R1,8                  GET RID OF\n         SRL   R1,8                    SUBPOOL\n         SLR   R14,R14               NO SENDING ADDRESS\n         SLR   R15,R15                 OR LENGTH\n         MVCL  R0,R14                CLEAR OUR TABLE\n         ICM   R14,B'1111',ODTE_DT_Ptr GET A(OLD TABLE)\n         BZ    HE0160                None, SKIP\n         L     R15,DT_Subp_Len-Data_Tbl(R14) YES, GET SUBPOOL, LENGTH\n         SLL   R15,8                 CLEAR SUBPOOL SO THAT\n         SRL   R15,8                   PAD CHAR IS X'00'\n         L     R0,@HE_DT_Pointer     A(NEW TABLE AREA)\n         L     R1,@HE_DT_Subp_Len    LENGTH OF NEW TABLE\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n         L     R1,ODTE_DT_Ptr        A(OLD DATA TABLE)\n         L     R0,DT_Subp_Len-Data_Tbl(R1) SUBPOOL, LENGTH OF TBL\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHE0160   DS    0H\n         L     R15,@HE_DT_Pointer    A(NEW TABLE AREA)\n         ST    R15,ODTE_DT_Ptr       SAVE IT\n         L     R0,@HE_DT_Subp_Len    SUBPOOL, LENGTH\n         ST    R0,DT_Subp_Len-Data_Tbl(R15) AND SAVE IN TABLE\n         B     HE0110                and try again\nHE0170   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, WE ARE READY TO INSERT THE ENTRY IN THE TABLE   *\n*                   R4 =  LENGTH OF DATA                            *\n*                   R5 =  A(DATA)                                   *\n*                   R15 = A(ENTRY IN TABLE)                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R14,R4                GET THE LENGTH OF DATA\n         SH    R14,=H'1'             EXECUTE LENGTH\n         EX    R14,HE9998            MOVE IT\n         STC   R14,DTE_Length-DT_Entry(R15) AND SAVE EXEC LENGTH\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW DECODE THE REST OF THE STUFF IN THE RECORD                 *\n*                  R2  = A(NEXT CHAR IN INPUT)                      *\n*                  R3  = LEN REMAINING IN INPUT                     *\n*                  R15 = A(ENTRY IN TABLE)                          *\n*    NOTE THAT WE HAVE NOT YET UPDATED THE NUMBER OF ENTRIES IN     *\n*   THE TABLE (DT_Entry_Count), SO THAT IF WE FIND AN ERROR IN THE  *\n*   REMAINDER OF THE INPUT CARD, WE CAN JUST EXIT.                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                 CLEAR OFFSET\n         LTR   R3,R3                 ANY DATA REMAINING IN THE INPUT?\n         BZ    HE0180                NO, WE'RE FINISHED\n         CLI   0(R2),C' '            YES, HAVE WE FINISHED?\n         BE    HE0180                YES, GO UPDATE TABLE\n         CLI   0(R2),C','            NO, IS THIS A VALID SEPARATOR?\n         BNE   HE8000                NO, ERROR\n         CLI   1(R2),C'0'            IS THE NEXT CHAR NUMERIC?\n         BL    HE0180                NO, SKIP\n         CLI   1(R2),C'9'            SO FAR, CHECK AGAIN\n         BH    HE0180                NOT NUMERIC, SKIP\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         BNP   HE8000                TRAILING COMMA, ERROR\n         MVI   @HE_TRTab,X'FF'       SET UP TRANSLATE TABLE\n         MVC   @HE_TRTab+1(255),@HE_TRTab SO THAT ALL\n         MVI   @HE_TRTab+C'0',X'00'      CHARACTERS EXCEPT\n         MVC   @HE_TRTab+C'1'(9),@HE_TRTab+C'0' NUMERICS ARE INVALID\n         MVI   @HE_TRTab+C' ',X'01'  FLAG SPACE AS SPECIAL\n         MVI   @HE_TRTab+C',',X'01'    COMMA TOO\n         LR    R5,R2                 SAVE A(DATA)\n         LA    R1,0(R2,R3)           A(PAST LAST CHAR)\n         LA    R2,1                  SIMULATE A SPACE\n         EX    R3,HE9997             CHECK OUR CHARACTERS\n         LR    R0,R2                 SAVE R2\n         LR    R2,R5                 RESTORE R2\n         CH    R0,=H'254'            DID WE FIND AN INVALID CHAR?\n         BNL   HE8000                YES, INVALID\n         SR    R1,R2                 R1 = LENGTH OF DATA\n         SH    R1,=H'1'              EXEC LEN\n         BM    HE8000                NOTHING, INVALID\n         EX    R1,HE9999             PACK THE DATA\n         CVB   R0,@HE_DBLWD          AND PUT IT R0\n         C     R0,=F'32767'          IS IT TOO BIG?\n         BH    HE8000                YES, ERROR\n         LA    R1,1(0,R1)            RESTORE REAL OPERAND LEN\n         AR    R2,R1                 ADJUST NEXT PTR\n         SR    R3,R1                 AND LENGTH REMAINING\nHE0180   DS    0H\n         STH   R0,DTE_Offset-DT_Entry(R15) SAVE IT\n         SLR   R0,R0                 CLEAR REGISTER\n         L     R15,ODTE_DT_Ptr       A(DATA TABLE)\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES\n         LA    R14,1(0,R14)          BUMP IT\n         STH   R14,DT_Entry_Count-Data_Tbl(R15) AND SAVE IT\n         SLR   R15,R15               CLEAR R15\n         B     HE9000                AND EXIT\nHE8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HE9000                AND EXIT\nHE9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HE_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHE9997 TRT     0(0,R5),@HE_TRTab     FIND ENDING CHARACTER\nHE9998 MVC     DTE_Data-DT_Entry(0,R15),0(R5)\nHE9999 PACK    @HE_DBLWD,0(0,R2)     PACK OFFSET/MSG CNT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    TRANSLATE TABLES FOR HE0000, USED TO INTERPRET DATA= OPERANDS. *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nHE_EBCDIC_TRTab DS XL256           EBCDIC TRANSLATE TABLE\n         ORG   HE_EBCDIC_TRTab\n         DC    256X'FE'\n         ORG   HE_EBCDIC_TRTab+C' '\n         DC    X'02'                 SEPARATOR (BLANK)\n         ORG   HE_EBCDIC_TRTab+C','\n         DC    X'02'                 SEPARATOR (,)\n         ORG   HE_EBCDIC_TRTab+C'\u00a2'\n         DC    XL7'00'               \u00a2 . < ( + ] &\n         ORG   HE_EBCDIC_TRTab+C'|'\n         DC    XL8'00'               | $ * ) ; \u00ac - /\n         ORG   HE_EBCDIC_TRTab+C'%'\n         DC    XL4'00'               % _ > ?\n         ORG   HE_EBCDIC_TRTab+C':'\n         DC    XL6'00'               : # @ ' = \"\n         ORG   HE_EBCDIC_TRTab+C'A'\n         DC    XL9'00'               A-I\n         ORG   HE_EBCDIC_TRTab+C'J'\n         DC    XL9'00'               J-R\n         ORG   HE_EBCDIC_TRTab+C'S'\n         DC    XL8'00'               S-Z\n         ORG   HE_EBCDIC_TRTab+C'0'\n         DC    XL10'00'              0-9\n         ORG\n\nHE_Hex_TRTab DS XL256              HEX TRANSLATE TABLE\n         ORG   HE_Hex_TRTab\n         DC    256X'FE'\n         ORG   HE_Hex_TRTab+C'A'\n         DC    XL6'00'               A-F\n         ORG   HE_Hex_TRTab+C'0'\n         DC    XL10'00'              0-9\n         ORG\n\n         LTORG\n\n@HE_Dynam       DSECT                 Dynamic area for HE\n@HE_Save        DS    18F              O/S Style save area\n@HE_DBLWD       DS    D                Work area\n@HE_DT_Pointer  DS    AL4              A(Data Table)\n@HE_DT_Subp_Len DS    FL4              Subpool, length of Dat Table\n                DS    X                Flag Byte\n@HE_Quote       EQU   *-1,X'80'         1... ....  QUOTED STRING\n@HE_Hex         EQU   *-1,X'40'         .1.. ....  HEX STRING\n@HE_TRTab       DS    XL256            Translate table\n                DS    0D               Alignment\n@HE_DynLen      EQU   *-@HE_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHF0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'JOB/DATA=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_JobData_OR flag set         *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HF0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HF_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HF_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HF_Dynam,R13            Assign a base\n         L     R15,@HF_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"OR\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HF8000                 NO, ERROR\n         CLC   0(2,R2),=C'OR'         YES, IS THIS IT?\n         BNE   HF8000                 NO, ERROR\n         OI    ODTE_JobData_OR-ODT_Entry(R10),L'ODTE_JobData_OR Yes, OK\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         B     HF9000                 AND EXIT\nHF8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HF9000                 AND EXIT\nHF9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HF_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HF_Dynam       DSECT                 Dynamic area for HF\n@HF_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HF_DynLen      EQU   *-@HF_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHG0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'STOPAFT=' Keyword Processor                                   *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_StopAft updated             *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HG0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HG_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HG_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HG_Dynam,R13            Assign a base\n         L     R15,@HG_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LOOK FOR THE FIRST NON-NUMERIC                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                  A(START OF OPERAND\nHG0020   DS    0H\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HG0030                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, CHECK AGAIN\n         BH    HG0020                 NO, NOT NUMERIC\n         LA    R2,1(0,R2)             OK, BUMP POINTER\n         BCT   R3,HG0020              AND TRY AGAIN\n         B     HG0040                 OK, SKIP\nHG0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE A NON-NUMERIC CHARACTER - CHECK TO MAKE SURE IT'S A    *\n*    VALID SEPARATOR (BLANK OR COMMA).                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C','             IS THIS A COMMA?\n         BE    HG0040                 YES, SKIP\n         CLI   0(R2),C' '             NO, HOW ABOUT A BLANK\n         BNE   HG8000                 NO, WE HAVE AN ERROR\nHG0040   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK TO SEE IF THE NUMBER IS TOO LONG (MAX = 9 CHARACTERS)    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                GET A(SEPARATOR)\n         SR    R15,R4                LESS THE START\n         CH    R15,=H'9'             IS IT TOO LONG?\n         BH    HG8000                YES, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    IT SEEMS TO BE OK, SO BINARIZE IT AND SAVE IN ODTE_StopAft.    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SH    R15,=H'1'             EXECUTE LEN\n         EX    R15,HG9999            PACK IT\n         CVB   R15,@HG_DBLWD         BINARIZE IT\n         LTR   R15,R15               IS THE NUMBER 0?\n         BE    HG8000                YES, THAT'S AN ERROR\n         ST    R15,ODTE_StopAft-ODT_Entry(R10) No, save it\n         SLR   R15,R15               CLEAR THE RETURN CODE\n         B     HG9000                AND EXIT\nHG8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE AN ERROR, SET THE RETURN CODE AND EXIT.                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HG9000                 AND EXIT\nHG9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HG_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHG9999 PACK    @HG_DBLWD,0(0,R4)        PACK STOPAFT COUNT\n\n         LTORG\n\n@HG_Dynam       DSECT                 Dynamic area for O\n@HG_Save        DS    18F              O/S Style save area\n@HG_DBLWD       DS    D                Work area\n                DS    0D               Alignment\n@HG_DynLen      EQU   *-@HG_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHH0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'INEXIT=/OUTEXIT=' Keyword Processor                           *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_InExit or ODTE_OutExit      *\n*                          updated                                  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HH0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HH_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HH_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HH_Dynam,R13            Assign a base\n         L     R15,@HH_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n         USING ODT_Entry,R10            Assign a base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Figure out if we are INEXIT or OUTEXIT, and set our flag       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                 A(Start of operands)\n         S     R15,=FL4'5'            Back up to keyword\n         CLI   0(R15),C'N'            INEXIT=?\n         BNE   HH0020                 No, must be OUTEXIT=\n         OI    @HH_InExit,L'@HH_InExit Yes, set our flag\nHH0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Figure out what we have here. We can be:                       *\n*      INEXIT=exitname                                              *\n*      INEXIT=(exitname)                                            *\n*      INEXIT=(exitname,parm)                                       *\n*      INEXIT=(exitname,'parm')                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C'('             Open paren?\n         BNE   HH0020C                No, skip\n         OI    @HH_Paren,L'@HH_Paren  Yes, set our flag\n         LA    R2,1(0,R2)             Point past it\n         S     R3,=FL4'1'             and decrement length\nHH0020C  DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Find the end of the exit name, by looking for a blank, comma,  *\n*   or, optionally, a close paren.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R14,R2                 A(Start)\n         LR    R15,R3                 Length\nHH0030   DS    0H\n         CLI   0(R14),C' '            END OF NAME?\n         BE    HH0050                 YES, SKIP\n         CLI   0(R14),C','            NO, TRY AGAIN\n         BE    HH0050                 FOUND END, SKIP\n         TM    @HH_Paren,L'@HH_Paren  Are we in parentheses?\n         BNO   HH0040                 No, skip\n         CLI   0(R14),C')'            Yes, end of name?\n         BE    HH0050                 Yes, skip\nHH0040   DS    0H\n         LA    R14,1(0,R14)           Point to next char\n         BCT   R15,HH0030             and keep checking\nHH0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have the end of the name - move it to our ODT entry         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SR    R14,R2                 Get length of name\n         C     R14,=FL4'8'            Too long?\n         BH    HH8000                 Yes, error\n\n         LR    R1,R2                  Start of data to be moved\n         LR    R3,R15                 Save length remaining\n         AR    R2,R14                 and reset input pointer\n\n         S     R14,=FL4'1'            EX Length to be moved\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT\n         BZ    HH0060                 No, skip\n         LA    R15,ODTE_InExit        Yes, A(InExit name)\n         MVC   ODTE_InExit,=CL(L'ODTE_InExit)' '  Clear it\n         LTR   R14,R14                Anything?\n         BNM   HH0070                 Yes, OK\n         OI    ODTE_No_Dflt_InExit,l'ODTE_No_Dflt_InExit Don't use dflt\n         B     HH0070C                and skip\nHH0060   DS    0H\n         LA    R15,ODTE_OutExit       A(OutExit Name)\n         MVC   ODTE_OutExit,=CL(L'ODTE_OutExit)' '  Clear it\n         LTR   R14,R14                Anything?\n         BNM   HH0070                 Yes, OK\n         OI    ODTE_No_Dflt_OutExit,l'ODTE_No_Dflt_OutExit No dflt\n         B     HH0070C                and skip\n\nHH0070   DS    0H\n         EX    R14,HH_OC              OC    0(0,R15),0(R1)\n\nHH0070C  DS    0H\n         TM    @HH_Paren,L'@HH_Paren  Are we in paren?\n         BNO   HH0180                 No, exit\n         CLI   0(R2),C')'             Yes, at the end?\n         BNE   HH0080                 No, skip\n         LA    R2,1(0,R2)             Yes, point past it\n         S     R3,=FL4'1'             decrement the length\n         B     HH0180                 and exit\nHH0080   DS    0H\n         CLI   0(R2),C','             Separator?\n         BNE   HH8000                 No, exit with error\n         LA    R2,1(0,R2)             Yes, point past it\n         S     R3,=FL4'1'             decrement the length\n         SLR   R0,R0                  Clear work register\n         LA    R0,C')'                Ending character\n\n         CLI   0(R2),C''''            Open quote?\n         BNE   HH0090                 No, skip\n         OI    @HH_Quotes,L'@HH_Quotes Yes, set our flag\n         LA    R2,1(0,R2)             Point past it\n         S     R3,=FL4'1'             Decrement length remaining\n         BNP   HH8000                 Nothing left, error\n         LA    R0,C''''               Ending character\nHH0090   DS    0H\n\n         LA    R14,0(R2,R3)           A(Byte after string)\n         LR    R15,R2                 A(1st byte of string)\nHH0100   DS    0H\n         SRST  R14,R15                Find it\n         BO    HH0100                 Keep trying (CC=3)\n         BNL   HH8000                 Not found, exit with error\n\n         SR    R14,R2                 Length of data\n         BZ    HH0110                 None, skip\n\n         LR    R0,R2                  Start of data to be moved\n         SR    R3,R14                 Update length remaining\n         AR    R2,R14                 Bump pointer\n\n         LR    R1,R14                 Length of data to be moved\n         LA    R14,@HH_ParmArea       Temp save area\n         AH    R14,@HH_ParmLen        A(Next byte)\n         LH    R15,@HH_ParmLen        Bump\n         AR    R15,R1                  current\n         STH   R15,@HH_ParmLen         length\n         LR    R15,R1                 Len to be moved\n         MVCL  R14,R0                 Move parm data\nHH0110   DS    0H\n         TM    @HH_Quotes,L'@HH_Quotes Are we in quotes?\n         BNO   HH0130                No, skip\n         LA    R2,1(0,R2)            Point past quote\n         S     R3,=FL4'1'            Decrement length remaining\n         CLI   0(R2),C''''           Is this two quotes?\n         BNE   HH0130                No, found the end\n\n         LA    R15,@HH_ParmArea      Yes, A(Parmarea)\n         AH    R15,@HH_ParmLen       Point past current data\n         MVI   0(R15),C''''          Add a quote\n         LH    R15,@HH_ParmLen       Bump the\n         A     R15,=FL4'1'            current\n         STH   R15,@HH_ParmLen        length\n         LA    R2,1(0,R2)            Point past quote\n         S     R3,=FL4'1'            Decrement length remaining\n         LA    R0,C''''              Look for a quote\n         B     HH0090                and keep checking\n\nHH0130   DS    0H\n         LA    R2,1(0,R2)            Bump past close paren\n         S     R3,=FL4'1'            and decrement length\n         B     HH0150                exit\n\nHH0150   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have assembled the parm in @HH_ParmArea. If a parm already  *\n*   exists, free it up ...                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0150C                No, skip\n         L     R1,ODTE_InExit_Parm_Ptr Yes, get A(Parm)\n         B     HH0150E                and skip\nHH0150C  DS    0H\n         L     R1,ODTE_InExit_Parm_Ptr Get A(Parm)\nHH0150E  DS    0H\n         LTR   R1,R1                  Any parm?\n         BZ    HH0150I                No, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         TM    @HH_Inexit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0150G                No, skip\n         ST    R15,ODTE_InExit_Parm_Ptr Yes, clear it\n         B     HH0150I                and skip\nHH0150G  DS    0H\n         ST    R15,ODTE_OutExit_Parm_Ptr Clear parm pointer\nHH0150I  DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and copy it to 24-bit storage                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,L'@HH_ParmLen       Length of Parm length\n         AH    R0,@HH_ParmLen         plus length of parm\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0160                 No, skip\n         ST    R1,ODTE_InExit_Parm_Ptr Yes, save A(Parm)\n         B     HH0170                 and skip\nHH0160   DS    0H\n         ST    R1,ODTE_OutExit_Parm_Ptr Save A(Parm)\n         B     HH0170                 and skip\nHH0170   DS    0H\n\n         MVC   0(L'@HH_ParmLen,R1),@HH_ParmLen Save parm length\n         LA    R0,L'@HH_ParmLen(0,R1) Point past it\n         LH    R1,@HH_ParmLen         Get its length\n         LA    R14,@HH_ParmArea       Point to assenbled parm\n         LR    R15,R1                 Same length\n         MVCL  R0,R14                 Move parm\n\nHH0180   DS    0H\n         SLR   R15,R15                CLEAR RETURN CODE\n         B     HH9000                 AND EXIT\n\nHH8000   DS    0H\n         LA    R15,4                  Bad stuff\n         B     HH9000                 AND EXIT\n\nHH9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HH_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHH_OC    OC    0(0,R15),0(R1)           Move exit name\n\n         LTORG\n\n@HH_Dynam       DSECT                 Dynamic area for HH\n@HH_Save        DS    18F              O/S Style save area\n                DS    X                Flag Byte\n@HH_InExit      EQU   *-1,X'80'         1... .... INEXIT= statement\n@HH_Paren       EQU   *-1,X'40'         .1.. .... Parentheses\n@HH_Quotes      EQU   *-1,X'20'         ..1. .... Parm in quotes\n@HH_ParmArea    DS    CL256            Parm area\n@HH_ParmLen     DS    HL2              Length of parm\n                DS    0D               Alignment\n@HH_DynLen      EQU   *-@HH_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHI0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'OUTPUT=' Keyword Processor                                    *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, 3rd parm updated with A(new ODT  *\n*                          entry)                                   *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HI0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HI_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HI_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HI_Dynam,R13            Assign a base\n         L     R15,@HI_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND MOVE THE NAME, CHARACTER BY CHARACTER.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@HI_DDName         A(HOLDING AREA)\n         MVC   @HI_DDName,=CL8' '     CLEAR IT OUT\n         LA    R14,9                  MAX LENGTH OF NAME + 1\n         CR    R14,R3                 ARE THERE THAT MANY LEFT?\n         BNH   HI0020                 YES, SKIP\n         LR    R14,R3                 NO, USE ONLY WHATS LEFT\nHI0020   DS    0H\n         CLI   0(R2),C' '             END OF NAME?\n         BE    HI0030                 YES, SKIP\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HI0030                 FOUND END, SKIP\n         OC    0(1,R15),0(R2)         MOVE CHAR TO NAME FIELD\n         LA    R15,1(0,R15)           BUMP RECEIVING POINTER\n         LA    R2,1(0,R2)             BUMP SENDING POINTER\n         SH    R3,=H'1'               DECREASE CHARS REMAINING\n         BCT   R14,HI0020             AND KEEP GOING\n         LA    R15,4                  TOO MANY CHARACTERS (>8)\n         B     HI9000                 SO EXIT\nHI0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE GOT THE NAME, SO FIND AN ENTRY IN THE OUTPUT ENV TBL.  *\n*   NOTE THAT AN ENTRY MAY ALREADY EXIST - IF SO, WE USE IT. IF NOT,*\n*   WE CREATE ONE,                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr         POINT TO OUR TABLE\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\n         USING ODT_Entry,R10            Tell the assembler\n\nHI0040   DS    0H\n         CLC   ODTE_DDName,@HI_DDName OUR ENTRY?\n         BE    HI0060                 YES, SKIP\n         AL    R10,=AL4(ODTE_Length)  No, point to next entry\n         BCT   R9,HI0040              and check it out\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE DIDN'T FIND OUR ENTRY IN THE TABLE, SO WE WILL CREATE ONE.  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_ODT_Ptr           A(OUR TABLE)\n         L     R15,=AL4(ODTE_Length)  LENGTH OF ONE ENTRY\n         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R1) Nbr entries\n         LA    R14,1(0,R14)           PLUS ONE FOR THE NEW ONE\n*        MR    R14,R14                LENGTH OF ENTRIES @RWS 15-11-13\n         MR    R14,R15                LENGTH OF ENTRIES @RWS 15-11-13\n         LA    R15,ODT_Entry-OutDesc_Tbl(0,R15)   PLUS LEN OF HEADER\n         L     R1,ODT_Subp_Len-OutDesc_Tbl(R1)  Get Tbl Len, Subpool\n         SLL   R1,8                   GET RID OF\n         SRL   R1,8                    SUBPOOL\n         CR    R1,R15                 DO WE HAVE ROOM?\n         BNL   HI0050                 YES, ADD AN ENTRY\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE DON'T HAVE ROOM IN THE TABLE TO INSERT THE NEW ENTRY, SO    *\n*   WE GETMAIN A NEW TABLE TWICE THE SIZE, AND USE IT INSTEAD.      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_ODT_Ptr          GET A(CURRENT TABLE)\n         L     R1,ODT_Subp_Len-OutDesc_Tbl(R15) GET SUBPOOL, LENGTH\n         SLDL  R0,8                   SUBPOOL IN R0\n         SLL   R0,24                  HIGH-ORDER BYTE OF R0\n         SRL   R1,7                   DOUBLE PREVIOUS SIZE\n         OR    R0,R1                  SET UP GETMAIN REGISTER\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HI_ODT_Subp_Len    SAVE SUBPOOL, LENGTH\n         ST    R1,@HI_ODT_Pointer      AND ADDRESS\n         LR    R0,R1                  R0 = A(NEW TABLE)\n         L     R1,@HI_ODT_Subp_Len    R1 = NEW TABLE LENGTH\n         L     R14,@_ODT_Ptr          R14 = A(OLD TABLE)\n         L     R15,ODT_Subp_Len-OutDesc_Tbl(R14) R15 = LENGTH\n         SLL   R15,8                  FILL CHAR\n         SRL   R15,8                   OF X'00'\n         MVCL  R0,R14                 MOVE OLD TABLE TO NEW\n         L     R1,@_ODT_Ptr           A(OLD TABLE)\n         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) IT'S SUBPOOL, LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         L     R1,@HI_ODT_Pointer     A(NEW TABLE)\n         ST    R1,@_ODT_Ptr           SAVE IT\n         L     R0,@HI_ODT_Subp_Len    NEW TABLE LENGTH, SUBPOOL\n         ST    R0,ODT_Subp_Len-OutDesc_Tbl(R1) SAVE IT IN THE TABLE\n         L     R15,=AL4(ODTE_Length)   LENGTH OF ONE ENTRY\n         MH    R15,ODT_Entry_Count-OutDesc_Tbl(R1) Len of entries\n         LA    R10,ODT_Entry-OutDesc_Tbl(0,R15) PLUS LEN OF HEADER\n         A     R10,@_ODT_Ptr         R10 = A(NEW ENTRY AREA)\nHI0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    INITIALIZE OUR NEW ENTRY WITH THE DEFAULT (FIRST) ENTRY.       *\n*       R10 --> NEW ENTRY AREA.                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R10                SAVE A(NEW ENTRY)\n         L     R1,@_ODT_Ptr           A(ENV TABLE)\n         LA    R0,ODT_Entry-OutDesc_Tbl(R1) A(FIRST ENTRY)\n         L     R1,=AL4(ODTE_Length)   ENTRY LENGTH\n         LR    R14,R15                A(NEW ENTRY)\n         LR    R15,R1                 SAME LENGTH\n         MVCL  R14,R0                 MOVE THE DEFAULT ENTRY\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW SET UP OUR STUFF WITHIN OUR ENTRY.                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   ODTE_DDName,@HI_DDName SAVE OUR DDNAME\n         MVI   ODTE_InExit,C' '       CLEAR\n         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit INPUT AND\n         MVC   ODTE_OutExit,ODTE_InExit      OUTPUT EXIT NAMES\n         SLR   R15,R15                CLEAR WORK REG\n         ST    R15,ODTE_RTT_Ptr       NO RECORD TYPE TABLE\n         ST    R15,ODTE_JNT_Ptr       NOR JOBNAME TABLE\n         ST    R15,ODTE_DT_Ptr        NO DATA TABLE EITHER\n         L     R15,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) Nbr entries\n         LA    R14,1(0,R14)           BUMP IT\n         STH   R14,ODT_Entry_Count-OutDesc_Tbl(R15) AND SAVE IT\nHI0060   DS    0H\nHI0070   DS    0H\n         L     R1,@HI_Save+4         A(HSA)\n         L     R1,24(0,R1)           A(Original Parm list)\n         ST    R10,8(0,R1)           Update A(ODT Entry)\n         SLR   R15,R15                CLEAR THE RETURN CODE\n         B     HI9000                 AND EXIT\nHI9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HI_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HI_Dynam       DSECT                 Dynamic area for Q\n@HI_Save        DS    18F              O/S Style save area\n@HI_DDName      DS    CL8              DDName for this ODTE\n@HI_ODT_Pointer DS    AL4              A(Output Desc Tbl)\n@HI_ODT_Subp_Len DS   FL4              Subpool, length of ODT\n                DS    0D               Alignment\n@HI_DynLen      EQU   *-@HI_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHJ0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'PERIOD=' Keyword Processor                                    *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_PeriodStart and             *\n*                          ODTE_PeriodEnd updated.                  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HJ0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HJ_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HJ_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HJ_Dynam,R13            Assign a base\n         L     R15,@HJ_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    BEGIN WITH PERIOD START TIME.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,ODTE_PeriodStart    A(PERIOD START)\nHJ0020   DS    0H\n         MVC   @HJ_Time(6),=C'000000' INIT TEMP AREA\n         LA    R4,@HJ_Time            AND POINT TO IT\nHJ0030   DS    0H\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HJ0040                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, MAKE SURE\n         BH    HJ0040                 NOT NUMERIC, SKIP\n         MVC   0(1,R4),0(R2)          ITS NUMERIC, MOVE IT\n         LA    R4,1(0,R4)             BUMP OUTPUT POINTER\n         LA    R2,1(0,R2)             BUMP INPUT POINTER\n         BCT   R3,HJ0030              AND TRY AGAIN\nHJ0040   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE REACHED THE END OF THE TIME FIELD.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@HJ_Time          A(Start of Time)\n         SR    R4,R15                LENGTH OF DATA\n         BZ    HJ0050                NOTHING THERE, CHECK IT OUT\n         CH    R4,=H'6'              TOO LONG?\n         BH    HJ8000                YES, ERROR\n\n         LR    R4,R1                 Save A(Target field)\n         XC    @HJ_DateConv_Area,@HJ_DateConv_Area Clear Date area\n         PACK  @HJ_DBLWD,@HJ_Time(2)  PACK HH\n         CVB   R15,@HJ_DBLWD          BINARIZE IT\n         STC   R15,@HJ_DateConv_Area+DConv_Time_hh-DateConv_Area\n         PACK  @HJ_DBLWD,@HJ_Time+2(2) GET NBR MINUTES\n         CVB   R15,@HJ_DBLWD          BINARIZE THEM\n         STC   R15,@HJ_DateConv_Area+DConv_Time_mm-DateConv_Area\n         PACK  @HJ_DBLWD,@HJ_Time+4(2) PACK SECONDS\n         CVB   R15,@HJ_DBLWD          BINARIZE THEM\n         STC   R15,@HJ_DateConv_Area+DConv_Time_ss-DateConv_Area\n         OI    @HJ_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+\n               nv_Input_hhmmss       Indicate Time conversion\n         LA    R1,@HJ_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get seconds since midnight\n         LTR   R15,R15               Everything OK?\n         BNZ   HJ8000                No, invalid time\n\n         LR    R1,R4                 Restore A(Target field)\n         L     R15,@HJ_DateConv_Area+DConv_Time-DateConv_Area\n         ST    R15,0(0,R1)           OK, SAVE IT\n         LA    R15,ODTE_PeriodEnd    A(PERIOD END TIME)\n         CR    R1,R15                IS THAT WHAT WE JUST DID?\n         BE    HJ0050                YES, SKIP\n         CLI   0(R2),C'-'            IS THIS THE TIME SEPARATOR?\n         BNE   HJ0050                NO, SKIP\n         LA    R1,ODTE_PeriodEnd     YES, A(PERIOD END TIME)\n         LA    R2,1(0,R2)            POINT PAST SEPARATOR\n         BCT   R3,HJ0020             AND PROCESS IT\nHJ0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE THE END OF THE PARAMETERS - CHECK THAT WE TERMINATE    *\n*   WITH A SPACE OR COMMA, AND THAT PERIOD START IS LESS THAN       *\n*   PERIOD END.                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C' '            TERMINATING SPACE?\n         BE    HJ0060                YES, SKIP\n         CLI   0(R2),C','            NO, HOW ABOUT COMMA?\n         BNE   HJ8000                NO, ERROR\nHJ0060   DS    0H\n         L     R15,ODTE_PeriodStart  GET PERIOD START TIME\n         C     R15,ODTE_PeriodEnd    COMPARE TO PERIOD END\n         BH    HJ8000                START > END, ERROR\n         SLR   R15,R15               OK, CLEAR THE RETURN CODE\n         B     HJ9000                AND EXIT\nHJ8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE AN ERROR, SET THE RETURN CODE.                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                 SET THE RETURN CODE\n         B     HJ9000                AND EXIT\nHJ9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HJ_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HJ_Dynam       DSECT                 Dynamic area for HJ\n@HJ_Save        DS    18F              O/S Style save area\n@HJ_DBLWD       DS    D                Work area\n@HJ_Time        DS    XL6              Work area\n@HJ_DateConv_Area DS   CL(DConv_Area_Length)     Our area\n                DS    0D               Alignment\n@HJ_DynLen      EQU   *-@HJ_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHK0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'SEQUENCE=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, @_SYSUT1_Sequence flag updated.  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HK0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HK_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HK_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HK_Dynam,R13            Assign a base\n         L     R15,@HK_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"YES\" KEYWORD.                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'3'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HK8000                 NO, ERROR\n         CLC   0(3,R2),=C'YES'        YES, IS THIS IT?\n         BNE   HK8000                 NO, ERROR\n         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence YES, SET FLAG\n         LA    R2,3(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'3'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HK9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HK9000                 YES, SKIP\n         B     HK8000                 NO, ERROR\nHK8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HK9000                 AND EXIT\nHK9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HK_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HK_Dynam       DSECT                 Dynamic area for S\n@HK_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HK_DynLen      EQU   *-@HK_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHL0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'CHECKVBS=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, @_SYSUT1_NoVBSChk flag set       *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HL0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HL_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HL_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HL_Dynam,R13            Assign a base\n         L     R15,@HL_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HL8000                 NO, ERROR\n         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?\n         BNE   HL8000                 NO, ERROR\n         OI    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk YES, SET FLAG\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HL9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HL9000                 YES, SKIP\n         B     HL8000                 NO, ERROR\nHL8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HL9000                 AND EXIT\nHL9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HL_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HL_Dynam       DSECT                 Dynamic area for U\n@HL_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HL_DynLen      EQU   *-@HL_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHM0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'WEEKENDS=' Keyword Processor                                  *\n*             Valid values are:                                     *\n*                     \"IGNORE\" - Do not process Saturday or Sunday  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_Ignore_Weekend flag set     *\n*                      4 - Invalid Parameter                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HM0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HM_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HM_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HM_Dynam,R13            Assign a base\n         L     R15,@HM_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of PRINT= keyword                         *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=HL2'6'             ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HM8000                 NO, ERROR\n         CLC   0(6,R2),=C'IGNORE'     YES, IS THIS IT?\n         BNE   HM8000                 NO, ERROR\n         OI    ODTE_Ignore_Weekend-ODT_Entry(R10),L'ODTE_Ignore_Weekend\n         LA    R2,6(0,R2)             POINT PAST LITERAL\n         SH    R3,=HL2'6'             RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HM9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HM9000                 YES, SKIP\n         B     HM8000                 NO, ERROR\nHM8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HM9000                 AND EXIT\nHM9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HM_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HM_Dynam       DSECT                 Dynamic area for HM\n@HM_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HM_DynLen      EQU   *-@HM_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'I0000: OPEN SYSUT1'\n\n         PUSH  USING\n\nI0010    DS    0H\n\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : I0010                                                  *\n*                                                                     *\n*  Abstract  : OPEN SYSUT1, allocating it to the active SMF dataset   *\n*              if required. Print some interesting(?) info about it.  *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSUT1 not useable.                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Removed EODAD stuff.                *\n*                                 Used W0010 to get A(JFCB).          *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING I0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@I_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@I_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @I_Dynam,R13             Assign a base\n         L     R15,@I_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*     Get the storage for our DCB and DCBE                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,4                     Length field\n         LA    R1,I_SYSUT1_BSAM_DCB_Length(0,R1) Plus length of DCB\n         LA    R0,I_SYSUT1_DCBE_Length(0,R1) Plus length of DCBE\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R1,@_SYSUT1_BtL_Ptr      Save A(Storage)\n         ST    R0,0(0,R1)               Save length\n         LA    R2,4(0,R1)               Point to DCB area\n         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it\n         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And go get the JFCB - if this fails, we assume that SYSUT1     *\n*   has not been allocated                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)\n         LA    R1,4(0,R1)               Point to DCB area\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  How did it go?\n         BZ    I0060                    OK, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    No SYSUT1 DDName found, so dynamically allocate it to the      *\n*   active SMF file, if there is one.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,CVTPTR(0,0)          Get A(CVT)\n         L     R15,CVTSMCA-CVT(R15)     And then the SMCA\n         TM    SMCAMISC-SMCABASE(R15),SMCAUSER  SMF recording?\n         BZ    I8000                    No, no active SMF file\n         L     R14,SMCAFRDS-SMCABASE(R15) Yes, get A(1st RDS)\n         L     R15,SMCALRDS-SMCABASE(R15) and A(last RDS)\nI0040    DS    0H\n         TM    12(R14),X'04'            Active SMF dataset?\n         BZ    I0050                    Yes, skip\n         L     R14,4(0,R14)             No, get A(Next)\n         CR    R14,R15                  End of chain?\n         BNE   I0040                    No, keep checking\n         B     I8000                    Yes, no active SMF file\nI0050    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have found the active SMF file (R14 points to the RDS),     *\n*   so build the SVC99 control blocks ...                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@I_SVC99_RB          A(S99 RB)\n         ST    R15,@I_SVC99_RB_Ptr+S99RBPTR-S99RBP SAVE IT\n         OI    @I_SVC99_RB_Ptr+S99RBPTR-S99RBP,S99RBPND\n\n         MVI   @I_SVC99_RB+S99RBLN-S99RB,S99RBEND-S99RB LENGTH\n         MVI   @I_SVC99_RB+S99VERB-S99RB,S99VRBAL ALLOCATE\n         SLR   R15,R15                CLEAR WORK REGISTER\n         STH   R15,@I_SVC99_RB+S99FLAG1-S99RB CLEAR FLAG1\n         STH   R15,@I_SVC99_RB+S99ERROR-S99RB CLEAR ERROR CODE\n         STH   R15,@I_SVC99_RB+S99INFO-S99RB CLEAR INFO CODE\n         LA    R15,@I_SVC99_TU_List   A(TEXT UNIT POINTERS)\n         ST    R15,@I_SVC99_RB+S99TXTPP-S99RB SAVE IT\n         SLR   R15,R15                CLEAR WORK REGISTER\n         ST    R15,@I_SVC99_RB+S99TXTPP+4-S99RB CLEAR RESERVED FIELD\n         ST    R15,@I_SVC99_RB+S99FLAG2-S99RB CLEAR FLAG 2\n\n         LA    R15,@I_SVC99_DDName_TU A(DDNAME)\n         ST    R15,@I_SVC99_TU_List   SAVE IT\n         LA    R15,@I_SVC99_DSName_TU A(DSNAME)\n         ST    R15,@I_SVC99_TU_List+4 SAVE IT\n         LA    R15,@I_SVC99_Status_TU A(STATUS)\n         ST    R15,@I_SVC99_TU_List+8 SAVE IT\n         LA    R15,@I_SVC99_NDisp_TU  A(NDISP)\n         ST    R15,@I_SVC99_TU_List+12 SAVE IT\n         LA    R15,@I_SVC99_CDisp_TU  A(CDISP)\n         ST    R15,@I_SVC99_TU_List+16 SAVE IT\n         LA    R15,@I_SVC99_Free_TU   A(FREE)\n         ST    R15,@I_SVC99_TU_List+20 SAVE IT\n         OI    @I_SVC99_TU_List+20,S99TUPLN END OF LIST\n\n         LA    R15,DALDDNAM           DDNAME TEXT KEY\n         STH   R15,@I_SVC99_DDName_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_DDName_TU+S99TUNUM-S99TUNIT SAVE IT\n         LA    R15,8                  LEN OF PARMS\n         STH   R15,@I_SVC99_DDName_TU+S99TULNG-S99TUNIT SAVE IT\n         MVC   @I_SVC99_DDName_TU+S99TUPAR-S99TUNIT(8),=CL8'SYSUT1'\n\n         LA    R15,DALDSNAM           DSNAME TEXT KEY\n         STH   R15,@I_SVC99_DSName_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_DSName_TU+S99TUNUM-S99TUNIT SAVE IT\n         LA    R15,44                 LEN OF PARMS\n         STH   R15,@I_SVC99_DSName_TU+S99TULNG-S99TUNIT SAVE IT\n         MVC   @I_SVC99_DSName_TU+S99TUPAR-S99TUNIT(44),16(R14) SMF DSN\n\n         LA    R15,DALSTATS           STATUS TEXT KEY\n         STH   R15,@I_SVC99_Status_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_Status_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_Status_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_Status_TU+S99TUPAR-S99TUNIT,X'08' SHR\n\n         LA    R15,DALNDISP           NORMAL DISP\n         STH   R15,@I_SVC99_NDisp_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_NDisp_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_NDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_NDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP\n\n         LA    R15,DALCDISP           CONDITIONAL DISP\n         STH   R15,@I_SVC99_CDisp_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_CDisp_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_CDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_CDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP\n\n         LA    R15,DALCLOSE           FREE=CLOSE\n         STH   R15,@I_SVC99_Free_TU+S99TUKEY-S99TUNIT SAVE IT\n         SLR   R15,R15                NBR PARMS\n         STH   R15,@I_SVC99_Free_TU+S99TUNUM-S99TUNIT SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and invoke Dynamic Allocation                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@I_SVC99_RB_Ptr     A(SVC99 RB Pointer)\n         SVC   99                     Go do it\n         LTR   R15,R15                Did it work?\n         BNZ   I8010                  No, error\n\n         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Yes, in sequence\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And go get the JFCB (again)                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)\n         LA    R1,4(0,R1)               Point to DCB area\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  How did it go?\n         BNZ   I8020                    Not good, exit with error\n\nI0060    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Save some info from the JFCB                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R1,@I_JFCB_Ptr           Save A(JFCB)\n\n         MVC   @I_JFCBUFNO,JFCBUFNO-INFMJFCB(R1) Save DCB=BUFNO=\n         MVC   @I_JFCNCP,JFCNCP-INFMJFCB(R1) Save DCB=NCP=\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some info about the device on which SYSUT1 lives           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         XC    @I_DVACLASS,@I_DVACLASS            Device Class\n         XC    @I_DVATRK,@I_DVATRK                Trks/Cyl\n         XC    @I_DVATRKLN,@I_DVATRKLN            Bytes/Trk\n\n         LA    R1,I_SYSUT1_BSAM_DCB+DCBDDNAM-IHADCB A(DDName)\n         LA    R0,@I_DEVAREA          A(Return area)\n         DEVTYPE (1),(0),DEVTAB       Get SYSUT1 device info\n         LTR   R15,R15                Did it work?\n         BNZ   I0070                  No, skip\n         MVC   @I_DVACLASS,@I_DEVAREA+DVACLASS-DVAREA Device Class\n         MVC   @I_DVATRK,@I_DEVAREA+DVATRK-DVAREA Trks/Cyl\n         MVC   @I_DVATRKLN,@I_DEVAREA+DVATRKLN-DVAREA Bytes/Trk\nI0070    DS    0H\n\n         L     R15,@I_JFCB_Ptr        A(JFCB)\n         TM    JFCDSRG2-INFMJFCB(R15),JFCORGAM VSAM?\n         BNZ   I0170                  Yes, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is non-VSAM; OPEN the BSAM DCB ...                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)\n         LA    R2,4(0,R2)             A(DCB)\n\n         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN BSAM DCB\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?\n         BNO   I8020                  No, error\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... save some info from the DCB ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @I_RECFM,DCBRECFM-IHADCB(R2) Save RECFM\n         MVC   @I_NCP,DCBNCP-IHADCB(R2)      Save NCP (Calc by OPEN)\n         LH    R15,DCBLRECL-IHADCB(R2)       Get LRECL\n         ST    R15,@_SYSUT1_Rec_Length       and save it\n         MVC   @I_BLKSI,DCBBLKSI-IHADCB(R2)   and BLKSIZE\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and close it.                                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @I_CLOSE,I_CLOSE              Move CLOSE parms\n         CLOSE ((2)),MODE=31,MF=(E,@I_CLOSE)  and close BSAM DCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Calculate the value of DCBNCP or DCBBUFNO that we will         *\n*   use so we can read a cylinder at a time (assuming SYSUT1 lives  *\n*   on DASD - if it doesn't, we use an arbitrary value of 30). OPEN *\n*   has calculated the number of blocks on a track (DCBNCP).        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,30                  Default number of buffers\n         STH   R0,@I_Buffer_Count     Save it\n\n         TM    @I_DVACLASS,UCB3DACC   DASD device?\n         BZ    I0100                  No, use default\n         SLR   R0,R0                  Yes, get\n         IC    R0,@I_NCP               blocks/track\n         MH    R0,@I_DVATRK           Times Trks/Cyl\n         LTR   R0,R0                  Is it 0?\n         BZ    I0080                  Yes, use blks/trk\n         C     R0,=FL4'255'           No, too big?\n         BNH   I0090                  No, use it\nI0080    DS    0H\n         SLR   R0,R0                  Yes, use\n         IC    R0,@I_NCP               blocks/trk\nI0090    DS    0H\n         STH   R0,@I_Buffer_Count     Save it\nI0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We know we are non-VSAM. If the RECFM is not variable spanned, *\n*   or we have been told not to check for spanning errors, we will  *\n*   use QSAM as our access method. Otherwise ...                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Should we check?\n         BO    I0140                  No, skip\n         TM    @I_RECFM,DCBRECV+DCBRECSB     VS or VBS?\n         BNO   I0140                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... we will use BSAM.                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Set BSAM Input flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Calculate the number of buffers we will need. If this has not  *\n*   been specified by the user (DCB=NCP= or DCB=BUFNO=), we use     *\n*   the value we calculated earlier that will allow us to read a    *\n*   cylinder at a time.                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@I_JFCNCP           Get user specified DCB=NCP=\n         LTR   R0,R0                  Anything?\n         BNZ   I0110                  Yes, skip\n         IC    R0,@I_JFCBUFNO         No, get DCB=BUFNO=\n         LTR   R0,R0                  Anything?\n         BZ    I0120                  No, use default\nI0110    DS    0H\n         STH   R0,@I_Buffer_Count     Yes, update our variable\nI0120    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some storage above-the-line for our buffers and stuff:     *\n*     +0     A(Next Buffer area)                                    *\n*     +4     A(DECB)                                                *\n*     +8     Offset within buffer of next segment                   *\n*     +C     Buffer (length of DCBBLKSI)                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,BuffArea_Hdr_Length Header bytes\n         AH    R1,@I_BLKSI            Plus buffer area\n         LA    R1,7(0,R1)             Make it\n         SRL   R1,3                    its a\n         SLL   R1,3                    doubleword\n         ST    R1,@I_Buffer_Length    Save Buffer length\n         LA    R2,8(0,R1)             Minimum storage we need\n         LH    R0,@I_Buffer_Count     Number of buffers we need\n         MR    R0,R0                  Total length\n         LA    R0,8(0,R1)             plus header length\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=((0),(2)),         this long                     +\n               LOC=ANY                   anywhere\n         ST    R1,@_SYSUT1_AtL_Ptr    Save the address\n         ST    R0,0(0,R1)              and the length\n         LR    R15,R0                 Get the length\n         SH    R15,=H'8'               less the header length\n         SLR   R14,R14                prepare for divide\n         D     R14,@I_Buffer_Length   Calculate number of buffers\n         STH   R15,@I_Buffer_Count    Save number of buffers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we do not have enough room below-the-line for the DCB and   *\n*   associated DECBs, free it and go get enough                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,I_READ_Length       Length of 1 DECB\n         MH    R1,@I_Buffer_Count     Length of all DECBs\n         LA    R1,4+I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R1)\n         L     R15,@_SYSUT1_BtL_Ptr   A(current storage)\n         C     R1,0(0,R15)            Long enough?\n         BNH   I0130                  Yes, skip\n         ST    R1,@I_DBLWD            No, save length required\n         L     R1,@_SYSUT1_BtL_Ptr    A(Our storage)\n         L     R0,0(0,R1)             Get its length\n         STORAGE RELEASE,             Free the storage                 +\n               LENGTH=(0),             this long                       +\n               ADDR=(1)                starting here\n         L     R0,@I_DBLWD            Get the amount we need\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R0,0(0,R1)             Save the length\n         ST    R1,@_SYSUT1_BtL_Ptr    Save A(Storage)\nI0130    DS    0H\n         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)\n         LA    R2,4(0,R2)             A(DCB area)\n         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it\n\n         LH    R15,@I_Buffer_Count    Nbr buffers\n         STC   R15,DCBNCP-IHADCB(R2)  Update NCP\n\n         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address\n\n         B     I0190                  and skip\n\nI0140    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is non-VSAM and not RECFM=VS or VBS, so we will use     *\n*   QSAM.                                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Set QSAM Input flag\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@I_JFCBUFNO         Get user-specified DCB=BUFNO=\n         LTR   R0,R0                  Anything?\n         BNZ   I0150                  Yes, skip\n         IC    R0,@I_JFCNCP           No, get DCB=NCP=\n         LTR   R0,R0                  Anything?\n         BZ    I0160                  No, skip\nI0150    DS    0H\n         STH   R0,@I_Buffer_Count     Yes, update our field\nI0160    DS    0H\n         MVC   0(I_SYSUT1_QSAM_DCB_Length,R2),I_SYSUT1_QSAM_DCB\n         LH    R15,@I_Buffer_Count    Blocks per cyl\n         STC   R15,DCBBUFNO-IHADCB(R2) Save it\n\n         LA    R14,I_SYSUT1_QSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address\n         B     I0190                  and skip\n\nI0170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is VSAM, so set our flag ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM  Set VSAM Input flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... save some VSAM-related info from the JFCB ...              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@I_JFCB_Ptr          A(JFCB)\n\n         SLR   R0,R0                    Clear work register\n         L     R0,JFCBABFS+1-INFMJFCB(R15) Get BUFSP\n         SRL   R0,8                     Align it properly\n         ST    R0,@I_JFCBABFS           Save it\n         SLR   R0,R0                    Clear work register\n         LH    R0,JFCBADBF-INFMJFCB(R15) Get BUFND\n         STH   R0,@I_JFCBADBF           Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... free the below-the-line storage ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Below-the-line storage)\n         L     R0,0(0,R1)               Get its length\n         STORAGE RELEASE,               Free the storage               +\n               LENGTH=(0),               this long                     +\n               ADDR=(1)                  starting here\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSUT1_BtL_Ptr     No more storage below\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and get some above-the-line for the ACB, EXLST and RPL     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,4+I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length+SYSUT1_RP+\n               L_Length\n         STORAGE OBTAIN,                Get some storage               +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   from above-the-line\n         ST    R1,@_SYSUT1_AtL_Ptr      Save the address\n         ST    R0,0(0,R1)               Save the length\n         LA    R2,4(0,R1)               Point to ACB area\n         MVC   0(I_SYSUT1_ACB_Length,R2),I_SYSUT1_ACB  Move ACB\n         ST    R2,@_SYSUT1_ACB_Ptr      Save A(ACB)\n\n         LA    R3,I_SYSUT1_ACB_Length(0,R2) A(Dynamic EXLST)\n         MVC   0(I_SYSUT1_EXLST_Length,R3),I_SYSUT1_EXLST Move it\n         MODCB ACB=(2),               Update SYSUT1 ACB                +\n               EXLST=(3),              with EXLST                      +\n               MF=(G,@I_MODCB1,I_MODCB1_Length)\n\n         ICM   R0,B'1111',@I_JFCBABFS Get user-specified BUFSP=\n         BNZ   I0180                  OK, skip\n         LH    R0,@I_JFCBADBF         None, get user specified BUFND=\n         LTR   R0,R0                  Any?\n         BNZ   I0180                  Yes, skip\n         SLR   R15,R15                No, clear work register\n         ST    R15,@I_BUFSP           Clear Buffer space\n         LH    R2,@I_DVATRK           Get Trks/Cyl\n         LH    R3,@I_DVATRKLN         Get Bytes/Trk\n         SLL   R3,16                  Make sure\n         SRL   R3,16                   its positive\n         MR    R2,R2                  Get Bytes/Cyl\n         LTR   R3,R3                  Anything?\n         BZ    I0180                  No, don't modify ACB\n         A     R3,=FL4'4096'          Yes, bump by a page\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         MODCB ACB=(2),               Update SYSUT1 ACB                +\n               BUFSP=(3),               for bytes/cyl                  +\n               MF=(G,@I_MODCB2,I_MODCB2_Length)\n\n         ST    R3,@I_BUFSP            and save Buffer Space\nI0180    DS    0H\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         LA    R3,@_SYSUT1_Rec_Length A(RECEIVING AREA)\n         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             *\n               FIELDS=LRECL,            WE WANT THE LRECL              *\n               AREA=(3),                MOVED TO THIS AREA             *\n               LENGTH=L'@_SYSUT1_Rec_Length, for this long             *\n               MF=(G,@I_SHOWCB,I_SHOWCB_Length)\n         LTR   R15,R15                Did it work?\n         BZ    I0190                  Yes, skip\n         LH    R15,=H'32767'          No, assume the biggest\n         ST    R15,@_SYSUT1_Rec_Length and save it\nI0190    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area in which the input record will be assembled        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_Rec_Length Get size of record\n         LA    R1,7(0,R1)            Make it\n         SRL   R1,3                   doubleword multiple\n         SLDL  R0,35                  in R0\n         STORAGE OBTAIN,             Get some storage                  +\n               LENGTH=(0),            this long                        +\n               LOC=BELOW              below the line\n\n         ST    R1,@_SYSUT1_Rec_Ptr   Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And open SYSUT1 (@_SYSUT1_DCB_Ptr contains the address of the  *\n*   DCB or ACB)                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_DCB_Ptr    Point to the DCB/ACB\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN DCB already open?\n         BO    I0210                  Yes, skip the OPEN\n         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN DCB/ACB\n         LTR   R15,R15                DID IT OPEN?\n         BNZ   I8020                  NO, ERROR\nI0210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is open, so go list some interesting(?) info            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_DCB_Ptr    A(DCB or ACB)\n         L     R15,=A(J0010)          A(DCB info routine)\n         BASR  R14,R15                Go do it\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  AND ANOTHER\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 has been opened successfully - if we are using BSAM     *\n*   to read it ...                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?\n         BNO   I0410                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... initialize the DECBs and buffer areas, and prime the areas *\n*   with initial READs                                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R4,@_SYSUT1_AtL_Ptr    A(Above-the-line storage)\n         LA    R4,8(0,R4)             A(1st buffer area)\n         L     R2,@_SYSUT1_DCB_Ptr    A(DCB)\n         LA    R5,I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R2)\n         LH    R6,@I_Buffer_Count     Nbr buffers\nI0400    DS    0H\n         ST    R5,BuffArea_DECB_Ptr-BuffArea(0,R4) Save A(DECB)\n         MVC   0(I_READ_Length,R5),I_READ  Initialize DECB\n         LA    R3,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)\n         READ  (5),SF,(2),(3),'S',MF=E    Issue the read\n         SLR   R15,R15                Clear work register\n         ST    R15,BuffArea_Offset-BuffArea(0,R4) Clear Offset\n         L     R15,@I_Buffer_Length   Get buffer size\n         AR    R15,R4                 Point to next area\n         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain BuffAreas\n         LR    R4,R15                 Point to next BuffArea\n         LA    R5,I_READ_Length(0,R5) A(next DECB)\n         BCT   R6,I0400               and do it too\n\n         S     R4,@I_Buffer_Length    Back up to last buffer area\n         L     R15,@_SYSUT1_AtL_Ptr   Point to\n         LA    R15,8(0,R15)             1st buffer area\n         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain last to 1st\n         ST    R15,@_SYSUT1_BuffArea_Ptr And init our pointer\n\nI0410    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the input is VSAM, generate an RPL in the area after the    *\n*   ACB                                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is SYSUT1 VSAM?\n         BNO   I0420                    No, skip\n\n         L     R2,@_SYSUT1_ACB_Ptr      A(ACB)\n         LA    R3,I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length(0,R2)\n         L     R4,@_SYSUT1_Rec_Ptr      A(Record area)\n         L     R5,@_SYSUT1_Rec_Length   Length of a record\n         GENCB BLK=RPL,               GENERATE RPL                     *\n               AM=VSAM,                 FOR VSAM                       *\n               ACB=(2),                 SYSUT1                         *\n               AREA=(4),                A(INPUT RECORD ADDRESS)        *\n               AREALEN=(5),             Len of the address             *\n               OPTCD=(ADR,SEQ,MVE,SYN), MOVE MODE                      *\n               WAREA=(3),               BUILD THE RPL HERE             *\n               LENGTH=SYSUT1_RPL_Length,  its this long                +\n               MF=(G,@I_GENCB,I_GENCB_Length)\n\n         ST    R3,@_SYSUT1_RPL_Ptr      Save A(RPL)\n\nI0420    DS    0H\n         SLR   R15,R15                Clear return code\n         B     I9000                  and exit\n\nI8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    No active SMF file                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   1(16,R1),=C'No active SMF File found'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                GO PRINT IT\n         LA    R15,4                  FLAG AN ERROR\n         B     I9000                  AND EXIT\n\nI8010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Dynalloc (SVC99) error                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   1(16,R1),=C'Error allocating'\n         MVC   18(10,R1),@I_SVC99_DSName_TU+S99TUPAR-S99TUNIT MOVE DSN\n         MVC   28(30,R1),=C', RC=XX, Error=XXXX, Info=XXXX'\n         SRL   R15,4                  MAKE ROOM FOR \"SIGN\"\n         STH   R15,@I_DBLWD           SAVE IT\n         OI    @I_DBLWD+1,X'0F'       INSERT A  SIGN\n         UNPK  @I_DBLWD+2(3),@I_DBLWD(2) UNPACK IT\n         TR    @I_DBLWD+3(2),I_HexNum MAKE IT READABLE\n         MVC   33(2,R1),@I_DBLWD+3    MOVE TO MESSAGE\n         LH    R15,@I_SVC99_RB+S99ERROR-S99RB GET ERROR CODE\n         SRL   R15,4                  MAKE ROOM FOR SIGN\n         ST    R15,@I_DBLWD+4         SAVE IT\n         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN\n         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT\n         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE\n         MVC   43(4,R1),@I_DBLWD+1   MOVE TO MESSAGE\n         LH    R15,@I_SVC99_RB+S99INFO-S99RB GET INFO CODE\n         SRL   R15,4                  MAKE ROOM FOR SIGN\n         ST    R15,@I_DBLWD+4         SAVE IT\n         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN\n         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT\n         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE\n         MVC   54(4,R1),@I_DBLWD+1   MOVE TO MESSAGE\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                GO PRINT IT\n         LA    R15,4                  FLAG AN ERROR\n         B     I9000                  AND EXIT\nI8020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Error opening SYSUT1                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  NO, GET A(SYSPRINT RECORD)\n         MVC   22(40,R1),=C'SYSUT1 could not be opened - terminating'\n         LA    R15,12                 SET RETURN CODE\n         B     I9000                  AND EXIT\n\nI9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@I_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nI_HexNum EQU   *-239\n         DC    C' 0123456789ABCDEF'\n\n         LTORG\n\n\n         PUSH PRINT\n         PRINT NOGEN\nI_SYSUT1_QSAM_DCB DCB DDNAME=SYSUT1,MACRF=GM,DSORG=PS,OPTCD=C,         +\n               DCBE=1\nI_SYSUT1_QSAM_DCB_Length EQU *-I_SYSUT1_QSAM_DCB LENGTH OF SYSUT1 DCB\n\nI_SYSUT1_BSAM_DCB DCB DDNAME=SYSUT1,MACRF=RC,DSORG=PS,                 +\n               DCBE=1\nI_SYSUT1_BSAM_DCB_Length EQU *-I_SYSUT1_BSAM_DCB LENGTH OF SYSUT1 DCB\n\nI_SYSUT1_DCBE DCBE RMODE31=BUFF,MULTSDN=1,EODAD=1\nI_SYSUT1_DCBE_Length EQU *-I_SYSUT1_DCBE Length of SYSUT1 DCBE\n\nI_SYSUT1_ACB ACB AM=VSAM,               FOR VSAM                       *\n               DDNAME=SYSUT1,           SYSUT1                         *\n               BUFND=3,                 DATA BUFFERS                   *\n               BUFSP=131072,            128K FOR BUFFERS               *\n               STRNO=1,                 NBR STRINGS                    *\n               EXLST=I_SYSUT1_EXLST,    EODAD                          *\n               MACRF=(ADR,NFX,DDN,NRM,NRS,SEQ,IN),                     *\n               RMODE31=ALL              Everything above-the-line\n             DS    0D\nI_SYSUT1_ACB_Length EQU   *-I_SYSUT1_ACB\n\n         PRINT GEN\nI_SYSUT1_EXLST EXLST AM=VSAM,           For VSAM                       +\n               EODAD=1                   End-of-Data\n             DS    0D\nI_SYSUT1_EXLST_Length EQU *-I_SYSUT1_EXLST\n         PRINT NOGEN\n\nI_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nI_OPEN_Length EQU  *-I_OPEN\n\n         READ  I_READ,SF,0,0,'S',MF=L\nI_READ_Length EQU  *-I_READ\n\nI_CLOSE  CLOSE (0),MODE=31,MF=L\nI_CLOSE_Length EQU *-I_CLOSE\n\n         POP    PRINT\n@I_Dynam        DSECT                 Dynamic area for I\n@I_Save         DS    18F              O/S Style save area\n@I_DBLWD        DS    D                Workarea\n\n@I_JFCB_Ptr     DS    AL4              A(JFCB)\n@I_DVACLASS     DS    X                Device class from DEVTYPE\n@I_DVATRK       DS    HL2              Trks/Cyl from DEVTYPE\n@I_DVATRKLN     DS    HL2              Bytes/Trk from DEVTYPE\n@I_RECFM        DS    X                DCB=RECFM\n\n@I_DCBChar      EQU   *                Non-VSAM DCB Characteristics\n@I_JFCBUFNO     DS    X                 DCB=BUFNO from JFCB\n@I_JFCNCP       DS    X                 DCB=NCP= from JFCB\n@I_BLKSI        DS    HL2               SYSUT1 BLKSIZE\n@I_NCP          DS    X                 DCB=NCP (calculated by OPEN)\n@I_Buffer_Count DS    HL2               Number of buffer areas\n@I_Buffer_Length DS   FL4               Buffer area length\n@I_ACBChar      ORG   @I_DCBChar       VSAM ACB Characteristics\n@I_JFCBABFS     DS    FL4               AMP=BUFSP= from JFCB\n@I_JFCBADBF     DS    HL2               AMP=BUFND= from JFCB\n@I_BUFSP        DS    FL4               VSAM BUFFSP\n                ORG\n\n@I_MACRO        DS    0F               Macro area\n                ORG   @I_MACRO\n@I_OPEN         DS    CL(I_OPEN_Length) OPEN macro\n                ORG   @I_MACRO\n@I_CLOSE        DS    CL(I_CLOSE_Length) CLOSE macro\n                ORG   @I_MACRO\n@I_SHOWCB       DS    CL(I_SHOWCB_Length) SHOWCB Macro\n                ORG   @I_MACRO\n@I_MODCB1       DS    CL(I_MODCB1_Length) MODCB Macro\n                ORG   @I_MACRO\n@I_MODCB2       DS    CL(I_MODCB2_Length) MODCB Macro\n                ORG   @I_MACRO\n@I_GENCB        DS    CL(I_GENCB_Length) GENCB Macro\n                ORG   @I_MACRO\n@I_DEVAREA      DS    CL(L'DVAPREFX+L'DVATAB) DEVTAB return info\n                ORG   @I_MACRO\n*-------------------------------------------------------------------*\n*                                                                   *\n*    DYNAMIC ALLOCATION (SVC 99) CONTROL BLOCKS                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n@I_SVC99_RB_Ptr    DS  F\n@I_SVC99_RB        DS  CL(S99RBEND-S99RB)\n@I_SVC99_TU_List   DS  6A\n@I_SVC99_DDName_TU DS  CL((S99TUPAR-S99TUNIT)+8)      DDNAME\n@I_SVC99_DSName_TU DS  CL((S99TUPAR-S99TUNIT)+44)     DSNAME\n@I_SVC99_Status_TU DS  CL((S99TUPAR-S99TUNIT)+1)      STATUS\n@I_SVC99_NDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      NORMAL DISP\n@I_SVC99_CDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      COND DISP\n@I_SVC99_Free_TU   DS  CL(S99TUENT-S99TUNIT)          FREE=CLOSE\n                   ORG ,\n\n                DS    0D               Alignment\n@I_DynLen       EQU   *-@I_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'J0000: Print info about DCB'\n\n         PUSH  USING\n\nJ0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : J0010                                                  *\n*                                                                     *\n*  Abstract  : Print info about a DCB or ACB.                         *\n*                                                                     *\n*  Inputs    : R1 ----> A(Open DCB or ACB)                            *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSUT1 not useable.                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Invoked W0010 to get JFCB and TIOT  *\n*                                 addresses.                          *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING J0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@J_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@J_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @J_Dynam,R13             Assign a base\n         L     R15,@J_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         ST    R1,@J_DCB_Ptr            Save A(DCB)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get our JFCB ...                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n\n         ST    R1,@J_JFCB_Ptr           Save A(JFCB)\n         ST    R0,@J_TIOT_Entry_Ptr     Save A(TIOT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Put out the DSN and volsers for this DDName                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr    Get A(SYSPRINT Record)\n         L     R15,@J_TIOT_Entry_Ptr    Get A(TIOT Entry)\n         MVC   1(L'TIOEDDNM,R1),TIOEDDNM-TIOENTRY(R15) Move DDName\n         MVC   2+L'TIOEDDNM(5,R1),=C'DSN: ' Move heading\n         L     R15,@J_JFCB_Ptr          Get A(JFCB)\n         MVC   2+L'TIOEDDNM+5(L'JFCBDSNM,R1),JFCBDSNM-INFMJFCB(R15)\n         LA    R1,2+L'TIOEDDNM+5+L'JFCBDSNM-1(,R1)  A(End of DSN)\nJ0020    DS    0H\n         CLI   0(R1),C' '               Is this the end?\n         BNE   J0030                    Yes, skip\n         BCT   R1,J0020                 No, back up and try again\nJ0030    DS    0H\n         MVC   1(10,R1),=C', Volser: '  Move VOLSER heading\n         LA    R1,11(0,R1)              Point past it\n         L     R15,@J_JFCB_Ptr          Get A(JFCB Pointer)\n         TM    JFCFLGS1-INFMJFCB(R15),JFCVRDS VIO?\n         BNO   J0030C                   No, skip\n         MVC   0(7,R1),=C'**VIO**'      Yes, dummy volser\n         B     J0050                    and skip\nJ0030C   DS    0H\n\n         SLR   R0,R0                    Clear work register\n         IC    R0,JFCBNVOL-INFMJFCB(R15) Get nbr volsers\n         LA    R15,JFCBVOLS-INFMJFCB(R15)  and point to first\n         CH    R0,=H'5'                 More than 5?\n         BNH   J0040                    No, skip\n         LA    R0,5                     Yes, only the 1st 5\nJ0040    DS    0H\n         MVC   0(6,R1),0(R15)           Move VOLSER\n         SH    R0,=H'1'                 Reduce volser count\n         BNP   J0050                    thats all, skip\n         MVI   6(R1),C','               More, add a comma\n         LA    R1,7(0,R1)               Point to next output area\n         LA    R15,6(0,R15)             A(Next input volser)\n         B     J0040                    and do it too\nJ0050    DS    0H\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Put out the DCB or ACB information                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@J_DCB_Ptr           A(DCB)\n         TM    DCBDSRG2-IHADCB(R15),DCBACBM Is this VSAM?\n         BO    J0140                    Yes, format VSAM stuff\n         L     R1,@_SYSPRINT_Rec_Ptr    No, get A(SYSPRINT Record)\n         MVC   10(11,R1),=C'DCB=(RECFM=' Move heading\n         LA    R1,21(0,R1)              Point to next byte\n         TM    DCBRECFM-IHADCB(R15),DCBRECF+DCBRECV  RECFM=U?\n         BNO   J0060                    No, skip\n         MVI   0(R1),C'U'               Yes, say so\n         LA    R1,1(0,R1)               Bump pointer\n         B     J0110                    and skip\nJ0060    DS    0H\n         TM    DCBRECFM-IHADCB(R15),DCBRECF  RECFM=F?\n         BZ    J0070                    No, skip\n         MVI   0(R1),C'F'               Yes, say so\n         B     J0080                    and skip\nJ0070    DS    0H\n         MVI   0(R1),C'V'               RECFM=V\nJ0080    DS    0H\n         LA    R1,1(0,R1)               Bump pointer\n         TM    DCBRECFM-IHADCB(R15),DCBRECBR  Blocked?\n         BZ    J0090                    No, skip\n         MVI   0(R1),C'B'               Yes, say so\n         LA    R1,1(0,R1)               Bump pointer\nJ0090    DS    0H\n         TM    DCBRECFM-IHADCB(R15),DCBRECSB Spanned or Standard?\n         BZ    J0100                    No, skip\n         MVI   0(R1),C'S'               Yes, say so\n         LA    R1,1(0,R1)               and bump pointer\nJ0100    DS    0H\n\n         MVC   0(7,R1),=C',LRECL='      Move literal\n         LA    R1,7(0,R1)               Point to next byte\n         LH    R0,DCBLRECL-IHADCB(R15)  Get LRECL\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(5),=X'2020202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+4             A(Significant digit)\n         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+5             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\nJ0110    DS    0H\n         MVC   0(9,R1),=C',BLKSIZE='    Move literal\n         LA    R1,9(0,R1)               Point to next byte\n         LH    R0,DCBBLKSI-IHADCB(R15)  Get BLKSIZE\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(5),=X'2020202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+4             A(Significant digit)\n         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+5             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\n\n         TM    DCBCIND2-IHADCB(R15),DCBCNQSM  QSAM?\n         BZ    J0120                    No, skip\n\n         TM    DCBCIND1-IHADCB(R15),DCBCBNDF  Yes, BUFNO default?\n         BO    J0130                    Yes, skip\n         MVC   0(7,R1),=C',BUFNO='      No, move literal\n         LA    R1,7(0,R1)               Point to next byte\n         SLR   R0,R0                    Clear work register\n         IC    R0,DCBBUFNO-IHADCB(R15)  Get BUFNO\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(3),=X'202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+2             A(Significant digit)\n         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+3             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\n         B     J0130                    and skip\n\nJ0120    DS    0H\n         MVC   0(5,R1),=C',NCP='        No, move literal\n         LA    R1,5(0,R1)               Point to next byte\n         SLR   R0,R0                    Clear work register\n         IC    R0,DCBNCP-IHADCB(R15)    Get NCP\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(3),=X'202120'    Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+2             A(Significant digit)\n         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+3             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\nJ0130    DS    0H\n\n         MVI   0(R1),C')'               Close off DCB info\n\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\n         B     J0170                    and skip\n\nJ0140    DS    0H\n\n         SLR   R0,R0                  Clear work register\n         ST    R0,@J_BUFND            Clear data space\n         ST    R0,@J_BUFSP            and buffer space\n         LR    R2,R15                 A(ACB)\n         LA    R3,@J_BUFND            A(Receiving area)\n         SHOWCB ACB=(2),              Get data from this ACB           +\n               FIELDS=(BUFND,BUFSP),    this data                      +\n               AREA=(3),                moved to here                  +\n               LENGTH=8,                for this long                  +\n               MF=(G,@J_SHOWCB,J_SHOWCB_Length)\n\n         L     R0,@J_BUFND            Get Data space\n         A     R0,@J_BUFSP            and buffer space\n         LTR   R0,R0                  anything to say?\n         BZ    J0170                  No, skip\n\n         L     R1,@_SYSPRINT_Rec_Ptr    Yes, get A(SYSPRINT Record)\n         MVC   10(7,R1),=C'AMP=BUF'     Move literal\n         ICM   R0,B'1111',@J_BUFSP      Get buffer space\n         BZ    J0150                    None, skip\n         MVC   17(2,R1),=C'SP'          Yes, make it BUFSP\n         B     J0160\nJ0150    DS    0H\n         MVC   17(2,R1),=C'ND'          Make it BUFND\n         L     R0,@J_BUFND              and load up the register\nJ0160    DS    0H\n         MVI   19(R1),C'='              Move literal\n         LA    R1,20(0,R1)              Point to next char\n         CVD   R0,@J_DBLWD              Pack our value\n         MVC   @J_Temp(9),=X'202020202020202120'\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+8             A(Significant digit)\n         EDMK  @J_Temp(9),@J_DBLWD+3    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+9             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\nJ0170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is the input file (SYSUT1) ...                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@J_TIOT_Entry_Ptr    A(TIOT entry)\n         CLC   =CL8'SYSUT1',TIOEDDNM-TIOENTRY(R15)  Input file?\n         BNE   J9010                    No, all done\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... display some info about input processing                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is this VSAM?\n         BO    J0200                  Yes, skip VBS stuff\n         L     R15,@J_DCB_Ptr         A(DCB)\n         TM    DCBRECFM-IHADCB(R15),DCBRECV+DCBRECSB VS or VBS?\n         BNO   J0200                  No, skip\n         L     R2,@_SYSPRINT_Rec_Ptr  Yes, A(Print record)\n         MVC   10(31,R2),=C'Variable Spanned segments will '\n         LA    R2,41(0,R2)            Point to next byte\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Is this BSAM?\n         BNO   J0180                  No, skip\n         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Yes, checking VBS?\n         BNO   J0190                  Yes, skip\nJ0180    DS    0H\n         MVC   0(4,R2),=C'not '       No VBS checking\n         LA    R2,4(0,R2)             bump output pointer\nJ0190    DS    0H\n         MVC   0(27,R2),=C'be checked for consistency.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT THE LINE\nJ0200    DS    0H\n         L     R2,@_SYSPRINT_Rec_Ptr  A(Print record)\n         MVC   10(11,R2),=C'Input data '\n         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?\n         BNO   J0210                  No, skip\n         MVC   21(14,R2),=C'assumed to be '\n         LA    R2,35(0,R2)            bump output pointer\n         B     J0220                  and skip\nJ0210    DS    0H\n         MVC   21(16,R2),=C'not necessarily '\n         LA    R2,37(0,R2)            bump output pointer\nJ0220    DS    0H\n         MVC   0(12,R2),=C'in sequence.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT THE LINE\n\nJ9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@J_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Clear return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n\n@J_Dynam        DSECT                 Dynamic area for J\n@J_Save         DS    18F              O/S Style save area\n@J_DBLWD        DS    D                Work area\n@J_Temp         DS    CL10             Work area\n@J_DCB_Ptr      DS    AL4              A(DCB)\n@J_TIOT_Entry_Ptr DS  AL4              A(TIOT Entry for this DCB)\n@J_JFCB_Ptr     DS    AL4              A(JFCB)\n\n@J_Macro        DS    0F               Macro area\n@J_SHOWCB       DS    CL(J_SHOWCB_Length) SHOWCB Macro\n                DS    0F\n@J_BUFND        DS    FL4              BUFND from ACB\n@J_BUFSP        DS    FL4              BUFSP from ACB\n                ORG\n                DS    0D               Alignment\n@J_DynLen       EQU   *-@J_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'K0000 - Date/Time Conversion Routine'\nK0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : K0010                                                  *\n*                                                                     *\n*  Abstract  : Populate DateConv_Area Dates and Times                 *\n*                                                                     *\n*  Inputs    : R1 ----> DateConv Area                                 *\n*  Outputs   : R15 = 0, DateConv_Area contains converted              *\n*                       Date/Time values.                             *\n*              R15 = 4, DateConv_Area unchanged                       *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING K0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@K_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@K_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @K_Dynam,R13             Assign a base\n         L     R15,@K_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         ST    R1,@K_DateConv_Area_Ptr  Save A(Callers DateConv_Area)\n         MVC   @K_DateConv_Area,0(R1)   Copy callers DateConv_Area\n         LA    R9,@K_DateConv_Area      Point to our DateConv_Area\n         USING DateConv_Area,R9         Tell the assembler\n\n         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Normal Date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_Julian,L'DConv_Input_Julian Julian Date?\n         BZ    K0180                    No, check time\n\nK0020    DS    0H\n         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?\n         BO    K0110                    Yes, skip\n\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?\n         BNO   K0030                    No, skip\n         ZAP   @K_DBLWD,=P'1900000'     Yes, set\n         AP    @K_DBLWD,DConv_Date_SMFDate  up Y2K Date\n         L     R15,@K_DBLWD+4           Save it\n         XC    @K_DBLWD+4(2),@K_DBLWD+4 Clear out year\n         CVB   R0,@K_DBLWD              Binarize Day-of-year\n         STH   R0,DConv_Date_DDD        Save it\n         SRL   R15,12                   Get rid of ddd\n         ST    R15,@K_DBLWD+4           Save it\n         OI    @K_DBLWD+7,X'0F'         Set up sign\n         CVB   R0,@K_DBLWD              Binarize Year\n         STH   R0,DConv_Date_YYYY       and save it too\nK0030    DS    0H\n\n         LH    R15,DConv_Date_YYYY      No, get Year\n         LTR   R15,R15                  Is it 0\n         BNP   K8010                    Yes, error\n\n         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?\n         BZ    K0040                    No, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Standard Date (yyyymmdd): dd, mm must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         BAS   R14,K6000       Go validate dd, mm\n         LTR   R15,R15         OK?\n         BNZ   K8010           No, error\n         STH   R0,DConv_Date_DDD Yes, save day-of-year\n         B     K0100           and go calculate BDate\n\nK0040    DS    0H\n         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Std num date?\n         BZ    K0070                    No, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Normal Date (yyyymondd): dd, mon must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         OC    DConv_Date_Month,=CL(L'DConv_Date_Month)' ' Upper-case\n         LA    R15,K_MONTHS    A(Month-name table)\n         LA    R14,1           Set month number\nK0050    DS    0H\n         MVC   @K_DBLWD(3),2(R15) Move month name from table\n         OC    @K_DBLWD(3),=C'   ' Uppercase it\n         CLC   @K_DBLWD(3),DConv_Date_Month Is this us?\n         BE    K0060           Yes, skip\n         LA    R15,11(0,R15)   No, bump to next month\n         LA    R14,1           Bump month number\n         CH    R14,=H'12'      Too far?\n         BNH   K0050           No, try again\n         B     K8010           Unknown month, error\nK0060    DS    0H\n         STC   R14,DConv_Date_MM  Save month number\n         BAL   R14,K6000       Go validate dd, mm, and yy\n         LTR   R15,R15         OK?\n         BNZ   K8010           No, error\n         STH   R0,DConv_Date_DDD Yes, save day-of-year\n         B     K0100           and go calculate BDate\n\nK0070    DS    0H\n         TM    DConv_Input_Julian,L'DConv_Input_Julian  JDate?\n         BO    K0080                    Yes, do it\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate No, SMF\n         BZ    K0180                    No, skip\nK0080    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Julian Date (yyyyddd): yyyy, ddd must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R2,DConv_Date_DDD Get Day of year\n         LTR   R2,R2           Is it 0\n         BNP   K8010           Yes, error\n\n         LA    R2,365          Days in a normal year\n         BAS   R14,K7000       Go check leap year\n         LTR   R15,R15         Is it a leap year?\n         BZ    K0090           No, skip\n         LA    R2,1(0,R2)      Yes, bump max days\nK0090    DS    0H\n         CH    R2,DConv_Date_DDD Day-of-year too big?\n         BL    K8010           Yes, error\n\nK0100    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate Base Date using the Julian Date in DConv_Date_YYYY and  *\n*    DConv_Date_DDD                                                   *\n*   In REXX terms,                                                    *\n*      YYYY = YYYY - 1             /*  Based on Year 0001          */ *\n*      BDate = (YYYY * 365) +,     /*  Days per year        plus   */ *\n*              (YYYY % 4)   -,     /*  Leap days            minus  */ *\n*              (YYYY % 100) +,     /*  non-Leap Centuries   plus   */ *\n*              (YYYY % 400) +,     /*  Leap centuries       plus   */ *\n*              DDD          -,     /*  Days in year         minus  */ *\n*              1                   /*  1 to get complete days      */ *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R2,DConv_Date_YYYY Get year\n         SH    R2,=H'1'         relative to year 0001\n         LR    R15,R2          Year *\n         MH    R15,=H'365'            365\n         LR    R0,R15          Initialize accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'4'              4\n         AR    R0,R15          Bump accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'100'            100\n         SR    R0,R15          Reduce accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'400'            400\n         AR    R0,R15          Bump accumulator\n         AH    R0,DConv_Date_DDD  Add days in current year\n         SH    R0,=H'1'        Complete days\n         ST    R0,DConv_Date_Base  Initialize Base Date\n         B     K0110           And skip\nK0110    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate various bits from the base date:                        *\n*     DConv_Date_YYYY                                                 *\n*     DConv_Date_DDD                                                  *\n*     DConv_Date_MM                                                   *\n*     DConv_Date_DD                                                   *\n*                                                                     *\n*   First, calculate the Year, and Day-of-year ...                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         L     R15,DConv_Date_Base Get the base date\n         SLR   R14,R14         set up for divide\n         D     R14,=F'365'     Do it\n         STH   R15,DConv_Date_YYYY Save Year\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ... and adjust the Day-of-year for leap years                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R0,R14          Get day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'4'          leap-days\n         SR    R0,R15          Reduce day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'100'        centuries\n         AR    R0,R15          Bump day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'400'        leap centuries\n         SR    R0,R15          Reduce day-of-year\n         A     R0,=FL4'1'      Bump for incomplete day\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Day-of-year is almost certainly negative at this point, so we     *\n*   will adjust it (and year) until it is greater than 1.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nK0120    DS    0H\n         C     R0,=FL4'1'      Is Day-of-year OK?\n         BNL   K0140           Yes, skip\n         A     R0,=F'365'      No, bump a year's worth\n         BAS   R14,K7000       Check for leap year\n         LTR   R15,R15         Is this a leap year?\n         BZ    K0130           No, skip\n         A     R0,=FL4'1'      Yes, bump Day-of-year\nK0130    DS    0H\n         LH    R15,DConv_Date_YYYY Get Year\n         S     R15,=FL4'1'     Reduce it\n         STH   R15,DConv_Date_YYYY and save it\n         B     K0120           Keep checking\nK0140    DS    0H\n         STH   R0,DConv_Date_DDD Save adjusted Day-of-year\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Adjust Year, since it it relative to 0001                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         LH    R15,DConv_Date_YYYY Get Year\n         A     R15,=FL4'1'     Bump it\n         STH   R15,DConv_Date_YYYY and save it\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Create the SMFDate from YYYY and DDD                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R0,DConv_Date_YYYY  Get YYYY\n         CVD   R0,@K_DBLWD         Pack it\n         L     R0,@K_DBLWD+4       Get packed year\n         SRL   R0,4                Get rid of sign\n         STH   R0,DConv_Date_SMFDate Move YYYY\n         LH    R0,DConv_Date_DDD   Get DDD\n         CVD   R0,@K_DBLWD         Pack it\n         MVC   DConv_Date_SMFDate+2(2),@K_DBLWD+6 Move DDD\n         SP    DConv_Date_SMFDate,=P'1900000' Convert to SMF Date\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Copy the Days-per-month table, and adjust the number of days in   *\n*  February, if this a leap year.                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         MVC   @K_Months,K_Months Copy the table\n         BAS   R14,K7000       Check for leap year\n         LTR   R15,R15         Is this a leap year?\n         BZ    K0150           No, skip\n         LH    R15,@K_Months+11 Yes, get days in Feb\n         LA    R15,1(0,R15)    Bump it\n         STH   R15,@K_Months+11 Save it\nK0150    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate the month number, and the day-of-month                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R0,DConv_Date_DDD Get day-of-year\n         LA    R14,1           January\n         LA    R15,@K_Months   A(Days-per-month table)\nK0160    DS    0H\n         CH    R0,0(0,R15)     Is this our month\n         BNH   K0170           Yes, skip\n         SH    R0,0(0,R15)     No, reduce days\n         LA    R14,1(0,R14)    Bump month number\n         LA    R15,11(0,R15)   Bump month pointer\n         B     K0160           and keep going\nK0170    DS    0H\n         STC   R0,DConv_Date_DD Save Day-of-month\n         STC   R14,DConv_Date_MM and month number\n         MVC   DConv_Date_Month,2(R15)  Move month name\n\n         L     R1,DConv_Date_Base Get base date\n         SLR   R0,R0           Clear for divide\n         D     R0,=F'7'        Get weekday (0=Mon, 1=Tue ...)\n         STC   R0,DConv_Date_DOW Save it\n         LR    R15,R0          Put in R15\n         SLL   R15,3           Weekday num * 8\n         AR    R15,R0          Weekday num * 9\n         LA    R15,K_DAYS(R15) Point to weekday name\n         MVC   DConv_Date_Day,0(R15)  Move weekday name\nK0180    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Do Time conversions                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    DConv_Input_Time,L'DConv_Input_Time  To hh,mm,ss?\n         BNO   K0190           No, skip\n\n         L     R15,DConv_Time  Yes, get secs*100 since midnight\n         C     R15,=FL4'8640000' Is it too big?\n         BH    K8010           Yes, error\n         SLR   R14,R14         Set up for divide\n         D     R14,=FL4'360000' Get hours\n         STC   R15,DConv_Time_hh Save it\n         SRDL  R14,32          Set up for divide\n         D     R14,=FL4'6000'  Get minutes\n         STC   R15,DConv_Time_mm Save them\n         SRDL  R14,32          Set up for divide\n         D     R14,=FL4'100'   Get seconds\n         STC   R15,DConv_Time_ss Save them\n         STC   R14,DConv_Time_tt Save hundredths\n         B     K0200           and exit\n\nK0190    DS    0H\n         TM    DConv_Input_hhmmss,L'DConv_Input_hhmmss  To secs*100?\n         BNO   K0200           No, skip\n\n         SLR   R0,R0           Clear accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_hh Get hours\n         L     R14,=FL4'360000' multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_mm Get minutes\n         L     R14,=FL4'6000'  multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_ss Get seconds\n         L     R14,=FL4'100' multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_tt Get hundredths of seconds\n         AR    R0,R15          Add to accumulator\n         C     R0,=FL4'8640000' Is it too big?\n         BH    K8010           Yes, error\n         ST    R0,DConv_Time   Save it\n\nK0200    DS    0H\n\n         L     R15,@K_DateConv_Area_Ptr  A(Callers DateConv_Area)\n         MVC   0(DConv_Area_Length,R15),@K_DateConv_Area Copy ours\n         SLR   R15,R15         Clear return code\n         B     K9010           and exit\n\nK6000    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Validate DConv_Date_MM, DConv_Date_DD                             *\n*   If valid, day-of-year is returned in R0                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ST    R14,@K_K6Save   Save return address\n         ST    R1,@K_K6Save+4  and R1\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Date_MM  Get month\n         LTR   R15,R15         Is it 0?\n         BZ    K6040           Yes, invalid\n         CH    R15,=H'12'      No, is it too big?\n         BH    K6040           Yes, invalid\n         MVC   @K_Months,K_Months Move Days-per-month table\n         BAS   R14,K7000       Check leap year\n         LTR   R15,R15         Is it?\n         BZ    K6010           No, skip\n         LH    R15,@K_Months+11 Yes, get February days\n         AH    R15,=H'1'       Bump it\n         STH   R15,@K_Months+11 and save it\nK6010    DS    0H\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Date_MM Get month number\n         MH    R15,=HL2'11'    Calculate offset\n         LA    R15,@K_Months-11(R15) Point to days in our month\n         SLR   R0,R0           Clear work register\n         IC    R0,DConv_Date_DD Get day-of-month\n         LTR   R0,R0           Is it 0?\n         BZ    K6040           Yes, error\n         CH    R0,0(R15)       Are Days too big?\n         BH    K6040           Yes, error\n         LA    R14,@K_Months   A(Our Days-per-month table)\nK6020    DS    0H\n         CR    R14,R15         Are we done?\n         BNL   K6030           Yes, skip\n         AH    R0,0(R14)       No, bump total days\n         LA    R14,11(0,R14)   point to next month\n         B     K6020           and try again\nK6030    DS    0H\n         SLR   R15,R15         Clear return code\n         B     K6050           and exit\nK6040    DS    0H\n         LA    R15,4           Error in date\n         SLR   R0,R0           Clear day-of-year\n         B     K6050\nK6050    DS    0H\n         L     R14,@K_K6Save   Restore return address\n         L     R1,@K_K6Save+4  Restore R1\n         BSM   0,R14           and return\n\n\nK7000    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Purpose   : This routine will determine if the year passed as a    *\n*              parm is a leap year                                    *\n*                                                                     *\n*  Input     : DConv_Date_YYYY                                        *\n*                                                                     *\n*  Output    : R15 = 0: Non-Leap Year                                 *\n*                    4: Leap Year                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R0,R1,@K_K7Save    Save our registers\n         LH    R1,DConv_Date_YYYY Get the Year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it is not divisible by 4, it is not a leap year                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'4'      Divide by 4\n         LTR   R0,R0           Any remainder?\n         BNZ   K7020           Yes, not a leap year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it also not divisible by 100, it is a leap year                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R1,DConv_Date_YYYY Get year\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'100'    Divide by 100\n         LTR   R0,R0           Any remainder?\n         BNZ   K7030           Yes, a leap year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it also divisible by 400, it is a leap year                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R1,DConv_Date_YYYY Get year\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'400'    Divide by 400\n         LTR   R0,R0           Any remainder?\n         BNZ   K7020           Yes, not a leap year\n         B     K7030           Must be a leap year\nK7020    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Not a leap year, clear the return code                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         SLR   R15,R15         Clear return code\n         B     K7090           and exit\nK7030    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   A leap year, set the return code                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     K7090           and exit\nK7090    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Exit (R15 contains the return code)                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LM    R0,R1,@K_K7Save Restore our registers\n         BSM   0,R14           and return\nK8010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DConv fields contain invalid data, exit with error                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     K9010           and exit\n\nK9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@K_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nK_Months DC    HL2'31',C'January  '\n         DC    HL2'28',C'February '\n         DC    HL2'31',C'March    '\n         DC    HL2'30',C'April    '\n         DC    HL2'31',C'May      '\n         DC    HL2'30',C'June     '\n         DC    HL2'31',C'July     '\n         DC    HL2'31',C'August   '\n         DC    HL2'30',C'September'\n         DC    HL2'31',C'October  '\n         DC    HL2'30',C'November '\n         DC    HL2'31',C'December '\nK_Months_Length EQU  *-K_Months\n\nK_Days   DC    C'Monday   '\n         DC    C'Tuesday  '\n         DC    C'Wednesday'\n         DC    C'Thursday '\n         DC    C'Friday   '\n         DC    C'Saturday '\n         DC    C'Sunday   '\n\n         LTORG\n\n@K_Dynam        DSECT                 Dynamic area for K\n@K_Save         DS    18F              O/S Style save area\n@K_DateConv_Area_Ptr DS AL4            A(Callers DateConv_Area)\n@K_DBLWD        DS    D                Work area\n@K_DateConv_Area DS   CL(DConv_Area_Length)     Our area\n@K_K6Save       DS    2AL4             K6000 save area\n@K_K7Save       DS    2AL4             K7000 save area\n@K_Months DS   CL(K_Months_Length) Month table\n                DS    0D               Alignment\n@K_DynLen       EQU   *-@K_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'L0000 - List Selection Ctiteria'\nL0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : L0010                                                  *\n*                                                                     *\n*  Abstract  : List selection criteria                                *\n*                                                                     *\n*  Inputs    : R1 ----> ODT entry                                     *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New. This used to be part of B0010, *\n*                                 but we ran out of base register.    *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING L0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@L_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@L_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @L_Dynam,R13             Assign a base\n         L     R15,@L_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         LR    R10,R1                   Point to the ODT Entry\n         USING ODT_Entry,R10            and tell the assembler\n\n* - - - - - - - - - - -  D A T E / T I M E     - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         CP    ODTE_StartDate,=P'0'   ANY START DATE SPECIFIED?\n         BNE   L0020                  YES, SKIP\n         CP    ODTE_EndDate,=P'999999' NO, ANY END DATE?\n         BNE   L0020                  YES, SKIP\n         MVC   10(L'L_Sum3,R2),L_Sum3 MOVE NO DATE/TIME MESSAGE\n         B     L0070                  AND SKIP\nL0020    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum2A,R2),L_Sum2A MOVE FIRST PART OF MESSAGE\n         CP    ODTE_StartDate,=P'0'  ANY START DATE?\n         BNE   L0030                 YES, SKIP\n         MVC   10+L'L_Sum2A(20,R2),=C' the start of SYSUT1'\n         LA    R2,10+L'L_Sum2A+20(0,R2) BUMP POINTER\n         B     L0040                 AND SKIP\nL0030    DS    0H\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_StartDate move in Date\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_StartTime                 Time too\n         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_*\n               Input_Time           Indicate SMF Time\n         LA    R15,@L_DateConv_Area     Point to Date Conversion area\n         ST    R15,@L_Parms          Save as 1st parm\n         LA    R15,10+L'L_Sum2A+1(0,R2) A(Output area)\n         ST    R15,@L_Parms+4        Save as 2nd parm\n         LA    R15,@L_Return_Ptr     A(Return area)\n         ST    R15,@L_Parms+8        Save it\n         LA    R1,@L_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\nL0040    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10+L'L_Sum2A-L'L_Sum2B(L'L_Sum2B,R2),L_Sum2B Next part\n         LA    R2,10+L'L_Sum2A+1(0,R2) Point past it\n         CP    ODTE_EndDate,=P'999999' ANY END DATE?\n         BNE   L0050                 YES, SKIP\n         MVC   0(19,R2),=C' the end of SYSUT1'\n         LA    R2,19(0,R2)           BUMP POINTER\n         B     L0060                 AND SKIP\nL0050    DS    0H\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_EndDate move in Date\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_EndTime                 Time too\n         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@L_DateConv_Area     Point to Date Conversion area\n         ST    R15,@L_Parms          Save as 1st parm\n         LA    R15,0(0,R2)           A(Output area)\n         ST    R15,@L_Parms+4        Save as 2nd parm\n         LA    R15,@L_Return_Ptr     A(Return area)\n         ST    R15,@L_Parms+8        Save it\n         LA    R1,@L_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R2,@L_Return_Ptr      Point past\n         LA    R2,1(0,R2)              Date/Time\nL0060    DS    0H\n         MVC   0(L'L_Sum2C,R2),L_Sum2C MOVE LAST PART OF MESSAGE\nL0070    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -   P E R I O D            - - - - - - - - - - -*\n\n         ICM   R15,B'1111',ODTE_PeriodStart PERIOD START TIME\n         BNZ   L0080                  OK, PRINT PERIOD MESSAGE\n         L     R15,ODTE_PeriodEnd     NO, GET PERIOD END\n         C     R15,=F'8640000'        IS THERE ONE?\n         BE    L0090                  NO, SKIP\nL0080    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10(20,R2),=C'Only records between'\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_PeriodStart             Time too\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R1,@L_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Time\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  30(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   30(R2),C' '           Clear spurious char\n         OI    32(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  33(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   33(R2),C':'           Clear spurious char\n         OI    35(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  36(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   36(R2),C':'           Clear spurious char\n         OI    38(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  39(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   39(R2),C'.'           Clear spurious char\n         OI    41(R2),X'F0'          Make it readable\n\n         MVC   42(4,R2),=C' and'\n\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_PeriodEnd               Time too\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R1,@L_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Time\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  46(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   46(R2),C' '           Clear spurious char\n         OI    48(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  49(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   49(R2),C':'           Clear spurious char\n         OI    51(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  52(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   52(R2),C':'           Clear spurious char\n         OI    54(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  55(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   55(R2),C'.'           Clear spurious char\n         OI    57(R2),X'F0'          Make it readable\n         MVC   58(18,R2),=C' will be eligible.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\nL0090    DS    0H\n\n* - - - - - - - - - - W E E K E N D S  - - - - - - - - - - - - - - -*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?\n         BNO   L0100                  No, OK\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD\n         MVC   10(77,R2),=C'SMF Data generated on Saturday and Sunday w+\n               ill not be eligible for selection.'\n\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\nL0100    DS    0H\n\n* - - - - - - - - - - R E C O R D   T Y P E S  - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD\n         ICM   R3,B'1111',ODTE_RTT_Ptr  A(RECORD TYPE TABLE)\n         BNZ   L0110                  OK, SKIP\n         MVC   10(L'L_Sum5,R2),L_Sum5 NO, MOVE NO RECORD TYPE MSG\n         B     L0180                  AND SKIP\nL0110    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum4A,R2),L_Sum4A Move 1st part of message\n         LH    R4,RTT_Entry_Count-RecType_Tbl(R3) Get nbr entries\n         CH    R4,=H'1'               More than 1?\n         BNH   L0120                  No, skip\n         MVI   10+L'L_Sum4A(R2),C's'  Yes, make msg plural\n         LA    R2,1(0,R2)             and bump SYSPRINT pointer\nL0120    DS    0H\n         LA    R2,10+L'L_Sum4A+1(0,R2) A(NEXT AVAILABLE BYTE)\n         LR    R15,R2                 Calculate offset\n         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record\n         STH   R15,@L_SYSPRINT_Rec_Offset  and save it\n         LA    R3,RTT_Entry-RecType_Tbl(R3) A(FIRST ENTRY IN TABLE)\nL0130    DS    0H\n         LA    R15,9(0,R2)            A(last byte we might write)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0140                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0140    DS    0H\n         SLR   R0,R0                  CLEAR WORK REGISTER\n         IC    R0,RTTE_RecType-RTT_Entry(R3) GET RECORD TYPE\n         CVD   R0,@L_DBLWD            PACK IT\n         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK\n         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)\n         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT\n         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)\n         SR    R15,R1                 R3 = EXEC LEN OF EDITED RECTYPE\n         EX    R15,L_MVC              MOVE IT\n         LA    R2,1(R15,R2)           A(NEXT BYTE)\n         TM    RTTE_SubType_Present-RTT_Entry(R3),L'RTTE_SubType_Presen+\n               t                      Any subtype?\n         BNO   L0150                  No, skip subtype stuff\n         LH    R0,RTTE_SubType-RTT_Entry(R3) YES, GET SUBTYPE\n         CVD   R0,@L_DBLWD            PACK IT\n         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK\n         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)\n         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT\n         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)\n         SR    R15,R1                 R15 = EXEC LEN OF SUBTYPE\n         MVI   0(R2),C'('             OPENING PAREN\n         LA    R2,1(0,R2)             POINT PAST IT\n         EX    R15,L_MVC              MOVE SUBTYPE\n         LA    R2,1(R15,R2)           POINT TO NEXT BYTE\n         MVI   0(R2),C')'             CLOSE PAREN\n         LA    R2,1(0,R2)             AND BUMP POINTER\nL0150    DS    0H\n         MVI   0(R2),C','             MOVE SEPARATOR\n         LA    R2,2(0,R2)             POINT PAST IT\n         LA    R3,RTTE_Length(0,R3)   A(NEXT ENTRY\n         BCT   R4,L0130               and do it\n\n         SH    R2,=H'2'               BACK UP TO LAST COMMA\n         MVI   0(R2),C' '             CLEAR IT\n         LA    R15,1+L'L_Sum4B+2+L'L_Sum4C(0,R2) A(last byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0160                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0160    DS    0H\n         MVC   1(L'L_Sum4B,R2),L_Sum4B MOVE NEXT PART OF MSG\n         LA    R2,1+L'L_Sum4B(0,R2)   POINT PAST IT\n         L     R15,ODTE_RTT_Ptr       A(RECORD TYPE TABLE)\n         TM    RTT_Entry_Exclude-RecType_TBL(R15),L'RTT_Entry_Exclude\n         BZ    L0170                  INCLUDEing, skip\n         MVC   0(2,R2),=C'in'         EXCLUDEing, IN of INELIGIBLE\n         LA    R2,2(0,R2)             AND POINT PAST IT\nL0170    DS    0H\n         MVC   0(L'L_Sum4C,R2),L_Sum4C MOVE LAST PART OF MESSAGE\nL0180    DS    0H\n\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -      J O B N A M E S     - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(NEW PRINT RECORD)\n         ICM   R3,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE)\n         BNZ   L0190                  OK, SKIP\n         MVC   10(L'L_Sum6,R2),L_Sum6 NO, SAY SO\n         B     L0270                  AND SKIP\nL0190    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum7A,R2),L_Sum7A MOVE FIRST PART OF MESSAGE\n         LH    R4,JNT_Entry_Count-JobName_Tbl(R3) GET NBR JOBNAMES\n         CH    R4,=H'1'               MORE THAN 1?\n         BNH   L0200                  NO, SKIP\n         MVI   10+L'L_Sum7A(R2),C's'  YES, MAKE IT PLURAL\n         LA    R2,1(0,R2)             BUMP IT\nL0200    DS    0H\n         LA    R2,10+L'L_Sum7A+1(0,R2) A(NEXT AVAILABLE BYTE)\n         LR    R15,R2                 Calculate offset\n         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record\n         STH   R15,@L_SYSPRINT_Rec_Offset  and save it\n         LA    R3,JNT_Entry-JobName_Tbl(R3) A(FIRST JOBNAME\nL0210    DS    0H\n         LA    R15,L'JNTE_JobName+2(0,R2) A(Last possible byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0220                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0220    DS    0H\n         MVC   0(L'JNTE_JobName,R2),JNTE_JobName-JNT_Entry(R3)\n         CLI   JNTE_JobName_Len-JNT_Entry(R3),L'JNTE_JobName-1 PREFIX?\n         BE    L0230                  NO, SKIP\n         SLR   R0,R0                  YES, CLEAR WORK REG\n         IC    R0,JNTE_JobName_Len-JNT_Entry(R3) GET PREFIX EXEC LEN\n         AR    R2,R0                  BUMP OUTPUT POINTER\n         MVI   1(R2),C'*'             ADD IN THE ASTERISK\n         LA    R2,1(0,R2)             INCREMENT POINTER\n         B     L0250                  AND SKIP\nL0230    DS    0H\n         LA    R2,L'JNTE_JobName-1(0,R2) BUMP POINTER\nL0240    DS    0H\n         CLI   0(R2),C' '             END OF JOBNAME?\n         BNE   L0250                  YES, SKIP\n         BCT   R2,L0240               NO, KEEP CHECKING\nL0250    DS    0H\n         MVI   1(R2),C','             ADD A COMMA\n         LA    R2,3(0,R2)             A(NEXT JOBNAME AREA)\n         LA    R3,JNTE_Length(0,R3)   A(NEXT JOBNAME)\n         BCT   R4,L0210               AND KEEP GOING\n\n         SH    R2,=H'2'               BACK UP OVER LAST COMMA\n         LA    R15,L'L_Sum7B(0,R2)    A(Last possible byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0260                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0260    DS    0H\n         MVC   0(L'L_Sum7B,R2),L_Sum7B MOVE REST OF MESSAGE\nL0270    DS    0H\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -          D A T A         - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)\n         BNZ   L0280                  OK, SKIP\n         MVC   10(L'L_Sum8,R2),L_Sum8 NO, SAY SO\n         B     L0300                  AND SKIP\nL0280    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum9A,R2),L_Sum9A MOVE FIRST PART OF MESSAGE\n         LA    R2,L'L_Sum9A+10(0,R2) POINT PAST IT\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES\n         LA    R15,DT_Entry-Data_Tbl(R15) A(FIRST ENTRY)\nL0290    DS    0H\n         LR    R0,R14                 SAVE BCT COUNT\n         SLR   R14,R14                CLEAR REG\n         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA\n         LA    R1,DTE_Data-DT_Entry(0,R15) A(DATA)\n         EX    R14,L_MVC              MOVE IT\n         LA    R2,1(R14,R2)           A(NEXT BYTE)\n         MVC   0(L'L_Sum9B,R2),L_Sum9B MOVE NEXT PART OF MSG\n         LA    R2,L'L_Sum9B(0,R2)     POINT PAST IT\n         LH    R14,DTE_Offset-DT_Entry(R15) GET OFFSET\n         CVD   R14,@L_DBLWD           PACK IT\n         MVC   @L_Offset,=X'4020206B202120' MOVE MASK\n         LA    R1,@L_Offset+6         A(LAST POSSIBLE POSITION)\n         EDMK  @L_Offset,@L_DBLWD+5   EDIT IT\n         LA    R14,@L_Offset+6        A(LAST POSSIBLE POSITION)\n         SR    R14,R1                 R14 = EXEC LEN\n         EX    R14,L_MVC              MOVE IT\n         SLR   R14,R14                CLEAR REGISTER\n         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA\n         LA    R1,1+DTE_Data-DT_Entry(R14,R15) A(NEXT ENTRY)\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R2,@_SYSPRINT_Rec_Ptr  A(PRINT RECORD)\n         MVC   28(2,R2),=C'or'        MOVE LITERAL\n         LA    R2,31(0,R2)            POINT TO FREE POSITION\n         LR    R14,R0                 RESTORE BCT REGISTER\n         LR    R15,R1                 RESTORE A(TABLE ENTRY)\n         BCT   R14,L0290              KEEP GOING\n         L     R2,@_SYSPRINT_Rec_Ptr  A(OUTPUT RECORD)\n         MVC   15(L'L_Sum9C,R2),L_Sum9C MOVE LAST PART\nL0300    DS    0H\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                YES, GET A NEW SYSPRINT REC\n\n* - - - - - - - - - -   S T O P A F T          - - - - - - - - - - -*\n\n         ICM   R15,B'1111',ODTE_StopAft GET STOPAFT COUNT\n         BZ    L0310                  None, SKIP\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10(58,R2),=C'A maximum of XX,XXX records will be selecte*\n               d to this file.'\n         MVC   22(7,R2),=X'4020206B202120' MOVE MASK\n         L     R15,ODTE_StopAft       GET STOPAFT\n         CVD   R15,@L_DBLWD           PACK IT\n         ED    22(7,R2),@L_DBLWD+5    AND EDIT IT\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT IT\nL0310    DS    0H\n\n         DROP  R10                    Free ODT Entry addressability\n\n         B     L9010                  and exit\n\nL9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@L_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nL_MVC MVC      0(0,R2),0(R1)          EXECUTED INSTRUCTION\n\n\nL_Sum2A  DC    C'Records between'\nL_Sum2B  DC    C' and'\nL_Sum2C  DC    C' will be eligible'\n\nL_Sum3   DC    C'No Date-Time criteria; all records will be eligible'\n\nL_Sum4A  DC    C'Record Type'\nL_Sum4B  DC    C'will be '\nL_Sum4C  DC    C'eligible'\n\nL_Sum5   DC    C'No Record Type criteria; all records will be eligible'\n\nL_Sum6   DC    C'No Jobname criteria; all records will be eligible'\n\nL_Sum7A  DC    C'Records for Jobname'\nL_Sum7B  DC    C' will be eligible'\n\nL_Sum8   DC    C'No Data criteria; all records will be eligible'\n\nL_Sum9A DC     C'Records must contain '\nL_Sum9B DC     C' in position '\nL_Sum9C DC     C' to be eligible'\n\n\n         LTORG\n\n@L_Dynam        DSECT                 Dynamic area for L\n@L_Save         DS    18F              O/S Style save area\n@L_DBLWD        DS    D                Work area\n@L_Parms        DS    3AL4             Parm area\n@L_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@L_SYSPRINT_Rec_Offset DS  HL2         Offset into SYSPRINT record\n@L_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n@L_Offset       DS    CL7              DATA= offset\n                DS    0D               Alignment\n@L_DynLen       EQU   *-@L_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'W0000 - Return JFCB pointer'\nW0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : W0010                                                  *\n*                                                                     *\n*  Abstract  : Return A(JFCB) as returned by SWAREQ                   *\n*                                                                     *\n*  Inputs    : R1 : A(DCB)                                            *\n*                                                                     *\n*  Outputs   : R1 : A(JFCB) or 0                                      *\n*              R0 : A(TIOT Entry) or 0                                *\n*              R15: 0:OK, 4: No JFCB                                  *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING W0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@W_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@W_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @W_Dynam,R13             Assign a base\n         L     R15,@W_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Find our TIOT entry ...                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,CVTPTR(0,0)          A(CVT)\n         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)\n         L     R15,0(0,R15)             A(Current TCB)\n         L     R15,TCBTIO-TCB(R15)      A(TIOT)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the DCB is OPEN, we can use DCBTIOT to find our entry ...   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN DCB OPen?\n         BNO   W0020                    No, skip\n\n         AH    R15,DCBTIOT-IHADCB(R1)   Offset in TIOT\n         B     W0040                    and skip\n\nW0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The DCB is not OPEN, chain through the TIOT looking for our    *\n*   DDName                                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,TIOENTRY-TIOT1(R15)  A(1st entry in TIOT)\nW0030    DS    0H\n         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?\n         BE    W8010                    Yes, DDName not found\n         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),DCBDDNAM-IHADCB(R1)\n         BE    W0040                    Found our entry, skip\n\n         SLR   R0,R0                    Clear work reg\n         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length\n         AR    R15,R0                   Point to next entry\n         B     W0030                    and check it out\nW0040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and then get the JFCB address from the SVA                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R15,@W_TIOT_Ptr          Save A(TIOT Entry)\n\n         XC    @W_SWAEPAX,@W_SWAEPAX    Clear SWAEPA\n         MVC   @W_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)\n         LA    R15,@W_SWAEPAX           A(EPA)\n         ST    R15,@W_EPA_Ptr           Save the address\n\n         MVC   @W_SWAREQ,W_SWAREQ       Move L-Form of macro\n         SWAREQ FCODE=RL,               Read Locate                    +\n               EPA=@W_EPA_Ptr,           using the EPA at this addr    +\n               UNAUTH=YES,               not being authorized          +\n               MF=(E,@W_SWAREQ)          keep ourselves re-entrant\n\n         L     R1,@W_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)\n         L     R0,@W_TIOT_Ptr           A(TIOT Entry)\n         SLR   R15,R15                  Clear return code\n         B     W9010                    and exit\n\nW8010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    TIOT entry not found                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R1,R1                    Clear A(JFCB)\n         SLR   R0,R0                    Clear A(TIOT)\n         LA    R15,4                    Set return code\n         B     W9010                    and exit\n\n\nW9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LR    R3,R0                    Save A(TIOT)\n         LR    R4,R1                    Save A(JFCB)\n         LA    R1,@W_Dynam              A(Local storage)\n\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n         LR    R0,R3                    Restore A(TIOT)\n         LR    R1,R4                    Restore A(JFCB)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\nW_SWAREQ SWAREQ MF=L                    Read Locate\nW_SWAREQ_Length EQU *-W_SWAREQ          Length of SWAREQ Macro\n\n         LTORG\n\n@W_Dynam        DSECT                 Dynamic area for W\n@W_Save         DS    18F              O/S Style save area\n@W_EPA_Ptr      DS    AL4              A(EPA for SWAREQ)\n@W_TIOT_Ptr     DS    AL4              A(TIOT Entry for DDName)\n@W_SWAREQ       DS    CL(W_SWAREQ_Length)\n                DS    0F\n@W_SWAEPAX      DS    CL(L'SWAEPAX)\n\n                DS    0D               Alignment\n@W_DynLen       EQU   *-@W_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'X0000 - Exit Invocation Routine'\nX0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : X0010                                                  *\n*                                                                     *\n*  Abstract  : Invoke user exits                                      *\n*                                                                     *\n*  Inputs    : R0 : 0:Inexit, 1:OutExit                               *\n*              R1 : A(SMF Record)                                     *\n*              R10: A(ODT Entry)                                      *\n*                                                                     *\n*  Outputs   : R1 : A(SMF Record as returned by exit)                 *\n*              R15: As received from the user exit                    *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING X0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@X_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@X_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @X_Dynam,R13             Assign a base\n         L     R15,@X_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         USING ODT_Entry,R10            Assign ODTE base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the SYSPRINT User Exit Interface (Y0010) has not been       *\n*   copied to 24-bit storage, do it now ...                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@_SYSPRINT_Y0010_Ptr A(Interface routine)\n         BNZ   X0020                    Already moved, OK\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=Y_Code_End-Y0010,  this long                     +\n               LOC=BELOW                 below-the-line\n\n         ST    R1,@_SYSPRINT_Y0010_Ptr  Save the address\n         LR    R0,R1                    Point to it\n         LA    R1,Y_Code_End-Y0010      Length of code\n         L     R14,=AL4(Y0010)          Point to start of code\n         LR    R15,R1                   Same length\n         MVCL  R0,R14                   Move code to 24-bit storage\n\n         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)\n         ST    R12,Y_@_Dynam_Ptr-Y0010(R15) Update A(@_Dynam)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and IDENTIFY it as SMFSLCTP, in case the exit is written   *\n*   in a HLL.                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Y0010_Ptr Point to our routine\n         IDENTIFY EP=SMFSLCTP,         and let MVS know                +\n               ENTRY=(1)                about it\n\nX0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Update the pointer to the ODT in the Y0010 copy                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)\n         ST    R10,Y_@_ODT_Entry_Ptr-Y0010(R15) Update A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some 24-bit storage, and build our parm list               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@X_24_DynLen,         this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         ST    R1,@X_ParmList_Ptr       Save it\n         USING @X_24_Dynam,R1           Assign a base\n\n         L     R15,@X_Dynam+4           Get A(HSA)\n         L     R0,24(0,R15)             A(SMF record) Original R1\n         ST    R0,@X_24_Exit_Parmlist   Save A(SMF Record)\n\n         ICM   R0,B'1111',20(R15)       Get Original R0\n         BNZ   X0030                    OutExit, skip\n\n         L     R0,ODTE_InExit_Data      Yes, A(Word for the user)\n         ST    R0,@X_24_Exit_Word       Save it\n         LA    R0,@X_24_Exit_Word       Point to it\n         ST    R0,@X_24_Exit_Parmlist+4 Save the pointer\n         L     R0,ODTE_InExit_Parm_Ptr  A(Parm for InExit)\n         ST    R0,@X_24_Exit_Parmlist+8 Save it\n         L     R15,ODTE_InExit_Ptr      A(InExit EP)\n         B     X0040                    Skip\n\nX0030    DS    0H\n\n         L     R0,ODTE_OutExit_Data     Yes, A(Word for the user)\n         ST    R0,@X_24_Exit_Word       Save it\n         LA    R0,@X_24_Exit_Word       Point to it\n         ST    R0,@X_24_Exit_Parmlist+4 Save it\n         L     R0,ODTE_OutExit_Parm_Ptr A(Parm for OutExit)\n         ST    R0,@X_24_Exit_Parmlist+8 Save it\n         L     R15,ODTE_OutExit_Ptr     A(OutExit EP)\n         B     X0040                    Skip\n\nX0040    DS    0H\n\n         L     R0,@_Input_Count         Input count\n         ST    R0,@X_24_Input_Count     Save it\n         LA    R0,@X_24_Input_Count     Point to it\n         ST    R0,@X_24_Exit_Parmlist+12 Save it\n\n         L     R0,ODTE_Selected         A(Selected count)\n         ST    R0,@X_24_Selected        Save it\n         LA    R0,@X_24_Selected        Point to it\n         ST    R0,@X_24_Exit_Parmlist+16 Save it\n         MVC   @X_24_DDName,ODTE_DDName Move DDName\n         LA    R0,@X_24_DDName          A(DDName)\n         ST    R0,@X_24_Exit_Parmlist+20 Save it\n         L     R0,@_SYSPRINT_Y0010_Ptr  A(SYSPRINT routine)\n         ST    R0,@X_24_Exit_Parmlist+24 Save it\n\n         OI    @X_24_Exit_Parmlist+24,X'80' Flag as last parm\n\n         LA    R14,@X_24_Save           Point to 24-bit savearea\n         ST    R14,8(0,R13)             Chain\n         ST    R13,4(0,R14)              saveareas\n         LR    R13,R14                  Point to 24-bit savearea\n\n         LA    R1,@X_24_Exit_Parmlist   Point to the parmlist\n         BASR  R14,R15                  Go do the exit\n\n         LR    R2,R15                   Save return code\n\n         L     R13,4(0,R13)             Restore A(Our 31-bit savearea)\n\n         L     R1,@X_ParmList_Ptr       Restore A(24-bit storage)\n         L     R15,@X_Dynam+4           Get A(HSA)\n         ICM   R0,B'1111',20(R15)       InExit?\n         BNZ   X0050                    No, skip\n         MVC   ODTE_InExit_Data,@X_24_Exit_Word Yes, save user stuff\n         B     X0060                    and skip\nX0050    DS    0H\n         MVC   ODTE_OutExit_Data,@X_24_Exit_Word Yes, save user stuff\nX0060    DS    0H\n\n         L     R1,@X_ParmList_Ptr       A(Parmlist)\n         L     R3,@X_24_Exit_Parmlist   Get A(SMF record)\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_24Bit_Stack_Ptr   on this stack\n\n         DROP  R1                       Free 24-bit storage base\n\n         LR    R15,R2                   Restore return code\n         B     X9010                    and exit\n\nX9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@X_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LR    R15,R2                   Set return code\n         L     R0,20(0,R13)             Restore R0\n         LR    R1,R3                    A(SMF record returned by exit)\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         LTORG\n\n@X_Dynam        DSECT                 Dynamic area for X\n@X_Save         DS    18F              O/S Style save area\n@X_ParmList_Ptr DS    AL4              A(Parmlist)\n                DS    0D               Alignment\n@X_DynLen       EQU   *-@X_Dynam      Length of storage required\n\n@X_24_Dynam     DSECT                 24-bit Dynamic area for X\n@X_24_Save      DS    18F              O/S Style save area\n@X_24_Exit_Parmlist DS 7FL4            Parmlist\n@X_24_Exit_Word DS    FL4              A Word for the user\n@X_24_Input_Count DS  FL4              Input count\n@X_24_Selected  DS    FL4              Selected count\n@X_24_DDName    DS    CL8              DDName\n                DS    0D               Alignment\n@X_24_DynLen    EQU   *-@X_24_Dynam   Length of 24-bit storage required\n\n\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         TITLE 'Y0000: SYSPRINT routine for User Exits'\n\n         PUSH  USING\n\nY0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : Y0010                                                  *\n*                                                                     *\n*  Abstract  : SYSPRINT routine for User Exits:                       *\n*               Load @_Dynam base                                     *\n*               Move user data to SYSPRINT record                     *\n*               Invoke G0010                                          *\n*                                                                     *\n*                                                                     *\n*  Inputs    : R1 --> A(Data to be printed)                           *\n*                     Fullword containing length of data              *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*  Notes     : This routine is moved to 24-bit storage, and the       *\n*              address of @_Dynam inserted into the copy.             *\n*              Before each invocation of the exit, the address of the *\n*              active ODT is also stored in Y_ODT_Entry_Ptr.          *\n*                                                                     *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING Y0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Make sure we are in AMODE(31)                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R14,Y0020                A(Dummy label)\n         ICM   R14,B'1000',=XL1'80'     in 31-bit mode\n         BSM   0,R14                    Gen into 31-bit mode\nY0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R12,Y_@_Dynam_Ptr        A(@_Dynam)\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@Y_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@Y_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Y_Dynam,R13             Assign a base\n         L     R15,@Y_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If SYSPRINT is OPEN ...                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it open?\n         BZ    Y9010                  No, skip printing\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... load the address of the ODT we are using ...               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,Y_@_ODT_Entry_Ptr  A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... move the data to the SYSPRINT record ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@_SYSPRINT_Rec_Ptr Get A(SYSPRINT record)\n         LH    R15,@_SYSPRINT_Rec_Len Get its length\n         LM    R0,R1,0(R1)            Get ptr, length of user data\n         ICM   R1,B'1000',=CL1' '     Pad character of blank\n         MVCL  R14,R0                 Move user data\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and print it                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Go do it\n\nY9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@Y_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nY_@_Dynam_Ptr     DC AL4(0)           A(@_Dynam)\nY_@_ODT_Entry_Ptr DC AL4(0)           A(ODT Entry for User exit)\n\n         LTORG\n\nY_Code_End  EQU   *                   End of code to be moved\n\n@Y_Dynam        DSECT                 Dynamic area for Y\n@Y_Save         DS    18F              O/S Style save area\n                DS    0D               Alignment\n@Y_DynLen       EQU   *-@Y_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\nSMFSLCT  RSECT\n\n         TITLE 'Z0000: Termination'\n\n         PUSH  USING\n\nZ0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : Z0010                                                  *\n*                                                                     *\n*  Abstract  : Termination routine:                                   *\n*               Print counters                                        *\n*               Close DCBs                                            *\n*               Free Storage areas                                    *\n*                                                                     *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15 = 0, at least 1 record selected to an output file  *\n*                    4, no records selected to any output file.       *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING Z0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@Z_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@Z_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Z_Dynam,R13             Assign a base\n         L     R15,@Z_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         NI    @Z_Select_OK,X'FF'-L'@Z_Select_OK Nothing selected\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE RECORD COUNTERS, IF POSSIBLE.                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_DCB_Ptr A(Sysprint DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS SYPRINT OPEN?\n         BZ    Z0060                  NO, SKIP PRINTING\n         LA    R15,99                 GET HIGH LINE COUNT\n         STH   R15,@_Line_Count       SAVE IT\n         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\n         USING ODT_Entry,R10          Tell the assembler\n\n         OI    ODTE_Print_NO,L'ODTE_Print_NO SUPPRESS HEADINGS\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO GET A NEW PAGE\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         ICM   R15,B'1111',@_Input_Count Nbr input records read\n         BZ    Z0050                  None, skip\n         CP    @_Dump_Start_Date,=P'999999' DID WE GET A TYPE 2?\n         BE    Z0040                  NO, SKIP\n         MVC   20(27,R2),=C'First Dump Header (Type 2):'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Dump_Start_Date    Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Dump_Start_Time              Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(27,R2),=C'Last Dump Trailer (Type 3):'\n         CP    @_Dump_End_Date,=P'0'  DID WE GET A TYPE 3?\n         BNE   Z0020                  YES, SKIP\n         MVI   51(R2),C'?'            NO, SAY SO\n         B     Z0030                  AND SKIP\nZ0020    DS    0H\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Dump_End_Date    Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Dump_End_Time              Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\nZ0030    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\nZ0040    DS    0H\n         MVC   20(26,R2),=C'Date/Time of first record:'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_First_Rec_Date   Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_First_Rec_Time             Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(25,R2),=C'Date/Time of last record:'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Input_Rec_Date   Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Input_Rec_Time             Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Output area)\n         ST    R15,@Z_Parms+8        Save as 3nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                A COUPLE OF\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  BLANK LINES\nZ0050    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(23,R1),=C'Number of records read:'\n         MVC   50(12,R1),=X'402020206B2020206B202120'\n         L     R15,@_Input_Count      GET INPUT COUNTER\n         CVD   R15,@Z_DBLWD           PACK IT\n         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE INPUT COUNT\n         TM    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Segment errors?\n         BZ    Z0060                  No, skip\n         L     R1,@_SYSPRINT_Rec_Ptr  Yes, A(SYSPRINT record)\n         MVC   17(39,R1),=C'** Segment errors discarded from SYSUT1'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Print warning message\nZ0060    DS    0H\n         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         CH    R9,=H'1'               MORE THAN 1 ENTRY?\n         BNH   Z0070                  No, continue\n         ST    R10,@Z_Default_ODTE_Ptr Yes, save its address\n         B     Z0160                  and skip it until last\nZ0070    DS    0H\n         ICM   R15,B'1111',@_SYSPRINT_DCB_Ptr A(Sysprint DCB)\n         BZ    Z0090                  None, skip\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Yes, is it open?\n         BNO   Z0090                  NO, SKIP\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A NEW SYSPRINT RECORD\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   20(27,R1),=C'Number of          records:'\n         MVC   30(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME\n         MVC   50(12,R1),=X'402020206B2020206B202120'\n         ICM   R15,B'1111',ODTE_Selected Get selected counter\n         BZ    Z0080                  None, skip\n         OI    @Z_Select_OK,L'@Z_Select_OK Yes, set our flag\nZ0080    DS    0H\n         CVD   R15,@Z_DBLWD           PACK IT\n         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT\n         TM    ODTE_Trunc,L'ODTE_Trunc  ANY RECORDS TRUNCATED?\n         BZ    Z0090                  NO, SKIP\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                YES, SKIP A LINE\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT)\n         MVC   10(73,R1),=C'*****  WARNING - At least 1 record truncate*\n               d on XXXXXXXX - WARNING  *****'\n         MVC   58(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME\nZ0090    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LAST CALL TO INPUT EXIT, AND DELETE, IF PRESENT                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_InExit_Ptr A(INPUT EXIT\n         BZ    Z0100                 None, SKIP\n         SLR   R1,R1                 Yes, clear A(SMF record)\n         SLR   R0,R0                 Flag as an InExit\n         L     R15,=AL4(X0010)       A(Exit interface)\n         BASR  R14,R15               Go do it\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0095                 Yes, skip\n         CLC   ODTE_InExit,ODTE_InExit-ODT_Entry(R15) No, default exit?\n         BE    Z0100                 YES, DON'T DELETE IT\nZ0095    DS    0H\n         LA    R0,ODTE_InExit        A(EXIT NAME)\n         DELETE EPLOC=(0)            AND DELETE IT\n\n         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)\n         BZ    Z0100                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer\nZ0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LAST CALL TO OUTPUT EXIT, AND DELETE, IF PRESENT               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_OutExit_Ptr  A(OUTPUT EXIT)\n         BZ    Z0110                 None, SKIP\n         SLR   R1,R1                 Yes, clear A(SMF record)\n         LA    R0,1                  Flag as an OutExit\n         L     R15,=AL4(X0010)       A(Exit interface)\n         BASR  R14,R15               Go do it\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0105                 Yes, skip\n         CLC   ODTE_OutExit,ODTE_OutExit-ODT_Entry(R15) No, default?\n         BE    Z0110                 YES, DON'T DELETE IT\nZ0105    DS    0H\n         LA    R0,ODTE_OutExit       A(EXIT NAME)\n         DELETE EPLOC=(0)            AND DELETE IT\n\n         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)\n         BZ    Z0110                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer\nZ0110    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE THE OUTPUT DCB, IF OPEN.                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R2,B'1111',ODTE_DCB_Ptr A(Output DCB)\n         BZ    Z0130                  None, skip\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Yes, is it open?\n         BZ    Z0120                  NO, BETTER NOT CLOSE IT\n         MVC   @Z_CLOSE,Z_CLOSE           YES, MOVE CLOSE PARMS\n         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT\nZ0120    DS    0H\n         LA    R0,B_SYSUT2_DCB_Length Length of DCB\n         LR    R1,R2                  A(DCB storage)\n         STORAGE RELEASE,             Get storage                      +\n               LENGTH=(0),             for the DCB                     +\n               ADDR=(1)                which is here\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_DCB_Ptr       No more DCB\nZ0130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP RECORD TYPE TABLE, IF IT EXISTS.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    Z0140                  None, BETTER NOT FREE IT\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0135                 Yes, skip\n         CLC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0140                 YES, DON'T DELETE IT\nZ0135    DS    0H\n         L     R0,0(0,R1)             NO, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0140    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP JOBNAME TABLE, IF IT EXISTS.                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_JNT_Ptr A(JOBN TABLE)\n         BZ    Z0150                  None, BETTER NOT FREE IT\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0145                 Yes, skip\n         CLC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0150                 YES, DON'T DELETE IT\nZ0145    DS    0H\n         L     R0,0(0,R1)             YES, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0150    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP DATA TABLE, IF PRESENT.                                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_DT_Ptr A(DATA TABLE\n         BZ    Z0160                 None SKIP\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0155                 Yes, skip\n         CLC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0160                 YES, DON'T DELETE IT\nZ0155    DS    0H\n         L     R0,0(0,R1)            YES, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0160    DS    0H\n         AL    R10,=AL4(ODTE_Length)  A(NEXT ENTRY)\n         BCT   R9,Z0070               GO DO IT TOO\n         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         CH    R9,=H'1'               MORE THAN 1 ENTRY?\n         BNH   Z0190                  NO, SKIP\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) YES, POINT TO DEFAULT\n         ICM   R15,B'0010',ODTE_InExit_Ptr GET A(INEXIT)\n         BZ    Z0170                  None, SKIP\n         LA    R0,ODTE_InExit         YES, POINT TO IT'S NAME\n         DELETE EPLOC=(0)             AND DELETE IT\n         XC    ODTE_InExit_Ptr,ODTE_InExit_Ptr CLEAR EXIT ADDRESS\n\n         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)\n         BZ    Z0170                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer\nZ0170    DS    0H\n         ICM   R15,B'1111',ODTE_OutExit_Ptr GET A(OUTEXIT)\n         BZ    Z0180                  None, SKIP\n         LA    R0,ODTE_OutExit        YES, POINT TO IT'S NAME\n         DELETE EPLOC=(0)             AND DELETE IT\n         XC    ODTE_OutExit_Ptr,ODTE_OutExit_Ptr CLEAR EXIT ADDRESS\n\n         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)\n         BZ    Z0180                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer\nZ0180    DS    0H\n         L     R15,@_ODT_Ptr          A(OUR TABLE)\n         LA    R9,1                   DO A SINGLE ENTRY\n         STH   R9,ODT_Entry_Count-OutDesc_Tbl(R15) PRETEND ONLY 1 ENTRY\n         B     Z0090                  AND FREE UP DEFAULT TABLES\nZ0190    DS    0H\n\n         DROP  R10\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Print the counters by record type                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE SYSPRINT, IF REQUIRED.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R2,B'1111',@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         BZ    Z0270                  None, skip\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN SYSPRINT OPEN?\n         BZ    Z0260                  NO, BETTER NOT CLOSE IT\n         MVC   @Z_CLOSE,Z_CLOSE       YES, MOVE CLOSE PARMS\n         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT\nZ0260    DS    0H\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(R1),                starting here                 +\n               LENGTH=G_SYSPRINT_DCB_Length this long\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_DCB_Ptr   No more DCB\n\n         ICM   R1,B'1111',@_SYSPRINT_Y0010_Ptr\n         BZ    Z0270\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(R1),                starting here                 +\n               LENGTH=Y_Code_End-Y0010   this long\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_Y0010_Ptr No more print interface\n\n         DELETE EP=SMFSLCTP             Un-IDENTIFY it\n\nZ0270    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free the Output Descriptor Table                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',@_ODT_Ptr   A(ENVIRONMENT TABLE)\n         BZ    Z0280                  None, dont free it\n         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) GET SUBPOOL, LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_ODT_Ptr          No more ODT\nZ0280    DS    0H\n         B     Z9010                  and exit\nZ9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Set the return code, if anything has been selected or not      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Assume all is OK\n         TM    @Z_Select_OK,L'@Z_Select_OK Anything selected?\n         BO    Z9020                    Yes, OK\n         LA    R15,8                    No, set return code\nZ9020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Save return code\n         LA    R1,@Z_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller (return code in R15)                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nZ_CLOSE    CLOSE (0),MODE=31,MF=L\nZ_CLOSE_Length EQU   *-Z_CLOSE\n         LTORG\n\n@Z_Dynam        DSECT                 Dynamic area for Z\n@Z_Save         DS    18F              O/S Style save area\n@Z_DBLWD        DS    D                Work area\n@Z_Default_ODTE_Ptr DS AL4             A(Defalt ODT Entry)\n@Z_Parms        DS    3AL4             Parms for F0010\n@Z_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@Z_InExit_Parm  DS    2AL4             Parms for InExit\n@Z_OutExit_Parm DS    2AL4             Parm list for OutExit\n                DS    X                Flag Byte\n@Z_Select_OK    EQU   *-1,X'80'         1... .... At least 1 rec sel\n@Z_Macros       DS    0F               Macro area\n@Z_Close        DS    CL(Z_CLOSE_Length)  Close macro\n                ORG   @Z_Macros\n@Z_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                ORG\n                DS    0D               Alignment\n@Z_DynLen       EQU   *-@Z_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZSMFSLCT": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x08\\x01\\x02\\x03\\x8f\\x01\\x13\\x05\\x1f V.o*\\x14\\x00\\x00\\xd6\\xd3\\xc4\\xe5\\xc5\\xd9\\xe2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-02-07T00:00:00", "modifydate": "2013-02-20T20:56:08", "lines": 11887, "newlines": 10772, "modlines": 0, "user": "OLDVERS"}, "text": "         TITLE 'Assembly Variables'\n         LCLC  &VERSION\n&VERSION SETC  'V1.5'\n\n         LCLC  &ASMDT\n&ASMDT   SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\nSMFSLCT  TITLE 'Introduction'\n*********************************************************************\n*                                                                   *\n*                 S  M  F  S  L  C  T                               *\n*                                                                   *\n*   This program will read SMF data (from the MAN datasets or output*\n*  from IFASMFDP), and will select records according to user        *\n*  specified criteria. Records can be selected by date and time,    *\n*  by record type (and /or subtype), by Jobname, or by data at an   *\n*  offset within the record. Records must meet date/time and        *\n*  record type criteria before being eligible for selection, as     *\n*  determined by Jobname and/or data specifications.                *\n*                                                                   *\n*   By default, any records selected from the input will be printed *\n*  to SYSPRINT, unless 'PRINT=NO' is specified in the SYSIN control *\n*  cards. If SYSUT2 is present, the selected input records will     *\n*  also be written to it.                                           *\n*                                                                   *\n*   Multiple output files with different selection criteria can be  *\n*  produced in one run of SMFSLCT. The output DDNames and selection *\n*  criteria are specified in the control cards in SYSIN.            *\n*                                                                   *\n*   Two user-written exits can be used with SMFSLCT - the first     *\n*  is given control after an SMF record is read, and the second     *\n*  after an SMF record has been selected.                           *\n*                                                                   *\n*  Input:                                                           *\n*      SYSUT1   - SMF dataset - either the output from IFASMFDP or  *\n*                 one of the SYS1.MAN datasets. If this DDName is   *\n*                 not allocated, it will be dynamically allocated to*\n*                 the active SMF dataset.                           *\n*      SYSIN    - Control cards (see below).                        *\n*                                                                   *\n*  Output:                                                          *\n*      SYSPRINT - Error messages, selected SMF records.             *\n*      SYSUT2   - optional, selected SMF records.                   *\n*                                                                   *\n*  Attributes:                                                      *\n*      Re-entrant, Reuseable, Refreshable, Not Authorized,          *\n*      AMODE(31), RMODE(ANY)                                        *\n*                                                                   *\n*  Coding    : All data areas in Dynamic Storage have names starting*\n*   Notes       with '@'. One area of Dynamic Storage is acquired   *\n*               during initialization, and is used as a LIFO stack  *\n*               for dynamic storage.                                *\n*              Conversely, data areas within the program (and thus  *\n*               are read-only) have names that do not start with    *\n*               an '@'.                                             *\n*                                                                   *\n*              The names of the Routines (and non-data labels within*\n*               the routines) follow the pattern:                   *\n*                 xnnnn                                             *\n*               where x    is 1 or more alphabetic characters       *\n*                     nnnn is a numeric sequence number             *\n*                                                                   *\n*              Data in dynamic storage that are globally accessible *\n*               have names of the form:                             *\n*                @_anyname                                          *\n*              Data associated with a routine typically have names: *\n*                 x_anyname or @x_anyname                           *\n*               where 'x' is the alphabetic character associated    *\n*                         with the routine                          *\n*              Addressability to globally-accessible dynamic data is*\n*               via R12; local dynamic data is addressable via R13. *\n*                                                                   *\n*              Each routine establishes it's own base register(s),  *\n*               and has access only to it's own read-only variables.*\n*               Base registers are typically R11.                   *\n*                                                                   *\n*  Sample Installation JCL:                                         *\n*                                                                   *\n*  //SMFSLCTA JOB blah,blah                                         *\n*  //*                                                              *\n*  //ASM     EXEC PGM=ASMA90,REGION=4M,                             *\n*  //             PARM='NODECK,OBJECT,RENT,XREF(SHORT),NOALIGN'     *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB                          *\n*  //          DD DISP=SHR,DSN=SYS1.MODGEN                          *\n*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),      *\n*  //             UNIT=SYSALLDA                                     *\n*  //SYSLIN    DD DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),           *\n*  //             UNIT=SYSALLDA,DISP=(MOD,PASS),                    *\n*  //             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB)              *\n*  //SYSIN     DD DISP=SHR,DSN=source-program                       *\n*  //*                                                              *\n*  //LKED    EXEC PGM=HEWL,REGION=4M,COND=(0,LT),                   *\n*  //             PARM='LIST,MAP,RENT,REUS,REFR'                    *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSLIN    DD DSN=&&OBJ,DISP=(OLD,DELETE)                       *\n*  //          DD DDNAME=SYSIN                                      *\n*  //SYSUT1    DD DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND)       *\n*  //             UNIT=SYSALLDA                                     *\n*  //SYSLMOD   DD DISP=SHR,DSN=loadlib                              *\n*  //                                                               *\n*                                                                   *\n*  Change Log:                                                      *\n*      1999/04/24 SDDA030 V1.1                                      *\n*                 Added code to ignore records invalidly spanned    *\n*                 in non-VSAM VBS input.                            *\n*                 Calculated DCB=NCP (BSAM), DCB=BUFNO (QSAM), or   *\n*                 AMP=BUFSP (VSAM) so we can read a cylinder of     *\n*                 input at a time (if input on DASD).               *\n*                 Used MACRF=PM on output file(s), so VBS datasets  *\n*                 can be created.                                   *\n*                 Lives and executes in 31-bit mode.                *\n*                 Used internal LIFO stack for dynamic storage      *\n*                 Made Y2K compliant!                               *\n*      1999/07/22 SDDA030 V1.2                                      *\n*                 Added Date conversion routines.                   *\n*                 Added new START=/END= date keywords.              *\n*                 Added 24-bit EODAD for SYSIN, if required         *\n*      1999/11/18 SDDA030 V1.3                                      *\n*                 Moved SYSUT1 OPEN logic(?) to its own subroutine  *\n*                 (I0010)                                           *\n*                 Added comments                                    *\n*                                                                   *\n*      2002/02/07 SDDA030 V1.4                                      *\n*                 Added stack below the line.                       *\n*                 Added new parms for exits as suggested by Dave    *\n*                 Alcock.                                           *\n*                 Added parms to INEXIT=/OUTEXIT= statements.       *\n*                 Defaulted 2-digit years on START=/END= to the     *\n*                 current century.                                  *\n*                 Corrected S0C4 Abends when lots of record types   *\n*                 or jobnames selected (Thanks to Paul              *\n*                 Luttenberger).                                    *\n*                 Changed RDJFCBs to SWAREQs.                       *\n*                 Corrected logic when setting DCB characteristics  *\n*                 for new output datasets with no DCB spacified.    *\n*                 Printed **VIO** for volser when appropriate.      *\n*      2006/10/26 SDDA030 V1.5                                      *\n*                 Fixed bug when printing record subtypes to be     *\n*                 selected (thanks to BBordonaro).                  *\n*                 Corrected calculation of SYSPRINT LRECL (fixed    *\n*                 check for CC) (thanks to Martin Samson).          *\n*                 Corrected non-re-entrancy error with SYSUT1 EXLST *\n*                 (thanks to Martin Samson - again!).               *\n*                                                                   *\n*  Author:                                                          *\n*   All comments, criticisms and suggestions gratefully received.   *\n*     Paul Dion  (pdion@canada.com)                                 *\n*                                                                   *\n*********************************************************************\n         TITLE 'Control Cards'\n*********************************************************************\n*                                                                   *\n*                 C o n t r o l   C a r d s                         *\n*                                                                   *\n*   Control cards are entered via SYSIN. Only columns 1-72 are      *\n*  scanned, and the scan terminates with the first blank. Cont-     *\n*  inuations are not allowed, but keywords can be specified more    *\n*  than once. If a keyword that has a single value (ie, START=)     *\n*  is specified more than once within an output group, or globally, *\n*  the last value specified is used.                                *\n*                                                                   *\n*   OUTPUT=DDName                                                   *\n*      specifies the DDName of an output dataset. All subsequent    *\n*                control statements, until the next \"OUTPUT=\"       *\n*                statement or end-of-file, determine which input    *\n*                records will be selected to this DDName. All       *\n*                control statements appearing before an \"OUTPUT=\"   *\n*                statement apply to all output DDNames, unless      *\n*                specifically overridden by control statements      *\n*                entered after the \"OUTPUT=\" statement.             *\n*                                                                   *\n*   START=yyddd-hhmmss                                              *\n*         yyyyddd-hhmmss                                            *\n*         TODAY-hhmmss                                              *\n*         (TODAY-n)-hhmmss                                          *\n*         YESTERDAY-hhmmss                                          *\n*         THISWEEK-hhmmss                                           *\n*         LASTWEEK-hhmmss                                           *\n*         THISMONTH-hhmmss                                          *\n*         LASTMONTH-hhmmss                                          *\n*      specifies the date and time at which selection of input      *\n*                records is to start. Defaults to 00000-000000 (ie  *\n*                the start of the input file). The specification of *\n*                time (-hhmmss) is optional - if omitted, it def-   *\n*                aults to 00:00:00.00.                              *\n*                Dates using the 2-digit year format will default   *\n*                to dates in the current century.                   *\n*                YESTERDAY is equivalent to specifying (TODAY-1).   *\n*                Note that a week starts on Monday, and ends on     *\n*                Sunday. Thus, specifying START=LASTWEEK will start *\n*                selecting records from the Monday of the previous  *\n*                week.                                              *\n*                                                                   *\n*   END=yyddd-hhmmss                                                *\n*       yyyyddd-hhmmss                                              *\n*       TODAY-hhmmss                                                *\n*       (TODAY-n)-hhmmss                                            *\n*       YESTERDAY-hhmmss                                            *\n*       THISWEEK-hhmmss                                             *\n*       LASTWEEK-hhmmss                                             *\n*       THISMONTH-hhmmss                                            *\n*       LASTMONTH-hhmmss                                            *\n*      specifies the date and time at which selection if input      *\n*                records is to stop. Defaults to 2699999-235959 (ie *\n*                the end of the input file). The specification of   *\n*                time (-hhmmss) is optional - if omitted, it def-   *\n*                aults to 23:59:59.99.                              *\n*                Dates using the 2-digit year format will default   *\n*                to dates in the current century.                   *\n*                YESTERDAY is equivalent to specifying (TODAY-1).   *\n*                Note that a week starts on Monday, and ends on     *\n*                Sunday. Thus, specifying END=LASTWEEK will stop    *\n*                selecting records on the Sunday of the previous    *\n*                week.                                              *\n*                                                                   *\n*   PERIOD=hhmmss-hhmmss                                            *\n*      specifies the start and stop time-of-day between which input *\n*                records will be eligible for selection. Records for*\n*                each day, as specified by start/end or defaulted,  *\n*                falling outside these times will be ignored.       *\n*                 The time can be specified as hh, hhmm or hhmmss;  *\n*                the missing digits will default to 0.              *\n*                 Defaults to \"PERIOD=000000-240000\".               *\n*                                                                   *\n*   WEEKENDS=IGNORE                                                 *\n*      specifies that SMF data generated on Saturday and Sunday will*\n*                be ignored.                                        *\n*                                                                   *\n*   INCLUDE=nn<(ss)>                                                *\n*      specifies that record type nn should be selected. A subtype  *\n*                ss can also be optionally included, in parentheses.*\n*                If more that one record type is coded on the       *\n*                control card, the record types (and subtypes)      *\n*                must be enclosed in parentheses.                   *\n*                SMF Record Type 30 is used as a model to determine *\n*                the SubType location.                              *\n*                Note that 'INCLUDE' is mutually exclusive with the *\n*                'EXCLUDE' keyword within an \"OUTPUT=\" definition,  *\n*                or globally, if no \"OUTPUT=\" statement is present. *\n*                                                                   *\n*   EXCLUDE=nn<(ss)>                                                *\n*      specifies that record type nn should not be selected. A      *\n*                subtype ss can optionally be included, in paren-   *\n*                theses. If more than one record type is coded,     *\n*                the record types (and subtypes) and subtypes must  *\n*                be enclosed in parentheses.                        *\n*                Note that 'EXCLUDE' is mutually exclusive with the *\n*                'INCLUDE' keyword within an \"OUTPUT=\" definition,  *\n*                or globally, if no \"OUTPUT=\" statement is present. *\n*                                                                   *\n*   PRINT=NO                                                        *\n*   PRINT=EBCDIC                                                    *\n*         NO     specifies that selected records are not to be      *\n*                printed on SYSPRINT. If an output ddname is        *\n*                present, selected records will be written to it.   *\n*         EBCDIC specifies that selected records are to be printed  *\n*                on SYSPRINT in EBCDIC only (the default is dump    *\n*                format). If an output ddname is present, the       *\n*                selected records will be written to it.            *\n*                                                                   *\n*   SEQUENCE=YES                                                    *\n*                specifies that the input records are in date/time  *\n*                sequence. If 'SEQUENCE=YES' is specified, SMFSLCT  *\n*                will terminate as soon as a record with a date     *\n*                stamp past the 'END=' date/time is encountered.    *\n*                Normal SMFSLCT processing assumes that the input   *\n*                records are not in sequence, and invokes           *\n*                termination at end-of-file.                        *\n*                                                                   *\n*   CHECKVBS=NO                                                     *\n*                specifies that no checking should be performed for *\n*                variable spanned segmentation errors. If this      *\n*                is specified, QSAM will be used to read SYSUT1,    *\n*                and invalid segment sequences will cause an S002   *\n*                (or potentially other system) abend. The default   *\n*                is that BSAM will be used to read VS or VBS files, *\n*                and invalid segments discarded.                    *\n*                Note that using BSAM requires more CPU time; where *\n*                the input file is known to be 'clean', specifying  *\n*                CHECKVBS=NO will reduce the CPU time used by this  *\n*                program.                                           *\n*                                                                   *\n*   JOBNAME=jjjjjjjj                                                *\n*      specifies that all records (subject to \"INCLUDE\"/\"EXCLUDE\",  *\n*                above), Job (or TSU or STC) jjjjjjjj should be     *\n*                selected.                                          *\n*                If more that one jobname is coded, the jobnames    *\n*                should be enclosed in parentheses.                 *\n*                 If the last character in the jobname is an        *\n*                asterisk, the characters preceeding the asterisk   *\n*                considered a prefix, and all jobnames that match   *\n*                the prefix will be selected.                       *\n*                SMF Record Type 5 is used as a model to determine  *\n*                the location of the Jobname field.                 *\n*                                                                   *\n*   DATA=xxx<,nn>                                                   *\n*      specifies the character string that must be present in the   *\n*                input record before it will be selected.           *\n*                DATA= indicates that the string xxx (specified     *\n*                      either as a data(xxx...x), a character string*\n*                      (C'xxx...x) or a hex string(X'xxx...x)) must *\n*                      start at offset position nn (nn=0-32767,     *\n*                      default=0), for the input record to be       *\n*                      selected. Note that the offset must include  *\n*                      the length of the RDW.                       *\n*                                                                   *\n*   JOB/DATA=OR                                                     *\n*      specifies that the selection algorithm should select an      *\n*                      input record if either the Jobname or data   *\n*                      specifications are met. The default is that  *\n*                      both Jobname and data criteria must be       *\n*                      satisfied before a record will be selected.  *\n*                                                                   *\n*   STOPAFT=nnn                                                     *\n*      specifies that SMFSLCT is to terminate after selecting nnn   *\n*                      records (nnn = 1 to 999999999). The default  *\n*                      is to terminate when end-of-file is reached  *\n*                      on input.                                    *\n*                                                                   *\n*   INEXIT=(member-name<,parm>)                                     *\n*      specifies that SMFSLCT is to invoke member-name after        *\n*                      each SMF record is read from the input, and  *\n*                      after checking the date/time against \"START=\"*\n*                      and \"END=\", but before checking any other    *\n*                      selection criteria.                          *\n*                      \"parm\" is an optional string that will be    *\n*                      passed to the exit each time it is invoked.  *\n*                      If present, the operands of INEXIT= must     *\n*                      be enclosed in parentheses. Further, if parm *\n*                      contains a close parenthesis, it must be     *\n*                      enclosed in quotes (as per IBM, if parm also *\n*                      contains a quote, it must be coded as two    *\n*                      two consecutive quotes).                     *\n*                                                                   *\n*   OUTEXIT=(member-name<,parm>)                                    *\n*      specifies that SMFSLCT is to invoke member-name after        *\n*                      an SMF record has been selected, but before  *\n*                      the record is printed and/or written to the  *\n*                      output file(s).                              *\n*                      \"parm\" is an optional string that will be    *\n*                      passed to the exit each time it is invoked.  *\n*                      If present, the operands of OUTEXIT= must    *\n*                      be enclosed in parentheses. Further, if parm *\n*                      contains a close parenthesis, it must be     *\n*                      enclosed in quotes (as per IBM, if parm also *\n*                      contains a quote, it must be coded as two    *\n*                      two consecutive quotes).                     *\n*                                                                   *\n*  Example:                                                         *\n*  //SMFSLCT  JOB blah,blah                                         *\n*  //STEP1   EXEC PGM=SMFSLCT,REGION=6M                             *\n*  //STEPLIB   DD DISP=SHR,DSN=if-required                          *\n*  //SYSPRINT  DD SYSOUT=*                                          *\n*  //SYSUT1    DD DISP=unloaded-man-file,DISP=SHR                   *\n*  //OUT1      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //OUT2      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //OUT3      DD UNIT=SYSALLDA,DISP=(,CATLG,DELETE),               *\n*  //             DSN=output-file1,SPACE=(blah,blah),               *\n*  //             DCB=(blah,blah)                                   *\n*  //SYSIN     DD *                                                 *\n*  START=87015,END=87017-170000                                     *\n*  OUTPUT=OUT1                                                      *\n*   INCLUDE=(30(2),20,5)                                            *\n*   JOBNAME=JOBONE                                                  *\n*   PRINT=NO                                                        *\n*  OUTPUT=OUT2                                                      *\n*   START=87013-081500,END=87013-170000                             *\n*   INCLUDE=34                                                      *\n*   JOBNAME=(TSO1,TSO2)                                             *\n*  OUTPUT=OUT3                                                      *\n*   DATA=C'A B C',257                                               *\n*   OUTEXIT=EXIT5                                                   *\n*  /*                                                               *\n*                                                                   *\n*       SMFSLCT will read the unloaded MAN file specified by SYSUT1.*\n*       Note that if SYSUT1 were not specified, the active MAN      *\n*       file would be read.                                         *\n*       SMFSLCT will ignore any input records produced before       *\n*       00:00:00 on 87.015, and terminate after finding a record    *\n*       produced after 17:00:00 on 87.017.                          *\n*       For the output file specified by DDName OUT1:               *\n*        Record types 5, 20, and 30 subtype 2, for Jobs with the    *\n*        name \"JOBONE\" will be selected, but not printed.           *\n*       For the output file specified by DDName OUT2:               *\n*        Record type 34 for Jobs (TSO users) with the names \"TSO1\"  *\n*        or \"TSO2\" will be selected, and printed.                   *\n*        The global date specification is overridden for this       *\n*        output file only.                                          *\n*       For the output file specified by DDName OUT3:               *\n*        All records containing the character string \"A B C\" in     *\n*        positions 257-261 (relative to 0, including the RDW) will  *\n*        be selected and printed. The exit \"EXIT5\" will be invoked  *\n*        for each record selected for \"OUT3\"                        *\n*                                                                   *\n*       Note that the selection criteria for the different output   *\n*       files are indented: this is for readability only - SMFSLCT  *\n*       ignores leading blanks.                                     *\n*                                                                   *\n*********************************************************************\n         TITLE 'Processing Overview'\n*********************************************************************\n*                                                                   *\n*          P r o c e s s i n g   O v e r v i e w                    *\n*                                                                   *\n*  Initialization.                                                  *\n*     SMFSLCT first opens SYSPRINT - if this file cannot be OPENed  *\n*    SMFSLCT terminates immediately. SYSIN statements (if present)  *\n*    are then read and interpreted. Assuming there were             *\n*    no control card errors, an OPEN is attempted for SYSUT1.       *\n*    If this fails, SYSUT1 is dynamically allocated to the active   *\n*    SMF file, and OPENed. Next, the JFCB for each output DDName is *\n*    read. If the output file is NEW, and DCB characteristics are   *\n*    not present in the JFCB, SMFSLCT assigns the RECFM, LRECL and  *\n*    BLKSIZE from SYSUT1 (if SYSUT1 is a VSAM dataset, RECFM=VBS,   *\n*    LRECL=32767, BLKSIZE=4096 are assigned as a default). If the   *\n*    output dataset is OLD or SHR, no DCB changes are made.         *\n*     If exits were specified, SMFSLCT 'LOAD's them, and saves      *\n*    their EP addresses.                                            *\n*                                                                   *\n*  Processing.                                                      *\n*     A record is read from SYSUT1, and, as long as it is not a dump*\n*    header or trailer (record type 2 or 3), it is checked against  *\n*    the start and stop times. If it is before the start time, the  *\n*    record is ignored, and the next record is read. If it is after *\n*    the stop time, termination is initiated.                       *\n*     After the start and stop time checks, the INEXIT (if present) *\n*    is invoked. If the exit indicates that this record should be   *\n*    selected (RC=4), all further checks are bypassed. If the exit  *\n*    indicates the record should be skipped (RC=8), the record is   *\n*    ignored. If the exit indicates that SMFSLCT should terminate,  *\n*    the stop date and time is set to 0, so that the next input     *\n*    record will cause termination to be invoked. If the exit is    *\n*    not present, or indicates that normal processing should cont-  *\n*    inue (RC=0), the selection criteria are checked.               *\n*     The first selection check is record type (INCLUDE=/EXCLUDE=). *\n*    If the record passes this check, the job name criteria         *\n*    (JOBNAME=) is checked. If the SMF record does not 'belong' to  *\n*    one of the Jobnames specified in the control cards (assuming   *\n*    that at least one Jobname was entered), the record is skipped, *\n*    unless JOB/DATA=OR was specified. If it was, or the SMF record *\n*    passed the Jobname check, the data criteria (DATA=) are exam-  *\n*    ined. If the data specified are present in the SMF record, the *\n*    record will be selected.                                       *\n*     Once an input record is selected, the output exit (OUTEXIT=), *\n*    if present, is invoked. This exit can indicate that the record *\n*    should be ignored (RC=8), that processing should terminate     *\n*    after this record (RC=12), or that normal processing should    *\n*    continue (RC=0).                                               *\n*     A selected record is first printed (unless PRINT=NO was       *\n*    specified in the control cards), either in the default dump    *\n*    format, or in EBCDIC only (PRINT=EBCDIC). Then, if output files*\n*    are open, the selected record is written to them. The output   *\n*    record length is checked against the input, and the input rec- *\n*    ord truncated or padded with blanks as appropriate. If the     *\n*    output RECFM is fixed, the SMF record is written without the   *\n*    RDW.                                                           *\n*                                                                   *\n*  Termination.                                                     *\n*     Termination is invoked either because an input SMF record's   *\n*    date and time is greater than the stop date and time, or       *\n*    because EOF was reached on the input file. The counters are    *\n*    printed, and all open files are closed. The exits are invoked  *\n*    one last time, and then deleted. All getmained storage is      *\n*    freed, and standard exit code is executed to return to OS.     *\n*                                                                   *\n*********************************************************************\n         TITLE 'User Exits'\n*********************************************************************\n*                                                                   *\n*     SMFSLCT has provision for two exits that will be invoked      *\n*    after a record is read, or a record is about to be written.    *\n*    Each exit receives the address of the SMF record as a parm.    *\n*    The exits can cause the SMF record to be selected or ignored   *\n*    (via the return codes), or can modify (or replace) the SMF     *\n*    record. The only restriction is that the record returned to    *\n*    SMFSLCT must remain a valid variable-length record.            *\n*                                                                   *\n*     SMFSLCT also provides to each exit a word of storage that the *\n*    exit can use in any manner whatsoever - SMFSLCT will not alter *\n*    the contents of this word (other than to initialize it to 0    *\n*    before the first invocation of the exit).                      *\n*                                                                   *\n*     The exits are LOADed at initialization, invoked via a BASR    *\n*    instruction at various points in the processing, and then      *\n*    DELETEd during termination. 'Global' exits (those that are     *\n*    named by INEXIT=/OUTEXIT= statements before any OUT= statement)*\n*    are LOADED only once; 'local' exits (those named after an      *\n*    OUT= statement, even if they are the same as the 'global'      *\n*    exits) are LOADed for each output statement. Thus, if an exit  *\n*    is not reusable, there may be multiple versions LOADed and     *\n*    invoked.                                                       *\n*                                                                   *\n*     The names of the exits are specified with the \"INEXIT=\" and   *\n*    \"OUTEXIT=\" control statement keywords (see above). The exits   *\n*    are invoked once for each output file, at 3 different points:  *\n*      Initialization: A(SMF Record) = 0                            *\n*                      Input count = -1                             *\n*      Processing    : A(SMF Record) > 0                            *\n*      Termination   : A(SMF Record) = 0                            *\n*                      Input Count >= 0                             *\n*                                                                   *\n*     The parms passed to the exits are the same for both INEXIT    *\n*    and OUTEXIT (all parameters reside below-the-line):            *\n*        R1 ---> A(SMF record) or 0                                 *\n*                                                                   *\n*                A(A word for the user)                             *\n*                  This word is 'output-file specific'; that is,    *\n*                  the same word will be passed to the INEXIT and   *\n*                  the OUTEXIT for the same output file (ie, when   *\n*                  the 6th parm, the address of the DDName, is      *\n*                  pointing to the same value). For different output*\n*                  files, a different word is passed.               *\n*                                                                   *\n*                A(HL2'length', parm as coded on the xxxEXIT=       *\n*                  statement. Note that the length is the length of *\n*                  the parm, and that any quotes surrounding the    *\n*                  parm have been removed)                          *\n*                                                                   *\n*                A(Fullword containing input count)                 *\n*                                                                   *\n*                A(Fullword containing output count)                *\n*                                                                   *\n*                A(DDName of output file)                           *\n*                                                                   *\n*                A(SYSPRINT routine. This routine can be invoked to *\n*                  cause SMFSLCT to write a record to SYSPRINT. If  *\n*                  this routine is invoked,                         *\n*                   R1 : A(2-word parmlist):                        *\n*                          A(Data to be printed)                    *\n*                          Length of data to be printed             *\n*                   R13: A(Standard 72-byte O/S save area)          *\n*                   R14: Return Address                             *\n*                   R15: EPA                                        *\n*                  This routine is also IDENTIFYed as SMFSLCTP, and *\n*                 so can be CALLed, LINKed, etc.                    *\n*                                                                   *\n*  INEXIT.                                                          *\n*     The input exit is specified using the \"INEXIT=\" control       *\n*    statement keyword, and is invoked after each SMF record is     *\n*    read and determined to be within the start and end times       *\n*    specified in the control cards (\"START=\", \"END=\"). The exit    *\n*    receives the address of the SMF record as a parm, and can      *\n*    modify the contents of the record, if required. If the exit    *\n*    wishes to replace the SMF record with another, the exit can    *\n*    change the address in the pointer to the SMF record so that it *\n*    points to a different area of storage, containing the new SMF  *\n*    record.                                                        *\n*     Note that the input exit is invoked (perhaps non-intuitively) *\n*    for each output file.                                          *\n*                                                                   *\n*     On Exit,                                                      *\n*        R15  =  0, Continue normal processing                      *\n*                4, Unconditionally select this record              *\n*                8, Ignore this record                              *\n*               12, Terminate SMFSLCT after this record             *\n*                                                                   *\n*  OUTEXIT.                                                         *\n*     The output exit is specified using the \"OUTEXIT=\" control     *\n*    statement keyword, and is invoked after an SMF record has been *\n*    selected (because it satisfied selection criteria, or it was   *\n*    unconditionally selected by the input exit). The exit          *\n*    receives the address of the SMF record as a parm, and can      *\n*    modify the contents of the record, if required. If the exit    *\n*    wishes to replace the SMF record with another, the exit can    *\n*    change the address in the pointer to the SMF record so that it *\n*    points to a different area of storage, containing the new SMF  *\n*    record.                                                        *\n*     On Exit,                                                      *\n*        R15  =  0, Continue normal processing                      *\n*                4, Unused                                          *\n*                8, Ignore this record                              *\n*               12, Terminate SMFSLCT after this record             *\n*                                                                   *\n*********************************************************************\n         TITLE 'STACK Macro'\n         MACRO\n&NAME    STACK &TYPE,&LOC=,&LEN=,&STACK=,&ADDR=\n         LCLC  &LENREG,&STKREG,&ADDREG,&LOCTN\n         AIF   ('&TYPE(1)' EQ 'PUSH').PUSH01\n         AIF   ('&TYPE(1)' EQ 'POP').POP01\n         AIF   ('&TYPE(1)' EQ 'INIT').INIT01\n         AIF   ('&TYPE(1)' EQ 'TERM').TERM01\n         MNOTE 8,'TYPE must be INIT, PUSH, POP, or TERM'\n         AGO   .MEND\n.*\n.INIT01  ANOP\n         AIF   ('&LEN' EQ '').INITE01\n         AIF   ('&LEN'(1,1) NE '(').INIT02\n&LENREG  SETC  '&LEN(1)'\n         AIF   ('&LENREG' NE  '1').INIT03\n         MNOTE 8,'LEN= register must be 0 or 2-15'\n         AGO   .MEND\n         AGO   .INIT03\n.INIT02  ANOP\n&LENREG  SETC  'R0'\n         LA    &LENREG,&LEN Length of Stack\n.INIT03  ANOP\n&LOCTN   SETC  '&LOC'\n         AIF   ('&LOC' NE '').INIT04\n&LOCTN   SETC  'ANY'\n.INIT04  ANOP\n         LA    R1,StackHdr_Length       Length of header\n         AR    &LENREG,R1               Bump length\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(&LENREG),         this long                     +\n               LOC=&LOCTN                anywhere\n         ST    R0,StackHdr_StackLen-StackHdr(0,R1) Save length\n         LA    R0,StackHdr_Length(0,R1) A(Current top of stack)\n         ST    R0,StackHdr_NAB-StackHdr(0,R1) Save A(Next Avail Byte)\n         AIF   ('&STACK' EQ '').INIT99\n         AIF   ('&STACK'(1,1) EQ '(').INIT92\n         ST    R1,&STACK                Save Stack origin\n         AGO   .INIT99\n.INIT92  ANOP\n         LR    &STACK(1),R1             Load return register\n         AGO   .INIT99\n.INIT99  ANOP\n         AIF   (D'Stack).MEND\nStack               DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This is a LIFO stack that is used by various procedures in the  *\n*  program to acquire storage. The Stack is GETMAINed at the beg-   *\n*  inning of the program, and is typically used by procedures to    *\n*  acquire storage for local variables (i.e., variables that are    *\n*  used only within the procedures), although the main procedure    *\n*  also uses a stack area to store Global variables (i.e., those    *\n*  that are available throughout the program).                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nStackHdr            EQU   *           Start of Header\nStackHdr_StackLen   DS    FL4          Length of Stack\nStackHdr_NAB        DS    AL4          A(Next Available Byte in Stack)\nStackHdr_Length     EQU   *-StackHdr  Length of Header\n\n&SYSECT  &SYSSTYP\n         AGO   .MEND\n.INITE01 ANOP\n         MNOTE 8,'LEN must be specified for STACK INIT'\n         AGO   .MEND\n.*\n.PUSH01  ANOP\n         AIF   ('&STACK' EQ '').PUSM02\n         AIF   ('&STACK'(1,1) NE '(').PUSH01A\n&STKREG  SETC  '&STACK(1)'\n         AGO   .PUSH02\n.PUSH01A ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.PUSH02  ANOP\n         AIF   ('&LEN' EQ '').PUSHE01\n         AIF   ('&LEN'(1,1) NE '(').PUSH03\n&LENREG  SETC  '&LEN(1)'\n         AGO   .PUSH04\n.PUSH03  ANOP\n&LENREG  SETC  'R0'\n.PUSH04  ANOP\n         LA    &LENREG,&LEN\n         LA    R1,7                     Make\n         AR    &LENREG,R1                a\n         SRL   &LENREG,3                 doubleword\n         SLL   &LENREG,3                 multiple\n         L     R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         AR    R1,&LENREG               Bump by length requested\n         SLR   R1,&STKREG               Get Stack used\n         C     R1,StackHdr_StackLen-StacKHdr(0,&STKREG) Too much?\n         BL    *+8                      No, OK\n         BAL   R14,0                    ABEND\n         ALR   R1,&STKREG               No, offset to address\n         ST    R1,StackHdr_NAB-StackHdr(0,&STKREG) A(Next Avail Byte)\n         SLR   R1,&LENREG               A(Start of storage area)\n         AIF   ('&ADDR' EQ '').MEND\n         AIF   ('&ADDR'(1,1) NE '(').PUSH92\n         LR    &ADDR(1),R1             Load return register\n         AGO   .MEND\n.PUSH92  ANOP\n         ST    R1,&ADDR                 Save Stack origin\n         AGO   .MEND\n.PUSHE01 ANOP\n         MNOTE 8,'LEN must be specified for STACK PUSH'\n         AGO   .MEND\n.PUSHE02 ANOP\n         MNOTE 8,'STACK must be specified for STACK PUSH'\n         AGO   .MEND\n.*\n.POP01   ANOP\n         AIF   ('&ADDR' EQ '').POPE01\n         AIF   ('&ADDR'(1,1) NE '(').POP02\n&ADDREG  SETC  '&ADDR(1)'\n         AGO   .POP02A\n.POP02   ANOP\n&ADDREG  SETC  'R0'\n         L     &ADDREG,&ADDR\n.POP02A  ANOP\n         AIF   ('&STACK' EQ '').POPE02\n         AIF   ('&STACK'(1,1) NE '(').POP03\n&STKREG  SETC  '&STACK(1)'\n         AGO   .POP04\n.POP03   ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.POP04   ANOP\n         ST    &ADDREG,StackHdr_NAB-StackHdr(0,&STKREG)\n         AGO   .MEND\n.POPE01  ANOP\n         MNOTE 8,'ADDR must be specified for STACK POP'\n         AGO   .MEND\n.POPE02  ANOP\n         MNOTE 8,'STACK must be specified for STACK POP'\n         AGO   .MEND\n.*\n.TERM01  ANOP\n         AIF   ('&STACK' EQ '').TERME02\n         AIF   ('&STACK'(1,1) NE '(').TERM03\n&STKREG  SETC  '&STACK(1)'\n         AGO   .TERM04\n.TERM03  ANOP\n&STKREG  SETC  'R15'\n         L     &STKREG,&STACK           A(Stack Origin)\n.TERM04  ANOP\n         L     R0,StackHdr_StackLen-StackHdr(0,&STKREG) Length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(&STKREG),           starting here                 +\n               LENGTH=(0)                for this long\n         AGO   .MEND\n.TERME02 ANOP\n         MNOTE 8,'STACK must be specified for STACK TERM'\n         AGO   .MEND\n.*\n.MEND    ANOP\n         MEND\n         TITLE 'IBM DSECTs'\n         PUSH  PRINT\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IKJTCB\n         IEFTIOT1\n         IEESMCA\n         IEFJFCBN\n         DCBD  DSORG=PS\n         IHADCBE\n         IHADVA\n         IEFUCBOB DEVCLAS=DA,LIST=NO\n         IEFZB505 LOCEPAX=YES\n         IEFJESCT\n         IEFQMIDS\n         IFASMFR (0,5,30)\n         IFGACB\nSYSUT1_ACB_Length EQU   *-IFGACB      Length of ACB\n         IFGRPL\nSYSUT1_RPL_Length EQU   *-IFGRPL      Length of RPL\n         IEFZB4D0\n         IEFZB4D2\n         POP   PRINT\n         TITLE 'Local DSECTs'\nOutDesc_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Output Descriptor Table contains one entry for each output  *\n*  file specified (in the \"OUTPUT=\" control card). Each entry is    *\n*  initialized with the default parameters, and then modified with  *\n*  the parameters entered via control cards. The first entry con-   *\n*  tains the default parms, and is used as the \"global\" entry.      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nODT_SubPool_Nbr     EQU   0           Subpool for this table\nODT_Subp_Len        DS    0F          Length and Subpool of table\nODT_SubPool         DS    X            SubPool\nODT_Length          DS    FL3          Length\nODT_Entry_Count     DS    HL2         Nbr entries in the table\nODT_Entry           EQU   *           Table Entry\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Output Descriptor Entry. There is one entry for each output    *\n*   file (defined using the \"OUTPUT=\" statement), plus one entry    *\n*   (the first) used as a default entry.                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nODTE_DCB_Ptr        DS    AL4          A(Output DCB)\nODTE_DDName         DS    CL8          Associated DDName\nODTE_RTT_Ptr        DS    AL4          A(Record Type Table)\nODTE_JNT_Ptr        DS    AL4          A(JobName Table)\nODTE_DT_Ptr         DS    AL4          A(Data Table)\nODTE_Selected       DS    FL4          Nbr Records Selected\nODTE_StopAft        DS    FL4          Stop after selecting this many\nODTE_InExit         DS    CL8          Input Exit Name\nODTE_InExit_Ptr     DS    AL4          A(Input Exit)\nODTE_InExit_Data    DS    FL4          Input Exit Data Area\nODTE_InExit_Parm_Ptr DS   AL4          A(Parm data for InExit)\nODTE_OutExit        DS    CL8          Output Exit Name\nODTE_OutExit_Ptr    DS    AL4          A(Output Exit)\nODTE_OutExit_Data   DS    FL4          Output Exit Data Area\nODTE_OutExit_Parm_Ptr DS  AL4          A(Parm data for OutExit)\nODTE_LRECL          DS    HL2          Max Output Record Length\nODTE_StartDate      DS    PL4          Start Date\nODTE_StartTime      DS    FL4            and Time\nODTE_EndDate        DS    PL4          End Date\nODTE_EndTime        DS    FL4            and Time\nODTE_PeriodStart    DS    FL4          Period Start Time\nODTE_PeriodEnd      DS    FL4          Period End Time\n                    DS    X            Flag Byte\nODTE_Print_NO       EQU   *-1,X'80'     1... .... PRINT=NO Specified\nODTE_Print_EB       EQU   *-1,X'40'     .1.. .... PRINT=EBCDIC Spec\nODTE_JobData_OR     EQU   *-1,X'20'     ..1. .... JOB/DATA=OR\nODTE_Trunc          EQU   *-1,X'10'     ...1 .... Output Rec Truncated\nODTE_CopyOnly       EQU   *-1,X'08'     .... 1... No selection criteria\nODTE_Inactive       EQU   *-1,X'04'     .... .1.. Inactive Entry\nODTE_Ignore_Weekend EQU   *-1,X'02'     .... ..1. WEEKEND=IGNORE\n                    DS    X            Flag Byte\nODTE_No_Dflt_InExit EQU   *-1,X'80'     1... .... Do not use default\nODTE_No_Dflt_OutExit EQU  *-1,X'40'     .1.. .... Do not use default\n\nODTE_Output_Count_Table DS  256FL4     Selected count by record type\n\nODTE_Length         EQU   *-ODT_Entry  Entry Length\n\n\n\nJobName_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The JobName Table is built when it is determined that the user  *\n*  wishes to select input records by jobname. The table             *\n*  consists of a header portion (describing the table as a whole),  *\n*  and then one entry for each valid jobname control card found.    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nJNT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE\nJNT_Subpool         DS    X            SUBPOOL\nJNT_Length          DS    FL3          LENGTH\nJNT_Entry_Count     DS    HL2          NBR ENTRIES IN THE TABLE\nJNT_Entry           EQU   *            DATA ENTRY\nJNTE_JobName_Len    DS    X             EXECUTE LENGTH OF JOBNAME/PFX\nJNTE_JobName        DS    CL8           JOBNAME, PADDED WITH BLANKS\nJNTE_Length         EQU   *-JNT_Entry\n\n\n\nRecType_Tbl         DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   THE RECORD TABLE IS BUILT WHEN IT IS DETERMINED THAT THE USER   *\n*  WISHES TO INCLUDE OR EXCLUDE RECORDS BY RECORD TYPE. EACH ENTRY  *\n*  CONSISTS OF TWO BYTES, A RECORD TYPE AND A SUBTYPE. All entries  *\n*  are either 'INCLUDE's or 'EXCLUDE's, as indicated by a flag in   *\n*  the header of the table.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nRTT_Subp_Len        DS    0F          LENGTH AND SUBPOOL OF TABLE\nRTT_Subpool         DS    X            SUBPOOL\nRTT_Length          DS    FL3          LENGTH\nRTT_Entry_Count     DS    HL2         NBR ENTRIES IN TABLE\n                    DS    X           Flag byte\nRTT_Entry_Include   EQU   *-1,X'80'    1... .... INCLUDE=\nRTT_Entry_Exclude   EQU   *-1,X'40'    .1.. .... EXCLUDE=\n                    DS    X           Reserved\nRTT_Entry           EQU   *           RECORD TABLE ENTRY\nRTTE_RecType        DS    X            RECORD TYPE\n                    DS    X            Flag Byte\nRTTE_SubType_Present EQU  *-1,X'80'     1... .... Subtype present\nRTTE_SubType        DS    XL2          SUBTYPE\nRTTE_Length         EQU   *-RTT_Entry Entry length\n\n\n\nData_Tbl            DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Data Table is built when it is determined that the user     *\n*  wishes to select input records by data in the record. The table  *\n*  consists of a header portion (describing the table as a whole),  *\n*  and then one entry for each valid 'data' control statement       *\n*  found, containing:                                               *\n*                     - the offset at which the data must be found  *\n*                       before the record will be selected,         *\n*                     - the execute length of the data, and         *\n*                     - the data.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nDT_Subp_Len         DS    0F          LENGTH AND SUBPOOL OF TABLE\nDT_Subpool          DS    X            SUBPOOL\nDT_Length           DS    FL3          LENGTH\nDT_Entry_Count      DS    HL2         NBR ENTRIES IN THE TABLE\nDT_Entry            EQU   *           DATA ENTRY\nDTE_Offset          DS    HL2          OFFSET OF DATA\nDTE_Length          DS    X            EXECUTE LENGTH OF DATA\nDTE_Data            EQU   *            DATA\n\n\nBuffArea            DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   The Buffer Area is used only when SYSUT1 is VS or VBS, and      *\n*  non-VSAM. Under these circumstances, we use BSAM to read blocks  *\n*  of SYSUT1, and assemble the records ourselves, so we can discard *\n*  any invalidly-spanned segments.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nBuffArea_Next_Ptr   DS    AL4         A(Next Buffer Area)\nBuffArea_DECB_Ptr   DS    AL4         A(DECB - Below-the-Line)\nBuffArea_Offset     DS    FL4         Offset within BuffArea_IOArea\nBuffArea_Seg_Count  DS    FL4         Segment nbr in curr block\nBuffArea_IOArea     EQU   *           I/O Area for Read\nBuffArea_Hdr_Length EQU   *-BuffArea  Length of Header info\n\n\n\nDateConv_Area       DSECT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   This DSECT describes the Date Conversion parameters used to     *\n*  make SMF Dates and Times useable                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    X           Input Descriptor Flag\nDConv_Input_Julian  EQU   *-1,X'80'    1... .... Input in YYYY and DDD\nDConv_Input_Base    EQU   *-1,X'40'    .1.. .... Input in Base date\nDConv_Input_YYMMDD  EQU   *-1,X'20'    ..1. .... Input in YYYY,MM,DD\nDConv_Input_YYMonDD EQU   *-1,X'10'    ...1 .... Input in YYYY,Month,DD\nDConv_Input_SMFDate EQU   *-1,X'08'    .... 1... Input in SMFDate\nDConv_Input_Time    EQU   *-1,X'02'    .... ..1. Input in Time\nDConv_Input_hhmmss  EQU   *-1,X'01'    .... ...1 Input in hh, mm, ss\n\nDConv_Date_SMFDate  DS    PL4         SMF Date Stamp\nDConv_Date_YYYY     DS    HL2         Year (including century)\nDConv_Date_DDD      DS    HL2         Day-of-year\nDConv_Date_Base     DS    FL4         Days since Jan1,0001 (a la REXX)\nDConv_Date_MM       DS    XL1         Month number (1-12)\nDConv_Date_DD       DS    XL1         Day-of-month (1-31)\nDConv_Date_Month    DS    CL9         Month name (January, February ..)\nDConv_Date_Day      DS    CL9         Day Name (Monday, Tuesday, etc.)\nDConv_Date_DOW      DS    XL1         Day-of-week (Mon=0, Tue=1, etc.)\n\nDConv_Time          DS    FL4         Time (secs*100 since midnight)\nDConv_Time_hh       DS    XL1         Hours       (0-23)\nDConv_Time_mm       DS    XL1         Minutes     (0-59)\nDConv_Time_ss       DS    XL1         Seconds     (0-59)\nDConv_Time_tt       DS    XL1         Seconds/100 (0-99)\nDConv_Area_Length   EQU   *-DateConv_Area  Length of area\n\n         TITLE 'Global Dynamic Storage'\n@_Dynam  DSECT\n\n@_31Bit_Stack_Ptr   DS    AL4         A(Stack storage above-the-line)\n@_31Bit_Stack_Len   EQU   4096-StackHdr_Length  4K Stack\n\n@_24Bit_Stack_Ptr   DS    AL4         A(Stack storage below-the-line)\n@_24Bit_Stack_Len   EQU   2048-StackHdr_Length  2K Stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSPRINT-related info                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n@_SYSPRINT_DCB_Ptr  DS    AL4         A(SYSPRINT DCB)\n@_SYSPRINT_Rec_Ptr  DS    AL4         A(SYSPRINT RECORD)\n@_SYSPRINT_Rec_Len  DS    HL2         SYSPRINT RECORD LENGTH (LESS ASA)\n@_SYSPRINT_Y0010_Ptr DS   AL4         A(Copy of Y0010)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1-related info                                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_SYSUT1_DCB_Ptr    DS    AL4         A(SYSUT1 DCB)\n                    ORG   @_SYSUT1_DCB_Ptr\n@_SYSUT1_ACB_Ptr    DS    AL4         A(SYSUT1 ACB)\n                    ORG   ,\n@_SYSUT1_Rec_Ptr    DS    AL4         A(Input record)\n@_SYSUT1_AtL_Ptr    DS    AL4         A(Above-the-line storage)\n@_SYSUT1_BtL_Ptr    DS    AL4         A(Below-the-line storage)\n@_SYSUT1_Rec_Length DS    FL4         Input record length\n@_SYSUT1_BuffArea_Ptr DS  AL4         A(Current buffer area - BSAM)\n@_SYSUT1_PBlock_Count DS  FL4         Physical Block Count - BSAM\n                    ORG   @_SYSUT1_BuffArea_Ptr\n@_SYSUT1_RPL_Ptr    DS    AL4         A(SYSUT1 RPL - VSAM)\n                    ORG   ,\n\n                    DS    X           Flag byte\n@_SYSUT1_VSAM       EQU   *-1,X'80'    1... .... SYSUT1:  VSAM\n@_SYSUT1_QSAM       EQU   *-1,X'40'    .1.. .... SYSUT1:  QSAM\n@_SYSUT1_BSAM       EQU   *-1,X'20'    ..1. .... SYSUT1:  BSAM\n@_SYSUT1_Sequence   EQU   *-1,X'10'    ...1 .... Input is in sequence\n@_SYSUT1_NoVBSChk   EQU   *-1,X'08'    .... 1... No VBS checking\n@_SYSUT1_Seg_Error  EQU   *-1,X'01'    .... ...1 Segments dropped\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Output-related fields                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_ODT_Ptr           DS    AL4         A(Output Descriptor Table)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Counters and Date/Times                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n                    DS    0F\n@_Line_Count        DS    HL2         LINE COUNT\n@_Page_Count        DS    PL2         PAGE COUNT\n@_Input_Count       DS    FL4         INPUT COUNTER\n\n@_Dump_Start_Date   DS    PL4         SMF Dump Start Date\n@_Dump_Start_Time   DS    FL4                    and Time\n@_Dump_End_Date     DS    PL4         SMF Dump End Date\n@_Dump_End_Time     DS    FL4                  and Time\n@_First_Rec_Date    DS    PL4         First Record Date\n@_First_Rec_Time    DS    FL4                  and Time\n@_Input_Rec_Date    DS    PL4         Current Record Date\n@_Input_Rec_Time    DS    FL4                    and Time\n\n@_Prev_Input_Rec_Date DS  PL4         Previous record date\n@_Prev_Input_Rec_DOW DS   X           Previous record Day-of-Week\n\n@_DateConv_Area     DS    CL(DConv_Area_Length)  Todays Date Info\n\n@_Input_Count_Table DS    256FL4      Input count by SMF Record Type\n\n         DS    0D                     ALIGNMENT\n@_DynLen EQU   *-@_Dynam               LENGTH OF STORAGE\n         TITLE 'Register Equates'\n         YREGS\n         TITLE 'A0010: Main Program Block'\nSMFSLCT  RMODE ANY\nSMFSLCT  AMODE 31\n\nSMFSLCT  RSECT\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : A0010                                                  *\n*                                                                     *\n*  Abstract  : Main program loop:                                     *\n*               Perform Initialization                                *\n*               Do until SYSUT1 EOF, or all criteria satisfied        *\n*                 Read SYSIN                                          *\n*                 Do for each appropriate output                      *\n*                   Write to output                                   *\n*                 EndDo                                               *\n*               Perform Termination                                   *\n*                                                                     *\n*                                                                     *\n*  Inputs    : Files:                                                 *\n*               SYSUT1  : Input SMF File (Dynamically allocated if    *\n*                                         not present in JCL)         *\n*               SYSIN   : Control Cards                               *\n*               SYSPRINT: Listing                                     *\n*              Parms: N/A                                             *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nA0010    DS    0H\n         USING *,R15                  ASSIGN TEMPORARY BASE\n         SAVE  (14,12),T,'SMFSLCT &VERSION  &ASMDT &SYSTIME'\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING A0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some storage for our LIFO stack ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,=AL4(@_31Bit_Stack_Len) Get length of storage we need\n         STACK INIT,                    Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=ANY                   anywhere\n         LR    R2,R1                    Save its address\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and get some room on it for the globally addressable       *\n*     variables ...                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@_DynLen,             this long                     +\n               STACK=(R2)                using this stack\n         LR    R12,R1                   Point to our storage\n\n         USING @_Dynam,R12              Assign a base\n\n         LA    R0,@_Dynam               A(Our storage)\n         LA    R1,@_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n\n         ST    R2,@_31Bit_Stack_Ptr     Save A(Stack)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and finally get an area on it for our local storage        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@A_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@A_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @A_DYNAM,R13             Assign a base\n         L     R15,@A_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the 24-bit stack                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,=AL4(@_24Bit_Stack_Len) Get length of storage we need\n         STACK INIT,                    Go get our storage             +\n               LEN=(R0),                 this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R1,@_24Bit_Stack_Ptr     Save its address\n\n         L     R15,@A_Dynam+4           Get A(HSA)\n         LM    R0,R1,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Perform our Initialization Routines                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(B0010)        A(Initialization Routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                How did it go?\n         BNZ   A9000                  Not so well, exit\n\nA1000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Start of main program loop:                                    *\n*      Get an input record                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(C0010)        A(SYSUT1 Read routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                How did it go?\n         BNZ   A9000                  Not so well, exit\n         L     R1,@_SYSUT1_Rec_Ptr    OK, get A(Input Record)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Indicate that we haven't printed the record yet, in case it    *\n*   is selected more than once.                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @A_Rec_Printed,X'FF'-L'@A_Rec_Printed OFF Printed Flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go through the Output Descriptor Table, seeing if this record  *\n*   will satisfy any of the criteria.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         USING ODT_Entry,R10           and assign a base\n         OI    @A_All_Done,L'@A_All_Done Assume all ODTEs inactive\nA1010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is an active entry ...                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Inactive,L'ODTE_Inactive ACTIVE ENTRY?\n         BO    A1250                   NO, SKIP\n         NI    @A_All_Done,X'FF'-L'@A_All_Done Reset flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... check the date and time of the input record against the    *\n*   start and end date/time criteria.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_CopyOnly,L'ODTE_CopyOnly Any selection criteria?\n         BO    A1200                  No, select the record\n         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?\n         BE    A1040                  YES, SKIP DATE/TIME CHECK\n         CLI   SMF0RTY-SMFRCD0(R1),X'03' NO, DUMP TRAILER?\n         BE    A1040                  YES, SKIP DATE/TIME CHECK\n         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_StartDate CHECK DATE\n         BL    A1250                  DON'T WANT THIS ONE, SKIP\n         BH    A1020                  AFTER START DATE, SKIP TIME CHK\n         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME\n         C     R15,ODTE_StartTime     DO WE WANT THIS ONE?\n         BL    A1250                  NO, GET ANOTHER ONE\nA1020    DS    0H\n         CP    SMF0DTE-SMFRCD0(L'SMF0DTE,R1),ODTE_EndDate PAST END?\n         BH    A1030                  YES, CHECK SEQUENCE\n         BL    A1040                  BEFORE END DATE, SKIP TIME CHK\n         L     R15,SMF0TME-SMFRCD0(R1) GET INPUT TIME\n         C     R15,ODTE_EndTime       BEFORE END TIME?\n         BNH   A1040                  YES, CONTINUE\nA1030    DS    0H\n         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?\n         BO    A1240                  YES, INACTIVATE THIS ENTRY\n         B     A1250                  NO, IGNORE THIS RECORD\nA1040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we are ignoring weekends, check it out                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend\n         BZ    A1060                  No, continue\n         CP    @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         BE    A1050                  Same date as prev, skip\n         XC    @A_DateConv_Area,@A_DateConv_Area No, clear Date area\n         MVC   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(R1) Move SMF Date\n         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate      Indicate SMF Date\n         LA    R1,@A_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Day-of-Week\n         L     R1,@_SYSUT1_Rec_Ptr   Restore A(Input Record)\n         ZAP   @_Prev_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @_Prev_Input_Rec_DOW,@A_DateConv_Area+DConv_Date_DOW-Dat+\n               eConv_Area            Save Day-of-week\nA1050    DS    0H\n         CLI   @_Prev_Input_Rec_DOW,X'04' Is DOW greater than Friday?\n         BH    A1250                 Yes, ignore this record\nA1060    DS    0H\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Start and End Date/Times are OK, check against the Period      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,SMF0TME-SMFRCD0(R1) GET THE TIME OF THE SMF REC\n         C     R15,ODTE_PeriodStart   BEFORE PERIOD START?\n         BL    A1250                  YES, IGNORE IT\n         C     R15,ODTE_PeriodEnd     NO, AFTER PERIOD END?\n         BH    A1250                  YES, SKIP IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Invoke the User Exit INEXIT, if there is one.                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_InExit_Ptr Get A(Input Exit)\n         BZ    A1070                  None, skip\n         SLR   R0,R0                  Yes, flag as an Inexit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         LTR   R15,R15                Check return code\n         BZ    A1070                  OK, continue normally\n         CH    R15,=H'8'              Something else, check it out\n         BL    A1200                  Select this record\n         BE    A1250                  Ignore it\n         ZAP   ODTE_EndDate,=P'0'     Clear End Date and Time so we\n         XC    ODTE_EndTime,ODTE_EndTime finish after this record\nA1070    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check this record against any record types specified ...       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_RTT_Ptr Get A(Record Table)\n         BZ    A1130                  None, don't check it\n         LH    R14,RTT_Entry_Count-RecType_Tbl(R15) Get nbr entries\n         LA    R15,RTT_Entry-RecType_Tbl(R15) and point to the first\n         SLR   R4,R4                  Clear R4\n         SLR   R5,R5                  R5 too\nA1080    DS    0H\n         CLC   SMF0RTY-SMFRCD0(L'SMF0RTY,R1),RTTE_RecType-RTT_Entry(R15+\n               ) Is this our record?\n         BE    A1100                  Yes, skip\nA1090    DS    0H\n         LA    R15,RTTE_Length(R15)   No, A(Next entry in table)\n         BCT   R14,A1080              and try again\n         B     A1120                  Not our record, skip\nA1100    DS    0H\n         TM    RTTE_SubType_Present-RTT_Entry(R15),L'RTTE_SubType_Prese+\n               nt                     SubType present?\n         BNO   A1110                  No, found our record\n         CLC   SMF30STP-SMFRCD30(L'SMF30STP,R1),RTTE_SubType-RTT_Entry(+\n               R15)                   Yes, our subtype?\n         BNE   A1090                  No, try again\nA1110    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and include or exclude it as required                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr       Get A(Record Table)\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    A1250                  EXCLUDEing, skip\n         B     A1130                  No, continue\nA1120    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    This record is not in the Record Type Table - we must check the*\n*    exclude indicator to see what we should do with it.            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr       Get A(Record Table)\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    A1130                  Yes, include this record\n         B     A1250                  No, skip it\nA1130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check this record for JobName selection.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JobName Table)\n         BZ    A1170                  None, skip\n*        CLI   SMF30RTY-SMFRCD30(R1),70 RMF record?\n*        BL    A1140                  No, skip\n*        CLI   SMF30RTY-SMFRCD30(R1),79 Really?\n*        BNH   A1170                  Yes, skip jobname check\nA1140    DS    0H\n         LH    R14,JNT_Entry_Count-JobName_Tbl(R15) Nbr entries\n         LA    R15,JNT_Entry-JobName_Tbl(R15) And point to first\n         LA    R2,SMF5JBN-SMFRCD5(R1) A(JobName in SMF record)\n         CLI   SMF30RTY-SMFRCD30(R1),30 Type 30 record?\n         BNE   A1150                  No, skip\n         L     R2,SMF30IOF-SMFRCD30(R1) Yes, offset to ID section\n         AR    R2,R1                  and point to JobName\nA1150    DS    0H\n         SLR   R3,R3                   Clear EX register\n         IC    R3,JNTE_JobName_Len-JNT_Entry(R15) Len of JobName Mask\n         EX    R3,A9999               Check JobNameE\n         BNE   A1160                  Not us, skip\n         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?\n         BO    A1200                  Yes, Select this record\n         B     A1170                  No, go check Data Table\nA1160    DS    0H\n         LA    R15,JNTE_Length(R15)   A(Next Entry)\n         BCT   R14,A1150              and try again\n         TM    ODTE_JobData_OR,L'ODTE_JobData_OR JOB/DATA=OR?\n         BNO   A1250                  No, skip this record\n         ICM   R15,B'1111',ODTE_DT_Ptr Yes, get A(Data Table)\n         BZ    A1250                  None, skip this record\nA1170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check for Data selection                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_DT_Ptr Get A(Data Table)\n         BZ    A1200                  None, select this record\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) Yes, get nbr entries\n         LA    R15,DT_Entry-Data_Tbl(R15) and point to the first\n         SLR   R3,R3                  Clear work register\nA1180    DS    0H\n         LH    R2,DTE_Offset-DT_Entry(R15) Offset of data\n         IC    R3,DTE_Length-DT_Entry(R15) EX length if data\n         LA    R4,0(R2,R3)            Offset of last char\n         CH    R4,SMF0LEN-SMFRCD0(R1) Is the record long enough?\n         BH    A1190                  No, data does not match\n         AR    R2,R1                  Yes, A(Offset)\n         EX    R3,A9998               Check the data\n         BE    A1200                  Found it, skip\nA1190    DS    0H\n         LA    R15,1+DTE_Data-DT_Entry(R3,R15) A(Next Entry)\n         BCT   R14,A1180              and check it\n         B     A1250                  Not found, skip this record\nA1200    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    This record has satisfied all the selection criteria for this  *\n*   output file, so invoke the user exit                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_OutExit_Ptr Get A(Output Exit)\n         BZ    A1210                  None, skip\n         LA    R0,1                   Yes, flag as an Outexit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         CH    R15,=H'8'              Check return code\n         BH    A1240                  Inactivate this ODT entry\n         BE    A1250                  Ignore the record\n\nA1210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Invoke D0010 to write to the output file ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R1,@A_D0010_Parm       Save A(SMF record)\n         ST    R10,@A_D0010_Parm+4    Save A(ODT Entry)\n\n         LA    R1,@A_D0010_Parm       A(Parm list)\n         L     R15,=AL4(D0010)        A(Selection routine)\n         BASR  R14,R15                Go select the record\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n\n         LTR   R15,R15                How did it go?\n         BNZ   A1250                  Not great, try next ODT\n\n         ICM   R15,B'1111',ODTE_StopAft Get Select Limit\n         BZ    A1220                  None, keep going\n         C     R15,ODTE_Selected      Yes, have we reached it?\n         BH    A1220                  Not yet, keep going\n         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry\nA1220    DS    0H\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and E0010 to print it, if required                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Print_NO,L'ODTE_Print_NO Should we print?\n         BO    A1250                  No, skip\n         TM    @A_Rec_Printed,L'@A_Rec_Printed Yes, already printed?\n         BO    A1250                  Yes, skip\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Skip a line (Print blanks)\n\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   0(7,R2),=X'4020206B202120'  Move mask\n         L     R15,@_Input_Count      Get input record count\n         CVD   R15,@A_DBLWD           Pack it\n         ED    0(7,R2),@A_DBLWD+5     Edit it\n         MVC   7(7,R2),=X'4020206B202120'  Move mask\n         L     R15,ODTE_Selected      Get selected count\n         CVD   R15,@A_DBLWD           Pack it\n         ED    7(7,R2),@A_DBLWD+5     Edit it\n         MVC   15(8,R2),=C'RecType:'  Move Record Type title\n         MVC   23(4,R2),=X'40202120'  Move mask\n         SLR   R15,R15                Clear work register\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         CVD   R15,@A_DBLWD           Pack it\n         ED    23(4,R2),@A_DBLWD+6     and put it in SYSPRINT rec\n         MVC   30(11,R2),=C'Date-Time: ' Move Date/Time heading\n\n         XC    @A_DateConv_Area,@A_DateConv_Area Clear Date area\n         ZAP   @A_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)  Date\n         MVC   @A_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               SMF0TME-SMFRCD0(R1)            Time too\n         OI    @A_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @A_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@A_DateConv_Area     Point to Date Conversion area\n         ST    R15,@A_F0010_Parm     Save as 1st parm\n         LA    R15,41(0,R2)          A(Output area)\n         ST    R15,@A_F0010_Parm+4   Save as 2nd parm\n         LA    R15,@A_Return_Ptr     A(Return area)\n         ST    R15,@A_F0010_Parm+8   Save as 2nd parm\n         LA    R1,@A_F0010_Parm      A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n         L     R15,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)\n         LH    R15,ODT_Entry_Count-OutDesc_Tbl(R15) GET NBR ENTRIES\n         CH    R15,=H'1'              MORE THAN 1?\n         BNH   A1230                  NO, SKIP 'SELECTED BY' MSG\n         L     R2,@A_Return_Ptr       Point to end of Date/Time\n         MVC   1(13,R2),=C', selected to'  MOVE SELECTION HDG\n         MVC   15(L'ODTE_DDName,R2),ODTE_DDName MOVE DDNAME\nA1230    DS    0H\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n\n         ST    R1,@A_E0010_Parm       Save A(SMF record)\n         ST    R10,@A_E0010_Parm+4    Save A(ODT Entry)\n\n         LA    R1,@A_E0010_Parm       A(Parm list)\n         L     R15,=AL4(E0010)        A(Print routine)\n         BASR  R14,R15                Go print the record\n\n         OI    @A_Rec_Printed,L'@A_Rec_Printed Printed now\n\n         L     R1,@_SYSUT1_Rec_Ptr    Restore A(Input Record)\n\n         B     A1250                  And continue\n\nA1240    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Flag this ODT Entry as Inactive                                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    ODTE_Inactive,L'ODTE_Inactive Inactive entry\nA1250    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Point to the next ODT Entry, and check it out                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AL    R10,=AL4(ODTE_Length)  Bump entry pointer\n         BCT   R9,A1010               and keep going\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have finished processing all ODT Entries - if they are all  *\n*   inactive, we will terminate.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @A_All_Done,L'@A_All_Done All ODTs inactive?\n         BZ    A1000                  No, go get more input\n\n         DROP  R10                    Free ODTE Base register\n\n         SLR   R15,R15                Yes, all done\n         B     A9000                  and exit\nA9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Perform our Termination routines ...                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(Z0010)        A(Termination Routine)\n         BASR  R14,R15                Go do it\n\n         LR    R3,R15                 Save the return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... get rid of the 24-bit stack ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK TERM,                    Free the stack                 +\n               STACK=@_24Bit_Stack_Ptr   starting here\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... free up our local data area ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@A_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... then the global data area ...                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@_Dynam               A(Global storage)\n         L     R2,@_31Bit_Stack_Ptr     Rescue Stack pointer\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=(R2)                on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and finally, the stack itself.                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK TERM,                    Free the stack                 +\n               STACK=(2)                 starting here\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Restore callers registers, and return to caller.               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         L     R14,12(0,R13)            Restore Return address\n         LR    R15,R3                   Restore return code\n         LM    R0,R12,20(R13)           Restore remainder of registers\n         BSM   0,R14                    and return to caller\n\n\n         LTORG\n\n\nA9998 CLC      0(0,R2),DTE_Data-DT_Entry(R15)  Check data\nA9999 CLC      0(0,R2),JNTE_JobName-JNT_Entry(R15) Check JobName\n\n\n         LTORG\n\n@A_Dynam        DSECT               Local Variables\n@A_Save         DS    18F            O/S Style Save Area\n@A_DBLWD        DS    D\n@A_ParmList     DS    0F\n@A_D0010_Parm   DS    2AL4           Parms for D0010\n                ORG   @A_ParmList\n@A_E0010_Parm   DS    2AL4           Parms for E0010\n                ORG   @A_ParmList\n@A_F0010_Parm   DS    3AL4           Parms for F0010\n@A_Return_Ptr   DS    AL4             Return pointer from F0010\n                ORG\n                DS    X              Flag Byte\n@A_All_Done     EQU   *-1,X'80'       1... .... All ODTs inactive\n@A_Rec_Printed  EQU   *-1,X'40'       .1.. .... Record printed\n@A_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                DS    0D             Alignment\n@A_DynLen       EQU   *-@A_Dynam    Length\n\n         DROP  R11,R13\n\nSMFSLCT  RSECT\n         TITLE 'B0010: Initialization'\n\n         PUSH  USING\n\nB0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : B0010                                                  *\n*                                                                     *\n*  Abstract  : Initialization routine                                 *\n*               Allocate and initialize various contol blocks         *\n*               Interpret SYSIN Control Cards                         *\n*               OPEN all output files                                 *\n*               Print info about output files                         *\n*                                                                     *\n*                                                                     *\n*  Inputs    : Parms: N/A                                             *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              1999/11/18 SDDA030 V1.3                                *\n*                                 Added comments                      *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Corrected SOC4s, etc., when we      *\n*                                 overflowed SYSPRINT record when     *\n*                                 listing rectypes/jobnames.          *\n*                                 Invoked I0010 to OPEN SYSUT1.       *\n*                                 Used W0010 to get A(JFCB), rather   *\n*                                 that issue RDJFCB.                  *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING B0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@B_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@B_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @B_Dynam,R13             Assign a base\n         L     R15,@B_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Create our Output Descriptor Table, ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,ODT_Entry-OutDesc_Tbl Header length\n*        AL    R0,=AL4(ODTE_Length)    plus len of 1 entry\n         AL    R0,=AL4(ODTE_Length*2)  plus len of 2 entries       JG\n         ICM   R0,B'1000',=AL1(ODT_SubPool_Nbr) set up subpool\n         STORAGE OBTAIN,              Go get our storage               +\n               LENGTH=(0),             this long                       +\n               LOC=ANY                 anywhere\n         ST    R1,@_ODT_Ptr            Save A(Table)\n         ST    R0,ODT_SubPool-OutDesc_Tbl(R1) Save subpool, length\n         LA    R15,1                   Nbr entries\n         STH   R15,ODT_Entry_Count-OutDesc_Tbl(R1) Init it\n         LA    R0,ODT_Entry-OutDesc_Tbl(R1) Point to our entry\n         L     R1,=AL4(ODTE_Length)    Get its length\n         SLR   R14,R14                 no sending area\n         SLR   R15,R15                 or length\n         MVCL  R0,R14                  Clear our entry\n         L     R10,@_ODT_Ptr           A(Output Descriptor Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) Point to 1st entry\n\n         USING ODT_Entry,R10           Assign a base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and initialize the base (first) entry.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ZAP   ODTE_StartDate,=P'0'   Start Date = 00000\n         XC    ODTE_StartTime,ODTE_StartTime Start Time = 00:00:00\n         ZAP   ODTE_EndDate,=P'999999' End Date = 00365\n         MVC   ODTE_EndTime,=F'8640000' End Time = 24:00:00\n         XC    ODTE_PeriodStart,ODTE_PeriodStart Period Start\n         MVC   ODTE_PeriodEnd,=F'8640000' Period End\n         MVI   ODTE_InExit,C' '       CLEAR\n         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit Input and\n         MVC   ODTE_OutExit,ODTE_InExit      Output Exit names\n         SLR   R15,R15                   Clear work register\n         ST    R15,ODTE_DCB_Ptr          No DCB yet\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Initialize our variables.                                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ZAP   @_First_Rec_Date,=P'0' First Date = 00000\n         XC    @_First_Rec_Time,@_First_Rec_Time First Time = 00:00:00\n         ZAP   @_Dump_Start_Date,=P'999999' Dump Start Date = 00.365\n         MVC   @_Dump_Start_Time,=F'8640000' Dump Start Time = 24:00:00\n         ZAP   @_Dump_End_Date,=P'0'  Dump End Date = 00.000\n         XC    @_Dump_End_Time,@_Dump_End_Time Dump End Time = 00:00:00\n         ZAP   @_Prev_Input_Rec_Date,=P'0'\n         LA    R15,99                 Get High Line count\n         STH   R15,@_Line_Count        and save it\n         ZAP   @_Page_Count,=P'0'     Clear Page count\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the current date and time ...                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @B_Time,B_Time         Move L-Form of macro\n         TIME  DEC,                   Get time                         C\n               @B_TimeArea,            and return it here              C\n               LINKAGE=SYSTEM,         don't use the SVC               C\n               DATETYPE=YYYYDDD,       format of returned data         C\n               MF=(E,@B_TIME)          addr of macro list\n         XC    @_DateConv_Area,@_DateConv_Area Clear date conv area\n         XC    @B_DBLWD,@B_DBLWD      Clear work area\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and some info about it.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@B_TimeArea         Get HH\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_HH-DateConv_Area\n         IC    R0,@B_TimeArea+1       Get MM\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_MM-DateConv_Area\n         IC    R0,@B_TimeArea+2       Get SS\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_SS-DateConv_Area\n         IC    R0,@B_TimeArea+3       Get tt\n         SLL   R0,4                   Make room for sign\n         STH   R0,@B_DBLWD+6          Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R0,@B_DBLWD            Binarize it\n         STC   R0,@_DateConv_Area+DConv_Time_tt-DateConv_Area\n         OI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DConv+\n               _Input_hhmmss          Indicate time in hhmmss\n\n         L     R15,@B_TimeArea+8      Get Date (0yyyyddd)\n         SLR   R14,R14                Clear work register\n         SLDL  R14,20                 R14 = yyyy\n         SLL   R14,4                  Make room for sign\n         ST    R14,@B_DBLWD+4         Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R14,@B_DBLWD           Binarize yyyy\n         STH   R14,@_DateConv_Area+DConv_Date_YYYY-DateConv_Area\n         SRL   R15,16                 R15 = ddd0\n         ST    R15,@B_DBLWD+4         Save it\n         OI    @B_DBLWD+7,X'0F'       Add a sign\n         CVB   R15,@B_DBLWD           Binarize ddd\n         STH   R15,@_DateConv_Area+DConv_Date_DDD-DateConv_Area\n         OI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,L'DConv+\n               _Input_Julian          Indicate date in YYYY and DDD\n\n         LA    R1,@_DateConv_Area    Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info about today\n\n         NI    @_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,X'FF'-L+\n               'DConv_Input_hhmmss    Off the flag\n         NI    @_DateConv_Area+DConv_Input_Julian-DateConv_Area,X'FF'-L+\n               'DConv_Input_Julian    Off the flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Initialize SYSPRINT stuff                                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_DCB_Ptr   Clear A(SYSPRINT DCB)\n         OI    ODTE_Print_NO,L'ODTE_Print_NO Suppress headings\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go get a record\n         NI    ODTE_Print_NO,X'FF'-L'ODTE_Print_NO Reset no print flag\n         LTR   R15,R15                  OK?\n         BNZ   B8000                    No, exit with error\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check out SYSIN control cards                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr          A(Output Desc Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) A(default (1st) entry)\n         L     R15,=AL4(H0010)        A(SYSIN processor)\n         BASR  R14,R15                Go interpret SYSIN\n         LTR   R15,R15                How did we do?\n         BNZ   B8000                  Not great, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go allocate (if necessary) and OPEN SYSUT1                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT Routine)\n         BASR  R14,R15                A blank line\n         L     R15,=AL4(G0010)        A(SYSPRINT Routine)\n         BASR  R14,R15                and another\n\n         L     R15,=AL4(I0010)        A(SYSUT1 OPEN)\n         BASR  R14,R15                Go OPEN SYSUT1\n         LTR   R15,R15                How did we do?\n         BNZ   B8000                  Not great, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We seemed to interpret the SYSIN statements OK, and SYSUT1 is  *\n*   OK, so go and fix up the Output Descriptor Table:               *\n*        - if there is only one entry (ie, the default), make the   *\n*          output ddname = SYSUT2,                                  *\n*        - if there is more than one, propagate the default exit    *\n*          names, record type, jobname and data table pointer addrs,*\n*          and include and exclude flags from the default to the    *\n*          other entries, unless they were specified in the other   *\n*          entries. Additionally, inactivate the default entry.     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,1                 Set Input count\n         LNR   R15,R15                to -1 for any exits\n         ST    R15,@_Input_Count      we may invoke\n\n         L     R10,@_ODT_Ptr         A(Output Descriptor Table)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         CH    R9,=H'1'              ONLY ONE ENTRY?\n         BH    B0020                 NO, SKIP\n         MVC   ODTE_DDName,=CL8'SYSUT2' YES, DEFAULT TO SYSUT2\n         SLR   R15,R15               Clear work register\n         ST    R15,ODTE_DCB_Ptr      No DCB yet\n         B     B0120                 AND SKIP\nB0020    DS    0H\n         LR    R1,R10                SAVE A(DEFAULT ENTRY)\n         OI    ODTE_Inactive,L'ODTE_Inactive MAKE DEFAULT INACTIVE\n         MVC   @B_Default_InExit_Name,ODTE_InExit Save default name\n         MVC   @B_Default_InExit_Parm_Ptr,ODTE_InExit_Parm_Ptr\n         MVC   @B_Default_OutExit_Name,ODTE_OutExit Save default name\n         MVC   @B_Default_OutExit_Parm_Ptr,ODTE_OutExit_Parm_Ptr\n         B     B0110\nB0030    DS    0H\n         CLI   ODTE_InExit,C' '      INPUT EXIT NAME BLANK?\n         BNE   B0040                 NO, SKIP\n         TM    ODTE_No_Dflt_InExit,L'ODTE_No_Dflt_Inexit Use default?\n         BO    B0040                 No, skip\n         MVC   ODTE_InExit,@B_Default_InExit_Name Yes, move default\n         MVC   ODTE_InExit_Parm_Ptr,@B_Default_InExit_Parm_Ptr\nB0040    DS    0H\n         CLI   ODTE_OutExit,C' '     OUTPUT EXIT NAME BLANK?\n         BNE   B0050                 NO, SKIP\n         TM    ODTE_No_Dflt_OutExit,L'ODTE_No_Dflt_Outexit Use default?\n         BO    B0050                 No, skip\n         MVC   ODTE_OutExit,@B_Default_OutExit_Name    Yes, DEFAULT\n         MVC   ODTE_OutExit_Parm_Ptr,@B_Default_OutExit_Parm_Ptr\nB0050    DS    0H\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TABLE) = 0?\n         BNZ   B0060                 NO, SKIP\n         MVC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R1) Yes, default\nB0060    DS    0H\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE) = 0?\n         BNZ   B0070                 NO, SKIP\n         MVC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R1) Yes, default\nB0070    DS    0H\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE) = 0?\n         BNZ   B0080                 NO, SKIP\n         MVC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R1) Yes, default\nB0080    DS    0H\n         TM    ODTE_Print_NO-ODT_Entry(R1),L'ODTE_Print_NO\n         BZ    B0090\n         OI    ODTE_Print_NO,L'ODTE_Print_NO Set flag\nB0090    DS    0H\n         TM    ODTE_Print_EB-ODT_Entry(R1),L'ODTE_Print_EB\n         BZ    B0100\n         OI    ODTE_Print_EB,L'ODTE_Print_EB Set flag\nB0100    DS    0H\n         TM    ODTE_JobData_OR-ODT_Entry(R1),L'ODTE_JobData_OR\n         BZ    B0110\n         OI    ODTE_JobData_OR,L'ODTE_JobData_OR Set flag\nB0110    DS    0H\n         AL    R10,=AL4(ODTE_Length) A(Next entry)\n         BCT   R9,B0030              AND DO IT\nB0120    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    For each entry in the Output Descriptor Table ...              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr          A(OUTPUT ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\nB0130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... get the attributes for the dataset                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Inactive,L'ODTE_Inactive INACTIVE ENTRY?\n         BO    B0220                  YES, SKIP DCB STUFF\n\n         LA    R0,B_SYSUT2_DCB_Length Length of DCB\n         STORAGE OBTAIN,              Get storage                      +\n               LENGTH=(0),             for the DCB                     +\n               LOC=BELOW               Below-the-line\n         MVC   0(B_SYSUT2_DCB_Length,R1),B_SYSUT2_DCB Move DCB\n         MVC   DCBDDNAM-IHADCB(L'DCBDDNAM,R1),ODTE_DDName IN DCB\n         ST    R1,ODTE_DCB_Ptr        Save A(DCB)\n\n         L     R15,=AL4(W0010)        A(Get JFCB address routine)\n         BASR  R14,R15                Go get it\n         LTR   R15,R15                How did we do?\n         BNZ   B0200                  Not good, skip\n         LR    R3,R1                  OK, point to JFCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is a new dataset ...                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    JFCBIND2-INFMJFCB(R3),JFCNEW DISP=NEW or not specified?\n         BM    B0180                  NO, USE EXISTING STUFF\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... set up RECFM, LRECL and BLKSIZE if they were not           *\n*   specified                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,ODTE_DCB_Ptr        A(DCB)\n\n         IC    R15,JFCRECFM-INFMJFCB(R3) GET JFCB RECFM\n         TM    JFCRECFM-INFMJFCB(R3),JFCFMREC ANYTHING THERE?\n         BNZ   B0140                  YES, OK\n         L     R1,@_SYSUT1_DCB_Ptr    A(Input DCB)\n         IC    R15,DCBRECFM-IHADCB(R1) NO, GET RECFM FROM SYSUT1\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?\n         BZ    B0140                   NO, OK\n         IC    R15,=AL1(DCBRECV+DCBRECBR+DCBRECSB) YES, DEFAULT TO VBS\nB0140    DS    0H\n         STC   R15,DCBRECFM-IHADCB(R2) SAVE RECFM\n         TM    DCBRECFM-IHADCB(R2),DCBRECU RECFM=U?\n         BO    B0170                   YES, SKIP LRECL CHECK\n         BNZ   B0150                   NO, BUT SOME LRECL SPECIFIED\n         TM    JFCRECFM-INFMJFCB(R3),JFCUND JFCB RECFM = U?\n         BO    B0170                   YES, SKIP LRECL CHECK\nB0150    DS    0H\n         LH    R15,JFCLRECL-INFMJFCB(R3) GET JFCB LRECL\n         LTR   R15,R15                 IS THERE ONE?\n         BNZ   B0160                   YES, SKIP\n         L     R1,@_SYSUT1_DCB_Ptr     No, A(SYSUT1 DCB)\n         LH    R15,DCBLRECL-IHADCB(R1) NO, GET SYSUT1 LRECL\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS THE INPUT VSAM?\n         BZ    B0160                   NO, OK\n         L     R15,=F'32760'           YES, DEFAULT LRECL=32760\nB0160    DS    0H\n         STH   R15,DCBLRECL-IHADCB(R2) Update OUTPUT LRECL\nB0170    DS    0H\n         LH    R15,JFCBLKSI-INFMJFCB(R3) GET JFCB BLKSIZE\n         LTR   R15,R15                 IS THERE ONE?\n         BNZ   B0180                   YES, SKIP\n         MVC   DCBBLKSI-IHADCB(L'DCBBLKSI,R2),DCBBLKSI-IHADCB(R1)\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM IS SYSUT1 VSAM?\n         BZ    B0180                   NO, OK\n         SLR   R15,R15                 YES, Use SDB\n         STH   R15,DCBBLKSI-IHADCB(R2) UPDATE SYSUT2\nB0180    DS    0H\n         L     R2,ODTE_DCB_Ptr            A(DCB)\n         MVC   @B_OPEN,B_OPEN             MOVE OPEN PARMS\n         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@B_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN IS IT OPEN?\n         BZ    B0200                  NO, SKIP\n         LH    R15,DCBLRECL-IHADCB(R2) YES, GET LRECL\n         TM    DCBRECFM-IHADCB(R2),DCBRECU IS RECFM = U?\n         BNO   B0190                  NO, OK\n         LH    R15,DCBBLKSI-IHADCB(R2) YES, GET BLKSIZE INSTEAD\nB0190    DS    0H\n         STH   R15,ODTE_LRECL         SAVE MAX OUTPUT LRECL\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Go list some stuff about this file                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,ODTE_DCB_Ptr        A(DCB)\n         L     R15,=A(J0010)          A(Info format routine)\n         BASR  R14,R15                Go do it\n         B     B0210                  and skip\n\nB0200    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THE OUTPUT DCB COULD NOT BE OPENED - SAY SO.                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT LINE)\n         L     R15,ODTE_DCB_Ptr       A(DCB)\n         MVC   1(8,R1),DCBDDNAM-IHADCB(R15) MOVE DDNAME\n         MVC   9(23,R1),=C' DD statement not found'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT OUR LINE\n\nB0210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*   Assume this entry has no selection criteria (i.e., a straight   *\n*  copy). This flag will get reset each time we find (and print)    *\n*  some selection criteria.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    ODTE_CopyOnly,L'ODTE_CopyOnly  Assume no selection crit\n\n         LA    R1,ODT_Entry           Point to ODTE\n         L     R15,=AL4(L0010)        A(List routine)\n         BASR  R14,R15                Go do it\n\nB0220    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK TO SEE IF WE HAVE TO LOAD THE EXITS - IF WE DO, WE DO.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   ODTE_InExit,C' '       IS THERE AN INEXIT?\n         BE    B0270                  NO, SKIP\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?\n         BNE   B0230                  No, go load it\n         ICM   R0,B'1111',@B_Default_InExit_Ptr Yes, get A(Exit)\n         BNZ   B0240                  LOADed already, skip\nB0230    DS    0H\n         LA    R0,ODTE_InExit         NO, POINT TO IT\n         LOAD  EPLOC=(0),ERRET=B0260 AND GO GET IT\n         CLC   ODTE_InExit,@B_Default_InExit_Name  Default?\n         BNE   B0240                  No, skip\n         ST    R0,@B_Default_InExit_Ptr Yes, save its address\nB0240    DS    0H\n         ST    R0,ODTE_InExit_Ptr     SAVE EPA\n\n         SLR   R1,R1                  Clear A(SMF Record)\n         SLR   R0,R0                  An InExit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         C     R15,=FL4'12'           How did it go?\n         BL    B0270                  OK, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive\n         B     B0360                  AND SKIP\n\nB0260    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'\n         MVC   10(L'ODTE_InExit,R1),ODTE_InExit MOVE EXIT NAME\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT\n         MVI   ODTE_InExit,C' '       Clear 1st byte of name\nB0270    DS    0H\n         CLI   ODTE_OutExit,C' '      IS THERE AN OUTEXIT?\n         BE    B0320                  NO, SKIP\n         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?\n         BNE   B0280                  No, go load it\n         ICM   R0,B'1111',@B_Default_OutExit_Ptr Yes, get A(Exit)\n         BNZ   B0290                  LOADed already, skip\nB0280    DS    0H\n         LA    R0,ODTE_OutExit        NO, POINT TO IT\n         LOAD  EPLOC=(0),ERRET=B0310 AND GO GET IT\n         CLC   ODTE_OutExit,@B_Default_OutExit_Name  Default?\n         BNE   B0290                  No, skip\n         ST    R0,@B_Default_OutExit_Ptr Yes, save its address\nB0290    DS    0H\n         ST    R0,ODTE_OutExit_Ptr    SAVE EPA\n\n         SLR   R1,R1                  Clear A(SMF Record)\n         LA    R0,1                   An OutExit\n         L     R15,=AL4(X0010)        A(Exit invocation routine)\n         BASR  R14,R15                Go do it\n         C     R15,=FL4'12'           How did it go?\n         BL    B0320                  OK, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Not good, make inactive\n         B     B0360                  AND SKIP\n\nB0310    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   20(35,R1),=C'Exit could not be LOADed - ignored.'\n         MVC   10(L'ODTE_OutExit,R1),ODTE_OutExit MOVE EXIT NAME\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT\n         MVI   ODTE_OutExit,C' '      Clear 1st byte of name\nB0320    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we are ignoring weekends, adjust the start/stop times (if   *\n*   present), if they start or stop on weekends.                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?\n         BNO   B0360                 No, OK\n         NI    @B_Dates_Altered,X'FF'-L'@B_Dates_Altered Off our flag\n\n         CP    ODTE_StartDate,=P'0'  Any start date?\n         BE    B0330                 No, skip\n\n         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area\n         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_StartDate\n         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate        Indicate SMF Date\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         MVC   @B_StartDate_Base,@B_DateConv_Area+DConv_Date_Base-DateC+\n               onv_Area              Save start Basedate\n         MVC   @B_StartDate_DOW,@B_DateConv_Area+DConv_Date_DOW-DateCon+\n               v_Area                Save start DOW\n         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'\n         BNH   B0330                 Not starting on a weekend, skip\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         LA    R15,7                 DOW of the next Monday\n         SR    R15,R0                Number of days until Monday\n         A     R15,@B_StartDate_Base Bump base date\n         ST    R15,@B_StartDate_Base  and save it\n         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base Date\n         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+\n               -L'DConv_Input_SMFDate Off SMFDate flag\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         ZAP   ODTE_StartDate,@B_DateConv_Area+DConv_Date_SMFDate-DateC+\n               onv_Area(L'DConv_Date_SMFDate)  Update Start Date\n         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag\n\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   10(23,R1),=C'Start Date modified to '\n         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_StartTime               Time too\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base date\n         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@B_DateConv_Area     Point to Date Conversion area\n         ST    R15,@B_Parms          Save as 1st parm\n         LA    R15,33(0,R1)          A(Output area)\n         ST    R15,@B_Parms+4        Save as 2nd parm\n         LA    R15,@B_Return_Ptr     A(Return area)\n         ST    R15,@B_Parms+8        Save it\n         LA    R1,@B_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15               GO PRINT\n\n         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+\n               DConv_Input_Base      Off the flag\n         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+\n               DConv_Input_Time      Off the flag\nB0330    DS    0H\n         CP    ODTE_EndDate,=P'999999' Any End Date?\n         BE    B0340                 No, skip\n\n         XC    @B_DateConv_Area,@B_DateConv_Area Clear Date area\n         ZAP   @B_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_EndDate\n         OI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate        Indicate SMF Date\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         MVC   @B_EndDate_Base,@B_DateConv_Area+DConv_Date_Base-DateCon+\n               v_Area                Save End Basedate\n         CLI   @B_DateConv_Area+DConv_Date_DOW-DateConv_Area,X'04'\n         BNH   B0340                 Not ending on a weekend, skip\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         LA    R15,4                 DOW of the previous Friday\n         SR    R0,R15                Number of days after Friday\n         L     R15,@B_EndDate_Base   Get Base date\n         SR    R15,R0                Back up to Friday\n         ST    R15,@B_EndDate_Base   and save it\n         ST    R15,@B_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base           Indicate Base Date\n         NI    @B_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,X'FF'+\n               -L'DConv_Input_SMFDate Off SMFDate flag\n         LA    R1,@B_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get info\n\n         ZAP   ODTE_EndDate,@B_DateConv_Area+DConv_Date_SMFDate-DateCon+\n               v_Area(L'DConv_Date_SMFDate) Update end date\n         OI    @B_Dates_Altered,L'@B_Dates_Altered Set our flag\n\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO SYSPRINT RECORD\n         MVC   10(21,R1),=C'End Date modified to '\n         MVC   @B_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_EndTime          Time too\n         OI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv_+\n               Input_Base            Indicate Base date\n         OI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time            Indicate SMF Time\n         LA    R15,@B_DateConv_Area  Point to Date Conversion area\n         ST    R15,@B_Parms          Save as 1st parm\n         LA    R15,31(0,R1)          A(Output area)\n         ST    R15,@B_Parms+4        Save as 2nd parm\n         LA    R15,@B_Return_Ptr     A(Return area)\n         ST    R15,@B_Parms+8        Save it\n         LA    R1,@B_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15               GO PRINT\n\n         NI    @B_DateConv_Area+DConv_Input_Base-DateConv_Area,X'FF'-L'+\n               DConv_Input_Base      Off the flag\n         NI    @B_DateConv_Area+DConv_Input_Time-DateConv_Area,X'FF'-L'+\n               DConv_Input_Time      Off the flag\nB0340    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If there is a StartDate and an EndDate, check the adjusted     *\n*   dates ...                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @B_Dates_Altered,L'@B_Dates_Altered  Did we do anything?\n         BNO   B0360                 No, skip\n         CP    ODTE_StartDate,=P'0'  Any start date?\n         BE    B0360                 No, skip\n         CP    ODTE_EndDate,=P'999999' Any End Date?\n         BE    B0360                 No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... to see if we have to select anything. For instance, a      *\n*   user may have specified:                                        *\n*      START=Saturday,END=Sunday,WEEKENDS=IGNORE                    *\n*   We will have adjusted the StartDate to Monday, and EndDate to   *\n*   the previous Friday. In this case, we inactivate the entry      *\n*   immediately.                                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@B_EndDate_Base   Get base date for End date\n         C     R15,@B_StartDate_Base Less than StartDate?\n         BNL   B0350                 No, skip\n         OI    ODTE_Inactive,L'ODTE_Inactive Yes, set inactive\n         B     B0360                and skip\nB0350    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we have adjusted the dates so that a weekend does not fall  *\n*   within the Start and End dates, we can turn off the 'Ignore     *\n*   Weekends' flag. This will save us some processing, since we     *\n*   won't have to figure out the Day-of-Week for each day.          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@B_EndDate_Base   Get base date for End date\n         S     R15,@B_StartDate_Base Get nbr days\n         SLR   R0,R0                 Clear work register\n         IC    R0,@B_StartDate_DOW   Get starting day-of-week\n         AR    R0,R15                Get DOW of last day\n         C     R0,=FL4'5'            Saturday or greater?\n         BNL   B0360                 Yes, skip\n         NI    ODTE_Ignore_Weekend,X'FF'-L'ODTE_Ignore_Weekend\n\nB0360    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    All done with this entry, check next                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n\n         AL    R10,=AL4(ODTE_Length)  A(Next ODT entry)\n         BCT   R9,B0130               GO PROCESS IT\n\n         DROP  R10                    Free ODT Entry base reg\n\n         SLR   R15,R15                Clear\n         ST    R15,@_Input_Count       Input count\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have finished going through the table, so print some        *\n*   blank lines ...                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  AND ANOTHER\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ...  and exit.                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                Clear return code\n         B     B9000                  and exit\n\n\n\nB8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Either SYSPRINT could not be opened, or we found an error in   *\n*   the SYSIN statements; set the return code, and exit             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  Error, set return code\n\nB9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@B_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         PUSH  PRINT\n         PRINT NOGEN\n\nB_Time   TIME  LINKAGE=SYSTEM,MF=L\nB_Time_Length EQU *-B_Time\n\nB_SYSUT2_DCB DCB DDNAME=SYSUT2,MACRF=PM,DSORG=PS\nB_SYSUT2_DCB_Length EQU *-B_SYSUT2_DCB LENGTH OF SYSUT1 DCB\n\nB_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nB_OPEN_Length EQU  *-B_OPEN\n\n         POP   PRINT\n\n         LTORG\n\n@B_Dynam        DSECT                 Dynamic area for B\n@B_Save         DS    18F              O/S Style save area\n@B_DBLWD        DS    D                Work area\n@B_Parms        DS    3AL4             Parm area\n@B_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@B_StartDate_Base DS  FL4              Start Date in REXX Base format\n@B_StartDate_DOW DS   XL1              Start Date Day-of-Week\n@B_EndDate_Base DS    FL4              End Date in REXX Base format\n\n@B_Default_InExit_Name DS  CL8         Default Exit Name\n@B_Default_InExit_Ptr  DS  AL4         A(EPA of default exit)\n@B_Default_InExit_Parm_Ptr DS AL4      A(Parm Ptr for InExit)\n@B_Default_OutExit_Name DS  CL8        Default Exit Name\n@B_Default_OutExit_Ptr  DS  AL4        A(EPA of default exit)\n@B_Default_OutExit_Parm_Ptr DS AL4     A(Parm Ptr for OutExit)\n\n                DS    X                Flag Byte\n@B_Dates_Altered EQU  *-1,X'80'         1... .... Start/End dates upd\n\n@B_MACRO        DS    0F               Macro area\n@B_OPEN         DS    CL(B_OPEN_Length) OPEN macro\n                ORG   @B_MACRO\n@B_Time         DS    CL(B_Time_Length) L-Form of Time\n@B_TimeArea     DS    CL16             Return area for Time\n                ORG   @B_MACRO\n@B_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                ORG\n                DS    0D               Alignment\n@B_DynLen       EQU   *-@B_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'C0000: Read the Input File'\n\n         PUSH  USING\n\nC0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : C0010                                                  *\n*                                                                     *\n*  Abstract  : SYSUT1 Read Routine:                                   *\n*               If SYSUT1 not OPEN                                    *\n*                 OPEN SYSUT1                                         *\n*               EndIf                                                 *\n*               Do until valid SMF record found                       *\n*                 Read SYSUT1                                         *\n*                 Check VBS Segmentation, if required                 *\n*               EndDo                                                 *\n*                                                                     *\n*  Inputs    : None                                                   *\n*                                                                     *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              1999/11/18 SDDA030 V1.3                                *\n*                                 Moved SYSUT1 OPEN logic(?) to its   *\n*                                 own subroutine (I0010)              *\n*                                 Added comments                      *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Removed invocation of I0010 to OPEN *\n*                                 SYSUT1 (now done in B0010).         *\n*                                 Updated EODAD on 1st time through.  *\n*                                 Cleaned up SYSUT1 resources at EOD. *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING C0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@C_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@C_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @C_Dynam,R13             Assign a base\n         L     R15,@C_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is the first time in (@_Input_Count = 0) ...           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@_Input_Count Get input counter\n         BNZ   C0020                    Not 1st time in, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... go update the DCBE/ACB EODAD routine address               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?\n         BO    C0010E                 Yes, skip\n\n         L     R15,@_SYSUT1_DCB_Ptr   Yes, A(Input DCB)\n         L     R15,DCBDCBE-IHADCB(0,R15) A(DCBE)\n         LA    R0,C7000               A(EOD Routine)\n         ST    R0,DCBEEODA-DCBE(0,R15) Update DCBE EODAD\n         B     C0010Z                  and skip\nC0010E   DS    0H\n\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         LA    R3,@C_SYSUT1_EXLST_Ptr  A(RECEIVING AREA)\n         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             +\n               FIELDS=EXLST,            WE WANT THE LRECL              +\n               AREA=(3),                MOVED TO THIS AREA             +\n               LENGTH=L'@C_SYSUT1_EXLST_Ptr, for this long             +\n               MF=(G,@C_SHOWCB,C_SHOWCB_Length)\n\n         L     R2,@C_SYSUT1_EXLST_Ptr   A(EXLST area)\n         LA    R3,C7000               Get A(EOD Routine)\n         MODCB EXLST=(2),             Update SYSUT1 EXLST              +\n               EODAD=(3),               for EOD address                +\n               MF=(G,@C_MODCB,C_MODCB_Length)\n\nC0010Z   DS    0H\n         LA    R15,99                   Get High Line count\n         STH   R15,@_Line_Count          and save it\n\nC0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Read the Input File.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM It the input VSAM?\n         BZ    C0030                  No, skip\n         L     R1,@_SYSUT1_RPL_Ptr    Yes, A(RPL)\n         GET   RPL=(1)                and issue GET\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have just read a record from the active SMF file, in which  *\n*  the end will be marked by a special record, so we had better     *\n*  check for it. If this is it, we signal EOF.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_Rec_Ptr    A(INPUT RECORD)\n         LH    R15,SMF0LEN-SMFRCD0(R1) GET LENGTH\n         CH    R15,=H'14'             IS IT THE RIGHT LENGTH?\n         BNE   C0180                  NO, SKIP\n         CLC   =C'SMFEOFMARK',SMF0FLG-SMFRCD0(R1) YES, IS THIS IT?\n         BE    C7000                  YES, EOF\n         B     C0180                  NO, CONTINUE\nC0030    DS    0H\n\n         TM    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Is the input QSAM?\n         BNO   C0040                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The input file is QSAM - just read it normally                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R0,@_SYSUT1_Rec_Ptr    A(input record)\n         L     R1,@_SYSUT1_DCB_Ptr    POINT TO INPUT DCB\n         GET   (1),(0)                GO GET THE RECORD\n         B     C0180                  and skip\nC0040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are using BSAM to access the input file.                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs Off our flag\n         SLR   R15,R15                Clear work register\n         ST    R15,@C_SegErr_Seg_Count Clear nbr error segments\nC0050    DS    0H\n         L     R15,@_SYSUT1_Rec_Ptr   A(Record area)\n         SLR   R0,R0                  Clear work reg\n         ST    R0,0(0,R15)            Clear record length\n         STH   R0,@C_Seg_Count        Clear segment count\n         NI    @C_Last_Segment,X'FF'-L'@C_Last_Segment Off our flag\nC0060    DS    0H\n         L     R1,@_SYSUT1_BuffArea_Ptr Point to our buffer area\n         ICM   R15,B'1111',BuffArea_Offset-BuffArea(R1) Get offset\n         BNZ   C0070                  OK, skip\n         L     R1,BuffArea_DECB_Ptr-BuffArea(0,R1) None, A(DECB)\n         CHECK (1)                    Wait for I/O completion\n         L     R1,@_SYSUT1_BuffArea_Ptr Restore buffer pointer\n         LA    R15,4                  Buffer offset\n         ST    R15,BuffArea_Offset-BuffArea(0,R1) Update it\n         L     R15,@_SYSUT1_PBlock_Count Get Phys Blk Count\n         LA    R15,1(0,R15)           Bump it\n         ST    R15,@_SYSUT1_PBlock_Count and save it\n         LA    R15,1                  Initialize segment\n         ST    R15,BuffArea_Seg_Count-BuffArea(0,R1)  count\nC0070    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check that the next segment is valid, based on the segments    *\n*   that have come before. Segment Type bits:                       *\n*          X'00'  00 - Complete segment                             *\n*          X'01'  01 - 1st segment                                  *\n*          X'02'  10 - Last segment                                 *\n*          X'03'  11 - Intermediate segment                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@_SYSUT1_Rec_Ptr   A(Input record area)\n         LH    R0,0(0,R14)            Get current record length\n\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(I/O Area)\n         A     R15,BuffArea_Offset-BuffArea(0,R1) A(Next Segment)\n         TM    2(R15),X'01'           Last or only segment?\n         BNZ   C0080                  No, skip\n         OI    @C_Last_Segment,L'@C_Last_Segment Yes, set flag\nC0080    DS    0H\n         TM    2(R15),X'02'           1st or complete segment?\n         BZ    C0110                  Yes, skip\n         LTR   R0,R0                  No, have we processed a 1st?\n         BZ    C0090                  No, segment error\n         LR    R14,R15                A(Start of segment)\n         LH    R15,0(0,R14)           Segment length\n         SH    R15,=H'4'              less length of SDW\n         LA    R14,4(0,R14)           point past SDW\n         B     C0140                  OK, skip\nC0090    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Segment error - Intermediate or last segment without a 1st.       *\n*  If we are not in the middle of dropping segments, save some info   *\n*  about the start of the segmenting error.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?\n         BO    C0100                  Yes, skip\n         MVC   @C_SegErr_Init_PBlock,@_SYSUT1_PBlock_Count\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffarea)\n         L     R15,BuffArea_Seg_Count-BuffArea(0,R15)\n         ST    R15,@C_SegErr_Init_Seg  Save segment number\n         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date\n         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time\n         SLR   R15,R15                Number of segments\n         ST    R15,@C_SegErr_Seg_Count Clear segment count\n         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error\n         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error\nC0100    DS    0H\n         L     R15,@C_SegErr_Seg_Count Get segment count\n         LA    R15,1(0,R15)           Bump it\n         ST    R15,@C_SegErr_Seg_Count Save it\n\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         L     R15,BuffArea_Offset-BuffArea(0,R1) Offset next segment\n         LA    R15,BuffArea_IOArea-BuffArea(R15,R1) A(Next segment)\n         LH    R14,0(0,R15)           Get length of Segment\n         A     R14,8(0,R1)            Bump offset to next segment\n         ST    R14,8(0,R1)            Save it\n         NI    @C_Last_Segment,L'@C_Last_Segment Off our flag\n         B     C0150                  and skip\nC0110    DS    0H\n         LTR   R0,R0                  Are we in the middle of a rec?\n         BNZ   C0120                  Yes, error\n         LR    R14,R15                OK, A(Start of segment)\n         LH    R15,0(0,R14)           Segment length\n         MVC   @C_Init_PBlock,@_SYSUT1_PBlock_Count Save init PBlock\n         MVC   @C_Init_Seg,BuffArea_Seg_Count-BuffArea(R1) seg #\n         B     C0140                  and skip\nC0120    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Segment error - No ending segment                                 *\n*  If we are not in the middle of dropping segments, save some info   *\n*  about the start of the segmenting error.                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Already in error?\n         BO    C0130                  Yes, skip\n         MVC   @C_SegErr_Init_PBlock,@C_Init_PBlock\n         MVC   @C_SegErr_Init_Seg,@C_Init_Seg\n         ZAP   @C_SegErr_Init_Date,@_Input_Rec_Date\n         MVC   @C_SegErr_Init_Time,@_Input_Rec_Time\n         OI    @C_Skipping_Segs,L'@C_Skipping_Segs Segmenting error\nC0130    DS    0H\n         LH    R15,@C_Seg_Count       Segments in partial record\n         A     R15,@C_SegErr_Seg_Count Bump error count\n         ST    R15,@C_SegErr_Seg_Count Set error count\n\n         B     C0050                  Start again\nC0140    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   At this point, R0  = Current length of input record               *\n*                  R14 = A(Segment from SYSUT1)+4 (ie, past SDW)      *\n*                  R15 = Length of Segment                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LR    R1,R0                  Get current length\n         AR    R1,R15                 Get new total length\n         C     R1,@_SYSUT1_Rec_Length Will it be too long?\n         BH    C0120                  Yes, error\n         A     R0,@_SYSUT1_Rec_Ptr    No, A(Next free area)\n         LR    R1,R15                 Length to move\n         MVCL  R0,R14                 Move data to input area\n         L     R1,@_SYSUT1_Rec_Ptr    A(Start of input rec area)\n         SR    R0,R1                  Current length of input\n         STH   R0,0(0,R1)             Update RDW\n         L     R1,@_SYSUT1_BuffArea_Ptr A(Input buffer area)\n         LA    R15,BuffArea_IOArea-BuffArea(0,R1) A(Start of block)\n         SR    R14,R15                Calculate new offset\n         ST    R14,BuffArea_Offset-BuffArea(0,R1) Save it\n         LH    R15,@C_Seg_Count       Get segments in curr rec\n         LA    R15,1(0,R15)           Bump it\n         STH   R15,@C_Seg_Count       Save it\nC0150    DS    0H\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Buffer area)\n         L     R14,BuffArea_Offset-BuffArea(0,R1) Get offset\n         CH    R14,BuffArea_IOArea-BuffArea(0,R15) Done the block?\n         BL    C0160                  No, skip\n         L     R2,@_SYSUT1_DCB_Ptr    A(SYSUT1 DCB)\n         L     R4,@_SYSUT1_BuffArea_Ptr A(buffer area)\n         L     R5,BuffArea_DECB_Ptr-BuffArea(0,R4) A(DECB)\n         MVC   0(C_READ_Length,R5),C_READ  Initialize DECB\n         LA    R6,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)\n         READ  (5),SF,(2),(6),'S',MF=E    Issue the read\n         SLR   R15,R15                Clear work register\n         ST    R15,BuffArea_Offset-Buffarea(0,R4) Clear offset\n         L     R15,@_SYSUT1_BuffArea_Ptr A(Current buffer area)\n         L     R15,BuffArea_Next_Ptr-BuffArea(0,R15) A(Next)\n         ST    R15,@_SYSUT1_BuffArea_Ptr and save the address\nC0160    DS    0H\n         TM    @C_Last_Segment,L'@C_Last_Segment  All done?\n         BZ    C0060                  No, keep going\n\n         TM    @C_Skipping_Segs,L'@C_Skipping_Segs Yes, segs skipped?\n         BZ    C0180                  No, OK\n\n         OI    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Yes, set flag\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   2(3,R2),=C'***'        Move flag\n         MVC   5(7,R2),=X'4020206B202120' Segment count mask\n         L     R15,@C_SegErr_Seg_Count Get segments dropped\n         CVD   R15,@C_DBLWD           Pack it\n         ED    5(7,R2),@C_DBLWD+5     Edit it in\n         MVC   13(7,R2),=C'segment'   Start of literal\n         LA    R2,20(0,R2)            point to next character\n         C     R15,=FL4'1'            More than 1 segment?\n         BNH   C0170                  No, skip\n         MVI   0(R2),C's'             Yes, pluralize it\n         LA    R2,1(0,R2)             and bump output pointer\nC0170    DS    0H\n         MVC   0(26,R2),=C' dropped, from (PBlk:Seg) '\n         L     R15,@C_SegErr_Init_PBlock  Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  26(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    32(R2),X'F0'          Make it readable\n         MVI   33(R2),C':'           Move separator\n         L     R15,@C_SegErr_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  34(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    36(R2),X'F0'          Make it readable\n         MVC   37(15,R2),=C' to (PBlk:Seg) '\n         L     R15,@C_Init_PBlock    Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  52(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    58(R2),X'F0'          Make it readable\n         MVI   59(R2),C':'           Move separator\n         L     R15,@C_SegErr_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  60(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    62(R2),X'F0'          Make it readable\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   6(10,R2),=C'Data after'\n\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@C_SegErr_Init_Date  Date\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @C_SegErr_Init_Time            Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,17(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         LA    R2,6(0,R2)             Bump pointer\n\n         MVC   0(10,R2),=C'and before'\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         L     R1,@_SYSUT1_Rec_Ptr   A(Input record)\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               SMF0TME-SMFRCD0(R1)          Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,11(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R2,@C_Return_Ptr      A(Return area)\n         MVC   1(17,R2),=C' are unavailable.'\n\n         L     R15,=AL4(G0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs\n         B     C0180                  and skip\nC0180    DS    0H\n         L     R1,@_SYSUT1_Rec_Ptr    AND POINT TO OUR RECORD\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Bump the input counters                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_Input_Count      GET THE INPUT COUNTER\n         LA    R15,1(0,R15)           BUMP IT\n         ST    R15,@_Input_Count\n\n         SLR   R15,R15                Clear work regiater\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         SLL   R15,2                  times 4\n         LA    R15,@_Input_Count_Table(R15) A(Our counter)\n         L     R0,0(0,R15)            Get count\n         AL    R0,=FL4'1'             Bump it\n         ST    R0,0(0,R15)            Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SAVE THE DATE/TIME OF THE FIRST RECORD.                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   SMF0RTY-SMFRCD0(R1),X'02' DUMP HEADER?\n         BNE   C0200                  NO, SKIP\n         CP    @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) 1st?\n         BL    C0230                  NO, SKIP IT\n         BH    C0190                  YES, SAVE IT\n         L     R15,@_Dump_Start_Time  SAME DAY, GET PREV TIME\n         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE\n         BNH   C0230                  NOT EARLIEST, SKIP\nC0190    DS    0H\n         ZAP   @_Dump_Start_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) Save it\n         MVC   @_Dump_Start_Time,SMF0TME-SMFRCD0(R1)\n         B     C0230                  AND SKIP\nC0200    DS    0H\n         CLI   SMF0RTY-SMFRCD0(R1),X'03' DUMP TRAILER\n         BNE   C0220                  NO, SKIP\n         CP    @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) LATEST?\n         BH    C0230                  NO, SKIP IT\n         BL    C0210                  YES, SAVE IT\n         L     R15,@_Dump_End_Time    SAME DAY, GET PREV TIME\n         C     R15,SMF0TME-SMFRCD0(R1) COMPARE AGAINST THIS ONE\n         BNL   C0230                  NOT EARLIEST, SKIP\nC0210    DS    0H\n         ZAP   @_Dump_End_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1)\n         MVC   @_Dump_End_Time,SMF0TME-SMFRCD0(R1)\n         B     C0230                  AND SKIP\nC0220    DS    0H\n         ZAP   @_Input_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE\n         MVC   @_Input_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME\n         CP    @_First_Rec_Date,=P'0' HAVE WE FOUND THE FIRST DATE?\n         BNE   C0230                  YES,SKIP\n         ZAP   @_First_Rec_Date,SMF0DTE-SMFRCD0(L'SMF0DTE,R1) SAVE DATE\n         MVC   @_First_Rec_Time,SMF0TME-SMFRCD0(R1) AND TIME\nC0230    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE'VE FINISHED WITH THIS RECORD, SO WE CLEAR THE RETURN CODE   *\n*   AND EXIT.                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                CLEAR THE RETURN CODE\n         B     C9000                  AND EXIT\nC7000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    END-OF-FILE EXIT FOR SYSUT1.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?\n         BNO   C7010                  No, skip\n         L     R15,@_SYSUT1_Rec_Ptr   Yes, A(SYSUT1 record)\n         LH    R15,0(0,R15)           Get length of record\n         LTR   R15,R15                Anything there?\n         BZ    C7010                  No, OK\n\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(SYSPRINT record)\n         MVC   2(3,R2),=C'***'        Move flag\n         MVC   5(7,R2),=X'4020206B202120' Segment count mask\n         LH    R15,@C_Seg_Count       Get segments dropped\n         CVD   R15,@C_DBLWD           Pack it\n         ED    5(7,R2),@C_DBLWD+5     Edit it in\n         MVC   12(35,R2),=C' segments dropped, from (PBlk:Seg) '\n         L     R15,@C_Init_PBlock  Get starting phys block\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  47(7,R2),@C_DBLWD+4(4) Unpack it\n         OI    53(R2),X'F0'          Make it readable\n         MVI   54(R2),C':'           Move separator\n         L     R15,@C_Init_Seg   Get starting segment number\n         CVD   R15,@C_DBLWD          Pack it\n         UNPK  55(3,R2),@C_DBLWD+6(2) Unpack it\n         OI    57(R2),X'F0'          Make it readable\n         MVC   58(21,R2),=C' to the end of SYSUT1'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   6(11,R2),=C'Data after '\n\n         XC    @C_DateConv_Area,@C_DateConv_Area Clear Date area\n         ZAP   @C_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Input_Rec_Date     Date\n         MVC   @C_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Input_Rec_Time               Time too\n         OI    @C_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @C_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@C_DateConv_Area     Point to Date Conversion area\n         ST    R15,@C_FParms         Save as 1st parm\n         LA    R15,17(0,R2)          A(Output area)\n         ST    R15,@C_FParms+4       Save as 2nd parm\n         LA    R15,@C_Return_Ptr     A(Return area)\n         ST    R15,@C_FParms+8       Save it\n         LA    R1,@C_FParms          A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R2,@C_Return_Ptr      A(Return area)\n         MVC   1(17,R2),=C' are unavailable.'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                PRINT THIS LINE\n         NI    @C_Skipping_Segs,X'FF'-L'@C_Skipping_Segs\n\nC7010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE SYSUT1 ...                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_DCB_Ptr     A(DCB or ACB)\n         MVC   @C_CLOSE,C_CLOSE        Move CLOSE parms\n         CLOSE ((2)),MODE=31,MF=(E,@C_CLOSE)   and CLOSE DCB/ACB\n\n         ICM   R1,B'1111',@_SYSUT1_Rec_Ptr  GET A(INPUT RECORD AREA)\n         BZ    C7020                  None, skip\n         L     R0,@_SYSUT1_Rec_Length YES, GET ITS LEN\n         LA    R15,7                  Make\n         AR    R0,R15                  a\n         SRL   R0,3                    doubleword\n         SLL   R0,3                    multiple\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_Rec_Ptr   No input record\nC7020    DS    0H\n         ICM   R1,B'1111',@_SYSUT1_AtL_Ptr A(Above-the-line storage)\n         BZ    C7030                  None, skip\n         L     R0,0(0,R1)             Get Subpool, length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_AtL_Ptr   No storage now\nC7030    DS    0H\n         ICM   R1,B'1111',@_SYSUT1_BtL_Ptr A(Below-the-line storage)\n         BZ    C7040                  None, skip\n         L     R0,0(0,R1)             Get Subpool, length\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_SYSUT1_BtL_Ptr   No storage now\n\nC7040    DS    0H\n         LA    R15,4                  SET THE RETURN CODE\n         B     C9000                  AND EXIT\n\nC9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@C_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         PUSH PRINT\n         PRINT NOGEN\n\n         READ  C_READ,SF,0,0,'S',MF=L\nC_READ_Length EQU  *-C_READ\n\nC_CLOSE    CLOSE (0),MODE=31,MF=L\nC_CLOSE_Length EQU   *-C_CLOSE\n\n         POP   PRINT\n\n         LTORG\n\n@C_Dynam              DSECT           Dynamic area for C\n@C_Save               DS   18F         O/S Style save area\n@C_DBLWD              DS   D           Work area\n@C_Return_Ptr         DS   AL4         A(Last byte formatted by F0010)\n@C_Seg_Count          DS   HL2         Nbr segs in curr record\n@C_Init_PBlock        DS   FL4         Phys Block of start of record\n@C_Init_Seg           DS   FL4         Seg # of start of record\n@C_SegErr_Init_PBlock DS   FL4         Phys Blk of start of seg err\n@C_SegErr_Init_Seg    DS   FL4         Segment# of start of seg err\n@C_SegErr_Init_Date   DS   PL4         Date of valid rec pre seg err\n@C_SegErr_Init_Time   DS   FL4         Time of valid rec pre seg err\n@C_SegErr_Seg_Count   DS   FL4         Nbr segments dropped\n                      DS   X           Flag byte\n@C_Last_Segment       EQU  *-1,X'80'    1... .... Last segment\n@C_Skipping_Segs      EQU  *-1,X'40'    .1.. .... Skipping Segments\n\n@C_Macro              DS   0F          Temp area for Macro L-Forms\n@C_EParms             EQU  *            Parms for E0010\n@C_EP_Input_Ptr       DS   AL4           A(INPUT AREA)\n@C_EP_Input_Len       DS   FL4           LEN OF INPUT AREA\n@C_EP_Input_Off       DS   FL4           CURRENT OFFSET\n@C_EP_Output_Ptr      DS   AL4           A(OUTPUT AREA)\n@C_EP_Output_Len      DS   FL4           OUTPUT AREA LENGTH\n@C_EP_Pr_Flag_Ptr     DS   AL4           A(Print flag)\n                      ORG  @C_Macro\n@C_DateConv_Area      DS   CL(DConv_Area_Length)  Date conversion area\n@C_FParms             DS   3AL4          Parms for F0010\n                      ORG  @C_Macro\n@C_SHOWCB             DS   CL(C_SHOWCB_Length) SHOWCB Macro\n@C_SYSUT1_EXLST_Ptr   DS   AL4           A(SYSUT1 EXLST)\n                      ORG  @C_Macro\n@C_MODCB              DS   CL(C_MODCB_Length) MODCB Macro\n                      ORG  @C_Macro\n@C_Close              DS   CL(C_CLOSE_Length)  Close macro\n\n                      ORG  ,\n                      DS   0D          Alignment\n@C_DynLen             EQU  *-@C_Dynam Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'D0000: Process selected record'\n\n         PUSH  USING\n\nD0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : D0010                                                  *\n*                                                                     *\n*  Abstract  : Write the selected input record to the output file(s). *\n*                                                                     *\n*  Inputs    : R1 ----> A(Input SMF record)                           *\n*                       A(ODTE entry)                                 *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING D0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@D_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@D_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @D_Dynam,R13             Assign a base\n         L     R15,@D_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  Off our flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get the address of the SMF record, and the ODT Entry that      *\n*   selected it                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,0(0,R1)              A(SMF record)\n\n         L     R10,4(0,R1)              A(ODT Entry)\n         USING ODT_Entry,R10            Tell the assembler\n\n         LR    R1,R15                   Set up A(SMF record)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE SELECTED A RECORD. WE BUMP THE SELECTED COUNT, PRINT   *\n*   IT (IF REQUIRED) AND WRITE IT (IF REQUIRED) TO SYSUT2.          *\n*                                                                   *\n*   ON ENTRY, R1 = A(SELECTED RECORD)                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_Selected      GET SELECTED COUNT\n         LA    R15,1(0,R15)           BUMP IT\n         ST    R15,ODTE_Selected      AND SAVE IT\n\n         SLR   R15,R15                Clear work regiater\n         IC    R15,SMF0RTY-SMFRCD0(R1) Get record type\n         SLL   R15,2                  times 4\n         LA    R15,ODTE_Output_Count_Table(R15) A(Our counter)\n         L     R0,0(0,R15)            Get count\n         AL    R0,=FL4'1'             Bump it\n         ST    R0,0(0,R15)            Save it\n\n         ICM   R15,B'1111',ODTE_DCB_Ptr A(Output DCB)\n         BZ    D0110                  None, exit\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS DCB OPEN?\n         BZ    D0110                  NO, exit quick smart\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND WRITE IT TO THE OUTPUT, IF POSSIBLE.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_Rec_Ptr    SAVE A(INPUT RECORD)\n         ICM   R1,B'1111',ODTE_DCB_Ptr  A(Output DCB)\n         BZ    D9000                  None, skip\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN IS OUTPUT OPEN?\n         BZ    D9000                  NO, SKIP\n         LH    R3,SMF0LEN-SMFRCD0(R2) GET INPUT RECORD LEN\n         LH    R0,ODTE_LRECL          GET MAX OUTPUT RECORD LEN\n         TM    DCBRECFM-IHADCB(R1),DCBRECV OUTPUT RECFM=F?\n         BO    D0080                  NO, SKIP\n         LA    R2,4(0,R2)             YES, POINT PAST RDW\n         SH    R3,=H'4'                DECREMENT THE LENGTH\n         B     D0100                   and skip\nD0080    DS    0H\n         CR    R3,R0                  INPUT GREATER THAN MAX OUTPUT?\n         BNH   D0090                  NO, OK\n         TM    DCBRECFM-IHADCB(R1),DCBRECV+DCBRECSB RECFM=VS?\n         BO    D0090                  YES, SKIP\n         OI    ODTE_Trunc,L'ODTE_Trunc INDICATE TRUNCATION\n         STH   R0,SMF0LEN-SMFRCD0(R2) Update RDW temporarily\n         OI    @D_RDW_Updated,L'@D_RDW_Updated  and set our flag\nD0090    DS    0H\n         TM    DCBRECFM-IHADCB(R1),DCBRECU OUT RECFM = U?\n         BNO   D0100                  NO, SKIP\n         STH   R3,DCBLRECL-IHADCB(R1) YES, UPDATE LRECL\nD0100    DS    0H\n         LR    R0,R2                  A(Output record)\n         PUT   (1),(0)                Write output\n\n         TM    @D_RDW_Updated,L'@D_RDW_Updated  Did we change RDW?\n         BNO   D0110                  No, skip\n         STH   R3,SMF0LEN-SMFRCD0(R2) Yes, restore it\n         NI    @D_RDW_Updated,X'FF'-L'@D_RDW_Updated  and off our flag\n\nD0110    DS    0H\n         SLR   R15,R15                Clear return code\n         B     D9000                  and exit\n\nD9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                 Save return code\n\n         LA    R1,@D_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@D_Dynam        DSECT                 Dynamic area for D\n@D_Save         DS    18F              O/S Style save area\n                DS    X                Flag Byte\n@D_RDW_Updated  EQU   *-1,X'80'         1... .... Record length updated\n                DS    0D               Alignment\n@D_DynLen       EQU   *-@D_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10                    Free ODT Entry base\n         DROP  R11,R13\n         POP   USING\n         TITLE 'E0000: FORMAT RECORD FOR PRINT'\n\n         PUSH  USING\n\nE0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : E0010                                                  *\n*                                                                     *\n*  Abstract  : Print selected input record                            *\n*                                                                     *\n*  Inputs    : R1 ----> A(Input SMF record)                           *\n*                       A(ODTE entry)                                 *\n*                                                                     *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error encountered                             *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING E0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@E_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@E_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @E_Dynam,R13             Assign a base\n         L     R15,@E_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Save the addresses of the input record, and of our ODT entry   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,0(0,R1)            Get A(Input record)\n         ST    R15,@E_Record_Ptr      Save it\n         L     R15,4(0,R1)            Get A(ODT Entry)\n         ST    R15,@E_ODTE_Ptr        Save it\n\n         L     R2,@E_Record_Ptr       A(Start of record)\nE0015    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Format the offset into the output record ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                 Get current posn in input rec\n         S     R15,@E_Record_Ptr      Convert to an offset\n         STH   R15,@E_DBLWD           Save it\n         MVI   @E_DBLWD+2,X'FE'       MAKE IT \"PACKED\"\n         L     R15,@_SYSPRINT_Rec_Ptr Get A(Output\n         LA    R15,18(0,R15)            area)\n         UNPK  0(5,R15),@E_DBLWD(3)   UNPACK IT\n         TR    0(5,R15),E_Hexnum      TRANSLATE TO HEX\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and set up some of our addresses                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R3,@_SYSPRINT_Rec_Ptr  A(Output\n         LA    R3,18(0,R3)              area)\n         L     R4,@E_Record_Ptr       Get length\n         AH    R4,SMF0LEN-SMFRCD0(R4)  of input record\n         SR    R4,R2                   remaining\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check to see if we are printing EBCDIC                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@E_ODTE_Ptr        A(Print flag)\n         TM    ODTE_Print_EB-ODT_Entry(R15),L'ODTE_Print_EB  EBCDIC?\n         BO    E0080                  Yes, go do it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are printing in Dump format (32 bytes per line) ...         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         C     R4,=F'32'              MORE THAN OUR MAX?\n         BNH   E0020                  NO, SKIP\n         L     R4,=F'32'              YES, ONLY PRINT 32\nE0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... with EBCDIC translation on the right-hand side             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVI   80(R3),C'*'            OPENING ASTERISK\n         SH    R4,=H'1'               EXECUTE LENGTH OF DATA\n         LA    R14,81(0,R3)           A(OUTPUT AREA)\n         EX    R4,E9996               MOVE TO EBCDIC AREA\n         EX    R4,E9997               TRANSLATE UNPRNTBL TO .\n         MVI   113(R3),C'*'           CLOSING ASTERISK\n         LA    R4,1(0,R4)             RESTORE LENGTH\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and hex data in groups of 4 bytes                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R3,6(0,R3)             A(START OF HEX DATA)\n         LA    R5,4                   GROUPS OF 4 BYTES EACH\nE0030    DS    0H\n         LA    R6,4                   DO 4 GROUPS\nE0040    DS    0H\n         CR    R4,R5                  CAN WE DO 4 BYTES?\n         BH    E0050                  YES, SKIP\n         LR    R5,R4                  NO, DO AS MANY AS WE CAN\nE0050    DS    0H\n         SH    R5,=H'1'               EXEC LEN OF DATA\n         LA    R14,@E_DBLWD           A(TARGET AREA)\n         EX    R5,E9996               MOVE TO DBLWD\n         LA    R15,@E_DBLWD(R5)       POINT TO LAST BYTE\n         MVI   1(R15),X'FE'           PUT IN SIGN\n         LA    R5,1(0,R5)             RESET LEN OF DATA\n         LR    R0,R5                  CALCULATE UNPACKED LEN =\n         SLL   R0,1                     = (R5 * 2)\n         LR    R15,R0                 PUT IN EXEC REGISTER\n         SLL   R15,4                  MAKE ROOM FOR PACKED LEN\n         OR    R15,R5                 GET PACKED LEN\n         EX    R15,E9999              UNPACK IT\n         LR    R14,R3                 A(OUTPUT AREA)\n         SRL   R15,4                  LENGTH OF OUTPUT ONLY\n         EX    R15,E9998              AND TRANSLATE IT\n         AR    R3,R0                  A(NEXT\n         LA    R3,1(0,R3)                    OUTPUT BYTE)\n         AR    R2,R5                  A(NEXT INPUT BYTE\n         SR    R4,R5                  NBR BYTES LEFT TO DO\n         BNP   E0100                  None, were finished this line\n         BCT   R6,E0040               DO NEXT GROUP OF 4\n         LA    R3,1(0,R3)             EXTRA BLANK IN THE MIDDLE\n         B     E0030                  AND DO ANOTHER GROUP OF 4\n\nE0080    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE SELECTED RECORD IN EBCDIC ONLY.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LH    R15,@_SYSPRINT_Rec_Len GET MAX LRECL\n         SH    R15,=H'24'             LESS STUFF WE HAVE USED\n         CR    R4,R15                 IS INPUT TOO LONG?\n         BNH   E0090                  NO, OK\n         LR    R4,R15                 YES, PRINT AS MUCH AS WE CAN\nE0090    DS    0H\n         LA    R14,6(0,R3)            A(OUTPUT AREA)\n         SH    R4,=H'1'               EXECUTE LENGTH OF DATA\n         EX    R4,E9996               MOVE TO EBCDIC AREA\n         EX    R4,E9997               TRANSLATE UNPRNTBL TO .\n         LA    R4,1(0,R4)             Restore length printed\n         AR    R2,R4                  Bump input pointer\nE0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The print line has been formatted, so print it ...             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Print our line\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and if there is more input record to format, do it.        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@E_Record_Ptr      Get A(Input record)\n         LR    R15,R2                 Calculate current\n         SR    R15,R14                 offset\n         CH    R15,SMF0LEN-SMFRCD0(R14)  Compare against record length\n         BNL   E9000                  All done, exit\n         B     E0015                  Keep going\nE9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@E_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nE9996    MVC   0(0,R14),0(R2)\nE9997    TR    0(0,R14),E_PrtTbl\nE9998    TR    0(0,R14),E_Hexnum\nE9999    UNPK  0(0,R3),@E_DBLWD(0)\n\nE_Hexnum EQU   *-239\n         DC    C' 0123456789ABCDEF'\n\nE_PrtTbl DC    C'................'        00-0F\n         DC    C'................'        10-1F\n         DC    C'................'        20-2F\n         DC    C'................'        30-3F\n         DC    C' ...........<(+]'        40-4F\n         DC    C'&&.........|$*);\u00ac'       50-5F\n         DC    C'-/.........,%_>?'        60-6F\n         DC    C'..........:#@''=\"'       70-7F\n         DC    C'.abcdefghi......'        80-8F\n         DC    C'.jklmnopqr......'        90-9F\n         DC    C'..stuvwxyz......'        A0-AF\n         DC    C'................'        B0-BF\n         DC    C'.ABCDEFGHI......'        C0-CF\n         DC    C'.JKLMNOPQR......'        DO-DF\n         DC    C'..STUVWXYZ......'        E0-EF\n         DC    C'0123456789......'        F0-FF\n\n         LTORG\n\n@E_Dynam        DSECT                 Dynamic area for E\n@E_Save         DS    18F              O/S Style save area\n@E_DBLWD        DS    D                Work area\n@E_Record_Ptr   DS    AL4              A(Input record)\n@E_ODTE_Ptr     DS    AL4              A(ODT Entry)\n                DS    0D               Alignment\n@E_DynLen       EQU   *-@E_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'F0000 - Format Date/Times for output'\n         PUSH  USING\n\nF0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : F0010                                                  *\n*                                                                     *\n*  Abstract  : Format Date/Time from DateConv area to printable       *\n*                                                                     *\n*  Inputs    : R1 ----> A(DateConv_Area)                              *\n*                       A(Start of output area)                       *\n*                       A(Word in which to return the address of      *\n*                         the last byte of formatted data)            *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error in conversion routine                   *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING F0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@F_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@F_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @F_Dynam,R13             Assign a base\n         L     R15,@F_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         L     R9,0(0,R1)               A(Date conv area)\n         L     R8,4(0,R1)               A(Output area)\n         L     R15,8(0,R1)              Get A(return area)\n         ST    R15,@F_Return_Ptr        Save it\n\n         LR    R1,R9                    Point to DateConv area\n         L     R15,=A(K0010)            A(Date conversion routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  Did it work?\n         BNZ   F8010                    No, exit doing nothing\n\n         MVI   0(R8),C' '               OK, blank out\n         MVC   1(29,R8),0(R8)             our receiving area\n         USING DateConv_Area,R9         and assign a DateConv base\n\n         MVC   0(L'DConv_Date_Day,R8),DConv_Date_Day\n         LA    R8,L'DConv_Date_Day-1(0,R8) A(Last char)\nF0020    DS    0H\n         CLI   0(R8),C' '            End of Day name?\n         BNE   F0030                 Yes, skip\n         BCT   R8,F0020              No, try again\nF0030    DS    0H\n         MVI   1(R8),C','            Insert separator\n         MVC   3(L'DConv_Date_Month,R8),DConv_Date_Month  Month name\n         LA    R8,3+L'DConv_Date_Month-1(0,R8) A(Last char)\nF0040    DS    0H\n         CLI   0(R8),C' '            End of Month name?\n         BNE   F0050                 Yes, skip\n         BCT   R8,F0040              No, try again\nF0050    DS    0H\n         SLR   R0,R0                 Clear work reg\n         IC    R0,DConv_Date_DD      Get Day of month\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  1(3,R8),@F_DBLWD+6(2)  unpack it\n         MVI   1(R8),C' '            Clear spurious digit\n         LA    R8,2(0,R8)            point to 1st char\n         CLI   0(R8),C'0'            Leading 0?\n         BNE   F0060                 No, skip\n         MVC   0(1,R8),1(R8)         Yes, left align day\n         SH    R8,=H'1'              and adjust pointer\nF0060    DS    0H\n         OI    1(R8),X'F0'           Make it readable\n         MVI   2(R8),C','            Insert separator\n         LH    R0,DConv_Date_YYYY    Get year\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  3(5,R8),@F_DBLWD+5(3) Unpack it\n         MVI   3(R8),C' '            Clear spurious character\n         OI    7(R8),X'F0'           Make it readable\n         MVI   9(R8),C'('            Move separator\n         MVC   10(4,R8),4(R8)        Move YYYY\n         MVI   14(R8),C'.'           Move separator\n         LH    R0,DConv_Date_DDD     Get day of year\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  15(3,R8),@F_DBLWD+6(2) Unpack it\n         OI    17(R8),X'F0'          Make it readable\n         MVI   18(R8),C')'           Move close paren\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_hh      Get hours\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  19(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   19(R8),C' '           Clear spurious char\n         OI    21(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_mm      Get minutes\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  22(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   22(R8),C':'           Clear spurious char\n         OI    24(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_ss      Get seconds\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  25(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   25(R8),C':'           Clear spurious char\n         OI    27(R8),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,DConv_Time_tt      Get hundredths of seconds\n         CVD   R0,@F_DBLWD           Pack it\n         UNPK  28(3,R8),@F_DBLWD+6(2) Unpack it\n         MVI   28(R8),C'.'           Clear spurious char\n         OI    30(R8),X'F0'          Make it readable\n\n         LA    R8,30(0,R8)           A(Last byte of data)\n         L     R15,@F_Return_Ptr     A(Caller's area)\n         ST    R8,0(0,R15)           Save it for the caller\n\n         SLR   R15,R15               Clear return code\n         B     F9010                  and exit\nF8010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Error from Date conversion routine                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     F9010           and exit\n\nF9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@F_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         LTORG\n\n@F_Dynam        DSECT                 Dynamic area for F\n@F_Save         DS    18F              O/S Style save area\n@F_DBLWD        DS    D                Work area\n@F_Return_Ptr   DS    AL4              A(Return area)\n                DS    0D               Alignment\n@F_DynLen       EQU   *-@F_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R9                     Free DateConv_Area base\n         DROP  R11,R13\n         POP   USING\n         TITLE 'G0000: WRITE SYSPRINT'\n\n         PUSH  USING\n\nG0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : G0010                                                  *\n*                                                                     *\n*  Abstract  : Write SYSPRINT record, producing page titles if        *\n*              required                                               *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSPRINT not usable                           *\n*                                                                     *\n*  Notes     : If SYSPRINT is not OPEN, an attempt is made to OPEN it.*\n*              On exit, @SYSPRINT_Rec_Ptr is updated with the         *\n*                       address of the next SYSPRINT record area.     *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING G0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@G_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@G_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @G_Dynam,R13             Assign a base\n         L     R15,@G_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we havent opened our DCB yet, do so                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)\n         BNZ   G0030                    OK, skip\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=G_SYSPRINT_DCB_Length, this long                 +\n               LOC=BELOW                 below-the-line\n\n         ST    R1,@_SYSPRINT_DCB_Ptr    Save it\n         MVC   0(G_SYSPRINT_DCB_Length,R1),G_SYSPRINT_DCB\n\n         MVC   @G_Open,G_Open         Move OPEN parms\n         L     R2,@_SYSPRINT_DCB_Ptr  Point to the DCB\n         MVC   0(G_SYSPRINT_DCB_Length,R2),G_SYSPRINT_DCB\n         OPEN  ((2),OUTPUT),MODE=31,MF=(E,@G_Open) and open it\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?\n         BZ    G8000                  No, exit quick smart\n         LH    R15,DCBLRECL-IHADCB(R2) Yes, get record length\n         TM    DCBRECFM-IHADCB(R2),DCBRECCC CC present?\n         BZ    G0020                  No, skip\n         SH    R15,=H'1'              Yes, decrement length\nG0020    DS    0H\n         STH   R15,@_SYSPRINT_Rec_Len Save data length of SYSPRINT\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n\nG0030    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE CURRENT SYSPRINT RECORD, CLEAR THE NEW RECORD AREA,  *\n*   AND BUMP THE LINE COUNT.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN  IS SYSPRINT OPEN?\n         BNO   G8000                  NO, EXIT\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)\n         LH    R15,@_Line_Count       Get current Line Count\n         LA    R15,1(0,R15)           Bump it\n         STH   R15,@_Line_Count       Save it\n         CH    R15,=H'60'             End of a page?\n         BL    G0050                  Not yet, exit\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SKIP TO A NEW PAGE, AND PRINT THE HEADING.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R0,R1                  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         MVI   0(R1),C'1'             START A NEW PAGE\n         LA    R15,@_DateConv_Area    A(Info about today)\n         ST    R15,@G_Parms           Save it\n         LA    R15,1(0,R1)            A(Output area)\n         ST    R15,@G_Parms+4         Save it\n         LA    R15,@G_LastChar        A(Return area)\n         ST    R15,@G_Parms+8         Save it\n         LA    R1,@G_Parms            Point to parms\n         L     R15,=A(F0010)          A(Format routine)\n         BASR  R14,R15                Go do it\n         LH    R15,@_SYSPRINT_Rec_Len GET SYSPRINT RECORD LENGTH\n         A     R15,@_SYSPRINT_Rec_Ptr POINT PAST END OF RECORD\n         LA    R14,L'G_Hdg1PP+L'G_Hdg1P+1 LEN OF PAGE NUMBER STUFF\n         SR    R15,R14                OFFSET OF PAGE NBR STUFF\n         MVC   0(L'G_Hdg1PP+L'G_Hdg1P,R15),G_Hdg1PP MOVE IT\n         AP    @_Page_Count,=P'1'     BUMP PAGE COUNT\n         ED    G_Hdg1P-G_Hdg1PP(L'G_Hdg1P,R15),@_Page_Count EDIT IT IN\n         L     R14,@G_LastChar        A(Last char of Date/Time)\n         SR    R15,R14                Len of white space\n         LA    R14,L'G_Hdg1TITL       LEN OF TITLE\n         SR    R15,R14                GET DIFFERENCE\n         SRL   R15,1                  HALVE IT (IE, CENTRE TITLE)\n         A     R15,@G_LastChar        A(output area)\n         MVC   0(L'G_Hdg1TITL,R15),G_Hdg1TITL MOVE TITLE\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save A(SYSPRINT Record)\n         LA    R15,1                  SET RECORD COUNT\n         STH   R15,@_Line_Count       AND SAVE IT\n         TM    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO\n         BO    G0040                  NO, SKIP THESE HEADINGS\n         LR    R0,R1\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         LA    R15,X'40'\n         SLL   R15,24\n         LA    R14,L'G_Hdg2A\n         OR    R15,R14\n         LA    R14,G_Hdg2A\n         MVCL  R0,R14\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         LR    R0,R1\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         LA    R15,X'40'\n         SLL   R15,24\n         LA    R14,L'G_Hdg2B\n         OR    R15,R14\n         LA    R14,G_Hdg2B\n         MVCL  R0,R14\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer\n         LR    R0,R1                  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         PUT   (1)                    WRITE IT\n         ST    R1,@_SYSPRINT_Rec_Ptr  Save record pointer\n         LA    R15,3                  SET RECORD COUNT\n         AH    R15,@_Line_Count       INCREMENT LINT COUNT\n         STH   R15,@_Line_Count       AND SAVE IT\nG0040    DS    0H\nG0050    DS    0H\n         L     R0,@_SYSPRINT_Rec_Ptr  Clear\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT)\n         LH    R1,DCBLRECL-IHADCB(R1)  Get output length\n         SLR   R14,R14                 output\n         LA    R15,X'40'               record\n         SLL   R15,24                  area to\n         MVCL  R0,R14                  blanks\n         L     R1,@_SYSPRINT_Rec_Ptr  Restore record pointer\n         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT)\n         TM    DCBRECFM-IHADCB(R15),DCBRECCC  ANY CONTROL CHAR?\n         BZ    G0060                  NO, SKIP\n         LA    R1,1(0,R1)             YES, POINT PAST IT\nG0060    DS    0H\n         ST    R1,@_SYSPRINT_Rec_Ptr  SAVE A(OUTPUT AREA)\n         SLR   R15,R15                Clear return code\n         B     G9000                  AND EXIT\nG8000    DS    0H\n         LA    R15,4                  Error opening SYSPRINT\n         B     G9000                  AND EXIT\nG9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Save the return code\n\n         LA    R1,@G_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nG_SYSPRINT_DCB DCB DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,        +\n               RECFM=FBA\nG_SYSPRINT_DCB_Length EQU *-G_SYSPRINT_DCB\n\nG_Open   OPEN  (0,INPUT),MODE=31,MF=L\nG_Open_Length EQU *-G_Open\n\nG_Hdg1TITL DC  C'SMFSLCT &VERSION'\nG_Hdg1PP DC    C'PAGE'\nG_Hdg1P  DC    X'40202120'            PAGE NUMBER MASK\n\nG_Hdg2A  DC    C'0  Input    Sel    Off-'\nG_Hdg2B  DC    C'   Count  Count     set  Data'\n\n         LTORG\n\n@G_Dynam        DSECT                 Dynamic area for G\n@G_Save         DS    18F              O/S Style save area\n                DS    0F               Alignment\n@G_Open         DS    CL(G_Open_Length)  Open parms\n@G_Parms        DS    3AL4             Parm area for F0010\n@G_LastChar     DS    AL4              Return area from F0010\n                DS    0D               Alignment\n@G_DynLen       EQU   *-@G_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'H0000: INTERPRET CONTROL CARDS'\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : H0010                                                  *\n*                                                                     *\n*  Abstract  : READ SYSIN control cards, and branch to interpretation *\n*              routines (Hx0010)                                      *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - Error in SYSIN Control Cards                  *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nH0010    DS    0H\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING H0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@H_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@H_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @H_Dynam,R13             Assign a base\n         L     R15,@H_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@H_rc                and clear return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    OPEN SYSIN.                                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   5(20,R1),=C'Input Control Cards:' MOVE HEADING\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT blank line\n         L     R1,@_SYSPRINT_Rec_Ptr  A(NEW SYSPRINT RECORD)\n         MVC   1(30,R1),=C'--- No Control Cards found ---'\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=H_SYSIN_DCB_Length,   this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         ST    R1,@H_SYSIN_DCB_Ptr    Save A(SYSIN DCB area)\n         MVC   @H_OPEN,H_OPEN         Move OPEN parms\n         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB\n         MVC   0(H_SYSIN_DCB_Length,R2),H_SYSIN_DCB Move DCB\n         MVC   @H_SYSIN_DCBE,H_SYSIN_DCBE Move SYSIN DCBE\n         LA    R15,@H_SYSIN_DCBE      Point to it\n         ST    R15,DCBDCBE-IHADCB(R2) Update address in DCB\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?\n         BZ    H9000                  NO, SKIP\n         TM    @H_SYSIN_DCBE+DCBEFLG1-DCBE,DCBEMD31 31-bit SAM OK?\n         BO    H0020                  Yes, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   31-bit SAM is not supported for SYSIN. This typically happens     *\n*  when it is allocated to the terminal in a TSO session (the I/O     *\n*  seems to be OK, but the EOD handling gets in trouble). So ...      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... close the current DCB ...                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   @H_CLOSE,H_CLOSE       Move close parms\n         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB\n         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... move a normal DCB (without the DCBE) to the 24-bit area ...    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   0(H_SYSIN24_DCB_Length,R2),H_SYSIN24_DCB Move DCB\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  ... and move the 24-bit EOD to below-the-line storage              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=H800024_Length,       this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         MVC   0(H800024_Length,R1),H800024_Start Move 24-bit EOD\n         O     R1,DCBEODAD-IHADCB(R2)     Set up\n         ST    R1,DCBEODAD-IHADCB(R2)      EODAD\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Open SYSIN                                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   @H_OPEN,H_OPEN           Move OPEN parms\n         L     R2,@H_SYSIN_DCB_Ptr      POINT TO THE DCB\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@H_OPEN) AND OPEN IT\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN  IS IT OPEN?\n         BZ    H9000                  NO, SKIP\n\nH0020    DS    0H\n         L     R10,@_ODT_Ptr          A(ODT Table)\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\nH0030    DS    0H\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    Read a control card from SYSIN, and print it.                 *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         L     R1,@H_SYSIN_DCB_Ptr    A(SYSIN DCB)\n         GET   (1)                    READ A SYSIN RECORD\n         LR    R2,R1                  SAVE A(INPUT RECORD)\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         LH    R3,DCBLRECL-IHADCB(R15) GET SYSIN RECORD LENGTH\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         CH    R3,@_SYSPRINT_Rec_Len  CAN WE FIT SYSIN ON SYSPRINT?\n         BNH   H0040                  YES, SKIP\n         LH    R3,@_SYSPRINT_Rec_Len  NO, PUT AS MUCH AS WE CAN\nH0040    DS    0H\n         SH    R3,=H'1'               GET EXECUTE LENGTH\n         EX    R3,H9998               MOVE TO SYSPRINT RECORD\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                AND WRITE IT\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         LH    R3,DCBLRECL-IHADCB(R15) INPUT RECORD LENGTH\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    If it is a comment ('*' in Col 1), ignore it.                 *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         CLI   0(R2),C'*'             Is this a comment?\n         BE    H0030                  Yes, get another record\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    Otherwise, skip leading blanks.                               *\n*                                                                  *\n*------------------------------------------------------------------*\n\nH0050    DS    0H\n         CLI   0(R2),C' '             IS THIS A LEADING BLANK?\n         BNE   H0060                  NO, SKIP\n         LA    R2,1(0,R2)             YES, BUMP INPUT POINTER\n         BCT   R3,H0050               AND CHECK NEXT CHARACTER\n         B     H0030                  ALL BLANK, IGNORE IT\nH0060    DS    0H\n\n\n*------------------------------------------------------------------*\n*                                                                  *\n*    At this point, R2 --> first non-blank character               *\n*                   R3 = nbr characters left on input record       *\n*                                                                  *\n*------------------------------------------------------------------*\n\n         LA    R4,H_Keyword_Table     A(Keyword Table)\n         LA    R5,H_Keyword_Table_End A(End of Keyword Table)\nH0070    DS    0H\n         LA    R15,8                  Set return code, just in case\n         CR    R4,R5                  End of Table?\n         BNL   H0100                  Yes, skip\n         SLR   R15,R15                No, clear R15\n         IC    R15,H_Keyword_Len-H_Keyword_Table(R4) Get len of Keyword\n         CR    R15,R3                 Could this be it?\n         BNL   H0080                  No, check next keyword\n         EX    R15,H9999              Yes, is this it?\n         BE    H0090                  Yes, skip\nH0080    DS    0H\n         LA    R4,1+L'H_Keyword_Rtn+L'H_Keyword_Len(R15,R4)\n         B     H0070                  Check out next entry\nH0090    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have identified the keyword - point R2 to the start of the  *\n*   operand field, adjust the length remaining, and go process the  *\n*   keyword stuff.                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,1(R15,R2)           A(START OF OPERANDS)\n         ST    R2,@H_Parms            Save it\n         SR    R3,R15                 ADJUST LENGTH REMAINING\n         SH    R3,=H'1'               SET IT UP PROPERLY\n         BNP   H0100                  INVALID, SKIP\n         ST    R3,@H_Parms+4          Save it\n         ST    R10,@H_Parms+8         Save A(ODT Entry)\n         LA    R1,@H_Parms            A(Parameters)\n         L     R15,H_Keyword_Rtn-H_Keyword_Table(R4) A(Proc Rtn)\n         BASR  R14,R15                Go process keyword operands\n         LTR   R15,R15                OK?\n         BNZ   H0100                  No, error message\n\n         LM    R2,R3,@H_Parms         Reload our registers\n         L     R10,@H_Parms+8         A(Current ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We are back: R2 --> next byte after operands, and              *\n*                 R3 = length remaining                             *\n*    If r2 is not pointing to a space, we have more keywords to     *\n*   look for; if not, we are finished with this record.             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LTR   R3,R3                  Anything left?\n         BNP   H0030                  No, go get next record\n         CLI   0(R2),C' '             Yes, are we done?\n         BE    H0030                  Yes, get next record\n         CLI   0(R2),C','             No, is it a separator?\n         LA    R15,4                  Set return code, just in case\n         BNE   H0100                  Not a separator, error\n         LA    R2,1(0,R2)             Yes, skip separator\n         BCT   R3,H0060               and check next keyword\n         LA    R15,4                  Non-blank last char, error\nH0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have found an error in the control cards - tell the user.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         C     R15,@H_rc              Is this the highest return code?\n         BNH   H0110                  No, skip\n         ST    R15,@H_rc              Yes, save it\nH0110    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         L     R15,@H_SYSIN_DCB_Ptr   A(SYSIN DCB)\n         S     R2,DCBRECAD-IHADCB(R15) R2=Offset of error\n         LA    R2,1(R1,R2)            R2 = A(Column of error)\n         MVI   0(R2),C'?'             Move a flag\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go print it\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT record)\n         MVC   5(55,R1),=C'Error detected above ''?'' - remainder of re*\n               cord ignored.'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Go print it\n         B     H0030                  Read another record\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The following is the EOD exit when 31-bit SAM is not supported *\n*   for SYSIN. This code is moved to 24-bit storage, and is invoked *\n*   by SYSIN EOD. All it does is branch to out 'real' EOD routine,  *\n*   in 31-bit mode.                                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nH800024_Start DS 0H                  Start of 24-bit EOD Routine\n         PUSH  USING                  Save current USINGs\n         DROP  ,                      No USINGs now\n         BALR  R15,0                  Load up our base\n         USING *,R15                  Tell the Assembler\n         L     R15,H800024_EOD        Get real EODAD\n         BSM   0,R15                  and go do it (in 31-bit mode)\nH800024_EOD DC AL4(X'80000000'+H8000) Real EODAD\n         DROP  R15                    Free up our base reg\nH800024_Length EQU *-H800024_Start   Length of 24-bit EOD Routine\n         POP   USING                  Restore USING environment\n\n\nH8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'Real' End-Of-File exit for SYSIN: Close SYSIN                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@H_SYSIN_DCB_Ptr A(SYSIN DCB)\n         BZ    H8020                  None, skip\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN SYSIN OPEN?\n         BZ    H8010                  No, better not close it\n         MVC   @H_CLOSE,H_CLOSE       Yes, move close parms\n         L     R2,@H_SYSIN_DCB_Ptr    Point to the DCB\n         CLOSE ((2)),MODE=31,MF=(E,@H_CLOSE)  and close it\nH8010    DS    0H\n         L     R1,@H_SYSIN_DCB_Ptr    A(Below-the-line storage)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_24Bit_Stack_Ptr   on this stack\n\nH8020    DS    0H\n         B     H9000                  Exit\n\n\nH9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R3,@H_rc                 Rescue the return code\n\n         LA    R1,@H_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nH9998 MVC      0(0,R1),0(R2)          Move SYSIN record to SYSPRINT\nH9999 CLC      0(0,R2),H_Keyword-H_Keyword_Table(R4) Check keyword\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Table of command card Keywords, and A(Processing Routines).    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nH_Keyword_Table EQU  *\n*\nH_Keyword_Rtn   DC    AL4(HA0010)            A(PROCESSING ROUTINE)\nH_Keyword_Len   DC    AL1(5)                 EXECUTE LEN OF KEYWORD\nH_Keyword       DC    C'START='              KEYWORD\n*\n                DC    AL4(HA0010)            A(PROCESSING ROUTINE)\n                DC    AL1(3)                 EXECUTE LEN OF KEYWORD\n                DC    C'END='                KEYWORD\n\n                DC    AL4(HB0010)            A(PROCESSING ROUTINE)\n                DC    AL1(5)                 EXECUTE LEN OF KEYWORD\n                DC    C'PRINT='              KEYWORD\n\n                DC    AL4(HC0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'INCLUDE='            KEYWORD\n\n                DC    AL4(HC0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'EXCLUDE='            KEYWORD\n\n                DC    AL4(HD0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'JOBNAME='            KEYWORD\n\n                DC    AL4(HE0010)            A(PROCESSING ROUTINE)\n                DC    AL1(4)                 EXECUTE LEN OF KEYWORD\n                DC    C'DATA='               KEYWORD\n\n                DC    AL4(HF0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'JOB/DATA='           KEYWORD\n\n                DC    AL4(HG0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'STOPAFT='            KEYWORD\n\n                DC    AL4(HH0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'INEXIT='             KEYWORD\n\n                DC    AL4(HH0010)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'OUTEXIT='            KEYWORD\n\n                DC    AL4(HI0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'OUTPUT='             KEYWORD\n\n                DC    AL4(HJ0010)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'PERIOD='             KEYWORD\n\n                DC    AL4(HK0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'SEQUENCE='           KEYWORD\n\n                DC    AL4(HL0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'CHECKVBS='           KEYWORD\n\n                DC    AL4(HM0010)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'WEEKENDS='           KEYWORD\n\nH_Keyword_Table_End EQU *                END OF KEYWORD TABLE\n\n         PUSH  PRINT\n         PRINT NOGEN\nH_SYSIN_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,     +\n               DCBE=H_SYSIN_DCBE\nH_SYSIN_DCB_Length EQU *-H_SYSIN_DCB\n\nH_SYSIN_DCBE DCBE RMODE31=BUFF,EODAD=H8000\nH_SYSIN_DCBE_Length EQU  *-H_SYSIN_DCBE\n\nH_SYSIN24_DCB DCB  DDNAME=SYSIN,MACRF=GL,DSORG=PS,RECFM=FB,LRECL=80,   +\n               EODAD=0\nH_SYSIN24_DCB_Length EQU *-H_SYSIN24_DCB\n\nH_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nH_OPEN_Length  EQU   *-H_OPEN\nH_CLOSE  CLOSE (0),MODE=31,MF=L\nH_CLOSE_Length EQU   *-H_CLOSE\n         POP   PRINT\n\n         LTORG\n\n@H_Dynam        DSECT                 Dynamic area for H\n@H_Save         DS    18F              O/S Style save area\n@H_Parms        DS    3AL4             Parm area\n@H_rc           DS    FL4              Return code\n@H_SYSIN_DCB_Ptr DS   AL4              A(SYSIN DCB)\n@H_SYSIN_DCBE   DS    CL(H_SYSIN_DCBE_Length) Dynamic DCBE\n@H_Macros       DS    0F               Macro area\n@H_OPEN         DS    CL(H_OPEN_Length)\n                ORG   @H_Macros\n@H_CLOSE        DS    CL(H_CLOSE_Length)\n                ORG\n                DS    0D               Alignment\n@H_DynLen       EQU   *-@H_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHA0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'START='/'END=' Keyword Processor                              *\n*             Validate Date and Times specified                     *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Start/EndDate set           *\n*                      4 - ERROR FOUND                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HA0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HA_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HA_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HA_Dynam,R13            Assign a base\n         L     R15,@HA_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of START=/END= keyword                    *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         LR    R15,R2                   Point to chars\n         SH    R15,=HL2'2'               before operand\n         CLC   =C'T=',0(R15)            START=\n         BNE   HA0020                   No, must be END=\n         OI    @HA_Start_Proc,L'@HA_Start_Proc Yes, set flag\n         B     HA0030                   and skip\nHA0020   DS    0H\n         NI    @HA_Start_Proc,X'FF'-L'@HA_Start_Proc Off flag\n         B     HA0030                   and skip\nHA0030   DS    0H\n         OI    @HA_Date_Proc,L'@HA_Date_Proc SAY WE ARE DOING DATE\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Check for our Date keywords                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         LA    R14,HA_Keyword_Table    A(Keyword Table)\n         LA    R15,HA_Keyword_Table_End A(End of Keyword Table)\nHA0040   DS    0H\n         CR    R14,R15                End of Table?\n         BNL   HA0070                 Yes, skip\n         SLR   R1,R1                  No, clear work register\n         IC    R1,HA_Keyword_Len-HA_Keyword_Table(R14) Get len of Kwd\n         CR    R1,R3                  Could this be it?\n         BNL   HA0050                 No, check next keyword\n         EX    R1,HA9999              Yes, is this it?\n         BE    HA0060                 Yes, skip\nHA0050   DS    0H\n         LA    R14,1+L'HA_Keyword_Rtn+L'HA_Keyword_Len(R1,R14)\n         B     HA0040                 Check out next entry\nHA0060   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have identified the keyword - initialize our DateConv area  *\n*   with the info we retrieved when we initialized (ie, Today) ...  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @HA_DateConv_Area,@_DateConv_Area\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and go process it.                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,HA_Keyword_Rtn-HA_Keyword_Table(R14) A(Proc Rtn)\n         BR    R15                    Go process keyword operands\n\nHA0070   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    COMMON 'START='/'END=' KEYWORD PROCESSING                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nHA0080   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP THE TEMPORARY AREA WITH 0, AND POINT TO IT.             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @HA_TEMP(7),=C'0000000' PRIME RECEIVING AREA\n         LA    R4,@HA_TEMP            POINT TO IT\nHA0090   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND COUNT THE NUMERIC CHARACTERS IN THE OPERAND.               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HA0100                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, REALLY NUMERIC?\n         BH    HA0100                 NO, SKIP\n         MVC   0(1,R4),0(R2)          YES, MOVE THE CHARACTER\n         LA    R4,1(0,R4)             BUMP RECEIVING PTR\n         LA    R2,1(0,R2)             POINT TO NEXT CHAR\n         BCT   R3,HA0090              AND CHECK IT OUT\nHA0100   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE EITHER FOUND A NON-NUMERIC CHARACTER (IE, A SEPARATOR),*\n*   OR WE HAVE RUN OUT OF INPUT.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,@HA_TEMP            A(TEMP AREA)\n         SR    R4,R0                  GET CHARS IN INPUT\n         BNP   HA0140                 NO DATA, SKIP\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THE DATA SEEMS OK, SO WE WILL PACK IT.                         *\n*              R1   = A(START OF TARGET FIELDS)                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @HA_Time_Proc,L'@HA_Time_Proc ARE WE DOING TIME?\n         BO    HA0150                 YES, GO SET IT UP\n         CH    R4,=H'5'               NO, IS DATE 5 CHARS?\n         BNE   HA0110                 No, skip\n         PACK  @HA_DBLWD,@HA_TEMP(5)  YES, PACK IT\n         MVC   @HA_DBLWD+4(1),@_DateConv_Area+DConv_Date_SMFDate-DateCo+\n               nv_Area                Move current century\n         B     HA0120                 and skip\nHA0110   DS    0H\n         CH    R4,=H'7'               IS DATE 7 CHARS?\n         BNE   HA8000                 NO, ERROR\n         PACK  @HA_DBLWD,@HA_TEMP(7)  Yes, pack it\n         SP    @HA_DBLWD,=P'1900000'  Adjust for SMF Date convention\nHA0120   DS    0H\n         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?\n         BNO   HA0130                 No, must be END=\n         ZAP   ODTE_StartDate-ODT_Entry(L'ODTE_StartDate,R10),@HA_DBLWD+\n               +4(4)                  Save Start Date\n         B     HA0140                 And skip\nHA0130   DS    0H\n         ZAP   ODTE_EndDate-ODT_Entry(L'ODTE_EndDate,R10),@HA_DBLWD+4(4+\n               )                      Save End date\n         B     HA0140                 And skip\nHA0140   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW SEE IF WE HAVE ANY MORE TO DO.                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LTR   R3,R3                  ANY INPUT LEFT?\n         BZ    HA0180                 NO, WE'RE FINISHED\n         CLI   0(R2),C'-'             IS THIS THE DATE SEPARATOR?\n         BNE   HA0170                 NO, SKIP\n         TM    @HA_Date_Proc,L'@HA_Date_Proc WERE WE DOING THE DATE?\n         BNO   HA8000                 NO, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND THE DATE/TIME SEPARATOR, SO WE WILL GO DO THE    *\n*   TIME                                                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HA_Date_Proc,X'FF'-L'@HA_Date_Proc  Yes, Off Date flag\n         OI    @HA_Time_Proc,L'@HA_Time_Proc Now we are doing time\n         LA    R2,1(0,R2)             POINT OVER THE SEPARATOR\n         BCT   R3,HA0080              AND DO THE TIME\n         B     HA8000                 SEPARATOR BUT NO TIME, ERROR\nHA0150   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND THE TIME, SPECIFIED AS HHMMSS - WE MUST          *\n*   CONVERT IT TO SECONDS*100 SINCE MIDNIGHT                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         XC    @HA_DateConv_Area,@HA_DateConv_Area Clear Date area\n         PACK  @HA_DBLWD,@HA_TEMP(2)  PACK HH\n         CVB   R15,@HA_DBLWD          BINARIZE IT\n         STC   R15,@HA_DateConv_Area+DConv_Time_hh-DateConv_Area\n         PACK  @HA_DBLWD,@HA_TEMP+2(2) GET NBR MINUTES\n         CVB   R15,@HA_DBLWD          BINARIZE THEM\n         STC   R15,@HA_DateConv_Area+DConv_Time_mm-DateConv_Area\n         PACK  @HA_DBLWD,@HA_TEMP+4(2) PACK SECONDS\n         CVB   R15,@HA_DBLWD          BINARIZE THEM\n         STC   R15,@HA_DateConv_Area+DConv_Time_ss-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+\n               nv_Input_hhmmss       Indicate Time conversion\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get seconds since midnight\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         L     R15,@HA_DateConv_Area+DConv_Time-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc Processing START=?\n         BNO   HA0160                 No, must be END=\n         ST    R15,ODTE_StartTime-ODT_Entry(R10) Save Start Time\n         B     HA0170                 And skip\nHA0160   DS    0H\n         ST    R15,ODTE_EndTime-ODT_Entry(R10) Save End Time\n         B     HA0170                 And skip\nHA0170   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE FOUND A NON-NUMERIC CHARACTER - WE WILL EXIT, WITH     *\n*   THE RETURN CODE 0 IF IT IS A VALID SEPARATOR, 4 IF IT IS NOT.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C','             IS THIS A VALID SPEARATOR?\n         BE    HA0180                 YES, SKIP\n         CLI   0(R2),C' '             NO, TRY AGAIN\n         BNE   HA8000                 INVALID CHARACTER, ERROR\nHA0180   DS    0H\n         SLR   R15,R15                CLEAR RETURN CODE\n         B     HA9000                 AND EXIT\n\nHA1000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=TODAY                                                *\n*     On Entry, R2 = A(\"TODAY\")                                     *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"TODAY\"                          *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,5(0,R2)             Adjust pointer\n         SH    R3,=HL2'5'             Adjust chars remaining\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA2000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=(TODAY-n)                                            *\n*     On Entry, R2 = A(\"(TODAY-\")                                   *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"(TODAY-n)\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,7(0,R2)             Adjust pointer\n         SH    R3,=HL2'7'             Adjust chars remaining\n         BNP   HA8000                 Error, exit\n         LR    R14,R2                 Save A(start)\nHA2010   DS    0H\n         CLI   0(R2),C')'             Closing paren?\n         BE    HA2020                 Yes, skip\n         CLI   0(R2),C'0'             No, is it numeric?\n         BL    HA8000                 No, error\n         CLI   0(R2),C'9'             So far, is it really?\n         BH    HA8000                 No, error\n         LA    R2,1(0,R2)             Yes, bump pointer\n         BCT   R3,HA2010              and try again\n         B     HA8000                 No closing paren, error\nHA2020   DS    0H\n         LR    R15,R2                 A(closing paren)\n         SR    R15,R14                Length of numerics\n         BNP   HA8000                 Nothing, error\n         S     R15,=FL4'1'            EX length\n         EX    R15,HA2999             Pack it\n         CVB   R15,@HA_DBLWD          Binarize it\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SR    R14,R15                Adjust Base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         LA    R2,1(0,R2)            Point past closing paren\n         S     R3,=FL4'1'            Adjust length remaining\n         B     HA0120                 and exit\n\nHA2999   PACK  @HA_DBLWD,0(0,R14)     Pack offset from today\n\nHA3000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=YESTERDAY                                            *\n*     On Entry, R2 = A(\"YESTERDAY\"                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"YESTERDAY\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'1'            Adjust Base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA4000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=THISWEEK                                             *\n*     On Entry, R2 = A(\"THISWEEK\")                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"THISWEEK\"                       *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,8(0,R2)             Adjust pointer\n         SH    R3,=HL2'8'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15                Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA4010                 No, skip\n         SR    R14,R15                Yes, back up to Monday\n         B     HA4020                 and skip\nHA4010   DS    0H\n         LA    R0,6                   Day-of-week for Sunday\n         SR    R0,R15                 Nbr days until Sunday\n         AR    R14,R0                 Adjust base date\nHA4020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA5000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=LASTWEEK                                             *\n*     On Entry, R2 = A(\"LASTWEEK\")                                  *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"LASTWEEK\"                       *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,8(0,R2)             Adjust pointer\n         SH    R3,=HL2'8'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'7'            Back up a week\n         SLR   R15,R15                Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DOW-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA5010                 No, skip\n         SR    R14,R15                Yes, back up to Monday\n         B     HA5020                 and skip\nHA5010   DS    0H\n         LA    R0,6                   Day-of-week for Sunday\n         SR    R0,R15                 Nbr days until Sunday\n         AR    R14,R0                 Adjust base date\nHA5020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA6000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=THISMONTH                                            *\n*     On Entry, R2 = A(\"THISMONTH\")                                 *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"THISMONTH\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA6010                 No, skip\n         S     R15,=FL4'1'            Yes, nbr days past the 1st\n         SR    R14,R15                Back up to the 1st\n         B     HA6020                 and skip\nHA6010   DS    0H\n         LA    R0,27                  Minimum days-per-month-1\n         SR    R0,R15                 Nbr days until the 27th\n         AR    R14,R0                 Adjust base date\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R0,R0                  Clear work register\n         IC    R0,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area Get mon\nHA6012   DS    0H\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         A     R14,=FL4'1'            Bump a day\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         SLR   R15,R15               Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_MM-DateConv_Area\n         CR    R15,R0                Same month?\n         BE    HA6012                Yes, bump again\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         S     R14,=FL4'1'           Back up a day\nHA6020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA7000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    START/END=LASTMONTH                                            *\n*     On Entry, R2 = A(\"LASTMONTH\")                                 *\n*               R3 = Nbr chars left                                 *\n*     On Exit,  R2 ---> Byte after \"LASTMONTH\"                      *\n*               R3 = Nbr Chars left                                 *\n*               @HA_DBLWD contains SMF Date                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R2,9(0,R2)             Adjust pointer\n         SH    R3,=HL2'9'             Adjust chars remaining\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SLR   R15,R15\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         SR    R14,R15                Last day of prev month\n         TM    @HA_Start_Proc,L'@HA_Start_Proc doing a START=\n         BNO   HA7020                 No, all done\n\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         SLR   R15,R15               Clear work register\n         IC    R15,@HA_DateConv_Area+DConv_Date_DD-DateConv_Area\n         S     R15,=FL4'1'           Nbr days until the 1st\n         L     R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         SR    R14,R15               Back up to the 1st\nHA7020   DS    0H\n         ST    R14,@HA_DateConv_Area+DConv_Date_Base-DateConv_Area\n         OI    @HA_DateConv_Area+DConv_Input_Base-DateConv_Area,L'DConv+\n               _Input_Base           Indicate Base Date\n         LA    R1,@HA_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go new SMFDate\n         LTR   R15,R15               Everything OK?\n         BNZ   HA8000\n\n         ZAP   @HA_DBLWD,@HA_DateConv_Area+DConv_Date_SMFDate-DateConv_+\n               Area(L'DConv_Date_SMFDate) Set up Date\n         B     HA0120                 and exit\n\nHA8000   DS    0H\n         LA    R15,4                  SET RETURN CODE\n         B     HA9000                 AND EXIT\nHA9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HA_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHA9999 CLC     0(0,R2),HA_Keyword-HA_Keyword_Table(R14) Check keyword\n\nHA_Time   TIME  LINKAGE=SYSTEM,MF=L\nHA_Time_Length EQU *-HA_Time\n\nHA_Keyword_Table EQU *\n\nHA_Keyword_Rtn  DC    AL4(HA1000)            A(PROCESSING ROUTINE)\nHA_Keyword_Len  DC    AL1(4)                 EXECUTE LEN OF KEYWORD\nHA_Keyword      DC    C'TODAY'               KEYWORD\n\n                DC    AL4(HA2000)            A(PROCESSING ROUTINE)\n                DC    AL1(6)                 EXECUTE LEN OF KEYWORD\n                DC    C'(TODAY-'             KEYWORD\n\n                DC    AL4(HA3000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'YESTERDAY'           KEYWORD\n\n                DC    AL4(HA4000)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'THISWEEK'            KEYWORD\n\n                DC    AL4(HA5000)            A(PROCESSING ROUTINE)\n                DC    AL1(7)                 EXECUTE LEN OF KEYWORD\n                DC    C'LASTWEEK'            KEYWORD\n\n                DC    AL4(HA6000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'THISMONTH'           KEYWORD\n\n                DC    AL4(HA7000)            A(PROCESSING ROUTINE)\n                DC    AL1(8)                 EXECUTE LEN OF KEYWORD\n                DC    C'LASTMONTH'           KEYWORD\n\nHA_Keyword_Table_End EQU *                END OF KEYWORD TABLE\n\n         LTORG\n\n@HA_Dynam       DSECT                 Dynamic area for HA\n@HA_Save        DS    18F              O/S Style save area\n@HA_DBLWD       DS    D                Work area\n@HA_TEMP        DS    CL7              Work area\n                DS    X                Flag Byte\n@HA_Start_Proc  EQU   *-1,X'80'         1... .... Processing START=\n@HA_Date_Proc   EQU   *-1,X'02'         .... ..1. Processing Date\n@HA_Time_Proc   EQU   *-1,X'01'         .... ...1 Processing Time\n@HA_Macros      DS    0F\n@HA_Time        DS    CL(HA_Time_Length) L-Form of Time\n@HA_TimeArea    DS    CL16             Return area for Time\n                ORG   @HA_Macros\n@HA_DateConv_Area DS  CL(DConv_Area_Length)\n                ORG\n                DS    0D               Alignment\n@HA_DynLen      EQU   *-@HA_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHB0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'PRINT=' Keyword PROCESSOR.                                    *\n*             VALID VALUES ARE:                                     *\n*                     \"NO\"     - DO NOT PRINT SELECTED RECORDS      *\n*                     \"EBCDIC\" - PRINT SELECTED RECORDS IN EBCDIC   *\n*                                ONLY                               *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - ALL OK, ODTE_Print_NO flag set           *\n*                      4 - ERROR FOUND                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HB0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HB_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HB_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HB_Dynam,R13            Assign a base\n         L     R15,@HB_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of PRINT= keyword                         *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HB8000                 NO, ERROR\n         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?\n         BNE   HB0020                 NO, skip\n         OI    ODTE_Print_NO-ODT_Entry(R10),L'ODTE_Print_NO YES, SET\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HB9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HB9000                 YES, SKIP\n         B     HB8000                 NO, ERROR\nHB0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"EBCDIC\" KEYWORD.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'6'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HB8000                 NO, ERROR\n         CLC   0(6,R2),=C'EBCDIC'     YES, IS THIS IT?\n         BNE   HB8000                 NO, ERROR\n         OI    ODTE_Print_EB-ODT_Entry(R10),L'ODTE_Print_EB YES, SET\n         LA    R2,6(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'6'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HB9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HB9000                 YES, SKIP\n         B     HB8000                 NO, ERROR\nHB8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HB9000                 AND EXIT\nHB9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HB_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HB_Dynam       DSECT                 Dynamic area for J\n@HB_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HB_DynLen      EQU   *-@HB_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\nHC0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'INCLUDE=/EXCLUDE=' Keyword Processor                          *\n*    ON ENTRY, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    ON EXIT,  R15 =   0 - All OK, ODTE_RTT_Ptr set                 *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HC0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HC_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HC_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HC_Dynam,R13            Assign a base\n         L     R15,@HC_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of INCLUDE=/EXCLUDE= keyword              *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n         LR    R15,R2                   Back up to start of\n         SH    R15,=HL2'8'               keyword\n         CLI   0(R15),C'I'              Include?\n         BNE   HC0020                   No, must be Exclude\n         NI    @HC_Exclude,X'FF'-L'@HC_Exclude OFF 'EXCLUDE' FLAG\n         B     HC0030                   and skip\nHC0020   DS    0H\n         OI    @HC_Exclude,L'@HC_Exclude Turn on Exclude flag\n         B     HC0030                   and skip\nHC0030   DS    0H\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK THAT BOTH INCLUDE AND EXCLUDE HAVE NOT BEEN SPECIFIED.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    HC0050                None, skip\n         TM    @HC_Exclude,L'@HC_Exclude Is this Exclude\n         BO    HC0040                 YES, SKIP\n         TM    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\n         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=\n         B     HC0050                 AND CONTINUE\nHC0040   DS    0H\n         TM    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include\n         BO    HC8000                 Error, both INCLUDE= and EXCLUDE=\nHC0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP OUR TRANSLATE TABLE TO LOOK FOR NUMERICS AND SEPARATORS.*\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVI   @HC_RecType,X'00'       Init Record type\n         XC    @HC_SubType,@HC_SubType   and sub-type\n         NI    @HC_Paren,X'FF'-L'@HC_Paren Off flag\n         NI    @HC_RecTyp,X'FF'-L'@HC_Rectyp Off flag\n         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present\n\n         MVI   @HC_TRTab,X'FE'        SET WHOLE TABLE TO\n         MVC   @HC_TRTab+1(L'@HC_TRTab-1),@HC_TRTab INVALID VALUES\n         MVI   @HC_TRTab+C'0',X'00'   NUMERICS ARE\n         MVC   @HC_TRTab+C'1'(9),@HC_TRTab+C'0' VALID\n         MVI   @HC_TRTab+C' ',X'01'   STOP ON A BLANK\n         MVI   @HC_TRTab+C',',X'01'        AND A COMMA\n         MVI   @HC_TRTab+C'(',X'01'        AND OPEN PARENS\n         MVI   @HC_TRTab+C')',X'01'        AND CLOSE PARENS\n         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp No rectype yet\n         NI    @HC_Paren,X'FF'-L'@HC_Paren No parens either\n         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?\n         BNE   HC0060                 NO, SKIP\n         OI    @HC_Paren,L'@HC_Paren  Yes, set our flag\n         LA    R2,1(0,R2)             POINT PAST IT\n         SH    R3,=H'1'               AND REDUCE LENGTH\nHC0060   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FIND NEXT SEPARATOR.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HC9998             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R5                 RESTORE A(START)\n         LR    R4,R1                 A(SEPARATOR)\n         SR    R4,R2                 R4 = LEN OF DATA\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, R2 = A(START OF DATA)                           *\n*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *\n*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HC8000                YES, SKIP\n         LTR   R4,R4                 ANY DATA THERE?\n         BNP   HC8000                NONE, ERROR\n         CH    R4,=H'3'              YES, IS IT TOO LONG?\n         BH    HC8000                YES, ERROR\n         LR    R15,R4                NO, GET LEN OF STRING\n         SH    R15,=H'1'             EXECUTE LENGTH\n         EX    R15,HC9999            PACK IT\n         CVB   R1,@HC_DBLWD          AND BINARIZE IT\n         LA    R15,0(R2,R4)          POINT TO SEPARATOR\n         TM    @HC_RecTyp,L'@HC_RecTyp HAVE WE ALREADY GOT RECTYPE?\n         BZ    HC0070                NO, SKIP\n         CLI   0(R15),C')'           YES, IS THIS END OF SUBTYPE?\n         BNE   HC8000                NO, ERROR\n         LA    R4,1(0,R4)            YES, BUMP PAST IT\n         STH   R1,@HC_SubType        SAVE SUBTYPE\n         OI    @HC_SubType_Present,L'@HC_SubType_Present Set flag\n         B     HC0080                AND SKIP\nHC0070   DS    0H\n         STC   R1,@HC_RecType        SAVE RECORD TYPE\n         CLI   0(R15),C'('           START OF SUBTYPE?\n         BNE   HC0080                NO, SKIP\n         OI    @HC_RecTyp,L'@HC_RecTyp YES, SAY WE HAVE RECORD TYPE\n         LA    R2,1(R2,R4)           POINT PAST OPEN PAREN\n         SR    R3,R4                 ADJUST LENGTH REMAINING\n         SH    R3,=H'1'                PROPERLY\n         B     HC0060                AND KEEP GOING\nHC0080   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, @HC_RecType CONTAINS THE RECORD TYPE,        *\n*                      @HC_SubType CONTAINS THE SUBTYPE             *\n*    AND WE GO TO FIND A FREE ENTRY IN THE RECTYPE TABLE            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,10                 INITIAL NBR ENTRIES IN TBL\n         ICM   R15,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    HC0090                NONE, SKIP\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         L     R0,RTT_Subp_Len-RecType_Tbl(R15) GET LEN\n         SLL   R0,8                  GET RID OF\n         SRL   R0,8                    SUBPOOL\n         CR    R0,R1                 IS THE TABLE BIG ENOUGH?\n         BNL   HC0110                YES, GO INSERT ENTRY\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) NO, GET NBR ENTRIES\n         SLL   R1,1                  DOUBLE THEM\nHC0090   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EITHER THE RECORD TYPE TABLE DOESN'T EXIST, OR IT IS TOO       *\n*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *\n*    R1 CONTAINS THE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE. *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF ENTRIES\n         LA    R0,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HC_DBLWD          SAVE SUBPOOL AND LENGTH\n         ST    R1,@HC_DBLWD+4        SAVE A(TABLE)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Move the old table to the new, or just clear the table if      *\n*   there is no old table                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R0,R1                 A(New TABLE) IN R0\n         L     R1,@HC_DBLWD          LEN IN R1\n         SLR   R15,R15               Assume no old table\n         ICM   R14,B'1111',ODTE_RTT_Ptr GET A(OLD TABLE)\n         BZ    HC0095                NONE, SKIP\n         L     R15,RTT_Subp_Len-RecType_Tbl(R14) YES, GET CURR LEN\n         SLL   R15,8                 CLEAR OUT\n         SRL   R15,8                  SUBPOOL\nHC0095   DS    0H\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n\n         ICM   R1,B'1111',ODTE_RTT_Ptr  GET A(OLD TABLE)\n         BZ    HC0100                   None, skip\n         L     R0,RTT_Subp_Len-RecType_Tbl(R1) GET ITS LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHC0100   DS    0H\n         L     R15,@HC_DBLWD+4       A(NEW TABLE)\n         ST    R15,ODTE_RTT_Ptr      SAVE IT\n         MVC   RTT_Subp_Len-RecType_Tbl(L'RTT_Subp_Len,R15),@HC_DBLWD\n         LH    R0,RTT_Entry_Count-RecType_Tbl(R15)\n         LTR   R0,R0                 Are we creating table?\n         BNZ   HC0110                No, skip\n         TM    @HC_Exclude,L'@HC_Exclude Yes, are we EXCLUDEing?\n         BO    HC0105                Yes, skip\n         OI    RTT_Entry_Include-RecType_Tbl(R15),L'RTT_Entry_Include\n         B     HC0110                and skip\nHC0105   DS    0H\n         OI    RTT_Entry_Exclude-RecType_Tbl(R15),L'RTT_Entry_Exclude\nHC0110   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND NOW INSERT THE RECORD TYPE AND SUBTYPE IN THE TABLE.       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_RTT_Ptr      A(RECORD TYPE TABLE)\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES\n         LA    R0,RTTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,RTT_Entry-RecType_Tbl(0,R1) ADD TBL HEADER LEN\n         AR    R1,R15                A(FREE ENTRY)\n         MVC   RTTE_RecType-RTT_Entry(L'RTTE_RecType,R1),@HC_RecType\n         NI    RTTE_SubType_Present-RTT_Entry(R1),X'FF'-L'RTTE_SubType_+\n               Present\n         TM    @HC_SubType_Present,L'@HC_SubType_Present SubType?\n         BNO   HC0120                No, skip\n         MVC   RTTE_SubType-RTT_Entry(L'RTTE_SubType,R1),@HC_SubType\n         OI    RTTE_SubType_Present-RTT_Entry(R1),L'RTTE_SubType_Presen+\n               t\nHC0120   DS    0H\n\n         LH    R1,RTT_Entry_Count-RecType_Tbl(R15) GET NBR ENTRIES\n         LA    R1,1(0,R1)            BUMP IT\n         STH   R1,RTT_Entry_Count-RecType_Tbl(R15) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP TO FIND THE NEXT SUBENTRY.                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AR    R2,R4                 A(SEPARATOR)\n         SR    R3,R4                 ADJUST LEN LEFT IN RECORD\n         SLR   R15,R15               CLEAR RETURN CODE\n         TM    @HC_Paren,L'@HC_Paren IS THE WHOLE MESS IN PARENS?\n         BZ    HC9000                NO, EXIT\n         NI    @HC_RecTyp,X'FF'-L'@HC_RecTyp YES, OFF FOUND FLAG\n         MVI   @HC_RecType,X'00'     CLEAR RECORD TYPE\n         XC    @HC_SubType,@HC_SubType AND SUBTYPE\n         NI    @HC_SubType_Present,X'FF'-L'@HC_SubType_Present\n         CLI   0(R2),C','            MORE RECORD TYPES?\n         BNE   HC0130                NO, SKIP\n         LA    R2,1(0,R2)            YES, BUMP PAST COMMA\n         SH    R3,=H'1'              ADJUST LENGTH\n         B     HC0060                AND TRY AGAIN\nHC0130   DS    0H\n         CLI   0(R2),C')'            IS THIS THE END?\n         BNE   HC8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST CLOSING PAREN\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         NI    @HC_Paren,X'FF'-L'@HC_Paren AND OFF PAREN FLAG\n         SLR   R15,R15               CLEAR RETURN CODE\n         B     HC9000                AND EXIT\nHC8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HC9000                AND EXIT\nHC9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HC_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHC9998 TRT     0(0,R5),@HC_TRTab     FIND ENDING CHARACTER\nHC9999 PACK    @HC_DBLWD,0(0,R2)     PACK RECORD TYPE/SUBTYPE\n\n         LTORG\n\n@HC_Dynam       DSECT                 Dynamic area for J\n@HC_Save        DS    18F              O/S Style save area\n@HC_DBLWD       DS    D                Work area\n@HC_RecType     DS    X                Record Type\n@HC_SubType     DS    HL2              Record Type 30 Subtype\n                DS    X                Flag Byte\n@HC_Paren       EQU   *-1,X'80'         1... ....  IN PARENTHESES\n@HC_RecTyp      EQU   *-1,X'40'         .1.. ....  RECTYPE FOUND\n@HC_Exclude     EQU   *-1,X'20'         ..1. ....  EXCLUDE SPECIFIED\n@HC_SubType_Present EQU *-1,X'10'       ...1 ....  SubType found\n@HC_TRTab       DS    XL256            Translate table\n                DS    0D               Alignment\n@HC_DynLen      EQU   *-@HC_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10                    ODT Entry base\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHD0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'JOBNAME=' Keyword Processor                                   *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_JNT_Ptr updated             *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HD0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HD_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HD_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HD_Dynam,R13            Assign a base\n         L     R15,@HD_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP OUR TRANSLATE TABLE TO STOP ON SEPARATORS.              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PARENTHESES FLAG\n         MVI   @HD_TRTab,X'00'        ANYTHING GOES IN A JOB NAME\n         MVC   @HD_TRTab+1(L'@HD_TRTab-1),@HD_TRTab\n         MVI   @HD_TRTab+C' ',X'01'   STOP ON A BLANK\n         MVI   @HD_TRTab+C',',X'01'        AND A COMMA\n         CLI   0(R2),C'('             PAREN AROUND WHOLE STRING?\n         BNE   HD0020                 NO, SKIP\n         OI    @HD_Paren,L'@HD_Paren  YES, SAY SO\n         LA    R2,1(0,R2)             POINT PAST IT\n         SH    R3,=H'1'               AND REDUCE LENGTH\n         MVI   @HD_TRTab+C')',X'01'   STOP ON CLOSE PAREN TOO\nHD0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FIND NEXT SEPARATOR.                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HD9999             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R5                 RESTORE A(START)\n         LR    R4,R1                 A(SEPARATOR)\n         SR    R4,R2                 R4 = LEN OF DATA\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, R2 = A(START OF DATA)                           *\n*                   R3 = LENGTH OF DATA LEFT IN SYSIN RECORD        *\n*                   R4 = LEN OF STRING (IE, R2+R4 = A(SEPARATOR)).  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HD8000                YES, SKIP\n         LTR   R4,R4                 ANY DATA THERE?\n         BNP   HD8000                NONE, ERROR\n         CH    R4,=H'8'              YES, IS IT TOO LONG?\n         BH    HD8000                YES, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, R2 POINTS TO START OF JOBNAME,               *\n*                      R4 CONTAINS ITS LENGTH                       *\n*    AND WE GO TO FIND A FREE ENTRY IN THE JOBNAME TABLE            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,10                 INITIAL NBR ENTRIES IN TBL\n         ICM   R15,B'1111',ODTE_JNT_Ptr A(JOB NAME TABLE)\n         BZ    HD0030                None, SKIP\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R1,1(0,R1)            ADD ONE FOR OUR NEW ENTRY\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN\n         L     R0,JNT_Subp_Len-JobName_Tbl(R15) GET CURR LEN\n         SLL   R0,8                  GET RID OF\n         SRL   R0,8                    SUBPOOL\n         CR    R0,R1                 IS THE TABLE BIG ENOUGH?\n         BNL   HD0050                YES, GO INSERT ENTRY\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) NO, NBR ENTRIES\n         SLL   R1,1                  DOUBLE THEM\nHD0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    EITHER THE JOB NAME TABLE DOESN'T EXIST, OR IT IS TOO          *\n*    SMALL TO HOLD OUR ENTRY, SO WE HAVE TO GO AND GET A NEW TABLE. *\n*    R1 CONTAINS TRHE NUMBER OF ENTRIES THAT SHOULD BE IN THE TABLE.*\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF ENTRIES\n         LA    R0,JNT_Entry-JobName_Tbl+7(0,R1) ADD TBL HEADER LEN\n         SRL   R0,3                  Make it a doubleword\n         SLL   R0,3                   multiple\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HD_JNT_Subp_Len   SAVE SUBPOOL AND LENGTH\n         ST    R1,@HD_JNT_Pointer    SAVE A(TABLE)\n         LR    R0,R1                 A(TABLE) IN R0\n         L     R1,@HD_JNT_Subp_Len   LEN IN R1\n         SLR   R14,R14               NOTHING IN R14\n         SLR   R15,R15               AND IN 15\n         MVCL  R0,R14                CLEAR THE TABLE\n         ICM   R14,B'1111',ODTE_JNT_Ptr GET A(OLD TABLE)\n         BZ    HD0040                None, SKIP\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    THERE WAS AN OLD TABLE, SO WE HAVE TO COPY IT TO THE NEW TABLE *\n*    AREA, AND THEN FREE UP THE OLD ONE.                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,JNT_Subp_Len-JobName_Tbl(R14) YES, GET CURR LENGTH\n         SLL   R15,8                 CLEAR OUT\n         SRL   R15,8                  SUBPOOL\n         L     R0,@HD_JNT_Pointer    GET A(NEW TABLE)\n         LR    R1,R15                SAME LENGTH\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n         L     R1,ODTE_JNT_Ptr       GET A(OLD TABLE)\n         L     R0,JNT_Subp_Len-JobName_Tbl(R1) GET ITS LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHD0040   DS    0H\n         L     R15,@HD_JNT_Pointer   A(NEW TABLE)\n         ST    R15,ODTE_JNT_Ptr      SAVE IT\n         MVC   JNT_Subp_Len-JobName_Tbl(L'JNT_Subp_Len,R15),@HD_JNT_Sub+\n               p_Len\nHD0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND NOW INSERT THE JOB NAME IN THE TABLE.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES\n         LA    R0,JNTE_Length        LENGTH OF ONE ENTRY\n         MR    R0,R0                 GET LENGTH OF CURRENT ENTRIES\n         LA    R1,JNT_Entry-JobName_Tbl(0,R1) ADD TBL HEADER LEN\n         AR    R1,R15                A(FREE ENTRY)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE ARE NOW POINTING AT A FREE ENTRY IN THE JOBNAME TABLE -     *\n*   IF THIS IS A PREFIX (IE, LAST CHAR IS AN '*'), CALCULATE THE    *\n*   EXECUTE LEN AND SAVE IT; OTHERWISE, USE 7 AS THE EXECUTE LEN.   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R14,L'JNTE_JobName-1  DEFAULT EXECUTE LENGTH\n         LA    R15,0(R2,R4)          POINT PAST JOBNAME\n         SH    R15,=H'1'             BACK UP A CHARACTER\n         CLI   0(R15),C'*'           IS THIS JOBNAME A PREFIX?\n         BNE   HD0060                NO, SKIP\n         SH    R4,=H'1'              YES, DON'T INCLUDE THE ASTERISK\n         LR    R14,R4                GET\n         SH    R14,=H'1'              EXECUTE LENGTH\nHD0060   DS    0H\n         STC   R14,JNTE_JobName_Len-JNT_Entry(R1) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    MOVE THE JOBNAME/PREFIX TO THE TABLE.                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,JNTE_JobName-JNT_Entry(R1) A(JOBNAME FIELD)\n         LA    R1,L'JNTE_JobName     LEN OF JOBNAME FIELD\n         LR    R14,R2                A(JOBNAME)\n         LA    R15,C' '              PAD CHARACTER\n         SLL   R15,24                IN THE PROPER PLACE\n         OR    R15,R4                INSERT LENGTH\n         MVCL  R0,R14                MOVE JOBNAME\n         L     R15,ODTE_JNT_Ptr      A(JOB NAME TABLE)\n         LH    R1,JNT_Entry_Count-JobName_Tbl(R15) GET NBR ENTRIES\n         LA    R1,1(0,R1)            BUMP IT\n         STH   R1,JNT_Entry_Count-JobName_Tbl(R15) SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SET UP TO FIND THE NEXT SUBENTRY.                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         AR    R2,R4                 A(SEPARATOR)\n         CLI   0(R2),C'*'            WAS THIS A PREFIX?\n         BNE   HD0070                NO, SKIP\n         LA    R2,1(0,R2)            YES, SKIP PAST THE ASTERISK\nHD0070   DS    0H\n         SR    R3,R4                 ADJUST LEN LEFT IN RECORD\n         SLR   R15,R15               CLEAR RETURN CODE\n         TM    @HD_Paren,L'@HD_Paren DO WE HAVE PARENS AROUND NAMES?\n         BZ    HD9000                NO, EXIT\n         CLI   0(R2),C','            YES, MORE JOBNAMES?\n         BNE   HD0080                NO, ERROR\n         LA    R2,1(0,R2)            YES, BUMP PAST COMMA\n         SH    R3,=H'1'              ADJUST LENGTH\n         B     HD0020                AND TRY AGAIN\nHD0080   DS    0H\n         CLI   0(R2),C')'            CLOSING PAREN?\n         BNE   HD8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         NI    @HD_Paren,X'FF'-L'@HD_Paren OFF PAREN FLAG\n         B     HD9000                AND EXIT\nHD8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HD9000                AND EXIT\nHD9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HD_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHD9999 TRT     0(0,R5),@HD_TRTab     FIND ENDING CHARACTER\n\n         LTORG\n\n@HD_Dynam       DSECT                 Dynamic area for HD\n@HD_Save        DS    18F              O/S Style save area\n@HD_JNT_Pointer DS    AL4              A(JobName Table)\n@HD_JNT_Subp_Len DS   FL4              Subpool, length of JNT\n@HD_TRTab       DS    XL256            Translate table\n                DS    X                Flag byte\n@HD_Paren       EQU   *-1,X'80'         1... .... In parentheses\n                DS    0D               Alignment\n@HD_DynLen      EQU   *-@HD_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHE0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'DATA=' Keyword Processor                                      *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_DT_Ptr updated              *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HE0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HE_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HE_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HE_Dynam,R13            Assign a base\n         L     R15,@HE_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Set up our translate table.                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         NI    @HE_Quote,X'FF'-L'@HE_Quote Off Quote flag\n         NI    @HE_Hex,X'FF'-L'@HE_Hex    and hex flag\n         MVC   @HE_TRTab,HE_EBCDIC_TRTab MOVE EBCDIC TRAN TABLE\n\n         CH    R3,=H'1'               MORE THAN 1 CHARACTER LEFT?\n         BNH   HE0070                 NO, NOT A QUOTED STRING\n         CLI   0(R2),C''''            YES, START WITH A QUOTE?\n         BE    HE0020                 YES, SKIP\n         CLI   0(R2),C'\"'             NO, DOUBLE QUOTE?\n         BNE   HE0030                 NO, SKIP\nHE0020   DS    0H\n         SH    R2,=H'1'               BACK UP A BYTE\n         AH    R3,=H'1'               SET UP LENGTH\n         B     HE0040                 AND SKIP\nHE0030   DS    0H\n         CLI   1(R2),C''''            YES, SINGLE QUOTE?\n         BE    HE0040                 YES, SKIP\n         CLI   1(R2),C'\"'             NO, DOUBLE QUOTE?\n         BNE   HE0070                 NO, NO QUOTED STRING\nHE0040   DS    0H\n         OI    @HE_Quote,L'@HE_Quote    SAY WE'RE DOING A QUOTED STRING\n         CLI   0(R2),C'C'             CHARACTER STRING?\n         BE    HE0050                 YES, SKIP\n         CLI   0(R2),C'='             QUOTES WITH NO C OR H?\n         BE    HE0050                 YES, ASSUME CHARACTER DATA\n         CLI   0(R2),C'X'             NO, HEX STRING?\n         BNE   HE8000                 NO, ERROR\n         OI    @HE_Hex,L'@HE_Hex      YES, SAY SO\n         MVC   @HE_TRTab,HE_Hex_TRTab AND MOVE HEX CHARS TO TRANS TBL\n         B     HE0060                 SKIP\nHE0050   DS    0H\n         MVI   @HE_TRTab,X'00'        ANYTHING GOES\n         MVC   @HE_TRTab+1(L'@HE_TRTab-1),@HE_TRTab BETWEEN QUOTES\nHE0060   DS    0H\n         SLR   R0,R0                  CLEAR WORK REGISTER\n         IC    R0,1(0,R2)             GET SEPARATOR CHARACTER\n         LA    R15,@HE_TRTab          A(TRANSLATE TABLE)\n         AR    R15,R0                 A(CHARACTER IN TRAN TBL\n         MVI   0(R15),X'01'           STOP TRANSLATION THERE\n         LA    R2,2(0,R2)             POINT PAST FIRST SEPARATOR\n         SH    R3,=H'2'               AND ADJUST LENGTH\n         BNP   HE8000                 NOTHING LEFT, ERROR\nHE0070   DS    0H\n         LR    R4,R2                 SAVE R2\n         LR    R5,R2                 AND AGAIN\n         SLR   R2,R2                 AND CLEAR FUNCTION BYTE\n         SH    R3,=H'1'              EXECUTE LENGTH\n         LA    R1,1(R3,R4)           ALL DONE, POINT PAST LAST BYTE\n         EX    R3,HE9997             TRANSLATE\n         LR    R0,R2                 SAVE FUNCTION BYTE\n         LR    R2,R1                 A(LAST CHARACTER)\n         SR    R1,R4                 GET LENGTH OF DATA\n         SR    R3,R1                 ADJUST LENGTH REMAINING\n         AH    R3,=H'1'               PROPERLY\n         CH    R0,=H'240'            ILLEGAL CHARACTER?\n         BNL   HE8000                YES, SKIP\n         LR    R4,R2                 NO, GET STARTING ADDRESS\n         SR    R4,R5                 GET LEN OF DATA\n         TM    @HE_Quote,L'@HE_Quote ARE WE DOING A QUOTED STRING?\n         BNO   HE0110                NO, SKIP\n         CH    R0,=H'1'              YES, DID WE GET A FINAL SEP?\n         BNE   HE8000                NO, ERROR\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              AND ADJUST LENGTH REMAINING\n         TM    @HE_Hex,L'@HE_Hex     ARE WE DOING HEX?\n         BZ    HE0110                NO, SKIP\n         STC   R4,@HE_DBLWD          YES, SAVE LENGTH\n         TM    @HE_DBLWD,X'01'       IS LENGTH AN EVEN NUMBER\n         BO    HE8000                NO, ERROR\n         SRL   R4,1                  GET LENGTH OF CONVERTED HEX\n         LR    R15,R5                A(START OF SOURCE)\n         LR    R14,R5                A(START OF TARGET DATA\nHE0080   DS    0H\n         LA    R0,X'FF'              WHEN R0 GOES NEGATIVE, WE HAVE\n         SLL   R0,16                   GOT ONE PACKED BYTE\nHE0090   DS    0H\n         CR    R15,R2                HAVE WE GONE FAR ENOUGH?\n         BNL   HE0110                YES, SKIP\n         IC    R1,0(0,R15)           GET BYTE OF SOURCE DATA\n         CLI   0(R15),C'0'           IS IT X'C1' - X'C6'?\n         BNL   HE0100                NO, OK\n         LA    R1,9(0,R1)            YES, CONVERT TO X'CA' - X'CF'\nHE0100   DS    0H\n         SLL   R1,28                 GET LOW NIBBLE AT TOP OF R1\n         SLDL  R0,4                  AND INTO R0\n         LA    R15,1(0,R15)          BUMP SOURCE PTR\n         LTR   R0,R0                 NO, HAVE WE DONE 2 SOURCE BYTES?\n         BNL   HE0090                NOT YET, CONTINUE\n         STC   R0,0(0,R14)           YES, SAVE HEX BYTE\n         LA    R14,1(0,R14)          BUMP DEST PTR\n         B     HE0080                AND CONTINUE\nHE0110   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WHEN WE GET HERE, R2 = A(NEXT CHARACTER AFTER DATA)            *\n*                      R4 = LENGTH OF DATA,                         *\n*                      R5 = A(START OF DATA)                        *\n*    IF THE DATA WAS IN HEX (ENTERED AS X'123456'), IT HAS BEEN     *\n*   CONVERTED, AND R4 REFLECTS THE NEW LENGTH.                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)\n         BZ    HE0140                None, GO GET ONE\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) YES, GET NBR ENTRIES\n         LA    R15,DT_Entry-Data_Tbl(R15) AND POINT TO THE FIRST ONE\n         LTR   R14,R14               ARE THERE ANY ENTRIES?\n         BZ    HE0130                NO, SKIP\nHE0120   DS    0H\n         SLR   R1,R1                 CLEAR WORK REGISTER\n         IC    R1,DTE_Length-DT_Entry(R15) GET LEN OF DATA\n         LA    R15,DTE_Data-DT_Entry+1(R1,R15) A(NEXT ENTRY\n         BCT   R14,HE0120            AND GO TILL THE END\nHE0130   DS    0H\n         LA    R14,DTE_Data-DT_Entry(R4,R15) A(END OF OUR NEW ENT)\n         S     R14,ODTE_DT_Ptr       LENGTH OF UPDATED TABLE\n         L     R1,ODTE_DT_Ptr        A(TABLE)\n         L     R1,DT_Subp_Len-Data_Tbl(R1) GET CURRENT LENGTH\n         SLL   R1,8                  GET RID OF\n         SRL   R1,8                    SUBPOOL\n         CR    R1,R14                WILL OUR ENTRY FIT?\n         BNL   HE0170                YES, GO DO IT\nHE0140   DS    0H\n         LA    R0,128                DEFAULT SUBPOOL AND LENGTH\n         ICM   R1,B'1111',ODTE_DT_Ptr GET A(CURRENT TABLE)\n         BZ    HE0150                None, SKIP\n         L     R1,DT_Subp_Len-Data_Tbl(R1) YES, GET SUBPOOL, LEN\n         SLDL  R0,8                  PUT SUBPOOL IN R0\n         SLL   R1,1                  DOUBLE CURRENT LENGTH\n         SLDL  R0,24                 AND PUT IT IN R0 TOO\nHE0150   DS    0H\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HE_DT_Subp_Len    SAVE SUBPOOL, LENGTH\n         ST    R1,@HE_DT_Pointer     AND A(NEW TABLE)\n         LR    R0,R1                 A(OUR TABLE)\n         L     R1,@HE_DT_Subp_Len    SUBPOOL, LENGTH OF IT\n         SLL   R1,8                  GET RID OF\n         SRL   R1,8                    SUBPOOL\n         SLR   R14,R14               NO SENDING ADDRESS\n         SLR   R15,R15                 OR LENGTH\n         MVCL  R0,R14                CLEAR OUR TABLE\n         ICM   R14,B'1111',ODTE_DT_Ptr GET A(OLD TABLE)\n         BZ    HE0160                None, SKIP\n         L     R15,DT_Subp_Len-Data_Tbl(R14) YES, GET SUBPOOL, LENGTH\n         SLL   R15,8                 CLEAR SUBPOOL SO THAT\n         SRL   R15,8                   PAD CHAR IS X'00'\n         L     R0,@HE_DT_Pointer     A(NEW TABLE AREA)\n         L     R1,@HE_DT_Subp_Len    LENGTH OF NEW TABLE\n         MVCL  R0,R14                MOVE OLD TABLE TO NEW\n         L     R1,ODTE_DT_Ptr        A(OLD DATA TABLE)\n         L     R0,DT_Subp_Len-Data_Tbl(R1) SUBPOOL, LENGTH OF TBL\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nHE0160   DS    0H\n         L     R15,@HE_DT_Pointer    A(NEW TABLE AREA)\n         ST    R15,ODTE_DT_Ptr       SAVE IT\n         L     R0,@HE_DT_Subp_Len    SUBPOOL, LENGTH\n         ST    R0,DT_Subp_Len-Data_Tbl(R15) AND SAVE IN TABLE\n         B     HE0110                and try again\nHE0170   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AT THIS POINT, WE ARE READY TO INSERT THE ENTRY IN THE TABLE   *\n*                   R4 =  LENGTH OF DATA                            *\n*                   R5 =  A(DATA)                                   *\n*                   R15 = A(ENTRY IN TABLE)                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R14,R4                GET THE LENGTH OF DATA\n         SH    R14,=H'1'             EXECUTE LENGTH\n         EX    R14,HE9998            MOVE IT\n         STC   R14,DTE_Length-DT_Entry(R15) AND SAVE EXEC LENGTH\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW DECODE THE REST OF THE STUFF IN THE RECORD                 *\n*                  R2  = A(NEXT CHAR IN INPUT)                      *\n*                  R3  = LEN REMAINING IN INPUT                     *\n*                  R15 = A(ENTRY IN TABLE)                          *\n*    NOTE THAT WE HAVE NOT YET UPDATED THE NUMBER OF ENTRIES IN     *\n*   THE TABLE (DT_Entry_Count), SO THAT IF WE FIND AN ERROR IN THE  *\n*   REMAINDER OF THE INPUT CARD, WE CAN JUST EXIT.                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                 CLEAR OFFSET\n         LTR   R3,R3                 ANY DATA REMAINING IN THE INPUT?\n         BZ    HE0180                NO, WE'RE FINISHED\n         CLI   0(R2),C' '            YES, HAVE WE FINISHED?\n         BE    HE0180                YES, GO UPDATE TABLE\n         CLI   0(R2),C','            NO, IS THIS A VALID SEPARATOR?\n         BNE   HE8000                NO, ERROR\n         CLI   1(R2),C'0'            IS THE NEXT CHAR NUMERIC?\n         BL    HE0180                NO, SKIP\n         CLI   1(R2),C'9'            SO FAR, CHECK AGAIN\n         BH    HE0180                NOT NUMERIC, SKIP\n         LA    R2,1(0,R2)            YES, POINT PAST IT\n         SH    R3,=H'1'              ADJUST LENGTH REMAINING\n         BNP   HE8000                TRAILING COMMA, ERROR\n         MVI   @HE_TRTab,X'FF'       SET UP TRANSLATE TABLE\n         MVC   @HE_TRTab+1(255),@HE_TRTab SO THAT ALL\n         MVI   @HE_TRTab+C'0',X'00'      CHARACTERS EXCEPT\n         MVC   @HE_TRTab+C'1'(9),@HE_TRTab+C'0' NUMERICS ARE INVALID\n         MVI   @HE_TRTab+C' ',X'01'  FLAG SPACE AS SPECIAL\n         MVI   @HE_TRTab+C',',X'01'    COMMA TOO\n         LR    R5,R2                 SAVE A(DATA)\n         LA    R1,0(R2,R3)           A(PAST LAST CHAR)\n         LA    R2,1                  SIMULATE A SPACE\n         EX    R3,HE9997             CHECK OUR CHARACTERS\n         LR    R0,R2                 SAVE R2\n         LR    R2,R5                 RESTORE R2\n         CH    R0,=H'254'            DID WE FIND AN INVALID CHAR?\n         BNL   HE8000                YES, INVALID\n         SR    R1,R2                 R1 = LENGTH OF DATA\n         SH    R1,=H'1'              EXEC LEN\n         BM    HE8000                NOTHING, INVALID\n         EX    R1,HE9999             PACK THE DATA\n         CVB   R0,@HE_DBLWD          AND PUT IT R0\n         C     R0,=F'32767'          IS IT TOO BIG?\n         BH    HE8000                YES, ERROR\n         LA    R1,1(0,R1)            RESTORE REAL OPERAND LEN\n         AR    R2,R1                 ADJUST NEXT PTR\n         SR    R3,R1                 AND LENGTH REMAINING\nHE0180   DS    0H\n         STH   R0,DTE_Offset-DT_Entry(R15) SAVE IT\n         SLR   R0,R0                 CLEAR REGISTER\n         L     R15,ODTE_DT_Ptr       A(DATA TABLE)\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES\n         LA    R14,1(0,R14)          BUMP IT\n         STH   R14,DT_Entry_Count-Data_Tbl(R15) AND SAVE IT\n         SLR   R15,R15               CLEAR R15\n         B     HE9000                AND EXIT\nHE8000   DS    0H\n         LA    R15,4                 SET RETURN CODE\n         B     HE9000                AND EXIT\nHE9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HE_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHE9997 TRT     0(0,R5),@HE_TRTab     FIND ENDING CHARACTER\nHE9998 MVC     DTE_Data-DT_Entry(0,R15),0(R5)\nHE9999 PACK    @HE_DBLWD,0(0,R2)     PACK OFFSET/MSG CNT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    TRANSLATE TABLES FOR HE0000, USED TO INTERPRET DATA= OPERANDS. *\n*                                                                   *\n*-------------------------------------------------------------------*\n\nHE_EBCDIC_TRTab DS XL256           EBCDIC TRANSLATE TABLE\n         ORG   HE_EBCDIC_TRTab\n         DC    256X'FE'\n         ORG   HE_EBCDIC_TRTab+C' '\n         DC    X'02'                 SEPARATOR (BLANK)\n         ORG   HE_EBCDIC_TRTab+C','\n         DC    X'02'                 SEPARATOR (,)\n         ORG   HE_EBCDIC_TRTab+C'\u00a2'\n         DC    XL7'00'               \u00a2 . < ( + ] &\n         ORG   HE_EBCDIC_TRTab+C'|'\n         DC    XL8'00'               | $ * ) ; \u00ac - /\n         ORG   HE_EBCDIC_TRTab+C'%'\n         DC    XL4'00'               % _ > ?\n         ORG   HE_EBCDIC_TRTab+C':'\n         DC    XL6'00'               : # @ ' = \"\n         ORG   HE_EBCDIC_TRTab+C'A'\n         DC    XL9'00'               A-I\n         ORG   HE_EBCDIC_TRTab+C'J'\n         DC    XL9'00'               J-R\n         ORG   HE_EBCDIC_TRTab+C'S'\n         DC    XL8'00'               S-Z\n         ORG   HE_EBCDIC_TRTab+C'0'\n         DC    XL10'00'              0-9\n         ORG\n\nHE_Hex_TRTab DS XL256              HEX TRANSLATE TABLE\n         ORG   HE_Hex_TRTab\n         DC    256X'FE'\n         ORG   HE_Hex_TRTab+C'A'\n         DC    XL6'00'               A-F\n         ORG   HE_Hex_TRTab+C'0'\n         DC    XL10'00'              0-9\n         ORG\n\n         LTORG\n\n@HE_Dynam       DSECT                 Dynamic area for HE\n@HE_Save        DS    18F              O/S Style save area\n@HE_DBLWD       DS    D                Work area\n@HE_DT_Pointer  DS    AL4              A(Data Table)\n@HE_DT_Subp_Len DS    FL4              Subpool, length of Dat Table\n                DS    X                Flag Byte\n@HE_Quote       EQU   *-1,X'80'         1... ....  QUOTED STRING\n@HE_Hex         EQU   *-1,X'40'         .1.. ....  HEX STRING\n@HE_TRTab       DS    XL256            Translate table\n                DS    0D               Alignment\n@HE_DynLen      EQU   *-@HE_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHF0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'JOB/DATA=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_JobData_OR flag set         *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HF0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HF_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HF_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HF_Dynam,R13            Assign a base\n         L     R15,@HF_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"OR\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HF8000                 NO, ERROR\n         CLC   0(2,R2),=C'OR'         YES, IS THIS IT?\n         BNE   HF8000                 NO, ERROR\n         OI    ODTE_JobData_OR-ODT_Entry(R10),L'ODTE_JobData_OR Yes, OK\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         B     HF9000                 AND EXIT\nHF8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HF9000                 AND EXIT\nHF9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HF_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HF_Dynam       DSECT                 Dynamic area for HF\n@HF_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HF_DynLen      EQU   *-@HF_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHG0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'STOPAFT=' Keyword Processor                                   *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_StopAft updated             *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HG0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HG_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HG_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HG_Dynam,R13            Assign a base\n         L     R15,@HG_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LOOK FOR THE FIRST NON-NUMERIC                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R4,R2                  A(START OF OPERAND\nHG0020   DS    0H\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HG0030                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, CHECK AGAIN\n         BH    HG0020                 NO, NOT NUMERIC\n         LA    R2,1(0,R2)             OK, BUMP POINTER\n         BCT   R3,HG0020              AND TRY AGAIN\n         B     HG0040                 OK, SKIP\nHG0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE A NON-NUMERIC CHARACTER - CHECK TO MAKE SURE IT'S A    *\n*    VALID SEPARATOR (BLANK OR COMMA).                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C','             IS THIS A COMMA?\n         BE    HG0040                 YES, SKIP\n         CLI   0(R2),C' '             NO, HOW ABOUT A BLANK\n         BNE   HG8000                 NO, WE HAVE AN ERROR\nHG0040   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK TO SEE IF THE NUMBER IS TOO LONG (MAX = 9 CHARACTERS)    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                GET A(SEPARATOR)\n         SR    R15,R4                LESS THE START\n         CH    R15,=H'9'             IS IT TOO LONG?\n         BH    HG8000                YES, ERROR\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    IT SEEMS TO BE OK, SO BINARIZE IT AND SAVE IN ODTE_StopAft.    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SH    R15,=H'1'             EXECUTE LEN\n         EX    R15,HG9999            PACK IT\n         CVB   R15,@HG_DBLWD         BINARIZE IT\n         LTR   R15,R15               IS THE NUMBER 0?\n         BE    HG8000                YES, THAT'S AN ERROR\n         ST    R15,ODTE_StopAft-ODT_Entry(R10) No, save it\n         SLR   R15,R15               CLEAR THE RETURN CODE\n         B     HG9000                AND EXIT\nHG8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE AN ERROR, SET THE RETURN CODE AND EXIT.                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HG9000                 AND EXIT\nHG9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HG_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHG9999 PACK    @HG_DBLWD,0(0,R4)        PACK STOPAFT COUNT\n\n         LTORG\n\n@HG_Dynam       DSECT                 Dynamic area for O\n@HG_Save        DS    18F              O/S Style save area\n@HG_DBLWD       DS    D                Work area\n                DS    0D               Alignment\n@HG_DynLen      EQU   *-@HG_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHH0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'INEXIT=/OUTEXIT=' Keyword Processor                           *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_InExit or ODTE_OutExit      *\n*                          updated                                  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HH0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HH_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HH_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HH_Dynam,R13            Assign a base\n         L     R15,@HH_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n         USING ODT_Entry,R10            Assign a base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Figure out if we are INEXIT or OUTEXIT, and set our flag       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R2                 A(Start of operands)\n         S     R15,=FL4'5'            Back up to keyword\n         CLI   0(R15),C'N'            INEXIT=?\n         BNE   HH0020                 No, must be OUTEXIT=\n         OI    @HH_InExit,L'@HH_InExit Yes, set our flag\nHH0020   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Figure out what we have here. We can be:                       *\n*      INEXIT=exitname                                              *\n*      INEXIT=(exitname)                                            *\n*      INEXIT=(exitname,parm)                                       *\n*      INEXIT=(exitname,'parm')                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C'('             Open paren?\n         BNE   HH0020C                No, skip\n         OI    @HH_Paren,L'@HH_Paren  Yes, set our flag\n         LA    R2,1(0,R2)             Point past it\n         S     R3,=FL4'1'             and decrement length\nHH0020C  DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Find the end of the exit name, by looking for a blank, comma,  *\n*   or, optionally, a close paren.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R14,R2                 A(Start)\n         LR    R15,R3                 Length\nHH0030   DS    0H\n         CLI   0(R14),C' '            END OF NAME?\n         BE    HH0050                 YES, SKIP\n         CLI   0(R14),C','            NO, TRY AGAIN\n         BE    HH0050                 FOUND END, SKIP\n         TM    @HH_Paren,L'@HH_Paren  Are we in parentheses?\n         BNO   HH0040                 No, skip\n         CLI   0(R14),C')'            Yes, end of name?\n         BE    HH0050                 Yes, skip\nHH0040   DS    0H\n         LA    R14,1(0,R14)           Point to next char\n         BCT   R15,HH0030             and keep checking\nHH0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have the end of the name - move it to our ODT entry         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SR    R14,R2                 Get length of name\n         C     R14,=FL4'8'            Too long?\n         BH    HH8000                 Yes, error\n\n         LR    R1,R2                  Start of data to be moved\n         LR    R3,R15                 Save length remaining\n         AR    R2,R14                 and reset input pointer\n\n         S     R14,=FL4'1'            EX Length to be moved\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT\n         BZ    HH0060                 No, skip\n         LA    R15,ODTE_InExit        Yes, A(InExit name)\n         MVC   ODTE_InExit,=CL(L'ODTE_InExit)' '  Clear it\n         LTR   R14,R14                Anything?\n         BNM   HH0070                 Yes, OK\n         OI    ODTE_No_Dflt_InExit,l'ODTE_No_Dflt_InExit Don't use dflt\n         B     HH0070C                and skip\nHH0060   DS    0H\n         LA    R15,ODTE_OutExit       A(OutExit Name)\n         MVC   ODTE_OutExit,=CL(L'ODTE_OutExit)' '  Clear it\n         LTR   R14,R14                Anything?\n         BNM   HH0070                 Yes, OK\n         OI    ODTE_No_Dflt_OutExit,l'ODTE_No_Dflt_OutExit No dflt\n         B     HH0070C                and skip\n\nHH0070   DS    0H\n         EX    R14,HH_OC              OC    0(0,R15),0(R1)\n\nHH0070C  DS    0H\n         TM    @HH_Paren,L'@HH_Paren  Are we in paren?\n         BNO   HH0180                 No, exit\n         CLI   0(R2),C')'             Yes, at the end?\n         BNE   HH0080                 No, skip\n         LA    R2,1(0,R2)             Yes, point past it\n         S     R3,=FL4'1'             decrement the length\n         B     HH0180                 and exit\nHH0080   DS    0H\n         CLI   0(R2),C','             Separator?\n         BNE   HH8000                 No, exit with error\n         LA    R2,1(0,R2)             Yes, point past it\n         S     R3,=FL4'1'             decrement the length\n         SLR   R0,R0                  Clear work register\n         LA    R0,C')'                Ending character\n\n         CLI   0(R2),C''''            Open quote?\n         BNE   HH0090                 No, skip\n         OI    @HH_Quotes,L'@HH_Quotes Yes, set our flag\n         LA    R2,1(0,R2)             Point past it\n         S     R3,=FL4'1'             Decrement length remaining\n         BNP   HH8000                 Nothing left, error\n         LA    R0,C''''               Ending character\nHH0090   DS    0H\n\n         LA    R14,0(R2,R3)           A(Byte after string)\n         LR    R15,R2                 A(1st byte of string)\nHH0100   DS    0H\n         SRST  R14,R15                Find it\n         BO    HH0100                 Keep trying (CC=3)\n         BNL   HH8000                 Not found, exit with error\n\n         SR    R14,R2                 Length of data\n         BZ    HH0110                 None, skip\n\n         LR    R0,R2                  Start of data to be moved\n         SR    R3,R14                 Update length remaining\n         AR    R2,R14                 Bump pointer\n\n         LR    R1,R14                 Length of data to be moved\n         LA    R14,@HH_ParmArea       Temp save area\n         AH    R14,@HH_ParmLen        A(Next byte)\n         LH    R15,@HH_ParmLen        Bump\n         AR    R15,R1                  current\n         STH   R15,@HH_ParmLen         length\n         LR    R15,R1                 Len to be moved\n         MVCL  R14,R0                 Move parm data\nHH0110   DS    0H\n         TM    @HH_Quotes,L'@HH_Quotes Are we in quotes?\n         BNO   HH0130                No, skip\n         LA    R2,1(0,R2)            Point past quote\n         S     R3,=FL4'1'            Decrement length remaining\n         CLI   0(R2),C''''           Is this two quotes?\n         BNE   HH0130                No, found the end\n\n         LA    R15,@HH_ParmArea      Yes, A(Parmarea)\n         AH    R15,@HH_ParmLen       Point past current data\n         MVI   0(R15),C''''          Add a quote\n         LH    R15,@HH_ParmLen       Bump the\n         A     R15,=FL4'1'            current\n         STH   R15,@HH_ParmLen        length\n         LA    R2,1(0,R2)            Point past quote\n         S     R3,=FL4'1'            Decrement length remaining\n         LA    R0,C''''              Look for a quote\n         B     HH0090                and keep checking\n\nHH0130   DS    0H\n         LA    R2,1(0,R2)            Bump past close paren\n         S     R3,=FL4'1'            and decrement length\n         B     HH0150                exit\n\nHH0150   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have assembled the parm in @HH_ParmArea. If a parm already  *\n*   exists, free it up ...                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0150C                No, skip\n         L     R1,ODTE_InExit_Parm_Ptr Yes, get A(Parm)\n         B     HH0150E                and skip\nHH0150C  DS    0H\n         L     R1,ODTE_InExit_Parm_Ptr Get A(Parm)\nHH0150E  DS    0H\n         LTR   R1,R1                  Any parm?\n         BZ    HH0150I                No, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         TM    @HH_Inexit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0150G                No, skip\n         ST    R15,ODTE_InExit_Parm_Ptr Yes, clear it\n         B     HH0150I                and skip\nHH0150G  DS    0H\n         ST    R15,ODTE_OutExit_Parm_Ptr Clear parm pointer\nHH0150I  DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and copy it to 24-bit storage                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,L'@HH_ParmLen       Length of Parm length\n         AH    R0,@HH_ParmLen         plus length of parm\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n\n         TM    @HH_InExit,L'@HH_InExit Is this INEXIT=?\n         BNO   HH0160                 No, skip\n         ST    R1,ODTE_InExit_Parm_Ptr Yes, save A(Parm)\n         B     HH0170                 and skip\nHH0160   DS    0H\n         ST    R1,ODTE_OutExit_Parm_Ptr Save A(Parm)\n         B     HH0170                 and skip\nHH0170   DS    0H\n\n         MVC   0(L'@HH_ParmLen,R1),@HH_ParmLen Save parm length\n         LA    R0,L'@HH_ParmLen(0,R1) Point past it\n         LH    R1,@HH_ParmLen         Get its length\n         LA    R14,@HH_ParmArea       Point to assenbled parm\n         LR    R15,R1                 Same length\n         MVCL  R0,R14                 Move parm\n\nHH0180   DS    0H\n         SLR   R15,R15                CLEAR RETURN CODE\n         B     HH9000                 AND EXIT\n\nHH8000   DS    0H\n         LA    R15,4                  Bad stuff\n         B     HH9000                 AND EXIT\n\nHH9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HH_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nHH_OC    OC    0(0,R15),0(R1)           Move exit name\n\n         LTORG\n\n@HH_Dynam       DSECT                 Dynamic area for HH\n@HH_Save        DS    18F              O/S Style save area\n                DS    X                Flag Byte\n@HH_InExit      EQU   *-1,X'80'         1... .... INEXIT= statement\n@HH_Paren       EQU   *-1,X'40'         .1.. .... Parentheses\n@HH_Quotes      EQU   *-1,X'20'         ..1. .... Parm in quotes\n@HH_ParmArea    DS    CL256            Parm area\n@HH_ParmLen     DS    HL2              Length of parm\n                DS    0D               Alignment\n@HH_DynLen      EQU   *-@HH_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHI0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'OUTPUT=' Keyword Processor                                    *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, 3rd parm updated with A(new ODT  *\n*                          entry)                                   *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HI0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HI_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HI_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HI_Dynam,R13            Assign a base\n         L     R15,@HI_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    AND MOVE THE NAME, CHARACTER BY CHARACTER.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@HI_DDName         A(HOLDING AREA)\n         MVC   @HI_DDName,=CL8' '     CLEAR IT OUT\n         LA    R14,9                  MAX LENGTH OF NAME + 1\n         CR    R14,R3                 ARE THERE THAT MANY LEFT?\n         BNH   HI0020                 YES, SKIP\n         LR    R14,R3                 NO, USE ONLY WHATS LEFT\nHI0020   DS    0H\n         CLI   0(R2),C' '             END OF NAME?\n         BE    HI0030                 YES, SKIP\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HI0030                 FOUND END, SKIP\n         OC    0(1,R15),0(R2)         MOVE CHAR TO NAME FIELD\n         LA    R15,1(0,R15)           BUMP RECEIVING POINTER\n         LA    R2,1(0,R2)             BUMP SENDING POINTER\n         SH    R3,=H'1'               DECREASE CHARS REMAINING\n         BCT   R14,HI0020             AND KEEP GOING\n         LA    R15,4                  TOO MANY CHARACTERS (>8)\n         B     HI9000                 SO EXIT\nHI0030   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE GOT THE NAME, SO FIND AN ENTRY IN THE OUTPUT ENV TBL.  *\n*   NOTE THAT AN ENTRY MAY ALREADY EXIST - IF SO, WE USE IT. IF NOT,*\n*   WE CREATE ONE,                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,@_ODT_Ptr         POINT TO OUR TABLE\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\n         USING ODT_Entry,R10            Tell the assembler\n\nHI0040   DS    0H\n         CLC   ODTE_DDName,@HI_DDName OUR ENTRY?\n         BE    HI0060                 YES, SKIP\n         AL    R10,=AL4(ODTE_Length)  No, point to next entry\n         BCT   R9,HI0040              and check it out\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE DIDN'T FIND OUR ENTRY IN THE TABLE, SO WE WILL CREATE ONE.  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_ODT_Ptr           A(OUR TABLE)\n         L     R15,=AL4(ODTE_Length)  LENGTH OF ONE ENTRY\n         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R1) Nbr entries\n         LA    R14,1(0,R14)           PLUS ONE FOR THE NEW ONE\n         MR    R14,R14                LENGTH OF ENTRIES\n         LA    R15,ODT_Entry-OutDesc_Tbl(0,R15) PLUS LEN OF HEADER\n         L     R1,ODT_Subp_Len-OutDesc_Tbl(R1) Get Tbl Len, Subpool\n         SLL   R1,8                   GET RID OF\n         SRL   R1,8                    SUBPOOL\n         CR    R1,R15                 DO WE HAVE ROOM?\n         BNL   HI0050                 YES, ADD AN ENTRY\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE DON'T HAVE ROOM IN THE TABLE TO INSERT THE NEW ENTRY, SO    *\n*   WE GETMAIN A NEW TABLE TWICE THE SIZE, AND USE IT INSTEAD.      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_ODT_Ptr          GET A(CURRENT TABLE)\n         L     R1,ODT_Subp_Len-OutDesc_Tbl(R15) GET SUBPOOL, LENGTH\n         SLDL  R0,8                   SUBPOOL IN R0\n         SLL   R0,24                  HIGH-ORDER BYTE OF R0\n         SRL   R1,7                   DOUBLE PREVIOUS SIZE\n         OR    R0,R1                  SET UP GETMAIN REGISTER\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   anywhere\n         ST    R0,@HI_ODT_Subp_Len    SAVE SUBPOOL, LENGTH\n         ST    R1,@HI_ODT_Pointer      AND ADDRESS\n         LR    R0,R1                  R0 = A(NEW TABLE)\n         L     R1,@HI_ODT_Subp_Len    R1 = NEW TABLE LENGTH\n         L     R14,@_ODT_Ptr          R14 = A(OLD TABLE)\n         L     R15,ODT_Subp_Len-OutDesc_Tbl(R14) R15 = LENGTH\n         SLL   R15,8                  FILL CHAR\n         SRL   R15,8                   OF X'00'\n         MVCL  R0,R14                 MOVE OLD TABLE TO NEW\n         L     R1,@_ODT_Ptr           A(OLD TABLE)\n         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) IT'S SUBPOOL, LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         L     R1,@HI_ODT_Pointer     A(NEW TABLE)\n         ST    R1,@_ODT_Ptr           SAVE IT\n         L     R0,@HI_ODT_Subp_Len    NEW TABLE LENGTH, SUBPOOL\n         ST    R0,ODT_Subp_Len-OutDesc_Tbl(R1) SAVE IT IN THE TABLE\n         L     R15,=AL4(ODTE_Length)   LENGTH OF ONE ENTRY\n         MH    R15,ODT_Entry_Count-OutDesc_Tbl(R1) Len of entries\n         LA    R10,ODT_Entry-OutDesc_Tbl(0,R15) PLUS LEN OF HEADER\n         A     R10,@_ODT_Ptr         R10 = A(NEW ENTRY AREA)\nHI0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    INITIALIZE OUR NEW ENTRY WITH THE DEFAULT (FIRST) ENTRY.       *\n*       R10 --> NEW ENTRY AREA.                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R10                SAVE A(NEW ENTRY)\n         L     R1,@_ODT_Ptr           A(ENV TABLE)\n         LA    R0,ODT_Entry-OutDesc_Tbl(R1) A(FIRST ENTRY)\n         L     R1,=AL4(ODTE_Length)   ENTRY LENGTH\n         LR    R14,R15                A(NEW ENTRY)\n         LR    R15,R1                 SAME LENGTH\n         MVCL  R14,R0                 MOVE THE DEFAULT ENTRY\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    NOW SET UP OUR STUFF WITHIN OUR ENTRY.                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   ODTE_DDName,@HI_DDName SAVE OUR DDNAME\n         MVI   ODTE_InExit,C' '       CLEAR\n         MVC   ODTE_InExit+1(L'ODTE_InExit-1),ODTE_InExit INPUT AND\n         MVC   ODTE_OutExit,ODTE_InExit      OUTPUT EXIT NAMES\n         SLR   R15,R15                CLEAR WORK REG\n         ST    R15,ODTE_RTT_Ptr       NO RECORD TYPE TABLE\n         ST    R15,ODTE_JNT_Ptr       NOR JOBNAME TABLE\n         ST    R15,ODTE_DT_Ptr        NO DATA TABLE EITHER\n         L     R15,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R14,ODT_Entry_Count-OutDesc_Tbl(R15) Nbr entries\n         LA    R14,1(0,R14)           BUMP IT\n         STH   R14,ODT_Entry_Count-OutDesc_Tbl(R15) AND SAVE IT\nHI0060   DS    0H\n         L     R1,@HI_Save+4         A(HSA)\n         L     R1,24(0,R1)           A(Original Parm list)\n         ST    R10,8(0,R1)           Update A(ODT Entry)\n         SLR   R15,R15                CLEAR THE RETURN CODE\n         B     HI9000                 AND EXIT\nHI9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HI_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HI_Dynam       DSECT                 Dynamic area for Q\n@HI_Save        DS    18F              O/S Style save area\n@HI_DDName      DS    CL8              DDName for this ODTE\n@HI_ODT_Pointer DS    AL4              A(Output Desc Tbl)\n@HI_ODT_Subp_Len DS   FL4              Subpool, length of ODT\n                DS    0D               Alignment\n@HI_DynLen      EQU   *-@HI_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHJ0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'PERIOD=' Keyword Processor                                    *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_PeriodStart and             *\n*                          ODTE_PeriodEnd updated.                  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HJ0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HJ_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HJ_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HJ_Dynam,R13            Assign a base\n         L     R15,@HJ_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n         L     R10,8(0,R1)              A(ODT Entry)\n\n         USING ODT_Entry,R10            Tell the assembler\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    BEGIN WITH PERIOD START TIME.                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,ODTE_PeriodStart    A(PERIOD START)\nHJ0020   DS    0H\n         MVC   @HJ_Time(6),=C'000000' INIT TEMP AREA\n         LA    R4,@HJ_Time            AND POINT TO IT\nHJ0030   DS    0H\n         CLI   0(R2),C'0'             IS THIS NUMERIC?\n         BL    HJ0040                 NO, SKIP\n         CLI   0(R2),C'9'             SO FAR, MAKE SURE\n         BH    HJ0040                 NOT NUMERIC, SKIP\n         MVC   0(1,R4),0(R2)          ITS NUMERIC, MOVE IT\n         LA    R4,1(0,R4)             BUMP OUTPUT POINTER\n         LA    R2,1(0,R2)             BUMP INPUT POINTER\n         BCT   R3,HJ0030              AND TRY AGAIN\nHJ0040   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE REACHED THE END OF THE TIME FIELD.                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@HJ_Time          A(Start of Time)\n         SR    R4,R15                LENGTH OF DATA\n         BZ    HJ0050                NOTHING THERE, CHECK IT OUT\n         CH    R4,=H'6'              TOO LONG?\n         BH    HJ8000                YES, ERROR\n\n         LR    R4,R1                 Save A(Target field)\n         XC    @HJ_DateConv_Area,@HJ_DateConv_Area Clear Date area\n         PACK  @HJ_DBLWD,@HJ_Time(2)  PACK HH\n         CVB   R15,@HJ_DBLWD          BINARIZE IT\n         STC   R15,@HJ_DateConv_Area+DConv_Time_hh-DateConv_Area\n         PACK  @HJ_DBLWD,@HJ_Time+2(2) GET NBR MINUTES\n         CVB   R15,@HJ_DBLWD          BINARIZE THEM\n         STC   R15,@HJ_DateConv_Area+DConv_Time_mm-DateConv_Area\n         PACK  @HJ_DBLWD,@HJ_Time+4(2) PACK SECONDS\n         CVB   R15,@HJ_DBLWD          BINARIZE THEM\n         STC   R15,@HJ_DateConv_Area+DConv_Time_ss-DateConv_Area\n         OI    @HJ_DateConv_Area+DConv_Input_hhmmss-DateConv_Area,L'DCo+\n               nv_Input_hhmmss       Indicate Time conversion\n         LA    R1,@HJ_DateConv_Area  Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get seconds since midnight\n         LTR   R15,R15               Everything OK?\n         BNZ   HJ8000                No, invalid time\n\n         LR    R1,R4                 Restore A(Target field)\n         L     R15,@HJ_DateConv_Area+DConv_Time-DateConv_Area\n         ST    R15,0(0,R1)           OK, SAVE IT\n         LA    R15,ODTE_PeriodEnd    A(PERIOD END TIME)\n         CR    R1,R15                IS THAT WHAT WE JUST DID?\n         BE    HJ0050                YES, SKIP\n         CLI   0(R2),C'-'            IS THIS THE TIME SEPARATOR?\n         BNE   HJ0050                NO, SKIP\n         LA    R1,ODTE_PeriodEnd     YES, A(PERIOD END TIME)\n         LA    R2,1(0,R2)            POINT PAST SEPARATOR\n         BCT   R3,HJ0020             AND PROCESS IT\nHJ0050   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE THE END OF THE PARAMETERS - CHECK THAT WE TERMINATE    *\n*   WITH A SPACE OR COMMA, AND THAT PERIOD START IS LESS THAN       *\n*   PERIOD END.                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CLI   0(R2),C' '            TERMINATING SPACE?\n         BE    HJ0060                YES, SKIP\n         CLI   0(R2),C','            NO, HOW ABOUT COMMA?\n         BNE   HJ8000                NO, ERROR\nHJ0060   DS    0H\n         L     R15,ODTE_PeriodStart  GET PERIOD START TIME\n         C     R15,ODTE_PeriodEnd    COMPARE TO PERIOD END\n         BH    HJ8000                START > END, ERROR\n         SLR   R15,R15               OK, CLEAR THE RETURN CODE\n         B     HJ9000                AND EXIT\nHJ8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    WE HAVE AN ERROR, SET THE RETURN CODE.                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                 SET THE RETURN CODE\n         B     HJ9000                AND EXIT\nHJ9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HJ_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HJ_Dynam       DSECT                 Dynamic area for HJ\n@HJ_Save        DS    18F              O/S Style save area\n@HJ_DBLWD       DS    D                Work area\n@HJ_Time        DS    XL6              Work area\n@HJ_DateConv_Area DS   CL(DConv_Area_Length)     Our area\n                DS    0D               Alignment\n@HJ_DynLen      EQU   *-@HJ_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHK0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'SEQUENCE=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, @_SYSUT1_Sequence flag updated.  *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HK0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HK_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HK_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HK_Dynam,R13            Assign a base\n         L     R15,@HK_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"YES\" KEYWORD.                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'3'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HK8000                 NO, ERROR\n         CLC   0(3,R2),=C'YES'        YES, IS THIS IT?\n         BNE   HK8000                 NO, ERROR\n         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence YES, SET FLAG\n         LA    R2,3(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'3'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HK9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HK9000                 YES, SKIP\n         B     HK8000                 NO, ERROR\nHK8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HK9000                 AND EXIT\nHK9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HK_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HK_Dynam       DSECT                 Dynamic area for S\n@HK_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HK_DynLen      EQU   *-@HK_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\n\n         PUSH  USING\n\nHL0010   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'CHECKVBS=' Keyword Processor                                  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, @_SYSUT1_NoVBSChk flag set       *\n*                      4 - Error found                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HL0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HL_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HL_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HL_Dynam,R13            Assign a base\n         L     R15,@HL_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of keyword                                *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=H'2'               ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HL8000                 NO, ERROR\n         CLC   0(2,R2),=C'NO'         YES, IS THIS IT?\n         BNE   HL8000                 NO, ERROR\n         OI    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk YES, SET FLAG\n         LA    R2,2(0,R2)             POINT PAST LITERAL\n         SH    R3,=H'2'               RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HL9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HL9000                 YES, SKIP\n         B     HL8000                 NO, ERROR\nHL8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HL9000                 AND EXIT\nHL9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HL_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n@HL_Dynam       DSECT                 Dynamic area for U\n@HL_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HL_DynLen      EQU   *-@HL_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         EJECT\nHM0010   DS    0H\n\n         PUSH  USING\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    'WEEKENDS=' Keyword Processor                                  *\n*             Valid values are:                                     *\n*                     \"IGNORE\" - Do not process Saturday or Sunday  *\n*    On Entry, R1 --->  A(Operand)                                  *\n*                       Fullword containing # characters left in    *\n*                        the input record                           *\n*                       A(ODT Entry)                                *\n*    On Exit,  R15 =   0 - All OK, ODTE_Ignore_Weekend flag set     *\n*                      4 - Invalid Parameter                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING HM0010,R11               Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@HM_DynLen,           this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@HM_DynLen             Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @HM_Dynam,R13            Assign a base\n         L     R15,@HM_Dynam+4          Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Load our parm registers:                                       *\n*         R2 ---> Operand of PRINT= keyword                         *\n*         R3    = Nbr chars left in the input record                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LM    R2,R3,0(R1)              Get parms\n         L     R10,8(0,R1)              A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CHECK FOR \"NO\" KEYWORD.                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         CH    R3,=HL2'6'             ENOUGH ROOM LEFT FOR LITERAL?\n         BNH   HM8000                 NO, ERROR\n         CLC   0(6,R2),=C'IGNORE'     YES, IS THIS IT?\n         BNE   HM8000                 NO, ERROR\n         OI    ODTE_Ignore_Weekend-ODT_Entry(R10),L'ODTE_Ignore_Weekend\n         LA    R2,6(0,R2)             POINT PAST LITERAL\n         SH    R3,=HL2'6'             RESET LENGTH REMAINING\n         SLR   R15,R15                ASSUME EVERYTHING IS OK\n         CLI   0(R2),C' '             VALID SEPARATOR?\n         BE    HM9000                 YES, OK\n         CLI   0(R2),C','             NO, TRY AGAIN\n         BE    HM9000                 YES, SKIP\n         B     HM8000                 NO, ERROR\nHM8000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SOME SORT OF ERROR FOUND, SET RETURN CODE                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,4                  FLAG AN ERROR\n         B     HM9000                 AND EXIT\nHM9000   DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,4(0,R13)              A(HSA)\n         L     R1,24(0,R1)              Get original R1\n         STM   R2,R3,0(R1)              Update parms\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@HM_Dynam             A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n         LTORG\n\n@HM_Dynam       DSECT                 Dynamic area for HM\n@HM_Save        DS    18F              O/S Style save area\n                DS    0D               Alignment\n@HM_DynLen      EQU   *-@HM_Dynam     Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'I0000: OPEN SYSUT1'\n\n         PUSH  USING\n\nI0010    DS    0H\n\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : I0010                                                  *\n*                                                                     *\n*  Abstract  : OPEN SYSUT1, allocating it to the active SMF dataset   *\n*              if required. Print some interesting(?) info about it.  *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSUT1 not useable.                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Removed EODAD stuff.                *\n*                                 Used W0010 to get A(JFCB).          *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING I0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@I_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@I_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @I_Dynam,R13             Assign a base\n         L     R15,@I_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*     Get the storage for our DCB and DCBE                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,4                     Length field\n         LA    R1,I_SYSUT1_BSAM_DCB_Length(0,R1) Plus length of DCB\n         LA    R0,I_SYSUT1_DCBE_Length(0,R1) Plus length of DCBE\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R1,@_SYSUT1_BtL_Ptr      Save A(Storage)\n         ST    R0,0(0,R1)               Save length\n         LA    R2,4(0,R1)               Point to DCB area\n         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it\n         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And go get the JFCB - if this fails, we assume that SYSUT1     *\n*   has not been allocated                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)\n         LA    R1,4(0,R1)               Point to DCB area\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  How did it go?\n         BZ    I0060                    OK, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    No SYSUT1 DDName found, so dynamically allocate it to the      *\n*   active SMF file, if there is one.                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,CVTPTR(0,0)          Get A(CVT)\n         L     R15,CVTSMCA-CVT(R15)     And then the SMCA\n         TM    SMCAMISC-SMCABASE(R15),SMCAUSER  SMF recording?\n         BZ    I8000                    No, no active SMF file\n         L     R14,SMCAFRDS-SMCABASE(R15) Yes, get A(1st RDS)\n         L     R15,SMCALRDS-SMCABASE(R15) and A(last RDS)\nI0040    DS    0H\n         TM    12(R14),X'04'            Active SMF dataset?\n         BZ    I0050                    Yes, skip\n         L     R14,4(0,R14)             No, get A(Next)\n         CR    R14,R15                  End of chain?\n         BNE   I0040                    No, keep checking\n         B     I8000                    Yes, no active SMF file\nI0050    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We have found the active SMF file (R14 points to the RDS),     *\n*   so build the SVC99 control blocks ...                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,@I_SVC99_RB          A(S99 RB)\n         ST    R15,@I_SVC99_RB_Ptr+S99RBPTR-S99RBP SAVE IT\n         OI    @I_SVC99_RB_Ptr+S99RBPTR-S99RBP,S99RBPND\n\n         MVI   @I_SVC99_RB+S99RBLN-S99RB,S99RBEND-S99RB LENGTH\n         MVI   @I_SVC99_RB+S99VERB-S99RB,S99VRBAL ALLOCATE\n         SLR   R15,R15                CLEAR WORK REGISTER\n         STH   R15,@I_SVC99_RB+S99FLAG1-S99RB CLEAR FLAG1\n         STH   R15,@I_SVC99_RB+S99ERROR-S99RB CLEAR ERROR CODE\n         STH   R15,@I_SVC99_RB+S99INFO-S99RB CLEAR INFO CODE\n         LA    R15,@I_SVC99_TU_List   A(TEXT UNIT POINTERS)\n         ST    R15,@I_SVC99_RB+S99TXTPP-S99RB SAVE IT\n         SLR   R15,R15                CLEAR WORK REGISTER\n         ST    R15,@I_SVC99_RB+S99TXTPP+4-S99RB CLEAR RESERVED FIELD\n         ST    R15,@I_SVC99_RB+S99FLAG2-S99RB CLEAR FLAG 2\n\n         LA    R15,@I_SVC99_DDName_TU A(DDNAME)\n         ST    R15,@I_SVC99_TU_List   SAVE IT\n         LA    R15,@I_SVC99_DSName_TU A(DSNAME)\n         ST    R15,@I_SVC99_TU_List+4 SAVE IT\n         LA    R15,@I_SVC99_Status_TU A(STATUS)\n         ST    R15,@I_SVC99_TU_List+8 SAVE IT\n         LA    R15,@I_SVC99_NDisp_TU  A(NDISP)\n         ST    R15,@I_SVC99_TU_List+12 SAVE IT\n         LA    R15,@I_SVC99_CDisp_TU  A(CDISP)\n         ST    R15,@I_SVC99_TU_List+16 SAVE IT\n         LA    R15,@I_SVC99_Free_TU   A(FREE)\n         ST    R15,@I_SVC99_TU_List+20 SAVE IT\n         OI    @I_SVC99_TU_List+20,S99TUPLN END OF LIST\n\n         LA    R15,DALDDNAM           DDNAME TEXT KEY\n         STH   R15,@I_SVC99_DDName_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_DDName_TU+S99TUNUM-S99TUNIT SAVE IT\n         LA    R15,8                  LEN OF PARMS\n         STH   R15,@I_SVC99_DDName_TU+S99TULNG-S99TUNIT SAVE IT\n         MVC   @I_SVC99_DDName_TU+S99TUPAR-S99TUNIT(8),=CL8'SYSUT1'\n\n         LA    R15,DALDSNAM           DSNAME TEXT KEY\n         STH   R15,@I_SVC99_DSName_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_DSName_TU+S99TUNUM-S99TUNIT SAVE IT\n         LA    R15,44                 LEN OF PARMS\n         STH   R15,@I_SVC99_DSName_TU+S99TULNG-S99TUNIT SAVE IT\n         MVC   @I_SVC99_DSName_TU+S99TUPAR-S99TUNIT(44),16(R14) SMF DSN\n\n         LA    R15,DALSTATS           STATUS TEXT KEY\n         STH   R15,@I_SVC99_Status_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_Status_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_Status_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_Status_TU+S99TUPAR-S99TUNIT,X'08' SHR\n\n         LA    R15,DALNDISP           NORMAL DISP\n         STH   R15,@I_SVC99_NDisp_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_NDisp_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_NDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_NDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP\n\n         LA    R15,DALCDISP           CONDITIONAL DISP\n         STH   R15,@I_SVC99_CDisp_TU+S99TUKEY-S99TUNIT SAVE IT\n         LA    R15,1                  NBR PARMS\n         STH   R15,@I_SVC99_CDisp_TU+S99TUNUM-S99TUNIT SAVE IT\n         STH   R15,@I_SVC99_CDisp_TU+S99TULNG-S99TUNIT LENGTH OF 1 TOO\n         MVI   @I_SVC99_CDisp_TU+S99TUPAR-S99TUNIT,X'08' KEEP\n\n         LA    R15,DALCLOSE           FREE=CLOSE\n         STH   R15,@I_SVC99_Free_TU+S99TUKEY-S99TUNIT SAVE IT\n         SLR   R15,R15                NBR PARMS\n         STH   R15,@I_SVC99_Free_TU+S99TUNUM-S99TUNIT SAVE IT\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and invoke Dynamic Allocation                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@I_SVC99_RB_Ptr     A(SVC99 RB Pointer)\n         SVC   99                     Go do it\n         LTR   R15,R15                Did it work?\n         BNZ   I8010                  No, error\n\n         OI    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Yes, in sequence\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And go get the JFCB (again)                                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Storage)\n         LA    R1,4(0,R1)               Point to DCB area\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n         LTR   R15,R15                  How did it go?\n         BNZ   I8020                    Not good, exit with error\n\nI0060    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Save some info from the JFCB                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R1,@I_JFCB_Ptr           Save A(JFCB)\n\n         MVC   @I_JFCBUFNO,JFCBUFNO-INFMJFCB(R1) Save DCB=BUFNO=\n         MVC   @I_JFCNCP,JFCNCP-INFMJFCB(R1) Save DCB=NCP=\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some info about the device on which SYSUT1 lives           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         XC    @I_DVACLASS,@I_DVACLASS            Device Class\n         XC    @I_DVATRK,@I_DVATRK                Trks/Cyl\n         XC    @I_DVATRKLN,@I_DVATRKLN            Bytes/Trk\n\n         LA    R1,I_SYSUT1_BSAM_DCB+DCBDDNAM-IHADCB A(DDName)\n         LA    R0,@I_DEVAREA          A(Return area)\n         DEVTYPE (1),(0),DEVTAB       Get SYSUT1 device info\n         LTR   R15,R15                Did it work?\n         BNZ   I0070                  No, skip\n         MVC   @I_DVACLASS,@I_DEVAREA+DVACLASS-DVAREA Device Class\n         MVC   @I_DVATRK,@I_DEVAREA+DVATRK-DVAREA Trks/Cyl\n         MVC   @I_DVATRKLN,@I_DEVAREA+DVATRKLN-DVAREA Bytes/Trk\nI0070    DS    0H\n\n         L     R15,@I_JFCB_Ptr        A(JFCB)\n         TM    JFCDSRG2-INFMJFCB(R15),JFCORGAM VSAM?\n         BNZ   I0170                  Yes, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is non-VSAM; OPEN the BSAM DCB ...                      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)\n         LA    R2,4(0,R2)             A(DCB)\n\n         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN BSAM DCB\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Is it open?\n         BNO   I8020                  No, error\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... save some info from the DCB ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @I_RECFM,DCBRECFM-IHADCB(R2) Save RECFM\n         MVC   @I_NCP,DCBNCP-IHADCB(R2)      Save NCP (Calc by OPEN)\n         LH    R15,DCBLRECL-IHADCB(R2)       Get LRECL\n         ST    R15,@_SYSUT1_Rec_Length       and save it\n         MVC   @I_BLKSI,DCBBLKSI-IHADCB(R2)   and BLKSIZE\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and close it.                                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         MVC   @I_CLOSE,I_CLOSE              Move CLOSE parms\n         CLOSE ((2)),MODE=31,MF=(E,@I_CLOSE)  and close BSAM DCB\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Calculate the value of DCBNCP or DCBBUFNO that we will         *\n*   use so we can read a cylinder at a time (assuming SYSUT1 lives  *\n*   on DASD - if it doesn't, we use an arbitrary value of 30). OPEN *\n*   has calculated the number of blocks on a track (DCBNCP).        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,30                  Default number of buffers\n         STH   R0,@I_Buffer_Count     Save it\n\n         TM    @I_DVACLASS,UCB3DACC   DASD device?\n         BZ    I0100                  No, use default\n         SLR   R0,R0                  Yes, get\n         IC    R0,@I_NCP               blocks/track\n         MH    R0,@I_DVATRK           Times Trks/Cyl\n         LTR   R0,R0                  Is it 0?\n         BZ    I0080                  Yes, use blks/trk\n         C     R0,=FL4'255'           No, too big?\n         BNH   I0090                  No, use it\nI0080    DS    0H\n         SLR   R0,R0                  Yes, use\n         IC    R0,@I_NCP               blocks/trk\nI0090    DS    0H\n         STH   R0,@I_Buffer_Count     Save it\nI0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    We know we are non-VSAM. If the RECFM is not variable spanned, *\n*   or we have been told not to check for spanning errors, we will  *\n*   use QSAM as our access method. Otherwise ...                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Should we check?\n         BO    I0140                  No, skip\n         TM    @I_RECFM,DCBRECV+DCBRECSB     VS or VBS?\n         BNO   I0140                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... we will use BSAM.                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Set BSAM Input flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Calculate the number of buffers we will need. If this has not  *\n*   been specified by the user (DCB=NCP= or DCB=BUFNO=), we use     *\n*   the value we calculated earlier that will allow us to read a    *\n*   cylinder at a time.                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@I_JFCNCP           Get user specified DCB=NCP=\n         LTR   R0,R0                  Anything?\n         BNZ   I0110                  Yes, skip\n         IC    R0,@I_JFCBUFNO         No, get DCB=BUFNO=\n         LTR   R0,R0                  Anything?\n         BZ    I0120                  No, use default\nI0110    DS    0H\n         STH   R0,@I_Buffer_Count     Yes, update our variable\nI0120    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some storage above-the-line for our buffers and stuff:     *\n*     +0     A(Next Buffer area)                                    *\n*     +4     A(DECB)                                                *\n*     +8     Offset within buffer of next segment                   *\n*     +C     Buffer (length of DCBBLKSI)                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,BuffArea_Hdr_Length Header bytes\n         AH    R1,@I_BLKSI            Plus buffer area\n         LA    R1,7(0,R1)             Make it\n         SRL   R1,3                    its a\n         SLL   R1,3                    doubleword\n         ST    R1,@I_Buffer_Length    Save Buffer length\n         LA    R2,8(0,R1)             Minimum storage we need\n         LH    R0,@I_Buffer_Count     Number of buffers we need\n         MR    R0,R0                  Total length\n         LA    R0,8(0,R1)             plus header length\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=((0),(2)),         this long                     +\n               LOC=ANY                   anywhere\n         ST    R1,@_SYSUT1_AtL_Ptr    Save the address\n         ST    R0,0(0,R1)              and the length\n         LR    R15,R0                 Get the length\n         SH    R15,=H'8'               less the header length\n         SLR   R14,R14                prepare for divide\n         D     R14,@I_Buffer_Length   Calculate number of buffers\n         STH   R15,@I_Buffer_Count    Save number of buffers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If we do not have enough room below-the-line for the DCB and   *\n*   associated DECBs, free it and go get enough                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,I_READ_Length       Length of 1 DECB\n         MH    R1,@I_Buffer_Count     Length of all DECBs\n         LA    R1,4+I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R1)\n         L     R15,@_SYSUT1_BtL_Ptr   A(current storage)\n         C     R1,0(0,R15)            Long enough?\n         BNH   I0130                  Yes, skip\n         ST    R1,@I_DBLWD            No, save length required\n         L     R1,@_SYSUT1_BtL_Ptr    A(Our storage)\n         L     R0,0(0,R1)             Get its length\n         STORAGE RELEASE,             Free the storage                 +\n               LENGTH=(0),             this long                       +\n               ADDR=(1)                starting here\n         L     R0,@I_DBLWD            Get the amount we need\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=(0),               this long                     +\n               LOC=BELOW                 below-the-line\n         ST    R0,0(0,R1)             Save the length\n         ST    R1,@_SYSUT1_BtL_Ptr    Save A(Storage)\nI0130    DS    0H\n         L     R2,@_SYSUT1_BtL_Ptr    A(Below-the-line storage)\n         LA    R2,4(0,R2)             A(DCB area)\n         MVC   0(I_SYSUT1_BSAM_DCB_Length,R2),I_SYSUT1_BSAM_DCB Move it\n\n         LH    R15,@I_Buffer_Count    Nbr buffers\n         STC   R15,DCBNCP-IHADCB(R2)  Update NCP\n\n         LA    R14,I_SYSUT1_BSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address\n\n         B     I0190                  and skip\n\nI0140    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is non-VSAM and not RECFM=VS or VBS, so we will use     *\n*   QSAM.                                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_QSAM,L'@_SYSUT1_QSAM Set QSAM Input flag\n\n         SLR   R0,R0                  Clear work register\n         IC    R0,@I_JFCBUFNO         Get user-specified DCB=BUFNO=\n         LTR   R0,R0                  Anything?\n         BNZ   I0150                  Yes, skip\n         IC    R0,@I_JFCNCP           No, get DCB=NCP=\n         LTR   R0,R0                  Anything?\n         BZ    I0160                  No, skip\nI0150    DS    0H\n         STH   R0,@I_Buffer_Count     Yes, update our field\nI0160    DS    0H\n         MVC   0(I_SYSUT1_QSAM_DCB_Length,R2),I_SYSUT1_QSAM_DCB\n         LH    R15,@I_Buffer_Count    Blocks per cyl\n         STC   R15,DCBBUFNO-IHADCB(R2) Save it\n\n         LA    R14,I_SYSUT1_QSAM_DCB_Length(0,R2) Point past DCB\n         MVC   0(I_SYSUT1_DCBE_Length,R14),I_SYSUT1_DCBE  Move DCBE\n         ST    R14,DCBDCBE-IHADCB(0,R2) Save A(DCBE) in DCB\n\n         ST    R2,@_SYSUT1_DCB_Ptr    Init DCB address\n         B     I0190                  and skip\n\nI0170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is VSAM, so set our flag ...                            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         OI    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM  Set VSAM Input flag\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... save some VSAM-related info from the JFCB ...              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@I_JFCB_Ptr          A(JFCB)\n\n         SLR   R0,R0                    Clear work register\n         L     R0,JFCBABFS+1-INFMJFCB(R15) Get BUFSP\n         SRL   R0,8                     Align it properly\n         ST    R0,@I_JFCBABFS           Save it\n         SLR   R0,R0                    Clear work register\n         LH    R0,JFCBADBF-INFMJFCB(R15) Get BUFND\n         STH   R0,@I_JFCBADBF           Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... free the below-the-line storage ...                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_BtL_Ptr      A(Below-the-line storage)\n         L     R0,0(0,R1)               Get its length\n         STORAGE RELEASE,               Free the storage               +\n               LENGTH=(0),               this long                     +\n               ADDR=(1)                  starting here\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSUT1_BtL_Ptr     No more storage below\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and get some above-the-line for the ACB, EXLST and RPL     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R0,4+I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length+SYSUT1_RP+\n               L_Length\n         STORAGE OBTAIN,                Get some storage               +\n               LENGTH=(0),               this long                     +\n               LOC=ANY                   from above-the-line\n         ST    R1,@_SYSUT1_AtL_Ptr      Save the address\n         ST    R0,0(0,R1)               Save the length\n         LA    R2,4(0,R1)               Point to ACB area\n         MVC   0(I_SYSUT1_ACB_Length,R2),I_SYSUT1_ACB  Move ACB\n         ST    R2,@_SYSUT1_ACB_Ptr      Save A(ACB)\n\n         LA    R3,I_SYSUT1_ACB_Length(0,R2) A(Dynamic EXLST)\n         MVC   0(I_SYSUT1_EXLST_Length,R3),I_SYSUT1_EXLST Move it\n         MODCB ACB=(2),               Update SYSUT1 ACB                +\n               EXLST=(3),              with EXLST                      +\n               MF=(G,@I_MODCB1,I_MODCB1_Length)\n\n         ICM   R0,B'1111',@I_JFCBABFS Get user-specified BUFSP=\n         BNZ   I0180                  OK, skip\n         LH    R0,@I_JFCBADBF         None, get user specified BUFND=\n         LTR   R0,R0                  Any?\n         BNZ   I0180                  Yes, skip\n         SLR   R15,R15                No, clear work register\n         ST    R15,@I_BUFSP           Clear Buffer space\n         LH    R2,@I_DVATRK           Get Trks/Cyl\n         LH    R3,@I_DVATRKLN         Get Bytes/Trk\n         SLL   R3,16                  Make sure\n         SRL   R3,16                   its positive\n         MR    R2,R2                  Get Bytes/Cyl\n         LTR   R3,R3                  Anything?\n         BZ    I0180                  No, don't modify ACB\n         A     R3,=FL4'4096'          Yes, bump by a page\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         MODCB ACB=(2),               Update SYSUT1 ACB                +\n               BUFSP=(3),               for bytes/cyl                  +\n               MF=(G,@I_MODCB2,I_MODCB2_Length)\n\n         ST    R3,@I_BUFSP            and save Buffer Space\nI0180    DS    0H\n         L     R2,@_SYSUT1_ACB_Ptr    A(ACB)\n         LA    R3,@_SYSUT1_Rec_Length A(RECEIVING AREA)\n         SHOWCB ACB=(2),              YES, FROM SYSUT1 ACB             *\n               FIELDS=LRECL,            WE WANT THE LRECL              *\n               AREA=(3),                MOVED TO THIS AREA             *\n               LENGTH=L'@_SYSUT1_Rec_Length, for this long             *\n               MF=(G,@I_SHOWCB,I_SHOWCB_Length)\n         LTR   R15,R15                Did it work?\n         BZ    I0190                  Yes, skip\n         LH    R15,=H'32767'          No, assume the biggest\n         ST    R15,@_SYSUT1_Rec_Length and save it\nI0190    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area in which the input record will be assembled        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_Rec_Length Get size of record\n         LA    R1,7(0,R1)            Make it\n         SRL   R1,3                   doubleword multiple\n         SLDL  R0,35                  in R0\n         STORAGE OBTAIN,             Get some storage                  +\n               LENGTH=(0),            this long                        +\n               LOC=BELOW              below the line\n\n         ST    R1,@_SYSUT1_Rec_Ptr   Save it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    And open SYSUT1 (@_SYSUT1_DCB_Ptr contains the address of the  *\n*   DCB or ACB)                                                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R2,@_SYSUT1_DCB_Ptr    Point to the DCB/ACB\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN DCB already open?\n         BO    I0210                  Yes, skip the OPEN\n         MVC   @I_OPEN,I_OPEN         MOVE OPEN PARMS\n         OPEN  ((2),INPUT),MODE=31,MF=(E,@I_OPEN) AND OPEN DCB/ACB\n         LTR   R15,R15                DID IT OPEN?\n         BNZ   I8020                  NO, ERROR\nI0210    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 is open, so go list some interesting(?) info            *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSUT1_DCB_Ptr    A(DCB or ACB)\n         L     R15,=A(J0010)          A(DCB info routine)\n         BASR  R14,R15                Go do it\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                SKIP A LINE\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  AND ANOTHER\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    SYSUT1 has been opened successfully - if we are using BSAM     *\n*   to read it ...                                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Are we using BSAM?\n         BNO   I0410                  No, skip\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... initialize the DECBs and buffer areas, and prime the areas *\n*   with initial READs                                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R4,@_SYSUT1_AtL_Ptr    A(Above-the-line storage)\n         LA    R4,8(0,R4)             A(1st buffer area)\n         L     R2,@_SYSUT1_DCB_Ptr    A(DCB)\n         LA    R5,I_SYSUT1_BSAM_DCB_Length+I_SYSUT1_DCBE_Length(0,R2)\n         LH    R6,@I_Buffer_Count     Nbr buffers\nI0400    DS    0H\n         ST    R5,BuffArea_DECB_Ptr-BuffArea(0,R4) Save A(DECB)\n         MVC   0(I_READ_Length,R5),I_READ  Initialize DECB\n         LA    R3,BuffArea_IOArea-BuffArea(0,R4) A(I/O Area)\n         READ  (5),SF,(2),(3),'S',MF=E    Issue the read\n         SLR   R15,R15                Clear work register\n         ST    R15,BuffArea_Offset-BuffArea(0,R4) Clear Offset\n         L     R15,@I_Buffer_Length   Get buffer size\n         AR    R15,R4                 Point to next area\n         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain BuffAreas\n         LR    R4,R15                 Point to next BuffArea\n         LA    R5,I_READ_Length(0,R5) A(next DECB)\n         BCT   R6,I0400               and do it too\n\n         S     R4,@I_Buffer_Length    Back up to last buffer area\n         L     R15,@_SYSUT1_AtL_Ptr   Point to\n         LA    R15,8(0,R15)             1st buffer area\n         ST    R15,BuffArea_Next_Ptr-BuffArea(0,R4) Chain last to 1st\n         ST    R15,@_SYSUT1_BuffArea_Ptr And init our pointer\n\nI0410    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the input is VSAM, generate an RPL in the area after the    *\n*   ACB                                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is SYSUT1 VSAM?\n         BNO   I0420                    No, skip\n\n         L     R2,@_SYSUT1_ACB_Ptr      A(ACB)\n         LA    R3,I_SYSUT1_ACB_Length+I_SYSUT1_EXLST_Length(0,R2)\n         L     R4,@_SYSUT1_Rec_Ptr      A(Record area)\n         L     R5,@_SYSUT1_Rec_Length   Length of a record\n         GENCB BLK=RPL,               GENERATE RPL                     *\n               AM=VSAM,                 FOR VSAM                       *\n               ACB=(2),                 SYSUT1                         *\n               AREA=(4),                A(INPUT RECORD ADDRESS)        *\n               AREALEN=(5),             Len of the address             *\n               OPTCD=(ADR,SEQ,MVE,SYN), MOVE MODE                      *\n               WAREA=(3),               BUILD THE RPL HERE             *\n               LENGTH=SYSUT1_RPL_Length,  its this long                +\n               MF=(G,@I_GENCB,I_GENCB_Length)\n\n         ST    R3,@_SYSUT1_RPL_Ptr      Save A(RPL)\n\nI0420    DS    0H\n         SLR   R15,R15                Clear return code\n         B     I9000                  and exit\n\nI8000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    No active SMF file                                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   1(16,R1),=C'No active SMF File found'\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                GO PRINT IT\n         LA    R15,4                  FLAG AN ERROR\n         B     I9000                  AND EXIT\n\nI8010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Dynalloc (SVC99) error                                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         MVC   1(16,R1),=C'Error allocating'\n         MVC   18(10,R1),@I_SVC99_DSName_TU+S99TUPAR-S99TUNIT MOVE DSN\n         MVC   28(30,R1),=C', RC=XX, Error=XXXX, Info=XXXX'\n         SRL   R15,4                  MAKE ROOM FOR \"SIGN\"\n         STH   R15,@I_DBLWD           SAVE IT\n         OI    @I_DBLWD+1,X'0F'       INSERT A  SIGN\n         UNPK  @I_DBLWD+2(3),@I_DBLWD(2) UNPACK IT\n         TR    @I_DBLWD+3(2),I_HexNum MAKE IT READABLE\n         MVC   33(2,R1),@I_DBLWD+3    MOVE TO MESSAGE\n         LH    R15,@I_SVC99_RB+S99ERROR-S99RB GET ERROR CODE\n         SRL   R15,4                  MAKE ROOM FOR SIGN\n         ST    R15,@I_DBLWD+4         SAVE IT\n         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN\n         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT\n         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE\n         MVC   43(4,R1),@I_DBLWD+1   MOVE TO MESSAGE\n         LH    R15,@I_SVC99_RB+S99INFO-S99RB GET INFO CODE\n         SRL   R15,4                  MAKE ROOM FOR SIGN\n         ST    R15,@I_DBLWD+4         SAVE IT\n         OI    @I_DBLWD+7,X'0F'       INSERT A SIGN\n         UNPK  @I_DBLWD(5),@I_DBLWD+5(3) UNPACK IT\n         TR    @I_DBLWD+1(4),I_HexNum MAKE IT READABLE\n         MVC   54(4,R1),@I_DBLWD+1   MOVE TO MESSAGE\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                GO PRINT IT\n         LA    R15,4                  FLAG AN ERROR\n         B     I9000                  AND EXIT\nI8020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Error opening SYSUT1                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr  NO, GET A(SYSPRINT RECORD)\n         MVC   22(40,R1),=C'SYSUT1 could not be opened - terminating'\n         LA    R15,12                 SET RETURN CODE\n         B     I9000                  AND EXIT\n\nI9000    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Rescue the return code\n\n         LA    R1,@I_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R15,R3                   Restore return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nI_HexNum EQU   *-239\n         DC    C' 0123456789ABCDEF'\n\n         LTORG\n\n\n         PUSH PRINT\n         PRINT NOGEN\nI_SYSUT1_QSAM_DCB DCB DDNAME=SYSUT1,MACRF=GM,DSORG=PS,OPTCD=C,         +\n               DCBE=1\nI_SYSUT1_QSAM_DCB_Length EQU *-I_SYSUT1_QSAM_DCB LENGTH OF SYSUT1 DCB\n\nI_SYSUT1_BSAM_DCB DCB DDNAME=SYSUT1,MACRF=RC,DSORG=PS,                 +\n               DCBE=1\nI_SYSUT1_BSAM_DCB_Length EQU *-I_SYSUT1_BSAM_DCB LENGTH OF SYSUT1 DCB\n\nI_SYSUT1_DCBE DCBE RMODE31=BUFF,MULTSDN=1,EODAD=1\nI_SYSUT1_DCBE_Length EQU *-I_SYSUT1_DCBE Length of SYSUT1 DCBE\n\nI_SYSUT1_ACB ACB AM=VSAM,               FOR VSAM                       *\n               DDNAME=SYSUT1,           SYSUT1                         *\n               BUFND=3,                 DATA BUFFERS                   *\n               BUFSP=131072,            128K FOR BUFFERS               *\n               STRNO=1,                 NBR STRINGS                    *\n               EXLST=I_SYSUT1_EXLST,    EODAD                          *\n               MACRF=(ADR,NFX,DDN,NRM,NRS,SEQ,IN),                     *\n               RMODE31=ALL              Everything above-the-line\n             DS    0D\nI_SYSUT1_ACB_Length EQU   *-I_SYSUT1_ACB\n\n         PRINT GEN\nI_SYSUT1_EXLST EXLST AM=VSAM,           For VSAM                       +\n               EODAD=1                   End-of-Data\n             DS    0D\nI_SYSUT1_EXLST_Length EQU *-I_SYSUT1_EXLST\n         PRINT NOGEN\n\nI_OPEN   OPEN  (0,INPUT),MODE=31,MF=L\nI_OPEN_Length EQU  *-I_OPEN\n\n         READ  I_READ,SF,0,0,'S',MF=L\nI_READ_Length EQU  *-I_READ\n\nI_CLOSE  CLOSE (0),MODE=31,MF=L\nI_CLOSE_Length EQU *-I_CLOSE\n\n         POP    PRINT\n@I_Dynam        DSECT                 Dynamic area for I\n@I_Save         DS    18F              O/S Style save area\n@I_DBLWD        DS    D                Workarea\n\n@I_JFCB_Ptr     DS    AL4              A(JFCB)\n@I_DVACLASS     DS    X                Device class from DEVTYPE\n@I_DVATRK       DS    HL2              Trks/Cyl from DEVTYPE\n@I_DVATRKLN     DS    HL2              Bytes/Trk from DEVTYPE\n@I_RECFM        DS    X                DCB=RECFM\n\n@I_DCBChar      EQU   *                Non-VSAM DCB Characteristics\n@I_JFCBUFNO     DS    X                 DCB=BUFNO from JFCB\n@I_JFCNCP       DS    X                 DCB=NCP= from JFCB\n@I_BLKSI        DS    HL2               SYSUT1 BLKSIZE\n@I_NCP          DS    X                 DCB=NCP (calculated by OPEN)\n@I_Buffer_Count DS    HL2               Number of buffer areas\n@I_Buffer_Length DS   FL4               Buffer area length\n@I_ACBChar      ORG   @I_DCBChar       VSAM ACB Characteristics\n@I_JFCBABFS     DS    FL4               AMP=BUFSP= from JFCB\n@I_JFCBADBF     DS    HL2               AMP=BUFND= from JFCB\n@I_BUFSP        DS    FL4               VSAM BUFFSP\n                ORG\n\n@I_MACRO        DS    0F               Macro area\n                ORG   @I_MACRO\n@I_OPEN         DS    CL(I_OPEN_Length) OPEN macro\n                ORG   @I_MACRO\n@I_CLOSE        DS    CL(I_CLOSE_Length) CLOSE macro\n                ORG   @I_MACRO\n@I_SHOWCB       DS    CL(I_SHOWCB_Length) SHOWCB Macro\n                ORG   @I_MACRO\n@I_MODCB1       DS    CL(I_MODCB1_Length) MODCB Macro\n                ORG   @I_MACRO\n@I_MODCB2       DS    CL(I_MODCB2_Length) MODCB Macro\n                ORG   @I_MACRO\n@I_GENCB        DS    CL(I_GENCB_Length) GENCB Macro\n                ORG   @I_MACRO\n@I_DEVAREA      DS    CL(L'DVAPREFX+L'DVATAB) DEVTAB return info\n                ORG   @I_MACRO\n*-------------------------------------------------------------------*\n*                                                                   *\n*    DYNAMIC ALLOCATION (SVC 99) CONTROL BLOCKS                     *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n@I_SVC99_RB_Ptr    DS  F\n@I_SVC99_RB        DS  CL(S99RBEND-S99RB)\n@I_SVC99_TU_List   DS  6A\n@I_SVC99_DDName_TU DS  CL((S99TUPAR-S99TUNIT)+8)      DDNAME\n@I_SVC99_DSName_TU DS  CL((S99TUPAR-S99TUNIT)+44)     DSNAME\n@I_SVC99_Status_TU DS  CL((S99TUPAR-S99TUNIT)+1)      STATUS\n@I_SVC99_NDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      NORMAL DISP\n@I_SVC99_CDisp_TU  DS  CL((S99TUPAR-S99TUNIT)+1)      COND DISP\n@I_SVC99_Free_TU   DS  CL(S99TUENT-S99TUNIT)          FREE=CLOSE\n                   ORG ,\n\n                DS    0D               Alignment\n@I_DynLen       EQU   *-@I_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         TITLE 'J0000: Print info about DCB'\n\n         PUSH  USING\n\nJ0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : J0010                                                  *\n*                                                                     *\n*  Abstract  : Print info about a DCB or ACB.                         *\n*                                                                     *\n*  Inputs    : R1 ----> A(Open DCB or ACB)                            *\n*  Outputs   : R15: 0 - OK                                            *\n*                   4 - SYSUT1 not useable.                           *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 Invoked W0010 to get JFCB and TIOT  *\n*                                 addresses.                          *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING J0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@J_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@J_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @J_Dynam,R13             Assign a base\n         L     R15,@J_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         ST    R1,@J_DCB_Ptr            Save A(DCB)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get our JFCB ...                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(W0010)          A(Get JFCB routine)\n         BASR  R14,R15                  Go do it\n\n         ST    R1,@J_JFCB_Ptr           Save A(JFCB)\n         ST    R0,@J_TIOT_Entry_Ptr     Save A(TIOT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Put out the DSN and volsers for this DDName                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Rec_Ptr    Get A(SYSPRINT Record)\n         L     R15,@J_TIOT_Entry_Ptr    Get A(TIOT Entry)\n         MVC   1(L'TIOEDDNM,R1),TIOEDDNM-TIOENTRY(R15) Move DDName\n         MVC   2+L'TIOEDDNM(5,R1),=C'DSN: ' Move heading\n         L     R15,@J_JFCB_Ptr          Get A(JFCB)\n         MVC   2+L'TIOEDDNM+5(L'JFCBDSNM,R1),JFCBDSNM-INFMJFCB(R15)\n         LA    R1,2+L'TIOEDDNM+5+L'JFCBDSNM-1(,R1)  A(End of DSN)\nJ0020    DS    0H\n         CLI   0(R1),C' '               Is this the end?\n         BNE   J0030                    Yes, skip\n         BCT   R1,J0020                 No, back up and try again\nJ0030    DS    0H\n         MVC   1(10,R1),=C', Volser: '  Move VOLSER heading\n         LA    R1,11(0,R1)              Point past it\n         L     R15,@J_JFCB_Ptr          Get A(JFCB Pointer)\n         TM    JFCFLGS1-INFMJFCB(R15),JFCVRDS VIO?\n         BNO   J0030C                   No, skip\n         MVC   0(7,R1),=C'**VIO**'      Yes, dummy volser\n         B     J0050                    and skip\nJ0030C   DS    0H\n\n         SLR   R0,R0                    Clear work register\n         IC    R0,JFCBNVOL-INFMJFCB(R15) Get nbr volsers\n         LA    R15,JFCBVOLS-INFMJFCB(R15)  and point to first\n         CH    R0,=H'5'                 More than 5?\n         BNH   J0040                    No, skip\n         LA    R0,5                     Yes, only the 1st 5\nJ0040    DS    0H\n         MVC   0(6,R1),0(R15)           Move VOLSER\n         SH    R0,=H'1'                 Reduce volser count\n         BNP   J0050                    thats all, skip\n         MVI   6(R1),C','               More, add a comma\n         LA    R1,7(0,R1)               Point to next output area\n         LA    R15,6(0,R15)             A(Next input volser)\n         B     J0040                    and do it too\nJ0050    DS    0H\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Put out the DCB or ACB information                             *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@J_DCB_Ptr           A(DCB)\n         TM    DCBDSRG2-IHADCB(R15),DCBACBM Is this VSAM?\n         BO    J0140                    Yes, format VSAM stuff\n         L     R1,@_SYSPRINT_Rec_Ptr    No, get A(SYSPRINT Record)\n         MVC   10(11,R1),=C'DCB=(RECFM=' Move heading\n         LA    R1,21(0,R1)              Point to next byte\n         TM    DCBRECFM-IHADCB(R15),DCBRECF+DCBRECV  RECFM=U?\n         BNO   J0060                    No, skip\n         MVI   0(R1),C'U'               Yes, say so\n         LA    R1,1(0,R1)               Bump pointer\n         B     J0110                    and skip\nJ0060    DS    0H\n         TM    DCBRECFM-IHADCB(R15),DCBRECF  RECFM=F?\n         BZ    J0070                    No, skip\n         MVI   0(R1),C'F'               Yes, say so\n         B     J0080                    and skip\nJ0070    DS    0H\n         MVI   0(R1),C'V'               RECFM=V\nJ0080    DS    0H\n         LA    R1,1(0,R1)               Bump pointer\n         TM    DCBRECFM-IHADCB(R15),DCBRECBR  Blocked?\n         BZ    J0090                    No, skip\n         MVI   0(R1),C'B'               Yes, say so\n         LA    R1,1(0,R1)               Bump pointer\nJ0090    DS    0H\n         TM    DCBRECFM-IHADCB(R15),DCBRECSB Spanned or Standard?\n         BZ    J0100                    No, skip\n         MVI   0(R1),C'S'               Yes, say so\n         LA    R1,1(0,R1)               and bump pointer\nJ0100    DS    0H\n\n         MVC   0(7,R1),=C',LRECL='      Move literal\n         LA    R1,7(0,R1)               Point to next byte\n         LH    R0,DCBLRECL-IHADCB(R15)  Get LRECL\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(5),=X'2020202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+4             A(Significant digit)\n         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+5             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\nJ0110    DS    0H\n         MVC   0(9,R1),=C',BLKSIZE='    Move literal\n         LA    R1,9(0,R1)               Point to next byte\n         LH    R0,DCBBLKSI-IHADCB(R15)  Get BLKSIZE\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(5),=X'2020202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+4             A(Significant digit)\n         EDMK  @J_Temp(5),@J_DBLWD+5    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+5             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\n\n         TM    DCBCIND2-IHADCB(R15),DCBCNQSM  QSAM?\n         BZ    J0120                    No, skip\n\n         TM    DCBCIND1-IHADCB(R15),DCBCBNDF  Yes, BUFNO default?\n         BO    J0130                    Yes, skip\n         MVC   0(7,R1),=C',BUFNO='      No, move literal\n         LA    R1,7(0,R1)               Point to next byte\n         SLR   R0,R0                    Clear work register\n         IC    R0,DCBBUFNO-IHADCB(R15)  Get BUFNO\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(3),=X'202120' Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+2             A(Significant digit)\n         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+3             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\n         B     J0130                    and skip\n\nJ0120    DS    0H\n         MVC   0(5,R1),=C',NCP='        No, move literal\n         LA    R1,5(0,R1)               Point to next byte\n         SLR   R0,R0                    Clear work register\n         IC    R0,DCBNCP-IHADCB(R15)    Get NCP\n         CVD   R0,@J_DBLWD              Pack it\n         MVC   @J_Temp(3),=X'202120'    Move mask\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+2             A(Significant digit)\n         EDMK  @J_Temp(3),@J_DBLWD+6    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+3             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n         LR    R1,R2                    A(Next byte)\nJ0130    DS    0H\n\n         MVI   0(R1),C')'               Close off DCB info\n\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\n         B     J0170                    and skip\n\nJ0140    DS    0H\n\n         SLR   R0,R0                  Clear work register\n         ST    R0,@J_BUFND            Clear data space\n         ST    R0,@J_BUFSP            and buffer space\n         LR    R2,R15                 A(ACB)\n         LA    R3,@J_BUFND            A(Receiving area)\n         SHOWCB ACB=(2),              Get data from this ACB           +\n               FIELDS=(BUFND,BUFSP),    this data                      +\n               AREA=(3),                moved to here                  +\n               LENGTH=8,                for this long                  +\n               MF=(G,@J_SHOWCB,J_SHOWCB_Length)\n\n         L     R0,@J_BUFND            Get Data space\n         A     R0,@J_BUFSP            and buffer space\n         LTR   R0,R0                  anything to say?\n         BZ    J0170                  No, skip\n\n         L     R1,@_SYSPRINT_Rec_Ptr    Yes, get A(SYSPRINT Record)\n         MVC   10(7,R1),=C'AMP=BUF'     Move literal\n         ICM   R0,B'1111',@J_BUFSP      Get buffer space\n         BZ    J0150                    None, skip\n         MVC   17(2,R1),=C'SP'          Yes, make it BUFSP\n         B     J0160\nJ0150    DS    0H\n         MVC   17(2,R1),=C'ND'          Make it BUFND\n         L     R0,@J_BUFND              and load up the register\nJ0160    DS    0H\n         MVI   19(R1),C'='              Move literal\n         LA    R1,20(0,R1)              Point to next char\n         CVD   R0,@J_DBLWD              Pack our value\n         MVC   @J_Temp(9),=X'202020202020202120'\n         LR    R2,R1                    Save A(Output Byte)\n         LA    R1,@J_Temp+8             A(Significant digit)\n         EDMK  @J_Temp(9),@J_DBLWD+3    Edit it\n         LR    R0,R1                    A(Start digit)\n         LA    R1,@J_Temp+9             Calculate\n         SR    R1,R0                     length\n         LR    R3,R1                    Destination length\n         MVCL  R2,R0                    Move it\n\n         L     R15,=AL4(G0010)          A(SYSPRINT routine)\n         BASR  R14,R15                  Go print it\n\nJ0170    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If this is the input file (SYSUT1) ...                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@J_TIOT_Entry_Ptr    A(TIOT entry)\n         CLC   =CL8'SYSUT1',TIOEDDNM-TIOENTRY(R15)  Input file?\n         BNE   J9010                    No, all done\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... display some info about input processing                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n         TM    @_SYSUT1_VSAM,L'@_SYSUT1_VSAM Is this VSAM?\n         BO    J0200                  Yes, skip VBS stuff\n         L     R15,@J_DCB_Ptr         A(DCB)\n         TM    DCBRECFM-IHADCB(R15),DCBRECV+DCBRECSB VS or VBS?\n         BNO   J0200                  No, skip\n         L     R2,@_SYSPRINT_Rec_Ptr  Yes, A(Print record)\n         MVC   10(31,R2),=C'Variable Spanned segments will '\n         LA    R2,41(0,R2)            Point to next byte\n         TM    @_SYSUT1_BSAM,L'@_SYSUT1_BSAM Is this BSAM?\n         BNO   J0180                  No, skip\n         TM    @_SYSUT1_NoVBSChk,L'@_SYSUT1_NoVBSChk Yes, checking VBS?\n         BNO   J0190                  Yes, skip\nJ0180    DS    0H\n         MVC   0(4,R2),=C'not '       No VBS checking\n         LA    R2,4(0,R2)             bump output pointer\nJ0190    DS    0H\n         MVC   0(27,R2),=C'be checked for consistency.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT THE LINE\nJ0200    DS    0H\n         L     R2,@_SYSPRINT_Rec_Ptr  A(Print record)\n         MVC   10(11,R2),=C'Input data '\n         TM    @_SYSUT1_Sequence,L'@_SYSUT1_Sequence Input in sequence?\n         BNO   J0210                  No, skip\n         MVC   21(14,R2),=C'assumed to be '\n         LA    R2,35(0,R2)            bump output pointer\n         B     J0220                  and skip\nJ0210    DS    0H\n         MVC   21(16,R2),=C'not necessarily '\n         LA    R2,37(0,R2)            bump output pointer\nJ0220    DS    0H\n         MVC   0(12,R2),=C'in sequence.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT THE LINE\n\nJ9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@J_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Clear return code\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n         LTORG\n\n\n@J_Dynam        DSECT                 Dynamic area for J\n@J_Save         DS    18F              O/S Style save area\n@J_DBLWD        DS    D                Work area\n@J_Temp         DS    CL10             Work area\n@J_DCB_Ptr      DS    AL4              A(DCB)\n@J_TIOT_Entry_Ptr DS  AL4              A(TIOT Entry for this DCB)\n@J_JFCB_Ptr     DS    AL4              A(JFCB)\n\n@J_Macro        DS    0F               Macro area\n@J_SHOWCB       DS    CL(J_SHOWCB_Length) SHOWCB Macro\n                DS    0F\n@J_BUFND        DS    FL4              BUFND from ACB\n@J_BUFSP        DS    FL4              BUFSP from ACB\n                ORG\n                DS    0D               Alignment\n@J_DynLen       EQU   *-@J_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'K0000 - Date/Time Conversion Routine'\nK0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : K0010                                                  *\n*                                                                     *\n*  Abstract  : Populate DateConv_Area Dates and Times                 *\n*                                                                     *\n*  Inputs    : R1 ----> DateConv Area                                 *\n*  Outputs   : R15 = 0, DateConv_Area contains converted              *\n*                       Date/Time values.                             *\n*              R15 = 4, DateConv_Area unchanged                       *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING K0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@K_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@K_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @K_Dynam,R13             Assign a base\n         L     R15,@K_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         ST    R1,@K_DateConv_Area_Ptr  Save A(Callers DateConv_Area)\n         MVC   @K_DateConv_Area,0(R1)   Copy callers DateConv_Area\n         LA    R9,@K_DateConv_Area      Point to our DateConv_Area\n         USING DateConv_Area,R9         Tell the assembler\n\n         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Normal Date?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?\n         BO    K0020                    Yes, skip\n         TM    DConv_Input_Julian,L'DConv_Input_Julian Julian Date?\n         BZ    K0180                    No, check time\n\nK0020    DS    0H\n         TM    DConv_Input_Base,L'DConv_Input_Base  Base Date?\n         BO    K0110                    Yes, skip\n\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate SMF?\n         BNO   K0030                    No, skip\n         ZAP   @K_DBLWD,=P'1900000'     Yes, set\n         AP    @K_DBLWD,DConv_Date_SMFDate  up Y2K Date\n         L     R15,@K_DBLWD+4           Save it\n         XC    @K_DBLWD+4(2),@K_DBLWD+4 Clear out year\n         CVB   R0,@K_DBLWD              Binarize Day-of-year\n         STH   R0,DConv_Date_DDD        Save it\n         SRL   R15,12                   Get rid of ddd\n         ST    R15,@K_DBLWD+4           Save it\n         OI    @K_DBLWD+7,X'0F'         Set up sign\n         CVB   R0,@K_DBLWD              Binarize Year\n         STH   R0,DConv_Date_YYYY       and save it too\nK0030    DS    0H\n\n         LH    R15,DConv_Date_YYYY      No, get Year\n         LTR   R15,R15                  Is it 0\n         BNP   K8010                    Yes, error\n\n         TM    DConv_Input_YYMMDD,L'DConv_Input_YYMMDD Std num date?\n         BZ    K0040                    No, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Standard Date (yyyymmdd): dd, mm must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         BAS   R14,K6000       Go validate dd, mm\n         LTR   R15,R15         OK?\n         BNZ   K8010           No, error\n         STH   R0,DConv_Date_DDD Yes, save day-of-year\n         B     K0100           and go calculate BDate\n\nK0040    DS    0H\n         TM    DConv_Input_YYMonDD,L'DConv_Input_YYMonDD Std num date?\n         BZ    K0070                    No, skip\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Normal Date (yyyymondd): dd, mon must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         OC    DConv_Date_Month,=CL(L'DConv_Date_Month)' ' Upper-case\n         LA    R15,K_MONTHS    A(Month-name table)\n         LA    R14,1           Set month number\nK0050    DS    0H\n         MVC   @K_DBLWD(3),2(R15) Move month name from table\n         OC    @K_DBLWD(3),=C'   ' Uppercase it\n         CLC   @K_DBLWD(3),DConv_Date_Month Is this us?\n         BE    K0060           Yes, skip\n         LA    R15,11(0,R15)   No, bump to next month\n         LA    R14,1           Bump month number\n         CH    R14,=H'12'      Too far?\n         BNH   K0050           No, try again\n         B     K8010           Unknown month, error\nK0060    DS    0H\n         STC   R14,DConv_Date_MM  Save month number\n         BAL   R14,K6000       Go validate dd, mm, and yy\n         LTR   R15,R15         OK?\n         BNZ   K8010           No, error\n         STH   R0,DConv_Date_DDD Yes, save day-of-year\n         B     K0100           and go calculate BDate\n\nK0070    DS    0H\n         TM    DConv_Input_Julian,L'DConv_Input_Julian  JDate?\n         BO    K0080                    Yes, do it\n         TM    DConv_Input_SMFDate,L'DConv_Input_SMFDate No, SMF\n         BZ    K0180                    No, skip\nK0080    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Julian Date (yyyyddd): yyyy, ddd must be consistent               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R2,DConv_Date_DDD Get Day of year\n         LTR   R2,R2           Is it 0\n         BNP   K8010           Yes, error\n\n         LA    R2,365          Days in a normal year\n         BAS   R14,K7000       Go check leap year\n         LTR   R15,R15         Is it a leap year?\n         BZ    K0090           No, skip\n         LA    R2,1(0,R2)      Yes, bump max days\nK0090    DS    0H\n         CH    R2,DConv_Date_DDD Day-of-year too big?\n         BL    K8010           Yes, error\n\nK0100    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate Base Date using the Julian Date in DConv_Date_YYYY and  *\n*    DConv_Date_DDD                                                   *\n*   In REXX terms,                                                    *\n*      YYYY = YYYY - 1             /*  Based on Year 0001          */ *\n*      BDate = (YYYY * 365) +,     /*  Days per year        plus   */ *\n*              (YYYY % 4)   -,     /*  Leap days            minus  */ *\n*              (YYYY % 100) +,     /*  non-Leap Centuries   plus   */ *\n*              (YYYY % 400) +,     /*  Leap centuries       plus   */ *\n*              DDD          -,     /*  Days in year         minus  */ *\n*              1                   /*  1 to get complete days      */ *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R2,DConv_Date_YYYY Get year\n         SH    R2,=H'1'         relative to year 0001\n         LR    R15,R2          Year *\n         MH    R15,=H'365'            365\n         LR    R0,R15          Initialize accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'4'              4\n         AR    R0,R15          Bump accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'100'            100\n         SR    R0,R15          Reduce accumulator\n         LR    R15,R2          Year\n         SLR   R14,R14              %\n         D     R14,=F'400'            400\n         AR    R0,R15          Bump accumulator\n         AH    R0,DConv_Date_DDD  Add days in current year\n         SH    R0,=H'1'        Complete days\n         ST    R0,DConv_Date_Base  Initialize Base Date\n         B     K0110           And skip\nK0110    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate various bits from the base date:                        *\n*     DConv_Date_YYYY                                                 *\n*     DConv_Date_DDD                                                  *\n*     DConv_Date_MM                                                   *\n*     DConv_Date_DD                                                   *\n*                                                                     *\n*   First, calculate the Year, and Day-of-year ...                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         L     R15,DConv_Date_Base Get the base date\n         SLR   R14,R14         set up for divide\n         D     R14,=F'365'     Do it\n         STH   R15,DConv_Date_YYYY Save Year\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ... and adjust the Day-of-year for leap years                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         LR    R0,R14          Get day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'4'          leap-days\n         SR    R0,R15          Reduce day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'100'        centuries\n         AR    R0,R15          Bump day-of-year\n         LH    R15,DConv_Date_YYYY Get number\n         SLR   R14,R14          of\n         D     R14,=F'400'        leap centuries\n         SR    R0,R15          Reduce day-of-year\n         A     R0,=FL4'1'      Bump for incomplete day\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Day-of-year is almost certainly negative at this point, so we     *\n*   will adjust it (and year) until it is greater than 1.             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nK0120    DS    0H\n         C     R0,=FL4'1'      Is Day-of-year OK?\n         BNL   K0140           Yes, skip\n         A     R0,=F'365'      No, bump a year's worth\n         BAS   R14,K7000       Check for leap year\n         LTR   R15,R15         Is this a leap year?\n         BZ    K0130           No, skip\n         A     R0,=FL4'1'      Yes, bump Day-of-year\nK0130    DS    0H\n         LH    R15,DConv_Date_YYYY Get Year\n         S     R15,=FL4'1'     Reduce it\n         STH   R15,DConv_Date_YYYY and save it\n         B     K0120           Keep checking\nK0140    DS    0H\n         STH   R0,DConv_Date_DDD Save adjusted Day-of-year\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Adjust Year, since it it relative to 0001                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         LH    R15,DConv_Date_YYYY Get Year\n         A     R15,=FL4'1'     Bump it\n         STH   R15,DConv_Date_YYYY and save it\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Create the SMFDate from YYYY and DDD                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R0,DConv_Date_YYYY  Get YYYY\n         CVD   R0,@K_DBLWD         Pack it\n         L     R0,@K_DBLWD+4       Get packed year\n         SRL   R0,4                Get rid of sign\n         STH   R0,DConv_Date_SMFDate Move YYYY\n         LH    R0,DConv_Date_DDD   Get DDD\n         CVD   R0,@K_DBLWD         Pack it\n         MVC   DConv_Date_SMFDate+2(2),@K_DBLWD+6 Move DDD\n         SP    DConv_Date_SMFDate,=P'1900000' Convert to SMF Date\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Copy the Days-per-month table, and adjust the number of days in   *\n*  February, if this a leap year.                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         MVC   @K_Months,K_Months Copy the table\n         BAS   R14,K7000       Check for leap year\n         LTR   R15,R15         Is this a leap year?\n         BZ    K0150           No, skip\n         LH    R15,@K_Months+11 Yes, get days in Feb\n         LA    R15,1(0,R15)    Bump it\n         STH   R15,@K_Months+11 Save it\nK0150    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Calculate the month number, and the day-of-month                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R0,DConv_Date_DDD Get day-of-year\n         LA    R14,1           January\n         LA    R15,@K_Months   A(Days-per-month table)\nK0160    DS    0H\n         CH    R0,0(0,R15)     Is this our month\n         BNH   K0170           Yes, skip\n         SH    R0,0(0,R15)     No, reduce days\n         LA    R14,1(0,R14)    Bump month number\n         LA    R15,11(0,R15)   Bump month pointer\n         B     K0160           and keep going\nK0170    DS    0H\n         STC   R0,DConv_Date_DD Save Day-of-month\n         STC   R14,DConv_Date_MM and month number\n         MVC   DConv_Date_Month,2(R15)  Move month name\n\n         L     R1,DConv_Date_Base Get base date\n         SLR   R0,R0           Clear for divide\n         D     R0,=F'7'        Get weekday (0=Mon, 1=Tue ...)\n         STC   R0,DConv_Date_DOW Save it\n         LR    R15,R0          Put in R15\n         SLL   R15,3           Weekday num * 8\n         AR    R15,R0          Weekday num * 9\n         LA    R15,K_DAYS(R15) Point to weekday name\n         MVC   DConv_Date_Day,0(R15)  Move weekday name\nK0180    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Do Time conversions                                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         TM    DConv_Input_Time,L'DConv_Input_Time  To hh,mm,ss?\n         BNO   K0190           No, skip\n\n         L     R15,DConv_Time  Yes, get secs*100 since midnight\n         C     R15,=FL4'8640000' Is it too big?\n         BH    K8010           Yes, error\n         SLR   R14,R14         Set up for divide\n         D     R14,=FL4'360000' Get hours\n         STC   R15,DConv_Time_hh Save it\n         SRDL  R14,32          Set up for divide\n         D     R14,=FL4'6000'  Get minutes\n         STC   R15,DConv_Time_mm Save them\n         SRDL  R14,32          Set up for divide\n         D     R14,=FL4'100'   Get seconds\n         STC   R15,DConv_Time_ss Save them\n         STC   R14,DConv_Time_tt Save hundredths\n         B     K0200           and exit\n\nK0190    DS    0H\n         TM    DConv_Input_hhmmss,L'DConv_Input_hhmmss  To secs*100?\n         BNO   K0200           No, skip\n\n         SLR   R0,R0           Clear accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_hh Get hours\n         L     R14,=FL4'360000' multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_mm Get minutes\n         L     R14,=FL4'6000'  multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_ss Get seconds\n         L     R14,=FL4'100' multiplier for secs*100\n         MR    R14,R14         Convert it\n         AR    R0,R15          Add to accumulator\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Time_tt Get hundredths of seconds\n         AR    R0,R15          Add to accumulator\n         C     R0,=FL4'8640000' Is it too big?\n         BH    K8010           Yes, error\n         ST    R0,DConv_Time   Save it\n\nK0200    DS    0H\n\n         L     R15,@K_DateConv_Area_Ptr  A(Callers DateConv_Area)\n         MVC   0(DConv_Area_Length,R15),@K_DateConv_Area Copy ours\n         SLR   R15,R15         Clear return code\n         B     K9010           and exit\n\nK6000    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Validate DConv_Date_MM, DConv_Date_DD                             *\n*   If valid, day-of-year is returned in R0                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         ST    R14,@K_K6Save   Save return address\n         ST    R1,@K_K6Save+4  and R1\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Date_MM  Get month\n         LTR   R15,R15         Is it 0?\n         BZ    K6040           Yes, invalid\n         CH    R15,=H'12'      No, is it too big?\n         BH    K6040           Yes, invalid\n         MVC   @K_Months,K_Months Move Days-per-month table\n         BAS   R14,K7000       Check leap year\n         LTR   R15,R15         Is it?\n         BZ    K6010           No, skip\n         LH    R15,@K_Months+11 Yes, get February days\n         AH    R15,=H'1'       Bump it\n         STH   R15,@K_Months+11 and save it\nK6010    DS    0H\n         SLR   R15,R15         Clear work register\n         IC    R15,DConv_Date_MM Get month number\n         MH    R15,=HL2'11'    Calculate offset\n         LA    R15,@K_Months-11(R15) Point to days in our month\n         SLR   R0,R0           Clear work register\n         IC    R0,DConv_Date_DD Get day-of-month\n         LTR   R0,R0           Is it 0?\n         BZ    K6040           Yes, error\n         CH    R0,0(R15)       Are Days too big?\n         BH    K6040           Yes, error\n         LA    R14,@K_Months   A(Our Days-per-month table)\nK6020    DS    0H\n         CR    R14,R15         Are we done?\n         BNL   K6030           Yes, skip\n         AH    R0,0(R14)       No, bump total days\n         LA    R14,11(0,R14)   point to next month\n         B     K6020           and try again\nK6030    DS    0H\n         SLR   R15,R15         Clear return code\n         B     K6050           and exit\nK6040    DS    0H\n         LA    R15,4           Error in date\n         SLR   R0,R0           Clear day-of-year\n         B     K6050\nK6050    DS    0H\n         L     R14,@K_K6Save   Restore return address\n         L     R1,@K_K6Save+4  Restore R1\n         BSM   0,R14           and return\n\n\nK7000    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Purpose   : This routine will determine if the year passed as a    *\n*              parm is a leap year                                    *\n*                                                                     *\n*  Input     : DConv_Date_YYYY                                        *\n*                                                                     *\n*  Output    : R15 = 0: Non-Leap Year                                 *\n*                    4: Leap Year                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         STM   R0,R1,@K_K7Save    Save our registers\n         LH    R1,DConv_Date_YYYY Get the Year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it is not divisible by 4, it is not a leap year                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'4'      Divide by 4\n         LTR   R0,R0           Any remainder?\n         BNZ   K7020           Yes, not a leap year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it also not divisible by 100, it is a leap year                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R1,DConv_Date_YYYY Get year\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'100'    Divide by 100\n         LTR   R0,R0           Any remainder?\n         BNZ   K7030           Yes, a leap year\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   If it also divisible by 400, it is a leap year                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LH    R1,DConv_Date_YYYY Get year\n         SLR   R0,R0           Clear for divide\n         D     R0,=FL4'400'    Divide by 400\n         LTR   R0,R0           Any remainder?\n         BNZ   K7020           Yes, not a leap year\n         B     K7030           Must be a leap year\nK7020    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Not a leap year, clear the return code                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         SLR   R15,R15         Clear return code\n         B     K7090           and exit\nK7030    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   A leap year, set the return code                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     K7090           and exit\nK7090    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Exit (R15 contains the return code)                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LM    R0,R1,@K_K7Save Restore our registers\n         BSM   0,R14           and return\nK8010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DConv fields contain invalid data, exit with error                *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         LA    R15,4           Set return code\n         B     K9010           and exit\n\nK9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@K_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\nK_Months DC    HL2'31',C'January  '\n         DC    HL2'28',C'February '\n         DC    HL2'31',C'March    '\n         DC    HL2'30',C'April    '\n         DC    HL2'31',C'May      '\n         DC    HL2'30',C'June     '\n         DC    HL2'31',C'July     '\n         DC    HL2'31',C'August   '\n         DC    HL2'30',C'September'\n         DC    HL2'31',C'October  '\n         DC    HL2'30',C'November '\n         DC    HL2'31',C'December '\nK_Months_Length EQU  *-K_Months\n\nK_Days   DC    C'Monday   '\n         DC    C'Tuesday  '\n         DC    C'Wednesday'\n         DC    C'Thursday '\n         DC    C'Friday   '\n         DC    C'Saturday '\n         DC    C'Sunday   '\n\n         LTORG\n\n@K_Dynam        DSECT                 Dynamic area for K\n@K_Save         DS    18F              O/S Style save area\n@K_DateConv_Area_Ptr DS AL4            A(Callers DateConv_Area)\n@K_DBLWD        DS    D                Work area\n@K_DateConv_Area DS   CL(DConv_Area_Length)     Our area\n@K_K6Save       DS    2AL4             K6000 save area\n@K_K7Save       DS    2AL4             K7000 save area\n@K_Months DS   CL(K_Months_Length) Month table\n                DS    0D               Alignment\n@K_DynLen       EQU   *-@K_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'L0000 - List Selection Ctiteria'\nL0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : L0010                                                  *\n*                                                                     *\n*  Abstract  : List selection criteria                                *\n*                                                                     *\n*  Inputs    : R1 ----> ODT entry                                     *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New. This used to be part of B0010, *\n*                                 but we ran out of base register.    *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING L0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@L_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@L_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @L_Dynam,R13             Assign a base\n         L     R15,@L_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         LR    R10,R1                   Point to the ODT Entry\n         USING ODT_Entry,R10            and tell the assembler\n\n* - - - - - - - - - - -  D A T E / T I M E     - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         CP    ODTE_StartDate,=P'0'   ANY START DATE SPECIFIED?\n         BNE   L0020                  YES, SKIP\n         CP    ODTE_EndDate,=P'999999' NO, ANY END DATE?\n         BNE   L0020                  YES, SKIP\n         MVC   10(L'L_Sum3,R2),L_Sum3 MOVE NO DATE/TIME MESSAGE\n         B     L0070                  AND SKIP\nL0020    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum2A,R2),L_Sum2A MOVE FIRST PART OF MESSAGE\n         CP    ODTE_StartDate,=P'0'  ANY START DATE?\n         BNE   L0030                 YES, SKIP\n         MVC   10+L'L_Sum2A(20,R2),=C' the start of SYSUT1'\n         LA    R2,10+L'L_Sum2A+20(0,R2) BUMP POINTER\n         B     L0040                 AND SKIP\nL0030    DS    0H\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_StartDate move in Date\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_StartTime                 Time too\n         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_*\n               Input_Time           Indicate SMF Time\n         LA    R15,@L_DateConv_Area     Point to Date Conversion area\n         ST    R15,@L_Parms          Save as 1st parm\n         LA    R15,10+L'L_Sum2A+1(0,R2) A(Output area)\n         ST    R15,@L_Parms+4        Save as 2nd parm\n         LA    R15,@L_Return_Ptr     A(Return area)\n         ST    R15,@L_Parms+8        Save it\n         LA    R1,@L_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\nL0040    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10+L'L_Sum2A-L'L_Sum2B(L'L_Sum2B,R2),L_Sum2B Next part\n         LA    R2,10+L'L_Sum2A+1(0,R2) Point past it\n         CP    ODTE_EndDate,=P'999999' ANY END DATE?\n         BNE   L0050                 YES, SKIP\n         MVC   0(19,R2),=C' the end of SYSUT1'\n         LA    R2,19(0,R2)           BUMP POINTER\n         B     L0060                 AND SKIP\nL0050    DS    0H\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         ZAP   @L_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),ODTE_EndDate move in Date\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_EndTime                 Time too\n         OI    @L_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@L_DateConv_Area     Point to Date Conversion area\n         ST    R15,@L_Parms          Save as 1st parm\n         LA    R15,0(0,R2)           A(Output area)\n         ST    R15,@L_Parms+4        Save as 2nd parm\n         LA    R15,@L_Return_Ptr     A(Return area)\n         ST    R15,@L_Parms+8        Save it\n         LA    R1,@L_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n         L     R2,@L_Return_Ptr      Point past\n         LA    R2,1(0,R2)              Date/Time\nL0060    DS    0H\n         MVC   0(L'L_Sum2C,R2),L_Sum2C MOVE LAST PART OF MESSAGE\nL0070    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -   P E R I O D            - - - - - - - - - - -*\n\n         ICM   R15,B'1111',ODTE_PeriodStart PERIOD START TIME\n         BNZ   L0080                  OK, PRINT PERIOD MESSAGE\n         L     R15,ODTE_PeriodEnd     NO, GET PERIOD END\n         C     R15,=F'8640000'        IS THERE ONE?\n         BE    L0090                  NO, SKIP\nL0080    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10(20,R2),=C'Only records between'\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_PeriodStart             Time too\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R1,@L_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Time\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  30(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   30(R2),C' '           Clear spurious char\n         OI    32(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  33(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   33(R2),C':'           Clear spurious char\n         OI    35(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  36(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   36(R2),C':'           Clear spurious char\n         OI    38(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  39(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   39(R2),C'.'           Clear spurious char\n         OI    41(R2),X'F0'          Make it readable\n\n         MVC   42(4,R2),=C' and'\n\n         XC    @L_DateConv_Area,@L_DateConv_Area Clear Date area\n         MVC   @L_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               ODTE_PeriodEnd               Time too\n         OI    @L_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R1,@L_DateConv_Area   Point to Date Conversion area\n         L     R15,=AL4(K0010)       A(Format routine)\n         BASR  R14,R15               Go get Time\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_hh-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  46(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   46(R2),C' '           Clear spurious char\n         OI    48(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_mm-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  49(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   49(R2),C':'           Clear spurious char\n         OI    51(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_ss-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  52(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   52(R2),C':'           Clear spurious char\n         OI    54(R2),X'F0'          Make it readable\n         SLR   R0,R0                 Clear work register\n         IC    R0,@L_DateConv_Area+DConv_Time_tt-DateConv_Area\n         CVD   R0,@L_DBLWD           Pack it\n         UNPK  55(3,R2),@L_DBLWD+6(2) Unpack it\n         MVI   55(R2),C'.'           Clear spurious char\n         OI    57(R2),X'F0'          Make it readable\n         MVC   58(18,R2),=C' will be eligible.'\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\nL0090    DS    0H\n\n* - - - - - - - - - - W E E K E N D S  - - - - - - - - - - - - - - -*\n\n         TM    ODTE_Ignore_Weekend,L'ODTE_Ignore_Weekend No Sat or Sun?\n         BNO   L0100                  No, OK\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD\n         MVC   10(77,R2),=C'SMF Data generated on Saturday and Sunday w+\n               ill not be eligible for selection.'\n\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\nL0100    DS    0H\n\n* - - - - - - - - - - R E C O R D   T Y P E S  - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD\n         ICM   R3,B'1111',ODTE_RTT_Ptr  A(RECORD TYPE TABLE)\n         BNZ   L0110                  OK, SKIP\n         MVC   10(L'L_Sum5,R2),L_Sum5 NO, MOVE NO RECORD TYPE MSG\n         B     L0180                  AND SKIP\nL0110    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum4A,R2),L_Sum4A Move 1st part of message\n         LH    R4,RTT_Entry_Count-RecType_Tbl(R3) Get nbr entries\n         CH    R4,=H'1'               More than 1?\n         BNH   L0120                  No, skip\n         MVI   10+L'L_Sum4A(R2),C's'  Yes, make msg plural\n         LA    R2,1(0,R2)             and bump SYSPRINT pointer\nL0120    DS    0H\n         LA    R2,10+L'L_Sum4A+1(0,R2) A(NEXT AVAILABLE BYTE)\n         LR    R15,R2                 Calculate offset\n         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record\n         STH   R15,@L_SYSPRINT_Rec_Offset  and save it\n         LA    R3,RTT_Entry-RecType_Tbl(R3) A(FIRST ENTRY IN TABLE)\nL0130    DS    0H\n         LA    R15,9(0,R2)            A(last byte we might write)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0140                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0140    DS    0H\n         SLR   R0,R0                  CLEAR WORK REGISTER\n         IC    R0,RTTE_RecType-RTT_Entry(R3) GET RECORD TYPE\n         CVD   R0,@L_DBLWD            PACK IT\n         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK\n         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)\n         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT\n         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)\n         SR    R15,R1                 R3 = EXEC LEN OF EDITED RECTYPE\n         EX    R15,L_MVC              MOVE IT\n         LA    R2,1(R15,R2)           A(NEXT BYTE)\n         TM    RTTE_SubType_Present-RTT_Entry(R3),L'RTTE_SubType_Presen+\n               t                      Any subtype?\n         BNO   L0150                  No, skip subtype stuff\n         LH    R0,RTTE_SubType-RTT_Entry(R3) YES, GET SUBTYPE\n         CVD   R0,@L_DBLWD            PACK IT\n         MVC   @L_DBLWD(4),=X'40202120' MOVE MASK\n         LA    R1,@L_DBLWD+3          A(LAST POSSIBLE POSITION)\n         EDMK  @L_DBLWD(4),@L_DBLWD+6 EDIT IT\n         LA    R15,@L_DBLWD+3         A(LAST POSSIBLE POSITION)\n         SR    R15,R1                 R15 = EXEC LEN OF SUBTYPE\n         MVI   0(R2),C'('             OPENING PAREN\n         LA    R2,1(0,R2)             POINT PAST IT\n         EX    R15,L_MVC              MOVE SUBTYPE\n         LA    R2,1(R15,R2)           POINT TO NEXT BYTE\n         MVI   0(R2),C')'             CLOSE PAREN\n         LA    R2,1(0,R2)             AND BUMP POINTER\nL0150    DS    0H\n         MVI   0(R2),C','             MOVE SEPARATOR\n         LA    R2,2(0,R2)             POINT PAST IT\n         LA    R3,RTTE_Length(0,R3)   A(NEXT ENTRY\n         BCT   R4,L0130               and do it\n\n         SH    R2,=H'2'               BACK UP TO LAST COMMA\n         MVI   0(R2),C' '             CLEAR IT\n         LA    R15,1+L'L_Sum4B+2+L'L_Sum4C(0,R2) A(last byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0160                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0160    DS    0H\n         MVC   1(L'L_Sum4B,R2),L_Sum4B MOVE NEXT PART OF MSG\n         LA    R2,1+L'L_Sum4B(0,R2)   POINT PAST IT\n         L     R15,ODTE_RTT_Ptr       A(RECORD TYPE TABLE)\n         TM    RTT_Entry_Exclude-RecType_TBL(R15),L'RTT_Entry_Exclude\n         BZ    L0170                  INCLUDEing, skip\n         MVC   0(2,R2),=C'in'         EXCLUDEing, IN of INELIGIBLE\n         LA    R2,2(0,R2)             AND POINT PAST IT\nL0170    DS    0H\n         MVC   0(L'L_Sum4C,R2),L_Sum4C MOVE LAST PART OF MESSAGE\nL0180    DS    0H\n\n         L     R15,=AL4(G0010)       A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -      J O B N A M E S     - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(NEW PRINT RECORD)\n         ICM   R3,B'1111',ODTE_JNT_Ptr A(JOBNAME TABLE)\n         BNZ   L0190                  OK, SKIP\n         MVC   10(L'L_Sum6,R2),L_Sum6 NO, SAY SO\n         B     L0270                  AND SKIP\nL0190    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum7A,R2),L_Sum7A MOVE FIRST PART OF MESSAGE\n         LH    R4,JNT_Entry_Count-JobName_Tbl(R3) GET NBR JOBNAMES\n         CH    R4,=H'1'               MORE THAN 1?\n         BNH   L0200                  NO, SKIP\n         MVI   10+L'L_Sum7A(R2),C's'  YES, MAKE IT PLURAL\n         LA    R2,1(0,R2)             BUMP IT\nL0200    DS    0H\n         LA    R2,10+L'L_Sum7A+1(0,R2) A(NEXT AVAILABLE BYTE)\n         LR    R15,R2                 Calculate offset\n         S     R15,@_SYSPRINT_Rec_Ptr   into SYSPRINT record\n         STH   R15,@L_SYSPRINT_Rec_Offset  and save it\n         LA    R3,JNT_Entry-JobName_Tbl(R3) A(FIRST JOBNAME\nL0210    DS    0H\n         LA    R15,L'JNTE_JobName+2(0,R2) A(Last possible byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0220                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0220    DS    0H\n         MVC   0(L'JNTE_JobName,R2),JNTE_JobName-JNT_Entry(R3)\n         CLI   JNTE_JobName_Len-JNT_Entry(R3),L'JNTE_JobName-1 PREFIX?\n         BE    L0230                  NO, SKIP\n         SLR   R0,R0                  YES, CLEAR WORK REG\n         IC    R0,JNTE_JobName_Len-JNT_Entry(R3) GET PREFIX EXEC LEN\n         AR    R2,R0                  BUMP OUTPUT POINTER\n         MVI   1(R2),C'*'             ADD IN THE ASTERISK\n         LA    R2,1(0,R2)             INCREMENT POINTER\n         B     L0250                  AND SKIP\nL0230    DS    0H\n         LA    R2,L'JNTE_JobName-1(0,R2) BUMP POINTER\nL0240    DS    0H\n         CLI   0(R2),C' '             END OF JOBNAME?\n         BNE   L0250                  YES, SKIP\n         BCT   R2,L0240               NO, KEEP CHECKING\nL0250    DS    0H\n         MVI   1(R2),C','             ADD A COMMA\n         LA    R2,3(0,R2)             A(NEXT JOBNAME AREA)\n         LA    R3,JNTE_Length(0,R3)   A(NEXT JOBNAME)\n         BCT   R4,L0210               AND KEEP GOING\n\n         SH    R2,=H'2'               BACK UP OVER LAST COMMA\n         LA    R15,L'L_Sum7B(0,R2)    A(Last possible byte)\n         S     R15,@_SYSPRINT_Rec_Ptr Length of data we might write\n         CH    R15,@_SYSPRINT_Rec_Len Too long?\n         BL    L0260                  No, OK\n         L     R15,=AL4(G0010)        Yes, A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  Get A(New SYSPRINT Record)\n         AH    R2,@L_SYSPRINT_Rec_Offset and point to appropriate byte\nL0260    DS    0H\n         MVC   0(L'L_Sum7B,R2),L_Sum7B MOVE REST OF MESSAGE\nL0270    DS    0H\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A SYSPRINT RECORD\n\n* - - - - - - - - - -          D A T A         - - - - - - - - - - -*\n\n         L     R2,@_SYSPRINT_Rec_Ptr  A(SYSPRINT RECORD)\n         ICM   R15,B'1111',ODTE_DT_Ptr A(DATA TABLE)\n         BNZ   L0280                  OK, SKIP\n         MVC   10(L'L_Sum8,R2),L_Sum8 NO, SAY SO\n         B     L0300                  AND SKIP\nL0280    DS    0H\n         NI    ODTE_CopyOnly,X'FF'-L'ODTE_CopyOnly Selection criteria\n         MVC   10(L'L_Sum9A,R2),L_Sum9A MOVE FIRST PART OF MESSAGE\n         LA    R2,L'L_Sum9A+10(0,R2) POINT PAST IT\n         LH    R14,DT_Entry_Count-Data_Tbl(R15) GET NBR ENTRIES\n         LA    R15,DT_Entry-Data_Tbl(R15) A(FIRST ENTRY)\nL0290    DS    0H\n         LR    R0,R14                 SAVE BCT COUNT\n         SLR   R14,R14                CLEAR REG\n         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA\n         LA    R1,DTE_Data-DT_Entry(0,R15) A(DATA)\n         EX    R14,L_MVC              MOVE IT\n         LA    R2,1(R14,R2)           A(NEXT BYTE)\n         MVC   0(L'L_Sum9B,R2),L_Sum9B MOVE NEXT PART OF MSG\n         LA    R2,L'L_Sum9B(0,R2)     POINT PAST IT\n         LH    R14,DTE_Offset-DT_Entry(R15) GET OFFSET\n         CVD   R14,@L_DBLWD           PACK IT\n         MVC   @L_Offset,=X'4020206B202120' MOVE MASK\n         LA    R1,@L_Offset+6         A(LAST POSSIBLE POSITION)\n         EDMK  @L_Offset,@L_DBLWD+5   EDIT IT\n         LA    R14,@L_Offset+6        A(LAST POSSIBLE POSITION)\n         SR    R14,R1                 R14 = EXEC LEN\n         EX    R14,L_MVC              MOVE IT\n         SLR   R14,R14                CLEAR REGISTER\n         IC    R14,DTE_Length-DT_Entry(R15) GET EXEC LEN OF DATA\n         LA    R1,1+DTE_Data-DT_Entry(R14,R15) A(NEXT ENTRY)\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R2,@_SYSPRINT_Rec_Ptr  A(PRINT RECORD)\n         MVC   28(2,R2),=C'or'        MOVE LITERAL\n         LA    R2,31(0,R2)            POINT TO FREE POSITION\n         LR    R14,R0                 RESTORE BCT REGISTER\n         LR    R15,R1                 RESTORE A(TABLE ENTRY)\n         BCT   R14,L0290              KEEP GOING\n         L     R2,@_SYSPRINT_Rec_Ptr  A(OUTPUT RECORD)\n         MVC   15(L'L_Sum9C,R2),L_Sum9C MOVE LAST PART\nL0300    DS    0H\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                YES, GET A NEW SYSPRINT REC\n\n* - - - - - - - - - -   S T O P A F T          - - - - - - - - - - -*\n\n         ICM   R15,B'1111',ODTE_StopAft GET STOPAFT COUNT\n         BZ    L0310                  None, SKIP\n         L     R2,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   10(58,R2),=C'A maximum of XX,XXX records will be selecte*\n               d to this file.'\n         MVC   22(7,R2),=X'4020206B202120' MOVE MASK\n         L     R15,ODTE_StopAft       GET STOPAFT\n         CVD   R15,@L_DBLWD           PACK IT\n         ED    22(7,R2),@L_DBLWD+5    AND EDIT IT\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO PRINT IT\nL0310    DS    0H\n\n         DROP  R10                    Free ODT Entry addressability\n\n         B     L9010                  and exit\n\nL9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@L_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nL_MVC MVC      0(0,R2),0(R1)          EXECUTED INSTRUCTION\n\n\nL_Sum2A  DC    C'Records between'\nL_Sum2B  DC    C' and'\nL_Sum2C  DC    C' will be eligible'\n\nL_Sum3   DC    C'No Date-Time criteria; all records will be eligible'\n\nL_Sum4A  DC    C'Record Type'\nL_Sum4B  DC    C'will be '\nL_Sum4C  DC    C'eligible'\n\nL_Sum5   DC    C'No Record Type criteria; all records will be eligible'\n\nL_Sum6   DC    C'No Jobname criteria; all records will be eligible'\n\nL_Sum7A  DC    C'Records for Jobname'\nL_Sum7B  DC    C' will be eligible'\n\nL_Sum8   DC    C'No Data criteria; all records will be eligible'\n\nL_Sum9A DC     C'Records must contain '\nL_Sum9B DC     C' in position '\nL_Sum9C DC     C' to be eligible'\n\n\n         LTORG\n\n@L_Dynam        DSECT                 Dynamic area for L\n@L_Save         DS    18F              O/S Style save area\n@L_DBLWD        DS    D                Work area\n@L_Parms        DS    3AL4             Parm area\n@L_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@L_SYSPRINT_Rec_Offset DS  HL2         Offset into SYSPRINT record\n@L_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n@L_Offset       DS    CL7              DATA= offset\n                DS    0D               Alignment\n@L_DynLen       EQU   *-@L_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'W0000 - Return JFCB pointer'\nW0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : W0010                                                  *\n*                                                                     *\n*  Abstract  : Return A(JFCB) as returned by SWAREQ                   *\n*                                                                     *\n*  Inputs    : R1 : A(DCB)                                            *\n*                                                                     *\n*  Outputs   : R1 : A(JFCB) or 0                                      *\n*              R0 : A(TIOT Entry) or 0                                *\n*              R15: 0:OK, 4: No JFCB                                  *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING W0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@W_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@W_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @W_Dynam,R13             Assign a base\n         L     R15,@W_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Find our TIOT entry ...                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,CVTPTR(0,0)          A(CVT)\n         L     R15,CVTTCBP-CVT(R15)     A(Current TCB pointer)\n         L     R15,0(0,R15)             A(Current TCB)\n         L     R15,TCBTIO-TCB(R15)      A(TIOT)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the DCB is OPEN, we can use DCBTIOT to find our entry ...   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN DCB OPen?\n         BNO   W0020                    No, skip\n\n         AH    R15,DCBTIOT-IHADCB(R1)   Offset in TIOT\n         B     W0040                    and skip\n\nW0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    The DCB is not OPEN, chain through the TIOT looking for our    *\n*   DDName                                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R15,TIOENTRY-TIOT1(R15)  A(1st entry in TIOT)\nW0030    DS    0H\n         CLI   TIOELNGH-TIOENTRY(R15),0 Last Entry?\n         BE    W8010                    Yes, DDName not found\n         CLC   TIOEDDNM-TIOENTRY(L'TIOEDDNM,R15),DCBDDNAM-IHADCB(R1)\n         BE    W0040                    Found our entry, skip\n\n         SLR   R0,R0                    Clear work reg\n         IC    R0,TIOELNGH-TIOENTRY(R15) Get entry length\n         AR    R15,R0                   Point to next entry\n         B     W0030                    and check it out\nW0040    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and then get the JFCB address from the SVA                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R15,@W_TIOT_Ptr          Save A(TIOT Entry)\n\n         XC    @W_SWAEPAX,@W_SWAEPAX    Clear SWAEPA\n         MVC   @W_SWAEPAX+SWVA-ZB505(L'SWVA),TIOEJFCB-TIOENTRY(R15)\n         LA    R15,@W_SWAEPAX           A(EPA)\n         ST    R15,@W_EPA_Ptr           Save the address\n\n         MVC   @W_SWAREQ,W_SWAREQ       Move L-Form of macro\n         SWAREQ FCODE=RL,               Read Locate                    +\n               EPA=@W_EPA_Ptr,           using the EPA at this addr    +\n               UNAUTH=YES,               not being authorized          +\n               MF=(E,@W_SWAREQ)          keep ourselves re-entrant\n\n         L     R1,@W_SWAEPAX+SWBLKPTR-ZB505 Get A(JFCB)\n         L     R0,@W_TIOT_Ptr           A(TIOT Entry)\n         SLR   R15,R15                  Clear return code\n         B     W9010                    and exit\n\nW8010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    TIOT entry not found                                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R1,R1                    Clear A(JFCB)\n         SLR   R0,R0                    Clear A(TIOT)\n         LA    R15,4                    Set return code\n         B     W9010                    and exit\n\n\nW9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LR    R3,R0                    Save A(TIOT)\n         LR    R4,R1                    Save A(JFCB)\n         LA    R1,@W_Dynam              A(Local storage)\n\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n         LR    R0,R3                    Restore A(TIOT)\n         LR    R1,R4                    Restore A(JFCB)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\nW_SWAREQ SWAREQ MF=L                    Read Locate\nW_SWAREQ_Length EQU *-W_SWAREQ          Length of SWAREQ Macro\n\n         LTORG\n\n@W_Dynam        DSECT                 Dynamic area for W\n@W_Save         DS    18F              O/S Style save area\n@W_EPA_Ptr      DS    AL4              A(EPA for SWAREQ)\n@W_TIOT_Ptr     DS    AL4              A(TIOT Entry for DDName)\n@W_SWAREQ       DS    CL(W_SWAREQ_Length)\n                DS    0F\n@W_SWAEPAX      DS    CL(L'SWAEPAX)\n\n                DS    0D               Alignment\n@W_DynLen       EQU   *-@W_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n\n         TITLE 'X0000 - Exit Invocation Routine'\nX0010    DS    0H\n\n         PUSH  USING\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : X0010                                                  *\n*                                                                     *\n*  Abstract  : Invoke user exits                                      *\n*                                                                     *\n*  Inputs    : R0 : 0:Inexit, 1:OutExit                               *\n*              R1 : A(SMF Record)                                     *\n*              R10: A(ODT Entry)                                      *\n*                                                                     *\n*  Outputs   : R1 : A(SMF Record as returned by exit)                 *\n*              R15: As received from the user exit                    *\n*                                                                     *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING X0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@X_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@X_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @X_Dynam,R13             Assign a base\n         L     R15,@X_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         USING ODT_Entry,R10            Assign ODTE base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If the SYSPRINT User Exit Interface (Y0010) has not been       *\n*   copied to 24-bit storage, do it now ...                         *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',@_SYSPRINT_Y0010_Ptr A(Interface routine)\n         BNZ   X0020                    Already moved, OK\n\n         STORAGE OBTAIN,                Go get our storage             +\n               LENGTH=Y_Code_End-Y0010,  this long                     +\n               LOC=BELOW                 below-the-line\n\n         ST    R1,@_SYSPRINT_Y0010_Ptr  Save the address\n         LR    R0,R1                    Point to it\n         LA    R1,Y_Code_End-Y0010      Length of code\n         L     R14,=AL4(Y0010)          Point to start of code\n         LR    R15,R1                   Same length\n         MVCL  R0,R14                   Move code to 24-bit storage\n\n         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)\n         ST    R12,Y_@_Dynam_Ptr-Y0010(R15) Update A(@_Dynam)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and IDENTIFY it as SMFSLCTP, in case the exit is written   *\n*   in a HLL.                                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R1,@_SYSPRINT_Y0010_Ptr Point to our routine\n         IDENTIFY EP=SMFSLCTP,         and let MVS know                +\n               ENTRY=(1)                about it\n\nX0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Update the pointer to the ODT in the Y0010 copy                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_Y0010_Ptr A(Moved code)\n         ST    R10,Y_@_ODT_Entry_Ptr-Y0010(R15) Update A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get some 24-bit storage, and build our parm list               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@X_24_DynLen,         this long                     +\n               STACK=@_24Bit_Stack_Ptr   using this stack\n\n         ST    R1,@X_ParmList_Ptr       Save it\n         USING @X_24_Dynam,R1           Assign a base\n\n         L     R15,@X_Dynam+4           Get A(HSA)\n         L     R0,24(0,R15)             A(SMF record) Original R1\n         ST    R0,@X_24_Exit_Parmlist   Save A(SMF Record)\n\n         ICM   R0,B'1111',20(R15)       Get Original R0\n         BNZ   X0030                    OutExit, skip\n\n         L     R0,ODTE_InExit_Data      Yes, A(Word for the user)\n         ST    R0,@X_24_Exit_Word       Save it\n         LA    R0,@X_24_Exit_Word       Point to it\n         ST    R0,@X_24_Exit_Parmlist+4 Save the pointer\n         L     R0,ODTE_InExit_Parm_Ptr  A(Parm for InExit)\n         ST    R0,@X_24_Exit_Parmlist+8 Save it\n         L     R15,ODTE_InExit_Ptr      A(InExit EP)\n         B     X0040                    Skip\n\nX0030    DS    0H\n\n         L     R0,ODTE_OutExit_Data     Yes, A(Word for the user)\n         ST    R0,@X_24_Exit_Word       Save it\n         LA    R0,@X_24_Exit_Word       Point to it\n         ST    R0,@X_24_Exit_Parmlist+4 Save it\n         L     R0,ODTE_OutExit_Parm_Ptr A(Parm for OutExit)\n         ST    R0,@X_24_Exit_Parmlist+8 Save it\n         L     R15,ODTE_OutExit_Ptr     A(OutExit EP)\n         B     X0040                    Skip\n\nX0040    DS    0H\n\n         L     R0,@_Input_Count         Input count\n         ST    R0,@X_24_Input_Count     Save it\n         LA    R0,@X_24_Input_Count     Point to it\n         ST    R0,@X_24_Exit_Parmlist+12 Save it\n\n         L     R0,ODTE_Selected         A(Selected count)\n         ST    R0,@X_24_Selected        Save it\n         LA    R0,@X_24_Selected        Point to it\n         ST    R0,@X_24_Exit_Parmlist+16 Save it\n         MVC   @X_24_DDName,ODTE_DDName Move DDName\n         LA    R0,@X_24_DDName          A(DDName)\n         ST    R0,@X_24_Exit_Parmlist+20 Save it\n         L     R0,@_SYSPRINT_Y0010_Ptr  A(SYSPRINT routine)\n         ST    R0,@X_24_Exit_Parmlist+24 Save it\n\n         OI    @X_24_Exit_Parmlist+24,X'80' Flag as last parm\n\n         LA    R14,@X_24_Save           Point to 24-bit savearea\n         ST    R14,8(0,R13)             Chain\n         ST    R13,4(0,R14)              saveareas\n         LR    R13,R14                  Point to 24-bit savearea\n\n         LA    R1,@X_24_Exit_Parmlist   Point to the parmlist\n         BASR  R14,R15                  Go do the exit\n\n         LR    R2,R15                   Save return code\n\n         L     R13,4(0,R13)             Restore A(Our 31-bit savearea)\n\n         L     R1,@X_ParmList_Ptr       Restore A(24-bit storage)\n         L     R15,@X_Dynam+4           Get A(HSA)\n         ICM   R0,B'1111',20(R15)       InExit?\n         BNZ   X0050                    No, skip\n         MVC   ODTE_InExit_Data,@X_24_Exit_Word Yes, save user stuff\n         B     X0060                    and skip\nX0050    DS    0H\n         MVC   ODTE_OutExit_Data,@X_24_Exit_Word Yes, save user stuff\nX0060    DS    0H\n\n         L     R1,@X_ParmList_Ptr       A(Parmlist)\n         L     R3,@X_24_Exit_Parmlist   Get A(SMF record)\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_24Bit_Stack_Ptr   on this stack\n\n         DROP  R1                       Free 24-bit storage base\n\n         LR    R15,R2                   Restore return code\n         B     X9010                    and exit\n\nX9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R2,R15                   Save return code\n         LA    R1,@X_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n         LR    R15,R2                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LR    R15,R2                   Set return code\n         L     R0,20(0,R13)             Restore R0\n         LR    R1,R3                    A(SMF record returned by exit)\n         LM    R2,R12,28(R13)           Restore other registers\n         BSM   0,R14                    and return\n\n\n\n         LTORG\n\n@X_Dynam        DSECT                 Dynamic area for X\n@X_Save         DS    18F              O/S Style save area\n@X_ParmList_Ptr DS    AL4              A(Parmlist)\n                DS    0D               Alignment\n@X_DynLen       EQU   *-@X_Dynam      Length of storage required\n\n@X_24_Dynam     DSECT                 24-bit Dynamic area for X\n@X_24_Save      DS    18F              O/S Style save area\n@X_24_Exit_Parmlist DS 7FL4            Parmlist\n@X_24_Exit_Word DS    FL4              A Word for the user\n@X_24_Input_Count DS  FL4              Input count\n@X_24_Selected  DS    FL4              Selected count\n@X_24_DDName    DS    CL8              DDName\n                DS    0D               Alignment\n@X_24_DynLen    EQU   *-@X_24_Dynam   Length of 24-bit storage required\n\n\n\nSMFSLCT  RSECT\n\n         DROP  R10\n         DROP  R11,R13\n         POP   USING\n         TITLE 'Y0000: SYSPRINT routine for User Exits'\n\n         PUSH  USING\n\nY0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : Y0010                                                  *\n*                                                                     *\n*  Abstract  : SYSPRINT routine for User Exits:                       *\n*               Load @_Dynam base                                     *\n*               Move user data to SYSPRINT record                     *\n*               Invoke G0010                                          *\n*                                                                     *\n*                                                                     *\n*  Inputs    : R1 --> A(Data to be printed)                           *\n*                     Fullword containing length of data              *\n*  Outputs   : R15 = 0                                                *\n*                                                                     *\n*  Notes     : This routine is moved to 24-bit storage, and the       *\n*              address of @_Dynam inserted into the copy.             *\n*              Before each invocation of the exit, the address of the *\n*              active ODT is also stored in Y_ODT_Entry_Ptr.          *\n*                                                                     *\n*                                                                     *\n*  History:                                                           *\n*              2002/02/07 SDDA030 V1.4                                *\n*                                 New                                 *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING Y0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Make sure we are in AMODE(31)                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R14,Y0020                A(Dummy label)\n         ICM   R14,B'1000',=XL1'80'     in 31-bit mode\n         BSM   0,R14                    Gen into 31-bit mode\nY0020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R12,Y_@_Dynam_Ptr        A(@_Dynam)\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@Y_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@Y_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Y_Dynam,R13             Assign a base\n         L     R15,@Y_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    If SYSPRINT is OPEN ...                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_DCB_Ptr A(SYSPRINT DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Is it open?\n         BZ    Y9010                  No, skip printing\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... load the address of the ODT we are using ...               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R10,Y_@_ODT_Entry_Ptr  A(ODT Entry)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... move the data to the SYSPRINT record ...                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,@_SYSPRINT_Rec_Ptr Get A(SYSPRINT record)\n         LH    R15,@_SYSPRINT_Rec_Len Get its length\n         LM    R0,R1,0(R1)            Get ptr, length of user data\n         ICM   R1,B'1000',=CL1' '     Pad character of blank\n         MVCL  R14,R0                 Move user data\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and print it                                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,=AL4(G0010)        A(Print routine)\n         BASR  R14,R15                Go do it\n\nY9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LA    R1,@Y_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller                                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         SLR   R15,R15                  Clear return code\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nY_@_Dynam_Ptr     DC AL4(0)           A(@_Dynam)\nY_@_ODT_Entry_Ptr DC AL4(0)           A(ODT Entry for User exit)\n\n         LTORG\n\nY_Code_End  EQU   *                   End of code to be moved\n\n@Y_Dynam        DSECT                 Dynamic area for Y\n@Y_Save         DS    18F              O/S Style save area\n                DS    0D               Alignment\n@Y_DynLen       EQU   *-@Y_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\nSMFSLCT  RSECT\n\n         TITLE 'Z0000: Termination'\n\n         PUSH  USING\n\nZ0010    DS    0H\n\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Routine   : Z0010                                                  *\n*                                                                     *\n*  Abstract  : Termination routine:                                   *\n*               Print counters                                        *\n*               Close DCBs                                            *\n*               Free Storage areas                                    *\n*                                                                     *\n*                                                                     *\n*  Inputs    : N/A                                                    *\n*  Outputs   : R15 = 0, at least 1 record selected to an output file  *\n*                    4, no records selected to any output file.       *\n*                                                                     *\n*  Notes     :                                                        *\n*                                                                     *\n*  History:                                                           *\n*              1999/04/24 SDDA030 V1.1                                *\n*                                 Used LIFO Stack for our dynamic     *\n*                                 areas.                              *\n*              ____/__/__ _______                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n\n\n         USING *,R15\n         SAVE  (14,12),T\n         LR    R11,R15                  Load permanent base reg\n         DROP  R15                      Free up temp base\n         USING Z0010,R11                Assign permanent base\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Get an area on the stack for our local storage                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         STACK PUSH,                    Get Stack area                 +\n               LEN=@Z_DynLen,            this long                     +\n               STACK=@_31Bit_Stack_Ptr   using this stack\n\n         LR    R2,R1                    Save its address\n         LR    R0,R1                    A(Our storage)\n         LA    R1,@Z_DynLen              Its length\n         SLR   R14,R14                  Clear source address\n         SLR   R15,R15                   and length\n         MVCL  R0,R14                   Clear our storage\n         LR    R1,R2                    Restore A(Our storage)\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Chain our save areas, and restore the important registers      *\n*   that we have destroyed                                          *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ST    R13,4(0,R1)              Chain\n         ST    R1,8(0,R13)               saveareas\n         LR    R13,R1                   Load dynam base\n         USING @Z_Dynam,R13             Assign a base\n         L     R15,@Z_Dynam+4           Get A(HSA)\n         LM    R0,R3,20(R15)            Restore callers registers\n\n         NI    @Z_Select_OK,X'FF'-L'@Z_Select_OK Nothing selected\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    PRINT THE RECORD COUNTERS, IF POSSIBLE.                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R15,@_SYSPRINT_DCB_Ptr A(Sysprint DCB)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS SYPRINT OPEN?\n         BZ    Z0060                  NO, SKIP PRINTING\n         LA    R15,99                 GET HIGH LINE COUNT\n         STH   R15,@_Line_Count       SAVE IT\n         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n\n         USING ODT_Entry,R10          Tell the assembler\n\n         OI    ODTE_Print_NO,L'ODTE_Print_NO SUPPRESS HEADINGS\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GO GET A NEW PAGE\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         ICM   R15,B'1111',@_Input_Count Nbr input records read\n         BZ    Z0050                  None, skip\n         CP    @_Dump_Start_Date,=P'999999' DID WE GET A TYPE 2?\n         BE    Z0040                  NO, SKIP\n         MVC   20(27,R2),=C'First Dump Header (Type 2):'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Dump_Start_Date    Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Dump_Start_Time              Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(27,R2),=C'Last Dump Trailer (Type 3):'\n         CP    @_Dump_End_Date,=P'0'  DID WE GET A TYPE 3?\n         BNE   Z0020                  YES, SKIP\n         MVI   51(R2),C'?'            NO, SAY SO\n         B     Z0030                  AND SKIP\nZ0020    DS    0H\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Dump_End_Date    Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Dump_End_Time              Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\nZ0030    DS    0H\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE RECORD\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\nZ0040    DS    0H\n         MVC   20(26,R2),=C'Date/Time of first record:'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_First_Rec_Date   Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_First_Rec_Time             Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Return area)\n         ST    R15,@Z_Parms+8        Save as 2nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R2,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(25,R2),=C'Date/Time of last record:'\n\n         XC    @Z_DateConv_Area,@Z_DateConv_Area Clear Date area\n         ZAP   @Z_DateConv_Area+DConv_Date_SMFDate-DateConv_Area(L'DCon+\n               v_Date_SMFDate),@_Input_Rec_Date   Date\n         MVC   @Z_DateConv_Area+DConv_Time-DateConv_Area(L'DConv_Time),+\n               @_Input_Rec_Time             Time too\n         OI    @Z_DateConv_Area+DConv_Input_SMFDate-DateConv_Area,L'DCo+\n               nv_Input_SMFDate     Indicate SMF Date\n         OI    @Z_DateConv_Area+DConv_Input_Time-DateConv_Area,L'DConv_+\n               Input_Time           Indicate SMF Time\n         LA    R15,@Z_DateConv_Area     Point to Date Conversion area\n         ST    R15,@Z_Parms          Save as 1st parm\n         LA    R15,51(0,R2)          A(Output area)\n         ST    R15,@Z_Parms+4        Save as 2nd parm\n         LA    R15,@Z_Return_Ptr     A(Output area)\n         ST    R15,@Z_Parms+8        Save as 3nd parm\n         LA    R1,@Z_Parms           A(Parm pointers)\n         L     R15,=AL4(F0010)       A(Format routine)\n         BASR  R14,R15               Go convert date and time\n\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                A COUPLE OF\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                  BLANK LINES\nZ0050    DS    0H\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT RECORD)\n         MVC   20(23,R1),=C'Number of records read:'\n         MVC   50(12,R1),=X'402020206B2020206B202120'\n         L     R15,@_Input_Count      GET INPUT COUNTER\n         CVD   R15,@Z_DBLWD           PACK IT\n         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                PRINT THE INPUT COUNT\n         TM    @_SYSUT1_Seg_Error,L'@_SYSUT1_Seg_Error Segment errors?\n         BZ    Z0060                  No, skip\n         L     R1,@_SYSPRINT_Rec_Ptr  Yes, A(SYSPRINT record)\n         MVC   17(39,R1),=C'** Segment errors discarded from SYSUT1'\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                Print warning message\nZ0060    DS    0H\n         L     R10,@_ODT_Ptr          POINT TO OUTPUT ENV TABLE\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) AND POINT TO FIRST\n         CH    R9,=H'1'               MORE THAN 1 ENTRY?\n         BNH   Z0070                  No, continue\n         ST    R10,@Z_Default_ODTE_Ptr Yes, save its address\n         B     Z0160                  and skip it until last\nZ0070    DS    0H\n         ICM   R15,B'1111',@_SYSPRINT_DCB_Ptr A(Sysprint DCB)\n         BZ    Z0090                  None, skip\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN Yes, is it open?\n         BNO   Z0090                  NO, SKIP\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                GET A NEW SYSPRINT RECORD\n         L     R1,@_SYSPRINT_Rec_Ptr  POINT TO IT\n         MVC   20(27,R1),=C'Number of          records:'\n         MVC   30(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME\n         MVC   50(12,R1),=X'402020206B2020206B202120'\n         ICM   R15,B'1111',ODTE_Selected Get selected counter\n         BZ    Z0080                  None, skip\n         OI    @Z_Select_OK,L'@Z_Select_OK Yes, set our flag\nZ0080    DS    0H\n         CVD   R15,@Z_DBLWD           PACK IT\n         ED    50(12,R1),@Z_DBLWD+3   AND EDIT IT\n         TM    ODTE_Trunc,L'ODTE_Trunc  ANY RECORDS TRUNCATED?\n         BZ    Z0090                  NO, SKIP\n         L     R15,=AL4(G0010)        A(SYSPRINT routine)\n         BASR  R14,R15                YES, SKIP A LINE\n         L     R1,@_SYSPRINT_Rec_Ptr  GET A(SYSPRINT)\n         MVC   10(73,R1),=C'*****  WARNING - At least 1 record truncate*\n               d on XXXXXXXX - WARNING  *****'\n         MVC   58(8,R1),ODTE_DDName   MOVE OUTPUT DDNAME\nZ0090    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LAST CALL TO INPUT EXIT, AND DELETE, IF PRESENT                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_InExit_Ptr A(INPUT EXIT\n         BZ    Z0100                 None, SKIP\n         SLR   R1,R1                 Yes, clear A(SMF record)\n         SLR   R0,R0                 Flag as an InExit\n         L     R15,=AL4(X0010)       A(Exit interface)\n         BASR  R14,R15               Go do it\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0095                 Yes, skip\n         CLC   ODTE_InExit,ODTE_InExit-ODT_Entry(R15) No, default exit?\n         BE    Z0100                 YES, DON'T DELETE IT\nZ0095    DS    0H\n         LA    R0,ODTE_InExit        A(EXIT NAME)\n         DELETE EPLOC=(0)            AND DELETE IT\n\n         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)\n         BZ    Z0100                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer\nZ0100    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    LAST CALL TO OUTPUT EXIT, AND DELETE, IF PRESENT               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R15,B'1111',ODTE_OutExit_Ptr  A(OUTPUT EXIT)\n         BZ    Z0110                 None, SKIP\n         SLR   R1,R1                 Yes, clear A(SMF record)\n         LA    R0,1                  Flag as an OutExit\n         L     R15,=AL4(X0010)       A(Exit interface)\n         BASR  R14,R15               Go do it\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0105                 Yes, skip\n         CLC   ODTE_OutExit,ODTE_OutExit-ODT_Entry(R15) No, default?\n         BE    Z0110                 YES, DON'T DELETE IT\nZ0105    DS    0H\n         LA    R0,ODTE_OutExit       A(EXIT NAME)\n         DELETE EPLOC=(0)            AND DELETE IT\n\n         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)\n         BZ    Z0110                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer\nZ0110    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE THE OUTPUT DCB, IF OPEN.                                 *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R2,B'1111',ODTE_DCB_Ptr A(Output DCB)\n         BZ    Z0130                  None, skip\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN Yes, is it open?\n         BZ    Z0120                  NO, BETTER NOT CLOSE IT\n         MVC   @Z_CLOSE,Z_CLOSE           YES, MOVE CLOSE PARMS\n         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT\nZ0120    DS    0H\n         LA    R0,B_SYSUT2_DCB_Length Length of DCB\n         LR    R1,R2                  A(DCB storage)\n         STORAGE RELEASE,             Get storage                      +\n               LENGTH=(0),             for the DCB                     +\n               ADDR=(1)                which is here\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_DCB_Ptr       No more DCB\nZ0130    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP RECORD TYPE TABLE, IF IT EXISTS.                       *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_RTT_Ptr A(RECORD TYPE TABLE)\n         BZ    Z0140                  None, BETTER NOT FREE IT\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0135                 Yes, skip\n         CLC   ODTE_RTT_Ptr,ODTE_RTT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0140                 YES, DON'T DELETE IT\nZ0135    DS    0H\n         L     R0,0(0,R1)             NO, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0140    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP JOBNAME TABLE, IF IT EXISTS.                           *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_JNT_Ptr A(JOBN TABLE)\n         BZ    Z0150                  None, BETTER NOT FREE IT\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0145                 Yes, skip\n         CLC   ODTE_JNT_Ptr,ODTE_JNT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0150                 YES, DON'T DELETE IT\nZ0145    DS    0H\n         L     R0,0(0,R1)             YES, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0150    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    FREE UP DATA TABLE, IF PRESENT.                                *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',ODTE_DT_Ptr A(DATA TABLE\n         BZ    Z0160                 None SKIP\n         L     R15,@Z_Default_ODTE_Ptr A(Default entry)\n         CR    R10,R15               Are we doing default?\n         BE    Z0155                 Yes, skip\n         CLC   ODTE_DT_Ptr,ODTE_DT_Ptr-ODT_Entry(R15) No, default?\n         BE    Z0160                 YES, DON'T DELETE IT\nZ0155    DS    0H\n         L     R0,0(0,R1)            YES, GET SUBPOOL AND LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\nZ0160    DS    0H\n         AL    R10,=AL4(ODTE_Length)  A(NEXT ENTRY)\n         BCT   R9,Z0070               GO DO IT TOO\n         L     R10,@_ODT_Ptr          A(ENVIRONMENT TABLE)\n         LH    R9,ODT_Entry_Count-OutDesc_Tbl(R10) GET NBR ENTRIES\n         CH    R9,=H'1'               MORE THAN 1 ENTRY?\n         BNH   Z0190                  NO, SKIP\n         LA    R10,ODT_Entry-OutDesc_Tbl(R10) YES, POINT TO DEFAULT\n         ICM   R15,B'0010',ODTE_InExit_Ptr GET A(INEXIT)\n         BZ    Z0170                  None, SKIP\n         LA    R0,ODTE_InExit         YES, POINT TO IT'S NAME\n         DELETE EPLOC=(0)             AND DELETE IT\n         XC    ODTE_InExit_Ptr,ODTE_InExit_Ptr CLEAR EXIT ADDRESS\n\n         ICM   R1,B'1111',ODTE_InExit_Parm_Ptr Get A(Parm)\n         BZ    Z0170                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_InExit_Parm_Ptr and clear parm pointer\nZ0170    DS    0H\n         ICM   R15,B'1111',ODTE_OutExit_Ptr GET A(OUTEXIT)\n         BZ    Z0180                  None, SKIP\n         LA    R0,ODTE_OutExit        YES, POINT TO IT'S NAME\n         DELETE EPLOC=(0)             AND DELETE IT\n         XC    ODTE_OutExit_Ptr,ODTE_OutExit_Ptr CLEAR EXIT ADDRESS\n\n         ICM   R1,B'1111',ODTE_OutExit_Parm_Ptr Get A(Parm)\n         BZ    Z0180                  None, skip\n         LH    R0,0(0,R1)             Yes, get its length\n         A     R0,=AL4(L'@HH_ParmLen) and bump for the length field\n         STORAGE RELEASE,             Free the storage                 +\n               ADDR=(1),               starting here                   +\n               LENGTH=(0)              for this long\n\n         SLR   R15,R15                Clear work register\n         ST    R15,ODTE_OutExit_Parm_Ptr and clear parm pointer\nZ0180    DS    0H\n         L     R15,@_ODT_Ptr          A(OUR TABLE)\n         LA    R9,1                   DO A SINGLE ENTRY\n         STH   R9,ODT_Entry_Count-OutDesc_Tbl(R15) PRETEND ONLY 1 ENTRY\n         B     Z0090                  AND FREE UP DEFAULT TABLES\nZ0190    DS    0H\n\n         DROP  R10\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Print the counters by record type                              *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    CLOSE SYSPRINT, IF REQUIRED.                                   *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R2,B'1111',@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         BZ    Z0270                  None, skip\n         TM    DCBOFLGS-IHADCB(R2),DCBOFOPN SYSPRINT OPEN?\n         BZ    Z0260                  NO, BETTER NOT CLOSE IT\n         MVC   @Z_CLOSE,Z_CLOSE       YES, MOVE CLOSE PARMS\n         CLOSE ((2)),MODE=31,MF=(E,@Z_CLOSE)    AND CLOSE IT\nZ0260    DS    0H\n         L     R1,@_SYSPRINT_DCB_Ptr  A(SYSPRINT DCB)\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(R1),                starting here                 +\n               LENGTH=G_SYSPRINT_DCB_Length this long\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_DCB_Ptr   No more DCB\n\n         ICM   R1,B'1111',@_SYSPRINT_Y0010_Ptr\n         BZ    Z0270\n         STORAGE RELEASE,               Free the storage               +\n               ADDR=(R1),                starting here                 +\n               LENGTH=Y_Code_End-Y0010   this long\n\n         SLR   R15,R15                  Clear work register\n         ST    R15,@_SYSPRINT_Y0010_Ptr No more print interface\n\n         DELETE EP=SMFSLCTP             Un-IDENTIFY it\n\nZ0270    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free the Output Descriptor Table                               *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         ICM   R1,B'1111',@_ODT_Ptr   A(ENVIRONMENT TABLE)\n         BZ    Z0280                  None, dont free it\n         L     R0,ODT_Subp_Len-OutDesc_Tbl(R1) GET SUBPOOL, LENGTH\n         STORAGE RELEASE,               Free our storage               +\n               ADDR=(1),                 starting here                 +\n               LENGTH=(0)                for this long\n         SLR   R15,R15                Clear work register\n         ST    R15,@_ODT_Ptr          No more ODT\nZ0280    DS    0H\n         B     Z9010                  and exit\nZ9010    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Set the return code, if anything has been selected or not      *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         SLR   R15,R15                  Assume all is OK\n         TM    @Z_Select_OK,L'@Z_Select_OK Anything selected?\n         BO    Z9020                    Yes, OK\n         LA    R15,4                    No, set return code\nZ9020    DS    0H\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    Free up our local storage ...                                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         LR    R3,R15                   Save return code\n         LA    R1,@Z_Dynam              A(Local storage)\n         L     R13,4(0,R13)             Rescue A(HSA)\n\n         STACK POP,                     Free the stack area            +\n               ADDR=(R1),                starting here                 +\n               STACK=@_31Bit_Stack_Ptr   on this stack\n         LR    R15,R3                   Restore return code\n\n*-------------------------------------------------------------------*\n*                                                                   *\n*    ... and return to caller (return code in R15)                  *\n*                                                                   *\n*-------------------------------------------------------------------*\n\n         L     R14,12(0,R13)            Restore return address\n         LM    R0,R12,20(R13)           Restore other registers\n         BSM   0,R14                    and return\n\nZ_CLOSE    CLOSE (0),MODE=31,MF=L\nZ_CLOSE_Length EQU   *-Z_CLOSE\n         LTORG\n\n@Z_Dynam        DSECT                 Dynamic area for Z\n@Z_Save         DS    18F              O/S Style save area\n@Z_DBLWD        DS    D                Work area\n@Z_Default_ODTE_Ptr DS AL4             A(Defalt ODT Entry)\n@Z_Parms        DS    3AL4             Parms for F0010\n@Z_Return_Ptr   DS    AL4              A(Last byte formatted by F0010)\n@Z_InExit_Parm  DS    2AL4             Parms for InExit\n@Z_OutExit_Parm DS    2AL4             Parm list for OutExit\n                DS    X                Flag Byte\n@Z_Select_OK    EQU   *-1,X'80'         1... .... At least 1 rec sel\n@Z_Macros       DS    0F               Macro area\n@Z_Close        DS    CL(Z_CLOSE_Length)  Close macro\n                ORG   @Z_Macros\n@Z_DateConv_Area DS   CL(DConv_Area_Length)  Date conversion area\n                ORG\n                DS    0D               Alignment\n@Z_DynLen       EQU   *-@Z_Dynam      Length of storage required\n\nSMFSLCT  RSECT\n\n         DROP  R11,R13\n         POP   USING\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT523/FILE523.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT523", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}