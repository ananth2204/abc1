{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012125000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2645370, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE469.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE469.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00*\\x06'", "DS1TRBAL": "b'i\\xfc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03n\\x00\\n\\x03q\\x00\\x07\\x00+'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"BREAKSET": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS;\n /*\n   TITLE      -   BRKPADD\n\n   FUNCTION   -   THIS PROGRAM FILLS THE BREAKPOINTS SPECIFICATION TABLE\n                  WITH GROUPS OF SERVICES THAT ARE AVAILABLE IN THE\n                  RELEASE OF ISPF THAT IS CURRENTLY RUNNING.  EACH\n                  COLUMN OF THE TABLE CAN BE INITIALIZED TO A CONSTANT\n                  VALUE YOU ENTER.\n\n                  NOTE THAT WHEN CONTROL RETURNS TO THE BREAKPOINTS\n                  PANEL, THE NEW ROWS WILL NOT APPEAR UNTIL YOU ENTER\n                  A SCROLL COMMAND.\n\n                  THIS PROGRAM HAS WORKED UNTIL NOW BUT THE AUTHOR MAKES\n                  NO PROMISES ABOUT FUTURE RUNS.\n\n   SPECIFIER  -   CHRIS GERKEN\n                  EXXON COMPANY, USA (EDPC)\n\n   DEVELOPER  -   CHRIS GERKEN\n\n   DATE       -   FEBRUARY 28, 1986\n\n   LANGUAGE   -   PLI\n\n   PANVALET   -\n\n   ENTRY      -   PLISTART\n\n   LINKAGE    -   THIS PROGRAM IS SELECTED VIA COMMAND TABLE FROM THE\n                  BREAKPOINTS SPECIFICATION PANEL.  A CLIST CAN ALSO\n                  INVOKE THIS PROGRAM.  DO NOT TRY IT ANYWHERE ELSE.\n\n   EXT. REF.  -   ISPLINK\n\n   DATA SETS  -   NONE\n\n   SPF TABLES -   ISRYBT1-ISRYBT4, DEPENDING ON SCREEN NUMBER\n\n   SPF PANELS -   BRKPE010\n\n   SPF MSGS   -   NONE\n\n   UPDATES    -   NONE\n\n */\n1BRK: PROC(ZPARM) OPTIONS(MAIN);\n0   DCL ZPARM         CHAR(100) VAR;\n0   DCL ISPLINK       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        PLIRETV       BUILTIN,\n        RETCODE       FIXED BIN(31),\n        LVAR          FIXED BIN(31);\n0   DCL #_OF_SERVICES FIXED BIN(31)  INIT(64);\n0   DCL POOL(64,3)    CHAR(8)  INIT('DISPLAY ','DISPLAY ','        ',\n                                    'TBDISPL ','DISPLAY ','        ',\n                                    'SETMSG  ','DISPLAY ','        ',\n                                    'TBDISPL ','TABLE   ','        ',\n                                    'TBCREATE','TABLE   ','        ',\n                                    'TBOPEN  ','TABLE   ','        ',\n                                    'TBSORT  ','TABLE   ','ISPF 2.1',\n                                    'TBQUERY ','TABLE   ','        ',\n                                    'TBSTATS ','TABLE   ','ISPF 2.1',\n                                    'TBSAVE  ','TABLE   ','        ',\n                                    'TBCLOSE ','TABLE   ','        ',\n                                    'TBEND   ','TABLE   ','        ',\n                                    'TBERASE ','TABLE   ','        ',\n                                    'TBADD   ','TABLE   ','        ',\n                                    'TBDELETE','TABLE   ','        ',\n                                    'TBGET   ','TABLE   ','        ',\n                                    'TBPUT   ','TABLE   ','        ',\n                                    'TBMOD   ','TABLE   ','        ',\n                                    'TBEXIST ','TABLE   ','        ',\n                                    'TBSCAN  ','TABLE   ','        ',\n                                    'TBSARG  ','TABLE   ','        ',\n                                    'TBTOP   ','TABLE   ','        ',\n                                    'TBBOTTOM','TABLE   ','        ',\n                                    'TBSKIP  ','TABLE   ','        ',\n                                    'TBVCLEAR','TABLE   ','        ',\n                                    'FTOPEN  ','FILET   ','        ',\n                                    'FTINCL  ','FILET   ','        ',\n                                    'FTCLOSE ','FILET   ','        ',\n                                    'FTERASE ','FILET   ','        ',\n                                    'VGET    ','VARIABLE','        ',\n                                    'VPUT    ','VARIABLE','        ',\n                                    'VDEFINE ','VARIABLE','        ',\n                                    'VDELETE ','VARIABLE','        ',\n                                    'VCOPY   ','VARIABLE','        ',\n                                    'VREPLACE','VARIABLE','        ',\n                                    'VRESET  ','VARIABLE','        ',\n                                    'SELECT  ','OTHER   ','        ',\n                                    'CONTROL ','OTHER   ','        ',\n                                    'LOG     ','OTHER   ','        ',\n                                    'GRERROR ','OTHER   ','ISPF 2.1',\n                                    'GRINIT  ','OTHER   ','ISPF 2.1',\n                                    'GRTERM  ','OTHER   ','ISPF 2.1',\n                                    'GETMSG  ','OTHER   ','ISPF 2.1',\n                                    'PQUERY  ','OTHER   ','ISPF 2.1',\n                                    'LIBDEF  ','OTHER   ','ISPF 2.2',\n                                    'LMINIT  ','LIBRARY ','ISPF 2.1',\n                                    'LMQUERY ','LIBRARY ','ISPF 2.1',\n                                    'LMFREE  ','LIBRARY ','ISPF 2.1',\n                                    'BROWSE  ','LIBRARY ','        ',\n                                    'EDIT    ','LIBRARY ','        ',\n                                    'EDREC   ','LIBRARY ','ISPF 2.1',\n                                    'LMOPEN  ','LIBRARY ','ISPF 2.1',\n                                    'LMCLOSE ','LIBRARY ','ISPF 2.1',\n                                    'LMGET   ','LIBRARY ','ISPF 2.1',\n                                    'LMPUT   ','LIBRARY ','ISPF 2.1',\n                                    'LMMLIST ','LIBRARY ','ISPF 2.1',\n                                    'LMMFIND ','LIBRARY ','ISPF 2.1',\n                                    'LMMADD  ','LIBRARY ','ISPF 2.1',\n                                    'LMMDEL  ','LIBRARY ','ISPF 2.1',\n                                    'LMMREN  ','LIBRARY ','ISPF 2.1',\n                                    'LMMREP  ','LIBRARY ','ISPF 2.1',\n                                    'LMERASE ','LIBRARY ','ISPF 2.1',\n                                    'LMRENAME','LIBRARY ','ISPF 2.1',\n                                    'LMPROM  ','LIBRARY ','ISPF 2.1');\n0   DCL SUBSTR        BUILTIN,\n        TRANSLATE     BUILTIN,\n        DSP           CHAR(3),\n        TBL           CHAR(3),\n        FLT           CHAR(3),\n        VAR           CHAR(3),\n        OTH           CHAR(3),\n        LIB           CHAR(3),\n        KEY           CHAR(8),\n        TABLE         CHAR(8),\n        ENVIR         CHAR(8),\n        BUF_13        CHAR(13),\n        BUF_20        CHAR(20),\n        SCREEN        FIXED BIN(31),\n        (I,J,K)       FIXED BIN(31),\n        WRITE         BIT(1),\n        PIC_1         PIC'9';\n1   LVAR = 4;\n    CALL ISPLINK('VDEFINE ','(ZSCREEN)', SCREEN ,'FIXED', LVAR);\n    LVAR = 20;\n    CALL ISPLINK('VCOPY   ','(ZENVIR) ', LVAR , BUF_20 ,'MOVE');\n    RETCODE = PLIRETV;\n    IF RETCODE = 0\n       THEN ENVIR = SUBSTR(BUF_20,1,8);\n       ELSE ENVIR = 'ISPF 1.1';\n0   /* WHAT TABLE ARE WE DEALING WITH HERE?                           */\n0   CALL ISPLINK('VGET    ','(ZSCREEN)','SHARED  ');\n    RETCODE = PLIRETV;\n    IF RETCODE > 0\n       THEN DO;\n            LVAR = 13;\n            BUF_13 = 'PGM(ISPSCRN#)';\n            CALL ISPLINK('SELECT  ', LVAR , BUF_13);\n            SCREEN = PLIRETV;\n            END;\n       ELSE;\n    PIC_1 = SCREEN;\n    TABLE = 'ISRYBT' || PIC_1 || ' ';\n1   CALL ISPLINK('CONTROL ','ERRORS  ','RETURN');\n0   CALL ISPLINK('TBTOP   ', TABLE);\n    RETCODE = PLIRETV;\n    IF RETCODE = 0\n       THEN DO;\n            CALL ISPLINK('TBVCLEAR', TABLE);\n            CALL ISPLINK('DISPLAY ','BRKPE010');\n            RETCODE = PLIRETV;\n            END;\n       ELSE;\n    IF RETCODE = 0\n       THEN DO;\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(DSP)', LVAR , DSP ,'MOVE');\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(TBL)', LVAR , TBL ,'MOVE');\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(FLT)', LVAR , FLT ,'MOVE');\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(VAR)', LVAR , VAR ,'MOVE');\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(OTH)', LVAR , OTH ,'MOVE');\n0           LVAR = 3;\n            CALL ISPLINK('VCOPY   ','(LIB)', LVAR , LIB ,'MOVE');\n0           DO I = 1 TO #_OF_SERVICES;\n               SELECT(POOL(I,2));\n                 WHEN('DISPLAY ') WRITE = (DSP = 'YES');\n                 WHEN('TABLE   ') WRITE = (TBL = 'YES');\n                 WHEN('FILET   ') WRITE = (FLT = 'YES');\n                 WHEN('VARIABLE') WRITE = (VAR = 'YES');\n                 WHEN('OTHER   ') WRITE = (OTH = 'YES');\n                 WHEN('LIBRARY ') WRITE = (LIB = 'YES');\n                 OTHERWISE        WRITE = '0'B;\n                 END;\n               WRITE = WRITE & (POOL(I,3) <= ENVIR);\n               IF WRITE\n                  THEN DO;\n0                      LVAR = 8;\n                       CALL ISPLINK('VREPLACE','(ISRYBVS)', LVAR ,\n                                                POOL(I,1));\n                       CALL ISPLINK('TBADD   ', TABLE);\n                       END;\n                  ELSE;\n               END;\n            CALL ISPLINK('TBTOP   ', TABLE);\n            END;\n       ELSE;\n0END BRK;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMD0TABL": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CMD0TABL TITLE ' VIEW LIST OF CURRENT SYSTEM COMMANDS'\nCMD0TABL CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         SPACE\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'CMD0TABL'              CSECT NAME\n         DC    C'09/03/85 '             DATE WRITTEN\n         DC    C'VERSION 3.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING CMD0TABL,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         LA    14,COPY\n         LA    15,COPYLEN\n         LA    0,PROT\n         LA    1,PROTLEN\n         MVCL  14,0\n         MVC   PANELID,=CL8'CMDB'\n         SPACE 3\n         ISPF  LOAD,ISPEXEC=(YES,ISPEXEC)\n         SPACE\n         MVC   COMMENT(160),SPACES\n         VDEFINE '(PANELID)',PANELID,CHAR,8,MF=E\n         SPACE\n         VDEFINE '(UMSG1)',UMSG1,CHAR,24,MF=E\n         SPACE\n         VDEFINE '(LMSG1)',LMSG1,CHAR,78,MF=E\n         SPACE\n         VDEFINE '(TYPE)',TYPE,CHAR,2,MF=E\n         SPACE\n         VDEFINE '(COMMENT COMMEN2)',COMMENT,CHAR,80,MF=E\n         SPACE\n         VDEFINE '(ZCMD)',ZCMD,CHAR,48,MF=E\n         SPACE\n         VDEFINE '(TBNAME PANEL MSG CSR AUTOSEL CTVERB)',              *\n               TBNAME,CHAR,8,MF=E\n         SPACE\n         VDEFINE '(ROW ZTDTOP THECSR)',ROW,FIXED,4,MF=E\n         SPACE\n         VDEFINE '(LSEL)',LSEL,CHAR,1,MF=E\n         SPACE\n         ISPEXEC ,'LMINIT DATAID(TBNAME) DDNAME(ISPPROF)'\n         SPACE\n         ISPEXEC ,'LMFREE DATAID(&&TBNAME)'\n         SPACE\n         ISPEXEC ,'TBCREATE &&TBNAME NOWRITE KEYS(ZCTVERB) NAMES(ZCTACT*\n                ZCTDESC TYPE) REPLACE'\n         SPACE\n         ISPEXEC ,'TBSORT &&TBNAME FIELDS(ZCTVERB)'\n         SPACE\n         ISPEXEC ,'TBSTATS &&ZAPPLID.CMDS STATUS2(TYPE)'\n         SPACE\n         CLI   TYPE,C'1'\n         BE    ISP\n         SPACE\n         MVC   TYPE,=CL2' *'\n         MVC   COMMENT(4),=CL4'$ *\u00a2'\n         MVC   COMMEN2(4),=CL4'$**\u00a2'\n         ISPEXEC ,'TBQUERY &&ZAPPLID.CMDS POSITION(CRP)'\n         SPACE\n         ISPEXEC ,'TBTOP &&ZAPPLID.CMDS'\n         SPACE\nLOOPAPPL DS    0H\n         ISPEXEC ,'TBSKIP &&ZAPPLID.CMDS'\n         SPACE\n         LTR   15,15\n         BNZ   RESAPPL\n         ISPEXEC ,'TBADD &&TBNAME ORDER'\n         SPACE\n         B     LOOPAPPL\nRESAPPL  DS    0H\n         ISPEXEC ,'TBSKIP &&ZAPPLID.CMDS NUMBER(&&CRP)'\n         SPACE 3\nISP      DS    0H\n         MVC   TYPE,SPACES\n         ISPEXEC ,'TBQUERY ISPCMDS POSITION(CRP)'\n         SPACE\n         ISPEXEC ,'TBTOP ISPCMDS'\n         SPACE\nLOOPISP  DS    0H\n         ISPEXEC ,'TBSKIP ISPCMDS'\n         SPACE\n         LTR   15,15\n         BNZ   RESISP\n         ISPEXEC ,'TBADD &&TBNAME ORDER'\n         SPACE\n         LTR   15,15\n         BZ    LOOPISP\n         TBGET TBNAME,MF=E\n         SPACE\n         MVC   TYPE,=CL2'**'\n         ISPEXEC ,'TBPUT &&TBNAME ORDER'\n         SPACE\n         MVC   TYPE,SPACES\n         B     LOOPISP\n         SPACE 3\nRESISP   DS    0H\n         ISPEXEC ,'TBSKIP ISPCMDS NUMBER(&&CRP)'\n         EJECT\n         MVC   ZTDTOP,=F'1'\n         MVC   ROW,=F'0'\n         MVC   PANEL(32),SPACES\n         MVC   PANEL,PANELID\nLOOP     TBTOP TBNAME,MF=E\n         SPACE\n         TBSKIP TBNAME,NUMBER=ZTDTOP,MF=E\n         SPACE\n         TBDISPL TBNAME,PANEL=PANEL,                                   *\n               MSG=MSG,                                                *\n               CURSOR=CSR,                                             *\n               CSRROW=ROW,                                             *\n               AUTOSEL=AUTOSEL,MF=E\n         SPACE\n         LR    10,15\n         MVC   ROW,=F'0'\n         MVC   PANEL(32),SPACES\n         MVC   PANEL,PANELID\n         C     10,=F'4'\n         BH    EXITPGM\n         CLC   ZCMD,SPACES\n         BE    NOERR\n         MVC   MSG,=CL8'ISPZ001'\n         MVC   PANEL,SPACES\n         B     LOOP\nNOERR    DS    0H\n         TBQUERY TBNAME,POSITION='THECSR',MF=E\n         SPACE\n         CLC   THECSR,=F'0'\n         BE    ENDLOOP\n         SPACE\n         CLI   LSEL,C'S'\n         BNE   ENDLOOP\n         SPACE\n         CONTROL DISPLAY,SAVE\n         SPACE\n         OPEN  (ISPPLIB,INPUT),MF=(E,OPENLIST)\n         SPACE\n         MVC   BLDLFF,=Y(1)\n         MVC   BLDLLL,=Y(12)\n         MVC   BLDLNAME,CTVERB\n         BLDL  ISPPLIB,BLDLAREA\n         SPACE\n         C     15,=F'0'\n         BNE   NOTFOUND\n         SELECT ,'PGM(ISPTUTOR) PARM(&&CTVERB)'\n         SPACE\n         MVC   CSR,=CL8'LSEL'\n         MVC   ROW,THECSR\n         MVC   AUTOSEL,=CL8'NO'\n         SPACE\nENDBLDL  DS    0H\n         CLOSE (ISPPLIB),MF=(E,OPENLIST)\n         SPACE\n         CONTROL DISPLAY,RESTORE\n         SPACE\nENDLOOP  DS    0H\n         C     10,=F'4'\n         BNE   LOOP\n         MVC   PANEL,=CL8' '\n         B     LOOP\n         SPACE\nNOTFOUND DS    0H\n         MVC   MSG,=CL8'DTSM001'\n         MVC   CSR,=CL8'LSEL'\n         MVC   PANEL,SPACES\n         MVC   ROW,THECSR\n         CLOSE (ISPPLIB),MF=(E,OPENLIST)\n         SPACE\n         CONTROL DISPLAY,RESTORE\n         SPACE\n         B     LOOP\n         SPACE 3\nEXITPGM  DS    0H\n         TBEND TBNAME,MF=E\n         SPACE\n         VRESET ,\n         ISPF  DELETE,ISPEXEC=YES\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         SR    15,15                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         EJECT\nSPACES   DC    CL160' '\nUMSG1    DC    CL24'HELP NOT AVAILABLE'\nLMSG1    DC    CL78'THERE IS NOT HELP STORED FOR THIS COMMAND'\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         ISPF  PARMS,ISPEXEC=YES\n         SPACE\nTYPE     DS    CL2\nCOMMENT  DS    CL80\nCOMMEN2  DS    CL80\nZCMD     DS    CL48\nTBNAME   DS    CL8\nPANEL    DS    CL8\nMSG      DS    CL8\nCSR      DS    CL8\nAUTOSEL  DS    CL8\nCTVERB   DS    CL8\nLSEL     DS    CL1\nROW      DS    F\nZTDTOP   DS    F\nTHECSR   DS    F\nBLDLAREA DS    0D\nBLDLFF   DS    Y\nBLDLLL   DS    Y\nBLDLNAME DS    CL8\nBLDLTTR  DS    CL3\nBLDLK    DS    CL1\nPANELID  DS    CL8\n         SPACE\nCOPY     DS    0D\n         ORG   *+PROTLEN\nCOPYLEN  EQU   *-COPY\n         SPACE\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nCMD0TABL CSECT ,                        RESUME CSECT\n         SPACE\nPROT     DS    0D\n         PRINT NOGEN\nISPPLIB  EQU   *-PROT+COPY\nISPPLIB@ DCB   DDNAME=ISPPLIB,MACRF=R,DSORG=PO\n         PRINT GEN\n         SPACE\nOPENLIST EQU   OPENLIS@-PROT+COPY\nOPENLIS@ OPEN  (0),MF=L\n         SPACE\nPROTLEN  EQU   *-PROT\n         END   CMD0TABL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNA0KBR": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CNA0KBR  TITLE ' - ISPF COMMAND TABLE BROWSE BY DDNAME'\n***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8503                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    THIS MODULE WILL ALLOW A USER TO BROWSE BY DDNAME.               *\n*                                                                     *\n***********************************************************************\nCNA0KBR  CSECT\n         SPACE\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*        SAVE REGISTER IN SAVE AREA AND GETMAIN WORKING STORAGE\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'CNA0KBR '              CSECT NAME\n         DC    C'02/16/85 '             DATE WRITTEN\n         DC    C'VERSION 1.2 '          VERSION NUMBER\n         DC    C'&SYSTIME '             ASSEMBLY TIME\n         DC    C'&SYSDATE '             ASSEMBLY DATE\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING CNA0KBR,12               PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         TITLE ' - INITALIZATION SECTION'\n***********************************************************************\n*        LOAD THE ISPLINK MODULE\n*        SET ISPF ERROR MODE TO CANCEL\n*        VDEFINE ERROR VARIABLES\n***********************************************************************\n         ISPF  LOAD                     LOAD ISPLINK\n         SPACE\n         CONTROL ERRORS,CANCEL          SET ISPF ERROR MODE\n         SPACE\n         VDEFINE '(UMSG1)',             VDEFINE VARIABLES              *\n               UMSG1,                   WORKING STORAGE AREA           *\n               CHAR,                    FULLWORD                       *\n               =F'24',                  4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(LMSG1)',             VDEFINE VARIABLES              *\n               LMSG1,                   WORKING STORAGE AREA           *\n               CHAR,                    FULLWORD                       *\n               =F'78',                  4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE 3\n***********************************************************************\n*\n*        CPPLRET IS A MODULE THAT WILL BUILD A CPPL FOR IKJPARSE\n*        1.   RESTORE PARAMTERS USER ENTERED INTO REGISTER 1\n*        2.   CALL CPPLRET TO BUILD A CPPL AND A CBUF FOR IKJPARSE\n*        3.   POINT REGISTER 3 TO WORKING STORAGE\n*        4.   CALL CNA0KBR1 WHICH WILL PARSE THE PARAMTERS AND STORE\n*             THE USER DATA INTO WORKING STORAGE (POINTED TO BY REG 3)\n*\n***********************************************************************\n         LR    1,11                     RESTORE PARAMETERS PASSED\n         CALL  CPPLRET                  GET CPPL FOR CALL\n         SPACE\n         LA    3,DSNADD                 GET ADDRESS OF LINK AREA\n         CALL  CNA0KBR1                 PARSE FIELDS\n         TITLE ' - PROCESS DDNAME REQUEST'\n***********************************************************************\n*   1.   MOVE THE DDNAME INTO AN 8 BYTE FIELD.\n*   2.   THE MODULE KDSNSUB WILL RETURN THE LIST OF DATASET ALLOCATED\n*        TO THE REQUESTED DDNAME.\n***********************************************************************\n         L     2,DSNLEN                 LOAD THE LENGTH OF THE DDNAME\n         BCTR  2,0                      SUBTRACT 1 FOR THE EXECUTE\n         L     14,DSNADD                LOAD THE ADDRESS OF THE DDNAME\n         MVC   DDNAME,=CL8' '           INIT THE DDNAME TO SPACES\n         MVC   DDNAME(*-*),0(14)        DUMMY MOVE FOR POINTER\n         EX    2,*-6                    MOVE THE DDNAME\n         SPACE\n         MVC   KDSNAMT,=H'30'           ALLOW UP TO 30 DATASETS\n         CALL  KDSNSUB,                 GET THE DSNAMES ALLOCATED      *\n               (DDNAME,                 8 BYTE DDNAME REQUESTED        *\n               KDSNAMT,                 RETURN UP TO THIS MANY DSNS    *\n               DSNTABLE,                TABLE TO STORE 44 BYTE DSNS    *\n               VOLTABLE),               TABLE TO STORE 6 BYTE VOLSERS  *\n               VL,                      SET BIT ON LAST PARM           *\n               MF=(E,SPFPARMS)          EXECUTE FORM OF MACRO\n         SPACE 3\n***********************************************************************\n*   RETURN CODES ARE:\n*        0   -   CALL WORKED\n*                DDNAME FIELD REMAINS THE SAME\n*                KDSNAMT FIELD CONTAINS AMOUNT OF DSNS RETURNED\n*                DSNTABLE CONTAINS 44 BYTE DSNS RETURNED\n*                VOLTABLE CONTAINS 6 BYTE VOLSERS TO THE ABOVE DSNS\n*\n*        4   -   THE DSNTABLE WOULD HAVE OVERFLOWED.\n*                THE KDSNAMT FIELD CONTAINS THE LIMIT OF DSNAMES THAT\n*                THE DSNTABLE CAN HOLD. IN THIS PROGRAM THE LIMIT IS\n*                30. THIS RETURN CODE SAYS THAT THE LIMIT WOULD HAVE\n*                BEEN EXECEED. ALL FIELDS ARE FILLED IN AS IN\n*                RETURN CODE 0 ABOVE.\n*\n*        8   -   REQUESTED DDNAME NOT ALLOCTED.\n*                THE KDSNAMT FIELD CONTAINS 0.\n*                ALL OTHER FIELDS REMAIN BLANK.\n***********************************************************************\n         C     15,=F'8'                 WAS DDNAME ALLOCATED\n         BL    B1000                    IF SO, CONTINUE\n         SPACE\n         MVC   UMSG1,=CL24'DDNAME NOT ALLOCATED'\n         MVC   LMSG1,=CL78'THE DDNAME YOU WISH TO BROWSE IS NOT CURRENT*\n               Y ALLOCATED'\n         SETMSG MSG==CL8'DTSM001',MF=E\n         SPACE\n         LA    10,8                     SET RETURN CODE TO 8\n         B     EXITPGM                  EXITPGM\n         SPACE 3\nB1000    DS    0H\n         C     15,=F'4'                 DID OVERFLOW OCCUR\n         BNE   B2000                    IF NOT RC 4 - CONTINUE\n         CONTROL DISPLAY,SM,=F'4',MF=E  ENTER ISPF LINE MODE\n         SPACE\n         TPUTE 'CNA0KBR ERROR: REQUESTED DDNAME HAS ALLOCTED IN MORE TH*\n               AN 30 DSNAMES'\n         SPACE\n         TPUTE 'CNA0KBR ERROR: DSNLIST WILL CONTAIN ONLY FIRST 30 DSNAM*\n               ES IN CONCATENATION'\n         SPACE\nB2000    DS    0H\n         TITLE ' - PROCESS DSNAMES RETURNED FOR DDNAME'\n***********************************************************************\n*   1.   CHECK IF CONCATENATION EXISTS.\n*   2.   IF NOT INVOKE BROWSE UPON THE SINGLE DATASET.\n***********************************************************************\n         CLC   KDSNAMT,=H'1'            WAS ONLY 1 DSN RETURNED\n         BNE   B3000                    IF NOT CONTINUE PROCESSING\n         MVC   JCLDSN,DSNTABLE          MOVE THE DSNAME TO SAVE AREA\n         MVC   BROWVOL,VOLTABLE         MOVE THE VOLSER OF DATASET\n         LA    10,BROWIT                GET ADDRESS OF BROW SUBROUTINE\n         B     JCLTOTSO                 CONVERT JCL DSN TO TSO DSN\n         SPACE\nB3000    DS    0H\n         SPACE 3\n***********************************************************************\n*   1.   IF A MEMBER WAS SPECIFIED BY THE USER, THEN REDUCE THE\n*        LIST OF DSNS TO THOSE THAT CONTAIN THE MEMBER\n*\n*   KMEMSUB IS A SUBROUTINE DESIGNED TO BE USED WITH KDSNSUB (ABOVE)\n*   KMEMSUB WILL SEARCH THE DSNTABLE RETURNED BY KDSNSUB AND SPACE OUT\n*   AND DSN IN THE TABLE THAT DOES NOT CONTAIN THE MEMBER REQUESTED.\n*\n***********************************************************************\n         CLC   MEM,=CL8' '              WAS A MEMBER REQUESTED\n         BE    DSNLIST                  IF NO MEMBER, BYPASS THIS CODE\n         CALL  KMEMSUB,                 CALL ROUTINE                   *\n               (MEM,                    MEMBER TO CHECK FOR            *\n               KDSNAMT,                 AMOUNT OF DSNS FROM KDSNSUB    *\n               DSNTABLE),               THE TABLE OF DSNS FROM KDSNSUB *\n               VL,                      MARK LAST PARM IN PARMLIST     *\n               MF=(E,SPFPARMS)          EXECUTE FORM OF CALL\n         SPACE 3\n         LTR   15,15                    CHECK RETURN CODE\n         BZ    B4000                    IF MEMBER FOUND - CONTINUE\n         MVC   UMSG1,=CL24'MEMBER NOT FOUND'\n         MVC   LMSG1,=CL78'THE MEMBER REQUESTED WAS NOT FOUND ON THE SP*\n               ECIFIED DDNAME'\n         SETMSG MSG==CL8'DTSM001',MF=E\n         SPACE\n         LA    10,8                     SET RETURN CODE\n         B     EXITPGM                  EXIT\nB4000    DS    0H\n         SPACE 3\n***********************************************************************\n*   KMEMSUB WILL SET KDSNAMT TO THE AMOUNT OF DSNS THAT CONTAINED\n*   THE MEMBER. IF THIS AMOUNT IS 1 - DIRECTLY INVOKE BROWSE ON THE\n*   DSN.\n***********************************************************************\n         CLC   KDSNAMT,=H'1'            WAS ONLY 1 DSNAME FOUND\n         BNE   DSNLIST                  IF MORE, BUILD TABLE OF DSNS\n*IND1ST  SEEK  (CLI,0(4),C' ',NE),      SEARCH DSN TABLE FOR NONBLANK\n*              BASEREG=4,BASE=DSNTABLE, DSNAME. IF NONE IS FOUND I\n*              LENREG=5,LEN=44,         HAVE A SEVERE BUG\n*              COUNTREG=6,COUNT=30,\n*              NOTFOUND=0\nFIND1ST  DS    0H\n         LA    4,DSNTABLE               GET ADDRESS OF TABLE\n         LA    5,44                     GET ENTRY LENGTH\n         LA    6,30                     GET NUMBER OF ENTRIES\nLOOP001  DS    0H\n         CLI   0(4),C' '                IS THERE A TABLE ENTRY\n         BNE   LOOX001                  WHEN FOUND EXIT\n         AR    4,5                      BUMP TO NEXT ENTRY\n         BCT   6,LOOP001                KEEP SEARCHING\n         B     0                        IF NOT FOUND ERROR\nLOOX001  DS    0H\n         SPACE\n         LA    2,30                     GET NUMBER OF TOTAL ENTRIES\n         SR    2,6                      2 WILL CONTAIN ENTRY NUMBER\n         MH    2,=H'6'                  FIND DISP INTO VOLTABLE\n         LA    3,VOLTABLE               GET ADDRESS OF VOLSER TABLE\n         LA    2,0(2,3)                 GET VOLSER OF DSN FOUND\n         MVC   BROWVOL,0(2)             MOVE THE VOLSER FOR BROW\n         MVC   JCLDSN,0(4)              MOVE THE DSNAME TO A SAVE AREA\n         LA    10,BROWIT                GET BROW SUBROUTINE ADDRESS\n         B     JCLTOTSO                 CONVERT JCL DSN TO TSO DSN\n         TITLE ' - CREATE AND PROCESS ISPF TABLE OF DSNAMES'\n***********************************************************************\n*   1.   CREATE A TABLE OF DSNAMES\n*   2.   VDEFINE THE VARIABLES FOR THE TABLE PROCESSING\n*   3.   TBADD THE DSNAMES INTO THE TABLE\n***********************************************************************\nDSNLIST  DS    0H\n         CLC   FIRSTK,=F'0'             WAS FIRST KEYWORD REQUESTED\n         BNE   FIND1ST                  YES, GO GET 1ST\n         MVC   CNATKBR(4),=CL4'KBRT'    TABLE NAME BEGINS WITH KEDT\n         TIME  ,                        GET THE TIME OF DAY\n         SPACE\n         ST    0,CNATKBR+4              TABLE NAME ENDS WITH TIME\n         TBCREATE CNATKBR,              TBCREATE TABLE                 *\n               NAMES='(TABLEDSN TABLEVOL LSEL)',                       *\n               WRITE='NOWRITE',         TEMPORARY TABLE                *\n               REPLACE='REPLACE',       REPLACE ANY CURRENT TABLE      *\n               MF=E                     EXECUTE FORM (FOR ISPF 2.1.2)\n         SPACE 3\n         VDEFINE '(ZTDTOP)',            VDEFINE VARIABLES              *\n               ZTDTOP,                  WORKING STORAGE AREA           *\n               FIXED,                   FULLWORD                       *\n               =F'4',                   4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(TABLEDSN)',          VDEFINE VARIABLES              *\n               TABLEDSN,                WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               56,                      10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(LSEL)',              VDEFINE VARIABLES              *\n               LSEL,                    WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               1,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(TABLEVOL)',          VDEFINE VARIABLES              *\n               TABLEVOL,                WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               6,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(DDNAME)',                                           *\n               DDNAME,                  WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               8,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         XC    ZTDTOP,ZTDTOP            ZERO OUT ZTDTOP\n         EJECT\n***********************************************************************\n*   1.   SEARCH DSNTABLE FROM KDSNSUB AND KMEMSUB -\n*   2.   ANY NON SPACE DSNAMES SHOULD BE TBADDED TO OUR TABLE\n***********************************************************************\n         LA    4,DSNTABLE               GET ADDRESS OF TABLE\n         LA    5,30                     SET TABLE LIMIT TO 30\n         SPACE\n*EEKLOOP SEEK  (CLI,0(4),C' ',NE),      SEARCH FOR EMPTY DSN SLOT\n*              BASEREG=4,               REGISTER 4 POINTS TO DSNTABLE\n*              LEN=44,                  ENTRIES ARE 44 BYTES LONG\n*              COUNTREG=5               REGISTER 5 CONTAINS COUNT\n         SPACE\nSEEKLOOP DS    0H\n         LA    15,44                    GET LENGTH OF ENTRY\nLOOP002  DS    0H\n         CLI   0(4),C' '                IS THERE A TABLE ENTRY\n         BNE   LOOX002                  IF YES - EXIT LOOP\n         AR    4,15                     BUMP TO NEXT ENTRY\n         BCT   5,LOOP002                KEEP SEARCHING\nLOOX002  DS    0H\n         SPACE\n         LTR   5,5                      IS TABLE SEARCH DONE\n         BZ    DISPLOOP                 GO DISPLAY TABLE\n         LA    2,30                     GET NUMBER OF TOTAL ENTRIES\n         SR    2,5                      2 WILL CONTAIN ENTRY NUMBER\n         MH    2,=H'6'                  FIND DISP INTO VOLTABLE\n         LA    3,VOLTABLE               GET ADDRESS OF VOLSER TABLE\n         LA    2,0(2,3)                 GET VOLSER OF DSN FOUND\n         MVC   TABLEVOL,0(2)            MOVE THE VOLSER FOR BROW\n         MVC   JCLDSN,0(4)              GET THE DSNAME\n         BAL   10,JCLTOTSO              CONVERT TO TSO SYNTAX\n         MVC   TABLEDSN,BROWDSN         GET CONVERTED DSNAME\n         LA    4,44(4)                  BUMP TO NEXT ENTRY FOR SEARCH\n         BCTR  5,0                      SUBTRACT 1 FROM ENTRY COUNT\n         MVI   LSEL,C' '\n         TBADD CNATKBR,MF=E             ADD TABLE ENTRY\n         SPACE\n         B     SEEKLOOP                 FIND ALL DSNAMES\n         TITLE ' - TBDISPL LOOP AND PROCESSING CODE'\n***********************************************************************\n*   1.   SET ZTDTOP AND TBDISPL THE TABLE\n***********************************************************************\nDISPLOOP DS    0H\n         TBTOP CNATKBR,MF=E             GO TO TOP OF TABLE\n         SPACE\n         TBSKIP CNATKBR,NUMBER=ZTDTOP,MF=E\n         SPACE\n         TBDISPL CNATKBR,PANEL='CNADKBR',MF=E\n         SPACE\nCHECKIT  LR    10,15                    SAVE RETURN CODE FROM TBDISPL\n         C     15,=F'4'                 WAS PF3 HIT\n         BNH   B5000                    BRANCH AROUND EXIT CODE\n         TBEND CNATKBR,MF=E             CLOSE TABLE\n         SPACE\n         SR    10,10                    SET RETURN CODE TO 0\n         B     EXITPGM                  EXIT PROGRAM\n         SPACE\nB5000    MVC   BROWDSN,TABLEDSN         GET THE DSNAME FOR BROW\n         MVC   BROWVOL,TABLEVOL         GET THE VOLSER FOR BROW\n         B     BROWIT2                  GO BROWIT\n         TITLE ' - EXIT THE PROGRAM'\n***********************************************************************\n*   1.   VDELETE ANY VARIABLES\n*   2.   DELETE THE ISPLINK MODULE FROM  CORE\n*   3.   STANDARD EXIT CODE - RETURN CODE IN REGISTER 10\n***********************************************************************\nEXITPGM  DS    0H\n         VRESET MF=E                    DELETE ALL FUNCTION VARIABLES\n         SPACE\n         ISPF  DELETE                   DELETE ISPLINK\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,10                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - CONVERT DSN FROM JCL SYNTAX TO TSO DSNAME SYNTAX'\n***********************************************************************\n*   1.   ADD QUOTES AROUND DSN\n*   2.   ADD MEMBER NAME IF SPECIFIED.\n***********************************************************************\nJCLTOTSO DS    0H\n         MVC   BROWDSN,=CL56''''        PUT FIRST QUOTE ON\n         MVC   BROWDSN+1(44),JCLDSN     MOVE THE DSNAME AFTER QUOTE\n         TRT   BROWDSN,TABLE40          FIND END OF DSNAME\n         CLC   MEM,=CL8' '              WAS A MEMBER ENTERED\n         BE    B6000                    IF NOT DONT PROCESS ONE\n         MVI   0(1),C'('                ADD PAREN FOR MEMBER\n         MVC   1(8,1),MEM               MOVE MEMBER NAME\n         TRT   BROWDSN,TABLE40          FIND END OF MEMBER NAME\n         MVI   0(1),C')'                MOVE FINAL PAREN\n         LA    1,1(1)                   POINT REG 1 TO END OF MEMBER\nB6000    DS    0H\n         MVI   0(1),C''''               END DSNAME WITH QUOTE\n         BR    (10)                     RETURN TO NEXT ROUTINE\n         TITLE ' - STANDARD BROW ROUTINES'\n***********************************************************************\n*   1.   BROWIT WILL BROW SIMPLE DSNAME\n*   2.   BROWIT2 WILL PROCESS LSEL LINE COMMAND\n***********************************************************************\nBROWIT   DS    0H\n         CONTROL ERRORS,RETURN,MF=E     SET ISPF ERROR MODE\n         SPACE\n         BROWSE  DATASET=BROWDSN,       DSNAME FOR BROW                *\n               VOLUME=BROWVOL,          VOLSER FOR BROW                *\n               MF=E                     EXECUTE FORM\n         SPACE\n         C     15,=F'4'                 WAS RETURN CODE GREATER THAN 4\n         BNH   B7000                    NO - BROW OK\n         MVC   VCOPYLEN,=F'8'\n         VCOPY '(ZERRMSG)',             GET ERROR MESSAGE              *\n               VCOPYLEN,                LENGTH PARM                    *\n               ZERRMSG,                 WORKING STORAGE ADDRESS        *\n               MOVE,                    MOVE THE ERROR MESSAGE         *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         SETMSG MSG=ZERRMSG,MF=E        ISSUE ERROR\n         SPACE\n         LA    10,16                    SET RETURN CODE\n         B     EXITPGM                  EXIT PROGRAM\nB7000    DS    0H\n         SR    10,10                    SET RETURN CODE\n         B     EXITPGM                  EXIT PROGRAM\n         SPACE 3\nBROWIT2  CONTROL ERRORS,RETURN,MF=E\n         SPACE\n         CLI   LSEL,C'P'                PDS COMMAND REQUESTED\n         BE    PDSCMD\n         CLI   LSEL,C' '                WAS A LINE COMMAND SPECIFIED\n         BE    B9000\n         CLI   LSEL,C'L'                WAS A LIBRARY REQUESTED\n         BNE   LSELS\n         TRT   BROWDSN,TABLE            FIND MEMBER\n         BZ    LSELS                    NO MEMBER FOUND\n         MVC   0(10,1),=CL10''''        SPACE OUT MEMBER NAME\nLSELS    CONTROL DISPLAY,SAVE,MF=E\n         SPACE\n         BROWSE  DATASET=BROWDSN,       DSNAME FOR BROW                *\n               VOLUME=BROWVOL,          VOLSER FOR BROW                *\n               MF=E                     EXECUTE FORM\n         SPACE\n         C     15,=F'4'\n         BNH   B8000                    NO - BROW OK\n         SPACE\n         MVC   VCOPYLEN,=F'8'\n         VCOPY '(ZERRMSG)',             GET ERROR MESSAGE              *\n               VCOPYLEN,                LENGTH PARM                    *\n               ZERRMSG,                 WORKING STORAGE ADDRESS        *\n               MOVE,                    MOVE MODE                      *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         SETMSG MSG=ZERRMSG,MF=E        ISSUE ERROR\n         SPACE\nB8000    DS    0H\n         CONTROL DISPLAY,RESTORE,MF=E\nB9000    DS    0H\n         CONTROL ERRORS,CANCEL,MF=E\n         SPACE\n         C     10,=F'4'                 WAS RETURN CODE GREATER THAN 4\n         BNE   DISPLOOP                 TBDISPL SOME MORE\n         TBDISPL CNATKBR,MF=E           GET NEXT LINE COMMAND\n         SPACE\n         B     CHECKIT                  CHECK RETURN CODE\n         SPACE\nPDSCMD   DS    0H\n         VCOPY '(PDSCMD)',VCOPYLEN,PDSADD,LOCATE,MF=E\n         SPACE\n         CONTROL DISPLAY,SAVE,MF=E\n         SPACE\n         L     2,PDSADD\n         SELECT VCOPYLEN,(2),MF=E\n         SPACE\n         B     B8000\n         EJECT\nTABLE40  DC    256X'00'                 TABLE FOR FINDING END OF DSN\n         ORG   TABLE40+C' '\n         DC    X'40'\nTABLE    DC    256X'00'                 TABLE FOR FINDING END OF DSN\n         ORG   TABLE+C'('\n         DC    C'('\n         ORG\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nDSNADD   DS    F                        ADDRESS OF DDNAME\nDSNLEN   DS    F                        LENGTH OF DDNAME\nMEM      DS    CL8                      MEMBER (OPTIONAL)\nFIRSTK   DS    F                        ONLY FIRST?\nDDNAME   DS    CL8                      DDNAME BUILT BY PARSE\nBROWDSN  DS    CL56                     DSNAME USE BY BROW SERVICE\nBROWVOL  DS    CL6                      VOLSER OF DSNAME FOR BROW\nPDSADD   DS    F                        BUFFER FOR ISPEXEC SELECT CMD\nTABLEDSN DS    CL56                     DSNAME USE FOR TABLE\nTABLEVOL DS    CL6                      VOLSER OF DSNAME FOR TABLE\nJCLDSN   DS    CL44                     JCLDSN USED BY CONVERT TO TSO\nKDSNAMT  DS    H                        AMOUNT FIELD FOR KDSNSUBS\nVCOPYLEN DS    F                        VCOPY LENGTH FIELDS\nZTDTOP   DS    F                        TOP OF TABLE ON TBDISPL\nCNATKBR  DS    CL8                      KED TABLE NAME\nLSEL     DS    CL1                      TBDISPL LINE COMMAND\nZERRMSG  DS    CL8                      NAME OF ERROR MESSAGE\nUMSG1    DS    CL24                     SHORT ERROR MESSAGE\nLMSG1    DS    CL78                     LONG ERROR MESSAGE\n         ISPF  PARMS,                   GENERATE ISPF WORKING STORAGE  *\n               MINIMUM=5                MINIMUM OF 5F IN PARMLIST\n         SPACE\nDSNTABLE DS    30CL44                   TABLE OF DSNS FOR KDSNSUB\nVOLTABLE DS    30CL6                    TABLE OF VOLSERS FOR KDSNSUB\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nCNA0KBR  CSECT ,                        RESUME CSECT\n         END   CNA0KBR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNA0KBR1": {"ttr": 776, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CNA0KBR1 TITLE ' - PARSE PARAMETERS FOR KBR COMMAND'\n***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822- 5719                                                  *\n*    LAST MODIFIED 8503                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    THIS PROGRAM PASSES THE USERS INPUT TO THE KBR (BROWSE BY DDNAME)*\n*    ISPF COMMAND.                                                    *\n***********************************************************************\n         EJECT\nCNA0KBR1 CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'CNA0KBR1 '             CSECT NAME\n         DC    C'03/21/85 '             DATE WRITTEN\n         DC    C'VERSION 1.1 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING CNA0KBR1,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         USING CPPL,4                   GET REG FOR CPPL\n         USING PPL,5                    GET REG FOR PPL\n         USING IKJPARMD,6               GET REGISTER FOR PARSE CSECT\n         SPACE 3\n         TITLE ' - GET CPPL AND ISSUE REQUEST PARSE'\n         LR    4,1                      GET CPPL ADDRESS\n         LA    5,PPLAREA                GRAB PPL POINTER (BUILT HERE)\n         L     6,=A(PARSECT)            GRAP PARSE CSECT ADDRESS\n         MVC   PPLCBUF,CPPLCBUF         MOVE CBUF PT FROM CPPL TO PPL\n         MVC   PPLUPT,CPPLUPT           MOVE UPT PT FROM CPPL TO PPL\n         ST    6,PPLPCL                 SAVE PARSECT ADDRESS IN PPL\n         MVC   PPLECT,CPPLECT           MOVE ECT PT FROM CPPL TO PPL\n         LA    2,CPECB                  GET ECB ADDRESS\n         ST    2,PPLECB                 STORE ADDRESS INTO PPL\n         LA    2,CPANS                  GET ANSWER AREA ADDRESS\n         ST    2,PPLANS                 STORE ADDRESS INTO PPL\n         LA    2,CPUWA                  GET UWA ADDRESS\n         ST    2,PPLUWA                 STORE ADDRESS INTO PPL\n         SPACE\n         CALLTSSR EP=IKJPARS,           CALL THE PARSE ROUTINE         *\n               MF=(E,(5))               POINTER TO THE PPL\n         SPACE\n         LTR   15,15                    IF PARSE ROUTINE FAILED\n         BNZ   PARSERR\n         DROP  5,4                      FREE REGISTERS\n         TITLE ' - MOVE PARSE PARMS INTO LINKAGE SECTION'\n         USING DSNPDE,5                 GET PANEL REGISTER\n         SPACE\n         L     6,CPANS                  GET POINTER TO PARSE RETURN\n*\n         LA    5,DSN                    POINT TO DSNAME AREA\n         MVC   0(4,3),PDEADDR           GET DSN ADDRESS\n         MVC   4(2,3),=H'0'             MOVE ZERO TO TOP OF FULLWORD\n         MVC   6(2,3),PDEL              GET DSNAME LENGTH\n         MVC   8(8,3),SPACES            MOVE SPACES TO MEMBER NAME\n         LH    2,PDELM                  GET MEMBER NAME LENGTH\n         LTR   2,2                      WAS A MEMBER SPECIFIED\n         BZ    NOMEM                    IF NOT - BYPASS MEM LOGIC\n         BCTR  2,0                      BUMP DOWN FOR MVC\n         L     14,PDEADDRM              GET ADDRESS OF MEMBER\n         MVC   8(0,3),0(14)             DUMMY MVC FOR EX INSTRUCTION\n         EX    2,*-6                    MOVE THE MEMBER NAME\nNOMEM    DS    0H                       END OF DSN CODE\n*\n         LA    5,KFIRST                 GET POINTER TO FIRST KEYWORD\n         MVC   16(2,3),=H'0'            SET FIRST HALFWORD TO 0\n         MVC   18(2,3),0(5)             MOVE THE FIRST KEYWORD VALUE\n*\n         DROP  5                        FREE REGISTER\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - SUBROUTINE PARSERR -  PARSE ENDED WITH NON-ZERO CC'\nPARSERR  DS    0H\n         LR    10,15\n         TPUTE 'PARSE ENCOUNTED SEVERE ERROR'\n         ABEND (10),DUMP\n         TITLE ' - WORKING STORAGE'\nSPACES   DC    CL80' '                  SPACE LITERAL\n         SPACE\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nPARMLIST DS    F                        PARMS FOR CALL OF CPPLRET\nCPECB    DS    F                        ECB FOR THE PPL\nCPANS    DS    F                        ANSWER AREA FOR THE PARSE\nCPUWA    DS    F                        USER WORK AREA\nPPLAREA  DS    0F,CL(PPLLEN)            FULLWORD ALIGN PPL\n         DS    0D                       EXTEND TO DOUBLWORD BOUNDRY\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nCNA0KBR1 CSECT ,                        RESUME CSECT\n         TITLE ' - IKJPARSE CONTROL BLOCKS'\n         PRINT NOGEN\nPARSECT  IKJPARM\n         SPACE\nDSN      IKJPOSIT DSNAME,               FIRST FIELD REQUIRED           *\n               PROMPT='A DDNAME(MEMBER) - MEMBER IS OPTIONAL',         *\n               HELP='A DDNAME(MEMBER) - MEMBER IS OPTIONAL',           *\n               VALIDCK=DSNEXIT\n         SPACE\nKFIRST   IKJKEYWD\n         IKJNAME 'FIRST'\n         SPACE\n         IKJENDP\n         PRINT GEN\n         TITLE ' - CVT DSECT'\n         CVT   DSECT=YES\n         TITLE ' - CPPL AND PPL DSECT'\n         DS    0H\n         IKJCPPL ,\n         SPACE 3\n         DS    0F                       FULLWORD ALIGNMENT\n         IKJPPL ,                       PPL DSECT\nPPLLEN   EQU   *-PPL                    PPL LENGTH\n         TITLE ' - PDE DSECTS AND LINKAGE SECTION'\nDSNPDE   DSECT                          PDE DSECT\nPDEADDR  DS    A                        ADDRESS OF DATA\nPDEL     DS    H                        LENGTH OF DATA\nPDEFLAGS DS    X                        PDE FLAG\n         DS    X                        FILLER BYTE\nPDEADDRM DS    A                        ADDRESS OF DATA\nPDELM    DS    H                        LENGTH OF DATA\nPDEFLAGM DS    X                        PDE FLAG\n         DS    X                        FILLER BYTE\n         SPACE 3\nCNA0KBR1 CSECT ,\nDSNEXIT  DS    0H                       PARSE EXIT ROUTINE\n         USING DSNEXIT,15               SET UP ADDRESSABILITY\n         L     1,0(1)                   GET PDE\n         USING DSNPDE,1                 SET UP ADDRESSABILITY\n         CLC   PDEL,=H'8'               IS LENGTH > 8\n         BH    DSNERR                   IF SO - ERROR\n         SR    15,15                    ELSE SET RC TO 0\n         BR    14                       EXIT\nDSNERR   DS    0H                       ERROR ROUTINE\n         LA    15,4                     SET RC TO 4\n         BR    14                       EXIT\n         DROP  15,1                     FREE REGISTERS\n         END   CNA0KBR1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNA0KED": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CNA0KED  TITLE ' - ISPF COMMAND TABLE EDIT BY DDNAME'\n*********************************************************************\n*                                                                   *\n*   BOB  ZIMMERMAN                                                  *\n*   CNA  INSURANCE                                                  *\n*   (312) 822-5719                                                  *\n*   LAST MODIFIED 8503                                              *\n*                                                                   *\n*                                                                   *\n*                                                                   *\n*   EDIT BY DDNAME REQUIRES OTHER MODULES (SEE INSTALLATION         *\n*   INSTRUCTIONS)                                                   *\n*                                                                   *\n*   THIS CODE WRITTEN/MAINTAINED AT CNA                             *\n*********************************************************************\n         EJECT\nCNA0KED  CSECT\n         SPACE\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*        SAVE REGISTER IN SAVE AREA AND GETMAIN WORKING STORAGE\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'CNA0KED '              CSECT NAME\n         DC    C'02/16/85 '             DATE WRITTEN\n         DC    C'VERSION 1.1 '          VERSION\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING CNA0KED,12               PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         TITLE ' - INITALIZATION SECTION'\n***********************************************************************\n*        LOAD THE ISPLINK MODULE\n*        SET ISPF ERROR MODE TO CANCEL\n*        DEFINE ISPF ERROR MESSAGE VARIABLES\n***********************************************************************\n         ISPF  LOAD                     LOAD ISPLINK\n         SPACE\n         CONTROL ERRORS,CANCEL          SET ISPF ERROR MODE\n         SPACE\n         XR    10,10\n         SELECT ,'PGM(EDREC)'           CHECK FOR EDIT RECOVERY\n         SPACE\n         C     15,=F'20'\n         BE    EXITPGM\n         SPACE\n         VDEFINE '(UMSG1)',             VDEFINE VARIABLES              *\n               UMSG1,                   WORKING STORAGE AREA           *\n               CHAR,                    FULLWORD                       *\n               =F'24',                  4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(LMSG1)',             VDEFINE VARIABLES              *\n               LMSG1,                   WORKING STORAGE AREA           *\n               CHAR,                    FULLWORD                       *\n               =F'78',                  4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE 3\n***********************************************************************\n*\n*        CPPLRET IS A MODULE THAT WILL BUILD A CPPL FOR IKJPARSE\n*        1.   RESTORE PARAMTERS USER ENTERED INTO REGISTER 1\n*        2.   CALL CPPLRET TO BUILD A CPPL AND A CBUF FOR IKJPARSE\n*        3.   POINT REGISTER 3 TO WORKING STORAGE\n*        4.   CALL CNA0KED1 WHICH WILL PARSE THE PARAMTERS AND STORE\n*             THE USER DATA INTO WORKING STORAGE (POINTED TO BY REG 3)\n*\n***********************************************************************\n         LR    1,11                     RESTORE PARAMETERS PASSED\n         CALL  CPPLRET                  GET CPPL FOR CALL\n         SPACE\n         LA    3,DSNADD                 GET ADDRESS OF LINK AREA\n         CALL  CNA0KED1                 PARSE FIELDS\n         TITLE ' - PROCESS DDNAME REQUEST'\n***********************************************************************\n*   1.   MOVE THE DDNAME INTO AN 8 BYTE FIELD.\n*   2.   THE MODULE KDSNSUB WILL RETURN THE LIST OF DATASET ALLOCATED\n*        TO THE REQUESTED DDNAME.\n***********************************************************************\n         L     2,DSNLEN                 LOAD THE LENGTH OF THE DDNAME\n         BCTR  2,0                      SUBTRACT 1 FOR THE EXECUTE\n         L     14,DSNADD                LOAD THE ADDRESS OF THE DDNAME\n         MVC   DDNAME,=CL8' '           INIT THE DDNAME TO SPACES\n         MVC   DDNAME(*-*),0(14)        DUMMY MOVE FOR POINTER\n         EX    2,*-6                    MOVE THE DDNAME\n         SPACE\n         MVC   KDSNAMT,=H'30'           ALLOW UP TO 30 DATASETS\n         CALL  KDSNSUB,                 GET THE DSNAMES ALLOCATED      *\n               (DDNAME,                 8 BYTE DDNAME REQUESTED        *\n               KDSNAMT,                 RETURN UP TO THIS MANY DSNS    *\n               DSNTABLE,                TABLE TO STORE 44 BYTE DSNS    *\n               VOLTABLE),               TABLE TO STORE 6 BYTE VOLSERS  *\n               VL,                      SET BIT ON LAST PARM           *\n               MF=(E,SPFPARMS)          EXECUTE FORM OF MACRO\n         SPACE 3\n***********************************************************************\n*   RETURN CODES ARE:\n*        0   -   CALL WORKED\n*                DDNAME FIELD REMAINS THE SAME\n*                KDSNAMT FIELD CONTAINS AMOUNT OF DSNS RETURNED\n*                DSNTABLE CONTAINS 44 BYTE DSNS RETURNED\n*                VOLTABLE CONTAINS 6 BYTE VOLSERS TO THE ABOVE DSNS\n*\n*        4   -   THE DSNTABLE WOULD HAVE OVERFLOWED.\n*                THE KDSNAMT FIELD CONTAINS THE LIMIT OF DSNAMES THAT\n*                THE DSNTABLE CAN HOLD. IN THIS PROGRAM THE LIMIT IS\n*                30. THIS RETURN CODE SAYS THAT THE LIMIT WOULD HAVE\n*                BEEN EXECEED. ALL FIELDS ARE FILLED IN AS IN\n*                RETURN CODE 0 ABOVE.\n*\n*        8   -   REQUESTED DDNAME NOT ALLOCTED.\n*                THE KDSNAMT FIELD CONTAINS 0.\n*                ALL OTHER FIELDS REMAIN BLANK.\n***********************************************************************\n         C     15,=F'8'                 WAS DDNAME ALLOCATED\n         BL    B1000                    IF SO, CONTINUE\n         SPACE\n         MVC   UMSG1,=CL24'DDNAME NOT ALLOCATED'\n         MVC   LMSG1,=CL78'THE DDNAME YOU REQUESTED TO EDIT IS NOT ALLO*\n               CATED AT THIS TIME'\n         SETMSG MSG==CL8'DTSM001',MF=E\n         SPACE\n         LA    10,8                     SET RETURN CODE TO 8\n         B     EXITPGM                  EXITPGM\n         SPACE 3\nB1000    DS    0H\n         C     15,=F'4'                 DID OVERFLOW OCCUR\n         BNE   B2000                    IF NOT RC 4 - CONTINUE\n         CONTROL DISPLAY,LINE,=F'4',MF=E ENTER ISPF LINE MODE\n         SPACE\n         TPUTE 'KED002W ERROR: REQUESTED DDNAME HAS ALLOCTED IN MORE TH*\n               AN 30 DSNAMES'\n         SPACE\n         TPUTE 'KED002W ERROR: DSNLIST WILL CONTAIN ONLY FIRST 30 DSNAM*\n               ES IN CONCATENATION'\n         SPACE\nB2000    DS    0H\n         TITLE ' - PROCESS DSNAMES RETURNED FOR DDNAME'\n***********************************************************************\n*   1.   CHECK IF CONCATENATION EXISTS.\n*   2.   IF NOT INVOKE EDIT UPON THE SINGLE DATASET.\n***********************************************************************\n         CLC   KDSNAMT,=H'1'            WAS ONLY 1 DSN RETURNED\n         BNE   B3000                    IF NOT CONTINUE PROCESSING\n         MVC   JCLDSN,DSNTABLE          MOVE THE DSNAME TO SAVE AREA\n         MVC   EDITVOL,VOLTABLE         MOVE THE VOLSER OF DATASET\n         LA    10,EDITIT                GET ADDRESS OF EDIT SUBROUTINE\n         B     JCLTOTSO                 CONVERT JCL DSN TO TSO DSN\n         SPACE\nB3000    DS    0H\n         SPACE 3\n***********************************************************************\n*   1.   IF A MEMBER WAS SPECIFIED BY THE USER, THEN REDUCE THE\n*        LIST OF DSNS TO THOSE THAT CONTAIN THE MEMBER\n*\n*   KMEMSUB IS A SUBROUTINE DESIGNED TO BE USED WITH KDSNSUB (ABOVE)\n*   KMEMSUB WILL SEARCH THE DSNTABLE RETURNED BY KDSNSUB AND SPACE OUT\n*   AND DSN IN THE TABLE THAT DOES NOT CONTAIN THE MEMBER REQUESTED.\n*\n***********************************************************************\n         CLC   MEM,=CL8' '              WAS A MEMBER REQUESTED\n         BE    DSNLIST                  IF NO MEMBER, BYPASS THIS CODE\n         CALL  KMEMSUB,                 CALL ROUTINE                   *\n               (MEM,                    MEMBER TO CHECK FOR            *\n               KDSNAMT,                 AMOUNT OF DSNS FROM KDSNSUB    *\n               DSNTABLE),               THE TABLE OF DSNS FROM KDSNSUB *\n               VL,                      MARK LAST PARM IN PARMLIST     *\n               MF=(E,SPFPARMS)          EXECUTE FORM OF CALL\n         SPACE 3\n         LTR   15,15                    CHECK RETURN CODE\n         BZ    B4000                    IF MEMBER FOUND - CONTINUE\n         SPACE\n         MVC   UMSG1,=CL24'MEMBER NOT FOUND'\n         MVC   LMSG1,=CL78'THE MEMBER REQUESTED WAS NOT FOUND ON THE SP*\n               ECIFIED DDNAME'\n         SETMSG MSG==CL8'DTSM001',MF=E\n         SPACE\n         LA    10,8                     SET RETURN CODE\n         B     EXITPGM                  EXIT\nB4000    DS    0H\n         SPACE 3\n***********************************************************************\n*   KMEMSUB WILL SET KDSNAMT TO THE AMOUNT OF DSNS THAT CONTAINED\n*   THE MEMBER. IF THIS AMOUNT IS 1 - DIRECTLY INVOKE EDIT ON THE\n*   DSN.\n***********************************************************************\n         CLC   KDSNAMT,=H'1'            WAS ONLY 1 DSNAME FOUND\n         BNE   DSNLIST                  IF MORE, BUILD TABLE OF DSNS\n*IND1ST  SEEK  (CLI,0(4),C' ',NE),      SEARCH DSN TABLE FOR NONBLANK\n*              BASEREG=4,BASE=DSNTABLE, DSNAME. IF NONE IS FOUND I\n*              LENREG=5,LEN=44,         HAVE A SEVERE BUG\n*              COUNTREG=6,COUNT=30,\n*              NOTFOUND=0\nFIND1ST  DS    0H\n         LA    4,DSNTABLE               GET ADDRESS OF TABLE\n         LA    5,44                     GET ENTRY LENGTH\n         LA    6,30                     GET NUMBER OF ENTRIES\nLOOP001  DS    0H\n         CLI   0(4),C' '                IS THERE A TABLE ENTRY\n         BNE   LOOX001                  WHEN FOUND EXIT\n         AR    4,5                      BUMP TO NEXT ENTRY\n         BCT   6,LOOP001                KEEP SEARCHING\n         B     0                        IF NOT FOUND ERROR\nLOOX001  DS    0H\n         SPACE\n         LA    2,30                     GET NUMBER OF TOTAL ENTRIES\n         SR    2,6                      2 WILL CONTAIN ENTRY NUMBER\n         MH    2,=H'6'                  FIND DISP INTO VOLTABLE\n         LA    3,VOLTABLE               GET ADDRESS OF VOLSER TABLE\n         LA    2,0(2,3)                 GET VOLSER OF DSN FOUND\n         MVC   EDITVOL,0(2)             MOVE THE VOLSER FOR EDIT\n         MVC   JCLDSN,0(4)              MOVE THE DSNAME TO A SAVE AREA\n         LA    10,EDITIT                GET EDIT SUBROUTINE ADDRESS\n         B     JCLTOTSO                 CONVERT JCL DSN TO TSO DSN\n         TITLE ' - CREATE AND PROCESS ISPF TABLE OF DSNAMES'\n***********************************************************************\n*   1.   CREATE A TABLE OF DSNAMES\n*   2.   VDEFINE THE VARIABLES FOR THE TABLE PROCESSING\n*   3.   TBADD THE DSNAMES INTO THE TABLE\n***********************************************************************\nDSNLIST  DS    0H\n         CLC   FIRSTK,=F'0'\n         BNE   FIND1ST\n         MVC   CNATKED(4),=CL4'KEDT'    TABLE NAME BEGINS WITH KEDT\n         TIME  ,                        GET THE TIME OF DAY\n         SPACE\n         ST    0,CNATKED+4              TABLE NAME ENDS WITH TIME\n         TBCREATE CNATKED,              TBCREATE TABLE                 *\n               NAMES='(TABLEDSN TABLEVOL LSEL)',                       *\n               WRITE='NOWRITE',         TEMPORARY TABLE                *\n               REPLACE='REPLACE',       REPLACE ANY CURRENT TABLE      *\n               MF=E                     EXECUTE FORM (FOR ISPF 2.1.2)\n         SPACE 3\n         VDEFINE '(ZTDTOP)',            VDEFINE VARIABLES              *\n               ZTDTOP,                  WORKING STORAGE AREA           *\n               FIXED,                   FULLWORD                       *\n               =F'4',                   4 BYTES LONG                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(TABLEDSN)',          VDEFINE VARIABLES              *\n               TABLEDSN,                WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               56,                      10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(LSEL)',              VDEFINE VARIABLES              *\n               LSEL,                    WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               1,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(TABLEVOL)',          VDEFINE VARIABLES              *\n               TABLEVOL,                WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               6,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         VDEFINE '(CNAFPROF CNAFMACR CNAFDUMM DDNAME)',                *\n               PROF,                    WORKING STORAGE AREA           *\n               CHAR,                    CHARACTER FORMAT               *\n               8,                       10 BYTES LONG                  *\n               MF=E                     EXECUTE FORM\n         SPACE\n         XC    ZTDTOP,ZTDTOP            ZERO OUT ZTDTOP\n         EJECT\n***********************************************************************\n*   1.   SEARCH DSNTABLE FROM KDSNSUB AND KMEMSUB -\n*   2.   ANY NON SPACE DSNAMES SHOULD BE TBADDED TO OUR TABLE\n***********************************************************************\n         LA    4,DSNTABLE               GET ADDRESS OF TABLE\n         LA    5,30                     SET TABLE LIMIT TO 30\n         SPACE\n*EEKLOOP SEEK  (CLI,0(4),C' ',NE),      SEARCH FOR EMPTY DSN SLOT\n*              BASEREG=4,               REGISTER 4 POINTS TO DSNTABLE\n*              LEN=44,                  ENTRIES ARE 44 BYTES LONG\n*              COUNTREG=5               REGISTER 5 CONTAINS COUNT\n         SPACE\nSEEKLOOP DS    0H\n         LA    15,44                    GET LENGTH OF ENTRY\nLOOP002  DS    0H\n         CLI   0(4),C' '                IS THERE A TABLE ENTRY\n         BNE   LOOX002                  IF YES - EXIT LOOP\n         AR    4,15                     BUMP TO NEXT ENTRY\n         BCT   5,LOOP002                KEEP SEARCHING\nLOOX002  DS    0H\n         SPACE\n         LTR   5,5                      IS TABLE SEARCH DONE\n         BZ    DISPLOOP                 GO DISPLAY TABLE\n         LA    2,30                     GET NUMBER OF TOTAL ENTRIES\n         SR    2,5                      2 WILL CONTAIN ENTRY NUMBER\n         MH    2,=H'6'                  FIND DISP INTO VOLTABLE\n         LA    3,VOLTABLE               GET ADDRESS OF VOLSER TABLE\n         LA    2,0(2,3)                 GET VOLSER OF DSN FOUND\n         MVC   TABLEVOL,0(2)            MOVE THE VOLSER FOR EDIT\n         MVC   JCLDSN,0(4)              GET THE DSNAME\n         BAL   10,JCLTOTSO              CONVERT TO TSO SYNTAX\n         MVC   TABLEDSN,EDITDSN         GET CONVERTED DSNAME\n         LA    4,44(4)                  BUMP TO NEXT ENTRY FOR SEARCH\n         BCTR  5,0                      SUBTRACT 1 FROM ENTRY COUNT\n         MVI   LSEL,C' '\n         TBADD CNATKED,MF=E             ADD TABLE ENTRY\n         SPACE\n         B     SEEKLOOP                 FIND ALL DSNAMES\n         TITLE ' - TBDISPL LOOP AND PROCESSING CODE'\n***********************************************************************\n*   1.   SET ZTDTOP AND TBDISPL THE TABLE\n***********************************************************************\nDISPLOOP DS    0H\n         TBTOP CNATKED,MF=E             GO TO TOP OF TABLE\n         SPACE\n         TBSKIP CNATKED,NUMBER=ZTDTOP,MF=E\n         SPACE\n         TBDISPL CNATKED,PANEL='CNADKED',MF=E\n         SPACE\nCHECKIT  LR    10,15                    SAVE RETURN CODE FROM TBDISPL\n         C     15,=F'4'                 WAS PF3 HIT\n         BNH   B5000                    BRANCH AROUND EXIT CODE\n         TBEND CNATKED,MF=E             CLOSE TABLE\n         SPACE\n         SR    10,10                    SET RETURN CODE TO 0\n         B     EXITPGM                  EXIT PROGRAM\n         SPACE\nB5000    MVC   EDITDSN,TABLEDSN         GET THE DSNAME FOR EDIT\n         MVC   EDITVOL,TABLEVOL         GET THE VOLSER FOR EDIT\n         B     EDITIT2                  GO EDITIT\n         TITLE ' - EXIT THE PROGRAM'\n***********************************************************************\n*   1.   VDELETE ANY VARIABLES\n*   2.   DELETE THE ISPLINK MODULE FROM  CORE\n*   3.   STANDARD EXIT CODE - RETURN CODE IN REGISTER 10\n***********************************************************************\nEXITPGM  DS    0H\n         VRESET MF=E                    DELETE ALL FUNCTION VARIABLES\n         SPACE\n         ISPF  DELETE                   DELETE ISPLINK\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,10                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - CONVERT DSN FROM JCL SYNTAX TO TSO DSNAME SYNTAX'\n***********************************************************************\n*   1.   ADD QUOTES AROUND DSN\n*   2.   ADD MEMBER NAME IF SPECIFIED.\n***********************************************************************\nJCLTOTSO DS    0H\n         MVC   EDITDSN,=CL56''''        PUT FIRST QUOTE ON\n         MVC   EDITDSN+1(44),JCLDSN     MOVE THE DSNAME AFTER QUOTE\n         TRT   EDITDSN,TABLE40          FIND END OF DSNAME\n         CLC   MEM,=CL8' '              WAS A MEMBER ENTERED\n         BE    B6000                    IF NOT DONT PROCESS ONE\n         MVI   0(1),C'('                ADD PAREN FOR MEMBER\n         MVC   1(8,1),MEM               MOVE MEMBER NAME\n         TRT   EDITDSN,TABLE40          FIND END OF MEMBER NAME\n         MVI   0(1),C')'                MOVE FINAL PAREN\n         LA    1,1(1)                   POINT REG 1 TO END OF MEMBER\nB6000    DS    0H\n         MVI   0(1),C''''               END DSNAME WITH QUOTE\n         BR    (10)                     RETURN TO NEXT ROUTINE\n         TITLE ' - STANDARD EDIT ROUTINES'\n***********************************************************************\n*   1.   EDITIT WILL EDIT SIMPLE DSNAME\n*   2.   EDITIT2 WILL PROCESS LSEL LINE COMMAND\n***********************************************************************\nEDITIT   DS    0H\n         CONTROL ERRORS,RETURN,MF=E     SET ISPF ERROR MODE\n         SPACE\n         EDIT  DATASET=EDITDSN,         DSNAME FOR EDIT                *\n               VOLUME=EDITVOL,          VOLSER FOR EDIT                *\n               MACRO=MACRO,             EDIT MACRO                     *\n               PROFILE=PROF,            EDIT PROFILE                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         C     15,=F'4'                 WAS RETURN CODE GREATER THAN 4\n         BNH   B7000                    NO - EDIT OK\n         SPACE\n         MVC   VCOPYLEN,=F'8'           SET VCOPY LENGTH\n         VCOPY '(ZERRMSG)',             COPY THE ERROR MESSAAGE        *\n               VCOPYLEN,                LENGTH                         *\n               ZERRMSG,                 WORKING STORAGE AREA           *\n               MOVE,                    MOVE MODE                      *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         SETMSG MSG=ZERRMSG,MF=E        ISSUE ERROR MESSAGE\n         SPACE\n         LA    10,16                    SET RETURN CODE\n         B     EXITPGM                  EXIT PROGRAM\nB7000    DS    0H\n         SR    10,10                    SET RETURN CODE\n         B     EXITPGM                  EXIT PROGRAM\n         SPACE 3\nEDITIT2  CONTROL ERRORS,RETURN,MF=E\n         SPACE\n         CLI   LSEL,C'P'                PDS COMMAND REQUESTED\n         BE    PDSCMD\n         CLI   LSEL,C' '                WAS A LINE COMMAND SPECIFIED\n         BE    B9000\n         CLI   LSEL,C'L'                WAS A LIBRARY REQUESTED\n         BNE   LSELS\n         TRT   EDITDSN,TABLE            FIND MEMBER\n         BZ    LSELS                    NO MEMBER FOUND\n         MVC   0(10,1),=CL10''''        SPACE OUT MEMBER NAME\nLSELS    CONTROL DISPLAY,SAVE,MF=E\n         SPACE\n         EDIT  DATASET=EDITDSN,         DSNAME FOR EDIT                *\n               VOLUME=EDITVOL,          VOLSER FOR EDIT                *\n               MACRO=MACRO,             EDIT MACRO                     *\n               PROFILE=PROF,            EDIT PROFILE                   *\n               MF=E                     EXECUTE FORM\n         SPACE\n         C     15,=F'4'                 WAS RETURN CODE GREATER THAN 4\n         BNH   B8000                    NO - EDIT OK\n         SPACE\n         MVC   VCOPYLEN,=F'8'           SET VCOPY LENGTH\n         VCOPY '(ZERRMSG)',             COPY THE ERROR MESSAAGE        *\n               VCOPYLEN,                LENGTH                         *\n               ZERRMSG,                 WORKING STORAGE AREA           *\n               MOVE,                    MOVE MODE                      *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         SETMSG MSG=ZERRMSG,MF=E        ISSUE ERROR MESSAGE\n         SPACE\nB8000    DS    0H\n         CONTROL DISPLAY,RESTORE,MF=E\nB9000    CONTROL ERRORS,CANCEL,MF=E\n         SPACE\n         C     10,=F'4'                 WAS RETURN CODE GREATER THAN 4\n         BNE   DISPLOOP                 TBDISPL SOME MORE\n         TBDISPL CNATKED,MF=E           GET NEXT LINE COMMAND\n         SPACE\n         B     CHECKIT                  CHECK RETURN CODE\n         SPACE\nPDSCMD   DS    0H\n         VCOPY '(PDSCMD)',VCOPYLEN,PDSADD,LOCATE,MF=E\n         SPACE\n         CONTROL DISPLAY,SAVE,MF=E\n         SPACE\n         L     2,PDSADD\n         SELECT VCOPYLEN,(2),MF=E\n         SPACE\n         CONTROL DISPLAY,RESTORE,MF=E\n         SPACE\n         B     B9000\n         EJECT\nTABLE40  DC    256X'00'                 TABLE FOR FINDING END OF DSN\n         ORG   TABLE40+C' '\n         DC    X'40'\nTABLE    DC    256X'00'                 TABLE FOR FINDING END OF DSN\n         ORG   TABLE+C'('\n         DC    C'('\n         ORG\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nDSNADD   DS    F                        ADDRESS OF DDNAME\nDSNLEN   DS    F                        LENGTH OF DDNAME\nMEM      DS    CL8                      MEMBER (OPTIONAL)\nPROF     DS    CL8                      EDIT PROFILE (OPTIONAL)\nMACRO    DS    CL8                      EDIT MACRO (OPTIONAL)\nFIRSTK   DS    F                        EDIT PANEL (OPTIONAL)\n         DS    F\nDDNAME   DS    CL8                      DDNAME BUILT BY PARSE\nEDITDSN  DS    CL56                     DSNAME USE BY EDIT SERVICE\nEDITVOL  DS    CL6                      VOLSER OF DSNAME FOR EDIT\nPDSADD   DS    F                        BUFFER FOR ISPEXEC SELECT CMD\nTABLEDSN DS    CL56                     DSNAME USE FOR TABLE\nTABLEVOL DS    CL6                      VOLSER OF DSNAME FOR TABLE\nJCLDSN   DS    CL44                     JCLDSN USED BY CONVERT TO TSO\nKDSNAMT  DS    H                        AMOUNT FIELD FOR KDSNSUBS\nVCOPYLEN DS    F                        VCOPY LENGTH FIELDS\nZTDTOP   DS    F                        TOP OF TABLE ON TBDISPL\nCNATKED  DS    CL8                      KED TABLE NAME\nLSEL     DS    CL1                      TBDISPL LINE COMMAND\nZERRMSG  DS    CL8                      LONG ERROR MESSAGE\nUMSG1    DS    CL24                     UPPER ERROR MESSAGE\nLMSG1    DS    CL78                     LOWER ERROR MESSAGE\n         ISPF  PARMS,                   GENERATE ISPF WORKING STORAGE  *\n               MINIMUM=5                MINIMUM OF 5F IN PARMLIST\n         SPACE\nDSNTABLE DS    30CL44                   TABLE OF DSNS FOR KDSNSUB\nVOLTABLE DS    30CL6                    TABLE OF VOLSERS FOR KDSNSUB\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nCNA0KED  CSECT ,                        RESUME CSECT\n         END   CNA0KED\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CNA0KED1": {"ttr": 1034, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "CNA0KED1 TITLE ' - PARSE PARAMETERS FOR EDIT BY DDNAME'\n***********************************************************************\n*                                                                     *\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8503                                               *\n*                                                                     *\n***********************************************************************\n*    THIS MODULE IS CALLED BY CNA0KED. THIS MODULE WILL PERFORM THE   *\n*    PARSE SERVICE AND SUPPLY VALID PARAMETERS TO CNA0KED.            *\n***********************************************************************\n         SPACE 3\nCNA0KED1 CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM                 *\n*                 REGISTER 12 IS ONLY BASE REGISTER                   *\n***********************************************************************\n         SPACE 3\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'CNA0KED1'              CSECT NAME\n         DC    C'03/12/85 '             DATE WRITTEN\n         DC    C'VERSION 1.1 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING CNA0KED1,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         TITLE ' - GET CPPL AND ISSUE REQUEST PARSE'\n***********************************************************************\n*    ASSIGN BASE REGISTERS FOR THE CPPL, PPL, AND THE PARSE CSECT     *\n*    AREA.                                                            *\n*                                                                     *\n*    AFTER INITALIZING ALL AREAS, CALL THE PARSE ROUTINE.             *\n***********************************************************************\n         SPACE\n         USING CPPL,5                   SET UP CPPL ADDRESABILITY\n         USING PPL,6                    SET UP PPL ADDRESABILITY\n         USING IKJPARMD,7               SET UP PARSE CSECT ADDRSABLITY\n         SPACE\n         LR    5,1                      GET CPPL ADDRESS\n         LA    6,PPLAREA                GRAB PPL POINTER (BUILT HERE)\n         L     7,=A(PARSECT)            GRAP PARSE CSECT ADDRESS\n         MVC   PPLCBUF,CPPLCBUF         MOVE CBUF PT FROM CPPL TO PPL\n         MVC   PPLUPT,CPPLUPT           MOVE UPT PT FROM CPPL TO PPL\n         ST    7,PPLPCL                 SAVE PARSECT ADDRESS IN PPL\n         MVC   PPLECT,CPPLECT           MOVE ECT PT FROM CPPL TO PPL\n         LA    2,CPECB                  GET ECB ADDRESS\n         ST    2,PPLECB                 STORE ADDRESS INTO PPL\n         LA    2,CPANS                  GET ANSWER AREA ADDRESS\n         ST    2,PPLANS                 STORE ADDRESS INTO PPL\n         LA    2,CPUWA                  GET UWA ADDRESS\n         ST    2,PPLUWA                 STORE ADDRESS INTO PPL\n         SPACE\n         CALLTSSR EP=IKJPARS,           CALL THE PARSE ROUTINE         *\n               MF=(E,(6))               POINTER TO THE PPL\n         SPACE\n         LTR   15,15                    IF PARSE ROUTINE FAILED\n         BNZ   PARSERR\n         DROP  6,5                      FREE REGISTERS\n         TITLE ' - MOVE PARSE PARMS INTO LINKAGE SECTION'\n***********************************************************************\n*    BEGIN GETTING THE DATA FROM PARSE AND RETURN TO LINKAGE AREA     *\n*    POINTED TO BY REGISTER 3.                                        *\n***********************************************************************\n         SPACE\n         USING DSNPDE,4                 SET UP PDE ADDRESSABILITY\n         L     7,CPANS                  GET POINTER TO PARSE RETURN\n*\n         LA    4,DSN                    POINT TO DSNAME\n         MVC   0(4,3),PDEADDR           GET DSNAME ADDRESS\n         MVC   4(2,3),=H'0'             MOVE ZERO TO TOP OF FULLWORD\n         MVC   6(2,3),PDEL              GET DSNAME LENGTH\n         MVC   8(8,3),SPACES            INIT MEMBER NAME TO SPACES\n         LH    2,PDELM                  GET LENGTH OF MEMBER\n         LTR   2,2                      WAS A MEMBER SPECIFIED\n         BZ    NOMEM                    IF NOT - KEEP GOING\n         BCTR  2,0                      BUMP DOWN FOR MVC\n         L     14,PDEADDRM              GET ADDRESS OF MEMBER\n         MVC   8(0,3),0(14)             DUMMY MVC FOR EX INSTRUCTION\n         EX    2,*-6                    MOVE MEMBER NAME\nNOMEM    DS    0H                       END MEMBER PROCESSING\n*\n         LA    4,PROF                   POINT TO PROFILE KEYWORD\n         MVC   16(8,3),SPACES           INIT PROFILE TO SPACES\n         LH    2,PDEL                   GET LENGTH OF PROFILE\n         LTR   2,2                      WAS PROFILE SPECIFIED\n         BZ    NOPROF                   IF NOT - KEEP GOING\n         BCTR  2,0                      BUMP DOWN FOR MVC INSTRUCTION\n         L     14,PDEADDR               GET ADDRESS OF PROFILE\n         MVC   16(0,3),0(14)            DUMMY MVC FOR EX\n         EX    2,*-6                    MOVE THE PROFILE\nNOPROF   DS    0H                       END PROFILE PROCESSING\n*\n         LA    4,MACRO                  POINT TO MACRO KEYWORD\n         MVC   24(8,3),SPACES           INIT MACRO TO SPACES\n         LH    2,PDEL                   GET LENGTH OF MACRO\n         LTR   2,2                      IF MACRO SPECIFIED\n         BZ    NOMACRO                  IF NOT - KEEP GOING\n         BCTR  2,0                      BUMP DOWN FOR MVC\n         L     14,PDEADDR               GET ADDRESS OF MACRO\n         MVC   24(0,3),0(14)            DUMMY MVC FOR EX INSTRUCTION\n         EX    2,*-6                    MOVE THE MACRO\nNOMACRO  DS    0H                       MACRO PROCESSING DONE\n*\n         LA    4,KFIRST                 POINT TO FIRST KEYWORD\n         MVC   32(2,3),=H'0'            INIT TOP HALF OF FULLWORD\n         MVC   34(2,3),0(4)             MOVE THE KEYWORD VALUE\n*\n         DROP  4                        FREE REGISTER\n         TITLE '- EXIT PROGRAM'\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - SUBROUTINE PARSERR -  PARSE ENDED WITH NON-ZERO CC'\nPARSERR  DS    0H\n         TPUTE 'PARSE ENCOUNTED SEVERE ERROR'\n         SPACE\n         ABEND (15),DUMP\n         TITLE ' - WORKING STORAGE'\nSPACES   DC    CL80' '                  SPACE LITERAL\n         SPACE\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nPARMLIST DS    F                        PARMS FOR CALL OF CPPLRET\nCPECB    DS    F                        ECB FOR THE PPL\nCPANS    DS    F                        ANSWER AREA FOR THE PARSE\nCPUWA    DS    F                        USER WORK AREA\nPPLAREA  DS    0F,CL(PPLLEN)            FULLWORD ALIGN PPL\n         DS    0D                       EXTEND TO DOUBLE WORD BOUNDRY\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nCNA0KED1 CSECT ,                        RESUME CSECT\n         TITLE ' - IKJPARSE CONTROL BLOCKS'\n         PRINT NOGEN\nPARSECT  IKJPARM\n         SPACE\nDSN      IKJPOSIT DSNAME,               FIRST FIELD REQUIRED           *\n               PROMPT='A DDNAME(MEMBER) - MEMBER IS OPTIONAL',         *\n               HELP='A VALID DDNAME - OPTIONALLY ENCLOSE MEMBER',      *\n               VALIDCK=DSNEXIT\n         SPACE\nKPROF    IKJKEYWD\n         IKJNAME 'PROFILE',SUBFLD=SPROF\n         SPACE\nKMACRO   IKJKEYWD\n         IKJNAME 'MACRO',SUBFLD=SMACRO\n         SPACE\nKFIRST   IKJKEYWD\n         IKJNAME 'FIRST'\n         SPACE\nSPROF    IKJSUBF\nPROF     IKJIDENT 'EDIT PROFILE NAME',                                 *\n               MAXLNTH=8,                                              *\n               PROMPT='A VALID EDIT PROFILE NAME',                     *\n               FIRST=ALPHA,                                            *\n               OTHER=ALPHANUM,                                         *\n               HELP='A VALID PDF EDIT PROFILE NAME'\n         SPACE\nSMACRO   IKJSUBF\nMACRO    IKJIDENT 'EDIT MACRO NAME',                                   *\n               MAXLNTH=8,                                              *\n               PROMPT='A VALID EDIT MACRO',                            *\n               FIRST=ALPHA,                                            *\n               OTHER=ALPHANUM,                                         *\n               HELP='A VALID PDF EDIT MACRO'\n         SPACE\n         IKJENDP\n         PRINT GEN\n         TITLE ' - CVT DSECT'\n         CVT   DSECT=YES                GENERATE A CVT MAP\n         TITLE ' - CPPL AND PPL DSECT'\n         DS    0H\n         IKJCPPL ,                      GENERATE A CPPL MAP\n         SPACE 3\n         DS    0F                       FULLWORD ALIGNMENT\n         IKJPPL ,                       PPL DSECT\nPPLLEN   EQU   *-PPL                    PPL LENGTH\n         TITLE ' - PDE DSECTS AND LINKAGE SECTION'\nDSNPDE   DSECT                          PDE DSECT\nPDEADDR  DS    A                        ADDRESS OF DATA\nPDEL     DS    H                        LENGTH OF DATA\nPDEFLAGS DS    X                        PDE FLAG\n         DS    X                        FILLER BYTE\nPDEADDRM DS    A                        ADDRESS OF DATA\nPDELM    DS    H                        LENGTH OF DATA\nPDEFLAGM DS    X                        PDE FLAG\n         DS    X                        FILLER BYTE\n         SPACE 3\nCNA0KED1 CSECT ,                        RESUME CSECT\nDSNEXIT  DS    0H                       PARSE EXIT ROUTINE\n         USING DSNEXIT,15               SETUP ADDRESSABILITY\n         L     1,0(1)                   GET PDE ADDRESS\n         USING DSNPDE,1                 SETUP ADDRESSABILITY\n         CLC   PDEL,=H'8'               IS LENGTH > 8 BYTES\n         BH    DSNERR                   IF SO - ERROR\n         SR    15,15                    CLEAR RETURN CODE\n         BR    14                       EXIT\nDSNERR   DS    0H                       ERROR ROUTINE\n         LA    15,4                     SET RETURN CODE TO 4\n         BR    14                       RETURN\n         DROP  15,1                     FREE REGISTERS\n         END   CNA0KED1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPPLRET": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    THIS PROGRAM AND ASSOCIATED WERE WRITTEN AT CNA INSURANCE        *\n*    COMPANY.                                                         *\n*                                                                     *\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MOD 8412                                                    *\n***********************************************************************\n*    THIS MODULE IS CALLED BY CNA0KED - IT WILL RETURN A VALID CPPL   *\n*    FOR THE PARSE ROUTINE.                                           *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  MACRO:      GENCODE--GENERATE INSTRUCTION OF COND PARAMETER LIST.  *\n*                                                                     *\n*  FUNCTION:   TO PARSE THE INSTRUCTION SUBLIST PASSED AND GENERATE   *\n*              THE PROPER CONDITIONAL BRANCH ACCORDING TO PARAMETERS  *\n*              PASSED.                                                *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*                                                                     *\n*          &INST   THE INSTRUCTION SUBLIST (EXACT ALLOWABLE FORMS     *\n*                  SPECIFIED IN THE \"NIU STRUCTURED MACROS\" WRITEUP). *\n*                                                                     *\n*          &LBL    LABEL TO BE ATTACHED TO THE CONDITIONAL BRANCH.    *\n*                                                                     *\n*          &TYPE   IS EQUAL TO \"NOT\" WHEN CODED; SPECIFIES THAT BRANCH*\n*                  TO BE TAKEN IF SPECIFIED CONDITION IS NOT TRUE.    *\n*                                                                     *\n*  XREF:       MACROS USED--GETCC                                     *\n*              MODULES CALLED--NONE                                   *\n*                                                                     *\n*  AUTHOR:     DAVID T. CARPENTER.                                    *\n*                                                                     *\n*  DATE:       10 OCTOBER 1976.                                       *\n*                                                                     *\n*  SEE THE \"NIU STRUCTURE MACROS\"  WRITEUP FOR FURTHER DOCUMENTATION. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  MODIFICATION:  BY WALTER G. SCHEER OF CNA INSURANCE ON 10/5/77 WS02*\n*                  -- ALL COND TYPE STATEMENTS WILL EXPECT THE        *\n*                       CONDITION CODE MASK LAST!                     *\n*                                                                     *\n* MAINTENANCE                                                         *\n*   MIKE AMLING -- MOVE GETCC FROM MACRO TO INLINE       4/14/83  MA04*\n*   MIKE AMLING -- CLEAN UP CODE                         4/14/83  MA05*\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  MACRO:      GETCC--RETURN PROPER CC VALUE TO CALLING MACRO.        *\n*                                                                     *\n*  FUNCTION:   TO VERIFY AND TRANSLATE IF NECESSARY THE SPECIFIED     *\n*              USER CONDITION.                                        *\n*                                                                     *\n*  PARAMETERS:                                                        *\n*                                                                     *\n*          &COND   THE SYMBOL SPECIFYING THE USER CONDITION THAT IS   *\n*                  TO BE VERIFIED AND TRANSLATED.                     *\n*                                                                     *\n*  XREF:       MACROS USED--NONE                                      *\n*              MODULES CALLED--NONE                                   *\n*                                                                     *\n*  AUTHOR:     DAVID T. CARPENTER.                                    *\n*                                                                     *\n*  DATE:       10 OCTOBER 1976.                                       *\n*                                                                     *\n*  SEE THE \"NIU STRUCTURE MACROS\"  WRITEUP FOR FURTHER DOCUMENTATION. *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  MODIFICATION: BY WALTER G. SCHEER OF CNA INSURANCE ON 10/5/77. WS01*\n*              -- WRITE ERROR MESSAGE IF THE RELATIONAL OPERATOR  WS01*\n*                    NAME IS NON-STANDARD.                        WS01*\n*                                                                     *\n* MAINTENANCE                                                         *\n*   MIKE AMLING -- CHANGE GE CONDITION CODE MASK TO 10,  4/14/83  MA02*\n*                   LE CONDITION CODE MASK TO 12.                 MA02*\n*   MIKE AMLING -- ADD C, NC, B AND NB CONDITION CODE    4/14/83  MA03*\n*                   MASKS.                                        MA03*\n*                                                                     *\n***********************************************************************\n         MACRO\n         GENCODE &INST,&LBL,&TYPE\n         GBLB  &ERRFLAG            INTERMACRO ERROR FLAG\n         LCLA  &CCMVAL             CONDITION CODE MASK VALUE      MA04\n         LCLC  &C\n.*                                                                MA05\n.** EDIT THE SUBLIST                                              MA05\n.*                                                                MA05\n         AIF   (N'&INST GT 5 OR                                        *\n                (N'&INST LT 3 AND N'&INST NE 1)).BADLIST          MA05\n&C       SETC  '&INST(N'&INST)'                                   MA04\n         AIF   ('&C'(1,1) LT '0' OR '&C'(1,1) GT '9').NOTNUM      MA04\n           AIF   (K'&C EQ 1).CCX                                  MA04\n           AIF (K'&C GT 2 OR '&C' LT '10' OR '&C' GT '15').NUMERR MA04\n         AGO   .CCX                                               MA04\n.NOTNUM  AIF   (K'&C EQ 1).CALCC                                  MA04\n         AIF   (K'&C NE 2).INVCOND\n           AIF   ('&C'(1,1) EQ 'N').NEGATE                        MA05\n           AIF   ('&C' EQ 'EQ').BC8\n           AIF   ('&C' EQ 'LT').BC4\n           AIF   ('&C' EQ 'GT').BC2\n           AIF   ('&C' NE 'LE').TRYGE\n&C           SETC  '12'                                           MA02\n           AGO   .CCX                                             MA04\n.TRYGE     AIF   ('&C' NE 'GE').INVCOND\n&C           SETC  '10'                                           MA02\n           AGO   .CCX                                             MA04\n.NEGATE  ANOP                                                     MA05\n&C       SETC  '&INST(N'&INST)'(2,1)\n.CALCC   AIF   ('&C' EQ 'P' OR '&C' EQ 'H').BC2\n           AIF   ('&C' EQ 'L' OR '&C' EQ 'M' OR '&C' EQ 'B').BC4  MA03\n             AIF   ('&C' EQ 'E' OR '&C' EQ 'Z').BC8\n               AIF   ('&C' EQ 'C').BC3                            MA03\n                 AIF   ('&C' NE 'O').INVCOND                      MA03\n&CCMVAL            SETA  1\n                 AGO   .TSTN\n.BC3           ANOP                                               MA03\n&CCMVAL        SETA  3                                            MA03\n               AGO   .TSTN                                        MA03\n.BC8         ANOP\n&CCMVAL      SETA  8\n             AGO   .TSTN\n.BC4       ANOP\n&CCMVAL    SETA  4\n           AGO   .TSTN\n.BC2     ANOP\n&CCMVAL  SETA 2\n.TSTN    AIF  ('&INST(N'&INST)'(1,1) NE 'N').DONE\n&CCMVAL    SETA  15-&CCMVAL\n.DONE    ANOP                                                     MA04\n&C       SETC  '&CCMVAL'                                          MA04\n.**      AGO   .CCX                                               MA04\n.CCX     ANOP                                                     MA04\n.*                                                                MA05\n.** THE EDIT PASSED, GENERATE CODE                                MA05\n.*                                                                MA05\n         AIF   (N'&INST EQ 1).INSTRUX IF SUBSTRING OF ONE-->.INSTRUX\n         AIF   (N'&INST LT 5).CHKFOUR IF NOT 3-OP-->CHKFOUR\n         &INST(1) &INST(2),&INST(3),&INST(4)\n         AGO   .INSTRUX           GO TO .INSTRUX\n.CHKFOUR ANOP\n         AIF   (N'&INST LT 4).TRI  IF NOT 2-OP-->CHKTRI\n         &INST(1) &INST(2),&INST(3)\n         AGO   .INSTRUX           GO TO .INSTRUX\n.TRI     ANOP\n         &INST(1) &INST(2)\n.INSTRUX ANOP\n         AIF   ('&TYPE' EQ 'NOT').GENNOT  IF A 'NOT'-->GENNOT\n         BC    &C,&LBL\n         MEXIT\n.GENNOT  ANOP\n         BC    15-&C,&LBL\n         MEXIT\n.*\n.** ERROR MESSAGES\n.*\n.INVCOND MNOTE 8,'VALUE ''&C'' NOT A STANDARD RELATIONAL OPERATOR' WS01\n         AGO   .CCX                                               MA04\n.BADLIST MNOTE 12,'*** IMPROPER NON-COMPARE SUBLIST ***'\n&ERRFLAG SETB  1                  SET &ERRFLAG=ON\n         MEXIT\n.NUMERR  MNOTE 12,'*** INVALID NUMERIC CONDITION ***'\n&ERRFLAG SETB  1                                                  MA05\n         MEND\n***********************************************************************\n*                                                                     *\n*   MACRO:  EXLBL                                                     *\n*                                                                     *\n*   FUNCTION:  THE EXLBL MACRO IS AN INTERNALLY INVOKED SUPPORT       *\n*       MACRO.  IT PERFORMS THE OPERATION OF CONDITIONALLY GENERATING *\n*       TWO DIFFERENT TYPES OF END LABELS DEPENDING ON THE ARGUMENT   *\n*       &TYPE.                                                        *\n*                                                                     *\n*   PARAMETERS:                                                       *\n*                                                                     *\n*      &TYPE  INDICATES THE TYPE OF INVOCATION:                       *\n*             DOIF - CAUSES THE GENERATION OF A LABEL FROM THE DOIFEX *\n*                 STACK, WHICH IS THE LABEL ASSOCIATED WITH THE ENDIF *\n*                 OR DO MACROS.                                       *\n*             COND - CAUSES THE GENERATION OF A LABEL FROM THE CONDEX *\n*                 STACK WHICH IS PART OF THE SEQUENCE OF LABELS       *\n*                 CARRIED BETWEEN CONDS.  AFTER GENERATION A NEW      *\n*                 UNIQUE LABEL IS PLACED ON THE STACK.                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    MODIFICATION HISTORY:                                            *\n*    DATE     AUTHOR              COMMENTS                         ID *\n*    05/30/79 MIKE AMLING         ADD DEFINITION OF DEFERRED      MA02*\n*                                  @#NO&N1 LABELS TO SUPPORT      MA02*\n*                                  CPARSE REWRITE                 MA02*\n*                                                                     *\n*    04/13/83 MIKE AMLING         USE DS 0H WHEN EQU * MIGHT      MA03*\n*                                  LEGITIMATELY BE UNALIGNED      MA03*\n*                                                                     *\n***********************************************************************\n         MACRO\n         EXLBL &TYPE\n         GBLA  &LVLPTR            INDEX INTO THE STACKS\n         GBLA  &EXGEN             THE LABEL COUNTER\n         GBLA  &EXNO              CURRENT SUBSCRIPT OF &EXNOLBL   MA02\n         GBLA  &DOIFEX(50)        STACK FOR $ENDIF AND $DO LABELS\n         GBLA  &CONDEX(50)        STACK FOR $COND END LABELS\n         GBLA  &EXNOLBL(100)      STACK OF SAVED @#NO LBLS        MA02\n         GBLA  &EXNOHI(50)        HIGHEST ELEMENT OF &EXNOLBL IN  MA02\n.*                                 USE OUTSIDE OF CURRENT DO OR IFMA02\n         AIF   ('&TYPE' NE 'DOIF').GENLBL  THEN WANT CONDEX LABEL\n@#EX&DOIFEX(&LVLPTR) DS 0H                                        MA03\n         MEXIT\n.GENLBL  ANOP\n@#EX&CONDEX(&LVLPTR) DS 0H                                        MA03\n&CONDEX(&LVLPTR) SETA &EXGEN      PLACE VALUE OF &EXGEN ON &CONDEX\n&EXGEN   SETA  &EXGEN+1           INCREMENT &EXGEN BY 1\n.LOOP    AIF   (&EXNO LE &EXNOHI(&LVLPTR)).EXIT                   MA02\n@#NO&EXNOLBL(&EXNO)  EQU  *                                       MA02\n&EXNO    SETA  &EXNO-1                                            MA02\n         AGO   .LOOP                                              MA02\n.EXIT    MEND\n         MACRO\n         ENDIF\n.**********************************************************************\n.*                                                                    *\n.*  MACRO:  ENDIF                                                     *\n.*                                                                    *\n.*  FUNCTION:  ENDIF FORMS THE ENDING DELIMITER FOR A IF-COND-ENDIF   *\n.*      MACRO SEQUENCE.  IT GENERATES END LABELS AND A CON-           *\n.*      DITIONAL ABEND INSTRUCTION DEPENDING ON THE &ELSE FLAG,       *\n.*      WHICH INDICATES THE PRESENCE OF A PRECEEDING COND WITH AN     *\n.*      ELSE ARGUMENT.  IN ADDITION, THE &ARGS FLAG INDICATES TO      *\n.*      ENDIF WHETHER THE IBM CONCEPT-14 FORMAT IS BEING UTILIZED,    *\n.*      WHICH ALSO SUPPRESSES THE ABEND GENERATION.  LASTLY, THE      *\n.*      ENDIF MACRO DECREMENTS THE STACKS POINTER TO CLEAR THE        *\n.*      STACKS FOR THIS SEQUENCE.                                     *\n.*                                                                    *\n.*  PARAMETERS:  NONE.                                                *\n.*                                                                    *\n.*  XREF:  MACROS USED - EXLBL                                        *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &FIRSTC            FLAG TO DETECT START OF SEQUENCE\n         GBLB  &ELSE(50)          STACK TO DETECT $COND ELSE PRESENCE\n         GBLB  &ARGS(50)          INDICATES SIMPLE IF-ELSE-ENDIF STRUC\n         GBLB  &EXCODE(50)        THE STACK FOR $IF OR $DO ID\n         GBLA  &LVLPTR            THE STACKS INDEX\n         GBLA  &DOIFEX(50)        THE $DO OR $IF END LABEL STACK\n         AIF   (&LVLPTR GT 0).CHKF  CHECK INVALID STACK LEVEL\n         MNOTE 12,'***ERROR: UNMATCHED ENDIF***'\n         AGO   .END\n.CHKF    AIF   (&FIRSTC EQ 0).CHKNXT IF NOT ON, PROCEED NORMALLY\n         MNOTE 12,'***ERROR: ENDIF IMMEDIATELY FOLLOWS IF OR DO***'\n&FIRSTC  SETB  0                  TURN OFF &FIRSTC\n         AGO   .DEC\n.CHKNXT  AIF   (&ELSE(&LVLPTR) EQ 1).ABCOM  DONT GENERATE ABEND\n         AIF   (&ARGS(&LVLPTR) EQ 0).ABND  THEN GENERATE ABEND\n         EXLBL COND               GENERATE LABEL\n         AGO   .ABCOM             BRANCH TO GET LABEL\n.ABND    B     @#EX&DOIFEX(&LVLPTR)  BRANCH AROUND ABEND\n         EXLBL COND               GENERATE LABEL\n         ABEND 50,DUMP\n.ABCOM   AIF   (&EXCODE(&LVLPTR) EQ 1).DECR  THEN MATCH OK\n         MNOTE 12,'***ERROR: ENDIF PAIRED WITH DO***'\n.DECR    EXLBL DOIF               GENERATE ENDIF LABEL\n&ELSE(&LVLPTR) SETB  0            TURN &ELSE OFF\n&ARGS(&LVLPTR) SETB  0            TURN OFF &ARGS\n.DEC     ANOP\n&LVLPTR  SETA  &LVLPTR-1          DECREMENT STACKS INDEX\n.END     MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n         ELSE\n.**********************************************************************\n.*                                                                    *\n.*  MACRO:  ELSE                                                      *\n.*                                                                    *\n.*  FUNCTION - ELSE ACCOMODATES THE CODING FORMAT OF THE              *\n.*             IBM CONCEPT-14 IF-ELSE-ENDIF MACRO FORMAT.             *\n.*                                                                    *\n.**********************************************************************\n         COND ELSE\n         MEND\n         MACRO\n         PUSHNEST &TYPE\n.**********************************************************************\n.*                                                                    *\n.*  MACRO:  PUSHNEST                                                  *\n.*                                                                    *\n.*  FUNCTION:  THE PUSHNEST MACRO IS AN INTERNALLY INVOKED SUPPORT    *\n.*      MACRO WHICH PERFORMS THE INITIAL LABEL STACKING OPERATIONS    *\n.*      NECESSARY TO ESTABLISH AN IF-COND-ENDIF OR A DO-COND-ENDDO    *\n.*      SEQUENCE.  THIS INCLUDES STACKING A UNIQUE DOIF END LABEL     *\n.*      FOR THE ENDIF OR DO MACROS, AND STACKING A LABEL TO BE USED   *\n.*      BY THE INTERVENING CONDS.  THE TYPE CODE (IF OR DO) IS ALSO   *\n.*      STACKED TO ALLOW SUBSEQUENT MACRO COMPATABILITY CHECKING      *\n.*      DURING ENDIF OR ENDDO PROCESSING.                             *\n.*                                                                    *\n.*  PARAMETERS:                                                       *\n.*                                                                    *\n.*     &TYPE  INDICATES THE TYPE OF INVOCATION.  CAN BE ONE OF THE    *\n.*            FOLLOWING:                                              *\n.*            IF - PUSHNEST INVOKED FROM IF MACRO.                    *\n.*            DO - PUSHNEST INVOKED FROM DO MACRO.                    *\n.*                                                                    *\n.*   MODIFICATION HISTORY:                                            *\n.*   DATE     AUTHOR              COMMENTS                         ID *\n.*   05/30/79 MIKE AMLING         ADD INITIALIZATION OF &EXNOHI()  MA02\n.*                                TO SUPPORT CPARSE REWRITE        MA02\n.*                                                                    *\n.**********************************************************************\n         GBLA  &EXGEN             THE LABEL COUNTER\n         GBLA  &LVLPTR            THE STACKS INDEX\n         GBLA  &CONDEX(50)        THE &COND LABEL STACK\n         GBLA  &DOIFEX(50)        THE $DO OR $ENDIF END LABEL STACK\n         GBLA  &EXNOHI(50)        HIGHEST SUBSCRIPT OF &EXNOLBL IN MA02\n.*                                 USE OUTSIDE OF CURRENT DO OR IF MA02\n         GBLA  &EXNO              CURRENT SUBSCRIPT OF &EXNOLBL    MA02\n         GBLB  &EXCODE(50)        STACK OF MACRO TYPE CODES:\n.*                                  0 = $DO\n.*                                  1 = $IF\n         AIF   (&LVLPTR LT 50).ADDSTK  IF NOT FULL PROCEED NORMALLY\n         MNOTE 12,'***ERROR: NESTING LEVEL EXCEEDS CAPACITY***'\n         MEXIT\n.ADDSTK  ANOP\n&LVLPTR  SETA  &LVLPTR+1          INCREMENT &LVLPTR FOR NEXT ENTRY\n&DOIFEX(&LVLPTR) SETA  &EXGEN     PUT &EXGEN COUNTER VALUE ON &DOIFEX\n&CONDEX(&LVLPTR) SETA  &EXGEN+1   PUT NEXT &EXGEN ON &CONDEX\n&EXGEN   SETA  &EXGEN+2           SET UP NEXT UNIQUE VALUE\n&EXCODE(&LVLPTR) SETB  ('&TYPE' EQ 'IF')\n&EXNOHI(&LVLPTR) SETA  &EXNO      SET TO HIGHEST &EXNO IN USE      MA02\n.*                                 OUTSIDE OF THIS $DO OR $IF      MA02\n         MEND\n***********************************************************************\n*                                                                     *\n*   MACRO:  IF                                                        *\n*                                                                     *\n*   FUNCTION:  THE IF MACRO FORMS THE BEGINNING DELIMITER FOR A       *\n*       STRUCTURED IF-COND-ENDIF MACRO SEQUENCE.  IT PERFORMS THE     *\n*       INITIAL STACK PROCESSING FOR THE SEQUENCE.  IN ADDITION, IN   *\n*       ORDER TO ACCOMODATE THE CODING FORMAT FOR THE IBM CONCEPT-14  *\n*       MACROS, ANY ARGUMENTS CODED WITH THE IF MACRO ARE PASSED TO   *\n*       A GENERATED COND.  A FLAG, &ARGS, IS ALSO SET TO INDICATE     *\n*       THIS CONDTION.                                                *\n*                                                                     *\n*   PARAMETERS:  ARGUMENTS MAY BE PASSED THROUGH &SYSLIST.            *\n*                                                                     *\n*   XREF:  MACROS USED - PUSHNEST.                                    *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* MAINTENANCE                                                         *\n*   MIKE AMLING -- PROVOKE AN ERROR MESSAGE IF MORE     11/ 2/82  MA01*\n*        THAN 25 OPERANDS, RATHER THAN GENERATING INCORRECT CODE      *\n*                                                                     *\n***********************************************************************\n         MACRO\n         IF\n         GBLA  &LVLPTR             LEVEL OF MACRO INVOCATION\n         GBLA  &EXNO               CURRENT SUBSCRIPT OF &EXNOLBL\n         GBLA  &NOS                NUMBER TO DISTINGUISH @#NO LBLS\n         GBLA  &GOS                NUMBER TO DISTINGUISH @#GO LBLS\n         GBLA  &CONDEX(50)         STACK CONTAINING LABEL SUFFIX OF\n.*                                  NEXT CONDITION SEGMENT\n         GBLA  &DOIFEX(50)         STACK OF UNIQUE LABELS PER LEVEL\n         GBLA  &EXNOLBL(100)       STACK OF SAVED @#NO LBLS\n         GBLA  &EXNOHI(50)         HIGHEST SUBSCRIPT OF &EXNOLBL IN\n.*                                  USE OUTSIDE OF THIS IF\n.*\n         GBLB  &ERRFLAG            ERROR DISCOVERED BY GENCODE\n         GBLB  &FIRSTC             STILL WAITING FOR FIRST CONDITION\n         GBLB  &ARGS(50)           SIMPLE IF-ELSE-ENDIF STRUC\n         GBLB  &ELSE(50)           INDICATOR OF ELSE PROCESSED AT LEVEL\n.*\n         LCLA  &CNTR               POINTER TO CPARSE PARAMETER\n         LCLA  &GOLBL(12)          STACK OF SAVED @#GO&GOS LABELS\n         LCLA  &GO                 CURRENT SUBSCRIPT OF &GOLBL\n.*\n         LCLB  &NOUSED             @#NO&NOS HAS BEEN USED\n         LCLB  &GOUSED             @#GO&GOS HAS BEEN USED\n.*\n         AIF   (&FIRSTC).IFIF      FIRST CONDITION OF PRECEDING IF OR\n.*                                  DO HAS NOT YET APPEARED\n&FIRSTC  SETB  (N'&SYSLIST LE 2 AND '&SYSLIST(1)&SYSLIST(2)' EQ '')\n         PUSHNEST IF               INITIALIZE STACKS\n         AIF   (&FIRSTC).EXIT      IF NO OPERANDS, DO NO MORE\n&ARGS(&LVLPTR) SETB  1             TURN ON &ARGS FLAG\n.*\n.** EDIT FOR IMPROPER USE OF ELSE.\n.*\n         AIF   ('&SYSLIST(1)' EQ 'ELSE').FIRSELS  IF ELSE IS ERROR\n.*\n.** THE EDIT PASSED, GENERATE CODE.\n.*\n&CNTR    SETA  0                   START WITH FIRST POSITIONAL\n*        COPY  CPARS               GENERATES CODE\n.**********************************************************************\n.*   BOB ZIMMERMAN                                                    *\n.*   CNA INSURANCE                                                    *\n.*   (312) 822-5719                                                   *\n.*   LAST MOD 8412                                                    *\n.**********************************************************************\n.*   THIS MEMBER IS REQUIRED AS A COPY MEMBER BY THE MODULE           *\n.*   CPPLRET.                                                         *\n.**********************************************************************\n.*                                                                    *\n.*   COPY MEMBER: 'CPARS'                                             *\n.*                                                                    *\n.*   FUNCTION:  TO GENERATE TESTING AND BRANCHING CODE IMPLEMENTING   *\n.*              THE 'IF', 'ELSIF', 'DO' AND 'COND' MACROS.            *\n.*                                                                    *\n.*   OPERANDS:  BEGINNING AND ENDING WITH SIMPLE CONDITIONS, THE      *\n.*              OPERAND LIST CONSISTS OF SIMPLE CONDITIONS AND        *\n.*              LOGICAL OPERATORS APPEARING IN TURNS.  FOR FULL       *\n.*              INFORMATION ABOUT SIMPLE CONDITIONS AND LOGICAL       *\n.*              OPERATIONS, CONSULT 'CODING OF CONDITIONS' IN         *\n.*              USER'S MANUAL.                                        *\n.*                                                                    *\n.*   XREF:      MACROS USED - 'GENCODE'                               *\n.*                                                                    *\n.*                                                                    *\n.*   AUTHOR:    NAIPING LEE.                                          *\n.*                                                                    *\n.*   DATE:      24 OCT 1976                                           *\n.*                                                                    *\n.**********************************************************************\n.*                                                                    *\n.*   MODIFICATION HISTORY:                                            *\n.*   DATE     AUTHOR              COMMENTS                         ID *\n.*   05/30/79 MIKE AMLING          REWRITTEN TO GENERATE OPTIMAL  MA02*\n.*                                  CODE (RELATED CHANGES TO      MA02*\n.*                                  EXLBL AND PUSHNEST)           MA02*\n.*                                                                    *\n.*   04/12/83 MIKE AMLING          REWRITTEN AS COPY MEMBER       MA03*\n.*                                  RATHER THAN MACRO TO SUPPORT  MA03*\n.*                                  UNLIMITED NUMBER OF OPERANDS  MA03*\n.*                                                                    *\n.**********************************************************************\n.* THE FOLLOWING VARIABLE SYMBOLS USED IN CPARS SHOULD BE         MA03*\n.*  DECLARED IN THE INVOKING MACRO.                               MA03*\n.*       GBLA  &LVLPTR             NESTING LEVEL OF MACRO\n.*       GBLA  &EXNO               CURRENT SUBSCRIPT OF &EXNOLBL  MA02\n.*       GBLA  &NOS                COUNT TO DISTINGUISH @#NO LBLS MA02\n.*       GBLA  &GOS                COUNT TO DISTINGUISH @#GO LBLS MA02\n.*       GBLA  &CONDEX(50)         STACK OF COND SEQUENCE LABELS\n.*       GBLA  &EXNOLBL(100)       STACK OF SAVED @#NO LBLS       MA02\n.*       GBLA  &EXNOHI(50)         HIGHEST ELEMENT OF &EXNOLBL IN MA02\n.*.*                                USE OUTSIDE OF THIS DO OR IF  MA02\n.*.*                                                              MA03\n.*       GBLB  &ERRFLAG            ERROR DISCOVERED BY GENCODE\n.*.*                                                              MA03\n.*       LCLA  &CNTR               POINTER TO CPARSE PARAMETER\n.*       LCLA  &GO                 CURRENT SUBSCRIPT OF &GOLBL    MA02\n.*       LCLA  &GOLBL(12)          STACK OF SAVED @#GO&GOS LABELS MA02\n.*.*                                                              MA03\n.*       LCLB  &NOUSED             @#NO&NOS HAS BEEN USED         MA02\n.*       LCLB  &GOUSED             @#GO&GOS HAS BEEN USED         MA02\n.*---------------------------------------------------------------------\n.LOOP    ANOP\n&CNTR    SETA  &CNTR+2                 UPDATE PTR TO CURRENT OPERANDS\n         AIF   ('&SYSLIST(&CNTR-1)' EQ '').EVEN#P EVEN # PARMS IS ERROR\n         AIF   (N'&SYSLIST EQ &CNTR-1).NULL                       MA03\n         AIF   ('&SYSLIST(&CNTR)' EQ 'AND').AND                   MA02\n         AIF   ('&SYSLIST(&CNTR)' EQ 'OR').OR                     MA02\n         AIF   ('&SYSLIST(&CNTR)' EQ 'ANDIF').ANDIF               MA02\n         AIF   ('&SYSLIST(&CNTR)' EQ 'ORIF').ORIF                 MA02\n         AGO   .BADOP                                             MA03\n.*---------------------------------------------------------------------\n.NULL    GENCODE &SYSLIST(&CNTR-1),@#EX&CONDEX(&LVLPTR),NOT\n         AIF   (&ERRFLAG).CPARSX       SKIP IF ERROR              MA02\n.*                SAVE CURRENT @#NO&NOS, IF USED                  MA02\n         AIF   (NOT &NOUSED).SAVEN1X                              MA02\n&EXNO    SETA  &EXNO+1             GET AN ELEMENT OF &EXNOLBL     MA02\n&EXNOLBL(&EXNO) SETA &NOS          SAVE &NOS TO BE DEFINED LATER  MA02\n&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02\n.SAVEN1X ANOP                                                     MA02\n.*                 DEFINE ALL SAVED @#GO&GOS'S                    MA02\n.EXGLOOP AIF   (&GO LE 0).EXGX                                    MA02\n@#GO&GOLBL(&GO) EQU *                                             MA02\n&GO      SETA  &GO-1                                              MA02\n         AGO   .EXGLOOP                                           MA02\n.EXGX    ANOP                                                     MA02\n.*               DEFINE CURRENT @#GO&GOS, IF USED                 MA02\n         AIF   (NOT &GOUSED).CPARSX                               MA02\n@#GO&GOS EQU   *                                                  MA02\n&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02\n&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02\n         AGO   .CPARSX                                            MA03\n.*---------------------------------------------------------------------\n.AND     GENCODE &SYSLIST(&CNTR-1),@#NO&NOS,NOT GEN TESTING CODE  MA02\n         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02\n&NOUSED  SETB  1                   INDICATE @#NO&NOS USED         MA02\n         AGO   .LOOP\n.*---------------------------------------------------------------------\n.OR      GENCODE &SYSLIST(&CNTR-1),@#GO&GOS,  GEN TESTING CODE    MA02\n         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02\n&GOUSED  SETB  1                   INDICATE @#GO&GOS USED         MA02\n.*               DEFINE CURRENT @#NO&NOS, IF USED                 MA02\n         AIF   (NOT &NOUSED).LOOP                                 MA02\n@#NO&NOS EQU   *                                                  MA02\n&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02\n&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02\n         AGO   .LOOP\n.*---------------------------------------------------------------------\n.ANDIF   GENCODE &SYSLIST(&CNTR-1),@#NO&NOS,NOT GEN TESTING CODE  MA02\n         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02\n.*                    SAVE CURRENT @#NO&NOS                       MA02\n&EXNO    SETA  &EXNO+1             GET AN ELEMENT OF &EXNOLBL     MA02\n&EXNOLBL(&EXNO) SETA &NOS          SAVE &NOS TO BE DEFINED LATER  MA02\n&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02\n&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02\n.*               DEFINE CURRENT @#GO&GOS, IF USED                 MA02\n         AIF   (NOT &GOUSED).LOOP                                 MA02\n@#GO&GOS EQU   *                                                  MA02\n&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02\n&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02\n         AGO   .LOOP\n.*---------------------------------------------------------------------\n.ORIF    GENCODE &SYSLIST(&CNTR-1),@#GO&GOS,   GEN TESTING CODE   MA02\n         AIF   (&ERRFLAG).CPARSX   SKIP IF ERROR                  MA02\n.*                    SAVE CURRENT @#GO&GOS                       MA02\n&GO      SETA  &GO+1               GET AN ELEMENT OF &GOLBL       MA02\n&GOLBL(&GO) SETA &GOS              SAVE &GOS TO BE DEFINED LATER  MA02\n&GOS     SETA  &GOS+1              GET A FRESH &GOS               MA02\n&GOUSED  SETB  0                   NEW &GOS HAS NOT YET BEEN USED MA02\n.*                 DEFINE ALL SAVED @#NO&NOS'S                    MA02\n.EXNLOOP AIF   (&EXNO LE &EXNOHI(&LVLPTR)).EXNX                   MA02\n@#NO&EXNOLBL(&EXNO) EQU *                                         MA02\n&EXNO    SETA  &EXNO-1                                            MA02\n         AGO   .EXNLOOP                                           MA02\n.EXNX    ANOP                                                     MA02\n.*                DEFINE CURRENT @#NO&NOS, IF USED                MA02\n         AIF   (NOT &NOUSED).LOOP                                 MA02\n@#NO&NOS EQU   *                                                  MA02\n&NOS     SETA  &NOS+1              GET A FRESH &NOS               MA02\n&NOUSED  SETB  0                   NEW &NOS HAS NOT YET BEEN USED MA02\n         AGO   .LOOP\n.*---------------------------------------------------------------------\n.*                                                                MA03\n.** ERROR MESSAGES                                                MA03\n.*                                                                MA03\n.BADOP   ANOP                                                     MA03\n&CNTR    SETA  &CNTR-1             FOR CONSISTENCY WITH ORIGINAL  MA02\n         MNOTE 12,'*** ERROR: INVALID LOGICAL OPERATER OCCURED AFTER PA-\n               RM &CNTR ***'\n         AGO   .CPARSX                                            MA03\n.EVEN#P  MNOTE 12,'*** ERROR: UNBALANCED (EVEN) NUMBER OF PARAMETERS **-\n               *'\n.**      AGO   .CPARSX                                            MA03\n.CPARSX  ANOP                                                     MA03\n         AGO   .EXIT\n.*\n.** ERROR MESSAGES\n.*\n.FIRSELS MNOTE 12,'*** ELSE AS FIRST CONDITION IS ILLEGAL ***'\n         AGO   .EXIT               GO TO .EXIT\n.IFIF    MNOTE 12,'***ERROR: IF IMMEDIATELY FOLLOWS IF OR DO***'\n.**      AGO   .EXIT               GO TO .EXIT\n.EXIT    MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\nCPPLRET  TITLE '- PROVIDE COMMAND PROCESSOR INTERFACE'\n***********************************************************************\n*  IF ONLY 1 INPUT PARAMETER\n*      IF RUNNING AS JST\n*          FAKE A CBUF, UPT, PSCB AND ECT\n*      ELSE\n*          FAKE A CBUF AND FIND THE REAL UPT, PSCB AND ECT\n*      ENDIF\n*      COPY THE PARM FIELD INTO THE CBUF\n*  ENDIF\n*  EXIT TO XXXXXXXX\n***********************************************************************\nCPPLRET  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING PSA,R0\n         RG    (RBASE,CPPLRET)\n         CNAENTER RBASE,ENTRY=NO,RENT=NOSAVE\n         USING SAVEAREA,R13\n         L     RTCB,PSATOLD      ADDRESS OUR TCB\n         RG    (RTCB,TCB)\n         SPACE 1\n         RG    (RPARM,PARM),RPARMLEN\n         ICM   RPARM,B'1111',0(R1)\n         IF    M                 IF ONLY 1 PARAM\n             LH    RPARMLEN,PARM\n             IF    (CL,RTCB,TCBJSTCB,E)  IS THIS THE JOB STEP TASK?\n                 RF    RTCB\n                 DC    H'0'          NOT YET SUPPORTED\n             ENDIF\n             LA    R0,WORKLEN(RPARMLEN)\n             GETMAIN R,LV=(0)\n             LR    RW,R1\n             RG    (RW,WORKAREA)\n             SPACE 1\n             MVC   EXTRLIST,PROTEXTR\n             EXTRACT EXTRANS,MF=(E,EXTRLIST) CHANGES R14\n             L     R1,EXTRANS\n             USING PSCB,R1\n             SPACE 1\n             LA    R15,CBUF      SET UP CPPL: CBUF, UPT, PSCB, ECT\n             L     R2,PSCBRLGB   ADDRESS THE RELOGON BUFFER\n             L     R0,PSCBUPT\n             L     R2,256(,R2)   GET ECT ADDRESS FROM WORD AFTER RLGB\n             USING ECT,R2\n             NI    ECTSWS,X'FF'-ECTNOPD\n             STM   R15,R2,WORKCPPL\n             DROP  R1\n             IF    (LTR,RPARMLEN,RPARMLEN,Z)\n                 OI    ECTSWS,ECTNOPD  TURN ON THE NO-OPERANDS SWITCH\n                 DROP  R2\n             ENDIF\n             LA    R0,4(,RPARMLEN)  SET THE CBUF LENGTH AND OFFSET\n             SLL   R0,16\n             ST    R0,CBUFLLOO\n             SPACE 1\n             LA    R0,CBUFCHAR   COPY THE PARM FIELD TO THE CBUF\n             LR    R1,RPARMLEN\n             LA    RPARM,2(,RPARM)\n             MVCL  R0,RPARM\n             RF    RPARM,RPARMLEN\n             LR    R1,RW         PASS CPPL ADDRESS IN REGISTER\n             RF    RW\n         ENDIF\n         LM    R14,R0,SAVEGR14   RESTORE R14 AND R0\n*        L     R15,=V(XXXXXXXX)  REPLACE THIS USING LINKAGE EDITOR\n         LM    R2,R12,SAVEGR02   RESTORE NON-LINKAGE REGISTERS\n         RF    RBASE\n*        BR    R15\n         BR    R14\n         TITLE '- CONSTANTS'\n         LTORG\nPROTEXTR EXTRACT FIELDS=PSB,MF=L\nPROTELEN EQU   *-PROTEXTR\n         TITLE '- DSECTS'\n         PRINT NOGEN\n         IKJCPPL\nLENCPPL  EQU   *-CPPL\n         SPACE 1\n         IHAPSA ,\n         IKJTCB ,\n         IKJPSCB ,\n         IKJECT ,\n         SPACE 2\nWORKAREA DSECT\nEXTRANS  DS    A\nEXTRLIST DS    XL(PROTELEN)\n         ORG   WORKAREA\nWORKCPPL DS    0F\n         ORG   WORKAREA+LENCPPL\nCBUF     DS    0H\nCBUFLLOO DS    0XL4\nCBUFLL   DS    H                 RDW LENGTH\nCBUFOO   DS    H                 OFFSETS\nCBUFCHAR DS    0C                COMMAND ITSELF\n         ORG\nWORKLEN  EQU   *-WORKAREA\n         SPACE 2\nPARM     DSECT\nPARMH    DS    H                 PARM FIELD LENGTH\nPARMCHAR DS    0C                PARM FIELD PROPER\n         SPACE 2\nSAVEAREA DSECT ,                 STANDARD OS 18-FULLWORD SAVE AREA\nSAVEWRD1 DS    F\nSAVEHSA  DS    A\nSAVELSA  DS    A\nSAVEGR14 DS    A\nSAVEGR15 DS    A\nSAVEGR00 DS    F\nSAVEGR01 DS    A\nSAVEGR02 DS    F\nSAVEGR03 DS    F\nSAVEGR04 DS    F\nSAVEGR05 DS    F\nSAVEGR06 DS    F\nSAVEGR07 DS    F\nSAVEGR08 DS    F\nSAVEGR09 DS    F\nSAVEGR10 DS    F\nSAVEGR11 DS    F\nSAVEGR12 DS    F\n         END   CPPLRET                                             RENT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATECNVT": {"ttr": 2052, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET 00MA2456   AT LEVEL 001 AS OF 06/11/75\nDATECNVT CSECT                                                          00001\n         TITLE '\"DATECNVT\" - DATE CONVERSION SUBROUTINE'                00002\n*********************************************************************** 00003\n*        THIS SUBROUTINE PERFORMS DATE CONVERSION AND DATE RETRIEVAL  * 00004\n* FOR THE INVOKING PROGRAM. ON ENTRY, REGISTER 1 MUST POINT TO A PARM * 00005\n* AREA WITHIN THE INVOKER'S STORAGE. THE CONTENTS OF THE 1ST THREE    * 00006\n* FIELDS INDICATE WHAT CONVERSION IS DESIRED:                         * 00007\n*                                                                     * 00008\n*        1. IF THE 1ST FIELD IN THE PARM LIST CONTAINS A NON-BINARY   * 00009\n*           ZERO VALUE, THEN THE SUBROUTINE ASSUMES THAT IT IS A VALID* 00010\n*           JULIAN DATE, AND PERFORMS ALL CONVERSIONS NECESSARY TO    * 00011\n*           FILL IN THE REST OF THE LIST.                             * 00012\n*        2. IF THE 1ST FIELD IS BINARY ZEROES, AND THE SECOND FIELD   * 00013\n*           CONTAINS A VALUE, THE SUBROUTINE CONVERTS THE SECOND FIELD* 00014\n*           (PACKED CALENDAR DATE), AND FILLS IN THE REST OF THE LIST,* 00015\n*           INCLUDING THE 1ST FIELD - (PACKED JULIAN DATE).           * 00016\n*        3. IF THE 1ST TWO FIELDS ARE BINARY ZERO, AND THE THIRD      * 00017\n*           CONTAINS A VALUE, THEN THE THIRD FIELD (PRINTABLE CALENDAR* 00018\n*           DATE) IS CONVERTED TO FILL IN THE REST OF THE FIELDS,     * 00019\n*           INCLUDING THE 1ST TWO.                                    * 00020\n*        4. IF ALL THREE OF THE 1ST FIELDS ARE BINARY ZERO,           * 00021\n*           IPL DATE IS RETRIEVED, AND THE ENTIRE LIST IS FILLED IN.  * 00022\n*        5. IF MORE THAN ONE OF THE 1ST THREE FIELDS CONTAINS A       * 00023\n*           VALID VALUE, THE SUBROUTINE PERFORMS CONVERSION ON THE    * 00024\n*           FIRST ONE ENCOUNTERED, AND OVERLAYS THE OTHER(S).         * 00025\n*                                                                     * 00026\n*        THE SUBROUTINE DOES PERFORM DATE CONTENT AND VALIDITY CHECK- * 00027\n* ING, AND WILL ISSUE THE FOLLOWING RETURN CODES IN REGISTER 15, ON   * 00028\n* RETURN TO THE INVOKING PROGRAM:                                     * 00029\n*                                                                     * 00030\n*        R15 = 0 MEANS SUCCESSFUL COMPLETION                          * 00031\n*        R15 = 4 MEANS INVALID DATE WAS PASSED; E.G. THE 32ND DAY OF  * 00032\n*                MONTH, JULIAN DATE OF 000, ETC. NO CONVERSION        * 00033\n*                HAS BEEN PERFORMED.                                  * 00034\n*        R15 = 8 MEANS THAT NON-NUMERIC DATE HAS BEEN PASSED IN A     * 00035\n*                FIELD; NO CONVERSION HAS BEEN PERFORMED.             * 00036\n*        R15 = 12 MEANS THAT THE PARM LIST WAS NOT DOUBLEWORD         * 00037\n*                ALIGNED; NO CONVERSION PERFORMED.                    * 00038\n*                                                                     * 00039\n*        THE PARM LIST PROVIDED BY THE INVOKING PROGRAM MUST HAVE     * 00040\n* THE FOLLOWING FORMAT, AND BE DOUBLEWORD ALIGNED:                    * 00041\n*                                                                     * 00042\n* PARMLIST DS    0D                                                   * 00043\n* PACKJUL  DC    PL3'YYDDD'        * PACKED JULIAN DATE; Y=YEAR, D=DAY* 00044\n* PACKCAL  DC    PL4'MMDDYY'       * PACKED CALENDAR DATE; E.G.       * 00045\n* *                                * PL4'123175'                      * 00046\n* PRNTCAL  DC    CL8'MM/DD/YY'     * PRINTABLE CALENDAR DATE; E.G.    * 00047\n* *                                * CL8'12/31/75' - YOU MUST CODE    * 00048\n* *                                * IN THE SLASHES                   * 00049\n* MNTHLNTH DS    XL1               * CONTAINS BINARY LENGTH OF NEXT   * 00050\n* *                                * FIELD, ON RETURN TO INVOKING PROG* 00051\n* MNTHNAME DS    CL9               ( CONTAINS NAME OF MONTH, LEFT     * 00052\n* *                                * JUSTIFIED, RIGHT BLANK FILLED ON * 00053\n* *                                * RETURN - E.G. C'APRIL    '       * 00054\n* DAYLNTH  DS    XL1               * BINARY LENGTH OF NEXT FIELD      * 00055\n* DAYNAME  DS    CL9               * NAME OF DAY OF WEEK, ON RETURN   * 00056\n* *                                * - E.G. C'SUNDAY   '              * 00057\n* WORK     DS    CL21              * WORK AREA                        * 00058\n*                                                                     * 00059\n*        THIS CODE IS REENTRANT AS IT STANDS. IF THE INVOKING PROG-   * 00060\n* RAM IS REENTRANT (INCLUDING THE PARM LIST PASSED TO THIS SUBROUTINE)* 00061\n* THEN THIS SUBROUTINE WILL NOT VIOLATE THAT REENTRANCY.  ON RETURN   * 00062\n* ALL OF THE INVOKING PROGRAMS REGISTERS WILL BE RETURNED INTACT,     * 00063\n* WITH THE EXCEPTION OF R15, WHICH IS USED TO PASS THE RETURN CODE.   * 00064\n*                                                                     * 00065\n*        - DENNIS BUSWELL, DEPT OF ADMIN, SYSTEMS TECH, 5/5/75        * 00066\n*                                                                     * 00067\n*********************************************************************** 00068\n         EJECT                                                          00069\n         USING *,R15               * ESTABLISH E.P REG AS BASE          00070\n         B     AROUNDID            * BRANCH AROUND                      00071\n         DC    C'DATECNVT'         *    I.D.                            00072\nAROUNDID STM   R14,R5,12(R13)      * SAVE INVOKER'S REGISTERS           00073\n         LR    R3,R1               * TRANSFER PARMLIST ADDRESS          00074\n         USING PARMLIST,R3         *    & ESTABLISH ADDRESSABILITY      00075\n         CLC   PACKJUL(15),=4F'0'  * DOES HE WANT IPL DATE ?            00076\n         BNE   CHCKPARM            * - NO, GO EDIT PARM FIELD           00077\n         LR    R4,R15              * - YES, SAVE OUR BASE REG           00078\n         TIME                                                           00079\n         LR    R15,R4              * RESTORE OUR BASE REG               00080\n         STCM  R1,7,PACKJUL        * FORCE DATE INTO JULIAN AREA        00081\n         SPACE 2                                                        00082\nCHCKPARM EQU   *                   * ROUTINE TO INSURE VALID DATA       00083\n*                                  * WAS PASSED                         00084\n         SR    R1,R1               * PRECLEAR R1                        00085\n         LR    R0,R3               * TRANSFER PARM LIST ADDRESS         00086\n         SRDL  R0,3                * SHIFT LOWEST ADDR BITS TO R1       00087\n         LTR   R1,R1               * WERE THEY ALL ZEROES ?             00088\n         BZ    DECODE              * - YES, CONTINUE ON                 00089\n         MVC   DOUB(2),=H'12'      * - NO, SET APPROPRIATE RETURN CODE  00090\n         B     RETURN              *    AND GO GET OUT                  00091\n         SPACE 2                                                        00092\nDECODE   EQU   *                   * ROUTINE TO FIND OUT WHAT           00093\n*                                  *    CONVERSION HE WANTS             00094\n         CLC   PACKJUL,=4F'0'      * IS JULIAN DATE CODED ?             00095\n         BNE   CNVTJUL             * - YES, GO EDIT IT                  00096\n         CLC   PACKCAL,=4F'0'      * HOW ABOUT PACKED CALENDAR ?        00097\n         BNE   CNVTCAL             * - YES, GO DO IT                    00098\n         SPACE 2                                                        00099\nCNVTPRNT MVC   WORK(2),PRNTCAL     * - MUST BE PRINTABLE CAL DATE       00100\n         MVC   WORK+2(2),PRNTCAL+3 *     SO LET'S PACK THE NUMERIC      00101\n         MVC   WORK+4(2),PRNTCAL+6 *        PORTION OF IT               00102\n         PACK  PACKCAL,WORK(6)     *           FOR EDIT SUBROUTINE      00103\n         SPACE 2                                                        00104\nCNVTCAL  LA    R1,PACKCAL          * POINT TO FIELD                     00105\n         BAL   R5,EDIT             *    AND GO EDIT IT                  00106\n         MVC   DOUB+6(2),PACKCAL+2 * PUT CAL YEAR INTO PARM AREA        00107\n         BAL   R5,TESTLEAP         *    & GO SET LEAP YR SWITCH         00108\n         BAL   R5,CALRANGE         * GO SEE IF THIS CAL DATE'S IN RANGE 00109\n         BAL   R5,CALTOPRT         * GO CNVRT PACKED CAL TO PRINTABLE   00110\n         BAL   R5,CALTOJUL         * GO CONVERT CAL TO JULIAN           00111\n         BAL   R5,BLDMONTH         * NOW GO BUILD NAME OF MONTH         00112\n         BAL   R5,BLDDAY           *    AND DAY FIELDS                  00113\n         B     GOODEND             *        AND GET OUT                 00114\n         SPACE 2                                                        00115\nCNVTJUL  EQU   *                                                        00116\n         NI    DOUB+4,0            * PRECLEAR 1ST BYTE OF FULLWORD      00117\n         MVC   DOUB+5(3),PACKJUL   * PUT PKD JULIAN INTO WORK AREA      00118\n         LA    R1,DOUB+4           * POINT TO IT,                       00119\n         BAL   R5,EDIT             *    AND GO EDIT IT                  00120\n         SR    R1,R1               * PRECLEAR WORK REG                  00121\n         IC    R1,PACKJUL          * PICK UP JULIAN YEAR                00122\n         SLL   R1,4                * MAKE ROOM FOR SIGN                 00123\n         STH   R1,DOUB+6           *   AND PUT YEAR IN PARM AREA        00124\n         BAL   R5,TESTLEAP         *        THEN GO SET LEAP SWITCH     00125\n         MVC   DOUB+6(2),PACKJUL+1 * PUT JULIAN DAYS INTO WORK AREA     00126\n         CVB   R1,DOUB             * CONVERT JULIAN DAYS                00127\n         STH   R1,BNRYJDAY         * SAVE IT FOR LATER                  00128\n         LTR   R1,R1               * IS JULIAN DATE ZERO ?              00129\n         BZ    BADJUL              * - YES, GO SET R.C. AND GET OUT     00130\n         LA    R2,365              * PRELOAD # OF DAYS IN REG YEAR      00131\n         AH    R2,LEAPSAVE         * ADD IN ANY LEAPYEAR ADJUSTMENT     00132\n         CR    R1,R2               * IS JULIAN IN RANGE ?               00133\n         BNH   JULIANOK            * - YES, CONTINUE                    00134\nBADJUL   MVC   DOUB(2),=H'4'       * - NO, SET RETURN CODE              00135\n         B     RETURN              *    AND GET OUT NOW                 00136\n         SPACE 1                                                        00137\nJULIANOK BAL   R5,JULTOCAL         * GO CONVERT JULIAN TO PACKED CAL    00138\n         BAL   R5,CALTOPRT         *    AND THEN CAL TO PRTABLE CAL     00139\n         BAL   R5,BLDMONTH         *        THEN NAME OF MONTH AND      00140\n         BAL   R5,BLDDAY           *            YEAR FIELDS             00141\n         SPACE 5                                                        00142\nGOODEND  XC    DOUB(2),DOUB        * SET RETURN CODE =0 - EVERYTHING OK 00143\n         SPACE 1                                                        00144\nRETURN   LM    R14,R5,12(R13)      * NOW RESTORE ALL OF INVOKER'S REGS  00145\n         DROP  R3                  * CHANGE BASE REGS FOR PARM LIST     00146\n         USING PARMLIST,R1         *    BACK TO R1                      00147\n         LH    R15,DOUB            * LOAD RETURN CODE,                  00148\n         BR    R14                 *    AND RETURN TO INVOKING PROGRAM  00149\n         DROP  R1                  * NOW REESTABLISH ADDRESSABILITY     00150\n         USING PARMLIST,R3         *    FOR \"PARMLIST\" WITH R3 FOR      00151\n*                                  *        REMAINDER OF CODE           00152\n         EJECT                                                          00153\n         SPACE 5                                                        00154\n**************************** SUBROUTINES ****************************** 00155\n         SPACE 3                                                        00156\nTESTLEAP EQU   *             ******* SUBROUT TO SET LEAP YR SWITCH      00157\n         MVC   LEAPSAVE,=H'1'      * PRESET SWITCH TO \"IT'S LEAP YEAR\"  00158\n         NC    DOUB,=X'0000000000000FF0' * \"AND\" OUT EXTRANEOUS BITS    00159\n         OI    DOUB+7,X'0F'        * FORCE IN PACKED SIGN               00160\n         CVB   R1,DOUB             * CONVERT IT TO BINARY               00161\n         STC   R1,DOUB+7           *   THEN PUT IT BACK FOR TESTING     00162\n         TM    DOUB+7,B'00000011'  * IS IT LEAP YEAR ?                  00163\n         BZR   R5                  * - YES, GET OUT - WE'RE ALL SET     00164\n         NI    LEAPSAVE+1,0        * - NO, RESET LEAP SWITCH            00165\n         BR    R5                  *    AND GET OUT                     00166\n         SPACE 5                                                        00167\nBLDMONTH EQU   *              ****** SUBROUTINE TO BUILD NAME OF MONTH  00168\n         LH    R1,BNRYMNTH         *    & PICK UP MONTH # IN BINARY     00169\n         BCTR  R1,0                * ADJUST FOR TABLE                   00170\n         MH    R1,=H'10'           * MULTIPLY BY TABLE ENTRY LENGTH     00171\n         LA    R1,MONTHTAB(R1)     * GET ADDR OF ENTRY WE WANT          00172\n         MVC   MNTHLNTH(L'MNTHLNTH+L'MNTHNAME),0(R1) * MOVE IT INTO     00173\n*                                  * USERS PARM FIELD                   00174\n         BR    R5                  * RETURN TO POINT OF INVOCATION      00175\n         SPACE 5                                                        00176\nCALTOPRT EQU   *              ****** SUBROUTINE TO CONVERT PACKED CAL   00177\n*                                  *    DATE TO PRINTABLE CALENDAR      00178\n         MVC   WORK(10),=X'40202020612020612120' * MOVE IN EDIT PATT    00179\n         ED    WORK(10),PACKCAL    * EDIT PACKED CAL DATE TO PRTABLE    00180\n         MVC   PRNTCAL,WORK+2      * MOVE RESULT INTO USER PARM FIELD,  00181\n         BR    R5                  *    AND RETURN TO POINT OF INVOC    00182\n         SPACE 5                                                        00183\nJULTOCAL EQU   *              ****** SUBROUT TO CALC CAL DATE FROM JUL  00184\n         LH    R1,BNRYJDAY         * PICK UP BINARY JULIAN DATE         00185\n         LH    R2,LEAPSAVE         *    & LEAP YEAR INDICATOR           00186\n         MH    R2,TABLNGTH         * MULTIPLY BY TABLE LENGTH           00187\n         LA    R2,REGYEAR(R2)      *    & GET ADDR OF APPROP TABLE      00188\n         LA    R4,1                * PRELOAD OUR MONTH COUNTER          00189\n         SPACE 1                                                        00190\nLOOPIT   CH    R1,2(R2)            * IS JULIAN GRTR = TABLE VALUE ?     00191\n         BNH   GOTCHA              * - YES, GET OUT                     00192\n         LA    R4,1(R4)            * - NO, ADD 1 TO MONTH COUNT         00193\n         LA    R2,2(R2)            *    POINT TO NEXT ENTRY             00194\n         B     LOOPIT              *        & GO TRY AGAIN              00195\n         SPACE 1                                                        00196\nGOTCHA   SH    R1,0(R2)            * SUBTRACT TABLE ENTRY FROM JULIAN   00197\n*                                  *    TO GET DAY OF MONTH             00198\n         STH   R4,BNRYMNTH         * SAVE BINARY MONTH # FOR LATER      00199\n         MH    R4,=H'10000'        * SHIFT MONTH OVER 4 DEC PLACES      00200\n         MH    R1,=H'100'          * SHIFT DAYS OVER 2                  00201\n         AR    R4,R1               * CONCATENATE MONTH AND DAYS         00202\n         SR    R1,R1               * PRECLEAR WORK REG                  00203\n         IC    R1,PACKJUL          * PICK UP YEAR                       00204\n         SLL   R1,4                * MAKE ROOM FOR SIGN                 00205\n         ST    R1,DOUB+4           * STORE RESULT                       00206\n         OI    DOUB+7,X'0F'        * FORCE IN SIGN                      00207\n         CVB   R1,DOUB             * CONVERT IT                         00208\n         AR    R1,R4               * CONCATENATE MONTH, DAY, YEAR       00209\n         CVD   R1,DOUB             * CONVERT RESULT                     00210\n         MVC   PACKCAL,DOUB+4      *    AND PUT IT IN USER'S PARM LIST  00211\n         BR    R5                  * RETURN TO POINT OF INVOCATION      00212\n         SPACE 5                                                        00213\nCALTOJUL EQU   *              ****** CALENDAR TO JULIAN CONVERS SUBRT   00214\n         L     R1,PACKCAL          * PICK UP PACKED CALENDAR DATE       00215\n         SRL   R1,4                * GET RID OF SIGN                    00216\n         STC   R1,PACKJUL          *    & PUT YEAR IN JULIAN AREA       00217\n         LH    R1,BNRYMNTH         * GET MONTH FROM CAL YEAR            00218\n         LH    R2,LEAPSAVE         * PICK UP LEAP YEAR INDICATOR        00219\n         MH    R2,TABLNGTH         * MULTIPLY BY TABLE LENGTH           00220\n         LA    R2,REGYEAR(R2)      *    & GET ADDR OF APPROP TABLE      00221\n         SPACE 5                                                        00222\n         BCTR  R1,0                * ADJUST TO BEGIN OF TABLE           00223\n         SLL   R1,1                * MULTIPLY R1 BY TABLE ENTRY LNGTH   00224\n         LH    R2,0(R2,R1)         * PICK UP ENTRY FROM TABLE           00225\n         AH    R2,BNRYCDAY         * PICK UP MONTH # IN BINARY          00226\n         STH   R2,BNRYJDAY         * STORE JULIAN DATE FOR LATER        00227\n         CVD   R2,DOUB             * CONVERT IT BACK                    00228\n         MVC   PACKJUL+1(2),DOUB+6 *    & PUT RESULT IN PARM LIST       00229\n         BR    R5                  * RETURN TO POINT OF INVOCATION      00230\n         SPACE 5                                                        00231\nBLDDAY   EQU   *              ****** SUBROUT TO BUILD NAME OF DAY       00232\n*                                  *    OF WEEK                         00233\n         MVC   WORK(2),CENTURY     * PUT CENTURY AND                    00234\n         MVC   WORK+2(2),PRNTCAL+6 *    YEAR IN WORK AREA               00235\n         PACK  DOUB,WORK(4)        * PACK THEM                          00236\n         CVB   R1,DOUB             *    & CONVERT THEM                  00237\n         ST    R1,WORK             * SAVE THIS VALUE                    00238\n         BCTR  R1,0                * BACK OFF 1 TO GET CENT-YEAR - 1    00239\n         LR    R2,R1               * SAVE THIS, TOO                     00240\n         SRL   R1,2                * DIVIDE CENT-YEAR -1 / 4            00241\n         LR    R14,R1              * SAVE THIS                          00242\n         LR    R1,R2               * RESTORE CENT-YEAR - 1              00243\n         SR    R0,R0               * PRECLEAR EVEN DIVIDE REG           00244\n         D     R0,=F'400'          * DIVIDE IT BY 400                   00245\n         LR    R4,R1               * SAVE RESULT                        00246\n         SR    R0,R0               * RECLEAR EVEN DIVIDE REG            00247\n         LR    R1,R2               * RESTORE  CENT-YEAR - 1             00248\n         D     R0,=F'100'          * DIVIDE IT BY 100                   00249\n         LH    R0,BNRYJDAY         * PICK UP JULIAN DAY IN BINARY       00250\n         A     R0,WORK             * ADD CENT-YEAR TO JULIAN            00251\n         AR    R0,R4               * ADD IN CENT-YEAR - 1 / 400         00252\n         AR    R0,R14              * ADD IN CENT-YEAR - 1 / 4           00253\n         SR    R0,R1               * SUBTRACT CENT-YEAR - 1 / 100       00254\n         LR    R1,R0               * TRANSFER TO ODD DIVIDE REG         00255\n         SR    R0,R0               * PRECLEAR EVEN DIVIDE REG           00256\n         D     R0,=F'7'            * DIVIDE BY SEVEN                    00257\n         LR    R1,R0               * GET REMAINDER OUT OF R0            00258\n         MH    R1,=H'10'           * MULTIPLY BY TABLE ENTRY LNGTH      00259\n         LA    R1,DAYTAB(R1)       * GET ADDRESS OF OUR ENTRY           00260\n         MVC   DAYLNTH(L'DAYLNTH+L'DAYNAME),0(R1) * MOVE RESULT TO      00261\n*                                  *    USER PARM LIST                  00262\n         BR    R5                  * RETURN TO POINT OF INVOCATION      00263\n         SPACE 5                                                        00264\nEDIT     EQU   *              ****** SUBROUT TO CHECK FOR VALID PACKED  00265\n*                                  *    DATA IN A 4 BYTE FIELD POINTED  00266\n*                                  *        TO BY R1 AT ENTRY           00267\n         TM    3(R1),B'00001100'   * 1ST TWO DIGITS OF SIGN VALID ?     00268\n         BNO   BADDIGIT            * - NO, GO SET R.C. & GET OUT        00269\n         TM    3(R1),B'00000011'   * HOW ABOUT LAST TWO ?               00270\n         BM    BADDIGIT            * - NO, DO LIKEWISE                  00271\n         L     R0,0(R1)            * LOAD PACKED DATA INTO R1           00272\n         SRL   R0,4                * SHIFT OUT PACKED SIGN              00273\n         SPACE 1                                                        00274\nEDLOOP   SR    R1,R1               * PRECLEAR ODD REGISTER              00275\n         SRDL  R0,4                * SHIFT ONE PACKED DIGIT INTO R1     00276\n         CL    R1,=X'90000000'     * IS DIGIT GREATER THAN 9 ?          00277\n         BH    BADDIGIT            * - YES, GO SET R.C. & GET OUT       00278\n         LTR   R0,R0               * ARE WE OUT OF DIGITS ?             00279\n         BNZ   EDLOOP              * - NO, KEEP IT UP                   00280\n         BR    R5                  * - YES, RETURN TO POINT OF INVOC    00281\n         SPACE 1                                                        00282\nBADDIGIT MVC   DOUB(2),=H'8'       * SET RETURN CODE TO APPROPIATE      00283\n         B     RETURN              *    VALUE & GO GET OUT              00284\n         SPACE 5                                                        00285\nCALRANGE EQU   *              ****** SUBROUTINE TO VALIDATE DAY OF      00286\n*                                  * MONTH - MAKE SURE THAT THE 32ND    00287\n*                                  * OF FEBRUARY HAS NOT BEEN PASSED    00288\n         XC    DOUB(6),DOUB        * PRECLEAR WORK AREA                 00289\n         MVC   DOUB+6(2),PACKCAL   * PUT X'0MMD' IN WORK AREA           00290\n         OI    DOUB+7,X'0F'        * FORCE IN PACKED SIGN               00291\n         CVB   R1,DOUB             * CONVERT IT                         00292\n         CH    R1,=H'12'           * IS MONTH GRTR THAN 12 ?            00293\n         BH    BADMONTH            * - YES, IT'S BAD                    00294\n         LTR   R1,R1               * IS MONTH ZERO ?                    00295\n         BZ    BADMONTH            * - YES, GO SET R.C. & END           00296\n         STH   R1,BNRYMNTH         * SAVE BINARY MONTH #                00297\n         BCTR  R1,0                * ADJUST REG TO BEGIN OF TABLE       00298\n         SR    R0,R0               * PRECLEAR WORK REG                  00299\n         IC    R0,VALIDTAB(R1)     * PICK UP ENTRY                      00300\n         MVC   DOUB+6(2),PACKCAL+1 * MOVE IN PASSED CAL DAY             00301\n         OI    DOUB+7,X'0F'        * FORCE IN PACKED SIGN               00302\n         NI    DOUB+6,X'0F'        * \"AND\" OUT LAST DIGIT OF MONTH      00303\n         CVB   R2,DOUB             * CONVERT IT                         00304\n         STH   R2,BNRYCDAY         * SAVE IT FOR LATER                  00305\n         CH    R1,=H'1'            * IS IT  FEB ?                       00306\n         BNE   NOTLEAP             * - YES, DON'T ADJUST TABLE          00307\n         AH    R0,LEAPSAVE         * - NO, ADD IN ANY LEAP YR ADJUST.   00308\nNOTLEAP  CR    R2,R0               * IS OUR DAY OF YEAR TO LARGE ?      00309\n         BNHR  R5                  * - NO, RETURN CLEAN                 00310\n         SPACE 1                                                        00311\nBADMONTH MVC   DOUB(2),=H'4'       * - YES, SET APPROPRIATE RETURN CODE 00312\n         B     RETURN              *    AND GO GET OUT NOW              00313\n         EJECT                                                          00314\n***********************  CONSTANTS, TABLES, ETC **********************  00315\n         SPACE 3                                                        00316\nCENTURY  DC    C'19'               * CURRENT CENTURY                    00317\n         SPACE 3                                                        00318\nTABLNGTH DC    AL2(ENDREGYR-REGYEAR) * LENGTH OF TABLE \"REGYEAR\"        00319\n         SPACE 3                                                        00320\nREGYEAR  DC    H'0'                * REGULAR YEAR JULIAN TABLE          00321\n         DC    H'31'               *                                    00322\n         DC    H'59'               *                                    00323\n         DC    H'90'               *                                    00324\n         DC    H'120'              *                                    00325\n         DC    H'151'              *                                    00326\n         DC    H'181'              *                                    00327\n         DC    H'212'              *                                    00328\n         DC    H'243'              *                                    00329\n         DC    H'273'              *                                    00330\n         DC    H'304'              *                                    00331\n         DC    H'334'              *                                    00332\n         DC    H'365'              *                                    00333\nENDREGYR EQU   *                   * END OF ABOVE TABLE                 00334\n         SPACE 3                                                        00335\nLEAPYEAR DC    H'0'                * LEAP YEAR JULIAN TABLE             00336\n         DC    H'31'               *                                    00337\n         DC    H'60'               *                                    00338\n         DC    H'91'               *                                    00339\n         DC    H'121'              *                                    00340\n         DC    H'152'              *                                    00341\n         DC    H'182'              *                                    00342\n         DC    H'213'              *                                    00343\n         DC    H'244'              *                                    00344\n         DC    H'274'              *                                    00345\n         DC    H'305'                                                   00346\n         DC    H'335'              *                                    00347\n         DC    H'366'              *                                    00348\n         SPACE 3                                                        00349\nDAYTAB   EQU   *                   * DAY OF WEEK TABLE                  00350\n         DC    X'08',C'SATURDAY '  * LENGTH OF ENTRY AND ENTRY ITSELF   00351\n         DC    X'06',C'SUNDAY   '  *                                    00352\n         DC    X'06',C'MONDAY   '  *                                    00353\n         DC    X'07',C'TUESDAY  '  *                                    00354\n         DC    X'09',C'WEDNESDAY'  *                                    00355\n         DC    X'08',C'THURSDAY '  *                                    00356\n         DC    X'06',C'FRIDAY   '  *                                    00357\n         SPACE 3                                                        00358\nMONTHTAB EQU   *                   * NAME OF MONTH TABLE                00359\n         DC    X'07',C'JANUARY  '  *                                    00360\n         DC    X'08',C'FEBRUARY '  *                                    00361\n         DC    X'05',C'MARCH    '  *                                    00362\n         DC    X'05',C'APRIL    '  *                                    00363\n         DC    X'03',C'MAY      '  *                                    00364\n         DC    X'04',C'JUNE     '  *                                    00365\n         DC    X'04',C'JULY     ' *                                     00366\n         DC    X'06',C'AUGUST   '  *                                    00367\n         DC    X'09',C'SEPTEMBER'  *                                    00368\n         DC    X'07',C'OCTOBER  '  *                                    00369\n         DC    X'08',C'NOVEMBER '  *                                    00370\n         DC    X'08',C'DECEMBER '  *                                    00371\n         SPACE 3                                                        00372\nVALIDTAB EQU   *                   * VALIDITY TABLE; CONTAINS LAST      00373\n*                                  *     VALID DAY OF EACH MONTH        00374\n         DC    FL1'31'             *                                    00375\n         DC    FL1'28'             *                                    00376\n         DC    FL1'31'             *                                    00377\n         DC    FL1'30'             *                                    00378\n         DC    FL1'31'             *                                    00379\n         DC    FL1'30'             *                                    00380\n         DC    FL1'31'             *                                    00381\n         DC    FL1'31'             *                                    00382\n         DC    FL1'30'             *                                    00383\n         DC    FL1'31'             *                                    00384\n         DC    FL1'30'             *                                    00385\n         DC    FL1'31'             *                                    00386\n         SPACE 3                                                        00387\n         LTORG                                                          00388\n         EJECT                                                          00389\n         SPACE 5                                                        00390\n***************************  DSECTS, EQUTES **************************  00391\n         SPACE 5                                                        00392\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         SPACE 3                                                        00394\nPARMLIST DSECT                     * DSECT FOR INVOKER'S PARM LIST      00395\nPACKJUL  DS    PL3                 * PACKED JULIAN DATE - P'YYDDD'      00396\nPACKCAL  DS    PL4                 * PACKED CALENDAR DATE - P'0MMDDYY'  00397\nPRNTCAL  DS    CL8                 * PRINTABLE CALENDAR DATE            00398\nMNTHLNTH DS    XL1                 * LENGTH OF MONTH NAME - BINARY      00399\nMNTHNAME DS    CL9                 * NAME OF MONTH - E.G. \"MARCH\"       00400\nDAYLNTH  DS    XL1                 * LENGTH OF NAME OF DAY - BINARY     00401\nDAYNAME  DS    CL9                 * NAME OF DAY - E.G. \"SUNDAY\"        00402\nWORK     DS    CL5                 * WORK AREA                          00403\nDOUB     DS    XL8                 * DOUBLEWORD WORK AREA               00404\nLEAPSAVE DS    XL2                 * LEAP YEAR INDICATOR; H'0' = NON-   00405\n*                                  * LEAP YEAR; H'1' = LEAP YEAR        00406\nBNRYJDAY DS    XL2                 * SAVE AREA FOR BINARY JULIAN DATE   00407\nBNRYMNTH DS    XL2                 *  \"     \"   \"     \"   MONTH #       00408\nBNRYCDAY DS    XL2                 *  \"     \"   \"     \" DAY OF MONTH    00409\n         END   DATECNVT                                                 00410\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDNLIST": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8412                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    WRITTEN AND MAINTAINED BY BRUCE LOMAR, BOB ZIMMERMAN             *\n*    CNA INSURANCE                                                    *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\n         MACRO\n         CNASEND\n         GBLC  &GBLSTRG                NAME OF STORAGE LENGTH\n         GBLC  &GBLSAVE                NAME OF SAVE AREA\n         GBLC  &GBLCNAM                NAME OF CSECT\n         GBLC  &GBLRENT                REENTRANCY OPTION\n         AIF   ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').DONE\n         AIF   ('&SYSECT' EQ '&GBLSAVE').GEN\n         SPACE 1\n&GBLSAVE DSECT ,                       RESUME SAVE AREA DSECT\n.GEN     ANOP\n         SPACE 1\nWORKEND$ DS    0D                      FORCE LENGTH TO DOUBLEWORD\n&GBLSTRG EQU   WORKEND$-&GBLSAVE       SET UP LENGTH EQUATE\n         SPACE 2\n&GBLCNAM CSECT ,                       RESUME CSECT\n.DONE    ANOP\n         MEND\n         MACRO\n         CNASTRG\n         GBLC  &GBLRENT\n         GBLC  &GBLSAVE\n         GBLC  &GBLWTG\n         GBLC  &GBLCESV            DEFINES SAVE AREA FOR NSL'S\n         AIF   ('&GBLRENT' EQ 'NO').DONE\n         AIF   ('&GBLRENT' EQ 'NOSAVE').DONE\n*\n*        WORK AREA DSECT BEGINNING WITH CNASTRG MACRO GENERATION\n*\n&GBLSAVE DSECT\n         DS    18F                 STANDARD SAVE AREA\n         AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').CCH\n         DS    F                   NEXT FREE STACK LOCATION\n         AGO   .DONE\n.CCH     AIF   ('&GBLRENT' NE 'COM' OR '&GBLWTG' EQ '').DONE\n&GBLWTG  DS    F                   NEXT EXECUTION ADDRESS\n.DONE    AIF   ('&GBLCESV' NE 'NSL').NONSL\n         DS    F                   DUMMY FOR STAE EXIT ROUTINE\n         DS    13F                 SAVE AREA FOR NSL ENTRY OPTION\n.NONSL   ANOP\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\nDDNLIST  TITLE 'SUBROUTINE: RETURN ALL ALLOCATED DDNAMES'\nDDNLIST  CSECT\n         RG    (RBASE,,12)\n         RG    (RCOUNT)\n         RG    (RARRAY)\n         RG    (RPARM)\n*                                                                     *\n*  TECHNICAL NOTES:                                                   *\n*     1. PROGRAM IS REENTRANT.                                        *\n*     2. RETURN-CODES:                                                *\n*              0 = SUCCESSFUL SEARCH (\"HITS\" FOUND).                  *\n*              4 = SUCCESSFUL SEARCH (\"HITS\" FOUND); ARRAY OVERFLOW.  *\n*              8 = UNSUCCESSFUL SEARCH (NO \"HITS\" FOUND).             *\n         EJECT\n*                                                                     *\n*     DDNLIST PARAMETERS ARE:                                         *\n*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *\n*                              DSNAMES FOUND)                         *\n*           ARRAY             (N X 8-BYTE ARRAY FOR DSNAMES)          *\n         CNAENTER RBASE,PARM=RPARM,RENT=YES,ENTRY=NO\n         XC    RC4,RC4\n         LM    RCOUNT,RARRAY,0(RPARM)        GRAB 3 ENTRY PARAMETERS\n         RF    RPARM                         FREE PARM-POINTER\n*              CLEAR RESULTS-ARRAY\n         RG    (RWORK1A),(RWORK1B)\n         RG    (RWORK2A),(RWORK2B)\n         XR    RWORK2A,RWORK2A\n         XR    RWORK2B,RWORK2B\n         ICM   RWORK2B,8,=C' '               BLANK-FILL CHAR\n         LH    RWORK1B,0(RCOUNT)             GET ARRAY COUNTER\n         LA    RWORK1A,8                     MULTIPLY BY 8\n         MR    RWORK1A,RWORK1A               MULTIPLY BY ARRAY COUNTER\n         LR    RWORK1A,RARRAY                SET ARRAY ADDRESS\n         MVCL  RWORK1A,RWORK2A               CLEAR RESULTS ARRAY\n*\n         RF    RWORK1A,RWORK1B\n         RF    RWORK2A,RWORK2B\n         RG    (RTALLY)\n*\n         SPACE 2\n         RG    (RTCB)                        TCB MAP\n         RG    (RTIOT)                       TIOT MAP\n         L     RTCB,540(R0)                  POINT TO TCBOLD\n         L     RTIOT,12(RTCB)                POINT TO TIOT (TCBTIO)\n         RF    RTCB                          DONE WITH TCB\n         RG    RTIOTLN                       TCB DDNAME ENTRY LENGTH\n         XR    RTIOTLN,RTIOTLN\n         LA    RTIOT,24(RTIOT)               POINT TO 1ST DDNAME ENTRY\n         XR    R0,R0                         CLEAR FOR RESULTS COUNT\n         LH    RTALLY,0(RCOUNT)              ARRAY COUNTER\n         LA    RTALLY,1(RTALLY)                PLUS 1 FOR BCT\n         SPACE 2\nDDLOOK   DS    0H\n         CLI   0(RTIOT),X'00'\n         BE    DONEDDN                       BR IF DDNAME NOT FOUND\n         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH\n         TM    1(RTIOT),X'80'                TEST FOR FREED TIOT ENTRY\n         BO    NEXTDDN                       BR IF FOUND\n         CLI   4(RTIOT),C' '                 TEST FOR CONCAT ENTRY\n         BNE   GOTDDN                        BR IF NOT CONCAT\nNEXTDDN  DS    0H\n         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY\n         B     DDLOOK\nGOTDDN   DS    0H\n         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT\n         B     NOROOM                        BR IF NO ROOM IN ARRAY\n         A     R0,=F'1'                      ADD TO \"HIT\" COUNT\n         MVC   0(8,RARRAY),4(RTIOT)          COPY DDNAME TO ARRAY\n         LA    RARRAY,8(RARRAY)              BUMP TO NEXT DDN SLOT\n         B     NEXTDDN                       LOOP TO NEXT ENTRY\n         EJECT\n*\n*** SEARCH ARRAY FILLED ... PREPARE FOR EXIT\n*\nNOROOM   DS    0H\n         RF    RTIOT,RTIOTLN\n         MVI   RC1,4                         SET OVERFLOW RETURN-CODE\nDONEDDN  DS    0H\n         STH   R0,0(RCOUNT)                  SAVE DSN COUNT\n         LTR   R0,R0                         ANY HITS?\n         BNZ   FASTEXIT                      BR IF YES\n         MVI   RC1,8                         SET NO-HIT RETURN-CODE\n         B     FASTEXIT\n         EJECT\n         RF    RTALLY,RCOUNT,RARRAY\n         EJECT\n*\n*** PROGRAM EXIT\n*\nFASTEXIT CNAEXIT RC4\n         TITLE '- CONSTANTS'\n         LTORG *\n         TITLE '- WORKING STORAGE'\n         CNASTRG\nRC4      DS    F\nRC1      EQU   RC4+3,1\n*\n         CNASEND\n         EJECT\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSINDEX": {"ttr": 2819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE '                           D A T A   S E T   I N D E X'\n***********************************************************************\n***                                                                 ***\n**  PROGNAME: DSINDEX                                                **\n**  PROGAUTH: DAVID ALCOCK                                           **\n**  PROGDATE: 04/14/85                                               **\n**                                                                   **\n**      THIS ISPF DIALOG ALLOWS A USER TO BROWSE OR EDIT DATA SETS   **\n**  FROM AN INDEX LIST.  THE USER IS FIRST PROMPTED FOR AN INDEX     **\n**  LEVEL.  THE PROGRAM WILL THEN SEARCH THROUGH THE CATALOG/CVOL    **\n**  TO FIND ENTRIES THAT MATCH THE SPECIFIED INDEX.  THE USER CAN    **\n**  THEN EDIT OR BROWSE A DATASET BY SELECTING IT FROM THE LIST.     **\n**                                                                   **\n**  EXTERNAL POINTS:                                                 **\n**           PROGRAM: LOCINDEX    *CVOL SEARCH*                      **\n**                    MINIXDMP    *MINI HEX DUMP*                    **\n**           PANELS:  DSINDX01    *POM*                              **\n**                    DSINDX02    *DATASET LIST*                     **\n**                    DSINDX03    *COMFIRM DATASET DELETE*           **\n**                    DSINDX04    *DATASET DSCB DISPLAY*             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nT_CON    EQU  CPYAREAL\nT_VAR    EQU  CPYTOL\n         EJECT\nDSINDEX  ENTER 'EDIT/BROWSE FROM INDEX LIST ... DAVID ALCOCK',         @\n               RENT=YES,              INDICATE WE WANT GETMAIN         @\n               LV=WORKDSL,            LENGTH TO GETMAIN                @\n               BASE=(12,11,10)        GRAP SOME BASE REGISTERS\n         USING WORKDS,R13             ADDRESSABILITY TO WORK AREA\n         PRINT NOGEN\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       INITIALIZATION SECTION                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n**  CLEAR GETMAINED WORK AREA TO BINARY ZEROS (EXCEPT REGISTERS)\n*\n         LA    R2,WORKDS+72             GET ADDR OF WORK AREA+RSA\n         LA    R3,WORKDSL-72            GET WORK AREA LENGTH-RSA\n         SLR   R5,R5                    SET LENGTH AND PAD TO ZERO\n         MVCL  R2,R4                    CLEAR WORK AREA TO ZEROS\n*\n**      COPY CONTANTS TO GETMAINED WORKAREA\n*\n         LA    R2,CPYTO                    GET ADDRESS TO INITALIZE\n         LA    R3,CPYAREAL                 GET LENGTH OF CPY AREA\n         LA    R4,CPYAREA                  LOCATE CONTANTS\n         LR    R5,R3                       GET LENGTH OF CPY AREA\n         MVCL  R2,R4                       COPY TO WORK AREA\n*\n**  ISSUE START MESSAGE\n*\n         MVC   LOGMSG1(8),=CL8'DSI@001A'\n         MVI   LOGMSG2,X'00'\n         MVC   FUNCT(8),=CL8'STARTED-'\n         BAL   R9,LOGMSG              ISSUE MESSAGE\n*\n** GET VARIABLES FROM PROFILE BEFORE DISPLAYING SCREEN\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'VGET',                                            @\n               =C'(DSILVL DSIVOL DSITAPE DSIDASD)',                    @\n               =CL8'PROFILE'),                                         @\n               VL,MF=(E,PARMLIST)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       DISPLAY FIRST PANEL                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDISPPOM  EQU   *\n*\n**  DISPLAY FIRST PANEL\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'DISPLAY',=CL8'DSINDX01'),                         @\n               VL,MF=(E,PARMLIST)\n         LTR   R15,R15            SEE IF END KEY WAS HIT\n         BZ    EPNL000            NO, CARRY ON\n*\n**  TERMINATE: END KEY HIT FROM POM (PRIMARY OPTION MENU)\n*\n         MVC   LOGMSG1(8),=CL8'DSI@001A'\n         MVI   LOGMSG2,X'00'\n         MVC   FUNCT(8),=CL8'ENDED---'\n         BAL   R9,LOGMSG              ISSUE MESSAGE\n         PRINT GEN\n         LEAVE RC=0\n         PRINT NOGEN\n*\n**  GET VALUES FROM ISPF INTO OUR PROGRAM DATA AREAS\n*\nEPNL000  EQU   *\n         LA    R15,44\n         ST    R15,DSILVLL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(DSILVL)',DSILVLL,DSILVL,=CL8'MOVE'),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,DSIVOLL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(DSIVOL)',DSIVOLL,DSIVOL,=CL8'MOVE'),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,3\n         ST    R15,DSITAPEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',                                           @\n               =C'(DSITAPE)',DSITAPEL,DSITAPE,=CL8'MOVE'),             @\n               VL,MF=(E,PARMLIST)\n         LA    R15,3\n         ST    R15,DSIDASDL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',                                           @\n               =C'(DSIDASD)',DSIDASDL,DSIDASD,=CL8'MOVE'),             @\n               VL,MF=(E,PARMLIST)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       FIGURE OUT WHAT WE ARE GONNA DO                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** EITHER DASD OR TAPE MUST BE YES\n*\n         CLC   DSITAPE(3),=CL3'YES'\n         BE    INIT000\n         CLC   DSIDASD(3),=CL3'YES'\n         BE    INIT000\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(21),=C'CONFLICT AT TAPE/DASD'\n         MVC   DSIMSGL(31),=C'MUST HAVE A YES IN TAPE OR DASD'\n         LA    R0,21\n         LA    R1,31\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         B     DISPPOM\nINIT000  EQU   *\n* I WAS GOING TO ADD A \"READVTOC\" ROUTINE BUT WE ARE ABOUT TO GET\n* ISPF VERSION 2 WHICH OBSOLETES MOST OF THIS PROGRAM.\n         B     READCVOL\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       DISPLAY THE DSNAME TABLE                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDSNLOOP  EQU   *\n         MVC   TSEL(7),=CL7' '            SET TO BLANKS\n         CLI   MSGID,X'00'                IS THERE A MESSAGE WAITING?\n         BE    DSNLOOPN                   NO, MOVE ON\n         CLI   MSGID,C' '                 IS THERE A MESSAGE WAITING?\n         BE    DSNLOOPN                   NO, MOVE ON\n         CALL  ISPLINK,                                                @\n               (=CL8'TBDISPL',=CL8'DSINDEX',=CL8'DSINDX02',MSGID),     @\n               VL,MF=(E,PARMLIST)\n         MVI   MSGID,X'00'\n         B     DSNLOOPR\nDSNLOOPN EQU   *\n         CALL  ISPLINK,                                                @\n               (=CL8'TBDISPL',=CL8'DSINDEX',=CL8'DSINDX02'),           @\n               VL,MF=(E,PARMLIST)\nDSNLOOPR EQU   *\n         LTR   R15,R15                 DID USER HIT THE END KEY\n         BZ    SELKTDSN                NO, HE SELECTED A DATASET\n         C     R15,=F'4'               DID HE SELECT MORE THAN 1\n         BE    SELKTDSN                YES, MOVE ON\n         CALL  ISPLINK,                                                @\n               (=CL8'TBEND',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n         B     DISPPOM\n*\nSELKTDSN EQU   *\n         BAL   R9,ROWPROC                 GET ISPF DATA FOR ROW\n*\n*        CHECK FOR VALID INPUT\n*\n         OC    TSEL(7),=CL7' '            CONVERT TO UPPERCASE\n         CLC   TSEL(3),=CL3'DEL'\n         BE    DELETE\n         CLC   TSEL(5),=CL5'UNCAT'\n         BE    UNCAT\n         CLC   TSEL(7),=CL7'SCRATCH'\n         BE    SCRATCH\n         CLI   TSEL,C'?'\n         BE    GETDSCB\n         CLI   TSEL,C'S'\n         BE    BROWSEIT\n         CLI   TSEL,C'E'\n         BE    EDIT\n         CLC   TSEL(4),=CL4'EDIT'\n         BE    EDIT\n         CLI   TSEL,C'B'\n         BE    BROWSEIT\n         CLC   TSEL(6),=CL6'SELECT'\n         BE    BROWSEIT\n*\n*        IF TSEL HAS SOMETHING, THAT SOMETHING IS INVALID\n*\n         L     R1,TSELL                   GET LENGTH\n         LTR   R1,R1                      CHECK LENGTH\n         BNZ   INVALIDS                   NOT ZERO, WHATS UP DOC\n         B     CHKCMDL                    OTHERWISE, CHECK COMMAND LINE\n*\n*        INVALID SELECTION FOUND\n*\nINVALIDS EQU   *\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(22),=C'INVALID SELECTION CODE'\n         MVC   DSIMSGL(19),=C'INVALID SELECTION:'\n         MVC   DSIMSGL+21(4),TSEL\n         LA    R0,22\n         LA    R1,30\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         B     DSNLOOP                               TRY AGAIN\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       EDIT THE DATASET                                            **\n***                                                                 ***\n***********************************************************************\nEDIT     EQU   *\n         CLI   TYPE,C'T'\n         BE    EDITERR\n*\n**   PUT TICKS AROUND DATASET NAME\n*\n         BAL   R9,DSNAMEED\n*\n**   TURN OFF ISPF ERROR HANDLING, SO THAT WE HAVE CONTROL\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),              @\n               VL,MF=(E,PARMLIST)\n*\n**   EDIT THE DATASET\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'EDIT',EDDSN),                                     @\n               VL,MF=(E,PARMLIST)\n         C     R15,=F'5'\n         BL    EDIT000\n         MVC   MSGID(8),=CL8'DSI@003A'   TURN ON IBM MESSAGS\n         BAL   R9,SETMSGI                IBM ISPF MESSAGES\nEDIT000  EQU   *\n*\n**   TURN ON ISPF ERROR HANDLING\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'CONTROL',=CL8'ERRORS',=CL8'CANCEL'),              @\n               VL,MF=(E,PARMLIST)\n         MVC   LASTA(11),=CL11'EDITED'\nEDITX    EQU   *\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'TBMOD',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n*\n**   LOG MESSAGE\n*\n         MVC   FUNCT(8),=CL8'EDIT----'\n         MVC   LOGMSG1(8),=CL8'DSI@002C'\n         MVI   LOGMSG2,X'00'\n         BAL   R9,LOGMSG              ISSUE MESSAGE\n         MVC   LOGMSG1(8),=CL8'DSI@002A'\n         MVC   LOGMSG2(8),=CL8'DSI@002B'\n         B     DSNLOOP                 GO BACK TO DSN SELECTION LIST\nEDITERR  EQU   *\n         MVC   MSGID(8),=CL8'DSI@000A'\n         MVC   LASTA(11),=CL11'\u00ac EDITED'\n         MVC   DSIMSGS(18),=C'CAN NOT EDIT TAPES'\n         MVC   DSIMSGL(31),=C'ISPF CAN NOT EDIT TAPE DATASETS'\n         LA    R0,18\n         LA    R1,31\n         BAL   R9,SETMSG\n         B     EDITX\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       BROWSE THE DATASET                                          **\n***                                                                 ***\n***********************************************************************\nBROWSEIT EQU   *\n         CLI   TYPE,C'T'\n         BE    BROWSEER\n*\n**   PUT TICKS AROUND DATASET NAME\n*\n         BAL   R9,DSNAMEED\n*\n**   TURN OFF ISPF ERROR HANDLING, SO THAT WE HAVE CONTROL\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'CONTROL',=CL8'ERRORS',=CL8'RETURN'),              @\n               VL,MF=(E,PARMLIST)\n*\n**   BROWSE THE DATASET\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'BROWSE',EDDSN),                                   @\n               VL,MF=(E,PARMLIST)\n         C     R15,=F'5'\n         BL    BROWSE0\n         MVC   MSGID(8),=CL8'DSI@003A'   TURN ON IBM MESSAGS\n         BAL   R9,SETMSGI                IBM ISPF MESSAGES\nBROWSE0  EQU   *\n*\n**   TURN ON ISPF ERROR HANDLING\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'CONTROL',=CL8'ERRORS',=CL8'CANCEL'),              @\n               VL,MF=(E,PARMLIST)\n         MVC   LASTA(11),=CL11'BROWSED'\nBROWSEX  EQU   *\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'TBMOD',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n*\n**   LOG MESSAGE\n*\n         MVC   FUNCT(8),=CL8'BROWSE--'\n         MVC   LOGMSG1(8),=CL8'DSI@002C'\n         MVI   LOGMSG2,X'00'\n         BAL   R9,LOGMSG              ISSUE MESSAGE\n         MVC   LOGMSG1(8),=CL8'DSI@002A'\n         MVC   LOGMSG2(8),=CL8'DSI@002B'\n         B     DSNLOOP                 GO BACK TO DSN SELECTION LIST\nBROWSEER EQU   *\n         MVC   MSGID(8),=CL8'DSI@000A'\n         MVC   LASTA(11),=CL11'\u00ac BROWSED'\n         MVC   DSIMSGS(20),=C'CAN NOT BROWSE TAPES'\n         MVC   DSIMSGL(33),=C'ISPF CAN NOT BROWSE TAPE DATASETS'\n         LA    R0,20\n         LA    R1,33\n         BAL   R9,SETMSG\n         B     BROWSEX\n         EJECT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GET DSCB AND THEN DISPLAY INFO                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nGETDSCB  EQU   *\n         CLI   TYPE,C'T'                  TAPE DATASET?\n         BE    DSNLOOP                    YES, FORGET IT\n*\n         MVC   FUNCT(8),=CL8'SHOW DS-'    FUNCTION\n         MVC   LOGMSG1(8),=CL8'DSI@002C'\n         MVI   LOGMSG2,X'00'              DISABLE SECOND MESSAGE\n         BAL   R9,LOGMSG                  ISSUE MESSAGE\n         MVC   LOGMSG1(8),=CL8'DSI@002A'\n         MVC   LOGMSG2(8),=CL8'DSI@002B'\n         BAL   R9,OBDSCB                  OBTAIN DSCB INFO\n         BAL   R9,SHOWDSCB                SHOW DSCB INFO\n         CALL  ISPLINK,                                                @\n               (=CL8'DISPLAY',=CL8'DSINDX04'),                         @\n               VL,MF=(E,PARMLIST)\n         MVC   LASTA(11),=CL11'* DS INFO *'\nGETDX    EQU   *\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'TBMOD',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n         B     DSNLOOP                    GET NEXT COMMAND\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       OBTAIN FORMAT1 DSCB                    .                    **\n***                                                                 ***\n***********************************************************************\n         SPACE  2\nOBDSCB   EQU   *\n         LA    R1,DSNAME                  -----+\n         ST    R1,FINDDSCB+4                   |\n         LA    R1,VOLSER                       | SET UP DYNAMIC\n         ST    R1,FINDDSCB+8                   | CAMLST PARM LIST\n         LA    R1,AREADSCB                     |\n         ST    R1,FINDDSCB+12             -----+\n         OBTAIN FINDDSCB                  GET FORMAT 1 DSCB\n         LTR   R15,R15                    WAS IT SUCESSFULL?\n         BZ    OBDSCBX                    YEA, MOVE ON\n         MVC   MSGID(8),=CL8'DSI@000C'\n         MVC   LASTA(11),=CL11'\u00ac SHOWN'\n         MVC   DSIMSGS(17),=C'CAN''T OBTAIN DSCB'\n         MVC   DSIMSGL(25),=C'OBTAIN OF F1DSCB FAILED RC='\n         LA    R6,DSIMSGL+25              LOCATE OUTPUT LOCATION\n         LR    R0,R15                     GET RC\n         BAL   R14,EDREG0                 CONVERT RC\n         LA    R0,17                      LENGTH OF DSIMSGS\n         LR    R1,R6                      GET END OF DSIMSGL\n         LA    R15,DSIMSGL                GET BEGINNING OF DSIMSGL\n         SR    R1,R15                     LENGTH OF DSIMSGL = END-BEG\n         LA    R15,20                     SET NON-ZERO RETURN CODE\nOBDSCBX  EQU   *\n         BR    R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       MODIFY DATASET: DELETE, SCRATCH UNCAT...                    **\n***                                                                 ***\n***********************************************************************\nDELETE   EQU   *\n         OI    EXECFLAG,$DELETE\nSCRATCH  EQU   *\n         MVC   FUNCT(8),=CL8'SCRATCH-'\n         BAL   R9,OBDSCB\n         LTR   R15,R15                    SUCCESSFULL?\n         BZ    DELDSFND                   YES, MOVE ON\n         MVC   LASTA(11),=CL11'\u00ac SCRATCHED'\n         MVC   DSIMSGS(17),=C'DATASET NOT FOUND'\n         MVC   DSIMSGL(31),=C'DATASET NOT ON CATLOGUED VOLSER'\n         LA    R0,17\n         LA    R1,31\n         B     MODDSX\nDELDSFND EQU   *\n         BAL   R9,SHOWDSCB\n         MVC   FUNCT(8),=CL8'SCRATCH'\n         CALL  ISPLINK,                                                @\n               (=CL8'DISPLAY',=CL8'DSINDX03'),                         @\n               VL,MF=(E,PARMLIST)\n         MVC   FUNCT(8),=CL8'SCRATCH-'\n         LTR   R15,R15                    SEE IF END KEY WAS HIT\n         BNZ   DELNO                      YES, DONT DELETE HIM\n*\n** SCRATCH THE DATASET\n*\n         MVC   VNUMB(2),=H'1'             SET NUMBER OF VOLUMES\n         MVC   VDEVCODE(4),=X'30,30,20,0E' SET DEVICE CODE = 3380\n* PLEASE NOTE THAT DEVICE CODE FOR 3380 IS HARD-CODED - X'30,30,20,0E'\n* WE ARE A ALL 3380 SHOP, YOU CAN GET THIS INFO FROM THE UCB\n* OR PUT IN IBM'S \"SYSALLDA\"\n         XC    VSTATCDE(2),VSTATCDE       SET SCRATCH CODE\n         LA    R1,DSNAME                  ------+\n         ST    R1,SCRATCHD+4                    |  SET UP CAMLST\n         LA    R1,VOLLIST                       |  PARMS\n         ST    R1,SCRATCHD+12             ------+\n         SLR   R0,R0                      INDICATE NO UCB\n         SCRATCH SCRATCHD                 SCRATCH DATASET\n         LTR   R15,R15                    WAS IT SUCESSFULL?\n         BNZ   DELFAIL                    NO, ISSUE MESSAGE\n         TM    EXECFLAG,$DELETE           IF WE WANT DELETE\n         BO    UNCAT                      ..THEN WE NEED AN UNCATLG\n         MVC   LASTA(11),=CL11'SCRATCHED'\n         MVC   DSIMSGS(17),=C'DATASET SCRATCHED'\n         MVC   DSIMSGL(17),=C'DATASET SCRATCHED'\n         LA    R0,17\n         LA    R1,17\n         B     MODDSX             LEAVE\n*\n** DELETE OF DATASET FAILED\n*\nDELFAIL  EQU   *\n         BAL   R14,CLRMSG\n         MVC   LASTA(11),=CL11'\u00ac SCRATCHED'\n         MVC   DSIMSGS(21),=C'DATASET NOT SCRATCHED'\n         MVC   DSIMSGL(18),=C'NOT SCRATCHED, RC='\n         LA    R6,DSIMSGL+18\n         LR    R0,R15\n         BAL   R14,EDREG0\n         LA    R0,21              LENGTH OF DSIMSGS\n         LA    R15,DSIMSGL        GET BEGINNING OF MESSAGE\n         LR    R1,R6              GET END OF MESSAGE\n         SR    R1,R15             LENGTH OF DSIMSGL = END - BEG\n         B     MODDSX             LEAVE\n*\n** USER DID NOT WANT THE DATASET SCRATCHED...HE HIT THE END KEY\n*\nDELNO    EQU   *\n         MVC   LASTA(11),=CL11'\u00ac SCRATCHED'\n         MVC   DSIMSGS(21),=C'DATASET NOT SCRATCHED'\n         MVC   DSIMSGL(21),=C'DATASET NOT SCRATCHED'\n         LA    R0,21\n         LA    R1,21\n         B     MODDSX\n*\n** UNCATALOG DATASET\n*\nUNCAT    EQU   *\n         MVC   FUNCT(8),=CL8'UNCATLG-'\n         LA    R1,DSNAME                  --+ SET UP\n         ST    R1,UNCATIT+4               --+ CAMLST PARMS\n         CATALOG UNCATIT                  UNCATALOGUE IT\n         LTR   R15,R15\n         BZ    UNCATOK\n         MVC   LASTA(11),=CL11'\u00ac UNCATLG'\n         BAL   R14,CLRMSG\n         TM    EXECFLAG,$DELETE\n         BO    UNCATND\n         MVC   DSIMSGS(18),=C'DATASET NOT UNCATLG'\n         MVC   DSIMSGL(22),=C'UNCATALOG  FAILED, RC='\n         LA    R6,DSIMSGL+23\n         LR    R0,R15\n         BAL   R14,EDREG0\n         LA    R0,18\n         LA    R15,DSIMSGL        GET BEGINNING OF MESSAGE\n         LR    R1,R6              GET END OF MESSAGE\n         SR    R1,R15             LENGTH OF DSIMSGL = END - BEG\n         B     MODDSX             LEAVE\n*\n** SCRATCHED THE DATASET, BUT THE UNCATALOGUE FUNCTION FAILED\n*\nUNCATND  EQU   *\n         MVC   DSIMSGS(22),=C'SCRTCHED, NOT UNCATLGD'\n         MVC   DSIMSGL(28),=C'SCRATCHED, BUT NOT UNCAT, RC='\n         LA    R6,DSIMSGL+28\n         LR    R0,R15\n         BAL   R14,EDREG0\n         LA    R0,22\n         LA    R15,DSIMSGL        GET BEGINNING OF MESSAGE\n         LR    R1,R6              GET END OF MESSAGE\n         SR    R1,R15             LENGTH OF DSIMSGL = END - BEG\n         B     MODDSX             LEAVE\n*\n**       ISSUE MESSAGE FOR UNCATLG OF DATASET\n*\nUNCATOK  EQU   *\n         TM    EXECFLAG,$DELETE\n         BO    UNCATOKD\n         MVC   LASTA(11),=CL11'UNCATLGED'\n         MVC   DSIMSGS(19),=C'DATASET UNCATALOGED'\n         LA    R0,19\n         LA    R1,0\n         B     MODDSX\n*\n**       ISSUE MESSAGE FOR DELETE OF DATASET\n*\nUNCATOKD EQU   *\n         MVC   FUNCT(8),=CL8'DELETE--'\n         MVC   LASTA(11),=CL11'DELETED'\n         MVC   DSIMSGS(15),=C'DATASET DELETED'\n         MVC   DSIMSGL(15),=C'DATASET DELETED'\n         LA    R0,15\n         LA    R1,15\n         B     MODDSX\n*\n*        COMMON EXIT FOR SCRATCH, DELETE, UNCATALOGUE FUNCTIONS\n*\nMODDSX   EQU   *\n         MVC   MSGID(8),=CL8'DSI@000C'\n         BAL   R9,SETMSG\n         BAL   R9,LOGMSG\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'TBMOD',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n         NI    EXECFLAG,TURNOFF-$DELETE\n         B     DSNLOOP\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       SHOW DSCB                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nSHOWDSCB EQU   *\n         ST    R9,S_DSCB                        SAVE RETURN ADDRESS\n         LA    R2,FULLDSCB                      LOCATE DSCB WITH DSN\n         SR    R0,R0                            CLEAR REG\n         LH    R0,DS1LRECL-IECSDSF1(R2)         GET LRECL\n         ST    R0,LRECL                         SAVE IT FOR ISPF\n         SR    R0,R0                            CLEAR REG\n         LH    R0,DS1BLKL-IECSDSF1(R2)          GET BLKSIZE\n         ST    R0,BLKSZ                         SAVE IT FOR ISPF\n*\n** FORMAT OPTION BYTE\n*\n         TM    DS1DSIND-IECSDSF1(R2),DS1IND40\n         BO    SDSCB000\n         TM    DS1DSIND-IECSDSF1(R2),DS1IND40\n         BO    SDSCB001\n         MVC   OPTION(4),=CL4'NONE'\n         B     SDSCB00X\nSDSCB000 EQU   *\n         MVC   OPTION(4),=CL4'RACF'\n         B     SDSCB00X\nSDSCB001 EQU   *\n         MVC   OPTION(4),=CL4'PSWD'\n         B     SDSCB00X\nSDSCB00X EQU   *\n*\n** GET DATASET ORGANIZATION\n*\n         TM    DS1DSORG-IECSDSF1(R2),DS1DSGIS\n         BO    SDSCB100\n         TM    DS1DSORG-IECSDSF1(R2),DS1DSGPS\n         BO    SDSCB101\n         TM    DS1DSORG-IECSDSF1(R2),DS1DSGDA\n         BO    SDSCB102\n         TM    DS1DSORG-IECSDSF1(R2),DS1DSGPO\n         BO    SDSCB103\n         TM    DS1DSORG-IECSDSF1(R2),DS1DSGU\n         BO    SDSCB104\n         MVC   DSORG(4),=CL4'???'\n         B     SDSCB10X\nSDSCB100 EQU   *\n         MVC   DSORG(4),=CL4'ISAM'\n         B     SDSCB10X\nSDSCB101 EQU   *\n         MVC   DSORG(4),=CL4'PS'\n         B     SDSCB10X\nSDSCB102 EQU   *\n         MVC   DSORG(4),=CL4'DA'\n         B     SDSCB10X\nSDSCB103 EQU   *\n         MVC   DSORG(4),=CL4'PDS'\n         B     SDSCB10X\nSDSCB104 EQU   *\n         MVC   DSORG(4),=CL4'UNMV'\n         B     SDSCB10X\nSDSCB10X EQU   *\n*\n** GET CREATION JOB,DATE / LAST REF JOB,DATE\n*\n         MVC   CJOB(5),DS1SYSCD+8-IECSDSF1(R2) GET CREATING*DMS*\n         MVC   CJOB+5(3),DS1DSSN-IECSDSF1(R2)  ..JOBNAME   *DMS*\n         LA    R1,DS1CREDT-IECSDSF1(R2)        --+\n         LA    R15,CDATE                         | CREATION DATE\n         BAL   R14,CONVDATE                    --+\n         MVC   LJOB(8),DS1SYSCD-IECSDSF1(R2)   GET LAST MOD JOB\n         LA    R1,DS1DSSN+3-IECSDSF1(R2)       --+\n         LA    R15,LDATE                         | LAST MOD DATE\n         BAL   R14,CONVDATE                    --+\n         LA    R1,DS1EXPDT-IECSDSF1(R2)        --+\n         LA    R15,XDATE                         | EXPIRATION DATE\n         BAL   R14,CONVDATE                    --+\n*\n** DUMP DSCB (EXCLUDING DATASET NAME)\n*\n         MVC   MINIOFF(2),=H'44'                START AFTER DSNAME\n         MVC   MINILEN(2),=H'16'                LENGTH TO DUMP\n         LA    R7,AREADSCB                      INPUT: OBTAIN DSCB\n         LA    R8,XLINE1                        OUTPUT: ISPF DATA AREA\n         LA    R2,6                             NUMBER OF LINES\nLOOPDSCB EQU   *\n         MVI   0(R8),C' '                       GET BLANK\n         MVC   1(64,R8),0(R8)                   ..PROPAGATE IT\n         BAL   R9,DUMPIT                        HEX DUMP\n         LA    R7,16(R7)                        BUMP TO NEXT 16 BYTES\n         LA    R8,65(R8)                        BUMP TO NEXT LINE\n         BCT   R2,LOOPDSCB                      DUMP 6 LINES\n*\n** DEFINE DEM GUYS TO ISPF\n*\n         LA    R15,4\n         ST    R15,LRECLL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(LRECL)',LRECL,=CL8'FIXED',LRECLL),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,4\n         ST    R15,BLKSZL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(BLKSZ)',BLKSZ,=CL8'FIXED',BLKSZL),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,4\n         ST    R15,OPTIONL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(OPTION)',OPTION,=CL8'CHAR',OPTIONL), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,4\n         ST    R15,DSORGL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(DSORG)',DSORG,=CL8'CHAR',DSORGL),    @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,CDATEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(CDATE)',CDATE,=CL8'CHAR',CDATEL),    @\n               VL,MF=(E,PARMLIST)\n         LA    R15,8\n         ST    R15,CJOBL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(CJOB)',CJOB,=CL8'CHAR',CJOBL),       @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,LDATEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(LDATE)',LDATE,=CL8'CHAR',LDATEL),    @\n               VL,MF=(E,PARMLIST)\n         LA    R15,8\n         ST    R15,LJOBL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(LJOB)',LJOB,=CL8'CHAR',LJOBL),       @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,XDATEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XDATE)',XDATE,=CL8'CHAR',XDATEL),    @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE1L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE1)',XLINE1,=CL8'CHAR',XLINE1L), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE2L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE2)',XLINE2,=CL8'CHAR',XLINE2L), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE3L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE3)',XLINE3,=CL8'CHAR',XLINE3L), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE4L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE4)',XLINE4,=CL8'CHAR',XLINE4L), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE5L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE5)',XLINE5,=CL8'CHAR',XLINE5L), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,65\n         ST    R15,XLINE6L\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(XLINE6)',XLINE6,=CL8'CHAR',XLINE6L), @\n               VL,MF=(E,PARMLIST)\n*\n         L     R9,S_DSCB                        GET RETURN ADDRESS\n         BR    R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       CHECK DATASET AGAINST SEARCH ARG.                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n* NOTE: I WAS GOING TO PUT A \"GENERIC\" SEARCH PATTERN CHECKING ROUTINE\n*       HERE BUT NEVER GOT AROUND TO IT.\nCHKDSN   EQU   *\n         LA    R7,1(R7)\n         ST    R7,ROWNUM\n         SR    R15,R15\n         BR    R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GET COMMAND LINE                                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCHKCMDL  EQU   *\n         LA    R15,79\n         ST    R15,ZCMDL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(ZCMD)',ZCMDL,ZCMD,=CL8'MOVE'),         @\n               VL,MF=(E,PARMLIST)\n*\n**       ENSURE WE HAVE A COMMAND AND INITIALIZE FOR SEARCH OF IT\n*\n         L     R2,ZCMDL                   LENGTH OF ZCMD\n         LTR   R2,R2                      IS IT ZERO?\n         BZ    CHKCMDLX                   YES, LEAVE\n         LA    R3,ZCMD                    ADDRESS(ZCMD)\n*\n** SEARCH FOR BEGINNING OF FIRST OPERAND\n*\n         CLC   0(2,R3),=C'L '\n         BE    CC1000\n         CLC   0(7,R3),=C'LOCATE '\n         BE    CC1001\n         CLC   0(2,R3),=C'F '\n         BE    CC1100\n         CLC   0(5,R3),=C'FIND '\n         BE    CC1101\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(18),=C'\"12345678\" INVALID'\n         MVC   DSIMSGS+1(8),0(R3)\n         MVC   DSIMSGL(25),=C'COMMAND IS NOT ACCEPTABLE'\n         LA    R0,18\n         LA    R1,25\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         B     CHKCMDLX\nCC1000   EQU   *\n         LA    R3,2(R3)                   BUMP PAST \"L \"\n         S     R2,=F'2'                   ..SUBTRACT ITS LENGTH\n         B     CC1000X                    LEAVE\nCC1001   EQU   *\n         LA    R3,7(R3)                   BUMP PAST \"LOCATE \"\n         S     R2,=F'7'                   ..SUBRACT ITS LENGTH\n         B     CC1000X                    LEAVE\nCC1100   EQU   *\n         OI    EXECFLAG,$FIND             TURN ON FLAG\n         LA    R3,2(R3)                   BUMP PAST \"F \"\n         S     R2,=F'2'                   ..SUBTRACT ITS LENGTH\n         B     CC1000X                    LEAVE\nCC1101   EQU   *\n         OI    EXECFLAG,$FIND             TURN ON FLAG\n         LA    R3,5(R3)                   BUMP PAST \"FIND \"\n         S     R2,=F'5'                   ..SUBTRACT ITS LENGTH\n         B     CC1000X                    LEAVE\nCC1000X  EQU   *\n         LTR   R2,R2                      CHECK OUT LENGTH\n         BZ    CC2001                     ZERO? NO SECOND OPERAND...\n         BM    CC2001                     MINUS? NO SECOND OPERAND...\n*\n** SEARCH FOR BEGINNING OF SECOND OPERAND\n*\nCC2000   EQU   *\n         CLI   0(R3),C' '\n         BNE   CC3000\n         LA    R3,1(R3)\n         BCT   R2,CC2000\nCC2001   EQU   *\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(18),=C'NO SEARCH ARGUMENT'\n         MVC   DSIMSGL(33),=C'REQUIRED SECOND OPERAND NOT FOUND'\n         LA    R0,18\n         LA    R1,33\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         B     CHKCMDLX\n*\n** ISOLATE SECOND OPERAND\n*\nCC3000   EQU   *\n         LA    R4,44                      LENGTH OF TBSRCH\n         ST    R3,S_TBSRCH                SAVE ADDRESS OF SEARCH ARG\nCC3001   EQU   *\n         CLI   0(R3),C' '\n         BE    CC3002\n         LA    R3,1(R3)\n         BCTR  R4,0\n         LTR   R4,R4\n         BZ    CC3002\n         BCT   R2,CC3001\nCC3002   EQU   *\n         LA    R5,44                      MAX LENGTH TO FIND\n         SR    R5,R4                      ..MINUS USED = ACTUAL\n         BCTR  R5,0                       ..DECREMENT FOR EX\n         L     R4,S_TBSRCH                OBTAIN SEARCH ARG LOCATION\n         LA    R3,DSNAME                  FIND ROW DATASET\n         L     R1,DSILVLL                 GET LENGTH OF LEVEL\n         LA    R3,1(R1,R3)                BUMP TO COMPARISON LOCATION\n         CALL  ISPLINK,                                                @\n               (=CL8'TBTOP',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n*\n** SKIP TO NEXT ROW\n** R3 : OFFSET IN ROW DSNAME, PAST LEVEL\n** R4 : ADDRESS OF VALUE TO FIND\n** R5 : LENGTH OF VALUE TO FIND\n*\nCCS000   EQU   *\n         CALL  ISPLINK,                                                @\n               (=CL8'TBSKIP',=CL8'DSINDEX'),                           @\n               VL,MF=(E,PARMLIST)\n         LTR   R15,R15\n         BNZ   CCSX\n         CLC   0(0,R3),0(R4)\n         EX    R5,*-6\n         BE    CHKCMDLX\n         BH    CHKCMDLX\n         B     CCS000\nCCSX     EQU   *\n         MVC   DSIMSGS(9),=C'NOT FOUND'\n         MVC   DSIMSGL(29),=C'COULDN''T FIND DSNAME BY SEARCH'\n         MVC   MSGID(8),=CL8'DSI@000B'\n         LA    R0,9\n         LA    R1,29\n         BAL   R9,SETMSG\n*\n** COMMON EXIT\n*\nCHKCMDLX EQU   *\n         NI    EXECFLAG,TURNOFF-$FIND\n         B     DSNLOOP\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PROCESS ROW                                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nROWPROC  EQU   *\n         LA    R15,4\n         ST    R15,ROWNUML\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(ROWNUM)',ROWNUML,ROWNUM,=CL8'MOVE'),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,7\n         ST    R15,TSELL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(TSEL)',TSELL,TSEL,=CL8'MOVE'),         @\n               VL,MF=(E,PARMLIST)\n         LA    R15,44\n         ST    R15,DSNAMEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(DSNAME)',DSNAMEL,DSNAME,=CL8'MOVE'),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,VOLSERL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(VOLSER)',VOLSERL,VOLSER,=CL8'MOVE'),   @\n               VL,MF=(E,PARMLIST)\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(LASTA)',LASTAL,LASTA,=CL8'MOVE'),      @\n               VL,MF=(E,PARMLIST)\n         LA    R15,4\n         ST    R15,TYPEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VCOPY',=C'(TYPE)',TYPEL,TYPE,=CL8'MOVE'),         @\n               VL,MF=(E,PARMLIST)\n         BR    R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        MESSAGE PROCESSING                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n**       TELL ISPF ABOUT OUR SCREEN MESSAGE\n**       INPUT: R0 - LENGTH OF SHORT MESSAGE.\n**              R1 - LENGTH OF LONG MESSAGE.\n*\nSETMSG   EQU   *\n         ST    R0,DSIMSGSL\n         ST    R1,DSIMSGLL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(DSIMSGS)',DSIMSGS,=CL8'CHAR',DSIMSGSL),             @\n               VL,MF=(E,PARMLIST)\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(DSIMSGL)',DSIMSGL,=CL8'CHAR',DSIMSGLL),             @\n               VL,MF=(E,PARMLIST)\nSETMSGI  EQU   *\n         CALL  ISPLINK,                                                @\n               (=CL8'SETMSG',MSGID),                                   @\n               VL,MF=(E,PARMLIST)\n         BR    R9\n*\n**       LOG MESSAGE TO LOG FILE\n*\nLOGMSG   EQU   *\n         LA    R1,8\n         ST    R1,FUNCTL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(FUNCT)',FUNCT,=CL8'CHAR',FUNCTL),                   @\n               VL,MF=(E,PARMLIST)\n         CALL  ISPLINK,                                                @\n               (=CL8'LOG',LOGMSG1),                                    @\n               VL,MF=(E,PARMLIST)\n         CLI   LOGMSG2,X'00'\n         BE    LOGMSGX\n         CALL  ISPLINK,                                                @\n               (=CL8'LOG',LOGMSG2),                                    @\n               VL,MF=(E,PARMLIST)\n* DEFINING ZERR MESSAGE TO ZERO IN TEST MODE TO CORRECT ISPF ABEND\n         XC    DSIMSGSL(4),DSIMSGSL\n         XC    DSIMSGLL(4),DSIMSGLL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(DSIMSGS)',DSIMSGS,=CL8'CHAR',DSIMSGSL),             @\n               VL,MF=(E,PARMLIST)\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(DSIMSGL)',DSIMSGL,=CL8'CHAR',DSIMSGLL),             @\n               VL,MF=(E,PARMLIST)\nLOGMSGX  EQU   *\n         BR    R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       LINK TO MINI HEX DUMP PROGRAM                               **\n**       INPUT  R7       ADDRESS OF INPUT AREA                       **\n**       OUTPUT R8       ADDRESS OF OUTPUT AREA                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT GEN\nDUMPIT   EQU   *\n         CALL  MINIXDMP,(MINILEN,(7),(8),MINIOFF),                     @\n               MF=(E,PARMLIST)\n         BR    R9\n         PRINT NOGEN\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       MISC SUBROUTINES                                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n**       GETWRK: GETMAIN WORKING STORAGE FOR LOCINDEX WORK AREA\n**       FREEWRK: FREEMAIN WORKING STORAGE FOR LOCINDEX WORK AREA\n*\nGETWRK   EQU   *\n         L     R0,LOCWRKL               GET WORK AREA LENGTH-RSA\n         GETMAIN RC,LV=(0)\n         ST    R1,LOCWRK\n         LR    R2,R1                    GET ADDR OF WORK AREA\n         LR    R3,R0                    GET WORK AREA LENGTH-RSA\n         SLR   R5,R5                    SET LENGTH AND PAD TO ZERO\n         MVCL  R2,R4                    CLEAR WORK AREA TO ZEROS\n         BR    R9\nFREEWRK  EQU   *\n         L     R0,LOCWRKL\n         L     R1,LOCWRK\n         FREEMAIN R,LV=(0),A=(1)\n         BR    R9\n*\n** PUT TICKS AROUND DATASET NAME (FOR ISPF EDIT/BROWSE)\n*\nDSNAMEED EQU   *\n         MVI   EDDSN,C' '              <    BLANK OUT\n         MVC   EDDSN+1(46),EDDSN       <    EDITED DSNAME FIELDS\n         LA    R4,EDDSN+1              PLACE TO PUT DSNAME\n         LA    R5,DSNAME               LOCATION OF DSNAME\n         L     R6,DSNAMEL              LENGTH OF DSNAME FROM PANEL\n         BCTR  R6,0                    SUBTRACT 1 FOR \"EX\" INSTRUCTION\n         MVC   0(0,R4),0(R5)           MOVE EDITED 'DSNAME'\n         EX    R6,*-6                  ..BY LENGTH\n         MVI   EDDSN,X'7D'             APOSTROPHE AT FRONT OF DSN\n         LA    R4,1(R6,R4)             LOCATE END OF EDITED DSNAME\n         MVI   0(R4),X'7D'             MOVE IN THE APOSTROPHE\n         BR    R9\n*\n**       CONVERT DATE FROM X'YY,DD,DD' TO C'YY.DDD'\n**       INPUT:  R1  - ADDRESS OF YDD\n**       OUTPUT: R15 - ADDRESS TO PUT YY.DDD\n*\nCONVDATE EQU  *\n         CLI   0(R1),X'00'               YEAR = ZEROS?\n         BE    CVDEXIT                   YES, DONT EVEN BOTHER\n         SLR   R3,R3                     ----+\n         ICM   R3,B'0001',0(R1)              |\n         CVD   R3,DOUBLE                     |  FORMAT YEAR\n         UNPK  0(2,R15),DOUBLE+6(2)          |\n         OI    1(R15),X'F0'              ----+\n*\n         SLR   R3,R3                     ----+\n         ICM   R3,B'0011',1(R1)              |\n         CVD   R3,DOUBLE                     |  FORMAT DAY\n         UNPK  3(3,R15),DOUBLE+6(2)          |\n         OI    5(R15),X'F0'              ----+\n*\n         MVI   2(R15),C'.'\nCVDEXIT  EQU  *\n         BR    R14\n*\n**       CLEAR ISPF MESSAGE AREAS\n*\nCLRMSG   EQU   *\n         MVI   DSIMSGS,C' '\n         MVC   DSIMSGS+1(29),DSIMSGS\n         MVI   DSIMSGL,C' '\n         MVC   DSIMSGL+1(78),DSIMSGL\n         BR    R14\n*\n**       PRETTY PRINT CONTENTS OF REGISTER 0\n**       R0 --> INPUT:REGISTER TO PRINT\n**       R6 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n**              (IT WILL BE ADVANCED TO NEXT BYTE AFTER NUMBER)\n*\nEDREG0   EQU   *\n         LTR   R0,R0                      CHECK FOR 0\n         BZ    EDREG00                    YES, PUT ZERO\n         CVD   R0,DOUBLE                  NO, CONVERT TO PACKEC\n         MVC   WRKNUM(7),=X'40,20,20,20,20,21,20' GET EDIT PATTERN\n         LA    R1,WRKNUM+6                LOCATE SIG DIGIT\n         EDMK  WRKNUM(7),DOUBLE+5         EDIT IT\n         LR    R4,R1                      SAVE POINTER TO START\n         LA    R15,WRKNUM+7               LOCATE LAST POSSIBLE BYTE + 1\n         SR    R15,R1                     LENGTH = END - START\n         BCTR  R15,0                      DECREMENT FOR EX\n         MVC   0(0,R6),0(R4)\n         EX    R15,*-6                    MOVE EDIT NUMBER TO OUTPUT\n         LA    R6,1(R15,R6)               BUMP POINTER PAST NUMBER\n         BR    R14                        RETURN TO CALLER\nEDREG00  EQU   *\n         MVI   0(R6),C'0'                 PUT IN ZERO\n         LA    R6,2(R6)                   BUMP POINTER PAST ZERO\n         BR    R14                        RETURN TO CALLER\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       READ CVOL FOR INDEX ENTRIES                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nREADCVOL EQU   *\n*\n** CREATE DSNAME INDEX TABLE\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'TBCREATE',                                        @\n               =CL8'DSINDEX',                   *TABLE NAME*           @\n               =C'(ROWNUM)',                    *KEYWORD LIST*         @\n               =C'(DSNAME VOLSER LASTA TYPE)',  *NAME LIST*            @\n               =CL8'NOWRITE'),                  *TEMP TABLE*           @\n               VL,MF=(E,PARMLIST)\n*\n** DEFINE FIELDS TO ISPF\n*\n         LA    R15,4\n         ST    R15,ROWNUML\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',                                         @\n               =C'(ROWNUM)',ROWNUM,=CL8'CHAR',ROWNUML),                @\n               VL,MF=(E,PARMLIST)\n         LA    R15,7\n         ST    R15,TSELL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(TSEL)',TSEL,=CL8'CHAR',TSELL),       @\n               VL,MF=(E,PARMLIST)\n         LA    R15,44\n         ST    R15,DSNAMEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(DSNAME)',DSNAME,=CL8'CHAR',DSNAMEL), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,6\n         ST    R15,VOLSERL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(VOLSER)',VOLSER,=CL8'CHAR',VOLSERL), @\n               VL,MF=(E,PARMLIST)\n         LA    R15,11\n         ST    R15,LASTAL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(LASTA)',LASTA,=CL8'CHAR',LASTAL),    @\n               VL,MF=(E,PARMLIST)\n         LA    R15,4\n         ST    R15,TYPEL\n         CALL  ISPLINK,                                                @\n               (=CL8'VDEFINE',=C'(TYPE)',TYPE,=CL8'CHAR',TYPEL),       @\n               VL,MF=(E,PARMLIST)\n*\n** SET UP FOR LOCINDEX SUBROUTINE\n*\n*        LOAD  EPLOC==CL8'LOCINDEX',ERRET=INDXLOAD\n*        ST    R0,S_LOC\n         MVC   S_LOC(4),=V(LOCINDEX)\n         OC    PARMLIST(L'PARMLIST),PARMLIST\n         BAL   R9,GETWRK                  GET WORKAREA FOR LOCINDEX\n         SLR   R8,R8                      CLEAR OUT NUMBER-FOUND\n         SLR   R7,R7                      CLEAR OUT NUMBER-FOUND\n*\n** CALL SUBROUTINE TO SEARCH CVOL/CATALOG FOR OUR INDEX\n*\nINDXSRCH EQU   *\n         L     R2,LOCWRK                  GETMAINED WORK AREA ADDRESS\n         L     R15,S_LOC\n         CALL  (15),                                                   @\n               (DSILVL,DSNAME,VOLSER,(2)),                             @\n               VL,MF=(E,PARMLIST)\n         B     *+4(R15)\n         B     INDXDASD                   00-DSNAME FOUND AND ON DISK\n         B     INDXNONE                   04-INDEX NOT FOUND AT ALL\n         B     INDXTAPE                   08-DSNAME FOUND AND ON TAPE\n         B     INDXSRCH                   12-DSNAME RESIDES ON MULTVOL\n         B     INDXEND                    16-ALL INDEX LEVELS FOUND\n         B     INDXIOE                    20-I/O ERROR ON CATALOG\n         B     INDXINTE                   24-INTERNAL ERROR\n*\n** LOCINDEX FOUND A DASD DATASET\n*\nINDXDASD EQU   *\n         CLC   DSIDASD(3),=CL3'YES'       ARE WE LOOKING FOR DASD DS?\n         BNE   INDXSRCH                   NO, GET NEXT INDEX\n         MVC   TYPE(4),=CL4'DASD'         PROSE\n         B     INDXOK                     CHECK THIS DATASET OUT...\n*\n** LOCINDEX FOUND A TAPE DATASET\n*\nINDXTAPE EQU   *\n         CLC   DSITAPE(3),=CL3'YES'       ARE WE LOOKING FOR TAPE DS?\n         BNE   INDXSRCH                   NO, GET NEXT INDEX\n         MVC   TYPE(4),=CL4'TAPE'         PROSE\n         B     INDXOK                     CHECK THIS DATASET OUT...\n*\n** INDEX LOOKS OKAY\n*\nINDXOK   EQU   *\n         BAL   R9,CHKDSN           SEE IF THIS DATASET MATCHS SEARCH\n         LTR   R15,R15             DID IT MATCH?\n         BNZ   INDXSRCH            ..NO, TRY NEXT DATASET\n         LA    R8,1(R8)            ADD 1 TO NUMBER OF DATASETS FOUND\n         LR    R5,R8               LOAD INTO WORK REGISTER\n         SLR   R4,R4               CLEAR OUT EVEN REGISTER\n         D     R4,=F'10'           DIVIDE TO FIND REMAINDER\n         LTR   R4,R4               TEST FOR ZERO\n         BNZ   ADDROW              NO, DONT ISSUE MESSAGE\n*\n*        PRINT STATUS IF THIS IS A VERY LARGE INDEX GROUP\n*\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         LA    R6,DSIMSGS\n         LR    R0,R8\n         BAL   R14,EDREG0\n         MVC   0(15,R6),=C'DATASETS SO FAR'\n         LA    R6,16(R6)\n         LA    R1,DSIMSGS\n         SR    R6,R1\n         LR    R0,R6\n         LA    R1,0\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         CALL  ISPLINK,                                                @\n               (=CL8'CONTROL',=CL8'DISPLAY',=CL8'LOCK'),               @\n               VL,MF=(E,PARMLIST)\n         CALL  ISPLINK,                                                @\n               (=CL8'DISPLAY',=CL8'DSINDX01'),                         @\n               VL,MF=(E,PARMLIST)\n*\n*        ADD ROW\n*\nADDROW   EQU   *\n         MVC   LASTA(11),=CL11' '\n         CALL  ISPLINK,                                                @\n               (=CL8'TBADD',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n         CALL  ISPLINK,                                                @\n               (=CL8'TBBOTTOM',=CL8'DSINDEX'),                         @\n               VL,MF=(E,PARMLIST)\n         B     INDXSRCH\n*\n*        LOCINDEX FOUND I/O ERROR ON CATALOG\n*\nINDXIOE  EQU   *\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(18),=C'I/O ERROR ON CATLOG'\n         MVC   DSIMSGL(34),=C'LOCINDEX FOUND I/O ERROR ON CATALOG'\n         MVC   MSGID(8),=CL8'DSI@000A'\n         LA    R0,18\n         LA    R1,34\n         B     INDXEXIT\n*\n*        LOCINDEX HAD INTERNAL ERROR\n*\nINDXINTE EQU   *\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(14),=C'INTERNAL ERROR'\n         MVC   DSIMSGL(30),=C'LOCINDEX HAD AN INTERNAL ERROR'\n         MVC   MSGID(8),=CL8'DSI@000A'\n         LA    R0,18\n         LA    R1,30\n         B     INDXEXIT\n*\n*        NO INDEX FOUND FOR LEVEL\n*\nINDXNONE EQU   *\n         BAL   R14,CLRMSG                  SET MESSAGES TO BLANKS\n         MVC   DSIMSGS(20),=C'LEVEL DOES NOT EXIST'\n         MVC   DSIMSGL(20),=C'LEVEL DOES NOT EXIST'\n         MVI   DSIMSGL+20,C':'\n         MVC   DSIMSGL+22(44),DSILVL\n         MVC   MSGID(8),=CL8'DSI@000A'     GET MESSAGE ID\n         LA    R0,20                       LENGTH OF SHORT MESSAGE\n         LA    R1,66                       LENGTH OF LONG  MESSAGE\nINDXEXIT EQU   *\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG                   SET MESSAGE\n         BAL   R9,FREEWRK                  FREE WORK AREA\n         B     DISPPOM\n*\n*        NO DATASETS FOUND TO MEET GENERIC SEARCH\n*\nINDXNFND EQU   *\n         BAL   R14,CLRMSG\n         MVC   DSIMSGS(17),=C'NO DATASETS FOUND'\n         MVC   DSIMSGL(32),=C'NONE FOUND IN SEARCH, NEXT NODE:'\n         LA    R6,DSIMSGL+33\n         LR    R0,R7\n         BAL   R14,EDREG0\n         LA    R0,17\n         LA    R1,40\n         B     INDXEXIT\n*\n*   END OF LOCINDEX PROCESSING\n*\nINDXEND  EQU   *\n         LTR   R7,R7                    TEST FOR ZERO (NO MATCHES)\n         BZ    INDXNFND                 ZERO, GOTO INDXNONE ROUTINE\n         BAL   R9,FREEWRK                  FREE WORK AREA\n         BAL   R14,CLRMSG\n         LA    R6,DSIMSGS\n         LR    R0,R8\n         BAL   R14,EDREG0\n         MVC   0(17,R6),=C'DATASETS FOUND OF'\n         LA    R6,18(R6)\n         LR    R0,R7\n         BAL   R14,EDREG0\n         LA    R1,DSIMSGS\n         SR    R6,R1\n         LR    R2,R6\n         BCTR  R2,0\n         MVC   DSIMSGL(0),DSIMSGS\n         EX    R2,*-6\n         LR    R0,R6\n         LR    R1,R6\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n*\n** ISSUE LOG MESSAGES\n*\n         MVC   FUNCT(8),=CL8'LOCINDEX'\n         MVC   LOGMSG1(8),=CL8'DSI@002A'\n         MVC   LOGMSG2(8),=CL8'DSI@001B'\n         BAL   R9,LOGMSG\n         MVC   LOGMSG1(8),=CL8'DSI@001C'\n         MVI   LOGMSG2,X'00'\n         BAL   R9,LOGMSG\n         MVC   LOGMSG1(8),=CL8'DSI@002A'\n         MVC   LOGMSG2(8),=CL8'DSI@002B'\n*\n*        GET TO THE TOP OF THINGS\n*\n         CALL  ISPLINK,                                                @\n               (=CL8'TBTOP',=CL8'DSINDEX'),                            @\n               VL,MF=(E,PARMLIST)\n*        DELETE EPLOC==CL8'LOCINDEX'\n         B     DSNLOOP\nINDXLOAD EQU   *\n         BAL   R14,CLRMSG\n         MVC   DSIMSGS(19),=C'LOCINDEX NOT LOADED'\n         MVC   DSIMSGL(34),=C'COULD NOT LOAD LOCINDEX SUBROUTINE'\n         LA    R0,19\n         LA    R1,34\n         MVC   MSGID(8),=CL8'DSI@000A'\n         BAL   R9,SETMSG\n         B     DISPPOM\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       D A T A    D E C L A R A T I O N S                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nLOCWRKL  DC    F'4096'         LENGTH OF LOCINDEX WORK AREA\n*\n*\n** COPY AREA (TO BE COPIED INTO GETMAINED WORK AREA)\n*\n         DS    0D\nCPYAREA  EQU   *\n         PRINT GEN\n         CAMLST SEARCH,*-*,*-*,*-*\n         CAMLST SCRATCH,*-*,,*-*,,OVRD\n         CAMLST UNCAT,*-*\n         PRINT NOGEN\nCPYAREAL EQU   *-CPYAREA\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       LITERALS                                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAIN WORK AREA                                           **\n***                                                                 ***\n***********************************************************************\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                        REGISTER SAVE AREA\nPARMLIST DS    8F                         PARMLIST FOR CALLS\nDOUBLE   DS    D                          DOUBLE WORD WORK AREA\nLOCWRK   DS    F                          GETMAIN WORK AREA (LOCINDEX)\nS_DSCB   DS    F                          RETURN ADDRESS\nS_LOC    DS    F                          EPA OF LOCINDEX\nS_TBSRCH DS    F                          ADDRESS OF SEARCH ARG\nMINILEN  DS    H'16'                      MINIXDMP LENGTH TO DUMP\nMINIOFF  DS    H'00'                      MINIXDMP OFFSET NUMBER\nWRKNUM   DS    CL15                       JUST A WORK NUMBER\nLOGMSG1  DS    CL8                        LOG MESSAGE ID\nLOGMSG2  DS    CL8                        LOG MESSAGE ID\nMSGID    DS    CL8                        ISPF MESSAGE ID\n*\n** CAMLST, OBTAIN DATA AREAS\n*\n*-- PLEASE NOTE THAT LABELS FULLDSCB, DSNAME, AREADSCB MUST REMAIN IN\n*-- THIS ORDER SO THAT THE IECSDSL1 MACRO CAN BE USED ASIS.\nFULLDSCB DS    0CL140                     FULL FORMAT 1 DSCB\nDSNAME   DS    44C' '                     DATASET NAME\nAREADSCB DS    140C' '                    AREA RETURNED BY CAMLST\n         DS    0H'0'                      GET ALIGNED\nVOLLIST  EQU   *                          VOLUME LIST FOR SCRATCH\nVNUMB    DS    H'1'                       NUMBER OF VOLUMES IN LIST\nVDEVCODE DS    X'30,30,20,0E'             DEVICE CODE\nVOLSER   DS    CL6                        VOLSER\nVSTATCDE DS    H'0'                       SCRATCH STATUS CODE\n*\n** PROGRAM FLAGS\n*\nEXECFLAG DS    B'00000000'                EXECUTION FLAG\n$DELETE  EQU   B'10000000'                ..DELETE: SCRATCH, AND UNCAT\n$FIND    EQU   B'01000000'                ..FIND IF ON, LOCATE IF OFF\nTURNOFF  EQU   B'11111111'                TURN OFF A FLAG\n*\n** ISPF DATA AREAS\n*\n         DS    0F\nEDDSN    DS    CL76                       EDITED DSNAME (WITH TICKS)\nTSEL     DS    CL7                        USER SELECTION CODE\nLASTA    DS    CL11                       LAST ACTION\nTYPE     DS    CL4                        TYPE (OF DATASET: TAPE|DASD)\nFUNCT    DS    CL8                        CURRENT DSINDEX FUNCTION\nDSIMSGS  DS    CL30                       SHORT MESSAGE\nDSIMSGL  DS    CL79                       LONG MESSAGE\nZCMD     DS    CL79                       COMMAND FROM COMMAND LINE\nBUFFER   DS    CL79                       SELECT PGM(...) BUFFER\nDSILVL   DS    CL80                       UNEDITED DSNAME\nDSIVOL   DS    CL6                        VOLSER TO LIMIT SEARCH\nDSITAPE  DS    CL3                        TAPE DATASETS?\nDSIDASD  DS    CL3                        DASD DATASETS?\nXLINE1   DS    CL65                       DSCB HEX DUMP LINE 1\nXLINE2   DS    CL65                        DSCB HEX DUMP LINE 2\nXLINE3   DS    CL65                         DSCB HEX DUMP LINE 3\nXLINE4   DS    CL65                          DSCB HEX DUMP LINE 4\nXLINE5   DS    CL65                           DSCB HEX DUMP LINE 5\nXLINE6   DS    CL65                            DSCB HEX DUMP LINE 6\nCDATE    DS    CL6                        DSCB - CREATION DATE\nCJOB     DS    CL8                             - CREATING JOB\nLDATE    DS    CL6                             - LAST MOD DATE\nLJOB     DS    CL8                             - LAST MOD JOB\nXDATE    DS    CL6                             - EXPIRATION DATE\nOPTION   DS    CL4                             - OPTION BYTE:SECURITY\nDSORG    DS    CL4                             - DATASET ORGAINIZATION\n         DS    0F\nLRECL    DS    F                               - LOGICAL RECORD LENGTH\nBLKSZ    DS    F                               - BLKSIZE\nROWNUM   DS    F                               - ROW NUMBER\n*                                         LENGTH OF\nDSILVLL  DS    F                          ..DSILVL\nDSIVOLL  DS    F                          ..DSIVOL\nDSITAPEL DS    F                          ..DSITAPE\nDSIDASDL DS    F                          ..DSIDASD\nTSELL    DS    F                          ..TSEL\nROWNUML  DS    F                          ..ROWNUM\nDSNAMEL  DS    F                          ..DSNAME\nVOLSERL  DS    F                          ..VOLSER\nLASTAL   DS    F                          ..LASTA\nTYPEL    DS    F                          ..TYPE\nDSIMSGSL DS    F                          ..DSIMSGS\nDSIMSGLL DS    F                          ..DSIMSGL\nZCMDL    DS    F                          ..ZCMD\nBUFFERL  DS    F                          ..BUFFER\nFUNCTL   DS    F                          ..FUNCT\nOPTIONL  DS    F                          ..OPTION\nDSORGL   DS    F                          ..DSORG\nCDATEL   DS    F                          ..CDATE\nCJOBL    DS    F                          ..CJOB\nLDATEL   DS    F                          ..LDATE\nXDATEL   DS    F                          ..XDATE\nLJOBL    DS    F                          ..LJOB\nLRECLL   DS    F                          ..LRECL\nBLKSZL   DS    F                          ..BLKSZ\nXLINE1L  DS    F                          ..XLINE1\nXLINE2L  DS    F                          ..XLINE2\nXLINE3L  DS    F                          ..XLINE3\nXLINE4L  DS    F                          ..XLINE4\nXLINE5L  DS    F                          ..XLINE5\nXLINE6L  DS    F                          ..XLINE6\n*\n** COPY TO AREA\n*\n         DS    0D\nCPYTO    EQU   *\n         PRINT GEN\nFINDDSCB CAMLST SEARCH,*-*,*-*,*-*\nSCRATCHD CAMLST SCRATCH,*-*,,*-*,,OVRD\nUNCATIT  CAMLST UNCAT,*-*\n         PRINT NOGEN\nCPYTOL   EQU   *-CPYTO\n         DS    0D                         ALIGN DOUBLE WORD\nWORKDSL  EQU   *-WORKDS                   LENGTH OF DSECT AREA\n         EJECT ,\n         PRINT GEN\n         IECSDSL1 (1)\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSN0INFO": {"ttr": 3335, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DSNI     TITLE 'RETURN DATASET CHARACTERISTICS TO ISPF'          *LBD*\n*--------------------------------------------------------------------*\n*                                                                    *\n*        MODIFIED BY L. DYCK TO RETURN DSNAME INFORMATION        *LBD*\n*        TO ISPF VARIABLES.                                      *LBD*\n*                                                                *LBD*\n*        THIS  WAS ORIGINALLY THE LISTSPC TSO COMMAND FROM       *LBD*\n*        THE CBT TAPE FILE 300                                   *LBD*\n*                                                                    *\n*   DSNINFO IS INVOKED AS FOLLOWS :                              *LBD*\n*                                                                    *\n*        ISPEXEC PGM(DSNINFO) PARM(DSN-VARIABLE)                 *LBD*\n*                                                                    *\n*        WHERE  DSN-VARIABLE IS THE ISPF VARIABLE CONTAINING     *LBD*\n*        THE DSNAME TO BE ANALYZED.                              *LBD*\n*                                                          *LBD 12/83*\n*        IF THE DSNAME IS NOT FULLY QUALIFIED, THAT IS     *LBD 12/83*\n*        IN QUOTES, THEN THE ISPF ZPREFIX IS APPENDED TO   *LBD 12/83*\n*        THE BEGINNING OF THE DSNAME SO THAT THE DYNAMIC   *LBD 12/83*\n*        ALLOCATION WILL BE SUCCESSFUL.                    *LBD 12/83*\n*                                                          *LBD 12/83*\n*                                                                *LBD*\n* ISPF VARIABLE NAMES:                                           *LBD*\n*                                                                *LBD*\n*              ALCYL                   # ALLOCATED CYL'S   *LBD 12/83*\n*              ATRECFM                 RECORD FORMAT FOR ATTR    *LBD*\n*              BALC                    # BLK'S ALLOCATED    *LBD 03/85*\n*              BLKSIZE                 BLOCK SIZE                *LBD*\n*              BUSE                    # BLK'S USED         *LBD 03/85*\n*              CREDT                   CREATION DATE             *LBD*\n*              DSORG                   DATA SET ORGANIZATION     *LBD*\n*              DEVTYPE                 UNIT NAME FOR DATASET     *LBD*\n*              DIRALLOC                # ALLOC DIR BLOCKS  *LBD 11/83*\n*              DIRUSE                  # USED DIR BLOCKS   *LBD 11/83*\n*              EX                      # OF EXTENTS              *LBD*\n*              GCREDT                  GREGORIAN CREDT     *LBD 11/83*\n*              GUSEDT                  GREGORIAN USEDT     *LBD 11/83*\n*              KEYLEN                  KEY LENGTH                *LBD*\n*              LRECL                   LOGICAL RECORD LENGTH     *LBD*\n*              MEMBER                  MEMBER NAME (OR BLANK)    *LBD*\n*              RECFM                   RECORD FORMAT             *LBD*\n*              RKP                     RELATIVE KEY POSITION     *LBD*\n*              SCALO                   SECONDARY ALLOCATION      *LBD*\n*              TRALC                   ALLOCATED TRACKS          *LBD*\n*              TRUSE                   USED TRACKS               *LBD*\n*              UNIT                    ALLOCATION UNIT TYPE      *LBD*\n*              USEDT                   LAST USE DATE             *LBD*\n*              VOLSER                  VOLSER OF DATASET         *LBD*\n*              USCYL                   # USED CYL'S        *LBD 12/83*\n*                                                                *LBD*\n*        NOTE: IF A MEMBER NAME IS SPECIFIED THE DSORG     *LBD 01/84*\n*              WILL REMAIN PO.  BUT VARIABLE MEMBER WILL   *LBD 01/84*\n*              CONTAIN THE MEMBER NAME .                   *LBD 01/84*\n*                                                          *LBD 02/84*\n*        RETURN CODES:            0 = OK                   *LBD 02/84*\n*                                 99 = DATASET NOT FOUND   *LBD 02/84*\n*                                                          *LBD 02/84*\n*                                                                    *\n*        ADDED CHECK FOR VSAM DSORG FOR DSORG= ONLY         *LBD 02/84*\n*        ADDED BALC VARIABLE                                *LBD 03/85*\n*--------------------------------------------------------------------*\n         EJECT                                             *LBD 11/83*\n         MACRO\n         RCPDINC &L1\n         GBLA  &DTUO,&DTUPO\n         GBLC  &DYNP\n         AIF   ('&L1' EQ '').T2\n         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT\n&DTUPO   SETA  &DTUPO+4\n&DTUO    SETA  &DTUO+&L1\n         MEXIT\n.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS\n&DTUPO   SETA  &DTUPO+4\n         MEND\n         MACRO\n         RCPDS\n         GBLB  &RCPDSBR\n         GBLC  &RCPWKDS,&RCPWKCS,&RCPDS\n         AIF   ('&RCPDS' NE '').RESUME\n&RCPDS   SETC  '&SYSECT'\n         AIF   ('&RCPWKDS' EQ '').CSECT\n&RCPWKDS DSECT                         ENTER WORKAREA DSECT\n         MEXIT\n.CSECT   AIF   ('&RCPWKCS' EQ '').BRANCH\n&RCPWKCS CSECT                         ENTER WORKAREA CSECT\n         MEXIT\n.RESUME  AIF   (&RCPDSBR).BRTO\n&RCPDS   CSECT                         RESUME PROGRAM CSECT\n&RCPDS   SETC  ''\n         MEXIT\n.BRANCH  ANOP\n&RCPDS   SETC  'RCP&SYSNDX'\n&RCPDSBR SETB  1\n         B     &RCPDS                  BRANCH AROUND CONSTANTS\n         MEXIT\n.BRTO    ANOP\n&RCPDS   DS    0H\n&RCPDSBR SETB  0\n&RCPDS   SETC  ''\n         MEND\n         MACRO\n&NAME    S99FAIL &RB=(R14),&RC=(R15),&CPPL=,&MF=G,&CP=\n         GBLB  &RCPCPPL(2)             CP INDICATOR\n         GBLC  &RCPPRE\n         LCLB  &GEN\n         LCLC  &C\n&NAME    DS    0H\n         AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF(1)' EQ 'E').EXEC\n         MNOTE 4,'&MF(1) IS AN INVALID MF, MF=G USED'\n.GEN     LA    R1,FAIL&SYSNDX     LOAD PLIST ADDRESS\n&GEN     SETB  1\n         AGO   .L\n.EXEC    AIF   ('&MF(2)' NE '').LISTOK\n         MNOTE 8,'LIST ADDRESS NOT SPECIFIED'\n         MEXIT\n.LISTOK  AIF   ('&MF(3)' EQ '').TMF2\n&MF(3)   EQU   24                      LENGTH OF PARAMETER LIST\n.TMF2    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').L\n         AIF   ('&MF(2)'(1,1) EQ '(').REG\n         LA    R1,&MF(2)          LOAD DAIRFAIL PARAM LIST ADDRESS\n         AGO   .L\n.REG     ANOP\n&C       SETC  '&MF(2)'(2,K'&MF(2)-2)\n         LR    R1,&C              LOAD DAIRFAIL PARAM LIST ADDR\n.L       AIF   ('&RB'(1,1) EQ '(').RBR\n         AIF   ('&RB' NE '').RBA\n         MNOTE 8,'REQ BLOCK ADDRESS NOT SPECIFIED'\n         MEXIT\n.RBR     ST    &RB(1),0(R1)       STORE S99 RB ADDRESS\n         AGO   .RC\n.RBA     LA    R14,&RB            LOAD ADDRESS OF REQ BLOCK\n         ST    R14,0(R1)          AND STORE IN PLIST\n.RC      AIF   ('&RC'(1,1) EQ '(').RCR\n         LA    R14,&RC            LOAD ADDRESS OF RET CODE\n         ST    R14,4(R1)          AND STORE IN PLIST\n         AGO   .EFF02\n.RCR     ANOP\n.GRC     LA    R14,20(R1)         LOAD ADDR RET CODE FLD\n         ST    &RC(1),0(R14)      STORE RET CODE\n         ST    R14,4(R1)          AND STORE ITS ADDRESS\n.EFF02   LA    R14,=A(0)          LOAD ADDR OF FULLWORD OF 0\n         ST    R14,8(R1)          STORE IT.\n         AIF   ('&CP' EQ 'YES' OR &RCPCPPL(1)).CPID\n         LA    R14,=X'8032'       LOAD ADDRESS OF CALLERID\n         ST    R14,12(R1)          AND STORE IT\n         XC    16(4,R1),16(R1)    CLEAR CPPL POINTER\n         AGO   .GO\n.CPID    LA    R14,=Y(50)         LOAD ADDRESS OF CALLERID\n         ST    R14,12(R1)         AND STORE IT\n         AIF   ('&CPPL' EQ '').DCPPL\n         AIF   ('&CPPL'(1,1) EQ '(').RCPPL\n         LA    R14,&CPPL          LOAD CPPL ADDRESS\n         ST    R14,16(R1)          AND STORE IT\n         AGO   .GO\n.DCPPL   MVC   16(4,R1),&RCPPRE.CPPL MOVE IN CPPL ADDRESS\n         AGO   .GO\n.RCPPL   ST    &CPPL(1),16(R1)    STORE ADDRESS OF CPPL\n.*       LINK  EP=IKJEFF18         MODIFIED BY BZFONT\n.GO      ANOP\n         AIF   (NOT &GEN).EXIT\n         SPACE 1\n         RCPDS\n&C SETC 'FAIL&SYSNDX'\n&C       DS    6F             RESERVE SPACE FOR PARAM LIST\n         RCPDS\n.EXIT    MEND\n         MACRO\n         RCPFDDN &DDN\n         GBLC &DYNP\n         SPACE\n***********************************************************************\n**        FREE DDNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DDN'(1,1) EQ '''').Q\n         AIF   ('&DDN'(K'&DDN,1) EQ '/').B\n         RCPSR2\n         AIF   ('&DDN'(1,1) EQ '(').R\n         L     R14,&DDN                LOAD ADDRESS OF DDNAME\n         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME\n         AGO   .STH\n.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME\n         LH    R2,4&DDN                LOAD LENGTH OF DDNAME\n.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DDNAME\n         MVI   S99TUKEY+1,DUNDDNAM     MOVE IN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.Q       RCPBTU DUNDDNAM,1,&DDN\n         MEXIT\n.B       RCPTUBFR DUNDDNAM,14,&DDN\n         MEND\n         MACRO\n         RCPDISP &DISP\n         LCLA  &I\n         LCLB  &B(4)\n         AIF   ('&DISP(1)' EQ '').TD2\n         SPACE\n***********************************************************************\n**     DATA SET INITIAL STATUS                                       **\n***********************************************************************\n&B(1)    SETB  ('&DISP(1)' EQ 'SHR')\n&B(2)    SETB  ('&DISP(1)' EQ 'NEW')\n&B(3)    SETB  ('&DISP(1)' EQ 'MOD')\n&B(4)    SETB  ('&DISP(1)' EQ 'OLD')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1\n         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'\n&B(1)    SETB  1\n.OK1     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')\n         RCPDINC 8\n.TD2     AIF   ('&DISP(2)' EQ '').TD3\n         SPACE\n***********************************************************************\n**    DATA SET NORMAL DISPOSITION                                    **\n***********************************************************************\n&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2\n         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'\n&B(1)    SETB  1\n.OK2     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.TD3     AIF   ('&DISP(3)' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   DATASET CONDITIONAL DISPOSITION                                 **\n***********************************************************************\n&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')\n&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')\n&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')\n&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')\n         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3\n         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'\n&B(1)    SETB  1\n.OK3     ANOP\n&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)\n         MVC   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')\n         RCPDINC 8\n.EXIT    MEND\n         MACRO\n         RCPSR2 &A\n         GBLB  &RCPSR2\n         GBLC  &DYNP\n         LCLC  &C\n.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY\n.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND\n.*    GENERATES MOVE INSTRUCTION FOR EXECUTE\n         AIF   ('&A' NE '').UNSAVE\n         AIF   (&RCPSR2).EXIT\n&RCPSR2  SETB  1\n         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2\n         MEXIT\n.UNSAVE  AIF   (NOT &RCPSR2).EXIT\n         B     *+10                    SKIP NEXT INSTRUCTION\n&C       SETC  '&DYNP.MVC'\n&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE\n         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2\n&RCPSR2  SETB  0\n.EXIT    MEND\n         MACRO\n&NAME    DYNSPACE &TYPE\n.*\n.*    THIS IS AN INNER MACRO TO ALLOC/FREE.\n.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST\n.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY\n.*                         EACH, REMEMBERING THE LARGEST.\n.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.\n.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,\n.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,\n.*    OR BY BEGINWKA, IF THE LATTER IS USED.\n.*\n.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE\n.*     NAME DYNSPACE\n.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE\n.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL\n.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.\n.*\n.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL\n.*          DYNSPACE ADD\n.*     (NO NAME FIELD AND ONE OPERAND)\n.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE\n.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE\n.*     CURRENT REQUEST IS FOR A GREATER AMOUNT\n.*\n.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO\n.*     NAME OR OPERAND FIELD.\n.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME\n.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.\n.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.\n.*\n         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN\n         GBLC  &DYNP,&DYNSP\n         LCLA  &I\n         AIF   ('&NAME' NE '').NAME\n         AIF   ('&TYPE' EQ '').ALLOC\n.*   THE ACCUMULATE FUNCTION IS REQUIRED\n&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST\n         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT\n&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM\n         MEXIT\n.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT\n&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME\n.EXIT    MEXIT\n.ALLOC   AIF   ('&DYNSP' EQ '').EXIT\n*\n**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA\n*\n&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE\n&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0\n&DYNSPQ  SETA 0\n         MEND\n         MACRO\n         RCPDDNRT\n         SPACE 1\n***********************************************************************\n**    DDNAME RETURN TEXT UNIT                                        **\n***********************************************************************\n         MVI   S99TUKEY+1,DALRTDDN     SET RETURN DDNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         MVI   S99TULNG+1,8            SET LENGTH FIELD\n         MVC   S99TUPAR(8),=CL8' '     INITIALIZE FIELD TO BLANKS\n         RCPDINC 14\n         MEND\n         MACRO\n         RCPDSN &DSN,&MEM\n         LCLC  &MEMBER\n         GBLC  &DYNP\n         SPACE\n***********************************************************************\n**   BUILD THE DSNAME TEXT UNIT                                      **\n***********************************************************************\n         AIF   ('&DSN'(1,1) EQ '''').Q\n         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD\n         AIF   ('&DSN'(1,1) EQ '(').REG\n         AIF   ('&DSN'  EQ '*').TERM\n         RCPSR2\n         L     R14,&DSN                LOAD ADDRESS OF DSNAME\n         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME\n.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE DSNAME\n         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 50\n         AGO   .TMEMBER\n.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME\n         RCPSR2\n         LH    R2,4&DSN                LOAD LENGTH OF DSNAME\n         AGO   .STH\n.TERM    MVI   S99TUKEY+1,DALTERM\n         RCPDINC 4\n         MEXIT\n.BD      RCPTUBFR DALDSNAM,50,&DSN\n         AGO   .TMEMBER\n.Q       RCPBTU DALDSNAM,1,&DSN\n.TMEMBER AIF   ('&MEM' EQ '').EXIT\n         SPACE\n***********************************************************************\n**   BUILD THE MEMBER NAME TEXT UNIT                                 **\n***********************************************************************\n&MEMBER  SETC  '&MEM'\n         AIF   ('&MEM' NE '*').MOK\n         AIF   ('&DSN'(1,1) NE '''').MAST\n         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'\n         MEXIT\n.MAST    ANOP\n&MEMBER  SETC  '8+&DSN'\n.MOK     ANOP\n         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM\n         RCPSR2\n         AIF   ('&MEMBER'(1,1) EQ '(').RM\n         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME\n         LTR   R2,R2                   TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER\n         AGO   .STHM\n.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER\n         LTR   R2,R2                   AND TEST FOR ZERO\n         BZ    *+30                    IF NO MEMBER, SKIP\n         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER\n.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER\n         BCTR  R2,0                    DECREMENT FOR EXECUTE\n         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME\n         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY\n         MVI   S99TUNUM+1,1            SET NUMBER FIELD\n         RCPDINC 14\n         MEXIT\n.BM      RCPTUBFR DALMEMBR,14,&MEMBER\n         MEXIT\n.QM      RCPBTU DALMEMBR,1,&MEMBER\n.EXIT    MEND\n         MACRO\n&NAME    FREE  &UNALC,&DSN=,&DDN=,&MEMBER=,&DISP=,&SYSOUT=,            X\n               &ERROR=,&MF=AUTO,&PREFIX=,&FILE=,&F=,&DA=,&HOLD=\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n&T       SETC  'A'\n&PAR     SETC  '&MF(2)+4'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n&PAR     SETC  '&MF(2)'(2,K'&MF(2)-2)\n&T       SETC  'R'\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n&PAR     SETC  '4&MF(2)'\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n&T       SETC  'A'\n&PAR     SETC  '&DYNP.RB'\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBUN        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&SYSOUT' NE '').SYSOUT\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TUNALC  AIF   ('&UNALC' NE '').PERM\n.THOLD   AIF   ('&HOLD' NE '').HOLD\n         AGO   .SVC99\n.DSN     RCPFDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.SYSOUT  RCPFSYS &SYSOUT\n         AGO   .TDDN\n.DDN     RCPFDDN &DDN&F&FILE\n         AGO   .TDISP\n.DISP RCPFDISP &DISP\n         AGO   .TUNALC\n.PERM    RCPUNALC\n         AGO   .THOLD\n.HOLD    RCPFHOLD &HOLD\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n.DYNA    DYNALLOC\n         AIF   ('&ERROR' EQ '').RESERVE\n         AIF   ('&PAR' EQ '').LTR\n         L&T   R14,&PAR                 LOAD REG 14 WITH ADDRESS OF RB\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n.LTR     LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n**       NOTE.  R14 POINTS TO REQUEST BLOCK, R15 HAS RETURN CODE     **\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC DATA                             **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU11\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AGO   .DTU10\n.DTU11   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n         MACRO\n&NAME    ALLOC &DUMMY,&PERM,                                           X\n               &WAITDSN=NO,&WAITVOL=NO,&WAITUNIT=NO,                   X\n               &DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,                   X\n               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X\n               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X\n               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X\n               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X\n               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,&TERM=,    X\n               &FCB=,                                                  X\n               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=,&MSVGP=\n.**********************************************************************\n.*                                                                    *\n.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *\n.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *\n.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *\n.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *\n.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *\n.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *\n.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *\n.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *\n.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *\n.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *\n.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *\n.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *\n.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *\n.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *\n.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *\n.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *\n.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *\n.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *\n.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *\n.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *\n.*    THAT QUANTITY. (SEE DYNSPACE)                                   *\n.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *\n.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *\n.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *\n.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *\n.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *\n.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *\n.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *\n.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *\n.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *\n.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *\n.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *\n.*                                                                    *\n.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *\n.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *\n.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *\n.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *\n.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *\n.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *\n.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *\n.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *\n.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *\n.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *\n.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *\n.*    CONTAIN THE LENGTH.                                            *\n.*    EG          ALLOC DSN=LOCATOR                                  *\n.*       LOCATOR  DC    A(DSN),Y(12)                                 *\n.*       DSN      DC    C'SYS1.LINKLIB'                              *\n.*                                                                   *\n.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *\n.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *\n.*       A VALUE IN A REGISTER, COPIES=(R3),                         *\n.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *\n.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *\n.*       FULLWORD FIELD.                                             *\n.*                                                                   *\n.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *\n.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *\n.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *\n.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *\n.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *\n.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *\n.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *\n.*       SUPERVISOR AND TSO).                                        *\n.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *\n.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *\n.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *\n.*       ARE TO RECEIVE THE DDNAME.                                  *\n.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *\n.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *\n.*                                                                   *\n.**********************************************************************\n.*  MODIFIED 08/25/82 TO ADD MSVGP SUPPORT .                         *\n.*  MODIFIED 09/10/82 TO ADD TERM  SUPPORT .                         *\n.*  MODIFIED 10/27/83 TO:                                            *\n.*             ADD WAITVOL TO WAIT FOR VOLUME TO BE MOUNTED.         *\n.*             ADD WAITDSN TO WAIT FOR DSN TO BECOME AVAILABLE.      *\n.*             ADD WAITUNIT TO WAIT FOR UNIT TO BECOME AVAILABLE.    *\n.*             **  THESE THREE OPTIONS ARE VALID ONLY IF THE USER    *\n.*             **  IS AN AUTHORIZED PROGRAM                          *\n.*                   LIONEL DYCK/ROCKWELL INT'L  (213) 594-1647      *\n.**********************************************************************\n         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO\n         GBLA  &DTUO              OFFSET TO TEXT UNITS\n         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS\n         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS\n         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL\n         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC\n         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS\n         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS\n         LCLA  &I                 COUNTER\n         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E\n         LCLC  &C,&T,&PAR\n.*\n.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,\n&RCPS99(1)     SETB           1\n&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER\n&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX\n&NAME    DS    0H\n         AIF   ('&PREFIX' EQ '').TMF\n         AIF   (K'&PREFIX LT 4).POK\n         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'\n&DYNP    SETC  '&PREFIX'(1,4)\n         AGO   .TMF\n.POK     ANOP\n&DYNP    SETC  '&PREFIX'\n.TMF     AIF   ('&MF(1)' EQ 'G').GEN\n         AIF   ('&MF' NE 'AUTO').TMFE\nNAME     DYNSPACE             GET NAME FOR SPACE\n         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n&T       SETC  'A'\n&PAR     SETC  '&DYNSP+4'\n&DSECT   SETB  1\n         AGO   .START\n.TMFE    AIF   ('&MF(2)' NE '').E2OK\n         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'\n         AGO   .GEN\n.E2OK    ANOP\n&DSECT   SETB  1\n         AIF   ('&MF(2)' EQ '(').RMFE\n         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS\n         USING &DYNP.DS,R1             USE GENERATED DSECT\n         AGO   .START\n.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START\n         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS\n         AGO   .START\n.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP\n.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB\n         USING S99RB,R15\n         ST    R15,0(R1)               AND STORE IN RB POINTER\n         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST\n         MVI   S99RBLN,20              MOVE IN LIST LENGTH\n         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE\n         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS\n         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB\n         AIF   ('&WAITDSN' EQ 'NO').NWD\n         OI    S99FLG21,S99WTDSN       SET WAIT FOR DSN FLAG\n.NWD     AIF   ('&WAITVOL' EQ 'NO').NWV\n         OI    S99FLG21,S99WTVOL       SET WAIT FOR VOLUME\n.NWV     AIF   ('&WAITUNIT' EQ 'NO').NWU\n         OI    S99FLG21,S99WTUNT       SET WAIT FOR UNIT\n.NWU     ANOP\n         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS\n         USING S99TUNIT,R15\n&DTUO    SETA  0\n&DTUPO   SETA  0\n         AIF   ('&SSREQ' EQ 'YES').SSREQ\n.TDSN    AIF   ('&DSN&DA' NE '').DSN\n         AIF   ('&DSNPDE' NE '').DSNPDE\n         AIF   ('&DSNRET' NE '').DSNRT\n         AIF   ('&SYSOUT' NE '').SYSOUT\n         AIF   ('&DUMMY' NE '').DUMMY\n         AIF   ('&QNAME' NE '').QNAME\n.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN\n         AIF   ('&DDNRET&DDNTO' NE '').DDNRT\n.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT\n.TVOLRET AIF   ('&VOLRET' NE '').VOLRET\n.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT\n.TLABEL  AIF   ('&LABEL' NE '').LABEL\n.TPSWD   AIF   ('&PASWORD' NE '').PASWORD\n.TFORUSE AIF   ('&FORUSER' NE '').FORUSER\n.TTU     AIF   ('&TU' NE '').TU\n.TDISP   AIF   ('&DISP' NE '').DISP\n.TSPACE  AIF   ('&SPACE' NE '').SPACE\n.TLRECL  AIF   ('&LRECL' NE '').DCB\n         AIF   ('&DEN' NE '').DCB\n         AIF   ('&RECFM' NE '').DCB\n         AIF   ('&BLKSIZE' NE '').DCB\n         AIF   ('&DSORG' NE '').DCB\n         AIF   ('&KEYLEN' NE '').DCB\n.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN\n.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN\n.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343\n.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM\n         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM\n.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL\n.TMSVGP  AIF   ('&MSVGP' NE '').MSVGP\n.TTERM   AIF   ('&TERM' NE '').TERM\n         AGO   .SVC99\n.TERM    RCPTERM\n         AGO   .SVC99\n.SSREQ   RCPSSREQ\n         AGO   .TDSN\n.DSN     RCPDSN &DSN&DA,&MEMBER\n         AGO   .TDDN\n.DSNPDE  RCPDSNPD &DSNPDE\n         AGO   .TDDN\n.DSNRT   RCPDSNRT &DSNRET\n&DSNRTO  SETA  &DTUO-46\n         AGO   .TDDN\n.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X\n               FORMS=&FORMS,FCB=&FCB\n         AGO   .TDDN\n.DUMMY   RCPDUMMY &DUMMY\n         AGO   .TDDN\n.QNAME   RCPQNAME &QNAME\n         AGO   .TDDN\n.DDN     RCPDDN &DDN&F&FILE\n         AGO   .TUNIT\n.DDNRT   RCPDDNRT &DDNRET\n&DDNRTO  SETA  &DTUO-10\n         AGO   .TUNIT\n.UNIT   RCPUNIT &UNIT,&VOL\n         AGO   .TVOLRET\n.VOLRET  RCPVOLRT &VOLRET\n&VOLRTO  SETA  &DTUO-8\n         AGO   .TDSRGO\n.DSORGRT RCPDSRGR\n&DSRGRTO SETA  &DTUO-2\n         AGO   .TLABEL\n.LABEL   RCPLABEL &LABEL\n         AGO   .TPSWD\n.PASWORD RCPPSWD &PASWORD\n         AGO   .TFORUSE\n.FORUSER RCPFORUS &FORUSER\n         AGO   .TTU\n.TU      RCPTU &TU\n         AGO   .TDISP\n.DISP    RCPDISP &DISP\n         AGO   .TSPACE\n.SPACE   RCPSPACE &SPACE\n         AGO   .TLRECL\n.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X\n               DSORG=&DSORG,KEYLEN=&KEYLEN\n         AGO .TDCBDSN\n.DCBDSN  RCPDCBDS &DCBDSN\n         AGO .TDCBDDN\n.DCBDDN  RCPDCBDD &DCBDDN\n         AGO .TFREE                                              TE7343\n.FREE    RCPFREE  &FREE                                          TE7343\n         AGO   .TPERM\n.PERM    RCPPERM\n         AGO   .TSPECI\n.MSVGP   RCPMSVGP &MSVGP\n         AGO   .SVC99\n.SPECIAL RCPSPEC &SPECIAL\n.SVC99   ANOP\n&DTUPO   SETA  &DTUPO-4\n         SPACE\n         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS\n         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR\n         RCPSR2 UNSAVE\n&DTUPO   SETA  &DTUPO+4\n         AIF   (NOT &DSECT).DYNA\n         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY\n         LA    R14,4(R1)               POINT TO REQUEST BLOCK\n.DYNA    DYNALLOC\n         AIF   (NOT &DSECT).LTR\n         USING &DYNP.RB,R14            SET UP ADDRESSABILITY\n**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **\n.LTR     AIF   ('&ERROR' EQ '').TDDTO\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   &ERROR                  BRANCH IF NON ZERO\n.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE\n&I       SETA  0\n.DDNTOL  ANOP\n&I       SETA  &I+1\n         AIF   ('&DDNTO(&I)' EQ '').RESERVE\n         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR\n         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.DDNTOR  ANOP\n&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)\n         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2\n         AGO   .DDNTOL\n.RESERVE AIF   (&DSECT).RESDS\n         SPACE 1\n***********************************************************************\n**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **\n***********************************************************************\n         RCPDS\n.SSP     ANOP\n&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER\n&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK\n&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS\n         AIF   (&DTUO EQ 0).DTU21\n&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS\n         AIF   (&DSNRTO EQ 0).TDDNRTO\n&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN\n.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11\n&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME\n.DTU11   AIF   (&VOLRTO EQ 0).DTU12\n&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER\n.DTU12   AIF   (&DSRGRTO EQ 0).DTU10\n&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG\n         AGO   .DTU10\n.DTU21   ANOP\n&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS\n.DTU10   ANOP\n&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED\n         AIF   (&DSECT).DSP\n         RCPDS\n         SPACE 3\n         AGO   .EXIT\n.RESDS   ANOP\n         AIF   ('&DYNSP' EQ '').SP3\n         DYNSPACE ADD\n.SP3     SPACE\n&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA\n         AGO   .SSP\n.DSP     AIF   ('&MF(3)' EQ '').END1\n&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA\n.END1    ANOP\n&SYSECT  CSECT\n         SPACE 3\n.EXIT    MEND\n         MACRO\n&LABEL   $EPILOG &RC\n         GBLC  &PROGM\n&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         AIF   ('&PROGM' NE 'GETMAIN').NOFREE\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         AGO   .LM\n.NOFREE  ANOP\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n.LM      ANOP\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         AIF   (T'&RC EQ 'O').SPEC\n         LA    R15,&RC             SET RETURN CODE\n.SPEC    ANOP\n         BR    R14                 RETURN TO CALLER\n         MEND\n         MACRO\n&LABEL   $PROLOG &LV=0,&GM=Y\n.**********************************************************************\n.*\n.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY\n.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD\n.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE\n.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS\n.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:\n.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE\n.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE\n.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA\n.*                                             REG 10 IS BASE\n.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES\n.*\n.**********************************************************************\n         LCLA  &AA,&AB,&AC\n         GBLB  &PRORG\n         GBLC  &PROGM\n&AC      SETA  4096\n&LABEL   CSECT\n         B     32(R15)             BRANCH AROUND\n         DC    AL1(26)\n         DC    CL8'&LABEL'         CSECT NAME\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\n         CNOP  0,4                 ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING &LABEL,R12          INFORM ASSEMBLER\n         AIF   (&LV GT 4023).MERR\n         AIF   ('&GM' EQ 'N').NOGM\n&PROGM   SETC  'GETMAIN'\n         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE\n         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER\n         AIF   (&LV+72 LE 256).XC2\n         AIF   (&LV+72 LE 512).XC1\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         AGO   .STORE\n.XC1     ANOP\n         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA\n         XC    0(256,R1),0(R1)          CLEAR SAVE AREA\n         AGO   .STORE\n.XC2     ANOP\n         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA\n         AGO   .STORE\n.NOGM    ANOP\n         CNOP  0,4\n         LA    R1,SAVE&SYSNDX\n         B     *+76\nSAVE&SYSNDX DC 18F'0'\n.STORE   ANOP\n         ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R11             SET SAVEAREA POINTER\n         AIF   (N'&SYSLIST EQ 0).MEND\n         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT\n         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT\n         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG\n         DROP  R12                 DROP ASSUMED BASE REG\n         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER\n.SKIPIT  ANOP\n&AA      SETA  2\n.LOOP    ANOP\n         AIF   (&AA GT N'&SYSLIST).MEXIT\n&AB      SETA  &AA-1\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG\n         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG\n         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER\n&AC      SETA  &AC+4096\n&AA      SETA  &AA+1\n         AGO   .LOOP\n.MEXIT   ANOP\n         AIF   (&PRORG).MEX2\n         SPACE\n         $REGS\n         SPACE\n.MEX2    ANOP\n&AA      SETA  &LV+72\n         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'\n         MEXIT\n.MEND    ANOP\n         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'\n         AGO   .MEXIT\n.MERR    ANOP\n         MNOTE 12,'LV > 4023 - REQUEST IGNORED'\n         AGO   .MEXIT\n         MEND\n         MACRO\n&L       CVDT  &O\n.*\n&L       XR    R15,R15\n         IC    R15,DS1&O\n         CVD   R15,DWD\n         ICM   R14,B'0011',DWD+L'DWD-2\n         ICM   R15,B'0011',DS1&O+1\n         CVD   R15,DWD\n         SRL   R14,4\n         STC   R14,DWD+5\n         ED    FMT&O,DWD+5\n         SPACE\n.*\n         MEND\n         EJECT                                             *LBD 11/83*\n         MACRO\n&L       CVRTX &O,&ADD=0,&OFFSET=0\n.*\n&L       XR    R15,R15\n         L     R15,DS1&O\n.*\n         CVD   R15,DWD\n         ED    FMT&O,DWD+8-((L'FMT&O+1)/2)\n         SPACE\n.*\n         MEND\n         MACRO\n&L       CVRT  &O,&ADD=0,&OFFSET=0\n.*\n&L       XR    R15,R15\n         LA    R1,1\n         SLA   R1,(L'DS1&O-&OFFSET)\n         BCTR  R1,0\n         EX    R1,*+L'*+4\n         B     *+L'*+4\n         ICM   R15,*-*,DS1&O+&OFFSET\n.*\n         AIF   (&ADD EQ 0).CVD\n.*\n         LA    R15,&ADD.(R15)\n.*\n.CVD     ANOP\n.*\n         CVD   R15,DWD\n         ED    FMT&O,DWD+8-((L'FMT&O+1)/2)\n         SPACE\n.*\n         MEND\n         EJECT                                             *LBD 11/83*\n         MACRO                                             *LBD 11/83*\n         JUSTL &OUT,&IN                                    *LBD 11/83*\n         LA    R1,&IN                  -> INPUT FIELD      *LBD 11/83*\n         LA    R2,&OUT                 -> OUTPUT FIELD     *LBD 11/83*\n         LA    R3,L'&IN                LOAD LEN            *LBD 11/83*\nS&SYSNDX DS    0H                      START JUSTIFICATION *LBD 11/83*\n         CLI   0(R1),C' '              BLANK               *LBD 11/83*\n         BE    U&SYSNDX                YES - INCREMENT     *LBD 11/83*\n         MVC   0(1,R2),0(R1)           MOVE CHARACTER      *LBD 11/83*\n         LA    R2,1(R2)                DITTO               *LBD 11/83*\nU&SYSNDX DS    0H                                          *LBD 11/83*\n         LA    R1,1(R1)                INCR BY 1           *LBD 11/83*\n         BCT   R3,S&SYSNDX             KEEP DOING IT       *LBD 11/83*\nE&SYSNDX DS    0H                      END OF JUSTIFICATION*LBD 11/83*\n         SPACE 2                                           *LBD 11/83*\n         MEND                                              *LBD 11/83*\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   PERFORM STANDARD REENTRANT PROLOGUE - GET WORK AREA AND SET UP   *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDSNINFO  $PROLOG R11,R12\n         EJECT                                             *LBD 12/83*\n         L     R1,0(R1)         * LOAD ADDR OF PARM        *LBD 12/83*\n         LH    R2,0(R1)         * LOAD LENGTH OF PARM      *LBD 12/83*\n         LTR   R2,R2            * LENGTH OF ZERO           *LBD 12/83*\n         BZ    NOPARM           * NO - BYPASS MOVE         *LBD 12/83*\n         BCTR  R2,R0            * SUBTRACT LENGTH BY 1     *LBD 12/83*\n         MVC   DSN+1(8),=CL8' '                            *LBD 12/83*\n         EX    R2,MVCPARM       * EXECUTE THE MOVE         *LBD 12/83*\nNOPARM   DS    0H                                          *LBD 12/83*\n         EJECT\n         GETMAIN R,LV=DSALEN                               *LBD 12/83*\n         ST    R1,CORE                                     *LBD 12/83*\n         LR    R8,R1                                       *LBD 12/83*\n         SPACE 2\n         USING DSAWRK,R8\n         USING UCBWRK,R7\n         EJECT\n         SPACE\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,EXTRACT)\n         EJECT\n*----------------------------------------------------------------*LBD*\n*                                                                *LBD*\n*        ACQUIRE DATASET NAME FROM ISPF                          *LBD*\n*                                                                *LBD*\n*----------------------------------------------------------------*LBD*\n         L     R15,ISPLINK\n         CALL  (15),(VDEFINE,ZPRF,VZPRF,CHAR,LZPRF),VL     *LBD 12/83*\n         EJECT                                             *LBD 12/83*\n         L     R15,ISPLINK\n         CALL  (15),(VDEFINE,DSN,VDSN,CHAR,LDSN),VL              *LBD*\n         EJECT                                             *LBD 12/83*\n         L     R15,ISPLINK\n         CALL  (15),(VGET,DSN,SHARED),VL                         *LBD*\n         EJECT                                             *LBD 12/83*\n         L     R15,ISPLINK\n         CALL  (15),(VGET,ZPRF,SHARED),VL                  *LBD 12/83*\n         EJECT                                             *LBD 12/83*\n         LA    R1,ODSN\n         LA    R2,VDSN\n         CLI   0(R2),X'7D'             QUOTE ?\n         BE    DSNUP                   YES - SKIP IT\n         MVC   TDSN(8),VZPRF           MOVE PREFIX         *LBD 12/83*\n         LA    R3,TDSN                                     *LBD 12/83*\nFINDP    CLI   0(R3),C' '                                  *LBD 12/83*\n         BE    MVCP                                        *LBD 12/83*\n         LA    R3,1(R3)                                    *LBD 12/83*\n         B     FINDP                                       *LBD 12/83*\nMVCP     MVI   0(R3),C'.'                                  *LBD 12/83*\n         LA    R3,1(R3)                                    *LBD 12/83*\n         L     R1,LDSN                                     *LBD 12/83*\n         BCTR  R1,R0                                       *LBD 12/83*\n         STC   R1,MVCPDSN+1                                *LBD 12/83*\nMVCPDSN  MVC   0(0,R3),VDSN                                *LBD 12/83*\n         LA    R1,ODSN                                     *LBD 12/83*\n         LA    R2,TDSN                                     *LBD 12/83*\nDSNLP    DS    0H\n         CLI   0(R2),X'7D'             QUOTE ?\n         BE    EDSN                    YES - SKIP IT\n         CLI   0(R2),C' '              END OF DSNAME\n         BE    EDSN                    YES - SKIP IT\n         CLI   0(R2),C'('              START OF MEMBER ?\n         BE    HMEMBER                 YES\n         MVC   0(1,R1),0(R2)           MOVE CHAR\n         LA    R1,1(R1)\nDSNUP    LA    R2,1(R2)\n         B     DSNLP\nHMEMBER  DS    0H\n         LA    R1,OMEM                 -> MEMBER\n         LA    R2,1(R2)                -> START OF MEMBER NAME\nMLP      CLI   0(R2),C')'              END OF MEMBER NAME ?\n         BE    EDSN                    YES\n         MVC   0(1,R1),0(R2)           NO - MOVE IT\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         B     MLP\nEDSN     DS    0H                      END OF DSNAME\n         L     R15,ISPLINK\n         CALL  (15),(VDEFINE,NAMES,VNAMES,CHAR,LNAMES),VL        *LBD*\n         MVC   MEMBER,OMEM\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*        ALLOC DATASET                                           *LBD*\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDSLOOP   EQU   *\n         SPACE\n         ALLOC DDNRET=DDNRET,DSN=OURDSN,ERROR=S99FAIL,DISP=SHR   *LBD*\n         MVC   OURDDN,DDNRET+2                                   *LBD*\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   LOOK UP DDNAME IN TIOT, GET UCB INFORMATION, AND OBTAIN DSCB'S   *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\n         L     R15,TIOTA\n         LA    R15,TIOENTRY-TIOT(R15)\n         USING TIOENTRY,R15\n         XR    R14,R14\n         SPACE\nTIOLOOK  EQU   *\n         CLC   TIOEDDNM,OURDDN\n         BE    DDNHIT\n         IC    R14,TIOELNGH\n         LA    R15,0(R14,R15)\n         LTR   R14,R14\n         BP    TIOLOOK\n         SPACE\n         ABEND 100\n         SPACE\nDDNHIT   EQU   *\n         ICM   R7,B'0111',TIOEFSRT\n         MVC   VOLSER,UCBVOLI\n         MVC   CUU,UCBNAME\n         MVC   DWD,OURDDN\n         SPACE\n         DEVTYPE DWD,DVTWKA,DEVTAB\n         SPACE\n         LA    R1,DEVTAB                                   *LBD 11/83*\nDEVLOOP  CLC   0(1,R1),UCBTYP+3        OUR DEVICE          *LBD 11/83*\n         BE    HAVEDEV                 YES                 *LBD 11/83*\n         LA    R1,9(R1)                -> NEXT DEVICE      *LBD 11/83*\n         CLI   0(R1),X'FF'             END OF TABLE        *LBD 11/83*\n         BNE   DEVLOOP                                     *LBD 11/83*\n         MVC   MYDEVTYP,=CL8'UNKNOWN'                      *LBD 11/83*\n         B     GOTDEV                                      *LBD 11/83*\nHAVEDEV  MVC   MYDEVTYP,1(R1)                              *LBD 11/83*\n         TM    UCBTYP+1,X'08'          3330V               *LBD 11/83*\n         BZ    GOTDEV                                      *LBD 11/83*\n         MVC   MYDEVTYP,=CL8'3330V'                        *LBD 11/83*\nGOTDEV   DS    0H                                                *LBD*\n         SPACE\n         MVC   CAMLST,CAMSRCH\n         EJECT\nOBTAINF1 EQU   *\n         LA    R15,ODSN\n         ST    R15,CAMDSN\n         LA    R15,VOLSER\n         ST    R15,CAMSER\n         LA    R15,OBTWKA\n         ST    R15,CAMWKA\n         XR    R0,R0\n         SPACE\n         OBTAIN CAMLST\n         SPACE\n         LTR   R15,R15\n         BNZ   OBTNFAIL\n         SPACE\n         CLI   DS1NOEPV,3\n         BNH   FORMAT\n         SPACE\n         LA    R15,DS1PTRDS\nOBTAINF3 ST    R15,CAMDSN\n         LA    R15,F3WKA\n         ST    R15,CAMWKA\n         MVC   CAMLST,CAMSEEK\n         SPACE\n         OBTAIN CAMLST\n         SPACE\n         LTR   R15,R15\n         BNZ   OBTNFAIL\n         SPACE\n         CLI   DS3FMTID,C'3'\n         LA    R15,DS2PTRDS\n         BNE   OBTAINF3\n         SPACE\n         DROP  R15\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   OUTPUT HEADINGS AND FORMAT DATA SET LABEL INFORMATION IN BUFFER  *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nFORMAT   EQU   *\n         MVC   OUTPUT,MASK                                 *LBD 11/83*\n         SPACE\n*DS1SCAL EQU   DS1SCALO+1,3\n         CVRT  SCAL\n         CVRT  BLKL\n         MVC   TRKCALDD,DS1BLKL    SAVE BLKSIZE             *LBD 03/85*\n         EJECT\n         CVRT  LRECL\n         CVRT  KEYL\n         MVC   TRKCALK,DS1KEYL     SAVE KEY FOR TRKCALC     *LBD 03/85*\n         CVRT  RKP\n         CVRT  NOEPV\n         EJECT\nRFAORM   LA    R15,FMTRECFM+L'FMTRECFM-1\n         TM    DS1RECFM,B'00000110'\n         BZ    RFT\n         BCTR  R15,0\n         TM    DS1RECFM,B'00000010'\n         BZ    RFA\nRFM      MVI   1(R15),C'M'\n         B     RFT\nRFA      MVI   1(R15),C'A'\nRFT      TM    DS1RECFM,B'00100000'\n         BZ    RFS\n         MVI   0(R15),C'T'\n         BCTR  R15,0\nRFS      TM    DS1RECFM,B'00001000'\n         BZ    RFB\n         MVI   0(R15),C'S'\n         BCTR  R15,0\nRFB      TM    DS1RECFM,B'00010000'\n         BZ    RFU\n         MVI   0(R15),C'B'\n         BCTR  R15,0\nRFU      TM    DS1RECFM,B'11000000'\n         BM    RFFORV\n         BZ    UNITS\n         MVI   0(R15),C'U'\n         B     UNITS\nRFFORV   TM    DS1RECFM,B'10000000'\n         BO    RFF\n         MVI   0(R15),C'V'\n         B     UNITS\nRFF      MVI   0(R15),C'F'\n         EJECT\nUNITS    XR    R15,R15\n         IC    R15,DS1SCALO\n         SRL   R15,6\n         LA    R14,ALLCUNIT(R15)\n         CLI   0(R14),C'A'                                 *LBD 11/83*\n         BE    UNABS                                       *LBD 11/83*\n         CLI   0(R14),C'B'                                 *LBD 11/83*\n         BE    UNBLK                                       *LBD 11/83*\n         CLI   0(R14),C'T'                                 *LBD 11/83*\n         BE    UNTRK                                       *LBD 11/83*\n*        ASSUME CYLINDER ALLOCATION                        *LBD 11/83*\nUNCYL    MVC   FMTUN(3),=C'CYL'                            *LBD 11/83*\n         B     UNDONE                                      *LBD 11/83*\nUNABS    MVC   FMTUN(3),=C'ABS'                            *LBD 11/83*\n         B     UNDONE                                      *LBD 11/83*\nUNBLK    MVC   FMTUN(3),=C'BLK'                            *LBD 11/83*\n         B     UNDONE                                      *LBD 11/83*\nUNTRK    MVC   FMTUN(3),=C'TRK'                            *LBD 11/83*\nUNDONE   DS    0H                                          *LBD 11/83*\n         SPACE\n         LA    R15,FMTDSORG+L'FMTDSORG-2\n         TM    DS1DSORG+1,X'08'        VSAM DATASET ?       *LBD 02/84*\n         BO    DSVSAM                                       *LBD 02/84*\n         TM    DS1DSORG,1\n         BZ    DODSORG\n         MVI   1(R15),C'U'\n         BCTR  R15,0\n         B     DODSORG                                      *LBD 02/84*\n         SPACE\nDSVSAM   MVC   FMTDSORG+2(2),=C'VS'    SET AS VSAM          *LBD 02/84*\n         B     DATES                   SKIP DIR COUNT       *LBD 02/84*\n         SPACE 1                                            *LBD 02/84*\nDODSORG  MVC   DWD(1),DS1DSORG\n         NI    DWD,X'E2'\n         TR    DWD(1),TRDSORG\n         XR    R1,R1\n         IC    R1,DWD\n         LA    R14,DSORGMN(R1)\n         MVC   0(2,R15),0(R14)\n         CLC   FMTDSORG+2(2),=C'PO'                        *LBD 11/83*\n         BNE   DATES                   NO - SKIP DIR COUNT *LBD 11/83*\n         EJECT                                             *LBD 11/83*\n*----------------------------------------------------------*LBD 11/83*\n*                                                          *LBD 11/83*\n*        COUNT  USED DIRECTORY BLOCKS                      *LBD 11/83*\n*                                                          *LBD 11/83*\n*----------------------------------------------------------*LBD 11/83*\n         MVC   PDS+40(8),OURDDN        SET UP DDNAME       *LBD 11/83*\n         OPEN  PDS                                         *LBD 11/83*\n         USING DIR,R10                                     *LBD 11/83*\nREADDIR  GET   PDS                                         *LBD 11/83*\n         LR    R10,R1                                      *LBD 11/83*\n         LH    R9,0(R10)                                   *LBD 11/83*\n         AR    R9,R10                  -> END OF DIR BLOCK *LBD 11/83*\n         LA    R10,2(R10)              -> PAST LENGTH      *LBD 11/83*\n         AP    DIRACNT,=P'01'          ADD 1 TO ALLOC CNT  *LBD 11/83*\nPLPS     CLI   DIRNAME,X'FF'           LAST USED BLOCK ?   *LBD 11/83*\n         BE    ENDUSE                  YES -               *LBD 11/83*\n         TM    DIRFLAG,DIRALIAS        ALIAS ??            *LBD 11/83*\n         BZ    NOTALIAS                NO                  *LBD 11/83*\n         AP    ALIASCNT,=P'01'                             *LBD 11/83*\nNOTALIAS DS    0H                                          *LBD 11/83*\n         AP    MEMCNT,=P'01'                               *LBD 11/83*\n         SR    R1,R1                                       *LBD 11/83*\n         NI    DIRFLAG,X'1F'           TURN OFF MISC BITS  *LBD 11/83*\n         IC    R1,DIRFLAG                                  *LBD 11/83*\n         LA    R1,6(R1)                ADD 6 HALF WORDS    *LBD 11/83*\n         SLA   R1,1                    MULT BY 2           *LBD 11/83*\n         AR    R10,R1                                      *LBD 11/83*\n         CR    R10,R9                                      *LBD 11/83*\n         BL    PLPS                                        *LBD 11/83*\n         AP    DIRCNT,=P'01'           INCR COUNT BY 1     *LBD 11/83*\n         B     READDIR                 AND READ NEXT BLOCK *LBD 11/83*\nENDUSE   AP    DIRACNT,=P'01'          ADD 1 TO ALLOC CNT  *LBD 11/83*\n         GET   PDS                                         *LBD 11/83*\n         B     ENDUSE                                      *LBD 11/83*\nEOFPDS   CLOSE PDS                     DONE - CLOSE IT     *LBD 11/83*\n         AP    DIRCNT,=P'01'           FOR LAST BLOCK      *LBD 11/83*\n         SP    DIRACNT,=P'01'          -1 TO CORRECT BUG   *LBD 12/83*\n         SPACE\nDATES    CVDT  CREDT\n         PACK  DWD,FMTCREDT+1(5)       PACK JULIAN DATE    *LBD 11/83*\n         LA    R1,DWD+4                LOAD PACKED CDATE   *LBD 11/83*\n         BAL   R14,DATEROU             AND GET GREG DATE   *LBD 11/83*\n         MVC   GCREDT(8),0(R1)         INTO ISPF VARIABLE  *LBD 11/83*\n         CVDT  REFD\n         PACK  DWD,FMTREFD+1(5)        PACK JULIAN DATE    *LBD 11/83*\n         LA    R1,DWD+4                LOAD PACKED USE DATE*LBD 11/83*\n         BAL   R14,DATEROU             AND GET GREG DATE   *LBD 11/83*\n         MVC   GUSEDT(8),0(R1)         INTO ISPF VARIABLE  *LBD 11/83*\n         XR    R15,R15\n         ST    R15,BTRALC\n         ICM   R15,B'0001',DS1NOEPV\n         BZ    EXTCVRT\n         MVC   DS3FMTID(9*10),DS3ADEXT\n         MVC   DS3EXTNT-3*10(3*10),DS1EXT1\n         LA    R14,DS3EXTNT-3*10\n         EJECT\n         XC    DS1ALCYL,DS1ALCYL                           *LBD 12/83*\n         XC    DS1USCYL,DS1USCYL                           *LBD 12/83*\n         XC    DS1BALC,DS1BALC                              *LBD 03/85*\n         XC    DS1BUSE,DS1BUSE                              *LBD 03/85*\nEXTENTS  EQU   *\n         USING EXTENT,R14\n         CLI   EXTTYPE,0\n         BNH   EXTLOOP\n* DEVTPC EQU   DVTWKA+10\n         LH    R1,EXTHICC              LOAD HI CYL         *LBD 02/84*\n         SH    R1,EXTLOCC              SUB LOC CYL         *LBD 02/84*\n         LA    R1,1(R1)                ADD FOR CURRENT CYL *LBD 02/84*\nCYLOK    A     R1,DS1ALCYL             ADD ALLOC CYL       *LBD 02/84*\n         ST    R1,DS1ALCYL             AND SAVE IT         *LBD 02/84*\n         LH    R1,EXTLOCC\n         MH    R1,DEVTPC\n         AH    R1,EXTLOHH\n         LH    R0,EXTHICC\n         MH    R0,DEVTPC\n         AH    R0,EXTHIHH\n         BCTR  R1,0\n         SR    R0,R1\n         A     R0,BTRALC\n         ST    R0,BTRALC\n         SPACE\nEXTLOOP  LA    R14,EXTNEXT\n         BCT   R15,EXTENTS\n         SPACE\nEXTCVRT  EQU   *\n         CLC   =C'BLK',FMTUN       BLOCK ALLOCATION ?       *LBD 03/85*\n         BNE   NOTBLK              NO                       *LBD 03/85*\n         TRKCALC FUNCTN=TRKCAP,UCB=(R7),REGSAVE=YES,R=1,    *LBD 03/85*X\n               K=TRKCALK,DD=TRKCALDD                        *LBD 03/85*\n         LR    R4,R0               SAVE BLKS/TRK            *LBD 03/85*\n         L     R3,DS1TRALC         LOAD ALLOC TRKS          *LBD 03/85*\n         SR    R2,R2               ZERO R2 FOR MULTIPLY     *LBD 03/85*\n         LR    R1,R0               GET BLKS PER TRK         *LBD 03/85*\n         MR    R2,R1               GET BLKS IN DATASET      *LBD 03/85*\n         ST    R3,DS1BALC          SAVE BLOCKS ALLOCATED    *LBD 03/85*\n         CVRT  BALC                CONVERT TO DISPLAY       *LBD 03/85*\n         LH    R3,DS1TRUSE         LOAD USED TRACKS         *LBD 03/85*\n         SR    R2,R2               ZERO R2 FOR MULTIPLY     *LBD 03/85*\n         MR    R2,R4               GET BLKS IN DATASET      *LBD 03/85*\n         ST    R3,DS1BUSE          SAVE BLOCKS ALLOCATED    *LBD 03/85*\n         CVRT  BUSE                CONVERT TO DISPLAY       *LBD 03/85*\nNOTBLK   DS    0H                                           *LBD 03/85*\n*DS1TRALC EQU  BTRALC,4\n         CVRT  TRALC\n*DS1TRUSE EQU  DS1LSTAR,2\n         ICM   R15,B'11',DS1LSTAR\n         CLI   DS1LSTAR+2,0                                       82089\n         BNH   *+L'*+4\n         LA    R15,1(R15)\n         STCM  R15,B'11',DS1LSTAR\n         CVRT  TRUSE\n         LR    R3,R15                  LOAD USED TRACKS    *LBD 02/84*\n         SR    R2,R2                   ZERO R2             *LBD 02/84*\n         LH    R1,DEVTPC               LOAD TRKS/CYL       *LBD 02/84*\n         DR    R2,R1                   DIVIDE              *LBD 02/84*\n         LTR   R2,R2                   ANY REMAINDER       *LBD 02/84*\n         BZ    NOLEFT                  NO                  *LBD 02/84*\n         LA    R3,1(R3)                YES - ADD 1 CYL     *LBD 02/84*\nNOLEFT   DS    0H                                          *LBD 02/84*\n         ST    R3,DS1USCYL             SAVE IT             *LBD 02/84*\n         L     R1,DS1ALCYL             LOAD ALLOC CYL      *LBD 02/84*\n         LTR   R1,R1                   ANY CYL ALLOC ?     *LBD 02/84*\n         BNZ   DOCYL                   YES                 *LBD 02/84*\n         LH    R1,=H'01'               SET AS MIN 1        *LBD 02/84*\nDOCYL    ST    R1,DS1ALCYL             RESAVE IT           *LBD 02/84*\n         CVRT  ALCYL                                       *LBD 12/83*\n         CVRT  USCYL                                       *LBD 12/83*\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   TRANSLATE OUT EDIT CHARACTERS AND WRITE FORMATTED LABEL DATA     *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE\n         TR    OUTPUT(MASKEND-MASK),TREDIT\n         JUSTL BALC,FMTBALC        BLOCKS ALLOCATED         *LBD 03/85*\n         JUSTL BUSE,FMTBUSE        BLOCKS USED              *LBD 03/85*\n         JUSTL TRALC,FMTTRALC                                    *LBD*\n         JUSTL TRUSE,FMTTRUSE                                    *LBD*\n         JUSTL EX,FMTNOEPV                                       *LBD*\n         MVC   UNIT(3),FMTUN                                     *LBD*\n         JUSTL SCALO,FMTSCAL                                     *LBD*\n         JUSTL RECFM,FMTRECFM                                    *LBD*\n         JUSTL BLKSIZE,FMTBLKL                                   *LBD*\n         JUSTL LRECL,FMTLRECL                                    *LBD*\n         JUSTL KEYLEN,FMTKEYL                                    *LBD*\n         JUSTL DSORG,FMTDSORG                                    *LBD*\n         JUSTL RKP,FMTRKP                                        *LBD*\n         JUSTL ALCYL,FMTALCYL                              *LBD 12/83*\n         JUSTL USCYL,FMTUSCYL                              *LBD 12/83*\n         MVC   CREDT(5),FMTCREDT+1                               *LBD*\n         MVC   USEDT(5),FMTREFD+1                                *LBD*\n         MVC   MYVOLSER(6),VOLSER                                *LBD*\n         MVC   FMTWORK,=XL8'4020202020202021'              *LBD 11/83*\n         ED    FMTWORK,DIRCNT                              *LBD 11/83*\n         JUSTL DIRUSE,FMTWORK                              *LBD 11/83*\n         MVC   FMTWORK,=XL8'4020202020202021'              *LBD 11/83*\n         ED    FMTWORK,DIRACNT                             *LBD 11/83*\n         JUSTL DIRALLOC,FMTWORK                            *LBD 11/83*\n         MVC   FMTWORK,=XL8'4020202020202021'              *LBD 11/83*\n         ED    FMTWORK,MEMCNT                              *LBD 11/83*\n         JUSTL MEMBERS,FMTWORK                             *LBD 11/83*\n         MVC   FMTWORK,=XL8'4020202020202021'              *LBD 11/83*\n         ED    FMTWORK,ALIASCNT                            *LBD 11/83*\n         JUSTL ALIASES,FMTWORK                             *LBD 11/83*\n         LA    R1,RECFM                                    *LBD 11/83*\n         LA    R2,ATRECFM                                  *LBD 11/83*\nFXRECFM  DS    0H                                          *LBD 11/83*\n         MVC   0(1,R2),0(R1)                               *LBD 11/83*\n         LA    R1,1(R1)                                    *LBD 11/83*\n         LA    R2,2(R2)                                    *LBD 11/83*\n         CLI   0(R1),C' '              END OF RECFM ?      *LBD 11/83*\n         BE    DOPUT                                       *LBD 11/83*\n         B     FXRECFM                                     *LBD 11/83*\nDOPUT    DS    0H                                          *LBD 11/83*\n         L     R15,ISPLINK\n         CALL  (15),(VPUT,NAMES,SHARED),VL\n         SPACE 2                                          *LBD 01/85*\n         L     R15,ISPLINK\n         CALL  (15),(VDELETE,NAMES),VL                           *LBD*\n         L     R15,ISPLINK\n         CALL  (15),(VDELETE,DSN),VL                             *LBD*\n         SPACE\n         EJECT\n*-------------------------------------------------------------------*\n*                                                                   *\n*   WHEN OUTPUT HAS BEEN GENERATED, FREE DATASET                    *\n*                                                                   *\n*-------------------------------------------------------------------*\n         SPACE 2\nFREE     EQU   *\n         FREE  DDN=OURDDNA,ERROR=S99FAIL\n         BE    DONE\n         EJECT\n*-------------------------------------------------------------------*\n*                                                                   *\n*   ABNORMAL SERVICE ROUTINE                                        *\n*                                                                   *\n*-------------------------------------------------------------------*\n         SPACE\nOBTNFAIL EQU   *\n         B     DONE\n         SPACE\nS99FAIL  S99FAIL\n         LA    R2,99              SET RETURN CODE          *LBD 02/84*\n         B     ALLDONE                                     *LBD 02/84*\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*        EXIT                                                    *LBD*\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDONE     DS    0H\n         SR    R2,R2              SET OK RETURN CODE       *LBD 02/84*\n         SPACE 1                                                 *LBD*\nALLDONE  DS    0H                                          *LBD 02/84*\n         DELETE EP=ISPLINK\n         SPACE 1                                                 *LBD*\n         FREEMAIN R,LV=DSALEN,A=CORE                       *LBD 12/83*\n         LR    R15,R2             SET RETURN CODE          *LBD 02/84*\n         $EPILOG ,                                               *LBD*\n         SPACE 2\n         PRINT NOGEN\n         EJECT\n*----------------------------------------------------------*LBD 11/83*\n*                                                          *LBD 11/83*\n*        CONVERT JULIAN DATE TO GREGORIAN DATE             *LBD 11/83*\n*                                                          *LBD 11/83*\n*----------------------------------------------------------*LBD 11/83*\n*        REG = THE REGISTER CONTAING THE PACKED JULIAN DATE\n*        THIS ROUTINE ALSO USES REGISTERS 1,2,3\n*        THIS ROUTINE CONVERTS THE JULIAN DATE INTO THE CALENDAR DATE\n*        EX.   FROM 75339 TO 12/05/75\nDATEROU  ZAP   MX001M,=P'01'           INITIALIZE MONTH\n         ZAP   T001BL+2(2),=P'28'      INITIALIZE FEB\n         MVC   R1001ST(4),0(R1)        MOVE JULIAN DATE    *LBD 11/83*\n         XC    W001X,W001X             ZERO WORK AREA\n         MVC   W001X+3(1),R1001ST+1    MOVE YEAR INTO WORK\n         L     R1,W001X                LOAD YEAR INTO REGISTER\n         SLL   R1,4                    SHIFT LEFT 1/2 BYTE\n         ST    R1,W001X                STORE YEAR INTO WORK AGAIN\n         OI    W001X+3,X'0F'           CONVERT YEAR INTO PACKED FORMAT\n         ZAP   YR001X,W001X            SAVE YEAR\n         DP    W001X,=P'04'            DIVIDE YEAR BY 4\n         CP    W001X+2(2),=P'00'       IF REMAINDER THEN LEAP YEAR\n         BNE   XNOLEAPX                NOT A LEAP YEAR\n         ZAP   T001BL+2(2),=P'29'      SET MONTH 2 EQUAL TO 29 DAYS\nXNOLEAPX LA    1,T001BL                SET POINTER TO MONTH TABLE\n         L     2,=F'02'                SET COUNTER\n         LA    3,MX001M-1              SET POINTER TO END OF TABLE\nXCPR01   CP    R1001ST+2(2),0(2,1)     COMPARE DAYS TO MONTH DABLE\n         BNH   XDATEX                  LESS THAN TABLE\n         AP    MX001M,=P'01'           INCRIMENT MONTH COUNTER\n         SP    R1001ST+2(2),0(2,1)     SUB TABLE DAY FORM JULIAN DAY\n         BXLE  1,2,XCPR01              CONTINUE SCAN\nXDATEX   ZAP   DYXX,R1001ST+2(2)       SET DAY\n         UNPK  W001X,DYXX              UNPACK DAY\n         OI    W001X+3,X'F0'           RESET SIGN\n         MVC   XD1(2),W001X+2          MOVE DAY TO O/P AREA\n         UNPK  W001X,MX001M            UNPACK MONTH\n         OI    W001X+3,X'F0'           RESET SIGN\n         MVC   XM1(2),W001X+2          MOVE MONTH TO O/P AREA\n         UNPK  W001X,YR001X            UNPACK YEAR\n         OI    W001X+3,X'F0'           RESER SIGN\n         MVC   XY1(2),W001X+2          MOVE YEAR TO O/P AREA\n         LA    R1,XM1                  LOAD REGISTER WITH ADDR OF CAL\n         BR    R14                     RETURN TO CALLER\n         EJECT\n         EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   DECLARE ALL CONSTANTS, LITERALS, WORK AREAS, AND CONTROL BLOCKS  *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nCORE     DC    F'0'                                        *LBD 12/83*\n         SPACE 2\nMASK     DC    X'402020202120402020202120202120404040'\n*                FMTTRALC    FMTTRUSE    NOEPV  FMTUN      *LBD 02/84*\n         DC    X'402020202120404040404040402020202120'\n*                SCAL         RECFM      BLKL              *LBD 02/84*\n         DC    X'4020202021204020202021204020212040202120'\n*                LRECL       KEYL         DSORG  RKP       *LBD 02/84*\n         DC    X'402020202120402020202120'\n*                CREDT       REFD                          *LBD 02/84*\n         DC    X'402020202021402020202021'                 *LBD 02/84*\n*                ALCYL       USCYL                         *LBD 02/84*\n         DC    X'402020202021'                              *LBD 03/85*\n*                BALC                                       *LBD 03/85*\n         DC    X'402020202021'                              *LBD 03/85*\n*                BUSE                                       *LBD 03/85*\nMASKEND  EQU   *\n         SPACE 2                                           *LBD 11/83*\nDEVTAB   DS    0F                                          *LBD 11/83*\n         DC    X'09',CL8'3330'                             *LBD 11/83*\n         DC    X'0B',CL8'3350'                             *LBD 11/83*\n         DC    X'0D',CL8'3330-1'                           *LBD 11/83*\n         DC    X'0E',CL8'3380'                             *LBD 11/83*\n         DC    X'FF'                   END OF TABLE        *LBD 11/83*\n         SPACE 2                                           *LBD 11/83*\nTREDIT   DC    256AL1(*-TREDIT)\n         ORG   TREDIT+X'20'\n         DC    X'4040'\n         ORG   TREDIT+256\nTRDSORG  DC    XL256'00'\n         ORG   TRDSORG+X'80'\n         DC    AL1(2)\n         ORG   TRDSORG+X'40'\n         DC    AL1(4)\n         ORG   TRDSORG+X'20'\n         DC    AL1(6)\n         ORG   TRDSORG+X'02'\n         DC    AL1(8)\n         ORG   TRDSORG+256\nDSORGMN  DC    C'  ISPSDAPO'       DATA SET ORGANIZATIONS\nALLCUNIT DC    C'ABTC'             ALLOCATION UNIT MNEMONICS\n         EJECT                                             *LBD 11/83*\n*******  CONSTANTS USED BY THE DATE CONVERSION ROUTINE     *LBD 11/83*\nW001X    DC    F'00'\nT001BL   EQU   *                       MONTH TABLE\n         DC    PL2'31'\n         DC    PL2'28'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\n         DC    PL2'30'\n         DC    PL2'31'\nMX001M   DC    PL2'00'                 MONTH WORK AREA\nR1001ST  DC    F'00'                   REGISTER SAVE AREA FOR REG\nYR001X   DC    PL2'00'                 YEAR WORK AREA\nDYXX     DC    PL2'00'                 DAY WORK AREA\nXM1      DC    CL2'  '                 MONTH O/P AREA\n         DC    C'/'\nXD1      DC    CL2'  '                 DAY O/P AREA\n         DC    C'/'\nXY1      DC    CL2'  '                 YEAR O/P AREA\n         EJECT\nCAMSRCH  CAMLST      SEARCH,*-*,*-*,*-*\nCAMSEEK  CAMLST      SEEK,*-*,*-*,*-*\n*        PRINT       DATA\n         SPACE\n         LTORG\n         EJECT                                                   *LBD*\nISPLINK  DC    V(ISPLINK)\nDIRCNT   DC    PL4'0'                  COUNT OF USED DIR   *LBD 11/83*\nDIRACNT  DC    PL4'0'                  ALLOC DIR BLOCKS    *LBD 11/83*\nMEMCNT   DC    PL4'0'                  MEMBER COUNT        *LBD 11/83*\nALIASCNT DC    PL4'0'                  ALIAS COUNT         *LBD 11/83*\nMVCPARM  MVC   DSN+1(0),2(R1)   * EXECUTED INSTRUCTION     *LBD 12/83*\nOURDDNA  DC    A(OURDDN),Y(8)                                    *LBD*\nOURDDN   DC    CL8' '                                            *LBD*\nOURDSN   DC    A(ODSN),Y(44)                                     *LBD*\nODSN     DC    CL44' '                                           *LBD*\nOMEM     DC    CL8' '                                            *LBD*\nTDSN     DC    CL56' '                                           *LBD*\nVDSN     DC    CL56' '                                           *LBD*\nVZPRF    DC    CL8' '                                      *LBD 12/83*\nVDEFINE  DC    CL8'VDEFINE'                                      *LBD*\nVGET     DC    CL8'VGET'                                         *LBD*\nVPUT     DC    CL8'VPUT'                                         *LBD*\nSHARED   DC    CL8'SHARED'                                       *LBD*\nDSN      DC    C'(DSNINFO )'                                     *LBD*\nZPRF     DC    C'(ZPREFIX)'                                *LBD 12/83*\nCHAR     DC    CL8'CHAR'                                         *LBD*\nLDSN     DC    A(L'VDSN)                                         *LBD*\nLZPRF    DC    A(L'VZPRF)                                  *LBD 12/83*\nVDELETE  DC    CL8'VDELETE'                                      *LBD*\nNAMES    DC    C'(TRALC,TRUSE,EX,UNIT,SCALO,RECFM,'        *LBD 11/83*\n         DC    C'BLKSIZE,LRECL,KEYLEN'                     *LBD 11/83*\n         DC    C',DSORG,RKP,CREDT,USEDT,MEMBER,ATRECFM,'         *LBD*\n         DC    C'VOLSER,DEVTYPE,DIRUSE,DIRALLOC'                 *LBD*\n         DC    C',GCREDT,GUSEDT'                           *LBD 11/83*\n         DC    C',MEMBERS,ALIASES'                         *LBD 11/83*\n         DC    C',ALCYL,USCYL'                             *LBD 12/83*\n         DC    C',BALC,BUSE'                                *LBD 03/85*\n         DC    C',)'                                       *LBD 11/83*\nLNAMES   DC    A(8)                                              *LBD*\nVNAMES   DS    0F                                                *LBD*\nTRALC    DC    CL8' '                                            *LBD*\nTRUSE    DC    CL8' '                                            *LBD*\nEX       DC    CL8' '                                            *LBD*\nUNIT     DC    CL8' '                                            *LBD*\nSCALO    DC    CL8' '                                            *LBD*\nRECFM    DC    CL8' '                                            *LBD*\nBLKSIZE  DC    CL8' '                                            *LBD*\nLRECL    DC    CL8' '                                            *LBD*\nKEYLEN   DC    CL8' '                                            *LBD*\nDSORG    DC    CL8' '                                            *LBD*\nRKP      DC    CL8' '                                            *LBD*\nCREDT    DC    CL8' '                                            *LBD*\nUSEDT    DC    CL8' '                                            *LBD*\nMEMBER   DC    CL8' '                                            *LBD*\nATRECFM  DC    CL8' '                                            *LBD*\nMYVOLSER DC    CL8' '                                            *LBD*\nMYDEVTYP DC    CL8' '                                            *LBD*\nDIRUSE   DC    CL8' '                                      *LBD 11/83*\nDIRALLOC DC    CL8' '                                      *LBD 11/83*\nGCREDT   DC    CL8' '                                      *LBD 11/83*\nGUSEDT   DC    CL8' '                                      *LBD 11/83*\nMEMBERS  DC    CL8' '                                      *LBD 11/83*\nALIASES  DC    CL8' '                                      *LBD 11/83*\nALCYL    DC    CL8' '                                      *LBD 12/83*\nUSCYL    DC    CL8' '                                      *LBD 12/83*\nBALC     DC    CL8' '                                       *LBD 03/85*\nBUSE     DC    CL8' '                                       *LBD 03/85*\n         EJECT\nPDS      DCB   DSORG=PS,MACRF=GL,DDNAME=NULLDDN,LRECL=256, *LBD 11/83* X\n               BLKSIZE=256,RECFM=F,EODAD=EOFPDS            *LBD 11/83*\n         EJECT\n         SPACE 2\nEXTENT   DSECT\n         SPACE\nEXTTYPE  DS    BL1\nEXTSEQ   DS    XL1\nEXTLOCC  DS    HL2\nEXTLOHH  DS    HL2\nEXTHICC  DS    HL2\nEXTHIHH  DS    HL2\n         SPACE\nEXTNEXT  EQU   *\n         EJECT\nTIOT     DSECT\n         IEFTIOT1\n         EJECT\nUCBWRK   DSECT\n         IEFUCBOB\n         EJECT\nDSAWRK   DSECT\nDSASTART DS    0H                                          *LBD 12/83*\n         SPACE\nTIOTA    DS    A\nANS      DS    A\nECB      DS    A\nUWA      DS    A\nDWD      DS    D\nOBTSTRT  DS    CL44                                        *LBD 12/83*\nOBTWKA   DS    0D,XL148\nF3WKA    DS    0D,XL148\nDVTWKA   DS    5F\nFAIL     DS    4F\nBTRALC   DS    F\nCAMLST   DS    F\nCAMDSN   DS    A\nCAMSER   DS    A\nCAMWKA   DS    A\nVOLSER   DS    CL6\nCUU      DS    CL3\nTRKCALK  DS    X                   KEYLEN OF DATASET        *LBD 03/85*\nTRKCALDD DS    H                   BLKSIZE OF DATASET       *LBD 03/85*\n         SPACE 2                                            *LBD 03/85*\n         DYNSPACE ,                                              *LBD*\n         EJECT\nEXTRACT  EXTRACT  TIOTA,FIELDS=TIOT,MF=L\n         EJECT\n         SPACE\nOUTLAST  DS    A\nOUTLLEN  DS    2H\nOUTPUT   DS    0CL(MASKEND-MASK)\nFMTTRALC DS    ZL6\nFMTTRUSE DS    ZL6\nFMTNOEPV DS    ZL3\nFMTUN    DS    CL3\nFMTSCAL  DS    ZL6\nFMTRECFM DS    CL6\nFMTBLKL  DS    ZL6\nFMTLRECL DS    ZL6\nFMTKEYL  DS    ZL6\nFMTDSORG DS    CL4\nFMTRKP   DS    ZL4\nFMTCREDT DS    ZL6\nFMTREFD  DS    ZL6                                         *LBD 11/83*\nFMTALCYL DS    ZL6                                         *LBD 12/83*\nFMTUSCYL DS    ZL6                                         *LBD 12/83*\nFMTBALC  DS    ZL6                                          *LBD 03/85*\nFMTBUSE  DS    ZL6                                          *LBD 03/85*\nFMTWORK  DS    ZL8                                         *LBD 11/83*\nDS1ALCYL DS    F                                           *LBD 12/83*\nDS1USCYL DS    F                                           *LBD 12/83*\nDS1BALC  DS    F                                            *LBD 03/85*\nDS1BUSE  DS    F                                            *LBD 03/85*\n         EJECT                                                   *LBD*\n         ORG   OBTWKA-44\n         IECSDSL1 (1)\n         SPACE\n         ORG   F3WKA\n         SPACE\n         IECSDSL1 (3)\n         SPACE\n         ORG   F3WKA\n         SPACE\n         IECSDSL1 (2)\n         SPACE\n         ORG\n         SPACE\n         SPACE\nDSALEN   EQU   *-DSASTART                                  *LBD 12/83*\n         SPACE\nDS1SCAL  EQU   DS1SCALO+1,3\nDEVTPC   EQU   DVTWKA+10\nDS1TRALC EQU   BTRALC,4\nDS1TRUSE EQU   DS1LSTAR,2\n         EJECT                                                   *LBD*\nDIR      DSECT                                             *LBD 12/83*\nDIRNAME  DS    CL8                                         *LBD 12/83*\nDIRTTR   DS    XL3                                         *LBD 12/83*\nDIRFLAG  DS    X                                           *LBD 12/83*\nDIRALIAS EQU   X'80'                                       *LBD 12/83*\n         EJECT                                                   *LBD*\n         IEFZB4D0                                                *LBD*\n         EJECT                                                   *LBD*\n         IEFZB4D2                                                *LBD*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DSN0MGF": {"ttr": 4103, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "000100 IDENTIFICATION DIVISION.\n000200 PROGRAM-ID.    DSN0MGF.\n000300 AUTHOR.        BOB ZIMMERMAN.\n000400 INSTALLATION.  CNA INSURANCE.\n000500 DATE-COMPILED.\n000600******************************************************************\n000700*    BOB ZIMMERMAN                                               *\n000800*    CNA INSURANCE                                               *\n000900*    (312) 822-5719                                              *\n001000*    LAST MODIFIED 8508                                          *\n001100******************************************************************\n001200*    THIS PROGRAM SUPPORT BOTH IBM'S VS COBOL AND VS COBOL II    *\n001300*    PRODUCTS.                                                   *\n001400******************************************************************\n001500/\n001600 ENVIRONMENT DIVISION.\n001700 DATA DIVISION.\n001800 WORKING-STORAGE SECTION.\n001900\n002000******************************************************************\n002100*    SPF-VARIABLES IS THE WORKING STORAGE AREA USED TO CONTAIN   *\n002200*    THE CONTENTS OF THE ISPF VARIABLES USED IN THIS DIALOG.     *\n002300*    THESE VARIABLES MAY BE ACCESSED USING EITHER THE VDEFINE    *\n002400*    SERVICE OR THE VCOPY SERVICE.                               *\n002500******************************************************************\n002600\n002700 01  SPF-VARIABLES                     SYNC.\n002800     05  COMPLETION-CODE               PIC S9(09) COMP.\n002900     05  SPF-ZTDTOP                    PIC S9(09) COMP.\n003000     05  SPF-CSR                       PIC S9(09) COMP.\n003100     05  SPF-ROWNUM                    PIC S9(09) COMP.\n003200     05  SPF-NUMROW                    PIC S9(09) COMP.\n003300     05  SPF-LSEL                      PIC X(08) VALUE SPACES.\n003400     05  SPF-DSNAME                    PIC X(56) VALUE SPACES.\n003500     05  SPF-VOLSER                    PIC X(06) VALUE SPACES.\n003600     05  SPF-STATS1                    PIC X(01) VALUE SPACES.\n003700     05  SPF-STATS2                    PIC X(01) VALUE SPACES.\n003800     05  SPF-PROFILE                   PIC X(08) VALUE SPACES.\n003900     05  SPF-IMACRO                    PIC X(08) VALUE SPACES.\n004000     05  SPF-TBDISPL-PANEL             PIC X(08).\n004100     05  SPF-FROM-TABLE                PIC X(08).\n004200     05  SPF-TO-TABLE                  PIC X(08).\n004300     05  SPF-WORK-AREA.\n004400         10  SPF-WORK-AREA-FIRST3      PIC X(03).\n004500         10  SPF-WORK-AREA-LAST        PIC X(01).\n004600\n004700     05  SPF-WORK-NAME.\n004800         10  SPF-WORK-USER             PIC X(05).\n004900         10  SPF-WORK-ID               PIC X(03).\n005000     05  SPF-TEMP-PANEL               PIC X(08).\n005100     05  SPF-TEMP-TABLE               PIC X(08).\n005200     05  SPF-THE-TABLE                PIC X(08).\n005300\n005400\n005500/\n005600******************************************************************\n005700*    THE FOLLOWING WORKING STORAGE AREA IS USED IN PROCESSING    *\n005800*    AND PARSING THE COMMAND LINE.                               *\n005900******************************************************************\n006000\n006100 01  ZCMD-PROCESS-AREA                 SYNC.\n006200     05  ZCMD-COMMAND-LINE             PIC X(80) VALUE SPACES.\n006300     05  ZCMD-OVERFLOW-SWITCH          PIC 9(01) VALUE 0.\n006400     05  ZCMD-COMMAND                  PIC X(80) VALUE SPACES.\n006500     05  ZCMD-PARM-COUNT               PIC S9(04) COMP VALUE +0.\n006600     05  ZCMD-PARM-TABLE.\n006700         10  ZCMD-PARM                 PIC X(80)\n006800                                       OCCURS 20 TIMES\n006900                                       INDEXED BY ZCMD-INX.\n007000\n007100\n007200/\n007300******************************************************************\n007400*    THE FOLLOWING AREA IS USED FOR ISPF DIALOG CALLS. IT        *\n007500*    CONTAINS LITERALS, NAMELISTS AND WORKING STORAGE AREAS      *\n007600*    THAT THE DIALOG CALLS REQUIRE.                              *\n007700******************************************************************\n007800\n007900 01  PDF-WORK-AREAS                   SYNC.\n008000     05  PDF-BROWSE                   PIC X(8) VALUE 'BROWSE'.\n008100     05  PDF-CANCEL                   PIC X(8) VALUE 'CANCEL'.\n008200     05  PDF-CHAR                     PIC X(8) VALUE 'CHAR'.\n008300     05  PDF-CONTROL                  PIC X(8) VALUE 'CONTROL'.\n008400     05  PDF-DISPLAY                  PIC X(8) VALUE 'DISPLAY'.\n008500     05  PDF-EDIT                     PIC X(8) VALUE 'EDIT'.\n008600     05  PDF-ERRORS                   PIC X(8) VALUE 'ERRORS'.\n008700     05  PDF-FIXED                    PIC X(8) VALUE 'FIXED'.\n008800     05  PDF-LINE                     PIC X(8) VALUE 'LINE'.\n008900     05  PDF-MOVE                     PIC X(8) VALUE 'MOVE'.\n009000     05  PDF-NEXT                     PIC X(8) VALUE 'NEXT'.\n009100     05  PDF-NOWRITE                  PIC X(8) VALUE 'NOWRITE'.\n009200     05  PDF-ORDER                    PIC X(8) VALUE 'ORDER'.\n009300     05  PDF-PREVIOUS                 PIC X(8) VALUE 'PREVIOUS'.\n009400     05  PDF-REPLACE                  PIC X(8) VALUE 'REPLACE'.\n009500     05  PDF-RESTORE                  PIC X(8) VALUE 'RESTORE'.\n009600     05  PDF-RETURN                   PIC X(8) VALUE 'RETURN'.\n009700     05  PDF-SAVE                     PIC X(8) VALUE 'SAVE'.\n009800     05  PDF-SELECT                   PIC X(8) VALUE 'SELECT'.\n009900     05  PDF-SETMSG                   PIC X(8) VALUE 'SETMSG'.\n010000     05  PDF-SHARE                    PIC X(8) VALUE 'SHARE'.\n010100     05  PDF-TBADD                    PIC X(8) VALUE 'TBADD'.\n010200     05  PDF-TBBOTTOM                 PIC X(8) VALUE 'TBBOTTOM'.\n010300     05  PDF-TBCLOSE                  PIC X(8) VALUE 'TBCLOSE'.\n010400     05  PDF-TBCREATE                 PIC X(8) VALUE 'TBCREATE'.\n010500     05  PDF-TBDELETE                 PIC X(8) VALUE 'TBDELETE'.\n010600     05  PDF-TBDISPL                  PIC X(8) VALUE 'TBDISPL'.\n010700     05  PDF-TBEND                    PIC X(8) VALUE 'TBEND'.\n010800     05  PDF-TBOPEN                   PIC X(8) VALUE 'TBOPEN'.\n010900     05  PDF-TBPUT                    PIC X(8) VALUE 'TBPUT'.\n011000     05  PDF-TBQUERY                  PIC X(8) VALUE 'TBQUERY'.\n011100     05  PDF-TBSARG                   PIC X(8) VALUE 'TBSARG'.\n011200     05  PDF-TBSAVE                   PIC X(8) VALUE 'TBSAVE'.\n011300     05  PDF-TBSCAN                   PIC X(8) VALUE 'TBSCAN'.\n011400     05  PDF-TBSKIP                   PIC X(8) VALUE 'TBSKIP'.\n011500     05  PDF-TBSORT                   PIC X(8) VALUE 'TBSORT'.\n011600     05  PDF-TBTOP                    PIC X(8) VALUE 'TBTOP'.\n011700     05  PDF-TBVCLEAR                 PIC X(8) VALUE 'TBVCLEAR'.\n011800     05  PDF-VCOPY                    PIC X(8) VALUE 'VCOPY'.\n011900     05  PDF-VDEFINE                  PIC X(8) VALUE 'VDEFINE'.\n012000     05  PDF-VRESET                   PIC X(8) VALUE 'VRESET'.\n012100     05  PDF-WRITE                    PIC X(8) VALUE 'WRITE'.\n012200     05  PDF-DUMMY-PARAMETER          PIC X(8) VALUE '        '.\n012300     05  PDF-NAME-LIST                PIC X(256).\n012400     05  PDF-COND-LIST                PIC X(80).\n012500     05  PDF-DSNAME                   PIC X(56).\n012600     05  PDF-VOLSER                   PIC X(6).\n012700     05  PDF-FULLWORD                 PIC S9(09) COMP.\n012800     05  PDF-RETURN-CODE              PIC S9(09) COMP.\n012900     05  WORK-NUM                     PIC S9(09) COMP.\n013000     05  WORK-NUM-DISPLAY             PIC Z(08)9.\n013100     05  PDF-BROWSE-RETURN-CODE       PIC S9(09) COMP.\n013200     05  PDF-TBDISPL-ROW              PIC S9(09) COMP.\n013300     05  PDF-SELECT-BUFFER-LENGTH     PIC S9(09) COMP.\n013400     05  WS-TABLE-ID.\n013500         10  WS-TABLE-ID-PREFACE      PIC X(5).\n013600         10  WS-TABLE-SUFFIX          PIC X(3).\n013700     05  PDF-TABLE-ID.\n013800         10  PDF-TABLE-ID-PREFACE     PIC X(5).\n013900         10  PDF-TABLE-SUFFIX         PIC X(3) VALUE 'DSN'.\n014000     05  PDF-TBDISPL-PANEL            PIC X(8).\n014100     05  PDF-TBDISPL-AUTOSEL          PIC X(8).\n014200     05  PDF-TBDISPL-MESSAGE          PIC X(8).\n014300     05  PDF-TBDISPL-CURSOR           PIC X(8).\n014400     05  PDF-VARIABLE-NAME            PIC X(8).\n014500     05  PDF-SHORT-MESSAGE            PIC X(24).\n014600     05  PDF-LONG-MESSAGE             PIC X(78).\n014700     05  PDF-SELECT-BUFFER            PIC X(256).\n014800     05  PDF-LIBRARY                  PIC X(08) VALUE 'DSNMGF'.\n014900/\n015000 PROCEDURE DIVISION.\n015100\n015200******************************************************************\n015300*    INITALIZE WORKING STORAGE AREAS.                            *\n015400*    VDEFINE AND VCOPY ANY ISPF VARIABLES THAT ARE REQUIRED.     *\n015500******************************************************************\n015600\n015700 0100-INIT-AND-VDEFINE.\n015800\n015900     CALL 'ISPLINK' USING             PDF-CONTROL\n016000                                      PDF-ERRORS\n016100                                      PDF-CANCEL.\n016200\n016300     MOVE SPACES TO PDF-SELECT-BUFFER.\n016400     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n016500     STRING 'SELECT PGM(EDREC)' DELIMITED BY SIZE\n016600         INTO PDF-SELECT-BUFFER\n016700         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n016800     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n016900     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n017000                                       PDF-SELECT-BUFFER.\n017100\n017200     PERFORM 5000-VDEFINE THRU 5999-EXIT.\n017300\n017400******************************************************************\n017500*    BUILD THE TABLE NAME FROM THE FIRST 5 BYTES OF THE USERID   *\n017600******************************************************************\n017700\n017800     MOVE '(ZUSER)' TO PDF-NAME-LIST.\n017900     MOVE 8 TO PDF-FULLWORD.\n018000     CALL 'ISPLINK' USING              PDF-VCOPY\n018100                                       PDF-NAME-LIST\n018200                                       PDF-FULLWORD\n018300                                       PDF-TABLE-ID\n018400                                       PDF-MOVE.\n018500     MOVE 'DSN' TO PDF-TABLE-SUFFIX.\n018600\n018700******************************************************************\n018800*    INITALIZE THE TBDISPL PARAMETERS TO SPACES                  *\n018900******************************************************************\n019000\n019100     MOVE SPACES TO PDF-TBDISPL-MESSAGE.\n019200     MOVE SPACES TO PDF-TBDISPL-CURSOR.\n019300     MOVE ZEROS TO PDF-TBDISPL-ROW.\n019400\n019500******************************************************************\n019600*    BUILD/OPEN THE ISPF TABLE                                   *\n019700******************************************************************\n019800\n019900     PERFORM 2000-BUILD-TABLE THRU 2999-EXIT.\n020000\n020100******************************************************************\n020200*    PROCESS USER INPUT UNTIL END/RETURN ENTERED                 *\n020300******************************************************************\n020400\n020500     MOVE ZEROS TO PDF-RETURN-CODE.\n020600     PERFORM 1000-DISPLAY-PANEL THRU 1999-EXIT\n020700         UNTIL PDF-RETURN-CODE > 4.\n020800\n020900 EXIT-PROGRAM.\n021000\n021100******************************************************************\n021200*    IF THIS IS NOT A RECURSIVE INVOCATION (TABLE WAS NOT OPEN)  *\n021300*       CLOSE THE ISPF TABLE                                     *\n021400******************************************************************\n021500\n021600     IF SPF-STATS2 NOT = 5\n021700         MOVE 50 TO PDF-FULLWORD\n021800         CALL 'ISPLINK' USING          PDF-TBCLOSE\n021900                                       PDF-TABLE-ID\n022000                                       PDF-DUMMY-PARAMETER\n022100                                       PDF-DUMMY-PARAMETER\n022200                                       PDF-FULLWORD\n022300                                       PDF-LIBRARY\n022400     ELSE\n022500         CALL 'ISPLINK' USING          PDF-TBSAVE\n022600                                       PDF-TABLE-ID\n022700                                       PDF-DUMMY-PARAMETER\n022800                                       PDF-DUMMY-PARAMETER\n022900                                       PDF-FULLWORD\n023000                                       PDF-LIBRARY.\n023100\n023200 EXIT-PROGRAM-NOW.\n023300\n023400******************************************************************\n023500*    TO FORCE ISPF TO CLOSE THE DSNMGF FILE, A DUMMY TBSTATS IS  *\n023600*    ISSUED.                                                     *\n023700******************************************************************\n023800\n023900     MOVE SPACES TO PDF-SELECT-BUFFER.\n024000     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n024100     STRING 'TBSTATS DUMMY LIBRARY(DUMMY)'\n024200         DELIMITED BY SIZE\n024300         INTO PDF-SELECT-BUFFER\n024400         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n024500     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n024600                                       PDF-SELECT-BUFFER.\n024700\n024800     MOVE SPACES TO PDF-SELECT-BUFFER.\n024900     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n025000     STRING 'VPUT (DSMPPANL) PROFILE'\n025100         DELIMITED BY SIZE\n025200         INTO PDF-SELECT-BUFFER\n025300         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n025400     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n025500                                       PDF-SELECT-BUFFER.\n025600\n025700     CALL 'ISPLINK' USING              PDF-VRESET.\n025800     GOBACK.\n025900/\n026000 1000-DISPLAY-PANEL.\n026100\n026200******************************************************************\n026300*    START AT THE TOP OF THE TABLE, SKIP TO WHERE THE USER LEAVES*\n026400*    THE TOP DISPLAY LINE WHEN HE HITS ENTER.                    *\n026500******************************************************************\n026600\n026700     CALL 'ISPLINK' USING              PDF-TBTOP\n026800                                       PDF-TABLE-ID.\n026900\n027000     CALL 'ISPLINK' USING              PDF-TBSKIP\n027100                                       PDF-TABLE-ID\n027200                                       SPF-ZTDTOP.\n027300\n027400     MOVE 'ROWNUM' TO PDF-VARIABLE-NAME.\n027500     CALL 'ISPLINK' USING              PDF-TBQUERY\n027600                                       PDF-TABLE-ID\n027700                                       PDF-DUMMY-PARAMETER\n027800                                       PDF-DUMMY-PARAMETER\n027900                                       PDF-VARIABLE-NAME.\n028000\n028100******************************************************************\n028200*    CHECK FOR AN EMPTY TABLE CONDITION                          *\n028300*        IF EMPTY - ADD 1 BLANK ROW                              *\n028400******************************************************************\n028500\n028600     IF SPF-ROWNUM = 0\n028700         CALL 'ISPLINK' USING          PDF-TBVCLEAR\n028800                                       PDF-TABLE-ID\n028900\n029000         CALL 'ISPLINK' USING          PDF-TBADD\n029100                                       PDF-TABLE-ID.\n029200\n029300******************************************************************\n029400*    IF AN ERROR MESSAGE EXISTS - FORCE AUTOSEL OF THE ROW IN    *\n029500*    ERROR                                                       *\n029600*    IF NO ERROR MESSAGE EXISTS - NO AUTOSEL IS FORCED           *\n029700*    IF NO ERROR MESSAGE AND THE CURSOR IS SET TO A ROW (I, R    *\n029800*    LINE COMMANDS) THEN PUT THE CURSOR IN THE LINE COMMAND AREA *\n029900******************************************************************\n030000\n030100     IF PDF-TBDISPL-MESSAGE NOT = SPACES\n030200         MOVE 'YES' TO PDF-TBDISPL-AUTOSEL\n030300     ELSE\n030400         MOVE 'NO' TO PDF-TBDISPL-AUTOSEL\n030500         MOVE SPF-CSR TO PDF-TBDISPL-ROW\n030600         IF SPF-CSR NOT = 0 AND PDF-TBDISPL-CURSOR = SPACES\n030700             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR.\n030800\n030900     CALL 'ISPLINK' USING              PDF-TBDISPL\n031000                                       PDF-TABLE-ID\n031100                                       PDF-TBDISPL-PANEL\n031200                                       PDF-TBDISPL-MESSAGE\n031300                                       PDF-TBDISPL-CURSOR\n031400                                       PDF-TBDISPL-ROW\n031500                                       PDF-DUMMY-PARAMETER\n031600                                       PDF-TBDISPL-AUTOSEL.\n031700     MOVE RETURN-CODE TO PDF-RETURN-CODE.\n031800     IF PDF-RETURN-CODE > 4\n031900         GO TO 1999-EXIT.\n032000\n032100******************************************************************\n032200*    REINIT ALL TBDISPL PARMS TO THEIR DEFAULTS                  *\n032300******************************************************************\n032400\n032500     MOVE SPF-TBDISPL-PANEL TO PDF-TBDISPL-PANEL.\n032600     MOVE SPACES TO PDF-TBDISPL-MESSAGE.\n032700     MOVE SPACES TO PDF-TBDISPL-CURSOR.\n032800     MOVE ZEROS TO PDF-TBDISPL-ROW.\n032900     MOVE ZEROS TO SPF-CSR.\n033000\n033100 1100-VARIABLE-NAME.\n033200\n033300******************************************************************\n033400*    CHECK TO SEE IF A TABLE ROW WAS MODIFIED                    *\n033500******************************************************************\n033600\n033700     MOVE 'CSR' TO PDF-VARIABLE-NAME.\n033800     CALL 'ISPLINK' USING              PDF-TBQUERY\n033900                                       PDF-TABLE-ID\n034000                                       PDF-DUMMY-PARAMETER\n034100                                       PDF-DUMMY-PARAMETER\n034200                                       PDF-DUMMY-PARAMETER\n034300                                       PDF-DUMMY-PARAMETER\n034400                                       PDF-DUMMY-PARAMETER\n034500                                       PDF-VARIABLE-NAME.\n034600\n034700     IF SPF-CSR = 0 GO TO 1500-PROCESS-ZCMD.\n034800\n034900     PERFORM 4000-LINE-COMMAND THRU 4999-EXIT.\n035000\n035100******************************************************************\n035200*    IF A ROW IS IN ERROR - TELL THE USER NOW                    *\n035300*                           FORCE THE USER TO FIX IT NOW         *\n035400******************************************************************\n035500\n035600     IF PDF-TBDISPL-MESSAGE NOT = SPACES\n035700         GO TO 1999-EXIT.\n035800\n035900******************************************************************\n036000*    IF MORE THAN ONE ROW WAS SELECTED - GO GET ANOTHER ROW      *\n036100******************************************************************\n036200\n036300     IF PDF-RETURN-CODE = 4\n036400         MOVE SPACES TO PDF-TBDISPL-PANEL\n036500         GO TO 1999-EXIT.\n036600/\n036700 1500-PROCESS-ZCMD.\n036800\n036900******************************************************************\n037000*    PROCESS THE PRIMARY COMMAND LINE                            *\n037100*            FIRST UNSTRING THE PRIMARY COMMAND AREA             *\n037200******************************************************************\n037300\n037400     IF ZCMD-COMMAND-LINE = SPACES\n037500         GO TO 1999-EXIT.\n037600\n037700     MOVE ZEROS TO ZCMD-PARM-COUNT.\n037800     MOVE ZEROS TO ZCMD-OVERFLOW-SWITCH.\n037900     MOVE SPACES TO ZCMD-COMMAND.\n038000     MOVE SPACES TO ZCMD-PARM-TABLE.\n038100\n038200     UNSTRING ZCMD-COMMAND-LINE\n038300              DELIMITED BY ALL SPACES\n038400              INTO ZCMD-COMMAND\n038500              ZCMD-PARM (1)\n038600              ZCMD-PARM (2)\n038700              ZCMD-PARM (3)\n038800              ZCMD-PARM (4)\n038900              ZCMD-PARM (5)\n039000              ZCMD-PARM (6)\n039100              ZCMD-PARM (7)\n039200              ZCMD-PARM (8)\n039300              ZCMD-PARM (9)\n039400              ZCMD-PARM (10)\n039500              ZCMD-PARM (11)\n039600              ZCMD-PARM (12)\n039700              ZCMD-PARM (13)\n039800              ZCMD-PARM (14)\n039900              ZCMD-PARM (15)\n040000              ZCMD-PARM (16)\n040100              ZCMD-PARM (17)\n040200              ZCMD-PARM (18)\n040300              ZCMD-PARM (19)\n040400              ZCMD-PARM (20)\n040500              TALLYING ZCMD-PARM-COUNT\n040600              ON OVERFLOW\n040700                  MOVE +1 TO ZCMD-OVERFLOW-SWITCH.\n040800\n040900     IF ZCMD-PARM-COUNT > 0\n041000         SUBTRACT 1 FROM ZCMD-PARM-COUNT.\n041100\n041200     IF ZCMD-OVERFLOW-SWITCH NOT = 0\n041300         MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n041400         MOVE 'THERE IS A LIMIT OF 20 PARAMETERS TO ANY PRIMARY CO\n041500-        'COMMAND' TO PDF-LONG-MESSAGE\n041600         MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n041700         MOVE SPACES TO PDF-TBDISPL-PANEL\n041800         GO TO 1999-EXIT.\n041900\n042000 1600-PRIMARY-COMMANDS.\n042100\n042200******************************************************************\n042300*    SORT PRIMAY COMMAND                                         *\n042400*         NO VALID OPERANDS                                      *\n042500******************************************************************\n042600\n042700     IF ZCMD-COMMAND = 'SORT'\n042800         IF ZCMD-PARM-COUNT > 0\n042900             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n043000             MOVE 'THERE ARE NO VALID PARAMETERS FOR THE SORT COMM\n043100-            'AND' TO PDF-LONG-MESSAGE\n043200             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n043300             MOVE SPACES TO PDF-TBDISPL-PANEL\n043400             GO TO 1999-EXIT\n043500         ELSE\n043600             MOVE SPACES TO PDF-TBDISPL-CURSOR\n043700             MOVE 0 TO SPF-CSR\n043800             MOVE '(DSNAME,C,A,VOLSER,C,A)' TO PDF-NAME-LIST\n043900             CALL 'ISPLINK' USING      PDF-TBSORT\n044000                                       PDF-TABLE-ID\n044100                                       PDF-NAME-LIST\n044200             MOVE SPACES TO ZCMD-COMMAND-LINE\n044300             GO TO 1999-EXIT.\n044400\n044500******************************************************************\n044600*    LIST PRIMAY COMMAND                                         *\n044700*         NO VALID OPERANDS                                      *\n044800******************************************************************\n044900\n045000     IF ZCMD-COMMAND = 'LIST' OR 'FLIST'\n045100         IF ZCMD-PARM-COUNT > 0\n045200             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n045300             MOVE 'THERE ARE NO VALID PARAMETERS FOR THE LIST COMM\n045400-            'AND' TO PDF-LONG-MESSAGE\n045500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n045600             MOVE SPACES TO PDF-TBDISPL-PANEL\n045700             GO TO 1999-EXIT\n045800         ELSE\n045900             PERFORM 7000-LIST-COMMAND THRU 7099-EXIT\n046000             IF PDF-TBDISPL-MESSAGE = SPACES\n046100                 GO TO 1500-PROCESS-ZCMD\n046200             ELSE\n046300                 GO TO 1999-EXIT.\n046400\n046500******************************************************************\n046600*    INIT PRIMAY COMMAND                                         *\n046700*         NO VALID OPERANDS                                      *\n046800******************************************************************\n046900\n047000     IF ZCMD-COMMAND = 'INIT'\n047100         IF ZCMD-PARM-COUNT > 0\n047200             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n047300             MOVE 'THERE ARE NO VALID PARAMETERS FOR THE INIT COMM\n047400-            'AND' TO PDF-LONG-MESSAGE\n047500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n047600             MOVE SPACES TO PDF-TBDISPL-PANEL\n047700             GO TO 1999-EXIT\n047800         ELSE\n047900             CALL 'ISPLINK' USING     PDF-TBTOP\n048000                                      PDF-TABLE-ID\n048100             PERFORM 6100-DEL THRU 6199-EXIT\n048200             MOVE SPACES TO ZCMD-COMMAND-LINE\n048300             GO TO 1999-EXIT.\n048400\n048500******************************************************************\n048600*    EXPAND PRIMARY COMMAND                                      *\n048700*         ONE VALID OPERAND - \"YES\" OR \"NO\"                      *\n048800******************************************************************\n048900\n049000     IF ZCMD-COMMAND = 'EXPAND'\n049100         IF ZCMD-PARM-COUNT > 1\n049200             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n049300             MOVE 'THIS COMMAND ONLY SUPPORTS AN ON OR OFF PARM'\n049400             TO PDF-LONG-MESSAGE\n049500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n049600             MOVE SPACES TO PDF-TBDISPL-PANEL\n049700             GO TO 1999-EXIT\n049800         ELSE\n049900         IF ZCMD-PARM (1) NOT = 'ON' AND 'OFF' AND SPACES\n050000             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n050100             MOVE 'THIS COMMAND ONLY SUPPORTS AN ON OR OFF PARM'\n050200             TO PDF-LONG-MESSAGE\n050300             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n050400             MOVE SPACES TO PDF-TBDISPL-PANEL\n050500             GO TO 1999-EXIT\n050600         ELSE\n050700         IF ZCMD-PARM (1) = 'ON' OR SPACES\n050800             MOVE SPACES TO PDF-TBDISPL-CURSOR\n050900             MOVE 'DSNBMGF1' TO SPF-TBDISPL-PANEL,\n051000                                PDF-TBDISPL-PANEL\n051100             MOVE SPACES TO ZCMD-COMMAND-LINE\n051200             GO TO 1999-EXIT\n051300         ELSE\n051400             MOVE SPACES TO PDF-TBDISPL-CURSOR\n051500             MOVE 'DSNBMGF' TO SPF-TBDISPL-PANEL,\n051600                                PDF-TBDISPL-PANEL\n051700             MOVE SPACES TO ZCMD-COMMAND-LINE\n051800             GO TO 1999-EXIT.\n051900\n052000******************************************************************\n052100*    LOCATE PRIMARY COMMAND                                      *\n052200*         ONE REQUIRED OPERAND - SEARCH ARGUMENT                 *\n052300******************************************************************\n052400\n052500     IF ZCMD-COMMAND = 'LOCATE' OR 'LOC' OR 'L'\n052600         IF ZCMD-PARM-COUNT > 1\n052700             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n052800             MOVE 'THIS COMMAND ONLY SUPPORTS ONE PARAMETER'\n052900             TO PDF-LONG-MESSAGE\n053000             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n053100             MOVE SPACES TO PDF-TBDISPL-PANEL\n053200             GO TO 1999-EXIT\n053300         ELSE\n053400         IF ZCMD-PARM (1) = SPACES\n053500             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n053600             MOVE 'THIS COMMAND REQUIRES ONE PARAMETER'\n053700             TO PDF-LONG-MESSAGE\n053800             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n053900             MOVE SPACES TO PDF-TBDISPL-PANEL\n054000             GO TO 1999-EXIT\n054100         ELSE\n054200         CALL 'ISPLINK' USING         PDF-TBTOP\n054300                                      PDF-TABLE-ID\n054400         MOVE SPACES TO SPF-DSNAME\n054500         STRING QUOTE\n054600             ZCMD-PARM (1)\n054700             DELIMITED BY SIZE\n054800             INTO SPF-DSNAME\n054900         MOVE '(DSNAME)' TO PDF-NAME-LIST\n055000         MOVE 'ZTDTOP' TO PDF-VARIABLE-NAME\n055100         MOVE '(GE)' TO PDF-COND-LIST\n055200         CALL 'ISPLINK' USING          PDF-TBSCAN\n055300                                       PDF-TABLE-ID\n055400                                       PDF-NAME-LIST\n055500                                       PDF-DUMMY-PARAMETER\n055600                                       PDF-DUMMY-PARAMETER\n055700                                       PDF-DUMMY-PARAMETER\n055800                                       PDF-DUMMY-PARAMETER\n055900                                       PDF-VARIABLE-NAME\n056000                                       PDF-COND-LIST\n056100         IF SPF-ZTDTOP NOT = 0\n056200             SUBTRACT 1 FROM SPF-ZTDTOP\n056300             GO TO 1999-EXIT\n056400         ELSE\n056500             GO TO 1999-EXIT.\n056600\n056700******************************************************************\n056800*    CREATE PRIMARY COMMAND                                      *\n056900*         ONE REQUIRED OPERAND - 3 BYTE DSNAME                   *\n057000******************************************************************\n057100\n057200     IF ZCMD-COMMAND = 'CREATE' OR 'CR'\n057300         IF ZCMD-PARM-COUNT > 1\n057400             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n057500             MOVE 'THIS COMMAND ONLY SUPPORTS ONE PARAMETER'\n057600             TO PDF-LONG-MESSAGE\n057700             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n057800             MOVE SPACES TO PDF-TBDISPL-PANEL\n057900             GO TO 1999-EXIT\n058000         ELSE\n058100         IF ZCMD-PARM (1) = SPACES\n058200             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n058300             MOVE 'THIS COMMAND REQUIRES ONE PARAMETER'\n058400             TO PDF-LONG-MESSAGE\n058500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n058600             MOVE SPACES TO PDF-TBDISPL-PANEL\n058700             GO TO 1999-EXIT\n058800         ELSE\n058900         MOVE ZCMD-PARM (1) TO SPF-WORK-AREA\n059000         IF   SPF-WORK-AREA-LAST NOT = SPACES\n059100             MOVE 'PARAMETER TOO LONG' TO PDF-SHORT-MESSAGE\n059200             MOVE 'THE PARAMETER MUST BE LESS THAN 4 BYTES LONG'\n059300             TO PDF-LONG-MESSAGE\n059400             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n059500             MOVE SPACES TO PDF-TBDISPL-PANEL\n059600             GO TO 1999-EXIT\n059700         ELSE\n059800         IF SPF-WORK-AREA = 'DSN'\n059900             MOVE '\"DSN\" IS RESERVED' TO PDF-SHORT-MESSAGE\n060000             MOVE 'THE \"DSN\" LABEL IS A RESERVED SLOT AND MAY NOT\n060100-            'BE USED'\n060200             TO PDF-LONG-MESSAGE\n060300             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n060400             MOVE SPACES TO PDF-TBDISPL-PANEL\n060500             GO TO 1999-EXIT\n060600         ELSE\n060700         MOVE PDF-TABLE-ID TO WS-TABLE-ID\n060800         MOVE SPF-WORK-AREA TO WS-TABLE-SUFFIX\n060900         MOVE WS-TABLE-ID TO SPF-TO-TABLE\n061000         MOVE PDF-TABLE-ID TO SPF-FROM-TABLE\n061100         MOVE SPACES TO PDF-SELECT-BUFFER\n061200         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n061300         STRING 'TBSTATS ' DELIMITED BY SIZE\n061400                SPF-TO-TABLE DELIMITED BY SPACE\n061500                ' STATUS1(ST1) LIBRARY(DSNMGF)'\n061600                DELIMITED BY SIZE\n061700             INTO PDF-SELECT-BUFFER\n061800             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n061900         SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH\n062000         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n062100                                       PDF-SELECT-BUFFER\n062200         IF SPF-STATS1 = 1\n062300             MOVE 'DUPLICATE DSN LIST' TO PDF-SHORT-MESSAGE\n062400             MOVE 'YOU ARE ATTEMPTING TO CREATE AN EXISTING LIST'\n062500             TO PDF-LONG-MESSAGE\n062600             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n062700             MOVE SPACES TO PDF-TBDISPL-PANEL\n062800             GO TO 1999-EXIT\n062900         ELSE\n063000         MOVE '(DSNAME VOLSER COMMENT PROFILE IMACRO)'\n063100             TO PDF-NAME-LIST\n063200         CALL 'ISPLINK' USING          PDF-TBCREATE\n063300                                       SPF-TO-TABLE\n063400                                       PDF-DUMMY-PARAMETER\n063500                                       PDF-NAME-LIST\n063600                                       PDF-WRITE\n063700                                       PDF-REPLACE\n063800                                       PDF-LIBRARY\n063900                                       PDF-SHARE\n064000         CALL 'ISPLINK' USING          PDF-TBTOP\n064100                                       PDF-TABLE-ID\n064200         PERFORM 6000-COPY-TABLE THRU 6099-EXIT\n064300         MOVE 50 TO PDF-FULLWORD\n064400         CALL 'ISPLINK' USING          PDF-TBCLOSE\n064500                                       SPF-TO-TABLE\n064600                                       PDF-DUMMY-PARAMETER\n064700                                       PDF-DUMMY-PARAMETER\n064800                                       PDF-FULLWORD\n064900                                       PDF-LIBRARY\n065000         MOVE SPACES TO PDF-SHORT-MESSAGE\n065100         STRING WS-TABLE-SUFFIX ' HAS BEEN CREATED' DELIMITED BY\n065200             SIZE INTO PDF-SHORT-MESSAGE\n065300         MOVE 'YOUR CREATE COMMAND HAS COMPLETED SUCCESSFULLY'\n065400         TO PDF-LONG-MESSAGE\n065500         MOVE 'DTSM001W' TO PDF-TBDISPL-MESSAGE\n065600         GO TO 1999-EXIT.\n065700\n065800\n065900******************************************************************\n066000*    COPY   PRIMARY COMMAND                                      *\n066100*         ONE REQUIRED OPERAND - 3 BYTE DSNAME                   *\n066200******************************************************************\n066300\n066400     IF ZCMD-COMMAND = 'COPY'\n066500         IF ZCMD-PARM-COUNT > 1\n066600             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n066700             MOVE 'THIS COMMAND ONLY SUPPORTS ONE PARAMETER'\n066800             TO PDF-LONG-MESSAGE\n066900             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n067000             MOVE SPACES TO PDF-TBDISPL-PANEL\n067100             GO TO 1999-EXIT\n067200         ELSE\n067300         IF ZCMD-PARM (1) = SPACES\n067400             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n067500             MOVE 'THIS COMMAND REQUIRES ONE PARAMETER'\n067600             TO PDF-LONG-MESSAGE\n067700             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n067800             MOVE SPACES TO PDF-TBDISPL-PANEL\n067900             GO TO 1999-EXIT\n068000         ELSE\n068100         MOVE ZCMD-PARM (1) TO SPF-WORK-AREA\n068200         IF   SPF-WORK-AREA-LAST NOT = SPACES\n068300             MOVE 'PARAMETER TOO LONG' TO PDF-SHORT-MESSAGE\n068400             MOVE 'THE PARAMETER MUST BE LESS THAN 4 BYTES LONG'\n068500             TO PDF-LONG-MESSAGE\n068600             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n068700             MOVE SPACES TO PDF-TBDISPL-PANEL\n068800             GO TO 1999-EXIT\n068900         ELSE\n069000         IF SPF-WORK-AREA = 'DSN'\n069100             MOVE '\"DSN\" IS RESERVED' TO PDF-SHORT-MESSAGE\n069200             MOVE 'THE \"DSN\" LABEL IS A RESERVED SLOT AND MAY NOT\n069300-            'BE USED'\n069400             TO PDF-LONG-MESSAGE\n069500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n069600             MOVE SPACES TO PDF-TBDISPL-PANEL\n069700             GO TO 1999-EXIT\n069800         ELSE\n069900         MOVE PDF-TABLE-ID TO WS-TABLE-ID\n070000         MOVE SPF-WORK-AREA TO WS-TABLE-SUFFIX\n070100         MOVE WS-TABLE-ID TO SPF-FROM-TABLE\n070200         MOVE PDF-TABLE-ID TO SPF-TO-TABLE\n070300         MOVE SPACES TO PDF-SELECT-BUFFER\n070400         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n070500         STRING 'TBSTATS ' DELIMITED BY SIZE\n070600                SPF-FROM-TABLE DELIMITED BY SPACE\n070700                ' STATUS1(ST1) LIBRARY(DSNMGF)'\n070800                DELIMITED BY SIZE\n070900             INTO PDF-SELECT-BUFFER\n071000             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n071100         SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH\n071200         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n071300                                       PDF-SELECT-BUFFER\n071400         IF SPF-STATS1 NOT = 1\n071500             MOVE SPACES TO PDF-SHORT-MESSAGE\n071600             STRING WS-TABLE-SUFFIX ' NOT FOUND'\n071700             DELIMITED BY SIZE INTO PDF-SHORT-MESSAGE\n071800             MOVE 'THE DSN LIST YOU REQUESTED DOES NOT EXIST'\n071900             TO PDF-LONG-MESSAGE\n072000             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n072100             MOVE SPACES TO PDF-TBDISPL-PANEL\n072200             GO TO 1999-EXIT\n072300         ELSE\n072400         MOVE '(DSNAME VOLSER COMMENT PROFILE IMACRO)'\n072500             TO PDF-NAME-LIST\n072600         CALL 'ISPLINK' USING          PDF-TBEND\n072700                                       SPF-TO-TABLE\n072800         CALL 'ISPLINK' USING          PDF-TBCREATE\n072900                                       SPF-TO-TABLE\n073000                                       PDF-DUMMY-PARAMETER\n073100                                       PDF-NAME-LIST\n073200                                       PDF-WRITE\n073300                                       PDF-REPLACE\n073400                                       PDF-LIBRARY\n073500                                       PDF-SHARE\n073600         CALL 'ISPLINK' USING          PDF-TBOPEN\n073700                                       SPF-FROM-TABLE\n073800                                       PDF-NOWRITE\n073900                                       PDF-LIBRARY\n074000         CALL 'ISPLINK' USING          PDF-TBTOP\n074100                                       SPF-FROM-TABLE\n074200         PERFORM 6000-COPY-TABLE THRU 6099-EXIT\n074300         CALL 'ISPLINK' USING          PDF-TBEND\n074400                                       SPF-FROM-TABLE\n074500         MOVE SPACES TO PDF-SHORT-MESSAGE\n074600         MOVE +1 TO SPF-ZTDTOP\n074700         STRING WS-TABLE-SUFFIX ' HAS BEEN COPIED' DELIMITED BY\n074800             SIZE INTO PDF-SHORT-MESSAGE\n074900         MOVE 'YOUR COPY COMMAND HAS COMPLETED SUCCESSFULLY'\n075000         TO PDF-LONG-MESSAGE\n075100         MOVE 'DTSM001W' TO PDF-TBDISPL-MESSAGE\n075200         GO TO 1999-EXIT.\n075300\n075400******************************************************************\n075500*    REPLACE PRIMARY COMMAND                                     *\n075600*         ONE REQUIRED OPERAND - 3 BYTE DSNAME                   *\n075700******************************************************************\n075800\n075900     IF ZCMD-COMMAND = 'REPLACE' OR 'REP' OR 'REPL'\n076000         IF ZCMD-PARM-COUNT > 1\n076100             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n076200             MOVE 'THIS COMMAND ONLY SUPPORTS ONE PARAMETER'\n076300             TO PDF-LONG-MESSAGE\n076400             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n076500             MOVE SPACES TO PDF-TBDISPL-PANEL\n076600             GO TO 1999-EXIT\n076700         ELSE\n076800         IF ZCMD-PARM (1) = SPACES\n076900             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n077000             MOVE 'THIS COMMAND REQUIRES ONE PARAMETER'\n077100             TO PDF-LONG-MESSAGE\n077200             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n077300             MOVE SPACES TO PDF-TBDISPL-PANEL\n077400             GO TO 1999-EXIT\n077500         ELSE\n077600         MOVE ZCMD-PARM (1) TO SPF-WORK-AREA\n077700         IF   SPF-WORK-AREA-LAST NOT = SPACES\n077800             MOVE 'PARAMETER TOO LONG' TO PDF-SHORT-MESSAGE\n077900             MOVE 'THE PARAMETER MUST BE LESS THAN 4 BYTES LONG'\n078000             TO PDF-LONG-MESSAGE\n078100             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n078200             MOVE SPACES TO PDF-TBDISPL-PANEL\n078300             GO TO 1999-EXIT\n078400         ELSE\n078500         IF SPF-WORK-AREA = 'DSN'\n078600             MOVE '\"DSN\" IS RESERVED' TO PDF-SHORT-MESSAGE\n078700             MOVE 'THE \"DSN\" LABEL IS A RESERVED SLOT AND MAY NOT\n078800-            'BE USED'\n078900             TO PDF-LONG-MESSAGE\n079000             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n079100             MOVE SPACES TO PDF-TBDISPL-PANEL\n079200             GO TO 1999-EXIT\n079300         ELSE\n079400         MOVE PDF-TABLE-ID TO WS-TABLE-ID\n079500         MOVE SPF-WORK-AREA TO WS-TABLE-SUFFIX\n079600         MOVE WS-TABLE-ID TO SPF-TO-TABLE\n079700         MOVE PDF-TABLE-ID TO SPF-FROM-TABLE\n079800         MOVE SPACES TO PDF-SELECT-BUFFER\n079900         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n080000         STRING 'TBSTATS ' DELIMITED BY SIZE\n080100                SPF-TO-TABLE DELIMITED BY SPACE\n080200                ' STATUS1(ST1) LIBRARY(DSNMGF)'\n080300                DELIMITED BY SIZE\n080400             INTO PDF-SELECT-BUFFER\n080500             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n080600         SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH\n080700         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n080800                                       PDF-SELECT-BUFFER\n080900         MOVE '(DSNAME VOLSER COMMENT PROFILE IMACRO)'\n081000             TO PDF-NAME-LIST\n081100         CALL 'ISPLINK' USING          PDF-TBCREATE\n081200                                       SPF-TO-TABLE\n081300                                       PDF-DUMMY-PARAMETER\n081400                                       PDF-NAME-LIST\n081500                                       PDF-WRITE\n081600                                       PDF-REPLACE\n081700                                       PDF-LIBRARY\n081800                                       PDF-SHARE\n081900         CALL 'ISPLINK' USING          PDF-TBTOP\n082000                                       PDF-TABLE-ID\n082100         PERFORM 6000-COPY-TABLE THRU 6099-EXIT\n082200         MOVE 50 TO PDF-FULLWORD\n082300         CALL 'ISPLINK' USING          PDF-TBCLOSE\n082400                                       SPF-TO-TABLE\n082500                                       PDF-DUMMY-PARAMETER\n082600                                       PDF-DUMMY-PARAMETER\n082700                                       PDF-FULLWORD\n082800                                       PDF-LIBRARY\n082900         MOVE SPACES TO PDF-SHORT-MESSAGE\n083000         IF SPF-STATS1 NOT = 1\n083100         STRING WS-TABLE-SUFFIX ' HAS BEEN CREATED' DELIMITED BY\n083200             SIZE INTO PDF-SHORT-MESSAGE\n083300         MOVE 'YOUR REPLACE COMMAND HAS COMPLETED SUCCESSFULLY'\n083400         TO PDF-LONG-MESSAGE\n083500         MOVE 'DTSM001W' TO PDF-TBDISPL-MESSAGE\n083600         GO TO 1999-EXIT\n083700         ELSE\n083800         STRING WS-TABLE-SUFFIX ' HAS BEEN REPLACED' DELIMITED BY\n083900             SIZE INTO PDF-SHORT-MESSAGE\n084000         MOVE 'YOUR REPLACE COMMAND HAS COMPLETED SUCCESSFULLY'\n084100         TO PDF-LONG-MESSAGE\n084200         MOVE 'DTSM001W' TO PDF-TBDISPL-MESSAGE\n084300         GO TO 1999-EXIT.\n084400\n084500******************************************************************\n084600*    SAVE   PRIMARY COMMAND                                      *\n084700*         NO OPERANDS ALLOWED                                    *\n084800******************************************************************\n084900\n085000     IF ZCMD-COMMAND = 'SAVE'\n085100         IF ZCMD-PARM-COUNT > 0\n085200             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n085300             MOVE 'THERE ARE NO VALID PARAMETERS FOR THIS COMMAND'\n085400             TO PDF-LONG-MESSAGE\n085500             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n085600             MOVE SPACES TO PDF-TBDISPL-PANEL\n085700             GO TO 1999-EXIT\n085800         ELSE\n085900             MOVE SPACES TO PDF-TBDISPL-CURSOR\n086000             MOVE 0 TO SPF-CSR\n086100             MOVE 25 TO PDF-FULLWORD\n086200             CALL 'ISPLINK' USING      PDF-TBSAVE\n086300                                       PDF-TABLE-ID\n086400                                       PDF-DUMMY-PARAMETER\n086500                                       PDF-DUMMY-PARAMETER\n086600                                       PDF-FULLWORD\n086700                                       PDF-LIBRARY\n086800             MOVE SPACES TO ZCMD-COMMAND-LINE\n086900             GO TO 1999-EXIT.\n087000\n087100******************************************************************\n087200*    CANCEL PRIMARY COMMAND                                      *\n087300*         NO OPERANDS ALLOWED                                    *\n087400******************************************************************\n087500\n087600     IF ZCMD-COMMAND = 'CANCEL'\n087700         IF ZCMD-PARM-COUNT > 0\n087800             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n087900             MOVE 'THERE ARE NO VALID PARAMETERS FOR THIS COMMAND'\n088000             TO PDF-LONG-MESSAGE\n088100             MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n088200             MOVE SPACES TO PDF-TBDISPL-PANEL\n088300             GO TO 1999-EXIT\n088400         ELSE\n088500             MOVE SPACES TO PDF-TBDISPL-CURSOR\n088600             MOVE 0 TO SPF-CSR\n088700             CALL 'ISPLINK' USING      PDF-TBEND\n088800                                       PDF-TABLE-ID\n088900\n089000* THIS IF STATEMENT SUPPORTS RECURSIVE INVOCATION\n089100\n089200             IF SPF-STATS2 = 5\n089300                CALL 'ISPLINK' USING   PDF-TBOPEN\n089400                                       PDF-TABLE-ID\n089500                                       PDF-WRITE\n089600                                       PDF-LIBRARY\n089700                                       PDF-SHARE\n089800             GO TO EXIT-PROGRAM-NOW\n089900             ELSE GO TO EXIT-PROGRAM-NOW.\n090000\n090100 1990-INVALID-COMMAND.\n090200\n090300     MOVE 'ISPZ001' TO PDF-TBDISPL-MESSAGE.\n090400     MOVE SPACES TO PDF-TBDISPL-PANEL.\n090500\n090600 1999-EXIT.\n090700     EXIT.\n090800/\n090900 2000-BUILD-TABLE.\n091000\n091100******************************************************************\n091200*    ISSUE TBSTATS TO DETERMINE THE STATUS OF THE CURRENT TABLE  *\n091300******************************************************************\n091400\n091500     MOVE SPACES TO PDF-SELECT-BUFFER.\n091600     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n091700     STRING 'TBSTATS ' DELIMITED BY SIZE\n091800            PDF-TABLE-ID DELIMITED BY SPACE\n091900            ' STATUS1(ST1) STATUS2(ST2) LIBRARY(DSNMGF)'\n092000            DELIMITED BY SIZE\n092100         INTO PDF-SELECT-BUFFER\n092200         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n092300     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n092400                                       PDF-SELECT-BUFFER.\n092500\n092600     IF SPF-STATS1 = 3\n092700         MOVE SPACES TO PDF-SHORT-MESSAGE\n092800         MOVE 'DDNAME \"DSNMGF\" MUST BE ALLOCATED TO AN ISPF TABLE\n092900-        'LIBRARY' TO PDF-LONG-MESSAGE\n093000         MOVE 'DTSM001' TO PDF-NAME-LIST\n093100         CALL 'ISPLINK' USING          PDF-SETMSG\n093200                                       PDF-NAME-LIST\n093300         MOVE SPACES TO PDF-SELECT-BUFFER\n093400         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n093500         STRING 'SELECT PGM(ISPTUTOR) PARM(DSNHMGF2)'\n093600             DELIMITED BY SIZE\n093700             INTO PDF-SELECT-BUFFER\n093800             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n093900         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n094000                                       PDF-SELECT-BUFFER\n094100         GO TO EXIT-PROGRAM-NOW.\n094200\n094300     IF SPF-STATS2 NOT = 5 AND 1\n094400         DISPLAY 'TABLE IS OPEN INCORRECTLY'\n094500         DISPLAY 'STATUS CODE RETURNED = ' SPF-STATS2\n094600         GO TO EXIT-PROGRAM-NOW.\n094700\n094800     IF SPF-STATS2 = 5\n094900         GO TO 2999-EXIT.\n095000\n095100     IF SPF-STATS1 = 1 AND\n095200        SPF-STATS2 NOT = 5\n095300        CALL 'ISPLINK' USING           PDF-TBOPEN\n095400                                       PDF-TABLE-ID\n095500                                       PDF-WRITE\n095600                                       PDF-LIBRARY\n095700                                       PDF-SHARE\n095800        GO TO 2999-EXIT.\n095900\n096000 2050-CREATE-TABLE.\n096100     MOVE '(DSNAME VOLSER COMMENT PROFILE IMACRO)'\n096200         TO PDF-NAME-LIST.\n096300     CALL 'ISPLINK' USING              PDF-TBCREATE\n096400                                       PDF-TABLE-ID\n096500                                       PDF-DUMMY-PARAMETER\n096600                                       PDF-NAME-LIST\n096700                                       PDF-WRITE\n096800                                       PDF-REPLACE\n096900                                       PDF-LIBRARY\n097000                                       PDF-SHARE.\n097100\n097200     CALL 'ISPLINK' USING              PDF-TBVCLEAR\n097300                                       PDF-TABLE-ID.\n097400\n097500     CALL 'ISPLINK' USING              PDF-TBADD\n097600                                       PDF-TABLE-ID.\n097700\n097800 2999-EXIT.\n097900     EXIT.\n098000/\n098100 4000-LINE-COMMAND.\n098200     CALL 'ISPLINK' USING              PDF-TBPUT\n098300                                       PDF-TABLE-ID.\n098400     IF SPF-LSEL = SPACES\n098500         GO TO 4999-EXIT.\n098600\n098700     IF SPF-LSEL = 'I'\n098800         CALL 'ISPLINK' USING          PDF-TBVCLEAR\n098900                                       PDF-TABLE-ID\n099000         CALL 'ISPLINK' USING          PDF-TBADD\n099100                                       PDF-TABLE-ID\n099200         MOVE SPACES TO SPF-LSEL\n099300         ADD 1 TO SPF-CSR\n099400         MOVE 'DSNAME' TO PDF-TBDISPL-CURSOR\n099500         GO TO 4999-EXIT.\n099600\n099700     IF SPF-LSEL = 'R'\n099800         CALL 'ISPLINK' USING          PDF-TBADD\n099900                                       PDF-TABLE-ID\n100000         MOVE SPACES TO SPF-LSEL\n100100         ADD 1 TO SPF-CSR\n100200         MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n100300         GO TO 4999-EXIT.\n100400\n100500     IF SPF-LSEL = 'D'\n100600         CALL 'ISPLINK' USING          PDF-TBDELETE\n100700                                       PDF-TABLE-ID\n100800         MOVE SPACES TO SPF-LSEL\n100900         SUBTRACT 1 FROM SPF-CSR\n101000         GO TO 4999-EXIT.\n101100\n101200     IF SPF-LSEL = 'B'\n101300         CALL 'ISPLINK' USING         PDF-CONTROL\n101400                                      PDF-DISPLAY\n101500                                      PDF-SAVE\n101600         CALL 'ISPLINK' USING         PDF-CONTROL\n101700                                      PDF-ERRORS\n101800                                      PDF-RETURN\n101900         CALL 'ISPLINK' USING         PDF-BROWSE\n102000                                      SPF-DSNAME\n102100                                      SPF-VOLSER\n102200         MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE\n102300         CALL 'ISPLINK' USING         PDF-CONTROL\n102400                                      PDF-ERRORS\n102500                                      PDF-CANCEL\n102600         CALL 'ISPLINK' USING         PDF-CONTROL\n102700                                      PDF-DISPLAY\n102800                                      PDF-RESTORE\n102900         IF PDF-BROWSE-RETURN-CODE NOT = 0\n103000             MOVE +8 TO PDF-FULLWORD\n103100             MOVE '(ZERRMSG)' TO PDF-NAME-LIST\n103200             CALL 'ISPLINK' USING     PDF-VCOPY\n103300                                      PDF-NAME-LIST\n103400                                      PDF-FULLWORD\n103500                                      PDF-TBDISPL-MESSAGE\n103600                                      PDF-MOVE\n103700             MOVE SPACE TO PDF-TBDISPL-PANEL\n103800             MOVE SPF-CSR TO PDF-TBDISPL-ROW\n103900             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n104000             GO TO 4999-EXIT\n104100         ELSE\n104200         MOVE SPACES TO SPF-LSEL\n104300         GO TO 4999-EXIT.\n104400\n104500     IF SPF-LSEL = 'E'\n104600         CALL 'ISPLINK' USING         PDF-CONTROL\n104700                                      PDF-DISPLAY\n104800                                      PDF-SAVE\n104900         CALL 'ISPLINK' USING         PDF-CONTROL\n105000                                      PDF-ERRORS\n105100                                      PDF-RETURN\n105200         CALL 'ISPLINK' USING         PDF-EDIT\n105300                                      SPF-DSNAME\n105400                                      SPF-VOLSER\n105500                                      PDF-DUMMY-PARAMETER\n105600                                      PDF-DUMMY-PARAMETER\n105700                                      SPF-IMACRO\n105800                                      SPF-PROFILE\n105900         MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE\n106000         CALL 'ISPLINK' USING         PDF-CONTROL\n106100                                      PDF-ERRORS\n106200                                      PDF-CANCEL\n106300         CALL 'ISPLINK' USING         PDF-CONTROL\n106400                                      PDF-DISPLAY\n106500                                      PDF-RESTORE\n106600         IF PDF-BROWSE-RETURN-CODE > 4\n106700             MOVE +8 TO PDF-FULLWORD\n106800             MOVE '(ZERRMSG)' TO PDF-NAME-LIST\n106900             CALL 'ISPLINK' USING     PDF-VCOPY\n107000                                      PDF-NAME-LIST\n107100                                      PDF-FULLWORD\n107200                                      PDF-TBDISPL-MESSAGE\n107300                                      PDF-MOVE\n107400             MOVE SPACE TO PDF-TBDISPL-PANEL\n107500             MOVE SPF-CSR TO PDF-TBDISPL-ROW\n107600             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n107700             GO TO 4999-EXIT\n107800         ELSE\n107900         MOVE SPACES TO SPF-LSEL\n108000         CALL 'ISPLINK' USING          PDF-TBPUT\n108100                                       PDF-TABLE-ID\n108200             GO TO 4999-EXIT.\n108300\n108400\n108500     MOVE '(ZSEL)' TO PDF-NAME-LIST.\n108600     MOVE +256 TO PDF-SELECT-BUFFER-LENGTH\n108700     CALL 'ISPLINK' USING             PDF-VCOPY\n108800                                      PDF-NAME-LIST\n108900                                      PDF-SELECT-BUFFER-LENGTH\n109000                                      PDF-SELECT-BUFFER\n109100                                      PDF-MOVE.\n109200\n109300     MOVE +3 TO PDF-FULLWORD.\n109400     CALL 'ISPLINK' USING             PDF-CONTROL\n109500                                      PDF-DISPLAY\n109600                                      PDF-LINE\n109700                                      PDF-FULLWORD.\n109800     CALL 'ISPLINK' USING             PDF-CONTROL\n109900                                      PDF-DISPLAY\n110000                                      PDF-SAVE.\n110100     CALL 'ISPLINK' USING             PDF-CONTROL\n110200                                      PDF-ERRORS\n110300                                      PDF-CANCEL.\n110400     CALL 'ISPLINK' USING             PDF-SELECT\n110500                                      PDF-SELECT-BUFFER-LENGTH\n110600                                      PDF-SELECT-BUFFER.\n110700     MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE.\n110800     CALL 'ISPLINK' USING             PDF-CONTROL\n110900                                      PDF-ERRORS\n111000                                      PDF-RETURN.\n111100     CALL 'ISPLINK' USING             PDF-CONTROL\n111200                                      PDF-DISPLAY\n111300                                      PDF-RESTORE.\n111400\n111500     CALL 'ISPLINK' USING              PDF-TBPUT\n111600                                       PDF-TABLE-ID.\n111700\n111800     IF PDF-BROWSE-RETURN-CODE NOT = 0\n111900         MOVE SPACES TO PDF-SHORT-MESSAGE\n112000         MOVE PDF-BROWSE-RETURN-CODE TO WORK-NUM-DISPLAY\n112100         STRING 'RETURN CODE = ' DELIMITED BY SIZE\n112200                 WORK-NUM-DISPLAY DELIMITED BY SIZE\n112300                 INTO PDF-SHORT-MESSAGE\n112400         MOVE 'THE REQUESTED FUNCTION ENDED WITH A NON-ZERO RETURN\n112500-        'CODE'\n112600         TO PDF-LONG-MESSAGE\n112700         MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n112800         MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n112900         MOVE SPACES TO PDF-TBDISPL-PANEL\n113000         MOVE SPF-CSR TO PDF-TBDISPL-ROW.\n113100\n113200 4999-EXIT.\n113300     EXIT.\n113400/\n113500 5000-VDEFINE.\n113600\n113700******************************************************************\n113800*    THE FOLLOWING VDEFINES DO NOT MAKE USE OF VDEFINING         *\n113900*    MULTIPLE VARIABLES WITH ONE CALL BECAUSE OF SOME OF THE     *\n114000*    RESTRICTIONS PLACED ON A VS COBOL II PROGRAM THAT USES      *\n114100*    THE COBOL II OPTIMIZER.                                     *\n114200******************************************************************\n114300\n114400******************************************************************\n114500*    ZTDTOP   -  IS THE ISPF VARIABLE FOR TABLE HANDELING        *\n114600******************************************************************\n114700\n114800     MOVE '(ZTDTOP)' TO PDF-NAME-LIST.\n114900     MOVE +4 TO PDF-FULLWORD.\n115000     CALL 'ISPLINK' USING              PDF-VDEFINE\n115100                                       PDF-NAME-LIST\n115200                                       SPF-ZTDTOP\n115300                                       PDF-FIXED\n115400                                       PDF-FULLWORD.\n115500\n115600******************************************************************\n115700*    CSR      -  IS THE ISPF VARIABLE FOR CURRENT CSR POSITION   *\n115800******************************************************************\n115900\n116000     MOVE '(CSR)' TO PDF-NAME-LIST.\n116100     MOVE +4 TO PDF-FULLWORD.\n116200     CALL 'ISPLINK' USING              PDF-VDEFINE\n116300                                       PDF-NAME-LIST\n116400                                       SPF-CSR\n116500                                       PDF-FIXED\n116600                                       PDF-FULLWORD.\n116700\n116800******************************************************************\n116900*    ROWNUM   -  IS THE ISPF VARIABLE FOR CURRENT ROW COUNT      *\n117000******************************************************************\n117100\n117200     MOVE '(ROWNUM)' TO PDF-NAME-LIST.\n117300     MOVE +4 TO PDF-FULLWORD.\n117400     CALL 'ISPLINK' USING              PDF-VDEFINE\n117500                                       PDF-NAME-LIST\n117600                                       SPF-ROWNUM\n117700                                       PDF-FIXED\n117800                                       PDF-FULLWORD.\n117900\n118000******************************************************************\n118100*    NUMROW   -  IS THE ISPF VARIABLE FOR CURRENT ROW COUNT      *\n118200******************************************************************\n118300\n118400     MOVE '(NUMROW)' TO PDF-NAME-LIST.\n118500     MOVE +4 TO PDF-FULLWORD.\n118600     CALL 'ISPLINK' USING              PDF-VDEFINE\n118700                                       PDF-NAME-LIST\n118800                                       SPF-NUMROW\n118900                                       PDF-FIXED\n119000                                       PDF-FULLWORD.\n119100\n119200******************************************************************\n119300*    ZCMD     -  ISPF COMMAND LINE - PRIMARY COMMANDS            *\n119400******************************************************************\n119500\n119600     MOVE '(ZCMD)' TO PDF-NAME-LIST.\n119700     MOVE +80 TO PDF-FULLWORD.\n119800     CALL 'ISPLINK' USING              PDF-VDEFINE\n119900                                       PDF-NAME-LIST\n120000                                       ZCMD-COMMAND-LINE\n120100                                       PDF-CHAR\n120200                                       PDF-FULLWORD.\n120300\n120400******************************************************************\n120500*    ST1      -  FIRST TABLE STATUS VARIABLE (TABLE EXIST?)      *\n120600******************************************************************\n120700\n120800     MOVE '(ST1)' TO PDF-NAME-LIST.\n120900     MOVE +1 TO PDF-FULLWORD.\n121000     CALL 'ISPLINK' USING              PDF-VDEFINE\n121100                                       PDF-NAME-LIST\n121200                                       SPF-STATS1\n121300                                       PDF-CHAR\n121400                                       PDF-FULLWORD.\n121500\n121600******************************************************************\n121700*    ST2      -  2ND TABLE STATUS VARIABLE (TABLE OPEN?)         *\n121800******************************************************************\n121900\n122000     MOVE '(ST2)' TO PDF-NAME-LIST.\n122100     MOVE +1 TO PDF-FULLWORD.\n122200     CALL 'ISPLINK' USING              PDF-VDEFINE\n122300                                       PDF-NAME-LIST\n122400                                       SPF-STATS2\n122500                                       PDF-CHAR\n122600                                       PDF-FULLWORD.\n122700\n122800******************************************************************\n122900*    VOLSER   -  THE VOLSER (PART OF THE TABLE)                  *\n123000******************************************************************\n123100\n123200     MOVE '(VOLSER)' TO PDF-NAME-LIST.\n123300     MOVE +6 TO PDF-FULLWORD.\n123400     CALL 'ISPLINK' USING              PDF-VDEFINE\n123500                                       PDF-NAME-LIST\n123600                                       SPF-VOLSER\n123700                                       PDF-CHAR\n123800                                       PDF-FULLWORD.\n123900\n124000\n124100******************************************************************\n124200*    DSNAME   -  THE DSNAME (PART OF THE TABLE)                  *\n124300******************************************************************\n124400\n124500     MOVE '(DSNAME)' TO PDF-NAME-LIST.\n124600     MOVE +56 TO PDF-FULLWORD.\n124700     CALL 'ISPLINK' USING              PDF-VDEFINE\n124800                                       PDF-NAME-LIST\n124900                                       SPF-DSNAME\n125000                                       PDF-CHAR\n125100                                       PDF-FULLWORD.\n125200\n125300******************************************************************\n125400*    PROFILE  -  THE EDIT PROFILE (PART OF THE TABLE)            *\n125500******************************************************************\n125600\n125700     MOVE '(PROFILE)' TO PDF-NAME-LIST.\n125800     MOVE +8 TO PDF-FULLWORD.\n125900     CALL 'ISPLINK' USING              PDF-VDEFINE\n126000                                       PDF-NAME-LIST\n126100                                       SPF-PROFILE\n126200                                       PDF-CHAR\n126300                                       PDF-FULLWORD.\n126400\n126500******************************************************************\n126600*    IMACRO   -  THE EDIT IMACRO  (PART OF THE TABLE)            *\n126700******************************************************************\n126800\n126900     MOVE '(IMACRO)' TO PDF-NAME-LIST.\n127000     MOVE +8 TO PDF-FULLWORD.\n127100     CALL 'ISPLINK' USING              PDF-VDEFINE\n127200                                       PDF-NAME-LIST\n127300                                       SPF-IMACRO\n127400                                       PDF-CHAR\n127500                                       PDF-FULLWORD.\n127600\n127700******************************************************************\n127800*    DSMPPANL -  THE TBDISPL PANEL NAME FOR EXPAND OPTION        *\n127900******************************************************************\n128000\n128100     MOVE '(DSMPPANL)' TO PDF-NAME-LIST.\n128200     MOVE +8 TO PDF-FULLWORD.\n128300     CALL 'ISPLINK' USING              PDF-VDEFINE\n128400                                       PDF-NAME-LIST\n128500                                       SPF-TBDISPL-PANEL\n128600                                       PDF-CHAR\n128700                                       PDF-FULLWORD.\n128800\n128900     MOVE SPACES TO PDF-SELECT-BUFFER.\n129000     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n129100     STRING 'VGET (DSMPPANL) PROFILE'\n129200         DELIMITED BY SIZE\n129300         INTO PDF-SELECT-BUFFER\n129400         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n129500     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n129600                                       PDF-SELECT-BUFFER.\n129700\n129800     IF SPF-TBDISPL-PANEL = SPACE\n129900        MOVE 'DSNBMGF' TO SPF-TBDISPL-PANEL.\n130000     MOVE SPF-TBDISPL-PANEL TO PDF-TBDISPL-PANEL.\n130100\n130200******************************************************************\n130300*    LSEL     -  THE LINE COMMAND VARIABLE                       *\n130400******************************************************************\n130500\n130600     MOVE '(LSEL)' TO PDF-NAME-LIST.\n130700     MOVE +8 TO PDF-FULLWORD.\n130800     CALL 'ISPLINK' USING              PDF-VDEFINE\n130900                                       PDF-NAME-LIST\n131000                                       SPF-LSEL\n131100                                       PDF-CHAR\n131200                                       PDF-FULLWORD.\n131300\n131400******************************************************************\n131500*    UMSG1    -  SHORT (UPPER) MESSAGE FOR ERRORS                *\n131600******************************************************************\n131700\n131800     MOVE '(UMSG1)' TO PDF-NAME-LIST.\n131900     MOVE +24 TO PDF-FULLWORD.\n132000     CALL 'ISPLINK' USING              PDF-VDEFINE\n132100                                       PDF-NAME-LIST\n132200                                       PDF-SHORT-MESSAGE\n132300                                       PDF-CHAR\n132400                                       PDF-FULLWORD.\n132500\n132600******************************************************************\n132700*    LMSG1    -  LONG (LOWER) MESSAGE FOR ERRORS                 *\n132800******************************************************************\n132900\n133000     MOVE '(LMSG1)' TO PDF-NAME-LIST.\n133100     MOVE +78 TO PDF-FULLWORD.\n133200     CALL 'ISPLINK' USING              PDF-VDEFINE\n133300                                       PDF-NAME-LIST\n133400                                       PDF-LONG-MESSAGE\n133500                                       PDF-CHAR\n133600                                       PDF-FULLWORD.\n133700******************************************************************\n133800*    MEMBER   -  FOR THE LIST COMMAND                            *\n133900******************************************************************\n134000\n134100     MOVE '(MEMBER)' TO PDF-NAME-LIST.\n134200     MOVE +8 TO PDF-FULLWORD.\n134300     CALL 'ISPLINK' USING              PDF-VDEFINE\n134400                                       PDF-NAME-LIST\n134500                                       SPF-WORK-NAME\n134600                                       PDF-CHAR\n134700                                       PDF-FULLWORD.\n134800     MOVE '(ID)' TO PDF-NAME-LIST.\n134900     MOVE +3 TO PDF-FULLWORD.\n135000     CALL 'ISPLINK' USING              PDF-VDEFINE\n135100                                       PDF-NAME-LIST\n135200                                       SPF-WORK-ID\n135300                                       PDF-CHAR\n135400                                       PDF-FULLWORD.\n135500 5999-EXIT.\n135600     EXIT.\n135700/\n135800 6000-COPY-TABLE.\n135900     CALL 'ISPLINK' USING             PDF-TBSKIP\n136000                                      SPF-FROM-TABLE.\n136100     IF RETURN-CODE NOT = 0\n136200         GO TO 6099-EXIT.\n136300\n136400     CALL 'ISPLINK' USING             PDF-TBADD\n136500                                      SPF-TO-TABLE.\n136600\n136700     GO TO 6000-COPY-TABLE.\n136800\n136900 6099-EXIT.\n137000     EXIT.\n137100/\n137200 6100-DEL.\n137300     CALL 'ISPLINK' USING             PDF-TBSKIP\n137400                                      PDF-TABLE-ID.\n137500     IF RETURN-CODE NOT = 0\n137600         GO TO 6199-EXIT.\n137700\n137800     CALL 'ISPLINK' USING             PDF-TBDELETE\n137900                                      PDF-TABLE-ID.\n138000\n138100     GO TO 6100-DEL.\n138200\n138300 6199-EXIT.\n138400     EXIT.\n138500/\n138600 7000-LIST-COMMAND.\n138700\n138800     CALL 'ISPLINK' USING             PDF-CONTROL\n138900                                      PDF-DISPLAY\n139000                                      PDF-SAVE.\n139100\n139200     MOVE SPACES TO PDF-SELECT-BUFFER.\n139300     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n139400     STRING 'LMINIT DATAID(DSNMGF) DDNAME(DSNMGF)'\n139500         DELIMITED BY SIZE\n139600         INTO PDF-SELECT-BUFFER\n139700         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n139800     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n139900     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n140000                                       PDF-SELECT-BUFFER.\n140100\n140200     MOVE '(DSNMGF)' TO PDF-NAME-LIST.\n140300     MOVE 8 TO PDF-FULLWORD.\n140400     CALL 'ISPLINK' USING              PDF-VCOPY\n140500                                       PDF-NAME-LIST\n140600                                       PDF-FULLWORD\n140700                                       SPF-THE-TABLE\n140800                                       PDF-MOVE.\n140900\n141000     MOVE SPACES TO PDF-SELECT-BUFFER.\n141100     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n141200     STRING 'LMOPEN DATAID(&DSNMGF)'\n141300         DELIMITED BY SIZE\n141400         INTO PDF-SELECT-BUFFER\n141500         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n141600     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n141700     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n141800                                       PDF-SELECT-BUFFER.\n141900\n142000     MOVE SPACES TO PDF-SELECT-BUFFER.\n142100     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n142200     STRING 'TBCREATE &DSNMGF NAMES(ID TABLEUPD USER NUMROW CDATE'\n142300         ' CTIME) NOWRITE REPLACE'\n142400         DELIMITED BY SIZE\n142500         INTO PDF-SELECT-BUFFER\n142600         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n142700     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n142800     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n142900                                       PDF-SELECT-BUFFER.\n143000\n143100     PERFORM 7100-GEN-TABLE THRU 7199-EXIT.\n143200\n143300     MOVE SPACES TO PDF-SELECT-BUFFER.\n143400     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n143500     STRING 'LMCLOSE DATAID(&DSNMGF)'\n143600         DELIMITED BY SIZE\n143700         INTO PDF-SELECT-BUFFER\n143800         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n143900     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n144000     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n144100                                       PDF-SELECT-BUFFER.\n144200\n144300     MOVE SPACES TO PDF-SELECT-BUFFER.\n144400     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n144500     STRING 'LMFREE DATAID(&DSNMGF)'\n144600         DELIMITED BY SIZE\n144700         INTO PDF-SELECT-BUFFER\n144800         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n144900     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n145000     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n145100                                       PDF-SELECT-BUFFER.\n145200\n145300     IF PDF-TBDISPL-MESSAGE NOT = SPACES\n145400         GO TO 7099-EXIT.\n145500\n145600     MOVE 'DSNBMGFL' TO SPF-TEMP-PANEL.\n145700     MOVE SPF-THE-TABLE TO  SPF-TEMP-TABLE.\n145800     PERFORM 7200-TBDISPL THRU 7299-EXIT.\n145900 7099-EXIT.\n146000     MOVE SPACES TO PDF-SELECT-BUFFER.\n146100     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n146200     STRING 'TBEND &DSNMGF'\n146300         DELIMITED BY SIZE\n146400         INTO PDF-SELECT-BUFFER\n146500         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n146600     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n146700     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n146800                                       PDF-SELECT-BUFFER.\n146900\n147000     CALL 'ISPLINK' USING             PDF-CONTROL\n147100                                      PDF-DISPLAY\n147200                                      PDF-RESTORE.\n147300\n147400\n147500\n147600 7100-GEN-TABLE.\n147700\n147800     MOVE SPACES TO PDF-SELECT-BUFFER.\n147900     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n148000     STRING 'LMMLIST DATAID(&DSNMGF) MEMBER(MEMBER)'\n148100         DELIMITED BY SIZE\n148200         INTO PDF-SELECT-BUFFER\n148300         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n148400     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n148500     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n148600                                       PDF-SELECT-BUFFER.\n148700\n148800     MOVE RETURN-CODE TO COMPLETION-CODE.\n148900     IF COMPLETION-CODE = 4\n149000         MOVE 'NO DSNLIST FOUND' TO PDF-SHORT-MESSAGE\n149100         MOVE 'THERE ARE NO SAVED DSNAME LISTS AT THIS TIME'\n149200         TO PDF-LONG-MESSAGE\n149300         MOVE 'DTSM001' TO PDF-TBDISPL-MESSAGE\n149400         MOVE SPACES TO PDF-TBDISPL-PANEL\n149500         GO TO 7199-EXIT.\n149600\n149700     IF COMPLETION-CODE = 8\n149800         GO TO 7199-EXIT.\n149900\n150000     IF PDF-TABLE-ID-PREFACE NOT = SPF-WORK-USER\n150100         AND ZCMD-COMMAND NOT = 'FLIST'\n150200         GO TO 7100-GEN-TABLE.\n150300\n150400     MOVE SPACES TO PDF-SELECT-BUFFER.\n150500     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n150600     STRING 'TBSTATS ' SPF-WORK-NAME\n150700            ' CDATE(CDATE) CTIME(CTIME) USER(USER)'\n150800            ' ROWCURR(NUMROW) LIBRARY(DSNMGF)'\n150900            DELIMITED BY SIZE\n151000         INTO PDF-SELECT-BUFFER\n151100         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n151200     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n151300     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n151400                                       PDF-SELECT-BUFFER.\n151500\n151600     MOVE SPACES TO PDF-SELECT-BUFFER.\n151700     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n151800     STRING 'TBADD &DSNMGF'\n151900         DELIMITED BY SIZE\n152000         INTO PDF-SELECT-BUFFER\n152100         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n152200     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n152300     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n152400                                       PDF-SELECT-BUFFER.\n152500\n152600     GO TO 7100-GEN-TABLE.\n152700\n152800 7199-EXIT.\n152900     EXIT.\n153000/\n153100 7200-TBDISPL.\n153200\n153300     MOVE SPACES TO PDF-SELECT-BUFFER.\n153400     MOVE +1 TO PDF-SELECT-BUFFER-LENGTH.\n153500     STRING 'TBTOP &DSNMGF'\n153600         DELIMITED BY SIZE\n153700         INTO PDF-SELECT-BUFFER\n153800         WITH POINTER PDF-SELECT-BUFFER-LENGTH.\n153900     SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH.\n154000     CALL 'ISPEXEC' USING              PDF-SELECT-BUFFER-LENGTH\n154100                                       PDF-SELECT-BUFFER.\n154200\n154300     CALL 'ISPLINK' USING             PDF-TBDISPL\n154400                                      SPF-TEMP-TABLE\n154500                                      SPF-TEMP-PANEL.\n154600     MOVE RETURN-CODE TO COMPLETION-CODE.\n154700     MOVE SPF-THE-TABLE TO SPF-TEMP-TABLE.\n154800     MOVE 'DSNBMGFL' TO SPF-TEMP-PANEL.\n154900\n155000     IF COMPLETION-CODE > 4\n155100         GO TO 7299-EXIT.\n155200\n155300     MOVE 'CSR' TO PDF-VARIABLE-NAME.\n155400     CALL 'ISPLINK' USING              PDF-TBQUERY\n155500                                       SPF-TEMP-TABLE\n155600                                       PDF-DUMMY-PARAMETER\n155700                                       PDF-DUMMY-PARAMETER\n155800                                       PDF-DUMMY-PARAMETER\n155900                                       PDF-DUMMY-PARAMETER\n156000                                       PDF-DUMMY-PARAMETER\n156100                                       PDF-VARIABLE-NAME.\n156200\n156300     IF SPF-CSR NOT = 0\n156400     IF SPF-LSEL = 'DEL'\n156500         MOVE SPACES TO PDF-SELECT-BUFFER\n156600         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n156700         MOVE PDF-TABLE-ID-PREFACE TO SPF-WORK-USER\n156800         STRING 'TBERASE ' DELIMITED BY SIZE\n156900                SPF-WORK-NAME DELIMITED BY SPACE\n157000                ' LIBRARY(DSNMGF)'\n157100                DELIMITED BY SIZE\n157200             INTO PDF-SELECT-BUFFER\n157300             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n157400         SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH\n157500         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n157600                                       PDF-SELECT-BUFFER\n157700\n157800         MOVE SPACES TO PDF-SELECT-BUFFER\n157900         MOVE +1 TO PDF-SELECT-BUFFER-LENGTH\n158000         MOVE PDF-TABLE-ID-PREFACE TO SPF-WORK-USER\n158100         STRING 'TBDELETE &DSNMGF'\n158200                DELIMITED BY SIZE\n158300             INTO PDF-SELECT-BUFFER\n158400             WITH POINTER PDF-SELECT-BUFFER-LENGTH\n158500         SUBTRACT 1 FROM PDF-SELECT-BUFFER-LENGTH\n158600         CALL 'ISPEXEC' USING          PDF-SELECT-BUFFER-LENGTH\n158700                                       PDF-SELECT-BUFFER\n158800         MOVE SPACES TO SPF-LSEL\n158900         IF COMPLETION-CODE = 4\n159000             MOVE SPACES TO SPF-TEMP-PANEL\n159100             GO TO 7200-TBDISPL\n159200         ELSE\n159300             GO TO 7200-TBDISPL.\n159400\n159500\n159600\n159700     IF COMPLETION-CODE = 4\n159800         MOVE SPACES TO SPF-TEMP-PANEL\n159900         GO TO 7200-TBDISPL.\n160000 7299-EXIT.\n160100     EXIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDREC": {"ttr": 4867, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET EDREC      AT LEVEL 005 AS OF 08/12/85\nEDRECUT  TITLE 'STANDARD EDIT RECOVERY ROUTINE FOR ISPF VERSION II'\nEDRECUT  CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'EDRECUT '              CSECT NAME\n         DC    C'08/12/85 '             DATE WRITTEN\n         DC    C'VERSION 1.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING EDRECUT,12               PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         ISPF  LOAD,ISPEXEC=(YES,ISPEXEC)\n         SPACE\n         EDREC 'INIT',,,'ISREDRTI'\n         SPACE\n         XR    4,4\n         LTR   15,15\n         BZ    EXITPGM\n         SPACE 3\nLOOP     EDREC 'QUERY'\n         SPACE\n         LTR   15,15\n         BZ    EXITPGM\n         DISPLAY PANEL='ISREDM02'\n         SPACE\n         LTR   15,15\n         BZ    PROCESS\n         EDREC 'DEFER',MF=E\n         LA    4,20\n         B     EXITPGM\nPROCESS  DS    0H\n         MVI   ZEDCMD,C' '\n         MVC   VCOPYLEN,=F'1'\n         VCOPY '(ZEDCMD)',VCOPYLEN,ZEDCMD,MOVE,MF=E\n         SPACE\n         CLI   ZEDCMD,C' '\n         BNE   B0001\n         ISPEXEC ,'EDREC PROCESS PASSWORD(&&PSWD)'\n         LA    4,1(4)\n         B     LOOP\nB0001    DS    0H\n         CLI   ZEDCMD,C'D'\n         BNE   B0002\n         EDREC 'DEFER'\n         B     LOOP\nB0002    DS    0H\n         EDREC 'CANCEL'\n         B     LOOP\nEXITPGM  DS    0H\n         ISPF  DELETE,ISPEXEC=YES\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,4                     GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         EJECT\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         SPACE\n         ISPF  PARMS,ISPEXEC=YES\nVCOPYLEN DS    F\nZEDCMD   DS    C\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nEDRECUT  CSECT ,                        RESUME CSECT\n         END   EDRECUT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EQURG": {"ttr": 4870, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO                                                          00001\n         EQURG                                                          00002\n         GBLB  &GBLEQU                                                  00006\n.*                                                                      00011\n.*       THIS MACRO WILL EXPAND TO GENERATE THE REGISTER EQUATE         00012\n.*       INSTRUCTIONS                                                   00013\n.*                                                                      00014\n         AIF   (&GBLEQU).END            SKIP IF ALREADY GENED           00408\n&GBLEQU  SETB  1\nR0       EQU   0                                                        00410\nR1       EQU   1                                                        00411\nR2       EQU   2                                                        00412\nR3       EQU   3                                                        00413\nR4       EQU   4                                                        00414\nR5       EQU   5                                                        00415\nR6       EQU   6                                                        00416\nR7       EQU   7                                                        00417\nR8       EQU   8                                                        00418\nR9       EQU   9                                                        00419\nR10      EQU   10                                                       00420\nR11      EQU   11                                                       00421\nR12      EQU   12                                                       00422\nR13      EQU   13                                                       00423\nR14      EQU   14                                                       00424\nR15      EQU   15                                                       00425\n.END     ANOP                                                           00428\n         MEND                                                           00439\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GET0TABL": {"ttr": 4872, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GET0TABL CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'GET0TABL '             CSECT NAME\n         DC    C'05/14/85 '             DATE WRITTEN\n         DC    C'VERSION 1.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    2,1                      SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING GET0TABL,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         CALL  RET0TABL,(DDNAME),MF=(E,SPFPARMS)\n         SPACE\n         ISPF  LOAD                LOAD ISPLINK\n         SPACE\n         L     2,0(2)              GET VARNAME POINTER\n         MVC   VARNAME,=CL10'(        )'\n         LH    3,0(2)              GET LENGTH OF VARNAME\n         CH    3,=H'0'             IS REGISTER 3 = 0\n         BE    BADLEN\n         CH    3,=H'8'\n         BH    BADLEN\n         BCTR  3,0                 BUMP DOWN FOR MVC\n         MVC   VARNAME+1(*-*),2(2) DUMMY MVC\n         EX    3,*-6               MOVE REST OF VARNAME\n         VREPLACE VARNAME,=F'8',DDNAME,MF=E\n         SPACE\n         VPUT  VARNAME,SHARED,MF=E\n         SPACE\n         ISPF  DELETE\n         SPACE 3\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         SR    15,15                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         SPACE 3\nBADLEN   DS    0H\n         TPUT  =CL79'INVALID PARAMETER LENGTH RECEIVED - EXPECTED 1 - 8*\n               BYTES',79\n         SPACE 3\n         ABEND 20\n         EJECT\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nDDNAME   DS    CL8\nVARNAME  DS    CL10\n         ISPF  PARMS,MINIMUM=1\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nGET0TABL CSECT ,                        RESUME CSECT\n         END   GET0TABL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOB0LIST": {"ttr": 4875, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "JOB0LIST TITLE ' - LIST ACTIVE JOBS - ISPF INTERFACE'\n*OB0LIST AMODE 31\nJOB0LIST CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'JOB0LIST '             CSECT NAME\n         DC    C'04/23/85 '             DATE WRITTEN\n         DC    C'VERSION 1.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING JOB0LIST,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n         EJECT\n         ISPF  LOAD                LOAD ISPLINK\n         SPACE\n         CONTROL ERRORS,CANCEL,MF=E\n         SPACE\n         VDEFINE '(ZTDTOP ZTDROWS ROWID)',ZTDTOP,FIXED,4,MF=E\n         SPACE 3\n         VDEFINE '(AUTOREQ JOBFTSO OSW)',AUTOREQ,CHAR,1,'(COPY)',MF=E\n         SPACE 3\n         VDEFINE '(JOBPLMT)',LIMIT,CHAR,8,'(COPY)',MF=E\n         SPACE 3\n         XC    ZTDTOP,ZTDTOP\n         XC    ROWID,ROWID\n         MVI   AUTOMODE,C'0'       SET AUTOMODE INITALLY OFF\n         MVI   AUTOREQ,C'0'        SET AUTOMODE REQUEST OFF\n         MVC   TABLE,=CL8'JOBT'    BEGIN TABLE NAME\n         TIME  ,                   GET CURRENT TIME\n         SPACE\n         ST    0,TABLE+4           BUILD TABLE NAME WITH TIME\n         MVC   VCOPYLEN,=F'14'\n         VDEFINE '(JOBPSORT)',JOBPSORT,CHAR,14,'(COPY)',MF=E\n         SPACE\n         CLC   JOBPSORT,=CL14' '\n         BNE   LOOP\n         MVC   JOBPSORT,=CL14'(JOBNAME,C,A)'\n         SPACE 3\nLOOP     DS    0H\n         TBCREATE TABLE,           BUILD THE TABLE                     *\n               NAMES='(JOBNAME STEPNAME PROCNAME JOBHH CPUTIME MEMSTAT1*\n               )',REPLACE='REPLACE',MF=E\n         SPACE\n         TBSORT TABLE,FIELDS=JOBPSORT,MF=E\n         SPACE\n         CALL  JOB1LIST,(TABLE),MF=(E,SPFPARMS)\n         SPACE\n         TBTOP TABLE,MF=E\n         SPACE\n         VREPLACE '(JOBNAME)',=F'8',JOBNAME,MF=E\n         SPACE\n         TBSCAN TABLE,ARGLIST='(JOBNAME)',MF=E\n         SPACE\n         CLI   AUTOMODE,C'1'       ARE WE IN AUTOMODE\n         BNE   DISPLIT             IF NOT GO TBDISPL\n         CONTROL DISPLAY,LOCK      LOCK KEYBOARD\n         SPACE\nDISPLIT  DS    0H\n         TBDISPL TABLE,PANEL='JOBBLIST',MF=E\n         SPACE\n         LTR   15,15               WAS END COMMAND ENTERED\n         BNZ   EXITPGM\n         TBTOP TABLE,MF=E\n         SPACE\n         CLC   ZTDTOP,=F'1'\n         BNH   SPJOB\n         TBSKIP TABLE,NUMBER=ZTDTOP,MF=E\n         SPACE\n         MVC   VCOPYLEN,=F'8'\n         VCOPY '(JOBNAME)',VCOPYLEN,JOBNAME,MOVE,MF=E\n         SPACE\n         CLI   OSW,C'1'\n         BNE   Y100\n         MVI   OSW,C'0'\nSPJOB    XC    JOBNAME,JOBNAME\nY100     DS    0H\n         CLI   AUTOMODE,C'1'       ARE WE IN AUTOMODE\n         BNE   CONTINUE            IF NOT CONTINUE\n         CLI   PA1HIT,C'1'         WAS PA1 HIT\n         BE    ATTNHIT             IF NOT KEEP DISPLAYING\n         TIME  BIN,                TAKE TIME READING\n         C     0,TIMELIM           IS AUTOMODE LIMIT UP\n         BL    LOOP                IF NOT UP - KEEP GOING\n         BAL   14,TURNOFF          TURN OF STAX AND PA1 SWITCH\nATTNHIT  MVI   AUTOMODE,C'0'       SET AUTOMODE OFF\n         CONTROL DISPLAY,REFRESH   REFRESH THE SCREEN\n         SPACE\n         B     LOOP                RETURN\n         SPACE\nCONTINUE DS    0H                  NOT AUTOMODE\n         CLI   AUTOREQ,C'1'        AUTOMODE REQUESTED\n         BNE   LOOP                GOTO LOOP IF NOT\n         MVI   PA1HIT,C'0'         SET PA1 HIT SWITCH TO OFF\n         MVI   AUTOMODE,C'1'       SET AUTOMODE ON\n         TIME  BIN                 GET TIME OF DAY\n         LR    2,0                 SAVE TIME OF DAY\n         A     2,=F'6000'          BUMP BY 1 MINUTE\n         ST    2,TIMELIM           SAVE TIME LIMIT OF 1 MINUTE OF AUTO\n         STM   11,13,STAXREGS\nSTAXIT   STAX  ATTNEXIT,                                               *\n               REPLACE=YES,                                            *\n               IBUF=0,                                                 *\n               OBUF=0,                                                 *\n               USADDR=STAXREGS,                                        *\n               MF=(E,STAXLIST)\n         B     LOOP\n         SPACE 5\nEXITPGM  DS    0H\n         TBEND TABLE,MF=E\n         SPACE\n         VRESET ,\n         SPACE\n         ISPF  DELETE\n         SPACE 5\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         SR    15,15                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - ATTENTION EXIT  '\nATTNEXIT DS    0H\n         L     1,8(1)              GET PARMS ADDRESS\n         LM    11,13,0(1)          RESTORE BASE REGISTER\nTURNOFF  STAX  ,                   TURN OFF STAX EXIT\n         SPACE\n         MVI   PA1HIT,C'1'         SET PA1 SWITCH ON\n         BR    14                  RETURN\n         TITLE ' - WORKING STORAGE '\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\nAUTOMODE DS    CL1                 AUTOMODE SET?\nAUTOREQ  DS    CL1                 AUTOREQ SWITCH\nJOBFTSO  DS    CL1                 TSO USER SWITCH\nOSW      DS    CL1                 TSO USER SWITCH\nPA1HIT   DS    CL1                 PA1 SWITCH\nSTAXREGS DS    3F                  BASE REGS FOR STAX EXIT\nTIMELIM  DS    F                   TIME LIMIT FOR AUTO MODE\nJOBPSORT DS    CL14                SORT KEY\nJOBNAME  DS    CL8                 SORT KEY\nVCOPYLEN DS    F                   SORT KEY\nTABLE    DS    CL8                 ISPF TABLE NAME\nLIMIT    DS    CL8                 LIMIT OUTPUT\nSLIMIT   DS    CL8                 LIMIT OUTPUT\nZTDTOP   DS    F                   TOP OF SCREEN DISPLAYED\nZTDROWS  DS    F                   TOP OF SCREEN DISPLAYED\nROWID    DS    F                   ROWID\n         ISPF  PARMS,MINIMUM=1     WORKING STORAGE\nSTAXLIST STAX  ATTNEXIT,IBUF=0,OBUF=0,REPLACE=YES,USADDR=0,MF=L\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nJOB0LIST CSECT ,                        RESUME CSECT\n         END   JOB0LIST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOB1LIST": {"ttr": 4879, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE ' - DA TSO CP CONVERTED TO ISPF DIALOG'\nJOB1LIST AMODE 31\nJOB1LIST CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'JOB1LIST '             CSECT NAME\n         DC    C'04/23/85 '             DATE WRITTEN\n         DC    C'VERSION 1.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    3,1                      SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING JOB1LIST,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=DSECTL,SP=0       GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING VARYABL,13               SETUP WORKING STORAGE\n         LA    14,BINIT\n         LA    15,EINIT\n         L     1,=X'40000000'\n         MVCL  14,0\n         EJECT\n         ISPF  LOAD                LOAD ISPLINK\n         SPACE\n         VDEFINE '(JOBNAME)',JOBNAME,CHAR,=F'8',MF=E\n         SPACE\n         VDEFINE '(PROCNAME)',PROCNAME,CHAR,=F'8',MF=E\n         SPACE\n         VDEFINE '(STEPNAME)',STEPNAME,CHAR,=F'8',MF=E\n         SPACE\n         VDEFINE '(MEMSTAT1)',MEMSTAT1,CHAR,=F'8',MF=E\n         SPACE\n         VDEFINE '(JOBHH)',JOBHH,CHAR,=F'8',MF=E\n         SPACE\n         VDEFINE '(CPUTIME)',CPUTIME,CHAR,=F'8',MF=E\n         SPACE 5\n         MVC   VCOPYLEN,=F'1'\n         VCOPY  '(JOBPTSO)',VCOPYLEN,JOBPTSO,MOVE,MF=E\n         SPACE 5\n         MVC   VCOPYLEN,=F'8'\n         VCOPY '(JOBPLMT)',VCOPYLEN,LIMIT,MOVE,MF=E\n         SPACE\n         MVC   LIMITL,VCOPYLEN\n         MVC   VCOPYLEN,=F'1'\n         VCOPY '(JOBFTSO)',VCOPYLEN,JOBFTSO,MOVE,MF=E\n         SPACE\n         L     1,0(3)              GET PARM PASSED\n         MVC   TABLE,0(1)          GET ISPF TABLE NAME\n         B     START               BRANCH TO ENTRY CODE.\n         EJECT\n$$EOJ    DS    0H                       GET ADDRESS FOR FREEMAIN\n         LR    10,15               SAVE RETURN CODE\n         VDELETE '(JOBNAME STEPNAME PROCNAME MEMSTAT1 JOBHH CPUTIME)', *\n               MF=E\n         SPACE\n         ISPF  DELETE              DELETE ISPLINK\n         SPACE 3\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,VARYABL+4             GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=DSECTL,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,10                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\nSTART    DS    0H                  PROGRAM ENTRY POINT.\nLINKREG  EQU   6                   LINK REGISTER\n*\n         MVI   BUFFER,C' '        CLEAR OUT BUFFER\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         SPACE\n*\n         MVC   SWITCH(1),CSWITCH\n         MVC   WRKD(1),CWRKD\n         MVC   DDOTS(2),DOTS      MOVE IN CONSTANTS TO #JOBS/\n         MVC   DJOBS(6),JOBS      INITIATORS MESSAGE\n         MVC   DINITIAT(11),INITIAT\n         LA    R2,0               COUNTER FOR # INITIATORS\n         LA    R3,0               COUNTER FOR # JOBS/STC\n         L     R11,CVTPTR         (R11)=ADDR CVT\n         USING CVT,R11\n         L     R9,CVTOPCTP        (R9) =ADDR (SRM'S RMCT)\n         ST    R9,RMCTPTR            WHICH IS SAVED FOR LATER\n         L     R9,CVTASVT         (R9)= ADDR ASVT\n         USING ASVT,R9\n         L     R5,ASVTMAXU        (R5)=MAX NUMB OF ASCB ENTRIES\n         LA    R5,2(R5)              +2 SO WE CAN SCAN ENTIRE ASVT..\n         LA    R9,ASVTFRST-4      (R9)= ADDR-4 OF FIRST ASCB ENTRY\n         DROP  R9\n         LA    R0,MSGL            MSGL IS LENGTH OF MESSAGE\n         LA    R1,MSGH            MSGH - MESSAGE \"SADSC DISPLAY ACTIVE\"\n         BAL   LINKREG,PUTMSG     DO THE TPUT OF MSGH\n         LA    R0,HEADINGL\n         LA    R1,HEADING\n*        BAL   LINKREG,PUTMSG     WRITE OUT HEADING\n         B     NEXTONE            GO GET ASCB\n         USING ASCB,R8\n*\n* LOOP THROUGH ALL ASCBS\n*\nLOOP1    L     R10,ASCBCSCB       LOAD CSCB ADDR\n         USING CSCB,R10\nCHKCSCB  TM    CHTRKID,CHINITID   IS IT AN INIT?\n         BNO   TESTJOB            NO-> ..GO CHECK FOR JOB\n         LA    R2,1(R2)           YES-> INCR COUNT OF INITS\n         B     NEXTONE              GO GET ANOTHER\n*\n*\nTESTJOB  DS    0H\n         TM    CHTRKID,CHJOBID    IS IT A STC?\n*        BNO   NEXTONE            NOPE-> MUST BE TSO..GO GET ANOTHER\n         BNO   CHECKTSO           NOPE-> MUST BE TSO..GO GET ANOTHER\n         B     NOTTSO\nCHECKTSO DS    0H\n         CLI   JOBPTSO,C'Y'        ARE TSO USERS DESIRED\n         BNE   NEXTONE             IF NOT KEEP GOING\n         MVI   SWITCH,X'F0'       SAY WE FOUND ONE\n         MVC   JOBNAME,CHKEY      MOVE IN JOBNAME FROM CSCB\n         MVC   PROCNAME,CHCLS     MOVE IN PROCNAME FROM CSCB\n         MVC   STEPNAME,=CL8'TSO ' MOVE IN STEPNAME FROM CSCB\n         B     GETREST             KEEP GOING\nNOTTSO   MVI   SWITCH,X'F0'       SAY WE FOUND ONE\n         MVC   JOBNAME,CHCLS      MOVE IN JOBNAME FROM CSCB\n         MVC   PROCNAME,CHKEY     MOVE IN PROCNAME FROM CSCB\n         MVC   STEPNAME,CHPROCSN  MOVE IN STEPNAME FROM CSCB\nGETREST  LA    R3,1(R3)           BUMP COUNT OF JOBS/STC\n         BAL   R6,COMPTIME        GO GET STEP/CPU TIME\n*                                   AND MEMORY STATUS\n         LA    R0,BUFFERL\n         LA    R1,BUFFER\n         BAL   LINKREG,PUTMSG     SHOVEL IT OUT\n         MVI   BUFFER,C' '        AND CLEAR IT OUT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n*\nNEXTONE  BCT   R5,DOIT            CHECK COUNT\n         B     DOJOBS             NO MORE..SPLIT\nDOIT     LA    R9,4(0,R9)         INCR INTO ASVT\n         L     R8,0(0,R9)         LOAD ASCB ADDR\n         LTR   R8,R8              END OF ASCBS?\n         BZ    DOJOBS             YES->EXIT\n         TM    0(R9),X'80'        ASID ASSIGNED?\n         BO    NEXTONE            NO-> TRY AGAIN.\n         B     LOOP1              YES->SEE IF WE LIKE IT\n         EJECT\n*\n* NOW WE HAVE DISPOSED OF THE STC IN THE SYSTEM,\n*\n*  WE MUST GO BACK THRU THE ASCBS AND LOOK FOR 'REAL' JOBS...\n*\n*\nDOJOBS   L     R11,CVTPTR         (R11)=ADDR CVT\n         L     R9,CVTASVT         (R9)= ADDR ASVT\n         USING ASVT,R9\n         L     R5,ASVTMAXU        (R5)=MAX NUMB OF ASCB ENTRIES\n         LA    R5,2(R5)              +2 SO WE CAN SCAN ENTIRE ASVT..\n         LA    R9,ASVTFRST-4      (R9)= ADDR-4 OF FIRST ASCB ENTRY\n         DROP  R9\n         B     NEXTPLS            GO GET ASCB\n*\n* LOOP THROUGH ALL ASCBS\n*\nLOOP2    L     R10,ASCBCSCB       LOAD CSCB ADDR\n         USING CSCB,R10\nCHKCSCB1 TM    CHTRKID,CHINITID   IS IT AN INIT?\n         BNO   NEXTPLS            ->NO GO GET ANOTHER ASCB\n         L     R4,ASCBJBNI        GET PTR TO JOBNAME\n         LTR   R4,R4              IS IT A JOB?\n         BZ    NEXTPLS            NOPE->DRY INIT..GO GET ANOTHER\n*\n* HERE WE GET  SNEAKY..A HONEST TO GOD JOB'S CSCB IS NOT POINTED TO\n*   BY ASCBCSCB, BUT INSTEAD, ASCBJBNI (JOBNAME) REALLY POINTS TO\n*   THE  CHKEY IN THE CSCB FOR THE JOB. WE'LL GET OUR GOODIES\n*   IN THE INDIRECT ROUTE........\n*\n         DROP  R10\n         USING CSCB,R4\n         S     R4,=F'8'           ADJUST FOR SNEAKINESS..\n         MVC   JOBNAME,CHKEY      MOVE IN JOBNAME\n         MVC   PROCNAME,CHSTEP    MOVE IN STEPNAME INVOK PROC\n         MVC   STEPNAME,CHPROCSN  MOVE IN STEPNAME OF PROC\n         DROP  R4\n         USING CSCB,R10           PUT BACK ADDRESSABILITY TO\n*                                  'REAL' CSCB..\n         LA    R3,1(R3)           BUMP COUNT OF JOBS/STC\n         BAL   R6,COMPTIME        GO GET STEP/CPU TIME\n*                                   AND MEMORY STATUS\n         LA    R0,BUFFERL\n         LA    R1,BUFFER\n         BAL   LINKREG,PUTMSG     SHOVEL IT OUT\n         MVI   BUFFER,C' '        AND CLEAR IT OUT\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n*\nNEXTPLS  BCT   R5,DOIT1           CHECK COUNT\n         B     CHKFIN             NO MORE..SPLIT\nDOIT1    LA    R9,4(0,R9)         INCR INTO ASVT\n         L     R8,0(0,R9)         LOAD ASCB ADDR\n         LTR   R8,R8              END OF ASCBS?\n         BZ    CHKFIN             YES->EXIT\n         TM    0(R9),X'80'        ASID ASSIGNED?\n         BO    NEXTPLS            NO-> TRY AGAIN.\n         B     LOOP2              YES->SEE IF WE LIKE IT\n*\nCHKFIN   CLC   BUFFER(8),=CL8' '  ANYTHING TO WRITE?\n         BE    CLEANUP            NO-> SPLIT\n         LA    R0,BUFFERL\n         LA    R1,BUFFER\n         BAL   LINKREG,PUTMSG     SHOVEL IT OUT\n         EJECT\nCLEANUP  TM    SWITCH,X'F0'       DID WE POKE ANYTHING\n         BZ    NOOUTPUT           NO..GRIPE AND SPLIT\n         B     $$EOJ              RETURN\n         SPACE 2\nNOOUTPUT LA    R0,GRIPEL\n         LA    R1,GRIPE\n         BAL   LINKREG,PUTMSG     SHOVEL IT OUT\n         B     $$EOJ\n*\n         EJECT\n*\n*  LOCAL  SUBROUTINE TO CALC JOB TIME AND CPU TIME.\n*       AND GEN SWAP REASON CODES/MEMORY STATUS\n*\n*  ENTER  WITH BAL R6,COMPTIME  (ALL REGS PRESERVED)\n*\n*\n*   COMPUTE ELAPSED TRANSACTION TIME (JOB TIME FOR BATCH)\n*\n*\nCOMPTIME STM   R2,R5,SAVEREGS    SAVE WORK REGS\n         SPACE 1\nELAPSED  L     R2,RMCTPTR        POINTER TO THE RMCT.\n         L     R2,X'7C'(,R2)     PICK UP TIME OF DAY FROM RMCT.  (SU)\n         L     R3,ASCBOUCB       GET ADDR OF OUCB FOR USER\n         S     R2,72(,R3)        SUBTRACT TRANSACTION START TIME.(SU)\n         SRDL  R2,32             MOVE INTO R5 FOR DIVIDE.\n         D     R2,=F'1024'       CONVERT TO SECONDS.\n         SR    R2,R2             IGNORE REMAINDER.\n         D     R2,=F'3600'       DIVIDE TO GET HOURS.\n         CVD   R3,WRKD           CONVERT HOURS -\n         UNPK  JOBHH,WRKD+6(2)     - TO PRINTABLE FORMAT.\n         OI    JOBHH+1,X'F0'     FIXUP SIGN BYTE.\n         MVI   JOBHH+2,C':'      SEPARATOR.\n         SRDL  R2,32             MOVE REMAINDER OVER FOR DIVIDE.\n         D     R2,=F'60'         GET MINUTES.\n         CVD   R3,WRKD           CONVERT MINUTES -\n         UNPK  JOBMM(2),WRKD+6(2)  - TO PRINTABLE FORMAT.\n         OI    JOBMM+1,X'F0'     FIXUP SIGN BYTE.\n         MVI   JOBMM+2,C':'      SEPARATOR.\n         CVD   R2,WRKD           REMAINDER IS SECONDS.\n         UNPK  JOBSS(2),WRKD+6(2)  CONVERT SEC TO PRINTABLE FORMAT.\n         OI    JOBSS+1,X'F0'     FIXUP SIGN.\n         SPACE 2\n*\n*   COMPUTE TOTAL CPU TIME USED IN THE CURRENT STEP.\n*\nCPUSTART LM    R2,R3,ASCBEJST    LOAD ASCBEJST (CPU TASK TIME).\n         SRDL  R2,12             CONVERT TO MICRO-SECONDS.\n         LM    R4,R5,ASCBSRBT    LOAD ASCBSRBT (CPU SRB TIME).\n         SRDL  R4,12             CONVERT TO MICROSECONDS.\n         AR    R3,R5             TOTAL CPU TIME (LOW ORDER).\n         BNO   CPULBL1           BRANCH IF NO OVERFLOW ON ADD.\n         A     R2,=F'1'          OTHERWISE, ADD 1 TO HIGH ORDER.\nCPULBL1  AR    R2,R4             TOTAL CPU TIME (HIGH ORDER).\n         D     R2,=F'100'        DIVIDE TO GET SECONDS.\n         LTR   R3,R3             CHK TO SEE IF ANYTHING IS THERE\n         BNM   CPULBL3           BRANCH IF RESULT MAKES SENSE.\n         LA    R3,0              OTHERWISE, SET THE VALUE TO ZERO.\nCPULBL3  CVD   R3,WRKD           *\n         MVC   CPUTIME,=X'20202021204B2020' *\n         ED    CPUTIME-1(9),WRKD+3 *\n         EJECT\n*\n***********************************************************************\n*\n*        SWAP  REASON CODE (R8=ASCB,R5=OUCB,R2-6=WORK)\n*\n***********************************************************************\n         L     R5,ASCBOUCB        GET ADDR OF OUCB\n         USING OUCB,R5\nSRCSTART SR    R2,R2              PREPARE FOR IC INSTRUCTION.     V2M0\n         IC    R2,OUCBSRC         LOAD SU7 SWAP REASON CODE.      V2M0\n         SLL   R2,2               MULTIPLY BY FOUR FOR OFFSET     V2M0\n         LA    R2,SRCTABLE(R2)    POINT TO CORRECT ENTRY.         V2M0\n         MVC   MEMSTAT2,0(R2)     MOVE IN SWAP REASON CODE.       V2M0\nSRCEND   DS    0H                 LABEL.\n         SPACE 2\n***********************************************************************\n*\n*        FIND  MEMORY POSITION (R8=ASCB,R5=OUCB,R2-6=WORK)\n*\n***********************************************************************\nQLCSTART MVC   MEMSTAT1,=CL2'IN'  DEFAULT POSITION IS SWAPPED-IN. V2M0\n         TM    OUCBSFL,OUCBNSW    SEE IF NON-SWAPPABLE MEMORY.    V2M0\n         BZ    QLCLBL1C           BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'NS'  MOVE IN NON-SWAPPABLE INDICATIONV2M0\n         B     QLCEND             FINISHED FOR THIS MEMORY.\nQLCLBL1C TM    OUCBSFL,OUCBPVL    SEE IF PRIVILEDGED STATUS.      V2M0\n         BZ    QLCLBL1            BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'PR'  MOVE IN PRIVILEDGED INDICATION. V2M0\n*                                 BUT CONTINUE IN CASE SWAPPED-OUT.\nQLCLBL1  TM    OUCBQFL,OUCBOFF    TEST FOR WAIT QUEUE.            V2M0\n         BZ    QLCLBL2            BRANCH IF NOT.\n         MVC   MEMSTAT1,=C'WT'    INDICATE WAIT STATUS.           V2M0\n         B     QLCEND             FINISHED FOR THIS MEMORY.       V2M0\nQLCLBL2  TM    OUCBQFL,OUCBOUT    TEST FOR OUT QUEUE.             V2M0\n         BZ    QLCLBL3            BRANCH IF NOT.\n         MVC   MEMSTAT1,=CL2'S '  INDICATE OUT STATUS.            V2M0\n         B     QLCEND             FINISHED FOR THIS MEMORY.\nQLCLBL3  TM    OUCBQFL,X'E0'      CHECK MISCELLANEOUS BITS.       V2M0\n         BZ    QLCEND             ASSUME MEMORY IS SWAPPED-IN.\n         MVC   MEMSTAT1,=CL2'<>'  INDICATE TRANSITIONING STATUS.\nQLCEND   DS    0H                 LABEL.\n         SPACE 2\n         LM    R2,R5,SAVEREGS    RESTORE REGISTERS\n         BR    R6                AND RETURN..\n         EJECT\n*.....................................................................*\n*        LOCAL SUBROUTINE FOR IO TO TSO USER                         *\n*.....................................................................*\n         SPACE\n*\n* PRINT MESSAGE TO TERMINAL POINTED TO BY R1\n*\n*    BAL  LINKREG,PUTMSG\n*\nPUTMSG   DS    0H\n         CLI JOBNAME,X'C1'\n         BLR LINKREG\n         CLI   JOBFTSO,C'O'\n         BNE   CH2\n         CLC   STEPNAME,=CL8'TSO'\n         BNER  LINKREG\nCH2      DS    0H\n         CLC   LIMIT,=CL8' '\n         BE    ADDIT\n         L     2,LIMITL\n         BCTR  2,0\n         CLC   LIMIT(*-*),JOBNAME\n         EX    2,*-6\n         BNER  LINKREG\nADDIT    TBADD TABLE,ORDER='ORDER',MF=E\n         BR    LINKREG\n         EJECT\n*.....................................................................*\n*        CONSTANTS                                                    *\n*.....................................................................*\n         SPACE 2\nSRCTABLE DC    C'    TPUTTGETLONGPGS<RSS<WAITRQSWDENQEXCHSWAP'\n*                0...1...2...3...4...5...6...7...8...9...A...\n         SPACE 2\n**********************************************************************\n* SWAP REASON CODES - TWO BYTES PER ENTRY:\n*\n*      CODE    DESCRIPTION\n*      ----    -------------------------------------------------------\n*       TPUT   TERMINAL OUTPUT WAIT SWAP-OUT.\n*       TGET   TERMINAL INPUT WAIT SWAP-OUT.\n*       LONG   LONG WAIT CAUSED SWAP-OUT.\n*       PGS<   AUXILIARY STORAGE (PAGING SPACE) SHORTAGE SWAP-OUT.\n*       RSS<   REAL STORAGE PAGEABLE POOL SHORTAGE SWAP-OUT.\n*       WAIT   MSO DETECTED WAIT SWAP-OUT.\n*       RQSW   REQSWAP SYSEVENT CAUSED SWAP-OUT.\n*       DENQ   CAP ENQ EXCHANGE SWAP-OUT.\n*       EXCH   CAP EXCHANGE SWAP BASED UPON RECOMMENDATION VALUES.\n*       SWAP   CAP UNILATERAL SWAP-OUT.\n**********************************************************************\n         SPACE 2\nDOTS     DC    C'..'\nJOBS     DC    C' JOBS '\nINITIAT  DC    C' INITIATORS'\nCSWITCH  DC    XL1'00'\nCWRKD    DC    D'0'\n         SPACE 2\n* TERMINAL OUTPUT MESSAGES\nMSGH     DC    C'                  SADSC DISPLAY ACTIVE'\nMSGL     EQU   *-MSGH\n         SPACE 2\n*               XXXXXXXX XXXXXXXX XXXXXXXX XX XXXX XX:XX:XX NNNNN.NN\nHEADING  DC    C'JOBNAME  STEPNAME PROCSTEP STATUS STEP-TIME STEP-CPU SX\n               EC'\nHEADINGL EQU   *-HEADING\n         SPACE 2\nGRIPE    DC    C'**NO INITIATORS OR JOBS RUNNING**'\nGRIPEL   EQU   *-GRIPE\n         SPACE 2\n         DS    0F\nMEMSIZE  DC    AL1(0),AL3(DSECTL)\n         EJECT\n*.....................................................................*\n*        LITERALS                                                     *\n*.....................................................................*\n         SPACE 2\n         LTORG\n         EJECT\n*.....................................................................*\n*        VARIABLES                                                    *\n*.....................................................................*\n         SPACE 2\nVARYABL  DSECT\nSAVEAREA DS    18F\nBINIT    DS    0D\nRMCTPTR  DS    F\nSWITCH   DS    X\nWRKD     DS    D\nSAVEREGS DS    4F\n         SPACE 2\n* TERMINAL OUTPUT MESSAGES\nMSG2     DS    0CL31\nDDOTS    DS    CL2\nNJOBS    DS    CL6\nDJOBS    DS    CL6\nNINIT    DS    CL6\nDINITIAT DS    CL11\nMSG2L    EQU   *-MSG2\n         SPACE 2\nBUFFER   DS    0CL52\nJOBNAME  DS    CL8                JOBNAME\n         DS    CL1                FILLER\nPROCNAME DS    CL8                STEPNAME  OR STEPNAME INVOKING PROC\n         DS    CL1\nSTEPNAME DS    CL8                STEPNAME FOR PROCS\n         DS    CL1\nMEMSTAT1 DS    CL2\n         DS    CL1\nMEMSTAT2 DS    CL4                MEMORY STATUS = SWAPPED NS\n         DS    CL1\nJOBHH    DS    CL2                FOR JOB  TIME HH:MM:SS\n         DS    CL1\nJOBMM    DS    CL2\n         DS    CL1\nJOBSS    DS    CL2\n         DS    CL1\nCPUTIME  DS    CL8                FOR CPUTIME NNNNN.NN SECONDS\nBUFFERL  EQU   *-BUFFER\nJOBFTSO  DS    C\nLIMIT    DS    CL8\nLIMITL   DS    F\nVCOPYLEN DS    F                   VCOPY LENGTH FIELD\nJOBPTSO  DS    C                   TSO USERS?\nTABLE    DS    CL8                 ISPF TABLE NAME\n         ISPF  PARMS               SPF WORKING STORAGE\n         SPACE 2\n         DS    0D\nEINIT    EQU   *-BINIT\nDSECTL   EQU   *-VARYABL\n*\n         EJECT\nCVT      DSECT\n         CVT   SYS=VMS,TSO=YES,DSECT=YES\n         EJECT\nCSCB     DSECT\n         IEECHAIN\n         EJECT\n         IHAASCB\n         EJECT\n         IHAASVT\n         EJECT\nBIT0     EQU   128\nBIT1     EQU   64\nBIT2     EQU   32\nBIT3     EQU   16\nBIT4     EQU   8\nBIT5     EQU   4\nBIT6     EQU   2\nBIT7     EQU   1\nOUCB     DSECT\nOUCBNAME DC    C'OUCB' -           BLOCK IDENTIFICATION\nOUCBFWD  DC    A(OUCB) -           SWAP CHAIN FORWARD POINTER\nOUCBBCK  DC    A(OUCB) -           SWAP CHAIN BCKWARD POINTER\nOUCBTMA  DC    F'0' -              TIME OF LAST ANALYSYS      @Z40BPCH\nOUCBQFL  DC    B'00100000' -       SWAPPABILITY TRANSITION FLAGS\nOUCBGOO  EQU   BIT0 -              TRANSITIONING OUT OF CORE\nOUCBGOI  EQU   BIT1 -              TRANSITIONING INTO CORE\nOUCBGOB  EQU   BIT2 -              TRANSITIONING BETWEEN STATES\nOUCBOFF  EQU   BIT4 -              REQUESTING ENTER WAIT STATE\nOUCBOUT  EQU   BIT5 -              REQUESTING ENTER OUT STATE\nOUCBSFL  DC    B'10010100' -       SWAPOUT CONTINUATION FLAGS\nOUCBNSW  EQU   BIT0 -              NON-SWAPPABLE STATUS\nOUCBCTI  EQU   BIT1 -              CTL INHIBITS QUIESCE\nOUCBBIB  EQU   BIT2 -              BRING IN FOR CANCEL         @Z40BPCH\nOUCBINV  EQU   BIT3 -              =1 IF OUCB IS INVALID       @Z40BPCH\nOUCBPVL  EQU   BIT5 -              PRIVILEGED PROGRAM RUNNING\nOUCBENQ  EQU   BIT6 -              ENQ RESIDENT STATUS\nOUCBSCN  EQU   BIT7 -              SWAP CHAIN TERMINATION MARK\nOUCBYFL  DC    B'00000000' -       USER TYPE FLAGS\nOUCBPSTE EQU   BIT0 -              POST ERROR @ZA07127\nOUCBSTT  EQU   BIT1 -              START CREATED USER\nOUCBLOG  EQU   BIT2 -              LOGON CREATED USER\nOUCBMNT  EQU   BIT3 -              MOUNT CREATED USER\nOUCBR01  EQU   BIT4 -              RESERVED                    @ZM43085\nOUCBAXS  EQU   BIT5 -              AUX SHORTAGE FORCED SWAP\nOUCBDTA  EQU   BIT6 -              DATA ACCUMULATION IMPACTED\nOUCBFXS  EQU   BIT7 -              FIXED STORAGE FORCED SWAP   @Z40BPCH\nOUCBAFL  DC    B'00000000' -       ALGORITHM STATUS FLAGS\nOUCBAPG  EQU   BIT1 -              APG ALGORITHM APPLICABLE\nOUCBRMA  EQU   BIT2 -              RMA ALGORITHM APPLICABLE\nOUCBCPL  EQU   BIT3 -              SIGNIFICANT CPU USER FLAG\nOUCBJSR  EQU   BIT4 -              JOBSELECT RECEIVED          @Z40BPCH\nOUCBR02  EQU   BIT5 -              RESERVED                   @ZM43085\nOUCBNWT  EQU   BIT6 -              MSO DETECTED NONSWAPPABLE WAIT\nOUCBASW  EQU   BIT7 -              AUTHORIZED FOR DONTSWAP\nOUCBTFL  DC    B'00000000' -       TRANSACTION STATUS FLAGS\nOUCBATR  EQU   BIT0 -              TRANSACTION IN EXISTENCE\nOUCBSTR  EQU   BIT1 -              TRANSACTION START PENDING\nOUCBNTR  EQU   BIT2 -              TRANSACTION STOP PENDING\nOUCBRTR  EQU   BIT3 -              TRANSACTION RESUME PENDING\nOUCBPCH  EQU   BIT4 -              PERF GRP PERIOD CHANGE PENDING\nOUCBMAR  EQU   BIT5 -              ACTIVITY RECORDING SUBTRACT FLAG\nOUCBINP  EQU   BIT6 -              INITIATOR ATTACH PENDING\nOUCBINC  EQU   BIT7 -              INITIATOR ATTACH CURRENT\nOUCBEFL  DC    B'00000000' -       EVENT STATUS FALGS\nOUCBLWT  EQU   BIT0 -              LONG WAIT STATUS\nOUCBTRM  EQU   BIT1 -              TERMINAL WAIT STATUS\nOUCBOWT  EQU   BIT2 -              OUTPUT TERMINAL WAIT\nOUCBCIM  EQU   BIT3 -              COMPOSITE INPUT MESSAGE\nOUCBNQF  EQU   BIT4 -              ENQHOLD EVENT PROCESSED\nOUCBQSS  EQU   BIT5 -              QSCEST  EVENT PROCESSED\nOUCBQSC  EQU   BIT6 -              QSCECMP EVENT PROCESSED\nOUCBMWT  EQU   BIT7 -              MSO DETECTED WAIT STATUS\nOUCBNQC  DC    HL1'0' -            NO. OF OUTSTANDING ENQHOLDS\nOUCBUFL  DC    B'00000000' -       USER TYPE FLAGS             @ZM43072\nOUCBJSFS EQU   BIT0 -              JOB SELECT DELAYED          @ZM43072\nOUCBJSAS EQU   BIT1 -              JOB SELECT DELAYED          @ZM43072\nOUCBNPG  DC    HL1'0' -            NEW PERFORMANCE GROUP NUMBER\nOUCBRPG  DC    HL1'0' -            RESET PERFORMANCE GROUP NUMBER\nOUCBNDP  DC    HL1'0' -            NEW ASCB DISPATCHING PRIORITY\nOUCBRDP  DC    HL1'0' -            REAL DISPATCHING PRIORITY   @Z40BPCH\nOUCBSPG  DC    HL1'0' -            SPECIFIED PERFORMANCE GROUP @Z40BPCH\nOUCBR30  DC    HL1'0' -            RESERVED                    @Z40BPEB\nOUCBR40  DC    HL1'0' -            RESERVED                    @Z40BPEB\nOUCBPGP  DC    HL1'12' -           CURRENT WPGP OFFSET IN WPGD\nOUCBWMG  DC    H'0' -              WPGD OFFSET IN WPGD TABLE\nOUCBDMO  DC    H'0' -              OFFSET INTO DOMAIN TABLE    @Z40BPCH\nOUCBDMN  DC    HL1'0'              DOMAIN NUMBER               @Z40BPCH\nOUCBSRC  DC    HL1'0'              SWAP OUT REASON CODE        @Z40BPCH\nOUCBSWC  DC    H'0' -              TRANSACTION SWAP COUNT\nOUCBASCB DC    A(0) -              ASCB ADDRESS\nOUCBIMCB DC    A(0) -              IMCB ADDRESS\nOUCBTMW  DC    F'0' -              WLM INTERVAL START TIME\nOUCBWMS  DC    F'0' -              INTERVAL SERVICE ACCUMULATOR\nOUCBCPU  DC    F'0' -              INTERVAL CPU SERVICE ACCUM  @Z40BPCH\nOUCBIOC  DC    F'0' -              INTERVAL I/O SERVICE ACCUM  @Z40BPCH\nOUCBMSO  DC    F'0' -              INTERVAL MSO SERVICE ACCUM  @Z40BPCH\nOUCBTMS  DC    F'0' -              TIME OF LAST SWAP ACTION\nOUCBTMO  DC    F'0' -              TRANSACTION START TIME\nOUCBPSO  DC    H'0' -              PAGES SWAPPED AT LAST SWAP-OUT\nOUCBWSS  DC    H'0' -              WORKING SET SIZE AT SWAP-IN\nOUCBACT  DC    A(0) -              ACTION QUEUE FORWARD POINTER\nOUCBCSW  DS    0F -                COMPARE AND SWAP FIELD NAME\nOUCBACN  DC    2B'00000000' -      DEFERRED ACTION FLAGS\nOUCBCFL  DC    B'00000000' -       MULTIPROCESS CONDITION FLAGS\nOUCBRDY  EQU   BIT0 -              USERRDY EVENT RECEIVED\nOUCBRSM  EQU   BIT1 -              RSM SERVICE OUTSTANDING\nOUCBCMRV DC    F'0' -              COMPOSITE RECOM VALUE       @Z40BPCH\nOUCBWMR  DC    F'0' -              WLM RECOMMENDATION VALUE    @Z40BPCH\nOUCBIRV  DC    H'0' -              IOM RECOMMENDATION VALUE    @Z40BPCH\nOUCBCRV  DC    H'0' -              CPM RECOMMENDATION VALUE    @Z40BPCH\nOUCBIOR  DC    H'0' -              I/O USAGE PROFILE\nOUCBR03  DC    H'0' -              RESERVED                    @ZM43085\nOUCBTMP  DC    F'0' -              PERF GRP PERIOD STARTING TIME\nOUCBR04  DC    H'0' -              RESERVED                    @ZM43085\nOUCBR05  DC    H'0' -              RESERVED                    @ZM43085\nOUCBPSS  DC    D'0' -              CPU PAGE SECONDS            @Z40BPCH\nOUCBPS1  EQU   OUCBPSS -           HIGH WORD PAGE SECONDS      @Z40BPCH\nOUCBPS2  EQU   OUCBPSS+4 -         LOW  WORD PAGE SECONDS      @Z40BPCH\nOUCBPST  DC    F'0' -              TIME OF LAST WORKING SET CHANGE\n*                                                              @Z40BPCH\nOUCBTCP  DC    F'0' -              TIME OF CPU USAGE EVALUATION\n*                                                              @Z40BPCH\nOUCBTIO  DC    F'0' -              TIME OF I/O USAGE EVALUATION\n*                                                              @Z40BPCH\nOUCBNDS  DC    H'1' -              NUM OUTSTANDING DONTSWAPS   @Z40BPEB\nOUCBR90  DC    H'0' -              RESERVED                    @Z40BPEB\nOUCBEND  DS    0D -                END OF OUCB\nOUCBLEN  EQU   OUCBEND-OUCB -      LENGTH OF OUCB\nR0       EQU   0                   REGISTER 0.\nR1       EQU   1                   REGISTER 1.\nR2       EQU   2                   REGISTER 2.\nR3       EQU   3                   REGISTER 3.\nR4       EQU   4                   REGISTER 4.\nR5       EQU   5                   REGISTER 5.\nR6       EQU   6                   REGISTER 6.\nR7       EQU   7                   REGISTER 7.\nR8       EQU   8                   REGISTER 8.\nR9       EQU   9                   REGISTER 9.\nR10      EQU   10                  REGISTER 10.\nR11      EQU   11                  REGISTER 11.\nR12      EQU   12                  REGISTER 12.\nR13      EQU   13                  REGISTER 13.\nR14      EQU   14                  REGISTER 14.\nR15      EQU   15                  REGISTER 15.\n         END   JOB1LIST\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KDDN": {"ttr": 5129, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8504                                               *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RNOTE &SUBRTN\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NEWSUB\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&SUBRTN').LOOPN1\n         AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* SUBSCRIPTS FOR THIS SUBROUTINE'S REGISTERS ARE &N*10-9 THRU &N*10\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA1  AIF   (&A GE 12).EXIT         12 IS HIGHEST SUPPORTED REGISTER\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&SINUSE(&N) OR &INUSE(&A))  NOTE WHETHER REG IN USE\n         AIF   ('&SUSING(&N)' EQ '&USING(&A)').LOOPA1  IF STILL USING,\n.*                                     LEAVE AS IS,\n&SUSING(&N) SETC ''                    ELSE SET TO NOT USING\n         AGO   .LOOPA1\n.*\n.* ASSIGN NUMBER TO NEWLY REFERENCED SUBROUTINE\n.*\n.NEWSUB  AIF   (&#SUB GE 20).ERR#SUB\n         AIF   (T'&SUBRTN EQ 'O').ERRSUB\n&N       SETA  &#SUB*10                LOWEST SUBCRIPT FOR NEXT SUB - 1\n&#SUB    SETA  &#SUB+1                 GET NEW SUBROUTINE NUMBER\n&SNAME(&#SUB) SETC '&SUBRTN'           NOTE SUBROUTINE NAME\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&A       SETA  2                       LOWEST SUPPORTED REG MINUS 1\n.LOOPA2  AIF   (&A GE 12).EXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&INUSE(&A))          NOTE REGISTERS IN USE\n&SUSING(&N) SETC '&USING(&A)'          AND DSECT NAMES\n         AGO   .LOOPA2\n.EXIT    ANOP\n         MEXIT\n.*\n.* ERROR MNOTES\n.*\n.ERRSUB  MNOTE 12,'SUBROUTINE NAME REQUIRED BUT MISSING'\n         MEXIT\n.ERRDOWN MNOTE 12,'ONLY DOWNWARD CALLS SUPPORTED'\n         MEXIT\n.ERR#SUB MNOTE 12,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    RSUB  &OPERAND\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &EQU(12),&USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n&NAME    DS    0H                      DEFINE SYMBOL FOR ENTRY POINT  $\n         AIF   ('&OPERAND' EQ '').OPX\n         AIF   ('&OPERAND' NE 'RECURSIVE').NORECUR\n         ST    R14,0(,RSTACK)          SAVE RETURN ADRESS             $\n         SH    RSTACK,=Y(4)            PUSH STACK DOWN                $\n.OPX     ANOP\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE.\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NOCALL\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&NAME').LOOPN1\n.SETUP   AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* ESTABLISH THE CALLERS' REGISTER ENVIRONMENT\n.*\n&SDOWN(&N) SETB 1\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT FOR THIS\n.*                                     SUBROUTINE MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REG - 1\n.LOOPA1  AIF   (&A GE 12).MEXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&INUSE(&A) SETB (&SINUSE(&N))          MARK CALLERS' REGISTERS IN USE\n&EQU(&A) SETC  ''                      NULL SO RF MACRO CAN'T FREE REG\n         AIF   ('&USING(&A)' EQ '').DROPX\n         DROP  &A                      DROP REG USED BY PRECEDING CODE\n.DROPX   ANOP\n&USING(&A) SETC '&SUSING(&N)'          SET TO CALLERS' DSECT NAME\n         AIF   ('&USING(&A)' EQ '').LOOPA1\n         USING &USING(&A),&A           RE-ESTABLISH CALLERS' USING    $\n         AGO   .LOOPA1\n.MEXIT   MEXIT\n.*\n.* ASSIGN A NEW NUMBER TO AN UNCALLED SUBROUTINE\n.*\n.NOCALL  AIF   ('&NAME' EQ '').ERRNAME\n         AIF   (&#SUB GE 20).ERR#SUB\n&#SUB    SETA  &#SUB+1                 INCREASE # OF REFERENCED SUBRTNS\n&N       SETA  &#SUB\n&SNAME(&N) SETC '&NAME'                SAVE NAME IN CASE REFERRED TO\n         AGO   .SETUP\n.*\n.* ERROR MSGS\n.*\n.NORECUR MNOTE 4,'&OPERAND IS INVALID OPERAND. IGNORED.'          MA01\n         AGO   .OPX                                               MA01\n.ERRDOWN MNOTE 8,'SUBROUTINE NAME &NAME ALREADY USED'\n         MEXIT\n.ERRNAME MNOTE 8,'SPECIFY SUBROUTINE NAME AS LABEL'\n         MEXIT\n.ERR#SUB MNOTE 8,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n         MACRO\n&NAME    RCALL &SUBRTN\n         RNOTE &SUBRTN\n&NAME    BAL   14,&SUBRTN              LINK TO SUBROUTINE             $\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RL\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         PUSH  PRINT                                                  $\n         PRINT ON,GEN                                                 $\n&A       SETA  2                       1ST SUPPORTED REGISTER - 1\n.LOOP    AIF   (&A GE 12).LISTX\n&A       SETA  &A+1\n         AIF   (NOT &INUSE(&A)).LOOP\n&C       SETC  '&EQU(&A)        '(1,8).' EQU   &A                      *\n                                                       '(1,60)\n         MNOTE *,'&C.$'\n         AIF   ('&USING(&A)' EQ '').LOOP\n&C       SETC  '         USING &USING(&A),&A                           *\n                                                       '(1,68)\n         MNOTE *,'&C.$'\n         AGO   .LOOP\n.LISTX   POP   PRINT                                                  $\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\nKDDN     TITLE 'TSO COMMAND KDDN (DISPL/TRAP DDNAMES FOR DSNAME)'\n*  COMMAND SYNTAX:  KDDN (DSNAME-LIST) SAVE                           *\n*  COMMAND ACTION:                                                    *\n*     1. PARSE THE DSNAME-LIST (LOOPING FOR EACH DSNAME).             *\n*     2. EXTRACT DDNAMES INTO A TABLE (KDDNSUB).                      *\n*     3. IF 'SAVE' OMITTED, TPUT THE TABLE.                           *\n*     4. IF 'SAVE':                                                   *\n*        A.  ALLOCATE A 'SAVE'-DATASET                                *\n*        B.  WRITE DDNAME-TABLE TO DATASET.                           *\n*        C.  CLOSE DATASET.                                           *\n*  TECHNICAL NOTES:                                                   *\n*     1. PROGRAM IS NOT REENTRANT.                                    *\n*     2. IKJDAIR SERVICE USED FOR ALLOCATE/FREE OF 'SAVE'-DATASET.    *\n*        'SAVE'-DATASET ALLOCATED BY DYNAMICALLY-DETERMINED DDNAME.   *\n*     3. 'SAVE' FUNCTION IS INSENSITIVE TO DSNAMES IN COMMAND INPUT   *\n*        WHICH ARE NOT ALLOCATED.                                     *\n*     4. RETURN-CODES:                                                *\n*              0 = SUCCESSFUL DISPLAY FUNCTION                        *\n*             20 = (UNANTICIPATED) COMMAND FAILURE                    *\n*            100 = NO DDNAMES FOUND DURING 'SAVE' FUNCTION            *\n*        (100+N) = SUCCESSFUL 'SAVE' FUNCTION;                        *\n*                  'N' = NUMERIC QUALIFIER OF LAST 'SAVE'-DATASET DDN *\n*                                                                     *\nKDDN     CSECT\n         RG    (RBASE,,12)\n         RG    (RBASE2,,11)\n         RG    (RCPPL,CPPL)\n         CNAENTER PARM=RCPPL,ENTRY=NO,RENT=NO\n* RESET PROGRAM BASE FOR READABILITY\n         L     RBASE,=V(KDDN)\n         DROP  R13\n         USING KDDN,RBASE\n         USING KDDN+4096,RBASE2\n         LA    RBASE2,4095(RBASE)\n         LA    RBASE2,1(RBASE2)\n         B     TOP\n         EJECT\nTOP      DS    0H\n         XC    RC4,RC4        INITIALIZE RETURN-CODE\n         RG    (RPPL,PPL)\n         LA    RPPL,PPLAREA\n         RG    (RPARSED,IKJPARMD)\n         L     RPARSED,=V(PARSECT)\n*\n**  PARSE THE OPERAND LIST\n*\n         SPACE\n*\n**  ESTABLISH VALUES IN THE PARSE PARAMETER LIST\n*\n         MVC   PPLCBUF,CPPLCBUF\n         MVC   PPLUPT,CPPLUPT\n         ST    RPARSED,PPLPCL\n         MVC   PPLECT,CPPLECT\n         XC    CPECB,CPECB\n         LA    R0,CPECB\n         ST    R0,PPLECB\n         XC    CPANS,CPANS\n         LA    R0,CPANS\n         ST    R0,PPLANS\n         LA    R0,WORK\n         ST    R0,PPLUWA\n*\n**  INVOKE PARSE\n*\n         CALLTSSR EP=IKJPARS,MF=(E,(RPPL))\n         SPACE\n         LTR   15,15                         TEST PARSE RETURN-CODE\n         BZ    PARSEOK                       PARSE OK\n* TPUT MESSAGE AND SET RETURN CODE ON PARSE FAILURE *\n         LA    R1,=C'COMMAND-PARSE FAILURE'\n         LA    R0,21\n         SVC   93\n         MVI   RC1,20\n         B     FASTEXIT\n         RF    RPPL\n         EJECT\n*\n**  AFTER SUCCESSFUL PARSE, PROCESS EACH DDNAME PARAMETER\n*\nPARSEOK  DS    0H\n         L     RPARSED,CPANS\n         RG    RDDN                          DDNAME-ALLOCATED ARRAY\n         LA    RDDN,DDNAME1                  SET DDNAME BASE\n         LA    R1,50                         CLEAR DDNAME ARRAY\nDDNCLR   MVC   0(8,RDDN),=CL8' '\n         LA    RDDN,8(RDDN)\n         BCT   R1,DDNCLR\n         LA    RDDN,DDNAME1                  RESET DDNAME BASE\n*\n**  FIND A DSNAME FROM INPUT LIST\n*\n         RG    (RPDE,PDE)\n         LA    RPDE,IDSN\n         SPACE\nDSNLOOP  DS    0H                            LOOPS THRU \"LOOPRET\"\n         LTR   RPDE,RPDE\n         BZ    EXIT                          NO MORE DSNAMES\n         MVC   REALDS,=CL44' '               CLEAR DSN-HOLD\n         L     R15,PDEADDR                   ADDR OF DSNAME\n         LH    R2,PDELEN                     LENGTH OF DSNAME\n         MVC   TO,=A(REALDS)\n         ST    R15,FROM\n         ST    R2,FROMLTH\n         ST    R2,TOLTH\n         ST    R2,REALLTH                    DSN LTH FOR TPUT\n         RCALL MVCL\n*\n*\nGOTDS    DS    0H\n         MVC   ARRAYCT,=AL2(ARRAY#)          SET ARRAY COUNT\n*        LINK  EP=KDDNSUB,PARAM=(REALDS,ARRAYCT,ARRAY1)\n         CALL  KDDNSUB,(REALDS,ARRAYCT,ARRAY1),VL\n*\n*** DDNAMES NOW IN TABLE ... PREPARE FOR 'SAVE' OR DISPLAY RESPONSE\n*\nDONEDSN  DS    0H\n         RG    RARRAY\n         RG    RCOUNT\n         LA    RARRAY,ARRAY1                 SET RESULTS BASE\n         LH    RCOUNT,ARRAYCT                SET ARRAY COUNT\n         CLC   ISAVE(2),=H'0'                'SAVE' KEYWORD?\n         BNE   DOGRAB                        BR IF YES TO PROCESS\n*\n***      STD   TPUT   RESPONSE\n*\n         XC    MESSAGE,MESSAGE\n         MVC   MESSAGE(44),REALDS\n         LA    R2,MESSAGE\n         A     R2,REALLTH\n         LA    R1,MESSAGE\n         L     R0,=A(L'MESSAGE)\n         LTR   RCOUNT,RCOUNT\n         BZ    TNODSN                        BR IF NO DDNAMES FOUND\n         MVC   1((L'MESSAGEF),R2),MESSAGEF\n         SVC   93\nTOUTDDN  DS    0H\n         LH    R0,8(RARRAY)                  PICK UP CONCAT COUNT\n         LTR   R0,R0\n         BNZ   TOUTDDN2                      BR FOR CONCAT DISPLAY\n         LA    R0,8\n         LR    R1,RARRAY\n         B     TOUTDDN3\nTOUTDDN2 DS    0H\n         MVC   RECDDN,0(RARRAY)\n         CVD   R0,PACKWORK\n         UNPK  RECONCAT,PACKWORK+6(2)\n         OI    RECONCAT+2,X'F0'\n         MVC   RECMSG,MESSAGEC\n         L     R0,=A(RECOUT)\n         LA    R1,RECORD\nTOUTDDN3 DS    0H\n         SVC   93                            TPUT DDNAME\n         LA    RARRAY,10(RARRAY)\n         BCT   RCOUNT,TOUTDDN                LOOP TO TPUT NEXT DDNAME\n         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN\nTNODSN   DS    0H                            DSNAME NOT FOUND MESSAGE\n         MVC   1((L'MESSAGEN),R2),MESSAGEN\n         SVC   93\n         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN\nLASTLINE DS    0H\n         LA    R1,=CL8' '                    WRITE BLANK LINE FOR\n         LA    R0,8                             READABILITY ON SCREEN\n         SVC   93\n         B     LOOPRET\n         EJECT\n*\n*** END OF LOOP FOR DSNAME-LIST PROCESSING\n*\nLOOPRET  DS    0H\n         ICM   RPDE,B'0111',PDECHAIN+1       SET TO NEXT PDE ENTRY\n         B     DSNLOOP\n         EJECT\n*\n*** PROCESSING FOR 'SAVE' KEYWORD\n*\nDOGRAB   DS    0H\n         CLI   ARRAY1,C' '                   ANY ALLOCATIONS?\n         BE    LOOPRET                       BR IF NO TO AVOID 'SAVE'\n*                                                PROCESSING\nDOGRAB1  RCALL SETDD\n         RCALL DYNALLOC\n         LTR   R15,R15                       TEST DYNALLOC RC\n         BZ    DOGRAB2                       BR IF OK\n         C     R15,=F'20'                    TEST FOR DUPLICATE DD\n         BNE   DYNABORT                      BR IF NO TO CLEANUP\n         CLC   GRABDDNN,=C'99'               TOO MANY DYNALLOCS?\n         BE    DYNABORT                      BR IF TRUE\n         B     DOGRAB1                       BR TO TRY ANOTHER DD\nDOGRAB2  DS    0H\n         MVC   0(8,RDDN),GRABDD              SAVE ALLOCATED DDNAME\n         LA    RDDN,8(RDDN)                  SET ARRAY BASE TO NEXT ENT\n*\n***      OUTPUT DATA FROM ARRAY\n*\n         USING IHADCB,R1\n         LA    R1,DYNAMDCB\n         MVC   DCBDDNAM,GRABDD\n         OPEN  (DYNAMDCB,(OUTPUT))\n         DROP  R1\n         PUT   DYNAMDCB,REALDS\nDOGRAB3  DS    0H\n         MVC   RECDDN,0(RARRAY)\n         MVC   RECONCAT,=CL3' '\n         LH    R0,8(RARRAY)\n         LTR   R0,R0\n         BZ    SKIPCON\n         CVD   R0,PACKWORK\n         UNPK  RECONCAT,PACKWORK+6(2)\n         OI    RECONCAT+2,X'F0'\nSKIPCON  DS    0H\n         PUT   DYNAMDCB,RECORD\n         LA    RARRAY,10(RARRAY)\n         BCT   RCOUNT,DOGRAB3\n         CLOSE (DYNAMDCB)\n*\n*** SET RETURN CODE\n*\n         CVB   R0,GRABDDNR\n         A     R0,=F'100'\n         ST    R0,RC4\n         B     LOOPRET                       LOOP TO NEXT DDNAME\n         EJECT\n*\n***      FREE  ALL DYNAMICALLY ALLOCATED DATASETS ON DYNALLOC ERROR\n*\nDYNABORT DS    0H\n         LR    RARRAY,RDDN                   SAVE CURRENT RDDN\n         LA    RDDN,DDNAME1                  RESET TO 1ST DDN\nDYNAB1   CR    RDDN,RARRAY                   ANY ALLOC SUCCESSFUL?\n         BE    BADEND                        BR IF NO\n         MVC   GRABDD,0(RDDN)\n         RCALL DYNFREE\n         LA    RDDN,8(RDDN)                  BUMP TO NEXT DDN\n         B     DYNAB1\nBADEND   DS    0H\n         LA    R1,=C'DYNAMIC-ALLOCATE FAILURE'\n         LA    R0,25\n         SVC   93\n         MVI   RC1,20\n         B     EXIT\n         RF    RARRAY\n         EJECT\n         RF    RDDN\n         EJECT\n*\n*** PROGRAM EXIT ANY TIME AFTER PARSE SERVICE INVOKED\n*\nEXIT     DS    0H\n         CLC   ISAVE,=H'0'                   SAVE KWD?\n         BE    EXIT2                         BR IF NO\n         CLC   RC4,=F'0'                     CHECK RETURN-CODE\n         BNE   EXIT2                         BR IF SOMETHING SAVED\n         MVI   RC1,100                       SET 'NOT SAVED' RC\nEXIT2    DS    0H\n         RF    RPDE\n         IKJRLSA CPANS\n*\n*** PROGRAM EXIT ANY TIME BEFORE PARSE SERVICE INVOKED\n*\nFASTEXIT CNAEXIT RC4\n         RF    RPARSED\n         TITLE '- SUBROUTINES'\nDYNALLOC RSUB  ,                             DYNAMIC-ALLOCATE\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDAPL,DAPL)\n         LA    RDAPL,DAPLAREA\n         RG    (RDAP08,DAPB08)\n         LA    RDAP08,DA08AREA\n*        BUILD ALLOC VALUES\n         MVC   DA08CD,=X'0008'\n         XC    DA08PDSN,DA08PDSN\n         MVC   DA08DDN,GRABDD\n         MVI   DA08DSP1,DA08NEW\n         MVI   DA08DPS2,DA08DEL\n         MVI   DA08DPS3,DA08DELE\n         MVI   DA08CTL,DA08PERM\n         OI    DA08CTL,DA08TRKS\n         MVC   DA08UNIT,=C'SYSDA   '\n         MVC   DA08SER,=CL8' '\n         XC    DA08BLK,DA08BLK\n         MVC   DA08PQTY,=F'1'\n         XC    DA08SQTY,DA08SQTY\n         XC    DA08DQTY,DA08DQTY\n         XC    DA08CTL+1(4),DA08CTL+1\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVC   DA08ALN,=CL8' '\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP08,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDAPL))  ALLOCATE\n         RF    RDAP08,RDAPL\n*\n         B     DYNEXIT\n         SPACE 3\nDYNFREE  RSUB  ,                             DYNAMIC-FREE\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDFPL,DAPL)\n         LA    RDFPL,DAPLAREA\n         RG    (RDAP18,DAPB18)\n         LA    RDAP18,DA18AREA\n*        BUILD FREE VALUES\n         MVC   DA18CD,=X'0018'\n         MVC   DA18DDN,GRABDD\n         MVC   DA18MNM,=CL8' '\n         MVC   DA18SCLS,=CL2' '\n         MVI   DA18CTL,DA18PERM\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP18,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDFPL))  FREE PREVIOUS ALLOCATE\n         RF    RDAP18,RDFPL\n*\n         B     DYNEXIT\n         EJECT\n*        SET GRAB-DATASET DDNAME AS FOLLOWS (FOR UNIQUENESS):\n*              \"KDDNXX..\"  WHERE \"..\" IS NUMBERED 1-UP\n*                    FROM \"1 \" TO \"99\".\n*\nSETDD    RSUB\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         CLI   GRABDDNN+1,C' '\n         BNE   SETDD2\n         CLI   GRABDDNN,C'9'\n         BNE   SETDD1\n         MVC   GRABDDNN,=C'09'\n         B     SETDD2\nSETDD1   PACK  GRABDDNP,GRABDDNN(1)\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN(1),GRABDDNP\n         OI    GRABDDNN,X'F0'                CLEAR THE SIGN\n         B     SETDD3\nSETDD2   DS    0H\n         PACK  GRABDDNP,GRABDDNN\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN,GRABDDNP\n         OI    GRABDDNN+1,X'F0'              CLEAR THE SIGN\nSETDD3   DS    0H\n         B     DYNEXIT\n         EJECT\nMVCL     RSUB\n         ST    R14,DYNRET\n         XR    R15,R15                       CLEAR RETURN-CODE\n         STM   R2,R6,MVCLH\n         LM    R2,R6,TO\n         LTR   R6,R6                         PAD REQUESTED?\n         BZ    *+8                           BR IF NO\n         ICM   R5,8,0(R6)                    INSERT PAD CHARACTER\n         MVCL  R2,R4                         MOVE\n         BC    7,*+8                         BR IF NOT CODE=3\n         LA    R15,4\n         LR    R1,R2                         RETURN END ADDR (TO)\n         LM    R2,R6,MVCLH\n         L     R14,DYNRET\n         BR    R14\nMVCLH    DS    5A\nTO       DS    A\nTOLTH    DS    F\nFROM     DS    A\nFROMLTH  DS    F\nPAD      DS    A\n         TITLE '- COMMON SUBROUTINE EXIT'\nDYNEXIT  DS    0H\n         L     R14,DYNRET\n         LM    R0,R12,DYNREG\n         BR    R14\nDYNRET   DS    F                             SUBROUTINE RETURN ADDRESS\nDYNREG   DS    13F                           SUBROUTINE RETURN REGS\n         DROP  ,\n         TITLE '- CONSTANTS'\n         RL\n*\nMESSAGE  DS    CL(44+L'MESSAGEF)\nMESSAGEF DC    C'ALLOCATED TO:'\nMESSAGEN DC    C'NOT ALLOCATED'\nMESSAGEC DC    C' IN CONCATENATION'\n*\nPERIOD   DC    C'.'\nTRTBL    DC    256AL1(*-TRTBL)\n         ORG\n         LTORG *\n         TITLE '- WORKING STORAGE'\nRC4      DS    F\nRC1      EQU   RC4+3,1\nCPECB    DS    F\nCPANS    DS    F\nCPUWA    DS    F\nPREFIX   DS    CL10\nPREFLTH  DS    F\nREALLTH  DS    F\n*\nPPLAREA  DS    0A,XL(PPLLEN)\nCPPLAREA DS    0A,XL(CPPLLEN)\n*\nDAPLAREA DS    0A,XL(DAPLLEN)\nDA08AREA DS    0A,XL(DAP08LEN)\nDA18AREA DS    0A,XL(DAP18LEN)\n*\nWORK     DS    CL30                          PPLUWA (NOT USED)\n*\n         ORG   WORK                          REUSE WORK FIELD\nDSNCT    DS    F                             COUNT OF ARRAY1 ARRAY\nRESETCT  DS    F                             COUNT OF DDNAME1 ARRAY\nRESETH   DS    F                             PROCESS COUNT OF DDNAME1\nDTBL     DS    2F                            DEVTYPE WORK AREA\nHOLDPROF DS    X                             TSO-PROFILE HOLD AREA\n         ORG\n*\n         DS    0D\nREALDS   DC    CL44' '                       TRUE DSNAME\n         DS    0D\nGRABDD   DS    0CL8                          DYNAMIC-ALLOCATE DDNAME\n         DC    CL6'KDDNXX'                   * FIXED PORTION\nGRABDDNN DC    C'0 '                         * VARIABLE DIGITS\n*\nGRABDDNR DS    0PL8                          WORK FIELD FOR SAVE-RC\n         DC    XL6'000000000000'\nGRABDDNP DS    PL2                           WORK FIELD FOR GRABDDNN\n*\nDDNAME1  DS    CL8                           ARRAY FOR 50 DDNAMES\n         DS    49CL8                         * HOLDS KDDNXX.. FOR SAVE\n*\nARRAY#   EQU   50\nARRAYCT DS     H\n         DS    0D                            ALIGNMENT FOR COBOL CALL\nARRAY1   DS    (ARRAY#)CL10                  ARRAY FOR DDNAMES\n*                                            * HOLDS DDNLIST FOR RESET\n         DS    0D\nPACKWORK DS    PL8\n*\nRECORD   DC    CL44' '                       OUTPUT 'SAVE' RECORD\n         ORG   RECORD\nRECDDN   DS    CL8\n         DS    CL2\nRECONCAT DS    CL3\nRECMSG   DS    CL(L'MESSAGEC)\nRECOUT   EQU   *-RECDDN\n         ORG\n*\n         PRINT NOGEN\n*    DCB FOR SAVE AND RESET PROCESSING (BOTH)\nDYNAMDCB DCB   DDNAME=X,DSORG=PS,MACRF=(PM),RECFM=FB,LRECL=44,         X\n               BLKSIZE=440\n         PRINT GEN\n         TITLE '- PARSE MACROS'\nPARSECT  IKJPARM\nIDSN     IKJPOSIT DSNAME,USID,LIST,                                    *\n               PROMPT='DSNAME LIST',                                   *\n               HELP='LIST OF DSNAMES FOR DDNAME DISPLAY'\nISAVE    IKJKEYWD\n         IKJNAME 'SAVE',ALIAS=('SA')\n         IKJENDP\n         TITLE '- DSECTS'\nPDE      DSECT\nPDEADDR  DS    A              ADDRESS OF DSNAME\nPDELEN   DS    H              LENGTH OF  DSNAME\nPDEFLAG  DS    X              FLAGS\n         DS    X              (ALIGNMENT)\n         ORG   *+(2*(*-PDEADDR))             BYPASS MEM/PW PDE FLDS\nPDECHAIN DS    A              ADDRESS OF NEXT PDE IN LIST\n         SPACE\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         SPACE\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         SPACE\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         SPACE\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         SPACE\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IHADCB DEVD=DA,DSORG=PS\n         EJECT\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KDSN": {"ttr": 5897, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8504                                               *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RNOTE &SUBRTN\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NEWSUB\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&SUBRTN').LOOPN1\n         AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* SUBSCRIPTS FOR THIS SUBROUTINE'S REGISTERS ARE &N*10-9 THRU &N*10\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA1  AIF   (&A GE 12).EXIT         12 IS HIGHEST SUPPORTED REGISTER\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&SINUSE(&N) OR &INUSE(&A))  NOTE WHETHER REG IN USE\n         AIF   ('&SUSING(&N)' EQ '&USING(&A)').LOOPA1  IF STILL USING,\n.*                                     LEAVE AS IS,\n&SUSING(&N) SETC ''                    ELSE SET TO NOT USING\n         AGO   .LOOPA1\n.*\n.* ASSIGN NUMBER TO NEWLY REFERENCED SUBROUTINE\n.*\n.NEWSUB  AIF   (&#SUB GE 20).ERR#SUB\n         AIF   (T'&SUBRTN EQ 'O').ERRSUB\n&N       SETA  &#SUB*10                LOWEST SUBCRIPT FOR NEXT SUB - 1\n&#SUB    SETA  &#SUB+1                 GET NEW SUBROUTINE NUMBER\n&SNAME(&#SUB) SETC '&SUBRTN'           NOTE SUBROUTINE NAME\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&A       SETA  2                       LOWEST SUPPORTED REG MINUS 1\n.LOOPA2  AIF   (&A GE 12).EXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&INUSE(&A))          NOTE REGISTERS IN USE\n&SUSING(&N) SETC '&USING(&A)'          AND DSECT NAMES\n         AGO   .LOOPA2\n.EXIT    ANOP\n         MEXIT\n.*\n.* ERROR MNOTES\n.*\n.ERRSUB  MNOTE 12,'SUBROUTINE NAME REQUIRED BUT MISSING'\n         MEXIT\n.ERRDOWN MNOTE 12,'ONLY DOWNWARD CALLS SUPPORTED'\n         MEXIT\n.ERR#SUB MNOTE 12,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    RSUB  &OPERAND\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &EQU(12),&USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n&NAME    DS    0H                      DEFINE SYMBOL FOR ENTRY POINT  $\n         AIF   ('&OPERAND' EQ '').OPX\n         AIF   ('&OPERAND' NE 'RECURSIVE').NORECUR\n         ST    R14,0(,RSTACK)          SAVE RETURN ADRESS             $\n         SH    RSTACK,=Y(4)            PUSH STACK DOWN                $\n.OPX     ANOP\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE.\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NOCALL\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&NAME').LOOPN1\n.SETUP   AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* ESTABLISH THE CALLERS' REGISTER ENVIRONMENT\n.*\n&SDOWN(&N) SETB 1\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT FOR THIS\n.*                                     SUBROUTINE MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REG - 1\n.LOOPA1  AIF   (&A GE 12).MEXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&INUSE(&A) SETB (&SINUSE(&N))          MARK CALLERS' REGISTERS IN USE\n&EQU(&A) SETC  ''                      NULL SO RF MACRO CAN'T FREE REG\n         AIF   ('&USING(&A)' EQ '').DROPX\n         DROP  &A                      DROP REG USED BY PRECEDING CODE\n.DROPX   ANOP\n&USING(&A) SETC '&SUSING(&N)'          SET TO CALLERS' DSECT NAME\n         AIF   ('&USING(&A)' EQ '').LOOPA1\n         USING &USING(&A),&A           RE-ESTABLISH CALLERS' USING    $\n         AGO   .LOOPA1\n.MEXIT   MEXIT\n.*\n.* ASSIGN A NEW NUMBER TO AN UNCALLED SUBROUTINE\n.*\n.NOCALL  AIF   ('&NAME' EQ '').ERRNAME\n         AIF   (&#SUB GE 20).ERR#SUB\n&#SUB    SETA  &#SUB+1                 INCREASE # OF REFERENCED SUBRTNS\n&N       SETA  &#SUB\n&SNAME(&N) SETC '&NAME'                SAVE NAME IN CASE REFERRED TO\n         AGO   .SETUP\n.*\n.* ERROR MSGS\n.*\n.NORECUR MNOTE 4,'&OPERAND IS INVALID OPERAND. IGNORED.'          MA01\n         AGO   .OPX                                               MA01\n.ERRDOWN MNOTE 8,'SUBROUTINE NAME &NAME ALREADY USED'\n         MEXIT\n.ERRNAME MNOTE 8,'SPECIFY SUBROUTINE NAME AS LABEL'\n         MEXIT\n.ERR#SUB MNOTE 8,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n         MACRO\n&NAME    RCALL &SUBRTN\n         RNOTE &SUBRTN\n&NAME    BAL   14,&SUBRTN              LINK TO SUBROUTINE             $\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RL\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         PUSH  PRINT                                                  $\n         PRINT ON,GEN                                                 $\n&A       SETA  2                       1ST SUPPORTED REGISTER - 1\n.LOOP    AIF   (&A GE 12).LISTX\n&A       SETA  &A+1\n         AIF   (NOT &INUSE(&A)).LOOP\n&C       SETC  '&EQU(&A)        '(1,8).' EQU   &A                      *\n                                                       '(1,60)\n         MNOTE *,'&C.$'\n         AIF   ('&USING(&A)' EQ '').LOOP\n&C       SETC  '         USING &USING(&A),&A                           *\n                                                       '(1,68)\n         MNOTE *,'&C.$'\n         AGO   .LOOP\n.LISTX   POP   PRINT                                                  $\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\nKDSN     TITLE 'TSO COMMAND KDSN (DISPL/TRAP/RESET DSNAMES FOR DDNAME)'\n*  COMMAND SYNTAX:  KDSN (DDNAME-LIST) SAVE RESET                     *\n*  COMMAND ACTION:                                                    *\n*     1. PARSE THE DDNAME-LIST (LOOPING FOR EACH DDNAME).             *\n*     2. EXTRACT DSNAMES INTO A TABLE (KDSNSUB).                      *\n*     3. IF 'SAVE' AND 'RESET' OMITTED, TPUT THE TABLE.               *\n*     4. IF 'SAVE':                                                   *\n*        A.  ALLOCATE A 'SAVE'-DATASET                                *\n*        B.  REFORMAT DSNAMES INTO TSO SYNTAX (VIA PGM=KDSNNAM)       *\n*        C.  WRITE AND CLOSE DATASET.                                 *\n*     5. IF 'RESET':                                                  *\n*        A.  TABLE ALL DDNAMES IN DDNAME-LIST.                        *\n*        B.  MATCH DATASETS CREATED BY 'SAVE' AGAINST LIST, AND       *\n*            ALLOCATE \"REUSE\" IF FOUND.                               *\n*        C.  FREE EACH 'SAVE' DATASET WHEN PROCESSED.                 *\n*  TECHNICAL NOTES:                                                   *\n*     1. PROGRAM IS NOT REENTRANT.                                    *\n*     2. IKJDAIR SERVICE USED FOR ALLOCATE/FREE OF 'SAVE'-DATASET.    *\n*        'SAVE'-DATASET ALLOCATED BY DYNAMICALLY-DETERMINED DDNAME.   *\n*     3. TSO 'ALLOC' COMMAND USED TO ACCOMPLISH 'RESET' PROCESSING.   *\n*     4. BOTH 'SAVE' AND 'RESET' FUNCTIONS ARE INSENSITIVE TO         *\n*        DDNAMES IN COMMAND INPUT WHICH ARE NOT ALLOCATED.            *\n*     5. 'RESET' FUNCTION IS FAIL-SOFT FOR REALLOCATING NON-EXISTENT  *\n*        DATASETS (USER TSO-PROFILE TEMPORARILY SET TO 'NOPROMPT'.    *\n*     6. RETURN-CODES:                                                *\n*              0 = SUCCESSFUL DISPLAY/'RESET' FUNCTION                *\n*             20 = (UNANTICIPATED) COMMAND FAILURE                    *\n*            100 = NO DATASETS FOUND DURING 'SAVE' FUNCTION           *\n*        (100+N) = SUCCESSFUL 'SAVE' FUNCTION;                        *\n*                  'N' = NUMERIC QUALIFIER OF LAST 'SAVE'-DATASET DDN *\n*                                                                     *\nKDSN     CSECT\n         RG    (RBASE,,12)\n         RG    (RBASE2,,11)\n         RG    (RCPPL,CPPL)\n         CNAENTER PARM=RCPPL,ENTRY=NO,RENT=NO\n* RESET PROGRAM BASE FOR READABILITY\n         L     RBASE,=V(KDSN)\n         DROP  R13\n         USING KDSN,RBASE\n         USING KDSN+4096,RBASE2\n         LA    RBASE2,4095(RBASE)\n         LA    RBASE2,1(RBASE2)\n         B     TOP\n         EJECT\nTOP      DS    0H\n*\n**  PARSE THE OPERAND LIST\n*\n         XC    RC4,RC4        INITIALIZE RETURN-CODE\n         RG    (RPPL,PPL)\n         LA    RPPL,PPLAREA\n         RG    (RPARSED,IKJPARMD)\n         L     RPARSED,=V(PARSECT)\n         SPACE\n*\n**  ESTABLISH VALUES IN THE PARSE PARAMETER LIST\n*\n         MVC   PPLCBUF,CPPLCBUF\n         MVC   PPLUPT,CPPLUPT\n         ST    RPARSED,PPLPCL\n         MVC   PPLECT,CPPLECT\n         XC    CPECB,CPECB\n         LA    R0,CPECB\n         ST    R0,PPLECB\n         XC    CPANS,CPANS\n         LA    R0,CPANS\n         ST    R0,PPLANS\n         LA    R0,WORK\n         ST    R0,PPLUWA\n*\n**  INVOKE PARSE\n*\n         CALLTSSR EP=IKJPARS,MF=(E,(RPPL))\n         SPACE\n         LTR   15,15                         TEST PARSE RETURN-CODE\n         BZ    PARSEOK                       PARSE OK\n* TPUT MESSAGE AND SET RETURN CODE ON PARSE FAILURE *\n         LA    R1,=C'COMMAND-PARSE FAILURE'\n         LA    R0,21\n         SVC   93\n         MVI   RC1,20\n         B     FASTEXIT\n         RF    RPPL\n         EJECT\n*\n**  AFTER SUCCESSFUL PARSE, PROCESS EACH DDNAME PARAMETER\n*\nPARSEOK  DS    0H\n         L     RPARSED,CPANS\n*  TEST  FOR   MUTUALLY-EXCLUSIVE KEYWORDS\n         CLC   ISAVE,=H'0'\n         BE    PARSEOK1                      BR IF NO 'SAVE' KEYWORD\n         CLC   IRESET,=H'0'\n         BE    PARSEOK1                      BR IF NO 'RESET' KEYWORD\n         LA    R1,=C'ERROR - KEYWORDS MUTUALLY EXCLUSIVE '\n         LA    R0,35\n         SVC   93\n         MVI   RC1,20\n         B     EXIT\n*\nPARSEOK1 DS    0H\n         RG    RDDN                          DDNAME-ALLOCATED ARRAY\n         LA    RDDN,DDNAME1                  SET DDNAME BASE\n         LA    R1,50                         CLEAR DDNAME ARRAY\nDDNCLR   MVC   0(8,RDDN),=CL8' '\n         LA    RDDN,8(RDDN)\n         BCT   R1,DDNCLR\n         LA    RDDN,DDNAME1                  RESET DDNAME BASE\n*\n**  FIND A DDNAME FROM INPUT LIST\n*\n         RG    (RPDE,PDE)\n         LA    RPDE,IDDN\n         SPACE\nDDNLOOP  DS    0H                            LOOPS THRU \"LOOPRET\"\n         LTR   RPDE,RPDE\n         BZ    AMIDONE                       NO MORE DDNAMES\n         L     R15,PDEADDR\n         LH    R1,PDELEN                     LENGTH OF DDNAME\n         BCTR  R1,R0                           MINUS 1 FOR \"EX\"\n         MVC   REALDD,=CL8' '\n         EX    R1,MVDD\n         B     GOTDD\nMVDD     MVC   REALDD(0),0(R15)              EXTRACT DDNAME\n*\n*\nGOTDD    DS    0H\n         CLC   IRESET,=H'0'                  'RESET' KEYWORD?\n         BNE   RESET1                        BR IF YES TO PROCESS RESET\n*   CONTINUE WITH DISPLAY/'SAVE' PROCESSING\n         MVC   DSNAMECT,=AL2(DSNAME#)        SET ARRAY COUNT\n*        LINK  EP=KDSNSUB,PARAM=(REALDD,DSNAMECT,DSNAME1),VL=1\n         CALL  KDSNSUB,(REALDD,DSNAMECT,DSNAME1),VL\n*\n*** DSNAMES NOW IN TABLE ... PREPARE FOR 'SAVE' OR DISPLAY RESPONSE\n*\nDONEDDN  DS    0H\n         RG    RDSN\n         RG    RCOUNT\n         LA    RDSN,DSNAME1                  SET RESULTS BASE\n         LH    RCOUNT,DSNAMECT               SET ARRAY COUNT\n         CLC   ISAVE(2),=H'0'                'SAVE' KEYWORD?\n         BNE   DOGRAB                        BR IF YES TO PROCESS\n*\n***      STD   TPUT   RESPONSE\n*\n         MVC   ODDN,REALDD\n         LA    R1,OMESSAGE\n         L     R0,=A(L'OMESSAGE)\n         LTR   RCOUNT,RCOUNT\n         BZ    TNODDN                        BR IF NO DSNAMES FOUND\n         MVC   OTEXT,MESSAGEF\n         SVC   93\nTOUTDSN  LA    R0,44\n         LR    R1,RDSN\n         SVC   93                            TPUT DSNAME\n         LA    RDSN,44(RDSN)\n         BCT   RCOUNT,TOUTDSN                LOOP TO TPUT NEXT DSNAME\n         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN\nTNODDN   DS    0H                            DDNAME NOT FOUND MESSAGE\n         MVC   OTEXT,MESSAGEN\n         SVC   93\n         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN\nLASTLINE DS    0H\n         LA    R1,=CL8' '                    WRITE BLANK LINE FOR\n         LA    R0,8                             READABILITY ON SCREEN\n         SVC   93\n         B     LOOPRET\n         EJECT\n*\n*** END OF LOOP FOR DDNAME-LIST PROCESSING\n*\nLOOPRET  DS    0H\n         ICM   RPDE,B'0111',PDECHAIN+1       SET TO NEXT PDE ENTRY\n         B     DDNLOOP\n         SPACE 3\n*\n*** ALL ENTRIES IN 'DDNAME-LIST' PROCESSED\n*\nAMIDONE  DS    0H\n         CLC   IRESET,=H'0'                  'RESET' KEYWORD?\n         BNE   RESET2                        BR TO PROCESS RESET\n         B     EXIT                          BR TO END OF PGM\n         EJECT\n*\n*** PROCESSING FOR 'SAVE' KEYWORD\n*\nDOGRAB   DS    0H\n         CLI   DSNAME1,C' '                  ANY ALLOCATIONS?\n         BE    LOOPRET                       BR IF NO TO AVOID 'SAVE'\n*                                                PROCESSING\nDOGRAB1  RCALL SETDD\n         RCALL DYNALLOC\n         LTR   R15,R15                       TEST DYNALLOC RC\n         BZ    DOGRAB2                       BR IF OK\n         C     R15,=F'20'                    TEST FOR DUPLICATE DD\n         BNE   DYNABORT                      BR IF NO TO CLEANUP\n         CLC   GRABDDNN,=C'99'               TOO MANY DYNALLOCS?\n         BE    DYNABORT                      BR IF TRUE\n         B     DOGRAB1                       BR TO TRY ANOTHER DD\nDOGRAB2  DS    0H\n         MVC   0(8,RDDN),GRABDD              SAVE ALLOCATED DDNAME\n         LA    RDDN,8(RDDN)                  SET ARRAY BASE TO NEXT ENT\n*\n***      CALL PROGRAM TO REFORMAT DSNAMES\n*\n         CALL  KDSNNAM,(DSNAME1,RECDSN,RECRDW),VL\n*\n***      WRITE RECORD TO OUTPUT DATASET\n*\n         MVC   RECDDN,REALDD\n         LH    R1,RECRDW\n         AH    R1,=H'12'                     ADD RDW,DDNAME FIELDS\n         STH   R1,RECRDW\n         AH    R1,=H'4'                      CREATE BDW\n         STH   R1,RECBDW\n         USING IHADCB,R1\n         LA    R1,DYNAMDCB\n         MVC   DCBDDNAM,GRABDD\n         OPEN  (DYNAMDCB,(OUTPUT))\n         LA    R1,DYNAMDCB\n         MVC   DCBLRECL,RECRDW               SET OUTPUT LRECL\n         MVC   DCBBLKSI,RECBDW               SET OUTPUT BLKSIZE\n         DROP  R1\n         WRITE DECBW,SF,DYNAMDCB,RECORD      WRITE THE 'SAVE' RECORD\n         CHECK DECBW\n         CLOSE (DYNAMDCB)\n*\n*** SET RETURN CODE\n*\n         CVB   R0,GRABDDNR\n         A     R0,=F'100'\n         ST    R0,RC4\n         B     LOOPRET                       LOOP TO NEXT DDNAME\n         EJECT\n*\n***      FREE  ALL DYNAMICALLY ALLOCATED DATASETS ON DYNALLOC ERROR\n*\nDYNABORT DS    0H\n         LR    RDSN,RDDN                     SAVE CURRENT RDDN\n         LA    RDDN,DDNAME1                  RESET TO 1ST DDN\nDYNAB1   CR    RDDN,RDSN                     ANY ALLOC SUCCESSFUL?\n         BE    BADEND                        BR IF NO\n         MVC   GRABDD,0(RDDN)\n         RCALL DYNFREE\n         LA    RDDN,8(RDDN)                  BUMP TO NEXT DDN\n         B     DYNAB1\nBADEND   DS    0H\n         LA    R1,=C'DYNAMIC-ALLOCATE FAILURE'\n         LA    R0,25\n         SVC   93\n         MVI   RC1,20\n         B     EXIT\n         RF    RDSN\n         EJECT\n*\n*** PUT ALL ENTRIES FROM 'DDNAME-LIST' ON TABLE FOR 'RESET' PROCESSING\n*\nRESET1   DS    0H\n         MVC   0(8,RDDN),REALDD              SAVE DDNAME OPERAND\n         LA    RDDN,8(RDDN)                  BUMP TO NEXT DDN SLOT\n         B     LOOPRET                       GET NEXT DDNAME OPERAND\n         SPACE 3\n*\n*** REALLOCATE ALL DDNAMES FROM 'DDNAME-LIST' TO ORIGINAL DATASETS\n*\nRESET2   DS    0H\n         LA    RDDN,DDNAME1                  SET TO 1ST INPUT DDN\n         XR    RCOUNT,RCOUNT\nRESET2A  CLI   0(RDDN),C' '                  COUNT NUMBER OF INPUT DDS\n         BE    RESET2AA\n         LA    RCOUNT,1(RCOUNT)\n         LA    RDDN,8(RDDN)\n         B     RESET2A\nRESET2AA ST    RCOUNT,RESETCT\nRESET2B  DS    0H\n         XR    RCOUNT,RCOUNT\n         LA    RCOUNT,1(RCOUNT)\n         LA    RDDN,DDNAME1                  SET TO 1ST INPUT DDN\n         RCALL SETDD                         SET DYNAM DDNAME\n         DEVTYPE GRABDD,DTBL                 TEST FOR DYNAM DDNAME\n         LTR   R15,R15\n         BNZ   RESETEND                      BR IF NOT ALLOCATED\n         USING IHADCB,R1\n         LA    R1,DYNAMDCB\n         MVC   DCBDDNAM,GRABDD\n         DROP  R1\n         OPEN  (DYNAMDCB,(INPUT))\n         READ  DECBR,SF,DYNAMDCB,RECORD,'S'  READ THE 'SAVE' RECORD\n         CHECK DECBR\nRESET2C  DS    0H\n         CLC   RECDDN,0(RDDN)                INPUT MATCHES RESET REQ?\n         BE    RESET2D                       BR IF TRUE TO PROCESS\n         LA    RDDN,8(RDDN)\n         LA    RCOUNT,1(RCOUNT)\n         C     RCOUNT,RESETCT\n         BNH   RESET2C                       LOOP TO NEXT MATCH\n         CLOSE (DYNAMDCB)                    CLOSE BUT DONOT FREE\n         B     RESETEND                      CONTINUE 'RESET' PROCESS\nRESET2D  DS    0H\n         RG    (RUPT,UPT)\n         L     RUPT,CPPLUPT                  SET USER PROFILE ADDR\n         MVC   HOLDPROF,UPTSWS               SAVE ORIGINAL PROFILE\n         OI    UPTSWS,UPTNPRM                SET 'NOPROMPT'\n         MVC   ALLOCDDN,0(RDDN)              SET ALLOC COMMAND PARAMS\n         MVI   ALLOCDSN,C' '                 CLEAR DSNAME PARAMETER\n         MVC   ALLOCDSN+1(L'ALLOCDSN-1),ALLOCDSN\n         LH    R1,RECRDW                     GET DATA LENGTH\n         SH    R1,=H'13'                      MINUS (RDW+DDNAME+1)\n         EX    R1,MVALLOC\n         MVC   ALLOCL,=AL2(L'ALLOCVRB)\n         MVC   CPPLAREA(CPPLLEN),0(RCPPL)    SET INTERNAL CPPL\n         MVC   CPPLAREA(4),=A(ALLOCCMD)      RESET COMMAND BUFFER ADDR\n         LA    R1,CPPLAREA                   SET PARAMETER POINTER\n         LINK  EP=ALLOC                      ALLOCATE W/ 'REUSE'\n         MVC   UPTSWS,HOLDPROF               RESET ORIGINAL PROFILE\n         RF    RUPT\n         CLOSE (DYNAMDCB)                    CLOSE 'SAVE' FILE\n         RCALL DYNFREE                       FREE 'SAVE' FILE\n         L     RCOUNT,RESETH                 SUBTRACT 1 FOR\n         BCT   RCOUNT,RESETEND                  PROCESSED DDNAME\n         B     EXIT                          (EXIT IF ALL DONE)\n         ST    RCOUNT,RESETH                 RESET COUNT OF DDNS TO\n*                                                  PROCESS\nRESETEND DS    0H\n         CLC   GRABDDNN,=C'99'               TEST FOR LAST DYNAM DDN\n         BNE   RESET2B                       BR IF FALSE\n         B     EXIT\nMVALLOC  MVC   ALLOCDSN(0),RECDSN\n         RF    RDDN\n         EJECT\n*\n*** PROGRAM EXIT ANY TIME AFTER PARSE SERVICE INVOKED\n*\nEXIT     DS    0H\n         CLC   ISAVE,=H'0'                   SAVE KWD?\n         BE    EXIT2                         BR IF NO\n         CLC   RC4,=F'0'                     CHECK RETURN-CODE\n         BNE   EXIT2                         BR IF SOMETHING SAVED\n         MVI   RC1,100                       SET 'NOT SAVED' RC\nEXIT2    DS    0H\n         RF    RPDE\n         IKJRLSA CPANS\n*\n*** PROGRAM EXIT ANY TIME BEFORE PARSE SERVICE INVOKED\n*\nFASTEXIT CNAEXIT RC4\n         RF    RPARSED\n         TITLE '- SUBROUTINES'\nDYNALLOC RSUB  ,                             DYNAMIC-ALLOCATE\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDAPL,DAPL)\n         LA    RDAPL,DAPLAREA\n         RG    (RDAP08,DAPB08)\n         LA    RDAP08,DA08AREA\n*        BUILD ALLOC VALUES\n         MVC   DA08CD,=X'0008'\n         XC    DA08PDSN,DA08PDSN\n         MVC   DA08DDN,GRABDD\n         MVI   DA08DSP1,DA08NEW\n         MVI   DA08DPS2,DA08DEL\n         MVI   DA08DPS3,DA08DELE\n         MVI   DA08CTL,DA08PERM\n         OI    DA08CTL,DA08TRKS\n         MVC   DA08UNIT,=C'SYSDA   '\n         MVC   DA08SER,=CL8' '\n         XC    DA08BLK,DA08BLK\n         MVC   DA08PQTY,=F'1'\n         XC    DA08SQTY,DA08SQTY\n         XC    DA08DQTY,DA08DQTY\n         XC    DA08CTL+1(4),DA08CTL+1\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVC   DA08ALN,=CL8' '\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP08,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDAPL))  ALLOCATE\n         RF    RDAP08,RDAPL\n*\n         B     DYNEXIT\n         SPACE 3\nDYNFREE  RSUB  ,                             DYNAMIC-FREE\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDFPL,DAPL)\n         LA    RDFPL,DAPLAREA\n         RG    (RDAP18,DAPB18)\n         LA    RDAP18,DA18AREA\n*        BUILD FREE VALUES\n         MVC   DA18CD,=X'0018'\n         MVC   DA18DDN,GRABDD\n         MVC   DA18MNM,=CL8' '\n         MVC   DA18SCLS,=CL2' '\n         MVI   DA18CTL,DA18PERM\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP18,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDFPL))  FREE PREVIOUS ALLOCATE\n         RF    RDAP18,RDFPL\n*\n         B     DYNEXIT\n         SPACE 3\n*        SET GRAB-DATASET DDNAME AS FOLLOWS (FOR UNIQUENESS):\n*              \"KDSNXX..\"  WHERE \"..\" IS NUMBERED 1-UP\n*                    FROM \"1 \" TO \"99\".\n*\nSETDD    RSUB  ,\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         CLI   GRABDDNN+1,C' '\n         BNE   SETDD2\n         CLI   GRABDDNN,C'9'\n         BNE   SETDD1\n         MVC   GRABDDNN,=C'09'\n         B     SETDD2\nSETDD1   PACK  GRABDDNP,GRABDDNN(1)\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN(1),GRABDDNP\n         OI    GRABDDNN,X'F0'                CLEAR THE SIGN\n         B     SETDD3\nSETDD2   DS    0H\n         PACK  GRABDDNP,GRABDDNN\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN,GRABDDNP\n         OI    GRABDDNN+1,X'F0'              CLEAR THE SIGN\nSETDD3   DS    0H\n         B     DYNEXIT\n         TITLE '- COMMON SUBROUTINE EXIT'\nDYNEXIT  DS    0H\n         L     R14,DYNRET\n         LM    R0,R12,DYNREG\n         BR    R14\nDYNRET   DS    F                             SUBROUTINE RETURN ADDRESS\nDYNREG   DS    13F                           SUBROUTINE RETURN REGS\n         DROP  ,\n         TITLE '- CONSTANTS'\n         RL\n*\nOMESSAGE DS    0CL(MLTH)\nODDN     DS    CL8\nOTEXT    DS    CL(L'MESSAGEF)\nMLTH     EQU   *-ODDN\nMESSAGEF DC    C' ALLOCATED TO: '\nMESSAGEN DC    C' NOT ALLOCATED '\n*\nALLOCCMD DC    AL2(ALLOCEND-ALLOCCMD)\nALLOCL   DC    AL2(ALLOCOPS-ALLOCVRB)\nALLOCVRB DC    C'ALLOC '\nALLOCOPS DC    C'FI('\nALLOCDDN DS    CL8\n         DC    C') SHR REUSE DA('\nALLOCDSN DS    CL220\nALLOCEND EQU   *\n*\n         LTORG *\n         TITLE '- WORKING STORAGE'\nRC4      DS    F\nRC1      EQU   RC4+3,1\nCPECB    DS    F\nCPANS    DS    F\nCPUWA    DS    F\n*\nPPLAREA  DS    0A,XL(PPLLEN)\nCPPLAREA DS    0A,XL(CPPLLEN)\n*\nDAPLAREA DS    0A,XL(DAPLLEN)\nDA08AREA DS    0A,XL(DAP08LEN)\nDA18AREA DS    0A,XL(DAP18LEN)\n*\nWORK     DS    CL30                          PPLUWA (NOT USED)\n*\n         ORG   WORK                          REUSE WORK FIELD\nDSNCT    DS    F                             COUNT OF DSNAME1 ARRAY\nRESETCT  DS    F                             COUNT OF DDNAME1 ARRAY\nRESETH   DS    F                             PROCESS COUNT OF DDNAME1\nDTBL     DS    2F                            DEVTYPE WORK AREA\nHOLDPROF DS    X                             TSO-PROFILE HOLD AREA\n         ORG\n*\n         DS    0D\nREALDD   DC    CL8' '                        TRUE DDNAME\n         DS    0D\nGRABDD   DS    0CL8                          DYNAMIC-ALLOCATE DDNAME\n         DC    CL6'KDSNXX'                   * FIXED PORTION\nGRABDDNN DC    C'0 '                         * VARIABLE DIGITS\n*\nGRABDDNR DS    0PL8                          WORK FIELD FOR SAVE-RC\n         DC    XL6'000000000000'\nGRABDDNP DS    PL2                           WORK FIELD FOR GRABDDNN\n*\nDDNAME1  DS    CL8                           ARRAY FOR 50 DDNAMES\n         DS    49CL8                         * HOLDS KDSNXX.. FOR SAVE\n*                                            * HOLDS DDNLIST FOR RESET\n*\nDSNAME#  EQU   50\nDSNAMECT DS    H\n         DS    0D                            ALIGNMENT FOR COBOL CALL\nDSNAME1  DS    (DSNAME#)CL44                 ARRAY FOR DSNAMES\n*\n         DS    0D                            ALIGNMENT FOR COBOL CALL\nRECORD   DS    0CL238                        INPUT/OUTPUT 'SAVE' RECORD\nRECBDW   DS    H\n         DC    H'0'\nRECRDW   DS    H\n         DC    H'0'\nRECDDN   DS    CL8                           ORIGINAL DDNAME\nRECDSN   DS    CL220                         QUOTED DSNAMES\n*\n         PRINT NOGEN\n*    DCB FOR SAVE AND RESET PROCESSING (BOTH)\nDYNAMDCB DCB   DDNAME=X,DSORG=PS,MACRF=(R,W),RECFM=V,LRECL=232,        X\n               BLKSIZE=236\n         PRINT GEN\n         TITLE '- PARSE MACROS'\nPARSECT  IKJPARM\nIDDN     IKJIDENT 'DDNAME LIST',LIST,MAXLNTH=8,                        *\n               FIRST=ALPHA,OTHER=ALPHANUM,                             *\n               PROMPT='DDNAME LIST',                                   *\n               HELP='LIST OF DDNAMES FOR DSNAME DISPLAY'\nISAVE    IKJKEYWD\n         IKJNAME 'SAVE',ALIAS=('SA')\nIRESET   IKJKEYWD\n         IKJNAME 'RESET',ALIAS=('RE')\n         IKJENDP\n         TITLE '- DSECTS'\nPDE      DSECT\nPDEADDR  DS    A              ADDRESS OF DDNAME\nPDELEN   DS    H              LENGTH OF  DDNAME\nPDEFLAG  DS    X              FLAGS\n         DS    X              (ALIGNMENT)\nPDECHAIN DS    A              ADDRESS OF NEXT PDE IN LIST\n         SPACE\nDEVNAMET DSECT\nDEVNUM   DS    F\nDEVNAME  DS    CL8\nDEVUNIT  DS    XL4\n         SPACE\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         SPACE\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         SPACE\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         SPACE\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         SPACE\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IHADCB DEVD=DA,DSORG=PS\n         EJECT\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KDSNNAM": {"ttr": 6666, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "000010 IDENTIFICATION DIVISION.                                         05/30/84\n000020 PROGRAM-ID.    KDSNNAM.                                          KDSNNAM\n000030 AUTHOR.        BRUCE LOMAR.                                         LV009\n000031 INSTALLTION.   CNA INSURANCE.                                       LV009\n000040\n000050 ENVIRONMENT DIVISION.\n000060 CONFIGURATION SECTION.\n000070 SOURCE-COMPUTER.\n000080     IBM-370.\n000090*    IBM-370 WITH DEBUGGING MODE.\n000100 INPUT-OUTPUT SECTION.\n000110 FILE-CONTROL.\n000120\n000130 DATA DIVISION.\n000140\n000150 WORKING-STORAGE SECTION.\n000160\n000170 01  ONE-QUOTE                        PIC X   VALUE ''''.\n000180 01  ONE-BLANK                        PIC X   VALUE SPACES.\n000190\n000200/\n000210 LINKAGE SECTION.\n000220\n000230 01  DSN-ARRAY.\n000240     03  DSNAME                       PIC X(44)\n000250                                      OCCURS 50 TIMES\n000260                                      INDEXED BY DSN-INX.\n000270 01  DSNAME-STRING                    PIC X(220).\n000280 01  STRING-LENGTH                    PIC S9(4) COMP.\n000290\n000300/\n000310 PROCEDURE DIVISION USING DSN-ARRAY DSNAME-STRING STRING-LENGTH.\n000320 0100-MAIN-ROUTINE.\n000330*    BUILD QUOTED DSNAMES INTO A STRING\n000340     MOVE SPACES TO DSNAME-STRING.\n000350     MOVE +1 TO STRING-LENGTH.\n000360     PERFORM 0200-STRING-DSN THRU 0200-EXIT\n000370         VARYING DSN-INX FROM 1 BY 1\n000380         UNTIL DSNAME (DSN-INX) = SPACES OR DSN-INX > 50\n000390     MOVE ZERO TO RETURN-CODE.\n000400     GOBACK.\n000410\n000420 0200-STRING-DSN.\n000430     IF DSNAME (DSN-INX) = 'TERMFILE'\n000440         STRING '*'       DELIMITED BY SIZE\n000450                ONE-BLANK DELIMITED BY SIZE\n000460             INTO DSNAME-STRING\n000470         WITH POINTER STRING-LENGTH\n000480         OVERFLOW GO TO 0225-STRING-ERROR\n000490     ELSE\n000500         STRING ONE-QUOTE            DELIMITED BY SIZE\n000510                DSNAME (DSN-INX)     DELIMITED BY SPACES\n000520                ONE-QUOTE            DELIMITED BY SIZE\n000530                ONE-BLANK            DELIMITED BY SIZE\n000540             INTO DSNAME-STRING\n000550         WITH POINTER STRING-LENGTH\n000560         OVERFLOW GO TO 0225-STRING-ERROR.\n000570 0200-EXIT.  EXIT.\n000580\n000590 0225-STRING-ERROR.\n000600     MOVE 99 TO RETURN-CODE.\n000610     GOBACK.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KLIB": {"ttr": 6913, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8504                                               *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RNOTE &SUBRTN\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NEWSUB\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&SUBRTN').LOOPN1\n         AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* SUBSCRIPTS FOR THIS SUBROUTINE'S REGISTERS ARE &N*10-9 THRU &N*10\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA1  AIF   (&A GE 12).EXIT         12 IS HIGHEST SUPPORTED REGISTER\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&SINUSE(&N) OR &INUSE(&A))  NOTE WHETHER REG IN USE\n         AIF   ('&SUSING(&N)' EQ '&USING(&A)').LOOPA1  IF STILL USING,\n.*                                     LEAVE AS IS,\n&SUSING(&N) SETC ''                    ELSE SET TO NOT USING\n         AGO   .LOOPA1\n.*\n.* ASSIGN NUMBER TO NEWLY REFERENCED SUBROUTINE\n.*\n.NEWSUB  AIF   (&#SUB GE 20).ERR#SUB\n         AIF   (T'&SUBRTN EQ 'O').ERRSUB\n&N       SETA  &#SUB*10                LOWEST SUBCRIPT FOR NEXT SUB - 1\n&#SUB    SETA  &#SUB+1                 GET NEW SUBROUTINE NUMBER\n&SNAME(&#SUB) SETC '&SUBRTN'           NOTE SUBROUTINE NAME\n.*\n.* NOTE THE REGISTER ENVIRONMENT\n.*\n&A       SETA  2                       LOWEST SUPPORTED REG MINUS 1\n.LOOPA2  AIF   (&A GE 12).EXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&SINUSE(&N) SETB (&INUSE(&A))          NOTE REGISTERS IN USE\n&SUSING(&N) SETC '&USING(&A)'          AND DSECT NAMES\n         AGO   .LOOPA2\n.EXIT    ANOP\n         MEXIT\n.*\n.* ERROR MNOTES\n.*\n.ERRSUB  MNOTE 12,'SUBROUTINE NAME REQUIRED BUT MISSING'\n         MEXIT\n.ERRDOWN MNOTE 12,'ONLY DOWNWARD CALLS SUPPORTED'\n         MEXIT\n.ERR#SUB MNOTE 12,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    RSUB  &OPERAND\n         GBLA  &#SUB\n         GBLB  &INUSE(13),&SINUSE(200),&SDOWN(20)                 MA01\n         GBLC  &EQU(12),&USING(12),&SNAME(20),&SUSING(200)\n         LCLA  &N,&A\n&NAME    DS    0H                      DEFINE SYMBOL FOR ENTRY POINT  $\n         AIF   ('&OPERAND' EQ '').OPX\n         AIF   ('&OPERAND' NE 'RECURSIVE').NORECUR\n         ST    R14,0(,RSTACK)          SAVE RETURN ADRESS             $\n         SH    RSTACK,=Y(4)            PUSH STACK DOWN                $\n.OPX     ANOP\n.*\n.* FIND THE NUMBER ASSIGNED TO THIS SUBROUTINE.\n.*\n.LOOPN1  AIF   (&N GE &#SUB).NOCALL\n&N       SETA  &N+1\n         AIF   ('&SNAME(&N)' NE '&NAME').LOOPN1\n.SETUP   AIF   (&SDOWN(&N)).ERRDOWN\n.*\n.* ESTABLISH THE CALLERS' REGISTER ENVIRONMENT\n.*\n&SDOWN(&N) SETB 1\n&N       SETA  &N*10-10                LOWEST SUBSCRIPT FOR THIS\n.*                                     SUBROUTINE MINUS 1\n&A       SETA  2                       LOWEST SUPPORTED REG - 1\n.LOOPA1  AIF   (&A GE 12).MEXIT\n&N       SETA  &N+1\n&A       SETA  &A+1\n&INUSE(&A) SETB (&SINUSE(&N))          MARK CALLERS' REGISTERS IN USE\n&EQU(&A) SETC  ''                      NULL SO RF MACRO CAN'T FREE REG\n         AIF   ('&USING(&A)' EQ '').DROPX\n         DROP  &A                      DROP REG USED BY PRECEDING CODE\n.DROPX   ANOP\n&USING(&A) SETC '&SUSING(&N)'          SET TO CALLERS' DSECT NAME\n         AIF   ('&USING(&A)' EQ '').LOOPA1\n         USING &USING(&A),&A           RE-ESTABLISH CALLERS' USING    $\n         AGO   .LOOPA1\n.MEXIT   MEXIT\n.*\n.* ASSIGN A NEW NUMBER TO AN UNCALLED SUBROUTINE\n.*\n.NOCALL  AIF   ('&NAME' EQ '').ERRNAME\n         AIF   (&#SUB GE 20).ERR#SUB\n&#SUB    SETA  &#SUB+1                 INCREASE # OF REFERENCED SUBRTNS\n&N       SETA  &#SUB\n&SNAME(&N) SETC '&NAME'                SAVE NAME IN CASE REFERRED TO\n         AGO   .SETUP\n.*\n.* ERROR MSGS\n.*\n.NORECUR MNOTE 4,'&OPERAND IS INVALID OPERAND. IGNORED.'          MA01\n         AGO   .OPX                                               MA01\n.ERRDOWN MNOTE 8,'SUBROUTINE NAME &NAME ALREADY USED'\n         MEXIT\n.ERRNAME MNOTE 8,'SPECIFY SUBROUTINE NAME AS LABEL'\n         MEXIT\n.ERR#SUB MNOTE 8,'ONLY 20 SUBROUTINES SUPPORTED'\n         MEND\n         MACRO\n&NAME    RCALL &SUBRTN\n         RNOTE &SUBRTN\n&NAME    BAL   14,&SUBRTN              LINK TO SUBROUTINE             $\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RL\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         PUSH  PRINT                                                  $\n         PRINT ON,GEN                                                 $\n&A       SETA  2                       1ST SUPPORTED REGISTER - 1\n.LOOP    AIF   (&A GE 12).LISTX\n&A       SETA  &A+1\n         AIF   (NOT &INUSE(&A)).LOOP\n&C       SETC  '&EQU(&A)        '(1,8).' EQU   &A                      *\n                                                       '(1,60)\n         MNOTE *,'&C.$'\n         AIF   ('&USING(&A)' EQ '').LOOP\n&C       SETC  '         USING &USING(&A),&A                           *\n                                                       '(1,68)\n         MNOTE *,'&C.$'\n         AGO   .LOOP\n.LISTX   POP   PRINT                                                  $\n         MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\nKLIB     TITLE 'TSO COMMAND KDSN (DISPL/TRAP/RESET DSNAMES FOR DDNAME)'\n*  COMMAND SYNTAX:  KLIB (DDNAME:MEMBER LIST) SAVE                    *\n*  COMMAND ACTION:                                                    *\n*     1. PARSE THE DDNAME-LIST (LOOPING FOR EACH DDNAME).             *\n*     2. EXTRACT DSNAMES INTO A TABLE (KDSNSUB).                      *\n*     3. BLDL MEMBER-NAME AGAINST EACH LIBRARY IN DSNAME TABLE;       *\n*        BLANK OUT \"NO-HIT\" DSNAMES (KMEMSUB).                        *\n*     4. IF 'SAVE' OMITTED, TPUT REMAINING DSNAMES FROM TABLE.        *\n*     5. IF 'SAVE':                                                   *\n*        A.  ALLOCATE A 'SAVE'-DATASET.                               *\n*        B.  WRITE MEMBER/DDNAME RECORD.                              *\n*        C.  WRITE DSNAME RECORDS.                                    *\n*  TECHNICAL NOTES:                                                   *\n*     1. PROGRAM IS NOT REENTRANT.                                    *\n*     2. IKJDAIR SERVICE USED FOR ALLOCATE/FREE OF 'SAVE'-DATASET.    *\n*        'SAVE'-DATASET ALLOCATED BY DYNAMICALLY-DETERMINED DDNAME.   *\n*     3. 'SAVE' FUNCTION IS INSENSITIVE TO DDNAMES IN COMMAND INPUT   *\n*        WHICH ARE NOT ALLOCATED.                                     *\n*     4. RETURN-CODES:                                                *\n*              0 = SUCCESSFUL DISPLAY/'RESET' FUNCTION                *\n*             20 = (UNANTICIPATED) COMMAND FAILURE                    *\n*            100 = NO DDNAME/MEMBER HITS DURING 'SAVE' FUNCTION       *\n*        (100+N) = SUCCESSFUL 'SAVE' FUNCTION;                        *\n*                  'N' = NUMERIC QUALIFIER OF LAST 'SAVE'-DATASET DDN *\n*                                                                     *\nKLIB     CSECT\n         RG    (RBASE,,12)\n         RG    (RBASE2,,11)\n         RG    (RCPPL,CPPL)\n         CNAENTER PARM=RCPPL,ENTRY=NO,RENT=NO\n* RESET PROGRAM BASE FOR READABILITY\n         L     RBASE,=V(KLIB)\n         DROP  R13\n         USING KLIB,RBASE\n         LA    RBASE2,4095(RBASE)\n         LA    RBASE2,1(RBASE2)\n         USING KLIB+4096,RBASE2\n         B     TOP\n         EJECT\nTOP      DS    0H\n*\n**  PARSE THE OPERAND LIST\n*\n         XC    RC4,RC4        INITIALIZE RETURN-CODE\n         RG    (RPPL,PPL)\n         LA    RPPL,PPLAREA\n         RG    (RPARSED,IKJPARMD)\n         L     RPARSED,=V(PARSECT)\n         SPACE\n*\n**  ESTABLISH VALUES IN THE PARSE PARAMETER LIST\n*\n         MVC   PPLCBUF,CPPLCBUF\n         MVC   PPLUPT,CPPLUPT\n         ST    RPARSED,PPLPCL\n         MVC   PPLECT,CPPLECT\n         XC    CPECB,CPECB\n         LA    R0,CPECB\n         ST    R0,PPLECB\n         XC    CPANS,CPANS\n         LA    R0,CPANS\n         ST    R0,PPLANS\n         LA    R0,WORK\n         ST    R0,PPLUWA\n*\n**  INVOKE PARSE\n*\n         CALLTSSR EP=IKJPARS,MF=(E,(RPPL))\n         SPACE\n         LTR   15,15                         TEST PARSE RETURN-CODE\n         BZ    PARSEOK                       PARSE OK\n* TPUT MESSAGE AND SET RETURN CODE ON PARSE FAILURE *\n         LA    R1,=C'COMMAND-PARSE FAILURE'\n         LA    R0,21\n         SVC   93\n         MVI   RC1,20\n         B     FASTEXIT\n         RF    RPPL\n         EJECT\n*\n**  AFTER SUCCESSFUL PARSE, PROCESS EACH DDNAME PARAMETER\n*\nPARSEOK  DS    0H\n         L     RPARSED,CPANS\n         RG    RDDN                          DDNAME-ALLOCATED ARRAY\n         LA    RDDN,DDNAME1                  SET DDNAME BASE\n         LA    R1,50                         CLEAR DDNAME ARRAY\nDDNCLR   MVC   0(8,RDDN),=CL8' '\n         LA    RDDN,8(RDDN)\n         BCT   R1,DDNCLR\n         LA    RDDN,DDNAME1                  RESET DDNAME BASE\n*\n**  FIND A DDNAME FROM INPUT LIST\n*\n         RG    (RPDE,PDE)\n         LA    RPDE,IDDN\n         SPACE\nDDNLOOP  DS    0H                            LOOPS THRU \"LOOPRET\"\n         LTR   RPDE,RPDE\n         BZ    EXIT                          NO MORE DDNAMES\n         MVI   MESSAGE,C' '                  CLEAR TPUT-OUTPUT LINE\n         MVC   MESSAGE+1(L'MESSAGE-1),MESSAGE\n         MVC   REALDD,=CL8' '\n         MVC   REALMEM,=CL8' '\n         L     R15,PDEADDR\n         LH    R1,PDELEN                     LENGTH OF DDNAME\n         BCTR  R1,R0                           MINUS 1 FOR \"EX\"\n         EX    R1,MVDD\n         EX    R1,MVDD2\n*\n         L     R15,PDEADDR2\n         LH    R1,PDELEN2                    LENGTH OF DDNAME\n         BCTR  R1,R0                           MINUS 1 FOR \"EX\"\n         EX    R1,MVMEM\n         LA    R2,OMEM+7                     MOVE RIGHT-JUSTIFIED\n         SR    R2,R1                           TO TPUT-OUTPUT LINE\n         EX    R1,MVMEM2\n         B     GOTDD\nMVDD     MVC   REALDD(0),0(R15)              EXTRACT DDNAME\nMVDD2    MVC   ODDN(0),0(R15)                EXTRACT DDNAME\nMVMEM    MVC   REALMEM(0),0(R15)             EXTRACT MEMBERNM\nMVMEM2   MVC   0(0,R2),0(R15)                EXTRACT MEMBERNM\n*\n*\nGOTDD    DS    0H\n         MVC   DSNAMECT,=AL2(DSNAME#)\n*        LINK  EP=KDSNSUB,PARAM=(REALDD,DSNAMECT,DSNAME1),VL=1\n         CALL  KDSNSUB,(REALDD,DSNAMECT,DSNAME1),VL\n         MVC   DSNCTH,DSNAMECT               SAVE DSNAME COUNT\n         LTR   R15,R15\n         BZ    DONEDDN\nBADDDN   DS    0H\n         MVI   MEMSW,C'X'                    SET 'NO DSNS FOUND'\n         B     ENDMEM                        BR TO OUTPUT ROUTINE\n*\n*** DSNAMES NOW IN TABLE ... CHECK FOR MEMBER \"HITS\"\n*\nDONEDDN  DS    0H\n         MVI   MEMSW,C'N'                    SET SWITCH TO 'NOT FOUND'\n*        LINK  EP=KMEMSUB,PARAM=(REALMEM,DSNAMECT,DSNAME1),VL\n         CALL  KMEMSUB,(REALMEM,DSNAMECT,DSNAME1),VL\n         LTR   R15,R15\n         BNZ   ENDMEM\n         MVI   MEMSW,C'Y'\n*\n*** ALL DSNAMES ALLOCATED TO DDNAME NOW TESTED FOR MEMBER-NAME HIT.\n*\nENDMEM   DS    0H\n         RG    RDSN                          DSNAME RESULTS ARRAY\n         RG    RCOUNT                        ARRAY COUNTER\n         LH    RCOUNT,DSNCTH                 SET DSNAME COUNT\n         LA    RDSN,DSNAME1                  SET DSNAME REGISTER\n         CLC   ISAVE(2),=H'0'                'SAVE' KEYWORD?\n         BNE   DOGRAB                        BR IF YES TO PROCESS\n*\n***      STD   TPUT   RESPONSE\n*\n         MVC   OTEXT1,MESSAGE1\n         CLI   MEMSW,C'Y'                    ANY MEMBER HITS?\n         BNE   TNODDN                        BR IF NO TO NOTFOUND MSG\n*\n         MVC   OTEXT2,MESSAGEF\n         LA    R1,MESSAGE\n         L     R0,=A(L'MESSAGE)\n         SVC   93\nTOUTDSN  DS    0H\n         CLI   0(RDSN),C' '\n         BE    TOUTDSN2                      LOOP TO TPUT NEXT DSNAME\n         LA    R0,44\n         LR    R1,RDSN\n         SVC   93                            TPUT DSNAME\nTOUTDSN2 DS    0H\n         LA    RDSN,44(RDSN)\n         BCT   RCOUNT,TOUTDSN                LOOP TO TPUT NEXT DSNAME\n         B     LASTLINE                      LOOP TO CHECK FOR NEXT DDN\nTNODDN   DS    0H                            DDNAME NOT FOUND MESSAGE\n         CLI   MEMSW,C'X'\n         BE    TNODSN\n         MVC   OTEXT2,MESSAGEN\n         B     ONELINE                       LOOP TO CHECK FOR NEXT DDN\nTNODSN   DS    0H\n         MVC   OTEXT1,MESSAGE2\n         MVC   OMEM,=CL8' '\n*\nONELINE  DS    0H\n         L     R0,=A(L'MESSAGE)\n         LA    R1,MESSAGE\n         SVC   93\nLASTLINE DS    0H\n         LA    R1,=CL8' '                    WRITE BLANK LINE FOR\n         LA    R0,8                             READABILITY ON SCREEN\n         SVC   93\n         B     LOOPRET\n         EJECT\n*\n*** END OF LOOP FOR DDNAME-LIST PROCESSING\n*\nLOOPRET  DS    0H\n         ICM   RPDE,B'0111',PDECHAIN+1       SET TO NEXT PDE ENTRY\n         B     DDNLOOP\n         EJECT\n*\n*** PROCESSING FOR 'SAVE' KEYWORD\n*\nDOGRAB   DS    0H\n         CLI   MEMSW,C'Y'                    ANY MEMBER HITS?\n         BNE   LOOPRET                       BR IF NO TO AVOID 'SAVE'\n*                                                PROCESSING\nDOGRAB1  RCALL SETDD\n         RCALL DYNALLOC\n         LTR   R15,R15                       TEST DYNALLOC RC\n         BZ    DOGRAB2                       BR IF OK\n         C     R15,=F'20'                    TEST FOR DUPLICATE DD\n         BNE   DYNABORT                      BR IF NO TO CLEANUP\n         CLC   GRABDDNN,=C'99'               TOO MANY DYNALLOCS?\n         BE    DYNABORT                      BR IF TRUE\n         B     DOGRAB1                       BR TO TRY ANOTHER DD\nDOGRAB2  DS    0H\n         MVC   0(8,RDDN),GRABDD              SAVE ALLOCATED DDNAME\n         LA    RDDN,8(RDDN)                  SET ARRAY BASE TO NEXT ENT\n*\n***      WRITE RECORDS TO OUTPUT DATASET\n***      (1ST = MEMBER; 2-N=UNQUOTED DSNAME)\n*\n         USING IHADCB,R1\n         LA    R1,DYNAMDCB\n         MVC   DCBDDNAM,GRABDD\n         DROP  R1\n         OPEN  (DYNAMDCB,(OUTPUT))\n         MVC   RECMEM,REALMEM\n         MVC   RECDDN,REALDD\n         PUT   DYNAMDCB,RECORD               WRITE 1ST 'SAVE' RECORD\nDOGRAB3  DS    0H\n         CLI   0(RDSN),C' '\n         BE    DOGRAB4                       BR TO BYPASS BLANK DSNAME\n         PUT   DYNAMDCB,(RDSN)               WRITE DSNAME 'SAVE' RECORD\nDOGRAB4  DS    0H\n         LA    RDSN,44(RDSN)\n         BCT   RCOUNT,DOGRAB3                LOOP TO PUT NEXT DSNAME\n*\n         CLOSE (DYNAMDCB)\n*\n*** SET RETURN CODE\n*\n         CVB   R0,GRABDDNR\n         A     R0,=F'100'\n         ST    R0,RC4\n         B     LOOPRET                       LOOP TO NEXT DDNAME\n         EJECT\n*\n***      FREE  ALL DYNAMICALLY ALLOCATED DATASETS ON DYNALLOC ERROR\n*\nDYNABORT DS    0H\n         LR    RDSN,RDDN                     SAVE CURRENT RDDN\n         LA    RDDN,DDNAME1                  RESET TO 1ST DDN\nDYNAB1   CR    RDDN,RDSN                     ANY ALLOC SUCCESSFUL?\n         BE    BADEND                        BR IF NO\n         MVC   GRABDD,0(RDDN)\n         RCALL DYNFREE\n         LA    RDDN,8(RDDN)                  BUMP TO NEXT DDN\n         B     DYNAB1\nBADEND   DS    0H\n         LA    R1,=C'DYNAMIC-ALLOCATE FAILURE'\n         LA    R0,25\n         SVC   93\n         MVI   RC1,20\n         B     EXIT\n         EJECT\n         RF    RDSN,RDDN,RCOUNT\n         EJECT\n*\n*** PROGRAM EXIT ANY TIME AFTER PARSE SERVICE INVOKED\n*\nEXIT     DS    0H\n         CLC   ISAVE,=H'0'                   'SAVE' KEYWORD\n         BE    EXIT2                         BR IF NOT PRESENT\n         CLC   RC4,=F'0'                     TEST RETURN-CODE\n         BNE   EXIT2                         'SAVE' PROCESSING DONE\n         MVI   RC1,100                       SET 'NOT SAVED' RET CODE\nEXIT2    DS    0H\n         RF    RPDE\n         IKJRLSA CPANS\n*\n*** PROGRAM EXIT ANY TIME BEFORE PARSE SERVICE INVOKED\n*\nFASTEXIT CNAEXIT RC4\n         RF    RPARSED\n         TITLE '- SUBROUTINES'\nDYNALLOC RSUB  ,                             DYNAMIC-ALLOCATE (NEW)\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDAPL,DAPL)\n         LA    RDAPL,DAPLAREA\n         RG    (RDAP08,DAPB08)\n         LA    RDAP08,DA08AREA\n*        BUILD ALLOC VALUES\n         MVC   DA08CD,=X'0008'\n         XC    DA08PDSN,DA08PDSN\n         MVC   DA08DDN,GRABDD\n         MVI   DA08DSP1,DA08NEW\n         MVI   DA08DPS2,DA08DEL\n         MVI   DA08DPS3,DA08DELE\n         MVI   DA08CTL,DA08PERM\n         OI    DA08CTL,DA08TRKS\n         MVC   DA08UNIT,=C'SYSDA   '\n         MVC   DA08SER,=CL8' '\n         XC    DA08BLK,DA08BLK\n         MVC   DA08PQTY,=F'1'\n         XC    DA08SQTY,DA08SQTY\n         XC    DA08DQTY,DA08DQTY\n         XC    DA08CTL+1(4),DA08CTL+1\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVC   DA08ALN,=CL8' '\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP08,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDAPL))  ALLOCATE\n         RF    RDAP08,RDAPL\n*\n         B     DYNEXIT\n         SPACE 3\nDYNFREE  RSUB  ,                             DYNAMIC-FREE (SHR)\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         RG    (RDFPL,DAPL)\n         LA    RDFPL,DAPLAREA\n         RG    (RDAP18,DAPB18)\n         LA    RDAP18,DA18AREA\n*        BUILD FREE VALUES\n         MVC   DA18CD,=X'0018'\n         MVC   DA18DDN,=C'KLIBTEMP'          SPECIAL DDNAME\n         MVC   DA18MNM,=CL8' '\n         MVC   DA18SCLS,=CL2' '\n         MVI   DA18CTL,DA18PERM\n*        BUILD DAPL VALUES\n         MVC   DAPLUPT,CPPLUPT\n         MVC   DAPLECT,CPPLECT\n         LA    R0,CPECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB,CPPLPSCB\n*\n         ST    RDAP18,DAPLDAPB\n         CALLTSSR EP=IKJDAIR,MF=(E,(RDFPL))  FREE PREVIOUS ALLOCATE\n         RF    RDAP18,RDFPL\n*\n         B     DYNEXIT\n         SPACE 3\n*        SET GRAB-DATASET DDNAME AS FOLLOWS (FOR UNIQUENESS):\n*              \"KLIBXX..\"  WHERE \"..\" IS NUMBERED 1-UP\n*                    FROM \"1 \" TO \"99\".\n*\nSETDD    RSUB\n         ST    R14,DYNRET\n         STM   R0,R12,DYNREG\n*\n         CLI   GRABDDNN+1,C' '\n         BNE   SETDD2\n         CLI   GRABDDNN,C'9'\n         BNE   SETDD1\n         MVC   GRABDDNN,=C'09'\n         B     SETDD2\nSETDD1   PACK  GRABDDNP,GRABDDNN(1)\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN(1),GRABDDNP\n         OI    GRABDDNN,X'F0'                CLEAR THE SIGN\n         B     SETDD3\nSETDD2   DS    0H\n         PACK  GRABDDNP,GRABDDNN\n         AP    GRABDDNP,=P'+1'\n         UNPK  GRABDDNN,GRABDDNP\n         OI    GRABDDNN+1,X'F0'              CLEAR THE SIGN\nSETDD3   DS    0H\n         B     DYNEXIT\n         TITLE '- COMMON SUBROUTINE EXIT'\nDYNEXIT  DS    0H\n         L     R14,DYNRET\n         LM    R0,R12,DYNREG\n         BR    R14\nDYNRET   DS    F                             SUBROUTINE RETURN ADDRESS\nDYNREG   DS    13F                           SUBROUTINE RETURN REGS\n         DROP  ,\n         TITLE '- PARSE VALIDITY-CHECK ON DDN(MEMBER) SYNTAX'\nMEMCK    DS    0H                            VALIDITY-CHECK EXIT\n         USING *,R15\n         USING PDE,R1\n         L     R1,0(R1)                      PDE ADDRESS\n         CLC   PDELEN2,=H'0'                 CHECK FOR MEMBER-NAME\n         BE    MEMCK2\n         CLC   PDELEN,=H'8'\n         BH    MEMCK2\n         XR    R15,R15                       SET GOOD RETURN-CODE\n         BR    R14\nMEMCK2   DS    0H\n         LA    R15,4                         SET ERROR RETURN-CODE\n         BR    R14\n         DROP  R15,R1\n         TITLE '- CONSTANTS'\n         RL\n*\nMESSAGE  DS    0CL(MLTH)\nODDN     DS    CL8\n         DS    C\nOTEXT1   DS    CL(L'MESSAGE1)\nOMEM     DS    CL8\n         DS    C\nOTEXT2   DS    CL(L'MESSAGEF)\nMLTH     EQU   *-ODDN\nMESSAGE1 DC    C'DATASETS SEARCHED - '\nMESSAGEF DC    C'FOUND ON:'\nMESSAGEN DC    C'NOT FOUND'\nMESSAGE2 DC    C'NOT ALLOCATED       '\n*\n         ORG\n         LTORG *\n         TITLE '- WORKING STORAGE'\nRC4      DS    F\nRC1      EQU   RC4+3,1\nCPECB    DS    F\nCPANS    DS    F\nCPUWA    DS    F\n*\nPPLAREA  DS    0A,XL(PPLLEN)\nCPPLAREA DS    0A,XL(CPPLLEN)\n*\nDAPLAREA DS    0A,XL(DAPLLEN)\nDA08AREA DS    0A,XL(DAP08LEN)\nDA18AREA DS    0A,XL(DAP18LEN)\n*\nWORK     DS    CL30                          PPLUWA (NOT USED)\n*\n         ORG   WORK                          REUSE WORK FIELD\nDSNCT    DS    F                             COUNT OF DSNAME1 ARRAY\nDSNH     DS    F                             PROCESS COUNT OF DSNAME1\nHOLDPROF DS    X                             TSO-PROFILE HOLD AREA\nMEMSW    DS    C                             MEMBER FOUND (Y/N)\n*                                                (X=NO DDNAME FOUND)\n         ORG\n*\nREALDD   DC    CL8' '                        TRUE DDNAME\nREALMEM  DC    CL8' '                        TRUE MEMBERNAME\n         DS    0D\nGRABDD   DS    0CL8                          DYNAMIC-ALLOCATE DDNAME\n         DC    CL6'KLIBXX'                   * FIXED PORTION\nGRABDDNN DC    C'0 '                         * VARIABLE DIGITS\n*\nGRABDDNR DS    0PL8                          WORK FIELD FOR SAVE-RC\n         DC    XL6'000000000000'\nGRABDDNP DS    PL2                           WORK FIELD FOR GRABDDNN\n*\nDDNAME1  DS    CL8                           ARRAY FOR 50 DDNAMES\n         DS    49CL8                         * HOLDS KDSNXX.. FOR SAVE\n*                                            * HOLDS DDNLIST FOR RESET\n*\n         DS    0D                            ALIGNMENT FOR COBOL CALL\nDSNAME#  EQU   50\nDSNCTH   DS    H\nDSNAMECT DS    H\nDSNAME1  DS    (DSNAME#)CL44                 ARRAY FOR DSNAME\n*\n         DS    0D                            ALIGNMENT FOR COBOL CALL\nRECORD   DS    0CL44                         INPUT/OUTPUT 'SAVE' RECORD\nRECMEM   DS    CL8                           MEMBER-NAME\nRECDDN   DS    CL8                           ORIGINAL DDNAME\n         DC    CL31' '\n*\n         PRINT NOGEN\n*    DCB FOR SAVE AND RESET PROCESSING (BOTH)\nDYNAMDCB DCB   DDNAME=X,DSORG=PS,MACRF=(PM),RECFM=FB,LRECL=44,         X\n               BLKSIZE=6204\n         PRINT GEN\n         TITLE '- PARSE MACROS'\nPARSECT  IKJPARM\nIDDN     IKJPOSIT DSNAME,LIST,DDNAM,                                   *\n               PROMPT='DDNAME(MEMBER)',VALIDCK=MEMCK,                  *\n               HELP='MEMBER SOUGHT ON LIBRARIES ALLOCATED TO DDNAME'\nISAVE    IKJKEYWD\n         IKJNAME 'SAVE',ALIAS=('SA')\n         IKJENDP\n         TITLE '- DSECTS'\nPDE      DSECT\nPDEADDR  DS    A              ADDRESS OF DDNAME\nPDELEN   DS    H              LENGTH OF  DDNAME\nPDEFLAG  DS    X              FLAGS\n         DS    X              (ALIGNMENT)\nPDEADDR2 DS    A              ADDRESS OF DDNAME\nPDELEN2  DS    H              LENGTH OF  DDNAME\nPDEFLAG2 DS    X              FLAGS\n         DS    X              (ALIGNMENT)\n         DS    CL(8)                         (DSNAME PASSWORD IGNORED)\nPDECHAIN DS    A              ADDRESS OF NEXT PDE IN LIST\n         SPACE\nDEVNAMET DSECT\nDEVNUM   DS    F\nDEVNAME  DS    CL8\nDEVUNIT  DS    XL4\n         SPACE\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         SPACE\n         IKJPPL\nPPLLEN   EQU   *-PPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         SPACE\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         SPACE\n         IKJDAP18\nDAP18LEN EQU   *-DAPB18\n         SPACE\n         PRINT NOGEN\n         CVT   DSECT=YES\n         IHADCB DEVD=DA,DSORG=PS\n         EJECT\n*        COPY  EQUATES\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KSUBS": {"ttr": 7681, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8412                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    WRITTEN AND MAINTAINED BY BRUCE LOMAR, BOB ZIMMERMAN             *\n*    CNA INSURANCE                                                    *\n*                                                                     *\n***********************************************************************\n*    THIS MODULE IS CALLED BY MANY DIALOGS AT CNA - CNA0KED FOR       *\n*    EXAMPLE. IT WILL SEARCH THE TIOT AND UCBS TO FIND DATASETS       *\n*    ALLOCATED, CONTAINS CERTAIN MEMBERS AND DDNAMES.                 *\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RF\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A,&X\n         LCLC  &C\n&X       SETA  N'&SYSLIST\n.LOOPX   AIF   (&X LE 0).MEXIT\n&C       SETC  '&SYSLIST(&X)'\n&X       SETA  &X-1\n         AIF   ('&C' EQ '').LOOPX      SKIP NULL ENTRIES\n.*\n.*  FREE THE REGISTER CURRENTLY IN USE AS &C\n.*\n&A       SETA  2                       LOWEST SUPPORTED REGISTER - 1\n.LOOPA   AIF   (&A GE 12).ERRINUS      12 IS HIGHEST SUPPORTED REGISTER\n&A       SETA  &A+1\n         AIF   ('&EQU(&A)' NE '&C').LOOPA\n.*\n&INUSE(&A) SETB 0                      INDICATE REG NO LONGER IN USE\n&EQU(&A) SETC  ''                      RESET FOR LATER RF MACROS\n         AIF   ('&USING(&A)' EQ '').LOOPX\n&USING(&A) SETC ''\n         DROP  &C                                                     $\n         AGO   .LOOPX\n.*\n.* ERROR MNOTES\n.*\n.ERRINUS MNOTE 4,'REGISTER &C NOT IN USE.'\n         AGO   .LOOPX\n.MEXIT   MEND\n***********************************************************************\n*                                                                     *\n*  AUTHORS AND DATES:                                                 *\n*                                                                     *\n*      MIKE AMLING - ORIGINAL CODE                       ??/??/80 N/A *\n*                                                                     *\n*                                                                     *\n*  MAINTENANCE SUMMARY:                                               *\n*                                                                     *\n*    MIKE AMLING - REVISE TO USE &INUSE(13)               5/ 5/83 MA01*\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n         RG    &S,&T\n         GBLB  &INUSE(13)                                         MA01\n         GBLC  &EQU(12),&USING(12)\n         LCLA  &A\n         LCLC  &C\n         AIF   (N'&SYSLIST LE 2).MULTIX\n         MNOTE 8,'ALL BUT FIRST 2 POSITIONAL PARAMETERS IGNORED.'\n.MULTIX  AIF   (T'&T NE 'O').PAIR\n         AIF   ('&S(3)' NE '').SPEC\n.*\n.*  SEARCH FOR 1 AVAILABLE REGISTER\n.*\n&A       SETA  2                ONE LESS THAN LOWEST SUPPORTED REGISTER\n.LOOP1   ANOP                                                     MA01\n&A       SETA  &A+1\n         AIF   (&INUSE(&A)).LOOP1\n         AIF   (&A GT 12).ERRNORE      IF 3..12 NOT AVAILABLE     MA01\n.*\n.*  SET UP LONE REGISTER OR EVEN REGISTER OF PAIR\n.*\n.TAKEA   ANOP\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&S(1)'                 NOTE NAME FOR RF MACRO\n&C       SETC  '&S(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&S(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n         AIF   ('&S(2)' EQ '').MEXIT\n         USING &S(2),&S(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n&USING(&A) SETC '&S(2)'                NOTE DSECT NAME FOR RCALL MACRO\n.MEXIT   MEXIT\n.*\n.*  SEARCH FOR AN AVAILABLE EVEN/ODD REGISTER PAIR\n.*\n.PAIR    AIF   (N'&S LE 2 AND N'&T LE 2).PAIROVX\n         MNOTE 8,'ASSIGNMENT OVERRIDE IGNORED WHEN REQUESTING PAIR.'\n.PAIROVX ANOP\n&A       SETA  3                       ODD REG OF 1ST PAIR - 2\n.LOOP2   ANOP                                                     MA01\n&A       SETA  &A+2\n         AIF   (&INUSE(&A) OR &INUSE(&A-1)).LOOP2\n         AIF   (&A GT 11).ERRNOPA   11 IS ODD REG OF HIGHEST PAIR MA01\n.*\n.*  SET UP ODD REGISTER OF PAIR\n.*\n&INUSE(&A) SETB 1                      NOTE REGISTER IN USE\n&EQU(&A) SETC  '&T(1)'                 NOTE ODD REG NAME FOR RF MACRO\n&C       SETC  '&T(1)       '(1,8)\n         MNOTE *,'&C EQU   &A'\n&T(1)    EQU   &A                      DEFINE SYMBOL FOR REGISTER     $\n&A       SETA  &A-1                    PRESET FOR DEFINING EVEN REG\n         AIF   ('&T(2)' EQ '').TAKEA\n&USING(&A+1) SETC '&T(2)'              NOTE DSECT NAME FOR RCALL MACRO\n         USING &T(2),&T(1)             TELL ASSEMBLER ABOUT CONTENTS  $\n         AGO   .TAKEA\n.*\n.*  CHECK USER-SPECIFIED REGISTER\n.*\n.SPEC    ANOP\n&A       SETA  K'&S(3)\n.SPCLOOP AIF   (&A LE 0).SPCOK\n         AIF   ('&S(3)'(&A,1) LT '0').ERRSPEC\n&A       SETA  &A-1\n         AGO   .SPCLOOP\n.SPCOK   ANOP\n&A       SETA  &S(3)\n         AIF   (&A LT 3 OR &A GT 12).ERRS312\n         AIF   (NOT &INUSE(&A)).TAKEA\n         AIF   ('&EQU(&A)' EQ '').ERRINU2\n         MNOTE 12,'SPECIFIED REGISTER &A IN USE AS &EQU(&A)'\n         MEXIT\n.ERRINU2 MNOTE 12,'SPECIFIED REGISTER &A IN USE BY CALLING CODE'\n         MEXIT\n.ERRSPEC MNOTE 8,'SPECIFIED REGISTER &S(3) NOT NUMERIC.'\n         MEXIT\n.ERRS312 MNOTE 8,'SPECIFIED REGISTER NOT IN RANGE 3-12.'\n         MEXIT\n.ERRNOPA MNOTE 8,'NO REGISTER PAIR AVAILABLE.'\n         MEXIT\n.ERRNORE MNOTE 8,'NO REGISTER AVAILABLE.'\n         MEND\n         MACRO\n         CNASEND\n         GBLC  &GBLSTRG                NAME OF STORAGE LENGTH\n         GBLC  &GBLSAVE                NAME OF SAVE AREA\n         GBLC  &GBLCNAM                NAME OF CSECT\n         GBLC  &GBLRENT                REENTRANCY OPTION\n         AIF   ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').DONE\n         AIF   ('&SYSECT' EQ '&GBLSAVE').GEN\n         SPACE 1\n&GBLSAVE DSECT ,                       RESUME SAVE AREA DSECT\n.GEN     ANOP\n         SPACE 1\nWORKEND$ DS    0D                      FORCE LENGTH TO DOUBLEWORD\n&GBLSTRG EQU   WORKEND$-&GBLSAVE       SET UP LENGTH EQUATE\n         SPACE 2\n&GBLCNAM CSECT ,                       RESUME CSECT\n.DONE    ANOP\n         MEND\n         MACRO\n         CNASTRG\n         GBLC  &GBLRENT\n         GBLC  &GBLSAVE\n         GBLC  &GBLWTG\n         GBLC  &GBLCESV            DEFINES SAVE AREA FOR NSL'S\n         AIF   ('&GBLRENT' EQ 'NO').DONE\n         AIF   ('&GBLRENT' EQ 'NOSAVE').DONE\n*\n*        WORK AREA DSECT BEGINNING WITH CNASTRG MACRO GENERATION\n*\n&GBLSAVE DSECT\n         DS    18F                 STANDARD SAVE AREA\n         AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').CCH\n         DS    F                   NEXT FREE STACK LOCATION\n         AGO   .DONE\n.CCH     AIF   ('&GBLRENT' NE 'COM' OR '&GBLWTG' EQ '').DONE\n&GBLWTG  DS    F                   NEXT EXECUTION ADDRESS\n.DONE    AIF   ('&GBLCESV' NE 'NSL').NONSL\n         DS    F                   DUMMY FOR STAE EXIT ROUTINE\n         DS    13F                 SAVE AREA FOR NSL ENTRY OPTION\n.NONSL   ANOP\n         MEND\n         MACRO\n&MNAME   CNAEXIT  &RC,&XCTL=,&SPKA=,&EXIT=YES\n.*\n.*       THIS MACRO PROVIDES A COMPANION EXIT MACRO TO\n.*       THE ENTRY MACRO CNAENTER.\n.*\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR CNAENTER AND CNAEXIT\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLCESP            SUBPOOL FOR SAVEAREA FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE FOR RENT=(NEWSTACK,TYPE)\n.*\n.*       LOCAL VARIABLES\n.*\n         LCLA  &LCLBASE            NUMBER OF REG TO GEN R.C. HOLD\n         LCLA  &LCLLOOP            LOOP CONTROL WHILE GENNING ABOVE\n         LCLC  &LCLLABL            STATEMENT LABEL\n         LCLC  &LCLRREG            CHARACTER FORM OF LCLBASE WITH R\n         LCLC  &LCLXNAM            NAME TO XCTL TO\n         LCLC  &LCLXLST            NAME OF XCTL PARM LIST\n         LCLC  &LCLXREG            NAME OF REGISTER FOR MODULE ADDR\n.*\n.*       CHECK THE XCTL= OPERAND\n.*       IT CANNOT BE USED WITH THE RC OPERAND\n.*       THERE ARE THREE FORMS OF THE OPERAND\n.*       XCTL=MODULE-NAME   (OBSOLETE VERSION)\n.*       XCTL=(SF,PLIST-NAME,ROUTINE-ADDRESS-LOCATION)\n.*       XCTL=(I,MODULE-NAME)\n.*\n         AIF   ('&XCTL' EQ '').XCTL1OK          NO XCTL= OPERAND\n         AIF   ('&RC' EQ '').XCTL1A             NO RC OPERAND\n         MNOTE 4,'RETURN CODE AND XCTL= INCOMPATIBLE. RETURN CODE IGNORE\n               ED'\n.XCTL1A  AIF   (N'&XCTL NE 1).XCTL1B\n&LCLXNAM SETC  '&XCTL'                          SET MODULE NAME\n         AGO   .XCTL1OK                         AND END CHECKS\n.XCTL1B  AIF   ('&XCTL(1)' NE 'I').XCTL1C       IS IT INLINE PLIST\n&LCLXNAM SETC  '&XCTL(2)'                       SET MODULE NAME\n         AIF   (N'&XCTL NE 2).XCTL1E1           GENERATE ERROR MESSAGE\n         AGO   .XCTL1OK\n.XCTL1C  AIF   ('&XCTL(1)' NE 'SF' AND '&XCTL(1)' NE 'E').XCTL1E2\n         AIF   ('&XCTL(2)' EQ '').XCTL1D        CHECK IF XCTL PLIST\n&LCLXLST SETC  '&XCTL(2)'                       SET XCTL PARM LIST ADDR\n.XCTL1D  AIF   ('&XCTL(3)' EQ '').XCTL1E        IS A REGISTER SET\n&LCLXREG SETC  '&XCTL(3)'                       SET REGISTER NAME\n.XCTL1E  AIF   (N'&XCTL GT 3).XCTL1E3           TOO MANY OPERANDS\n         AGO   .XCTL1OK                         END CHECKS\n.XCTL1E1 MNOTE 4,'XCTL=(I,PLIST-NAME) MUST HAVE 2 OPERANDS'\n         AGO   .XCTL1OK\n.XCTL1E2 MNOTE 4,'XCTL= FORMS ARE I AND E. XCTL=&XCTL(1) INVALID'\n         AGO   .XCTL1OK\n.XCTL1E3 MNOTE 4,'XCTL= TOO MANY OPERANDS'\n.XCTL1OK ANOP\n.*\n.*       CHECK USAGE OF SPKA OPERAND\n.*\n         AIF   ('&SPKA' EQ '').SPKA1OK    NO SPKA= OPERAND\n         AIF   ('&GBLCESV' NE '').SPKA1OK MUST BE RENT=(NEWSTACK,X)\n         MNOTE 4,'SPKA=&SPKA VALID ONLY FOR RENT=(NEWSTACK,NSL)'\n.SPKA1OK ANOP\n.*\n.***     CHECK USAGE OF THE EXIT=NO OPERAND\n.*\n         AIF   ('&EXIT' EQ 'YES').EXITOK\n         AIF   ('&EXIT' EQ 'NO').EXITC1\n         MNOTE 8,'EXIT=&EXIT VALUE INVALID'\n.EXITC1  ANOP\n         AIF   ('&XCTL' EQ '').EXITC2\n         MNOTE 8,'EXIT=NO INVALID WITH XCTL=&XCTL'\n.EXITC2  AIF   ('&RC' EQ '').EXITOK\n         MNOTE 8,'EXIT=NO INVALID WITH RETURN CODE OPERAND &RC'\n.EXITOK  ANOP\n.*\n.*       RESUME CSECT IF WE HAVE LEFT IT\n.*\n         AIF   ('&GBLCNAM' EQ '&SYSECT').READY\n&GBLCNAM CSECT ,                   RESUME ORIGINAL CSECT\n         SPACE 2\n.READY   ANOP\n.*\n.*       SET STATEMENT LABEL\n.*\n&LCLLABL SETC  '&MNAME'\n.*\n.*       SET UP GLOBALS TO CAUSE DEFAULT IF CNAENTER NOT USED\n.*\n         AIF   (&GBLACTV).ACTIVE\n&GBLRENT SETC  'NO'\n&GBLSAVE SETC  'SAVEAREA'\n         MNOTE 4,'CNAENTER NOT USED - WILL GENERATE FOR NON-REENTRANT'\n.ACTIVE  ANOP\n.*\n.*       THERE ARE TWO FUNDAMENTAL CASES - 1 REQUIRING A FREEMAIN\n.*       AND THE OTHER NOT.  THE FIRST CASE OCCURS WHEN &GBLRENT\n.*       IS 'YES' OR 'NEWSTACK'.  THE OTHER OCCURS WHEN &GBLRENT\n.*       IS 'NO' 'NOSAVE' 'STACK' OR 'COM'.  FIRST SECTION OF MACRO\n.*       DETERMINES WHICH CASE IS PRESENT.\n.*\n         AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'NEWSTACK').FREE\n         AIF   ('&XCTL' NE '').GENXCTL\n.*\n.*       NOW GET THE RETURN CODE INTO R15 IF IT IS NOT IN 15 OR A\n.*       SELF-DEFINING TERM.\n.*\n         AIF   ('&EXIT' EQ 'NO').NFRCSET    CASE - EXIT=NO\n         AIF   ('&RC' EQ '0').NFRCSET       CASE - CNAEXIT 0 OPTIMIZE\n         AIF   ('&XCTL' NE '').NFRCSET      CASE - XCTL OPERAND PRESENT\n         AIF   ('&RC' EQ '').NFRCSET        CASE - NULL DEFAULT 0\n         AIF   ('&RC' EQ '(R15)').NFRCSET   CASE - RC PRESET\n         AIF   ('&RC' EQ '(15)').NFRCSET    CASE - RC PRESET\n         AIF   ('&RC'(1,1) EQ '(').NFREG    CASE - REG FORM\n         AIF   (T'&RC EQ 'N').NFRCSET       CASE - SELF-DEFINING\n&LCLLABL L     R15,&RC             LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''                  NULIFY LABEL COPY\n         AGO   .NFRCSET\n.NFREG   ANOP\n&LCLLABL LR    R15,&RC(1)          LOAD RETURN CODE VALUE\n&LCLLABL SETC  ''\n.*\n.***     R15 LOADED UNLESS SR OR LA TO BE GENERATED\n.*\n.NFRCSET ANOP\n.*\n.*       RESTORE REGISTER 13 FOR NON-REENTRANT CASE\n.*\n         AIF   ('&GBLRENT' EQ 'NOSAVE').NFLR14\n&LCLLABL L     R13,&GBLSAVE+4      RESTORE CALLER'S SAVE AREA\n&LCLLABL SETC  ''\n.*\n.***     REENTER HERE FROM REENTRANT CASE\n.*\n.NFLR14  ANOP\n         AIF   ('&RC' EQ '').NFLR14A           SKIP SUBSTRING IF NO PRM\n         AIF   ('&RC'(1,1) EQ '(').NFLRN0      ALREADY LOADED IF REG.\n         AIF   ('&EXIT' EQ 'NO' OR '&XCTL' NE '').NFLRN0\n         AIF   ('&RC' NE '' AND T'&RC NE 'N').NFLRN0\n.NFLR14A ANOP\n&LCLLABL LM    R14,R12,12(R13)     RESTORE REGISTERS\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLRY0\n         LA    R15,&RC             SET RETURN CODE NOT ZERO\n         AGO   .NFLRN0A\n.NFLRY0  ANOP\n         SR    R15,R15             SET RETURN CODE ZERO\n         AGO   .NFLRN0A\n.*\n.***     NEXT 2 INSTRUCTIONS IF RETURN CODE WAS LEFT IN R15\n.*\n.NFLRN0  ANOP\n&LCLLABL L     R14,12(,R13)        RESTORE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REMAINING REGISTERS\n.NFLRN0A ANOP\n         MVI   12(R13),X'FF'       FLAG AS RETURNED FOR SNAP SVC\n         AIF   ('&EXIT' EQ 'NO').EXITNFN\n         BR    R14                 RETURN TO CALLER\n.EXITNFN ANOP\n         MEXIT\n.*\n.*       REENTRANT CASE - FIRST GET RETURN CODE INTO A REGISTER\n.*       WHICH IS NOT R15 AND IS NOT A BASE REGISTER.  DETERMINE\n.*       WHICH REGISTER FIRST\n.*\n.FREE    AIF   ('&GBLCESV' NE '').GENNSL GO GENERATE SYSTEM CONV.\n         AIF   ('&XCTL' NE '').FRSET   AVOID RETURN CODE LOGIC\n&LCLRREG SETC  '&RC(1)'\n         AIF   ('&RC' EQ '').FRNEED\n         AIF   ('&RC'(1,1) EQ '(' AND '&RC' NE '(R15)').FRSET\n.FRNEED  ANOP\n&LCLBASE SETA  2\n.FRCHECK ANOP\n&LCLLOOP SETA  1\n&LCLRREG SETC  'R&LCLBASE'\n.FRLOOP  ANOP\n         AIF   ('&LCLRREG' EQ '&GBLREGS(&LCLLOOP)').FRRETRY\n&LCLLOOP SETA  &LCLLOOP+1\n         AIF   (&LCLLOOP LE &GBLREG#).FRLOOP\n         AGO   .FRLRC\n.FRRETRY ANOP\n&LCLBASE SETA  &LCLBASE+1\n         AGO   .FRCHECK\n.FRLRC   ANOP\n         AIF   ('&EXIT' EQ 'NO').FRLR SAVE R15 AGAINST FREEMAIN\n         AIF   ('&RC' EQ '0').FRSET  CASE - CNAEXIT 0 OPTIMIZED\n         AIF   ('&XCTL' NE '').FRSET        CASE - XCTL= NO R15\n         AIF   ('&RC' EQ '').FRSET          CASE - NULL DEFAULTS TO 0\n         AIF   ('&RC'(1,1) EQ '(').FRLR     CASE - REGISTER OPERAND\n         AIF   (T'&RC EQ 'N').FRSET         CASE - GENERATE LA INSTRUCT\n&LCLLABL L     &LCLRREG,&RC        LOAD RETURN CODE VALUE\n&LCLLABL SETC ''\n         AGO   .FRSET\n.FRLR    ANOP\n&LCLLABL LR    &LCLRREG,&RC(1)     SAVE RETURN CODE OVER FREEMAIN\n&LCLLABL SETC  ''\n.FRSET   ANOP\n&LCLLABL LR    R1,R13              SET ADDRESS TO FREE\n&LCLLABL SETC  ''\n         L     R13,&GBLSAVE+4      GET CALLER'S SAVE AREA\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').FRSTACK\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTRG,SP=&GBLCESP\n         AGO   .NFSET15\n.FRSTACK ANOP\n DC 0C'  FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP' FREEMAIN ISSUED\n         FREEMAIN R,A=(1),LV=&GBLSTCK,SP=&GBLCESP\n.NFSET15 AIF   ('&XCTL' NE '').GENXCTL     GENERATE XCTL EXIT CODE\n         AIF   ('&RC' EQ '' OR '&RC' EQ '0').NFLR14\n         AIF   ('&RC'(1,1) EQ '(').FRSET15\n         AIF   (T'&RC EQ 'N').NFLR14\n.FRSET15 ANOP\n         LR    R15,&LCLRREG        SET RETURN CODE INTO PROPER REG\n         AGO   .NFLR14\n.*\n.*       GENERATE FOR RENT=(NEWSTACK,NSL),SPKA=\n.*\n.GENNSL  ANOP\n&LCLLABL CNOP  0,4\n&LCLLABL SETC  ''\n         L     R0,*+8              LOAD SUBPOOL AND LENGTH\n         B     *+8                 SKIP INLINE CONSTANT\n         DC    AL1(&GBLCESP),AL3(&GBLSTCK)\n         LA    R1,0(,R13)          POINT AT STACK\n         LM    R2,R14,80(R13)      RESTORE OPEN/CLOSE/EOV REGS\n         SVC   10                  ISSUE FREEMAIN SVC DIRECTLY\n         AIF   ('&SPKA' EQ '').NSL1B\n         SPKA  &SPKA               RETURN TO SUPERVISOR KEY\n.NSL1B   AIF   ('&EXIT' EQ 'NO').MEND  IF EXIT=NO, GET OUT QUICKLY\n         AIF   ('&LCLXREG' EQ '').NSL1C SKIP BRANCH TEST IF NOT REQ\n         ICM   R15,15,&LCLXREG     CHECK FOR EP IN THIS LOAD MODULE\n         BNZR  R15                 AND GO TO IT IF PRESENT\n.NSL1C   AIF   ('&LCLXNAM' NE '').XCTL2B GEN INLINE LIST XCTL\n   DC 0C'XCTL  SF=(E,&LCLXLST)'\n         XCTL  SF=(E,&LCLXLST)\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC6)\n.*\n.SVC6GEN AIF   ('&GBLCESV' NE 'SVC6').SVC5GEN TRY SVC15\n         MNOTE 12,'RENT=(NEWSTACK,SVC6) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR RENT=(NEWSTACK,SVC15)\n.*\n.SVC5GEN AIF   ('&GBLCESV' NE 'SVC15').SVCXGEN TRY NEW PARM\n         MNOTE 12,'RENT=(NEWSTACK,SVC15) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE ERROR MESSAGE FOR UNRECOGNIZED &GBLCESV VALUE'\n.*\n.SVCXGEN MNOTE 12,'RENT=(NEWSTACK,&GBLCESV) NOT SUPPORTED BY CNAEXIT'\n         MEXIT\n.*\n.*       GENERATE XCTL=(I,MODULE-NAME) VERSION OF XCTL\n.*\n.GENXCTL LM    R14,R12,12(R13)     RESTORE CALLERS REGISTERS\n.XCTL2B  CNOP  2,4                 INSURE CONSTANT ALIGNMENT\n         BALR  R15,0               SET NEW ADDRESSABILITY\n         PUSH  USING               SAVE PREVIOUS ENVIRONMENT\n         DROP  ,                   AVOID ADDRESSING PROBLEMS\n         USING *,R15               AND TELL THE ASSEMBLER THE TRUTH\n         L     R15,*+16            GET ADDRESS OF NEXT ROUTINE\n         LTR   R15,R15             IS IT IN THIS MODULE\n         BNZR  R15                 YES, GO TO IT DIRECTLY\n         BALR  R15,0               NO, RESET ADDRESSABILITY\n         USING *,R15               TELL THE ASSEMBLER AGAIN\n         LA    R15,*+10            POINT AT XCTL SF= LIST\n         XCTL  SF=(E,(15))         AND GO TO PROGRAM WITH ASSIST\n         WXTRN &LCLXNAM            DECLARE AS WEAK EXTERNAL REFERENCE\n         DC    A(&LCLXNAM)         IF LINKEDITED IN\n         XCTL  EP=&LCLXNAM,SF=L    BUILD XCTL PARAMETER LIST\n         POP   USING               GET USERS ENVIRONMENT BACK\n.MEND    ANOP                        WAY TO BRANCH OUT\n         MEND\n         MACRO\n&MNAME   CNAENTER  &BASES,         BASE REGISTER LIST                  X\n               &CBASE=DR12,        REGISTER ADDRESSING COMMON          X\n               &ENTRY=DYES,        GENERATE ENTRY STATEMENT (WITH NAME)X\n               &ID=DYES,           FULL, NONE OR DATELESS ID           X\n               &PARM=DR2,          WHERE TO PUT PARM LIST POINTER      X\n               &PLOAD=,            HOW TO SET UP PARAMETER POINTERS    X\n               &RENT=DYES,         REENTRANCY OR NOT AND TYPE          X\n               &SAVE=YES,          SHOULD REGISTERS BE SAVED           X\n               &SCLEAR=DNO,        SHOULD SAVE AREA BE CLEARED?        X\n               &SNAME=,            NAME OF SAVE/WORK AREA              X\n               &SP=,               SUBPOOL FOR SAVE AREA               X\n               &SPKA=,             SET PROTECT KEY                     X\n               &STACK=D2048,       SIZE OF STACK FOR NEWSTACK OPTION   X\n               &STORAGE=DWORKLEN,  LENGTH OF STORAGE TO OBTAIN         X\n               &WCLEAR=DNO,        SHOULD WORK AREA BE CLEARED?        X\n               &WTG=D              WHERE TO GO FIELD NAME\n.*\n.*       DECLARE GLOBAL SYMBOLS USED FOR MULTIPLE INVOCATIONS AND\n.*       THE CNAEXIT MACRO\n.*\n         GBLA  &GBLREG#            NUMBER OF BASE REGISTERS\n         GBLA  &GBLQCNT            NUMBER OF Q ADDRESS CONSTANTS\n         GBLB  &GBLACTV            MACRO HAS BEEN INVOKED BEFORE\n         GBLB  &GBLSCLR            CLEAR SAVE AREA OPTION\n         GBLB  &GBLWCLR            WORK AREA CLEAR OPTION\n         GBLC  &GBLREGS(5)         BASE REGISTER VALUES\n         GBLC  &GBLUSNG            BASE REGS WITH COMMAS FOR USING\n         GBLC  &GBLID              ID OPTION\n         GBLC  &GBLPARM            PARM OPTION\n         GBLC  &GBLRENT            RENT OPTION\n         GBLC  &GBLRSVE            SAVE REGISTERS OPTION (YES OR NO)\n         GBLC  &GBLSAVE            SNAME OPTION\n         GBLC  &GBLSTRG            STORAGE OPTION\n         GBLC  &GBLSTCK            SIZE OF STACK\n         GBLC  &GBLCNAM            CSECT NAME\n         GBLC  &GBLQNAM(20)        UP TO 20 Q NAMES\n         GBLC  &GBLWTG             WTG OPERAND OF 1ST ENTRY\n         GBLC  &GBLCBAS            COMMON BASE REGISTER\n         GBLC  &GBLCESP            SUBPOOL FOR GETMAIN AND FREEMAIN\n         GBLC  &GBLCESV            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         GBLC  &CNASPFL            LEVEL NUMBER FROM SPF LIBRARY\n         GBLC  &CNASPFD            DATE OF LAST MODIFICATION\n         GBLC  &CNASPFU            USERID OF LAST UPDATER\n.*\n.*       LOCAL SYMBOLS USED\n.*\n         LCLA  &LCLREG#            NUMBER OF ENTRIES IN &BASES\n         LCLA  &LCLSUB1            DESTINATION SUBSCRIPT\n         LCLA  &LCLSUB2            SOURCE SUBSCRIPT\n         LCLA  &LCLIDSZ            SIZE OF ID CONSTANTS\n         LCLA  &LCLIDLN            &LCLIDSZ-1\n         LCLA  &LCLCONS            LENGTH OF ALL CONSTANTS\n         LCLA  &LCLFILL            SIZE TO ALIGN SAVE AREA\n         LCLA  &LCLWORK            ARITHMETIC WORK\n         LCLA  &LCLPLUS            OFFSET CALCULATIONS\n         LCLA  &LCLOFFS            OFFSET TO ENTRY OFFSET\n         LCLA  &LCLSTRL            OFFSET TO STORAGE VALUE FOR STACKING\n         LCLA  &LCLPRML            NUMBER OF VALUES TO PLOAD OPERAND\n         LCLB  &LCLOFF             ON FOR 2ND-NTH ENTRIES\n         LCLB  &LCLRENT            IS SOME FORM OF REENTRANCY IN?\n         LCLB  &LCLENTR            IS ENTRY STATEMENT NEEDED?\n         LCLB  &LCLSCLR            CLEAR SAVE AREA THIS ENTRY?\n         LCLB  &LCLWCLR            CLEAR WORK AREA THIS ENTRY?\n         LCLC  &LCLENAM            NAME FOR ENTRY STATEMENT\n         LCLC  &LCLPARM            NAME FOR KEEPING R1\n         LCLC  &LCLCHAR            CHARACTER WORK FIELD\n         LCLC  &LCLSTRG            STORAGE THIS TIME THHROUGH\n         LCLC  &LCLID              ID OPTION FOR THIS CALL\n         LCLC  &LCLSVCT            SVC TYPE - SVCR6, SVCR15, NSL, NULL\n         LCLC  &LCLTBAS            ENTRY POINT BASE FOR FIRST INSTRS.\n.*\n.*       IF THIS IS THE FIRST ENTRY, EDIT THE VALUES GIVEN\n.*\n         AIF   (&GBLACTV).NTH\n&GBLACTV SETB  (1)               SET FOR NEXT TIME IN\n&GBLCNAM SETC  '&SYSECT'           SET CSECT NAME\n.*\n.*       EDIT THE REENTRANCY OPTION  (FIRST SUBPARAMETER)\n.*\n         AIF   ('&RENT(1)' EQ 'DYES').DRENT\n&LCLCHAR SETC  '&RENT(1)'\n&LCLRENT SETB  ('&LCLCHAR' EQ 'YES'   OR '&LCLCHAR' EQ 'NEWSTACK' OR   *\n                '&LCLCHAR' EQ 'STACK' OR '&LCLCHAR' EQ 'NOSAVE'   OR   *\n                '&LCLCHAR' EQ 'COM')\n         AIF   (&LCLRENT OR '&LCLCHAR' EQ 'NO').RENTOK\n         MNOTE 4,'&RENT IS AN INVALID REENTRANCY OPTION - YES USED.'\n.DRENT   ANOP\n&GBLRENT SETC  'YES'\n&LCLRENT SETB  (1)\n         AGO   .RENTOVR\n.RENTOK  ANOP\n&GBLRENT SETC  '&RENT(1)'\n.*\n.*       EDIT THE WTG OPERAND IF &GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').RENTOVR\n         AIF   ('&WTG' EQ 'D').RENTWTX     NO WTG TYPE PROCESSING\n&GBLWTG  SETC  '&WTG'\n         AIF   ('&GBLWTG' NE '').RENTWTX\n         MNOTE *,'WTG OPERAND NULLIFIED - NO WTG CODE GENERATED'\n.RENTWTX ANOP\n         AIF   ('&CBASE' EQ 'DR12').DEFCBAS\n         AIF   ('&CBASE' NE '').ASGNCBS\n         MNOTE 8,'COMMON BASE NEEDED TO RELOCATE WORK AREA - R12 USED.'\n.DEFCBAS ANOP\n&GBLCBAS SETC  'R12'\n         AGO   .RENTOVR\n.ASGNCBS ANOP\n&GBLCBAS SETC  '&CBASE'\n.RENTOVR ANOP\n.*\n.*       EDIT THE SECOND RENT OPERAND.  THIS IS VALID ONLY IF THE\n.*       RENT=NEWSTACK OPERAND IS CODED, AND MUST HAVE ONE OF THE\n.*       VALUES 'SVCR6' 'SVCR15' 'NSL' OR NULL.\n.*\n&LCLTBAS SETC  'R15'                           ASSUME R15 AS ENTRY\n         AIF   ('&RENT(2)' EQ '').RNT2END      NO SVC OPTION CODED\n         AIF   ('&RENT(1)' NE 'NEWSTACK').RNT2E1 ERROR IF NOT NEWSTACK\n         AIF   ('&RENT(2)' NE 'SVCR6' AND '&RENT(2)' NE 'SVCR15' AND   X\n               '&RENT(2)' NE 'NSL').RNT2E2     NOT VALID ENTRYS\n&GBLCESV SETC  '&RENT(2)'                      SET TYPE OF SVC ENTRY\n&LCLSVCT SETC  '&RENT(2)'                      SET IT IN LOCAL\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2END R15 IS RIGHT\n&LCLTBAS SETC  'R6'                            SET R6 AS ENTRY BASE\n         AGO   .RNT2END\n.RNT2E1  MNOTE 8,'SECOND RENT= OPERAND ONLY VALID WITH NEWSTACK'\n         AGO   .RNT2END\n.RNT2E2  MNOTE 8,'SECOND RENT= OPERAND MUST BE SVCR6, SVCR15, OR NSL'\n.RNT2END ANOP\n.*\n.*       EDIT THE SPKA OPERAND.  IT IS ONLY VALID IF SECOND RENT\n.*       OPTION IS USED.  IT IS USED ONLY IF SPECIFIED ON THE MACRO\n.*\n         AIF   ('&SPKA' EQ '').RNT3END\n         AIF   ('&GBLCESV' NE '').RNT3END  SKIP IF 2ND RENT SPEC'D\n         MNOTE 4,'SPKA= OPERAND NOT VALID IF 2ND RENT OPTION OMITTED'\n.RNT3END ANOP\n.*\n.*       EDIT THE SAVE OPERAND.  THIS MUST BE YES UNLESS RENT=\n.*       NO OR NOSAVE WAS ENTERED.  THEN IT MAY BE NO.\n.*\n&GBLRSVE SETC  'YES'                FORCE DEFAULT VALUE\n         AIF ('&SAVE' EQ 'YES').RSAVEOK\n         AIF ('&SAVE' NE 'NO').RSAVEX1\n         AIF ('&GBLRENT' EQ 'NO' OR '&GBLRENT' EQ 'NOSAVE').RSAVEOK\n         MNOTE 8,'SAVE=NO ONLY ALLOWED WITH RENT=NO OR RENT=NOSAVE'\n         AGO   .RSAVEXL\n.RSAVEX1 MNOTE 8,'SAVE= MUST BE YES OR NO'\n         AGO   .RSAVEXL\n.RSAVEOK ANOP\n&GBLRSVE SETC  '&SAVE'\n.RSAVEXL ANOP\n.*\n.*       EDIT THE STACK OPERAND - SHOULD BE D2048 UNLESS\n.*       &GBLRENT=NEWSTACK.  IN THAT CASE, SET &GBLSTCK\n.*       TO VALUE OF STACK OPERAND.  MULTIPLY BY 1024 IF\n.*       ALL NUMERIC EXCEPT TERMINAL K.\n.*\n         AIF   ('&GBLRENT' EQ 'NEWSTACK').NSEDIT\n         AIF   ('&STACK' EQ 'D2048').STACKX\n         MNOTE 4,'STACK= IGNORED SINCE RENT=NEWSTACK NOT SPECIFIED'\n         AGO   .STACKX\n.NSEDIT  ANOP\n&LCLWORK SETA  K'&STACK\n         AIF   ('&STACK'(&LCLWORK,1) EQ 'K' AND &LCLWORK GT 1).KVAL\n         AIF   ('&STACK' NE 'D2048').ASGNSTK\n&GBLSTCK SETC  '2048'\n         AGO   .STACKX\n.KVAL    ANOP\n&LCLCHAR SETC  '&STACK'(1,&LCLWORK-1)\n.KVALOOP ANOP\n&LCLWORK SETA  &LCLWORK-1\n         AIF   ('&LCLCHAR'(&LCLWORK,1) LT '0').ASGNSTK\n         AIF   (&LCLWORK GT 1).KVALOOP\n&GBLSTCK SETC  '&LCLCHAR*1024'\n         AGO   .STACKX\n.ASGNSTK ANOP\n&GBLSTCK SETC  '&STACK'\n.STACKX  ANOP\n.*\n.*       EDIT THE BASE REGISTER SET AND SET UP GBLREG#, GBLREGS AND\n.*       GBLUSNG.\n.*\n&LCLREG# SETA  N'&BASES\n&GBLREG# SETA  &LCLREG#\n&LCLSUB1 SETA  1\n&LCLSUB2 SETA  1\n         AIF   (&LCLRENT).OK#\n&GBLREG# SETA  &GBLREG#+1          INCREMENT FOR R13 ADDITION\n&GBLREGS(1) SETC 'R13'\n&LCLSUB1 SETA  2\n.OK#     ANOP\n         AIF   (&GBLREG# GT 0).OKCOPY\n         MNOTE 8,'NO BASE REGISTERS SPECIFIED - WILL USE R11'\n&GBLREG# SETA  1\n&GBLREGS(1) SETC 'R11'\n.OKCOPY  AIF   (&LCLSUB2 GT &LCLREG#).COPUSNG\n&GBLREGS(&LCLSUB1) SETC '&BASES(&LCLSUB2)'\n&LCLSUB1 SETA  &LCLSUB1+1\n&LCLSUB2 SETA  &LCLSUB2+1\n         AGO   .OKCOPY\n.COPUSNG ANOP\n&GBLUSNG SETC  ',&GBLREGS(1)'\n         AIF   (&GBLREG# LE 1).ID\n&LCLSUB1 SETA  2\n         AIF   ('&LCLSVCT' NE '').ERRSVC1\n.UCOPY   AIF   (&LCLSUB1 GT &GBLREG#).ID\n&GBLUSNG SETC  '&GBLUSNG,&GBLREGS(&LCLSUB1)'\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .UCOPY\n.ERRSVC1 MNOTE 4,'ONLY 1 BASE REGISTER SUPPORTED FOR SVC TYPE &LCLSVCT'\n.*\n.*       EDIT THE IDENTIFICATION OPTION - DEFAULT IS DYES(YES)-IF SPEC\n.*       IS NOT YES, NO, NODATE OR SHORT, SET TO SHORT\n.*\n.ID      AIF   ('&ID' EQ 'DYES').DID\n         AIF   ('&ID' EQ 'YES').IDOK\n         AIF   ('&ID' EQ 'NO').IDOK\n         AIF   ('&ID' EQ 'NODATE').IDOK\n         AIF   ('&ID' EQ 'SHORT').IDOK\n         MNOTE 4,'&ID IS AN INVALID IDENTIFICATION OPTION - SHORT USED'\n&GBLID   SETC  'SHORT'\n&LCLID   SETC  'SHORT'\n         AGO   .PRM\n.DID     ANOP\n&GBLID   SETC  'YES'\n&LCLID   SETC  'YES'\n         AGO   .PRM\n.IDOK    ANOP\n&GBLID   SETC  '&ID'\n&LCLID   SETC  '&ID'\n.*\n.*       EDIT THE PARM OPERAND - SET R2 IF OMITTED\n.*\n.PRM     AIF   ('&PARM' EQ 'DR2').DPARM\n         AIF   ('&PARM' NE '').SETPRM\n         MNOTE *,'INPUT PARAMETER LIST POINTER WILL BE IN R2'\n.DPARM   ANOP\n&GBLPARM SETC  'R2'\n&LCLPARM SETC  'R2'\n         AGO   .ENT\n.SETPRM  ANOP\n&GBLPARM SETC  '&PARM'\n&LCLPARM SETC  '&PARM'\n.*\n.*       EDIT THE ENTRY= OPERAND - VALID VALUES ARE YES, NO AND\n.*       (YES,NAME) - IF YES, &MNAME MUST NOT BE NULL - SET NO\n.*       IF INVALID VALUE OR YES AND NO &MNAME\n.*\n.ENT     ANOP\n&LCLENAM SETC  '&MNAME'                  SET LOCAL NAME TO MACRO\n         AIF   ('&MNAME' NE '').ENTNOK   YES, LET IT DEFAULT\n&LCLENAM SETC  '&SYSECT'                 MUST BE AT START OF MACRO\n.ENTNOK  AIF   ('&ENTRY' EQ 'DYES').EYES\n         AIF   ('&ENTRY' EQ 'YES').EYES\n         AIF   ('&ENTRY' EQ 'NO').SNAME\n         AIF   ('&ENTRY(1)' EQ 'YES').ENAME\n         MNOTE 4,'&ENTRY INVALID ENTRY OPTION - NO USED'\n         AGO   .SNAME\n.EOMIT   MNOTE 8,'ENTRY NAME OMITTED - WILL USE NAME FIELD OF CNAENTER X\n               MACRO IF PRESENT'\n.EYES    AIF   ('&MNAME' EQ '').ENONE\n&LCLENAM SETC  '&MNAME'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENAME   AIF   ('&ENTRY(2)' EQ '').EOMIT\n&LCLENAM SETC  '&ENTRY(2)'\n&LCLENTR SETB  (1)\n         AGO   .SNAME\n.ENONE   MNOTE 8,'ENTRY=YES CANCELLED BECAUSE THERE IS NO NAME ON THE MX\n               ACRO'\n.*\n.*       SET THE GLOBAL SAVEVAL TO BE SAVE/WORK AREA NAME FROM\n.*       SNAME= OPERAND.  DEFAULT TO WORKAREA OR SAVEAREA\n.*       DEPENDING ON REENTRANCY OPTION\n.*\n.SNAME   AIF   ('&SNAME' EQ '').SNDEF\n&GBLSAVE SETC  '&SNAME'\n         AGO   .QCONCK\n.SNDEF   ANOP\n&GBLSAVE SETC  'WORKAREA'\n         AIF   (&LCLRENT).QCONCK\n&GBLSAVE SETC  'SAVEAREA'\n.QCONCK  AIF   ('&GBLRENT' NE 'COM').SCLR\n         CNADXD &GBLSAVE\n&GBLSAVE SETC  '&GBLQNAM(&GBLQCNT)'\n.*\n.*       SET THE GLOBAL CLEARS\n.*\n.SCLR    ANOP\n&GBLSCLR SETB  ('&SCLEAR' EQ 'YES')\n&LCLSCLR SETB  (&GBLSCLR)\n.*\n.*       SET THE GLOBAL CLEARW\n.*\n&GBLWCLR SETB  ('&WCLEAR' EQ 'YES')\n&LCLWCLR SETB  (&GBLWCLR)\n.*\n.*       SET GLOBAL STRGVAL FROM STORAGE= - NULL ALLOWED FOR NON-RENT\n.*\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         AIF   ('&STORAGE' EQ 'DWORKLEN').EDITSP\n&GBLSTRG SETC  '&STORAGE'\n&LCLSTRG SETC  '&STORAGE'\n         AIF   ('&GBLSTRG' NE '').EDITSP\n         AIF   (NOT &LCLRENT).CALC\n         AIF   ('&RENT(1)' EQ 'NOSAVE').EDITSP\n&GBLSTRG SETC  'WORKLEN'\n&LCLSTRG SETC  'WORKLEN'\n         MNOTE 8,'STORAGE= NULLIFIED BUT VALUE REQUIRED - WORKLEN USED'\n.*\n.*  EDIT THE SP= PARAMETER (SUBPOOL = )\n.*\n.EDITSP  ANOP\n&GBLCESP SETC '0'            DEFAULT IT TO SUBPOOL 0\n         AIF  ('&SP' EQ '').CALC  ACCEPT THE DEFAULT\n&GBLCESP SETC '&SP'          SET THE OPERAND VALUE\n         AGO  .CALC\n.*\n.*\n.*\n.*       EDIT SUPPLIED OPERANDS AGAINST GLOBAL VALUES USED IN FIRST\n.*       INVOCATION OF CNAENTER\n.*\n.*\n.*\n.NTH     ANOP\n.*\n.*       SET UP LOCAL ITEMS TO MATCH GLOBALS FOR FIRST APPROXIMATION\n.*\n&LCLSCLR SETB  (&GBLSCLR)\n&LCLWCLR SETB  (&GBLWCLR)\n&LCLPARM SETC  '&GBLPARM'\n&LCLID   SETC  '&GBLID'\n&LCLSTRG SETC  '&GBLSTRG'\n&LCLOFF  SETB  (1)\n&LCLSVCT SETC  '&GBLCESV'             SVC TYPE\n&LCLTBAS SETC  'R15'                  TEMPORARY BASE IS R15\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2L1\n&LCLTBAS SETC  'R6'                   TEMPORARY BASE IS R6 FOR SVCR6\n.RNT2L1  ANOP\n.*\n.*       IGNORE ANY DESIGNATION OF BASE REGISTERS\n.*\n         AIF   (N'&BASES EQ 0).RENTR\n         MNOTE 4,'BASE REGISTERS IGNORED - WILL USE SAME AS ON 1ST CALLX\n                TO CNAENTER - &GBLREGS(1) IS FIRST BASE'\n.*\n.*       THE ENTRY ATTRIBUTE MUST BE ASSUMED ELSE WHY ANOTHER ENTRY?\n.*\n.RENTR   AIF   ('&ENTRY' EQ 'DYES' OR '&ENTRY' EQ 'YES').RSETM\n         AIF   ('&ENTRY(2)' NE '').RSET2\n         MNOTE 8,'&ENTRY INVALID FOR THIS CALL - YES USED AND NAME ON MX\n               ACRO WILL BE ENTRY NAME'\n.RSETM   AIF   ('&MNAME' NE '').RSETM2\n         MNOTE 8,'MACRO NAME REQUIRED FOR ENTRY POINT - ####$$$$ USED'\n&LCLENAM SETC  '####$$$$'\n         AGO   .RENTSET\n.RSET2   ANOP\n&LCLENAM SETC  '&ENTRY(2)'\n         AGO   .RENTSET\n.RSETM2  ANOP\n&LCLENAM SETC  '&MNAME'\n.RENTSET ANOP\n&LCLENTR SETB  (1)\n.*\n.*       ID VALUE RESET TO CONTAIN NO DATE SPECIFICATION IF YES\n.*       CURRENTLY IN EFFECT\n.*\n         AIF   ('&LCLID' NE 'YES').CKIDOVR\n&LCLID   SETC  'NODATE'\n.CKIDOVR AIF   ('&ID' EQ 'DYES').RPRM\n         AIF   ('&ID' EQ 'YES').LCLYES\n         AIF   ('&ID' EQ 'SHORT').LCLYES\n         AIF   ('&ID' EQ 'NODATE').LCLYES\n         AIF   ('&ID' EQ 'NO').LCLYES\n         MNOTE 4,'&ID INVALID FOR ID= - VALUE &LCLID USED.'\n         AGO   .RPRM\n.LCLYES  ANOP\n&LCLID   SETC  '&ID'\n.*\n.*       SEE IF PARM REGISTER TO BE OVERRIDEN FOR THIS ENTRY\n.*\n.RPRM    ANOP\n         AIF   ('&PARM' EQ 'DR2').RRENT\n&LCLPARM SETC  '&PARM'\n.*\n.*       FLUSH RENT OPTION IF CODED - USE ORIGINAL\n.*\n.RRENT   AIF   ('&RENT(1)' EQ 'DYES').RSWRCK\n         AIF   ('&RENT(1)' EQ '&GBLRENT').RSWRCK\n         MNOTE 4,'&RENT REENTRANCY OPTION IGNORED - &GBLRENT FROM FIRSTX\n               USE OF CNAENTER USED.'\n.RSWRCK  ANOP\n.*\n.*       SET &LCLRENT FOR PROPER GEN TYPE\n.*\n&LCLRENT SETB  ('&GBLRENT' EQ 'YES'   OR '&GBLRENT' EQ 'NEWSTACK' OR   *\n                '&GBLRENT' EQ 'STACK' OR '&GBLRENT' EQ 'NOSAVE' OR     *\n                '&GBLRENT' EQ 'COM')\n.*\n.*       EDIT SPKA OPTION. ONLY VALID IF 2ND RENT OPTION CODED\n.*\n         AIF  ('&SPKA' EQ '' OR '&GBLCESV' NE '').RNT4OK\n         MNOTE 4,'SPKA=&SPKA IGNORED IF 2ND RENT OPTION NOT CODED'\n.RNT4OK  ANOP\n.*\n.*       EDIT WTG OPERAND IF GBLRENT=COM\n.*\n         AIF   ('&GBLRENT' NE 'COM').NOCBAS\n         AIF   ('&GBLWTG' EQ '').NLWTG\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '&GBLWTG').NOWTGE\n         MNOTE 8,'&WTG WTG ENTRY IGNORED - &GBLWTG USED'\n         AGO   .NOWTGE\n.NLWTG   ANOP\n         AIF   ('&WTG' EQ 'D' OR '&WTG' EQ '').NOWTGE\n         MNOTE 8,'NO WTG CODE GENERATED DUE TO FIRST ENTRY CONDITIONS'\n.NOWTGE  ANOP\n         AIF   ('&CBASE' EQ 'DR12' OR '&CBASE' EQ '&GBLCBAS').NOCBAS\n         MNOTE 8,'COMMON BASE CODED IGNORED - &GBLCBAS USED'\n.NOCBAS  ANOP\n.*\n.*       RESET LOCAL VALUE OF CLEAR SWITHCES IF NOT DEFAULTED\n.*\n         AIF   ('&SCLEAR' EQ 'DNO').CKWCLR\n&LCLSCLR SETB  ('&SCLEAR' EQ 'YES')\n.CKWCLR  AIF   ('&WCLEAR' EQ 'DNO').RSN\n&LCLWCLR SETB  ('&WCLEAR' EQ 'YES')\n.*\n.*       SAVE AREA NAME MUST REMAIN CONSTANT OVER INVOCATIONS\n.*\n.RSN     AIF   ('&SNAME' EQ '').RSTRG\n         AIF   ('&SNAME' EQ '&GBLSAVE').RSTRG\n         MNOTE 8,'&SNAME WILL NOT BE USED FOR SAVE/WORK AREA NAME - &GBL\n               LSAVE WILL BE USED INSTEAD'\n.*\n.*       STORAGE VALUE CAN ONLY CHANGE FOR RENT=NEWSTACK OR RENT=STACK\n.*\n.RSTRG   AIF   ('&STORAGE' EQ 'DWORKLEN').CALC\n         AIF   ('&STORAGE' EQ '&GBLSTRG').CALC\n         AIF   ('&GBLRENT' EQ 'NEWSTACK' OR '&GBLRENT' EQ 'STACK').REST\n        MNOTE 8,'UNABLE TO CHANGE STORAGE LENGTH - VALUE &GBLSTRG USED'\n         AGO   .CALC\n.REST    ANOP\n&LCLSTRG SETC  '&STORAGE'\n.*\n.*\n.*\n.*       COMMON MACRO SET UP AND OFFSET CALCULATION\n.*\n.*\n.*    ID=    NO     SHORT   NODATE    YES     ENTRY=  (SPFID)  FIRST?\n.*\n.*            0       10      10       24       NO       NO      ---\n.*\n.*                            28       28       YES      ---     NO\n.*\n.*                            28       42       YES      NO      YES\n.*\n.*                            34       48       NO       YES     ---\n.*\n.*                            52       66       YES      YES     YES\n.*\n.*\n.CALC    ANOP\n&LCLIDSZ SETA  0\n         AIF   ('&LCLID' EQ 'NO').NOSPFID\n&LCLIDSZ SETA  10\n         AIF   ('&LCLID' EQ 'SHORT').NOSPFID  NO ID OR DATES\n         AIF   (NOT &LCLENTR AND NOT &LCLOFF).IDLEN\n&LCLIDSZ SETA  &LCLIDSZ+18           FOR ENTRY=YES\n.IDLEN   AIF   (&LCLOFF).NOSPFID     NO DATES FOR 2ND ENTRY\n         AIF   ('&LCLID' EQ 'NODATE').CALCND  NO DATE - MAY BE SPF\n&LCLIDSZ SETA  &LCLIDSZ+14           FOR ASSEMBLY DATE AND TIME\n.CALCND  AIF   ('&CNASPFL' EQ '').NOSPFID       SKIP IF NO SPF DATA\n&LCLIDSZ SETA  &LCLIDSZ+24         LENGTH OF SPF SOURCE DATA\n.NOSPFID ANOP\n&LCLIDLN SETA  &LCLIDSZ-1\n.*\n.*       SIZE OF ID CONSTANTS CALCULATED - CALCULATE TOTAL\n.*       CONSTANT SIZE BY ADDING 2 FOR STORAGE CALCULATION\n.*       FOR STACKING, 2 FOR OFFSET FOR BASE 1 CALCULATION\n.*       AND 72 PLUS ALIGNMENT FILLER FOR IN-LINE SAVE AREAS.\n.*\n&LCLCONS SETA  &LCLIDSZ\n&LCLPLUS SETA  4\n         AIF   (NOT &LCLOFF).NOFF\n&LCLCONS SETA  &LCLCONS+2         ADD FOR BASE 1 OFFSET\n&LCLOFFS SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.NOFF    AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').N\n&LCLCONS SETA  &LCLCONS+2         ADD FOR STORAGE OFFSET\n&LCLSTRL SETA  &LCLIDSZ+&LCLPLUS\n&LCLPLUS SETA  &LCLPLUS+2\n.N       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOSAVE\n&LCLWORK SETA  &LCLCONS/4\n&LCLWORK SETA  &LCLWORK*4\n&LCLFILL SETA  &LCLWORK+4-&LCLCONS\n         AIF   (&LCLFILL LT 4).FSET\n&LCLFILL SETA  0\n.FSET    ANOP\n&LCLCONS SETA  &LCLCONS+&LCLFILL+72\n.*\n.*\n.*       CALCULATIONS ARE DONE ... BEGIN CODE GENERATION\n.*\n.*\n.NOSAVE  ANOP\n         AIF   (NOT &LCLOFF).NOALGN\n         CNOP  0,8                 FORCE DOUBLE WORD ALIGNMENT\n.NOALGN  AIF   (NOT &LCLENTR).NEGE\n&LCLENAM DS    0H                  ENTRY POINT NAME\n         ENTRY &LCLENAM            EXTERNAL DECLARATION\n.NEGE    AIF   ('&MNAME' EQ '').NNAME\n         AIF   ('&LCLENAM' EQ '&MNAME' AND &LCLENTR).NNAME\n&MNAME   DS    0H                  ENTRY POINT NAME\n.NNAME   ANOP\n         USING *,&LCLTBAS          TEMPORARY BASE\n         AIF   (&LCLCONS EQ 0).NOCONS\n&LCLWORK SETA  &LCLCONS+4\n         B     *+&LCLWORK          BRANCH AROUND ALL CONSTANTS\n         AIF   (&LCLIDSZ EQ 0).NOIDSZ\n         DC    AL1(&LCLIDLN)       LENGTH OF ID FIELDS\n         AIF   (NOT &LCLENTR).NOECON\n         DC    CL9'&LCLENAM'       ENTRY NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         DC    CL9'IN CSECT '\n.NOECON  DC    CL9'&SYSECT'        CSECT NAME IN ID FIELDS\n         AIF   (&LCLIDSZ EQ 10).NOIDSZ\n         AIF   (&LCLOFF).NOIDSZ    SKIP BOTH TIME AND SPF DATA FOR 2ND\n         AIF   ('&LCLID' EQ 'NODATE').SPFID1\n         DC    CL9'&SYSDATE'       ASSEMBLY DATE IN ID FIELDS\n         DC    CL5'&SYSTIME'       ASSEMBLY TIME IN ID FIELDS\n.SPFID1  AIF   ('&CNASPFD' EQ '').NOIDSZ INSERT SPF DATA\n         DC    CL8' &CNASPFD'      DATE OF THIS MODIFICATION\n         DC    CL8'&CNASPFL'       LEVEL NUMBER OF THIS VERSION\n         DC    CL8'&CNASPFU'       TSO USERID OF LAST UPDATER\n.NOIDSZ  AIF   (NOT &LCLOFF).STCKCK\n         AIF   ('&GBLRENT' EQ 'NO').SAOFF\n         DC    Y(&LCLENAM-&SYSECT) OFFSET TO MODULE BASE\n         AGO   .STCKCK\n.SAOFF   DC    Y(&LCLENAM-&GBLSAVE) OFFSET TO MODULE BASE\n.STCKCK  AIF   ('&GBLRENT' NE 'STACK' AND '&GBLRENT' NE 'NEWSTACK').F\n         DC    Y(&LCLSTRG)         WORK AREA SIZE FROM STACK\n.F       AIF   ('&GBLRENT' NE 'NO' OR &LCLOFF).NOCONS\n         AIF   (&LCLFILL EQ 0).NOFILL\n         DC    XL(&LCLFILL)'00'    FILLER TO ALIGN SAVE AREA\n.NOFILL  ANOP\n&GBLSAVE DC    18F'0'              MODULE'S SAVE AREA\n.NOCONS  ANOP\n         SPACE 2\n.*\n.*             GENERATE CODE FOR SVC ENTRY OPTIONS\n.*\n         AIF   ('&LCLSVCT' EQ '').RNT2GND   NO SVC ENTRY, GO TO STD.\n         AIF   ('&LCLSVCT' EQ 'SVCR6').RNT2G1 DON'T SAVE BASE REGISTER\n         AIF   ('&LCLSVCT' EQ 'NSL').RNT2G1  LIKEWISE FOR NSL OPTION\n         LR    R3,&LCLTBAS         SAVE TEMPORARY BASE\n         DROP  &LCLTBAS\n         USING &LCLENAM,R3\n&LCLTBAS SETC  'R3'                RESET TEMPORARY BASE\n.RNT2G1  AIF   ('&SPKA' EQ '').RNT2G1A      SKIP IF NO SPKA OPTION\n         AIF   ('&SPKA' NE 'DATAMGT').USERSPK\n         SPKA  80                  SET DATAMGT PROTECT KEY\n         AGO   .RNT2G1A\n.USERSPK SPKA  &SPKA               SET PROTECT KEY FOR USER\n.RNT2G1A ANOP\n  DS  0C'GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP' GET NEW STACK\n         GETMAIN R,LV=&GBLSTCK,SP=&GBLCESP\n         AIF   ('&LCLSVCT' NE 'NSL').RNT2G2  SKIP SAVE IF NOT NSL\n         STM   R2,R14,80(R1)       SAVE OPEN/CLOSE/EOV REGS (EX. R3)\n         LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         BALR  &GBLREGS(1),0       GET LOCATION\n         LA    R15,*-&SYSECT       CALCULATE CORRECT BASE\n         SLR   &GBLREGS(1),R15      --> 4K MODULE LIMIT <--\n         AGO   .RNT2G3             SKIP OTHER OPTION FIDDLING\n.RNT2G2  LR    R13,R1              SET SAVEAREA IN PROPER BASE\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS' AND NOT &LCLOFF).RNT2G3A\n         AIF   ('&GBLREGS(1)' EQ '&LCLTBAS').RNT2G2A\n         LR    &GBLREGS(1),&LCLTBAS SET PERMANENT BASE REGISTER\n.RNT2G2A AIF   (NOT &LCLOFF).RNT2G3      SKIP IF NOT SECOND ENTRY\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS ADJUST THE BASE REGISTER\n.RNT2G3  DROP  &LCLTBAS            RESET ADDRESSING\n         USING &SYSECT&GBLUSNG     SET USING FOR PROGRAM\n.RNT2G3A LH    R15,&LCLENAM+&LCLSTRL SET ADDRESS OF NEXT\n         AR    R15,R13              WORKAREA IN THE STACK\n         ST    R15,72(,R13)         FOR RENT=STACK PROCESSING\n         XC    4(8,R13),4(R13)      CLEAR BACK AND FOREWARD POINTERS\n         USING &GBLSAVE,R13         DECLARE DSA\n         AIF   ('&LCLSVCT' NE 'SVCR6').RNT2G4 IS IT R6 ENTRY\n         LM    R0,R1,32(R5)         RESTORE PARAMETER REGS FROM\n         L     R15,92(R5)           SVRB SAVEAREA\n.RNT2G4  SPACE 2\n         MEXIT\n.RNT2GND ANOP\n.*\n.*             NOW GENERATE FOR NON SVC ENTRY OPTIONS\n.*\n         AIF   ('&GBLRSVE' EQ 'NO').RSVE#1\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         AGO   .RSVE#2\n.RSVE#1  LR    R3,R14              SAVE R14 FOR RETURN\n.RSVE#2  LR    &LCLPARM,R1         SAVE INPUT PARAMETER LIST PTR.\n         AIF   (&LCLRENT).RBASES\n         AIF   (&LCLOFF).SOFFBAS\n         LA    R15,&GBLSAVE        WILL BE BASE AND S.A. POINTER\n.NRBAS   ST    R13,4(,R15)         SET BACK CHAIN\n         ST    R15,8(,R13)         SET FORWARD CHAIN\n         LR    R13,R15             SET BASE AND S.A. POINTER\n         DROP  R15                 END TEMPORARY ADDRESSING\n         USING &GBLSAVE&GBLUSNG    PERMANENT ADDRESSING\n         AGO   .NTHBASE\n.SOFFBAS ANOP\n         SH    R15,&LCLENAM+&LCLOFFS WILL BE BASE AND S.A. POINTER\n         AGO   .NRBAS\n.RBASES  LR    &GBLREGS(1),R15     SET 1ST BASE REGISTER\n         AIF   (NOT &LCLOFF).ROFFBAS\n         SH    &GBLREGS(1),&LCLENAM+&LCLOFFS RESET BACK TO ORIGIN\n.ROFFBAS DROP  R15                 END TEMPORARY ADDRESSING\n         USING &SYSECT&GBLUSNG     PERMANENT ADDRESSING\n.NTHBASE AIF   (&GBLREG# LE 1).NTHSET\n&LCLSUB1 SETA  2\n&LCLSUB2 SETA  1\n         LA    R14,2048            CONSTANT FOR NTH BASE GENERATION\n.NTHGENR AIF   (&LCLSUB1 GT &GBLREG#).NTHSET\n         LA    &GBLREGS(&LCLSUB1),2048(R14,&GBLREGS(&LCLSUB2).)\n&LCLSUB2 SETA  &LCLSUB1\n&LCLSUB1 SETA  &LCLSUB1+1\n         AGO   .NTHGENR\n.NTHSET  ANOP\n         SPACE 2\n         AIF   ('&GBLRENT' EQ 'NO').PL\n         AIF   ('&GBLRENT' EQ 'NOSAVE').PL\n         AIF   ('&GBLRENT' EQ 'YES').GET\n         AIF   ('&GBLRENT' EQ 'STACK').STACK\n         AIF   ('&GBLRENT' EQ 'COM').COMGET\n*                                  GET STACK\n         GETMAIN  R,LV=&GBLSTCK,SP=&GBLCESP\n         AGO   .FWDCHN\n.STACK   ANOP\n         L     R1,72(,R13)         GET NEXT AREA ORIGIN IN STACK\n         AGO   .FWDCHN\n.GET     ANOP\n*                                  GET WORKING STORAGE\n         GETMAIN  R,LV=&LCLSTRG,SP=&GBLCESP\n         AGO   .FWDCHN\n.COMGET  ANOP\n         L     R1,Q&GBLQNAM(1)     GET OFFSET TO WORK AREA\n         AR    R1,&GBLCBAS         ADJUST TO ADDRESS\n.FWDCHN  ST    R1,8(,R13)          SET FORWARD CHAIN\n         AIF   (NOT &LCLWCLR).SCLRCK\n         LR    R14,R1              ADDRESS TO BEGIN CLEAR\n         AIF   ('&GBLRENT' EQ 'YES').CLRLC\n         AIF   (&LCLENTR).LHENTR\n         LH    R15,&SYSECT+&LCLSTRL LENGTH OF CLEAR\n         AGO   .CLRCMN\n.CLRLC   LH    R15,*+8             LENGTH OF CLEAR\n         B     *+6                 AROUND CONSTANT\n         DC    Y(&LCLSTRG)         SIZE OF WORK AREA\n         AGO   .CLRCMN\n.LHENTR  LH    R15,&LCLENAM+&LCLSTRL LENGTH OF CLEAR\n.CLRCMN  SR    R1,R1               FILL CHARACTER IS X'00'\n         MVCL  R14,R0              CLEAR THE WORK AREA\n         L     R1,8(,R13)          RELOAD CURRENT WORK POINTER\n         AGO   .CLRD\n.SCLRCK  AIF   (NOT &LCLSCLR).CLRD\n         XC    0(72,R1),0(R1)      CLEAR THE SAVE AREA\n.CLRD    AIF   ('&GBLRENT' EQ 'YES' OR '&GBLRENT' EQ 'COM').NOSTKS\n         AIF   (&LCLENTR).LENENTR\n         LH    R15,&SYSECT+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n         AGO   .BLDSTKN\n.LENENTR LH    R15,&LCLENAM+&LCLSTRL SIZE OF AREA NEEDED IN STACK\n.BLDSTKN AR    R15,R1              R15 IS NEXT FREE SLOT IN STACK\n         ST    R15,72(,R1)         SET FOR NEXT MODULE TO FIND\n.NOSTKS  AIF   ('&GBLRSVE' EQ 'NO').NRSV#3\n         ST    R13,4(,R1)          SET BACK CHAIN\n         LM    R13,R1,8(R13)       RESTORE CLOBBERED REGISTERS\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n         AGO   .PL                 GO CHECK FOR PARAMETER LIST SAVE\n.NRSV#3  LR    R13,R1              SET WORK AREA REGISTER\n         USING &GBLSAVE,R13        TELL ASSEMBLER ABOUT REGISTER\n.PL      AIF   ('&PLOAD' EQ '').DONE\n&LCLPRML SETA  N'&PLOAD\n&LCLWORK SETA  1\n         SPACE 2\n.PLLOOP  CNAPLOAD &PLOAD(&LCLWORK),&LCLWORK,&LCLPARM\n&LCLWORK SETA  &LCLWORK+1\n         AIF   (&LCLWORK LE &LCLPRML).PLLOOP\n.DONE    AIF   ('&GBLRENT' NE 'COM').DONE1\n         AIF   ('&GBLWTG' EQ '').DONE1\n         ICM   R15,15,&GBLWTG         PICK UP WHERE TO GO ADDRESS\n         BNZR  R15                    GO THERE IF INITIALIZED\n.DONE1   ANOP\n         SPACE 2\n         MEND\nKDSNDDN  TITLE 'SUBROUTINE: FIND DSNAME OR DDNAME OR MEMBER'\nKDSNDDN  CSECT\n         RG    (RBASE,,12)\n         RG    (RARG)\n         RG    (RCOUNT)\n         RG    (RARRAY)\n         RG    (RPARM)\n*                                                                     *\n*  TECHNICAL NOTES:                                                   *\n*     1. PROGRAM IS REENTRANT.                                        *\n*     2. \"DDD\" SERVICE USED FOR ALLOCATE/FREE OF LIBRARIES FOR BLDL   *\n*        DURING MEMBER-SEARCH FUNCTION.                               *\n*     3. THREE ENTRYPOINTS ARE USED (LINKEDITED WITH THREE ALIASES).  *\n*     4. THREE PARAMETERS ARE RECEIVED AT EACH ENTRYPOINT;            *\n*        LAST TWO PARAMETERS ARE UPDATED BY SUBROUTINE:               *\n*           SEARCH-ARGUMENT                                           *\n*           ARRAY ROW-COUNTER                                         *\n*           ARRAY                                                     *\n*        NOTE: \"KSNSUB\" ENTRY HAS AN OPTIONAL 4TH PARAMETER.          *\n*     5. RETURN-CODES:                                                *\n*              0 = SUCCESSFUL SEARCH (\"HITS\" FOUND).                  *\n*              4 = SUCCESSFUL SEARCH (\"HITS\" FOUND); ARRAY OVERFLOW.  *\n*              8 = UNSUCCESSFUL SEARCH (NO \"HITS\" FOUND).             *\n         EJECT\n*                                                                     *\n*     KDSNSUB PARAMETERS ARE:                                         *\n*           SEARCH-ARGUMENT   (8-BYTE DDNAME)                         *\n*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *\n*                              DSNAMES FOUND)                         *\n*           ARRAY             (N X 44-BYTE ARRAY FOR DSNAMES)         *\n*           ARRAY             (N X 6-BYTE ARRAY FOR VOLSERS;OPTIONAL) *\nKDSNSUB  CNAENTER RBASE,PARM=RPARM,RENT=YES\n         MVI   FUNC,C'1'\n         B     DOIT\n         EJECT\n*                                                                     *\n*     KDDNSUB PARAMETERS ARE:                                         *\n*           SEARCH-ARGUMENT   (44-BYTE DSNAME)                        *\n*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *\n*                              DDNAMES FOUND)                         *\n*           ARRAY             (N X 10-BYTE ARRAY FOR DDNAMES;         *\n*                              ARRAY ROW FORMAT:                      *\n*                              8-BYTE DDNAME                          *\n*                              HALFWORD BINARY CONCATENATION SEQUENCE *\n*                                   (0 = DSNAME IS NOT CONCATENATED)) *\nKDDNSUB  CNAENTER PARM=RPARM,RENT=YES\n         MVI   FUNC,C'2'\n         B     DOIT\n         EJECT\n*                                                                     *\n*     KMEMSUB PARAMETERS ARE:                                         *\n*           SEARCH-ARGUMENT   (8-BYTE MEMBER NAME)                    *\n*           ARRAY ROW-COUNTER (HALFWORD BINARY; UPDATED TO NUMBER OF  *\n*                              \"HITS\" FOUND)                          *\n*           ARRAY             (N X 44-BYTE ARRAY FILLED WITH DSNAMES; *\n*                              \"NO-HIT\" DSNAMES ARE BLANKED-OUT IN    *\n*                              PLACE).                                *\nKMEMSUB  CNAENTER PARM=RPARM,RENT=YES\n         MVI   FUNC,C'3'\n         B     DOIT\n         EJECT\nDOIT     DS    0H\n         XC    RC4,RC4\n         LM    RARG,RARRAY,0(RPARM)          GRAB 3 ENTRY PARAMETERS\n         XC    HOLDVOL,HOLDVOL               CLEAR\n         TM    8(RPARM),X'80'                TEST FOR 4TH PARAMETER\n         BO    *+10                          BR IF NOT PRESENT\n         MVC   HOLDVOL,12(RPARM)             COPY 4TH-PARM ADDRESS\n         NI    HOLDVOL,X'EF'                 CLEAR VL-BIT\n         RF    RPARM                         FREE PARM-POINTER\n         CLI   FUNC,C'3'                     MEMBER-TEST?\n         BE    SEARCH3                       BR IF YES\n*              CLEAR RESULTS-ARRAY FOR DSN/DDN SEARCH\n         RG    (RWORK1A),(RWORK1B)\n         RG    (RWORK2A),(RWORK2B)\n         XR    RWORK2A,RWORK2A\n         XR    RWORK2B,RWORK2B\n         ICM   RWORK2B,8,=C' '               BLANK-FILL CHAR\n         LH    RWORK1B,0(RCOUNT)             GET ARRAY COUNTER\n         LA    RWORK1A,44                    MULTIPLY BY 44\n         CLI   FUNC,C'2'                     DDN-SEARCH?\n         BNE   *+8                           BR IF YES\n         LA    RWORK1A,10                    MULTIPLY BY 10\n         MR    RWORK1A,RWORK1A               MULTIPLY BY ARRAY COUNTER\n         LR    RWORK1A,RARRAY                SET ARRAY ADDRESS\n         MVCL  RWORK1A,RWORK2A               CLEAR RESULTS ARRAY\n*\n         RF    RWORK1A,RWORK1B\n         RF    RWORK2A,RWORK2B\n         RG    (RTALLY)\n*\nSEARCH12 DS    0H\n         RG    (RTCB)                        TCB MAP\n         RG    (RTIOT)                       TIOT MAP\n         L     RTCB,540(R0)                  POINT TO TCBOLD\n         L     RTIOT,12(RTCB)                POINT TO TIOT (TCBTIO)\n         RF    RTCB                          DONE WITH TCB\n         RG    RTIOTLN                       TCB DDNAME ENTRY LENGTH\n         XR    RTIOTLN,RTIOTLN\n         LA    RTIOT,24(RTIOT)               POINT TO 1ST DDNAME ENTRY\n         XR    R0,R0                         CLEAR FOR RESULTS COUNT\n         LH    RTALLY,0(RCOUNT)              ARRAY COUNTER\n         LA    RTALLY,1(RTALLY)                PLUS 1 FOR BCT\n         CLI   FUNC,C'2'                     DDNAME SEARCH?\n         BE    DSLOOK                        BR IF YES\n         EJECT\n*              FIND DSNAMES FOR A DDNAME\nDDLOOK   DS    0H                            FIND INITIAL DDNAME ENTRY\n         RG    RVOL\n         L     RVOL,HOLDVOL                  GET VOLSER ARRAY ADDR\n         CLI   0(RTIOT),X'00'\n         BE    DONEDDN                       BR IF DDNAME NOT FOUND\n         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH\n         CLC   0(8,RARG),4(RTIOT)            COMPARE INPUT TO TIOEDDNM\n         BE    GOTDDN                        BR IF FOUND\n         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY\n         B     DDLOOK\nGOTDDN   DS    0H\n         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT\n         B     NOROOM                        BR IF NO ROOM IN ARRAY\n         A     R0,=F'1'                      ADD TO \"HIT\" COUNT\n         TM    3(RTIOT),X'20'                TEST TIOELINK FOR DA(*)\n         BZ    NOTTERM                       BR TO GET DSNAME\n         MVC   0(8,RARRAY),=C'TERMFILE '\n         B     VOLTST\nNOTTERM  DS    0H\n         TM    3(RTIOT),X'02'\n         BZ    NOTSYSO\n         MVC   0(8,RARRAY),=C'JESFILE '\n         B     VOLTST\nNOTSYSO  DS    0H\n         L     R1,12(RTIOT)                  PICK UP JFCB ADDRESS\n         SRL   R1,8                          SHIFT TO CLEAR TIOESTTC\n         MVC   0(44,RARRAY),16(R1)           PICK UP DSNAME\nVOLTST   DS    0H\n         LTR   RVOL,RVOL                     VOLSERS WANTED?\n         BZ    NEXTDSN                       BR IF NO\n         MVC   0(6,RVOL),=CL6' '\n         CLC   0(8,RARRAY),=CL8'NULLFILE'\n         BE    BUMPVOL\n         CLC   0(8,RARRAY),=CL8'TERMFILE'\n         BE    BUMPVOL\n         CLC   0(8,RARRAY),=CL8'JESFILE'\n         BE    BUMPVOL\n         L     R1,16(RTIOT)                  GET UCB ADDRESS\n         USING IEFUCBOB,1\n         MVC   0(6,RVOL),UCBVOLI             GRAB VOLSER\n         DROP  1\nBUMPVOL  LA    RVOL,6(RVOL)                  BUMP TO NEXT VOL SLOT\nNEXTDSN  DS    0H\n         LA    RARRAY,44(RARRAY)             BUMP TO NEXT DSN SLOT\n         LA    RTIOT,0(RTIOTLN,RTIOT)        LOOP TO NEXT ENTRY\n         CLI   0(RTIOT),X'00'\n         BE    DONEDDN\n         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH\n         CLC   4(8,RTIOT),=CL8' '            TEST FOR CONCAT DSNAMES\n         BE    GOTDDN                        BR IF FOUND\n         B     DONEDDN\n         RF    RVOL\n         EJECT\n*              FIND DDNAMES FOR A DSNAME\nDSLOOK   DS    0H                            FIND INITIAL DDNAME ENTRY\n         CLI   0(RTIOT),X'00'\n         BE    DONEDDN                       BR IF DDNAME NOT FOUND\n         IC    RTIOTLN,0(RTIOT)              PICK UP TIOELNGH\n         CLI   4(RTIOT),C' '                 CONCATENATION?\n         BE    BUMPDD                        BR IF YES\n         MVC   REALDD,4(RTIOT)               GET CURRENT DDNAME\n         XC    CONCAT,CONCAT                 ZERO CONCAT COUNTER\n         L     R1,FOURBLANK\n         CL    R1,4(RTIOTLN,RTIOT)           NEXT DDN BLANK?\n         BNE   SKIPDD                        BR TO BYPASS CONCAT COUNT\nBUMPDD   DS    0H\n         LH    R1,CONCAT\n         LA    R1,1(R1)                      ADD 1 TO CONCAT COUNTER\n         STH   R1,CONCAT\nSKIPDD   DS    0H\n         TM    1(RTIOT),X'80'                TEST FOR INELIGIBLE ENTRY\n         BO    SKIPDD2                       BR IF FOUND\nCKTERM   DS    0H\n         CLC   0(9,RARG),=C'TERMFILE '       CHECK FOR SPECIAL ARGUMENT\n         BNE   CKSYSOUT                      BR IF FALSE\n         TM    3(RTIOT),X'20'                DOES TIOT ENTRY MATCH?\n         BO    GOTDSN                        BR IF TRUE\n         B     SKIPDD2                       SKIP THIS ENTRY\nCKSYSOUT DS    0H\n         CLC   0(8,RARG),=C'JESFILE '        CHECK FOR SPECIAL ARGUMENT\n         BNE   CKNULL                        BR IF FALSE\n         TM    3(RTIOT),X'02'                DOES TIOT ENTRY MATCH?\n         BO    GOTDSN                        BR IF TRUE\n         B     SKIPDD2                       SKIP THIS ENTRY\nCKNULL   DS    0H\n         CLC   0(9,RARG),=C'NULLFILE '       CHECK FOR SPECIAL ARGUMENT\n         BNE   CKDSN                         BR IF FALSE\n         TM    3(RTIOT),X'22'                IS TIOT ENTRY JES OR TERM?\n         BM    SKIPDD2                       BR IF TRUE TO SKIP ENTRY\nCKDSN    DS    0H\n         L     R1,12(RTIOT)                  PICK UP JFCB ADDRESS\n         SRL   R1,8                          SHIFT TO CLEAR TIOESTTC\n         CLC   0(44,RARG),16(R1)             COMPARE INPUT TO JFCB DSN\n         BE    GOTDSN                        BR IF FOUND\nSKIPDD2  DS    0H\n         LA    RTIOT,0(RTIOTLN,RTIOT)        SET TO NEXT ENTRY\n         B     DSLOOK\nGOTDSN   DS    0H\n         BCT   RTALLY,*+8                    DECREASE ARRAY COUNT\n         B     NOROOM                        BR IF NO ROOM IN ARRAY\n         A     R0,=F'1'                      ADD TO \"HIT\" COUNT\n         MVC   0(8,RARRAY),REALDD            PICK UP DDNAME\n         MVC   8(2,RARRAY),CONCAT            PICK UP CONCAT COUNTER\n         LA    RARRAY,10(RARRAY)             BUMP TO NEXT DDN SLOT\n         LA    RTIOT,0(RTIOTLN,RTIOT)        LOOP TO NEXT ENTRY\n         CLI   0(RTIOT),X'00'\n         BE    DONEDDN\n         B     DSLOOK\n         EJECT\n*\n*** SEARCH ARRAY FILLED ... PREPARE FOR EXIT\n*\nNOROOM   DS    0H\n         RF    RTIOT,RTIOTLN\n         MVI   RC1,4                         SET OVERFLOW RETURN-CODE\nDONEDDN  DS    0H\n         STH   R0,0(RCOUNT)                  SAVE DSN COUNT\n         LTR   R0,R0                         ANY HITS?\n         BNZ   FASTEXIT                      BR IF YES\n         MVI   RC1,8                         SET NO-HIT RETURN-CODE\n         B     FASTEXIT\n         EJECT\n*\n*** LOOP EACH DSNAME TO BLDL AGAINST MEMBER NAME\n*\nSEARCH3  DS    0H\n         RG    RWORK\n         XR    RWORK,RWORK\n         LH    RTALLY,0(RCOUNT)              WORKING DSN COUNT\n         MVC   DTBL1,=H'1'                   NO. OF BLDL ENTRIES\n         MVC   DTBLLTH,=H'12'                BLDL ENTRY LENGTH\n         MVC   DTBLMEM,0(RARG)               SET MEMBER FOR BLDL\n         MVC   PDSDCB(CDCBLTH),CONDCB        MOVE DCB TO GETMAIN AREA\n         MVC   LOPEN(COPNLTH),CONOPEN\n         MVC   LCLOSE(CCLSLTH),CONCLOS\nKMEMTEMP FREE  EXIT=FINDMEM\nFINDMEM  DS    0H\n*\nKMEMTEMP DDD   DSN=0(RARRAY)@,DISP=SHR,EXIT=NOMEM\n*\n         LA    R2,PDSDCB\n         OPEN  ((2),(INPUT)),MF=(E,LOPEN)    OPEN FOR BLDL\n         BLDL  (2),DTBL                      TEST FOR MEMBER\n         ST    R15,DTBLRET                   SAVE RETURN-CODE\n         CLOSE ((2)),MF=(E,LCLOSE)           CLEANUP AFTER BLDL\n         L     R15,DTBLRET                   TEST BLDL RETURN-CODE\n         LTR   R15,R15\n         BZ    YESMEM                        BR IF FOUND\nNOMEM    DS    0H\n         MVC   0(44,RARRAY),=CL44' '         BLANK DSNAME IF NOT FOUND\n         B     LOOPMEM\nYESMEM   DS    0H\n         A     RWORK,=F'1'                   COUNT HITS\nLOOPMEM  DS    0H\n*\nKMEMTEMP FREE  EXIT=LOOPMEM2\n*\nLOOPMEM2 LA    RARRAY,44(RARRAY)\n         BCT   RTALLY,FINDMEM                   PROCESSED DSNAME\n         STH   RWORK,0(RCOUNT)               SET COUNT OF HITS\n         LTR   RWORK,RWORK\n         BNZ   FASTEXIT                      BR IF HITS\n         MVI   RC1,8                         SET \"NO-HIT\" RETURN CODE\n         B     FASTEXIT\n         EJECT\n         RF    RWORK,RTALLY,RARG,RCOUNT,RARRAY\n         EJECT\n*\n*** PROGRAM EXIT\n*\nFASTEXIT CNAEXIT RC4\n         TITLE '- SUBROUTINES'\n         DDDD  CODE\n         TITLE '- CONSTANTS'\n         DS    0D\nFOURBLANK DC   CL4' '\n*    DCB FOR BLDL PROCESSING\n         PRINT NOGEN\nCONDCB   DCB   DDNAME=KMEMTEMP,DSORG=PO,MACRF=(R)\nCDCBLTH  EQU   *-CONDCB\nCONOPEN  OPEN  (,INPUT),MF=L\nCOPNLTH  EQU   *-CONOPEN\nCONCLOS  CLOSE (,),MF=L\nCCLSLTH  EQU   *-CONCLOS\n         PRINT GEN\n         LTORG *\n         TITLE '- WORKING STORAGE'\n         CNASTRG\nRC4      DS    F\nRC1      EQU   RC4+3,1\nCONCAT   DS    H\nFUNC     DS    C\nHOLDVOL  DS    A\n*\n         DS    0F\nREALDD   DS    CL8                           DDNAME HOLD FOR DSLOOK\n*\nDTBL     DS    0F                            BLDL WORK AREA\nDTBL1    DS    H                             # ENTRIES\nDTBLLTH  DS    H                             ENTRY LENGTH\nDTBLMEM  DS    CL8\nDTBLRET  DS    F\n*\n         DDDD  STORAGE\n*\nPDSDCB   DS    0A,CL(CDCBLTH)\nLOPEN    DS    0A,CL(COPNLTH)\nLCLOSE   DS    0A,CL(CCLSLTH)\n         CNASEND\n         TITLE '- DSECTS'\n         PRINT NOGEN\n         IHADCB DEVD=DA,DSORG=PS\nIEFUCBOB DSECT\n         IEFUCBOB\n         EJECT\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOCINDEX": {"ttr": 8199, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***      CODE  FROM LAMVSUG                               *LBD 07/84*\n*                                                         *LBD 07/84*\nLOC      TITLE 'LOCINDEX - SUPERLOCATE ROUTINE FOR MVS '    *HMD 04/82*\n*        LOCINDEX SUBROUTINE REPLACEMENT FOR MVS\n*        THIS ROUTINE SUPPORTS 'LEVEL' OPTIONS OF THE 'LISTS' COMMAND\n*             AND IS USED BY OTHER YCC VARIATIONS OF THAT PROGRAM\n*        FOLLOWING IS ORIGINAL LOCINDEX DESCRIPTION:\n*.....................................................................*\n*.                                                                   .*\n*.   LOCINDEX                                                        .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   1.0  GENERAL DESCRIPTION                                        .*\n*.                                                                   .*\n*.   THIS SUBROUTINE IS USED TO RETURN DSNAMES AND THE VOLSER        .*\n*.   FOR A SPECIFIED INDEX STRUCTURE.  THE INDEX STRUCTURE CAN BE    .*\n*.   SPECIFIED AS SEVERAL HIGH-LEVEL QUALIFIERS OR IT CAN BE A       .*\n*.   DSNAME CONTAINING ONE EMBEDDED ASTERISK NOT AS THE HIGH-LEVEL   .*\n*.   QUALIFIER.                                                      .*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.....................................................................*\n*.                                                                   .*\n*.   2.0  PARAMETER LIST AND RETURN CODE DESCRIPTION                 .*\n*.                                                                   .*\n*.   THE PARAMETER LIST IS A FOUR OR FIVE WORD LIST CONTAINING THE   .*\n*.   FOLLOWING:                                                      .*\n*.                                                                   .*\n*.    WORD         DESCRIPTION                                       .*\n*.                                                                   .*\n*.      1          ADDRESS OF THE 44-BYTE FIELD CONTAINING THE       .*\n*.                 INDEX STRUCTURE.                                  .*\n*.      2          ADDRESS OF THE 44-BYTE FIELD INTO WHICH           .*\n*.                 LOCINDEX WILL PLACE THE DSNAME.                   .*\n*.      3          ADDRESS OF THE 6-BYTE FIELD INTO WHICH            .*\n*.                 LOCINDEX WILL PLACE THE VOLSER OF THE DATASET.    .*\n*.      4          ADDRESS OF A 4K WORK AREA TO BE USED BY           .*\n*.                 LOCINDEX FOR STORING CATALOG BLOCKS.              .*\n*.      5          OPTIONAL FIELD FOR THE ADDRESS OF A FULLWORD      .*\n*.                 OF STORAGE ON AN INTEGRAL BOUNDARY INTO WHICH     .*\n*.                 LOCINDEX WILL STORE THE RETURN CODE.              .*\n*.                                                                   .*\n*.   THE HIGH ORDER BIT OF THE LAST WORD OF THE PARAMETER LIST       .*\n*.   MUST BE SET ON.                                                 .*\n*.                                                                   .*\n*.    RETURN CODE  MEANING                                           .*\n*.                                                                   .*\n*.         0       A DSNAME WAS FOUND AND THE DATASET RESIDES ON     .*\n*.                 A DISK VOLUME.                                    .*\n*.         4       THE INDEX STRUCTURE WAS NOT FOUND.                .*\n*.         8       A DSNAME WAS FOUND AND THE DATASET RESIDES ON     .*\n*.                 A TAPE VOLUME.                                    .*\n*.        12       A DSNAME WAS FOUND BUT IT RESIDES ON MULTIPLE     .*\n*.                 VOLUMES.                                          .*\n*.        16       THERE ARE NO MORE DATASETS FOR THIS INDEX         .*\n*.                 STRUCTURE.                                        .*\n*.        20       AN I/O ERROR WAS DETECTED ON THE CATALOG.         .*\n*.        24       ERROR WAS DETECTED IN SVC26 WHOSE CAUSE COULD     .*\n*.                 NOT BE DETERMINED. NOTIFY SYSTEMS PROGRAMMER.     .*\n*.....................................................................*\n*\n*        THE PRIMARY DIFFERENCES BETWEEN THE MVS VERSION\n*        AND THE OS VERSION ARE:\n*              1) THE PART ABOVE THE ASTERISK IS PASSED TO VSAM\n*                 GENERIC LOCATE AND WORKS HOWEVER GENERIC LOCATE\n*                 LOCATE WORKS. ONLY NON-VSAM DATASETS ARE PASSED\n*                 BACK TO THE CALLER.\n*              2) THE CHARACTERS BELOW THE ASTERISK MUST APPEAR\n*                 IN THE DATASET NAME ANYWHERE AFTER THE SEARCH\n*                 KEY CHARACTERS. THEY MAY CONTAIN LEADING\n*                 AND TRAILING PARTIAL INDEX LEVELS.\n*              3) THE AMOUNT OF STORAGE REQUIRED FOR A VSAM GENERIC\n*                 LOCATE IS MUCH MORE THAN THE 4K AREA PROVIDED BY\n*                 THE OS CALLER. A 64K AREA IS GETMAINED AND ITS\n*                 ADDRESS IS STORED IN THE FIRST WORK OF THE 4K\n*                 CALLER WORK AREA. IT IS FREEMAINED WHEN THE\n*                 RETURN CODE OF 16 SIGNALS THE END OF DATASETS\n*                 UNDER THIS INDEX.\n*              5) THE 265 BYTE CAMLIST WORK AREA IS PUT IN THE\n*                 CALLER PROVIDED WORK AREA AT OFFSET 4. THIS\n*                 ALLOWS ACCESS TO THE COMPLETE VOLUME LIST.\n         EJECT\nLOCINDEX CSECT\n         USING *,15\n         SAVE  (14,12),,*\n         GETMAIN R,LV=LSECT\n         ST    R13,4(R1)\n         ST    R1,8(13)\n         LR    R12,R13\n         LR    R13,R1\n         L     R1,24(R12)\n         BALR  R12,0\n         USING *,12\n         USING DSASECT,R13\n         ST    R1,INPARM\n         L     R10,12(R1)\n         USING WORKSECT,R10\n         L     R2,0(R1)\n         CLC   OINDEX,0(R2)   SAME INDEX STRUCTURE AS LAST CALL?\n         BE    CAMLOC         GO GET NEXT DATASET\n         MVC   OINDEX,0(R2)\n         EJECT\nBLDKEY   DS    0H\n*        THIS BLOCK ANALIZES THE NEW INDEX STRUCTURE INTO COMPONENTS\n*        IT CONSTRUCTS A VSAM CATALOG GENERIC SEARCH KEY AND AN\n*        OPTIONAL LOWER LEVEL QUALIFIER VERIFICATION STRING\n*        ONE ASTERISK IS ALLOWED ANYWHERE BELOW THE USERID.\n*        IT MAY REPRESENT ALL OR PART OF AN 'INDEX LEVEL'\n*        EXITS: NORMAL TO 'GENLOC'\n*               TO 'ERROR4' IF A SYSTAX ERROR OCCURS IN INDEX STRUCTURE\n         SR    R1,R1\n         SR    R2,R2          CLEAR FOR TRT INSTRUCTION\n         MVI   TRTAB,0\n         MVC   TRTAB+1(255),TRTAB\n         MVI   TRTAB+C' ',4\n         MVI   TRTAB+C'*',8\n         MVI   TRTAB+C'.',12\n         MVC   KEY,OINDEX     COPY INDEX INPUT\n         TRT   KEY,TRTAB\n         BZ    ERROR4         MUST BE A BLANK IN 44 CHARS\n         B     *(R2)\n         B     USERID         C' ' MUST BE A USERID\n         B     ERROR4         C'*' ASTERISK MUST FOLLOW PERIOD\n         B     COMPLEX        C'.' MUST DO FULL ANALYSIS OF STRUCTURE\n         EJECT\nUSERID   DS    0H\n*        THIS BLOCK BUILDS SEARCH KEY FOR USERID. MUST BE <9 CHARACTERS\n*        AND WE ADD A PERIOD TO IT TO INDICATE TO GENERIC LOCATE\n*        THAT WE ARE INTERESTED IN THE DATASETS UNDER THE NAME AND\n*        NOT THE ALIAS RECORD (CVOL POINTER) OF THE NAME ITSELF.\n         MVI   0(R1),C'.'\n         LA    R3,KEY\n         SR    R1,R3\n         CH    R1,=H'8'\n         BH    ERROR4\n         LA    R1,1(R1)\n         STC   R1,NAME        STORE KEY LENGTH\n         MVI   LREST,USERIDF  USERID ONLY                   *HMD 12/79*\n         B     GENLOC         GET ALL LEVELS                *HMD 12/79*\n* END OF USERID\n         EJECT\nCOMPLEX  DS    0H\n*        NOW WE SEARCH FOR AN IMBEDDED ASTERISK IN INDEX STRUCTURE\n*        CHARACTERS ABOVE IT ARE USED AS THE GENERIC KEY.\n*        CHARACTERS AFTER IT ARE USED AS THE LOWER LEVEL QUALIFIERS.\n         MVI   TRTAB+C'.',0   NO LONGER INTERESTED IN PERIODS\n         TRT   KEY,TRTAB\n         BZ    ERROR4\n         B     *(R2)\n         B     ONEPART        NO ASTERISK\n         B     TWOPART\n         SPACE 2\nONEPART  MVI   LREST,USERIDF       MOVE IN USERID FLAG      *HMD 12/79*\n         LA    R3,KEY\n         SR    R1,R3\n         STH   R1,LKEY\n         STC   R1,NAME\n         B     GENLOC\n         SPACE 2\nTWOPART  DS    0H\n*        THIS BLOCK HANDLES THE CASE WHERE THERE IS AN EMBEDDED\n*        ASTERISK IN THE INDEX LEVEL. THE CHARACTERS BELOW THE\n*        ASTERISK ARE MOVED TO 'REST'. THE CHARACTERS FROM THE\n*        ASTERISK ON ARE BLANKED IN 'KEY'. THE LENGTH OF THE\n*        NON BLANK PART OF 'REST' LESS ONE IS SAVED IN 'LREST'\n*        FOR USE IN THE LATER CLC INSTRUCTION. THE LENGTH OF\n*        THE KEY IS SAVED IN 'NAME' FOR THE GENERIC LOCATE AND\n*        IN 'LKEY' FOR AN INDICATION OF HOW MANY CHARS TO\n*        SKIP BEFORE LOOKING IN A DSN FOR A MATCH TO 'REST'.\n         LA    R3,KEY+42\n         SR    R3,R1         GET LENGTH OF KEY ABOVE ASTERISK\n         MVC   REST,=CL44' ' INITIALIZE REST\n         EX    R3,MOVREST    MOVE PART BELOW ASTERISK\n         LA    R3,1(R3)\n         EX    R3,BLNKEY     BLANK KEY FROM ASTERISK ON\n         SH    R3,=H'43'\n         LPR   R3,R3         GET CHARS ABOVE ASTERISK\n         STH   R3,LKEY\n         STC   R3,NAME\nTESTXX   TRT   REST,TRTAB    FIND NON-BLANK LENGTH OF REST\n         B     *(R2)\n         B     LENRST\n         B     ERROR4        SORRY, ONLY ONE * PER CUSTOMER\nLENRST   LA    R3,REST+1     CALCULATE LENGTH FROM ADDRESS\n         SR    R1,R3            OF FIRST BLANK\n         BP    STREST                                       *HMD 12/79*\n         MVI   LREST,ASTERF  ASTERISK IN LAST LEVEL         *HMD 12/79*\n         B     GENLOC        DO GENERIC LOCATE              *HMD 12/79*\nSTREST   DS    0H                                           *HMD 12/79*\n         STH   R1,LREST\n         B     GENLOC\nMOVREST  MVC   REST(0),1(R1)\nBLNKEY   MVC   0(0,R1),=CL44' '\n* END OF TWOPART\n* END OF COMPLEX\n* END OF BLDKEY\n         EJECT\nGENLOC   DS    0H\n*        THIS BLOCK ISSUES A VSAM GENERIC LOCATE TO BUILD AN IN-CORE\n*        LIST OF DATASETS THAT BEGIN WITH THE SEARCH KEY\n*        THERE IS NO GOOD DOCUMENTATION ON THE GENERIC\n*        LOCATE IN THE LITERATURE. SEE THE CATALOG PLM FOR\n*        WHAT LITTLE THERE IS. THE FORM BELOW WAS INFERRED\n*        FROM SOME FICHE AND BY INTERCEPTING SVC 26 WITH DSS.\n         MVC   GENFLAG,=X'05201100'\n         XC    GENX1,GENX1\n         XC    GENX2,GENX2\n         LA    R1,NAME\n         ST    R1,GENNAME\n         GETMAIN R,LV=X'FFFF'      GET 65535 BYTES OF MAIN  *HMD 11/79*\n         ST    R1,GETADDR\n         ST    R1,GENWORK\n         MVC   0(4,R1),=X'FFFF0004'                         *HMD 02/80*\n         LA    R1,GENPARM\n         SVC   26\n         LTR   R15,R15\n         BZ    SUPEROK\n         CH    R15,=H'44'     OUT OF SPACE?                 *HMD 11/79*\n         BE    SUPEROK        JUST RETURN WHAT'S THERE      *HMD 11/79*\n         B     ERROR24        INDICATE ERROR CONDITION      *HMD 11/79*\nSUPEROK  L     R1,GETADDR     GET VSAM CATLG RETURN AREA\n         LA    R1,0(R1)       CLEAR HIGH BYTE\n         SR    R2,R2          CLEAR FOR ICM\n         ICM   R2,3,2(R1)     GET NUMBER BYTES USED\n         AR    R2,R1          ADD START ADDR\n         ST    R2,LAST        SAVE LAST BYTE ADDR\n         LA    R1,49(R1)      SKIP 4 BYTE PREFIX AND FIRST 45 BYTE ENTR\n         ST    R1,NEXT        SAVE ADDR OF FIRST DSN ENTRY\n* END OF GENLOC\n         EJECT\nCAMLOC   DS    0H\n*        NOW DO A REGULAR CAMLIST NAME LOCATE FOR THE NEXT NON-VSAM\n*        DATASET IN THE INCORE LIST\n         XC    CAMLST(16),CAMLST\n         LA    R1,KEY\n         ST    R1,CAMLST+4\n         LA    R1,VOLCNT\n         ST    R1,CAMLST+12\n         L     R1,NEXT\nTEST     C     R1,LAST\n         BNL   RET16          NO MORE DATASETS IN LIST\n         CLI   0(R1),C'A'     IS IT NON-VSAM\n         BE    S1\nNOGO     LA    R1,45(R1)\n         B     TEST\nS1       TM    LREST,X'80'    IS THERE A LOWER QUALIFIER\n         BO    S2             NO, SO GO LOCATE\n         EJECT\nTESTQUAL DS    0H\n*        THIS CODE LOOKS FOR THE CHARACTER STRING BELOW THE\n*        ASTERISK IN THE INDEX SEARCH KEY. THIS STRING MUST\n*        BE SOMEWHERE IN THE DATASET NAME BELOW THE KEY OR\n*        THE NAME IS REJECTED\n         LA    R2,1(R1)\n         AH    R2,LKEY        SKIP GENERIC KEY CHARS\n         TM    LREST,ASTERF   ASTERISK IN LAST LEVEL?       *HMD 12/79*\n         BO    LOOK48         GET LAST LEVEL ONLY           *HMD 12/79*\n         LH    R3,LREST       GET # CHARS-1 IN REST\n         LA    R4,44\n         SR    R4,R3\n         SH    R4,LKEY        R4=# CHARS BELOW KEY + 1\nCOMP     EX    R3,COMPAR\n         BE    S2\n         LA    R2,1(R2)\n         BCT   R4,COMP\n         B     NOGO\nCOMPAR   CLC   REST(0),0(R2)\nTRTREST  TRT   0(0,R2),TRTAB         FOR DOT SEARCH         *HMD 12/79*\nLOOK48   DS    0H                                           *HMD 12/79*\n         MVI   TRTAB+C'.',X'01'      RESTORE DOT            *HMD 12/79*\n         MVI   TRTAB+C' ',X'00'      REMOVE  SPACE          *HMD 12/79*\n         MVI   TRTAB+C'*',X'00'      REMOVE  ASTERISK       *HMD 12/79*\n         LA    R3,8                  LENGTH TO SCAN         *HMD 12/79*\n         STM   R1,R2,SAVE12          SAVE REGISTERS OVER TRT*HMD 12/79*\n         EX    R3,TRTREST            LOOK FOR DOT '.'       *HMD 12/79*\n         LM    R1,R2,SAVE12          RESTORE REGISTERS      *HMD 12/79*\n         B     S2                    THIS IS OK             *HMD 12/79*\n         B     NOGO                  FORGET THIS ONE        *HMD 12/79*\n* END OF TESTQUAL\n         EJECT\nS2       DS    0H\n*        NOW TO ISSUE NORMAL LOCATE BY NAME AND RETURN INFORMATION\n*        ACCORDING TO DESCRIPTION OF PARAMETERS IN LEADING DOCUMENT\n         MVC   KEY,1(R1)      COPY DSN\n         LA    R1,45(R1)      PT TO NXT DSN\n         ST    R1,NEXT        SAVE FOR NXT TIME\n         LA    R1,CAMLST\n         SVC   26             LOCATE BY NAME\n         L     R2,INPARM      NOW GET PASSED PARM LIST\n         LM    R2,R3,4(R2)    PICK UP 2ND & 3RD USER PARMS\n         MVC   0(44,R2),KEY   SAVE DSN\n         MVC   0(6,R3),SER    SAVE VOL\n         TM    DEVT+2,X'20'   IS THIS DISK\n         BZ    ERROR8         NO, PASS 8 RETURN CODE\n         CLI   VOLCNT+1,1     IS IT MULTI-VOL\n         BNE   ERROR12        YES, PASS 12 RETURN CODE\n* END OF CAMLOC\n         EJECT\n*VARIOUS RETURNS\nRETN     SR    R15,R15\n         B     RC\nERROR4   LA    R15,4\n         B     RC\nERROR8   LA    R15,8\n         B     RC\nERROR12  LA    R15,12\n         B     RC\nRET16    FREEMAIN R,LV=X'FFFF',A=GETADDR\n         LA    R15,16\n         B     RC\nERROR24  FREEMAIN R,LV=X'FFFF',A=GETADDR                    *HMD 04/82*\n         LA    R15,24                                       *HMD 04/82*\n         B     RC                                           *HMD 04/82*\nERROR20  LA    R15,20\nRC       L     R1,INPARM\n         TM    12(R1),X'80'\n         BO    EXIT\n         L     R1,16(R1)\n         ST    R15,0(R1)\nEXIT     L     R13,4(R13)\n         ST    R15,16(R13)\n         L     R1,8(R13)\n         FREEMAIN R,LV=LSECT,A=(1)\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\nDSASECT  DSECT\n         DS    18A\nGENPARM  DS    0F            GENERIC LOCATE PARM AREA\nGENFLAG  DS    F\nGENNAME  DS    A\nGENX1    DS    A\nGENWORK  DS    A\nGENX2    DS    3A\nKEYLEN   DS    0H\n         DS    X\nNAME     DS    X\nKEY      DS    CL44\nINPARM   DS    A             SAVE R1 UPON ENTRY TO LOCINDEX\nCAMLST   DS    4A\n         DS    0D\nLSECT    EQU   *-DSASECT\n         EJECT\nGETSECT  DSECT               GETMAINED VSAM WORK AREA\nGETLEN   DS    H             LENGT OF AREA\nGETUSED  DS    H             AMOUNT ALLOCATED CURRENTLY TO DATA\nGETENTY  DS    0CL45         FIRST ELEMENT OF DSN ARRAY\nGETTYPE  DS    C             TYPE FLAG ('A'=NONVSAM)\nGETNAME  DS    CL44          DSN\n         EJECT\nWORKSECT DSECT               WORK AREA PASSED AS PARM\nGETADDR  DS    A             ADDRESS OF GETMAINED VSAM WORK AREA\nTRTAB    DS    CL256                                        *HMD 12/79*\n         DS    0D            ALIGNMENT                      *HMD 12/79*\nVOLCNT   DS    H\nDEVT     DS    XL4\nSER      DS    CL6\nSEQ      DS    H\n         DS    CL251\nOINDEX   DS    CL44          PREVIOUS VALUE OF FIRST PARM\nREST     DS    CL44          LOW QUALIFIER COMPARE STRING\nNEXT     DS    A             ADDRESS OF NEXT DSN IN INCORE TABLE\nLAST     DS    A             ADDRESS OF BYTE AFTER END OF DSNLIST\nLKEY     DS    H             LENGTH OF GENERIC KEY\nSAVE12   DS    2F            SAVE AREA OVER TRT INSTR       *HMD 12/79*\nNOREST   DS    0B            FLAG IF 'REST' IS EMPTY\nLREST    DS    H             LENGTH OF REST\nUSERIDF  EQU   X'80'         USERID FLAG                    *HMD 12/79*\nASTERF   EQU   X'40'         LAST LEVEL ONLY INDICATOR      *HMD 12/79*\n* END OF WORKSECT DSECT                                     *HMD 11/79*\n         EJECT                                              *HMD 11/79*\nLOCINDEX CSECT               PLACE IN THIS CSECT            *HMD 11/79*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOG0MSG": {"ttr": 8452, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "LOG0MSG  TITLE ' - LOG A MESSAGE INTO THE ISPF LOG'\n***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8503                                               *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*    THIS PROGRAM ALLOWS THE USER TO LOG A MESSAGE IN THE ISPF LOG.   *\n*    THIS IS HELPFUL IN TESTING. YOU ARE ABLE TO MARK YOUR LOG        *\n*    DURING A TRACE. SEE THE INSTALLTION PDS FOR MEMBER LOGMSG.       *\n***********************************************************************\n         EJECT\nLOG0MSG  CSECT\n         ISPF  SET,LEVEL=1\n***********************************************************************\n*              STANDARD ENTRY CODE FOR RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'LOG0MSG '              CSECT NAME\n         DC    C'02/23/85 '             DATE WRITTEN\n         DC    C'VERSION 1.1 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING LOG0MSG,12               PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         LR    2,1                      SAVE PARMS PASSED\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n***********************************************************************\n*              INITALIZATION SECTION:\n*                   LOAD ISPLINK\n*                   VDEFINE THE LOG MESSAGE AREAS (UMSG30 LMSG30)\n***********************************************************************\n         ISPF  LOAD                     LOAD THE ISPLINK MODULE\n         SPACE\n         CONTROL ERRORS,CANCEL          SET ISPF ERROR MODE\n         SPACE\n         VDEFINE '(UMSG30 UMSG31)',UMSG30,CHAR,24,MF=E\n         SPACE\n         VDEFINE '(LMSG30)',LMSG30,CHAR,78,MF=E\n         SPACE 3\n         VDEFINE '(LMSG31)',LMSG31,CHAR,78,MF=E\n         SPACE\n***********************************************************************\n*              CHECK LOG MODE:\n*                  IF ANY PARMS PASSED  - LOG THOSE PARMS AND EXIT\n*                  IF NO PARMS PASSED -  DISPLAY PANEL TO GET DATA\n***********************************************************************\n         L     2,0(2)                   ADDRESS PARMS RECEIVED\n         LH    3,0(2)                   GET LENGTH OF PARMS\n         LA    2,2(2)                   BUMP TO POINT TO DATA\n         LTR   3,3                      WERE ANY PARMS PASSED\n         BZ    DISPLOOP                 IF NOT - DISPLAY PANEL\n         LA    10,EXITPGM               EXIT PROGRAM AFTER LOGGING MSG\n         SETMSG 'DTSM031'               LET USER KNOW LOG WORKED\n         SPACE\n         B     LOGLOOP                  GO WRITE MESSAGE\n         SPACE 3\n***********************************************************************\n*              DISPLAY PANEL TO GET MESSAGE FOR LOGGING\n*              IF PF3 HIT - EXIT\n*              OTHERWISE - COPY VARIABLE LOGMSG TO LOG\n*              LOG THE MESSAGE AND LOOP TO DISPLAY\n***********************************************************************\nDISPLOOP DS    0H\n         DISPLAY 'LOGDMSG'              DISPLAY PANEL CALLED LOGDMSG\n         SPACE\n         LTR   15,15                    CHECK RETURN CODE\n         BNZ   EXITPGM                  IF END COMMAND - EXIT\n         VCOPY '(LOGMSG)',VCOPYLEN,LOGMSG,LOCATE,MF=E\n         SPACE\n         L     3,VCOPYLEN               GET LENGTH OF MESSAGE\n         L     2,LOGMSG                 GET ADDRESS OF MESSAGE\n         LA    10,DISPLOOP              SET LOOP ADDRESS\n         SETMSG 'DTSM031'               LET USER KNOW LOG WORKED\n         SPACE\n         B     LOGLOOP                  GO LOG MESSAGE\n         SPACE 3\n***********************************************************************\n*              THIS ROUTINE LOGS VARIABLE LENGTH MESSAGES\n*              FIRST CHECK IF MESSAGE LENGTH IS ZERO\n*              IF NOT - IS MESSAGE AT LEAST 78 BYTES\n*                       IF YES LOG FIRST 78 BYTES AND BUMP\n*              IF LESS- LOG WHAT REMAINS\n***********************************************************************\nLOGLOOP  DS    0H\n         LTR   3,3                      IS LENGTH ZERO\n         BZR   10                       IF SO EXIT\n         C     3,=F'78'                 IS LENGTH 78\n         BL    LOGLAST                  IF LESS BRANCH TO END ROUTINE\n         MVC   LMSG30,0(2)              MOVE THE LONG MESSAGE\n         LOG   'DTSM030'                LOG THE MESSAGE\n         SPACE\n         LA    2,78(2)                  BUMP PAST THESE 78 BYTES\n         S     3,=F'78'                 REDUCE LENGTH BY 78\n         B     LOGLOOP                  CONTINUE LOGGING\n         SPACE\nLOGLAST  DS    0H\n         BCTR  3,0                      SUBTRACT 1 FROM MSG LENGTH\n         MVC   LMSG30,SPACES            INIT MESSAGE TO SPACES\n         MVC   LMSG30(*-*),0(2)         DUMMY MVC\n         EX    3,*-6                    EXECUTE PREVIOUS MVS\n         LOG   'DTSM030'                LOG THE MESSAGE\n         SPACE\n         BR    10                       RETURN\n         SPACE 3\n***********************************************************************\n*              EXITPGM - EXIT PROGRAM SUBROUTINE\n***********************************************************************\nEXITPGM  VRESET ,                       DELETE ALL FUNCTION VARIABLES\n         SPACE\n         ISPF  DELETE                   DELETE ISPLINK MODULE\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         SR    15,15                    SET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - WORKING STORAGE'\n***********************************************************************\n*              WORKING STORAGE\n***********************************************************************\nSPACES   DC    CL78' '                  LITERAL OF SPACES\nUMSG30   DC    CL24'LOG MESSAGE REQUEST'\nUMSG31   DC    CL24'MESSAGES LOGGED'\nLMSG31   DC    CL78'YOUR REQUEST TO LOG MESSAGES TO THE ISPF LOG COMPLE*\n               TED SUCCESSFULLY'\n         SPACE\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         SPACE\n         ISPF  PARMS                    GENERATE WS FOR ISPF MACROS\n         SPACE\nVCOPYLEN DS    F                        LENGTH OF VCOPY\nLOGMSG   DS    A                        ADDRESS OF LOGMSG VARIABLE\nLMSG30   DS    CL78                     LONG ERROR MESSAGE\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nLOG0MSG  CSECT ,                        RESUME CSECT\n         END   LOG0MSG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LSP0ACE": {"ttr": 8456, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*        TITLE 'DIALOG SERVICES LSPACE'\n***********************************************************************\n*                                                                     *\n*        MIKE  SHAW                                                   *\n*        MORINO ASSOCIATES                                            *\n*        LAST MODIFIED 8504                                           *\n*                                                                     *\n***********************************************************************\n*        MODULE NAME - LSPACED                                        *\n*                      QUICK DASD VOLUME SPACE LISTER                 *\n*                                                                     *\n*        FUNCTION -                                                   *\n*           THIS MODULE DISPLAYS FREE SPACE INFORMATION ON A          *\n*           DASD VOLUME SPECIFIED BY THE USER. (SIMILAR TO            *\n*           SPF 3.7 VTOC, BUT MUCH FASTER).                           *\n*                                                                     *\n*        PANEL AND INPUTS/OUTPUTS DESCRIPTION:                        *\n*                                                                     *\n*        INITIAL PANEL (LSPDP1) LOOKS LIKE THIS:                      *\n*                                                                     *\n*        *----------------------------------------------*             *\n*        |  ---------------- LSPACE ------------------  |             *\n*        |                                              |             *\n*        |  VOLSER ===> _______                         |             *\n*        |                                              |             *\n*        |                                              |             *\n*        |                                              |             *\n*        |                                              |             *\n*        *----------------------------------------------*             *\n*                                                                     *\n*        USER TYPES A FULL DASD VOLSER OR A GENERIC VOLSER            *\n*        IN THE 'VOLSER' FIELD ABOVE - GENERIC IS 1-5 CHARACTERS      *\n*        WITH A TRAILING ASTERISK, (E.G., TSO9* OR STOR*)             *\n*                                                                     *\n*                                                                     *\n*        ACTUAL DATA PANEL (LSPDP2) LOOKS (SOMETHING) LIKE THIS:      *\n*                                                                     *\n*        *-------------------------------------------------------*    *\n*        |  ---------------------- LSPACE ---------------------- |    *\n*        |  COMMAND ===> ____                                    |    *\n*        |                                                       |    *\n*        |  VOLSER ADR TYPE FREE FREE FREE (LARGEST XTNT) MOUNT  |    *\n*        |                  CYLS TRKS XNTS  CYLS    TRKS  ATTRIB |    *\n*        |                                                       |    *\n*        |  PUB024 2A3 3380  89  1707  54    68     1023  PUBLIC |    *\n*        |                                                       |    *\n*        *-------------------------------------------------------*    *\n*                                                                     *\n*        FOR A GENERIC SEARCH, THE DATA LINE IS REPEATED FOR EACH     *\n*        VOLSER THAT MATCHES THE SEARCH ARGUMENT. ISPF TABLE          *\n*        CREATE/DISPLAY/DELETE SERVICES ARE USED. THE NUMBER          *\n*        OF VOLUMES FOUND IS THE NUMBER OF LINES IN THE TABLE.        *\n*        THE USER CAN SCROLL UP & DOWN TO REVIEW THE DISPLAY.         *\n*        THIS FUNCTION CAN BE EASILY HOOKED INTO THE ISRUTIL PANEL    *\n*        AS AN OPTION.                                                *\n*                                                                     *\n*          EXAMPLE: (FOR OPTION 3.L):                                 *\n*                                                                     *\n*                L,'PGM(LSPACED)'                                     *\n*                                                                     *\n*           THIS PROGRAM CALLS THE MVS UCB SEARCH ROUTINE TO GET      *\n*           APPLICABLE DASD UCB ADDRESSES, THEN USES THE UCB          *\n*           ADDRESS TO ISSUE THE LSPACE SVC. (SVC 78).                *\n*           THIS SVC IS DOCUMENTED IN SY26-3828, OS/VS2 DADSM         *\n*           LOGIC. THIS SVC ISSUES A RESERVE AGAINST THE              *\n*           VOLUME BEING CHECKED, BUT IT IS A SHORT TERM RESERVE      *\n*           AND IS QUICK. AFTER THE SVC EXECUTES,                     *\n*           ITS RESULTS ARE 'MASSAGED' TO DISPLAY THE SAME INFO       *\n*           FREE SPACE INFO AS SPF 3.7 OR ISPF V2 OPTION 3.4.         *\n*           THE 'FREE TRACKS' FORMULA IS:                             *\n*                                                                     *\n*           FREE TRKS=FREE TRKS+(FREE CYL * TRKSPERCYL)               *\n*                                                                     *\n*        RESTRICTIONS -                                               *\n*           DEVICE TYPE SENSITIVE, SUPPORTS 3330-1,3330-11,2305-2,    *\n*                                           3350,3380                 *\n*                                                                     *\n*        MODULE DESCRIPTION -                                         *\n*           TYPE -  SPF DIALOG SERVICE                                *\n*           LANGUAGE -  ASSEMBLER                                     *\n*           ATTRIBUTES -  NOT REENTRANT, NOT AUTHORIZED               *\n*                                                                     *\n*        ENTRY POINTS - LSPACED (ONLY ENTRY POINT)                    *\n*                                                                     *\n*        LINKAGE - CALLED BY SPF                                      *\n*                                                                     *\n*        INPUT - VOLSER AS ENTERED ON ENTRY PANEL                     *\n*                                                                     *\n*        OUTPUT - SPACE INFO AS DISPLAYED ON OUTPUT PANEL             *\n*                                                                     *\n*        EXIT - NORMAL RETURN LINKAGE                                 *\n*                                                                     *\n*        RETURN CODE - ZERO                                           *\n*                                                                     *\n*        EXTERNAL REFERENCES -                                        *\n*                                                                     *\n*           ROUTINES - ISPLINK MODULE                                 *\n*                                                                     *\n*           DATA AREAS - SPF DIALOG VARIABLES                         *\n*                                                                     *\n*           PANEL MEMBERS-  LSPDP1 (ENTRY PANEL)                      *\n*                           LSPDP2 (OUTPUT PANEL)                     *\n*                           LSPDP3 (TUTORIAL PANEL)                   *\n*           MESSAGE MEMBER- LSPM00                                    *\n*                                                                     *\n*        TABLES = NONE                                                *\n*                                                                     *\n*        MACROS = SAVE, CALL, RETURN, IEFUCBOB, CVT, CVAFTST, LOAD,   *\n*                 DELETE                                              *\n*                                                                     *\n*        MODIFICATION LOG -                                           *\n*                                                                     *\n*        12/11/81  MIKE YAFFE - WROTE INITIAL MODULE                  *\n*                                                                     *\n*        02/27/82  MIKE YAFFE - MOD TO DETERMINE IF VTOC IS           *\n*                  INDEXED OR UNINDEXED                               *\n*                                                                     *\n*        11/28/83  MIKE SHAW - ADDED 3380 SUPPORT                     *\n*                                                                     *\n*        10/01/84  MIKE SHAW - CHANGED UCB LOOKUP FOR XA              *\n*                                                                     *\n*        10/12/84  MIKE SHAW - ALTERED OUTPUT FORMAT TO USE           *\n*                  TABLE SERVICES AND A GENERIC LOOKUP FOR            *\n*                  MULTIPLE VOLUMES, OR JUST ONE                      *\n*                  IF LSPACE SVC PASSES BACK A NON-ZERO RETURN CODE,  *\n*                  IT IS DISPLAYED ON TABLE ROW WITH VOLSER AND       *\n*                  PROCESSING CONTINUES.                              *\n*                                                                     *\n*        04/01/85  BOB ZIMMERMAN OF CNA INSURANCE                     *\n*                  UNDER VERSION 2 OF ISPF, THIS WILL NOW ALLOW       *\n*                  THE USER TO SORT THE DISPLAY                       *\n*                                                                     *\n***********************************************************************\n         EJECT\nLSPACED  CSECT\n         ISPF  SET,LEVEL=1\n         SPACE 1\nR0       EQU   0               LINKAGE REGISTER\nR1       EQU   1               LINKAGE REGISTER\nR2       EQU   2               ADDR OF CVT\nR3       EQU   3               ADDR OF UCB LOOKUP TABLE\nR4       EQU   4               ADDR OF CURRENT UCB\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10              BRANCHING REGISTER\nR11      EQU   11              ADDR OF ISPLINK\nR12      EQU   12              BASE REGISTER\nR13      EQU   13              ADDRESS OF SAVEAREA\nR14      EQU   14              LINKAGE REGISTER\nR15      EQU   15              LINKAGE REGISTER\n         SPACE 1\n         USING LSPACED,R12     ESTABLISH ADDRESSABILITY TO BASE REG\n         SPACE 3\n***********************************************************************\n*        LINKAGE ENTRY SEQUENCE\n***********************************************************************\n         SPACE 1\n         SAVE  (14,12),,DIALOG_SERVICES_LSPACE_&SYSDATE_&SYSTIME\n         LR    R12,R15         GET ENTRY ADDRESS\n         LA    R2,SAVEAREA     GET ADDR OF S.A.\n         ST    R2,8(R0,R13)    ESTABLISH BACK CHAIN\n         ST    R13,SAVEAREA+4  ESTABLISH FORWARD CHAIN\n         LR    R13,R2          LOAD THIS PROGS SAVE AREA ADDRESS\n         SPACE 3\n***********************************************************************\n*        INITIALIZATION ROUTINE\n***********************************************************************\n         SPACE 1\n         LOAD  EP=ISPLINK         LOAD DIALOG INTERFACE ROUTINE\n         SPACE 1\n         LR    R9,R0              SAVE EP AND\n         ST    R9,ISPLINK               SAVE ISPLINK ADDRESS\n         VCOPY '(ZENVIR)',4,ZENVIR,LOCATE\n         SPACE\n         ST    15,ZENVIR\n         LR    R15,R9             ASSUME LOAD WORKED\n         CALL  (15),(VDEFINE,EXTVL3,INTVL3,CHAR,LENG3),VL\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(VDEFINE,EXTVL5,INTVL5,CHAR,LENG5),VL\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(VDEFINE,EXTVL6,INTVL6,CHAR,LENG6),VL\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(VDEFINE,EXTVL7,INTVL7,CHAR,LENG7),VL\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(VDEFINE,EXTVL9,INTVL9,CHAR,LENG9),VL\n         SPACE 3\n         ISPF  SUPPRESS,LIST=(VDEFINE,CHAR)\n         VDEFINE '(ZCMD)',ZCMD,CHAR,80\n         SPACE 3\n         VDEFINE '(VOLS)',$VOLS,FIXED,4\n         SPACE 3\n***********************************************************************\n*        MAINLINE ROUTINE\n***********************************************************************\n         SPACE 1\nMAIN     DS    0H\n         LR    R15,R9\n         CALL  (15),(DISPLAY,PANEL1),VL\n*\nMAIN1    DS    0H\n         CH    R15,ENDKEY            WAS END OR RETURN PRESSED\n         BE    EOJ                   YES- GO TO END OF JOB\n         SPACE 2\nENTRMASH DS    0H\n         CLI   $VOLSER,C'*'          ASTERISK AS 1ST CHAR NOT ALLOWED\n         BE    ENDOFTAB              QUIT IF FOUND\n         LA    R2,5                  SET UP FOR BCT\n         LA    R3,$VOLSER+1          SCAN STARTING ADDRESS\nSCANVOL  CLI   0(R3),C'*'            IS THIS A GENERIC REQUEST?\n         BE    SETLEN                GO SET LENGTH IF IT IS\n         LA    R3,1(R3)              CHECK NEXT CHARACTER\n         BCT   R2,SCANVOL            SCAN ENTIRE VOLSER\n         SPACE 1\n         LA    R3,5                  SET FULL LENGTH FOR EXECUTE\n         B     TABC                  AND GO CHECK OUT UCBS\n         SPACE 1\nSETLEN   DS    0H\n         LA    R2,$VOLSER            SUBTRACT VOLSER\n         SR    R3,R2                 STARTING ADDRESS FROM ENDING\n         BCTR  R3,0                  DECREMENT FOR EXECUTE\n         SPACE 1\nTABC     DS    0H\n         LR    R15,R9\n         CALL  (15),(TBCREATE,LSPACTAB,SKIPPARM,                       X\n               TABLINE,NOWRITE,REPLACE),VL\n         SPACE 1\n         MVI   TBCRDONE,X'FF'        INDICATE TBCREATE DONE\n         L     R2,CVTPTR             LOAD R2 WITH CVT ADDRESS\n         USING CVT,R2                ESTABLISH ADDRESSABILITY TO CVT\n         SPACE 1\n         XC    VOLS,VOLS             ZERO OUT VOLUME COUNT\n         XC    WORKA,WORKA           ZERO OUT UCB LOOKUP WORK AREA\nLOOP     L     R15,CVTUCBSC          LOAD R3 WITH UCB LOOKUP RTN ADR XA\n         USING UCB,R4                ESTABLISH ADDRESSABILITY TO UCB\n         SPACE 1\n         DS    0H\n         CALL  (15),(WORKA,DEV,UCBA),VL GO GET A UCB               XA\n         LTR   R15,R15               DONE YET?                     XA\n         BNZ   ENDOFTAB              IF NOT ZERO, WE'RE DONE       XA\n         L     R4,UCBA               GET A(UCB)\n         TM    UCBSTAT,UCBONLI       IS DASD ONLINE ?\n         BNO   FINDNEXT              NO-  GET NEXT UCB\n         TM    UCBSTAT,UCBCHGS       IS DASD GOING OFFLINE ?\n         BO    FINDNEXT              YES- GET NEXT UCB\n         EX    R3,COMPVOL            IS THIS THE VOLSER WE WANT ?\n         BE    PROCESS               YES- GO DO IT\n*\nFINDNEXT DS    0H\n         B     LOOP                  TRY AGAIN\nCOMPVOL  CLC   UCBVOLI(0),$VOLSER    * EXECUTED CLC *\n         DROP  R2                                                  XA\n*\nPROCESS  DS    0H\n         LR    R0,R4                 POINT R0 TO UCB NEEDED\n         LA    R1,SVC78MSG           POINT R1 TO MSG AREA\n         SVC   78                    GET THE GOODIES - CHECK RC LATER\n         SPACE 1\n         MVC   $UAD,UCBNAME          MOVE TO DIALOG VARIABLE\n         MVC   UVOL,UCBVOLI          SAVE ACTUAL VOLSER\n         L     R14,VOLS              INCREMENT\n         LA    R14,1(,R14)           VOLUME HIT\n         ST    R14,VOLS              COUNT\n         PACK  NUMCYLH,NUMCYL        PACK TO STORAGE AREA\n         PACK  NUMTRKH,NUMTRK        PACK TO STORAGE AREA\n         PACK  NUMXTNTH,NUMXTNT      PACK TO STORAGE AREA\n         PACK  LRGCYLH,LRGCYL        PACK TO STORAGE AREA\n         PACK  LRGTRKH,LRGTRK        PACK TO STORAGE AREA\n         SPACE 1\nGETMNT1  DS    0H\n         TM    UCBSTAB,UCBBPRV       IS DEVICE PRIVATE\n         BNO   GETMNT2               NO- TRY PUBLIC\n         MVC   $UMOUNT,=C'PRIVATE'   YES- MOVE DESCRIPTION\n         B     GETUTYP\n*\nGETMNT2  DS    0H\n         TM    UCBSTAB,UCBBPUB       IS DEVICE PUBLIC\n         BNO   GETMNT3               NO- TRY STORAGE\n         MVC   $UMOUNT,=C'PUBLIC '   YES- MOVE DESCRIPTION\n         B     GETUTYP\n*\nGETMNT3  DS    0H\n         TM    UCBSTAB,UCBBSTR       IS DEVICE STORAGE\n         BNO   GETMNT4               NO- WHO KNOWS?\n         MVC   $UMOUNT,=C'STORAGE'   YES- MOVE DESCRIPTION\n         B     GETUTYP               CONTINUE\n         SPACE 1\nGETMNT4  DS    0H\n         MVC   $UMOUNT,=C'???????'   UNKNOWN MOUNT ATTRIBUTE\n         SPACE 1\nGETUTYP  DS    0H\n         TM    UCBUNTYP,U3380        IS DEVICE A 3350\n         BNO   TST3350A              NO- TRY ANOTHER\n         MVC   $UTYP,=C'3380   '     YES- MOVE DESCRIPTION\n         LTR   R15,R15               WAS LSPACE RC = 0?\n         BNZ   FORCERR               NO SPACE INFO IF SO\n         B     COMP3380              GOTO TRACK CALCULATION RTN\n*\nTST3350A DS    0H\n         TM    UCBUNTYP,U3350        IS DEVICE A 3350\n         BNO   TST3330A              NO- TRY ANOTHER\n         MVC   $UTYP,=C'3350   '     YES- MOVE DESCRIPTION\n         LTR   R15,R15               WAS LSPACE RC = 0?\n         BNZ   FORCERR               NO SPACE INFO IF SO\n         B     COMP3350              GOTO TRACK CALCULATION RTN\n*\nTST3330A DS    0H\n         TM    UCBUNTYP,U3330#11     IS DEVICE A 3330-11\n         BNO   TST3330B              NO- TRY ANOTHER\n         MVC   $UTYP,=C'3330-11'     YES- MOVE DESCRIPTION\n         LTR   R15,R15               WAS LSPACE RC = 0?\n         BNZ   FORCERR               NO SPACE INFO IF SO\n         B     COMP3330              GOTO TRACK CALCULATION RTN\n*\nTST3330B DS    0H\n         TM    UCBUNTYP,U3330#1      IS DEVICE A 3330-1\n         BNO   TST2305               NO- TRY ANOTHER\n         MVC   $UTYP,=C'3330-1 '     YES- MOVE DESCRIPTION\n         LTR   R15,R15               WAS LSPACE RC = 0?\n         BNZ   FORCERR               NO SPACE INFO IF SO\n         B     COMP3330              GOTO TRACK CALCULATION RTN\n*\nTST2305  DS    0H\n         TM    UCBUNTYP,U2305#2      IS DEVICE A 2305-2\n         BNO   WHATUTYP              NO- TRY ANOTHER\n         MVC   $UTYP,=C'2305-2 '     YES- MOVE DESCRIPTION\n         LTR   R15,R15               WAS LSPACE RC = 0?\n         BNZ   FORCERR               NO SPACE INFO IF SO\n         B     COMP2305              GOTO TRACK CALCULATION RTN\n*\nWHATUTYP DS    0H\n         MVC   $UTYP,=C'???????'     WHO KNOWS?\n         B     TBADDROW              GO DISPLAY WHAT WE'VE GOT\n         SPACE 1\nCOMP3380 DS    0H\n         CLC   NUMCYL,=C'0000'       ARE THE NO OF FREE CYLINDERS 0 ?\n         BE    CHK80LC               YES- TRY LARGEST CYLINDER CALC\n         PACK  TEMPWK5,NUMCYL        PACK NUMBER OF FREE CYLINDERS\n         MP    TEMPWK5,=P'15'        MULTIPLY BY TRK/CYL FOR 3380\n         AP    NUMTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n*\nCHK80LC  DS    0H\n         CLC   LRGCYL,=C'0000'       IS THE LARGEST FREE GROUP 0 ?\n         BE    GOTUTYP               YES- THATS ALL, GET OUT\n         PACK  TEMPWK5,LRGCYL        PACK LARGEST FREE GROUP\n         MP    TEMPWK5,=P'15'        MULTIPLY BY TRK/CYL FOR 3380\n         AP    LRGTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n         B     GOTUTYP               THATS ALL, GET OUT\n*\nCOMP3350 DS    0H\n         CLC   NUMCYL,=C'0000'       ARE THE NO OF FREE CYLINDERS 0 ?\n         BE    CHK50LC               YES- TRY LARGEST CYLINDER CALC\n         PACK  TEMPWK5,NUMCYL        PACK NUMBER OF FREE CYLINDERS\n         MP    TEMPWK5,=P'30'        MULTIPLY BY TRK/CYL FOR 3350\n         AP    NUMTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n*\nCHK50LC  DS    0H\n         CLC   LRGCYL,=C'0000'       IS THE LARGEST FREE GROUP 0 ?\n         BE    GOTUTYP               YES- THATS ALL, GET OUT\n         PACK  TEMPWK5,LRGCYL        PACK LARGEST FREE GROUP\n         MP    TEMPWK5,=P'30'        MULTIPLY BY TRK/CYL FOR 3350\n         AP    LRGTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n         B     GOTUTYP               THATS ALL, GET OUT\n*\nCOMP3330 DS    0H\n         CLC   NUMCYL,=C'0000'       ARE THE NO OF FREE CYLINDERS 0 ?\n         BE    CHK30LC               YES- TRY LARGEST CYLINDER CALC\n         PACK  TEMPWK5,NUMCYL        PACK NUMBER OF FREE CYLINDERS\n         MP    TEMPWK5,=P'19'        MULTIPLY BY TRK/CYL FOR 3330\n         AP    NUMTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n*\nCHK30LC  DS    0H\n         CLC   LRGCYL,=C'0000'       IS THE LARGEST FREE GROUP 0 ?\n         BE    GOTUTYP               YES- THATS ALL, GET OUT\n         PACK  TEMPWK5,LRGCYL        PACK LARGEST FREE GROUP\n         MP    TEMPWK5,=P'19'        MULTIPLY BY TRK/CYL FOR 3330\n         AP    LRGTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n         B     GOTUTYP               THATS ALL, GET OUT\n*\nCOMP2305 DS    0H\n         CLC   NUMCYL,=C'0000'       ARE THE NO OF FREE CYLINDERS 0 ?\n         BE    CHK05LC               YES- TRY LARGEST CYLINDER CALC\n         PACK  TEMPWK5,NUMCYL        PACK NUMBER OF FREE CYLINDERS\n         MP    TEMPWK5,=P'8'         MULTIPLY BY TRK/CYL FOR 2305-2\n         AP    NUMTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n*\nCHK05LC  DS    0H\n         CLC   LRGCYL,=C'0000'       IS THE LARGEST FREE GROUP 0 ?\n         BE    GOTUTYP               YES- THATS ALL, GET OUT\n         PACK  TEMPWK5,LRGCYL        PACK LARGEST FREE GROUP\n         MP    TEMPWK5,=P'8'         MULTIPLY BY TRK/CYL FOR 2305-2\n         AP    LRGTRKH,TEMPWK5+2(3)  ADD IT TO NUMBER OF FREE TRACKS\n         NOP   GOTUTYP               THATS ALL, GET OUT\n*\nGOTUTYP  DS    0H\n         MVC   HOLD6BYT,MASK         MOVE IN EDIT MASK\n         ED    HOLD6BYT,NUMCYLH+2    EDIT THE DATA\n         MVC   $NUMCYL,HOLD6BYT+1    MOVE TO DIALOG VARIABLE\n         MVC   HOLD6BYT,MASK         MOVE IN EDIT MASK\n         ED    HOLD6BYT,NUMTRKH      EDIT THE DATA\n         MVC   $NUMTRK,HOLD6BYT+1    MOVE TO DIALOG VARIABLE\n         MVC   HOLD6BYT,MASK         MOVE IN EDIT MASK\n         ED    HOLD6BYT,NUMXTNTH     EDIT THE DATA\n         MVC   $NUMXTNT,HOLD6BYT+1   MOVE TO DIALOG VARIABLE\n         MVC   HOLD6BYT,MASK         MOVE IN EDIT MASK\n         ED    HOLD6BYT,LRGCYLH+2    EDIT THE DATA\n         MVC   $LRGCYL,HOLD6BYT+1    MOVE TO DIALOG VARIABLE\n         MVC   HOLD6BYT,MASK         MOVE IN EDIT MASK\n         ED    HOLD6BYT,LRGTRKH      EDIT THE DATA\n         MVC   $LRGTRK,HOLD6BYT+1    MOVE TO DIALOG VARIABLE\n         SPACE 1\n         CVAFTST UCB=(4)             ISSUE CVAF MACRO\n         CH    R15,=X'0008'          IS VTOC INDEXED\n         BNE   NOINDX                NO- ANY OTHER RC ASSUME UNINDEXED\n         MVC   $VTOC,INDXED          MOVE IN INDEXED LITERAL\n         B     *+10                  GO ON TO ADD TABEL ROW\nNOINDX   DS    0H\n         MVC   $VTOC,UNINDXED        MOVE IN UNINDEXED LITERAL\n         B     TBADDROW              CONTINUE\n         SPACE 1\nFORCERR  DS    0H                    ERROR IN LSPACE OR UNKNOWN TYPE\n         CVD   R15,SVC78RTN          CONVERT THE RETURN CODE\n         UNPK  $RETCODE(7),SVC78RTN+4(4) UNPACK IT\n         MVC   $RETCODE,$RETCODE+1   SHIFT OVER BY ONE\n         OI    $RETCODE+5,X'F0'      SET ZONE FOR DISPLAY\n         MVC   $NUMCYL,=C'*****'     EYECATCHER\n         MVC   $NUMTRK,=C'====>'     EYECATCHER\n         MVC   $NUMXTNT,=C'ERROR'    INDICATE\n         MVC   $LRGCYL,=C'RC=  '     AN\n         MVC   $LRGCYL+3(2),$RETCODE+4 ERROR\n         MVC   $LRGTRK,=C'FROM '     OCCURRED\n         MVC   $UMOUNT,=C'LSPACE  '  LSPACE RC NOT EQUAL TO ZERO\nTBADDROW DS    0H\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(TBADD,LSPACTAB),VL ADD A ROW TO TABLE\n         SPACE 1\n         B     LOOP\n*\nENDOFTAB DS    0H\n         OC    VOLS,VOLS             ANY FOUND?\n         BZ    NOTFND                ISSUE MESSAGE IF NOT\n         SPACE 1\n         L     R0,VOLS            GET VOLUME COUNT\n         CVD   R0,SVC78RTN        CONVERT TO DECIMAL\n*        MVC   $VOLS,MASK           MOVE IN EDIT MASK\n*        ED    $VOLS,SVC78RTN+5     EDIT VOLUME COUNT IN\n         MVC   $VOLS,VOLS           MOVE IN EDIT MASK\n         SPACE 1\n         LR    R15,R9             GET A(ISPLINK)\n         CALL  (15),(TBTOP,LSPACTAB),VL BACK TO TOP ROW\n         SPACE 1\nTABLEDIS DS    0H\n         CLI   FTIME,X'FF'\n         BE    CONT1\n         MVI   FTIME,X'FF'\n         TBSORT LSPACTAB,FIELDS='(UVOL,C,A)'\n         SPACE\nCONT1    LR    R15,R9             GET A(ISPLINK)\n         CALL  (15),(TBDISPL,LSPACTAB,LSPACTAB),VL\n         SPACE 1\n         CH    R15,=H'8'             WAS END OR RETURN PRESSED\n         BH    EOJ                   YES- DISPLAY VOLSER SELECTION\n         LTR   15,15                    WAS PF3 HIT\n         BNZ   MAIN                     YES\n         CLC   ZENVIR,=F'0'             ISPF VERSION 2?\n         BNE   MAIN                     IF NOT GET OUT\n         CLC   ZCMD(8),=CL8'VOLUME'\n         BNE   NOTVOL\n         TBSORT LSPACTAB,FIELDS='(UVOL,C,A)'\n         SPACE\n         B     TABLEDIS\nNOTVOL   DS    0H\n         CLC   ZCMD(8),=CL8'FREE'\n         BNE   NOTFREE\n         TBSORT LSPACTAB,FIELDS='(NCYL,N,D,NTRK,N,D)'\n         SPACE\n         B     TABLEDIS\nNOTFREE  DS    0H\n         CLC   ZCMD(8),=CL8'LARGEST'\n         BNE   NOTLARG\n         TBSORT LSPACTAB,FIELDS='(LCYL,N,D,LTRK,N,D)'\n         SPACE\nNOTLARG  B     TABLEDIS\n         SPACE\nNOTFND   LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(DISPLAY,SKIPPARM,MESSAGE1),VL\n         B     MAIN1\n*\n         SPACE 3\n***********************************************************************\n*        LINKAGE EXIT SEQUENCE\n***********************************************************************\n         SPACE 1\nEOJ      DS    0H\n         CLI   TBCRDONE,X'FF'     WAS TBCREATE DONE?\n         BNE   NOCLOSE            DON'T CLOSE IT IF SO\n         LR    R15,R9             GET ISPLINK ADDRESS\n         CALL  (15),(TBEND,LSPACTAB),VL DELETE TABLE\n         SPACE\nNOCLOSE  DS    0H\n         VRESET ,\n         SPACE\n         DELETE EP=ISPLINK        REDUCE ISPLINK USE COUNT\n         SPACE\n         L     R13,SAVEAREA+4\n         RETURN (14,12),RC=0\n         SPACE 3\n***********************************************************************\n*        CONSTANTS AND OTHER GARBAGE\n***********************************************************************\n         SPACE 1\nSAVEAREA DC    18F'-1'         LINKAGE SAVEAREA\nSVC78RTN DS    D               SVC78 RETURN CODE WORK AREA\nVOLS     DC    F'0'\nZENVIR   DS    A\nZCMD     DS    CL80\n         ISPF  PARMS           SPF PARMS AREA\n         SPACE\nFTIME    DS    C\nNUMCYLH  DS    CL5             HOLD AREA TO PACK INTO\nNUMTRKH  DS    CL3             HOLD AREA TO PACK INTO\nNUMXTNTH DS    CL3             HOLD AREA TO PACK INTO\nLRGCYLH  DS    CL5             HOLD AREA TO PACK INTO\nLRGTRKH  DS    CL3             HOLD AREA TO PACK INTO\nTEMPWK5  DS    CL5             HOLD AREA TO PACK INTO\nHOLD6BYT DS    CL6             HOLD AREA TO UNPACK INTO\nMASK     DC    X'402020202120' EDIT MASK\n         SPACE 1\nWORKA    DC    100X'00'        UCBLOOKUP WORK AREA                 XA\nDEV      DC    X'20'           DASD DEVICE CLASS BYTE              XA\nUCBA     DC    A(0)            RETURNED UCB ADDRESS                XA\n         SPACE 1\nENTERKEY DC    H'0000'         ENTER KEY RETURN CODE\nENDKEY   DC    H'0008'         END OR RETURN KEY RETURN CODE\nU3330#1  EQU   X'09'           MASK FOR UNIT 3330-1\nU3330#11 EQU   X'0D'           MASK FOR UNIT 3330-11\nU3350    EQU   X'0B'           MASK FOR UNIT 3350\nU3380    EQU   X'0E'           MASK FOR UNIT 3380\nU2305#2  EQU   X'07'           MASK FOR UNIT 2305-2 (OR STC 4305)\nINDXED   DC    CL9'YES      '  VTOC TYPE LITERAL\nUNINDXED DC    CL9'NO       '  VTOC TYPE LITERAL\n         SPACE 1\nDISPLAY  DC    CL8'DISPLAY'\nVDEFINE  DC    CL8'VDEFINE'\nTBADD    DC    CL8'TBADD'\nTBTOP    DC    CL8'TBTOP'\nTBEND    DC    CL8'TBEND'\nTBDISPL  DC    CL8'TBDISPL'\nTBCREATE DC    CL8'TBCREATE'\nLSPACTAB DC    CL8'LSPDP2'\nNOWRITE  DC    CL8'NOWRITE'\nREPLACE  DC    CL8'REPLACE'\n         SPACE 1\nCHAR     DC    CL8'CHAR'\nPANEL1   DC    CL8'LSPDP1'     MEMBER NAME IN PANEL LIB\nMESSAGE1 DC    CL8'LSPM001'    MEMBER NAME IN PANEL LIB IS LSPM00\nMESSAGE2 DC    CL8'LSPM002'    MEMBER NAME IN PANEL LIB IS LSPM00\nSKIPPARM DC    C' '\nTBCRDONE DC    X'00'              SWITCH TO INDICATE TBCREATE DONE\nLENG3    DC    F'3'\nLENG5    DC    F'5'\nLENG6    DC    F'6'\nLENG7    DC    F'7'\nLENG9    DC    F'9'\nEXTVL3   DC    C'(UAD)'\nEXTVL5   DC    C'(NCYL NTRK NXT LCYL LTRK)'\nEXTVL6   DC    C'(VOL RETCODE UVOL VOLS)'\nEXTVL7   DC    C'(UTYP UMNT)'\nEXTVL9   DC    C'(IX)'\nTABLINE  DC    C'(UVOL UAD UTYP NCYL NTRK NXT LCYL LTRK UMNT)'\n*\nINTVL6   DS    0H\n$VOLSER  DS    CL6             VOLUME SERIAL (INPUT)\n$RETCODE DS    CL6             SVC78 RETURN CODE (FOR DISPLAY)\nUVOL     DS    CL6             VOLUME SERIAL (OUTPUT)\n$VOLS    DS    CL6                VOLUME HIT COUNT\n         DS    C               FILLER FOR UNPACK -> IF YOU HAVE TO ADD\n*                              ANOTHER LENGTH 6 VARIABLE, BE CAREFUL AS\n*                              YOU MUST CHANGE UNPACK LOGIC BECAUSE OF\n*                              THIS FILLER FIELD. (IT WILL HAVE TO GO)\n*\nINTVL3   DS    0H\n$UAD     DS    CL3             UNIT ADDRESS\n*\nINTVL7   DS    0H\n$UTYP    DS    CL7             UNIT TYPE\n$UMOUNT  DS    CL7             MOUNT STATUS\n*\nINTVL5   DS    0H\n$NUMCYL  DC    C'00000'        NUMBER OF FREE CYLINDERS\n$NUMTRK  DC    C'00000'        NUMBER OF FREE TRACKS\n$NUMXTNT DC    C'00000'        NUMBER OF FREE EXTENTS\n$LRGCYL  DC    C'00000'        LARGEST EXTENT OF FREE CYLINDERS\n$LRGTRK  DC    C'00000'        LARGEST EXTENT OF FREE TRACKS\n*\nINTVL9   DS    0H\n$VTOC    DS    CL9             VTOC TYPE INDICATOR\n*\nSVC78MSG DS    0CL30\n         DS    CL6\nNUMCYL   DS    CL4             NUMBER OF FREE CYLINDERS\n         DS    C\nNUMTRK   DS    CL4             NUMBER OF FREE TRACKS\n         DS    C\nNUMXTNT  DS    CL4             NUMBER OF FREE EXTENTS\n         DS    C\nLRGCYL   DS    CL4             LARGEST EXTENT OF FREE CYLINDERS\n         DS    C\nLRGTRK   DS    CL4             LARGEST EXTENT OF FREE TRACKS\n         SPACE 3\nCVT      DSECT\n         CVT   DSECT=YES\nUCB      DSECT\n         IEFUCBOB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LST0A": {"ttr": 8711, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "000010 IDENTIFICATION DIVISION.                                         04/04/86\n000020 PROGRAM-ID.    LST0A.                                            LST0A\n000030 AUTHOR.        BOB ZIMMERMAN.                                       LV005\n000040 INSTALLATION.  CNA INSURANCE.\n000050 DATE-COMPILED.\n000060\n000070******************************************************************\n000080*    BOB ZIMMERMAN                                               *\n000090*    CNA INSURANCE                                               *\n000100*    (312) 822-5719                                              *\n000110*    LAST MODIFIED 8506                                          *\n000120******************************************************************\n000130/\n000140 ENVIRONMENT DIVISION.\n000150 DATA DIVISION.\n000160 WORKING-STORAGE SECTION.\n000170\n000180******************************************************************\n000190*    THE FOLLOWING TWO ALPHABETS ARE USED TO TRANSLATE ANY PARMS *\n000200*    PASSED THRU LINKAGE FROM LOWER-CASE TO UPPER-CASE. THE 05   *\n000210*    LEVEL BELOW MARKED LOWER-CASE SHOULD BE THE ALPHABET IN     *\n000220*    LOWER-CASE.                                                 *\n000230******************************************************************\n000240 01  THE-ALPHABET.\n000250     05  UPPER-CASE                    PIC X(26) VALUE\n000260         'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n000270     05  LOWER-CASE                    PIC X(26) VALUE\n000280         'abcdefghijklmnopqrstuvwxyz'.\n000290\n000300\n000310\n000320******************************************************************\n000330*    SPF-VARIABLES IS THE WORKING STORAGE AREA USED TO CONTAIN   *\n000340*    THE CONTENTS OF THE ISPF VARIABLES USED IN THIS DIALOG.     *\n000350*    THESE VARIABLES MAY BE ACCESSED USING EITHER THE VDEFINE    *\n000360*    SERVICE OR THE VCOPY SERVICE.                               *\n000370******************************************************************\n000380\n000390 01  SPF-VARIABLES.\n000400     05  SPF-ZTDTOP                    PIC S9(09) COMP.\n000410     05  SPF-CSR                       PIC S9(09) COMP.\n000420     05  SPF-SEQUENCE                  PIC S9(09) COMP VALUE ZERO.\n000430     05  SPF-LAST-CSR                  PIC S9(09) COMP VALUE ZERO.\n000440     05  SPF-DDNAME                    PIC X(08) VALUE SPACES.\n000450     05  SPF-ALTDDNAM                  PIC X(08) VALUE SPACES.\n000460     05  SPF-SCAN                      PIC X(04) VALUE 'SCAN'.\n000470     05  SPF-SCAN-BYTE                 PIC X(01) VALUE ' '.\n000480     05  SPF-MORE                      PIC X(01) VALUE SPACES.\n000490     05  SPF-DSNAME                    PIC X(56) VALUE SPACES.\n000500     05  SPF-LSEL                      PIC X(02) VALUE SPACES.\n000510     05  SPF-VOLSER                    PIC X(06) VALUE SPACES.\n000520     05  WORK-NUM                      PIC ZZZ9.\n000530\n000540\n000550\n000560******************************************************************\n000570*    THE FOLLOWING WORKING STORAGE AREA IS USED TO CONTAIN THE   *\n000580*    LIST OF DDNAMES CURRENTLY FOUND IN THE TIOT. THIS AREA IS   *\n000590*    PASSED TO PROGRAM DDNLIST (WHICH FILLS IN THE DDNAMES).     *\n000600******************************************************************\n000610\n000620 01  DDNLIST-AREA.\n000630     05  DDN-LIST-COUNT                PIC S9(04) COMP VALUE +0.\n000640     05  DDN-TABLE.\n000650         10  DDN-DDNAME                PIC X(08)\n000660                                       OCCURS 500 TIMES\n000670                                       INDEXED BY DDN-INX.\n000680/\n000690******************************************************************\n000700*    THE FOLLOWING WORKING STORAGE AREA IS USED IN PROCESSING    *\n000710*    AND PARSING THE COMMAND LINE.                               *\n000720******************************************************************\n000730\n000740 01  ZCMD-PROCESS-AREA                 SYNC.\n000750     05  ZCMD-COMMAND-LINE             PIC X(80) VALUE SPACES.\n000760     05  ZCMD-OVERFLOW-SWITCH          PIC 9(01) VALUE 0.\n000770     05  ZCMD-COMMAND                  PIC X(80) VALUE SPACES.\n000780     05  ZCMD-PARM-COUNT               PIC S9(04) COMP VALUE +0.\n000790     05  ZCMD-PARM-TABLE.\n000800         10  ZCMD-PARM                 PIC X(80)\n000810                                       OCCURS 20 TIMES\n000820                                       INDEXED BY ZCMD-INX.\n000830\n000840\n000850\n000860******************************************************************\n000870*    THE FOLLOWING AREA IS USED TO RETURN THE DSNAME AND         *\n000880*    VOLSER FOR ANY GIVEN DDNAME IN THE TIOT. KDSNSUB            *\n000890*    (SUBROUTINE) IS CALLED TO RETURN THIS INFORMATION.          *\n000900******************************************************************\n000910\n000920 01  KDSNSUB-AREA                     SYNC.\n000930     05  KDSNSUB-DDNAME                PIC X(08) VALUE SPACES.\n000940     05  KDSNSUB-COUNT                 PIC S9(04) COMP VALUE +15.\n000950     05  KDSNSUB-DSN-TABLE.\n000960         10  KDSNSUB-DSN               PIC X(44)\n000970                                       OCCURS 15 TIMES\n000980                                       INDEXED BY DSN-INX.\n000990     05  KDSNSUB-VOL-TABLE.\n001000         10  KDSNSUB-VOL               PIC X(06)\n001010                                       OCCURS 15 TIMES\n001020                                       INDEXED BY VOL-INX.\n001030/\n001040******************************************************************\n001050*    THE FOLLOWING AREA IS USED FOR ISPF DIALOG CALLS. IT        *\n001060*    CONTAINS LITERALS, NAMELISTS AND WORKING STORAGE AREAS      *\n001070*    THAT THE DIALOG CALLS REQUIRE.                              *\n001080******************************************************************\n001090\n001100 01  PDF-WORK-AREAS                   SYNC.\n001110     05  PDF-DUMMY-PARAMETER          PIC X(8) VALUE '        '.\n001120     05  PDF-BROWSE                   PIC X(8) VALUE 'BROWSE'.\n001130     05  PDF-CANCEL                   PIC X(8) VALUE 'CANCEL'.\n001140     05  PDF-CHAR                     PIC X(8) VALUE 'CHAR'.\n001150     05  PDF-CONTROL                  PIC X(8) VALUE 'CONTROL'.\n001160     05  PDF-DISPLAY                  PIC X(8) VALUE 'DISPLAY'.\n001170     05  PDF-EDIT                     PIC X(8) VALUE 'EDIT'.\n001180     05  PDF-EDIT-PROFILE             PIC X(8) VALUE '    '.\n001190     05  PDF-ERRORS                   PIC X(8) VALUE 'ERRORS'.\n001200     05  PDF-LINE                     PIC X(8) VALUE 'LINE'.\n001210     05  PDF-MOVE                     PIC X(8) VALUE 'MOVE'.\n001220     05  PDF-NEXT                     PIC X(8) VALUE 'NEXT'.\n001230     05  PDF-NOWRITE                  PIC X(8) VALUE 'NOWRITE'.\n001240     05  PDF-ORDER                    PIC X(8) VALUE 'ORDER'.\n001250     05  PDF-PREVIOUS                 PIC X(8) VALUE 'PREVIOUS'.\n001260     05  PDF-REPLACE                  PIC X(8) VALUE 'REPLACE'.\n001270     05  PDF-RESTORE                  PIC X(8) VALUE 'RESTORE'.\n001280     05  PDF-RETURN                   PIC X(8) VALUE 'RETURN'.\n001290     05  PDF-SAVE                     PIC X(8) VALUE 'SAVE'.\n001300     05  PDF-SELECT                   PIC X(8) VALUE 'SELECT'.\n001310     05  PDF-TBADD                    PIC X(8) VALUE 'TBADD'.\n001320     05  PDF-TBBOTTOM                 PIC X(8) VALUE 'TBBOTTOM'.\n001330     05  PDF-TBCREATE                 PIC X(8) VALUE 'TBCREATE'.\n001340     05  PDF-TBDISPL                  PIC X(8) VALUE 'TBDISPL'.\n001350     05  PDF-TBEND                    PIC X(8) VALUE 'TBEND'.\n001360     05  PDF-TBQUERY                  PIC X(8) VALUE 'TBQUERY'.\n001370     05  PDF-TBSARG                   PIC X(8) VALUE 'TBSARG'.\n001380     05  PDF-TBSCAN                   PIC X(8) VALUE 'TBSCAN'.\n001390     05  PDF-TBSORT                   PIC X(8) VALUE 'TBSORT'.\n001400     05  PDF-TBSKIP                   PIC X(8) VALUE 'TBSKIP'.\n001410     05  PDF-TBTOP                    PIC X(8) VALUE 'TBTOP'.\n001420     05  PDF-TBVCLEAR                 PIC X(8) VALUE 'TBVCLEAR'.\n001430     05  PDF-FIXED                    PIC X(8) VALUE 'FIXED'.\n001440     05  PDF-VCOPY                    PIC X(8) VALUE 'VCOPY'.\n001450     05  PDF-VDEFINE                  PIC X(8) VALUE 'VDEFINE'.\n001460     05  PDF-VREPLACE                 PIC X(8) VALUE 'VREPLACE'.\n001470     05  PDF-VRESET                   PIC X(8) VALUE 'VRESET'.\n001480     05  PDF-FULLWORD                 PIC S9(09) COMP.\n001490     05  PDF-RETURN-CODE              PIC S9(09) COMP.\n001500     05  PDF-BROWSE-RETURN-CODE       PIC S9(09) COMP.\n001510     05  PDF-TBDISPL-ROW              PIC S9(09) COMP.\n001520     05  PDF-SELECT-BUFFER-LENGTH     PIC S9(09) COMP.\n001530     05  PDF-NAME-LIST                PIC X(256).\n001540     05  PDF-COND-LIST                PIC X(80).\n001550     05  PDF-TABLE-ID.\n001560         10  PDF-TABLE-ID-PREFACE     PIC X(5).\n001570         10  FILLER                   PIC X(3).\n001580     05  PDF-TBDISPL-PANEL            PIC X(8).\n001590     05  PDF-TBDISPL-AUTOSEL          PIC X(3).\n001600     05  PDF-TBDISPL-MESSAGE          PIC X(8).\n001610     05  PDF-TBDISPL-CURSOR           PIC X(8).\n001620     05  PDF-TBQUERY-CRP              PIC X(8).\n001630     05  PDF-SHORT-MESSAGE            PIC X(24).\n001640     05  PDF-LONG-MESSAGE             PIC X(78).\n001650     05  PDF-SELECT-BUFFER            PIC X(256).\n001660     05  PDF-DSNAME                   PIC X(56).\n001670     05  PDF-VOLSER                   PIC X(6).\n001680\n001690/\n001700******************************************************************\n001710*    DDNAME TABLE RECEIVED THRU PARMS                            *\n001720******************************************************************\n001730 01  MATCH-SW                         PIC X.\n001740 01  DDNAME-TABLE.\n001750     05  PASSED-DDNAME                PIC X(08)\n001760                                      OCCURS 50 TIMES\n001770                                      INDEXED BY PDDN-INX.\n001780 01  DDNAME-TABLE-1.\n001790     05  PASSED-DDNAME-LET-1          PIC X(01)\n001800                                      OCCURS 8 TIMES\n001810                                      INDEXED BY PDDN-1.\n001820 01  DDNAME-TABLE-2.\n001830     05  PASSED-DDNAME-LET-2          PIC X(01)\n001840                                      OCCURS 8 TIMES\n001850                                      INDEXED BY PDDN-2.\n001860/\n001870******************************************************************\n001880*    THE ONLY PARAMETER ALLOWED PASSED IS THE WORD FULL. IT      *\n001890*    WILL INITALIZE THE TBDISPL TO BE IN FULL MODE AS APPOSED    *\n001900*    TO COMPRESS MODE. THE PARAMETER IS PASSED USING STANDARD    *\n001910*    TSO (EXEC PGM= PARM=) CONVENTIONS.                          *\n001920******************************************************************\n001930\n001940 LINKAGE SECTION.\n001950 01  PASSED-PARMS.\n001960     05  PARM-LENGTH                   PIC S9(04) COMP.\n001970     05  PARM-DATA.\n001980         10  PARM-DATA-LETTER          PIC X(01)\n001990                                       OCCURS 1 TO 256 TIMES\n002000                                       DEPENDING ON PARM-LENGTH.\n002010/\n002020 PROCEDURE DIVISION USING PASSED-PARMS.\n002030\n002040******************************************************************\n002050*    INITALIZE WORKING STORAGE AREAS.                            *\n002060*    CAPITOLIZE THE PARMS PASSED (IN CASE THEY ARE LOWER         *\n002070*    CASE).                                                      *\n002080*    VDEFINE AND VCOPY ANY ISPF VARIABLES THAT ARE REQUIRED.     *\n002090******************************************************************\n002100\n002110 0100-INIT-AND-VDEFINE.\n002120\n002130     TRANSFORM PARM-DATA FROM LOWER-CASE TO UPPER-CASE.\n002140\n002150     CALL 'ISPLINK' USING             PDF-CONTROL\n002160                                      PDF-ERRORS\n002170                                      PDF-CANCEL.\n002180\n002190     IF PARM-LENGTH > 0 THEN\n002200        MOVE '(PASSPARM)' TO PDF-NAME-LIST\n002210        MOVE PARM-LENGTH TO PDF-FULLWORD\n002220        CALL 'ISPLINK' USING          PDF-VREPLACE\n002230                                      PDF-NAME-LIST\n002240                                      PDF-FULLWORD\n002250                                      PARM-DATA.\n002260\n002270     IF PARM-DATA = 'FULL'\n002280         MOVE SPACES TO PARM-DATA\n002290         MOVE 'ALL' TO SPF-SCAN.\n002300\n002310     IF PARM-DATA NOT = SPACES\n002320         UNSTRING PARM-DATA DELIMITED BY ALL SPACES\n002330         INTO PASSED-DDNAME (1) PASSED-DDNAME(2) PASSED-DDNAME(3)\n002340           PASSED-DDNAME (4) PASSED-DDNAME(5) PASSED-DDNAME(6)\n002350           PASSED-DDNAME (7) PASSED-DDNAME(8) PASSED-DDNAME(9)\n002360           PASSED-DDNAME (10) PASSED-DDNAME(11) PASSED-DDNAME(12)\n002370           PASSED-DDNAME (13) PASSED-DDNAME(14) PASSED-DDNAME(15)\n002380           PASSED-DDNAME (16) PASSED-DDNAME(17) PASSED-DDNAME(18)\n002390           PASSED-DDNAME (19)\n002400           PASSED-DDNAME(20) PASSED-DDNAME(21) PASSED-DDNAME (22)\n002410           PASSED-DDNAME(23) PASSED-DDNAME(24) PASSED-DDNAME (25)\n002420           PASSED-DDNAME(26) PASSED-DDNAME(27) PASSED-DDNAME (28)\n002430           PASSED-DDNAME(29)\n002440           PASSED-DDNAME(30) PASSED-DDNAME(31) PASSED-DDNAME (32)\n002450           PASSED-DDNAME(33) PASSED-DDNAME(34) PASSED-DDNAME (35)\n002460           PASSED-DDNAME(36) PASSED-DDNAME(37) PASSED-DDNAME (38)\n002470           PASSED-DDNAME(39)\n002480           PASSED-DDNAME(40) PASSED-DDNAME(41) PASSED-DDNAME (42)\n002490           PASSED-DDNAME(43) PASSED-DDNAME(44) PASSED-DDNAME (45)\n002500           PASSED-DDNAME(46) PASSED-DDNAME(47) PASSED-DDNAME (48)\n002510           PASSED-DDNAME(49)\n002520           PASSED-DDNAME(50)\n002530         MOVE 'ALL' TO SPF-SCAN\n002540       ELSE MOVE SPACES TO DDNAME-TABLE.\n002550\n002560******************************************************************\n002570*    ZTDTOP   -  IS THE ISPF VARIABLE FOR TABLE HANDELING        *\n002580*    CSR      -  REPRESENTS THE CURRENT CRP FROM TBDISPL         *\n002590*    SEQNUM   -  IS USED TO IDENTIFY THE DSNAMES WITHIN DDNAME   *\n002600******************************************************************\n002610\n002620     MOVE '(ZTDTOP CSR SEQNUM)' TO PDF-NAME-LIST.\n002630     MOVE +4 TO PDF-FULLWORD.\n002640     CALL 'ISPLINK' USING              PDF-VDEFINE\n002650                                       PDF-NAME-LIST\n002660                                       SPF-ZTDTOP\n002670                                       PDF-FIXED\n002680                                       PDF-FULLWORD.\n002690\n002700\n002710******************************************************************\n002720*    SCAN     -  THE VARIABLE DETERMINING IF THIS ROW IS THE     *\n002730*                FIRST ROW OF A CONCATENATION OR NOT.            *\n002740*                USED TO CONTROL FULL/COMPRESS OPTIONS           *\n002750******************************************************************\n002760\n002770     MOVE '(SCAN)' TO PDF-NAME-LIST.\n002780     CALL 'ISPLINK' USING              PDF-VDEFINE\n002790                                       PDF-NAME-LIST\n002800                                       SPF-SCAN\n002810                                       PDF-CHAR\n002820                                       PDF-FULLWORD.\n002830\n002840******************************************************************\n002850*    ZCMD     -  ISPF COMMAND LINE - PRIMARY COMMANDS            *\n002860******************************************************************\n002870\n002880     MOVE '(ZCMD)' TO PDF-NAME-LIST.\n002890     MOVE +80 TO PDF-FULLWORD.\n002900     CALL 'ISPLINK' USING              PDF-VDEFINE\n002910                                       PDF-NAME-LIST\n002920                                       ZCMD-COMMAND-LINE\n002930                                       PDF-CHAR\n002940                                       PDF-FULLWORD.\n002950\n002960\n002970******************************************************************\n002980*    SCANSW   -  SWITCH IN TABLE TO DETERMINE IF THE ROW         *\n002990*                SHOULD BE DISPLAYED IN COMPRESS MODE.           *\n003000******************************************************************\n003010\n003020     MOVE '(SCANSW MORE)' TO PDF-NAME-LIST.\n003030     MOVE +1 TO PDF-FULLWORD.\n003040     CALL 'ISPLINK' USING              PDF-VDEFINE\n003050                                       PDF-NAME-LIST\n003060                                       SPF-SCAN-BYTE\n003070                                       PDF-CHAR\n003080                                       PDF-FULLWORD.\n003090\n003100******************************************************************\n003110*    DDNAME   -  THE DDNAME DISPLAYED (TBDISPL)                  *\n003120*    ALTDDNAME-  SECOND DDNAME FOR IDENTIFYING THE ROW (TBSORT)  *\n003130******************************************************************\n003140\n003150     MOVE '(DDNAME ALTDDNAM)' TO PDF-NAME-LIST.\n003160     MOVE +8 TO PDF-FULLWORD.\n003170     CALL 'ISPLINK' USING              PDF-VDEFINE\n003180                                       PDF-NAME-LIST\n003190                                       SPF-DDNAME\n003200                                       PDF-CHAR\n003210                                       PDF-FULLWORD.\n003220\n003230\n003240******************************************************************\n003250*    VOLSER   -  THE VOLSER FOR TBDISPL                          *\n003260******************************************************************\n003270\n003280     MOVE '(VOLSER)' TO PDF-NAME-LIST.\n003290     MOVE +6 TO PDF-FULLWORD.\n003300     CALL 'ISPLINK' USING              PDF-VDEFINE\n003310                                       PDF-NAME-LIST\n003320                                       SPF-VOLSER\n003330                                       PDF-CHAR\n003340                                       PDF-FULLWORD.\n003350\n003360\n003370******************************************************************\n003380*    DSNAME   -  THE DSNAME FOR TBDISPL                          *\n003390******************************************************************\n003400\n003410     MOVE '(DSNAME)' TO PDF-NAME-LIST.\n003420     MOVE +56 TO PDF-FULLWORD.\n003430     CALL 'ISPLINK' USING              PDF-VDEFINE\n003440                                       PDF-NAME-LIST\n003450                                       SPF-DSNAME\n003460                                       PDF-CHAR\n003470                                       PDF-FULLWORD.\n003480\n003490\n003500******************************************************************\n003510*    LSEL     -  THE LINE COMMAND VARIABLE                       *\n003520******************************************************************\n003530\n003540     MOVE '(LSEL)' TO PDF-NAME-LIST.\n003550     MOVE +2 TO PDF-FULLWORD.\n003560     CALL 'ISPLINK' USING              PDF-VDEFINE\n003570                                       PDF-NAME-LIST\n003580                                       SPF-LSEL\n003590                                       PDF-CHAR\n003600                                       PDF-FULLWORD.\n003610\n003620\n003630******************************************************************\n003640*    UMSG     -  SHORT (UPPER) MESSAGE FOR ERRORS                *\n003650******************************************************************\n003660\n003670     MOVE '(UMSG)' TO PDF-NAME-LIST.\n003680     MOVE +24 TO PDF-FULLWORD.\n003690     CALL 'ISPLINK' USING              PDF-VDEFINE\n003700                                       PDF-NAME-LIST\n003710                                       PDF-SHORT-MESSAGE\n003720                                       PDF-CHAR\n003730                                       PDF-FULLWORD.\n003740\n003750\n003760******************************************************************\n003770*    LMSG     -  LONG (LOWER) MESSAGE FOR ERRORS                 *\n003780******************************************************************\n003790\n003800     MOVE '(LMSG)' TO PDF-NAME-LIST.\n003810     MOVE +78 TO PDF-FULLWORD.\n003820     CALL 'ISPLINK' USING              PDF-VDEFINE\n003830                                       PDF-NAME-LIST\n003840                                       PDF-LONG-MESSAGE\n003850                                       PDF-CHAR\n003860                                       PDF-FULLWORD.\n003870\n003880\n003890******************************************************************\n003900*    RET0TABL -  PROGRAM RETURNS UNIQUE TABLE ID                 *\n003910*                THIS SUPPORTS RECURSIVE USE OF THIS FUNCTION    *\n003920******************************************************************\n003930\n003940     CALL 'RET0TABL' USING            PDF-TABLE-ID.\n003950     MOVE 'LISTA' TO PDF-TABLE-ID-PREFACE.\n003960\n003970     MOVE 'LSTDA' TO PDF-TBDISPL-PANEL.\n003980     MOVE SPACES TO PDF-TBDISPL-MESSAGE.\n003990     MOVE SPACES TO PDF-TBDISPL-CURSOR.\n004000     MOVE ZEROS TO PDF-TBDISPL-ROW.\n004010\n004020     PERFORM 2000-BUILD-TABLE THRU 2999-EXIT.\n004030\n004040     MOVE ZEROS TO PDF-RETURN-CODE.\n004050     PERFORM 1000-DISPLAY-PANEL THRU 1999-EXIT\n004060         UNTIL PDF-RETURN-CODE > 4.\n004070\n004080 EXIT-PROGRAM.\n004090\n004100\n004110     CALL 'ISPLINK' USING PDF-TBEND PDF-TABLE-ID.\n004120     CALL 'ISPLINK' USING              PDF-VRESET.\n004130     GOBACK.\n004140/\n004150\n004160\n004170 1000-DISPLAY-PANEL.\n004180\n004190     CALL 'ISPLINK' USING              PDF-TBTOP\n004200                                       PDF-TABLE-ID.\n004210\n004220     CALL 'ISPLINK' USING              PDF-TBSKIP\n004230                                       PDF-TABLE-ID\n004240                                       SPF-ZTDTOP.\n004250\n004260     IF PDF-TBDISPL-MESSAGE NOT = SPACES\n004270         MOVE 'YES' TO PDF-TBDISPL-AUTOSEL\n004280     ELSE\n004290         MOVE 'NO' TO PDF-TBDISPL-AUTOSEL\n004300         MOVE SPF-LAST-CSR TO PDF-TBDISPL-ROW\n004310         IF SPF-LAST-CSR NOT = 0\n004320             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR.\n004330\n004340     CALL 'ISPLINK' USING              PDF-TBDISPL\n004350                                       PDF-TABLE-ID\n004360                                       PDF-TBDISPL-PANEL\n004370                                       PDF-TBDISPL-MESSAGE\n004380                                       PDF-TBDISPL-CURSOR\n004390                                       PDF-TBDISPL-ROW\n004400                                       PDF-DUMMY-PARAMETER\n004410                                       PDF-TBDISPL-AUTOSEL.\n004420     MOVE RETURN-CODE TO PDF-RETURN-CODE.\n004430     IF PDF-RETURN-CODE > 4\n004440         GO TO 1999-EXIT.\n004450\n004460\n004470     MOVE 'LSTDA' TO PDF-TBDISPL-PANEL.\n004480     MOVE SPACES TO PDF-TBDISPL-MESSAGE.\n004490     MOVE SPACES TO PDF-TBDISPL-CURSOR.\n004500     MOVE ZEROS TO PDF-TBDISPL-ROW.\n004510     MOVE ZEROS TO SPF-CSR, SPF-LAST-CSR.\n004520\n004530\n004540\n004550 1100-TBQUERY-CRP.\n004560     MOVE 'CSR' TO PDF-TBQUERY-CRP.\n004570     CALL 'ISPLINK' USING              PDF-TBQUERY\n004580                                       PDF-TABLE-ID\n004590                                       PDF-DUMMY-PARAMETER\n004600                                       PDF-DUMMY-PARAMETER\n004610                                       PDF-DUMMY-PARAMETER\n004620                                       PDF-DUMMY-PARAMETER\n004630                                       PDF-DUMMY-PARAMETER\n004640                                       PDF-TBQUERY-CRP.\n004650\n004660     IF SPF-CSR = 0 GO TO 1500-PROCESS-ZCMD.\n004670     MOVE SPF-CSR TO SPF-LAST-CSR.\n004680\n004690     PERFORM 4000-LINE-COMMAND THRU 4999-EXIT.\n004700\n004710     IF PDF-TBDISPL-MESSAGE NOT = SPACES\n004720         GO TO 1999-EXIT.\n004730\n004740     IF PDF-RETURN-CODE = 4\n004750         MOVE SPACES TO PDF-TBDISPL-PANEL\n004760         GO TO 1999-EXIT.\n004770\n004780 1500-PROCESS-ZCMD.\n004790     IF ZCMD-COMMAND-LINE = SPACES\n004800         GO TO 1999-EXIT.\n004810\n004820     MOVE ZEROS TO ZCMD-PARM-COUNT.\n004830     MOVE ZEROS TO ZCMD-OVERFLOW-SWITCH.\n004840     MOVE SPACES TO ZCMD-COMMAND.\n004850     MOVE SPACES TO ZCMD-PARM-TABLE.\n004860\n004870     UNSTRING ZCMD-COMMAND-LINE\n004880              DELIMITED BY ALL SPACES\n004890              INTO ZCMD-COMMAND\n004900              ZCMD-PARM (1)\n004910              ZCMD-PARM (2)\n004920              ZCMD-PARM (3)\n004930              ZCMD-PARM (4)\n004940              ZCMD-PARM (5)\n004950              ZCMD-PARM (6)\n004960              ZCMD-PARM (7)\n004970              ZCMD-PARM (8)\n004980              ZCMD-PARM (9)\n004990              ZCMD-PARM (10)\n005000              ZCMD-PARM (11)\n005010              ZCMD-PARM (12)\n005020              ZCMD-PARM (13)\n005030              ZCMD-PARM (14)\n005040              ZCMD-PARM (15)\n005050              ZCMD-PARM (16)\n005060              ZCMD-PARM (17)\n005070              ZCMD-PARM (18)\n005080              ZCMD-PARM (19)\n005090              ZCMD-PARM (20)\n005100              TALLYING ZCMD-PARM-COUNT\n005110              ON OVERFLOW\n005120                  MOVE +1 TO ZCMD-OVERFLOW-SWITCH.\n005130\n005140     IF ZCMD-PARM-COUNT > 0\n005150         SUBTRACT 1 FROM ZCMD-PARM-COUNT.\n005160\n005170     IF ZCMD-OVERFLOW-SWITCH NOT = 0\n005180         MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n005190         MOVE 'THERE IS A LIMIT OF 20 PARAMETERS TO ANY PRIMARY CO\n005200-        'COMMAND' TO PDF-LONG-MESSAGE\n005210         MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005220         MOVE SPACES TO PDF-TBDISPL-PANEL\n005230         GO TO 1999-EXIT.\n005240\n005250 1600-COMPRESS-COMMAND.\n005260     IF ZCMD-COMMAND = 'COMPRESS' OR 'CMP'\n005270         IF ZCMD-PARM-COUNT NOT = 0\n005280             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n005290             MOVE 'THERE ARE NO VALID PARMS FOR THIS COMMAND'\n005300             TO PDF-LONG-MESSAGE\n005310             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005320             MOVE SPACES TO PDF-TBDISPL-PANEL\n005330             GO TO 1999-EXIT.\n005340\n005350     IF ZCMD-COMMAND = 'COMPRESS' OR 'CMP'\n005360         MOVE 'SCAN' TO SPF-SCAN\n005370         MOVE SPACES TO ZCMD-COMMAND-LINE\n005380         GO TO 1999-EXIT.\n005390\n005400 1605-FULL-COMMAND.\n005410     IF ZCMD-COMMAND = 'FULL'\n005420         IF ZCMD-PARM-COUNT NOT = 0\n005430             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n005440             MOVE 'THERE ARE NO VALID PARMS FOR THIS COMMAND'\n005450             TO PDF-LONG-MESSAGE\n005460             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005470             MOVE SPACES TO PDF-TBDISPL-PANEL\n005480             GO TO 1999-EXIT.\n005490\n005500     IF ZCMD-COMMAND = 'FULL'\n005510         MOVE 'ALL' TO SPF-SCAN\n005520         MOVE SPACES TO ZCMD-COMMAND-LINE\n005530         GO TO 1999-EXIT.\n005540\n005550 1610-REFRESH-COMMAND.\n005560     IF ZCMD-COMMAND = 'REFRESH' OR '*' OR 'REF'\n005570         IF ZCMD-PARM-COUNT NOT = 0\n005580             MOVE 'INVALID PARAMETER' TO PDF-SHORT-MESSAGE\n005590             MOVE 'THERE ARE NO VALID PARMS FOR THIS COMMAND'\n005600             TO PDF-LONG-MESSAGE\n005610             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005620             MOVE SPACES TO PDF-TBDISPL-PANEL\n005630             GO TO 1999-EXIT.\n005640\n005650     IF ZCMD-COMMAND = 'REFRESH' OR '*' OR 'REF'\n005660         PERFORM 2000-BUILD-TABLE THRU 2999-EXIT\n005670         IF ZCMD-COMMAND NOT = '*'\n005680             MOVE SPACES TO ZCMD-COMMAND-LINE\n005690             GO TO 1999-EXIT\n005700         ELSE\n005710             GO TO 1999-EXIT.\n005720\n005730 1620-LOCATE-COMMAND.\n005740     IF ZCMD-COMMAND = 'LOCATE' OR 'L' OR 'LOC'\n005750         IF ZCMD-PARM-COUNT = 0\n005760             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n005770             MOVE 'EXPECTED DDNAME OR PARTIAL DDNAME TO LOCATE'\n005780             TO PDF-LONG-MESSAGE\n005790             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005800             MOVE SPACES TO PDF-TBDISPL-PANEL\n005810             GO TO 1999-EXIT\n005820\n005830         ELSE\n005840         IF ZCMD-PARM-COUNT > 1\n005850             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n005860             MOVE 'EXPECTED ONLY ONE PARAMETER FOR THIS COMMAND'\n005870             TO PDF-LONG-MESSAGE\n005880             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n005890             MOVE SPACES TO PDF-TBDISPL-PANEL\n005900             GO TO 1999-EXIT.\n005910\n005920     IF ZCMD-COMMAND = 'LOCATE' OR 'L' OR 'LOC'\n005930         PERFORM 5000-LOCATE THRU 5999-EXIT\n005940         GO TO 1999-EXIT.\n005950\n005960 1630-SETPROF-COMMAND.\n005970     IF ZCMD-COMMAND = 'SET' OR 'SETPROF'\n005980         IF ZCMD-PARM-COUNT = 0\n005990             MOVE 'MISSING PARAMETER' TO PDF-SHORT-MESSAGE\n006000             MOVE 'EXPECTED EDIT PROFILE NAME'\n006010             TO PDF-LONG-MESSAGE\n006020             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n006030             MOVE SPACES TO PDF-TBDISPL-PANEL\n006040             GO TO 1999-EXIT\n006050\n006060         ELSE\n006070         IF ZCMD-PARM-COUNT > 1\n006080             MOVE 'TOO MANY PARAMETERS' TO PDF-SHORT-MESSAGE\n006090             MOVE 'EXPECTED ONLY ONE PARAMETER FOR THIS COMMAND'\n006100             TO PDF-LONG-MESSAGE\n006110             MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n006120             MOVE SPACES TO PDF-TBDISPL-PANEL\n006130             GO TO 1999-EXIT.\n006140\n006150     IF ZCMD-COMMAND = 'SET' OR 'SETPROF'\n006160         IF ZCMD-PARM (1) = 'SPACES'\n006170             MOVE SPACES TO PDF-EDIT-PROFILE\n006180             GO TO 1999-EXIT\n006190         ELSE\n006200             MOVE ZCMD-PARM (1) TO PDF-EDIT-PROFILE\n006210             GO TO 1999-EXIT.\n006220\n006230 1990-INVALID-COMMAND.\n006240     MOVE 'ISPZ001' TO PDF-TBDISPL-MESSAGE.\n006250     MOVE SPACES TO PDF-TBDISPL-PANEL.\n006260\n006270 1999-EXIT.\n006280     IF PDF-RETURN-CODE = 0 AND\n006290        PDF-TBDISPL-MESSAGE = SPACES\n006300         PERFORM 2000-BUILD-TABLE THRU 2999-EXIT.\n006310\n006320/\n006330 2000-BUILD-TABLE.\n006340\n006350     MOVE '(DDNAME DSNAME MORE SCANSW VOLSER ALTDDNAM SEQNUM)'\n006360         TO PDF-NAME-LIST.\n006370     CALL 'ISPLINK' USING              PDF-TBCREATE\n006380                                       PDF-TABLE-ID\n006390                                       PDF-DUMMY-PARAMETER\n006400                                       PDF-NAME-LIST\n006410                                       PDF-NOWRITE\n006420                                       PDF-REPLACE.\n006430\n006440     CALL 'ISPLINK' USING              PDF-TBVCLEAR\n006450                                       PDF-TABLE-ID.\n006460\n006470     MOVE '1' TO SPF-SCAN-BYTE.\n006480     CALL 'ISPLINK' USING              PDF-TBSARG\n006490                                       PDF-TABLE-ID.\n006500\n006510     MOVE SPACES TO SPF-SCAN-BYTE.\n006520\n006530     MOVE '(ALTDDNAM,C,A,SEQNUM,N,A)' TO PDF-NAME-LIST.\n006540     MOVE 0 TO SPF-SEQUENCE.\n006550     MOVE +500 TO DDN-LIST-COUNT.\n006560     MOVE SPACES TO DDN-TABLE.\n006570     CALL 'DDNLIST' USING              DDN-LIST-COUNT\n006580                                       DDN-TABLE.\n006590\n006600     PERFORM 3000-BUILD-TABLE THRU 3999-EXIT\n006610         VARYING DDN-INX FROM 1 BY 1\n006620         UNTIL DDN-INX > DDN-LIST-COUNT.\n006630\n006640     CALL 'ISPLINK' USING             PDF-TBSORT\n006650                                      PDF-TABLE-ID\n006660                                      PDF-NAME-LIST.\n006670\n006680\n006690 2999-EXIT.\n006700     EXIT.\n006710/\n006720 3000-BUILD-TABLE.\n006730     IF DDNAME-TABLE NOT = SPACES\n006740        MOVE SPACES TO MATCH-SW\n006750        PERFORM 8000-MATCH THRU 8099-EXIT\n006760                VARYING PDDN-INX FROM 1 BY 1\n006770                UNTIL PDDN-INX > 50\n006780        IF MATCH-SW = SPACES\n006790           GO TO 3999-EXIT.\n006800     MOVE SPACES TO SPF-LSEL.\n006810     MOVE DDN-DDNAME (DDN-INX) TO KDSNSUB-DDNAME.\n006820     MOVE +15 TO KDSNSUB-COUNT.\n006830     CALL 'KDSNSUB' USING              KDSNSUB-DDNAME\n006840                                       KDSNSUB-COUNT\n006850                                       KDSNSUB-DSN-TABLE\n006860                                       KDSNSUB-VOL-TABLE.\n006870     MOVE ' ' TO SPF-MORE.\n006880     MOVE DDN-DDNAME (DDN-INX) TO SPF-DDNAME, SPF-ALTDDNAM.\n006890     PERFORM 10000-TBADD THRU 10099-EXIT\n006900         VARYING DSN-INX FROM 1 BY 1\n006910         UNTIL DSN-INX > KDSNSUB-COUNT.\n006920\n006930 3999-EXIT. EXIT.\n006940/\n006950 4000-LINE-COMMAND.\n006960     IF SPF-LSEL = SPACES\n006970         GO TO 4999-EXIT.\n006980\n006990     IF SPF-LSEL = 'F' AND SPF-DDNAME = SPACES\n007000         MOVE 'NO DDNAME FOUND' TO PDF-SHORT-MESSAGE\n007010         MOVE SPACES TO PDF-LONG-MESSAGE\n007020         MOVE 'USE THE ENTRY WITH A DDNAME PRESENT'\n007030             TO PDF-LONG-MESSAGE\n007040         MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n007050         MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n007060         MOVE SPF-CSR TO PDF-TBDISPL-ROW\n007070         MOVE SPACES TO PDF-TBDISPL-PANEL\n007080         GO TO 4999-EXIT.\n007090\n007100     IF SPF-LSEL = 'F'\n007110         MOVE SPACES TO PDF-SELECT-BUFFER\n007120         MOVE +3 TO PDF-FULLWORD\n007130         CALL 'ISPLINK' USING PDF-CONTROL PDF-DISPLAY\n007140              PDF-LINE PDF-FULLWORD\n007150         MOVE SPACES TO PDF-SELECT-BUFFER\n007160         STRING 'CMD(FREE F(' DELIMITED BY SIZE\n007170             SPF-DDNAME DELIMITED BY SPACES\n007180             '))' DELIMITED BY SIZE\n007190         INTO PDF-SELECT-BUFFER\n007200         MOVE +80 TO PDF-SELECT-BUFFER-LENGTH\n007210         CALL 'ISPLINK' USING PDF-SELECT\n007220                              PDF-SELECT-BUFFER-LENGTH\n007230                              PDF-SELECT-BUFFER\n007240         GO TO 4999-EXIT.\n007250\n007260     IF SPF-LSEL = 'B'\n007270         MOVE SPACES TO PDF-DSNAME\n007280         STRING QUOTE DELIMITED BY SIZE\n007290                SPF-DSNAME DELIMITED BY SPACES\n007300                QUOTE DELIMITED BY SIZE\n007310                INTO PDF-DSNAME\n007320         MOVE SPF-VOLSER TO PDF-VOLSER\n007330         CALL 'ISPLINK' USING         PDF-CONTROL\n007340                                      PDF-DISPLAY\n007350                                      PDF-SAVE\n007360         CALL 'ISPLINK' USING         PDF-CONTROL\n007370                                      PDF-ERRORS\n007380                                      PDF-RETURN\n007390         CALL 'ISPLINK' USING         PDF-BROWSE\n007400                                      PDF-DSNAME\n007410                                      PDF-VOLSER\n007420         MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE\n007430         CALL 'ISPLINK' USING         PDF-CONTROL\n007440                                      PDF-ERRORS\n007450                                      PDF-CANCEL\n007460         CALL 'ISPLINK' USING         PDF-CONTROL\n007470                                      PDF-DISPLAY\n007480                                      PDF-RESTORE\n007490         IF PDF-BROWSE-RETURN-CODE NOT = 0\n007500             MOVE +8 TO PDF-FULLWORD\n007510             MOVE '(ZERRMSG)' TO PDF-NAME-LIST\n007520             CALL 'ISPLINK' USING     PDF-VCOPY\n007530                                      PDF-NAME-LIST\n007540                                      PDF-FULLWORD\n007550                                      PDF-TBDISPL-MESSAGE\n007560                                      PDF-MOVE\n007570             MOVE SPACE TO PDF-TBDISPL-PANEL\n007580             MOVE SPF-CSR TO PDF-TBDISPL-ROW\n007590             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n007600             GO TO 4999-EXIT\n007610         ELSE\n007620         MOVE SPACES TO SPF-LSEL\n007630             GO TO 4999-EXIT.\n007640\n007650     IF SPF-LSEL = 'E'\n007660         MOVE SPACES TO PDF-DSNAME\n007670         STRING QUOTE DELIMITED BY SIZE\n007680                SPF-DSNAME DELIMITED BY SPACES\n007690                QUOTE DELIMITED BY SIZE\n007700                INTO PDF-DSNAME\n007710         MOVE SPF-VOLSER TO PDF-VOLSER\n007720         CALL 'ISPLINK' USING         PDF-CONTROL\n007730                                      PDF-DISPLAY\n007740                                      PDF-SAVE\n007750         CALL 'ISPLINK' USING         PDF-CONTROL\n007760                                      PDF-ERRORS\n007770                                      PDF-RETURN\n007780         CALL 'ISPLINK' USING         PDF-EDIT\n007790                                      PDF-DSNAME\n007800                                      PDF-VOLSER\n007810                                      PDF-DUMMY-PARAMETER\n007820                                      PDF-DUMMY-PARAMETER\n007830                                      PDF-DUMMY-PARAMETER\n007840                                      PDF-EDIT-PROFILE\n007850         MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE\n007860         CALL 'ISPLINK' USING         PDF-CONTROL\n007870                                      PDF-ERRORS\n007880                                      PDF-CANCEL\n007890         CALL 'ISPLINK' USING         PDF-CONTROL\n007900                                      PDF-DISPLAY\n007910                                      PDF-RESTORE\n007920         IF PDF-BROWSE-RETURN-CODE > 4\n007930             MOVE +8 TO PDF-FULLWORD\n007940             MOVE '(ZERRMSG)' TO PDF-NAME-LIST\n007950             CALL 'ISPLINK' USING     PDF-VCOPY\n007960                                      PDF-NAME-LIST\n007970                                      PDF-FULLWORD\n007980                                      PDF-TBDISPL-MESSAGE\n007990                                      PDF-MOVE\n008000             MOVE SPACE TO PDF-TBDISPL-PANEL\n008010             MOVE SPF-CSR TO PDF-TBDISPL-ROW\n008020             MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n008030             GO TO 4999-EXIT\n008040         ELSE\n008050         MOVE SPACES TO SPF-LSEL\n008060             GO TO 4999-EXIT.\n008070\n008080     MOVE '(ZSEL)' TO PDF-NAME-LIST.\n008090     MOVE +256 TO PDF-SELECT-BUFFER-LENGTH\n008100     CALL 'ISPLINK' USING             PDF-VCOPY\n008110                                      PDF-NAME-LIST\n008120                                      PDF-SELECT-BUFFER-LENGTH\n008130                                      PDF-SELECT-BUFFER\n008140                                      PDF-MOVE.\n008150\n008160     MOVE +3 TO PDF-FULLWORD.\n008170     CALL 'ISPLINK' USING             PDF-CONTROL\n008180                                      PDF-DISPLAY\n008190                                      PDF-LINE\n008200                                      PDF-FULLWORD.\n008210     CALL 'ISPLINK' USING             PDF-CONTROL\n008220                                      PDF-DISPLAY\n008230                                      PDF-SAVE.\n008240     CALL 'ISPLINK' USING             PDF-CONTROL\n008250                                      PDF-ERRORS\n008260                                      PDF-CANCEL.\n008270     CALL 'ISPLINK' USING             PDF-SELECT\n008280                                      PDF-SELECT-BUFFER-LENGTH\n008290                                      PDF-SELECT-BUFFER.\n008300     MOVE RETURN-CODE TO PDF-BROWSE-RETURN-CODE.\n008310     CALL 'ISPLINK' USING             PDF-CONTROL\n008320                                      PDF-ERRORS\n008330                                      PDF-RETURN.\n008340     CALL 'ISPLINK' USING             PDF-CONTROL\n008350                                      PDF-DISPLAY\n008360                                      PDF-RESTORE.\n008370\n008380     IF PDF-BROWSE-RETURN-CODE NOT = 0\n008390         MOVE SPACES TO PDF-SHORT-MESSAGE\n008400         MOVE PDF-BROWSE-RETURN-CODE TO WORK-NUM\n008410         STRING 'RETURN CODE = ' DELIMITED BY SIZE\n008420                 WORK-NUM DELIMITED BY SIZE\n008430                 INTO PDF-SHORT-MESSAGE\n008440         MOVE 'THE REQUESTED FUNCTION ENDED WITH A NON-ZERO RETURN\n008450-    'CODE'\n008460         TO PDF-LONG-MESSAGE\n008470         MOVE 'TLNM019E' TO PDF-TBDISPL-MESSAGE\n008480         MOVE 'LSEL' TO PDF-TBDISPL-CURSOR\n008490         MOVE SPACES TO PDF-TBDISPL-PANEL\n008500         MOVE SPF-CSR TO PDF-TBDISPL-ROW.\n008510\n008520 4999-EXIT.\n008530     EXIT.\n008540/\n008550 5000-LOCATE.\n008560     CALL 'ISPLINK' USING              PDF-TBTOP\n008570                                       PDF-TABLE-ID.\n008580\n008590     MOVE ZCMD-PARM (1) TO SPF-ALTDDNAM.\n008600     MOVE '(ALTDDNAM)' TO PDF-NAME-LIST.\n008610     MOVE '(GE)' TO PDF-COND-LIST.\n008620     MOVE 'ZTDTOP' TO PDF-TBQUERY-CRP.\n008630     CALL 'ISPLINK' USING              PDF-TBSCAN\n008640                                       PDF-TABLE-ID\n008650                                       PDF-NAME-LIST\n008660                                       PDF-DUMMY-PARAMETER\n008670                                       PDF-DUMMY-PARAMETER\n008680                                       PDF-NEXT\n008690                                       PDF-DUMMY-PARAMETER\n008700                                       PDF-TBQUERY-CRP\n008710                                       PDF-COND-LIST.\n008720\n008730     IF RETURN-CODE = 8\n008740         CALL 'ISPLINK' USING          PDF-TBBOTTOM\n008750                                       PDF-TABLE-ID\n008760                                       PDF-DUMMY-PARAMETER\n008770                                       PDF-DUMMY-PARAMETER\n008780                                       PDF-DUMMY-PARAMETER\n008790                                       PDF-TBQUERY-CRP\n008800     ELSE\n008810     IF SPF-ZTDTOP NOT = 1 AND\n008820         SPF-DDNAME NOT = ZCMD-PARM (1)\n008830         MOVE SPACES TO SPF-DDNAME\n008840         MOVE '(DDNAME)' TO PDF-NAME-LIST\n008850         MOVE '(NE)' TO PDF-COND-LIST\n008860         CALL 'ISPLINK' USING          PDF-TBSCAN\n008870                                       PDF-TABLE-ID\n008880                                       PDF-NAME-LIST\n008890                                       PDF-DUMMY-PARAMETER\n008900                                       PDF-DUMMY-PARAMETER\n008910                                       PDF-PREVIOUS\n008920                                       PDF-DUMMY-PARAMETER\n008930                                       PDF-TBQUERY-CRP\n008940                                       PDF-COND-LIST.\n008950\n008960     MOVE SPACES TO ZCMD-COMMAND-LINE.\n008970\n008980 5999-EXIT.\n008990     EXIT.\n009000/\n009010 8000-MATCH.\n009020     MOVE DDN-DDNAME (DDN-INX) TO DDNAME-TABLE-1.\n009030     MOVE PASSED-DDNAME (PDDN-INX) TO DDNAME-TABLE-2.\n009040\n009050     PERFORM 8100-CHECK THRU 8199-EXIT\n009060          VARYING PDDN-1 FROM 1 BY 1 UNTIL PDDN-1 > 8.\n009070\n009080     IF DDNAME-TABLE-1 = DDNAME-TABLE-2\n009090        MOVE '1' TO MATCH-SW.\n009100\n009110 8099-EXIT. EXIT.\n009120\n009130 8100-CHECK.\n009140     SET PDDN-2 TO PDDN-1.\n009150     IF PASSED-DDNAME-LET-2 (PDDN-2) = '*'\n009160        AND (PDDN-2 = 8 OR\n009170             PASSED-DDNAME-LET-2 (PDDN-2 + 1) = SPACES)\n009180\n009190        PERFORM 8200-SPACE THRU 8299-EXIT\n009200                VARYING PDDN-1 FROM PDDN-2 BY 1\n009210                UNTIL PDDN-1 > 8\n009220        MOVE SPACES TO PASSED-DDNAME-LET-2 (PDDN-2).\n009230\n009240 8199-EXIT. EXIT.\n009250\n009260 8200-SPACE.\n009270     MOVE SPACES TO PASSED-DDNAME-LET-1 (PDDN-1).\n009280 8299-EXIT. EXIT.\n009290/\n009300 10000-TBADD.\n009310     ADD 1 TO SPF-SEQUENCE.\n009320     MOVE KDSNSUB-DSN (DSN-INX) TO SPF-DSNAME.\n009330     SET VOL-INX TO DSN-INX.\n009340     MOVE KDSNSUB-VOL (VOL-INX) TO SPF-VOLSER.\n009350\n009360     IF DSN-INX > 1\n009370         MOVE SPACES TO SPF-DDNAME, SPF-SCAN-BYTE\n009380     ELSE\n009390         MOVE '1' TO SPF-SCAN-BYTE.\n009400\n009410     IF KDSNSUB-COUNT > 1\n009420         MOVE '+' TO SPF-MORE.\n009430\n009440     IF KDSNSUB-COUNT = DSN-INX\n009450         MOVE SPACE TO SPF-MORE.\n009460\n009470     CALL 'ISPLINK' USING              PDF-TBADD\n009480                                       PDF-TABLE-ID\n009490                                       PDF-ORDER.\n009500\n009510 10099-EXIT. EXIT.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINIXDMP": {"ttr": 9219, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n***                                                                 ***\n**       PROGNAME: MINIXDMP                                          **\n**       PROGAUTH: DAVID ALCOCK                                      **\n**       PROGDATE: 03/02/85                                          **\n**                                                                   **\n**       PRODUCE A MINIATURE HEX DUMP A LINE AT A TIME WITH          **\n**       OFFSET, WHICH YOU CAN PUT TO A FILE, WTO, TPUT, ETC.        **\n**       MINIXDMP IS CALLED FOR EACH LINE TO BE PRODUCED.            **\n**       THIS PROGRAM SET RETURN CODE=4 IF THE LENGTH TO             **\n**       TOO HIGH AND RETURN CODE=8 IF LENGTH IS ZERO.               **\n**       IF OVERHEAD IS A CONCERN THEN DO A STATIC CALL,             **\n**       OTHERWISE DO A LINK, SINCE THE MODULE RESIDES IN            **\n**       A LNKLST LIBRARY.                                           **\n**                                                                   **\n**       SAMPLE RESULT:                                              **\n**                                                                   **\n**  +X'0000' F1F2F3F4 F1F2F3F4 F1F2F3F4 F1F2F3F4 *1234123412341234*  **\n**  +X'0010' F1F2F3F4 F1F2F3F4 00000000 00000000 *12341234........*  **\n**  +X'0020' C4C1E5C5 C4C1E5C5 C4C1E5C5 C4C1E5C5 *DAVEDAVEDAVEDAVE*  **\n**  +X'0030' C4C1E5C5 C4C1E5C5 C4C1E5C5 C4C1E5C5 *DAVEDAVEDAVEDAVE*  **\n**  +X'0040' C4C1E5C5 C4C1E5C5 C4C1E5C5 C4C1E5C5 *DAVEDAVEDAVEDAVE*  **\n**                                                                   **\n**       SAMPLE PROGRAM TO PRODUCE RESULTS ABOVE:                    **\n**                                                                   **\n**  TESTIT ENTER 'TEST MINIXDMP PROGRAM'                             **\n**         LINK EP=MINIXDMP,PARAM=(LENGTH,INPUT,OUTPUT,OFFSET)       **\n**         TPUT OUTPUT,L'OUTPUT                                      **\n**         LINK EP=MINIXDMP,PARAM=(LENGTH,INPUT+16,OUTPUT,OFFSET)    **\n**         TPUT OUTPUT,L'OUTPUT                                      **\n**         LA   R3,DAVE                                              **\n**         LA   R4,3                                                 **\n**  DOLOOP EQU  *                                                    **\n**         LINK EP=MINIXDMP,PARAM=(LENGTH,(3),OUTPUT,OFFSET)         **\n**         TPUT OUTPUT,L'OUTPUT                                      **\n**         LA   R3,16(R3)                                            **\n**         BCT  R4,DOLOOP                                            **\n**         LEAVE RC=0                                                **\n**  OFFSET DC   H'0'     <- SET TO ZERO FIRST TIME,                  **\n**  LENGTH DC   H'16'                                                **\n**  OUTPUT DS   CL80                                                 **\n**  INPUT  DC   CL16'1234123412341234'                               **\n**         DC   CL8'12341234',XL8'00'                                **\n**  DAVE   DC   16CL4'DAVE'                                          **\n**         END                                                       **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\nMINIXDMP ENTER 'MINIATURE HEX DUMP...DAVID ALCOCK'\n         LM    R2,R5,0(R1)             GET INPUT PARMS\n*        ......R2 <-- LENGTH OF INPUT AREA (POINTS TO HALFWORD)\n*        .......R3 <-- ADDRESS OF INPUT AREA\n*        ........R4 <-- ADDRESS OF OUTPUT AREA\n*        .........R5 <-- OFFSET COUNT FIELD (POINTS TO HALFWORD)\n         SR    R7,R7                    ZERO WORK REGISTER\n         LH    R7,0(R5)                 GET OFFSET INTO WORK REGISTER\n         LA    R7,16(R7)                INCREMENT BY OFFSET\n         MVC   0(3,R4),=C'+X'''         MOVE HEX OFFSET PREFIX\n         LA    R4,3(R4)                 BUMP UP TO OUTPUT STUFF\n         LA    R15,2                    GET LENGTH TO CONVERT\n         STH   R15,DUMPLEN              SAVE FOR ROUTINE\n         CALL  CON2PHEX,(DUMPLEN,(5),(4)) CONVERT GROUP TO HEX STR\n         STH   R7,0(R5)                 SAVE OFFSET FOR NEXT TIME\n         LA    R15,4                    GET LENGTH TO CONVERT\n         STH   R15,DUMPLEN              SAVE FOR FOR REMAINING CALLS\n         MVI   4(R4),X'7D'              PUT HEX OFFSET SUFFIX\n         LA    R4,6(R4)                 BUMP UP TO HEX STUFF\n         MVI   36(R4),C'*'              CHARACTER DUMP PREFIX\n         SLR   R15,R15                  CLEAR OUT REGISTER\n         LH    R15,0(R2)                LENGTH TO DUMP\n         CH    R15,=H'16'               ---+\n         BH    LENHIGH                     | TEST FOR VALID\n         LTR   R15,R15                     | LENGTH TO PRINT\n         BZ    LENZERO                  ---+\n         BCTR  R15,0                    DECREMENT FOR MOVE\n         EX    R15,MOVECHAR             ONLY MOVE THE PART TO DUMP\n         EX    R15,TRANCHAR             TRANSLATE THIS FOR UNPRINTABLES\n         MVI   37+16(R4),C'*'           PUT CHARACTER DUMP SUFFIX\n         XR    R14,R14                  CLEAR OUT REGISTER\n         LH    R15,0(R2)                GET LENGTH TO PRINT\n         LA    R1,4                     NUMBER OF 4 BYTE GROUPS ON LINE\n         DR    R14,R1                   FIND EVEN/LEFTOVER FOR DUMP\n         LR    R6,R15                   NUMBER OF FULL 4 BYTE FIELDS\n         LA    R6,1(R6)                 EXTRA LOOP TO CATCH LEFTOVERS\n         LR    R8,R14                   NUMBER OF LEFTOVER BYTES\nPRTHEX   EQU   *\n         CH    R6,=H'1'                 ON LAST (LEFTOVER) GROUP?\n         BNZ   PH0001                   NO, MOVE ON\n         LTR   R8,R8                    YES, CHECK FOR LEFTOVER BYTES\n         BZ    GOBACK                        NONE, LEAVE\n         STH   R8,DUMPLEN                    GOT SOME, SET DUMP LENGTH\nPH0001   EQU   *\n         CALL  CON2PHEX,(DUMPLEN,(3),(4))    CONVERT GROUP TO HEX STR\n         LA    R3,4(R3)                 BUMP UP ON INPUT\n         LA    R4,9(R4)                 BUMP UP ON OUTPUT\n         BCT   R6,PRTHEX                PRINT NEXT...\n         SLR   R15,R15                  SET RETURN CODE = 0\nGOBACK   EQU   *\n         LEAVE RC=(15)                  LEAVE THIS PARTY\nLENHIGH  EQU   *                        INPUT LENGTH IS TOO HIGH\n         LA    R15,4                    SET RETURN CODE\n         B     GOBACK\nLENZERO  EQU   *                        INPUT LENGTH IS ZERO\n         LA    R15,8                    SET RETURN CODE\n         B     GOBACK\n         DS    0D\nDOUBLE   DS    D                       WORK AREA\nDUMPLEN  DS    H                       LENGTH TO DUMP TO HEX STRING\nMOVECHAR MVC   37(0,R4),0(R3)          SET UP EBCDIC AREA ON OUTPUT\nTRANCHAR TR    37(0,R4),TRANSTAB       TRANSLATE CHARACTER DUMP\nTRANSTAB DC    256C'.'                 CHARACTER TRANSLATE TABLE\n         ORG   TRANSTAB+C' '\n         DC    C' '\n         ORG   TRANSTAB+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   TRANSTAB+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   TRANSTAB+C'S'\n         DC    C'STUVWXYZ'\n         ORG   TRANSTAB+C'0'\n         DC    C'0123456789'\n         ORG\n         LTORG ,\n***********************************************************************\n***                                                                 ***\n**       CONVERT INPUT STRING TO EBCDIC HEX STRING DISPLAY           **\n***                                                                 ***\n***********************************************************************\nCON2PHEX ENTER 'CONVERT TO EBCDIC HEX STRING...DAVID ALCOCK'\n         LM    R2,R4,0(R1)             GET INPUT PARMS\n*        ..... R2 <-- LENGTH OF INPUT AREA\n*        ...... R3 <-- ADDRESS OF INPUT AREA\n*        ....... R4 <-- ADDRESS OF OUTPUT AREA\n         SLR   R6,R6\n         LH    R6,0(R2)                GET LENGTH OF INPUT BYTES\n         CH    R6,=H'1'                IS IT 1?\n         BE    HEXPRT1                 ...YES, THEN PRINT 2\n         CH    R6,=H'2'                IS IT 2?\n         BE    HEXPRT2                 ...YES, THEN PRINT 4\n         CH    R6,=H'3'                IS IT 3?\n         BE    HEXPRT3                 ...YES, THEN PRINT 6\n         CH    R6,=H'4'                IS IT 4?\n         BE    HEXPRT4                 ...YES, THEN PRINT 8\n         LA    R15,1                   SET NON-ZERO CONDITION CODE\n         B     EXIT\nHEXPRT1  UNPK  WRKAREA(3),0(2,R3)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  WRKAREA(5),0(3,R3)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  WRKAREA(7),0(4,R3)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  WRKAREA(9),0(5,R3)      UNPACK HEX\nHEXCLTR  MVZ   WRKAREA(8),XZROS        CLEAR FOR TRANSLATE\n         TR    WRKAREA(8),TRTBL        MAKE PRINTABLE\n         SLR   R15,R15                 CLEAR OUT REGISTER\n         SLL   R6,1                    MULTIPLY BY 2\n         BCTR  R6,0                    DECREMENT FOR MOVE\n         EX    R6,MOVEXSTR             MOVE IT OUT\nEXIT     LEAVE RC=(15)\nMOVEXSTR MVC   0(0,R4),XSTRING\nWRKAREA  EQU   *                       WORK AREA\nXSTRING  DS    CL8                     STRING TO RETURN\nXTRABYTE DS    CL1                     THROW-A-WAY BYTE (EXTRA)\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TABLE\n         LTORG ,\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NETTRAK": {"ttr": 9223, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "NETTRACK TITLE ' - NETTRACK SYSTEM - GUIDE ISPF TAPE - STATE OF MONTA'\n***********************************************************************\n*                                                                     *\n*    THIS PROGRAM ESSENTIALLY DOES TWO THINGS: FIRST IT ACTS AS A     *\n* PANEL MANAGER, ALLOWING EACH PANEL DISPLAYED TO DETERMINE THE NEXT  *\n* PANEL TO BE DISPLAYED; A CHAIN OF ANY NUMBER OF PANELS, IN ANY      *\n* ORDER, AND OF ANY LEVEL OF COMPLEXITY CAN BE BUILT. SECOND, IT      *\n* SAVES DATA RETURNED FROM THE VARIOUS PANELS, AND AT TERMINATION     *\n* WILL WRITE THAT DATA AS A NEW MEMBER OF AN EXISTING PDS.            *\n*                                                                     *\n*    THIS PROGRAM RUNS UNDER THE DIALOGUE MANAGER FEATURE OF ISPF. IT *\n* IS CALLED DIRECTLY BY DIALOGUE MANAGER, AND IMMEDIATELY DISPLAYS    *\n* PANEL \"NT1STPNL\", TO GET THE USER STARTED. EACH PANEL CAN PASS THE  *\n* NAME OF THE NEXT PANEL TO BE DISPLAYED, VIA THE VARIABLE NAMED      *\n* \"NTNXTPNL\". IF A PANEL WANTS TO RETURN INFORMATION OF ANY KIND      *\n* TO BE SAVED IN THE LOG DATASET BY THIS PROGRAM, THEN IT MUST PASS   *\n* THAT DATA VIA ONE OF THE 240 BYTE VARIABLES NAMED \"NTDATA00\"        *\n* THROUGH \"NTDATAXX\"; AT THE TIME THIS PROGRAM WAS WRITTEN, \"XX\"      *\n* WAS \"09\" WHICH GIVES A TOTAL OF TEN 240 VARIABLES FOR PASSING       *\n* DATA. THESE VARIABLES CAN BE BE USED OVER AND OVER IN ANY           *\n* COMBINATION BY ANY PANEL IN THE USER'S CHAIN. SOMETIMES, THE        *\n* PANEL DEVELOPER DOES NOT HAVE ENOUGH ROOM TO FURNISH HIS END USER   *\n* A BIG ENOUGH FIELD, REGARDLESS OF THE NUMBER OR SIZE OF THE PASSED  *\n* VARIABLES AVAILABLE. A TYPICAL EXAMPLE OF THIS WOULD BE A PANEL     *\n* SECTION WHERE THE END USER IS ASKED TO TYPE IN A DESCRIPTION OF HIS *\n* PROBLEM; THERE IS NO WAY OF KNOWING IN ADVANCE JUST HOW MUCH THE    *\n* USER WILL HAVE TO SAY. TO SOLVE THIS, ANYTIME A PANEL RETURNS A     *\n* \"Y\" TO THIS PROGRAM IN VARIABLE \"NTCONTIN\", A SPECIAL CONTINUATION  *\n* PANEL WILL BE DISPLAYED WHICH CONTAINS FOUR 240 BYTE VARIABLES,     *\n* WHICH WILL BE RETRIEVED AND BUILT INTO THE LOG. THIS CONTINUATION   *\n* PANEL CAN BE INVOKED ANY NUMBER OF TIMES, WHICH EFFECTIVELY GIVES   *\n* THE END USER UNLIMITED TYPING ROOM FOR COMMENTS. AFTER THE USER     *\n* BREAKS THE CONTINUATION CYCLE, THE NEXT PANEL REQUESTED IS          *\n* DISPLAYED.                                                          *\n*                                                                     *\n*    THE POINT OF THIS SYSTEM IS TO FURNISH THE TELEPROCESSING USER   *\n* WITH A STEP BY STEP GUIDE TO DETERMINING A NETWORK PROBLEM, AND     *\n* ALSO TO FURNISH NETWORK CONTROL WITH SOME USEFUL COMMENTS SPECIFIC  *\n* TO THAT PROBLEM. NETWORK CONTROL, IN TURN, GETS A RECORD OF WHICH   *\n* STEPS THE USER WENT THROUGH, AND WHAT HE DID AT EACH STEP. THE USER *\n* CAN USE THE SYSTEM HIMSELF, OR NETWORK CONTROL CAN USE IT WHILE     *\n* WORKING WITH THE USER OVER THE PHONE. ALTHOUGH THIS PROGRAM IS      *\n* MAINTAINED BY TECH, ALL PANEL BUILDING AND MODIFYING CAN BE DONE    *\n* BY NETWORK CONTROL, WITH NO HELP FROM TECH, AND NO PROGRAM CHANGES. *\n*                                                                     *\n*    THIS PROGRAM WILL SAVE ANY DATA TRANSFERRED VIA THE GENERALIZED  *\n* 240 BYTE VARIABLES IN A HUGE IN-CORE SAVE AREA. WHEN THE USER       *\n* TERMINATES, THIS AREA IS BROKEN UP INTO 80 BYTE RECORDS AND WRITTEN *\n* OUT TO A NEW MEMBER OF THE NETWORK PROBLEM LOG PDS. BEFORE DOING    *\n* SO, THE PROGRAM READS THE PDS DIRECTORY LOOKING FOR THE HIGHEST     *\n* SEQUENTIAL MEMBER NAME OF THE FORM \"PRBNNNNN\"; IT THEN ADDS 1 TO    *\n* THIS AND USES THIS DEVELOPED VALUE AS THE NAME OF THE NEW MEMBER    *\n* BEING WRITTEN. SINCE THE USER'S DATA IS STRUNG OUT IN ONE LONG      *\n* STRING, SOME MEANS OF BREAKING IT UP FOR READABILITY HAD TO BE      *\n* USED. THIS IS DONE BY INSERTING AN EYE-CATCHER WITH THE NAME OF     *\n* THE PANEL THAT FURNISHED THE DATA, JUST BEFORE THE DATA ITSELF.     *\n* WHEN SCANNING THE IN-CORE DATA AND BREAKING IT INTO 80 BYTE PIECES, *\n* ANY PIECE THAT IS TOTALLY BLANK IS DROPPED. IF A BLANK LINE IS      *\n* DESIRED, SIMPLY INSERTING ANY NON-BLANK CHARACTER THAT IS NOT TOO   *\n* NOTICEABLE (\"UNDERSCORE\", \"OR-BAR\", ETC) WILL NULLIFY THE BLANK     *\n* TEST, AND CAUSE THE ALMOST-BLANK LINE TO BE INCLUDED FOR PURPOSES   *\n* OF SEPARATION OR READABILITY. THIS MUST BE DONE IN THE PANEL,       *\n* PRIOR TO RETURNING CONTROL TO THIS PROGRAM.                         *\n*    THE REASON FOR THIS TWO PHASE (IN-CORE FOLLOWED BY WRITING       *\n* RECORDS LATER) APPROACH IS TO AVOID THE PROBLEM THAT WOULD OCCUR    *\n* WHEN TWO END USERS ARE USING THIS SYSTEM SIMULTANEOUSLY - I.E. BOTH *\n* WOULD BE TRYING TO ADD NEW MEMBERS TO THE NETWORK LOG DATASET AT    *\n* THE SAME TIME, AND BOTH WOULD NEED TO HAVE THE DATASET OPEN FOR A   *\n* LONG PERIOD. SINCE THE DATA IS SAVED IN STORAGE FOR THE RELATIVELY  *\n* LONG INTERVAL WHEN THEY'RE GOING THROUGH THE SYSTEM, AND THEN IS    *\n* COPIED TO THE DATASET BY A HIGH SPEED WRITE LOOP, THE DATASET IS    *\n* OPEN AND IN USE FOR A VERY SHORT PERIOD OF TIME. THIS REDUCES THE   *\n* CHANCES OF ANY CONFLICT BETWEEN TWO OR MORE SIMULTANEOUS USERS.     *\n* HOWEVER, IT COULD STILL HAPEN, SO THIS PROGRAM CALLS A CLIST TO     *\n* DYNAMICALLY ALLOCATE THE DATASET, AND IF THE DATASET IS IN USE, THE *\n* CLIST SETS THE RETURN CODE HIGH TO ALERT THE PROGRAM, WHICH IN TURN *\n* DISPLAYS A SPECIAL PANEL REQUESTING THE USER TO WAIT ONE MINUTE     *\n* THEN HIT ENTER/END, AT WHICH TIME THE PROGRAM TRIES THE ALLOCATE    *\n* CLIST AGAIN.                                                        *\n*    ANOTHER POTENTIAL PROBLEM IS THAT THE NETWORK LOG DATASET CAN    *\n* RUN OUT OF ROOM FOR NEW MEMBERS, OR RUN OUT OF DIRECTORY ROOM. THIS *\n* HAS BEEN TAKEN CARE OF BY PLACING IT IN THE \"TSO\" POOL OF DISK      *\n* PACKS, SO THAT DMS/OS WILL AUTOMATICALLY COMPRESS AND RE-ALLOCATE   *\n* IT AS THE NEED ARISES, JUST LIKE IT DOES FOR TSO LIBRARIES.         *\n*                                                                     *\n*    NATURALLY, IT IS POSSIBLE FOR A PANEL TO RETURN THE NAME OF A    *\n* PANEL THAT DOESN'T EXIST, OR ONE THAT HAS VARIOUS ERRORS IN IT,     *\n* IN \"NTNXTPNL\". IF SO, THIS PROGRAM WILL DISPLAY A SPECIAL \"ERROR    *\n* PANEL PANEL\", WHICH ALLOWS THE DEVELOPER TO TYPE IN A SUBSTITUTE    *\n* PANEL NAME, AND TEST FARTHER DOWN HIS CHAIN. THIS SPECIAL PANEL     *\n* ALSO ATTEMPTS TO IDENTIFY THE CAUSE OF THE ERROR FOR HIM. NATURALLY,*\n* THIS SHOULD ONLY HAPPEN DURING DEVELOPMENT; THE END USER SHOULD     *\n* NEVER SEE THE ERROR PANEL PANEL.                                    *\n*                                                                     *\n*    ANY TIME THE DEVELOPER WISHES TO TERMINATE THE DIALOGUE,         *\n* RETURNING THE WORD \"EXIT\" IN THE VARIABLE \"NTNXTPNL\" WILL CAUSE     *\n* THIS PROGRAM TO PERFORM FINAL HOUSEKEEPING AND END. JUST BEFORE     *\n* TERMINATING, THE PROGRAM DISPLAYS ONE LAST SPECIAL PANEL TO         *\n* INFORM THE USER OF THE PROBLEM NUMBER THAT WAS ASSIGNED TO HIM.     *\n*                                                                     *\n*    THE ONLY UNUSUAL THINGS ABOUT THIS DIALOGUE ARE THAT IT OBTAINS  *\n* THE NAME OF THE NEXT PANEL TO BE DISPLAYED FROM THE LAST PANEL,     *\n* AND THAT ONLY TWO SPECIFIC AND TEN (AT THE MOMENT, SEE ABOVE)       *\n* GENERALIZED VARIABLES ARE RETRIEVED BY THIS PROGRAM. (THE DEVELOPER *\n* CAN HAVE ANY NUMBER OF LOCAL VARIABLES WITHIN A PANEL, OR SHARED    *\n* VARIABLES THAT CAN BE PASSED BETWEEN HIS VARIOUS PANELS, BUT THESE  *\n* MUST BE TRANSFERRED OR CONCATENATED INTO ONE OF THE GENERAL PURPOSE *\n* VARIABLES IF THE PANEL DEVELOPER WANTS THAT PARTICULAR INFORMATION  *\n* ENTERED INTO THE LOG DATASET.                                       *\n* THE REASON FOR THIS IS TO ALLOW FREQUENT AND HEAVY MODIFICATION     *\n* TO THE PANEL CHAIN WITHOUT MODIFYING/REASSEMBLING THIS PROGRAM.     *\n* IT GIVES THE DEVELOPER A LOT OF FREEDOM IN MODIFYING HIS PANEL      *\n* CHAINS WITHOUT REQUIRING PROGRAM CHANGES AND TESTING.               *\n*                                                                     *\n*                                                                     *\n*               - DENNIS BUSWELL, 02/05/85                            *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                     INITIALIZATION                                  *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nNETTRACK PROC LINKAGE=(OS,CSECT),ID='NETTRACK V 1.0',BASE=(11,12)\n         SPACE 2\n         ST    R1,PARMADDR         * SAVE A(EXEC PARM)\n         SPACE 2\n***********************************************************************\n* MAKE INITIAL CALLS TO \"ISPLINK\" TO SET CONDITIONS WE WANT TO RUN    *\n* UNDER - RETURN TO US IF RET CODE > 12                               *\n***********************************************************************\n         SPACE 2\n         CALL  ISPLINK,(CONTROL1,ERRORS,RETURN),VL\n         SPACE 3\n***********************************************************************\n* CHECK FOR EXEC PARM TO ALLOW SCREEN SPLITTING (DEVELOPMENT ONLY)    *\n* FOR PRODUCTION USE, WE MUST RUN WITH SCREEN SPLIT DISABLED          *\n***********************************************************************\n         SPACE 2\n         L     R1,PARMADDR         * PICK UP A(A(EXEC PARM))\n         L     R1,0(R1)            * GET A(EXEC PARM)\n         CLC   2(5,R1),=C'SPLIT'   * USER TESTING/DEVELOPING ?\n         BE    SPLITOK             * - YES, LEAVE SPLIT SCREEN AS IS\n         SPACE 1\n         CALL  ISPLINK,(CONTROL1,SPLIT,DISABLE),VL *-NO, DISABLE SPLIT\n         LTR   R15,R15             * SCREEN ALREADY SPLIT ?\n         BZ    NOTSPLIT            * - NO, EVERYTHING IS OK\n         SPACE 1\n         MVC   NTERRPNL(8),=C'NTNOSPLT' * SET UP ERROR MESSAGE\n         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * DISPLAY ERROR PANEL\n         B     TERME                  *    & GO FINISH UP\n         SPACE 1\nSPLITOK  EQU   *\nNOTSPLIT EQU   *\n         SPACE 3\n***********************************************************************\n* ISSUE GETMAIN TO SEE IF USER LOGGED ON WITH BIG ENOUGH REGION TO    *\n* ALLOW US A 512K GETMAIN; IF NOT, DISPLAY A SPECIAL PANEL AND MAKE   *\n* HIM LOGON AGAIN WITH A LARGER REGION SIZE.                          *\n***********************************************************************\n         SPACE 3\n         GETMAIN EC,LV=524288,A=STRGADDR,SP=2 * ASK FOR 512 K\n         SPACE 1\n         LTR   R15,R15             * DID WE GET 512K OK ?\n         BZ    GOTMAIN             * - YES, WE'RE IN BUSINESS\n         SPACE 1\n         MVC   NTERRPNL(8),=C'NTMORSTG' * FORCE IN NAME OF \"RE-LOGON\n*                                  * WITH-MORE-STORAGE\" PANEL\n         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * - NO, TOUGH LUCK\n         B     TERME               * NOW GO QUIT\nGOTMAIN  EQU   *\n         L     R1,STRGADDR         * PICK UP A(STORAGE WE GOT)\n         ST    R1,NEXTNTRY         * PRIME A(NEXT ENTRY TO USE)\n         A     R1,=F'524128'       * ADD 512K MINUS 160 BYTES\n         ST    R1,LASTNTRY         * SAVE THIS AS LAST POSSIBLE ENTRY\n         SPACE 3\n***********************************************************************\n* NOW DO VDEFINES TO INITIALIZE AND SET LENGTHS OF ALL VARIABLES WE   *\n* WILL BE USING LATER ON                                              *\n***********************************************************************\n         SPACE 2\n*                                    ***** 1ST DEFINE ALL OF THE 240\n*                                        * BYTE VARIABLES AT 1 CRACK\n         SPACE 1\n         MVI   LFTPAREN,C'('             * TEMPORARILY MAKE NAMELIST\n*                                        *    ONE LARGE LIST\n         MVI   RTPAREN,C')'              *\n         SPACE 1\n         CALL  ISPLINK,(VDEFINE,NAMELST1,GENVARS,CHAR,L240),VL\n         SPACE 1\n         MVI   LFTPAREN,C' '             * RESET TO INDIVIDUAL ITEMS\n*                                        *\n         MVI   RTPAREN,C' '              *\n         SPACE 2\n*                                    ***** NEXT DEFINE \"NTCONTIN\"\n         SPACE 1\n         CALL  ISPLINK,(VDEFINE,NMCONTIN,NTCONTIN,CHAR,L1),VL\n         SPACE 1\n         SPACE 2\n*                                    ***** THEN DEFINE \"NTCONTIN\"\n         SPACE 1\n         CALL  ISPLINK,(VDEFINE,VDEF8LST,VDEF8VAL,CHAR,L8),VL\n         SPACE 1\n***********************************************************************\n* NOW \"VPUT\" ALL OF THE VARIABLES WE JUST DEFINED, WHICH WILL COPY   *\n* THEM FROM THIS PROGRAM'S FUNCTION POOL TO THE SHARED POOL.         *\n***********************************************************************\n         SPACE 2\n         MVC   VPUTLIST(075),=C'(NTCONTIN NTNXTPNL NTBADPNL NTERRPNL NTX\n               PROB# NTDATA00 NTDATA01 NTDATA02)      '\n         SPACE 1\n         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN\n*                                   * SHARED POOL SO ERROR PANEL CAN\n*                                   * USE IT\n         MVC   VPUTLIST(075),=C'(NTDATA03 NTDATA04 NTDATA05 NTDATA06 NTX\n               DATA07 NTDATA08 NTDATA09)              '\n         SPACE 1\n         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN\n*                                   * SHARED POOL SO ERROR PANEL CAN\n*                                   * USE IT\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                        MAINLINE                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n***********************************************************************\n* DISPLAY PANEL \"NT1STPNL\" TO GET THINGS STARTED; THIS AND ONLY THIS  *\n* PANEL NAME IS FROZEN IN THE DEVELOPER'S NORMAL PANEL CHAIN; PANELS  *\n* BEYOND THIS CAN BE NAMED WHATEVER THE DEVELOPER WANTS. TRUE, THERE  *\n* ARE SEVERAL \"SPECIAL SITUATION PANELS\" WHOSE NAMES ARE LIKEWISE     *\n* HARD CODED IN THIS PROGRAM, AND WHOSE NAMES HAVE TO REMAIN AS IS    *\n* BUT THESE PANELS MUST BE PRESENT REGARDLESS OF THE SIZE OR DESIGN   *\n* OF THE DEVELOPER'S PANEL CHAIN, AND DON'T REALLY EFFECT HIM.        *\n***********************************************************************\n         SPACE 1\n         MVC   PANLNAME(8),=C'NT1STPNL' * FORCE IN FIRST PANEL NAME\n         B     FRSTPANL             * NOW BRANCH DIRECTLY TO CALL\n         SPACE 4\n***********************************************************************\n* DISPLAY NEW PANEL REQUESTED BY LAST PANEL DISPLAYED.                *\n***********************************************************************\n         SPACE 1\nNEXTPANL MVC   PANLNAME(8),NTNXTPNL * FORCE IN CORRECT PANEL NAME\nFRSTPANL EQU   *\n         CLC   PANLNAME(8),=C'$NONAME$' * USER FORGET TO SET\n*                                   * \"NTNXTPNL\" ?\n         BE    NOPNLNAM             * - YES, GO HANDLE\n         SPACE 1\n         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * DISPLAY PANEL\n         SPACE 4\n***********************************************************************\n* IF PANEL DISPLAYED WAS BAD FOR ANY REASON, NOTIFY DEVELOPER VIA     *\n* A SPECIAL \"ERROR-PANEL PANEL\" AND LET HIM TYPE IN ANOTHER PANEL     *\n* NAME AND KEEP GOING. THIS IS FOR PANEL DEVELOPMENT PURPOSES ONLY -  *\n* THE END USER SHOULD NEVER GET IN THIS POSITION.                     *\n***********************************************************************\n         SPACE 1\n         CH    R15,=H'8'            * PANEL DISPLAY OK ?\n         BNH   PANELSOK             * - YES, GO HANDLE\n         SPACE 1\n         SPACE 1\n         CH    R15,=H'12'           * PANEL NOT FOUND ?\n         BNE   NOT12                * - NO, GO HANDLE\n         MVI   MSGNAME+7,C'1'       * - YES, SET APPROPRIATE MESSAGE\n         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL\n         SPACE 1\nNOT12    EQU   *\n         CH    R15,=H'16'           * VARIABLE TRUNCATION ?\n         BNE   NOT16                * - NO, GO HANDLE\n         MVI   MSGNAME+7,C'2'       * - YES, SET APPROPRIATE MESSAGE\n         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL\n         SPACE 1\nNOT16    EQU   *\n         MVI   MSGNAME+7,C'3'       * - YES, SET APPROPRIATE MESSAGE\n         B     ERRORRDY             *    & GO DISPLAY ERROR PANEL\n         SPACE 2\nNOPNLNAM EQU   *\n         MVI   MSGNAME+7,C'7'       * - YES, SET APPROPRIATE MESSAGE\n         SPACE 2\nERRORRDY EQU   *\n         MVC   NTBADPNL,PANLNAME    * SAVE NAME OF LAST PANEL\n         CALL  ISPLINK,(VREPLACE,VREPNAMS,REPLNTHS,REPDATA),VL\n         SPACE 2\n         MVC   VPUTLIST,=C'(NTBADPNL) ' *\n         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * PUT VARIABLES IN\n*                                   * SHARED POOL SO ERROR PANEL CAN\n*                                   * USE IT\n         SPACE 1\n         CALL  ISPLINK,(DISPLAY,NTERRPNL,MSGNAME),VL * ERROR PANEL\n*                                   * WHAT USER WANTS US TO DO\n         SPACE 4\n***********************************************************************\n* NOW ISSUE VGET AND VCOPY TO GET USER'S DATA                         *\n***********************************************************************\n         SPACE 2\nPANELSOK EQU   *                    *\n         MVC   L8(4),=F'8'          * RESET ALL OUR LENGTH\n         MVC   L240(4),=F'240'      *    INDICATORS\n         MVC   L1(4),=F'1'          *\n         SPACE 2\n         MVC   VGETNAME(44),=C'NTNXTPNL NTCONTIN NTDATA00 NTDATA01 NTDAX\n               02) '\n         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL\n         SPACE 2\n         MVC   VGETNAME(64),=C'NTDATA03 NTDATA04 NTDATA05 NTDATA06 NTDAX\n               TA07 NTDATA08 NTDATA09) '\n         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL\n         SPACE 2\n         MVC   VGETNAME(80),=CL255' ' * NOW CLEAR OUT NAME AREA\n         SPACE 3\n*                               ***** ===> NOTE <=== DO NOT TRY TO\n*                                   * COMBINE THE MULTIPLE VCOPIES\n*                                   * BELOW INTO ONE LARGE CALL FOR\n*                                   * EFFICIENCY'S SAKE; IF YOU DO\n*                                   * AND ONE VCOPY HAS AN ERROR DUE\n*                                   * TO LENGTH TRUNCATION, THE FOLLOW-\n*                                   * ING VCOPIES WILL BE BYPASSED, AND\n*                                   * THEIR DATA LOST\n         SPACE 1\n         MVC   L8(4),=F'8'          * RESET LENGTH AGAIN\n         CALL  ISPLINK,(VCOPY,NMNXTPNL,L8,NTNXTPNL,MOVE),VL\n         SPACE 2\n         MVC   L1(4),=F'1'          *\n         CALL  ISPLINK,(VCOPY,NMCONTIN,L1,NTCONTIN,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA00,L240,NTDATA00,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA01,L240,NTDATA01,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA02,L240,NTDATA02,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA03,L240,NTDATA03,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA04,L240,NTDATA04,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA05,L240,NTDATA05,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA06,L240,NTDATA06,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA07,L240,NTDATA07,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA08,L240,NTDATA08,MOVE),VL\n         SPACE 2\n         MVC   L240(4),=F'240'      * RESET LENGTH\n         CALL  ISPLINK,(VCOPY,NMDATA09,L240,NTDATA09,MOVE),VL\n         SPACE 4\n*                               ***** NOW LET'S VREPLACE THE VALUE\n*                                   * OF \"NTNXTPNL\" WITH A VALUE\n*                                   * OF \"$NONAME$\" SO WE CAN CATCH\n*                                   * THE SITUATION WHERE USER FORGETS\n*                                   * TO SET OR VPUT \"NTNXTPNL\"\n         CLI   NTCONTIN,C'Y'        * USER IN CONTINUATION MODE ?\n         BE    NOREPYET             * - YES, SKIP VREPLACE FOR NOW\n         SPACE 1\n         CALL  ISPLINK,(VREPLACE,VRNMNPAN,REPLNTHS,VRNONAME),VL\n         SPACE 2\n         MVC   VPUTLIST,=C'(NTNXTPNL) ' *\n         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * VPUT \"NO-NAME\"\n         SPACE 1\nNOREPYET EQU   *\n         SPACE 2\n***********************************************************************\n* BUILD HIS INFO INTO OUR IN-CORE TABLE                               *\n***********************************************************************\n         SPACE 2\nBUILDNFO EQU   *\n         L     R1,NEXTNTRY          * PICK UP A(NEXT TABLE ENTRY)\n         CLC   PANLNAME(8),=C'NTEXTEND' * COMMENT EXTENSION PANEL ?\n         BE    SKIPNAME             * - YES, FORGET PANEL NAME FLAG\n         MVC   0(80,R1),=CL240' '   * CLEAR OUT TRASH\n         MVC   0(10,R1),=C'PANEL ===>' * FORCE IN LEGEND\n         MVC   11(8,R1),PANLNAME    * PUT IN NEXT PANEL CHOICE\n         LA    R1,80(R1)            * POINT TO NEXT SPOT\n         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?\n         BNL   NOMOROOM             * - YES, NO OTHER CHOICE\n         SPACE 1\nSKIPNAME EQU   *\n         LA    R15,NTDATA00         * POINT TO USER'S DATA\n         LA    R14,30               * INIT BCT REG\n         SPACE 1\nNEXTSECT EQU   *                    *\n         CLC   0(80,15),=CL255' '   * BLANK LINE ?\n         BE    ITSBLANK             * - YES, DON'T MOVE IT IN\n         MVC   0(80,R1),0(R15)      * MOVE IN THIS SECTION\n         MVC   0(80,R15),=CL255' '  * BLANK OUT SENDING FIELD\n         LA    R1,80(R1)            * BUMP UP\n         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?\n         BNL   NOMOROOM             * - YES, NO OTHER CHOICE\nITSBLANK LA    R15,80(R15)          *    POINTERS\n         BCT   R14,NEXTSECT         * DO ALL OF THEM\n         SPACE 2\n         CLC   NTNXTPNL,=C'EXIT    ' * USER QUITTING ?\n         BNE   SAVENTRY\n         CLI   NTCONTIN,C'Y'         * - YES, BUT ARE WE CONTINUING ?\n         BE    SAVENTRY              * - YES, SKIP FINAL FLAG FOR NOW\n         MVC   0(80,R1),=CL255' '    * CLEAR EXTRA SPOT\n         MVC   80(80,R1),=CL80'===> USER QUIT AT THIS POINT <==='\n         LA    R1,160(R1)           * BUMP POINTER UP\n         C     R1,LASTNTRY          * GOING TO OVERRUN IN-CORE TABLE?\n         BNL   NOMOROOM             * - YES, NO OTHER CHOICE\n         SPACE 1\nSAVENTRY ST    R1,NEXTNTRY          * SAVE A(NEXT ENTRY)\n         SPACE 2\n***********************************************************************\n* NOW PICK UP USER'S CHOICE FOR NEXT PANEL AND DISPLAY IT             *\n***********************************************************************\n         SPACE 2\n         CLI   NTCONTIN,C'Y'          * USER WANT \"ADDITIONAL DATA\n*                                     *   SCREEN\"\n         BNE   TESTEXIT               * - NO, GO SEE IF ALL DONE\n         MVC   PANLNAME(8),=C'NTEXTEND' * - NO, HE HAS MORE TO SAY\n         B     FRSTPANL               * GO DO IT\n         SPACE 1\nTESTEXIT EQU   *\n         CLC   NTNXTPNL(4),=C'EXIT'   * USER WANT COMPLETELY OUT ?\n         BE    ALLDONE                * - YES, GO CLEAN UP AND END\n         B     NEXTPANL               * - NO, KEEP GOING\n         SPACE 5\n***********************************************************************\n*    WE RAN OUT OF IN-CORE STORAGE ROOM; DISPLAY SPECIAL WARNING      *\n* SCREEN FOR USER, THEN GO SAVE WHAT WE CAN AND FINISH UP.            *\n***********************************************************************\n         SPACE 2\nNOMOROOM EQU   *\n         MVC   NTERRPNL(8),=C'NTNOROOM' * SET UP ERROR MESSAGE\n         CALL  ISPLINK,(DISPLAY,NTERRPNL),VL * ERROR PANEL\n         B     ALLDONE                *    & GO FINISH UP\n         EJECT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                         TERMINATION                                 *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nALLDONE  EQU   *\n         SPACE 4\n***********************************************************************\n* 1ST CALL CLIST \"NTRKCLST\" TO ALLOCATE NETWORK TRACKING LOG FILE     *\n***********************************************************************\n         SPACE 1\nALLOCATE EQU   *\n         MVC   CMDBUF(23),=C'CMD(%NTRKCLST ALLOCATE) '\n         CALL  ISPLINK,(SELECT,CMDBUFLN,CMDBUF),VL * CALL CLIST TO\n         SPACE 2\n         LTR   R15,R15            * ALLOCATE GO OK ?\n         BZ    OPENUP             * - YES, GO OPEN\n         MVC   PANLNAME(8),=C'NTALFAIL' * PUT IN NAME OF WAIT PANEL\n         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * GET USER TO WAIT 1 MIN\n         B     ALLOCATE           * NOW GO TRY AGAIN\n         SPACE 2\n***********************************************************************\n* THEN OPEN \"NETRKDIR\" AND READ IN THE ENTIRE DIRECTORY OF OUR LOG    *\n* DATASET, AND FIND THE HIGHEST PROBLEM NUMBER THAT WAS ASSIGNED      *\n* LAST; ASSIGN NEXT NUMBER IN SEQUENCE TO THIS PROBLEM                *\n***********************************************************************\n         SPACE 1\nOPENUP   EQU   *                   *\n         OPEN  (NETRKDIR,INPUT)    * OPEN DIRECTORY DCB\n         SPACE 3\nGETDRBLK GET   NETRKDIR\n         LA    R2,2(R1)            * POINT TO 1ST ENTRY IN BLOCK\n         LA    R3,6                * MAX # SPF ENTRIES PER BLOCK\n         SPACE 1\nCHECKENT CLC   0(8,R2),=8XL1'FF'   * END-OF-ENTRIES FLAG\n         BE    EODDIRCT            * - YES, ALL DONE\n         CLC   0(42,R2),=42XL1'00' * EMPTY ENTRY ?\n         BE    EODDIRCT            * - YES, ALL DONE\n*                              ***** FOLLOWING MAKES SURE THAT MEMBER\n*                                  * NAME IS OF THE FORM \"PROBNNNN\" -\n*                                  * BEFORE WE USE IT; LIBRARY MAY\n*                                  * CONTAIN MEMBERS THAT DON'T FOLLOW\n*                                  * THE PATTERN.\n         LA    R1,3(R2)            * POINT TO LAST 5 BYTES OF MEMB NAME\n         LA    R15,5               * INIT BCT REG\n         SPACE 1\nTESTNUM  TM    0(R1),X'F0'         * NUMERIC DIGIT ?\n         BNO   TRYNEXT             * - NO, DROP THIS ONE\n         LA    R1,1(R1)            * - YES, POINT TO NEXT BYTE\n         BCT   R15,TESTNUM         *    & KEEP TRYING\n         SPACE 1\n         CLC   0(3,R2),=C'PRB'     * THIS NAME HAVE RIGHT PREFIX ?\n         BNE   TRYNEXT             * - NO, FORGET IT\n         SPACE 1\n         MVC   STOWNAME(8),0(R2)   * -YES, SAVE THIS NAME AS HIGHEST\n         SPACE 1\nTRYNEXT  EQU   *\n         LA    R2,42(R2)           * POINT TO NEXT ENTRY\n         BCT   R3,CHECKENT         *   & KEEP TRYING\n         B     GETDRBLK            * GET NEXT DIRECTORY BLOCK\n         SPACE 1\nEODDIRCT EQU   *\n         PACK  DOUB(8),STOWNAME+3(5) * PACK C'NNNN' SECTION OF\n*                                    * LAST (HIGHEST) NAME IN DIRECT\n         AP    DOUB,=P'1'            * UP IT BY ONE\n         UNPK  STOWNAME+5(3),DOUB+5(3) * NOW UNPK IT\n         OI    STOWNAME+7,X'F0'      * CORRECT SIGN\n         SPACE 2\n***********************************************************************\n* NEXT, CLOSE QSAM DIRECTORY INPUT DCB AND THEN USING THE SAME        *\n* DDNAME, OPEN THE BPAM DCB SO WE CAN WRITE OUT RECORDS WE'VE SAVED.  *\n***********************************************************************\n         SPACE 1\n         CLOSE NETRKDIR              * CLOSE INPUT (EXCP)\n         SPACE 2\n         OPEN  (NETRKOUT,OUTPUT)     * OPEN OUTPUT (BPAM)\n         SPACE 2\n         MVC   OUTLRECL(2),NETRKOUT+82 * SAVE LRECL AND BLKSIZE\n         MVC   OUTBLKSZ(2),NETRKOUT+62 *   FOR WRITE SUBROUTINE\n         SPACE 2\n***********************************************************************\n* NOW LOOP THROUGH IN-CORE DATA AND WRITE IT OUT TO THE LOG DATASET.  *\n***********************************************************************\n         SPACE 1\n         LA    R1,=CL255' '        * POINT TO BLANK LINE\n         BAL   R9,WRITEREC         *    & GO WRITE A SPACER  LINE\n         SPACE 1\n         BAL   R9,BLDDTTIM         * GO BUILD FANCY DATE/TIME REC\n         SPACE 1\n         LA    R1,DATEREC          * POINT TO FANCY DATE/TIME REC\n         BAL   R9,WRITEREC         *    & GO WRITE IT OUT\n         SPACE 1\n         LA    R1,=CL255' '        * POINT TO BLANK LINE\n         BAL   R9,WRITEREC         *    & GO WRITE A SPACER  LINE\n         SPACE 3\n         L     R2,STRGADDR         * GET A(AREA WHERE WE SAVED INFO)\n         SPACE 1\nNEXTLOG  EQU   *\n         CLC   0(10,R2),=C'PANEL ===>' * NEW PANEL LEGEND PRESENT ?\n         BNE   SAMEPANL            * - NO, KEEP WRITING THIS GROUP\n         CLC   0(19,R2),=C'PANEL ===> NTEXTEND' * COMMENT EXTENSION ?\n         BE    SAMEPANL                * - YES, SKIP SEPARATOR\n         LA    R1,=CL255' '        * POINT TO BLANK LINE\n         BAL   R9,WRITEREC         *    & GO WRITE A\n         LA    R1,=CL255' '        *       COUPLE OF\n         BAL   R9,WRITEREC         *          THEM\n         LA    R1,SEPLINE          * POINT TO SEPARATOR LINE\n         BAL   R9,WRITEREC         *    & GO WRITE IT OUT\n         SPACE 1\nSAMEPANL EQU   *\n         LA    R1,0(R2)            * POINT TO CURRENT DATA REC\n         BAL   R9,WRITEREC         *    & GO WRITE IT OUT\n         CLC   0(19,R2),=C'PANEL ===> NTEXTEND' * COMMENT EXTENSION ?\n         BE    NOSPACER                * - YES, SKIP SEPARATOR\n         CLC   0(10,R2),=C'PANEL ===>' * NEW PANEL LEGEND PRESENT ?\n         BNE   NOSPACER            * - YES,\n         LA    R1,SEPLINE          * POINT TO SEPARATOR LINE\n         BAL   R9,WRITEREC         *    & GO WRITE IT OUT\nNOSPACER EQU   *\n         LA    R2,80(R2)           * POINT TO NEXT REC\n         C     R2,NEXTNTRY         * HIT END OF TABLE ?\n         BL    NEXTLOG             * - NO, KEEP GOING\n         SPACE 1\n         SR    R1,R1               * INDICATE \"LAST TIME THROUGH\"\n         BAL   R9,WRITEREC         *    & GO LET SUBROUTINE WRITE\n*                                  *       OUT ANY REMAINING SHORT BLK\n         SPACE 4\n***********************************************************************\n* FOLLOWING LOGIC FAKES IN THE SPF STATISTICS FIELD FOR THE NEW       *\n* MEMBER, AND THEN ISSUES A \"STOW\" MACRO TO ADD IT TO THE PDS.        *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n* PUT USER'S ID INTO THE SPF DIRECTORY EXTENSION FIELD FOR IT.        *\n***********************************************************************\n         SPACE 1\n         MVC   VGETNAME(8),=C'ZUSER   ' * INDICATE VARIABLE NAME NEEDED\n         CALL  ISPLINK,(VGET,VGETLIST,SHARED),VL * PUT IN SHARED POOL\n         SPACE 2\n         MVC   L8(4),=F'8'         * RESET LENGTH 8 FIELD\n         SPACE 2\n         CALL  ISPLINK,(VCOPY,NMUSERID,L8,STUSERID,MOVE),VL\n*                                  * NOW COPY IT INTO OUR STORAGE,\n*                                  * IN THE SPF DIRECTORY EXTENSION\n*                                  * EXTENSION FIELD FOR USERID\n         SPACE 2\n***********************************************************************\n* ISSUE TIME MACRO AND BUILD IN SPF STATISTICS SECTION IN THE         *\n* DIRECTORY EXTENSION.                                                *\n***********************************************************************\n         SPACE 1\n         TIME  DEC                 * RESULT= P'HHMMSSTH' - NO PKD SIGN\n         ST    R1,STCRDAT          * BUILD SPF CREATE DATE\n         ST    R1,STMODDAT         * MAKE SPF LAST MODIFIED THE SAME\n         SRL   R0,16               * GET RID OF SECONDS & HUNDRETHS\n         STH   R0,STMODTIM         * PUT IN SPF LAST MOD TIME FIELD\n         SPACE 1\n***********************************************************************\n* ISSUE STOW MACRO TO FORCE NAME OF NEW PROBLEM/MEMBER INTO THE       *\n* NETWORK PROBLEM LOG DIRECTORY.                                      *\n***********************************************************************\n         STOW  NETRKOUT,STOWLIST,A\n         LTR   R2,R15              * STOW WORK OK?\n         BNZ   ABEND2              * - NO, GO ABEND\n         SPACE 2\n         CLOSE NETRKOUT              * CLOSE UP OUTPUT\n         SPACE 2\n***********************************************************************\n* LAST CALL CLIST \"NTRKCLST\" TO FREE NETWORK TRACKING LOG FILE        *\n***********************************************************************\n         SPACE 1\n         MVC  CMDBUF(23),=C'CMD(%NTRKCLST FREE)     '\n         CALL ISPLINK,(SELECT,CMDBUFLN,CMDBUF),VL * CALL CLIST TO\n         SPACE 2\n***********************************************************************\n* DISPLAY FINAL PANEL TO GIVE USER PROBLEM NUMBER ASSIGNED            *\n***********************************************************************\n         SPACE 1\n         MVC   VREPNAMS(10),=C'(NTPROB#) ' * FORCE IN VARIABLE NAME\n         SPACE 1\n         CALL  ISPLINK,(VREPLACE,VREPNAMS,REPLNTHS,STOWNAME),VL\n         SPACE 2\n         MVC   VPUTLIST,=C'(NTPROB#) ' *\n         SPACE 1\n         CALL  ISPLINK,(VPUT,VPUTLIST,SHARED),VL * \"VPUT\" PROBLEM\n*                                   * NUMBER VARIABLE\n         SPACE 1\n         MVC   PANLNAME(8),=C'NTPR#PNL' * PUT IN PROB# PANEL NAME\n         CALL  ISPLINK,(DISPLAY,PANLNAME),VL * DISPLAY PANEL TO SEE\n         SPACE 3\nFREEMAIN EQU   *\n         CLC   STRGADDR(4),=F'0'    * WE GET ANY STORAGE EARLIER ?\n         BE    NOGOT                * - NO, FORGET FREEMAIN\n         SPACE 1\n         FREEMAIN E,LV=524288,A=STRGADDR,SP=2 * FREE ANY STG WE GOT\n         SPACE 1\nNOGOT    EQU   *\nTERME    EQU   *\n         SPACE 1\n         CALL  ISPLINK,(CONTROL1,SPLIT,ENABLE),VL * RE-ENABLE SPLIT\n         SPACE 1\n         CORP  RC=(15)\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n*                    INTERNAL SUBROUTINES                             *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nBLDDTTIM EQU   *              ****** THIS SUBROUTINE BUILDS THE DATE\n*                                  * AND TIME OF THE RUN INTO A\n*                                  * FANCY DATE/TIME HEADING RECORD\n*                                  * FOR LATER USE\n         SPACE 1\n         STM   R8,R9,BLDTSAVE      * SAVE REGS WE'LL ALTER\n         SPACE 1\n*                        ********** FOLLOWING LOGIC BUILDS IPL DATE IN\n*                                 *    OUR PRINT HEADING\n         XC    DATEPARM(15),DATEPARM * INDICATE IPL DATE DESIRED\n         L     R15,=V(DATECNVT)   * GET ADDR OF DATE CONVERT/RETRIEVAL\n         LA    R1,DATEPARM        *     SUBROUTINE & PNT TO PARM LIST\n         BALR  R14,R15            * GO GET TODAY'S DATE\n         LTR   R15,R15            * WORK OK ?\n         BNZ   BLDDRETN           * - NO, FORGET IT\n         SPACE 1\n         MVC   DAY(9),DAYNAME     * MOVE NAME OF DAY OF WEEK TO HEAD\n         SR    R1,R1              * CLEAR WORK REG\n         IC    R1,DAYLNTH         * GET LENGTH OF LAST FIELD\n         LA    R15,DAY(R1)        * POINT TO 1ST BYTE PAST THAT\n         MVI   0(R15),C','        * MOVE IN PUNCTUATION\n         MVC   2(9,R15),MNTHNAME  * NOW MOVE IN NAME OF MONTH\n         IC    R1,MNTHLNTH        * GET IT'S LENGTH\n         LA    R15,3(R15,R1)      * POINT TO 1ST BYTE PAST RESULT\n         CLI   PRNTCAL+3,C'0'     * IS THERE ONLY ONE SIGNIFICANT\n*                                 *    DIGIT IN DAY OF MONTH ?\n         BE    SHORTDAY           * - YES, GO HANDLE SEPARATELY\n         MVC   0(2,R15),PRNTCAL+3 * - NO, MOVE IN BOTH DIGITS\n         LA    R15,2(R15)         *    & POINT TO NEXT FREE SPOT\n         B     RESTDATE           * NOW GO FINISH UP\nSHORTDAY MVC   0(1,R15),PRNTCAL+4 * MOVE IN ONLY SIGNIFICANT DIGIT\n         LA    R15,1(R15)         * POINT AROUND IT,\nRESTDATE MVI   0(R15),C','        * MOVE IN PUNCTUATION\n         MVC   2(2,R15),=C'19'    * FORCE IN CENTURY\n         MVC   4(2,R15),PRNTCAL+6 *    & THEN PUT IN YEAR\n         LA    R8,7(R15)          * SAVE A(NEXT AVAIL SPOT)\n         SPACE 3\n*                        ********** FOLLOWING BUILDS TIME OF DAY IN\n*                                 * PRINT HEADING\n         TIME\n         SRL   R0,12              * GET RID OF SECONDS & HUNDRETHS,\n*                                 *   BUT LEAVE ROOM FOR PACKED SIGN\n         ST    R0,DOUB+4          * PUT IN CORE,\n         OI    DOUB+7,X'0F'       * FORCE IN PACKED DECIMAL SIGN\n         SRL   R0,12              * GET RID OF EVERYTHING IN R0\n*                                 *   EXCEPT THE HOURS\n         CH    R0,=X'0012'        * IS THIS 12 NOON ?\n         BE    PM12               * - YES, GO ALTER PRINT LEGEND\n         BL    CHKMIDNT           * - NO, GO SEE IF IT'S MIDNIGHT\n         SP    DOUB+4(4),=P'1200' * IT'S 13:00 OR GREATER, SO LET'S\n*                                 *    CONVERT IT TO HUMAN TIME\nPM12     MVI   AMPM+1,C'P'        * CHANGE \"AM\" TO \"PM\"\n         B     EDTIME             *    & GO FINISH UP\n         SPACE 1\nCHKMIDNT LTR   R0,R0              * IS IT MIDNIGHT ?\n         BNZ   EDTIME             * - NO, LEAVE ALONE\n         AP    DOUB+4(4),=P'1200' * CHANGE \"00\" TO \"12\"\nEDTIME   MVC   FIELDWK(7),=X'402020207A2120' * MOVE IN EDIT PATTERN\n         LA    R1,FIELDWK+6        * PRE-POINT EDMK REG TO LAST BYTE\n         LR    R15,R1              * SAVE THIS VALUE\n         EDMK  FIELDWK(7),DOUB+5      * EDIT IN  TIME\n         SR    R15,R1              * CALC LENGTH OF RESULT\n         STC   R15,TIMEMVC+1       * ALTER OUR \"MVC\" LENGTH WITH IT\n         MVC   0(2,R8),=C'AT'      * MOVE IN LEGEND SECTION\nTIMEMVC  MVC   3(0,R8),0(R1)       * MOVE RESULT INTO HEADING\n         LA    R8,4(R8,R15)        * POINT TO NEXT FREE SPOT AND\n         MVC   0(4,R8),AMPM        * THEN MOVE IN AM/PM INDICATOR\n         SPACE 2\nBLDDRETN LM    R8,R9,BLDTSAVE      * RESTORE REGS WE USED\n         BR    R9                  *    & RETURN TO CALLER\n         SPACE 2\nBLDTSAVE DS    2F                  * SAVE AREA FOR ABOVE SUBROUTINE\n         SPACE 5\n         SPACE 5\nWRITEREC EQU    *              ***** SUBROUTINE TO WRITE OUT RECORDS\n*                                  * AS A MEW MEMBER OF THE LOG PDS.\n*                                  * ON ENTRY IF R1 IS >0, THEN IT\n*                                  * MUST POINT TO A RECORD (NOT A\n*                                  * BLOCK); IF R1 =0 THEN IT INDICATES\n*                                  * THAT NO MORE RECORDS WILL BE\n*                                  * PASSED FOR THIS MEMBER. THIS\n*                                  * ALLOWS THIS SUBROUTINE TO WRITE\n*                                  * OUT ANY PARTIAL (SHORT) BLOCK,\n*                                  * AND THEREFORE SHOULD BE USED ONLY\n*                                  * ONCE, AFTER THE LAST RECORD WAS\n*                                  * PASSED.\n         SPACE 1\n         STM   R6,R9,WRTMSAVE      * SAVE REGS WE'LL ALTER\n         SPACE 1\n         LTR   R1,R1               * R1 ACTUALLY POINT TO A REC ?\n         BZ    DONTADD             * - NO, DON'T UPDATE SPF STATS\n*                                  * 1ST UPDATE SPF REC COUNT\n         LH    R15,STINIT          * PICK UP CURRENT TOTAL RECS\n*                                  * (WILL BE SPF INITIAL SIZE)\n         LA    R15,1(R15)          * UPDATE BY ONE REC\n         STH   R15,STINIT          * PUT IT BACK\n         STH   R15,STSIZE          * ALSO UPDATE SPF SIZE\n         SPACE 1\nDONTADD  EQU   *                   *\n         LTR   R6,R1               * TRANSFER REC ADDR & SEE WHAT KIND\n         BNZ   NOTLSTBK            * IF IT CONTAINS A REC ADDR, GO\n*                                  *    BUILD THIS RECORD INTO OUR\n*                                  *       OUTPUT BLOCK\n         SPACE 1\n*                         ********** LOGIC TO WRITE OUT LAST BLOCK\n*                                  * FOR A MEMBER\n*                                  * - IF NOT, IT MEANS LAST RECORD IS\n*                                  *     ALREADY IN ON THIS BLOCK FOR\n*                                  * THIS MEMBER, SO WRITE BLOCK OUT\n         LH    R8,NOOFRECS         * GET NO OF RECS IN BLOCK\n         LTR   R8,R8               * WAS BLOCK ALREADY WRITTEN ANYWAY ?\n         BZ    WRITERTN            * - YES, SO GET OUT NOW\n         MH    R8,OUTLRECL         * MULTIPLY BY LRECL TO GET # OF\n*                                  *    BYTES ALREADY IN BLOCK\n         STH   R8,NETRKOUT+62      * MODIFY DCB BLKSIZE WITH THIS VALUE\n*                                  * NOW LET'S WRITE OUT FINAL SHORT\n*                                  *    BLOCK FOR THIS MEMBER\n         WRITE OUTLECB1,SF,NETRKOUT,OUTAREA\n         CHECK OUTLECB1            * WAIT & MAKE SURE WRITE WORKED OK\n         XC    NOOFRECS,NOOFRECS   * NOW RESET # OF RECORDS TO 0\n         B     WRITERTN            *    & GO RETURN\n         SPACE 2\nNOTLSTBK EQU   *         *********** NORMAL  RECORD/BLOCK LOGIC\n         SPACE 1\n         LH    R8,NOOFRECS         * GET # OF RECORDS CURRENTLY IN BLK\n         MH    R8,NETRKOUT+82      * CALC # OF BYTES IN BLOCK NOW\n         CH    R8,NETRKOUT+62      * IS THIS BLOCK FULL ?\n         BL    NOTFULL             * - NO, GO PUT REC IN CURR BLOCK\nWRITEBLK WRITE OUTLECB2,SF,NETRKOUT,OUTAREA\n*                                  * - YES, WRITE OUT FULL BLOCK\n         CHECK OUTLECB2            * WAIT & CHECK FOR NORMAL COMPLETION\n         SR    R8,R8               * CLEAR OUR # OF BYTES IN BLOCK REG\n         STH   R8,NOOFRECS         * RESET # OF RECORDS TO ZERO\n         SPACE 1\nNOTFULL  L     R1,=A(OUTAREA)      * GET A(OUTPUT AREA)\n         AR    R8,R1               * DEVELOP ADDR OF NEXT SPOT IN BLOCK\n*                                  *    TO PUT A RECORD\n         LH    R7,OUTLRECL         * GET LRECL & PUT IT IN\n         LR    R9,R7               *     \"MVCL\" LENGTH REGS\n         MVCL  R8,R6               * MOVE THIS REC TO BLOCK\n         LA    R1,1                * NOW UPDATE OUR\n         AH    R1,NOOFRECS         *    # OF RECORDS\n         STH   R1,NOOFRECS         *       ACCUMULATOR\n         SPACE 1\nWRITERTN EQU   *\n         MVC   NETRKOUT+62(2),OUTBLKSZ * RESET DCB BLOCKSIZE TO FULL\n*                                  *      BLOCKS\n         LM    R6,R9,WRTMSAVE      * RESTORE REGS WE USED\n         BR    R9                  *    & RETURN\n         SPACE 2\nWRTMSAVE DS    4F                  * SAVE AREA FOR ABOVE SUBROUTINE\n         SPACE 5\n         EJECT\n***********************************************************************\n*                                                                     *\n*                      USER ABENDS                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nABEND1   ABEND 101                 * UNCRECOVERABLE BPAM WRITE ERROR\nABEND2   ABEND 102                 * STOW MACRO FAILED\n         EJECT\n***********************************************************************\n*                                                                     *\n*                                                                     *\n* FOLLOWING ARE THE CONSTANTS AND VARIABLE FIELDS PASSED TO THE       *\n* \"ISPLINK\" MODULE BY US FOR THE VARIOUS \"DISPLAY\", \"VGET\", AND       *\n* \"VPUT\" SERVICES THAT WE NEED.                                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nVGET     DC    C'VGET    '         * NOTE RIGHT BLANK PAD TO 8 CHARS\nVGETLIST EQU   *                   * NAME OF VARIABLE TO \"VGET\"\nVGETNAME DC    CL80' '             *\n         SPACE 1\nVPUT     DC    C'VPUT    '         *\nVPUTLIST DC    CL250' '            * NAMES OF VARIABLES TO \"VPUT\"\n         SPACE 1\nDISPLAY  DC    C'DISPLAY  '        *\nPANLNAME DC    CL8' '              * NAME OF PANEL WE'LL USE\nNTERRPNL DC    C'NTERRPNL'         * NAME OF ERROR PANEL\nMSGNAME  DC    C'NETM00X'          *   & MESSAGE # TO GO WITH IT\nCONTROL1 DC    C'CONTROL '         *\nERRORS   DC    C'ERRORS  '         *\nRETURN   DC    C'RETURN  '         *\nSPLIT    DC    C'SPLIT   '         * DON'T ALLOW\nDISABLE  DC    C'DISABLE '         *    USE TO SPLIT SCREEN ON US\nENABLE   DC    C'ENABLE  '         * RE-ENABLE SPLIT BEFORE WE END\n         SPACE 1\nSHARED   DC    C'SHARED  '         *\n         SPACE 1\nVCOPY    DC    C'VCOPY   '         *\nMOVE     DC    C'MOVE    '         *\nL1       DC    F'1'                * LENGTH OF 1 FOR \"VCOPY\"\nL8       DC    F'8'                * LENGTH OF 8 FOR \"VCOPY\"\nL240     DC    F'240'              * LENGTH OF 240 FOR \"VCOPY\"\nCHAR     DC    C'CHAR    '         *\n         SPACE 1\nSELECT   DC    C'SELECT  '         * KEYWORD FOR \"SELECT\"\nCMDBUFLN DC    F'23'               * LENGTH OF \"CMDBUF\" BELOW\nCMDBUF   DC    CL23' '             * BUFFFER CMD TO CALL CLIST\n         SPACE 1\nVDEFINE  DC    C'VDEFINE '         * NAMES OF \"VDEFINE\" FUNCTION\nVDEF8LST DC    C'('                * VDEFINE NAMES BUILT HERE FOR\n         DC    C'NTNXTPNL '        *\n         DC    C'NTBADPNL '        *\n         DC    C'NTERRPNL '        *\n         DC    C'NTPROB#) '        *\n*                                  *    LENGTH 8 VARIABLES\nVDEF8VAL DC    CL80' '             * ALL LENGTH 8 VARS INIT TO BLANK\n         SPACE 1\nVREPLACE DC    C'VREPLACE '        *\nVREPNAMS DC    C'(NTBADPNL) '      * VARIABLE FOR VREPLACE\nREPLNTHS DC    F'8'                * LNTH OF VARIABLE NAME FOR VREPLACE\nVRNMNPAN DC    C'(NTNXTPNL) '      * VARIABLE FOR VREPLACE\nVRNONAME DC    C'$NONAME$'         * INVALID NAME - ON PURPOSE\n         SPACE 1\nNMUSERID DC    C'ZUSER    '        * NAMES OF THE\nNMCONTIN DC    C'NTCONTIN '        *\nNMNXTPNL DC    C'NTNXTPNL '        *\nNAMELST1 EQU   *    (USED ONLY BY VDEFINE)\nLFTPAREN DC    C' '                *\nNMDATA00 DC    C'NTDATA00 '        *        VARIABLE FIELDS\nNMDATA01 DC    C'NTDATA01 '        *\nNMDATA02 DC    C'NTDATA02 '        *\nNMDATA03 DC    C'NTDATA03 '        *               WE'LL NEED\nNMDATA04 DC    C'NTDATA04 '        *\nNMDATA05 DC    C'NTDATA05 '        *\nNMDATA06 DC    C'NTDATA06 '        *\nNMDATA07 DC    C'NTDATA07 '        *\nNMDATA08 DC    C'NTDATA08 '        *\nNMDATA09 DC    C'NTDATA09 '        *\nRTPAREN  DC    C' '                *\nENDNMLST DC    CL10' '             * THIS TERMINATES NAMELIST SCAN\n         SPACE 3\n*                              ***** FIELDS BELOW ARE THE ONLY\n*                                  * VARIABLES WE'LL RETRIEVE; THESE\n*                                  * ARE THE STORAGE AREAS WHERE THE\n*                                  * DATA IS ACTUALLY PLACED\n         SPACE 1\nNTNXTPNL DC    CL8' '              * NAME OF NEXT PANEL\nNTCONTIN DC    C' '                * C'Y' INDICATES USER NEEDS ADDIT-\n*                                  *   IONAL ROOM FOR COMMENTS\nGENVARS  EQU   *                   * \"VDEFINE\"\nNTDATA00 DC    CL240' '            * FIRST DATA FIELD\nNTDATA01 DC    CL240' '            * 2ND DATA FIELD\nNTDATA02 DC    CL240' '            * 3RD DATA FIELD,\nNTDATA03 DC    CL240' '            *\nNTDATA04 DC    CL240' '            *    ETC\nNTDATA05 DC    CL240' '            *\nNTDATA06 DC    CL240' '            *\nNTDATA07 DC    CL240' '            *\nNTDATA08 DC    CL240' '            *\nNTDATA09 DC    CL240' '            *\n*                                  *\n         SPACE 1\nREPDATA  DS    0CL8            ***** FOLLOWING FIELD FOR VREPLACE\nNTBADPNL DC    CL8' '              * NAME OF PANEL IN ERROR\n         SPACE 5\nDOUB     DC    D'0'                * WORK AREA\n         SPACE 1\nPARMADDR DC    F'0'                * A(PARM PASSED - IF ANY)\n         SPACE 3\nOUTLRECL DS    H                   * PDS LRECL\nOUTBLKSZ DS    H                   * PDS FULL BLOCK SIZE\nNOOFRECS DC    H'0'                * # OF RECS CURRENTLY IN BLOCK\n         SPACE 3\n         DS    0D                  *\nSTOWLIST EQU   *                   * LIST FOR \"STOW\" TO UPDATE PDS\n*                                  * DIRECTORY FOR \"SYS1.AUTHOR.IZED.\n*                                  * DATASETS\".\nSTOWNAME DC    CL8'PRB00000'       * PROTOTYPE NAME OF MEMBER\nSTOWTTR  DC    CL3' '              * TTR ADDR; FILLED IN BY SYSTEM\nSTOWC    DC    X'0F'               * FLAG BYTE - SPF # OF USER HALF\n*                                  *    WORDS IN DIRECTORY EXTENSION\nSTOWUSRD DS    0CL62               * MAXIMUM POSSIBLE USER DATA XTNSN\n*                                  *   SPF USES 15 HALFWORDS\nSTVERMOD DC    X'0100'             * SPF VER/MOD LEVEL\n         DC    XL2'00'             * NOT USED\nSTCRDAT  DC    PL4'0'              * SPF CREATE DATE - P'YYDDD' JULIAN\nSTMODDAT DC    PL4'0'              * SPF LAST MOD DATE - P'YYDDD' JUL\nSTMODTIM DC    XL2'00'             * SPF LAST MOD TIME P'HHMM' WITH\n*                                  *    PACKED SIGN DROPPED\nSTSIZE   DC    XL2'00'             * SPF CURRENT # RECS, BINARY\nSTINIT   DC    XL2'00'             * SPF INITIAL # RECS, BINARY\nSTMODLVL DC    XL2'00'             * SPF MOD LEVEL - FORCE TO 0\nSTUSERID DC    CL8' '              * SPF USER ID\n         DC    CL2' '              * FILLER\n         SPACE 3\nNETRKDIR DCB   DSORG=PS,MACRF=GL,DDNAME=NETRKLOG,RECFM=U,BLKSIZE=32760,X\n               EODAD=EODDIRCT\n         SPACE 3\nNETRKOUT DCB   DSORG=PO,MACRF=W,DDNAME=NETRKLOG,SYNAD=ABEND1\n         SPACE 3\n         LTORG\n         SPACE 3\nFIELDWK  DC    CL12' '             * WORK AREA FOR EDMK\n         SPACE 3\nAMPM     DC    C' AM.'             * AM/PM INDICATOR\n         SPACE 3\n         DS    0D                  * MUST DOUBLEWORD ALIGN PARM BELOW\nDATEPARM EQU   *                   ***** PARM LIST FOR EXTERNAL DATE\n*                                  * CONVERSION/RETRIEVAL SUBROUTINE\nPACKJUL  DS    PL3                 * PACKED JULIAN - P'YYDDD'\nPACKCAL  DS    PL4                 * PACKED CALENDAR - P'MMDDYY'\nPRNTCAL  DS    CL8                 * PRINTABLE DATE - C'MM/DD/YY'\nMNTHLNTH DS    XL1                 * LENGTH OF NAME OF MONTH FOLLOWING\nMNTHNAME DS    CL9                 * NAME OF MONTH - E.G. C'JUNE     '\nDAYLNTH  DS    XL1                 * LENGTH OF NAME OF DAY FOLLOWING\nDAYNAME  DS    CL9                 * NAME OF DAY - E.G. C'MONDAY   '\nDATEWORK DS    CL21                * WORK AREA REQUIRED BY SUBROUTINE\n         SPACE 3\n*                                  *    DATE IN CHARACTER\n         SPACE 1\nSEPLINE  DC    CL80'--------------------'\n         SPACE 1\nDATEREC DS     0CL80           *****  AREA TO BUILD FANCY DATE/TIME\n         DC    C'THIS PROBLEM WAS LOGGED ON '\nDAY      DC    CL80' '             *\n         SPACE 3\nSTRGADDR DC    F'0'                * A(GETMAINED 512K TO BUILD DATA)\nNEXTNTRY DC    F'0'                * A(SPOT FOR NEXT ENTRY IN STG)\nLASTNTRY DC    F'0'                * A(LAST SAFE SPOT TO USE)\n         SPACE 3\nOUTAREA  DS    CL32760             * AREA FOR BUILDING OUTPUT BLOCKS\n         SPACE 3\n         SPACE 3\n**************************************************************\n*   ABSOLUTE REGISTER EQUATES\n**************************************************************\n          SPACE\nR0        EQU   0\nR1        EQU   1           PARAMETER REGISTER\nR2        EQU   2\nR3        EQU   3\nR4        EQU   4\nR5        EQU   5\nR6        EQU   6\nR7        EQU   7\nR8        EQU   8\nR9        EQU   9\nR10       EQU   10\nR11       EQU   11\nR12       EQU   12\nR13       EQU   13          ADDRESS OF SAVE-AREA\nR14       EQU   14          RETURN REGISTER\nR15       EQU   15\n          SPACE\n**************************************************************\n*   CONDITIONAL VALUES\n**************************************************************\n          SPACE\n*   AFTER COMPARE INSTRUCTIONS (A:B)\n          SPACE\nH         EQU   2           A HIGH\nL         EQU   4           A LOW\nE         EQU   8           A EQUAL B\nNH        EQU   13          A NOT HIGH\nNL        EQU   11          A NOT LOW\nNE        EQU   7           A NOT EQUAL B\n          SPACE\n*   AFTER ARITHMETIC INSTRUCTIONS\n          SPACE\nO         EQU   1           OVERFLOW     (AFTER TM - ALL ONES)\nP         EQU   2           PLUS\nM         EQU   4           MINUS        (AFTER TM - MIXED   )\nZ         EQU   8           ZERO         (AFTER TM - ALL ZERO)\nNP        EQU   13          NOT PLUS\nNM        EQU   11          NOT MINUS\nNZ        EQU   7           NOT ZERO\n          SPACE\n*   AFTER TEST UNDER MASK INSTRUCTIONS\n          SPACE\nNO        EQU   14          NOT ONES     (SEE ABOVE FOR O, M, & Z)\n          SPACE\n**************************************************************\n         END   NETTRACK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWMSGS": {"ttr": 9731, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS;\n /*\n   TITLE      -   NEWMSGS\n\n   FUNCTION   -   THIS PROGRAM WILL INITIALIZE AN EMPTY MEMBER OF A PDS\n                  WITH 10 BLANK MESSAGES.  EACH MESSAGE CONSISTS OF A\n                  MESSAGE ID, SHORT MESSAGE, HELP KEYWORD, ALARM\n                  KEYWORD, AND LONG MESSAGE.\n\n   SPECIFIER  -   CAROLINE WILLIAMS\n                  EXXON COMPANY, USA (EDPC)\n\n   DEVELOPER  -   CAROLINE WILLIAMS\n\n   DATE       -   FEBRUARY 28, 1986\n\n   LANGUAGE   -   PLI\n\n   PANVALET   -\n\n   ENTRY      -   PLISTART\n\n   LINKAGE    -   THIS PROGRAM IS AN EDIT MACRO.\n\n   EXT. REF.  -   ISPLINK\n\n   DATA SETS  -   NONE\n\n   SPF TABLES -   NONE\n\n   SPF PANELS -   NONE\n\n   SPF MSGS   -   NONE\n\n   UPDATES    -   NONE\n\n */\n1NEWMSGS: PROC OPTIONS(MAIN);\n0   DCL ISPLINK       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        PLIRETV       BUILTIN,\n        REPEAT        BUILTIN,\n        SUBSTR        BUILTIN,\n        RETCODE       FIXED BIN(31),\n        LVAR          FIXED BIN(31),\n        ZERO          FIXED BIN(31)   INIT(0);\n0   DCL MEMNAME       CHAR(8),\n        BUF80A        CHAR(80),\n        BUF80B        CHAR(80),\n        BUF80C        CHAR(80),\n        NUMB          PIC'9',\n        PIC_2         PIC'99',\n        QUOTE         CHAR(1)   INIT(''''),\n        HELP          CHAR(8)   INIT(' .HELP=*'),\n        ALARM         CHAR(10)  INIT('.ALARM=NO '),\n        LPTR          CHAR(2),\n        LMEMBER       FIXED BIN(31),\n        LSPACE        FIXED BIN(31),\n        (I,J,K)       FIXED BIN(31);\n1   CALL ISPLINK('ISREDIT ',ZERO,'\u00a2MACRO\u00a2');\n    CALL ISPLINK('ISREDIT ',ZERO,'\u00a2LOCATE 0\u00a2');\n    RETCODE = PLIRETV;\n0   IF RETCODE > 4\n       THEN DO;\n            LVAR = 2;\n            CALL ISPLINK('VDEFINE ','LPTR    ',LPTR,'CHAR',LVAR);\n            LVAR = 80;\n            CALL ISPLINK('VDEFINE ','BUF80A  ',BUF80A,'CHAR',LVAR);\n            CALL ISPLINK('VDEFINE ','BUF80B  ',BUF80B,'CHAR',LVAR);\n            CALL ISPLINK('VDEFINE ','BUF80C  ',BUF80C,'CHAR',LVAR);\n            CALL ISPLINK('ISREDIT ',ZERO,'\u00a2(MEMNAME) = MEMBER\u00a2');\n            LVAR = 8;\n            CALL ISPLINK('VCOPY   ','(MEMNAME)',LVAR,MEMNAME,'MOVE');\n            LMEMBER = LVAR;\n            LSPACE = 11 - LMEMBER;\n            J = 0;\n0           DO I = 0 TO 9;\n               NUMB = I;\n               BUF80A = SUBSTR(MEMNAME,1,LMEMBER) || NUMB ||\n                        REPEAT(' ',LSPACE) || QUOTE || REPEAT(' ',23)||\n                        QUOTE || HELP || REPEAT(' ',8) || ALARM ||\n                        REPEAT(' ',13);\n               BUF80B = QUOTE || REPEAT(' ',69) || QUOTE ||\n                        REPEAT(' ',7);\n               BUF80C = REPEAT('~',79);\n               PIC_2 = J;\n               LPTR = PIC_2;\n               CALL ISPLINK('ISREDIT ',ZERO,\n                            '\u00a2LINE_AFTER (LPTR) = (BUF80A)\u00a2');\n               J = J + 1;\n               PIC_2 = J;\n               LPTR = PIC_2;\n               CALL ISPLINK('ISREDIT ',ZERO,\n                            '\u00a2LINE_AFTER (LPTR) = (BUF80B)\u00a2');\n               J = J + 1;\n               PIC_2 = J;\n               LPTR = PIC_2;\n               CALL ISPLINK('ISREDIT ',ZERO,\n                            '\u00a2LINE_AFTER (LPTR) = (BUF80C)\u00a2');\n               J = J + 1;\n            END;\n0           CALL ISPLINK('ISREDIT ',ZERO,'\u00a2CHANGE \"~\" \" \" ALL\u00a2');\n            CALL ISPLINK('ISREDIT ',ZERO,'\u00a2RESET\u00a2');\n            END;\n0END NEWMSGS;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OUTPRNT2": {"ttr": 9734, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS;\n /*\n   TITLE      -   TUTPRNT2\n\n   FUNCTION   -   THIS PROGRAM PRINTS TUTORIAL PANELS IN ORDER\n\n   SPECIFIER  -   CHRIS GERKEN\n\n   DEVELOPER  -   CHRIS GERKEN\n\n   DATE       -   OCTOBER 10, 1984\n\n   LANGUAGE   -   PLI\n\n   PANVALET   -\n\n   ENTRY      -   PLISTART\n\n   LINKAGE    -   THIS PROGRAM IS SELECTED BY CLIST TUTPRINT\n\n   EXT. REF.  -   ISPLINK\n\n   DATA SETS  -   PDS'S CONTAINING ISPF PANEL DEFINITIONS\n\n   SPF TABLES -   TUTPTABL\n\n   SPF PANELS -   TUTPC050\n\n   SPF MSGS   -   TUTP000\n\n   UPDATES    -   NONE\n\n */\n1TUTPRNT: PROC OPTIONS(MAIN);\n0   DCL ISPLINK       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        ISPEXEC       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        PLIRETV       BUILTIN,\n        RETCODD       FIXED BIN(31),\n        RETCODE       FIXED BIN(31),\n        LVAR          FIXED BIN(31);\n0   DCL CTABLE       STREAM FILE PRINT,\n        LISTING      STREAM FILE PRINT;\n0   DCL NEW_AMPER     BIT(1),\n        XEROX         BIT(1),\n        BOLD          BIT(1)  INIT('1'B),\n        EOV           BIT(1),\n        EXP1          CHAR(1),\n        EXP2          CHAR(1),\n        TOC           BIT(1),\n        PAN           BIT(1),\n        CAP           BIT(1),\n        REMOT         CHAR(5),\n        DATAID        CHAR(8),\n        TUTOR         CHAR(8),\n        MEMBER        CHAR(8),\n        SYSUID        CHAR(8),\n        QUP           CHAR(8),\n        QCONT         CHAR(8),\n        QSEL          CHAR(400),\n        BUF_10        CHAR(10),\n        H_POS         CHAR(60),\n        VALID_CHARS   CHAR(65),\n        KEYLIST       CHAR(20),\n        NAMELIST      CHAR(100),\n        BUFFER        CHAR(300),\n        VERIFY        BUILTIN,\n        INDEX         BUILTIN,\n        HIGH          BUILTIN,\n        MIN           BUILTIN,\n        MOD           BUILTIN,\n        REPEAT        BUILTIN,\n        TRANSLATE     BUILTIN,\n        TIME          BUILTIN,\n        SUBSTR        BUILTIN;\n0   DCL EOF           BIT(1),\n        OVERPRINT     BIT(1),\n        EXPAND        BIT(1),\n        BLANK_FIELD   BIT(1),\n        PRINT_PANELS  BIT(1),\n        PRINT_CTABLE  BIT(1),\n        NOT_FOUND     BIT(1),\n        PRINT_ME      BIT(1),\n        PIC_2         PIC'Z9',\n        PIC_2A        PIC'99',\n        PIC_4         PIC'ZZZ9',\n        ROWID         FIXED BIN(31),\n        SECTION       FIXED BIN(31),\n        LEVEL         FIXED BIN(31),\n        PAGE#         FIXED BIN(31)  INIT(0),\n        TOTNUM        FIXED BIN(31),\n        TTL_BEG       FIXED BIN(31),\n        TTL_END       FIXED BIN(31),\n        LINE#         FIXED BIN(31)  INIT(0),\n        CTABLE_LINE#  FIXED BIN(31)  INIT(0),\n        FIELD#        FIXED BIN(31),\n        ISEL          FIXED BIN(31),\n        NSEL          FIXED BIN(31),\n        ICONT         FIXED BIN(31),\n        IOVER         FIXED BIN(31),\n        POS           FIXED BIN(31),\n        POS1          FIXED BIN(31),\n        POS2          FIXED BIN(31),\n        MORE          FIXED BIN(31),\n        LEFT          FIXED BIN(31),\n        FILL          FIXED BIN(31),\n        (I,J,K,L,M,N) FIXED BIN(31),\n        TUTNUM        FIXED BIN(31)  INIT(0),\n        BUFLEN        FIXED BIN(31),\n        EXP_COUNT     FIXED BIN(31),\n        EXP_STRT(0:50) FIXED BIN(31),\n        PAGES(50)     FIXED BIN(31),\n        HRCHY(50)     FIXED BIN(31),\n        UDK           CHAR(1),\n        BUF_2         CHAR(2),\n        BUF_3         CHAR(3),\n        BUF_4         CHAR(4),\n        UPPER_CASE    CHAR(26) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        LOWER_CASE    CHAR(26) INIT('abcdefghijklmnopqrstuvwxyz'),\n        BUF1          CHAR(80),\n        BUF2          CHAR(80),\n        BUF_80        CHAR(80),\n        BUF3          CHAR(120),\n        LINE          CHAR(80),\n        SCREEN(32)    CHAR(80);\n0   DCL FDCLIST       CHAR(19),\n        FDCTYPE(0:19) FIXED BIN(31),\n        FDCINT(0:19)  FIXED BIN(31),\n        FDCPAD(0:19)  CHAR(1),\n        FDC#          FIXED BIN(31),\n        FDCS          FIXED BIN(31);\n0   DCL START         FIXED BIN(31) INIT(0),\n        ATTR          FIXED BIN(31) INIT(1),\n        BODY          FIXED BIN(31) INIT(2),\n        MODEL         FIXED BIN(31) INIT(3),\n        INIT          FIXED BIN(31) INIT(4),\n        REINIT        FIXED BIN(31) INIT(5),\n        PROC          FIXED BIN(31) INIT(6),\n        END           FIXED BIN(31) INIT(7);\n0   DCL WIDTH         FIXED BIN(31) INIT(25),\n        HIGHT         FIXED BIN(31) INIT(40);\n0   DCL HELPID        CHAR(20),\n        HELP_FOUND    BIT(1),\n        HELPLEN       FIXED BIN(31);\n1   CALL ISPLINK('CONTROL ','ERRORS  ','RETURN  ');\n0   CALL SETUP;\n0   /*   OUTPUT THOSE TUTORIALS                                */\n0   LVAR = 75;\n    BUFFER = 'LMMLIST        DATAID(&ID)    OPTION(LIST)   ' ||\n             'MEMBER(MEMBER) STATS(YES)     ';\n    CALL ISPEXEC(LVAR , BUFFER);\n    LVAR = 8;\n    CALL ISPLINK('VCOPY   ','(TUTORTOP)', LVAR, TUTOR ,'MOVE');\n    LEVEL = 1;\n    PAGES(1) = 1;\n    CALL TUTPROC;\n    CALL NEXTTUT;\n    DO WHILE (LEVEL > 0);\n       CALL TUTPROC;\n       CALL NEXTTUT;\n       END;\n0   CALL ISPLINK('TBEND   ','TUTPTABL');\n    CALL ISPLINK('SETMSG  ','TUTP000 ');\n    CALL ISPLINK('VRESET  ');\n1TUTPROC: PROC;\n0   /*   START:    LEVEL IS SET TO THE CURRENT POSITION IN THE TUTORIAL\n                            HIERARCHY.\n                   TUTOR IS SET TO THE ID OF THE TUTORIAL TO BE\n                            PROCESSED.\n\n         PROCESS:  PRINT TUTORIAL PANEL.\n                   SAVE ZSEL, ZCONT AND ZUP VALUES.\n                   ADD A ROW FOR THIS PANEL IN TUTPTABL\n\n         END:      ROWID IS SET TO THE ROW-ID OF THE ROW FOR THIS PANEL\n                            IN TUTPTABL.\n                   HRCHY(LEVEL) IS SET TO THE ROW-ID OF TUTOR\n     */\n0   CALL INITIAL;\n    IF MOD(PAGE#,10) = 0\n       THEN CALL ISPLINK('CONTROL ','DISPLAY ','REFRESH ');\n       ELSE;\n    CALL ISPLINK('CONTROL ','DISPLAY ','LOCK    ');\n    CALL ISPLINK('DISPLAY ','TUTPC050');\n0   I = 0;\n    CALL NEWLINE;\n    DO WHILE (\u00acEOF);\n       I = I + 1;\n       SELECT(SECTION);\n         WHEN(ATTR)  IF I > 1\n                        THEN DO;\n                             CALL RAISE;\n                             CALL DECOM;\n                             CALL NEWFDC;\n                             END;\n                        ELSE;\n         WHEN(BODY)  IF ((SUBSTR(LINE,1,5) \u00ac= ')BODY') & (LINE# < 32))\n                        THEN DO;\n                             IF EXPAND\n                                THEN CALL EXPLINE;\n                                ELSE;\n                             LINE# = LINE# + 1;\n                             SCREEN(LINE#) = LINE;\n                             END;\n                        ELSE;\n         WHEN(PROC)  DO;\n                     CALL RAISE;\n                     CALL DECOM;\n                     POS = VERIFY(LINE,' ');\n                     IF POS > 0\n                        THEN DO;\n                             IF POS < 74\n                               THEN IF SUBSTR(LINE,POS,6) = '&ZCONT'\n                                    THEN DO;\n                                         CALL GET_CONT;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 75\n                               THEN IF SUBSTR(LINE,POS,5) = '&ZSEL'\n                                    THEN DO;\n                                         CALL GET_SEL;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 76\n                               THEN IF SUBSTR(LINE,POS,4) = '&ZUP'\n                                    THEN DO;\n                                         CALL GET_UP;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 75\n                               THEN IF SUBSTR(LINE,POS,5) = '&CONT'\n                                    THEN DO;\n                                         CALL GET_CONT;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 76\n                               THEN IF SUBSTR(LINE,POS,4) = '&SEL'\n                                    THEN DO;\n                                         CALL GET_SEL;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 77\n                               THEN IF SUBSTR(LINE,POS,3) = '&UP'\n                                    THEN DO;\n                                         CALL GET_UP;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             END;\n                        ELSE;\n                     END;\n         OTHERWISE;\n         END;\n       CALL NEWLINE;\n       END;\n0   IF INDEX(FDCLIST,'&') = 0\n       THEN NEW_AMPER = '0'B;\n       ELSE NEW_AMPER = '1'B;\n0   /*  UPDATE TABLE          */\n0   IF NOT_FOUND\n       THEN DO;\n            LEVEL = LEVEL - 1;\n            END;\n       ELSE DO;\n            NSEL = 0;\n            MEMBER = TUTOR;\n            CALL ISPLINK('TBADD   ','TUTPTABL');\n            RETCODE = PLIRETV;\n            IF RETCODE > 0\n               THEN DO;\n                    LEVEL = LEVEL - 1;\n                    END;\n               ELSE DO;\n                    CALL ISPLINK('TBGET   ','TUTPTABL','D1 ','ROWID  ');\n                    HRCHY(LEVEL) = ROWID;\n                    END;\n            END;\n    IF \u00acNOT_FOUND      /* HOW 'BOUT THOSE DOUBLE NEGATIVES?  */\n       THEN DO;\n            TOTNUM = TOTNUM + 1;\n            PAGE# = PAGE# + 1;\n            IF PAN\n               THEN DO;\n                    PUT PAGE FILE(LISTING);\n                    PUT FILE(LISTING) SKIP(5);\n                    DO I = 1 TO LINE#;\n                       CALL DSPLINE;\n                       END;\n                    CALL FOOTER;\n                    END;\n               ELSE;\n            IF TOC\n               THEN DO;\n                    IF MOD(TUTNUM,40) = 0\n                       THEN DO;\n                            PUT PAGE    FILE(CTABLE);\n                            PUT SKIP(6) FILE(CTABLE);\n                            END;\n                       ELSE;\n                    TUTNUM = TUTNUM + 1;\n                    POS  = INDEX(SUBSTR(SCREEN(1),15,66),' ') + 14;\n                    POS1 = VERIFY(SUBSTR(SCREEN(1),POS,81-POS),' ') +\n                           POS - 1;\n                    POS2 = INDEX(SUBSTR(SCREEN(1),POS1,81-POS1),'----');\n                    PUT FILE(CTABLE) EDIT\n                                       (SUBSTR(SCREEN(1),POS1,POS2-1) ||\n                                        REPEAT('..',15-LEVEL) ||\n                                        REPEAT('.', 50-POS2),\n                                        PAGE#,'('||TUTOR||')')\n                                       (COL(LEVEL*2),A,\n                                        COL(83),F(4),X(3),A(10));\n                    END;\n               ELSE;\n            END;\n       ELSE;\n1INITIAL: PROC;\n    CALL ISPLINK('LMMFIND ', DATAID , TUTOR);\n    RETCODE = PLIRETV;\n    NOT_FOUND = (RETCODE > 0);\n0   H_POS = REPEAT(' ',59);\n    PIC_2A = PAGES(1);\n    SUBSTR(H_POS,1,2) = PIC_2A;\n    DO I = 2 TO LEVEL;\n       PIC_2A = PAGES(I);\n       SUBSTR(H_POS,I*3-3) = '.' || PIC_2A;\n       END;\n0   /*   INITIALIZE COUNTERS AND STUFF...   */\n0   EOF = '0'B;\n    FDCS = 3;\n    FDCTYPE = 0;\n    FDCTYPE(0) = 1;\n    FDCTYPE(1) = 1;\n    FDCTYPE(2) = 1;\n    FDCTYPE(3) = 2;\n    FDCINT = 0;\n    FDCINT(0) = 0;\n    FDCINT(1) = 1;\n    FDCINT(2) = 0;\n    FDCINT(3) = 1;\n0   SECTION = 0;\n    SUBSTR(FDCLIST,1,3) = '%+_';\n    FDCPAD(0) = ' ';\n    FDCPAD(1) = ' ';\n    FDCPAD(2) = ' ';\n    FDCPAD(3) = ' ';\n    LINE# = 0;\n    HELP_FOUND = '0'B;\n    HELPID = '                    ';\n0   CALL ISPLINK('TBVCLEAR','TUTPTABL');\n0   ICONT = 0;\n    IOVER = 0;\n    ISEL  = 0;\n    NSEL  = 0;\n0END INITIAL;\n1NEWLINE: PROC;\n0   LVAR = 90;\n    BUFFER = 'LMGET          DATAID(&ID)    MODE(INVAR)    ' ||\n             'DATALOC(INVAR) DATALEN(LNVAR) MAXLEN(80)     ';\n    CALL ISPEXEC(LVAR , BUFFER);\n    RETCODE = PLIRETV;\n    IF RETCODE = 8\n       THEN EOF = '1'B;\n       ELSE SELECT;\n              WHEN (SUBSTR(LINE,1,6) = ')ATTR ')\n                              IF (I = 0)\n                                 THEN DO;\n                                      SECTION = ATTR;\n                                      POS = INDEX(LINE,'DEFAULT(');\n                                      IF POS > 0\n                                         THEN SUBSTR(FDCLIST,1,3) =\n                                                   SUBSTR(LINE,POS+8,3);\n                                         ELSE;\n                                      FDCPAD = ' ';\n                                      END;\n                                 ELSE;\n              WHEN (SUBSTR(LINE,1,6) = ')BODY ') DO;\n                              SECTION = BODY;\n                              POS = INDEX(LINE,'EXPAND(');\n                              IF (POS > 0) & (POS < 72)\n                                 THEN DO;\n                                      POS = POS + 7;\n                                      EXPAND = '1'B;\n                                      EXP1 = SUBSTR(LINE,POS,1);\n                                      EXP2 = SUBSTR(LINE,POS+1,1);\n                                      END;\n                                 ELSE EXPAND = '0';\n                              END;\n              WHEN (SUBSTR(LINE,1,6) = ')INIT ')\n                              SECTION = INIT;\n              WHEN (SUBSTR(LINE,1,6) = ')PROC ')\n                              SECTION = PROC;\n              WHEN (SUBSTR(LINE,1,5) = ')END ') DO;\n                              SECTION = END;\n                              EOF = '1'B;\n                              END;\n              OTHERWISE     IF I = 0\n                               THEN SECTION = BODY;\n                               ELSE;\n              END;\n0END NEWLINE;\n1NEWFDC: PROC;\n0   POS = VERIFY(LINE,' ');\n    IF POS > 0\n       THEN DO;\n            FDCS = FDCS + 1;\n            FDCINT(FDCS) = 0;\n            FDCTYPE(FDCS) = 1;\n            SUBSTR(FDCLIST,FDCS,1) = SUBSTR(LINE,POS,1);\n            FDCPAD(FDCS)  = ' ';\n            IF INDEX(LINE,'INTENS(HIGH)') > 0\n               THEN FDCINT(FDCS) = 1;\n               ELSE;\n            IF INDEX(LINE,'TYPE(OUTPUT)') > 0\n               THEN FDCTYPE(FDCS) = 0;\n               ELSE;\n            IF INDEX(LINE,'TYPE(TEXT)') > 0\n               THEN FDCTYPE(FDCS) = 1;\n               ELSE;\n            IF INDEX(LINE,'TYPE(INPUT)') > 0\n               THEN FDCTYPE(FDCS) = 2;\n               ELSE;\n            POS = INDEX(LINE,'PAD(');\n            IF POS > 0\n               THEN FDCPAD(FDCS) = SUBSTR(LINE,POS+5,1);\n               ELSE;\n            IF INDEX(LINE,'INTENS(NON)') > 0\n               THEN DO;\n                    FDCINT(FDCS) = 0;\n                    FDCTYPE(FDCS)= 0;\n                    FDCPAD(FDCS) = ' ';\n                    END;\n               ELSE;\n            END;\n       ELSE;\n0END NEWFDC;\n1EXPLINE: PROC;\n0   POS1 = INDEX(LINE,EXP1);\n    EXP_COUNT = 0;\n    EXP_STRT(0) = 0;\n    POS = 0;\n    DO WHILE (POS1 > 0);\n       POS = POS + POS1;\n       IF SUBSTR(LINE,POS+2,1) = EXP2\n          THEN DO;\n               LINE = SUBSTR(LINE,1,POS-1) ||\n                      SUBSTR(LINE,POS+1,1) ||\n                      SUBSTR(LINE,POS+3,78-POS) || '  ';\n               EXP_COUNT = EXP_COUNT + 1;\n               EXP_STRT(EXP_COUNT) = POS;\n               END;\n          ELSE;\n       POS1 = INDEX(SUBSTR(LINE,POS+1,81-POS),EXP1);\n       END;\n0   IF EXP_COUNT > 0\n       THEN DO;\n0           DO POS = 80 TO 1 BY -1 WHILE(SUBSTR(LINE,POS,1) = ' ');\n               END;\n            POS = 80 - POS;\n0           MORE = MOD(POS,EXP_COUNT);\n            FILL = (POS - MORE) / EXP_COUNT;\n            N = 1;\n0           DO M = 1 TO MORE;\n               J = EXP_STRT(M-1) + 1;\n               K = EXP_STRT(M);\n               SUBSTR(BUF_80,N,K-J+2+FILL) = SUBSTR(LINE,J,K-J) ||\n                                             REPEAT(SUBSTR(LINE,K,1),\n                                                    FILL+2);\n               N = N + K - J + FILL;\n               END;\n0           DO M = (MORE + 1) TO EXP_COUNT;\n               J = EXP_STRT(M-1) + 1;\n               K = EXP_STRT(M);\n               SUBSTR(BUF_80,N,K-J+1+FILL) = SUBSTR(LINE,J,K-J) ||\n                                             REPEAT(SUBSTR(LINE,K,1),\n                                                    FILL+1);\n               N = N + K - J - 1 + FILL;\n               END;\n0           LEFT = 81 - POS - EXP_STRT(M-1);\n            SUBSTR(BUF_80,N,LEFT) = SUBSTR(LINE,EXP_STRT(M-1)+1,LEFT);\n            LINE = BUF_80;\n            END;\n       ELSE;\n0END EXPLINE;\n1RAISE: PROC;\n0   LINE = TRANSLATE(LINE,UPPER_CASE,LOWER_CASE);\n0END RAISE;\n1DECOM: PROC;\n0   POS1 = INDEX(LINE,'/*');\n    POS2 = INDEX(SUBSTR(LINE,POS1+2,79-POS1),'*/');\n    DO WHILE ((0 < POS1) & (0 < POS2));\n       SUBSTR(LINE,POS1,POS1+POS2+3) = REPEAT(' ',POS1+POS2+2);\n       POS1 = INDEX(LINE,'/*');\n       POS2 = INDEX(SUBSTR(LINE,POS1+2,79-POS1),'*/');\n       END;\n0END DECOM;\n1GET_CONT: PROC;\n0   POS  = INDEX(LINE,'=');\n    POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),' ');\n    IF POS1 = 0\n       THEN POS1 = POS + 1;\n       ELSE POS1 = POS + POS1;\n0   /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0   POS = INDEX(SUBSTR(LINE,POS1,81-POS1),' ');\n    IF POS = 0\n       THEN POS2 = 81 - POS1;\n       ELSE POS2 = POS - 1;\n0   /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n0   QCONT = SUBSTR(LINE,POS1,POS2) || '        ';\n    ICONT = 1;\n0END GET_CONT;\n1GET_UP: PROC;\n0   POS  = INDEX(LINE,'=');\n    POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),' ');\n    IF POS1 = 0\n       THEN POS1 = POS + 1;\n       ELSE POS1 = POS + POS1;\n0   /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0   POS = INDEX(SUBSTR(LINE,POS1,81-POS1),' ');\n    IF POS = 0\n       THEN POS2 = 81 - POS1;\n       ELSE POS2 = POS - 1;\n0   /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n0   QUP = SUBSTR(LINE,POS1,POS2) || '        ';\n0END GET_UP;\n1GET_SEL: PROC;\n    L = 0;\n    CALL NEWLINE;\n    DO UNTIL (POS > 0);\n       POS = INDEX(LINE,',');\n       POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),'* ');\n       IF POS1 = 0\n          THEN POS1 = POS + 1;\n          ELSE POS1 = POS + POS1;\n0      /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0      POS = VERIFY(SUBSTR(LINE,POS1,81-POS1),VALID_CHARS);\n       IF POS = 0\n          THEN POS2 = 81 - POS1;\n          ELSE POS2 = POS - 1;\n0      /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n       L = L + 1;\n       SUBSTR(QSEL,8*L-7,POS2) = SUBSTR(LINE,POS1,POS2);\n0      CALL NEWLINE;\n       POS = INDEX(LINE,')');\n       END;\n0   ISEL = L;\n0END GET_SEL;\n1DSPLINE: PROC;\n    FIELD# = 0;\n    BUF1 = TRANSLATE(SCREEN(I),HIGH(FDCS),SUBSTR(FDCLIST,1,FDCS));\n    IF CAP\n       THEN BUF1 = TRANSLATE(BUF1,UPPER_CASE,LOWER_CASE);\n       ELSE;\n    IF \u00acNEW_AMPER\n       THEN DO;\n            POS = INDEX(BUF1,'&');\n            POS1 = 1;\n            DO WHILE (POS > 0);\n               POS = POS1 + POS - 1;\n               IF POS = 80\n                  THEN SUBSTR(BUF1,80,1) = ' ';\n                  ELSE IF SUBSTR(BUF1,POS+1,1) = '&'\n                          THEN DO;\n                               BUF1 = SUBSTR(BUF1,1,POS)        ||\n                                      SUBSTR(BUF1,POS+2,79-POS) ||\n                                      ' ';\n                               POS = POS + 1;\n                               END;\n                          ELSE DO;\n                               EOV = '0'B;\n                               DO POS1 = 1 TO MIN(8,80-POS) WHILE(\u00acEOV);\n                                  J = INDEX(VALID_CHARS,\n                                            SUBSTR(BUF1,POS+POS1,1));\n                                  SELECT;\n                                    WHEN (J = 0)               EOV='1'B;\n                                    WHEN ((J < 11)&(POS1 = 1)) EOV='1'B;\n                                    OTHERWISE;\n                                    END;\n                                  END;\n                               POS1 = POS1 - 1;\n                               BUF1 = SUBSTR(BUF1,1,POS-1) ||\n                                      REPEAT(' ',POS1-1)   ||\n                                      SUBSTR(BUF1,POS+POS1,81-POS-POS1);\n                               POS1 = POS1 + POS + 1;\n                               IF POS1 < 81\n                                  THEN IF SUBSTR(BUF1,POS1,1)='.'\n                                          THEN SUBSTR(BUF1,POS1,1)=' ';\n                                          ELSE;\n                               END;\n               POS1 = POS;\n               POS = INDEX(SUBSTR(BUF1,POS,81-POS),'&');\n               END;\n            END;\n       ELSE;\n    BUF2 = REPEAT(' ',79);\n    BUF3 = REPEAT(' ',119);\n    OVERPRINT = '0'B;\n    POS = INDEX(BUF1,HIGH(1));\n    IF POS = 1\n       THEN FDC# = -1;\n       ELSE FDC# = 0;\n    DO WHILE (POS < 80);\n       IF FDC# \u00ac= 0\n          THEN DO;\n               POS1 = INDEX(SUBSTR(BUF1,POS+1,81-POS),HIGH(1));\n               IF POS1 = 0\n                  THEN POS1 = 80 - POS;\n                  ELSE POS1 = POS1 - 1;\n               FDC#=INDEX(\n                       SUBSTR(FDCLIST,1,FDCS),\n                       SUBSTR(SCREEN(I),POS,1));\n               SUBSTR(BUF1,POS,1) = ' ';\n               POS = POS+1;\n               END;\n          ELSE DO;\n               POS1 = INDEX(BUF1,HIGH(1));\n               IF POS1 = 0\n                  THEN POS1 = 80;\n                  ELSE POS1 = POS1 - 1;\n               POS = 1;\n               END;\n       K = FDCTYPE(FDC#);\n       BLANK_FIELD =  (K = 0) |\n                     ((K = 1) & (VERIFY(SUBSTR(BUF1,POS,POS1),' ')=0))|\n                     ((K = 2) & (FDCPAD(FDC#) = ' '));\n       SELECT;\n         WHEN (BLANK_FIELD)\n                  IF \u00acXEROX\n                     THEN SUBSTR(BUF1,POS,POS1) = REPEAT(' ',POS1-1);\n                     ELSE DO;\n                          SUBSTR(BUF3,FIELD#*2+POS+1,1) = ' ';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(' ',POS1-1);\n                          END;\n         WHEN (FDCTYPE(FDC#) = 0)\n                  IF \u00acXEROX\n                     THEN SUBSTR(BUF1,POS,POS1) = REPEAT(' ',POS1-1);\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(' ',POS1-1);\n                          END;\n         WHEN (FDCTYPE(FDC#) = 1) DO;     /*  TEXT  */\n                  IF \u00acXEROX\n                     THEN IF FDCINT(FDC#) = 1\n                             THEN DO;\n                                  OVERPRINT = '1'B;\n                                  SUBSTR(BUF2,POS,POS1) =\n                                        SUBSTR(BUF1,POS,POS1);\n                                  END;\n                             ELSE;\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                SUBSTR(BUF1,POS,POS1);\n                          END;\n                  END;\n         WHEN (FDCTYPE(FDC#) = 2) DO; /* VARIABLE - PAD */\n                  IF \u00acXEROX\n                     THEN DO;\n                          SUBSTR(BUF1,POS,POS1) =\n                                 REPEAT(FDCPAD(FDC#),POS1-1);\n                          IF FDCINT(FDC#) = 1\n                             THEN DO;\n                                  SUBSTR(BUF2,POS,POS1) =\n                                        REPEAT(FDCPAD(FDC#),POS1-1);\n                                  OVERPRINT = '1'B;\n                                  END;\n                             ELSE;\n                          END;\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(FDCPAD(FDC#),POS1-1);\n                          END;\n                  END;\n         OTHERWISE;\n         END;\n       FDCTYPE(0) = FDCTYPE(FDC#);\n       FDCINT(0)  = FDCINT(FDC#);\n       FDCPAD(0)  = FDCPAD(FDC#);\n       POS = INDEX(BUF1,HIGH(1));\n       IF POS = 0\n          THEN POS = 81;\n          ELSE;\n       FDC# = -1;\n       END;\n    IF XEROX\n       THEN PUT FILE(LISTING) EDIT(BUF3) (COL(10),A(120));\n       ELSE PUT FILE(LISTING) EDIT(BUF1) (COL(10),A(80));\n    IF OVERPRINT & BOLD\n       THEN DO;\n            PUT SKIP(0) FILE(LISTING) EDIT(BUF2) (COL(10),A(80));\n            END;\n       ELSE;\n0END DSPLINE;\n1FOOTER: PROC;\n0   PUT FILE(LISTING) EDIT ('PANEL ID: '||TUTOR)\n                           (LINE(40),COL(13),A(18));\n0   PIC_2A = PAGES(1);\n    PUT FILE(LISTING) EDIT ('HIER: '||SUBSTR(H_POS,1,LEVEL*3-1))\n                           (COL(36),A);\n0   PUT SKIP(0) FILE(LISTING) EDIT ('PAGE: ',PAGE#)\n                           (COL(82),A(6),F(4));\n0END FOOTER;\n0END TUTPROC;\n1NEXTTUT: PROC;\n0   /*   START:    ROWID IS SET TO THE ROW-ID OF THE ROW FOR THIS PANEL\n                            IN TUTPTABL.\n\n         PROCESS:  RETRIEVE ROW WITH ROW-ID OF ROWID.\n                   FIGURE OUT WHAT TUTORIAL TO PRINT NEXT.\n\n         END:      TUTOR IS THE ID OF THE NEXT TUTORIAL.\n                   LEVEL IS SET TO THE POSITION OF ID TUTOR IN THE\n                            TUTORIAL HIERARCHY.\n     */\n0   PRINT_ME = '0'B;\n    DO WHILE (\u00acPRINT_ME & (LEVEL > 0));\n       ROWID = HRCHY(LEVEL);\n       CALL ISPLINK('TBTOP   ','TUTPTABL');\n       CALL ISPLINK('TBSKIP  ','TUTPTABL',' ','D1 ','D2 ', ROWID);\n       SELECT;\n         WHEN (ISEL > 0) DO;  /* PROCESS QSEL LIST   */\n              NSEL = NSEL + 1;\n              ICONT = 0;\n              CALL ISPLINK('TBPUT   ','TUTPTABL');\n              IF NSEL > ISEL\n                 THEN DO;    /* NO MORE ID'S */\n                      LEVEL = LEVEL - 1;\n                      END;\n                 ELSE DO;\n                      TUTOR = SUBSTR(QSEL,8*NSEL-7,8);\n                      LEVEL = LEVEL + 1;\n                      IF NSEL = 1\n                         THEN PAGES(LEVEL) = 1;\n                         ELSE PAGES(LEVEL) = PAGES(LEVEL) + 1;\n                      PRINT_ME = '1'B;\n                      END;\n              END;\n         WHEN (ICONT > 0) DO;   /* PROCESS QCONT ID    */\n              TUTOR = QCONT;\n              PAGES(LEVEL) = PAGES(LEVEL) + 1;\n              PRINT_ME = '1'B;\n              END;\n         OTHERWISE DO;\n              LEVEL = LEVEL - 1;\n              END;\n         END;\n       END;\n0END NEXTTUT;\n1SETUP: PROC;\n0   LVAR = 4;\n    CALL ISPLINK('VDEFINE ','(NSEL)    ', NSEL      ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ISEL)    ', ISEL      ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ICONT)   ', ICONT     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(IOVER)   ', IOVER     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(LEVEL)   ', LEVEL     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ROWID)   ', ROWID     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(TOTNUM)  ', TOTNUM    ,'FIXED', LVAR);\n0   LVAR = 8;\n    CALL ISPLINK('VDEFINE ','(TUTOR)   ', TUTOR     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(MEMBER)  ', MEMBER     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(ID)      ', DATAID    ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(QCONT)   ', QCONT     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(QUP)     ', QUP       ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(ZUSER)   ', SYSUID    ,'CHAR' , LVAR);\n0   LVAR = 60;\n    CALL ISPLINK('VDEFINE ','(HPOS)    ', H_POS     ,'CHAR' , LVAR);\n0   LVAR = 80;\n    CALL ISPLINK('VDEFINE ','(INVAR)   ', LINE      ,'CHAR' , LVAR);\n0   LVAR = 400;\n    CALL ISPLINK('VDEFINE ','(QSEL)    ', QSEL      ,'CHAR' , LVAR);\n0   NAMELIST = '(QSEL QUP QCONT NSEL ISEL ICONT IOVER)';\n    KEYLIST  = '(MEMBER)';\n    CALL ISPLINK('TBCREATE','TUTPTABL', KEYLIST , NAMELIST ,'NOWRITE');\n0   /*           SET FLAGS ET ALL           */\n0   NAMELIST = '(CAP TOC PAN XRX UDK TUTORTOP)';\n    CALL ISPLINK('VGET    ', NAMELIST ,'PROFILE ');\n    NAMELIST = '(ID)';\n    CALL ISPLINK('VGET    ', NAMELIST ,'SHARED  ');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(CAP)', LVAR , BUF_3 ,'MOVE');\n    CAP = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(TOC)', LVAR , BUF_3 ,'MOVE');\n    TOC = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(PAN)', LVAR , BUF_3 ,'MOVE');\n    PAN = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(XRX)', LVAR , BUF_3 ,'MOVE');\n    XEROX = (BUF_3 = 'YES');\n    LVAR = 1;\n0   CALL ISPLINK('VCOPY   ','(UDK)', LVAR , UDK ,'MOVE');\n0   TOTNUM = 0;\n0   IF XEROX\n       THEN CALL PANXEROX;\n       ELSE;\n0   PUT PAGE FILE(LISTING);\n    CALL ISPLINK('VGET    ','(ZUSER)','SHARED  ');\n    PUT SKIP FILE(LISTING) EDIT(' *** TUTORIAL PRINT OUTPUT FOR USER '||\n                                SYSUID || ' ***')\n                               (COL(3),A);\n0   VALID_CHARS = '0123456789' || UPPER_CASE || LOWER_CASE || '#@$';\n1PANXEROX: PROC;\n0   PUT FILE(LISTING) EDIT('=UDK=' || UDK)          (COL(1),A(6));\n    PUT FILE(LISTING) EDIT(UDK || '+X ')            (COL(1),A(4));\n    PUT FILE(LISTING) EDIT('=UDK=' || UDK)          (COL(1),A(6));\n    PUT FILE(LISTING) EDIT(UDK || 'c1          ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '+1Titan10B-L')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '+2Titan10-L ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || 'm510,5,5,5,650') (COL(1),A(15));\n    PUT FILE(LISTING) EDIT(UDK || '+P          ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '1           ')   (COL(1),A(13));\n0   PUT FILE(CTABLE) EDIT('=UDK=' || UDK)         (COL(1),A(6));\n    PUT FILE(CTABLE) EDIT(UDK || '+X ')           (COL(1),A(4));\n    PUT FILE(CTABLE) EDIT('=UDK=' || UDK)         (COL(1),A(6));\n    PUT FILE(CTABLE) EDIT(UDK || 'c1          ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '+1Titan10B-L')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '+2Titan10-L ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || 'm510,5,5,5,650') (COL(1),A(15));\n    PUT FILE(CTABLE) EDIT(UDK || '+P          ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '1           ')  (COL(1),A(13));\n0END PANXEROX;\n0END SETUP;\n0END TUTPRNT;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PFK0INIT": {"ttr": 9993, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PFK0INIT TITLE ' INITALIZE A SET OF PFKEYS'\nPFK0INIT PROC  LINKAGE=(OS,CSECT),BASE=12\n         SPACE\n         ISPF  LOAD\n         SPACE\n         MVC   VCOPYLEN,=F'4'\n         VCOPY '(ZAPPLID)',VCOPYLEN,ZAPPLID,MOVE,MF=E\n         SPACE\n         CLC   ZAPPLID,=CL4'ISR'\n         BNE   PROCESS\n         VREPLACE '(UMSG1 LMSG1)',VREPLEN1,UMSG1\n         SPACE\nSETERROR DS    0H\n         SETMSG MSG='DTSM001'\n         SPACE\n         LA    11,12\n         B     EXITPGM\n         SPACE\nPROCESS  DS    0H\n         TBSTATS 'ISRPROF',STATUS2='STATUS'\n         SPACE\n         MVC   VCOPYLEN,=F'1'\n         VCOPY '(STATUS)',VCOPYLEN,STATUS,MOVE,MF=E\n         SPACE\n         CLI   STATUS,C'1'\n         BNE   SETKEYS\n         SPACE\n         VREPLACE '(UMSG1 LMSG1)',VREPLEN2,UMSG2\n         B     SETERROR\n         SPACE\nSETKEYS  DS    0H\n         XR    11,11\n         SPACE\n         TBTOP TABLE\n         SPACE\n         TBSKIP TABLE\n         SPACE\n         VPUT  '(ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ZPF07 ZPF08 ZPF09 *\n               ZPF10 ZPF11 ZPF12 ZPF12 ZPF12 ZPF13 ZPF14 ZPF15 ZPF16 ZP*\n               F17 ZPF18 ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24)',PROFILE\n         SPACE\nEXITPGM  DS    0H\n         ISPF  DELETE\n         SPACE\n         CORP  RC=(11)\n         EJECT\nTABLE    DC    CL8'ISRPROF'\nLIBRARY  DC    CL8'ISPPROF'\nUMSG1    DC    C'INVALID APPLICATION ID'\nUMSG1LEN EQU   *-UMSG1\nLMSG1    DC    C'THIS COMMAND MAY NOT BE ISSUED UNDER THE \"ISR\" APPLICA*\n               TION'\nLMSG1LEN EQU   *-LMSG1\nUMSG2    DC    C' '\nUMSG2LEN EQU   *-UMSG2\nLMSG2    DC    C'YOUR ISPF SESSION WAS NOT STARTED WITH THE PDF UTILITY*\n               - UNABLE TO SET PFKEYS'\nLMSG2LEN EQU   *-LMSG2\nVREPLEN1 DC    A(UMSG1LEN,LMSG1LEN)\nVREPLEN2 DC    A(UMSG2LEN,LMSG2LEN)\n         SPACE 3\nVCOPYLEN DS    F\nZAPPLID  DS    CL4\nSTATUS   DS    CL1\n         ISPF  PARMS\n         SPACE\n         FINAL ,\n         END   PFK0INIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RET0TABL": {"ttr": 9995, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "RET0TABL CSECT\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'RET0TABL '             CSECT NAME\n         DC    C'05/14/85 '             DATE WRITTEN\n         DC    C'VERSION 1.0 '          VERSION NUMBER\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    2,1                      SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING RET0TABL,12              PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\nRETURN   DDD   SPACE=(TRK,(1,1)),DISP=(NEW,DELETE),TYPE=TEMP\n         SPACE 3\n         L     2,0(2)\n         MVC   0(8,2),DDDNAME\nDDDNAME@ FREE  ,\n         SPACE 3\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         SR    15,15                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         EJECT\n         DDDD  CODE\n         SPACE\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         DDDD  STORAGE\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nRET0TABL CSECT ,                        RESUME CSECT\n         END   RET0TABL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRM0LOCK": {"ttr": 10241, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS NUMBER INTERRUPT;\n SECURE: PROCEDURE OPTIONS(MAIN);\n          DCL ISPLINK EXTERNAL ENTRY OPTIONS(ASM INTER RETCODE);\n          DCL PLIRETV BUILTIN;\n          DCL LENGTH  BUILTIN;\n          DCL KEY CHAR(8) INIT ((8)' ');\n          DCL NLOCK CHAR(1) INIT ('N');\n          DCL FIRST CHAR(1) INIT ('Y');\n          DCL YH9KEY CHAR(8) INIT ((8)'K');\n          DCL TERMKEY CHAR(8) INIT ((8)'T');\n /*                                                                 */\n /*                                                                 */\n /*                                                                 */\n          DCL LKEY FIXED BIN(31,0) INIT(8);\n          DCL ZKEY FIXED BIN(31,0) INIT(1);\n          DCL RC FIXED BIN(31,0) INIT(0);\n /*                                                                 */\n /*                                                                 */\n /*                                                                 */\n ON ATTENTION BEGIN;\n              KEY = '* ATTN *';\n              END;\n CALL ISPLINK('VDEFINE','(KEY)',KEY,'CHAR ',LKEY);\n CALL ISPLINK('VDEFINE','(TERMKEY)',TERMKEY,'CHAR ',LKEY);\n CALL ISPLINK('VDEFINE','(YH9KEY)',YH9KEY,'CHAR ',LKEY);\n CALL ISPLINK('VDEFINE','(NLOCK)',NLOCK,'CHAR ',ZKEY);\n CALL ISPLINK('VGET','(YH9KEY)','PROFILE');\n RC = PLIRETV;\n /*   PUT DATA;                                                     */\n UNCODE: TERMKEY = SUBSTR(YH9KEY,5,1) ||\n                   SUBSTR(YH9KEY,1,1) ||\n                   SUBSTR(YH9KEY,8,1) ||\n                   SUBSTR(YH9KEY,6,1) ||\n                   SUBSTR(YH9KEY,3,1) ||\n                   SUBSTR(YH9KEY,7,1) ||\n                   SUBSTR(YH9KEY,4,1) ||\n                   SUBSTR(YH9KEY,2,1);\n /*   PUT DATA;                                                     */\n USER: IF TERMKEY = '        ' THEN DO;\n         CALL  ISPLINK('CONTROL','NOCMD');\n         CALL ISPLINK('DISPLAY','TRMDLCK2 ','TRMM102 ');\n         IF KEY = '        ' THEN GO TO FINISH;\n         TERMKEY = KEY;\n ENCODE: YH9KEY = SUBSTR(TERMKEY,2,1) ||\n                  SUBSTR(TERMKEY,8,1) ||\n                  SUBSTR(TERMKEY,5,1) ||\n                  SUBSTR(TERMKEY,7,1) ||\n                  SUBSTR(TERMKEY,1,1) ||\n                  SUBSTR(TERMKEY,4,1) ||\n                  SUBSTR(TERMKEY,6,1) ||\n                  SUBSTR(TERMKEY,3,1);\n         CALL ISPLINK('VPUT','(YH9KEY)','PROFILE');\n       END;\n LOOP:\n       KEY = '        ';\n       IF FIRST = 'Y' THEN DO;\n          FIRST = 'N';\n         CALL  ISPLINK('CONTROL','NOCMD');\n          CALL ISPLINK('DISPLAY','TRMDLCK1 ');\n        END;\n         ELSE DO;\n         CALL  ISPLINK('CONTROL','NOCMD');\n            CALL ISPLINK('DISPLAY','TRMDLCK1 ','TRMM100 ');\n            END;\n /*    PUT DATA;                                                    */\n /*                                                                 */\n /*                                                                 */\n /*                                                                 */\n PROCESS:   IF NLOCK = 'Y' & TERMKEY = KEY THEN DO;\n             CALL  ISPLINK('CONTROL','NOCMD');\n             CALL ISPLINK('DISPLAY','TRMDLCK2 ','TRMM101 ');\n             TERMKEY = KEY;\n             NLOCK = 'N';\n             FIRST = 'Y';\n             KEY = '        ';\n /*          PUT DATA;                                              */\n            END;\n          IF KEY = TERMKEY THEN GO TO FINISH;\n          GO TO LOOP;\n FINISH: RC = PLIRETV;\n         YH9KEY = SUBSTR(TERMKEY,2,1) ||\n                  SUBSTR(TERMKEY,8,1) ||\n                  SUBSTR(TERMKEY,5,1) ||\n                  SUBSTR(TERMKEY,7,1) ||\n                  SUBSTR(TERMKEY,1,1) ||\n                  SUBSTR(TERMKEY,4,1) ||\n                  SUBSTR(TERMKEY,6,1) ||\n                  SUBSTR(TERMKEY,3,1);\n         CALL ISPLINK('VPUT','(YH9KEY)','PROFILE');\n /*      PUT DATA;                                                  */\n END SECURE;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSO0": {"ttr": 10244, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSO0     TITLE ' - ISPF/PDF REVISED TSO OPTION'\n***********************************************************************\n*   BOB ZIMMERMAN\n*   CNA INSURANCE\n*   (312) 822-5719\n*   LAST MODIFIED 8503\n***********************************************************************\n*   THIS PROGRAM REPLACES THE CURRENT OPTION 6 DELIVERED WITH THE ISPF\n*   FOR  MVS SYSTEMS.\n*\n*   THE SIGNIFICANT MODIFICATIONS TO THE IBM SCREEN ARE:\n*      1)  THIS OPTION WILL REMEMBER THE LAST TSO COMMAND TYPED\n*      2)  ALLOWS TWO DATA ENTRY LINES; ONE FOR ISPF AND ONE FOR TSO\n*      3)  ALLOWS STACKING OF COMMANDS ON EITHER DATA ENTRY LINE\n*      4)  THE 'CANCEL' PRIMARY COMMAND WILL NOT SAVE THE LAST TSO CMD\n*          THE NEXT TO THE LAST COMMAND WILL BE SAVED\n*      5)  WHEN STACKING TSO COMMANDS, IF A COMMAND ENDS WITH A\n*          NON-ZERO RETURN CODE, THE USER WILL BE NOTIFIED AND\n*          PROMPTED (DOES HE WANT TO CONTINUE OR NOT)\n***********************************************************************\n*    VERSION 2 MODIFICATIONS:                                         *\n*        THIS FUNCTION, WHEN STARTING, WILL CHECK TO SEE IF A         *\n*        VARIABLE IN THE SHARED POOL CALLED TSOSCMD, CONTAINS ANY     *\n*        VALID DATA. IF IT DOES, IT WILL INVOKE THAT AS THE TSO       *\n*        COMMAND IMMEDIATELY.                                         *\n*        THIS IS DESIGNED TO MAKE USE OF THE TSOCMD COMMAND ENCLOSED  *\n*        WITH THIS TAPE.                                              *\n*                                                                     *\n*    VERSION 2.1 AND 2.2 MODIFICATIONS:                               *\n*        CLEANED UP PROBLEM OF SOME TSO COMMAND ERRORS WERE NOT       *\n*        HIGHLIGHTED TO THE USER. THE CURSOR WOULD JUST REMAIN ON     *\n*        THE TSO COMMAND LINE. NOW ALL ERRORS ARE CORRECTLY           *\n*        DISPLAYED TO THE USER.                                       *\n***********************************************************************\n         EJECT\nTSO0     CSECT\n         ISPF  SET,LEVEL=1\n***********************************************************************\n*        STANDARD ENTRY CODE FOR A RE-ENTRANT PROGRAM\n*                 REGISTER 12 IS ONLY BASE REGISTER\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'TSO0 '                 CSECT NAME\n         DC    C'02/21/85 '             DATE WRITTEN\n         DC    C'VERSION 2.2 '          VERSION\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING TSO0,12                  PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n***********************************************************************\n*        INITALIZATION OF THE PROGRAM\n*              1.  LOAD THE ISPLINK MODULE\n*              2.  VDEFINE ALL VARIABLES\n***********************************************************************\n         ISPF  LOAD                     LOAD ISPLINK\n         SPACE\n         CONTROL ERRORS,                SET ISPF ERROR MODE            *\n               RETURN                   IGNORE ANY RC OF 12 OR GREATER\n         SPACE\n         VDEFINE '(UMSG1)',             VARIABLE NAME                  *\n               UMSG1,                   WORKING STORAGE ADDRESS        *\n               CHAR,                    VARIABLE TYPE                  *\n               24,                      LENGTH OF VARIABLE             *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         VDEFINE '(LMSG1)',             VARIABLE NAME                  *\n               LMSG1,                   WORKING STORAGE ADDRESS        *\n               CHAR,                    VARIABLE TYPE                  *\n               78,                      LENGTH OF VARIABLE             *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         VDEFINE '(CMD1 CMD2 CMD3 CMD4 CMD5 CMD6 CMD7 CMD8 CMD9 CMD10 C*\n               MD11 CMD12 CMD13 CMD14 CMD15 CMD16 CMD17 CMD18 CMD19 CMD*\n               20 CMD21 CMD22 CMD23 CMD24 CMD25 CMD26)',               *\n               TSOCMD,                  WORKING STORAGE ADDRESS        *\n               CHAR,                    VARIABLE TYPE                  *\n               255,                     LENGTH OF VARIABLE             *\n               MF=E                     EXECUTE FORM OF MACRO\n         TITLE 'CHECK FOR TSOSCMD COMMAND '\n         VGET  '(TSOSCMD)',SHARED       IS VARIABLE IN SHARED POOL\n         SPACE\n         LTR   15,15                    CHECK RETURN CODE\n         BNZ   PROCESS                  IF NOT KEEP GOING\n         VCOPY '(TSOSCMD)',VCOPYLEN,TSOSCMD,LOCATE,MF=E\n         SPACE\n         L     2,VCOPYLEN               CHECK LENGTH OF DATA\n         LTR   2,2                      WAS DATA RECEIVED\n         BZ    PROCESS                  IF NONE KEEP GOING\n         BCTR  2,0                      BUMP DOWN FOR MVC\n         C     2,=F'254'                WAS DATA GREATER THAN 255\n         BH    PROCESS                  IF SO BYPASS\n         L     3,TSOSCMD                GET ADDRESS OF DATA\n         CLC   0(0,3),SPACES            WAS SPACES FOUND\n         EX    2,*-6                    COMPARE THE DATA\n         BE    PROCESS                  IF SO BYPASS\n         VREPLACE '(TSOTEXT)',VCOPYLEN,0(3),MF=E\n         SPACE\n         VREPLACE '(TSOSCMD)',1,SPACES\n         SPACE\n         VPUT  '(TSOSCMD)',SHARED\n         SPACE\n         CONTROL DISPLAY,LOCK\n         SPACE\n         TITLE 'DISPLAY PANEL AND ISSUE TSO COMMANDS'\n***********************************************************************\n*        DISPLAY PANEL TSOD\n*        ISSUE EACH TSO COMMAND VIA ISPEXEC SELECT CMD\n*        IF RETURN CODE NOT ZERO - PROMPT USER FOR WHAT TO DO\n***********************************************************************\nPROCESS  DS    0H\n         DISPLAY 'TSOD',                PANEL NAME FOR DISPLAY IS TSOD *\n               MESSAGE,                 MESSAGE FOR DISPLAY AT LABEL   *\n               CURSOR,                  CURSOR FOR DISPLAY AT CURSOR   *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         LTR   15,15                    WAS END COMMAND ENTERED\n         BNZ   EXITPGM                  EXIT PROGRAM\n         SPACE\n         MVC   MESSAGE,SPACES           REINIT THE MESSAGE FIELD\n         MVC   CURSOR,SPACES            REINIT THE CURSOR FIELD\n         SPACE 3\n***********************************************************************\n*        REGISTER 3 WILL BE USED AS POINTER INTO TSO COMMAND TABLE\n*        REGISTER 4 WILL BE USED TO COUNT THE NUMBER OF TABLE ENTRIES\n***********************************************************************\n         LA    3,TSOCMD                 POINT TO FIRST TSO COMMAND\n         LA    4,26                     COUNT OF TSO COMMANDS\n         SR    11,11                    SAVE RETURN CODE OF TSO CMDS\n         SPACE\nTSOLOOP  DS    0H\n         CLC   0(255,3),SPACES          IS CURRENT COMMAND = SPACES\n         BE    NEXTCMD                  BRANCH AROUND CMD CODE\n         SPACE\n         LTR   11,11                    CHECK RC FROM PREVIOUS CMD\n         BZ    ISSUECMD                 IF ZERO - CONTINUE\n         MVC   MSG(TPUTMSGL),TPUTMSG    INIT MESSAGE AREA\n         CVD   11,DBLWORD               CVD THE RETURN CODE\n         UNPK  MSG+TPUTMSGL(4),DBLWORD  UNPACK RETURN CODE\n         OI    MSG+TPUTMSGL+3,X'F0'     UNSIGN THE FIELD\n         TPUT  =C' ',1                  SPACE LINE\n         SPACE\n         TPUT  MSG,TPUTMSGL+4           WRITE ERROR MESSAGE\n         SPACE\nREISSUE  TPUTE 'ENTER \"N\" TO STOP -',PARMS=ASIS\n         SPACE\n         MVI   MSG,C' '                 INIT MSG TO SPACES\n         TGET  MSG,75,,WAIT             GET ANSWER\n         OI    MSG,X'40'                SET TO UPPERCASE\n         CLI   MSG,C'N'                 WAS N ENTERED\n         BE    PROCESS                  BRACH BACK TO LOOP\n         CLI   MSG,C' '                 IS IT A SPACE\n         BNE   REISSUE                  IF NOT - BAD RESPONSE\n         TPUT  =C' ',1                  SPACE LINE\n         SPACE\nISSUECMD SELECT 255,0(3),MF=E           ISSUE ISPEXEC SELECT CMD\n         SPACE\n         LR    11,15                    SAVE RETURN CODE\n         C     11,=F'12'                WAS A BAD RETURN CODE ISSUED\n         BL    NEXTCMD                  IF NOT - KEEP GOING\n         VCOPY '(ZERRLM)',VCOPYLEN,UMSG1,LOCATE,MF=E\n         SPACE\n         CONTROL DISPLAY,SM,MF=E        SET ISPF LINE MODE ON\n         SPACE\n         L     1,UMSG1                  GET ADDRESS OF MESSAGE\n         L     0,VCOPYLEN               GET ADDRESS OF MESSAGE\n         TPUT  (1),(0)                  WRITE MESSAGE\n         SPACE\n         VREPLACE '(ZERRLM)',1,SPACES,MF=E\n         SPACE\nNEXTCMD  DS    0H\n         LA    3,255(3)                 BUMP TO NEXT TSO CMD\n         BCT   4,TSOLOOP                CHECK NUMBER OF TSO CMDS\n         B     PROCESS                  REDISPLAY PANEL\n         TITLE ' - EXITPGM - SUBROUTINE TO EXIT PROGRAM'\n***********************************************************************\n*        EXIT PROGRAM ROUTINE WILL\n*              1.  DELETE ALL VDEFINE VARIABLES\n*              2.  DELETE ISPLINK\n*              3.  STANDARD EXIT CODE\n***********************************************************************\nEXITPGM  VRESET MF=E                    DELETE FUNCTION POOL VARIABLES\n         SPACE\n         ISPF  DELETE                   DELETE ISPLINK ADDRESS\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         LR    10,15                    SAVE RETURN CODE\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,10                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - WORKING STORAGE'\nSPACES   DC    255C' '                  SPACE LITERAL\nTPUTMSG  DC    C'PREVIOUS TSO COMMAND ENDED WITH CONDITION CODE '\nTPUTMSGL EQU   *-TPUTMSG\n         SPACE\n***********************************************************************\n*        WORKSTOR IS THE DSECT TO MAP GETMAIN AREA\n*        REGISTER 13 IS USED AS WORKSTOR BASE\n***********************************************************************\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         SPACE\n         ISPF  PARMS                    ISPF WORKING STORAGE\n         SPACE\nDBLWORD  DS    D\nMESSAGE  DS    CL8                      MESSAGE FIELD FOR DISPLAY\nCURSOR   DS    CL8                      CURSOR FIELD FOR DISPLAY\nUMSG1    DS    CL24                     SHORT ISPF ERROR MESSAGE\nLMSG1    DS    CL78                     LONG ISPF ERROR MESSAGE\nMSG      DS    CL75                     TPUT/TGET MESSAGE AREA\nVCOPYLEN DS    F                        LENGTH FIELD FOR VCOPY\nTSOSCMD  DS    F                        ADDRESS OF COMMAND\nTSOCMD   DS    26CL255                  TSO COMMANDS FROM DISPLAY\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nTSO0     CSECT ,                        RESUME CSECT\n         SPACE\n         END   TSO0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSO0CMD": {"ttr": 10249, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TSO0CMD  TITLE ' - INVOKE OPTION 6 FROM THE PRIMARY OPTION PANEL'\n***********************************************************************\n*    BOB ZIMMERMAN                                                    *\n*    CNA INSURANCE                                                    *\n*    (312) 822-5719                                                   *\n*    LAST MODIFIED 8504                                               *\n***********************************************************************\n*   THIS COMMAND SUPPORTS THE TSOCMD COMMAND TABLE COMMAND.\n*\n*   THIS COMMAND ALLOWS A USER TO TYPE TSOCMD FROM ANY SCREEN AND BE\n*   PRESENTED THE SAME FUNCTION AS IF HE TYPED OPTION 6 FROM THE PDF\n*   PRIMARY OPTION MENU. WHEN THE USER EXITS THE FUNCTION, HE RETURNS\n*   TO THE SAME FUNCTION AS WHEN HE TYPED THE TSOCMD COMMAND.\n***********************************************************************\n* VERSION 2 MODIFICATIONS:                                            *\n*    THIS PROGRAM WILL NOW ACCEPT PARMS. TSOCMD CAN BE INVOKED WITH   *\n*    THE PASSING OF PARMS. FOR EXAMPLE:                               *\n*                                                                     *\n*    TSOCMD < A TSO COMMAND >                                         *\n*                                                                     *\n*    THE TSO COMMAND WILL BE INSERTED ON THE TSO COMMAND LINE OF      *\n*    OPTION 6 AND WILL BE INVOKED FOR YOU.                            *\n*                                                                     *\n* ***NOTE THIS REQUIRES THE NEW TSO COMMAND ON THIS TAPE BE           *\n*    INSTALLED.                                                       *\n***********************************************************************\n         SPACE\nTSO0CMD  CSECT\n         ISPF  SET,LEVEL=1\n***********************************************************************\n*        STANDARD ENTRY CODE\n***********************************************************************\n         USING *,15                     TEMPORARY BASE REGISTER\n         B     PASSLIT                  BRANCH AROUND LITERALS\n         DC    C'TSO0CMD '              CSECT NAME\n         DC    C'02/21/85 '             DATE WRITTEN\n         DC    C'VERSION 2.0 '          VERSION\n         DC    C'&SYSDATE '             DATE ASSEMBLED\n         DC    C'&SYSTIME '             TIME ASSEMBLED\nPASSLIT  DS    0H\n         STM   14,12,12(13)             SAVE CALLERS REGISTERS\n         LR    11,1                     SAVE PARAMETERS PASSED\n         LR    12,15                    REGISTER 12 IS BASE REGISTER\n         DROP  15                       END TEMPORARY ADDRESSING\n         USING TSO0CMD,12               PERMANENT ADDRESSING\n         SPACE\n         GETMAIN R,LV=WSLEN,SP=0        GET WORKING STORAGE AREA\n         SPACE\n         ST    1,8(13)                  SET FORWARD CHAIN IN SAVEAREA\n         ST    13,4(1)                  SET BACKWARD CHAIN\n         LM    13,1,8(13)               RESTORE CLOBBERED REGISTERS\n         USING WORKSTOR,13              SETUP WORKING STORAGE\n         SPACE 3\n***********************************************************************\n* INITALIZATION INCLUDES:\n*        LOAD ISPLINK\n*        SET ISPF ERROR MODE\n*        SET ISPEXEC CONTROL NONDISPL END MODE\n*        SET ZCMD OPTION TO 6\n***********************************************************************\n         ISPF  LOAD                     LOAD ISPLINK\n         SPACE\n         CONTROL ERRORS,                SET ISPF ERROR MODE            *\n               CANCEL,                  CANCEL ANY RC OF 12 OR GREATER *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         CONTROL NONDISPL,              DONT DISPLAY NEXT SCREEN       *\n               END,                     SIMULATE THE END COMMAND       *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         VREPLACE '(ZCMD)',             ZCMD IN FUNCTION POOL          *\n               1,                       1 BYTE LONG                    *\n               =C'6',                   SET TO VALUE OF 6              *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE 3\n***********************************************************************\n* PROCESSING INCLUDES:\n*        DISPLAY PRIMARY OPTION MENU ISR@PRIM\n*        THIS PANEL WILL NOT BE DISPLAYED BECAUSE OF PREVIOUS NONDISPL\n*        VCOPY THE ZSEL VALUE SET IN PROC SECTION OF ISR@PRIM\n*        INVOKE THE COMMAND COPIED\n***********************************************************************\n         DISPLAY 'ISR@PRIM',            DISPLAY PANEL ISR@PRIM         *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         VCOPY '(ZSEL)',                COPY ZSEL VARIABLE             *\n               VCOPYLEN,                LENGTH OF COMMAND WILL BE SET  *\n               ZSEL,                    ADDRESS OF COMMAND WILL BE SET *\n               LOCATE,                  VCOPY LOCATE MODE - NOT MOVE   *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE\n         L     2,ZSEL                   GET ADDRESS OF COMMAND\n         L     11,0(11)                 GET ANY PARMS PASSED\n         LH    10,0(11)                 GET LENGTH OF PARMS\n         LTR   10,10                    IF NO PARMS\n         BZ    SELIT                    BYPASS THIS\n         C     10,=F'255'               TOO MANY PARMS?\n         BH    SELIT                    IF SO BYPASS\n         ST    10,VREPLEN               SAVE LENGTH\n         VREPLACE '(TSOSCMD)',VREPLEN,2(11),MF=E\n         SPACE\n         VPUT  '(TSOSCMD)',SHARED\n         SPACE\nSELIT    SELECT VCOPYLEN,               ISPEXEC SELECT THE COMMAND     *\n               (2),                     POINTED TO BY REGISTER 2       *\n               MF=E                     EXECUTE FORM OF MACRO\n         SPACE 3\n         LR    11,15                    SAVE RETURN CODE\n***********************************************************************\n* EXIT CODE INCLUDES:\n*        DELETE ISPF VARIABLES\n*        DELETE ISPLINK\n*        STANDARD EXIT CODE\n***********************************************************************\n         VRESET MF=E                    DELETE FUNCTION POOL VARIABLES\n         SPACE\n         ISPF  DELETE                   DELETE ISPLINK MODULE\n         SPACE\n         LR    1,13                     GET ADDRESS FOR FREEMAIN\n         L     13,WORKSTOR+4            GET CALLERS SAVE AREA\n         FREEMAIN R,A=(1),LV=WSLEN,SP=0 FREE WORKING STORAGE\n         SPACE\n         LR    15,11                    GET RETURN CODE\n         L     14,12(,13)               RESTORE RETURN ADDRESS\n         LM    0,12,20(13)              RESTORE REMAINING REGISTERS\n         MVI   12(13),X'FF'             FLAG AS RETURNED FOR SNAP SVC\n         BR    14                       RETURN TO CALLER\n         TITLE ' - WORKING STORAGE'\nWORKSTOR DSECT                          WORKING STORAGE DSECT\nSAVEAREA DS    18F                      PROGRAM SAVE AREA\n         DS    0D                       DOUBLE WORD ALIGN\n         SPACE\nVCOPYLEN DS    F                        LENGTH OF OPTION 6 COMMAND\nVREPLEN  DS    F                        LENGTH OF OPTION 6 COMMAND\nZSEL     DS    A                        ADDRESS OF OPTION 6 COMMAND\n         ISPF  PARMS                    ISPF WORKING STORAGE\n         DS    0D\nWSLEN    EQU   *-WORKSTOR               LENGTH OF WORKING STORAGE\nTSO0CMD  CSECT ,                        RESUME CSECT\n         END   TSO0CMD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TUTPRNT1": {"ttr": 10252, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS;\n /*\n   TITLE      -   TUTPRNT1\n\n   FUNCTION   -   THIS PROGRAM DISPLAYS THE TUTORIAL PRINT OPTION PANEL\n\n   SPECIFIER  -   CHRIS GERKEN\n                  EXXON COMPANY, USA (EDPC)\n\n   DEVELOPER  -   CHRIS GERKEN\n\n   DATE       -   OCTOBER 10, 1984\n\n   LANGUAGE   -   PLI\n\n   PANVALET   -\n\n   ENTRY      -   PLISTART\n\n   LINKAGE    -   THIS PROGRAM IS SELECTED FROM AN SPF SELECT MENU\n\n   EXT. REF.  -   ISPLINK\n\n   DATA SETS  -   PDS'S CONTAINING ISPF PANEL DEFINITIONS\n\n   SPF TABLES -   NONE\n\n   SPF PANELS -   TUTPE010\n\n   SPF MSGS   -   TUTP001\n\n   UPDATES    -   NONE\n\n */\n1TUTPRNT: PROC OPTIONS(MAIN);\n0   DCL ISPLINK       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        ISPEXEC       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        PLIRETV       BUILTIN,\n        RETCODD       FIXED BIN(31),\n        RETCODE       FIXED BIN(31),\n        LVAR          FIXED BIN(31);\n0   DCL OPENED        BIT(1),\n        LMINITED      BIT(1),\n        EXIT          BIT(1),\n        MEMBER        CHAR(8),\n        TABLE         CHAR(8),\n        MSGID         CHAR(8),\n        FIELD         CHAR(8),\n        DATAID        CHAR(8),\n        TUTORTOP      CHAR(8),\n        DSN           CHAR(46),\n        ZENVIR        CHAR(32),\n        NAMELIST      CHAR(100),\n        BUFFER        CHAR(300),\n        SUBSTR        BUILTIN;\n0   DCL 1 LMINIT_BUF,\n          2 COMMAND   CHAR(7)    INIT('LMINIT '),\n          2 DATAID    CHAR(11)   INIT('DATAID(ID) '),\n          2 PROJECT   CHAR(15)   INIT('               '),\n          2 GROUP1    CHAR(14)   INIT('              '),\n          2 GROUP2    CHAR(14)   INIT('              '),\n          2 GROUP3    CHAR(14)   INIT('              '),\n          2 GROUP4    CHAR(14)   INIT('              '),\n          2 TYPE      CHAR(12)   INIT('            '),\n          2 DSNAME    CHAR(14)   INIT('              '),\n          2 DDNAME    CHAR(1)    INIT(' '),\n          2 SERIAL    CHAR(1)    INIT(' '),\n          2 ENQ       CHAR(9)    INIT('ENQ(SHR) ');\n1   CALL ISPLINK('CONTROL ','ERRORS  ','RETURN  ');\n0   LVAR = 8;\n    CALL ISPLINK('VDEFINE ','(ZERRMSG) ', MSGID     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(MEMBER)  ', MEMBER    ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(ID)      ', DATAID    ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(TUTORTOP)', TUTORTOP  ,'CHAR' , LVAR);\n0   LVAR = 32;\n    CALL ISPLINK('VDEFINE ','(ZENVIR)  ', ZENVIR    ,'CHAR' , LVAR);\n0   LVAR = 46;\n    CALL ISPLINK('VDEFINE ','(DSN)     ', DSN       ,'CHAR' , LVAR);\n0   CALL GET_OPTIONS;\n    IF \u00acEXIT\n       THEN DO;\n            LVAR = 14;\n            BUFFER = 'CMD(%TUTPRINT)';\n            CALL ISPLINK('SELECT  ', LVAR , BUFFER);\n            END;\n       ELSE;\n0   CALL WRAPUP;\n1GET_OPTIONS: PROC;\n0   /*   WHAT ENVIRONMENT ARE WE RUNNING UNDER?                */\n0   CALL ISPLINK('VGET    ','(ZENVIR)  ','SHARED  ');\n    RETCODE = PLIRETV;\n    IF RETCODE = 0\n       THEN DO;\n0           /* GET NAME(S) OF SOURCE DATA SET(S)         */\n0           CALL ISPLINK('DISPLAY ','TUTPE010');\n            RETCODE = PLIRETV;\n            END;\n       ELSE DO;\n            CALL ISPLINK('SETMSG  ','TUTP017 ');\n            RETCODE = 8;\n            END;\n    RETCODD = 8;\n    LMINITED = '0'B;\n    DO WHILE ((RETCODE = 0) & (RETCODD > 0));\n       CALL LMINIT;\n       IF RETCODD > 0\n          THEN DO;\n               CALL ISPLINK('DISPLAY ','        ', MSGID , FIELD);\n               RETCODE = PLIRETV;\n               END;\n          ELSE;\n       END;\n0   IF LMINITED\n       THEN DO;\n            LVAR = 45;\n            BUFFER = 'LMOPEN         DATAID(&ID)    OPTION(INPUT)  ';\n            CALL ISPEXEC(LVAR , BUFFER);\n            OPENED = '1'B;\n            CALL ISPLINK('VPUT   ','(REMOT)' ,'SHARED  ');\n            END;\n       ELSE OPENED = '0'B;\n0   EXIT = \u00acLMINITED | \u00acOPENED;\n1LMINIT: PROC;\n0   IF SUBSTR(DSN,1,1) = ' '\n       THEN DO;\n0           LMINIT_BUF.PROJECT = 'PROJECT(&PRJ1) ';\n0           LMINIT_BUF.GROUP1 = 'GROUP1(&LIB1) ';\n0           LVAR = 8;\n            CALL ISPLINK('VCOPY   ','(LIB2)', LVAR , DSN ,'MOVE');\n            IF LVAR > 0\n               THEN LMINIT_BUF.GROUP2 = 'GROUP2(&LIB2) ';\n               ELSE;\n0           LVAR = 8;\n            CALL ISPLINK('VCOPY   ','(LIB3)', LVAR , DSN ,'MOVE');\n            IF LVAR > 0\n               THEN LMINIT_BUF.GROUP3 = 'GROUP3(&LIB3) ';\n               ELSE;\n0           LVAR = 8;\n            CALL ISPLINK('VCOPY   ','(LIB4)', LVAR , DSN ,'MOVE');\n            IF LVAR > 0\n               THEN LMINIT_BUF.GROUP4 = 'GROUP4(&LIB4) ';\n               ELSE;\n0           LMINIT_BUF.TYPE = 'TYPE(&TYP1) ';\n            FIELD = 'PRJ1    ';\n            END;\n       ELSE DO;\n            LMINIT_BUF.DSNAME = 'DATASET(&DSN) ';\n            FIELD = 'DSN     ';\n            END;\n    LVAR = 126;\n    CALL ISPEXEC (LVAR , LMINIT_BUF);\n    RETCODD = PLIRETV;\n0   IF RETCODD = 0\n       THEN DO;\n            LMINITED = '1'B;\n            CALL ISPLINK('VPUT    ','(ID)','SHARED  ');\n            END;\n       ELSE LMINITED = '0'B;\n0   IF RETCODD = 0\n       THEN DO;\n            CALL ISPLINK('LMOPEN  ', DATAID ,'INPUT   ');\n            CALL ISPLINK('LMMLIST ', DATAID ,'LIST','D1 ');\n            RETCODD = PLIRETV;\n            IF RETCODE = 0\n               THEN DO;\n                    CALL ISPLINK('LMMFIND ', DATAID , TUTORTOP);\n                    RETCODD = PLIRETV;\n                    IF RETCODD > 0\n                       THEN DO;\n                            MSGID = 'TUTP001 ';\n                            FIELD = 'TUTORTOP';\n                            END;\n                       ELSE;\n                    END;\n               ELSE;\n            IF RETCODE = 0\n               THEN CALL ISPLINK('LMMLIST ', DATAID ,'FREE');\n               ELSE;\n            CALL ISPLINK('LMCLOSE ', DATAID);\n            END;\n       ELSE;\n0END LMINIT;\n0END GET_OPTIONS;\n1WRAPUP: PROC;\n0   /*   WRAP UP THIS PROGRAM, CLOSE FILES, ETC.               */\n0   IF OPENED\n       THEN DO;\n            LVAR = 30;\n            BUFFER = 'LMCLOSE        DATAID(&ID)    ';\n            CALL ISPEXEC(LVAR , BUFFER);\n            END;\n       ELSE;\n0   IF LMINITED\n       THEN DO;\n            LVAR = 30;\n            BUFFER = 'LMFREE         DATAID(&ID)    ';\n            CALL ISPEXEC(LVAR , BUFFER);\n            END;\n       ELSE;\n0END WRAPUP;\n0END TUTPRNT;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TUTPRNT2": {"ttr": 10499, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*PROCESS;\n /*\n   TITLE      -   TUTPRNT2\n\n   FUNCTION   -   THIS PROGRAM PRINTS TUTORIAL PANELS IN ORDER\n\n   SPECIFIER  -   CHRIS GERKEN\n\n   DEVELOPER  -   CHRIS GERKEN\n\n   DATE       -   OCTOBER 10, 1984\n\n   LANGUAGE   -   PLI\n\n   PANVALET   -\n\n   ENTRY      -   PLISTART\n\n   LINKAGE    -   THIS PROGRAM IS SELECTED BY CLIST TUTPRINT\n\n   EXT. REF.  -   ISPLINK\n\n   DATA SETS  -   PDS'S CONTAINING ISPF PANEL DEFINITIONS\n\n   SPF TABLES -   TUTPTABL\n\n   SPF PANELS -   TUTPC050\n\n   SPF MSGS   -   TUTP000\n\n   UPDATES    -   NONE\n\n */\n1TUTPRNT: PROC OPTIONS(MAIN);\n0   DCL ISPLINK       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        ISPEXEC       EXTERNAL ENTRY OPTIONS(ASM RETCODE INTER),\n        PLIRETV       BUILTIN,\n        RETCODD       FIXED BIN(31),\n        RETCODE       FIXED BIN(31),\n        LVAR          FIXED BIN(31);\n0   DCL CTABLE       STREAM FILE PRINT,\n        LISTING      STREAM FILE PRINT;\n0   DCL NEW_AMPER     BIT(1),\n        XEROX         BIT(1),\n        BOLD          BIT(1)  INIT('1'B),\n        EOV           BIT(1),\n        EXP1          CHAR(1),\n        EXP2          CHAR(1),\n        TOC           BIT(1),\n        PAN           BIT(1),\n        CAP           BIT(1),\n        REMOT         CHAR(5),\n        DATAID        CHAR(8),\n        TUTOR         CHAR(8),\n        MEMBER        CHAR(8),\n        SYSUID        CHAR(8),\n        QUP           CHAR(8),\n        QCONT         CHAR(8),\n        QSEL          CHAR(400),\n        BUF_10        CHAR(10),\n        H_POS         CHAR(60),\n        VALID_CHARS   CHAR(65),\n        KEYLIST       CHAR(20),\n        NAMELIST      CHAR(100),\n        BUFFER        CHAR(300),\n        VERIFY        BUILTIN,\n        INDEX         BUILTIN,\n        HIGH          BUILTIN,\n        MIN           BUILTIN,\n        MOD           BUILTIN,\n        REPEAT        BUILTIN,\n        TRANSLATE     BUILTIN,\n        TIME          BUILTIN,\n        SUBSTR        BUILTIN;\n0   DCL EOF           BIT(1),\n        OVERPRINT     BIT(1),\n        EXPAND        BIT(1),\n        BLANK_FIELD   BIT(1),\n        PRINT_PANELS  BIT(1),\n        PRINT_CTABLE  BIT(1),\n        NOT_FOUND     BIT(1),\n        PRINT_ME      BIT(1),\n        PIC_2         PIC'Z9',\n        PIC_2A        PIC'99',\n        PIC_4         PIC'ZZZ9',\n        ROWID         FIXED BIN(31),\n        SECTION       FIXED BIN(31),\n        LEVEL         FIXED BIN(31),\n        PAGE#         FIXED BIN(31)  INIT(0),\n        TOTNUM        FIXED BIN(31),\n        TTL_BEG       FIXED BIN(31),\n        TTL_END       FIXED BIN(31),\n        LINE#         FIXED BIN(31)  INIT(0),\n        CTABLE_LINE#  FIXED BIN(31)  INIT(0),\n        FIELD#        FIXED BIN(31),\n        ISEL          FIXED BIN(31),\n        NSEL          FIXED BIN(31),\n        ICONT         FIXED BIN(31),\n        IOVER         FIXED BIN(31),\n        POS           FIXED BIN(31),\n        POS1          FIXED BIN(31),\n        POS2          FIXED BIN(31),\n        MORE          FIXED BIN(31),\n        LEFT          FIXED BIN(31),\n        FILL          FIXED BIN(31),\n        (I,J,K,L,M,N) FIXED BIN(31),\n        TUTNUM        FIXED BIN(31)  INIT(0),\n        BUFLEN        FIXED BIN(31),\n        EXP_COUNT     FIXED BIN(31),\n        EXP_STRT(0:50) FIXED BIN(31),\n        PAGES(50)     FIXED BIN(31),\n        HRCHY(50)     FIXED BIN(31),\n        UDK           CHAR(1),\n        BUF_2         CHAR(2),\n        BUF_3         CHAR(3),\n        BUF_4         CHAR(4),\n        UPPER_CASE    CHAR(26) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        LOWER_CASE    CHAR(26) INIT('abcdefghijklmnopqrstuvwxyz'),\n        BUF1          CHAR(80),\n        BUF2          CHAR(80),\n        BUF_80        CHAR(80),\n        BUF3          CHAR(120),\n        LINE          CHAR(80),\n        SCREEN(32)    CHAR(80);\n0   DCL FDCLIST       CHAR(19),\n        FDCTYPE(0:19) FIXED BIN(31),\n        FDCINT(0:19)  FIXED BIN(31),\n        FDCPAD(0:19)  CHAR(1),\n        FDC#          FIXED BIN(31),\n        FDCS          FIXED BIN(31);\n0   DCL START         FIXED BIN(31) INIT(0),\n        ATTR          FIXED BIN(31) INIT(1),\n        BODY          FIXED BIN(31) INIT(2),\n        MODEL         FIXED BIN(31) INIT(3),\n        INIT          FIXED BIN(31) INIT(4),\n        REINIT        FIXED BIN(31) INIT(5),\n        PROC          FIXED BIN(31) INIT(6),\n        END           FIXED BIN(31) INIT(7);\n0   DCL WIDTH         FIXED BIN(31) INIT(25),\n        HIGHT         FIXED BIN(31) INIT(40);\n0   DCL HELPID        CHAR(20),\n        HELP_FOUND    BIT(1),\n        HELPLEN       FIXED BIN(31);\n1   CALL ISPLINK('CONTROL ','ERRORS  ','RETURN  ');\n0   CALL SETUP;\n0   /*   OUTPUT THOSE TUTORIALS                                */\n0   LVAR = 75;\n    BUFFER = 'LMMLIST        DATAID(&ID)    OPTION(LIST)   ' ||\n             'MEMBER(MEMBER) STATS(YES)     ';\n    CALL ISPEXEC(LVAR , BUFFER);\n    LVAR = 8;\n    CALL ISPLINK('VCOPY   ','(TUTORTOP)', LVAR, TUTOR ,'MOVE');\n    LEVEL = 1;\n    PAGES(1) = 1;\n    CALL TUTPROC;\n    CALL NEXTTUT;\n    DO WHILE (LEVEL > 0);\n       CALL TUTPROC;\n       CALL NEXTTUT;\n       END;\n0   CALL ISPLINK('TBEND   ','TUTPTABL');\n    CALL ISPLINK('SETMSG  ','TUTP000 ');\n    CALL ISPLINK('VRESET  ');\n1TUTPROC: PROC;\n0   /*   START:    LEVEL IS SET TO THE CURRENT POSITION IN THE TUTORIAL\n                            HIERARCHY.\n                   TUTOR IS SET TO THE ID OF THE TUTORIAL TO BE\n                            PROCESSED.\n\n         PROCESS:  PRINT TUTORIAL PANEL.\n                   SAVE ZSEL, ZCONT AND ZUP VALUES.\n                   ADD A ROW FOR THIS PANEL IN TUTPTABL\n\n         END:      ROWID IS SET TO THE ROW-ID OF THE ROW FOR THIS PANEL\n                            IN TUTPTABL.\n                   HRCHY(LEVEL) IS SET TO THE ROW-ID OF TUTOR\n     */\n0   CALL INITIAL;\n    IF MOD(PAGE#,10) = 0\n       THEN CALL ISPLINK('CONTROL ','DISPLAY ','REFRESH ');\n       ELSE;\n    CALL ISPLINK('CONTROL ','DISPLAY ','LOCK    ');\n    CALL ISPLINK('DISPLAY ','TUTPC050');\n0   I = 0;\n    CALL NEWLINE;\n    DO WHILE (\u00acEOF);\n       I = I + 1;\n       SELECT(SECTION);\n         WHEN(ATTR)  IF I > 1\n                        THEN DO;\n                             CALL RAISE;\n                             CALL DECOM;\n                             CALL NEWFDC;\n                             END;\n                        ELSE;\n         WHEN(BODY)  IF ((SUBSTR(LINE,1,5) \u00ac= ')BODY') & (LINE# < 32))\n                        THEN DO;\n                             IF EXPAND\n                                THEN CALL EXPLINE;\n                                ELSE;\n                             LINE# = LINE# + 1;\n                             SCREEN(LINE#) = LINE;\n                             END;\n                        ELSE;\n         WHEN(PROC)  DO;\n                     CALL RAISE;\n                     CALL DECOM;\n                     POS = VERIFY(LINE,' ');\n                     IF POS > 0\n                        THEN DO;\n                             IF POS < 74\n                               THEN IF SUBSTR(LINE,POS,6) = '&ZCONT'\n                                    THEN DO;\n                                         CALL GET_CONT;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 75\n                               THEN IF SUBSTR(LINE,POS,5) = '&ZSEL'\n                                    THEN DO;\n                                         CALL GET_SEL;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 76\n                               THEN IF SUBSTR(LINE,POS,4) = '&ZUP'\n                                    THEN DO;\n                                         CALL GET_UP;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 75\n                               THEN IF SUBSTR(LINE,POS,5) = '&CONT'\n                                    THEN DO;\n                                         CALL GET_CONT;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 76\n                               THEN IF SUBSTR(LINE,POS,4) = '&SEL'\n                                    THEN DO;\n                                         CALL GET_SEL;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             IF POS < 77\n                               THEN IF SUBSTR(LINE,POS,3) = '&UP'\n                                    THEN DO;\n                                         CALL GET_UP;\n                                         POS = 80;\n                                         END;\n                                    ELSE;\n                             END;\n                        ELSE;\n                     END;\n         OTHERWISE;\n         END;\n       CALL NEWLINE;\n       END;\n0   IF INDEX(FDCLIST,'&') = 0\n       THEN NEW_AMPER = '0'B;\n       ELSE NEW_AMPER = '1'B;\n0   /*  UPDATE TABLE          */\n0   IF NOT_FOUND\n       THEN DO;\n\n            /* FOLLOWING ADDED FOR MISSING PANELS - ABL */\n            IF TOC\n               THEN DO;\n                    IF MOD(TUTNUM,40) = 0\n                       THEN DO;\n                            PUT PAGE    FILE(CTABLE);\n                            PUT SKIP(6) FILE(CTABLE);\n                            END;\n                       ELSE;\n                    TUTNUM = TUTNUM + 1;\n                    SCREEN(1)='***(MEMBER NOT FOUND)***  ';\n                    POS1 = 1;\n                    POS2 = 27;\n                    PUT FILE(CTABLE) EDIT\n                                       (SUBSTR(SCREEN(1),POS1,POS2-1) ||\n                                        REPEAT('..',15-LEVEL) ||\n                                        REPEAT('.', 50-POS2),' ***',\n                                        '('||TUTOR||')  **MISSING')\n                                       (COL(LEVEL*2),A,\n                                        COL(83),A(4),X(3),A);\n                    END;\n               ELSE;\n            /* ABOVE ADDED FOR MISSING PANELS - ABL */\n\n            LEVEL = LEVEL - 1;\n            END;\n       ELSE DO;\n            NSEL = 0;\n            MEMBER = TUTOR;\n            CALL ISPLINK('TBADD   ','TUTPTABL');\n            RETCODE = PLIRETV;\n            IF RETCODE > 0\n               THEN DO;\n                    LEVEL = LEVEL - 1;\n                    END;\n               ELSE DO;\n                    CALL ISPLINK('TBGET   ','TUTPTABL','D1 ','ROWID  ');\n                    HRCHY(LEVEL) = ROWID;\n                    END;\n            END;\n    IF \u00acNOT_FOUND      /* HOW 'BOUT THOSE DOUBLE NEGATIVES?  */\n       THEN DO;\n            TOTNUM = TOTNUM + 1;\n            PAGE# = PAGE# + 1;\n            IF PAN\n               THEN DO;\n                    PUT PAGE FILE(LISTING);\n                    PUT FILE(LISTING) SKIP(5);\n                    DO I = 1 TO LINE#;\n                       CALL DSPLINE;\n                       END;\n                    CALL FOOTER;\n                    END;\n               ELSE;\n            IF TOC\n               THEN DO;\n                    IF MOD(TUTNUM,40) = 0\n                       THEN DO;\n                            PUT PAGE    FILE(CTABLE);\n                            PUT SKIP(6) FILE(CTABLE);\n                            END;\n                       ELSE;\n                    TUTNUM = TUTNUM + 1;\n\n                    /* FOLLOWING CHANGED FOR MISSING BLANK - ABL */\n                    POS  = INDEX(SUBSTR(SCREEN(1),15,56),' ') + 14;\n                    POS1 = VERIFY(SUBSTR(SCREEN(1),POS,81-POS),' ') +\n                           POS - 1;\n                    IF POS = 14\n                       THEN POS1=VERIFY(SUBSTR(SCREEN(1),15,66),'-')\n                                 +14;  /* FIRST TITLE BYTE */\n                       ELSE;\n                    /* ABOVE CHANGED FOR MISSING BLANK - ABL */\n\n                    POS2 = INDEX(SUBSTR(SCREEN(1),POS1,81-POS1),'----');\n                    PUT FILE(CTABLE) EDIT\n                                       (SUBSTR(SCREEN(1),POS1,POS2-1) ||\n                                        REPEAT('..',15-LEVEL) ||\n                                        REPEAT('.', 50-POS2),\n                                        PAGE#,'('||TUTOR||')')\n                                       (COL(LEVEL*2),A,\n                                        COL(83),F(4),X(3),A(10));\n                    END;\n               ELSE;\n            END;\n       ELSE;\n1INITIAL: PROC;\n    CALL ISPLINK('LMMFIND ', DATAID , TUTOR);\n    RETCODE = PLIRETV;\n    NOT_FOUND = (RETCODE > 0);\n0   H_POS = REPEAT(' ',59);\n    PIC_2A = PAGES(1);\n    SUBSTR(H_POS,1,2) = PIC_2A;\n    DO I = 2 TO LEVEL;\n       PIC_2A = PAGES(I);\n       SUBSTR(H_POS,I*3-3) = '.' || PIC_2A;\n       END;\n0   /*   INITIALIZE COUNTERS AND STUFF...   */\n0   EOF = '0'B;\n    FDCS = 3;\n    FDCTYPE = 0;\n    FDCTYPE(0) = 1;\n    FDCTYPE(1) = 1;\n    FDCTYPE(2) = 1;\n    FDCTYPE(3) = 2;\n    FDCINT = 0;\n    FDCINT(0) = 0;\n    FDCINT(1) = 1;\n    FDCINT(2) = 0;\n    FDCINT(3) = 1;\n0   SECTION = 0;\n    SUBSTR(FDCLIST,1,3) = '%+_';\n    FDCPAD(0) = ' ';\n    FDCPAD(1) = ' ';\n    FDCPAD(2) = ' ';\n    FDCPAD(3) = ' ';\n    LINE# = 0;\n    HELP_FOUND = '0'B;\n    HELPID = '                    ';\n0   CALL ISPLINK('TBVCLEAR','TUTPTABL');\n0   ICONT = 0;\n    IOVER = 0;\n    ISEL  = 0;\n    NSEL  = 0;\n0END INITIAL;\n1NEWLINE: PROC;\n0   LVAR = 90;\n    BUFFER = 'LMGET          DATAID(&ID)    MODE(INVAR)    ' ||\n             'DATALOC(INVAR) DATALEN(LNVAR) MAXLEN(80)     ';\n    CALL ISPEXEC(LVAR , BUFFER);\n    RETCODE = PLIRETV;\n    IF RETCODE = 8\n       THEN EOF = '1'B;\n       ELSE SELECT;\n              WHEN (SUBSTR(LINE,1,6) = ')ATTR ')\n                              IF (I = 0)\n                                 THEN DO;\n                                      SECTION = ATTR;\n                                      POS = INDEX(LINE,'DEFAULT(');\n                                      IF POS > 0\n                                         THEN SUBSTR(FDCLIST,1,3) =\n                                                   SUBSTR(LINE,POS+8,3);\n                                         ELSE;\n                                      FDCPAD = ' ';\n                                      END;\n                                 ELSE;\n              WHEN (SUBSTR(LINE,1,6) = ')BODY ') DO;\n                              SECTION = BODY;\n                              POS = INDEX(LINE,'EXPAND(');\n                              IF (POS > 0) & (POS < 72)\n                                 THEN DO;\n                                      POS = POS + 7;\n                                      EXPAND = '1'B;\n                                      EXP1 = SUBSTR(LINE,POS,1);\n                                      EXP2 = SUBSTR(LINE,POS+1,1);\n                                      END;\n                                 ELSE EXPAND = '0';\n                              END;\n              WHEN (SUBSTR(LINE,1,6) = ')INIT ')\n                              SECTION = INIT;\n              WHEN (SUBSTR(LINE,1,6) = ')PROC ')\n                              SECTION = PROC;\n              WHEN (SUBSTR(LINE,1,5) = ')END ') DO;\n                              SECTION = END;\n                              EOF = '1'B;\n                              END;\n              OTHERWISE     IF I = 0\n                               THEN SECTION = BODY;\n                               ELSE;\n              END;\n0END NEWLINE;\n1NEWFDC: PROC;\n0   POS = VERIFY(LINE,' ');\n    IF POS > 0\n       THEN DO;\n            FDCS = FDCS + 1;\n            FDCINT(FDCS) = 0;\n            FDCTYPE(FDCS) = 1;\n            SUBSTR(FDCLIST,FDCS,1) = SUBSTR(LINE,POS,1);\n            FDCPAD(FDCS)  = ' ';\n            IF INDEX(LINE,'INTENS(HIGH)') > 0\n               THEN FDCINT(FDCS) = 1;\n               ELSE;\n            IF INDEX(LINE,'TYPE(OUTPUT)') > 0\n               THEN FDCTYPE(FDCS) = 0;\n               ELSE;\n            IF INDEX(LINE,'TYPE(TEXT)') > 0\n               THEN FDCTYPE(FDCS) = 1;\n               ELSE;\n            IF INDEX(LINE,'TYPE(INPUT)') > 0\n               THEN FDCTYPE(FDCS) = 2;\n               ELSE;\n            POS = INDEX(LINE,'PAD(');\n            IF POS > 0\n               THEN FDCPAD(FDCS) = SUBSTR(LINE,POS+5,1);\n               ELSE;\n            IF INDEX(LINE,'INTENS(NON)') > 0\n               THEN DO;\n                    FDCINT(FDCS) = 0;\n                    FDCTYPE(FDCS)= 0;\n                    FDCPAD(FDCS) = ' ';\n                    END;\n               ELSE;\n            END;\n       ELSE;\n0END NEWFDC;\n1EXPLINE: PROC;\n0   POS1 = INDEX(LINE,EXP1);\n    EXP_COUNT = 0;\n    EXP_STRT(0) = 0;\n    POS = 0;\n    DO WHILE (POS1 > 0);\n       POS = POS + POS1;\n       IF SUBSTR(LINE,POS+2,1) = EXP2\n          THEN DO;\n               LINE = SUBSTR(LINE,1,POS-1) ||\n                      SUBSTR(LINE,POS+1,1) ||\n                      SUBSTR(LINE,POS+3,78-POS) || '  ';\n               EXP_COUNT = EXP_COUNT + 1;\n               EXP_STRT(EXP_COUNT) = POS;\n               END;\n          ELSE;\n       POS1 = INDEX(SUBSTR(LINE,POS+1,81-POS),EXP1);\n       END;\n0   IF EXP_COUNT > 0\n       THEN DO;\n0           DO POS = 80 TO 1 BY -1 WHILE(SUBSTR(LINE,POS,1) = ' ');\n               END;\n            POS = 80 - POS;\n0           MORE = MOD(POS,EXP_COUNT);\n            FILL = (POS - MORE) / EXP_COUNT;\n            N = 1;\n0           DO M = 1 TO MORE;\n               J = EXP_STRT(M-1) + 1;\n               K = EXP_STRT(M);\n               SUBSTR(BUF_80,N,K-J+2+FILL) = SUBSTR(LINE,J,K-J) ||\n                                             REPEAT(SUBSTR(LINE,K,1),\n                                                    FILL+2);\n               N = N + K - J + FILL;\n               END;\n0           DO M = (MORE + 1) TO EXP_COUNT;\n               J = EXP_STRT(M-1) + 1;\n               K = EXP_STRT(M);\n               SUBSTR(BUF_80,N,K-J+1+FILL) = SUBSTR(LINE,J,K-J) ||\n                                             REPEAT(SUBSTR(LINE,K,1),\n                                                    FILL+1);\n               N = N + K - J - 1 + FILL;\n               END;\n0           LEFT = 81 - POS - EXP_STRT(M-1);\n            SUBSTR(BUF_80,N,LEFT) = SUBSTR(LINE,EXP_STRT(M-1)+1,LEFT);\n            LINE = BUF_80;\n            END;\n       ELSE;\n0END EXPLINE;\n1RAISE: PROC;\n0   LINE = TRANSLATE(LINE,UPPER_CASE,LOWER_CASE);\n0END RAISE;\n1DECOM: PROC;\n0   POS1 = INDEX(LINE,'/*');\n    POS2 = INDEX(SUBSTR(LINE,POS1+2,79-POS1),'*/');\n    DO WHILE ((0 < POS1) & (0 < POS2));\n       SUBSTR(LINE,POS1,POS1+POS2+3) = REPEAT(' ',POS1+POS2+2);\n       POS1 = INDEX(LINE,'/*');\n       POS2 = INDEX(SUBSTR(LINE,POS1+2,79-POS1),'*/');\n       END;\n0END DECOM;\n1GET_CONT: PROC;\n0   POS  = INDEX(LINE,'=');\n    POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),' ');\n    IF POS1 = 0\n       THEN POS1 = POS + 1;\n       ELSE POS1 = POS + POS1;\n0   /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0   POS = INDEX(SUBSTR(LINE,POS1,81-POS1),' ');\n    IF POS = 0\n       THEN POS2 = 81 - POS1;\n       ELSE POS2 = POS - 1;\n0   /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n0   QCONT = SUBSTR(LINE,POS1,POS2) || '        ';\n    ICONT = 1;\n0END GET_CONT;\n1GET_UP: PROC;\n0   POS  = INDEX(LINE,'=');\n    POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),' ');\n    IF POS1 = 0\n       THEN POS1 = POS + 1;\n       ELSE POS1 = POS + POS1;\n0   /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0   POS = INDEX(SUBSTR(LINE,POS1,81-POS1),' ');\n    IF POS = 0\n       THEN POS2 = 81 - POS1;\n       ELSE POS2 = POS - 1;\n0   /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n0   QUP = SUBSTR(LINE,POS1,POS2) || '        ';\n0END GET_UP;\n1GET_SEL: PROC;\n    L = 0;\n\n    /*  FOLLOWING CHANGED TO ALLOW MULTIPLE SELECTS PER LINE - ABL */\n    IF INDEX(LINE,',') = 0\n       THEN CALL NEWLINE;\n       ELSE;\n    /*  ABOVE CHANGED TO ALLOW MULTIPLE SELECTS PER LINE - ABL */\n\n    DO UNTIL (POS > 0);\n       POS = INDEX(LINE,',');\n       POS1 = VERIFY(SUBSTR(LINE,POS+1,80-POS),'* ');\n       IF POS1 = 0\n          THEN POS1 = POS + 1;\n          ELSE POS1 = POS + POS1;\n0      /*  POS1 NOW CONTAINS THE STARTING POSITION OF THE TUTOR ID   */\n0      POS = VERIFY(SUBSTR(LINE,POS1,81-POS1),VALID_CHARS);\n       IF POS = 0\n          THEN POS2 = 81 - POS1;\n          ELSE POS2 = POS - 1;\n0      /*  POS2 NOW CONTAINS THE LENGTH OF THE TUTOR ID              */\n       L = L + 1;\n       SUBSTR(QSEL,8*L-7,POS2) = SUBSTR(LINE,POS1,POS2);\n\n       /*  FOLLOWING CHANGED TO ALLOW MULTIPLE SELECTS PER LINE - ABL */\n       LINE=SUBSTR(LINE,POS1+POS2);\n       IF SUBSTR(QSEL,8*L-7,1) = ' '\n          THEN L = L - 1;     /*   FOR THE  ?,* )     CASE  */\n          ELSE DO;\n                  IF INDEX(LINE,',') = 0\n                     THEN DO;\n                             POS=INDEX(LINE,')');\n                             IF POS = 0\n                                THEN CALL NEWLINE;\n                                ELSE;\n                             END;\n                     ELSE POS = 0;\n                  END;\n       /*  ABOVE CHANGED TO ALLOW MULTIPLE SELECTS PER LINE - ABL */\n\n       END;\n0   ISEL = L;\n0END GET_SEL;\n1DSPLINE: PROC;\n    FIELD# = 0;\n    BUF1 = TRANSLATE(SCREEN(I),HIGH(FDCS),SUBSTR(FDCLIST,1,FDCS));\n    IF CAP\n       THEN BUF1 = TRANSLATE(BUF1,UPPER_CASE,LOWER_CASE);\n       ELSE;\n    IF \u00acNEW_AMPER\n       THEN DO;\n            POS = INDEX(BUF1,'&');\n            POS1 = 1;\n            DO WHILE (POS > 0);\n               POS = POS1 + POS - 1;\n               IF POS = 80\n                  THEN SUBSTR(BUF1,80,1) = ' ';\n                  ELSE IF SUBSTR(BUF1,POS+1,1) = '&'\n                          THEN DO;\n                               BUF1 = SUBSTR(BUF1,1,POS)        ||\n                                      SUBSTR(BUF1,POS+2,79-POS) ||\n                                      ' ';\n                               POS = POS + 1;\n                               END;\n                          ELSE DO;\n                               EOV = '0'B;\n                               DO POS1 = 1 TO MIN(8,80-POS) WHILE(\u00acEOV);\n                                  J = INDEX(VALID_CHARS,\n                                            SUBSTR(BUF1,POS+POS1,1));\n                                  SELECT;\n                                    WHEN (J = 0)               EOV='1'B;\n                                    WHEN ((J < 11)&(POS1 = 1)) EOV='1'B;\n                                    OTHERWISE;\n                                    END;\n                                  END;\n                               POS1 = POS1 - 1;\n                               BUF1 = SUBSTR(BUF1,1,POS-1) ||\n                                      REPEAT(' ',POS1-1)   ||\n                                      SUBSTR(BUF1,POS+POS1,81-POS-POS1);\n                               POS1 = POS1 + POS + 1;\n                               IF POS1 < 81\n                                  THEN IF SUBSTR(BUF1,POS1,1)='.'\n                                          THEN SUBSTR(BUF1,POS1,1)=' ';\n                                          ELSE;\n                               END;\n               POS1 = POS;\n               POS = INDEX(SUBSTR(BUF1,POS,81-POS),'&');\n               END;\n            END;\n       ELSE;\n    BUF2 = REPEAT(' ',79);\n    BUF3 = REPEAT(' ',119);\n    OVERPRINT = '0'B;\n    POS = INDEX(BUF1,HIGH(1));\n    IF POS = 1\n       THEN FDC# = -1;\n       ELSE FDC# = 0;\n    DO WHILE (POS < 80);\n       IF FDC# \u00ac= 0\n          THEN DO;\n               POS1 = INDEX(SUBSTR(BUF1,POS+1,81-POS),HIGH(1));\n               IF POS1 = 0\n                  THEN POS1 = 80 - POS;\n                  ELSE POS1 = POS1 - 1;\n               FDC#=INDEX(\n                       SUBSTR(FDCLIST,1,FDCS),\n                       SUBSTR(SCREEN(I),POS,1));\n               SUBSTR(BUF1,POS,1) = ' ';\n               POS = POS+1;\n               END;\n          ELSE DO;\n               POS1 = INDEX(BUF1,HIGH(1));\n               IF POS1 = 0\n                  THEN POS1 = 80;\n                  ELSE POS1 = POS1 - 1;\n               POS = 1;\n               END;\n       K = FDCTYPE(FDC#);\n       BLANK_FIELD =  (K = 0) |\n                     ((K = 1) & (VERIFY(SUBSTR(BUF1,POS,POS1),' ')=0))|\n                     ((K = 2) & (FDCPAD(FDC#) = ' '));\n       SELECT;\n         WHEN (BLANK_FIELD)\n                  IF \u00acXEROX\n                     THEN SUBSTR(BUF1,POS,POS1) = REPEAT(' ',POS1-1);\n                     ELSE DO;\n                          SUBSTR(BUF3,FIELD#*2+POS+1,1) = ' ';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(' ',POS1-1);\n                          END;\n         WHEN (FDCTYPE(FDC#) = 0)\n                  IF \u00acXEROX\n                     THEN SUBSTR(BUF1,POS,POS1) = REPEAT(' ',POS1-1);\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(' ',POS1-1);\n                          END;\n         WHEN (FDCTYPE(FDC#) = 1) DO;     /*  TEXT  */\n                  IF \u00acXEROX\n                     THEN IF FDCINT(FDC#) = 1\n                             THEN DO;\n                                  OVERPRINT = '1'B;\n                                  SUBSTR(BUF2,POS,POS1) =\n                                        SUBSTR(BUF1,POS,POS1);\n                                  END;\n                             ELSE;\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                SUBSTR(BUF1,POS,POS1);\n                          END;\n                  END;\n         WHEN (FDCTYPE(FDC#) = 2) DO; /* VARIABLE - PAD */\n                  IF \u00acXEROX\n                     THEN DO;\n                          SUBSTR(BUF1,POS,POS1) =\n                                 REPEAT(FDCPAD(FDC#),POS1-1);\n                          IF FDCINT(FDC#) = 1\n                             THEN DO;\n                                  SUBSTR(BUF2,POS,POS1) =\n                                        REPEAT(FDCPAD(FDC#),POS1-1);\n                                  OVERPRINT = '1'B;\n                                  END;\n                             ELSE;\n                          END;\n                     ELSE DO;\n                          FIELD# = FIELD# + 1;\n                          SUBSTR(BUF3,FIELD#*2+POS-1,1) = ' ';\n                          IF FDCINT(FDC#) = 1\n                             THEN SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'1';\n                             ELSE SUBSTR(BUF3,FIELD#*2+POS,2)=UDK||'2';\n                          SUBSTR(BUF3,FIELD#*2+POS+2,POS1) =\n                                REPEAT(FDCPAD(FDC#),POS1-1);\n                          END;\n                  END;\n         OTHERWISE;\n         END;\n       FDCTYPE(0) = FDCTYPE(FDC#);\n       FDCINT(0)  = FDCINT(FDC#);\n       FDCPAD(0)  = FDCPAD(FDC#);\n       POS = INDEX(BUF1,HIGH(1));\n       IF POS = 0\n          THEN POS = 81;\n          ELSE;\n       FDC# = -1;\n       END;\n    IF XEROX\n       THEN PUT FILE(LISTING) EDIT(BUF3) (COL(10),A(120));\n       ELSE PUT FILE(LISTING) EDIT(BUF1) (COL(10),A(80));\n    IF OVERPRINT & BOLD\n       THEN DO;\n            PUT SKIP(0) FILE(LISTING) EDIT(BUF2) (COL(10),A(80));\n            END;\n       ELSE;\n0END DSPLINE;\n1FOOTER: PROC;\n0   PUT FILE(LISTING) EDIT ('PANEL ID: '||TUTOR)\n                           (LINE(40),COL(13),A(18));\n0   PIC_2A = PAGES(1);\n    PUT FILE(LISTING) EDIT ('HIER: '||SUBSTR(H_POS,1,LEVEL*3-1))\n                           (COL(36),A);\n0   PUT SKIP(0) FILE(LISTING) EDIT ('PAGE: ',PAGE#)\n                           (COL(82),A(6),F(4));\n0END FOOTER;\n0END TUTPROC;\n1NEXTTUT: PROC;\n0   /*   START:    ROWID IS SET TO THE ROW-ID OF THE ROW FOR THIS PANEL\n                            IN TUTPTABL.\n\n         PROCESS:  RETRIEVE ROW WITH ROW-ID OF ROWID.\n                   FIGURE OUT WHAT TUTORIAL TO PRINT NEXT.\n\n         END:      TUTOR IS THE ID OF THE NEXT TUTORIAL.\n                   LEVEL IS SET TO THE POSITION OF ID TUTOR IN THE\n                            TUTORIAL HIERARCHY.\n     */\n0   PRINT_ME = '0'B;\n    DO WHILE (\u00acPRINT_ME & (LEVEL > 0));\n       ROWID = HRCHY(LEVEL);\n       CALL ISPLINK('TBTOP   ','TUTPTABL');\n       CALL ISPLINK('TBSKIP  ','TUTPTABL',' ','D1 ','D2 ', ROWID);\n       SELECT;\n         WHEN (ISEL > 0) DO;  /* PROCESS QSEL LIST   */\n              NSEL = NSEL + 1;\n              ICONT = 0;\n              CALL ISPLINK('TBPUT   ','TUTPTABL');\n              IF NSEL > ISEL\n                 THEN DO;    /* NO MORE ID'S */\n                      LEVEL = LEVEL - 1;\n                      END;\n                 ELSE DO;\n                      TUTOR = SUBSTR(QSEL,8*NSEL-7,8);\n                      LEVEL = LEVEL + 1;\n                      IF NSEL = 1\n                         THEN PAGES(LEVEL) = 1;\n                         ELSE PAGES(LEVEL) = PAGES(LEVEL) + 1;\n                      PRINT_ME = '1'B;\n                      END;\n              END;\n         WHEN (ICONT > 0) DO;   /* PROCESS QCONT ID    */\n              TUTOR = QCONT;\n              PAGES(LEVEL) = PAGES(LEVEL) + 1;\n              PRINT_ME = '1'B;\n              END;\n         OTHERWISE DO;\n              LEVEL = LEVEL - 1;\n              END;\n         END;\n       END;\n0END NEXTTUT;\n1SETUP: PROC;\n0   LVAR = 4;\n    CALL ISPLINK('VDEFINE ','(NSEL)    ', NSEL      ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ISEL)    ', ISEL      ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ICONT)   ', ICONT     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(IOVER)   ', IOVER     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(LEVEL)   ', LEVEL     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(ROWID)   ', ROWID     ,'FIXED', LVAR);\n    CALL ISPLINK('VDEFINE ','(TOTNUM)  ', TOTNUM    ,'FIXED', LVAR);\n0   LVAR = 8;\n    CALL ISPLINK('VDEFINE ','(TUTOR)   ', TUTOR     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(MEMBER)  ', MEMBER     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(ID)      ', DATAID    ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(QCONT)   ', QCONT     ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(QUP)     ', QUP       ,'CHAR' , LVAR);\n    CALL ISPLINK('VDEFINE ','(ZUSER)   ', SYSUID    ,'CHAR' , LVAR);\n0   LVAR = 60;\n    CALL ISPLINK('VDEFINE ','(HPOS)    ', H_POS     ,'CHAR' , LVAR);\n0   LVAR = 80;\n    CALL ISPLINK('VDEFINE ','(INVAR)   ', LINE      ,'CHAR' , LVAR);\n0   LVAR = 400;\n    CALL ISPLINK('VDEFINE ','(QSEL)    ', QSEL      ,'CHAR' , LVAR);\n0   NAMELIST = '(QSEL QUP QCONT NSEL ISEL ICONT IOVER)';\n    KEYLIST  = '(MEMBER)';\n    CALL ISPLINK('TBCREATE','TUTPTABL', KEYLIST , NAMELIST ,'NOWRITE');\n0   /*           SET FLAGS ET ALL           */\n0   NAMELIST = '(CAP TOC PAN XRX UDK TUTORTOP)';\n    CALL ISPLINK('VGET    ', NAMELIST ,'PROFILE ');\n    NAMELIST = '(ID)';\n    CALL ISPLINK('VGET    ', NAMELIST ,'SHARED  ');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(CAP)', LVAR , BUF_3 ,'MOVE');\n    CAP = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(TOC)', LVAR , BUF_3 ,'MOVE');\n    TOC = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(PAN)', LVAR , BUF_3 ,'MOVE');\n    PAN = (BUF_3 = 'YES');\n0   LVAR = 3;\n    CALL ISPLINK('VCOPY   ','(XRX)', LVAR , BUF_3 ,'MOVE');\n    XEROX = (BUF_3 = 'YES');\n    LVAR = 1;\n0   CALL ISPLINK('VCOPY   ','(UDK)', LVAR , UDK ,'MOVE');\n0   TOTNUM = 0;\n0   IF XEROX\n       THEN CALL PANXEROX;\n       ELSE;\n0   PUT PAGE FILE(LISTING);\n    CALL ISPLINK('VGET    ','(ZUSER)','SHARED  ');\n    PUT SKIP FILE(LISTING) EDIT(' *** TUTORIAL PRINT OUTPUT FOR USER '||\n                                SYSUID || ' ***')\n                               (COL(3),A);\n0   VALID_CHARS = '0123456789' || UPPER_CASE || LOWER_CASE || '#@$';\n1PANXEROX: PROC;\n0   PUT FILE(LISTING) EDIT('=UDK=' || UDK)          (COL(1),A(6));\n    PUT FILE(LISTING) EDIT(UDK || '+X ')            (COL(1),A(4));\n    PUT FILE(LISTING) EDIT('=UDK=' || UDK)          (COL(1),A(6));\n    PUT FILE(LISTING) EDIT(UDK || 'c1          ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '+1Titan10B-L')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '+2Titan10-L ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || 'm510,5,5,5,650') (COL(1),A(15));\n    PUT FILE(LISTING) EDIT(UDK || '+P          ')   (COL(1),A(13));\n    PUT FILE(LISTING) EDIT(UDK || '1           ')   (COL(1),A(13));\n0   PUT FILE(CTABLE) EDIT('=UDK=' || UDK)         (COL(1),A(6));\n    PUT FILE(CTABLE) EDIT(UDK || '+X ')           (COL(1),A(4));\n    PUT FILE(CTABLE) EDIT('=UDK=' || UDK)         (COL(1),A(6));\n    PUT FILE(CTABLE) EDIT(UDK || 'c1          ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '+1Titan10B-L')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '+2Titan10-L ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || 'm510,5,5,5,650') (COL(1),A(15));\n    PUT FILE(CTABLE) EDIT(UDK || '+P          ')  (COL(1),A(13));\n    PUT FILE(CTABLE) EDIT(UDK || '1           ')  (COL(1),A(13));\n0END PANXEROX;\n0END SETUP;\n0END TUTPRNT;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT469/FILE469.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT469", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}