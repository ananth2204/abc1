{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20110613192437000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 44, "INMDSNAM": "GCC.DOC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 6249, "INMBLKSZ": 6253, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 255, "INMRECFM": "?"}}, "file": {"GCC.DOC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6253, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "b'X\\x00/\\xb0\\x00\\x00\\x00\\x15\\x00\\x00\\x00\\x15\\x00\\r\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"C@PARSE": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* YACC parser for C syntax and for Objective C.  -*-c-*-\n   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n   1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file defines the grammar of C and that of Objective C.\n   @@ifobjc ... @@end_ifobjc  conditionals contain code for Objective C only.\n   @@ifc ... @@end_ifc  conditionals contain code for C only.\n   Sed commands in Makefile.in are used to convert this file into\n   c-parse.y and into objc-parse.y.  */\n\n/* To whomever it may concern: I have heard that such a thing was once\n   written by AT&T, but I have never seen it.  */\n\n@@ifc\n%expect 10 /* shift/reduce conflicts, and no reduce/reduce conflicts.  */\n@@end_ifc\n\n%{\n#include \"config.h\"\n#include \"system.h\"\n#include \"coretypes.h\"\n#include \"tm.h\"\n#include \"tree.h\"\n#include \"input.h\"\n#include \"cpplib.h\"\n#include \"intl.h\"\n#include \"timevar.h\"\n#include \"c-pragma.h\"\t\t/* For YYDEBUG definition, and parse_in.  */\n#include \"c-tree.h\"\n#include \"flags.h\"\n#include \"varray.h\"\n#include \"output.h\"\n#include \"toplev.h\"\n#include \"ggc.h\"\n\n@@ifobjc\n#include \"objc-act.h\"\n@@end_ifobjc\n\n/* Like YYERROR but do call yyerror.  */\n#define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n\n/* Like the default stack expander, except (1) use realloc when possible,\n   (2) impose no hard maxiumum on stack size, (3) REALLY do not use alloca.\n\n   Irritatingly, YYSTYPE is defined after this %{ %} block, so we cannot\n   give malloced_yyvs its proper type.  This is ok since all we need from\n   it is to be able to free it.  */\n\nstatic short *malloced_yyss;\nstatic void *malloced_yyvs;\n\n#define yyoverflow(MSG, SS, SSSIZE, VS, VSSIZE, YYSSZ)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  size_t newsize;\t\t\t\t\t\t\t\\\n  short *newss;\t\t\t\t\t\t\t\t\\\n  YYSTYPE *newvs;\t\t\t\t\t\t\t\\\n  newsize = *(YYSSZ) *= 2;\t\t\t\t\t\t\\\n  if (malloced_yyss)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      newss = really_call_realloc (*(SS), newsize * sizeof (short));\t\\\n      newvs = really_call_realloc (*(VS), newsize * sizeof (YYSTYPE));\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      newss = really_call_malloc (newsize * sizeof (short));\t\t\\\n      newvs = really_call_malloc (newsize * sizeof (YYSTYPE));\t\t\\\n      if (newss)\t\t\t\t\t\t\t\\\n        memcpy (newss, *(SS), (SSSIZE));\t\t\t\t\\\n      if (newvs)\t\t\t\t\t\t\t\\\n        memcpy (newvs, *(VS), (VSSIZE));\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!newss || !newvs)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      yyerror (MSG);\t\t\t\t\t\t\t\\\n      return 2;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  *(SS) = newss;\t\t\t\t\t\t\t\\\n  *(VS) = newvs;\t\t\t\t\t\t\t\\\n  malloced_yyss = newss;\t\t\t\t\t\t\\\n  malloced_yyvs = (void *) newvs;\t\t\t\t\t\\\n} while (0)\n%}\n\n%start program\n\n%union {long itype; tree ttype; enum tree_code code;\n\tlocation_t location; }\n\n/* All identifiers that are not reserved words\n   and are not declared typedefs in the current block */\n%token IDENTIFIER\n\n/* All identifiers that are declared typedefs in the current block.\n   In some contexts, they are treated just like IDENTIFIER,\n   but they can also serve as typespecs in declarations.  */\n%token TYPENAME\n\n/* Reserved words that specify storage class.\n   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n%token SCSPEC\t\t\t/* Storage class other than static.  */\n%token STATIC\t\t\t/* Static storage class.  */\n\n/* Reserved words that specify type.\n   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n%token TYPESPEC\n\n/* Reserved words that qualify type: \"const\", \"volatile\", or \"restrict\".\n   yylval contains an IDENTIFIER_NODE which indicates which one.  */\n%token TYPE_QUAL\n\n/* Character or numeric constants.\n   yylval is the node for the constant.  */\n%token CONSTANT\n\n/* String constants in raw form.\n   yylval is a STRING_CST node.  */\n\n%token STRING\n\n/* \"...\", used for functions with variable arglists.  */\n%token ELLIPSIS\n\n/* the reserved words */\n/* SCO include files test \"ASM\", so use something else. */\n%token SIZEOF ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD TYPEOF ALIGNOF\n%token ATTRIBUTE EXTENSION LABEL\n%token REALPART IMAGPART VA_ARG CHOOSE_EXPR TYPES_COMPATIBLE_P\n%token PTR_VALUE PTR_BASE PTR_EXTENT\n%token FUNC_NAME\n\n/* Add precedence rules to solve dangling else s/r conflict */\n%nonassoc IF\n%nonassoc ELSE\n\n/* Define the operator tokens and their precedences.\n   The value is an integer because, if used, it is the tree code\n   to use in the expression made from the operator.  */\n\n%right <code> ASSIGN '='\n%right <code> '?' ':'\n%left <code> OROR\n%left <code> ANDAND\n%left <code> '|'\n%left <code> '\u00ac'\n%left <code> '&'\n%left <code> EQCOMPARE\n%left <code> ARITHCOMPARE\n%left <code> LSHIFT RSHIFT\n%left <code> '+' '-'\n%left <code> '*' '/' '%'\n%right <code> UNARY PLUSPLUS MINUSMINUS\n%left HYPERUNARY\n%left <code> POINTSAT '.' '(' '\u00dd'\n\n/* The Objective-C keywords.  These are included in C and in\n   Objective C, so that the token codes are the same in both.  */\n%token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n%token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n%token AT_THROW AT_TRY AT_CATCH AT_FINALLY AT_SYNCHRONIZED\n%token OBJC_STRING\n\n%type <code> unop\n%type <ttype> ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n%type <ttype> BREAK CONTINUE RETURN GOTO ASM_KEYWORD SIZEOF TYPEOF ALIGNOF\n\n%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n%type <ttype> expr_no_commas cast_expr unary_expr primary STRING\n%type <ttype> declspecs_nosc_nots_nosa_noea declspecs_nosc_nots_nosa_ea\n%type <ttype> declspecs_nosc_nots_sa_noea declspecs_nosc_nots_sa_ea\n%type <ttype> declspecs_nosc_ts_nosa_noea declspecs_nosc_ts_nosa_ea\n%type <ttype> declspecs_nosc_ts_sa_noea declspecs_nosc_ts_sa_ea\n%type <ttype> declspecs_sc_nots_nosa_noea declspecs_sc_nots_nosa_ea\n%type <ttype> declspecs_sc_nots_sa_noea declspecs_sc_nots_sa_ea\n%type <ttype> declspecs_sc_ts_nosa_noea declspecs_sc_ts_nosa_ea\n%type <ttype> declspecs_sc_ts_sa_noea declspecs_sc_ts_sa_ea\n%type <ttype> declspecs_ts declspecs_nots\n%type <ttype> declspecs_ts_nosa declspecs_nots_nosa\n%type <ttype> declspecs_nosc_ts declspecs_nosc_nots declspecs_nosc declspecs\n%type <ttype> maybe_type_quals_attrs typespec_nonattr typespec_attr\n%type <ttype> typespec_reserved_nonattr typespec_reserved_attr\n%type <ttype> typespec_nonreserved_nonattr\n\n%type <ttype> scspec SCSPEC STATIC TYPESPEC TYPE_QUAL maybe_type_qual\n%type <ttype> initdecls notype_initdecls initdcl notype_initdcl\n%type <ttype> init maybeasm\n%type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n%type <ttype> maybe_attribute attributes attribute attribute_list attrib\n%type <ttype> any_word\n\n%type <ttype> compstmt compstmt_start compstmt_nostart compstmt_primary_start\n%type <ttype> do_stmt_start poplevel stmt label\n\n%type <ttype> c99_block_start c99_block_end\n%type <ttype> declarator\n%type <ttype> notype_declarator after_type_declarator\n%type <ttype> parm_declarator\n%type <ttype> parm_declarator_starttypename parm_declarator_nostarttypename\n%type <ttype> array_declarator\n\n%type <ttype> structsp_attr structsp_nonattr\n%type <ttype> component_decl_list component_decl_list2\n%type <ttype> component_decl components components_notype component_declarator\n%type <ttype> component_notype_declarator\n%type <ttype> enumlist enumerator\n%type <ttype> struct_head union_head enum_head\n%type <ttype> typename absdcl absdcl1 absdcl1_ea absdcl1_noea\n%type <ttype> direct_absdcl1 absdcl_maybe_attribute\n%type <ttype> xexpr parms parm firstparm identifiers\n\n%type <ttype> parmlist parmlist_1 parmlist_2\n%type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n%type <ttype> identifiers_or_typenames\n\n%type <itype> setspecs setspecs_fp extension\n\n%type <location> save_location\n\n@@ifobjc\n/* the Objective-C nonterminals */\n\n%type <ttype> ivar_decl_list ivar_decls ivar_decl ivars ivar_declarator\n%type <ttype> methoddecl unaryselector keywordselector selector\n%type <ttype> keyworddecl receiver objcmessageexpr messageargs\n%type <ttype> keywordexpr keywordarglist keywordarg\n%type <ttype> myparms myparm optparmlist reservedwords objcselectorexpr\n%type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n%type <ttype> non_empty_protocolrefs protocolrefs identifier_list objcprotocolexpr\n\n%type <ttype> CLASSNAME OBJECTNAME OBJC_STRING\n\n%type <ttype> superclass\n%type <itype> objc_try_catch_stmt objc_finally_block\n@@end_ifobjc\n\n%{\n/* Number of statements (loosely speaking) and compound statements\n   seen so far.  */\nstatic int stmt_count;\nstatic int compstmt_count;\n\n/* Input location of the end of the body of last simple_if;\n   used by the stmt-rule immediately after simple_if returns.  */\nstatic location_t if_stmt_locus;\n\n\n/* List of types and structure classes of the current declaration.  */\nstatic GTY(()) tree current_declspecs;\nstatic GTY(()) tree prefix_attributes;\n\n/* List of all the attributes applying to the identifier currently being\n   declared; includes prefix_attributes and possibly some more attributes\n   just after a comma.  */\nstatic GTY(()) tree all_prefix_attributes;\n\n/* Stack of saved values of current_declspecs, prefix_attributes and\n   all_prefix_attributes.  */\nstatic GTY(()) tree declspec_stack;\n\n/* PUSH_DECLSPEC_STACK is called from setspecs; POP_DECLSPEC_STACK\n   should be called from the productions making use of setspecs.  */\n#define PUSH_DECLSPEC_STACK\t\t\t\t\t\t \\\n  do {\t\t\t\t\t\t\t\t\t \\\n    declspec_stack = tree_cons (build_tree_list (prefix_attributes,\t \\\n\t\t\t\t\t\t all_prefix_attributes), \\\n\t\t\t\tcurrent_declspecs,\t\t\t \\\n\t\t\t\tdeclspec_stack);\t\t\t \\\n  } while (0)\n\n#define POP_DECLSPEC_STACK\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    current_declspecs = TREE_VALUE (declspec_stack);\t\t\t\\\n    prefix_attributes = TREE_PURPOSE (TREE_PURPOSE (declspec_stack));\t\\\n    all_prefix_attributes = TREE_VALUE (TREE_PURPOSE (declspec_stack));\t\\\n    declspec_stack = TREE_CHAIN (declspec_stack);\t\t\t\\\n  } while (0)\n\n/* For __extension__, save/restore the warning flags which are\n   controlled by __extension__.  */\n#define SAVE_EXT_FLAGS()\t\t\\\n\t(pedantic\t\t\t\\\n\t | (warn_pointer_arith << 1)\t\\\n\t | (warn_traditional << 2)\t\\\n\t | (flag_iso << 3))\n\n#define RESTORE_EXT_FLAGS(val)\t\t\t\\\n  do {\t\t\t\t\t\t\\\n    pedantic = val & 1;\t\t\t\t\\\n    warn_pointer_arith = (val >> 1) & 1;\t\\\n    warn_traditional = (val >> 2) & 1;\t\t\\\n    flag_iso = (val >> 3) & 1;\t\t\t\\\n  } while (0)\n\n@@ifobjc\n/* Objective-C specific parser/lexer information */\n\nstatic enum tree_code objc_inherit_code;\nstatic int objc_pq_context = 0, objc_public_flag = 0;\n\n/* The following flag is needed to contextualize ObjC lexical analysis.\n   In some cases (e.g., 'int NSObject;'), it is undesirable to bind\n   an identifier to an ObjC class, even if a class with that name\n   exists.  */\nstatic int objc_need_raw_identifier;\n#define OBJC_NEED_RAW_IDENTIFIER(VAL)\tobjc_need_raw_identifier = VAL\n@@end_ifobjc\n\n@@ifc\n#define OBJC_NEED_RAW_IDENTIFIER(VAL)\t/* nothing */\n@@end_ifc\n\nstatic bool parsing_iso_function_signature;\n\n/* Tell yyparse how to print a token's value, if yydebug is set.  */\n\n#define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n\nstatic void yyprint (FILE *, int, YYSTYPE);\nstatic void yyerror (const char *);\nstatic int yylexname (void);\nstatic inline int _yylex (void);\nstatic int  yylex (void);\nstatic void init_reswords (void);\n\n  /* Initialisation routine for this file.  */\nvoid\nc_parse_init (void)\n{\n  init_reswords ();\n}\n\n%}\n\n%%\nprogram: /* empty */\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids an empty source file\");\n\t\t}\n\t| extdefs\n\t;\n\n/* the reason for the strange actions in this rule\n is so that notype_initdecls when reached via datadef\n can find a valid list of type and sc specs in $0. */\n\nextdefs:\n\t{$<ttype>$ = NULL_TREE; } extdef\n\t| extdefs {$<ttype>$ = NULL_TREE; ggc_collect(); } extdef\n\t;\n\nextdef:\n\textdef_1\n\t{ parsing_iso_function_signature = false; } /* Reset after any external definition.  */\n\t;\n\nextdef_1:\n\tfndef\n\t| datadef\n@@ifobjc\n\t| objcdef\n@@end_ifobjc\n\t| ASM_KEYWORD '(' expr ')' ';'\n\t\t{ STRIP_NOPS ($3);\n\t\t  if ((TREE_CODE ($3) == ADDR_EXPR\n\t\t       && TREE_CODE (TREE_OPERAND ($3, 0)) == STRING_CST)\n\t\t      || TREE_CODE ($3) == STRING_CST)\n\t\t    assemble_asm ($3);\n\t\t  else\n\t\t    error (\"argument of `asm' is not a constant string\"); }\n\t| extension extdef\n\t\t{ RESTORE_EXT_FLAGS ($1); }\n\t;\n\ndatadef:\n\t  setspecs notype_initdecls ';'\n\t\t{ if (pedantic)\n\t\t    error (\"ISO C forbids data definition with no type or storage class\");\n\t\t  else\n\t\t    warning (\"data definition has no type or storage class\");\n\n\t\t  POP_DECLSPEC_STACK; }\n        | declspecs_nots setspecs notype_initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_ts setspecs initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs ';'\n\t  { shadow_tag ($1); }\n\t| error ';'\n\t| error '}'\n\t| ';'\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C does not allow extra `;' outside of a function\"); }\n\t;\n\nfndef:\n\t  declspecs_ts setspecs declarator\n\t\t{ if (! start_function (current_declspecs, $3,\n\t\t\t\t\tall_prefix_attributes))\n\t\t    YYERROR1;\n\t\t}\n\t  old_style_parm_decls save_location\n\t\t{ DECL_SOURCE_LOCATION (current_function_decl) = $6;\n\t\t  store_parm_decls (); }\n\t  compstmt_or_error\n\t\t{ finish_function ();\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_ts setspecs declarator error\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_nots setspecs notype_declarator\n\t\t{ if (! start_function (current_declspecs, $3,\n\t\t\t\t\tall_prefix_attributes))\n\t\t    YYERROR1;\n\t\t}\n\t  old_style_parm_decls save_location\n\t\t{ DECL_SOURCE_LOCATION (current_function_decl) = $6;\n\t\t  store_parm_decls (); }\n\t  compstmt_or_error\n\t\t{ finish_function ();\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nots setspecs notype_declarator error\n\t\t{ POP_DECLSPEC_STACK; }\n\t| setspecs notype_declarator\n\t\t{ if (! start_function (NULL_TREE, $2,\n\t\t\t\t\tall_prefix_attributes))\n\t\t    YYERROR1;\n\t\t}\n\t  old_style_parm_decls save_location\n\t\t{ DECL_SOURCE_LOCATION (current_function_decl) = $5;\n\t\t  store_parm_decls (); }\n\t  compstmt_or_error\n\t\t{ finish_function ();\n\t\t  POP_DECLSPEC_STACK; }\n\t| setspecs notype_declarator error\n\t\t{ POP_DECLSPEC_STACK; }\n\t;\n\nidentifier:\n\tIDENTIFIER\n\t| TYPENAME\n@@ifobjc\n\t| OBJECTNAME\n\t| CLASSNAME\n@@end_ifobjc\n\t;\n\nunop:     '&'\n\t\t{ $$ = ADDR_EXPR; }\n\t| '-'\n\t\t{ $$ = NEGATE_EXPR; }\n\t| '+'\n\t\t{ $$ = CONVERT_EXPR;\n@@ifc\n  if (warn_traditional && !in_system_header)\n    warning (\"traditional C rejects the unary plus operator\");\n@@end_ifc\n\t\t}\n\t| PLUSPLUS\n\t\t{ $$ = PREINCREMENT_EXPR; }\n\t| MINUSMINUS\n\t\t{ $$ = PREDECREMENT_EXPR; }\n\t| '~'\n\t\t{ $$ = BIT_NOT_EXPR; }\n\t| '!'\n\t\t{ $$ = TRUTH_NOT_EXPR; }\n\t;\n\nexpr:\tnonnull_exprlist\n\t\t{ $$ = build_compound_expr ($1); }\n\t;\n\nexprlist:\n\t  /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| nonnull_exprlist\n\t;\n\nnonnull_exprlist:\n\texpr_no_commas\n\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n\t| nonnull_exprlist ',' expr_no_commas\n\t\t{ chainon ($1, build_tree_list (NULL_TREE, $3)); }\n\t;\n\nunary_expr:\n\tprimary\n\t| '*' cast_expr   %prec UNARY\n\t\t{ $$ = build_indirect_ref ($2, \"unary *\"); }\n\t/* __extension__ turns off -pedantic for following primary.  */\n\t| extension cast_expr\t  %prec UNARY\n\t\t{ $$ = $2;\n\t\t  RESTORE_EXT_FLAGS ($1); }\n\t| unop cast_expr  %prec UNARY\n\t\t{ $$ = build_unary_op ($1, $2, 0);\n\t\t  overflow_warning ($$); }\n\t/* Refer to the address of a label as a pointer.  */\n\t| ANDAND identifier\n\t\t{ $$ = finish_label_address_expr ($2); }\n\t| sizeof unary_expr  %prec UNARY\n\t\t{ skip_evaluation--;\n\t\t  if (TREE_CODE ($2) == COMPONENT_REF\n\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2, 1)))\n\t\t    error (\"`sizeof' applied to a bit-field\");\n\t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n\t| sizeof '(' typename ')'  %prec HYPERUNARY\n\t\t{ skip_evaluation--;\n\t\t  $$ = c_sizeof (groktypename ($3)); }\n\t| alignof unary_expr  %prec UNARY\n\t\t{ skip_evaluation--;\n\t\t  $$ = c_alignof_expr ($2); }\n\t| alignof '(' typename ')'  %prec HYPERUNARY\n\t\t{ skip_evaluation--;\n\t\t  $$ = c_alignof (groktypename ($3)); }\n\t| REALPART cast_expr %prec UNARY\n\t\t{ $$ = build_unary_op (REALPART_EXPR, $2, 0); }\n\t| IMAGPART cast_expr %prec UNARY\n\t\t{ $$ = build_unary_op (IMAGPART_EXPR, $2, 0); }\n\t;\n\nsizeof:\n\tSIZEOF { skip_evaluation++; }\n\t;\n\nalignof:\n\tALIGNOF { skip_evaluation++; }\n\t;\n\ntypeof:\n\tTYPEOF { skip_evaluation++; }\n\t;\n\ncast_expr:\n\tunary_expr\n\t| '(' typename ')' cast_expr  %prec UNARY\n\t\t{ $$ = c_cast_expr ($2, $4); }\n\t;\n\nexpr_no_commas:\n\t  cast_expr\n\t| expr_no_commas '+' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '-' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '*' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '/' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '%' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas LSHIFT expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas RSHIFT expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas ARITHCOMPARE expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas EQCOMPARE expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '&' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '|' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas '\u00ac' expr_no_commas\n\t\t{ $$ = parser_build_binary_op ($2, $1, $3); }\n\t| expr_no_commas ANDAND\n\t\t{ $1 = c_common_truthvalue_conversion\n\t\t    (default_conversion ($1));\n\t\t  skip_evaluation += $1 == truthvalue_false_node; }\n\t  expr_no_commas\n\t\t{ skip_evaluation -= $1 == truthvalue_false_node;\n\t\t  $$ = parser_build_binary_op (TRUTH_ANDIF_EXPR, $1, $4); }\n\t| expr_no_commas OROR\n\t\t{ $1 = c_common_truthvalue_conversion\n\t\t    (default_conversion ($1));\n\t\t  skip_evaluation += $1 == truthvalue_true_node; }\n\t  expr_no_commas\n\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n\t\t  $$ = parser_build_binary_op (TRUTH_ORIF_EXPR, $1, $4); }\n\t| expr_no_commas '?'\n\t\t{ $1 = c_common_truthvalue_conversion\n\t\t    (default_conversion ($1));\n\t\t  skip_evaluation += $1 == truthvalue_false_node; }\n          expr ':'\n\t\t{ skip_evaluation += (($1 == truthvalue_true_node)\n\t\t\t\t      - ($1 == truthvalue_false_node)); }\n\t  expr_no_commas\n\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n\t\t  $$ = build_conditional_expr ($1, $4, $7); }\n\t| expr_no_commas '?'\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids omitting the middle term of a ?: expression\");\n\t\t  /* Make sure first operand is calculated only once.  */\n\t\t  $<ttype>2 = save_expr ($1);\n\t\t  $1 = c_common_truthvalue_conversion\n\t\t    (default_conversion ($<ttype>2));\n\t\t  skip_evaluation += $1 == truthvalue_true_node; }\n\t  ':' expr_no_commas\n\t\t{ skip_evaluation -= $1 == truthvalue_true_node;\n\t\t  $$ = build_conditional_expr ($1, $<ttype>2, $5); }\n\t| expr_no_commas '=' expr_no_commas\n\t\t{ char class;\n\t\t  $$ = build_modify_expr ($1, NOP_EXPR, $3);\n\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n\t\t  if (IS_EXPR_CODE_CLASS (class))\n\t\t    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR);\n\t\t}\n\t| expr_no_commas ASSIGN expr_no_commas\n\t\t{ char class;\n\t\t  $$ = build_modify_expr ($1, $2, $3);\n\t\t  /* This inhibits warnings in\n\t\t     c_common_truthvalue_conversion.  */\n\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n\t\t  if (IS_EXPR_CODE_CLASS (class))\n\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK);\n\t\t}\n\t;\n\nprimary:\n\tIDENTIFIER\n\t\t{\n\t\t  if (yychar == YYEMPTY)\n\t\t    yychar = YYLEX;\n\t\t  $$ = build_external_ref ($1, yychar == '(');\n\t\t}\n\t| CONSTANT\n\t| STRING\n\t| FUNC_NAME\n\t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n\t| '(' typename ')' '{'\n\t\t{ start_init (NULL_TREE, NULL, 0);\n\t\t  $2 = groktypename ($2);\n\t\t  really_start_incremental_init ($2); }\n\t  initlist_maybe_comma '}'  %prec UNARY\n\t\t{ tree constructor = pop_init_level (0);\n\t\t  tree type = $2;\n\t\t  finish_init ();\n\n\t\t  if (pedantic && ! flag_isoc99)\n\t\t    pedwarn (\"ISO C90 forbids compound literals\");\n\t\t  $$ = build_compound_literal (type, constructor);\n\t\t}\n\t| '(' expr ')'\n\t\t{ char class = TREE_CODE_CLASS (TREE_CODE ($2));\n\t\t  if (IS_EXPR_CODE_CLASS (class))\n\t\t    C_SET_EXP_ORIGINAL_CODE ($2, ERROR_MARK);\n\t\t  $$ = $2; }\n\t| '(' error ')'\n\t\t{ $$ = error_mark_node; }\n\t| compstmt_primary_start compstmt_nostart ')'\n                 { tree saved_last_tree;\n\n\t\t   if (pedantic)\n\t\t     pedwarn (\"ISO C forbids braced-groups within expressions\");\n\t\t  saved_last_tree = COMPOUND_BODY ($1);\n\t\t  RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n\t\t  last_tree = saved_last_tree;\n\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n\t\t  if (!last_expr_type)\n\t\t    last_expr_type = void_type_node;\n\t\t  $$ = build1 (STMT_EXPR, last_expr_type, $1);\n\t\t  TREE_SIDE_EFFECTS ($$) = 1;\n\t\t}\n\t| compstmt_primary_start error ')'\n\t\t{\n\t\t  last_tree = COMPOUND_BODY ($1);\n\t\t  TREE_CHAIN (last_tree) = NULL_TREE;\n\t\t  $$ = error_mark_node;\n\t\t}\n\t| primary '(' exprlist ')'   %prec '.'\n\t\t{ $$ = build_function_call ($1, $3); }\n\t| VA_ARG '(' expr_no_commas ',' typename ')'\n\t\t{ $$ = build_va_arg ($3, groktypename ($5)); }\n\n      | CHOOSE_EXPR '(' expr_no_commas ',' expr_no_commas ',' expr_no_commas ')'\n\t\t{\n                  tree c;\n\n                  c = fold ($3);\n                  STRIP_NOPS (c);\n                  if (TREE_CODE (c) != INTEGER_CST)\n                    error (\"first argument to __builtin_choose_expr not a constant\");\n                  $$ = integer_zerop (c) ? $7 : $5;\n\t\t}\n      | TYPES_COMPATIBLE_P '(' typename ',' typename ')'\n\t\t{\n\t\t  tree e1, e2;\n\n\t\t  e1 = TYPE_MAIN_VARIANT (groktypename ($3));\n\t\t  e2 = TYPE_MAIN_VARIANT (groktypename ($5));\n\n\t\t  $$ = comptypes (e1, e2, COMPARE_STRICT)\n\t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n\t\t}\n\t| primary '\u00dd' expr '\u00a8'   %prec '.'\n\t\t{ $$ = build_array_ref ($1, $3); }\n\t| primary '.' identifier\n\t\t{\n@@ifobjc\n\t\t    if (!is_public ($1, $3))\n\t\t      $$ = error_mark_node;\n\t\t    else\n@@end_ifobjc\n\t\t      $$ = build_component_ref ($1, $3);\n\t\t}\n\t| primary POINTSAT identifier\n\t\t{\n                  tree expr = build_indirect_ref ($1, \"->\");\n\n@@ifobjc\n\t\t      if (!is_public (expr, $3))\n\t\t\t$$ = error_mark_node;\n\t\t      else\n@@end_ifobjc\n\t\t\t$$ = build_component_ref (expr, $3);\n\t\t}\n\t| primary PLUSPLUS\n\t\t{ $$ = build_unary_op (POSTINCREMENT_EXPR, $1, 0); }\n\t| primary MINUSMINUS\n\t\t{ $$ = build_unary_op (POSTDECREMENT_EXPR, $1, 0); }\n@@ifobjc\n\t| objcmessageexpr\n\t\t{ $$ = build_message_expr ($1); }\n\t| objcselectorexpr\n\t\t{ $$ = build_selector_expr ($1); }\n\t| objcprotocolexpr\n\t\t{ $$ = build_protocol_expr ($1); }\n\t| objcencodeexpr\n\t\t{ $$ = build_encode_expr ($1); }\n\t| OBJC_STRING\n\t\t{ $$ = build_objc_string_object ($1); }\n@@end_ifobjc\n\t;\n\nold_style_parm_decls:\n\told_style_parm_decls_1\n\t{\n\t  parsing_iso_function_signature = false; /* Reset after decls.  */\n\t}\n\t;\n\nold_style_parm_decls_1:\n\t/* empty */\n\t{\n\t  if (warn_traditional && !in_system_header\n\t      && parsing_iso_function_signature)\n\t    warning (\"traditional C rejects ISO C style function definitions\");\n\t  if (warn_old_style_definition && !in_system_header\n\t      && !parsing_iso_function_signature)\n\t    warning (\"old-style parameter declaration\");\n\t  parsing_iso_function_signature = false; /* Reset after warning.  */\n\t}\n\t| datadecls\n\t{\n\t  if (warn_old_style_definition && !in_system_header)\n\t    warning (\"old-style parameter declaration\");\n\t}\n\t;\n\n/* The following are analogous to lineno_decl, decls and decl\n   except that they do not allow nested functions.\n   They are used for old-style parm decls.  */\nlineno_datadecl:\n\t  save_location datadecl\n\t\t{ }\n\t;\n\ndatadecls:\n\tlineno_datadecl\n\t| errstmt\n\t| datadecls lineno_datadecl\n\t| lineno_datadecl errstmt\n\t;\n\n/* We don't allow prefix attributes here because they cause reduce/reduce\n   conflicts: we can't know whether we're parsing a function decl with\n   attribute suffix, or function defn with attribute prefix on first old\n   style parm.  */\ndatadecl:\n\tdeclspecs_ts_nosa setspecs initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_nots_nosa setspecs notype_initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_ts_nosa ';'\n\t\t{ shadow_tag_warned ($1, 1);\n\t\t  pedwarn (\"empty declaration\"); }\n\t| declspecs_nots_nosa ';'\n\t\t{ pedwarn (\"empty declaration\"); }\n\t;\n\n/* This combination which saves a lineno before a decl\n   is the normal thing to use, rather than decl itself.\n   This is to avoid shift/reduce conflicts in contexts\n   where statement labels are allowed.  */\nlineno_decl:\n\t  save_location decl\n\t\t{ }\n\t;\n\n/* records the type and storage class specs to use for processing\n   the declarators that follow.\n   Maintains a stack of outer-level values of current_declspecs,\n   for the sake of parm declarations nested in function declarators.  */\nsetspecs: /* empty */\n\t\t{ pending_xref_error ();\n\t\t  PUSH_DECLSPEC_STACK;\n\t\t  split_specs_attrs ($<ttype>0,\n\t\t\t\t     &current_declspecs, &prefix_attributes);\n\t\t  all_prefix_attributes = prefix_attributes; }\n\t;\n\n/* Possibly attributes after a comma, which should reset all_prefix_attributes\n   to prefix_attributes with these ones chained on the front.  */\nmaybe_resetattrs:\n\t  maybe_attribute\n\t\t{ all_prefix_attributes = chainon ($1, prefix_attributes); }\n\t;\n\ndecl:\n\tdeclspecs_ts setspecs initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_nots setspecs notype_initdecls ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_ts setspecs nested_function\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_nots setspecs notype_nested_function\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs ';'\n\t\t{ shadow_tag ($1); }\n\t| extension decl\n\t\t{ RESTORE_EXT_FLAGS ($1); }\n\t;\n\n/* A list of declaration specifiers.  These are:\n\n   - Storage class specifiers (scspec), which for GCC currently includes\n   function specifiers (\"inline\").\n\n   - Type specifiers (typespec_*).\n\n   - Type qualifiers (TYPE_QUAL).\n\n   - Attribute specifier lists (attributes).\n\n   These are stored as a TREE_LIST; the head of the list is the last\n   item in the specifier list.  Each entry in the list has either a\n   TREE_PURPOSE that is an attribute specifier list, or a TREE_VALUE that\n   is a single other specifier or qualifier; and a TREE_CHAIN that is the\n   rest of the list.  TREE_STATIC is set on the list if something other\n   than a storage class specifier or attribute has been seen; this is used\n   to warn for the obsolescent usage of storage class specifiers other than\n   at the start of the list.  (Doing this properly would require function\n   specifiers to be handled separately from storage class specifiers.)\n\n   The various cases below are classified according to:\n\n   (a) Whether a storage class specifier is included or not; some\n   places in the grammar disallow storage class specifiers (_sc or _nosc).\n\n   (b) Whether a type specifier has been seen; after a type specifier,\n   a typedef name is an identifier to redeclare (_ts or _nots).\n\n   (c) Whether the list starts with an attribute; in certain places,\n   the grammar requires specifiers that don't start with an attribute\n   (_sa or _nosa).\n\n   (d) Whether the list ends with an attribute (or a specifier such that\n   any following attribute would have been parsed as part of that specifier);\n   this avoids shift-reduce conflicts in the parsing of attributes\n   (_ea or _noea).\n\n   TODO:\n\n   (i) Distinguish between function specifiers and storage class specifiers,\n   at least for the purpose of warnings about obsolescent usage.\n\n   (ii) Halve the number of productions here by eliminating the _sc/_nosc\n   distinction and instead checking where required that storage class\n   specifiers aren't present.  */\n\n/* Declspecs which contain at least one type specifier or typedef name.\n   (Just `const' or `volatile' is not enough.)\n   A typedef'd name following these is taken as a name to be declared.\n   Declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n\ndeclspecs_nosc_nots_nosa_noea:\n\t  TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_nosc_nots_nosa_ea:\n\t  declspecs_nosc_nots_nosa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_nosc_nots_sa_noea:\n\t  declspecs_nosc_nots_sa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_nosc_nots_sa_ea:\n\t  attributes\n\t\t{ $$ = tree_cons ($1, NULL_TREE, NULL_TREE);\n\t\t  TREE_STATIC ($$) = 0; }\n\t| declspecs_nosc_nots_sa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_nosc_ts_nosa_noea:\n\t  typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_noea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_ea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_noea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_ea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_nosc_ts_nosa_ea:\n\t  typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_ts_nosa_noea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_ea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_noea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_ea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_nosc_ts_sa_noea:\n\t  declspecs_nosc_ts_sa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_sa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_sa_noea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_sa_ea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_noea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_ea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_nosc_ts_sa_ea:\n\t  declspecs_nosc_ts_sa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_ts_sa_noea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_sa_ea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_noea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_ea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_sc_nots_nosa_noea:\n\t  scspec\n\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);\n\t\t  TREE_STATIC ($$) = 0; }\n\t| declspecs_sc_nots_nosa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_nosa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_nosa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_nots_nosa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_nots_nosa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_nots_nosa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_nots_nosa_ea:\n\t  declspecs_sc_nots_nosa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_nots_sa_noea:\n\t  declspecs_sc_nots_sa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_sa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_nots_sa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_nots_sa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_nots_sa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_nots_sa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_nots_sa_ea:\n\t  declspecs_sc_nots_sa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_ts_nosa_noea:\n\t  declspecs_sc_ts_nosa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_nosa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_nosa_noea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_nosa_ea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_nosa_noea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_nosa_ea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_nosa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_ts_nosa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_nosa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_nosa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_ts_nosa_ea:\n\t  declspecs_sc_ts_nosa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_nosa_noea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_nosa_ea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_nosa_noea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_nosa_ea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\ndeclspecs_sc_ts_sa_noea:\n\t  declspecs_sc_ts_sa_noea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_sa_ea TYPE_QUAL\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_sa_noea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_sa_ea typespec_reserved_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_sa_noea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_sa_ea typespec_nonattr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_nosc_ts_sa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_nosc_ts_sa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_sa_noea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_sa_ea scspec\n\t\t{ if (extra_warnings && TREE_STATIC ($1))\n\t\t    warning (\"`%s' is not at beginning of declaration\",\n\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t;\n\ndeclspecs_sc_ts_sa_ea:\n\t  declspecs_sc_ts_sa_noea attributes\n\t\t{ $$ = tree_cons ($2, NULL_TREE, $1);\n\t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n\t| declspecs_sc_ts_sa_noea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_ts_sa_ea typespec_reserved_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_sa_noea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t| declspecs_sc_nots_sa_ea typespec_attr\n\t\t{ $$ = tree_cons (NULL_TREE, $2, $1);\n\t\t  TREE_STATIC ($$) = 1; }\n\t;\n\n/* Particular useful classes of declspecs.  */\ndeclspecs_ts:\n\t  declspecs_nosc_ts_nosa_noea\n\t| declspecs_nosc_ts_nosa_ea\n\t| declspecs_nosc_ts_sa_noea\n\t| declspecs_nosc_ts_sa_ea\n\t| declspecs_sc_ts_nosa_noea\n\t| declspecs_sc_ts_nosa_ea\n\t| declspecs_sc_ts_sa_noea\n\t| declspecs_sc_ts_sa_ea\n\t;\n\ndeclspecs_nots:\n\t  declspecs_nosc_nots_nosa_noea\n\t| declspecs_nosc_nots_nosa_ea\n\t| declspecs_nosc_nots_sa_noea\n\t| declspecs_nosc_nots_sa_ea\n\t| declspecs_sc_nots_nosa_noea\n\t| declspecs_sc_nots_nosa_ea\n\t| declspecs_sc_nots_sa_noea\n\t| declspecs_sc_nots_sa_ea\n\t;\n\ndeclspecs_ts_nosa:\n\t  declspecs_nosc_ts_nosa_noea\n\t| declspecs_nosc_ts_nosa_ea\n\t| declspecs_sc_ts_nosa_noea\n\t| declspecs_sc_ts_nosa_ea\n\t;\n\ndeclspecs_nots_nosa:\n\t  declspecs_nosc_nots_nosa_noea\n\t| declspecs_nosc_nots_nosa_ea\n\t| declspecs_sc_nots_nosa_noea\n\t| declspecs_sc_nots_nosa_ea\n\t;\n\ndeclspecs_nosc_ts:\n\t  declspecs_nosc_ts_nosa_noea\n\t| declspecs_nosc_ts_nosa_ea\n\t| declspecs_nosc_ts_sa_noea\n\t| declspecs_nosc_ts_sa_ea\n\t;\n\ndeclspecs_nosc_nots:\n\t  declspecs_nosc_nots_nosa_noea\n\t| declspecs_nosc_nots_nosa_ea\n\t| declspecs_nosc_nots_sa_noea\n\t| declspecs_nosc_nots_sa_ea\n\t;\n\ndeclspecs_nosc:\n\t  declspecs_nosc_ts_nosa_noea\n\t| declspecs_nosc_ts_nosa_ea\n\t| declspecs_nosc_ts_sa_noea\n\t| declspecs_nosc_ts_sa_ea\n\t| declspecs_nosc_nots_nosa_noea\n\t| declspecs_nosc_nots_nosa_ea\n\t| declspecs_nosc_nots_sa_noea\n\t| declspecs_nosc_nots_sa_ea\n\t;\n\ndeclspecs:\n\t  declspecs_nosc_nots_nosa_noea\n\t| declspecs_nosc_nots_nosa_ea\n\t| declspecs_nosc_nots_sa_noea\n\t| declspecs_nosc_nots_sa_ea\n\t| declspecs_nosc_ts_nosa_noea\n\t| declspecs_nosc_ts_nosa_ea\n\t| declspecs_nosc_ts_sa_noea\n\t| declspecs_nosc_ts_sa_ea\n\t| declspecs_sc_nots_nosa_noea\n\t| declspecs_sc_nots_nosa_ea\n\t| declspecs_sc_nots_sa_noea\n\t| declspecs_sc_nots_sa_ea\n\t| declspecs_sc_ts_nosa_noea\n\t| declspecs_sc_ts_nosa_ea\n\t| declspecs_sc_ts_sa_noea\n\t| declspecs_sc_ts_sa_ea\n\t;\n\n/* A (possibly empty) sequence of type qualifiers and attributes.  */\nmaybe_type_quals_attrs:\n\t  /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| declspecs_nosc_nots\n\t\t{ $$ = $1; }\n\t;\n\n/* A type specifier (but not a type qualifier).\n   Once we have seen one of these in a declaration,\n   if a typedef name appears then it is being redeclared.\n\n   The _reserved versions start with a reserved word and may appear anywhere\n   in the declaration specifiers; the _nonreserved versions may only\n   appear before any other type specifiers, and after that are (if names)\n   being redeclared.\n\n   FIXME: should the _nonreserved version be restricted to names being\n   redeclared only?  The other entries there relate only the GNU extensions\n   and Objective C, and are historically parsed thus, and don't make sense\n   after other type specifiers, but it might be cleaner to count them as\n   _reserved.\n\n   _attr means: specifiers that either end with attributes,\n   or are such that any following attributes would\n   be parsed as part of the specifier.\n\n   _nonattr: specifiers.  */\n\ntypespec_nonattr:\n\t  typespec_reserved_nonattr\n\t| typespec_nonreserved_nonattr\n\t;\n\ntypespec_attr:\n\t  typespec_reserved_attr\n\t;\n\ntypespec_reserved_nonattr:\n\t  TYPESPEC\n\t\t{ OBJC_NEED_RAW_IDENTIFIER (1);\t}\n\t| structsp_nonattr\n\t;\n\ntypespec_reserved_attr:\n\t  structsp_attr\n\t;\n\ntypespec_nonreserved_nonattr:\n\t  TYPENAME\n\t\t{ /* For a typedef name, record the meaning, not the name.\n\t\t     In case of `foo foo, bar;'.  */\n\t\t  $$ = lookup_name ($1); }\n@@ifobjc\n\t| CLASSNAME protocolrefs\n\t\t{ $$ = get_static_reference ($1, $2); }\n\t| OBJECTNAME protocolrefs\n\t\t{ $$ = get_object_reference ($2); }\n\n/* Make \"<SomeProtocol>\" equivalent to \"id <SomeProtocol>\"\n   - nisse@lysator.liu.se */\n        | non_empty_protocolrefs\n                { $$ = get_object_reference ($1); }\n@@end_ifobjc\n\t| typeof '(' expr ')'\n\t\t{ skip_evaluation--;\n\t\t  if (TREE_CODE ($3) == COMPONENT_REF\n\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($3, 1)))\n\t\t    error (\"`typeof' applied to a bit-field\");\n\t\t  $$ = TREE_TYPE ($3); }\n\t| typeof '(' typename ')'\n\t\t{ skip_evaluation--; $$ = groktypename ($3); }\n\t;\n\n/* typespec_nonreserved_attr does not exist.  */\n\ninitdecls:\n\tinitdcl\n\t| initdecls ',' maybe_resetattrs initdcl\n\t;\n\nnotype_initdecls:\n\tnotype_initdcl\n\t| notype_initdecls ',' maybe_resetattrs notype_initdcl\n\t;\n\nmaybeasm:\n\t  /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| ASM_KEYWORD '(' STRING ')'\n\t\t{ $$ = $3; }\n\t;\n\ninitdcl:\n\t  declarator maybeasm maybe_attribute '='\n\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n\t\t\t\t\t  chainon ($3, all_prefix_attributes));\n\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n\t  init\n/* Note how the declaration of the variable is in effect while its init is parsed! */\n\t\t{ finish_init ();\n\t\t  finish_decl ($<ttype>5, $6, $2); }\n\t| declarator maybeasm maybe_attribute\n\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n\t\t\t\t       chainon ($3, all_prefix_attributes));\n\t\t  finish_decl (d, NULL_TREE, $2);\n                }\n\t;\n\nnotype_initdcl:\n\t  notype_declarator maybeasm maybe_attribute '='\n\t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1,\n\t\t\t\t\t  chainon ($3, all_prefix_attributes));\n\t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n\t  init\n/* Note how the declaration of the variable is in effect while its init is parsed! */\n\t\t{ finish_init ();\n\t\t  finish_decl ($<ttype>5, $6, $2); }\n\t| notype_declarator maybeasm maybe_attribute\n\t\t{ tree d = start_decl ($1, current_declspecs, 0,\n\t\t\t\t       chainon ($3, all_prefix_attributes));\n\t\t  finish_decl (d, NULL_TREE, $2); }\n\t;\n/* the * rules are dummies to accept the Apollo extended syntax\n   so that the header files compile. */\nmaybe_attribute:\n      /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| attributes\n\t\t{ $$ = $1; }\n\t;\n\nattributes:\n      attribute\n\t\t{ $$ = $1; }\n\t| attributes attribute\n\t\t{ $$ = chainon ($1, $2); }\n\t;\n\nattribute:\n      ATTRIBUTE '(' '(' attribute_list ')' ')'\n\t\t{ $$ = $4; }\n\t;\n\nattribute_list:\n      attrib\n\t\t{ $$ = $1; }\n\t| attribute_list ',' attrib\n\t\t{ $$ = chainon ($1, $3); }\n\t;\n\nattrib:\n    /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| any_word\n\t\t{ $$ = build_tree_list ($1, NULL_TREE); }\n\t| any_word '(' IDENTIFIER ')'\n\t\t{ $$ = build_tree_list ($1, build_tree_list (NULL_TREE, $3)); }\n\t| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'\n\t\t{ $$ = build_tree_list ($1, tree_cons (NULL_TREE, $3, $5)); }\n\t| any_word '(' exprlist ')'\n\t\t{ $$ = build_tree_list ($1, $3); }\n\t;\n\n/* This still leaves out most reserved keywords,\n   shouldn't we include them?  */\n\nany_word:\n\t  identifier\n\t| scspec\n\t| TYPESPEC\n\t| TYPE_QUAL\n\t;\n\nscspec:\n\t  STATIC\n\t| SCSPEC\n\t;\n\n/* Initializers.  `init' is the entry point.  */\n\ninit:\n\texpr_no_commas\n\t| '{'\n\t\t{ really_start_incremental_init (NULL_TREE); }\n\t  initlist_maybe_comma '}'\n\t\t{ $$ = pop_init_level (0); }\n\t| error\n\t\t{ $$ = error_mark_node; }\n\t;\n\n/* `initlist_maybe_comma' is the guts of an initializer in braces.  */\ninitlist_maybe_comma:\n\t  /* empty */\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids empty initializer braces\"); }\n\t| initlist1 maybecomma\n\t;\n\ninitlist1:\n\t  initelt\n\t| initlist1 ',' initelt\n\t;\n\n/* `initelt' is a single element of an initializer.\n   It may use braces.  */\ninitelt:\n\t  designator_list '=' initval\n\t\t{ if (pedantic && ! flag_isoc99)\n\t\t    pedwarn (\"ISO C90 forbids specifying subobject to initialize\"); }\n\t| designator initval\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"obsolete use of designated initializer without `='\"); }\n\t| identifier ':'\n\t\t{ set_init_label ($1);\n\t\t  if (pedantic)\n\t\t    pedwarn (\"obsolete use of designated initializer with `:'\"); }\n\t  initval\n\t\t{}\n\t| initval\n\t;\n\ninitval:\n\t  '{'\n\t\t{ push_init_level (0); }\n\t  initlist_maybe_comma '}'\n\t\t{ process_init_element (pop_init_level (0)); }\n\t| expr_no_commas\n\t\t{ process_init_element ($1); }\n\t| error\n\t;\n\ndesignator_list:\n\t  designator\n\t| designator_list designator\n\t;\n\ndesignator:\n\t  '.' identifier\n\t\t{ set_init_label ($2); }\n\t| '\u00dd' expr_no_commas ELLIPSIS expr_no_commas '\u00a8'\n\t\t{ set_init_index ($2, $4);\n\t\t  if (pedantic)\n\t\t    pedwarn (\"ISO C forbids specifying range of elements to initialize\"); }\n\t| '\u00dd' expr_no_commas '\u00a8'\n\t\t{ set_init_index ($2, NULL_TREE); }\n\t;\n\nnested_function:\n\t  declarator\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids nested functions\");\n\n\t\t  push_function_context ();\n\t\t  if (! start_function (current_declspecs, $1,\n\t\t\t\t\tall_prefix_attributes))\n\t\t    {\n\t\t      pop_function_context ();\n\t\t      YYERROR1;\n\t\t    }\n\t\t  parsing_iso_function_signature = false; /* Don't warn about nested functions.  */\n\t\t}\n\t   old_style_parm_decls save_location\n\t\t{ tree decl = current_function_decl;\n\t\t  DECL_SOURCE_LOCATION (decl) = $4;\n\t\t  store_parm_decls (); }\n/* This used to use compstmt_or_error.\n   That caused a bug with input `f(g) int g {}',\n   where the use of YYERROR1 above caused an error\n   which then was handled by compstmt_or_error.\n   There followed a repeated execution of that same rule,\n   which called YYERROR1 again, and so on.  */\n\t  compstmt\n\t\t{ tree decl = current_function_decl;\n\t\t  finish_function ();\n\t\t  pop_function_context ();\n\t\t  add_decl_stmt (decl); }\n\t;\n\nnotype_nested_function:\n\t  notype_declarator\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids nested functions\");\n\n\t\t  push_function_context ();\n\t\t  if (! start_function (current_declspecs, $1,\n\t\t\t\t\tall_prefix_attributes))\n\t\t    {\n\t\t      pop_function_context ();\n\t\t      YYERROR1;\n\t\t    }\n\t\t  parsing_iso_function_signature = false; /* Don't warn about nested functions.  */\n\t\t}\n\t  old_style_parm_decls save_location\n\t\t{ tree decl = current_function_decl;\n\t\t  DECL_SOURCE_LOCATION (decl) = $4;\n\t\t  store_parm_decls (); }\n/* This used to use compstmt_or_error.\n   That caused a bug with input `f(g) int g {}',\n   where the use of YYERROR1 above caused an error\n   which then was handled by compstmt_or_error.\n   There followed a repeated execution of that same rule,\n   which called YYERROR1 again, and so on.  */\n\t  compstmt\n\t\t{ tree decl = current_function_decl;\n\t\t  finish_function ();\n\t\t  pop_function_context ();\n\t\t  add_decl_stmt (decl); }\n\t;\n\n/* Any kind of declarator (thus, all declarators allowed\n   after an explicit typespec).  */\n\ndeclarator:\n\t  after_type_declarator\n\t| notype_declarator\n\t;\n\n/* A declarator that is allowed only after an explicit typespec.  */\n\nafter_type_declarator:\n\t  '(' maybe_attribute after_type_declarator ')'\n\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n\t| after_type_declarator '(' parmlist_or_identifiers  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n/*\t| after_type_declarator '(' error ')'  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n\t\t  poplevel (0, 0, 0); }  */\n\t| after_type_declarator array_declarator  %prec '.'\n\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n\t| '*' maybe_type_quals_attrs after_type_declarator  %prec UNARY\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t| TYPENAME\n@@ifobjc\n\t| OBJECTNAME\n@@end_ifobjc\n\t;\n\n/* Kinds of declarator that can appear in a parameter list\n   in addition to notype_declarator.  This is like after_type_declarator\n   but does not allow a typedef name in parentheses as an identifier\n   (because it would conflict with a function with that typedef as arg).  */\nparm_declarator:\n\t  parm_declarator_starttypename\n\t| parm_declarator_nostarttypename\n\t;\n\nparm_declarator_starttypename:\n\t  parm_declarator_starttypename '(' parmlist_or_identifiers  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n/*\t| parm_declarator_starttypename '(' error ')'  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n\t\t  poplevel (0, 0, 0); }  */\n\t| parm_declarator_starttypename array_declarator  %prec '.'\n\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n\t| TYPENAME\n@@ifobjc\n\t| OBJECTNAME\n@@end_ifobjc\n\t;\n\nparm_declarator_nostarttypename:\n\t  parm_declarator_nostarttypename '(' parmlist_or_identifiers  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n/*\t| parm_declarator_nostarttypename '(' error ')'  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n\t\t  poplevel (0, 0, 0); }  */\n\t| parm_declarator_nostarttypename array_declarator  %prec '.'\n\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n\t| '*' maybe_type_quals_attrs parm_declarator_starttypename  %prec UNARY\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t| '*' maybe_type_quals_attrs parm_declarator_nostarttypename  %prec UNARY\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t| '(' maybe_attribute parm_declarator_nostarttypename ')'\n\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n\t;\n\n/* A declarator allowed whether or not there has been\n   an explicit typespec.  These cannot redeclare a typedef-name.  */\n\nnotype_declarator:\n\t  notype_declarator '(' parmlist_or_identifiers  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n/*\t| notype_declarator '(' error ')'  %prec '.'\n\t\t{ $$ = build_nt (CALL_EXPR, $1, NULL_TREE, NULL_TREE);\n\t\t  poplevel (0, 0, 0); }  */\n\t| '(' maybe_attribute notype_declarator ')'\n\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n\t| '*' maybe_type_quals_attrs notype_declarator  %prec UNARY\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t| notype_declarator array_declarator  %prec '.'\n\t\t{ $$ = set_array_declarator_type ($2, $1, 0); }\n\t| IDENTIFIER\n\t;\n\nstruct_head:\n\t  STRUCT\n\t\t{ $$ = NULL_TREE; }\n\t| STRUCT attributes\n\t\t{ $$ = $2; }\n\t;\n\nunion_head:\n\t  UNION\n\t\t{ $$ = NULL_TREE; }\n\t| UNION attributes\n\t\t{ $$ = $2; }\n\t;\n\nenum_head:\n\t  ENUM\n\t\t{ $$ = NULL_TREE; }\n\t| ENUM attributes\n\t\t{ $$ = $2; }\n\t;\n\n/* structsp_attr: struct/union/enum specifiers that either\n   end with attributes, or are such that any following attributes would\n   be parsed as part of the struct/union/enum specifier.\n\n   structsp_nonattr: other struct/union/enum specifiers.  */\n\nstructsp_attr:\n\t  struct_head identifier '{'\n\t\t{ $$ = start_struct (RECORD_TYPE, $2);\n\t\t  /* Start scope of tag before parsing components.  */\n\t\t}\n\t  component_decl_list '}' maybe_attribute\n\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n\t\t\t\t      chainon ($1, $7)); }\n\t| struct_head '{' component_decl_list '}' maybe_attribute\n\t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n\t\t\t\t      nreverse ($3), chainon ($1, $5));\n\t\t}\n\t| union_head identifier '{'\n\t\t{ $$ = start_struct (UNION_TYPE, $2); }\n\t  component_decl_list '}' maybe_attribute\n\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n\t\t\t\t      chainon ($1, $7)); }\n\t| union_head '{' component_decl_list '}' maybe_attribute\n\t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n\t\t\t\t      nreverse ($3), chainon ($1, $5));\n\t\t}\n\t| enum_head identifier '{'\n\t\t{ $$ = start_enum ($2); }\n\t  enumlist maybecomma_warn '}' maybe_attribute\n\t\t{ $$ = finish_enum ($<ttype>4, nreverse ($5),\n\t\t\t\t    chainon ($1, $8)); }\n\t| enum_head '{'\n\t\t{ $$ = start_enum (NULL_TREE); }\n\t  enumlist maybecomma_warn '}' maybe_attribute\n\t\t{ $$ = finish_enum ($<ttype>3, nreverse ($4),\n\t\t\t\t    chainon ($1, $7)); }\n\t;\n\nstructsp_nonattr:\n\t  struct_head identifier\n\t\t{ $$ = xref_tag (RECORD_TYPE, $2); }\n\t| union_head identifier\n\t\t{ $$ = xref_tag (UNION_TYPE, $2); }\n\t| enum_head identifier\n\t\t{ $$ = xref_tag (ENUMERAL_TYPE, $2);\n\t\t  /* In ISO C, enumerated types can be referred to\n\t\t     only if already defined.  */\n\t\t  if (pedantic && !COMPLETE_TYPE_P ($$))\n\t\t    pedwarn (\"ISO C forbids forward references to `enum' types\"); }\n\t;\n\nmaybecomma:\n\t  /* empty */\n\t| ','\n\t;\n\nmaybecomma_warn:\n\t  /* empty */\n\t| ','\n\t\t{ if (pedantic && ! flag_isoc99)\n\t\t    pedwarn (\"comma at end of enumerator list\"); }\n\t;\n\n/* We chain the components in reverse order.  They are put in forward\n   order in structsp_attr.\n\n   Note that component_declarator returns single decls, so components\n   and components_notype can use TREE_CHAIN directly, wheras components\n   and components_notype return lists (of comma separated decls), so\n   component_decl_list and component_decl_list2 must use chainon.\n\n   The theory behind all this is that there will be more semicolon\n   separated fields than comma separated fields, and so we'll be\n   minimizing the number of node traversals required by chainon.  */\n\ncomponent_decl_list:\n\t  component_decl_list2\n\t\t{ $$ = $1; }\n\t| component_decl_list2 component_decl\n\t\t{ $$ = chainon ($2, $1);\n\t\t  pedwarn (\"no semicolon at end of struct or union\"); }\n\t;\n\ncomponent_decl_list2:\t/* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| component_decl_list2 component_decl ';'\n\t\t{ $$ = chainon ($2, $1); }\n\t| component_decl_list2 ';'\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"extra semicolon in struct or union specified\"); }\n@@ifobjc\n\t/* foo(sizeof(struct{ @defs(ClassName)})); */\n\t| DEFS '(' CLASSNAME ')'\n\t\t{ $$ = nreverse (get_class_ivars_from_name ($3)); }\n@@end_ifobjc\n\t;\n\ncomponent_decl:\n\t  declspecs_nosc_ts setspecs components\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nosc_ts setspecs\n\t\t{\n\t\t  /* Support for unnamed structs or unions as members of\n\t\t     structs or unions (which is \u00dda\u00a8 useful and \u00ddb\u00a8 supports\n\t\t     MS P-SDK).  */\n\t\t  if (pedantic)\n\t\t    pedwarn (\"ISO C doesn't support unnamed structs/unions\");\n\n\t\t  $$ = grokfield(NULL, current_declspecs, NULL_TREE);\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nosc_nots setspecs components_notype\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nosc_nots\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids member declarations with no members\");\n\t\t  shadow_tag_warned ($1, pedantic);\n\t\t  $$ = NULL_TREE; }\n\t| error\n\t\t{ $$ = NULL_TREE; }\n\t| extension component_decl\n\t\t{ $$ = $2;\n\t\t  RESTORE_EXT_FLAGS ($1); }\n\t;\n\ncomponents:\n\t  component_declarator\n\t| components ',' maybe_resetattrs component_declarator\n\t\t{ TREE_CHAIN ($4) = $1; $$ = $4; }\n\t;\n\ncomponents_notype:\n\t  component_notype_declarator\n\t| components_notype ',' maybe_resetattrs component_notype_declarator\n\t\t{ TREE_CHAIN ($4) = $1; $$ = $4; }\n\t;\n\ncomponent_declarator:\n\t  declarator maybe_attribute\n\t\t{ $$ = grokfield ($1, current_declspecs, NULL_TREE);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($2, all_prefix_attributes), 0); }\n\t| declarator ':' expr_no_commas maybe_attribute\n\t\t{ $$ = grokfield ($1, current_declspecs, $3);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n\t| ':' expr_no_commas maybe_attribute\n\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n\t;\n\ncomponent_notype_declarator:\n\t  notype_declarator maybe_attribute\n\t\t{ $$ = grokfield ($1, current_declspecs, NULL_TREE);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($2, all_prefix_attributes), 0); }\n\t| notype_declarator ':' expr_no_commas maybe_attribute\n\t\t{ $$ = grokfield ($1, current_declspecs, $3);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n\t| ':' expr_no_commas maybe_attribute\n\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2);\n\t\t  decl_attributes (&$$,\n\t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n\t;\n\n/* We chain the enumerators in reverse order.\n   They are put in forward order in structsp_attr.  */\n\nenumlist:\n\t  enumerator\n\t| enumlist ',' enumerator\n\t\t{ if ($1 == error_mark_node)\n\t\t    $$ = $1;\n\t\t  else\n\t\t    TREE_CHAIN ($3) = $1, $$ = $3; }\n\t| error\n\t\t{ $$ = error_mark_node; }\n\t;\n\n\nenumerator:\n\t  identifier\n\t\t{ $$ = build_enumerator ($1, NULL_TREE); }\n\t| identifier '=' expr_no_commas\n\t\t{ $$ = build_enumerator ($1, $3); }\n\t;\n\ntypename:\n\t  declspecs_nosc\n\t\t{ pending_xref_error ();\n\t\t  $<ttype>$ = $1; }\n\t  absdcl\n\t\t{ $$ = build_tree_list ($<ttype>2, $3); }\n\t;\n\nabsdcl:   /* an absolute declarator */\n\t/* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| absdcl1\n\t;\n\nabsdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */\n\t/* empty */\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t NULL_TREE),\n\t\t\t\t\tall_prefix_attributes); }\n\t| absdcl1\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $1),\n\t\t\t\t\tall_prefix_attributes); }\n\t| absdcl1_noea attributes\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $1),\n\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n\t;\n\nabsdcl1:  /* a nonempty absolute declarator */\n\t  absdcl1_ea\n\t| absdcl1_noea\n\t;\n\nabsdcl1_noea:\n\t  direct_absdcl1\n\t| '*' maybe_type_quals_attrs absdcl1_noea\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t;\n\nabsdcl1_ea:\n\t  '*' maybe_type_quals_attrs\n\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n\t| '*' maybe_type_quals_attrs absdcl1_ea\n\t\t{ $$ = make_pointer_declarator ($2, $3); }\n\t;\n\ndirect_absdcl1:\n\t  '(' maybe_attribute absdcl1 ')'\n\t\t{ $$ = $2 ? tree_cons ($2, $3, NULL_TREE) : $3; }\n\t| direct_absdcl1 '(' parmlist\n\t\t{ $$ = build_nt (CALL_EXPR, $1, $3, NULL_TREE); }\n\t| direct_absdcl1 array_declarator\n\t\t{ $$ = set_array_declarator_type ($2, $1, 1); }\n\t| '(' parmlist\n\t\t{ $$ = build_nt (CALL_EXPR, NULL_TREE, $2, NULL_TREE); }\n\t| array_declarator\n\t\t{ $$ = set_array_declarator_type ($1, NULL_TREE, 1); }\n\t;\n\n/* The \u00dd...\u00a8 part of a declarator for an array type.  */\n\narray_declarator:\n\t'\u00dd' maybe_type_quals_attrs expr_no_commas '\u00a8'\n\t\t{ $$ = build_array_declarator ($3, $2, 0, 0); }\n\t| '\u00dd' maybe_type_quals_attrs '\u00a8'\n\t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 0); }\n\t| '\u00dd' maybe_type_quals_attrs '*' '\u00a8'\n\t\t{ $$ = build_array_declarator (NULL_TREE, $2, 0, 1); }\n\t| '\u00dd' STATIC maybe_type_quals_attrs expr_no_commas '\u00a8'\n\t\t{ $$ = build_array_declarator ($4, $3, 1, 0); }\n\t/* declspecs_nosc_nots is a synonym for type_quals_attrs.  */\n\t| '\u00dd' declspecs_nosc_nots STATIC expr_no_commas '\u00a8'\n\t\t{ $$ = build_array_declarator ($4, $2, 1, 0); }\n\t;\n\n/* A nonempty series of declarations and statements (possibly followed by\n   some labels) that can form the body of a compound statement.\n   NOTE: we don't allow labels on declarations; this might seem like a\n   natural extension, but there would be a conflict between attributes\n   on the label and prefix attributes on the declaration.  */\n\nstmts_and_decls:\n\t  lineno_stmt_decl_or_labels_ending_stmt\n\t| lineno_stmt_decl_or_labels_ending_decl\n\t| lineno_stmt_decl_or_labels_ending_label\n\t\t{\n\t\t  error (\"label at end of compound statement\");\n\t\t}\n\t| lineno_stmt_decl_or_labels_ending_error\n\t;\n\nlineno_stmt_decl_or_labels_ending_stmt:\n\t  lineno_stmt\n\t| lineno_stmt_decl_or_labels_ending_stmt lineno_stmt\n\t| lineno_stmt_decl_or_labels_ending_decl lineno_stmt\n\t| lineno_stmt_decl_or_labels_ending_label lineno_stmt\n\t| lineno_stmt_decl_or_labels_ending_error lineno_stmt\n\t;\n\nlineno_stmt_decl_or_labels_ending_decl:\n\t  lineno_decl\n\t| lineno_stmt_decl_or_labels_ending_stmt lineno_decl\n\t\t{\n\t\t  if ((pedantic && !flag_isoc99)\n\t\t      || warn_declaration_after_statement)\n\t\t    pedwarn_c90 (\"ISO C90 forbids mixed declarations and code\");\n\t\t}\n\t| lineno_stmt_decl_or_labels_ending_decl lineno_decl\n\t| lineno_stmt_decl_or_labels_ending_error lineno_decl\n\t;\n\nlineno_stmt_decl_or_labels_ending_label:\n\t  lineno_label\n\t| lineno_stmt_decl_or_labels_ending_stmt lineno_label\n\t| lineno_stmt_decl_or_labels_ending_decl lineno_label\n\t| lineno_stmt_decl_or_labels_ending_label lineno_label\n\t| lineno_stmt_decl_or_labels_ending_error lineno_label\n\t;\n\nlineno_stmt_decl_or_labels_ending_error:\n\terrstmt\n\t| lineno_stmt_decl_or_labels errstmt\n\t;\n\nlineno_stmt_decl_or_labels:\n\t  lineno_stmt_decl_or_labels_ending_stmt\n\t| lineno_stmt_decl_or_labels_ending_decl\n\t| lineno_stmt_decl_or_labels_ending_label\n\t| lineno_stmt_decl_or_labels_ending_error\n\t;\n\nerrstmt:  error ';'\n\t;\n\npushlevel:  /* empty */\n\t\t{ pushlevel (0);\n\t\t  clear_last_expr ();\n\t\t  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n\t\t}\n\t;\n\npoplevel:  /* empty */\n                {\n@@ifobjc\n\t\t  if (c_dialect_objc ())\n\t\t    objc_clear_super_receiver ();\n@@end_ifobjc\n\t\t  $$ = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n\t\t}\n        ;\n\n/* Start and end blocks created for the new scopes of C99.  */\nc99_block_start: /* empty */\n\t\t{ if (flag_isoc99)\n\t\t    {\n\t\t      $$ = c_begin_compound_stmt ();\n\t\t      pushlevel (0);\n\t\t      clear_last_expr ();\n\t\t      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n\t\t    }\n\t\t  else\n\t\t    $$ = NULL_TREE;\n\t\t}\n\t;\n\n/* Productions using c99_block_start and c99_block_end will need to do what's\n   in compstmt: RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); $$ = $2; where\n   $1 is the value of c99_block_start and $2 of c99_block_end.  */\nc99_block_end: /* empty */\n                { if (flag_isoc99)\n\t\t    {\n\t\t      tree scope_stmt = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n\t\t      $$ = poplevel (KEEP_MAYBE, 0, 0);\n\t\t      SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmt))\n\t\t\t= SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmt))\n\t\t\t= $$;\n\t\t    }\n\t\t  else\n\t\t    $$ = NULL_TREE; }\n\t;\n\n/* Read zero or more forward-declarations for labels\n   that nested functions can jump to.  */\nmaybe_label_decls:\n\t  /* empty */\n\t| label_decls\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids label declarations\"); }\n\t;\n\nlabel_decls:\n\t  label_decl\n\t| label_decls label_decl\n\t;\n\nlabel_decl:\n\t  LABEL identifiers_or_typenames ';'\n\t\t{ tree link;\n\t\t  for (link = $2; link; link = TREE_CHAIN (link))\n\t\t    {\n\t\t      tree label = declare_label (TREE_VALUE (link));\n\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n\t\t      add_decl_stmt (label);\n\t\t    }\n\t\t}\n\t;\n\n/* This is the body of a function definition.\n   It causes syntax errors to ignore to the next openbrace.  */\ncompstmt_or_error:\n\t  compstmt\n\t\t{}\n\t| error compstmt\n\t;\n\ncompstmt_start: '{' { compstmt_count++;\n                      $$ = c_begin_compound_stmt (); }\n        ;\n\ncompstmt_nostart: '}'\n\t\t{ $$ = convert (void_type_node, integer_zero_node); }\n\t| pushlevel maybe_label_decls compstmt_contents_nonempty '}' poplevel\n\t\t{ $$ = poplevel (KEEP_MAYBE, 0, 0);\n\t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5))\n\t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n\t\t    = $$; }\n\t;\n\ncompstmt_contents_nonempty:\n\t  stmts_and_decls\n\t| error\n\t;\n\ncompstmt_primary_start:\n\t'(' '{'\n\t\t{ if (last_tree == NULL)\n\t\t    {\n\t\t      error (\"braced-group within expression allowed only inside a function\");\n\t\t      YYERROR;\n\t\t    }\n\t\t  /* We must force a BLOCK for this level\n\t\t     so that, if it is not expanded later,\n\t\t     there is a way to turn off the entire subtree of blocks\n\t\t     that are contained in it.  */\n\t\t  keep_next_level ();\n\t\t  compstmt_count++;\n\t\t  $$ = add_stmt (build_stmt (COMPOUND_STMT, last_tree));\n\t\t  last_expr_type = NULL_TREE;\n\t\t}\n        ;\n\ncompstmt: compstmt_start compstmt_nostart\n\t\t{ RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n\t\t  last_expr_type = NULL_TREE;\n                  $$ = $1; }\n\t;\n\n/* Value is number of statements counted as of the closeparen.  */\nsimple_if:\n\t  if_prefix c99_block_lineno_labeled_stmt\n                { c_finish_then (); }\n/* Make sure c_expand_end_cond is run once\n   for each call to c_expand_start_cond.\n   Otherwise a crash is likely.  */\n\t| if_prefix error\n\t;\n\nif_prefix:\n\t  /* We must build the IF_STMT node before parsing its\n\t     condition so that STMT_LINENO refers to the line\n\t     containing the \"if\", and not the line containing\n\t     the close-parenthesis.\n\n\t     c_begin_if_stmt returns the IF_STMT node, which\n\t     we later pass to c_expand_start_cond to fill\n\t     in the condition and other tidbits.  */\n          IF\n                { $<ttype>$ = c_begin_if_stmt (); }\n            '(' expr ')'\n\t\t{ c_expand_start_cond (c_common_truthvalue_conversion ($4),\n\t\t\t\t       compstmt_count,$<ttype>2);\n\t\t  $<itype>$ = stmt_count;\n\t\t  if_stmt_locus = $<location>-1; }\n        ;\n\n/* This is a subroutine of stmt.\n   It is used twice, once for valid DO statements\n   and once for catching errors in parsing the end test.  */\ndo_stmt_start:\n\t  DO\n\t\t{ stmt_count++;\n\t\t  compstmt_count++;\n\t\t  c_in_iteration_stmt++;\n\t\t  $<ttype>$\n\t\t    = add_stmt (build_stmt (DO_STMT, NULL_TREE,\n\t\t\t\t\t    NULL_TREE));\n\t\t  /* In the event that a parse error prevents\n\t\t     parsing the complete do-statement, set the\n\t\t     condition now.  Otherwise, we can get crashes at\n\t\t     RTL-generation time.  */\n\t\t  DO_COND ($<ttype>$) = error_mark_node; }\n\t  c99_block_lineno_labeled_stmt WHILE\n\t\t{ $$ = $<ttype>2;\n\t\t  RECHAIN_STMTS ($$, DO_BODY ($$));\n\t\t  c_in_iteration_stmt--; }\n\t;\n\n/* The forced readahead in here is because we might be at the end of a\n   line, and the line and file won't be bumped until yylex absorbs the\n   first token on the next line.  */\n\nsave_location:\n\t\t{ if (yychar == YYEMPTY)\n\t\t    yychar = YYLEX;\n\t\t  $$ = input_location; }\n\t;\n\nlineno_labeled_stmt:\n\t  lineno_stmt\n\t| lineno_label lineno_labeled_stmt\n\t;\n\n/* Like lineno_labeled_stmt, but a block in C99.  */\nc99_block_lineno_labeled_stmt:\n\t  c99_block_start lineno_labeled_stmt c99_block_end\n\t\t{ if (flag_isoc99)\n\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1)); }\n\t;\n\nlineno_stmt:\n\t  save_location stmt\n\t\t{ if ($2)\n\t\t    {\n\t\t      STMT_LINENO ($2) = $1.line;\n\t\t      /* ??? We currently have no way of recording\n\t\t\t the filename for a statement.  This probably\n\t\t\t matters little in practice at the moment,\n\t\t\t but I suspect that problems will occur when\n\t\t\t doing inlining at the tree level.  */\n\t\t    }\n\t\t}\n\t;\n\nlineno_label:\n\t  save_location label\n\t\t{ if ($2)\n\t\t    {\n\t\t      STMT_LINENO ($2) = $1.line;\n\t\t    }\n\t\t}\n\t;\n\nselect_or_iter_stmt:\n\t  simple_if ELSE\n\t\t{ c_expand_start_else ();\n\t\t  $<itype>1 = stmt_count; }\n\t  c99_block_lineno_labeled_stmt\n                { c_finish_else ();\n\t\t  c_expand_end_cond ();\n\t\t  if (extra_warnings && stmt_count == $<itype>1)\n\t\t    warning (\"empty body in an else-statement\"); }\n\t| simple_if %prec IF\n\t\t{ c_expand_end_cond ();\n\t\t  /* This warning is here instead of in simple_if, because we\n\t\t     do not want a warning if an empty if is followed by an\n\t\t     else statement.  Increment stmt_count so we don't\n\t\t     give a second error if this is a nested `if'.  */\n\t\t  if (extra_warnings && stmt_count++ == $<itype>1)\n\t\t    warning (\"%Hempty body in an if-statement\",\n                             &if_stmt_locus); }\n/* Make sure c_expand_end_cond is run once\n   for each call to c_expand_start_cond.\n   Otherwise a crash is likely.  */\n\t| simple_if ELSE error\n\t\t{ c_expand_end_cond (); }\n       /* We must build the WHILE_STMT node before parsing its\n\t  condition so that STMT_LINENO refers to the line\n\t  containing the \"while\", and not the line containing\n\t  the close-parenthesis.\n\n\t  c_begin_while_stmt returns the WHILE_STMT node, which\n\t  we later pass to c_finish_while_stmt_cond to fill\n\t  in the condition and other tidbits.  */\n\t| WHILE\n                { stmt_count++;\n\t\t  $<ttype>$ = c_begin_while_stmt (); }\n\t  '(' expr ')'\n                { c_in_iteration_stmt++;\n\t\t  $4 = c_common_truthvalue_conversion ($4);\n\t\t  c_finish_while_stmt_cond\n\t\t    (c_common_truthvalue_conversion ($4), $<ttype>2);\n\t\t  $<ttype>$ = add_stmt ($<ttype>2); }\n\t  c99_block_lineno_labeled_stmt\n                { c_in_iteration_stmt--;\n\t\t  RECHAIN_STMTS ($<ttype>6, WHILE_BODY ($<ttype>6)); }\n\t| do_stmt_start\n\t  '(' expr ')' ';'\n                { DO_COND ($1) = c_common_truthvalue_conversion ($3); }\n\t| do_stmt_start error\n\t\t{ }\n\t| FOR\n\t\t{ $<ttype>$ = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n\t\t\t\t\t  NULL_TREE, NULL_TREE);\n\t\t  add_stmt ($<ttype>$); }\n\t  '(' for_init_stmt\n\t\t{ stmt_count++;\n\t\t  RECHAIN_STMTS ($<ttype>2, FOR_INIT_STMT ($<ttype>2)); }\n\t  xexpr ';'\n                { if ($6)\n\t\t    FOR_COND ($<ttype>2)\n\t\t      = c_common_truthvalue_conversion ($6); }\n\t  xexpr ')'\n                { c_in_iteration_stmt++;\n\t\t  FOR_EXPR ($<ttype>2) = $9; }\n\t  c99_block_lineno_labeled_stmt\n                { RECHAIN_STMTS ($<ttype>2, FOR_BODY ($<ttype>2));\n\t\t  c_in_iteration_stmt--;}\n\t| SWITCH '(' expr ')'\n\t\t{ stmt_count++;\n\t\t  $<ttype>$ = c_start_case ($3);\n\t\t  c_in_case_stmt++; }\n\t  c99_block_lineno_labeled_stmt\n                { c_finish_case ();\n\t\t  c_in_case_stmt--; }\n\t;\n\nfor_init_stmt:\n\t  xexpr ';'\n\t\t{ add_stmt (build_stmt (EXPR_STMT, $1)); }\n\t| decl\n\t\t{ check_for_loop_decls (); }\n\t;\n\n/* Parse a single real statement, not including any labels.  */\nstmt:\n\t  compstmt\n\t\t{ stmt_count++; $$ = $1; }\n\t| expr ';'\n\t\t{ stmt_count++;\n\t\t  $$ = c_expand_expr_stmt ($1); }\n\t| c99_block_start select_or_iter_stmt c99_block_end\n\t\t{ if (flag_isoc99)\n\t\t    RECHAIN_STMTS ($1, COMPOUND_BODY ($1));\n\t\t  $$ = NULL_TREE; }\n\t| BREAK ';'\n\t        { stmt_count++;\n\t\tif (!(c_in_iteration_stmt || c_in_case_stmt))\n\t\t  {\n\t\t    error (\"break statement not within loop or switch\");\n\t\t    $$ = NULL_TREE;\n\t\t  }\n\t\telse\n\t\t  $$ = add_stmt (build_break_stmt ()); }\n\t| CONTINUE ';'\n                { stmt_count++;\n\t\tif (!c_in_iteration_stmt)\n\t\t  {\n\t\t    error (\"continue statement not within a loop\");\n\t\t    $$ = NULL_TREE;\n\t\t  }\n\t\telse\n\t\t  $$ = add_stmt (build_continue_stmt ()); }\n\t| RETURN ';'\n                { stmt_count++;\n\t\t  $$ = c_expand_return (NULL_TREE); }\n\t| RETURN expr ';'\n                { stmt_count++;\n\t\t  $$ = c_expand_return ($2); }\n\t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n\t\t{ stmt_count++;\n\t\t  $$ = simple_asm_stmt ($4); }\n\t/* This is the case with just output operands.  */\n\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n\t\t{ stmt_count++;\n\t\t  $$ = build_asm_stmt ($2, $4, $6, NULL_TREE, NULL_TREE); }\n\t/* This is the case with input operands as well.  */\n\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n\t  asm_operands ')' ';'\n\t\t{ stmt_count++;\n\t\t  $$ = build_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n\t/* This is the case with clobbered registers as well.  */\n\t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ':'\n\t  asm_operands ':' asm_clobbers ')' ';'\n\t\t{ stmt_count++;\n\t\t  $$ = build_asm_stmt ($2, $4, $6, $8, $10); }\n\t| GOTO identifier ';'\n\t\t{ tree decl;\n\t\t  stmt_count++;\n\t\t  decl = lookup_label ($2);\n\t\t  if (decl != 0)\n\t\t    {\n\t\t      TREE_USED (decl) = 1;\n\t\t      $$ = add_stmt (build_stmt (GOTO_STMT, decl));\n\t\t    }\n\t\t  else\n\t\t    $$ = NULL_TREE;\n\t\t}\n\t| GOTO '*' expr ';'\n\t\t{ if (pedantic)\n\t\t    pedwarn (\"ISO C forbids `goto *expr;'\");\n\t\t  stmt_count++;\n\t\t  $3 = convert (ptr_type_node, $3);\n\t\t  $$ = add_stmt (build_stmt (GOTO_STMT, $3)); }\n\t| ';'\n\t\t{ $$ = NULL_TREE; }\n@@ifobjc\n\t| AT_THROW expr ';'\n\t\t{ stmt_count++;\n\t\t  $$ = objc_build_throw_stmt ($2);\n\t\t}\n\t| AT_THROW ';'\n\t\t{ stmt_count++;\n\t\t  $$ = objc_build_throw_stmt (NULL_TREE);\n\t\t}\n\t| objc_try_catch_stmt\n\t\t{ objc_build_finally_prologue (); }\n\t  objc_finally_block\n\t\t{ $$ = objc_build_try_catch_finally_stmt ($1, $3); }\n\t| AT_SYNCHRONIZED '(' expr ')'\n\t\t{ objc_build_synchronized_prologue ($3); }\n\t  compstmt\n\t\t{ $$ = objc_build_synchronized_epilogue (); }\n\t;\n\nobjc_try_catch_stmt:\n\t  objc_try_stmt\n\t\t{ objc_build_try_epilogue (1); }\n\t  objc_catch_list\n\t\t{ objc_build_catch_epilogue (); $$ = 1; }\n\t| objc_try_stmt\n\t\t{ objc_build_try_epilogue (0); $$ = 0; }\n\t;\n\n\nobjc_try_stmt:\n\t  AT_TRY\n\t\t{ objc_build_try_prologue (); }\n\t  compstmt\n\t;\n\nobjc_catch_list:\n\t  objc_catch_list objc_catch_block\n\t| objc_catch_block\n\t;\n\nobjc_catch_block:\n\t  AT_CATCH '(' parm ')'\n\t\t{ objc_build_catch_stmt ($3); }\n\t  compstmt\n\t\t{ stmt_count++; }\n\t;\n\nobjc_finally_block:\n\t  AT_FINALLY compstmt\n\t    { $$ = 1; }\n\t| /* NULL */\n\t    { $$ = 0; }\n@@end_ifobjc\n\t;\n\n/* Any kind of label, including jump labels and case labels.\n   ANSI C accepts labels only before statements, but we allow them\n   also at the end of a compound statement.  */\n\nlabel:\t  CASE expr_no_commas ':'\n                { stmt_count++;\n\t\t  $$ = do_case ($2, NULL_TREE); }\n\t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n                { stmt_count++;\n\t\t  $$ = do_case ($2, $4); }\n\t| DEFAULT ':'\n                { stmt_count++;\n\t\t  $$ = do_case (NULL_TREE, NULL_TREE); }\n\t| identifier save_location ':' maybe_attribute\n\t\t{ tree label = define_label ($2, $1);\n\t\t  stmt_count++;\n\t\t  if (label)\n\t\t    {\n\t\t      decl_attributes (&label, $4, 0);\n\t\t      $$ = add_stmt (build_stmt (LABEL_STMT, label));\n\t\t    }\n\t\t  else\n\t\t    $$ = NULL_TREE;\n\t\t}\n\t;\n\n/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n\nmaybe_type_qual:\n\t/* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| TYPE_QUAL\n\t\t{ }\n\t;\n\nxexpr:\n\t/* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| expr\n\t;\n\n/* These are the operands other than the first string and colon\n   in  asm (\"addextend %2,%1\": \"=dm\" (x), \"0\" (y), \"g\" (*x))  */\nasm_operands: /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| nonnull_asm_operands\n\t;\n\nnonnull_asm_operands:\n\t  asm_operand\n\t| nonnull_asm_operands ',' asm_operand\n\t\t{ $$ = chainon ($1, $3); }\n\t;\n\nasm_operand:\n\t  STRING '(' expr ')'\n\t\t{ $$ = build_tree_list (build_tree_list (NULL_TREE, $1), $3); }\n\t| '\u00dd' identifier '\u00a8' STRING '(' expr ')'\n\t\t{ $2 = build_string (IDENTIFIER_LENGTH ($2),\n\t\t\t\t     IDENTIFIER_POINTER ($2));\n\t\t  $$ = build_tree_list (build_tree_list ($2, $4), $6); }\n\t;\n\nasm_clobbers:\n\t  STRING\n\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n\t| asm_clobbers ',' STRING\n\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n\t;\n\n/* This is what appears inside the parens in a function declarator.\n   Its value is a list of ..._TYPE nodes.  Attributes must appear here\n   to avoid a conflict with their appearance after an open parenthesis\n   in an abstract declarator, as in\n   \"void bar (int (__attribute__((__mode__(SI))) int foo));\".  */\nparmlist:\n\t  maybe_attribute\n\t\t{ pushlevel (0);\n\t\t  declare_parm_level (); }\n\t  parmlist_1\n\t\t{ $$ = $3;\n\t\t  poplevel (0, 0, 0); }\n\t;\n\nparmlist_1:\n\t  parmlist_2 ')'\n\t| parms ';'\n\t\t{ mark_forward_parm_decls (); }\n\t  maybe_attribute\n\t\t{ /* Dummy action so attributes are in known place\n\t\t     on parser stack.  */ }\n\t  parmlist_1\n\t\t{ $$ = $6; }\n\t| error ')'\n\t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); }\n\t;\n\n/* This is what appears inside the parens in a function declarator.\n   Is value is represented in the format that grokdeclarator expects.  */\nparmlist_2:  /* empty */\n\t\t{ $$ = get_parm_info (0); }\n\t| ELLIPSIS\n\t\t{ $$ = get_parm_info (0);\n\t\t  /* Gcc used to allow this as an extension.  However, it does\n\t\t     not work for all targets, and thus has been disabled.\n\t\t     Also, since func (...) and func () are indistinguishable,\n\t\t     it caused problems with the code in expand_builtin which\n\t\t     tries to verify that BUILT_IN_NEXT_ARG is being used\n\t\t     correctly.  */\n\t\t  error (\"ISO C requires a named argument before `...'\");\n\t\t  parsing_iso_function_signature = true;\n\t\t}\n\t| parms\n\t\t{ $$ = get_parm_info (1);\n\t\t  parsing_iso_function_signature = true;\n\t\t}\n\t| parms ',' ELLIPSIS\n\t\t{ $$ = get_parm_info (0);\n\t\t  parsing_iso_function_signature = true;\n\t\t}\n\t;\n\nparms:\n\tfirstparm\n\t\t{ push_parm_decl ($1); }\n\t| parms ',' parm\n\t\t{ push_parm_decl ($3); }\n\t;\n\n/* A single parameter declaration or parameter type name,\n   as found in a parmlist.  */\nparm:\n\t  declspecs_ts setspecs parm_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_ts setspecs notype_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_ts setspecs absdcl_maybe_attribute\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nots setspecs notype_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\n\t| declspecs_nots setspecs absdcl_maybe_attribute\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t;\n\n/* The first parm, which must suck attributes from off the top of the parser\n   stack.  */\nfirstparm:\n\t  declspecs_ts_nosa setspecs_fp parm_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_ts_nosa setspecs_fp notype_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_ts_nosa setspecs_fp absdcl_maybe_attribute\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nots_nosa setspecs_fp notype_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $3),\n\t\t\t\t\tchainon ($4, all_prefix_attributes));\n\t\t  POP_DECLSPEC_STACK; }\n\n\t| declspecs_nots_nosa setspecs_fp absdcl_maybe_attribute\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t;\n\nsetspecs_fp:\n\t  setspecs\n\t\t{ prefix_attributes = chainon (prefix_attributes, $<ttype>-2);\n\t\t  all_prefix_attributes = prefix_attributes; }\n\t;\n\n/* This is used in a function definition\n   where either a parmlist or an identifier list is ok.\n   Its value is a list of ..._TYPE nodes or a list of identifiers.  */\nparmlist_or_identifiers:\n\t  maybe_attribute\n\t\t{ pushlevel (0);\n\t\t  declare_parm_level (); }\n\t  parmlist_or_identifiers_1\n\t\t{ $$ = $3;\n\t\t  poplevel (0, 0, 0); }\n\t;\n\nparmlist_or_identifiers_1:\n\t  parmlist_1\n\t| identifiers ')'\n\t\t{ tree t;\n\t\t  for (t = $1; t; t = TREE_CHAIN (t))\n\t\t    if (TREE_VALUE (t) == NULL_TREE)\n\t\t      error (\"`...' in old-style identifier list\");\n\t\t  $$ = tree_cons (NULL_TREE, NULL_TREE, $1);\n\n\t\t  /* Make sure we have a parmlist after attributes.  */\n\t\t  if ($<ttype>-1 != 0\n\t\t      && (TREE_CODE ($$) != TREE_LIST\n\t\t\t  || TREE_PURPOSE ($$) == 0\n\t\t\t  || TREE_CODE (TREE_PURPOSE ($$)) != PARM_DECL))\n\t\t    YYERROR1;\n\t\t}\n\t;\n\n/* A nonempty list of identifiers.  */\nidentifiers:\n\tIDENTIFIER\n\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n\t| identifiers ',' IDENTIFIER\n\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n\t;\n\n/* A nonempty list of identifiers, including typenames.  */\nidentifiers_or_typenames:\n\tidentifier\n\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n\t| identifiers_or_typenames ',' identifier\n\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n\t;\n\nextension:\n\tEXTENSION\n\t\t{ $$ = SAVE_EXT_FLAGS();\n\t\t  pedantic = 0;\n\t\t  warn_pointer_arith = 0;\n\t\t  warn_traditional = 0;\n\t\t  flag_iso = 0; }\n\t;\n\n@@ifobjc\n/* Objective-C productions.  */\n\nobjcdef:\n\t  classdef\n\t| classdecl\n\t| aliasdecl\n\t| protocoldef\n\t| methoddef\n\t| END\n\t\t{\n\t\t  if (objc_implementation_context)\n                    {\n\t\t      finish_class (objc_implementation_context);\n\t\t      objc_ivar_chain = NULL_TREE;\n\t\t      objc_implementation_context = NULL_TREE;\n\t\t    }\n\t\t  else\n\t\t    warning (\"`@end' must appear in an implementation context\");\n\t\t}\n\t;\n\n/* A nonempty list of identifiers.  */\nidentifier_list:\n\tidentifier\n\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n\t| identifier_list ',' identifier\n\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n\t;\n\nclassdecl:\n\t  CLASS identifier_list ';'\n\t\t{\n\t\t  objc_declare_class ($2);\n\t\t}\n\t;\n\naliasdecl:\n\t  ALIAS identifier identifier ';'\n\t\t{\n\t\t  objc_declare_alias ($2, $3);\n\t\t}\n\t;\n\nsuperclass:\n\t  ':' identifier { $$ = $2; }\n\t| /* NULL */ %prec HYPERUNARY    { $$ = NULL_TREE; }\n\t;\n\nclass_ivars:\n\t  '{' ivar_decl_list '}'\n\t| /* NULL */\n\t;\n\nclassdef:\n\t  INTERFACE identifier superclass protocolrefs\n\t\t{\n\t\t  objc_interface_context = objc_ivar_context\n\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, $3, $4);\n                  objc_public_flag = 0;\n\t\t}\n\t  class_ivars\n\t\t{\n                  continue_class (objc_interface_context);\n\t\t}\n\t  methodprotolist END\n\t\t{\n\t\t  finish_class (objc_interface_context);\n\t\t  objc_interface_context = NULL_TREE;\n\t\t}\n\n\t| IMPLEMENTATION identifier superclass\n\t\t{\n\t\t  objc_implementation_context = objc_ivar_context\n\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, $3, NULL_TREE);\n                  objc_public_flag = 0;\n\t\t}\n\t  class_ivars\n\t\t{\n                  objc_ivar_chain\n\t\t    = continue_class (objc_implementation_context);\n\t\t}\n\n\t| INTERFACE identifier '(' identifier ')' protocolrefs\n\t\t{\n\t\t  objc_interface_context\n\t\t    = start_class (CATEGORY_INTERFACE_TYPE, $2, $4, $6);\n                  continue_class (objc_interface_context);\n\t\t}\n\t  methodprotolist END\n\t\t{\n\t\t  finish_class (objc_interface_context);\n\t\t  objc_interface_context = NULL_TREE;\n\t\t}\n\n\t| IMPLEMENTATION identifier '(' identifier ')'\n\t\t{\n\t\t  objc_implementation_context\n\t\t    = start_class (CATEGORY_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n                  objc_ivar_chain\n\t\t    = continue_class (objc_implementation_context);\n\t\t}\n\t;\n\nprotocoldef:\n\t  PROTOCOL identifier protocolrefs\n\t\t{\n\t\t  objc_pq_context = 1;\n\t\t  objc_interface_context\n\t\t    = start_protocol(PROTOCOL_INTERFACE_TYPE, $2, $3);\n\t\t}\n\t  methodprotolist END\n\t\t{\n\t\t  objc_pq_context = 0;\n\t\t  finish_protocol(objc_interface_context);\n\t\t  objc_interface_context = NULL_TREE;\n\t\t}\n\t/* The @protocol forward-declaration production introduces a\n\t   reduce/reduce conflict on ';', which should be resolved in\n\t   favor of the production 'identifier_list -> identifier'.  */\n\t| PROTOCOL identifier_list ';'\n\t\t{\n\t\t  objc_declare_protocols ($2);\n\t\t}\n\t;\n\nprotocolrefs:\n\t  /* empty */\n\t\t{\n\t\t  $$ = NULL_TREE;\n\t\t}\n\t| non_empty_protocolrefs\n\t;\n\nnon_empty_protocolrefs:\n\t  ARITHCOMPARE identifier_list ARITHCOMPARE\n\t\t{\n\t\t  if ($1 == LT_EXPR && $3 == GT_EXPR)\n\t\t    $$ = $2;\n\t\t  else\n\t\t    YYERROR1;\n\t\t}\n\t;\n\nivar_decl_list:\n          ivar_decl_list visibility_spec ivar_decls\n        | ivar_decls\n        ;\n\nvisibility_spec:\n\t  PRIVATE { objc_public_flag = 2; }\n\t| PROTECTED { objc_public_flag = 0; }\n\t| PUBLIC { objc_public_flag = 1; }\n\t;\n\nivar_decls:\n          /* empty */\n\t\t{\n                  $$ = NULL_TREE;\n                }\n\t| ivar_decls ivar_decl ';'\n\t| ivar_decls ';'\n\t\t{\n                  if (pedantic)\n\t\t    pedwarn (\"extra semicolon in struct or union specified\");\n                }\n\t;\n\n\n/* There is a shift-reduce conflict here, because `components' may\n   start with a `typename'.  It happens that shifting (the default resolution)\n   does the right thing, because it treats the `typename' as part of\n   a `typed_typespecs'.\n\n   It is possible that this same technique would allow the distinction\n   between `notype_initdecls' and `initdecls' to be eliminated.\n   But I am being cautious and not trying it.  */\n\nivar_decl:\n\tdeclspecs_nosc_ts setspecs ivars\n\t        { $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| declspecs_nosc_nots setspecs ivars\n\t\t{ $$ = $3;\n\t\t  POP_DECLSPEC_STACK; }\n\t| error\n\t\t{ $$ = NULL_TREE; }\n\t;\n\nivars:\n\t  /* empty */\n\t\t{ $$ = NULL_TREE; }\n\t| ivar_declarator\n\t| ivars ',' maybe_resetattrs ivar_declarator\n\t;\n\nivar_declarator:\n\t  declarator\n\t\t{\n\t\t  $$ = add_instance_variable (objc_ivar_context,\n\t\t\t\t\t      objc_public_flag,\n\t\t\t\t\t      $1, current_declspecs,\n\t\t\t\t\t      NULL_TREE);\n                }\n\t| declarator ':' expr_no_commas\n\t\t{\n\t\t  $$ = add_instance_variable (objc_ivar_context,\n\t\t\t\t\t      objc_public_flag,\n\t\t\t\t\t      $1, current_declspecs, $3);\n                }\n\t| ':' expr_no_commas\n\t\t{\n\t\t  $$ = add_instance_variable (objc_ivar_context,\n\t\t\t\t\t      objc_public_flag,\n\t\t\t\t\t      NULL_TREE,\n\t\t\t\t\t      current_declspecs, $2);\n                }\n\t;\n\nmethodtype:\n\t  '+'\n\t\t{ objc_inherit_code = CLASS_METHOD_DECL; }\n\t| '-'\n\t\t{ objc_inherit_code = INSTANCE_METHOD_DECL; }\n\t;\n\nmethoddef:\n\t  methodtype\n\t\t{\n\t\t  objc_pq_context = 1;\n\t\t  if (!objc_implementation_context)\n\t\t    fatal_error (\"method definition not in class context\");\n\t\t}\n\t  methoddecl\n\t\t{\n\t\t  objc_pq_context = 0;\n\t\t  objc_add_method (objc_implementation_context,\n\t\t\t\t   $3,\n\t\t\t\t   objc_inherit_code == CLASS_METHOD_DECL);\n\t\t  start_method_def ($3);\n\t\t}\n\t  optarglist\n\t\t{\n\t\t  continue_method_def ();\n\t\t}\n\t  compstmt_or_error\n\t\t{\n\t\t  finish_method_def ();\n\t\t}\n\t;\n\n/* the reason for the strange actions in this rule\n is so that notype_initdecls when reached via datadef\n can find a valid list of type and sc specs in $0. */\n\nmethodprotolist:\n\t  /* empty  */\n\t| methodprotolist methodproto\n\t| methodprotolist { $<ttype>$ = NULL_TREE; } datadef\n\t;\n\nsemi_or_error:\n\t  ';'\n\t| error\n\t;\n\nmethodproto:\n\t  methodtype\n\t\t{\n\t\t  /* Remember protocol qualifiers in prototypes.  */\n\t\t  objc_pq_context = 1;\n\t\t}\n\t  methoddecl\n\t\t{\n\t\t  /* Forget protocol qualifiers here.  */\n\t\t  objc_pq_context = 0;\n\t\t  objc_add_method (objc_interface_context,\n\t\t\t\t   $3,\n\t\t\t\t   objc_inherit_code == CLASS_METHOD_DECL);\n\t\t}\n\t  semi_or_error\n\t;\n\nmethoddecl:\n\t  '(' typename ')' unaryselector\n\t\t{\n\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, NULL_TREE);\n\t\t}\n\n\t| unaryselector\n\t\t{\n\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, NULL_TREE);\n\t\t}\n\n\t| '(' typename ')' keywordselector optparmlist\n\t\t{\n\t\t  $$ = build_method_decl (objc_inherit_code, $2, $4, $5);\n\t\t}\n\n\t| keywordselector optparmlist\n\t\t{\n\t\t  $$ = build_method_decl (objc_inherit_code, NULL_TREE, $1, $2);\n\t\t}\n\t;\n\n/* \"optarglist\" assumes that start_method_def has already been called...\n   if it is not, the \"xdecls\" will not be placed in the proper scope */\n\noptarglist:\n\t  /* empty */\n\t| ';' myxdecls\n\t;\n\n/* to get around the following situation: \"int foo (int a) int b; {}\" that\n   is synthesized when parsing \"- a:a b:b; id c; id d; { ... }\" */\n\nmyxdecls:\n\t  /* empty */\n\t| mydecls\n\t;\n\nmydecls:\n\tmydecl\n\t| errstmt\n\t| mydecls mydecl\n\t| mydecl errstmt\n\t;\n\nmydecl:\n\tdeclspecs_ts setspecs myparms ';'\n\t\t{ POP_DECLSPEC_STACK; }\n\t| declspecs_ts ';'\n\t\t{ shadow_tag ($1); }\n\t| declspecs_nots ';'\n\t\t{ pedwarn (\"empty declaration\"); }\n\t;\n\nmyparms:\n\tmyparm\n\t\t{ push_parm_decl ($1); }\n\t| myparms ',' myparm\n\t\t{ push_parm_decl ($3); }\n\t;\n\n/* A single parameter declaration or parameter type name,\n   as found in a parmlist. DOES NOT ALLOW AN INITIALIZER OR ASMSPEC */\n\nmyparm:\n\t  parm_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $1),\n\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n\t| notype_declarator maybe_attribute\n\t\t{ $$ = build_tree_list (build_tree_list (current_declspecs,\n\t\t\t\t\t\t\t $1),\n\t\t\t\t\tchainon ($2, all_prefix_attributes)); }\n\t| absdcl_maybe_attribute\n\t\t{ $$ = $1; }\n\t;\n\noptparmlist:\n\t  /* empty */\n\t\t{\n\t\t  $$ = NULL_TREE;\n\t\t}\n\t| ',' ELLIPSIS\n\t\t{\n\t\t  /* oh what a kludge! */\n\t\t  $$ = objc_ellipsis_node;\n\t\t}\n\t| ','\n\t\t{\n\t\t  pushlevel (0);\n\t\t}\n\t  parmlist_2\n\t\t{\n\t\t  /* returns a tree list node generated by get_parm_info */\n\t\t  $$ = $3;\n\t\t  poplevel (0, 0, 0);\n\t\t}\n\t;\n\nunaryselector:\n\t  selector\n\t;\n\nkeywordselector:\n\t  keyworddecl\n\n\t| keywordselector keyworddecl\n\t\t{\n\t\t  $$ = chainon ($1, $2);\n\t\t}\n\t;\n\nselector:\n\t  IDENTIFIER\n\t| TYPENAME\n\t| CLASSNAME\n\t| OBJECTNAME\n\t| reservedwords\n\t;\n\nreservedwords:\n\t  ENUM | STRUCT\t| UNION\t| IF | ELSE | WHILE | DO | FOR\n\t| SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN\n\t| GOTO | ASM_KEYWORD | SIZEOF | TYPEOF | ALIGNOF\n\t| TYPESPEC | TYPE_QUAL\n\t;\n\nkeyworddecl:\n\t  selector ':' '(' typename ')' identifier\n\t\t{\n\t\t  $$ = build_keyword_decl ($1, $4, $6);\n\t\t}\n\n\t| selector ':' identifier\n\t\t{\n\t\t  $$ = build_keyword_decl ($1, NULL_TREE, $3);\n\t\t}\n\n\t| ':' '(' typename ')' identifier\n\t\t{\n\t\t  $$ = build_keyword_decl (NULL_TREE, $3, $5);\n\t\t}\n\n\t| ':' identifier\n\t\t{\n\t\t  $$ = build_keyword_decl (NULL_TREE, NULL_TREE, $2);\n\t\t}\n\t;\n\nmessageargs:\n\t  selector\n        | keywordarglist\n\t;\n\nkeywordarglist:\n\t  keywordarg\n\t| keywordarglist keywordarg\n\t\t{\n\t\t  $$ = chainon ($1, $2);\n\t\t}\n\t;\n\n\nkeywordexpr:\n\t  nonnull_exprlist\n\t\t{\n\t\t  if (TREE_CHAIN ($1) == NULL_TREE)\n\t\t    /* just return the expr., remove a level of indirection */\n\t\t    $$ = TREE_VALUE ($1);\n                  else\n\t\t    /* we have a comma expr., we will collapse later */\n\t\t    $$ = $1;\n\t\t}\n\t;\n\nkeywordarg:\n\t  selector ':' keywordexpr\n\t\t{\n\t\t  $$ = build_tree_list ($1, $3);\n\t\t}\n\t| ':' keywordexpr\n\t\t{\n\t\t  $$ = build_tree_list (NULL_TREE, $2);\n\t\t}\n\t;\n\nreceiver:\n\t  expr\n\t| CLASSNAME\n\t\t{\n\t\t  $$ = get_class_reference ($1);\n\t\t}\n\t| TYPENAME\n\t\t{\n\t\t  $$ = get_class_reference ($1);\n\t\t}\n\t;\n\nobjcmessageexpr:\n\t  '\u00dd' receiver messageargs '\u00a8'\n\t\t{ $$ = build_tree_list ($2, $3); }\n\t;\n\nselectorarg:\n\t  selector\n        | keywordnamelist\n\t;\n\nkeywordnamelist:\n\t  keywordname\n\t| keywordnamelist keywordname\n\t\t{\n\t\t  $$ = chainon ($1, $2);\n\t\t}\n\t;\n\nkeywordname:\n\t  selector ':'\n\t\t{\n\t\t  $$ = build_tree_list ($1, NULL_TREE);\n\t\t}\n\t| ':'\n\t\t{\n\t\t  $$ = build_tree_list (NULL_TREE, NULL_TREE);\n\t\t}\n\t;\n\nobjcselectorexpr:\n\t  SELECTOR '(' selectorarg ')'\n\t\t{\n\t\t  $$ = $3;\n\t\t}\n\t;\n\nobjcprotocolexpr:\n\t  PROTOCOL '(' identifier ')'\n\t\t{\n\t\t  $$ = $3;\n\t\t}\n\t;\n\n/* extension to support C-structures in the archiver */\n\nobjcencodeexpr:\n\t  ENCODE '(' typename ')'\n\t\t{\n\t\t  $$ = groktypename ($3);\n\t\t}\n\t;\n\n@@end_ifobjc\n%%\n\n/* yylex() is a thin wrapper around c_lex(), all it does is translate\n   cpplib.h's token codes into yacc's token codes.  */\n\nstatic enum cpp_ttype last_token;\n\n/* The reserved keyword table.  */\nstruct resword\n{\n  const char *word;\n  ENUM_BITFIELD(rid) rid : 16;\n  unsigned int disable   : 16;\n};\n\n/* Disable mask.  Keywords are disabled if (reswords\u00ddi\u00a8.disable & mask) is\n   _true_.  */\n#define D_C89\t0x01\t/* not in C89 */\n#define D_EXT\t0x02\t/* GCC extension */\n#define D_EXT89\t0x04\t/* GCC extension incorporated in C99 */\n#define D_OBJC\t0x08\t/* Objective C only */\n\nstatic const struct resword reswords\u00dd\u00a8 =\n{\n  { \"_Bool\",\t\tRID_BOOL,\t0 },\n  { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n  { \"__FUNCTION__\",\tRID_FUNCTION_NAME, 0 },\n  { \"__PRETTY_FUNCTION__\", RID_PRETTY_FUNCTION_NAME, 0 },\n  { \"__alignof\",\tRID_ALIGNOF,\t0 },\n  { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n  { \"__asm\",\t\tRID_ASM,\t0 },\n  { \"__asm__\",\t\tRID_ASM,\t0 },\n  { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n  { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n  { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, 0 },\n  { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, 0 },\n  { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n  { \"__complex\",\tRID_COMPLEX,\t0 },\n  { \"__complex__\",\tRID_COMPLEX,\t0 },\n  { \"__const\",\t\tRID_CONST,\t0 },\n  { \"__const__\",\tRID_CONST,\t0 },\n  { \"__extension__\",\tRID_EXTENSION,\t0 },\n  { \"__func__\",\t\tRID_C99_FUNCTION_NAME, 0 },\n  { \"__imag\",\t\tRID_IMAGPART,\t0 },\n  { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n  { \"__inline\",\t\tRID_INLINE,\t0 },\n  { \"__inline__\",\tRID_INLINE,\t0 },\n  { \"__label__\",\tRID_LABEL,\t0 },\n  { \"__ptrbase\",\tRID_PTRBASE,\t0 },\n  { \"__ptrbase__\",\tRID_PTRBASE,\t0 },\n  { \"__ptrextent\",\tRID_PTREXTENT,\t0 },\n  { \"__ptrextent__\",\tRID_PTREXTENT,\t0 },\n  { \"__ptrvalue\",\tRID_PTRVALUE,\t0 },\n  { \"__ptrvalue__\",\tRID_PTRVALUE,\t0 },\n  { \"__real\",\t\tRID_REALPART,\t0 },\n  { \"__real__\",\t\tRID_REALPART,\t0 },\n  { \"__restrict\",\tRID_RESTRICT,\t0 },\n  { \"__restrict__\",\tRID_RESTRICT,\t0 },\n  { \"__signed\",\t\tRID_SIGNED,\t0 },\n  { \"__signed__\",\tRID_SIGNED,\t0 },\n  { \"__thread\",\t\tRID_THREAD,\t0 },\n  { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n  { \"__typeof__\",\tRID_TYPEOF,\t0 },\n  { \"__volatile\",\tRID_VOLATILE,\t0 },\n  { \"__volatile__\",\tRID_VOLATILE,\t0 },\n  { \"asm\",\t\tRID_ASM,\tD_EXT },\n  { \"auto\",\t\tRID_AUTO,\t0 },\n  { \"break\",\t\tRID_BREAK,\t0 },\n  { \"case\",\t\tRID_CASE,\t0 },\n  { \"char\",\t\tRID_CHAR,\t0 },\n  { \"const\",\t\tRID_CONST,\t0 },\n  { \"continue\",\t\tRID_CONTINUE,\t0 },\n  { \"default\",\t\tRID_DEFAULT,\t0 },\n  { \"do\",\t\tRID_DO,\t\t0 },\n  { \"double\",\t\tRID_DOUBLE,\t0 },\n  { \"else\",\t\tRID_ELSE,\t0 },\n  { \"enum\",\t\tRID_ENUM,\t0 },\n  { \"extern\",\t\tRID_EXTERN,\t0 },\n  { \"float\",\t\tRID_FLOAT,\t0 },\n  { \"for\",\t\tRID_FOR,\t0 },\n  { \"goto\",\t\tRID_GOTO,\t0 },\n  { \"if\",\t\tRID_IF,\t\t0 },\n  { \"inline\",\t\tRID_INLINE,\tD_EXT89 },\n  { \"int\",\t\tRID_INT,\t0 },\n  { \"long\",\t\tRID_LONG,\t0 },\n  { \"register\",\t\tRID_REGISTER,\t0 },\n  { \"restrict\",\t\tRID_RESTRICT,\tD_C89 },\n  { \"return\",\t\tRID_RETURN,\t0 },\n  { \"short\",\t\tRID_SHORT,\t0 },\n  { \"signed\",\t\tRID_SIGNED,\t0 },\n  { \"sizeof\",\t\tRID_SIZEOF,\t0 },\n  { \"static\",\t\tRID_STATIC,\t0 },\n  { \"struct\",\t\tRID_STRUCT,\t0 },\n  { \"switch\",\t\tRID_SWITCH,\t0 },\n  { \"typedef\",\t\tRID_TYPEDEF,\t0 },\n  { \"typeof\",\t\tRID_TYPEOF,\tD_EXT },\n  { \"union\",\t\tRID_UNION,\t0 },\n  { \"unsigned\",\t\tRID_UNSIGNED,\t0 },\n  { \"void\",\t\tRID_VOID,\t0 },\n  { \"volatile\",\t\tRID_VOLATILE,\t0 },\n  { \"while\",\t\tRID_WHILE,\t0 },\n@@ifobjc\n  { \"id\",\t\tRID_ID,\t\t\tD_OBJC },\n\n  /* These objc keywords are recognized only immediately after\n     an '@'.  */\n  { \"class\",\t\tRID_AT_CLASS,\t\tD_OBJC },\n  { \"compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },\n  { \"defs\",\t\tRID_AT_DEFS,\t\tD_OBJC },\n  { \"encode\",\t\tRID_AT_ENCODE,\t\tD_OBJC },\n  { \"end\",\t\tRID_AT_END,\t\tD_OBJC },\n  { \"implementation\",\tRID_AT_IMPLEMENTATION,\tD_OBJC },\n  { \"interface\",\tRID_AT_INTERFACE,\tD_OBJC },\n  { \"private\",\t\tRID_AT_PRIVATE,\t\tD_OBJC },\n  { \"protected\",\tRID_AT_PROTECTED,\tD_OBJC },\n  { \"protocol\",\t\tRID_AT_PROTOCOL,\tD_OBJC },\n  { \"public\",\t\tRID_AT_PUBLIC,\t\tD_OBJC },\n  { \"selector\",\t\tRID_AT_SELECTOR,\tD_OBJC },\n  { \"throw\",\t\tRID_AT_THROW,\t\tD_OBJC },\n  { \"try\",\t\tRID_AT_TRY,\t\tD_OBJC },\n  { \"catch\",\t\tRID_AT_CATCH,\t\tD_OBJC },\n  { \"finally\",\t\tRID_AT_FINALLY,\t\tD_OBJC },\n  { \"synchronized\",\tRID_AT_SYNCHRONIZED,\tD_OBJC },\n  /* These are recognized only in protocol-qualifier context\n     (see above) */\n  { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC },\n  { \"byref\",\t\tRID_BYREF,\t\tD_OBJC },\n  { \"in\",\t\tRID_IN,\t\t\tD_OBJC },\n  { \"inout\",\t\tRID_INOUT,\t\tD_OBJC },\n  { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n  { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n@@end_ifobjc\n};\n#define N_reswords (sizeof reswords / sizeof (struct resword))\n\n/* Table mapping from RID_* constants to yacc token numbers.\n   Unfortunately we have to have entries for all the keywords in all\n   three languages.  */\nstatic const short rid_to_yy\u00ddRID_MAX\u00a8 =\n{\n  /* RID_STATIC */\tSTATIC,\n  /* RID_UNSIGNED */\tTYPESPEC,\n  /* RID_LONG */\tTYPESPEC,\n  /* RID_CONST */\tTYPE_QUAL,\n  /* RID_EXTERN */\tSCSPEC,\n  /* RID_REGISTER */\tSCSPEC,\n  /* RID_TYPEDEF */\tSCSPEC,\n  /* RID_SHORT */\tTYPESPEC,\n  /* RID_INLINE */\tSCSPEC,\n  /* RID_VOLATILE */\tTYPE_QUAL,\n  /* RID_SIGNED */\tTYPESPEC,\n  /* RID_AUTO */\tSCSPEC,\n  /* RID_RESTRICT */\tTYPE_QUAL,\n\n  /* C extensions */\n  /* RID_COMPLEX */\tTYPESPEC,\n  /* RID_THREAD */\tSCSPEC,\n\n  /* C++ */\n  /* RID_FRIEND */\t0,\n  /* RID_VIRTUAL */\t0,\n  /* RID_EXPLICIT */\t0,\n  /* RID_EXPORT */\t0,\n  /* RID_MUTABLE */\t0,\n\n  /* ObjC */\n  /* RID_IN */\t\tTYPE_QUAL,\n  /* RID_OUT */\t\tTYPE_QUAL,\n  /* RID_INOUT */\tTYPE_QUAL,\n  /* RID_BYCOPY */\tTYPE_QUAL,\n  /* RID_BYREF */\tTYPE_QUAL,\n  /* RID_ONEWAY */\tTYPE_QUAL,\n\n  /* C */\n  /* RID_INT */\t\tTYPESPEC,\n  /* RID_CHAR */\tTYPESPEC,\n  /* RID_FLOAT */\tTYPESPEC,\n  /* RID_DOUBLE */\tTYPESPEC,\n  /* RID_VOID */\tTYPESPEC,\n  /* RID_ENUM */\tENUM,\n  /* RID_STRUCT */\tSTRUCT,\n  /* RID_UNION */\tUNION,\n  /* RID_IF */\t\tIF,\n  /* RID_ELSE */\tELSE,\n  /* RID_WHILE */\tWHILE,\n  /* RID_DO */\t\tDO,\n  /* RID_FOR */\t\tFOR,\n  /* RID_SWITCH */\tSWITCH,\n  /* RID_CASE */\tCASE,\n  /* RID_DEFAULT */\tDEFAULT,\n  /* RID_BREAK */\tBREAK,\n  /* RID_CONTINUE */\tCONTINUE,\n  /* RID_RETURN */\tRETURN,\n  /* RID_GOTO */\tGOTO,\n  /* RID_SIZEOF */\tSIZEOF,\n\n  /* C extensions */\n  /* RID_ASM */\t\tASM_KEYWORD,\n  /* RID_TYPEOF */\tTYPEOF,\n  /* RID_ALIGNOF */\tALIGNOF,\n  /* RID_ATTRIBUTE */\tATTRIBUTE,\n  /* RID_VA_ARG */\tVA_ARG,\n  /* RID_EXTENSION */\tEXTENSION,\n  /* RID_IMAGPART */\tIMAGPART,\n  /* RID_REALPART */\tREALPART,\n  /* RID_LABEL */\tLABEL,\n  /* RID_PTRBASE */\tPTR_BASE,\n  /* RID_PTREXTENT */\tPTR_EXTENT,\n  /* RID_PTRVALUE */\tPTR_VALUE,\n\n  /* RID_CHOOSE_EXPR */\t\t\tCHOOSE_EXPR,\n  /* RID_TYPES_COMPATIBLE_P */\t\tTYPES_COMPATIBLE_P,\n\n  /* RID_FUNCTION_NAME */\t\tFUNC_NAME,\n  /* RID_PRETTY_FUNCTION_NAME */\tFUNC_NAME,\n  /* RID_C99_FUNCTION_NAME */\t\tFUNC_NAME,\n\n  /* C++ */\n  /* RID_BOOL */\tTYPESPEC,\n  /* RID_WCHAR */\t0,\n  /* RID_CLASS */\t0,\n  /* RID_PUBLIC */\t0,\n  /* RID_PRIVATE */\t0,\n  /* RID_PROTECTED */\t0,\n  /* RID_TEMPLATE */\t0,\n  /* RID_NULL */\t0,\n  /* RID_CATCH */\t0,\n  /* RID_DELETE */\t0,\n  /* RID_FALSE */\t0,\n  /* RID_NAMESPACE */\t0,\n  /* RID_NEW */\t\t0,\n  /* RID_OFFSETOF */    0,\n  /* RID_OPERATOR */\t0,\n  /* RID_THIS */\t0,\n  /* RID_THROW */\t0,\n  /* RID_TRUE */\t0,\n  /* RID_TRY */\t\t0,\n  /* RID_TYPENAME */\t0,\n  /* RID_TYPEID */\t0,\n  /* RID_USING */\t0,\n\n  /* casts */\n  /* RID_CONSTCAST */\t0,\n  /* RID_DYNCAST */\t0,\n  /* RID_REINTCAST */\t0,\n  /* RID_STATCAST */\t0,\n\n  /* Objective C */\n  /* RID_ID */\t\t\tOBJECTNAME,\n  /* RID_AT_ENCODE */\t\tENCODE,\n  /* RID_AT_END */\t\tEND,\n  /* RID_AT_CLASS */\t\tCLASS,\n  /* RID_AT_ALIAS */\t\tALIAS,\n  /* RID_AT_DEFS */\t\tDEFS,\n  /* RID_AT_PRIVATE */\t\tPRIVATE,\n  /* RID_AT_PROTECTED */\tPROTECTED,\n  /* RID_AT_PUBLIC */\t\tPUBLIC,\n  /* RID_AT_PROTOCOL */\t\tPROTOCOL,\n  /* RID_AT_SELECTOR */\t\tSELECTOR,\n  /* RID_AT_THROW */\t\tAT_THROW,\n  /* RID_AT_TRY */\t\tAT_TRY,\n  /* RID_AT_CATCH */\t\tAT_CATCH,\n  /* RID_AT_FINALLY */\t\tAT_FINALLY,\n  /* RID_AT_SYNCHRONIZED */\tAT_SYNCHRONIZED,\n  /* RID_AT_INTERFACE */\tINTERFACE,\n  /* RID_AT_IMPLEMENTATION */\tIMPLEMENTATION\n};\n\nstatic void\ninit_reswords (void)\n{\n  unsigned int i;\n  tree id;\n  int mask = (flag_isoc99 ? 0 : D_C89)\n\t      | (flag_no_asm ? (flag_isoc99 ? D_EXT : D_EXT|D_EXT89) : 0);\n\n  if (!c_dialect_objc ())\n     mask |= D_OBJC;\n\n  ridpointers = ggc_calloc ((int) RID_MAX, sizeof (tree));\n  for (i = 0; i < N_reswords; i++)\n    {\n      /* If a keyword is disabled, do not enter it into the table\n\t and so create a canonical spelling that isn't a keyword.  */\n      if (reswords\u00ddi\u00a8.disable & mask)\n\tcontinue;\n\n      id = get_identifier (reswords\u00ddi\u00a8.word);\n      C_RID_CODE (id) = reswords\u00ddi\u00a8.rid;\n      C_IS_RESERVED_WORD (id) = 1;\n      ridpointers \u00dd(int) reswords\u00ddi\u00a8.rid\u00a8 = id;\n    }\n}\n\n#define NAME(type) cpp_type2name (type)\n\nstatic void\nyyerror (const char *msgid)\n{\n  c_parse_error (msgid, last_token, yylval.ttype);\n}\n\nstatic int\nyylexname (void)\n{\n  tree decl;\n\n@@ifobjc\n  int objc_force_identifier = objc_need_raw_identifier;\n  OBJC_NEED_RAW_IDENTIFIER (0);\n@@end_ifobjc\n\n  if (C_IS_RESERVED_WORD (yylval.ttype))\n    {\n      enum rid rid_code = C_RID_CODE (yylval.ttype);\n\n@@ifobjc\n      /* Turn non-typedefed refs to \"id\" into plain identifiers; this\n\t allows constructs like \"void foo(id id);\" to work.  */\n      if (rid_code == RID_ID)\n      {\n\tdecl = lookup_name (yylval.ttype);\n\tif (decl == NULL_TREE || TREE_CODE (decl) != TYPE_DECL)\n\t  return IDENTIFIER;\n      }\n\n      if (!OBJC_IS_AT_KEYWORD (rid_code)\n\t  && (!OBJC_IS_PQ_KEYWORD (rid_code) || objc_pq_context))\n@@end_ifobjc\n      {\n\t/* Return the canonical spelling for this keyword.  */\n\tyylval.ttype = ridpointers\u00dd(int) rid_code\u00a8;\n\treturn rid_to_yy\u00dd(int) rid_code\u00a8;\n      }\n    }\n\n  decl = lookup_name (yylval.ttype);\n  if (decl)\n    {\n      if (TREE_CODE (decl) == TYPE_DECL)\n\treturn TYPENAME;\n    }\n@@ifobjc\n  else\n    {\n      tree objc_interface_decl = is_class_name (yylval.ttype);\n      /* ObjC class names are in the same namespace as variables and\n\t typedefs, and hence are shadowed by local declarations.  */\n      if (objc_interface_decl\n\t  && (global_bindings_p ()\n\t      || (!objc_force_identifier && !decl)))\n\t{\n\t  yylval.ttype = objc_interface_decl;\n\t  return CLASSNAME;\n\t}\n    }\n@@end_ifobjc\n\n  return IDENTIFIER;\n}\n\nstatic inline int\n_yylex (void)\n{\n get_next:\n  last_token = c_lex (&yylval.ttype);\n  switch (last_token)\n    {\n    case CPP_EQ:\t\t\t\t\treturn '=';\n    case CPP_NOT:\t\t\t\t\treturn '!';\n    case CPP_GREATER:\tyylval.code = GT_EXPR;\t\treturn ARITHCOMPARE;\n    case CPP_LESS:\tyylval.code = LT_EXPR;\t\treturn ARITHCOMPARE;\n    case CPP_PLUS:\tyylval.code = PLUS_EXPR;\treturn '+';\n    case CPP_MINUS:\tyylval.code = MINUS_EXPR;\treturn '-';\n    case CPP_MULT:\tyylval.code = MULT_EXPR;\treturn '*';\n    case CPP_DIV:\tyylval.code = TRUNC_DIV_EXPR;\treturn '/';\n    case CPP_MOD:\tyylval.code = TRUNC_MOD_EXPR;\treturn '%';\n    case CPP_AND:\tyylval.code = BIT_AND_EXPR;\treturn '&';\n    case CPP_OR:\tyylval.code = BIT_IOR_EXPR;\treturn '|';\n    case CPP_XOR:\tyylval.code = BIT_XOR_EXPR;\treturn '\u00ac';\n    case CPP_RSHIFT:\tyylval.code = RSHIFT_EXPR;\treturn RSHIFT;\n    case CPP_LSHIFT:\tyylval.code = LSHIFT_EXPR;\treturn LSHIFT;\n\n    case CPP_COMPL:\t\t\t\t\treturn '~';\n    case CPP_AND_AND:\t\t\t\t\treturn ANDAND;\n    case CPP_OR_OR:\t\t\t\t\treturn OROR;\n    case CPP_QUERY:\t\t\t\t\treturn '?';\n    case CPP_OPEN_PAREN:\t\t\t\treturn '(';\n    case CPP_EQ_EQ:\tyylval.code = EQ_EXPR;\t\treturn EQCOMPARE;\n    case CPP_NOT_EQ:\tyylval.code = NE_EXPR;\t\treturn EQCOMPARE;\n    case CPP_GREATER_EQ:yylval.code = GE_EXPR;\t\treturn ARITHCOMPARE;\n    case CPP_LESS_EQ:\tyylval.code = LE_EXPR;\t\treturn ARITHCOMPARE;\n\n    case CPP_PLUS_EQ:\tyylval.code = PLUS_EXPR;\treturn ASSIGN;\n    case CPP_MINUS_EQ:\tyylval.code = MINUS_EXPR;\treturn ASSIGN;\n    case CPP_MULT_EQ:\tyylval.code = MULT_EXPR;\treturn ASSIGN;\n    case CPP_DIV_EQ:\tyylval.code = TRUNC_DIV_EXPR;\treturn ASSIGN;\n    case CPP_MOD_EQ:\tyylval.code = TRUNC_MOD_EXPR;\treturn ASSIGN;\n    case CPP_AND_EQ:\tyylval.code = BIT_AND_EXPR;\treturn ASSIGN;\n    case CPP_OR_EQ:\tyylval.code = BIT_IOR_EXPR;\treturn ASSIGN;\n    case CPP_XOR_EQ:\tyylval.code = BIT_XOR_EXPR;\treturn ASSIGN;\n    case CPP_RSHIFT_EQ:\tyylval.code = RSHIFT_EXPR;\treturn ASSIGN;\n    case CPP_LSHIFT_EQ:\tyylval.code = LSHIFT_EXPR;\treturn ASSIGN;\n\n    case CPP_OPEN_SQUARE:\t\t\t\treturn '\u00dd';\n    case CPP_CLOSE_SQUARE:\t\t\t\treturn '\u00a8';\n    case CPP_OPEN_BRACE:\t\t\t\treturn '{';\n    case CPP_CLOSE_BRACE:\t\t\t\treturn '}';\n    case CPP_ELLIPSIS:\t\t\t\t\treturn ELLIPSIS;\n\n    case CPP_PLUS_PLUS:\t\t\t\t\treturn PLUSPLUS;\n    case CPP_MINUS_MINUS:\t\t\t\treturn MINUSMINUS;\n    case CPP_DEREF:\t\t\t\t\treturn POINTSAT;\n    case CPP_DOT:\t\t\t\t\treturn '.';\n\n      /* The following tokens may affect the interpretation of any\n\t identifiers following, if doing Objective-C.  */\n    case CPP_COLON:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ':';\n    case CPP_COMMA:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ',';\n    case CPP_CLOSE_PAREN:\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ')';\n    case CPP_SEMICOLON:\t\tOBJC_NEED_RAW_IDENTIFIER (0);\treturn ';';\n\n    case CPP_EOF:\n      return 0;\n\n    case CPP_NAME:\n      return yylexname ();\n\n    case CPP_AT_NAME:\n      /* This only happens in Objective-C; it must be a keyword.  */\n      return rid_to_yy \u00dd(int) C_RID_CODE (yylval.ttype)\u00a8;\n\n    case CPP_NUMBER:\n    case CPP_CHAR:\n    case CPP_WCHAR:\n      return CONSTANT;\n\n    case CPP_STRING:\n    case CPP_WSTRING:\n      return STRING;\n\n    case CPP_OBJC_STRING:\n      return OBJC_STRING;\n\n      /* These tokens are C++ specific (and will not be generated\n         in C mode, but let's be cautious).  */\n    case CPP_SCOPE:\n    case CPP_DEREF_STAR:\n    case CPP_DOT_STAR:\n    case CPP_MIN_EQ:\n    case CPP_MAX_EQ:\n    case CPP_MIN:\n    case CPP_MAX:\n      /* These tokens should not survive translation phase 4.  */\n    case CPP_HASH:\n    case CPP_PASTE:\n      error (\"syntax error at '%s' token\", NAME(last_token));\n      goto get_next;\n\n    default:\n      abort ();\n    }\n  /* NOTREACHED */\n}\n\nstatic int\nyylex (void)\n{\n  int r;\n  timevar_push (TV_LEX);\n  r = _yylex();\n  timevar_pop (TV_LEX);\n  return r;\n}\n\n/* Function used when yydebug is set, to print a token in more detail.  */\n\nstatic void\nyyprint (FILE *file, int yychar, YYSTYPE yyl)\n{\n  tree t = yyl.ttype;\n\n  fprintf (file, \" \u00dd%s\u00a8\", NAME(last_token));\n\n  switch (yychar)\n    {\n    case IDENTIFIER:\n    case TYPENAME:\n    case OBJECTNAME:\n    case TYPESPEC:\n    case TYPE_QUAL:\n    case SCSPEC:\n    case STATIC:\n      if (IDENTIFIER_POINTER (t))\n\tfprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n      break;\n\n    case CONSTANT:\n      fprintf (file, \" %s\", GET_MODE_NAME (TYPE_MODE (TREE_TYPE (t))));\n      if (TREE_CODE (t) == INTEGER_CST)\n\t{\n\t  fputs (\" \", file);\n\t  fprintf (file, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n\t\t   TREE_INT_CST_HIGH (t), TREE_INT_CST_LOW (t));\n\t}\n      break;\n    }\n}\n\n/* This is not the ideal place to put these, but we have to get them out\n   of c-lex.c because cp/lex.c has its own versions.  */\n\n/* Parse the file.  */\nvoid\nc_parse_file (void)\n{\n  yyparse ();\n  /* In case there were missing closebraces, get us back to the global\n     binding level.  */\n  while (! global_bindings_p ())\n    poplevel (0, 0, 0);\n  /* __FUNCTION__ is defined at file scope (\"\").  This\n     call may not be necessary as my tests indicate it\n     still works without it.  */\n  finish_fname_decls ();\n\n  if (malloced_yyss)\n    {\n      free (malloced_yyss);\n      free (malloced_yyvs);\n      malloced_yyss = 0;\n    }\n}\n\n#include \"gt-c-parse.h\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYING": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year  name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Library General\nPublic License instead of this License.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCCCMS": {"ttr": 517, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "Release Notes for GCCCMS\n------------------------\n\nThis document explains what needs to be done to get GCCMVS from:\n\nhttp://gccmvs.sourceforge.net\n\nto run on VM/CMS. The code is designed to work on VM/370,\nVM/380, VM/XA and z/VM. You just need to set the\nappropriate configuration before building.\n\nNote that when used on an non XA capable version of CMS,\nonly the 24-bit version of the module is created. Otherwise,\nan RMODE 24 AMODE 31 module (ie XA-style) is produced as\nwell. Sites running z/VM, but without the High Level Assembler\n(or compatible product) need a modified version of IFOX\n(see below) which increases the number of externals allowed.\n\nThe notes for the MVS version of the compiler (gccmvs.txt)\nshould be read in conjunction with this document. In particlar\nthe section on conversion from ASCII to EBCDIC is relevant to VM.\n\n\nOverview of changes for VM/CMS\n------------------------------\n\nNote that you will probably need to put:\nSET LDRTBLS 25\nor similar in your PROFILE EXEC etc to provide the resources\nthat GCC requires.\n\nWhile you're doing that, you should probably add \"PDPCLIB\"\nto your \"GLOBAL TXTLIB\" command, preferably at the front.\n\nThe changes to the main GCC code in GCCMVS to support CMS\nare fairly minimal, mainly confined to include file processing.\n\nHowever, the changes to PDPCLIB (the C runtime library) are\nmore extensive. An old version of the MVS assembler interface\nwas used as a base, and similarities remain between the MVS\nand CMS versions. The main differences are:\n\n1) The CMS assembler only supports the OS/MFT (OS/360) macro\n   formats. The GCCMVS run time uses some OS/MVS macros, which\n   had to be changed back to the MFT versions.\n\n2) The conventions for passing command line parameters to CMS\n   programs is different to that in OS.\n\n3) The low storage layout is different (PSA macro in OS, NUCON in CMS).\n\n4) CMS execs are needed to replace the PROCS and JCL files used in GCCMVS.\n\nIn addition, two changes to CMS are required to build GCC on VM/370.\nThese are as follows:\n\n1) The IFOX assembler needs modifying to allow more than 256\nexternals per program. (this change is also required for z/VM\nusers still using the IFOX assembler).\n\n2) The CMS loader needs modifying to allow more than 256 externals\nper load module.\n\nNeither of these changes are included with this distribution. Both\nmay be found in the \"files\" section of the Yahoo H390-VM \"e-group\".\nNote that if you are using VM/380 or the VM/370 Sixpack, these\nchanges are already included.\n\n\nInstalling the compiler on VM\n-----------------------------\n\nTo install from scratch you need to cross-compile from another\nplatform. Scripts are provided for MS Windows and Linux.\n\nFirst of all you need to get the source code by:\n\n1. Downloading the GCC base code (as per GCCMVS).\n\n2. Downloading the MVS & CMS patch and applying it (as per GCCMVS).\n\n\nYou then need to set the configuration properly.\n\nThere are 4 distinct CMS programming environments possible:\n\n1. VM/370 where everything is 24-bit. This is the S370\nenvironment.\n\n2. z/VM with native CMS macros where it is possible to write\n31-bit executables that reside above the 16 MB line. Since\nPDPCLIB uses MVS emulation macros which can't handle being\nrun from above the line, this environment isn't yet available.\nIf this changes in the future, this would be the S390\nenvironment.\n\n3. VM/380 where 31-bit executables can be created, but they\nmust reside below the line and they can only obtain a single\nchunk of ATL memory (current restriction). This is the S380\nenvironment.\n\n4. VM/XA where 31-bit capability exists, but I/O macros\nnecessitate that the executable must reside below the line.\nz/VM users fall into this category. This is also the S380\nenvironment.\n\n\nThe differences between categories 3 and 4 are as follows:\n\n1. VM/XA can get control in 31-bit mode, not requiring\nan AMODE switch.\n\n2. VM/XA can make multiple ATL memory requests.\n\n3. VM/XA will remain in 31-bit mode after an SVC 202 call.\n\n\nRather than create another flavor of the code, PDPCLIB\nwas written such that S380 mode:\n\n1. Detects whether it was called in 31-bit or 24-bit mode\nand switches to 31-bit mode if not already in that. This\ncode is in cmsstart.asm and could potentially be removed.\n\n2. Uses an internal heap manager (memmgr) so that only a\nsingle request for a chunk of 31-bit memory is made. This\nis faster than repeatedly calling the operating system\nanyway, but can be reversed out by not defining USE_MEMMGR\nin stdcompm.bat and stdcomp.parm.\n\n3. Switches to 24-bit mode prior to calling SVC 202. This\ncan be reversed out in cmssupa.asm if required for some\nreason. The technical reason why this is required is\nbecause the version of CMS used in VM/380 runs in BC mode\nso cannot preserve the AMODE flag over an SVC call itself -\ninstead Hercules/380 has been coded to detect a PSW being\nloaded and if it matches the last known transition, the\nAMODE is set based on that, which doesn't work with SVC 202\nbecause the SVC doesn't return to the same point.\n\n\nYou need to decide what mode:\n\n1. You want the GCC executable to be.\n\n2. You want executables produced by GCC to be.\n\n\nThe execs are set up by default to produce a S/380 GCC\nexecutable using memmgr (which will thus work on both\nVM/380 and z/VM), and the executables subsequently\nproduced are S/370 (which will thus work anywhere).\n\nIf you are using z/VM you have the option of switching\noff memmgr for the GCC module by getting rid of USE_MEMMGR\nin stdcompm.bat and stdcomp.parm. You may wish to do this\nto create a more flexible module that uses up less storage\nfor small compiles, and for really huge compiles, will\nnot exhaust the fixed limit that memmgr has. Neither\nthing is likely to be a genuine concern, so the default\nsetup should be fine.\n\nOn every version of VM, you have the option of using a\nS/370 version of GCC, and it will still work for most\npractical uses. It won't compile very large programs\nwith full optimization though (such as some of the GCC\nsource code itself) since it exceeds the 16 MB limit.\nHowever, if you wish to do this, then overwrite pdptop.mac\nwith pdp370.mac and switch off USE_MEMMGR in stdcompm.bat\nand stdcomp.parm and set ALL370 to 1 in compile.exec.\nAlso you may need to change all occurrences of the\nmaclib DMSGPI to CMSLIB.\n\nOn VM/380 and z/VM you have the option of getting GCC\nto produce S/380 modules. This is done by setting BLD to\n380 in compile.exec and defining USE_MEMMGR in stdpdp.parm.\nOn z/VM you can skip this last step, ie don't change\nstdpdp.parm, and you can produce VM/XA modules without\nthe use of a heap manager (this will produce executables\nthat typically use less memory but have the ability to\nuse larger amounts of memory if required).\n\n\nOnce you have made the changes you require for your\nenvironment, you are ready to build everything. The\n\"allcms.bat\" file may be useful to do that in some\ncircumstances. But the documentation below is for\nthe individual steps.\n\n\nAs mentioned, you need an assembler that can handle more\nthan 256 externals. By default it is assumed that you are\nusing ASMAHL (High Level Assembler) which fits that purpose.\nIf instead you are using ASSEMBLE (Assembler/XF aka IFOX00)\nyou need to modify gccaall.exec to specify that as your\nassembler name. Also you should modify gcce.exec and\ngccr.exec\n\n\nNow you can build the cross-compiler using \"compile.bat\"\n(or \"compile\" under Unix). This will produce a version of GCC\nthat can produce 370 assembler on Windows. You need to pass a\nparameter to compile.bat of -DTARGET_CMS, ie:\n\ncompile -DTARGET_CMS\n\nNow use compmvs.bat (compmvs in Unix) to create a set of\nassembler source file containing the CMS version of GCC, ie:\n\ncompmvs -DTARGET_CMS\n\nDon't worry about the fact that the executable is called\ngccmvs.exe and the batch file is also called mvs.  The\nname is shared, but they are different.\n\n\nYou now need to bundle up all the source (assembler, C,\nheaders, execs, parms) and transfer it to VM. There are\na lot of different ways you can accomplish this and it\nis beyond the scope of the GCCCMS install to specify how\nto do this.\n\nHowever, one example method is explained here.\n\nzipmvs.bat (zipmvs in Unix) will zip up all the important\nsource code. These zip files can then be unzipped into a\nsingle directory and then rezipped to produce a convenient\nsingle zip file. Should be zipped with no compression\nthough (zip -0).\n\nIf you have cygwin (or real Unix) you can run the \"cmsutil\"\nbatch file to generate a text file which can then be\ntransferred via the card reader (you will need to add a\n\"USERID GCCCMS\" or similar (without quotes) to the first\nline of the file if you are using VM/370 or VM/380. This\nfile can then be assigned to the card reader and then a\n\"readcard * *\" can be done, followed by \"cmsutil\" and you\nwill end up with an mvsunzip module. VM/380 comes with\nthis already done and you can see the technique already\ndone too.\n\nSo now that you have the mvsunzip module and the zip\nfile, you can marry them together.\n\nOn z/VM you will probably use ind$file to transfer the\nzip file in binary mode. On VM/370 and VM/380 under\nHercules you will probably use a TDF tape file and\npoint to the zip file. Then run:\n\nmvsunzip dd:hrcin a\n\nassuming your tape is on filedef HRCIN and you are\nextracting to the A disk.\n\nNext let's discuss disks. GCCCMS is designed to be built\nin a \"standard build environment\" (used by other programs)\nwhich consists of 3 disks.\n\n1. All the source code and building.\n2. The final executables designed to eventually be installed on the Y drive.\n3. A work disk.\n\nThese are typically A, B and C.\n\nThe EXEC \"COMPILE\" (and its front-end, \"ALLCMS\"), takes\nthose 3 letters as parameters. If for some reason you only\nhave one disk, you can set them all to A, in which case the\nexecutables won't be separately copied to B, and there\nwon't be an assembler verification (which is what the work\ndisk is used for in the case of GCCCMS's build exec).\n\nTo build GCC, the first disk (let's assume A - and because\nother commands assume A, this is likely to be the only\noption that works fully) needs to be at least 46 MB in size.\nVM/370 allows a disk up to about 52 MB, so it's probably\nbest to just define the max.\n\nThe B disk needs to be about 7 MB in size, mainly for the\nGCC and GCC370 modules.\n\nThe C disk needs to be about 18 MB in size - it contains a\ncopy of the generated assembly code.\n\n\nOn VM/380 (and some VM/370) you will find disks suitable\nfor compiling GCC that are set up under a GCCCMS userid.\nThe 291, 391 and 491 disks are set to the maximum (52 MB)\nallowed.\n\n\nAlso note that for full integrity, you can use bison and\nsed to generate the generated file. The batch file \"fullcms\"\nis used to do this, and is what is used prior to a release.\n\n\n\nUsing the compiler\n------------------\n\nThe run time has a number of differences to the GCCMVS compiler.\n\n1) As VM parameter passing is (at least on VM/370) all upper\ncase, 8-byte tokens a facility exists to read the parameters\nfrom OS DD name SYSPARM. Simply define this file and the\ncommand line will be picked up from the first line of that\nfile. Another facility available is to provide a command line\nat the same time as defining a dummy SYSPARM, and it will go\ninto special processing. This means (unless the first parameter\nis \"_+\") lowercasing everything, eliminating the space gaps\n(spaces require a _ before them to be preserved) except for\ncharacters prefixed with a \"_\" which will be uppercased (or\nif \"_+\" was specified at the beginning - lowercased).\n\n2) If you omit the \"DD:\" from the front of a filename passed\nto the I/O open routines the run-time code will assume it has\nbeen passed a CMS file name. If the name contains a \".\" it\nwill be assumed it seperates the filename and filetype. As the\ncode still uses OS emulation SVC202 is used to issue a \"filedef\"\ncommand to define the file to the code.\n\nTo compile, assemble and link a program \"TEST C A\" use the\nfollowing commands:\n\nGCCE TEST C A\nLOAD TEST (NOAUTO\nGENMOD TEST\nTEST\n\n(note that this relies on the GLOBAL TXTLIB having PDPCLIB\nin it so that it can resolve the externals)\n\n\n\nVersion\n-------\n\nTo find out version, you can go:\n\nGCC --version\n\n\n\nSupport\n-------\n\nTry asking a generic GCC question here:\n\nhttp://tech.groups.yahoo.com/group/hercules-os380/\n\nIf your question is more VM-related than GCC-related,\na broader range of VM expertise is available here:\n\nhttp://tech.groups.yahoo.com/group/H390-VM/\n\nThe main people who contributed to and are familiar with\nGCCCMS are Dave Wade, Paul Edwards and Robert O'Hara.\n\n\n\nz/VM example\n------------\n\nExample of using ind$file via c3270.\n\n\"cmsutil\" is run to create a file like this on the PC\n(note that there is no userid):\n\n:READ FILE1 EXEC A\nfdfdfd\n:READ FILE2 ASSEMBLE A\ndefkkd\n\nconvert to binary format, e.g:\n\nloc2ebc cmsutil.txt cmsutil.card 80\n\nlog on to z/VM with c3270\n\nGet into c3270 command mode with ctrl-\u00a8\n\ntransfer file with:\n\nc3270> transfer localfile=cmsutil.card \"hostfile=cmsutil card\"\ndirection=send mode=binary exist=replace\n\n(note that text mode didn't seem to work for me)\n\nenter to get back to z/vm\n\nSPOOL PUN *\nPUNCH CMSUTIL CARD (NOH\n\nreadcard * * (nop replace\n\n\nCompile the utilities by going:\n\ncmsutil\n\nThen back on the PC use \"allcms\" to create all.zip,\nencode it to be printable characters, then convert it\nto EBCDIC. This is done to avoid problems with the CR\nbeing stripped by the file transfer (it seems that c3270\nreads files in text mode regardless).\n\nThen transfer the encoded binary up\n\nc3270> transfer localfile=xfer.card \"hostfile=xfer card b\"\ndirection=send mode=binary exist=replace\n\nedit runspool exec to fix drive numbers\n\naccess 191 d\n\nThen:\n\nrunspool\n\n(although it's better to rename this script so that\nyou don't lose your drive letter changes and end up\nwith a disaster).\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCCMVS": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GCC and PDPCLIB for z/OS and MVS/380\n------------------------------------\n\nThis is a port of GCC version 3.4.6 to MVS (all versions\nof MVS, from z/OS down to 3.8j plus MVS/380). GCC 3.4.6\ndoesn't ship with a C runtime library suitable for use\non an MVS environment, so for that, PDPCLIB is included,\nto provide a complete solution to all your programming\nneeds. So long as you only need an ISO C90 (ANSI C89)\ncompiler, anyway!\n\nAlthough GCC originated on an ASCII Unix environment,\nthis MVS version of GCC is mostly unrelated to that\nenvironment. It is an MVS EBCDIC compiler. Mostly\nbuilt on MVS, using only tools that are also available\non MVS. It does not need or use a USS environment.\n\nThe same can be said of the C runtime library. Although\nthere is an ASCII Windows version of PDPCLIB available\ntoo, the MVS version was written for MVS, not Windows.\n\nSo too is the case with 24-bit support. Although MVS\n3.8j (24-bit) is a supported environment, every fullword\nof the 31-bit version is purely 31-bit.\n\nNor does the fact that GCC is copyrighted with a variety\nof licencing conditions (see the COPYING file in the\nGCC base source code) impact on your commercial use of\nload modules you compile with GCC. Every byte of\nPDPCLIB is public domain (no code is accepted otherwise).\nThus every byte of your executable is either your own\nwork, thus copyrighted by you and you alone, or it was\nfrom PDPCLIB, and thus can be used as freely as you\ncan use Shakespeare's \"Hamlet\". There is absolutely no\nlicencing restriction. No creditting. Nothing. No\nrestriction on modification. No requirements on you to\ndo anything if you modify it. No restriction on selling\nit, with or without modification. And no need to ask\npermission - it is already granted.\n\nIn principle, GCC will work with C runtime libraries\nother than PDPCLIB (e.g. Dignus is a defined GCC target,\nand was the base for the PDPCLIB target, since GCC 3.2.3\nwas generating nice, flexible code for that target).\nAlso in principle, PDPCLIB will work with compilers other\nthan GCC, and indeed, the first time PDPCLIB worked on\nMVS, it was after having been compiled by C/370. In practice,\nGCC's MVS target and PDPCLIB have matured, and continue\nto mature, hand in hand.  This combined product is\nknown as \"GCCMVS\" in the MVS environment, \"GCCCMS\"\nin the CMS environment, \"GCCVSE\" in the VSE environment\nand \"GCCMUS\" in the MUSIC/SP environment.\n\n\n\nQUICK START\n-----------\n\nRun GCC.JCL(EXAMPLE) to make sure it works.\n\nIf you are on a z/OS system and wish to produce 31-bit\nmodules instead of 24-bit, replace PDPCLIB.MACLIB(PDPTOP)\nwith PDPCLIB.MACLIB(PDP390), delete and reallocate\nPDPCLIB.NCALIB, then run GCC.JCL(STAGE4).\nThen run GCC.JCL(EXAMPLE) to ensure it still works and\nthat the link step is producing an AMODE 31, RMODE ANY\nmodule.\n\n\n\nOBTAINING\n---------\n\nThe normal way for a z/OS user (systems or application\nprogrammer) to obtain GCCMVS is via an XMIT tape downloaded\nfrom the sourceforge website:\n\nhttp://gccmvs.sourceforge.net\n\nThe normal way for an MVS/380 user to obtain GCCMVS is to\nsimply wait for a new version of either to be released,\nwhich normally comes with the version of the compiler that\nwas latest at the time of release.\n\nHowever, the XMIT can also be used on MVS/380 (and indeed,\nMVS 3.8j).\n\nBut probably the most convenient way of obtaining it is\nfrom the \"SEASIK\" DFDSS dump, which contains a number of\nfreeware products.\n\nIf you prefer, the compiler can also be produced by\nbuilding it from scratch from source code. When it is done\nthis way, it is done on the assumption that the MVS\nsystem does not already have a C compiler or tools\navailable, and will thus do a cross-compile (on an ASCII\nmachine). This is a very involved process, although it is\nusually done in an automated manner.\n\n\n\nDATASETS\n--------\n\nThe following datasets are included in the XMIT:\n\nrequired:\nGCC.LINKLIB - the compiler\nPDPCLIB.NCALIB - the C runtime library binaries\nPDPCLIB.INCLUDE - the C header files\nPDPCLIB.MACLIB - assembler support files\n\noptional:\nGCC.PROCLIB - compile procedure\nGCC.JCL - compile JCL\nPDPCLIB.LINKLIB - some useful utilities\nGCC.DOC - documentation for the C compiler\nPDPCLIB.DOC - documentation for the C runtime library\nGCC.SOURCE - complete source code for C compiler\nGCC.INCLUDE - header files for C compiler\nPDPCLIB.SOURCE - complete source code for the C runtime library\nGCC.S2 - assembler code (stage 2 output) used to build GCC load module\n\n\n\nBUILDING FROM SOURCE\n--------------------\n\nThere are at least 5 different things you could do that\ncould be described as \"building from source code\", and\nit depends on what you are trying to achieve that would\ndetermine which, if any, of these you would choose:\n\n1. Using assembler, simply set PDPTOP in PDPCLIB.MACLIB\nto be the version you want (S/390, S/380 or S/370) then\nreassemble the code in GCC.S2 using the STAGE1A and\nSTAGE1B JCL to produce the GCC load module. In STAGE1B,\nyou should rename \"MODULE\" from \"STAGE1\" to \"GCC\". After\ndoing that, you have another opportunity to change\nPDPTOP, for what you want your own executables to come\nout as. Then on z/OS submit STAGE4 to compile the C runtime\nlibrary.  MVS 3.8j and MVS/380 users should use STAGE4Z\ninstead.\n\n2. Compile the C code in GCC.SOURCE by running through\nthe STAGE2 and STAGE3 jobs, using the provided GCC\nexecutable. Then run STAGE4.\n\n3. Same as 2, except use BISON and SED to generate some\nof the C code which is actually generated code.\n\n4. Take the ASCII patch file, and the ASCII base gcc 3.2.3,\nbuild a cross compiler, generate the assembler, put that\non MVS, then run stages 1 to 3 to build the executable\nwith verification. This is what is described at length\nbelow. This is a non-trivial task.\n\n5. Do number 4, then with the newly-built compiler, go\nand build BISON and SED, then compile the compiler again,\nthis time using the tools, and then verify that all\ngenerated code is as expected. This is what the MVS/380\nbuild does.\n\n\n\nTHREE STAGES\n------------\n\nCompilers are normally built in 3 stages.\n\nSTAGE 1 - using a compiler from another vendor, or from\nan earlier version of your own compiler, or using a\ncross-compiler, compile your new compiler.\n\nSTAGE 2 - using your just-built new compiler, recompile\nyour compiler again, to produce a new module. This new\nmodule will most likely be significantly different from\nthe previous one, because it used your own compiler,\nrather than another vendor's, so will have generated\ndifferent code, even though both sets of code work fine.\n\nSTAGE 3 - using your NEW just-built module, once again\nrecompile everything to produce a new module. This new\nmodule should be identical to the one you used (although\nthere may be timestamp differences, depending on your\nbuild environment). If it isn't, it means that there's\na bug in your compiler that is affecting the compiler itself.\n\n\n\nOBTAINING BASE SOURCE\n---------------------\n\nGCCMVS is simply a patch of around 300k (zipped) on\ntop of standard GCC 3.4.6. Standard GCC 3.4.6 can be\nobtained from:\nftp.gnu.org/gnu/gcc/gcc-3.4.6/gcc-3.4.6.tar.bz2\nFile is dated 2006-03-10 00:00 and is\n28,193,401 bytes in size.\n\nHowever, you would probably be better off with the smaller:\nftp.gnu.org/gnu/gcc/gcc-3.4.6/gcc-core-3.4.6.tar.bz2\nFile is dated 2006-03-10 00:00 and is\n13,366,790 bytes in size.\n\nThe official place to obtain the GCCMVS patch from is:\nhttp://gccmvs.sourceforge.net\n\nGCCCMS (GCC for CMS) is part of the same product,\nand you can read gcccms.txt for further information.\n\nGCCVSE (GCC for VSE) is also part of the same product\nand has a gccvse.txt.\n\nGCCMUS (GCC for MUSIC/SP) is also included and has a gccmus.txt.\nNote that the initial work on that was done by Dave Edwards (RIP)\nwho made it available here:\nhttp://webpages.mcgill.ca/staff/group3/dedwar1/web/gccmu10.zip\n\nGCC can also be targetted to PDOS, although that is still experimental.\n\nNote that at the moment there is a separate, but\nsimilar, product - GCC for USS on OS/390, z/OS,\nmaintained by David Pitts, which is available from here:\nhttp://www.cozx.com/~dpitts/gcc.html\nA lot of code is shared between the two projects, but\nnot all. The code may coalesce in the future.\n\n\nYou will also need to obtain PDPCLIB.  The official\nplace to get PDPCLIB from is:\nhttp://pdos.sourceforge.net\n\n\n\nPREPARING INITIAL SOURCE\n------------------------\n\nIf you obtain GCCMVS in source code form, then\nyou need the following tools:\n\n1. The \"patch\" utility (Unix standard).\n\n2. a C compiler (by default, gcc for windows with\npdpclib for windows is used (which also requires a\n\"make\" which supports spaces, such as the one from\nBorland C++, or else you need to change all spaces to\ntabs in the makefile), but you can use C compilers\nother than gcc, and you can use standard gcc without\npdpclib for windows too).\n\n3. Miscellaneous decompression tools such as bzip2\nand tar (normally you get these by installing Cygwin).\n\nSo do the following (note that all these commands\nand the rest of the process is contained in cygwin.bat\nas an EXAMPLE of what you MIGHT want to do if you had\na standard cygwin install and wanted to be up and\nrunning as quickly as possible, and allmvs.bat MIGHT,\nafter modification, be used for someone doing a gcc/pdpclib\nwin32 build (this is the combination that is exercised\nin development) - and you can see this being done in the\nbuild scripts for MVS/380):\n\nbzip2 -d gcc-3.4.6.tar.bz2\ntar xvf gcc-3.4.6.tar\nren gcc-3.4.6 gcc\ncd gcc\npatch -p 1 -f <patch.txt (whatever the patch file is called)\n\nNote that this file that you are reading right now is\ncalled gccmvs.txt and after you've applied the patch,\nyou can switch to reading the gccmvs.txt that just got\nproduced. Just in case the one you are reading now is\nout of date.\n\nFor your information, some of the files in\nthe gccmvs patch were originally obtained by doing:\n./configure --target=i370-ibm-mvspdp --enable-languages=c\nbut you should NOT do that, otherwise you will\noverwrite various working source files with possibly\nnon-working ones. Actually there is a script called\n\"masterbuild\" in the i370 directory which was run on a Unix\nsystem that generated a lot of the MVS et al compilation\nscripts and an include file. The way it works is to first\ncall configure to build a cross-compiler (for Unix or\nwhatever). Once that is built, configure is called again,\nthis time to (attempt to) use the cross-compiler to build an\nMVS (instead of Unix) version of the C compiler. But since\nwe're missing things like a cross-assembler and cross-linker,\nwhat we instead do is use \"dummy\" scripts to just go through\nthe motions and we record a list of files it attempted to\ncompile along the way. With the file list we then generate\nthe unique MVS-specific way of building things and we also\nrun another utility to go over the assembler files to find\nduplicate (or rather, long) externals. Configure is designed\nto look for linker errors to see if a particular function is\navailable or not, but what the dummy script does instead is\nto force an error for a missing prototype, relying on the\nheader files to define all available functions.\n\n\nYou will also need to extract PDPCLIB. You should\ncreate a dummy \"pdos\" directory, and create a \"pdpclib\"\ndirectory under that (which is where all the PDPCLIB\nfiles should go), and then place \"pdos\" and \"gcc\" at the\nsame level, so you end up with a structure like this:\n\ngcc/include\ngcc/gcc\ngcc/libiberty\npdos/pdpclib\n\nIt needs to be like this because the compile scripts\nassume these relative paths and names.\n\n\n\nCOMPILING CROSS-COMPILER\n------------------------\n\nThen, assuming you are doing this from a DOS\nprompt, change to the gcc/gcc directory and go:\n\ngencomp (this step is actually optional, as the\nsource files it generates are actually already\npart of the patch, so you're probably better off\nomitting this step, and it assumes you are using\ngcc as your compiler).\n\ncompile\n\nwhich will create an executable called gccmvs.exe\non Windows, or gccmvs on Unix.\n\nFirst problem - by default, \"compile.bat\" is set up\nto compile using gcc/pdpclib-win32. You can easily\nchange this to use some other compiler, but if you\nwant to use the default, it requires you to actually\nbuild pdpclib-win32 according to the instructions\nincluded in pdpclib.txt in the pdpclib directory.\nThe advantage of using pdpclib-win32 is that it means\nthat the C runtime library you use for the PC is the\nsame/similar to that which is being used on the\nmainframe, so if you were to hit a bug, you will find\nout the problem on the PC before you get to the\nmainframe. Another advantage is that it bypasses the\nbuggy newlib headers which pollute the namespace with\nUnix rubbish which sometimes causes problems.\n\n\n\nCHOOSING TARGET ENVIRONMENT\n---------------------------\n\nThere are actually 3 distinct architectures supported:\nS/\nS/\nS/\n\nSome time during MVS/ESA, IBM provided 31-bit versions of the\n\"PUT\" etc macro (and supporting infrastructure) so that you\ncould actually have a clean AMODE 31, RMODE ANY executable.\nPrior to that time, any executable that needed to call \"PUT\"\nneeded to be RMODE 24 and switch to AMODE 24 before calling\n\"PUT\", then it could switch back to AMODE 31. ie it was a\nhybrid of sorts.\n\nPrior to MVS/XA, ie back at MVS 3.8j, you couldn't even have\na hybrid. Your application needed to be AMODE 24, RMODE 24.\n\nAdd to this mix the recent introduction of MVS/380, which\nis a modification to MVS 3.8j to allow it to support a hybrid\nmode (although at time of writing, the hybrid environment is\nnot identical to MVS/XA, and the intention is to modify \"PUT\"\netc so that it is no longer a hybrid anyway, but instead\nallows pure 31-bit executables - but then it will use the\nS/390 definition).\n\nSo you will need to choose your environment. There are 4 distinct\ncategories of potential users:\n\n1. If you are running TK3 (Turnkey-MVS, ie MVS 3.8j), you\nshould choose S/370 and copy pdp370.mac to pdptop.mac (in pdpclib)\nto set the architecture to S370 and also get rid of the AMODE and RMODE\nstatements. You should also change USE_MEMMGR to XXX_MEMMGR in\ncompmvs.bat so that it has no effect.\n\n2. If you are running a later version of MVS/ESA, or OS/390, or z/OS\nor later, then you have a pure 31-bit environment available to you,\nand you can copy pdp390.mac to pdptop.mac and optionally change\ncompmvs.bat, stage2c.jcl and stage3c.jcl to replace USE_MEMMGR with\nXXX_MEMMGR. This will make the compiler use standard GETMAIN instead\nof having an internal heap. The standard GETMAIN is more flexible\nbut a bit slower. Executables you produce will only work on\na 31-bit system\n\n3. If you are running MVS/380, then everything is set up by default.\nThe AMODE is ANY (it will switch to 31-bit mode at startup, but\ncan cope with being called in any mode, and will return to the\ncaller in that mode) and RMODE is 24 (not ANY, MVS/XA modules\nthat do I/O need to reside below the line). However do note\nthat only the compiler runs in 31-bit. STAGE4Z copies the S/370\nversion of the macro in so that normal programs are compiled\nas AMODE 24, RMODE 24 using standard GETMAIN, because most applications\ndon't require the extra memory and are more portable this way.\n\n4. If you are running MVS/XA or an early version of MVS/ESA, then\nyou have three choices:\nA. Follow the instructions for TK3 above to create 24-bit\nexecutables.\nB. Use the default MVS/380 version above.\nC. Same as B, except change USE_MEMMGR to XXX_MEMMGR as per\nS/390 instructions. If you're running STAGE4Z rather than STAGE4\n(not sure if STAGE4 will work on MVS/XA), then comment out the\nstep that copies PDP370 to PDPTOP.\n\n\nFor full integrity on S/380 or S/390 you can also run gencomp, so\nyou need to change gencomp.jcl to replace occurrences\nof \"BISON\" and \"SED\" to whatever you have called\nyour installation libraries for those two products. The script\n\"withbis\" will do a full build assuming bison is available,\nand that is normally called via \"fullmvs\" to package GCCMVS\nready for distribution. Note that the building of MVS/380 does\nall these steps to create a pure mainframe product.\n\n\n\nGENERATING ASSEMBLER\n--------------------\n\nNow run the \"compmvs\" script.\n\n(unless you want to use the unmodified IFOX on MVS 3.8, in which\ncase go \"compmvs -DIFOX\")\n\nThis will generate S/370 assembler code (clean, 31-bit\nassembler).\n\nYou now need to get all the stuff up onto the mainframe.\n\nThis is your big chance to screw things up.\nYou need to transfer these files with the\nsame ASCII to EBCDIC translation that GCCMVS\nexpects.  Easiest to stuff up are the following:\n\n| x'4f'\n\u00ac x'5f'\n\u00dd x'ad'\n\u00a8 x'bd'\n\nIf you actually try transferring this file you\nare reading now to the mainframe, and do a\nsearch on \"screw\" and put \"hex on\", you can\nsee how successful you are likely to be. However,\nthere are ways to avoid bad translation tables,\nand having to deal with so many files as well.\n\nFor example you could use the \"mvsunzip\" and\n\"mvsendec\" tools that come with PDPCLIB. These allow\nyou to zip up code (but without compression), encode\ninto printable hex (translate tables are never so bad\nthat they can't handle A-F and 0-9), and then reverse\nthe process on the mainframe. However, to reverse\nthe process, you still need to get those utilities\nonto the mainframe in the first place. For that,\nif you have m4 installed, you can run the \"makeutil\"\nscript to produce a convenient batch job that\ncompiles these basic utilities.\n\nAll such file transfer methods are beyond the scope\nof GCCMVS. The example (stress - example) jobs below\nassume an emulated tape is being used. This is a\nconvenient method for MVS/380 users.\n\nThe JCL is all set up to use particular prefixes in\nproc statements - GCCPREF and PDPPREF.  Thus they\nall need to be changed, as well as any JOBCARD\nchanges your installation requires, unless you're\nhappy with the defaults of \"GCC\" and \"PDPCLIB\". jcl,\nm4 and prc files all need to be changed.\n\nIt is recommended that you spend the time to automate\nthe process of changing the jobcard so that you can\nrerun these jobs again and again. You could set up an\nedit macro in ISPF or you could make use of the\n\"fixjcl\" batch file on the PC to make the changes. Note\nthat on your jobcard, you don't need REGION=0K, you can\nprobably get by with something like REGION=100M.\n\n\n\nRUNNING JOBS ON MVS\n-------------------\n\nYou probably want to run stage0a.jcl to create high-level\naliases for GCC and PDPCLIB. The exception is if you do\nnot have authority to create new aliases, and wish instead\nto run the compiler out of your own libraries. In which\ncase you would be using a high-level prefix of perhaps\n\"userid.GCC\" and \"userid.PDPCLIB\" instead, and thus no\naliases are required. Note that the compile JCL also expects\na 'SYS1.MODGEN' to exist. This doesn't exist on TK3, so\nyou will either need to create an alias for it, or modify\nthe JCL to replace MODGEN with AMODGEN.\n\nNext run stage0b.jcl to allocate the datasets which will\neventually store the source code etc from the PC.\n\nThe next steps are an example of how to get the source\ncode from the PC to mainframe. It uses zip on the PC\nside, and minizip on the host side, and emulated tape\ninbetween. Replace these steps with whatever your site\nuses.\n\nIn order to get minizip onto the host if it isn't\nalready there, you can run \"makeutil\", which is\ncalled by \"bootstrap\". Assuming the pre-existence of\nminizip, or something similar, zip up all the source\ncode etc to go to the mainframe by running \"zipmvs\".\nNote that for for complete integrity on a 31-bit\nsystem, it would be good if you editted zipmvs.bat and\nremoved all those \"rem\" statements down the bottom. This\nwill prevent you from uploading the generated source,\nand force gencomp to generate them instead. The script\n\"withbis\" will do this automatically.\n\nstage0c.jcl is then used to transfer the zip file up.\n\nstage0d.jcl then executes minizip to unzip the zip files.\n\nThat ends the involvement of the PC, as everything is\nnow on the host.\n\n\n\nBUILDING STAGE1\n---------------\n\nRun the JCL from GCC.JCL(STAGE1A) and GCC.JCL(STAGE1B).\nThis will create the stage1 executable, which is a\nworking gccmvs, the only disadvantage of which is that\nit was compiled on the PC instead of the mainframe.\n\nIf you had another vendor's compiler, or an old version\nof GCCMVS, you could have built this on the host in\nthe first place.\n\n\n\nGENERATED FILES\n---------------\n\nFor complete integrity on a 31-bit system,\nyou can run GCC.JCL(GENCOMP), which will\nregenerate all the generated source files.\nThis assumes that you have bison and sed\navailable. If you don't have them, you can\ncompile them using the stage1 executable,\nand you can temporarily rename stage1 to gcc.\nIf you already have old copies of bison, sed\nand gcc, there is no need to recompile them\nnow with stage1. That step happens later.\n\n\n\nBUILDING STAGE2\n---------------\n\nNext run GCC.JCL(STAGE2A-C).  Making use of\nthe just-compiled STAGE1, it will compile from\nsource code the entire gccmvs suite, this\ntime to create an executable called STAGE2.\n\nNote for MVS 3.8j users: Due to memory requirements,\nyou cannot build a stage2 compiler. You should\ninstead just rename this STAGE1 compiler to GCC,\ncopy it to GCC.LINKLIB, then pick up again in\nSTAGE4(Z).\n\n\n\nBUILDING STAGE3\n---------------\n\nIt so happens that the process used to build the stage1\ncompiler, being from the same vendor, has generated\nidentical code to that produced in stage2. So, it is\npossible to compare the stage1 and stage2 executables,\nwithout needing to go to stage3. As such, stage2d is\ndesigned to do the comparison prematurely, and avoid\nthe need for STAGE3.\n\nIf that is not your situation, you will now need to\nrun the STAGE3(A-C) jobs, which will compare with the\noutput of STAGE2.  The other situation where you\nwill need to run STAGE3 is if you ran GENCOMP, as\nthe source code will have changed slightly as a\nresult of that.\n\nWhen STAGE3C completes, it verifies the integrity\nof the compiler output, then produces a GCC module.\nDuring that process, a GCC.S2 file is produced\ncontaining the generated assembler. This can then\nbe transported to any other system, even MVS 3.8j\nwith memory constraints, to produce a perfectly\nviable C compiler, just by reassembly.\n\nNote that if the executables STAGE2 and GCC (aka\nSTAGE3) were not identical, then there is a compiler\nbug somewhere that is affecting the integrity of\nthe compiler itself.\n\n\n\nFINALIZING\n----------\n\nNow run GCC.JCL(STAGE4). MVS 3.8j and MVS/380 users\nshould run STAGE4Z instead, because of the 15 alias\nrestriction on these systems. This will compile\nPDPCLIB, the C runtime library. You have the option\nof changing PDPTOP to choose a different architecture\nto target for your own executables.\n\nNow (optionally) generate the 24-bit version of the\ncompiler and clean up all the intermediate datasets by\nsubmitting STAGE5A. Comment out the first step if you\ndon't have any use for the 24-bit version.\n\nThen (optionally) compile some useful utilities from\nPDPCLIB by submitting STAGE5B.\n\nNow if you're a systems programmer, you can choose to\ninstall the procs in GCC.PROCLIB into SYS1.PROCLIB\netc, after modifying them to your site's requirements.\nSubmit STAGE5C to do that. Note that if you want to\nrun the 24-bit version of the compiler by default,\nyou should change the PROCs to change the\n\"EXEC PGM=GCC\" to \"EXEC PGM=GCC370\".\n\nSTAGE6.JCL is not required to be run. It is only\nused in circumstances where you want to dump the\ndatasets to tape and then reload them.\n\n\nCongratulations, you now have GCCMVS fully installed.\n\nYou can now compile your own C programs by\nrunning the example jcl found in GCC.JCL(EXAMPLE),\nor if you have installed the procs, then EXAMPLE2.\n\n\n\nBISON and SED\n-------------\n\nFor complete integrity on a 31-bit system,\nyou should now go and recompile bison and sed,\nthen rename your GCC.SOURCE and GCC.INCLUDE\nto \".OLD\" datasets, repopulate them (from the\nzip files), then run GENCOMP (to repopulate\nthe generated source files), and then confirm\nthat the source and include haven't changed\nwith your new compiler by comparing with the\nold datasets. The MVS/380 build scripts do this\nas part of the process, by running the \"withbis\"\nscript. However, the integrity of the tools is\noutside the scope of GCC proper.\n\n\n\n\nCREDITS\n-------\n\nEveryone who worked on GCC in areas besides i370\n  and to the people out there who contribute the\n  odd fix that they developed.\nJan Stein for the original i370 machine definition\nDave Pitts for doing the port to OS/390 USS,\n  without which the further work could not have\n  been done.\nLinas Vepstas for a slew of bug fixes and enhancements\n  made during his port of Linux to S/370.\nPaul Edwards for doing the port to native (ie\n  non-USS) MVS 3.8, MVS/XA, OS/390, Z/OS, MVS/380\n  as well as getting GCC to be able to compile\n  itself on the mainframe (previously it was\n  only compilable by IBM's C compiler).\nPhil Roberts for testing & debugging & releasing\n  the native MVS port created by Paul Edwards. The\n  product wouldn't exist without Phil's work either.\nDave Wade for fixing the last compiler bug that\n  was preventing GCC from compiling itself on the\n  mainframe, and also for doing the VM/CMS port.\n  And various other bug fixes and improvements to\n  PDPCLIB as well.\nDave Edwards (RIP) for doing the MUSIC/SP port and\n  fixing various bugs in PDPCLIB in the process.\nTim Pinkanawa for writing the HTML documentation.\nTim Holloway for figuring out where to put the code\n  to get the static function names unique so that\n  the final problem stopping the compiler from\n  being C90 compliant was fixed.\nRobert O'Hara for getting EPLIST support in PDPCLIB\n  working on CMS and providing the mods to VM/380\n  required to get 31-bit GCCCMS binary compatible\n  between VM/380 and z/VM.\nGerhard Postpischil for providing the mods to MVS/380\n  required to get 31-bit GCCMVS binary compatible\n  between MVS/380 and z/OS so that we could build\n  GCCMVS on a free system. Also for the final functions\n  missing in PDPCLIB for C90 conformance for MVS and\n  for the virtual rewrite of mvssupa.asm.\nScott Cosel for the XMIT JCL which enabled a nice\n  package to be produced for z/OS users. Also for\n  producing a real 31-bit z/OS executable using\n  GCCMVS on z/OS and putting that in XMIT format to\n  truly test MVS/380. Also for other testing.\nTony Harminc for assistance in getting integer divide\n  working properly.\nUlrich Weigand for providing direction on tying up some\n  loose ends, especially getting rid of some warnings from\n  gencomp.\nFausto Saporito for his work on making the MUSIC/SP port\n  native.\nFran Hensler, Bruce Smith, Bill Carlborg, Louis Millon,\n  Michel Beaulieu and others for assistance and code\n  for the z/VSE port.\n\n\n\nVERSION\n-------\n\nSee version.c for the version number.\n\n\n\nSUPPORT\n-------\n\nPDPCLIB is separately maintained by Paul Edwards,\nand support is generally forthcoming for that.\nCertainly submission of *public domain* (ie NOT\nGPL) bug fixes/enhancements are welcome.\n\nSupport for most common GCC problems is generally\navailable also.\n\nThe usual place to get support for either thing is\nthe hercules-os380 Yahoo group at:\n\nhttp://tech.groups.yahoo.com/group/hercules-os380/\n\nIf your question is more MVS-related than GCC-related,\nthere are a number of other MVS forums linked from\nos380.\n\n\n\nTECHNICAL NOTES\n---------------\n\nTechnical notes about executables created in this manner plus\nother issues:\n\n1. A \"hello, world\" program is approximately 52k in size.\n\n2. The memory requirements (not including the\nspace for the executable) for a \"hello, world\"\nprogram are around 350k, assuming the default\nstack size of 256k is being used in mvsstart.asm (and\nthe rest is mainly because the 3 standard files all\nuse 32k buffers, so that's 96k + 256k = around 350k.\n\n3. PDPCLIB is designed to conform to the ISO/IEC\n9899:1990 (aka ANSI X3.159-1989) standard, and there\nare no extensions (like \"open\", \"chmod\" etc\nfound on other operating systems or compilers).\n\n4. What PDPCLIB on MVS is primarily designed for,\nis fast processing of binary, fixed block datasets,\nand also for text processing, via fgets, from\nvariable length records.  Or if you want to write a\nutility to traverse MVS control blocks, you\ncan use it for that sort of thing.  When operating\non binary, fixed-length records, the path from\nfwrite to the \"PUT\" macro is very short indeed.\nThe path from fputs to the \"PUT\" macro is pretty\nshort too.\n\n5. The files that PDPCLIB operates on do not\nhave default DCB information (LRECL etc).  This\nhas the advantage that the programs will operate\non datasets of any LRECL, but does have the\ndownside that you need to specify all the DCB\ninformation in your JCL. IBM's default appears\nto be RECFM=U, which will not get you very far.\n\n6. The executables that are produced can be run\nas both TSO command processor or in batch.  The\nparameter parsing will handle either method of\ninvocation.\n\n7. N/A.\n\n8. PDPCLIB makes no attempt to operate on VSAM\ndatasets, or anything else outside of bog-standard\nsequential files.  It will also refuse any attempt\nto open a file in update or append mode, and random\naccess will usually be unacceptably slow due to\nthe constant reopening of the file. The design of\nRECFM=U handling is to allow the \"copyfile\" utility\n(part of PDPCLIB) to be able to do a binary copy\nfrom a VB file, to a U file, to an FB file, back to\na VB file, and have the files still be identical.\n\n9. Note that the \"-g -dA\" option can be used to get\nsource file line numbers inserted into the assembler\nfile.\n\n10. The compiler generates excessive instructions,\nreloading the base register at every single label.\nThe smarts are already in the code generator to\navoid this, it's just that they're not quite smart\nenough, so needed to be disabled! Search for do_spec_1\nin i370.c to see the problem. An exception has been\nmade for functions that fit in a single page. This\ngets around the vast majority of the problem.\n\n11. You need to have an assembler capable of handling\nmore than 400 externals. If you are using the (very\nold) IBM-supplied IFOX, then you need to apply this\npatch:\nhttp://www.prycroft6.com.au/vs2mods/download/asmxfesd.zip\nIf you really must use an unmodified IFOX, you can\ncompile with \"-DIFOX\" which will disable some externals\nthat you may be able to do without. It is not recommended\nor supported.\n\n12. The compiler requires approximately 50 MB of memory to\ncompile everything optimized, on top of the GCC executable\nitself (3 MB). Specifically C@COMMON won't build with only\n49 MB of memory for data. This means you can't complete the\nnormal build process on any S/370 machine.\n\n13. Note that the source and include files are generally\nstored in VB files, except for the bits with assembler in\nit, which need to be FB80.\n\n14. When importing a new release it is necessary\nto allow c-parse.c to be imported. This is set to\nignore in .cvsignore. We have a local modification\nto c-parse.c that allows it to handle both ASCII\nand EBCDIC. But there is actually no need to use\nthis modified c-parse.c, as a version that works\non EBCDIC can be generated using bison on an\nEBCDIC host, and that is in fact what the \"gencomp\"\nJCL does. But if you don't have bison, you will need\nthis modification. While updating .cvsignore, it\nis also best to get rid of the genrtl.c and genrtl.h\nfrom there, to allow them to be imported if they exist.\n\n15. Most generated files are generated by \"gencomp\".\nBut some were generated by using\n\"configure\" and \"make\".\nThe command to run configure is:\n./configure --target=i370-ibm-mvspdp --enable-languages=c\n\n16. Since the S/370 target as it stands doesn't dedicate\na register for a frame pointer, the stack pointer and\nframe pointer are both set to R13. As such, alloca() can't\nallocate space on the stack. So, it was necessary to modify\nthe builtin_alloca() function to stop it from allocating\nspace and letting it call alloca() instead. This could\nall be changed, but would add an additional complexity.\n\n17. The assembler code generated by gccmvs when run on the\nPC is slightly different (even when the same parameters\nare used for code generation) from that when run on the\nmainframe, if -O2 is used instead of -Os. But functionally\nequivalent. This non-deterministic nature of the compiler\nis disconcerting. It seems to not always allocate registers\nconsistently. This has been traced to floating point code\nin predict.c and local-alloc.c which is sensitive to the\nvery small changes in floating point representation. This\nshould be changed to include deltas when comparing floating\npoint values. Here's an example of what's happening:\n\n*** c-lex.s Mon Jan 14 20:48:35 2008\n--- temp.dat Mon Jan 14 21:14:04 2008\n***************\n*** 1328,1335 ****\n           SLR   15,15\n           STC   15,0(3,4)\n           SLR   6,6\n-          LR    9,6\n           LR    8,6\n           L     2,192(13)\n           CLR   2,5\n           BNL   L303\n--- 1328,1335 ----\n           SLR   15,15\n           STC   15,0(3,4)\n           SLR   6,6\n           LR    8,6\n+          LR    9,6\n           L     2,192(13)\n           CLR   2,5\n           BNL   L303\n\n\n18. builtins have all been switched off in the compiler\nby default (ie -fno-builtin), as they can sometimes\ngenerate bad code. Instead, the header file is used to\nselectively enable working builtins.\n\n19. Versions of GCCMVS up to and including 3.2.3 MVS 6.0\nshould be considered betas because of the compiler bugs that\nthey contained. With the elimination of those bugs, GCCMVS\nis now of acceptable quality.\n\n20. nostdinc is on by default so that you have to\nspecify where you get your include files from on\nthe compile command line. There might be a better\nway of doing this rather than setting no_standard_includes\nin cppinit.c\n\n21. We should look at making \"configure\" and \"make\"\nwork for the mvspdp target, so that people on Unix\ndon't need to use our custom-made scripts. They currently\nwork, but the detab routines are bypassed.\n\n22. PDPCLIB should be changed to read data a block\nat a time rather than a record at a time. This will\nallow us to efficiently process datasets with an\nLRECL of 1, which fits the C paradigm more accurately.\n\n23. We should consider having a utility to compare two\nexecutables so that we can see that the stage2 and stage3\nexecutables are identical. A utility to do this can be\nwritten as follows: BLDL each to find the length.\nIf lengths are equal, GETMAIN the space for it twice.\nLoad the first load module in the first GETMAINed space.\nCopy it to the second GETMAINed space with MVCL.\nLoad the second load module to the first GETMAINed space.\nCompare the two GETMAINed spaces with CLCL. We currently\ncompare assembler instead, which should be just as good.\n\n24. Because MVS 3.8 has a limitation of 15 aliases in the linker\n(and presumably elsewhere), the same module is linked multiple\ntimes, to ensure all aliases can be created. This opens up the\npossibility of some object code being out of date if someone\nlinks one of the modules manually without doing the other required\nlinks as per STAGE4Z. The alternative is to add more than 15\naliases via other means, but no-one has explained why there is\na 15 alias limit in the first place, so we don't know what the\nramifications of doing that are.\n\n25. If you are using a compiler that gives you an error when you\ncompile vasprintf.c, then add a define in the compile command to\ndefine VALIST_NOT_PTR, and that should get around the problem.\nSee stdcompw.bat for an example. The gcc code is basically not 100%\nC90-compliant as it depends on the implementation of va_list.\n\n26. With -pedantic-errors switched on we get slightly different\nand seemingly slightly less efficient code generated. This was\nnot expected. pedantic-errors is desirable to aid portability.\n\n27. I added the __extension__ keyword to genoutput.c because\nI couldn't see how to get rid of the pedantic error.  This should\nbe replaced with something better.\n\n28. #pragma map() and linkage exist, but don't currently\nhave any effect. TARGET_ALIASES would need to be switched\non for map to start having an effect.\nSyntax is like this:\n#pragma map(finalize_buffer, \"FIN@BUF\")\nGCC already has:\n#pragma redefined_extname oldname newname\nbut that's not what is normally used for MVS. And it doesn't\nhave any effect either! Probably because of the name\ngrunging being done in GCCMVS unconditionally to trunc to 8\ncharacters and convert abnormal characters into '@' and\nuppercasing.\n\n29. Failed compiles on the PC don't clean up after an error,\nso you can have a partially-produced .s file which causes much\nconfusion later when you have missing externals.\n\n30. makeutil.bat has been provided to put some useful\nutilities into a single JCL stream for convenient transfer.\n\n31. GCC when compiling a program with \"main()\" in it, will\ngenerate code for an entry point for the entire executable.\nThis entry point is called @@MAIN and is different from\nMAIN. @@MAIN will then call @@CRT0 which will eventually\ncall MAIN.  @@CRT0 returns directly to the OS from there,\nand in fact, if @@CRT0 is forced to be the entry point,\nit will still work fine too. @@MAIN was introduced so that\nthe linker can automatically resolve things. However, that\nbit of the automatic resolution will only work if you\npass the object code with @@MAIN directly to the linker,\nrather than first of all creating an NCAL and then passing\nthat to the linker. If you wish to create NCALs, then you\nwill need to put an \"ENTRY @@MAIN\" in yourself for the\nlinkage editor control statements. Unfortunately this setup\nhas the side-effect that the entry point of modules by default\nis not 0, which while perfectly technically valid, is a bit\nannoying.\n\n32. The calling convention is slightly different in GCC\ncompared to IBM C. Integers are passed by value rather than\nreference. This is normally not visible, but we should\nconsider making this the same as IBM C and perhaps follow\nthe LE specs.\n\n33. This file and all compile scripts etc should probably\nbe moved into the \"config/i370\" directory, but for now it\nis more convenient to leave them where they are.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I370": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ";;- Machine description for GNU compiler -- System/370 version.\n\n;; =======================================================================\n;; Note that this file is not nearly as complicated as it looks\n;; at first glance. See below the copyright notice for an explanation\n;; (you will get nowhere without an explanation).\n;; =======================================================================\n\n\n;;  Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002\n;;  Free Software Foundation, Inc.\n;;  Contributed by Jan Stein (jan@cd.chalmers.se).\n;;  Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n;;  Lots of Bug Fixes & Enhancements by Linas Vepstas (linas@linas.org)\n;;  More bug fixes by Paul Edwards (fight.subjugation@gmail.com)\n\n;; This file is part of GCC.\n\n;; GCC is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 2, or (at your option)\n;; any later version.\n\n;; GCC is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GCC; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 59 Temple Place - Suite 330,\n;; Boston, MA 02111-1307, USA.\n\n\n;; =======================================================================\n;; At the heart of the GCC backend (the backend is what generates the\n;; code for a particular CPU, the frontend deals with some high-level\n;; language - you can basically feed an arbitrary language into the\n;; front and get code for an arbitrary CPU out the back) is this\n;; \"machine description\" file. This is where you put the S/370\n;; instructions, e.g. \"MH\", multiply halfword, into a form that the\n;; rest of the GCC compiler understands.\n\n;; At some point in GCC's deliberations, it will have a requirement\n;; to say multiply x (an integer) by say \"5\". This can be done by the\n;; MH instruction. The thing is that \"x\" could actually already be in\n;; a register, or it could be in memory. If in memory, it could be\n;; conveniently referenced by an RX instruction (ie base + index). It\n;; may not be accessible via an S address (base only), for whatever\n;; reason (typically, a variable is on the stack, and offset on the\n;; stack is more than 4096, so base + offset can't get to it).\n\n;; So basically GCC needs to be made aware of whether the MH instruction\n;; can operate on an S address, an RX, or only a register. The \"ST\"\n;; instruction is RX so can operate on RX or S. In this case, MH, the\n;; destination needs to be a register. It's an RX instruction though,\n;; so the source can be be an RX address. However, there's an\n;; additional constraint - the source must be a halfword, so this is\n;; only suitable for values between -32768 and 32767 inclusive.\n;; All this information needs to be communicated to the compiler.\n\n;; Let's take a look at this instruction:\n;;\n;; (define_insn \"\"\n;;   \u00dd(set (match_operand:SI 0 \"register_operand\" \"=d\")\n;; \t(mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n;; \t\t (match_operand:SI 2 \"immediate_operand\" \"K\")))\u00a8\n;;   \"\"\n;;   \"*\n;; {\n;;   check_label_emit ();\n;;   mvs_check_page (0, 4, 0);\n;;   return \\\"MH\t%0,%H2\\\";\n;; }\"\n;;    \u00dd(set_attr \"length\" \"4\")\u00a8\n;; )\n;;\n;; The important things here are:\n;;\n;; the \"mult:SI\" tells it that this will do a multiply of fullword integers.\n;; If it had been \"DI\" it would be doublewords, ie either register pairs\n;; or 8 bytes of memory aligned on an 8-byte boundary. \"SI\" is a standard\n;; integer. \"DI\" is double-sized integer. \"HI\" is a halfword integer,\n;; and finally we have \"QI\" for a quarter, or byte operation.\n;;\n;; \"mult\" is a standard keyword that GCC knows and it will go looking for\n;; a pattern of this name when it needs to do a multiply.\n\n;; Next look at the \"match_operand:SI\". That tells it that the operand\n;; for this instruction needs to be an integer. If e.g. this said\n;; instead \"DI\", it would let GCC know that if it needs to multiply an\n;; integer, it first needs to move it into a register pair before doing\n;; this instruction. This bit is extremely important. The loading into\n;; the right registers needs to be done *BEFORE* the instruction is\n;; executed. It's too late at this stage of the game to start defining\n;; some temporary registers you would like to use to complete this\n;; operation.\n\n;; Next we see a \"0\". That means operand number 0, the destination.\n;;\n;; Then we have \"register_operand\". That means that the destination\n;; is a register. You can't use this to write an answer directly to\n;; memory. Note that you can find this keyword, and other keywords,\n;; in the \"GCC internals\" manual under \"Machine Descriptions\",\n;; \"RTL template\", and are called the \"predicate\" (look for manual\n;; sections called \"predicates\" too). Some of these\n;; predicates are not documented there, they are specific to S/370.\n;; e.g. \"s_operand\" which says that it must be an S-type (ie no\n;; index) memory reference. So long as the compiler knows this in\n;; advance, it will take care of moving any variable into an S-type\n;; memory reference. Be careful. The predicate \"r_or_s_operand\"\n;; doesn't mean RX or S memory address. It means that the following\n;; pattern will deal with both a REGISTER and an S-type address.\n\n;; Next we have a constraint. That's the \"=d\". The \"=\" says that\n;; this operand will be an output (destination). A \"+\" would mean\n;; that it is both input and output. And nothing would mean\n;; input-only. These are documented in \"constraint modifier\n;; characters\" under \"operand constraints\" under \"machine descriptions\".\n;; The \"d\" bit would have been documented under \"simple constraints\",\n;; except it is not standard with GCC. It is an S/370 extension which\n;; means that it is a general register, ie even R0, rather than \"a\"\n;; which would be an address register (ie R0 isn't allowed). This\n;; lets GCC know that if it happens to have the value in R0, then\n;; that's fine. It doesn't need to go to the effort of moving it\n;; into say R1 in order to do the \"MH\" instruction.\n\n;; That completes the first operand. The second operand is a bit\n;; complicated. As you know, the MH instruction only takes 2\n;; operands. But in the general case (logically, for any machine),\n;; a multiply involves 3 separate things. There are two numbers\n;; that are multiplied together to produce a third. In the case\n;; of the MH instruction, it can only operate on itself. ie\n;; instead of a = b * c we have a = a * b. We need to inform GCC\n;; of that fact. We do this by saying that the second logical\n;; operand is actually the exact same thing as the first. We\n;; do this by setting the constraint to \"0\", meaning that the\n;; first operand is not just constrained to being a register -\n;; it's constrained to be the exact same register in operand 0!!!\n\n;; Finally on the last parameter, we need to tell it that the\n;; integer, e.g. \"5\", must be known at compile time. It can't\n;; be a variable. If it is a variable, it might exceed the limits\n;; of a halfword. So we tell it that it must be an \"immediate\n;; operand\". But that's not all. If the number is \"50000\", it will\n;; exceed the limit of a halfword. So we have another S/370-specific\n;; constraint. This time \"K\". \"K\" means that the value must lie\n;; between -32768 and 32767 so that this instruction can actually\n;; be used.\n\n;; That's the basics. You will need to refer to the manual for more\n;; details. However, there's more things to be aware of. There\n;; can actually be multiple constraints in the one instruction.\n;; e.g. if you want to move some data from R3 to R4, you can use\n;; the \"LR\" instruction. And to move from an RX memory address\n;; you can use \"L\". Both of these things are just \"movsi\" to GCC,\n;; and it expects to be able to move from a variety of data types.\n;; moving a constant or an arbitrary fullword in memory, are both\n;; done by the \"L\" instruction. But LR is only for registers.\n;; So we might see a constraint of \"d\" for operand 1, but \"di\"\n;; for operand 2. \"g\" would mean that we can take any data type.\n\n;; If operand 1 is \"=d,dm\" and operand 2 is \"di,F\", then what\n;; this means is that the \"di\" matches the \"d\", ignore the stuff\n;; after the comma, and the following pattern will deal with\n;; that combination. Which means that either a constant or a\n;; register can be the source, and the destination will be a\n;; register. If we now look after the comma, then we match\n;; \"dm\" with \"F\". What that means is that an immediate floating\n;; point value, such as \"5.7\" can be moved into either a\n;; data register (d) or any memory address (m). If it could only\n;; be moved into an S address, it would have an \"S\" there instead\n;; of a \"m\". So if you look at any pattern which involves \"MVC\",\n;; you will see that it is never exposed to an \"m\", it will\n;; always have an \"S\" there (or something even more stringent).\n\n;; Another thing to be aware of is that the patterns sometimes\n;; have standard names (like \"movdi\"). You can have multiple patterns\n;; to accomplish the same basic thing in different circumstances.\n;; The way it is organized is to put your preferred instructions\n;; first, and then the official name on the last one. A lot of\n;; the S/370 instructions have a first pattern that is only enabled\n;; if you activate \"TARGET_CHAR_INSTRUCTIONS\", which indeed, is on\n;; by default.\n\n;; Below here you will find documentation from my predecessors who\n;; seem to assume you've found, read, and understood the official\n;; documentation. :-)\n\n;; =======================================================================\n;; Condition codes for some of the instructions (in particular, for\n;; add, sub, shift, abs, etc. are handled with the cpp macro NOTICE_UPDATE_CC\n;;\n;; Special constraints for 370 machine description:\n;;\n;;    a -- Any address register from 1 to 15.\n;;    d -- Any register from 0 to 15.\n;;    f -- Floating point register\n;;    I -- An 8-bit constant (0..255).\n;;    J -- A 12-bit constant (0..4095).\n;;    K -- A 16-bit constant (-32768..32767).\n;;    R -- a valid S operand in an RS, SI or SS instruction, or register\n;;    S -- a valid S operand in an RS, SI or SS instruction\n;;\n;; Note this well:\n;; When defining an instruction, e.g. the movsi pattern:\n;;\n;;    (define_insn \"\"\n;;        \u00dd(set (match_operand:SI 0 \"r_or_s_operand\" \"=dm,d,dm\")\n;;            (match_operand:SI 1 \"r_or_s_operand\" \"diR,dim,*fF\"))\u00a8\n;;\n;; The \"r_or_s_operand\" predicate is used to recognize the instruction;\n;; however, it is not further used to enforce a constraint at later stages.\n;; Thus, for example, although \"r_or_s_operand\" bars operands of the form\n;; base+index+displacement, such operands can none-the-less show up during\n;; post-instruction-recog processing: thus, for example, garbage like\n;; MVC     152(4,r13),0(r5,r13) might be generated if both op0 and op1 are\n;; mem operands.   To avoid this, use the S constraint.\n;;\n;;\n;; Special formats used for outputting 370 instructions.\n;;\n;;   %B -- Print a constant byte integer.\n;;   %H -- Print a signed 16-bit constant.\n;;   %K -- Print a signed 16-bit constant signed-extended to 32-bits.\n;;   %L -- Print least significant word of a CONST_DOUBLE.\n;;   %M -- Print most significant word of a CONST_DOUBLE.\n;;   %N -- Print next register (second word of a DImode reg).\n;;   %O -- Print the offset of a memory reference (PLUS (REG) (CONST_INT)).\n;;   %R -- Print the register of a memory reference (PLUS (REG) (CONST_INT)).\n;;   %X -- Print a constant byte integer in hex.\n;;   %W -- Print a signed 32-bit int sign-extended to 64-bits.\n;;\n;; We have a special constraint for pattern matching.\n;;\n;;   s_operand -- Matches a valid S operand in a RS, SI or SS type instruction.\n;;\n;;   r_or_s_operand -- Matches a register or a valid S operand in a RS, SI\n;;\t\t       or SS type instruction or a register\n;;\n;; For MVS C/370 we use the following stack locations for:\n;;\n;;   136 - internal function result buffer\n;;   140 - numeric conversion buffer\n;;   144 - pointer to internal function result buffer\n;;   148 - start of function arguments and automatic variables\n;;\n;; For TARGET_DIGNUS or TARGET_PDPMAC we use the stack locations for:\n;;\n;;   80 - numeric conversion buffer\n;;   84 - pointer to internal function result buffer\n;;   88 - start of function arguments and automatic variables\n;;\n;; To support programs larger than a page, 4096 bytes, PAGE_REGISTER points\n;; to a page origin table, all internal labels are generated to reload the\n;; BASE_REGISTER knowing what page it is on and all branch instructions go\n;; directly to the target if it is known that the target is on the current\n;; page (essentially backward references).  All forward references and off\n;; page references are handled by loading the address of target into a\n;; register and branching indirectly.\n;;\n;; Some *di patterns have been commented out per advice from RMS, as gcc\n;; will generate the right things to do.\n;;\n;; See the note in i370.h about register 14, clobbering it, and optimization.\n;; Basically, using clobber in egcs-1.1.1 will ruin ability to optimize around\n;; branches, so don't do it.\n;;\n;; We use the \"length\" attirbute to store the max possible code size of an\n;; insn.  We use this length to estimate the length of forward branches, to\n;; determine if they're on page or off.\n\n(define_attr \"length\" \"\" (const_int 0))\n\n;;\n;;- Test instructions.\n;;\n\n;\n; tstdi instruction pattern(s).\n;\n\n(define_insn \"tstdi\"\n  \u00dd(set (cc0)\n\t(match_operand:DI 0 \"register_operand\" \"d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  return \\\"SRDA\t%0,0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; tstsi instruction pattern(s).\n;\n\n(define_insn \"tstsi\"\n  \u00dd(set (cc0)\n\t(match_operand:SI 0 \"register_operand\" \"d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LTR\t%0,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; tsthi instruction pattern(s).\n;\n\n(define_insn \"tsthi\"\n  \u00dd(set (cc0)\n\t(match_operand:HI 0 \"register_operand\" \"d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 2);\n  return \\\"CH\t%0,=H'0'\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; tstqi instruction pattern(s).\n;\n\n;(define_insn \"\"\n;  \u00dd(set (cc0)\n;\t(match_operand:QI 0 \"s_operand\" \"S\"))\u00a8\n;  \"unsigned_jump_follows_p (insn)\"\n;  \"*\n;{\n;  check_label_emit ();\n;  if (REG_P (operands\u00dd0\u00a8))\n;    {\n;      /* an unsigned compare to zero is always zero/not-zero...  */\n;      mvs_check_page (0, 4, 4);\n;      return \\\"N\t%0,=XL4'000000FF'\\\";\n;    }\n;  mvs_check_page (0, 4, 0);\n;  return \\\"CLI\t%0,0\\\";\n;}\"\n;   \u00dd(set_attr \"length\" \"4\")\u00a8\n;)\n\n;(define_insn \"tstqi\"\n;  \u00dd(set (cc0)\n;     (match_operand:QI 0 \"register_operand\" \"d\"))\u00a8\n;  \"\"\n;  \"*\n;{\n;  check_label_emit ();\n;  if (unsigned_jump_follows_p (insn))\n;    {\n;      /* an unsigned compare to zero is always zero/not-zero...  */\n;      mvs_check_page (0, 4, 4);\n;      return \\\"N\t%0,=XL4'000000FF'\\\";\n;    }\n;  mvs_check_page (0, 8, 0);\n;  return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n;}\"\n;   \u00dd(set_attr \"length\" \"8\")\u00a8\n;)\n\n;\n; tstdf instruction pattern(s).\n;\n\n(define_insn \"tstdf\"\n  \u00dd(set (cc0)\n\t(match_operand:DF 0 \"general_operand\" \"f\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LTDR\t%0,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; tstsf instruction pattern(s).\n;\n\n(define_insn \"tstsf\"\n  \u00dd(set (cc0)\n\t(match_operand:SF 0 \"general_operand\" \"f\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LTER\t%0,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;;\n;;- Compare instructions.\n;;\n\n;\n; cmpdi instruction pattern(s).\n;\n\n;(define_insn \"cmpdi\"\n;  \u00dd(set (cc0)\n;\t(compare (match_operand:DI 0 \"register_operand\" \"d\")\n;\t\t (match_operand:DI 1 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"*\n;{\n;  check_label_emit ();\n;  if (REG_P (operands\u00dd1\u00a8))\n;    {\n;      mvs_check_page (0, 8, 0);\n;      if (unsigned_jump_follows_p (insn))\n;        return \\\"CLR\t%0,%1\\;BNE\t*+6\\;CLR\t%N0,%N1\\\";\n;      return \\\"CR\t%0,%1\\;BNE\t*+6\\;CLR\t%N0,%N1\\\";\n;    }\n;  mvs_check_page (0, 12, 0);\n;  if (unsigned_jump_follows_p (insn))\n;    return \\\"CL\t%0,%M1\\;BNE\t*+8\\;CL\t%N0,%L1\\\";\n;  return \\\"C\t%0,%M1\\;BNE\t*+8\\;CL\t%N0,%L1\\\";\n;}\")\n\n;\n; cmpsi instruction pattern(s).\n;\n\n(define_insn \"cmpsi\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:SI 0 \"register_operand\" \"d\")\n\t\t (match_operand:SI 1 \"general_operand\" \"md\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      if (unsigned_jump_follows_p (insn))\n\treturn \\\"CLR\t%0,%1\\\";\n      return \\\"CR\t%0,%1\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 4);\n      if (unsigned_jump_follows_p (insn))\n\t return \\\"CL\t%0,=F'%c1'\\\";\n      return \\\"C\t%0,=F'%c1'\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  if (unsigned_jump_follows_p (insn))\n    return \\\"CL\t%0,%1\\\";\n  return \\\"C\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; cmphi instruction pattern(s).\n;\n\n; deprecate constraint d because it takes multiple instructions\n; and a memory access ...\n(define_insn \"cmphi\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:HI 0 \"register_operand\" \"d\")\n\t\t (match_operand:HI 1 \"general_operand\" \"???diS\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      if (unsigned_jump_follows_p (insn))\n\treturn \\\"STH\t%1,\\\" CONVLO \\\"(,13)\\;CLM\t%0,3,\\\" CONVLO \\\"(13)\\\";\n      return \\\"STH\t%1,\\\" CONVLO \\\"(,13)\\;CH\t%0,\\\" CONVLO \\\"(,13)\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      if (unsigned_jump_follows_p (insn))\n        {\n      mvs_check_page (0, 4, 2);\n      return \\\"CLM\t%0,3,%H1\\\";\n        }\n      mvs_check_page (0, 4, 2);\n      return \\\"CH\t%0,%H1\\\";\n    }\n  if (unsigned_jump_follows_p (insn))\n    {\n      mvs_check_page (0, 10, 0);\n      if (REG_P (operands\u00dd1\u00a8))\n\treturn \\\"STH\t%1,\\\" CONVLO \\\"(,13)\\;CLM\t%0,3,\\\" CONVLO \\\"(13)\\\";\n      return \\\"MVC\t\\\" CONVLO \\\"(2,13),%1\\;CLM\t%0,3,\\\" CONVLO \\\"(13)\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"CH\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; cmpqi instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:QI 0 \"r_or_s_operand\" \"dS\")\n\t\t (match_operand:QI 1 \"general_operand\" \"diS\")))\u00a8\n  \"unsigned_jump_follows_p (insn)\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n          return \\\"STC\t%1,\\\" CONVLO \\\"(,13)\\;CLM\t%0,1,\\\" CONVLO \\\"(13)\\\";\n        }\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  mvs_check_page (0, 4, 1);\n          return \\\"CLM\t%0,1,=XL1'%X1'\\\";\n        }\n      mvs_check_page (0, 4, 0);\n      return \\\"CLM\t%0,1,%1\\\";\n    }\n  else if (GET_CODE (operands\u00dd0\u00a8) == CONST_INT)\n    {\n      cc_status.flags |= CC_REVERSED;\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 4, 1);\n          return \\\"CLM\t%1,1,=XL1'%X0'\\\";\n        }\n      mvs_check_page (0, 4, 0);\n      return \\\"CLI\t%1,%B0\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"CLI\t%0,%B1\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == MEM)\n    {\n      mvs_check_page (0, 6, 0);\n      return \\\"CLC\t%O0(1,%R0),%1\\\";\n    }\n  cc_status.flags |= CC_REVERSED;\n  mvs_check_page (0, 4, 0);\n  return \\\"CLM\t%1,1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n(define_insn \"cmpqi\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:QI 0 \"register_operand\" \"d\")\n\t\t (match_operand:QI 1 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (unsigned_jump_follows_p (insn))\n    {\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  mvs_check_page (0, 4, 1);\n          return \\\"CLM\t%0,1,=XL1'%X1'\\\";\n        }\n      if (!(REG_P (operands\u00dd1\u00a8)))\n\t{\n\t  mvs_check_page (0, 4, 0);\n          return \\\"CLM\t%0,1,%1\\\";\n        }\n      mvs_check_page (0, 8, 0);\n      return \\\"STC\t%1,\\\" CONVLO \\\"(,13)\\;CLM\t%0,1,\\\" CONVLO \\\"(13)\\\";\n    }\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 18, 0);\n      return \\\"SLL\t%0,24\\;SRA\t%0,24\\;SLL\t%1,24\\;SRA\t%1,24\\;CR\t%0,%1\\\";\n    }\n  mvs_check_page (0, 12, 0);\n  return \\\"SLL\t%0,24\\;SRA\t%0,24\\;C\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"18\")\u00a8\n)\n\n;\n; cmpdf instruction pattern(s).\n;\n\n(define_insn \"cmpdf\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:DF 0 \"general_operand\" \"f,mF\")\n\t\t (match_operand:DF 1 \"general_operand\" \"fmF,f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"CDR\t%0,%1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"CD\t%0,%1\\\";\n    }\n  cc_status.flags |= CC_REVERSED;\n  mvs_check_page (0, 4, 0);\n  return \\\"CD\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; cmpsf instruction pattern(s).\n;\n\n(define_insn \"cmpsf\"\n  \u00dd(set (cc0)\n\t(compare (match_operand:SF 0 \"general_operand\" \"f,mF\")\n\t\t (match_operand:SF 1 \"general_operand\" \"fmF,f\")))\u00a8\n  \"\"\n  \"*\n{\ncheck_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"CER\t%0,%1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"CE\t%0,%1\\\";\n    }\n  cc_status.flags |= CC_REVERSED;\n  mvs_check_page (0, 4, 0);\n  return \\\"CE\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; cmpmemsi instruction pattern(s).\n;\n\n(define_expand \"cmpmemsi\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t  (compare (match_operand:BLK 1 \"general_operand\" \"\")\n\t\t   (match_operand:BLK 2 \"general_operand\" \"\")))\n     (use (match_operand:SI 3 \"general_operand\" \"\"))\n     (use (match_operand:SI 4 \"\" \"\"))\u00a8\n   \"\"\n   \"\n{\n  rtx op1, op2;\n\n  op1 = XEXP (operands\u00dd1\u00a8, 0);\n  if (GET_CODE (op1) == REG\n      || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG\n\t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n\t  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))\n    {\n      op1 = operands\u00dd1\u00a8;\n    }\n  else\n    {\n      op1 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op1));\n    }\n\n  op2 = XEXP (operands\u00dd2\u00a8, 0);\n  if (GET_CODE (op2) == REG\n      || (GET_CODE (op2) == PLUS && GET_CODE (XEXP (op2, 0)) == REG\n\t  && GET_CODE (XEXP (op2, 1)) == CONST_INT\n\t  && (unsigned) INTVAL (XEXP (op2, 1)) < 4096))\n    {\n      op2 = operands\u00dd2\u00a8;\n    }\n  else\n    {\n      op2 = gen_rtx_MEM (BLKmode, copy_to_mode_reg (SImode, op2));\n    }\n\n  if (GET_CODE (operands\u00dd3\u00a8) == CONST_INT\n      && (unsigned)INTVAL (operands\u00dd3\u00a8) < 256)\n    {\n      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n\t\tgen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\tgen_rtx_COMPARE (SImode, op1, op2)), /* was VOIDmode */\n\t\tgen_rtx_USE (VOIDmode, operands\u00dd3\u00a8))));\n    }\n  else\n    {\n        /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n        rtx reg1 = gen_reg_rtx (DImode);\n        rtx reg2 = gen_reg_rtx (DImode);\n        rtx result = operands\u00dd0\u00a8;\n        rtx mem1 = operands\u00dd1\u00a8;\n        rtx mem2 = operands\u00dd2\u00a8;\n        rtx len = operands\u00dd3\u00a8;\n        if (!CONSTANT_P (len))\n          len = force_reg (SImode, len);\n\n        /* Load up the address+length pairs.  */\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                        force_operand (XEXP (mem1, 0), NULL_RTX));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),\n                        force_operand (XEXP (mem2, 0), NULL_RTX));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);\n\n        /* Compare! */\n        emit_insn (gen_cmpmemsi_1 (result, reg1, reg2));\n    }\n  DONE;\n}\")\n\n; Compare a block that is less than 256 bytes in length.\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"register_operand\" \"=d\")\n\t(compare:SI (match_operand:BLK 1 \"s_operand\" \"m\")\n\t\t (match_operand:BLK 2 \"s_operand\" \"m\")))\n   (use (match_operand:SI 3 \"immediate_operand\" \"I\"))\u00a8\n  \"((unsigned) INTVAL (operands\u00dd3\u00a8) < 256)\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 22, 0);\n  return \\\"CLC\t%O1(%c3,%R1),%2\\;BH\t*+12\\;BL\t*+6\\;SLR\t%0,%0\\;LNR\t%0,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n; Compare a block that is larger than 255 bytes in length.\n;        (mem:BLK (subreg:SI (match_operand:DI 1 \"register_operand\" \"+d\") 0))\n;        (mem:BLK (subreg:SI (match_operand:DI 2 \"register_operand\" \"+d\") 0))))\n\n(define_insn \"cmpmemsi_1\"\n  \u00dd(set (match_operand:SI 0 \"register_operand\" \"+d\")\n        (compare:SI\n        (mem:BLK (match_operand:DI 1 \"register_operand\" \"+d\") )\n        (mem:BLK (match_operand:DI 2 \"register_operand\" \"+d\") )))\n   (use (match_dup 1))\n   (use (match_dup 2))\n   (clobber (match_dup 1))\n   (clobber (match_dup 2))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 18, 0);\n  return \\\"LA\t%0,1(0,0)\\;CLCL\t%1,%2\\;BH\t*+12\\;BL\t*+6\\;SLR\t%0,%0\\;LNR\t%0,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"18\")\u00a8\n)\n\n;;\n;;- Move instructions.\n;;\n\n;\n; movdi instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,m,S\")\n        (match_operand:DI 1 \"general_operand\" \"g,d,SF\"))\u00a8\n;;  \u00dd(set (match_operand:DI 0 \"r_or_s_operand\" \"=dS,m\")\n;;        (match_operand:DI 1 \"r_or_s_operand\" \"diS*fF,d*fF\"))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STD\t%1,\\\" CONVLO \\\"(,13)\\;LM\t%0,%N0,\\\" CONVLO \\\"(13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LR\t%0,%1\\;LR\t%N0,%N1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"SLR\t%0,%0\\;SLR\t%N0,%N0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n  \t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 6, 0);\n\t  return \\\"SLR\t%0,%0\\;LA\t%N0,%c1(0,0)\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"L\t%0,%1\\;SRDA\t%0,32\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_DOUBLE)\n\t{\n\t  mvs_check_page (0, 6, 8);\n\t  return \\\"LM\t%0,%N0,%1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      /*return \\\"LM\t%0,%N0,%1\\\";*/\n      return \\\"L\t%0,%1\\;L\t%N0,4+%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STD\t%1,%0\\\";\n    }\n  else if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      /*return \\\"STM\t%1,%N1,%0\\\"; */\n      return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\";\n    }\n  mvs_check_page (0, 6, 8);\n  return \\\"MVC\t%O0(8,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n(define_insn \"movdi\"\n  \u00dd(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,dm\")\n\t(match_operand:DI 1 \"general_operand\" \"dimF,*fd\"))\u00a8\n;;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"=d,dm\")\n;;\t(match_operand:DI 1 \"r_or_s_operand\" \"diSF,*fd\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STD\t%1,\\\" CONVLO \\\"(,13)\\;LM\t%0,%N0,\\\" CONVLO \\\"(13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LR\t%0,%1\\;LR\t%N0,%N1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"SLR\t%0,%0\\;SLR\t%N0,%N0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n  \t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 6, 0);\n\t  return \\\"SLR\t%0,%0\\;LA\t%N0,%c1(0,0)\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"L\t%0,%1\\;SRDA\t%0,32\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      /*return \\\"LM\t%0,%N0,%1\\\";*/\n      return \\\"L\t%0,%1\\;L\t%N0,4+%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STD\t%1,%0\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  /*return \\\"STM\t%1,%N1,%0\\\"; */\n  return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;; we have got to provide a movdi alternative that will go from\n;; register to memory & back in its full glory.  However, we try to\n;; discourage its use by listing this alternative last.\n;; The problem is that the instructions above only provide\n;; S-form style (base + displacement) mem access, while the\n;; below provides the full (base+index+displacement) RX-form.\n;; These are rarely needed, but when needed they're needed.\n;; Don't use LM/STM as they can't handle a full RX-form address.\n\n;;(define_insn \"\"\n;;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"=d,???m\")\n;;        (match_operand:DI 1 \"general_operand\" \"???m,d\"))\u00a8\n;;\n;;  \"\"\n;;  \"*\n;;{\n;;  check_label_emit ();\n;;  if (REG_P (operands\u00dd0\u00a8))\n;;    {\n;;      mvs_check_page (0, 8, 0);\n;;      return \\\"L\t%0,%1\\;L\t%N0,4+%1\\\";\n;;    }\n;;  else if (REG_P (operands\u00dd1\u00a8))\n;;    {\n;;      mvs_check_page (0, 8, 0);\n;;      return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\";\n;;    }\n;;  mvs_check_page (0, 6, 8);\n;;  return \\\"MVC\t%O0(8,%R0),%1\\\";\n;;}\"\n;;   \u00dd(set_attr \"length\" \"8\")\u00a8\n;;)\n\n;\n; movsi instruction pattern(s).\n;\n\n; For some reason, presumably a bug somewhere, we need to use\n; \"R\" in the constraint rather than \"S\", otherwise it doesn't\n; allow MVCs to be generated in circumstances where it should.\n; Using \"R\" is harmless enough in this circumstance though.\n\n(define_insn \"movsi\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,dm,R\")\n\t(match_operand:SI 1 \"general_operand\" \"dimF,*fd,R\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STE\t%1,\\\" CONVLO \\\"(,13)\\;L\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n\t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LA\t%0,%c1(0,0)\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"L\t%0,%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STE\t%1,%0\\\";\n    }\n  else if (!REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 6, 0);\n      return \\\"MVC\t%O0(4,%R0),%1\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"ST\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; movhi instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:HI 0 \"r_or_s_operand\" \"=R,d\")\n        (match_operand:HI 1 \"general_operand\" \"R,g\"))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n\t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LA\t%0,%c1(0,0)\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  mvs_check_page (0, 4, 2);\n\t  return \\\"LH\t%0,%H1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LH\t%0,%1\\\";\n    }\n  else if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STH\t%1,%0\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 6, 2);\n      return \\\"MVC\t%O0(2,%R0),%H1\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"MVC\t%O0(2,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"movhi\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,m\")\n\t(match_operand:HI 1 \"general_operand\" \"g,d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n\t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LA\t%0,%c1(0,0)\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  mvs_check_page (0, 4, 2);\n\t  return \\\"LH\t%0,%H1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LH\t%0,%1\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"STH\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; movqi instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:QI 0 \"r_or_s_operand\" \"=R,d\")\n\t(match_operand:QI 1 \"general_operand\" \"R,g\"))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  if ((INTVAL (operands\u00dd1\u00a8) >= 0)\n  \t      && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t    {\n\t      mvs_check_page (0, 4, 0);\n\t      return \\\"LA\t%0,%c1(0,0)\\\";\n\t    }\n\t  mvs_check_page (0, 4, 4);\n\t  return \\\"L\t%0,=F'%c1'\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"IC\t%0,%1\\\";\n    }\n  else if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STC\t%1,%0\\\";\n    }\n  else if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"MVI\t%0,%B1\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"MVC\t%O0(1,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"movqi\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,m\")\n\t(match_operand:QI 1 \"general_operand\" \"g,d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  if ((INTVAL (operands\u00dd1\u00a8) >= 0)\n  \t      && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t    {\n\t      mvs_check_page (0, 4, 0);\n\t      return \\\"LA\t%0,%c1(0,0)\\\";\n\t    }\n\t  mvs_check_page (0, 4, 4);\n\t  return \\\"L\t%0,=F'%c1'\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"IC\t%0,%1\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"STC\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; movstrictqi instruction pattern(s).\n;\n; Need to comment this out in 3.4.6 because otherwise we are\n; getting an IC generated followed by a branch, when there\n; should have been an intervening compare.\n\n;(define_insn \"movstrictqi\"\n;  \u00dd(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+d\"))\n;   (match_operand:QI 1 \"general_operand\" \"g\"))\u00a8\n;  \"\"\n;  \"*\n;{\n;  check_label_emit ();\n;  if (REG_P (operands\u00dd1\u00a8))\n;    {\n;      mvs_check_page (0, 8, 0);\n;      return \\\"STC\t%1,\\\" CONVLO \\\"(,13)\\;IC\t%0,\\\" CONVLO \\\"(,13)\\\";\n;    }\n;  mvs_check_page (0, 4, 0);\n;  return \\\"IC\t%0,=XL1'%X1'\\\";\n;}\"\n;   \u00dd(set_attr \"length\" \"8\")\u00a8\n;)\n\n;\n; movstricthi instruction pattern(s).\n;\n; Need to comment this out in 3.4.6 because otherwise we are\n; getting code like this (example from stdio):\n\n; SLR   2,2\n; IC    2,0(8)\n; LA    5,92(0,0)\n; CLR   2,5\n; BE    L699\n; BH    L702\n; ICM   5,3,=H'64'\n; BE    L696\n; ICM   5,3,=H'78'\n; BE    L694\n\n; ie using ICM instead of LA, and then failing to actually do\n; the compare! Was causing a branch to not be done (for the \"+\")\n; in stdio ; when doing printf(\"%+d\")\n\n;(define_insn \"\"\n;  \u00dd(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n;\t(match_operand:HI 1 \"general_operand\" \"dSi\"))\u00a8\n;  \"\"\n;  \"*\n;{\n;  check_label_emit ();\n;  if (REG_P (operands\u00dd1\u00a8))\n;    {\n;      mvs_check_page (0, 8, 0);\n;      return \\\"STH\t%1,\\\" CONVLO \\\"(,13)\\;ICM\t%0,3,\\\" CONVLO \\\"(13)\\\";\n;    }\n;  else if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n;    {\n;      mvs_check_page (0, 4, 2);\n;      return \\\"ICM\t%0,3,%H1\\\";\n;    }\n;  mvs_check_page (0, 4, 0);\n;  return \\\"ICM\t%0,3,%1\\\";\n;}\"\n;   \u00dd(set_attr \"length\" \"8\")\u00a8\n;)\n\n(define_insn \"movstricthi\"\n  \u00dd(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n\t(match_operand:HI 1 \"general_operand\" \"d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"STH\t%1,\\\" CONVLO \\\"(,13)\\;ICM\t%0,3,\\\" CONVLO \\\"(13)\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"STH\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; movdf instruction pattern(s).\n;\n\n(define_insn \"\"\n;;  \u00dd(set (match_operand:DF 0 \"r_or_s_operand\" \"=fm,fm,*dm\")\n;;        (match_operand:DF 1 \"r_or_s_operand\" \"fmF,*dm,fmF\"))\u00a8\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,fS,*dS,???d\")\n      (match_operand:DF 1 \"general_operand\" \"fmF,f,*dS,fSF,???d\"))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LDR\t%0,%1\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STM\t%1,%N1,\\\" CONVLO \\\"(13)\\;LD\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SDR\t%0,%0\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LD\t%0,%1\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 12, 0);\n\t  return \\\"STD\t%1,\\\" CONVLO \\\"(,13)\\;LM\t%0,%N0,\\\" CONVLO \\\"(13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LR\t%0,%1\\;LR\t%N0,%N1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LM\t%0,%N0,%1\\\";\n      /*return \\\"L\t%0,%1\\;L\t%N0,4+%1\\\";*/\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STD\t%1,%0\\\";\n    }\n  else if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      /*return \\\"STM\t%1,%N1,%0\\\"; */\n      return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\";\n    }\n  mvs_check_page (0, 6, 8);\n  return \\\"MVC\t%O0(8,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"12\")\u00a8\n)\n\n(define_insn \"movdf\"\n;;  \u00dd(set (match_operand:DF 0 \"general_operand\" \"=f,fm,m,*d\")\n;;\t(match_operand:DF 1 \"general_operand\" \"fmF,*d,f,fmF\"))\u00a8\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,fS,*d,???d\")\n      (match_operand:DF 1 \"general_operand\" \"fmF,f,*d,SfF,???d\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LDR\t%0,%1\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STM\t%1,%N1,\\\" CONVLO \\\"(13)\\;LD\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SDR\t%0,%0\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LD\t%0,%1\\\";\n    }\n  else if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 12, 0);\n\t  return \\\"STD\t%1,\\\" CONVLO \\\"(,13)\\;LM\t%0,%N0,\\\" CONVLO \\\"(13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LR\t%0,%1\\;LR\t%N0,%N1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      /*return \\\"LM\t%0,%N0,%1\\\";*/\n      return \\\"L\t%0,%1\\;L\t%N0,4+%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STD\t%1,%0\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  /*return \\\"STM\t%1,%N1,%0\\\"; */\n  return \\\"ST\t%1,%0\\;ST\t%N1,4+%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"12\")\u00a8\n)\n\n;\n; movsf instruction pattern(s).\n;\n\n(define_insn \"\"\n;;  \u00dd(set (match_operand:SF 0 \"r_or_s_operand\" \"=fm,fm,*dm\")\n;;        (match_operand:SF 1 \"r_or_s_operand\" \"fmF,*dm,fmF\"))\u00a8\n;;  \u00dd(set (match_operand:SF 0 \"general_operand\" \"=f,m,fm,*d,S\")\n;;         (match_operand:SF 1 \"general_operand\" \"fmF,fF,*d,fmF,S\"))\u00a8\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f*d,fm,S,???d\")\n        (match_operand:SF 1 \"general_operand\" \"fmF,fF*d,S,???d\"))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LER\t%0,%1\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"ST\t%1,\\\" CONVLO \\\"(,13)\\;LE\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SER\t%0,%0\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LE\t%0,%1\\\";\n    }\n  else if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STE\t%1,\\\" CONVLO \\\"(,13)\\;L\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LR\t%0,%1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"L\t%0,%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STE\t%1,%0\\\";\n    }\n  else if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"ST\t%1,%0\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"MVC\t%O0(4,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n(define_insn \"movsf\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,fm,m,*d\")\n\t(match_operand:SF 1 \"general_operand\" \"fmF,*d,f,fmF\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"LER\t%0,%1\\\";\n\t}\n      if (REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"ST\t%1,\\\" CONVLO \\\"(,13)\\;LE\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SER\t%0,%0\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LE\t%0,%1\\\";\n    }\n  else if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (FP_REG_P (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 8, 0);\n\t  return \\\"STE\t%1,\\\" CONVLO \\\"(,13)\\;L\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"L\t%0,%1\\\";\n    }\n  else if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"STE\t%1,%0\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"ST\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; clrstrsi instruction pattern(s).\n; memset a block of bytes to zero.\n; block must be less than 16M (24 bits) in length\n;\n(define_expand \"clrstrsi\"\n  \u00dd(set (match_operand:BLK 0 \"general_operand\" \"g\")\n        (const_int 0))\n   (use (match_operand:SI  1 \"general_operand\" \"\"))\n   (match_operand 2 \"\" \"\")\u00a8\n   \"\"\n   \"\n{\n  {\n        /* implementation suggested by  Richard Henderson <rth@cygnus.com> */\n        rtx reg1 = gen_reg_rtx (DImode);\n        rtx reg2 = gen_reg_rtx (DImode);\n        rtx mem1 = operands\u00dd0\u00a8;\n        rtx zippo = gen_rtx_CONST_INT (SImode, 0);\n        rtx len = operands\u00dd1\u00a8;\n        if (!CONSTANT_P (len))\n          len = force_reg (SImode, len);\n\n        /* Load up the address+length pairs.  */\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                        force_operand (XEXP (mem1, 0), NULL_RTX));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0), zippo);\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), zippo);\n\n        /* Copy! */\n        emit_insn (gen_movstrsi_1 (reg1, reg2));\n  }\n  DONE;\n}\")\n\n;\n; movstrsi instruction pattern(s).\n; block must be less than 16M (24 bits) in length\n\n(define_expand \"movstrsi\"\n  \u00dd(set (match_operand:BLK 0 \"general_operand\" \"\")\n        (match_operand:BLK 1 \"general_operand\" \"\"))\n   (use (match_operand:SI  2 \"general_operand\" \"\"))\n   (match_operand 3 \"\" \"\")\u00a8\n   \"\"\n   \"\n{\n  rtx op0, op1;\n\n  op0 = XEXP (operands\u00dd0\u00a8, 0);\n  if (GET_CODE (op0) == REG\n      || (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 0)) == REG\n\t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n\t  && (unsigned) INTVAL (XEXP (op0, 1)) < 4096))\n    op0 = operands\u00dd0\u00a8;\n  else\n    op0 = replace_equiv_address (operands\u00dd0\u00a8, copy_to_mode_reg (SImode, op0));\n\n  op1 = XEXP (operands\u00dd1\u00a8, 0);\n  if (GET_CODE (op1) == REG\n      || (GET_CODE (op1) == PLUS && GET_CODE (XEXP (op1, 0)) == REG\n\t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n\t  && (unsigned) INTVAL (XEXP (op1, 1)) < 4096))\n    op1 = operands\u00dd1\u00a8;\n  else\n    op1 = replace_equiv_address (operands\u00dd1\u00a8, copy_to_mode_reg (SImode, op1));\n\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT && INTVAL (operands\u00dd2\u00a8) < 256)\n    emit_insn (gen_rtx_PARALLEL (VOIDmode,\n\t\t\tgen_rtvec (2,\n\t\t\t\t   gen_rtx_SET (VOIDmode, op0, op1),\n\t\t\t\t   gen_rtx_USE (VOIDmode, operands\u00dd2\u00a8))));\n\n  else\n    {\n        /* implementation provided by  Richard Henderson <rth@cygnus.com> */\n        rtx reg1 = gen_reg_rtx (DImode);\n        rtx reg2 = gen_reg_rtx (DImode);\n        rtx mem1 = operands\u00dd0\u00a8;\n        rtx mem2 = operands\u00dd1\u00a8;\n        rtx len = operands\u00dd2\u00a8;\n        if (!CONSTANT_P (len))\n          len = force_reg (SImode, len);\n\n        /* Load up the address+length pairs.  */\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                        force_operand (XEXP (mem1, 0), NULL_RTX));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n\n        emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),\n                        force_operand (XEXP (mem2, 0), NULL_RTX));\n        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);\n\n        /* Copy! */\n        emit_insn (gen_movstrsi_1 (reg1, reg2));\n    }\n  DONE;\n}\")\n\n; Move a block that is less than 256 bytes in length.\n\n(define_insn \"\"\n  \u00dd(set (match_operand:BLK 0 \"s_operand\" \"=m\")\n\t(match_operand:BLK 1 \"s_operand\" \"m\"))\n   (use (match_operand 2 \"immediate_operand\" \"I\"))\u00a8\n  \"((unsigned) INTVAL (operands\u00dd2\u00a8) < 256)\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 6, 0);\n  return \\\"MVC\t%O0(%c2,%R0),%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n; Move a block that is larger than 255 bytes in length.\n;  \u00dd(set (mem:BLK (subreg:SI (match_operand:DI 0 \"register_operand\" \"+d\") 0))\n;        (mem:BLK (subreg:SI (match_operand:DI 1 \"register_operand\" \"+d\") 0)))\n\n(define_insn \"movstrsi_1\"\n  \u00dd(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"+d\") )\n        (mem:BLK (match_operand:DI 1 \"register_operand\" \"+d\") ))\n   (use (match_dup 0))\n   (use (match_dup 1))\n   (clobber (match_dup 0))\n   (clobber (match_dup 1))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"MVCL\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;;\n;;- Conversion instructions.\n;;\n\n;\n; extendsidi2 instruction pattern(s).\n;\n\n(define_expand \"extendsidi2\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n        (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  if (GET_CODE (operands\u00dd1\u00a8) != CONST_INT)\n    {\n      emit_insn (gen_rtx_SET (VOIDmode,\n\t\t  operand_subword (operands\u00dd0\u00a8, 0, 1, DImode), operands\u00dd1\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\tgen_rtx_ASHIFTRT (DImode, operands\u00dd0\u00a8,\n\t\t\t\tgen_rtx_CONST_INT (SImode, 32))));\n    }\n  else\n    {\n      if (INTVAL (operands\u00dd1\u00a8) < 0)\n\t{\n\t  emit_insn (gen_rtx_SET (VOIDmode,\n\t\t\t\t  operand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n\t\t\t       gen_rtx_CONST_INT (SImode, -1)));\n        }\n      else\n\t{\n\t  emit_insn (gen_rtx_SET (VOIDmode,\n\t\t\t\toperand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n\t\t\t       gen_rtx_CONST_INT (SImode, 0)));\n        }\n      emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (SImode, operands\u00dd0\u00a8),\n\t\t\t   operands\u00dd1\u00a8));\n    }\n  DONE;\n}\")\n\n;\n; extendhisi2 instruction pattern(s).\n;\n\n(define_insn \"extendhisi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,m\")\n\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g,d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (REG_P (operands\u00dd1\u00a8))\n      {\n        if (REGNO (operands\u00dd0\u00a8) != REGNO (operands\u00dd1\u00a8))\n\t  {\n\t    mvs_check_page (0, 10, 0);\n            return \\\"LR\t%0,%1\\;SLL\t%0,16\\;SRA\t%0,16\\\";\n\t  }\n        else\n          return \\\"\\\"; /* Should be empty.  16-bits regs are always 32-bits.  */\n      }\n      if (operands\u00dd1\u00a8 == const0_rtx)\n\t{\n\t  CC_STATUS_INIT;\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"SLR\t%0,%0\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n \t  && (unsigned) INTVAL (operands\u00dd1\u00a8) < 4096)\n\t{\n\t  mvs_check_page (0, 4, 0);\n\t  return \\\"LA\t%0,%c1(0,0)\\\";\n\t}\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n\t{\n\t  mvs_check_page (0, 4, 2);\n\t  return \\\"LH\t%0,%H1\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"LH\t%0,%1\\\";\n    }\n  mvs_check_page (0, 12, 0);\n  return \\\"SLL\t%1,16\\;SRA\t%1,16\\;ST\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"12\")\u00a8\n)\n\n;\n; extendqisi2 instruction pattern(s).\n;\n\n(define_insn \"extendqisi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"0mi\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n    }\n  if (s_operand (operands\u00dd1\u00a8, GET_MODE (operands\u00dd1\u00a8)))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"ICM\t%0,8,%1\\;SRA\t%0,24\\\";\n    }\n  mvs_check_page (0, 12, 0);\n  return \\\"IC\t%0,%1\\;SLL\t%0,24\\;SRA\t%0,24\\\";\n}\"\n   \u00dd(set_attr \"length\" \"12\")\u00a8\n)\n\n;\n; extendqihi2 instruction pattern(s).\n;\n\n(define_insn \"extendqihi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"0m\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n    }\n  if (s_operand (operands\u00dd1\u00a8, GET_MODE (operands\u00dd1\u00a8)))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"ICM\t%0,8,%1\\;SRA\t%0,24\\\";\n    }\n  mvs_check_page (0, 12, 0);\n  return \\\"IC\t%0,%1\\;SLL\t%0,24\\;SRA\t%0,24\\\";\n}\"\n   \u00dd(set_attr \"length\" \"12\")\u00a8\n)\n\n;\n; zero_extendsidi2 instruction pattern(s).\n;\n\n(define_expand \"zero_extendsidi2\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n        (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n      emit_insn (gen_rtx_SET (VOIDmode,\n\t\t  operand_subword (operands\u00dd0\u00a8, 0, 1, DImode), operands\u00dd1\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\tgen_rtx_LSHIFTRT (DImode, operands\u00dd0\u00a8,\n\t\t\t\tgen_rtx_CONST_INT (SImode, 32))));\n  DONE;\n}\")\n\n;\n; zero_extendhisi2 instruction pattern(s).\n;\n\n(define_insn \"zero_extendhisi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n  CC_STATUS_INIT;\n  mvs_check_page (0, 4, 4);\n  return \\\"N\t%1,=XL4'0000FFFF'\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; zero_extendqisi2 instruction pattern(s).\n;\n\n(define_insn \"zero_extendqisi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,&d\")\n\t(zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0i,m\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n      CC_STATUS_INIT;\n      mvs_check_page (0, 4, 4);\n      return \\\"N\t%0,=XL4'000000FF'\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"LA\t%0,%c1(0,0)\\\";\n    }\n  CC_STATUS_INIT;\n  mvs_check_page (0, 8, 0);\n  return \\\"SLR\t%0,%0\\;IC\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; zero_extendqihi2 instruction pattern(s).\n;\n\n(define_insn \"zero_extendqihi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,&d\")\n\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0i,m\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd1\u00a8))\n    {\n      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n      CC_STATUS_INIT;\n      mvs_check_page (0, 4, 4);\n      return \\\"N\t%0,=XL4'000000FF'\\\";\n    }\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"LA\t%0,%c1(0,0)\\\";\n    }\n  CC_STATUS_INIT;\n  mvs_check_page (0, 8, 0);\n  return \\\"SLR\t%0,%0\\;IC\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; truncsihi2 instruction pattern(s).\n;\n\n(define_insn \"truncsihi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,m\")\n\t(truncate:HI (match_operand:SI 1 \"general_operand\" \"0,d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n      mvs_check_page (0, 8, 0);\n      return \\\"SLL\t%0,16\\;SRA\t%0,16\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"STH\t%1,%0\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; fix_truncdfsi2 instruction pattern(s).\n;\n\n(define_insn \"fix_truncdfsi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n        (fix:SI (truncate:DF (match_operand:DF 1 \"general_operand\" \"f\"))))\n\t(clobber (reg:DF 16))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;\n  if (REGNO (operands\u00dd1\u00a8) == 16)\n    {\n      mvs_check_page (0, 12, 8);\n      return \\\"AD\t0,=XL8'4F08000000000000'\\;STD\t0,\\\" CONVLO \\\"(,13)\\;L\t%0,\\\" CONVHI \\\"(,13)\\\";\n    }\n  mvs_check_page (0, 14, 8);\n  return \\\"LDR\t0,%1\\;AD\t0,=XL8'4F08000000000000'\\;STD\t0,\\\" CONVLO \\\"(,13)\\;L\t%0,\\\" CONVHI \\\"(,13)\\\";\n}\"\n   \u00dd(set_attr \"length\" \"14\")\u00a8\n)\n\n;\n; floatsidf2 instruction pattern(s).\n;\n; LE/370 mode uses the float field of the TCA.\n;\n\n(define_insn \"floatsidf2\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n        (float:DF (match_operand:SI 1 \"general_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;\n#if defined(TARGET_LINUX)\n  mvs_check_page (0, 22, 12);\n  return \\\"MVC\t\\\" CONVLO \\\"(4,13),=XL4'4E000000'\\;ST\t%1,\\\" CONVLO \\\"+4(,13)\\;XI\t\\\" CONVLO \\\"+4(13),128\\;LD\t%0,\\\" CONVLO \\\"(,13)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n#elif defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n  mvs_check_page (0, 22, 12);\n  return \\\"MVC\t\\\" CONVLO \\\"(4,13),=XL8'4E00000080000000'\\;ST\t%1,\\\" CONVHI \\\"(,13)\\;XI\t\\\" CONVHI \\\"(13),128\\;LD\t%0,\\\" CONVLO \\\"(,13)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n#else\n  mvs_check_page (0, 16, 8);\n  return \\\"ST\t%1,508(,12)\\;XI\t508(12),128\\;LD\t%0,504(,12)\\;SD\t%0,=XL8'4E00000080000000'\\\";\n#endif\n}\"\n   \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n;\n; truncdfsf2 instruction pattern(s).\n;\n\n(define_insn \"truncdfsf2\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n        (float_truncate:SF (match_operand:DF 1 \"general_operand\" \"f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LRER\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; extendsfdf2 instruction pattern(s).\n;\n\n(define_insn \"extendsfdf2\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n        (float_extend:DF (match_operand:SF 1 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_SET (0, const0_rtx);\n  if (FP_REG_P (operands\u00dd1\u00a8))\n    {\n      if (REGNO (operands\u00dd0\u00a8) == REGNO (operands\u00dd1\u00a8))\n\t{\n\t  mvs_check_page (0, 10, 0);\n\t  return \\\"STE\t%1,\\\" CONVLO \\\"(,13)\\;SDR\t%0,%0\\;LE\t%0,\\\" CONVLO \\\"(,13)\\\";\n\t}\n      mvs_check_page (0, 4, 0);\n      return \\\"SDR\t%0,%0\\;LER\t%0,%1\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"SDR\t%0,%0\\;LE\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;;\n;;- Add instructions.\n;;\n\n;\n; adddi3 instruction pattern(s).\n;\n;\n;(define_expand \"adddi3\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(plus:DI (match_operand:DI 1 \"general_operand\" \"\")\n;\t\t (match_operand:DI 2 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx label = gen_label_rtx ();\n;  rtx op0_high = operand_subword (operands\u00dd0\u00a8, 0, 1, DImode);\n;  rtx op0_low = gen_lowpart (SImode, operands\u00dd0\u00a8);\n;\n;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,\n;\t\t    gen_rtx_PLUS (SImode,\n;\t\t\t    operand_subword (operands\u00dd1\u00a8, 0, 1, DImode),\n;\t\t\t    operand_subword (operands\u00dd2\u00a8, 0, 1, DImode))));\n;  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n;\t      gen_rtx_SET (VOIDmode, op0_low,\n;\t\t      gen_rtx_PLUS (SImode, gen_lowpart (SImode, operands\u00dd1\u00a8),\n;\t\t\t      gen_lowpart (SImode, operands\u00dd2\u00a8))),\n;\t      gen_rtx_USE (VOIDmode, gen_rtx_LABEL_REF (VOIDmode, label)))));\n;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,\n;\t\t    gen_rtx_PLUS (SImode, op0_high,\n;\t\t\t    gen_rtx_CONST_INT (SImode, 1))));\n;  emit_label (label);\n;  DONE;\n;}\")\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\n   (use (label_ref (match_operand 3 \"\" \"\")))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  int onpage;\n\n  check_label_emit ();\n  onpage = mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd3\u00a8));\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      if (!onpage)\n\t{\n\t  mvs_check_page (0, 8, 4);\n\t  return \\\"ALR\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n\t}\n      if (mvs_check_page (0, 6, 0))\n\t{\n\t  mvs_check_page (0, 2, 4);\n\t  return \\\"ALR\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n\t}\n      return \\\"ALR\t%0,%2\\;BC\t12,%l3\\\";\n    }\n  if (!onpage)\n    {\n      mvs_check_page (0, 10, 4);\n      return \\\"AL\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n    }\n  if (mvs_check_page (0, 8 ,0))\n    {\n      mvs_check_page (0, 2, 4);\n      return \\\"AL\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n    }\n  return \\\"AL\t%0,%2\\;BC\t12,%l3\\\";\n}\"\n   \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;\n; addsi3 instruction pattern(s).\n;\n; The following insn is used when it is known that operand one is an address,\n; frame, stack or argument pointer, and operand two is a constant that is\n; small enough to fit in the displacement field.\n; Notice that we can't allow the frame pointer to used as a normal register\n; because of this insn.\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"register_operand\" \"=d\")\n\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%a\")\n\t\t (match_operand:SI 2 \"immediate_operand\" \"J\")))\u00a8\n  \"((REGNO (operands\u00dd1\u00a8) == FRAME_POINTER_REGNUM || REGNO (operands\u00dd1\u00a8) == ARG_POINTER_REGNUM || REGNO (operands\u00dd1\u00a8) == STACK_POINTER_REGNUM) && (unsigned) INTVAL (operands\u00dd2\u00a8) < 4096)\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */\n  mvs_check_page (0, 4, 0);\n  return \\\"LA\t%0,%c2(,%1)\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n; This insn handles additions that are relative to the frame pointer.\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (plus:SI (match_operand:SI 1 \"register_operand\" \"%a\")\n                  (match_operand:SI 2 \"immediate_operand\" \"i\")))\u00a8\n  \"REGNO (operands\u00dd1\u00a8) == FRAME_POINTER_REGNUM\"\n  \"*\n{\n  check_label_emit ();\n  if ((unsigned) INTVAL (operands\u00dd2\u00a8) < 4096)\n    {\n      CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */\n      mvs_check_page (0, 4, 0);\n      return \\\"LA\t%0,%c2(,%1)\\\";\n    }\n  if (REGNO (operands\u00dd1\u00a8) == REGNO (operands\u00dd0\u00a8))\n    {\n      CC_STATUS_INIT;\n      mvs_check_page (0, 4, 0);\n      return \\\"A\t%0,%2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"L\t%0,%2\\;AR\t%0,%1\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;;\n;; The CC status bits for the arithmetic instructions are handled\n;; in the NOTICE_UPDATE_CC macro (yeah???) and so they do not need\n;; to be set below.  They only need to be invalidated if *not* set\n;; (e.g. by BCTR) ... yeah I think that's right ...\n;;\n\n(define_insn \"addsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"AR\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      if (INTVAL (operands\u00dd2\u00a8) == -1)\n\t{\n          CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"BCTR\t%0,0\\\";\n\t}\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"A\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; addhi3 instruction pattern(s).\n;\n\n(define_insn \"addhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n\t\t (match_operand:HI 2 \"general_operand\" \"dmi\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"STH\t%2,\\\" CONVLO \\\"(,13)\\;AH\t%0,\\\" CONVLO \\\"(,13)\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      if (INTVAL (operands\u00dd2\u00a8) == -1)\n\t{\n          CC_STATUS_INIT;  /* add assumes CC but BCTR doesn't set CC */\n\t  mvs_check_page (0, 2, 0);\n\t  return \\\"BCTR\t%0,0\\\";\n\t}\n      mvs_check_page (0, 4, 2);\n      return \\\"AH\t%0,%H2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"AH\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; addqi3 instruction pattern(s).\n;\n\n(define_insn \"addqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%a\")\n\t\t (match_operand:QI 2 \"general_operand\" \"ai\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* add assumes CC but LA doesn't set CC */\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"LA\t%0,0(%1,%2)\\\";\n  return \\\"LA\t%0,%B2(,%1)\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; adddf3 instruction pattern(s).\n;\n\n(define_insn \"adddf3\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"ADR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"AD\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; addsf3 instruction pattern(s).\n;\n\n(define_insn \"addsf3\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n\t\t (match_operand:SF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"AER\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"AE\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Subtract instructions.\n;;\n\n;\n; subdi3 instruction pattern(s).\n;\n;\n;(define_expand \"subdi3\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(minus:DI (match_operand:DI 1 \"general_operand\" \"\")\n;\t\t  (match_operand:DI 2 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx label = gen_label_rtx ();\n;  rtx op0_high = operand_subword (operands\u00dd0\u00a8, 0, 1, DImode);\n;  rtx op0_low = gen_lowpart (SImode, operands\u00dd0\u00a8);\n;\n;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,\n;\t\t    gen_rtx_MINUS (SImode,\n;\t\t\t      operand_subword (operands\u00dd1\u00a8, 0, 1, DImode),\n;\t\t\t      operand_subword (operands\u00dd2\u00a8, 0, 1, DImode))));\n;  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n;\t\t    gen_rtx_SET (VOIDmode, op0_low,\n;\t\t\t      gen_rtx_MINUS (SImode,\n;\t\t\t\t      gen_lowpart (SImode, operands\u00dd1\u00a8),\n;\t\t\t\t      gen_lowpart (SImode, operands\u00dd2\u00a8))),\n;\t\t    gen_rtx_USE (VOIDmode,\n;\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label)))));\n;  emit_insn (gen_rtx_SET (VOIDmode, op0_high,\n;\t\t      gen_rtx_MINUS (SImode, op0_high,\n;\t\t\t      gen_rtx_CONST_INT (SImode, 1))));\n;  emit_label (label);\n;  DONE;\n;}\")\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n\t\t  (match_operand:SI 2 \"general_operand\" \"g\")))\n   (use (label_ref (match_operand 3 \"\" \"\")))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  int onpage;\n\n  check_label_emit ();\n  CC_STATUS_INIT;\n  onpage = mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd3\u00a8));\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      if (!onpage)\n\t{\n\t  mvs_check_page (0, 8, 4);\n\t  return \\\"SLR\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n\t}\n      if (mvs_check_page (0, 6, 0))\n\t{\n\t  mvs_check_page (0, 2, 4);\n\t  return \\\"SLR\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n\t}\n      return \\\"SLR\t%0,%2\\;BC\t12,%l3\\\";\n    }\n  if (!onpage)\n    {\n      mvs_check_page (0, 10, 4);\n      return \\\"SL\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n    }\n  if (mvs_check_page (0, 8, 0))\n    {\n      mvs_check_page (0, 2, 4);\n      return \\\"SL\t%0,%2\\;L\t14,=A(%l3)\\;BCR\t12,14\\\";\n    }\n  return \\\"SL\t%0,%2\\;BC\t12,%l3\\\";\n}\"\n   \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;\n; subsi3 instruction pattern(s).\n;\n\n(define_insn \"subsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n\t\t  (match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"SR\t%0,%2\\\";\n    }\n  if (operands\u00dd2\u00a8 == const1_rtx)\n    {\n      CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */\n      mvs_check_page (0, 2, 0);\n      return \\\"BCTR\t%0,0\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"S\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; subhi3 instruction pattern(s).\n;\n\n(define_insn \"subhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n\t\t  (match_operand:HI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 8, 0);\n      return \\\"STH\t%2,\\\" CONVLO \\\"(,13)\\;SH\t%0,\\\" CONVLO \\\"(,13)\\\";\n    }\n  if (operands\u00dd2\u00a8 == const1_rtx)\n    {\n      CC_STATUS_INIT;  /* subtract assumes CC but BCTR doesn't set CC */\n      mvs_check_page (0, 2, 0);\n      return \\\"BCTR\t%0,0\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 2);\n      return \\\"SH\t%0,%H2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"SH\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; subqi3 instruction pattern(s).\n;\n\n;(define_expand \"subqi3\"\n;  \u00dd(set (match_operand:QI 0 \"register_operand\" \"=d\")\n;\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n;\t\t  (match_operand:QI 2 \"general_operand\" \"di\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  if (REG_P (operands\u00dd2\u00a8))\n;    {\n;      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n;\t\t\tgen_rtx_MINUS (QImode, operands\u00dd1\u00a8, operands\u00dd2\u00a8)));\n;    }\n;  else\n;    {\n;      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n;\t\t\tgen_rtx_PLUS (QImode, operands\u00dd1\u00a8,\n;\t\t\t\t negate_rtx (QImode, operands\u00dd2\u00a8))));\n;    }\n;  DONE;\n;}\")\n\n(define_insn \"subqi3\"\n  \u00dd(set (match_operand:QI 0 \"register_operand\" \"=d\")\n\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0\")\n\t\t (match_operand:QI 2 \"register_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"SR\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; subdf3 instruction pattern(s).\n;\n\n(define_insn \"subdf3\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n\t\t  (match_operand:DF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"SDR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"SD\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; subsf3 instruction pattern(s).\n;\n\n(define_insn \"subsf3\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n\t\t  (match_operand:SF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"SER\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"SE\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Multiply instructions.\n;;\n\n;\n; mulsi3 instruction pattern(s).\n;\n\n(define_expand \"mulsi3\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t(mult:SI (match_operand:SI 1 \"general_operand\" \"\")\n\t\t (match_operand:SI 2 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT\n      && REG_P (operands\u00dd0\u00a8)\n      && CONST_OK_FOR_LETTER_P (INTVAL (operands\u00dd1\u00a8), 'K'))\n    {\n      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\t  gen_rtx_MULT (SImode, operands\u00dd2\u00a8, operands\u00dd1\u00a8)));\n    }\n  else if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT\n           && REG_P (operands\u00dd0\u00a8)\n\t   && CONST_OK_FOR_LETTER_P (INTVAL (operands\u00dd2\u00a8), 'K'))\n    {\n      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\t  gen_rtx_MULT (SImode, operands\u00dd1\u00a8, operands\u00dd2\u00a8)));\n    }\n  else\n    {\n      rtx r = gen_reg_rtx (DImode);\n\n      /* XXX trouble.  Below we generate some rtx's that model what\n       * is really supposed to happen with multiply on the 370/390\n       * hardware, and that is all well & good.  However, during optimization\n       * it can happen that the two operands are exchanged (after all,\n       * multiplication is commutitive), in which case the doubleword\n       * ends up in memory and everything is hosed.  The gen_reg_rtx\n       * should have kept it in a reg ...  We hack around this\n       * below, in the M/MR isntruction pattern, and constrain it to\n       * \\\"di\\\" instead of \\\"g\\\".  But this still ends up with lots & lots of\n       * movement between registers & memory and is an awful waste.\n       * Dunno how to untwist it elegantly; but it seems to work for now.\n\n       * Note, this comment doesn't seem to be relevant for 3.4.6\n       * at least, so it is being opened up.\n       */\n      if (GET_CODE (operands\u00dd1\u00a8) == CONST_INT)\n      {\n      emit_insn (gen_rtx_SET (VOIDmode,\n\t\t\t  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),\n\t\t\t\t\t  operands\u00dd1\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, r,\n\t\t\t  gen_rtx_MULT (DImode, r, operands\u00dd2\u00a8)));\n      }\n      else\n      {\n      emit_insn (gen_rtx_SET (VOIDmode,\n\t\t\t  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),\n\t\t\t\t\t  operands\u00dd2\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, r,\n\t\t\t  gen_rtx_MULT (DImode, r, operands\u00dd1\u00a8)));\n      }\n      emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\t  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));\n    }\n  DONE;\n}\")\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"register_operand\" \"=d\")\n\t(mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n\t\t (match_operand:SI 2 \"const_int_operand\" \"K\")))\u00a8\n  \"CONST_OK_FOR_LETTER_P (INTVAL (operands\u00dd2\u00a8), 'K')\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  return \\\"MH\t%0,%H2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n; See mulsi3 comment above as to why this is constrained to\n; \"di\" rather than \"g\"\n(define_insn \"\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n\t(mult:DI (match_operand:DI 1 \"general_operand\" \"0\")\n\t\t (match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"MR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"M\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; muldf3 instruction pattern(s).\n;\n\n(define_insn \"muldf3\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"MDR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"MD\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; mulsf3 instruction pattern(s).\n;\n\n(define_insn \"mulsf3\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n\t\t (match_operand:SF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"MER\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"ME\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Divide instructions.\n;;\n\n;\n; divsi3 instruction pattern(s).\n;\n\n(define_expand \"divsi3\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t(div:SI (match_operand:SI 1 \"general_operand\" \"\")\n\t\t(match_operand:SI 2 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  rtx r = gen_reg_rtx (DImode);\n\n  emit_insn (gen_extendsidi2 (r, operands\u00dd1\u00a8));\n  emit_insn (gen_rtx_SET (VOIDmode, r,\n\t\t\tgen_rtx_DIV (DImode, r, operands\u00dd2\u00a8)));\n  emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\tgen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));\n  DONE;\n}\")\n\n\n;\n; udivsi3 instruction pattern(s).\n;\n\n(define_expand \"udivsi3\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n\t\t (match_operand:SI 2 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  rtx dr = gen_reg_rtx (DImode);\n  rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);\n  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, GET_MODE_SIZE (SImode));\n\n\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      if (INTVAL (operands\u00dd2\u00a8) > 0)\n\t{\n\t  emit_insn (gen_zero_extendsidi2 (dr, operands\u00dd1\u00a8));\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t\tgen_rtx_DIV (DImode, dr, operands\u00dd2\u00a8)));\n\t}\n      else\n\t{\n\t  rtx label1 = gen_label_rtx ();\n\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands\u00dd1\u00a8));\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));\n\t  emit_insn (gen_cmpsi (dr_0, operands\u00dd2\u00a8));\n\t  emit_jump_insn (gen_bltu (label1));\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));\n\t  emit_label (label1);\n\t}\n    }\n  else\n    {\n      rtx label1 = gen_label_rtx ();\n      rtx label2 = gen_label_rtx ();\n      rtx label3 = gen_label_rtx ();\n      rtx sr = gen_reg_rtx (SImode);\n\n      emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands\u00dd1\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, sr, operands\u00dd2\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, dr_1, const0_rtx));\n      emit_insn (gen_cmpsi (sr, dr_0));\n      emit_jump_insn (gen_bgtu (label3));\n      emit_insn (gen_cmpsi (sr, const0_rtx));\n      emit_jump_insn (gen_blt (label2));\n      emit_insn (gen_cmpsi (sr, const1_rtx));\n      emit_jump_insn (gen_beq (label1));\n      emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t\t  gen_rtx_LSHIFTRT (DImode, dr,\n\t\t\t\t    gen_rtx_CONST_INT (SImode, 32))));\n      emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t    gen_rtx_DIV (DImode, dr, sr)));\n      emit_jump_insn (gen_jump (label3));\n      emit_label (label1);\n      emit_insn (gen_rtx_SET (VOIDmode, dr_1, dr_0));\n      emit_jump_insn (gen_jump (label3));\n      emit_label (label2);\n      emit_insn (gen_rtx_SET (VOIDmode, dr_1, const1_rtx));\n      emit_label (label3);\n    }\n  emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8, dr_1));\n\n  DONE;\n}\")\n\n; This is used by divsi3 & udivsi3.\n\n(define_insn \"\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n\t(div:DI (match_operand:DI 1 \"register_operand\" \"0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"dm\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"DR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"D\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; divdf3 instruction pattern(s).\n;\n\n(define_insn \"divdf3\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n        (div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n                (match_operand:DF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"DDR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"DD\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; divsf3 instruction pattern(s).\n;\n\n(define_insn \"divsf3\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n        (div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n                (match_operand:SF 2 \"general_operand\" \"fmF\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (FP_REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"DER\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"DE\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Modulo instructions.\n;;\n\n;\n; modsi3 instruction pattern(s).\n;\n\n(define_expand \"modsi3\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t(mod:SI (match_operand:SI 1 \"general_operand\" \"\")\n\t\t(match_operand:SI 2 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  rtx r = gen_reg_rtx (DImode);\n\n  emit_insn (gen_extendsidi2 (r, operands\u00dd1\u00a8));\n  emit_insn (gen_rtx_SET (VOIDmode, r,\n\t\t\tgen_rtx_MOD (DImode, r, operands\u00dd2\u00a8)));\n  emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8,\n\t\t\tgen_rtx_SUBREG (SImode, r, 0)));\n  DONE;\n}\")\n\n;\n; umodsi3 instruction pattern(s).\n;\n\n(define_expand \"umodsi3\"\n  \u00dd(set (match_operand:SI 0 \"general_operand\" \"\")\n\t(umod:SI (match_operand:SI 1 \"general_operand\" \"\")\n\t\t (match_operand:SI 2 \"general_operand\" \"\")))\u00a8\n  \"\"\n  \"\n{\n  rtx dr = gen_reg_rtx (DImode);\n  rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);\n\n  emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands\u00dd1\u00a8));\n\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      if (INTVAL (operands\u00dd2\u00a8) > 0)\n\t{\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t\t      gen_rtx_LSHIFTRT (DImode, dr,\n\t\t\t\t\tgen_rtx_CONST_INT (SImode, 32))));\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t\tgen_rtx_MOD (DImode, dr, operands\u00dd2\u00a8)));\n\t}\n      else\n\t{\n\t  rtx label1 = gen_label_rtx ();\n\t  rtx sr = gen_reg_rtx (SImode);\n\n\t  emit_insn (gen_rtx_SET (VOIDmode, sr, operands\u00dd2\u00a8));\n\t  emit_insn (gen_cmpsi (dr_0, sr));\n\t  emit_jump_insn (gen_bltu (label1));\n\t  emit_insn (gen_rtx_SET (VOIDmode, sr, gen_rtx_ABS (SImode, sr)));\n\t  emit_insn (gen_rtx_SET (VOIDmode, dr_0,\n\t\t\t      gen_rtx_PLUS (SImode, dr_0, sr)));\n\t  emit_label (label1);\n\t}\n    }\n  else\n    {\n      rtx label1 = gen_label_rtx ();\n      rtx label2 = gen_label_rtx ();\n      rtx label3 = gen_label_rtx ();\n      rtx sr = gen_reg_rtx (SImode);\n\n      emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands\u00dd1\u00a8));\n      emit_insn (gen_rtx_SET (VOIDmode, sr, operands\u00dd2\u00a8));\n      emit_insn (gen_cmpsi (sr, dr_0));\n      emit_jump_insn (gen_bgtu (label3));\n      emit_insn (gen_cmpsi (sr, const0_rtx));\n      emit_jump_insn (gen_blt (label2));\n      emit_insn (gen_cmpsi (sr, const1_rtx));\n      emit_jump_insn (gen_beq (label1));\n      emit_insn (gen_rtx_SET (VOIDmode, dr,\n\t\t\t  gen_rtx_LSHIFTRT (DImode, dr,\n\t\t\t\t    gen_rtx_CONST_INT (SImode, 32))));\n      emit_insn (gen_rtx_SET (VOIDmode, dr, gen_rtx_MOD (DImode, dr, sr)));\n      emit_jump_insn (gen_jump (label3));\n      emit_label (label1);\n      emit_insn (gen_rtx_SET (VOIDmode, dr_0, const0_rtx));\n      emit_jump_insn (gen_jump (label3));\n      emit_label (label2);\n      emit_insn (gen_rtx_SET (VOIDmode, dr_0,\n\t\t\t  gen_rtx_MINUS (SImode, dr_0, sr)));\n      emit_label (label3);\n\n    }\n  emit_insn (gen_rtx_SET (VOIDmode, operands\u00dd0\u00a8, dr_0));\n\n  DONE;\n}\")\n\n; This is used by modsi3 & umodsi3.\n\n(define_insn \"\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n\t(mod:DI (match_operand:DI 1 \"register_operand\" \"0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"dm\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"DR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"D\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- And instructions.\n;;\n\n;\n; anddi3 instruction pattern(s).\n;\n\n;(define_expand \"anddi3\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(and:DI (match_operand:DI 1 \"general_operand\" \"\")\n;\t\t(match_operand:DI 2 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx gen_andsi3();\n;\n;  emit_insn (gen_andsi3 (operand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd1\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd2\u00a8, 0, 1, DImode)));\n;  emit_insn (gen_andsi3 (gen_lowpart (SImode, operands\u00dd0\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd1\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd2\u00a8)));\n;  DONE;\n;}\")\n\n\n;\n; andsi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"r_or_s_operand\" \"=d,R\")\n\t(and:SI (match_operand:SI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g,Si\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"NR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"N\t%0,%2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"NC\t%O0(4,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"andsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"NR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"N\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; andhi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:HI 0 \"r_or_s_operand\" \"=d,S\")\n\t(and:HI (match_operand:HI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di,Si\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"NR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      /* %K2 == sign extend operand to 32 bits so that CH works */\n      if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n        {\n          mvs_check_page (0, 4, 4);\n          return \\\"N\t%0,%K2\\\";\n        }\n      mvs_check_page (0, 4, 0);\n      return \\\"N\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 6, 2);\n      return \\\"NC\t%O0(2,%R0),%H2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"NC\t%O0(2,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"andhi3\"\n  \u00dd(set (match_operand:HI 0 \"register_operand\" \"=d\")\n\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      /* %K2 == sign extend operand to 32 bits so that CH works */\n      mvs_check_page (0, 4, 4);\n      return \\\"N\t%0,%K2\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"NR\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; andqi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:QI 0 \"r_or_s_operand\" \"=d,S\")\n\t(and:QI (match_operand:QI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"dim,Si\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"NR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"N\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"NI\t%0,%B2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"NC\t%O0(1,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"andqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* and sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"N\t%0,=XL4'%X2'\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"NR\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Bit set (inclusive or) instructions.\n;;\n\n;\n; iordi3 instruction pattern(s).\n;\n\n;(define_expand \"iordi3\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(ior:DI (match_operand:DI 1 \"general_operand\" \"\")\n;\t\t(match_operand:DI 2 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx gen_iorsi3();\n;\n;  emit_insn (gen_iorsi3 (operand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd1\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd2\u00a8, 0, 1, DImode)));\n;  emit_insn (gen_iorsi3 (gen_lowpart (SImode, operands\u00dd0\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd1\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd2\u00a8)));\n;  DONE;\n;}\")\n\n;\n; iorsi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"r_or_s_operand\" \"=d,m\")\n\t(ior:SI (match_operand:SI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g,Si\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"OR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"O\t%0,%2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"OC\t%O0(4,%R0),%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"iorsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"OR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"O\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; iorhi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:HI 0 \"r_or_s_operand\" \"=d,m\")\n\t(ior:HI (match_operand:HI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di,mi\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"OR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"O\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 6, 2);\n      return \\\"OC\t%O0(2,%R0),%H2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"OC\t%O0(2,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"iorhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"O\t%0,%K2\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"OR\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; iorqi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:QI 0 \"r_or_s_operand\" \"=d,m\")\n\t(ior:QI (match_operand:QI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"di,mi\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"OR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"O\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"OI\t%0,%B2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"OC\t%O0(1,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"iorqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* OR sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"O\t%0,=XL4'%X2'\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"OR\t%0,%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Xor instructions.\n;;\n\n;\n; xordi3 instruction pattern(s).\n;\n\n;(define_expand \"xordi3\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(xor:DI (match_operand:DI 1 \"general_operand\" \"\")\n;\t\t(match_operand:DI 2 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx gen_xorsi3();\n;\n;  emit_insn (gen_xorsi3 (operand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd1\u00a8, 0, 1, DImode),\n;\t\t\t operand_subword (operands\u00dd2\u00a8, 0, 1, DImode)));\n;  emit_insn (gen_xorsi3 (gen_lowpart (SImode, operands\u00dd0\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd1\u00a8),\n;\t\t\t gen_lowpart (SImode, operands\u00dd2\u00a8)));\n;  DONE;\n;}\")\n\n;\n; xorsi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"r_or_s_operand\" \"=d,m\")\n\t(xor:SI (match_operand:SI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g,Si\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"XR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"X\t%0,%2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"XC\t%O0(4,%R0),%2\\\";\n}\"\n   \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"xorsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"XR\t%0,%2\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"X\t%0,%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; xorhi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:HI 0 \"r_or_s_operand\" \"=d,m\")\n\t(xor:HI (match_operand:HI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di,mi\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"XR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n        {\n          mvs_check_page (0, 4, 4);\n          return \\\"X\t%0,%K2\\\";\n        }\n      mvs_check_page (0, 4, 0);\n      return \\\"X\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 6, 2);\n      return \\\"XC\t%O0(2,%R0),%H2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"XC\t%O0(2,%R0),%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"xorhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:HI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"X\t%0,%2\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"XR\t%0,%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; xorqi3 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:QI 0 \"r_or_s_operand\" \"=d,m\")\n\t(xor:QI (match_operand:QI 1 \"r_or_s_operand\" \"%0,0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"di,mi\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"XR\t%0,%2\\\";\n    }\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"X\t%0,%2\\\";\n    }\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"XI\t%0,%B2\\\";\n    }\n  mvs_check_page (0, 6, 0);\n  return \\\"XC\t%O0(1,%R0),%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"xorqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n\t\t(match_operand:QI 2 \"general_operand\" \"di\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (GET_CODE (operands\u00dd2\u00a8) == CONST_INT)\n    {\n      mvs_check_page (0, 4, 0);\n      return \\\"X\t%0,=XL4'%X2'\\\";\n    }\n  mvs_check_page (0, 2, 0);\n  return \\\"XR\t%0,%2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Negate instructions.\n;;\n\n;\n; negsi2 instruction pattern(s).\n;\n\n(define_insn \"negsi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(neg:SI (match_operand:SI 1 \"general_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LCR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; neghi2 instruction pattern(s).\n;\n\n(define_insn \"neghi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(neg:HI (match_operand:HI 1 \"general_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 10, 0);\n  return \\\"SLL\t%1,16\\;SRA\t%1,16\\;LCR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;\n; negdf2 instruction pattern(s).\n;\n\n(define_insn \"negdf2\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n\t(neg:DF (match_operand:DF 1 \"general_operand\" \"f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LCDR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; negsf2 instruction pattern(s).\n;\n\n(define_insn \"negsf2\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n\t(neg:SF (match_operand:SF 1 \"general_operand\" \"f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LCER\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;;\n;;- Absolute value instructions.\n;;\n\n;\n; abssi2 instruction pattern(s).\n;\n\n(define_insn \"abssi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(abs:SI (match_operand:SI 1 \"general_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LPR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; abshi2 instruction pattern(s).\n;\n\n(define_insn \"abshi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(abs:HI (match_operand:HI 1 \"general_operand\" \"d\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 10, 0);\n  return \\\"SLL\t%1,16\\;SRA\t%1,16\\;LPR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;\n; absdf2 instruction pattern(s).\n;\n\n(define_insn \"absdf2\"\n  \u00dd(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n\t(abs:DF (match_operand:DF 1 \"general_operand\" \"f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LPDR\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;\n; abssf2 instruction pattern(s).\n;\n\n(define_insn \"abssf2\"\n  \u00dd(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n\t(abs:SF (match_operand:SF 1 \"general_operand\" \"f\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"LPER\t%0,%1\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n\n;;\n;;- One complement instructions.\n;;\n\n;\n; one_cmpldi2 instruction pattern(s).\n;\n\n;(define_expand \"one_cmpldi2\"\n;  \u00dd(set (match_operand:DI 0 \"general_operand\" \"\")\n;\t(not:DI (match_operand:DI 1 \"general_operand\" \"\")))\u00a8\n;  \"\"\n;  \"\n;{\n;  rtx gen_one_cmplsi2();\n;\n;  emit_insn (gen_one_cmplsi2 (operand_subword (operands\u00dd0\u00a8, 0, 1, DImode),\n;\t\t\t      operand_subword (operands\u00dd1\u00a8, 0, 1, DImode)));\n;  emit_insn (gen_one_cmplsi2 (gen_lowpart (SImode, operands\u00dd0\u00a8),\n;\t\t\t      gen_lowpart (SImode, operands\u00dd1\u00a8)));\n;  DONE;\n;}\")\n\n;\n; one_cmplsi2 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:SI 0 \"r_or_s_operand\" \"=dm\")\n\t(not:SI (match_operand:SI 1 \"r_or_s_operand\" \"0\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"X\t%0,=F'-1'\\\";\n    }\n  CC_STATUS_INIT;\n  mvs_check_page (0, 6, 4);\n  return \\\"XC\t%O0(4,%R0),=F'-1'\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"one_cmplsi2\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  mvs_check_page (0, 4, 4);\n  return \\\"X\t%0,=F'-1'\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; one_cmplhi2 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:HI 0 \"r_or_s_operand\" \"=dm\")\n\t(not:HI (match_operand:HI 1 \"r_or_s_operand\" \"0\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"X\t%0,=F'-1'\\\";\n    }\n  mvs_check_page (0, 6, 2);\n  return \\\"XC\t%O0(2,%R0),=XL2'FFFF'\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"one_cmplhi2\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  mvs_check_page (0, 4, 4);\n  return \\\"X\t%0,=F'-1'\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; one_cmplqi2 instruction pattern(s).\n;\n\n(define_insn \"\"\n  \u00dd(set (match_operand:QI 0 \"r_or_s_operand\" \"=dm\")\n\t(not:QI (match_operand:QI 1 \"r_or_s_operand\" \"0\")))\u00a8\n  \"TARGET_CHAR_INSTRUCTIONS\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 4, 4);\n      return \\\"X\t%0,=F'-1'\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"XI\t%0,255\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n(define_insn \"one_cmplqi2\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT;  /* XOR sets CC but not how we want it */\n  mvs_check_page (0, 4, 4);\n  return \\\"X\t%0,=F'-1'\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;;\n;;- Arithmetic shift instructions.\n;;\n\n;\n; ashldi3 instruction pattern(s).\n;\n\n(define_insn \"ashldi3\"\n  \u00dd(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n\t\t   (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  /* this status set seems not have the desired effect,\n   * proably because the 64-bit long-long test is emulated ?! */\n  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLDA\t%0,0(%2)\\\";\n  return \\\"SLDA\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; ashrdi3 instruction pattern(s).\n;\n\n(define_insn \"ashrdi3\"\n  \u00dd(set (match_operand:DI 0 \"register_operand\" \"=d\")\n\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  /* this status set seems not have the desired effect,\n   * proably because the 64-bit long-long test is emulated ?! */\n  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SRDA\t%0,0(%2)\\\";\n  return \\\"SRDA\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; ashlsi3 instruction pattern(s).\n;\n\n(define_insn \"ashlsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n\t\t   (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLL\t%0,0(%2)\\\";\n  return \\\"SLL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; ashrsi3 instruction pattern(s).\n;\n\n(define_insn \"ashrsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_SET (operands\u00dd0\u00a8, operands\u00dd1\u00a8);\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SRA\t%0,0(%2)\\\";\n  return \\\"SRA\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; ashlhi3 instruction pattern(s).\n;\n\n(define_insn \"ashlhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n\t\t   (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 8, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLL\t%0,16(%2)\\;SRA\t%0,16\\\";\n  return \\\"SLL\t%0,16+%c2\\;SRA\t%0,16\\\";\n}\"\n  \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; ashrhi3 instruction pattern(s).\n;\n\n(define_insn \"ashrhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 8, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLL\t%0,16\\;SRA\t%0,16(%2)\\\";\n  return \\\"SLL\t%0,16\\;SRA\t%0,16+%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; ashlqi3 instruction pattern(s).\n;\n\n(define_insn \"ashlqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n\t\t   (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLL\t%0,0(%2)\\\";\n  return \\\"SLL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; ashrqi3 instruction pattern(s).\n;\n\n(define_insn \"ashrqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 8, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SLL\t%0,24\\;SRA\t%0,24(%2)\\\";\n  return \\\"SLL\t%0,24\\;SRA\t%0,24+%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;;\n;;- Logical shift instructions.\n;;\n\n;\n; lshrdi3 instruction pattern(s).\n;\n\n(define_insn \"lshrdi3\"\n  \u00dd(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SRDL\t%0,0(%2)\\\";\n  return \\\"SRDL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n\n;\n; lshrsi3 instruction pattern(s).\n;\n\n(define_insn \"lshrsi3\"\n  \u00dd(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"SRL\t%0,0(%2)\\\";\n  return \\\"SRL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; lshrhi3 instruction pattern(s).\n;\n\n(define_insn \"lshrhi3\"\n  \u00dd(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT; /* AND sets the CC but not how we want it */\n  if (REG_P (operands\u00dd2\u00a8))\n    {\n      mvs_check_page (0, 8, 4);\n      return \\\"N\t%0,=XL4'0000FFFF'\\;SRL\t%0,0(%2)\\\";\n    }\n  mvs_check_page (0, 8, 4);\n  return \\\"N\t%0,=XL4'0000FFFF'\\;SRL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;\n; lshrqi3 instruction pattern(s).\n;\n\n(define_insn \"lshrqi3\"\n  \u00dd(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n\t\t     (match_operand:SI 2 \"general_operand\" \"Ja\")))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  CC_STATUS_INIT; /* AND sets the CC but not how we want it */\n  mvs_check_page (0, 8, 4);\n  if (REG_P (operands\u00dd2\u00a8))\n    return \\\"N\t%0,=XL4'000000FF'\\;SRL\t%0,0(%2)\\\";\n  return \\\"N\t%0,=XL4'000000FF'\\;SRL\t%0,%c2\\\";\n}\"\n  \u00dd(set_attr \"length\" \"8\")\u00a8\n)\n\n;; =======================================================================\n;;- Conditional jump instructions.\n;; =======================================================================\n\n;\n; beq instruction pattern(s).\n;\n\n(define_insn \"beq\"\n  \u00dd(set (pc)\n\t(if_then_else (eq (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BE\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BER\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bne instruction pattern(s).\n;\n\n(define_insn \"bne\"\n  \u00dd(set (pc)\n\t(if_then_else (ne (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNE\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNER\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bgt instruction pattern(s).\n;\n\n(define_insn \"bgt\"\n  \u00dd(set (pc)\n\t(if_then_else (gt (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bgtu instruction pattern(s).\n;\n\n(define_insn \"bgtu\"\n  \u00dd(set (pc)\n\t(if_then_else (gtu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; blt instruction pattern(s).\n;\n\n(define_insn \"blt\"\n  \u00dd(set (pc)\n\t(if_then_else (lt (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bltu instruction pattern(s).\n;\n\n(define_insn \"bltu\"\n  \u00dd(set (pc)\n\t(if_then_else (ltu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bge instruction pattern(s).\n;\n\n(define_insn \"bge\"\n  \u00dd(set (pc)\n\t(if_then_else (ge (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bgeu instruction pattern(s).\n;\n\n(define_insn \"bgeu\"\n  \u00dd(set (pc)\n\t(if_then_else (geu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; ble instruction pattern(s).\n;\n\n(define_insn \"ble\"\n  \u00dd(set (pc)\n\t(if_then_else (le (cc0)\n\t\t\t  (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; bleu instruction pattern(s).\n;\n\n(define_insn \"bleu\"\n  \u00dd(set (pc)\n\t(if_then_else (leu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (label_ref (match_operand 0 \"\" \"\"))\n\t\t      (pc)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;;\n;;- Negated conditional jump instructions.\n;;\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (eq (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNE\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNER\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (ne (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BE\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BER\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (gt (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (gtu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (lt (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (ltu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BNL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BNLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (ge (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (geu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BL\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BLR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (le (cc0)\n\t\t\t  (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else (leu (cc0)\n\t\t\t   (const_int 0))\n\t\t      (pc)\n\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"BH\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BHR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;; ==============================================================\n;;- Subtract one and jump if not zero.\n;; These insns seem to not be getting matched ...\n;; XXX should fix this, as it would improve for loops\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else\n\t (ne (plus:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n\t\t      (const_int -1))\n\t     (const_int 0))\n\t (label_ref (match_operand 1 \"\" \"\"))\n\t (pc)))\n   (set (match_dup 0)\n\t(plus:SI (match_dup 0)\n\t\t (const_int -1)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd1\u00a8)))\n    {\n      return \\\"BCT\t%0,%l1\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l1)\\;BCTR\t%0,14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (pc)\n\t(if_then_else\n\t (eq (plus:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n\t\t      (const_int -1))\n\t     (const_int 0))\n\t (pc)\n\t (label_ref (match_operand 1 \"\" \"\"))))\n   (set (match_dup 0)\n\t(plus:SI (match_dup 0)\n\t\t (const_int -1)))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd1\u00a8)))\n    {\n      return \\\"BCT\t%0,%l1\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l1)\\;BCTR\t%0,14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;; =============================================================\n;;- Unconditional jump instructions.\n;;\n\n;\n; jump instruction pattern(s).\n;\n\n(define_insn \"jump\"\n  \u00dd(set (pc)\n\t(label_ref (match_operand 0 \"\" \"\")))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 4, 0);\n  if (i370_short_branch(insn) || mvs_check_label (CODE_LABEL_NUMBER (operands\u00dd0\u00a8)))\n    {\n      return \\\"B\t%l0\\\";\n    }\n  mvs_check_page (0, 2, 4);\n  return \\\"L\t14,=A(%l0)\\;BR\t14\\\";\n}\"\n  \u00dd(set_attr \"length\" \"6\")\u00a8\n)\n\n;\n; indirect-jump instruction pattern(s).\n; hack alert -- should check that displacement is < 4096\n\n(define_insn \"indirect_jump\"\n  \u00dd(set (pc) (match_operand:SI 0 \"general_operand\" \"rm\"))\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 2, 0);\n      return \\\"BR\t%0\\\";\n    }\n  mvs_check_page (0, 4, 0);\n  return \\\"B\t%0\\\";\n}\"\n  \u00dd(set_attr \"length\" \"4\")\u00a8\n)\n\n;\n; tablejump instruction pattern(s).\n;\n\n(define_insn \"tablejump\"\n  \u00dd(set (pc)\n\t(match_operand:SI 0 \"general_operand\" \"am\"))\n   (use (label_ref (match_operand 1 \"\" \"\")))\n;   (clobber (reg:SI 14))\n   \u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  if (REG_P (operands\u00dd0\u00a8))\n    {\n      mvs_check_page (0, 6, 0);\n      return \\\"BR\t%0\\;DS\t0F\\\";\n    }\n  mvs_check_page (0, 10, 0);\n  return \\\"L\t14,%0\\;BR\t14\\;DS\t0F\\\";\n}\"\n  \u00dd(set_attr \"length\" \"10\")\u00a8\n)\n\n;;\n;;- Jump to subroutine.\n;;\n;; For the C/370 environment the internal functions, ie. sqrt, are called with\n;; a non-standard form.  So, we must fix it here.  There's no BM like IBM.\n;;\n;; The ELF ABI is different from the C/370 ABI because we have a simpler,\n;; more powerful way of dealing with structure-value returns.  Basically,\n;; we use R1 to point at structure returns (64-bit and larger returns)\n;; and R11 to point at the args.  Note that this handles double-precision\n;; (64-bit) values just fine, in a less-kludged manner than the C/370 ABI.\n;; Since R1 is used, we use R2 to pass the argument pointer to the routine.\n\n;\n; call instruction pattern(s).\n;\n; We define four call instruction patterns below. The first two patterns,\n; although general, end up matching (only?) calls through function pointers.\n; The last two, which require a symbol-ref to match, get used for all\n; ordinary subroutine calls.\n\n(define_insn \"call\"\n  \u00dd(call (match_operand:QI 0 \"memory_operand\" \"m\")\n\t (match_operand:SI 1 \"immediate_operand\" \"i\"))\n;;    (clobber (reg:SI 2))\n   \u00a8\n  \"\"\n  \"*\n{\n#ifdef TARGET_LINUX\n#ifdef STACK_GROWS_DOWNWARD\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n\n  CC_STATUS_INIT;\n  check_label_emit ();\n  mvs_check_page (0, 10, 4);\n  sprintf ( temp, \\\"LA\tr2,%d(,sp)\\;LA\t15,%%0\\;BASR\t14,15\\\", i );\n  return temp;\n#else /* STACK_GROWS_DOWNWARD */\n  CC_STATUS_INIT;\n  check_label_emit ();\n  mvs_check_page (0, 6, 4);\n  return \\\"LA\t15,%0\\;BASR\t14,15\\\";\n#endif /* STACK_GROWS_DOWNWARD */\n\n#else\n\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n\n  CC_STATUS_INIT;\n  check_label_emit ();\n  if (mvs_function_check (XSTR (operands\u00dd0\u00a8, 0)))\n    {\n      mvs_check_page (0, 22, 4);\n      sprintf ( temp, \\\"LA\t1,136(,13)\\;ST\t1,%d(,13)\\;LA 1,%d(,13)\\;LA\t15,%%0\\;BALR\t14,15\\;LD\t0,136(,13)\\\",\n\t     i - 4, i - 4 );\n    }\n  else\n    {\n      mvs_check_page (0, 10, 4);\n      sprintf ( temp, \\\"LA\t1,%d(,13)\\;LA\t15,%%0\\;BALR\t14,15\\\", i );\n    }\n  return temp;\n#endif\n}\"\n  \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n;\n; call_value instruction pattern(s).\n;\n\n(define_insn \"call_value\"\n  \u00dd(set (match_operand 0 \"\" \"=rf\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n \t      (match_operand:SI 2 \"general_operand\" \"i\")))\n;;   (clobber (reg:SI 2))\n   \u00a8\n  \"\"\n  \"*\n{\n#ifdef TARGET_LINUX\n#ifdef STACK_GROWS_DOWNWARD\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n  mvs_check_page (0, 10, 4);\n  sprintf ( temp, \\\"LA\tr2,%d(,sp)\\;LA\t15,%%1\\;BASR\t14,15\\\", i );\n  return temp;\n\n#else /* STACK_GROWS_DOWNWARD */\n  CC_STATUS_INIT;\n  check_label_emit ();\n  mvs_check_page (0, 6, 4);\n  return \\\"LA\t15,%1\\;BASR\t14,15\\\";\n#endif /* STACK_GROWS_DOWNWARD */\n\n#else\n\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n\n  check_label_emit ();\n  if (mvs_function_check (XSTR (operands\u00dd1\u00a8, 0)))\n    {\n      mvs_check_page (0, 22, 4);\n      sprintf ( temp, \\\"LA\t1,136(,13)\\;ST\t1,%d(,13)\\;LA 1,%d(,13)\\;LA\t15,%%1\\;BALR\t14,15\\;LD\t0,136(,13)\\\",\n\t   i - 4, i - 4 );\n    }\n  else\n    {\n      mvs_check_page (0, 10, 4);\n      sprintf ( temp, \\\"LA\t1,%d(,13)\\;LA\t15,%%1\\;BALR\t14,15\\\", i );\n    }\n  return temp;\n\n#endif\n}\"\n  \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(call (mem:QI (match_operand:SI 0 \"\" \"i\"))\n\t (match_operand:SI 1 \"general_operand\" \"g\"))\n;;   (clobber (reg:SI 2))\n   \u00a8\n  \"GET_CODE (operands\u00dd0\u00a8) == SYMBOL_REF\"\n  \"*\n{\n#ifdef TARGET_LINUX\n#ifdef STACK_GROWS_DOWNWARD\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n  mvs_check_page (0, 10, 4);\n  sprintf ( temp, \\\"LA\tr2,%d(,sp)\\;L\t15,%%0\\;BASR\t14,15\\\", i );\n  return temp;\n\n#else /* STACK_GROWS_DOWNWARD */\n  CC_STATUS_INIT;\n  check_label_emit ();\n  mvs_check_page (0, 6, 4);\n  return \\\"L\t15,%0\\;BASR\t14,15\\\";\n#endif /* STACK_GROWS_DOWNWARD */\n\n#else\n\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n\n  check_label_emit ();\n  if (mvs_function_check (XSTR (operands\u00dd0\u00a8, 0)))\n    {\n      mvs_check_page (0, 22, 4);\n      sprintf ( temp, \\\"LA\t1,136(,13)\\;ST\t1,%d(,13)\\;LA\t1,%d(,13)\\;L\t15,%%0\\;BALR\t14,15\\;LD\t0,136(,13)\\\",\n\t   i - 4, i - 4 );\n    }\n  else\n    {\n      mvs_check_page (0, 10, 4);\n      sprintf ( temp, \\\"LA\t1,%d(,13)\\;L\t15,%%0\\;BALR\t14,15\\\", i );\n    }\n  return temp;\n#endif\n}\"\n  \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n(define_insn \"\"\n  \u00dd(set (match_operand 0 \"\" \"=rf\")\n\t(call (mem:QI (match_operand:SI 1 \"\" \"i\"))\n\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n;;   (clobber (reg:SI 2))\n   \u00a8\n  \"GET_CODE (operands\u00dd1\u00a8) == SYMBOL_REF\"\n  \"*\n{\n#ifdef TARGET_LINUX\n#ifdef STACK_GROWS_DOWNWARD\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n\n  check_label_emit ();\n  mvs_check_page (0, 10, 4);\n  sprintf ( temp, \\\"LA\tr2,%d(,sp)\\;L\t15,%%1\\;BASR\t14,15\\\", i );\n  return temp;\n\n#else /* STACK_GROWS_DOWNWARD */\n  CC_STATUS_INIT;\n  check_label_emit ();\n  mvs_check_page (0, 6, 4);\n  return \\\"L\t15,%1\\;BASR\t14,15\\\";\n#endif /* STACK_GROWS_DOWNWARD */\n\n#else\n\n  static char temp\u00dd128\u00a8;\n  int i = STACK_POINTER_OFFSET;\n  CC_STATUS_INIT;\n\n  check_label_emit ();\n  if (mvs_function_check (XSTR (operands\u00dd1\u00a8, 0)))\n    {\n      mvs_check_page (0, 22, 4);\n      sprintf ( temp, \\\"LA\t1,136(,13)\\;ST\t1,%d(,13)\\;LA\t1,%d(,13)\\;L\t15,%%1\\;BALR\t14,15\\;LD\t0,136(,13)\\\",\n\t   i - 4, i - 4 );\n    }\n  else\n    {\n      mvs_check_page (0, 10, 4);\n      sprintf ( temp, \\\"LA\t1,%d(,13)\\;L\t15,%%1\\;BALR\t14,15\\\", i );\n    }\n  return temp;\n#endif\n}\"\n  \u00dd(set_attr \"length\" \"22\")\u00a8\n)\n\n;;\n;; Call subroutine returning any type.\n;; This instruction pattern appears to be used only by the\n;; expand_builtin_apply definition for __builtin_apply.  It is needed\n;; since call_value might return an int in r15 or a float in fpr0 (r16)\n;; and the builtin code calls abort since the reg is ambiguous. Well,\n;; the below is probably broken anyway, we just want to go for now.\n;;\n(define_expand \"untyped_call\"\n\u00dd(parallel \u00dd(call (match_operand 0 \"\" \"\")\n                  (const_int 0))\n              (match_operand 1 \"\" \"\")\n              (match_operand 2 \"\" \"\")\u00a8)\u00a8\n  \"\"\n  \"\n{\n  int i;\n\n  emit_call_insn (GEN_CALL (operands\u00dd0\u00a8, const0_rtx, const0_rtx, const0_rtx));\n\n  for (i = 0; i < XVECLEN (operands\u00dd2\u00a8, 0); i++)\n    {\n      rtx set = XVECEXP (operands\u00dd2\u00a8, 0, i);\n      emit_move_insn (SET_DEST (set), SET_SRC (set));\n    }\n\n  /* The optimizer does not know that the call sets the function value\n     registers we stored in the result block.  We avoid problems by\n     claiming that all hard registers are used and clobbered at this\n     point.  */\n  /* emit_insn (gen_blockage ()); */\n\n  DONE;\n}\")\n\n\n;;\n;;- Miscellaneous instructions.\n;;\n\n;\n; nop instruction pattern(s).\n;\n\n(define_insn \"nop\"\n  \u00dd(const_int 0)\u00a8\n  \"\"\n  \"*\n{\n  check_label_emit ();\n  mvs_check_page (0, 2, 0);\n  return \\\"NOPR\t0\\\";\n}\"\n  \u00dd(set_attr \"length\" \"2\")\u00a8\n)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMITDOC": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "This PDS contains a stack of XMITed PDSes. They all\nneed to be restored via the RECEIVE command, by\nrunning the job XMIT6 (after reading the comments\nin it) or similar. You probably want to create two\naliases - one for GCC (the compiler proper), and one\nfor PDPCLIB (the C runtime library) before doing so.\nXMIT1 provides an example of that.\n\nAfter restoration, you may wish to run GCC.JCL(EXAMPLE)\nto compile an example C program, after the usual site\ncustomizations.\n\nFor further information, please see GCC.DOC(GCCMVS)\nafter the restoration.\n\nNote that XMIT2-5 and 7 do not need to be run, and are\nonly for reference purposes, for people who received\nthe XMIT as a zip file on the PC.\n\nYou may wish to delete the one or two XMIT files\nthat were created during this process, as they\nare only useful when trying to transport GCCMVS.\nXMIT8 is provided for that purpose.\n\nNote that the \"GCC\" module is a 31-bit version of the\ncompiler, so if you are running MVS/370 it won't work,\nand you should instead use \"GCC370\" which is a 24-bit\nmodule. The 31-bit version should work fine as-is on\nz/OS, OS/390, MVS/XA and MVS/380. Also note that\nalthough the compiler is 31-bit, by default it produces\n24-bit modules. If you wish to change this to 31-bit,\nthen after installation read GCC.DOC(GCCMVS) where\nthere are instructions for running STAGE4.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT853/CBT.V500.FILE853.PDS/GCCDOC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT853/CBT.V500.FILE853.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}