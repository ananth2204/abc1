{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20110613192458000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2645370, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 6160, "INMRECFM": "FB", "INMDIR": 44, "INMDSNAM": "PDPCLIB.SOURCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 6176, "INMBLKSZ": 6180, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2645370, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PDPCLIB.SOURCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6160, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6180, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "b'P\\x00/\\xb0\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x14\\x00\\x0e\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@MEMMGR": {"ttr": 6155, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  memmgr - manage memory                                           */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"__memmgr.h\"\n\n#include <stdlib.h>\n\nMEMMGR __memmgr;\n\nvoid memmgrDefaults(MEMMGR *memmgr)\n{\n    return;\n}\n\nvoid memmgrInit(MEMMGR *memmgr)\n{\n    memmgr->start = NULL;\n    memmgr->startf = NULL;\n    return;\n}\n\nvoid memmgrTerm(MEMMGR *memmgr)\n{\n    return;\n}\n\n/* Supply a block of memory. We make sure this is inserted in\n   the right spot logically in memory, and since it will be a\n   free block, we stick it at the front of the list */\nvoid memmgrSupply(MEMMGR *memmgr, void *buffer, size_t szbuf)\n{\n    MEMMGRN *p, *l, *b;\n\n    if (((int)buffer % MEMMGR_ALIGN) != 0)\n    {\n        szbuf -= (MEMMGR_ALIGN - (int)buffer % MEMMGR_ALIGN);\n        buffer = (char *)buffer + (MEMMGR_ALIGN - (int)buffer % MEMMGR_ALIGN);\n    }\n\n    if ((szbuf % MEMMGR_ALIGN) != 0)\n    {\n        szbuf -= szbuf % MEMMGR_ALIGN;\n    }\n\n    p = memmgr->start;\n    l = NULL;\n    while ((p != NULL) && ((MEMMGRN *)buffer >= p))\n    {\n        l = p;\n        p = p->next;\n    }\n\n    b = (MEMMGRN *)buffer;\n\n    b->prev = l;\n    b->next = p;\n\n    if (l != NULL)\n    {\n        l->next = b;\n    }\n    else\n    {\n        memmgr->start = b;\n    }\n\n    if (p != NULL)\n    {\n        p->prev = b;\n    }\n\n    b->fixed = 1;\n    b->size = szbuf;\n    b->allocated = 0;\n\n    /* add this to the front of the list */\n    b->nextf = memmgr->startf;\n    if (b->nextf != NULL)\n    {\n        b->nextf->prevf = b;\n    }\n    b->prevf = NULL;\n    memmgr->startf = b;\n#ifdef __MEMMGR_INTEGRITY\n    b->eyecheck1 = b->eyecheck2 = 0xa5a5a5a5;\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\nvoid *memmgrAllocate(MEMMGR *memmgr, size_t bytes, int id)\n{\n    MEMMGRN *p, *n;\n    size_t oldbytes = bytes;\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***allocating size %d\\n\\n\", bytes);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    /* technically they could have specified a strange free\n       memory size, like 101, which would disrupt the alignment.\n       MEMMGR_MINFREE should have compensated for this by ensuring\n       that it is a multiple of the MEMMGRN alignment */\n    bytes += MEMMGRN_SZ;\n    if ((bytes % MEMMGR_MINFRTOT) != 0)\n    {\n        bytes = ((bytes / MEMMGR_MINFRTOT) + 1)\n                * MEMMGR_MINFRTOT;\n    }\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***converted to %d\\n\\n\", bytes);\n    }\n#endif\n    /* if they have exceeded the limits of the data type,\n       bail out now. */\n    if (bytes < oldbytes)\n    {\n        return (NULL);\n    }\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size >= bytes)\n        {\n            /* The free chain should never have something allocated.\n               If it does, let's just crash so the user can get a\n               call stack rather than have their data randomly\n               corrupted. */\n            if (p->allocated)\n            {\n#if MEMMGR_CRASH\n                *(char *)0 = 0;\n#endif\n                exit(EXIT_FAILURE);\n            }\n            /* we don't need the whole block, so construct a new\n               free node */\n            if ((p->size - bytes) >= MEMMGR_MINFRTOT)\n            {\n                n = (MEMMGRN *)((char *)p + bytes);\n                n->next = p->next;\n                if (n->next != NULL)\n                {\n                    n->next->prev = n;\n                }\n                n->prev = p;\n                p->next = n;\n                n->fixed = 0;\n                n->size = p->size - bytes;\n                n->allocated = 0;\n#ifdef __MEMMGR_INTEGRITY\n                n->eyecheck1 = n->eyecheck2 = 0xa5a5a5a5;\n#endif\n                p->size = bytes;\n\n                /* remove p this from the free chain and\n                   replace with n */\n                n->nextf = p->nextf;\n                n->prevf = p->prevf;\n                if (n->nextf != NULL)\n                {\n                    n->nextf->prevf = n;\n                }\n                if (n->prevf != NULL)\n                {\n                    n->prevf->nextf = n;\n                }\n                /* if the previous entry is NULL, then we must be\n                   the first in the queue. If we're not, crash */\n                else if (memmgr->startf != p)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = n;\n                }\n            }\n            /* otherwise we're not creating a new node, so just\n               remove this entry from the free chain */\n            else\n            {\n                if (p->nextf != NULL)\n                {\n                    p->nextf->prevf = p->prevf;\n                }\n                if (p->prevf != NULL)\n                {\n                    p->prevf->nextf = p->nextf;\n                }\n                /* if the previous entry is NULL, then we must be\n                   the first in the queue. If we're not, crash */\n                else if (memmgr->startf != p)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = p->nextf;\n                }\n            }\n            /* for safety, don't keep the old free pointer chain\n               hanging around */\n            p->nextf = NULL;\n            p->prevf = NULL;\n\n            p->allocated = 0x5a5a;\n            p->id = id;\n            break;\n        }\n        p = p->nextf;\n    }\n    if (p == NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"***alloc returning NULL!\\n\\n\");\n        }\n#endif\n        return (p);\n    }\n    else\n    {\n        size_t *q;\n\n        q = (size_t *)((char *)p + MEMMGRN_SZ);\n        *(q - 1) = oldbytes;\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"***alloc returning %p\\n\\n\", p);\n        }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n        memmgrIntegrity(memmgr);\n#endif\n        return ((char *)p + MEMMGRN_SZ);\n    }\n}\n\nvoid memmgrFree(MEMMGR *memmgr, void *ptr)\n{\n    MEMMGRN *p, *n, *l;\n    int combprev = 0; /* did we combine with the previous? */\n    int combnext = 0; /* are we combining with the next node? */\n\n    p = (MEMMGRN *)((char *)ptr - MEMMGRN_SZ);\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***freeing size %d block %p\\n\\n\", p->size, p);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    /* If they try to free a bit of memory that isn't remotely\n       what it's meant to be, just crash so that they get a\n       call stack */\n    if (p->allocated != 0x5a5a)\n    {\n#if MEMMGR_CRASH\n        *(char *)0 = 0;\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    p->allocated = 0;\n    /* let's hope we're in the middle of a valid chain */\n    l = p->prev;\n    n = p->next;\n\n    /* If the previous block is also free, just expand it's size\n       without any further fuss */\n    if (!p->fixed && (l != NULL) && !l->allocated)\n    {\n        l->size += p->size;\n        l->next = p->next;\n        if (l->next != NULL)\n        {\n            l->next->prev = l;\n        }\n        combprev = 1;\n    }\n    /* is the next one up combinable? */\n    if ((n != NULL) && !n->allocated && !n->fixed)\n    {\n        combnext = 1;\n    }\n\n    /* We can have a fuss-free combination if the previous node\n       was not combined */\n    if (combnext && !combprev)\n    {\n        p->size += n->size;\n        p->next = n->next;\n        if (p->next != NULL)\n        {\n            p->next->prev = p;\n        }\n        p->nextf = n->nextf;\n        if (p->nextf != NULL)\n        {\n            p->nextf->prevf = p;\n        }\n        p->prevf = n->prevf;\n        if (p->prevf != NULL)\n        {\n            p->prevf->nextf = p;\n        }\n        else if (memmgr->startf != n)\n        {\n#if MEMMGR_CRASH\n            *(char *)0 = 0;\n#endif\n            exit(EXIT_FAILURE);\n        }\n        else\n        {\n            memmgr->startf = p;\n        }\n    }\n\n    /* this is the hairy situation. We're combining two existing\n       free blocks into one. While the blocks themselves are\n       contiguous, the two components are at random spots in the\n       free memory chain, e.g. they might be B and E in\n       A <-> B <-> C <-> D <-> E <-> F\n       So what's the obvious thing to do? Give it up and become a\n       Buddhist monk! The less obvious thing is to keep B in its\n       spot, just with an enhanced size, then get D and F to link\n       together. The special case of the two nodes actually already\n       being linked together by happy coincidence doesn't need\n       special handling. If it does, that monastery looks more\n       and more appealing every day. Do you reckon Buddhist monks\n       talk about giving it all up and doing C programming? Once\n       the node E is eliminated, B can be expanded. */\n\n    else if (combnext && combprev)\n    {\n        if (n->nextf != NULL)\n        {\n            n->nextf->prevf = n->prevf;\n        }\n        if (n->prevf != NULL)\n        {\n            n->prevf->nextf = n->nextf;\n        }\n        else if (memmgr->startf != n)\n        {\n#if MEMMGR_CRASH\n            *(char *)0 = 0;\n#endif\n            exit(EXIT_FAILURE);\n        }\n        else\n        {\n            memmgr->startf = n->nextf;\n            n->nextf->prevf = NULL;\n        }\n\n        /* Ok, the free memory has been taken care of, now we go\n           back to the newly combined node and combine it with\n           this one. */\n        l->size += n->size;\n        l->next = n->next;\n        if (l->next != NULL)\n        {\n            l->next->prev = l;\n        }\n\n        /* That wasn't so hairy after all */\n        /* Actually it was */\n    }\n\n    if (combnext)\n    {\n#ifdef __MEMMGR_INTEGRITY\n        n->eyecheck1 = n->eyecheck2 = 0;\n#endif\n        /* for safety */\n        n->nextf = NULL;\n        n->prevf = NULL;\n    }\n    if (combprev)\n    {\n#ifdef __MEMMGR_INTEGRITY\n        p->eyecheck1 = p->eyecheck2 = 0;\n#endif\n        /* for safety */\n        p->nextf = NULL;\n        p->prevf = NULL;\n    }\n\n    /* If we didn't do any combination, then add this new node to\n       the front of the free chain */\n    if (!combprev && !combnext)\n    {\n        p->nextf = memmgr->startf;\n        memmgr->startf = p;\n        p->prevf = NULL;\n        if (p->nextf != NULL)\n        {\n            p->nextf->prevf = p;\n        }\n    }\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***free returning\\n\\n\");\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\nvoid memmgrFreeId(MEMMGR *memmgr, int id)\n{\n    MEMMGRN *p, *l;\n\n    p = memmgr->start;\n    l = NULL;\n\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    while (p != NULL)\n    {\n        if ((p->id == id) && p->allocated)\n        {\n            /* skip past the MEMMGRN */\n            memmgrFree(memmgr, p + 1);\n\n            /* It is possible that the p node has been invalidated\n               now, because of combination with the previous node.\n               So we go back to the previous pointer and try again.\n               This time it shouldn't find the node allocated. */\n            if (l != NULL)\n            {\n                p = l;\n            }\n        }\n        l = p;\n        p = p->next;\n    }\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    return;\n}\n\n/* find the largest block of memory available */\nsize_t memmgrMaxSize(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t max = 0;\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size > max)\n        {\n            max = p->size;\n        }\n        p = p->next;\n    }\n    if (max != 0)\n    {\n        max -= MEMMGRN_SZ;\n    }\n    return (max);\n}\n\n/* find total amount of memory available */\nsize_t memmgrTotSize(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t tot = 0;\n\n    p = memmgr->startf;\n\n    while (p != NULL)\n    {\n        if (p->size != 0)\n        {\n            tot += (p->size - MEMMGRN_SZ);\n        }\n        p = p->next;\n    }\n    return (tot);\n}\n\nint memmgrDebug = 0;\nint memmgrDebug2 = 0;\n\n\n#ifdef __MEMMGR_INTEGRITY\n/* do an integrity check */\nvoid memmgrIntegrity(MEMMGR *memmgr)\n{\n    MEMMGRN *p;\n    size_t max = 0;\n\n#ifdef __MEMMGR_DEBUG\n#if 0\n    if (memmgrDebug2 != 0)\n    {\n        memmgrDebug2++;\n        if (memmgrDebug2 == 22362000)\n        {\n            memmgrDebug = 1;\n        }\n    }\n#endif\n    if (memmgrDebug)\n    {\n        printf(\"%d integrity checking all nodes\\n\\n\", memmgrDebug2);\n    }\n#endif\n    p = memmgr->start;\n\n    while (p != NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"p is %p\\n\\n\", p);\n            printf(\"ec1 %x, ec2 %x\\n\\n\",\n                   p->eyecheck1, p->eyecheck2);\n            printf(\"size %d, alloc %x\\n\\n\",\n                   p->size, p->allocated);\n            printf(\"forward is %p, back is %p\\n\\n\",\n                   p->next, p->prev);\n            printf(\"forwardf is %p, backf is %p\\n\\n\",\n                   p->nextf, p->prevf);\n        }\n#endif\n        if ((p->eyecheck1 != 0xa5a5a5a5) || (p->eyecheck2 != 0xa5a5a5a5))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        if ((p->next != NULL) && (p->next->prev != p))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        p = p->next;\n    }\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"integrity checking free chain\\n\\n\");\n    }\n#endif\n    p = memmgr->startf;\n    if ((p != NULL) && (p->prevf != NULL))\n    {\n        *(char *)0 = '\\0'; /* try to invoke crash */\n        exit(EXIT_FAILURE);\n    }\n\n    while (p != NULL)\n    {\n#ifdef __MEMMGR_DEBUG\n        if (memmgrDebug)\n        {\n            printf(\"p is %p\\n\\n\", p);\n            printf(\"ec1 %x, ec2 %x\\n\\n\",\n                   p->eyecheck1, p->eyecheck2);\n            printf(\"size %d, alloc %x\\n\\n\",\n                   p->size, p->allocated);\n            printf(\"forwardf is %p, backf is %p\\n\\n\",\n                   p->nextf, p->prevf);\n        }\n#endif\n        if ((p->eyecheck1 != 0xa5a5a5a5) || (p->eyecheck2 != 0xa5a5a5a5)\n            || p->allocated)\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        if ((p->nextf != NULL) && (p->nextf->prevf != p))\n        {\n            *(char *)0 = '\\0'; /* try to invoke crash */\n            exit(EXIT_FAILURE);\n        }\n        p = p->nextf;\n    }\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"finished integrity checking\\n\\n\");\n    }\n#endif\n    return;\n}\n#endif\n\n/* resize a memory block */\n/* note that the size in the control block is the\n   size of available data plus the control block */\nint memmgrRealloc(MEMMGR *memmgr, void *ptr, size_t newsize)\n{\n    MEMMGRN *p, *n, *z;\n    size_t oldbytes = newsize;\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***reallocating %p\\n\\n\", ptr);\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n    newsize += MEMMGRN_SZ;\n    if ((newsize % MEMMGR_MINFRTOT) != 0)\n    {\n        newsize = ((newsize / MEMMGR_MINFRTOT) + 1)\n                   * MEMMGR_MINFRTOT;\n    }\n\n    /* if they have exceeded the limits of the data type,\n       bail out now. */\n    if (newsize < oldbytes)\n    {\n        return (-1);\n    }\n\n    /* if they are passing a NULL pointer, bail out also */\n    if (ptr == NULL)\n    {\n        return (-1);\n    }\n\n\n    p = (MEMMGRN *)((char *)ptr - MEMMGRN_SZ);\n\n    /* If they try to manipulate a bit of memory that isn't remotely\n       what it's meant to be, just crash so that they get a\n       call stack */\n    if (p->allocated != 0x5a5a)\n    {\n#if MEMMGR_CRASH\n        *(char *)0 = 0;\n#endif\n        exit(EXIT_FAILURE);\n    }\n\n    /* let's hope we're in the middle of a valid chain */\n\n    /* Now we have 3 distinct scenarios.\n       1. They are asking for a reduction in size, and there's room\n          to create a new (free) block of memory.\n          so newsize + minfree + cb <= p->size\n       2. They're asking for a reduction in size, but there's not\n          enough room for a new control block.\n          so newsize < p->size but newsize + minfree + cb > p->size\n       3. They're asking for an expansion of memory, and the next\n          block of memory up is able to satisfy that request.\n          so newsize > p->size\n    */\n\n    /* are they asking for an expansion? */\n    if (p->size < newsize)\n    {\n        n = p->next;\n        if ((n != NULL)\n            && !n->allocated\n            && !n->fixed\n            && ((n->size + p->size) >= newsize))\n        {\n            /* ok, we can satisfy this request. Let's see if we\n               have enough room to insert a new node. */\n            if ((p->size + n->size) < (newsize + MEMMGR_MINFRTOT))\n            {\n                /* not enough room for a new node - just combine\n                   and be done */\n                if (n->nextf != NULL)\n                {\n                    n->nextf->prevf = n->prevf;\n                }\n                if (n->prevf != NULL)\n                {\n                    n->prevf->nextf = n->nextf;\n                }\n                else if (memmgr->startf != n)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = n->nextf;\n                }\n                /* Ok, free chain has been taken care of, now let's get\n                   rid of that next node by combining */\n                p->size += n->size;\n                p->next = n->next;\n                if (p->next != NULL)\n                {\n                    p->next->prev = p;\n                }\n            }\n            else\n            {\n                /* we have room for a new node - so, construct the new\n                   node first */\n                z = (MEMMGRN *)((char *)p + newsize);\n                z->allocated = 0;\n                z->fixed = 0;\n#ifdef __MEMMGR_INTEGRITY\n                z->eyecheck1 = z->eyecheck2 = 0xa5a5a5a5;\n#endif\n                z->size = p->size + n->size - newsize;\n                z->prev = p;\n                p->next = z;\n                z->next = n->next;\n                if (z->next != NULL)\n                {\n                    z->next->prev = z;\n                }\n                z->nextf = n->nextf;\n                if (z->nextf != NULL)\n                {\n                    z->nextf->prevf = z;\n                }\n                z->prevf = n->prevf;\n                if (z->prevf != NULL)\n                {\n                    z->prevf->nextf = z;\n                }\n                else if (memmgr->startf != n)\n                {\n#if MEMMGR_CRASH\n                    *(char *)0 = 0;\n#endif\n                    exit(EXIT_FAILURE);\n                }\n                else\n                {\n                    memmgr->startf = z;\n                }\n                /* n node is now irrelevant. adjust p's size */\n                p->size = newsize;\n            }\n        }\n        /* we don't have enough room to satisfy this expansion request */\n        else\n        {\n            return (-1);\n        }\n    }\n    /* It's not an expansion, but is there enough room to insert a\n       new node? */\n    else if ((newsize + MEMMGR_MINFRTOT) <= p->size)\n    {\n        /* yep, let's insert new node */\n        n = (MEMMGRN *)((char *)p + newsize);\n        n->next = p->next;\n        if (n->next != NULL)\n        {\n            n->next->prev = n;\n        }\n        n->prev = p;\n        p->next = n;\n        n->fixed = 0;\n        n->size = p->size - newsize;\n        n->allocated = 0;\n#ifdef __MEMMGR_INTEGRITY\n        n->eyecheck1 = n->eyecheck2 = 0xa5a5a5a5;\n#endif\n        p->size = newsize;\n\n        /* combine with next block if possible */\n        z = n->next;\n        if ((z != NULL) && !z->allocated && !z->fixed)\n        {\n#ifdef __MEMMGR_INTEGRITY\n            z->eyecheck1 = z->eyecheck2 = 0;\n#endif\n            n->size += z->size;\n            n->next = z->next;\n            if (n->next != NULL)\n            {\n                n->next->prev = n;\n            }\n            n->nextf = z->nextf;\n            if (n->nextf != NULL)\n            {\n                n->nextf->prevf = n;\n            }\n            n->prevf = z->prevf;\n            if (n->prevf != NULL)\n            {\n                n->prevf->nextf = n;\n            }\n            else if (memmgr->startf != z)\n            {\n#if MEMMGR_CRASH\n                *(char *)0 = 0;\n#endif\n                exit(EXIT_FAILURE);\n            }\n            else\n            {\n                memmgr->startf = n;\n            }\n        }\n        /* otherwise add it to the start of the free chain */\n        else\n        {\n            n->nextf = memmgr->startf;\n            if (n->nextf != NULL)\n            {\n                n->nextf->prevf = n;\n            }\n            n->prevf = NULL;\n            memmgr->startf = n;\n        }\n    }\n    /* Otherwise they are requesting a minor resize downwards,\n       and we just need to acknowledge it, not actually do\n       anything. */\n\n#ifdef __MEMMGR_DEBUG\n    if (memmgrDebug)\n    {\n        printf(\"***returning from realloc\\n\\n\");\n    }\n#endif\n#ifdef __MEMMGR_INTEGRITY\n    memmgrIntegrity(memmgr);\n#endif\n\n    /* Keep track of the new size */\n    {\n        size_t *q;\n\n        q = (size_t *)((char *)p + MEMMGRN_SZ);\n        *(q - 1) = oldbytes;\n    }\n    return (0);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASSERT": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  assert.c - implementation of stuff in assert.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"assert.h\"\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"stddef.h\"\n\n__PDPCLIB_API__ int __assert(char *x, char *y, int z)\n{\n    fprintf(stderr, \"assertion failed for statement %s in \"\n            \"file %s on line %d\\n\", x, y, z);\n    abort();\n    return (0);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMSSTART": {"ttr": 6659, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  CMSSTART - STARTUP ROUTINES FOR CMS FOR USE WITH GCC.             *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n.NOMODE ANOP\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n         ENTRY @@CRT0\n@@CRT0   EQU   *\n*         ENTRY CEESTART\n*CEESTART EQU   *\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1            save R1 so we can get the PLIST\n         LR    R8,R0             save R0 so we can get the EPLIST\n         LR    R9,R13            save R13 so we can get flag byte\n         GETMAIN R,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n* Now let's get the program name and parameter list.\n         USING NUCON,R0          why do this? to access cmndline!\n         MVC   PGMNAME,CMNDLINE  get the name of this program\n         LA    R2,0(R11)         clean up PLIST\n         ST    R2,ARGPTR         store first argument for C\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         AIF   ('&SYS' EQ 'S370').NOBSM\n         BSM   R4,R0\n.NOBSM   ANOP\n         ST    R4,SAVER4\n         LR    R2,R11            get original R1\n         LTR   R4,R4\n         BZ    AMODE24\n         AIF   ('&SYS' EQ 'S370').NOSAVE\n         USING USERSAVE,R9\n         L     R2,USECTYP        get old style R1 flag byte\n.NOSAVE  ANOP\nAMODE24  EQU   *\n* At this point, the high order byte of R2 contains the\n* traditional CMS R1 flag byte.  A x'0B' or x'01' indicates the\n* presence of an extended parameter accessable via R0.\n         CLM   R2,8,=X'01'       called from EXEC, EXEC 2 or REXX?\n         BE    EPLIST            yes use the eplist\n         CLM   R2,8,=X'0B'       called from command line?\n         BE    EPLIST            yes, use the eplist\nNOEPLIST EQU   *\n         LA    R2,0              signal no eplist available\n         B     ONWARD\nEPLIST   EQU   *\n         LR    R2,R8             point to eplist\nONWARD   EQU   *\n*\n         ST    R2,ARGPTRE        store eplist for C\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR        store program name\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&SYS' NE 'S380').N380ST1\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n         LR    R9,R15\n*\n         AIF   ('&SYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R9\n         FREEMAIN R,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n         DS    0H\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&SYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nARGPTRE  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         NUCON\n         AIF   ('&SYS' NE 'S380').N380ST4\n         USERSAVE\n.N380ST4 ANOP\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CMSSUPA": {"ttr": 6663, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n*\n* MODS BY DAVE WADE\n*\n*\n*   1 - CHANGE REQUEST TYPE FROM RU TO R ON ALL GETMAIN/FREEMAIN\n*\n*   2 - REMOVE IEFJFCB AND REPLACE WITH DS 176\n*\n*   3 - ADD SVC 202 ROUTINE TO ALLOW CMS FUNCTIONS TO BE CALLED\n*\n**********************************************************************\n*                                                                    *\n*  CMSSUPA - SUPPORT ROUTINES FOR PDPCLIB UNDER CMS                  *\n*                                                                    *\n*  Note that it is necessary for these routines to stay below the    *\n*  line because they are using macros like \"GET\" that are documented *\n*  in z/VM as needing to be executed in AMODE 24. In order to lift   *\n*  this 24-bit restriction it will be necessary to switch to         *\n*  native CMS macros.                                                *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  EQU   *\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n* Member not used on CMS\n*         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n*         LA    R9,00(,R9)         Strip off high-order bit or byte\n*\n         AIF   ('&SYS' EQ 'S390').BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n.CHKBLWE ANOP\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR C/370\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n         USING IHADCB,R2\n         MVC   ZDCBAREA(INDCBLN),INDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,ENDFILE\n         ST    R4,DCBEODAD\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   OPENMB,OPENMAC\n*\n         RDJFCB ((R2),INPUT)\n*        LTR   R9,R9\n* DW * DON'T SUPPORT MEMBER NAME FOR NOW\n*        BZ    NOMEM\n         B     NOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         TM    DCBOFLGS,OFOPN     Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   WOPENMB,WOPENMAC\n*\n         RDJFCB ((R2),OUTPUT)\n*        LTR   R9,R9\n* DW * NO MEMBER ON VM/370\n*        BZ    WNOMEM\n         B     WNOMEM\n         USING ZDCBAREA,R2\n*        MVC   JFCBELNM,0(R9)\n*        OI    JFCBIND1,JFCPDS\n* DW * END OF MOD\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\n* CMS is missing this flag\n*         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         TM    DCBOFLGS,OFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n*\n* Handle will be returned in R7\n*\n         LR    R7,R2\n         AIF   ('&OUTM' NE 'M').NMM4\n         L     R6,=F'32768'\n* Give caller an internal buffer to write to. Below the line!\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&SYS' NE 'S370').MVT8090  If not S/370 then 380 or 390\n         GETMAIN R,LV=(R6),SP=SUBPOOL  No LOC= for S/370\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/380 or S/390\n         GETMAIN R,LV=(R6),SP=SUBPOOL,LOC=BELOW\n.GETOENE ANOP\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\n.NMM4    ANOP\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,DCBLRECL\n         ST    R6,0(R8)\n* DW * VM/370 IS MISSING THESE DEFS\n*        TM    DCBRECFM,DCBRECF\n         TM    DCBRECFM,RECF\n* END\n         BNO   VARIABLE\n* This looks really whacky, but is correct\n* We check for V, in order to split between F and U\n* Because U has both F and V\n         TM    DCBRECFM,RECV\n         BNO   FIXED\n         L     R6,=F'2'\n         B     DONESET\nFIXED    DS    0H\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AREAD\n@@AREAD  EQU   *\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&SYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&SYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GET   (R2)\n         ST    R1,0(R3)\n         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&SYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AWRITE - Write to file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE EQU   *\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1\n         L     R2,0(R1)\n         USING ZDCBAREA,R2\n         L     R4,8(R1)         R4 points to length to write\n         L     R4,0(R4)         R4 = length to write\n         STH   R4,DCBLRECL      store length to write\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n*\n         AIF ('&SYS' EQ 'S370').NOMOD3\n         CALL  @@SETM24\n.NOMOD3  ANOP\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n* In move mode, always use our internal buffer. Ignore passed parm.\n         L     R3,ASMBUF\n         PUT   (R2),(R3)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R3)\n.NLM3    ANOP\n         AIF ('&SYS' EQ 'S370').NOMOD4\n         CALL  @@SETM31\n.NOMOD4  ANOP\n         LA    R15,0\n*\nRETURNAW DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n*         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE EQU   *\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         AIF   ('&SYS' EQ 'S390').BELOW3\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         AGO   .NOBEL3\n.BELOW3  ANOP\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n.NOBEL3  ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n         FREEMAIN R,LV=(R6),A=(R5),SP=SUBPOOL\nNFRCL    DS    0H\n.NMM6    ANOP\n         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n         CLOSE ((R2)),MF=(E,CLOSEMB)\n         FREEPOOL ((R2))\n         FREEMAIN R,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN R,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  GETM - GET MEMORY                                                 *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETM\n@@GETM   EQU   *\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(R1)\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n* THIS LINE IS FOR C/370\n*         L     R3,0(R2)\n         LR    R4,R3\n         A     R3,=F'8'\n*\n* It would be nice to allocate memory with the default\n* LOC=RES. However, due to the fact that we need to be\n* in AMODE 24 to use things like \"GET\", it is necessary\n* for this program to reside below the line. As such,\n* we need to use LOC=ANY to get ATL memory.\n*\n         AIF   ('&SYS' NE 'S370').ANYCHKY\n* CAN'T USE \"ANY\" ON MVS 3.8\n         GETMAIN R,LV=(R3),SP=SUBPOOL\n         AGO   .ANYCHKE\n.ANYCHKY ANOP\n         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n.ANYCHKE ANOP\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  FREEM - FREE MEMORY                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@FREEM\n@@FREEM  EQU   *\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(R1)\n         S     R2,=F'8'\n         L     R3,0(R2)\n         AIF   ('&SYS' EQ 'S370').F370\n         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n         AGO   .FINFREE\n.F370    ANOP\n* S/370\n         FREEMAIN R,LV=(R3),A=(R2),SP=SUBPOOL\n.FINFREE ANOP\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@SVC202 - ISSUES AN SVC 202 CALL\n*\n*  E.G. @@SVC202(PARMS,CODE,ERROR)\n*\n* WHERE :-\n*\n*  PARMS IS A POINTER TO AN SVC202 PARAMETER LIST\n*\n*  CODE IS A CODE TO SAY OF &CONTROL IS ON OR OFF\n*\n* AND ERROR IS SET TO -1\n*\n**********************************************************************\n         ENTRY @@SVC202\n@@SVC202 EQU *\n         SAVE  (14,12),,@@SVC202\n         LR    R12,R15\n         USING @@SVC202,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         AIF ('&SYS' NE 'S380').NOMODS1\n         CALL  @@SETM24\n.NOMODS1 ANOP\n         L     R3,0(R1)         R3 POINTS TO SVC202 PARM LIST\n         L     R4,4(R1)         R4 POINTS TO CODE\n         L     R5,8(R1)         R5 POINTS TO RETURN CODE\n         SR    R6,R6            CLEAR R6\n         ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LR    R1,R3\n*\n         AIF   ('&SYS' EQ 'S390').DOCALL\n         SVC   202              ISSUE COMMAND\n         DC    AL4(SV202ER)     ERROR\n         AGO   .FINCALL\n.DOCALL  ANOP\n         CMSCALL ERROR=SV202ER\n.FINCALL ANOP\n*\nSV202RT  EQU    *\n         LR    R7,R15\n         AIF ('&SYS' NE 'S380').NOMODS2\n         CALL  @@SETM31\n.NOMODS2 ANOP\n         LR    R15,R7\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\nSV202ER  EQU   *\n         L     R3,=F'-1'\n         ST    R3,0(R5)\n         B     SV202RT\n         LTORG\n*\n*\n*\n**********************************************************************\n*\n*  @@ATTN@@ - ISSUES AN SVC 202 CALL TO STACK A LINE\n*\n*  E.G. @@ATTN@@(LINE,LEN,ORDER)\n*\n* WHERE :-\n*\n*  LINE IS A POINTER TO LINE TO BE STACKED\n*\n*  LEN IS THE NUMBER OF CHARACTERS. (<256)\n*\n*  ORDER IS POINTER TO EITHER FIFO OR LIFO\n*\n**********************************************************************\n         ENTRY @@ATTN@@\n@@ATTN@@ EQU *\n         SAVE  (14,12),,@@ATTN@@\n         LR    R12,R15\n         USING @@ATTN@@,R12\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO LINE TO STACK\n         ST    R3,ATTNLN        SAVE IN 202 PLIST\n         L     R4,4(R1)         R4 POINTS TO LENGTH OF LINE\n         MVC   ATTNLN,3(R4)     FIDDLE\n         L     R5,8(R1)         R5 POINTS TO LIFO OR FIFO\n         MVC   ATTNOD,0(R5)\n         SR    R6,R6            CLEAR R6\n*        ST    R6,0(R5)         AND SAVE IN RETURN CODE\n         LA    R1,ATTNPL\n         SVC   202              ISSUE COMMAND\n         DC    AL4(ATTNER)      ERROR\nATTNRT   EQU    *\n         LR     R1,R11\n         RETURN (14,12),RC=(15)\nATTNER   EQU    *\n*        L      R3,=F'-1'\n*        ST     R3,0(R5)\n         B      ATTNRT\n         LTORG\n*\nATTNPL   DS   0D\n         DC   CL8'ATTN'\nATTNOD   DC   CL4'XXXX'     WHERE ORDER MAY BE LIFO OR FIFO.\n*                            FIFO IS THE DEFAULT\nATTNLN   DC   AL1(0)         LENGTH OF LINE TO BE STACKED\nATTNAD   DC   AL3(ATTNAD)    ADDRESS OF LINE TO BE STACKED\n*\n*\n**********************************************************************\n*\n*  @@STACKN - RETURNS THE NUMBER OF LINES ON THE CONSOLE STACK\n*\n*  E.G. @@STACKN(COUNT)\n*\n* WHERE :-\n*\n*  COUNT IS A POINTER TO AN INT - NUMBER OF LINES TETURNED\n*\n*\n**********************************************************************\n         ENTRY @@STACKN\n@@STACKN EQU *\n         SAVE  (14,12),,@@STACKN\n         LR    R12,R15\n         USING @@STACKN,R12\n         USING NUCON,R0\n         LR    R11,R1           NEED TO RESTORE R1 FOR C\n         L     R3,0(R1)         R3 POINTS TO COUNT\n         LH    R2,NUMFINRD      R2 HAS COUNT OF LINES ON STACK\n         ST    R2,0(R3)         R2 TO COUNT\n         LR    R1,R11\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN  *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN   *\n*  ANY PARTICULAR WAY.                                               *\n*                                                                    *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                               *\n*                                                                    *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01 *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                   *\n*                                                                    *\n**********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK EQU   *\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(R1)\n         STCK  0(R2)\n         L     R4,0(R2)\n         L     R5,4(R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Keep this code last because it uses a different base register\n*\n         DROP  R12\n**********************************************************************\n*                                                                    *\n*  SETJ - SAVE REGISTERS INTO ENV                                    *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)        get the env variable\n         STM   R0,R14,0(R15)    save registers to be restored\n         LA    R15,0            setjmp needs to return 0\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                *\n*                                                                    *\n**********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)         get the env variable\n         L     R15,60(R2)       get the return code\n         LM    R0,R14,0(R2)     restore registers\n         BR    R14              return to caller\n         LTORG ,\n*\n*\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&SYS' EQ 'S370').NOMODE2 If S/370 we can't switch mode\n**********************************************************************\n*                                                                    *\n*  SETM24 - Set AMODE to 24                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n**********************************************************************\n*                                                                    *\n*  SETM31 - Set AMODE to 31                                          *\n*                                                                    *\n**********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE2 ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n         DCBD  DSORG=PS\n         ORG   IHADCB\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         ORG   IHADCB\n         DS    CL(OUTDCBLN)\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\nJFCBPTR  DS    F\nJFCB     DS    0F\n*        IEFJFCBN\n* z/VM manual says to use 176 characters\n         DS    CL176\nSAVEADCB DS    18F                Register save area for PUT\n         DS    0F\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTting data\n*\nZDCBLEN  EQU   *-ZDCBAREA\nRECF     EQU   X'80'                   FIXED RECORD FORMAT\nRECV     EQU   X'40'                   VARYING RECORD FORMAT\nRECU     EQU   X'C0'                   UNDEFINED RECORD FORMAT\nRECUV    EQU   X'40'                   U OR V RECORD FORMAT\nRECUF    EQU   X'80'                   U OR F RECORD FORMAT\nOFOPN    EQU   X'10'                   OPEN SUCCESSFUL\n         NUCON\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYFILE": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  This program reads from an input file and writes to an output    */\n/*  file.                                                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd6144\u00a8; /* arbitrary buffer size */\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    char *in_name;\n    char *out_name;\n    int c;\n    int off = 0;\n    char *in = \"r\";\n    char *out = \"w\";\n    unsigned long total = 0;\n\n    if (argc < 3)\n    {\n        printf(\"usage: copyfile \u00dd-bb/-tt/-tb/-bt\u00a8 <infile> <outfile>\\n\");\n        printf(\"default is text to text copy\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (argc > 3)\n    {\n        if (argv\u00dd1\u00a8\u00dd0\u00a8 == '-')\n        {\n            if ((argv\u00dd1\u00a8\u00dd1\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd1\u00a8 == 'B'))\n            {\n                in = \"rb\";\n            }\n            if ((argv\u00dd1\u00a8\u00dd2\u00a8 == 'b') || (argv\u00dd1\u00a8\u00dd2\u00a8 == 'B'))\n            {\n                out = \"wb\";\n            }\n            off++;\n        }\n    }\n    in_name = *(argv + off + 1);\n    if (strcmp(in_name, \"-\") == 0)\n    {\n        fp = stdin;\n    }\n    else\n    {\n        fp = fopen(in_name, in);\n    }\n    if (fp == NULL)\n    {\n        printf(\"failed to open %s for reading\\n\", in_name);\n        return (EXIT_FAILURE);\n    }\n\n    out_name = *(argv + off + 2);\n    if (strcmp(out_name, \"-\") == 0)\n    {\n        fq = stdout;\n    }\n    else\n    {\n        fq = fopen(out_name, out);\n    }\n    if (fq == NULL)\n    {\n        printf(\"failed to open %s for writing\\n\", out_name);\n        return (EXIT_FAILURE);\n    }\n\n    printf(\"copying from file %s, mode %s\\n\",\n           in_name,\n           (strlen(in) == 1) ? \"text\" : \"binary\");\n\n    printf(\"to file %s, mode %s\\n\",\n           out_name,\n           (strlen(out) == 1) ? \"text\" : \"binary\");\n\n    while ((c = fread(buf, 1, sizeof buf, fp)) > 0)\n    {\n        total += c;\n        fwrite(buf, 1, c, fq);\n        if (ferror(fq)) break;\n    }\n\n    if (ferror(fp) || ferror(fq))\n    {\n        printf(\"i/o error\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"%lu bytes copied\\n\", total);\n\n    fclose(fq); /* keep last in case it is stdout */\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "CTYPE": {"ttr": 262, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  ctype.c - implementation of stuff in ctype.h                     */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stddef.h\"\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\nstatic unsigned short __isbufR\u00dd257\u00a8 = {\n    0x0000U, /* EOF */\n    0x0004U, /* NUL */\n    0x0004U, /* 01  */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0140U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#else\n\nstatic unsigned short __isbufR\u00dd257\u00a8 = {\n    0x0000U, /* EOF */\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0104U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0104U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0000U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0004U,\n    0x0000U,\n    0x0004U,\n    0x0140U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x00D0U,\n    0x0000U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0473U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0073U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0653U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x00D0U,\n    0x0000U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0253U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0459U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U,\n    0x0000U };\n\nstatic short __tolowR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0x81,\n    0x82,\n    0x83,\n    0x84,\n    0x85,\n    0x86,\n    0x87,\n    0x88,\n    0x89,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0x91,\n    0x92,\n    0x93,\n    0x94,\n    0x95,\n    0x96,\n    0x97,\n    0x98,\n    0x99,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xA2,\n    0xA3,\n    0xA4,\n    0xA5,\n    0xA6,\n    0xA7,\n    0xA8,\n    0xA9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\nstatic short __toupR\u00dd257\u00a8 = {\n    -1,\n    0x00,\n    0x01,\n    0x02,\n    0x03,\n    0x04,\n    0x05,\n    0x06,\n    0x07,\n    0x08,\n    0x09,\n    0x0A,\n    0x0B,\n    0x0C,\n    0x0D,\n    0x0E,\n    0x0F,\n    0x10,\n    0x11,\n    0x12,\n    0x13,\n    0x14,\n    0x15,\n    0x16,\n    0x17,\n    0x18,\n    0x19,\n    0x1A,\n    0x1B,\n    0x1C,\n    0x1D,\n    0x1E,\n    0x1F,\n    0x20,\n    0x21,\n    0x22,\n    0x23,\n    0x24,\n    0x25,\n    0x26,\n    0x27,\n    0x28,\n    0x29,\n    0x2A,\n    0x2B,\n    0x2C,\n    0x2D,\n    0x2E,\n    0x2F,\n    0x30,\n    0x31,\n    0x32,\n    0x33,\n    0x34,\n    0x35,\n    0x36,\n    0x37,\n    0x38,\n    0x39,\n    0x3A,\n    0x3B,\n    0x3C,\n    0x3D,\n    0x3E,\n    0x3F,\n    0x40,\n    0x41,\n    0x42,\n    0x43,\n    0x44,\n    0x45,\n    0x46,\n    0x47,\n    0x48,\n    0x49,\n    0x4A,\n    0x4B,\n    0x4C,\n    0x4D,\n    0x4E,\n    0x4F,\n    0x50,\n    0x51,\n    0x52,\n    0x53,\n    0x54,\n    0x55,\n    0x56,\n    0x57,\n    0x58,\n    0x59,\n    0x5A,\n    0x5B,\n    0x5C,\n    0x5D,\n    0x5E,\n    0x5F,\n    0x60,\n    0x61,\n    0x62,\n    0x63,\n    0x64,\n    0x65,\n    0x66,\n    0x67,\n    0x68,\n    0x69,\n    0x6A,\n    0x6B,\n    0x6C,\n    0x6D,\n    0x6E,\n    0x6F,\n    0x70,\n    0x71,\n    0x72,\n    0x73,\n    0x74,\n    0x75,\n    0x76,\n    0x77,\n    0x78,\n    0x79,\n    0x7A,\n    0x7B,\n    0x7C,\n    0x7D,\n    0x7E,\n    0x7F,\n    0x80,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0x8A,\n    0x8B,\n    0x8C,\n    0x8D,\n    0x8E,\n    0x8F,\n    0x90,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0x9A,\n    0x9B,\n    0x9C,\n    0x9D,\n    0x9E,\n    0x9F,\n    0xA0,\n    0xA1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xAA,\n    0xAB,\n    0xAC,\n    0xAD,\n    0xAE,\n    0xAF,\n    0xB0,\n    0xB1,\n    0xB2,\n    0xB3,\n    0xB4,\n    0xB5,\n    0xB6,\n    0xB7,\n    0xB8,\n    0xB9,\n    0xBA,\n    0xBB,\n    0xBC,\n    0xBD,\n    0xBE,\n    0xBF,\n    0xC0,\n    0xC1,\n    0xC2,\n    0xC3,\n    0xC4,\n    0xC5,\n    0xC6,\n    0xC7,\n    0xC8,\n    0xC9,\n    0xCA,\n    0xCB,\n    0xCC,\n    0xCD,\n    0xCE,\n    0xCF,\n    0xD0,\n    0xD1,\n    0xD2,\n    0xD3,\n    0xD4,\n    0xD5,\n    0xD6,\n    0xD7,\n    0xD8,\n    0xD9,\n    0xDA,\n    0xDB,\n    0xDC,\n    0xDD,\n    0xDE,\n    0xDF,\n    0xE0,\n    0xE1,\n    0xE2,\n    0xE3,\n    0xE4,\n    0xE5,\n    0xE6,\n    0xE7,\n    0xE8,\n    0xE9,\n    0xEA,\n    0xEB,\n    0xEC,\n    0xED,\n    0xEE,\n    0xEF,\n    0xF0,\n    0xF1,\n    0xF2,\n    0xF3,\n    0xF4,\n    0xF5,\n    0xF6,\n    0xF7,\n    0xF8,\n    0xF9,\n    0xFA,\n    0xFB,\n    0xFC,\n    0xFD,\n    0xFE,\n    0xFF };\n\n#endif\n\nunsigned short *__isbuf = &__isbufR\u00dd1\u00a8;\nshort *__tolow = &__tolowR\u00dd1\u00a8;\nshort *__toup = &__toupR\u00dd1\u00a8;\n\n__PDPCLIB_API__ int isalnum(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0001U);\n}\n\n__PDPCLIB_API__ int isalpha(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0002U);\n}\n\n__PDPCLIB_API__ int iscntrl(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0004U);\n}\n\n__PDPCLIB_API__ int isdigit(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0008U);\n}\n\n__PDPCLIB_API__ int isgraph(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0010U);\n}\n\n__PDPCLIB_API__ int islower(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0020U);\n}\n\n__PDPCLIB_API__ int isprint(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0040U);\n}\n\n__PDPCLIB_API__ int ispunct(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0080U);\n}\n\n__PDPCLIB_API__ int isspace(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0100U);\n}\n\n__PDPCLIB_API__ int isupper(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0200U);\n}\n\n__PDPCLIB_API__ int isxdigit(int c)\n{\n    return (__isbuf\u00dd(c)\u00a8 & 0x0400U);\n}\n\n__PDPCLIB_API__ int tolower(int c)\n{\n    return (__tolow\u00dd(c)\u00a8);\n}\n\n__PDPCLIB_API__ int toupper(int c)\n{\n    return (__toup\u00dd(c)\u00a8);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOSSTART": {"ttr": 6920, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; dosstart.asm - startup code for C programs for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___start:proc\n\npublic ___psp\npublic ___envptr\npublic ___osver\n\n_DATA   segment word public 'DATA'\nbanner  db  \"PDPCLIB\"\n___psp   dd  ?\n___envptr dd ?\n___osver dw ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n_STACK  segment word stack 'STACK'\n        db 1000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\ntop:\n\n___intstart proc\n\n; add some nops to create a cs-addressable save area, and also create a\n; bit of an eyecatcher\n\nnop\nnop\nnop\nnop\n\n; push the psp now, ready for calling start\npush ds\nmov ax, 0\npush ax\n\n; determine how much memory is needed. The stack pointer points\n; to the top. Work out what segment that is, then subtract the\n; starting segment (the PSP), and you have your answer.\n\nmov ax, sp\nmov cl, 4\nshr ax, cl ; get sp into pages\nmov bx, ss\nadd ax, bx\nadd ax, 2 ; safety margin because we've done some pushes etc\nmov bx, es\nsub ax, bx ; subtract the psp segment\n\n; free initially allocated memory\n\nmov bx, ax\nmov ah, 4ah\nint 21h\n\nmov dx,DGROUP\nmov ds,dx\n\nmov ah,30h\nint 21h\nxchg al,ah\nmov \u00dd___osver\u00a8,ax\n\nmov word ptr ___psp, 0\nmov word ptr \u00dd___psp + 2\u00a8, es\nmov word ptr ___envptr, 0\nmov dx, es:\u00dd02ch\u00a8\nmov word ptr \u00dd___envptr + 2\u00a8, dx\nmov dx, ds\nmov es, dx\n\n; we have already pushed the pointer to psp\ncall far ptr ___start\nadd sp, 4  ; delete psp from stack\n\npush ax\n\n; how do I get rid of the warning about \"instruction can be compacted\n; with override\"?  The answer is certainly NOT to change the \"far\" to\n; \"near\".\ncall far ptr ___exita\nadd sp, 2\nret\n___intstart endp\n\npublic ___exita\n___exita proc\npush bp\nmov bp, sp\nmov ax, \u00ddbp + 6\u00a8\nmov ah,4ch\nint 21h ; terminate\npop bp\nret\n___exita endp\n\n\npublic ___main\n___main proc\nret\n___main endp\n\n\n_TEXT ends\n\nend top\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOSSUPA": {"ttr": 6923, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; dossupa.asm - assembler support functions for DOS\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.model large\n\nextrn ___divide:proc\nextrn ___modulo:proc\n\npublic fidrqq\npublic fiwrqq\npublic fierqq\n\n_DATA   segment word public 'DATA'\nfidrqq  dw  ?\nfiwrqq  dw  ?\nfierqq  dw  ?\n_DATA   ends\n_BSS    segment word public 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment word public 'CODE'\n\npublic ___open\n___open proc\npush bp\nmov bp, sp\n\npush bx\npush dx\npush ds\n\nmov dx,\u00ddbp+8\u00a8\nmov ds,dx\nmov dx,\u00ddbp+6\u00a8\nmov al,\u00ddbp+11\u00a8\n\nmov ah, 3dh\nint 21h\n\njc ___open1\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___open2\n___open1:\nmov dx,\u00ddbp+14\u00a8\nmov ds,dx\nmov bx,\u00ddbp+12\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___open2:\npop ds\npop dx\npop bx\n\npop bp\nret\n___open endp\n\n\npublic ___read\n___read proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov dx,\u00ddbp+8\u00a8\nmov cx,\u00ddbp+12\u00a8\n\nmov ah, 3fh\nint 21h\n\njc ___read1\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___read2\n___read1:\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___read2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___read endp\n\n\npublic ___write\n___write proc\npush bp\nmov bp,sp\n\npush bx\npush cx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov dx,\u00ddbp+8\u00a8\nmov cx,\u00ddbp+12\u00a8\n\nmov ah, 40h\nint 21h\n\njc ___write1\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 0\njmp short ___write2\n___write1:\nmov dx,\u00ddbp+16\u00a8\nmov ds,dx\nmov bx,\u00ddbp+14\u00a8\nmov word ptr \u00ddbx\u00a8, 1\n___write2:\n\npop ds\npop dx\npop cx\npop bx\n\npop bp\nret\n___write endp\n\n\n; seek - handle, offset, type\n\npublic ___seek\n___seek proc\npush bp\nmov bp, sp\npush bx\npush dx\npush cx\n\nmov bx, \u00ddbp + 8\u00a8\nmov dx, \u00ddbp + 10\u00a8\nmov cx, \u00ddbp + 12\u00a8\nmov al, \u00ddbp + 13\u00a8\n\nmov ah, 042h\nint 021h\n\npop cx\npop dx\npop bx\npop bp\nret\n___seek endp\n\n\npublic ___close\n___close proc\npush bp\nmov bp, sp\npush bx\n\nmov bx,\u00ddbp+8\u00a8\n\nmov ah, 03eh\nint 021h\n\npop bx\npop bp\nret\n___close endp\n\n\npublic ___remove\n___remove proc\npush bp\nmov bp, sp\npush ds\npush dx\n\nmov dx, \u00ddbp + 8\u00a8\nmov ds, \u00ddbp + 10\u00a8\n\nmov ah, 041h\nint 021h\n\npop dx\npop ds\npop bp\nret\n___remove endp\n\n\npublic ___rename\n___rename proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush di\n\nmov dx, \u00ddbp + 8\u00a8\nmov ds, \u00ddbp + 10\u00a8\nmov di, \u00ddbp + 12\u00a8\nmov es, \u00ddbp + 14\u00a8\n\nmov ah, 056h\nint 021h\n\npop di\npop es\npop dx\npop ds\npop bp\nret\n___rename endp\n\n\n\npublic ___allocmem\n___allocmem proc\npush bp\nmov bp,sp\n\npush bx\npush dx\npush ds\n\nmov bx,\u00ddbp+6\u00a8\n\nshr bx,1\nshr bx,1\nshr bx,1\nshr bx,1\n\nadd bx,1\nmov ah, 48h\nint 21h\n\njnc allocok\nmov ax, 0\nallocok:\nmov dx,\u00ddbp+10\u00a8\nmov ds,dx\nmov bx,\u00ddbp+8\u00a8\n\nmov word ptr \u00ddbx\u00a8, 0\nmov word ptr \u00ddbx+2\u00a8, ax\n\npop ds\npop dx\npop bx\npop bp\nret\n___allocmem endp\n\n\npublic ___freemem\n___freemem proc\npush bp\nmov bp,sp\npush es\npush dx\npush cx\n\nmov dx,\u00ddbp+6\u00a8\nmov cx,\u00ddbp+8\u00a8\n\nshr dx, 1\nshr dx, 1\nshr dx, 1\nshr dx, 1\n\nadd cx, dx\nmov es, cx\nmov ah, 049h\nint 21h\n\npop cx\npop dx\npop es\npop bp\nret\n___freemem endp\n\n\npublic ___setj\n___setj proc\n        push bp\n        mov bp,sp\n        push ds\n\n        mov ax, \u00ddbp + 6\u00a8\n        mov ds, \u00ddbp + 8\u00a8\n        push bx\n        push bp\n        mov bp, sp\n        mov bx, bp\n        pop bp\n        push bx               ; sp\n\n        mov bx,ax\n        mov \u00ddbx + 2\u00a8, cx\n        mov \u00ddbx + 4\u00a8, dx\n        mov \u00ddbx + 6\u00a8, di\n        mov \u00ddbx + 8\u00a8, si\n\n        pop ax\n        mov \u00ddbx + 10\u00a8, bx    ; sp\n        mov ax, \u00ddbp + 0\u00a8     ; bp\n        mov \u00ddbx + 12\u00a8, ax    ; bp\n\n        mov ax, \u00ddbp + 2\u00a8     ; return address\n        mov \u00ddbx + 14\u00a8, ax    ; return address\n        mov ax, \u00ddbp + 4\u00a8     ; return address\n        mov \u00ddbx + 16\u00a8, ax    ; return address\n\n        pop ax               ; bx\n        mov \u00ddbx + 0\u00a8, ax\n        pop ax               ; ds\n        push ax\n        mov \u00ddbx + 18\u00a8, ax\n        mov ax, es\n        mov \u00ddbx + 20\u00a8, ax    ; es\n        mov ax, \u00ddbx + 0\u00a8     ; bx\n        mov bx, ax\n\n        mov ax, 0\n\n        pop ds\n        pop bp\n        ret\n___setj endp\n\n\npublic ___longj\n___longj proc\n        push bp\n        mov bp, sp\n\n        mov bx, \u00ddbp + 6\u00a8\n        mov ds, \u00ddbp + 8\u00a8\n        mov bp, \u00ddbx + 10\u00a8\n        mov sp, bp\n        mov bp, \u00ddbx + 12\u00a8\n        pop ax               ; position of old bx\n        pop ax               ; position of old ds\n        pop ax               ; position of old bp\n        pop ax               ; position of old return address\n        pop ax               ; position of old return address\n\n        mov ax, \u00ddbx + 16\u00a8    ; return address\n        push ax\n        mov ax, \u00ddbx + 14\u00a8    ; return address\n        push ax\n\n        mov ax, \u00ddbx + 12\u00a8    ; bp saved as normal\n        push ax\n\n        mov cx, \u00ddbx + 2\u00a8\n        mov dx, \u00ddbx + 4\u00a8\n        mov di, \u00ddbx + 6\u00a8\n        mov si, \u00ddbx + 8\u00a8\n\n        mov ax, \u00ddbx + 0\u00a8\n        push ax              ; bx\n        mov ax, \u00ddbx + 18\u00a8    ; ds\n        push ax\n        mov ax, \u00ddbx + 20\u00a8    ; es\n        mov es, ax\n        mov ax, \u00ddbx + 22\u00a8    ; return value\n        pop ds\n        pop bx\n\n        pop bp\n        ret\n___longj endp\n\n\n; full path, parm block\npublic ___exec\n___exec proc\npush bp\nmov bp, sp\npush ds\npush dx\npush es\npush bx\npush cx\npush si\npush di\n\nmov dx, \u00ddbp + 6\u00a8\nmov ds, \u00ddbp + 8\u00a8\nmov bx, \u00ddbp + 10\u00a8\nmov es, \u00ddbp + 12\u00a8\n\njmp short bypass\ndummy1 dw ?\ndummy2 dw ?\nbypass:\n\nmov dummy1, sp\nmov dummy2, ss\n\nmov al, 0\nmov ah, 04bh\ncld              ; dos 2 \"bug\"\nint 21h\n\ncli\nmov ss, dummy2\nmov sp, dummy1\nsti\n\npop di\npop si\npop cx\npop bx\npop es\npop dx\npop ds\npop bp\nret\n___exec endp\n\n\npublic ___datetime\n___datetime proc\npush bp\nmov bp, sp\npush ds\npush dx\npush cx\npush bx\n\nmov bx, \u00ddbp + 6\u00a8\nmov ds, \u00ddbp + 8\u00a8\n\nmov ah, 02ah\nint 021h\n\nmov \u00ddbx + 0\u00a8, cx\nmov ch, 0\nmov cl, dh\nmov \u00ddbx + 2\u00a8, cx\nmov dh, 0\nmov \u00ddbx + 4\u00a8, dx\n\nmov ah, 02ch\nint 021h\n\nmov ah, 0\nmov al, ch\nmov \u00ddbx + 6\u00a8, ax\nmov ch, 0\nmov \u00ddbx + 8\u00a8, cx\nmov ah, 0\nmov al, dh\nmov \u00ddbx + 10\u00a8, ax\nmov dh, 0\nmov \u00ddbx + 12\u00a8, dx\n\npop bx\npop cx\npop dx\npop ds\npop bp\nret\n___datetime endp\n\n\nifdef WATCOM\n; divide dx:ax by cx:bx, result in dx:ax\npublic __U4D\n__U4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lumod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ludiv@\nret\n__U4D endp\nendif\n\n\npublic f_ludiv@\nf_ludiv@ proc far\npush bp\nmov bp,sp\npush bx\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne ludiv_full\n\nmov ax, \u00ddbp + 8\u00a8\nmov dx, 0\ndiv word ptr \u00ddbp + 10\u00a8\nmov bx, ax\nmov ax, \u00ddbp + 6\u00a8\ndiv word ptr \u00ddbp + 10\u00a8\n\nmov dx, bx\njmp short ludiv_fin\n\nludiv_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___divide\nadd sp, 8\n\nludiv_fin:\n\npop bx\npop bp\nret 8\nf_ludiv@ endp\n\n\n; dx:ax divided by cx:bx, result in dx:ax, module on cx:bx\n\nifdef WATCOM\npublic __I4D\n__I4D proc\npush cx\npush bx\npush dx\npush ax\npush cx\npush bx\npush dx\npush ax\ncall far ptr f_lmod@\nmov cx, dx\nmov bx, ax\ncall far ptr f_ldiv@\nret\n__I4D endp\nendif\n\n\n; must release stack space in this procedure\npublic f_ldiv@\nf_ldiv@ proc\npush bp\nmov bp,sp\npush dx\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne ldiv_full\n\nmov ax,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+8\u00a8\nidiv word ptr \u00ddbp+10\u00a8\njmp short ldiv_fin\n\nldiv_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___divide\nadd sp, 8\n\nldiv_fin:\n\npop dx\npop bp\nret 8\nf_ldiv@ endp\n\n\npublic f_lmod@\nf_lmod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne lmod_full\n\nmov ax,\u00ddbp+6\u00a8\nmov dx,\u00ddbp+8\u00a8\nidiv word ptr \u00ddbp+10\u00a8\nmov ax,dx\nmov dx,0\njmp short lmod_fin\n\nlmod_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___modulo\nadd sp, 8\n\nlmod_fin:\n\npop bp\nret 8\nf_lmod@ endp\n\n\n; procedure needs to fix up stack\npublic f_lumod@\nf_lumod@ proc\npush bp\nmov bp,sp\n\ncmp word ptr \u00ddbp + 12\u00a8, 0\njne lumod_full\n\nmov ax, \u00ddbp + 8\u00a8\nmov dx, 0\ndiv word ptr \u00ddbp + 10\u00a8\nmov ax, \u00ddbp + 6\u00a8\ndiv word ptr \u00ddbp + 10\u00a8\nmov ax,dx\nmov dx, 0\njmp short lumod_fin\n\nlumod_full:\npush word ptr \u00ddbp + 12\u00a8\npush word ptr \u00ddbp + 10\u00a8\npush word ptr \u00ddbp + 8\u00a8\npush word ptr \u00ddbp + 6\u00a8\ncall far ptr ___modulo\nadd sp, 8\n\nlumod_fin:\n\npop bp\nret 8\nf_lumod@ endp\n\n\n; multiply cx:bx by dx:ax, result in dx:ax\n\npublic __I4M\n__I4M:\npublic __U4M\n__U4M:\npublic f_lxmul@\nf_lxmul@ proc\npush bp\nmov bp,sp\npush cx\n\npush ax\nmul cx\nmov cx, ax\npop ax\nmul bx\nadd dx, cx\n\npop cx\npop bp\nret\nf_lxmul@ endp\n\n\n; shift dx:ax left by cl\n\npublic f_lxlsh@\nf_lxlsh@ proc\npush bx\n\ncmp cl, 24\njl lxlsh_16\nmov dh, al\nmov dl, 0\nmov ax, 0\nsub cl, 24\njmp short lxlsh_last\n\nlxlsh_16:\ncmp cl, 16\njl lxlsh_8\nmov dx, ax\nmov ax, 0\nsub cl, 16\njmp short lxlsh_last\n\nlxlsh_8:\ncmp cl, 8\njl lxlsh_last\nmov dh, dl\nmov dl, ah\nmov ah, al\nmov al, 0\nsub cl, 8\n;jmp short lxlsh_last\n\nlxlsh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, ax\nshr bx, cl\nxchg ch, cl\nshl dx, cl\nor dl, bh\nshl ax, cl\n\npop bx\nret\nf_lxlsh@ endp\n\n\n; shift dx:ax right by cl\n\npublic f_lxursh@\nf_lxursh@ proc\npush bx\n\ncmp cl, 24\njl lxursh_16\nmov al, dh\nmov ah, 0\nmov dx, 0\nsub cl, 24\njmp short lxursh_last\n\nlxursh_16:\ncmp cl, 16\njl lxursh_8\nmov ax, dx\nmov dx, 0\nsub cl, 16\njmp short lxursh_last\n\nlxursh_8:\ncmp cl, 8\njl lxursh_last\nmov al, ah\nmov ah, dl\nmov dl, dh\nmov dh, 0\nsub cl, 8\n;jmp short lxursh_last\n\nlxursh_last:\n\nmov ch, 8\nsub ch, cl\nxchg ch, cl\nmov bx, dx\nshl bx, cl\nxchg ch, cl\nshr ax, cl\nor ah, bl\nshr dx, cl\n\npop bx\nret\nf_lxursh@ endp\n\n\n; this procedure needs to fix up the stack\npublic f_scopy@\nf_scopy@ proc\n\npush bp\nmov bp, sp\npush cx\npush ds\npush es\npush si\npush di\nlds si, \u00ddbp + 6\u00a8\nles di, \u00ddbp + 10\u00a8\ncld\nrep movsb\n\npop di\npop si\npop es\npop ds\npop cx\npop bp\nret 8\nf_scopy@ endp\n\n\npublic f_ftol@\nf_ftol@ proc\nret\nf_ftol@ endp\n\npublic ___SIN__\n___SIN__ proc\nret\n___SIN__ endp\n\npublic ___COS__\n___COS__ proc\nret\n___COS__ endp\n\nifdef WATCOM\npublic __CHP\n__CHP proc\nret\n__CHP endp\nendif\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOSSUPC": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  dossupc.c - some support routines for floating point work        */\n/*  for MSDOS                                                        */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSSRENAM": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  dssrenam - fix dfdss dumps from another site to have names that  */\n/*  are within this site's allowable high level qualifiers           */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd40000\u00a8;\n\n#define MLEN 44 /* length of MVS dataset name */\n\nint main(int argc, char **argv)\n{\n    unsigned char lll\u00dd4\u00a8;\n    FILE *fp;\n    FILE *fq;\n    char *from;\n    char *to;\n    int diff;\n    int reclen;\n    int flen;\n    int numrecs = 0;\n\n    if (argc != 4)\n    {\n        printf(\"usage: dssrenam <in file> <out file> <substitution>\\n\");\n        printf(\"e.g. dssrenam dd:in dd:out SED./SCOTT.SED.\\n\");\n        printf(\"or dssrenam dd:in dd:out /SCOTT.\\n\");\n        printf(\"or dssrenam dd:in dd:out SCOTT./\\n\");\n        printf(\"input and output file should be in ftprdw (ie VB) format\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n\n    fq = fopen(*(argv + 2), \"wb\");\n    if (fq == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + 2));\n        return (EXIT_FAILURE);\n    }\n\n    from = *(argv + 3);\n\n    to = strchr(from, '/');\n\n    if (to == NULL)\n    {\n        printf(\"missing / in 3rd parameter\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    *to = '\\0';\n    to++;\n\n    diff = strlen(to) - strlen(from);\n\n    flen = strlen(from);\n    while (fread(lll, sizeof lll, 1, fp) == 1)\n    {\n        numrecs++;\n        reclen = lll\u00dd0\u00a8 << 8 | lll\u00dd1\u00a8;\n        if (reclen >= 4) reclen -= 4;\n        if (fread(buf, reclen, 1, fp) != 1) break;\n\n        /* if we have a reasonable sized buffer, see if we need to\n           do some manipulations */\n        if (reclen >= MLEN)\n        {\n            /* if a type 40 record */\n            if (buf\u00dd10\u00a8 == 0x40)\n            {\n                int i;\n                int dlen;\n\n                i = 16;\n\n                /* add MLEN because the catalog name will be that */\n                while ((i + MLEN + flen) < reclen)\n                {\n                    dlen = buf\u00ddi\u00a8;\n                    /* if the dsn prefix matches */\n                    if ((dlen >= flen)\n                        && (memcmp(&buf\u00ddi+MLEN+1\u00a8, from, flen) == 0)\n                       )\n                    {\n                        if (diff != 0)\n                        {\n                            memmove(&buf\u00ddi+MLEN+1+strlen(to)\u00a8,\n                                    &buf\u00ddi+MLEN+1+strlen(from)\u00a8,\n                                    reclen-i-MLEN-1);\n                            reclen += diff;\n                            *(short *)&buf\u00dd6\u00a8 = reclen;\n                            dlen += diff;\n                            buf\u00ddi\u00a8 = dlen;\n                        }\n                        memcpy(&buf\u00ddi+MLEN+1\u00a8, to, strlen(to));\n                    }\n\n                    i += (dlen + MLEN + 1);\n                }\n            }\n\n            /* if a type 20 record */\n            if (buf\u00dd10\u00a8 == 0x20)\n            {\n                /* and the dsn prefix matches */\n                if (memcmp(&buf\u00dd75\u00a8, from, strlen(from)) == 0)\n                {\n                    /* if to is bigger, then shift to right */\n                    if (diff >= 0)\n                    {\n                        memmove(&buf\u00dd75 + diff\u00a8, &buf\u00dd75\u00a8, MLEN - diff);\n                    }\n                    /* otherwise, shift to left - diff is negative */\n                    else\n                    {\n                        memmove(&buf\u00dd75\u00a8, &buf\u00dd75 - diff\u00a8, MLEN + diff);\n                        memset(&buf\u00dd75 + MLEN + diff\u00a8, ' ', -diff);\n                    }\n                    memcpy(&buf\u00dd75\u00a8, to, strlen(to));\n                    buf\u00dd16\u00a8 += diff;\n                }\n            }\n\n            /* if a type 10 record */\n            if (buf\u00dd10\u00a8 == 0x10)\n            {\n                int extadj; /* adjustment for number of extents */\n\n                /* and the dsn prefix matches */\n                if (memcmp(&buf\u00dd44\u00a8, from, strlen(from)) == 0)\n                {\n                    /* if to is bigger, then shift to right */\n                    if (diff >= 0)\n                    {\n                        memmove(&buf\u00dd44 + diff\u00a8, &buf\u00dd44\u00a8, MLEN - diff);\n                    }\n                    /* otherwise, shift to left - diff is negative */\n                    else\n                    {\n                        memmove(&buf\u00dd44\u00a8, &buf\u00dd44 - diff\u00a8, MLEN + diff);\n                        memset(&buf\u00dd44 + MLEN + diff\u00a8, ' ', -diff);\n                    }\n                    memcpy(&buf\u00dd44\u00a8, to, strlen(to));\n                }\n                /* now we need to get to the dataset in the VVR */\n                /* this technique will only work for DSSDUMP */\n                extadj = (buf\u00dd42\u00a8 - 1) * 10;\n                if ((reclen > (205 + extadj))\n                    && (memcmp(&buf\u00dd205+extadj\u00a8, from, flen) == 0))\n                {\n                    if (diff != 0)\n                    {\n                        memmove(&buf\u00dd205+extadj+strlen(to)\u00a8,\n                                &buf\u00dd205+extadj+strlen(from)\u00a8,\n                                reclen-205-extadj-strlen(from));\n                        reclen += diff;\n                        *(short *)&buf\u00dd6\u00a8 = reclen;\n                        *(short *)&buf\u00dd194+extadj\u00a8 += diff;\n                        buf\u00dd204+extadj\u00a8 += diff;\n\n                        /* change the subrecord length in dummy VVR */\n                        *(short *)&buf\u00dd196+extadj\u00a8 += diff;\n                    }\n                    memcpy(&buf\u00dd205+extadj\u00a8, to, strlen(to));\n                }\n            }\n\n        }\n        if (diff != 0)\n        {\n            lll\u00dd0\u00a8 = (reclen + 4) >> 8;\n            lll\u00dd1\u00a8 = (reclen + 4) & 0xff;\n        }\n        fwrite(lll, sizeof lll, 1, fq);\n        fwrite(buf, reclen, 1, fq);\n    }\n    printf(\"%d records processed\\n\", numrecs);\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "ERRNO": {"ttr": 1032, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  errno.c - implementation of stuff in errno.h                     */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stddef.h\"\n\nint __errno = 0;\n\n__PDPCLIB_API__ int *__get_errno()\n    { return(&__errno); }\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXTZIP": {"ttr": 1034, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  extzip.c - extract an encoded zip from a printout                */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nstatic char buf\u00dd800\u00a8;\n\nint main(void)\n{\n    int write = 0;\n\n    while (fgets(buf, sizeof buf, stdin) != NULL)\n    {\n        /* allow a formfeed to be represented as any\n           one or two control characters */\n        if (iscntrl((unsigned char)buf\u00dd0\u00a8))\n        {\n            memmove(buf, buf + 1, strlen(buf));\n            if (iscntrl((unsigned char)buf\u00dd0\u00a8))\n            {\n                memmove(buf, buf + 1, strlen(buf));\n            }\n            if (memcmp(buf, \"504B\", 4) == 0)\n            {\n                write = 1;\n            }\n\n        }\n        else if (buf\u00dd0\u00a8 == '\\f')\n        {\n            write = 0;\n        }\n        if (write)\n        {\n            fputs(buf, stdout);\n        }\n    }\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FOLKS": {"ttr": 1036, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  folks - read a VB (MVS) format file in binary mode, and process  */\n/*  its contents. Note that the C standard allows binary files to    */\n/*  be NUL-padded. This program allows for that.                     */\n/*                                                                   */\n/*  The intention of this program is to provide example PDPCLIB      */\n/*  behaviour that should occur regardless of RECFM=F/V/U when       */\n/*  opened in binary mode.                                           */\n/*                                                                   */\n/*********************************************************************/\n\n\n/* Here is an example of transferring a VB file with\n   \"Hello there\"\n   \"Folks\"\n   in it to the PC, preserving the RDW (Record Descriptor Word)\n*/\n\n/*\nbinary\n EZA1701I >>>TYPE i\n 200 Type is Image (Binary)\n EZA1460I Command:\nlocsite rdw\n EZA1460I Command:\nput folks\n EZA1701I >>>SITE VARrecfm Lrecl=256 Recfm=VB BLKSIZE=27998\n 500 Syntax error, Command not recognized.\n>>> PC ignores SITE command.  Use sendsite to suppress <<<\n EZA1701I >>>STOR folks\n 150 Ready to receive \"/C/folks\". Mode STREAM Type BINARY.\n 226 Transfer finished successfully. Closing data connection.\n EZA1617I 24 bytes transferred in 0.076 seconds. Transfer rate 0.32 Kbytes/sec.\n EZA1460I Command:\nquit\n*/\n\n\n/* Here is a hexdump of the transferred file on arrival at the PC */\n\n/*\n000000  000F0000 C8859393 9640A388 85998500  .........@......\n000010  090000C6 969392A2                    ........\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    unsigned char lenb\u00dd4\u00a8;\n    int len;\n    int c;\n    int x;\n\n    if (argc <= 1)\n    {\n        printf(\"usage: folks <fnm>\\n\");\n        return (EXIT_FAILURE);\n    }\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"failed to open %s\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n    while (fread(lenb, sizeof lenb, 1, fp) == 1)\n    {\n        len = lenb\u00dd0\u00a8 << 8 | lenb\u00dd1\u00a8;\n        printf(\"len is %d\\n\", len);\n        if (lenb\u00dd2\u00a8 != 0 || lenb\u00dd3\u00a8 != 0)\n        {\n            printf(\"file is corrupt - reserved\\n\");\n            return (EXIT_FAILURE);\n        }\n        if (len == 0) /* allow for NUL-padding */\n        {\n            break;\n        }\n        if (len < 4)\n        {\n            printf(\"file is corrupt - length\\n\");\n            return (EXIT_FAILURE);\n        }\n        c = fgetc(fp);\n        printf(\"first data byte is %x\\n\", c);\n        for (x = 5; x < len; x++)\n        {\n            fgetc(fp);\n        }\n    }\n    return (EXIT_SUCCESS);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FPFUNCSB": {"ttr": 1039, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsb.c - some support routines for floating point work       */\n/*  for Borland C++ for OS/2                                         */\n/*                                                                   */\n/*********************************************************************/\n\n#ifdef __OS2__\nint __turboFloat;\n\nlong _ftol(double x)\n{\n    (void)x;\n    return (0);\n}\n#endif\n\n#ifdef __MSDOS__\n\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\nunsigned long CTYP __divide(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        g++;\n    }\n    return ((unsigned long)g);\n}\n\nunsigned long CTYP __modulo(unsigned long x, unsigned long y)\n{\n    unsigned int a;\n    unsigned int b;\n    unsigned int c;\n    unsigned int d;\n    unsigned int e;\n    unsigned int f;\n    unsigned int g = 0;\n    unsigned int h;\n\n    b = (unsigned int)(y & 0xffffU);\n    a = (unsigned int)(y >> 16);\n    c = -b;\n    d = a;\n    if (b > 0)\n    {\n        d++;\n    }\n    f = 1;\n    while (f != 0)\n    {\n        e = (unsigned int)(x >> 16);\n        h = (unsigned int)(x & 0xffffU);\n        f = e / d;\n        g += f;\n        e = e % d;\n        x = ((unsigned long)e << 16) + (unsigned long)c * f + h;\n    }\n    if (x >= y)\n    {\n        x -= y;\n    }\n    return (x);\n}\n\n#ifdef __WATCOMC__\nvoid _cstart(void)\n{\n    return;\n}\n\nint _argc, _8087;\n\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSC": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsc.c - some support routines for floating point work       */\n/*  for IBM CSET compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused;\n\n_exeentry(void)\n{\n    __main();\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSG": {"ttr": 1285, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsg.c - some support routines for floating point work       */\n/*  for GNU C compiler for OS/2                                      */\n/*                                                                   */\n/*********************************************************************/\n\n__main(void)\n{\n    return;\n}\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FPFUNCSW": {"ttr": 1287, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  fpfuncsw.c - some support routines for floating point work       */\n/*  for Watcom C compiler for OS/2                                   */\n/*                                                                   */\n/*********************************************************************/\n\nint _fltused_ = 0;\nint __real87 = 0;\nint _argc;\n\n__init_387_emulator(void)\n{\n    return;\n}\n\n__8087(void)\n{\n    return;\n}\n\n__STOSD(void)\n{\n    return;\n}\n\n__CHP(void)\n{\n    return;\n}\n\nvoid __main(void);\n\n_cstart_(void)\n{\n    __main();\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HEXDUMP": {"ttr": 1289, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*\n**  HEXDUMP.C - Dump a file.\n**\n**  Usage: hexdump file_name \u00ddstart\u00a8 \u00ddlength\u00a8\n**\n**  e.g. hexdump temp.txt\n**\n**  \"start\" is zero-based.\n**\n**  The output format is similar to that used on a VAX machine, except\n**  that the ordering isn't screwed up to make up for the screwed\n**  little-endian cpu.\n**\n**  This program was written by Paul Edwards\n**  It was modified by:\n**  Bob Stout\n**  Andrew Clarke\n**\n**  This program is released to the public domain\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nstatic void dodump(FILE * fp, long start, long count);\nstatic void skipb(FILE * fp, long start);\n\nmain(int argc, char **argv)\n{\n    FILE *fp;\n    long start, count;\n\n    if (argc < 2)\n    {\n        puts(\"Usage: HEXDUMP file_name \u00ddstart\u00a8 \u00ddlength\u00a8\");\n        return (EXIT_FAILURE);\n    }\n    if (argc > 2)\n    {\n        start = strtol(*(argv + 2), NULL, 0);\n    }\n    else\n    {\n        start = 0L;\n    }\n    if (argc > 3)\n    {\n        count = strtol(*(argv + 3), NULL, 0);\n    }\n    else\n    {\n        count = -1L;\n    }\n    fp = fopen(*(argv + 1), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"unable to open file %s for input\\n\", *(argv + 1));\n        return (EXIT_FAILURE);\n    }\n    skipb(fp, start);\n    dodump(fp, start, count);\n    return (EXIT_SUCCESS);\n}\n\nstatic void dodump(FILE * fp, long start, long count)\n{\n    int c, pos1, pos2;\n    long x = 0L;\n    char prtln\u00dd100\u00a8;\n\n    while (((c = fgetc(fp)) != EOF) && (x != count))\n    {\n        if (x % 16 == 0)\n        {\n            memset(prtln, ' ', sizeof prtln);\n            sprintf(prtln, \"%0.6lX   \", start + x);\n            pos1 = 8;\n            pos2 = 45;\n        }\n        sprintf(prtln + pos1, \"%0.2X\", c);\n        if (isprint(c))\n        {\n            sprintf(prtln + pos2, \"%c\", c);\n        }\n        else\n        {\n            sprintf(prtln + pos2, \".\");\n        }\n        pos1 += 2;\n        *(prtln + pos1) = ' ';\n        pos2++;\n        if (x % 4 == 3)\n        {\n            *(prtln + pos1++) = ' ';\n        }\n        if (x % 16 == 15)\n        {\n            printf(\"%s\\n\", prtln);\n        }\n        x++;\n    }\n    if (x % 16 != 0)\n    {\n        printf(\"%s\\n\", prtln);\n    }\n    return;\n}\n\nstatic void skipb(FILE * fp, long start)\n{\n    long x = 0;\n\n    while (x < start)\n    {\n        fgetc(fp);\n        x++;\n    }\n    return;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "LINSTART": {"ttr": 1292, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Startup code for Linux */\n/* written by Paul Edwards */\n/* released to the public domain */\n\n#include \"errno.h\"\n#include \"stddef.h\"\n\n\nextern int __start(int argc, char **argv);\nextern int __exit(int rc);\n\n\n/* We can get away with a minimal startup code, plus make it\n   a C program. There is no return address. Instead, on the\n   stack is a count, followed by all the parameters as pointers */\n\nint _start(char *p)\n{\n    int rc;\n\n    rc = __start(*(int *)(&p - 1), &p);\n    __exit(rc);\n    return (rc);\n}\n\nstatic char membuf\u00dd31000000\u00a8;\n\nvoid *__allocmem(size_t size)\n{\n    return (membuf);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINSUPA": {"ttr": 7428, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "# linsupa.asm - support code for C programs for Linux\n#\n# This program written by Paul Edwards\n# Released to the public domain\n\n.globl __setj\n__setj:\npush %ebp\nmov %esp, %ebp\n\nmovl 8(%ebp), %eax\npush %ebp\nmov %esp, %ebx\npush %ebx # esp\n\nmovl %ecx, 4(%eax)\nmovl %edx, 8(%eax)\nmovl %edi, 12(%eax)\nmovl %esi, 16(%eax)\n\npop %ebx\nmovl %ebx, 20(%eax) # esp\nmovl 0(%ebp), %ebx\nmovl %ebx, 24(%eax) # ebp\n\nmovl 4(%ebp), %ebx # return address\nmovl %ebx, 28(%eax) # return address\n\npop %ebx\nmovl %ebx, 0(%eax)\nmov $0, %eax\n\npop %ebp\nret\n\n\n\n.globl __longj\n__longj:\npush %ebp\nmov %esp, %ebp\n\nmovl 8(%ebp), %eax\nmovl 20(%eax), %ebp\nmov %ebp, %esp\n\npop %ebx # position of old ebx\npop %ebx # position of old ebp\npop %ebx # position of old return address\n\nmov 28(%eax), %ebx # return address\npush %ebx\n\nmov 24(%eax), %ebx # ebp saved as normal\npush %ebx\nmov %esp, %ebp\n\nmovl 0(%eax), %ebx\nmovl 4(%eax), %ecx\nmovl 8(%eax), %edx\nmovl 12(%eax), %edi\nmovl 16(%eax), %esi\n\nmovl 32(%eax), %eax\n\npop %ebp\n\nret\n\n\n.globl __write\n__write:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 4 = write\nmovl $4, %eax\n# handle\nmovl 8(%ebp), %ebx\n# data pointer\nmovl 12(%ebp), %ecx\n# length\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n.globl __read\n__read:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 3 = read\nmovl $3, %eax\n# handle\nmovl 8(%ebp), %ebx\n# data pointer\nmovl 12(%ebp), %ecx\n# length\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __open\n__open:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 5 = open\nmovl $5, %eax\n# filename\nmovl 8(%ebp), %ebx\n# flag\nmovl 12(%ebp), %ecx\n# mode\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __seek\n__seek:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\npush %edx\n\n# function code 19 = lseek\nmovl $19, %eax\n# handle\nmovl 8(%ebp), %ebx\n# offset\nmovl 12(%ebp), %ecx\n# whence\nmovl 16(%ebp), %edx\nint $0x80\npop %edx\npop %ecx\npop %ebx\npop %ebp\nret\n\n\n\n.globl __rename\n__rename:\npush %ebp\nmov %esp, %ebp\npush %ebx\npush %ecx\n\n# function code 38 = rename\nmovl $38, %eax\n# old file\nmovl 8(%ebp), %ebx\n# new file\nmovl 12(%ebp), %ecx\nint $0x80\npop %ecx\npop %ebx\npop %ebp\n\n\n.globl __remove\n__remove:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 10 = unlink\nmovl $10, %eax\n# filename\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n\n\n.globl __close\n__close:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 6 = close\nmovl $6, %eax\n# handle\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n\n\n.globl __exita\n__exita:\n# exit/terminate\nmovl $1, %eax\nint $0x80\nret\n\n\n.globl __time\n__time:\npush %ebp\nmov %esp, %ebp\npush %ebx\n# function code 13 = retrieve current time\nmovl $13, %eax\n# pointer to time_t\nmovl 8(%ebp), %ebx\nint $0x80\npop %ebx\npop %ebp\nret\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOCALE": {"ttr": 1294, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  locale.c - implementation of stuff in locale.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"locale.h\"\n#include \"limits.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\nstatic struct lconv thislocale = {\n    \".\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    \"\",\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX,\n    CHAR_MAX\n};\n\n__PDPCLIB_API__ char *setlocale(int category, const char *locale)\n{\n    (void)category;\n    if (locale == NULL)\n    {\n        return (\"C\");\n    }\n    else if ((strcmp(locale, \"C\") == 0)\n             || (strcmp(locale, \"\") == 0))\n    {\n        return (\"C\");\n    }\n    else\n    {\n        return (NULL);\n    }\n}\n\n__PDPCLIB_API__ struct lconv *localeconv(void)\n{\n    return (&thislocale);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MATH": {"ttr": 1296, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*  9-April-2006 D.Wade                                              */\n/*      Moved definitions for HUGE_VAL to math.h                   */\n/*      Inserted argument rang checks in :-                          */\n/*       acos                                                        */\n/*                                                                   */\n/*                                                                   */\n/*                                                                   */\n/*  2-April-2006 D.Wade added code for the :-                        */\n/*                                                                   */\n/*      acos(double x);                                              */\n/*      asin(double x);                                              */\n/*      atan(double x);                                              */\n/*      cos(double x);                                               */\n/*      sin(double x);                                               */\n/*      tan(double x);                                               */\n/*      cosh(double x);                                              */\n/*      sinh(double x);                                              */\n/*      tanh(double x);                                              */\n/*      exp(double x);                                               */\n/*      frexp(double value, int *exp);                               */\n/*      ldexp(double x, int exp);                                    */\n/*      log(double x);                                               */\n/*      log10(double x);                                             */\n/*      modf(double value, double *iptr);                            */\n/*      pow(double x, double y);                                     */\n/*      sqrt(double x);                                              */\n/*                                                                   */\n/* Note:-                                                            */\n/*  In order to avoide Copyright these functions are generally       */\n/*  implemented using Taylor Series. As a result they are a little   */\n/*  slower that the equivalents in many maths packages.              */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  math.c - implementation of stuff in math.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"math.h\"\n#include \"float.h\"\n#include \"errno.h\"\n#include \"stddef.h\"\n\n/*\n\n  Some constants to make life easier elsewhere\n  (These should I guess be in math.h)\n\n*/\nstatic const double pi   = 3.1415926535897932384626433832795;\nstatic const double ln10 = 2.3025850929940456840179914546844;\nstatic const double ln2 = 0.69314718055994530941723212145818 ;\n\n\n__PDPCLIB_API__ double ceil(double x)\n{\n    int y;\n\n    y = (int)x;\n    if ((double)y < x)\n    {\n        y++;\n    }\n    return ((double)y);\n}\n\n#ifdef fabs\n#undef fabs\n#endif\n__PDPCLIB_API__ double fabs(double x)\n{\n    if (x < 0.0)\n    {\n        x = -x;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ double floor(double x)\n{\n    int y;\n\n    if (x < 0.0)\n    {\n        y = (int)x;\n        if ((double)y != x)\n        {\n            y--;\n        }\n    }\n    else\n    {\n        y = (int)x;\n    }\n    return ((double)y);\n}\n\n__PDPCLIB_API__ double fmod(double x, double y)\n{\n    int imod;\n    if(y == 0.0) return (0.0);\n    imod = x / y;\n    return ((double)x-((double)imod*y));\n}\n\n#ifdef acos\n#undef acos\n#endif\n/*\n\n  For cos just use (sin(x)**2 + cos(x)**2)=1\n  Note:- asin(x) decides which taylor series\n  to use to ensure quickest convergence.\n\n*/\n__PDPCLIB_API__ double acos(double x)\n{\n\n/*\n*/\n\n    if ( fabs(x) > 1.0 ) /* is argument out of range */\n    {\n        errno=EDOM;\n        return (HUGE_VAL);\n    }\n    if ( x < 0.0 ) return ( pi - acos(-x) ) ;\n\n    return ( asin ( sqrt(1.0 - x*x) ) );\n\n}\n\n#ifdef asin\n#undef asin\n#endif\n/*\n\n   This routines Calculate arcsin(x) & arccos(x).\n\n   Note if \"x\" is close to \"1\" the series converges slowly.\n   To avoid this we use (sin(x)**2 + cos(x)**2)=1\n   and fact cos(x)=sin(x+pi/2)\n\n*/\n\n__PDPCLIB_API__ double asin (double y)\n{\n    int i;\n    double term,answer,work,x,powx,coef;\n\n    x = y;\n\n/*\n  if arg is -ve then we want \"-asin(-x)\"\n*/\n\n    if (x <0.0 ) return ( -asin(-x) );\n\n/*\n    If arg is > 1.0 we can't calculate\n    (note also < -1.0 but previous statement removes this case)\n*/\n    if ( x > 1.0 )\n    {\n        errno=EDOM;\n        return(HUGE_VAL);\n    }\n\n/*\n now check for large(ish) x > 0.6\n*/\n\n    if( x > 0.75 )\n    {\n        x = ( sqrt(1.0 - (x*x) ) );\n        return((pi/2.0)-asin(x));\n    }\n\n/*\n     arcsin(x) = x + 1/2 (x\u00ac3/3) + (1/2)(3/4)(x\u00ac5/5) +\n        (1/2)(3/4)(5/6)(x\u00ac7/7) + ...\n*/\n    i=1;\n    answer=x;\n    term = 1;\n    coef = 1;\n    powx = x;\n\n    while (1)\n    {\n        work = i;\n        coef = (coef * work)/(work+1);\n        powx = powx * x * x;\n        term =  coef * powx / (work + 2.0);\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i+=2;\n    }\n\n    return(answer);\n}\n\n\n#ifdef atan\n#undef atan\n#endif\n/*\n\n     Because atan(x) is valid for large values of \"x\" &\n     the taylor series converges more slowly for large \"X\"\n     we use the following\n\n     1. Reduce to the first octant by using :-\n\n        atan(-x)=-atan(x),\n        atan(1/x)=PI/2-atan(x)\n\n     2. Reduce further so that |x| less than tan(PI/12)\n\n        atan(x)=pi/6+atan((X*sqrt(3)-1)/(x+sqrt(3)))\n\n     3. Then use the taylor series\n\n        atan(x) = x - x**3 + x**5 - x**7\n                      ----   ----   ----\n                        3      5      7\n\n*/\n\n__PDPCLIB_API__ double atan (double x)\n{\n    int i;\n    double term,answer,work,powx;\n\n/*\n  if arg is -ve then we want \"-atan(-x)\"\n*/\n\n    if ( x<0.0 ) return ( -atan(-x) );\n\n/*\n If arg is large we can't calculate\n use atan(1/x)=PI/2-atan(x)\n*/\n\n    if ( x > 1.0 ) return ((pi/2) - atan(1.0/x));\n\n/*\n now check for large(ish) x > tan(15) (0.26794919243112)\n if so use atan(x)=pi/6+atan((X*SQRT3-1)/(X+SQRT3))\n*/\n\n    if( x > (2.0 - sqrt(3.0)))\n    return( (pi/6.0) + atan( ( x * sqrt(3.0)-1.0 ) / (x + sqrt(3.0) ) ) );\n\n/*\n*       atan(x) = x - x**3 + x**5 - x**7\n*                     ----   ----   ----\n*                       3      5      7\n*/\n\n    i=1;\n    answer=x;\n    term = x;\n    powx = x;\n\n    while (1)\n    {\n        work = i;\n        powx = 0.0 - powx * x * x;\n        term = powx / (work + 2.0);\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i+=2;\n    }\n\n    return(answer);\n\n}\n\n\n/* atan2 was taken from libnix and modified slightly */\n\n__PDPCLIB_API__ double atan2(double y,double x)\n{\n    return (x >= y) ?\n               (x >= -y ? atan(y/x) : -pi/2 - atan(x/y))\n              :\n               (x >= -y ? pi/2 - atan(x/y)\n                        : (y >= 0) ? pi + atan(y/x)\n                                   : -pi + atan(y/x));\n}\n\n\n#ifdef cos\n#undef cos\n#endif\n__PDPCLIB_API__ double cos(double x)\n{\n/*\n\n   Calculate COS using Taylor series.\n\n   sin(x) = 1 - x**2  +  x**4  - x**6 + x**8\n                ====     ====    ====   ====    .........\n                  2!       4!      6!     8!\n\n   Note whilst this is accurate it can be slow for large\n   values of \"X\" so we scale\n\n*/\n\n    int i;\n    double term,answer,work,x1;\n\n/*\n    Scale arguments to be in range 1 => pi\n*/\n\n    i = x/(2*pi);\n    x1 =  x - (i * (2.0 * pi));\n\n    i=1;\n    term=answer=1;\n\n\n    while (1)\n    {\n        work = i;\n        term = -(term * x1 * x1)/(work * (work + 1.0));\n        if ( answer == (answer + term) )break;\n        answer = answer + term;\n        i += 2;\n    }\n\n    return(answer);\n\n}\n\n#ifdef sin\n#undef sin\n#endif\n__PDPCLIB_API__ double sin(double x)\n{\n/*\n\n   Calculate SIN using Taylor series.\n\n   sin(x) = x - x**3  +  x**5  - x**7 + x**9\n                ====     ====    ====   ====\n                  3!       5!      7!     9!\n\n   Note whilst this is accurate it can be slow for large values\n   of \"X\" so we scale\n\n*/\n\n    int i;\n    double term,answer,work,x1;\n\n/*\n  scale so series converges pretty quickly\n*/\n    i = x/(2.0*pi);\n    x1 =  x - (i * (2.0 * pi));\n\n/*\n set up initial term\n*/\n    i=1;\n    term=answer=x1;\n/*\n loop until no more changes\n*/\n    while (1)\n    {\n        work = i+1;\n        term = -(term * x1 * x1)/(work * (work + 1.0));\n        if ( answer == (answer + term) )break;\n        answer = answer + term;\n        i = i+2;\n    }\n\n    return(answer);\n}\n\n#ifdef tan\n#undef tan\n#endif\n__PDPCLIB_API__ double tan (double x)\n{\n/*\n\n  use tan = sin(x)/cos(x)\n  if cos(x) is 0 then return HUGE_VAL else return sin/cos\n\n  *** need to set ERROR for overflow ***\n\n*/\n    double temp;\n\n    temp=cos(x);\n    if (temp == 0.0 )\n    {\n        /* errno=EDOM; don't seem to return an error here */\n        return (HUGE_VAL); /* need to set error here */\n    }\n    return ( sin(x)/cos(x) );\n}\n\n/*\n\n  Hyperbolic functions\n\n  SINH(X) = (E**X-E**(-1))/2\n  COSH(X) = (E**X+E**(-1))/2\n\n*/\n__PDPCLIB_API__ double cosh(double x)\n{\n    double dexpx;\n\n    dexpx = exp(x);\n\n    return( 0.5 * (dexpx + (1.0/dexpx) ) );\n\n}\n\n__PDPCLIB_API__ double sinh(double x)\n{\n    double dexpx;\n\n    dexpx = exp(x);\n\n    return( 0.5 * (dexpx - (1.0/dexpx) ) );\n}\n\n/*\n    tanh returns the hyperbolic area tangent of floating point argument x.\n*/\n\n__PDPCLIB_API__ double tanh(double x)\n{\n    double dexp2;\n\n    dexp2 = exp( -2.0 * x);\n    return ( (1.0  - dexp2) /  (1.0 + dexp2) );\n}\n\n/*\n\nexp(x) = 1 + x + x2/2 + x3/6 + x4/24 + x5/120 + ... + xn/n! + ...\n\n*/\n__PDPCLIB_API__ double exp (double x)\n{\n    int i;\n    double term,answer,work;\n\n    i=2;\n    term=x;\n    answer=x;\n\n    while (1)\n    {\n        work = i;\n        term =  (term * x)/work;\n        if ( answer == (answer + term) )break;\n        answer = answer + (term);\n        i++;\n    }\n\n    answer=answer+1.0;\n    return(answer);\n}\n\n/*\n\n   Calculate LOG using Taylor series.\n\n   log(1+ x) = x - x**2  +  x**3  - x**4 + x**5\n                   ====     ====    ====   ====    .........\n                    2         3       4     8\n\n   Note this only works for small x so we scale....\n\n*/\n__PDPCLIB_API__ double log (double x)\n{\n    int i,scale;\n    double term,answer,work,xs;\n\n    if (x <= 0 )\n    {\n        /* need to set signal */\n        errno=EDOM;\n        return (HUGE_VAL);\n    }\n    if( x == 1.0)return(0.0);\n\n/*\n  Scale arguments to be in range 1 < x <= 10\n*/\n\n/*\n    scale = 0;\n    xs = x;\n    while ( xs > 10.0 ) { scale ++; xs=xs/10.0;}\n    while ( xs < 1.0 ) { scale --; xs=xs*10.0;}\n*/\n    xs = frexp(x,&scale);\n    xs = (1.0 * xs) - 1.0;\n    scale = scale - 0;\n\n    i=2;\n    term=answer=xs;\n\n    while (1)\n    {\n        work = i;\n        term = - (term * xs);\n        if ( answer == (answer + (term/work)) )break;\n        answer = answer + (term/work);\n        i++;\n    }\n\n    answer = answer + (double)scale * ln2;\n    return(answer);\n}\n\n\n__PDPCLIB_API__ double log10(double x)\n{\n    return ( log(x) / ln10 );\n}\n\n\n/*\n\n   This code uses log and exp to calculate x to the power y.\n   If\n\n*/\n\n__PDPCLIB_API__ double pow(double x,double y)\n{\n    int j,neg;\n    double yy,xx;\n    neg=0;\n    j=y;\n    yy=j;\n    if( yy == y) {\n        xx = x;\n        if ( y < 0 ){neg = 1; j = -j;}\n        if ( y == 0) return (1.0);\n        --j;\n        while(j>0){ xx=xx * x; j--;}\n        if(neg)xx=1.0/xx;\n        return (xx);\n    }\n    if (x < 0.0)\n    {\n         errno=EDOM;\n         return(0.0);\n    }\n    if (y == 0.0) return (1.0);\n\n    return (exp(y*log(x)));\n}\n\n#ifdef sqrt\n#undef sqrt\n#endif\n/*\n\n   pretty tivial code here.\n\n     1) Scale x such that 1 <= x <= 4.0\n\n     2) Use newton Raphson to calculate root.\n\n     4) multiply back up.\n\n   Because we only scale by \"4\" this is pretty slow....\n\n*/\n\n__PDPCLIB_API__ double sqrt(double x)\n{\n    double xs,yn,ynn;\n    double pow1;\n    int i;\n\n    if (x < 0.0)\n    {\n        errno=EDOM;\n        return(0.0);\n    }\n    if (x == 0.0) return (0.0);\n\n/*\n\n  Scale argument 1 <= x <= 4\n\n*/\n\n    xs=x;\n    pow1=1;\n\n    while(xs<1.0){xs=xs*4.0;pow1=pow1/2.0;}\n    while(xs>=4.0){xs=xs/4.0;pow1=pow1*2.0;}\n\n/*\n  calculate using Newton raphson\n  use x0 = x/2.0\n*/\n\n    i=0;\n    yn = xs/2.0;\n    ynn = 0;\n    while(1)\n    {\n        ynn = (yn + xs/yn)*0.5;\n        if ( fabs(ynn-yn) <= 10.0 * DBL_MIN ) break; else yn=ynn;\n        if ( i > 10  ) break; else i++ ;\n    }\n    return (ynn*pow1);\n}\n\n\n__PDPCLIB_API__ double frexp(double x, int *exp)\n{\n/*\n  split float into fraction and mantissa\n  note this is not so easy for IBM as it uses HEX float\n*/\n    union dblhex\n    {\n        double d;\n        unsigned short s\u00dd4\u00a8;\n    };\n    union dblhex split;\n\n    if ( x == 0.0)\n    {\n        exp=0;\n        return (0.0);\n    }\n\n    split.d = x;\n    *exp = (((split.s\u00dd0\u00a8 >> 8) & 0x007f)-64) * 4;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 & 0x80ff;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 | 0x4000;\n    /* following code adjust for fact IBM has hex float */\n    while ( (fabs(split.d) < 0.5) && (split.d != 0) )\n    {\n        split.d = split.d * 2;\n        *exp =( *exp ) - 1;\n    }\n    /*    */\n    return(split.d);\n}\n\n__PDPCLIB_API__ double ldexp(double x, int exp)\n{\n/*\n  note this is not so easy for IBM as it uses HEX float\n*/\n    int bin_exp,hex_exp,adj_exp;\n    union dblhex\n    {\n        double d;\n        unsigned short s\u00dd4\u00a8;\n    };\n    union dblhex split;\n/*\n    note \"X\" mauy already have an exponent => extract it\n*/\n    split.d = frexp(x,&bin_exp);\n    bin_exp = bin_exp + exp;  /* add in from caller */\n/* need to test for sensible value here */\n    hex_exp =  (bin_exp / 4); /* convert back to HEX */\n    adj_exp =  bin_exp - (hex_exp * 4);\n    if (adj_exp < 0){ hex_exp=hex_exp -1; adj_exp = 4 + adj_exp;}\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 & 0x80ff;\n    split.s\u00dd0\u00a8 = split.s\u00dd0\u00a8 | (((hex_exp+64)  << 8) & 0x7f00);\n    /* following code adjust for fact IBM has hex float */\n    /* well it will I have done */\n    while ( adj_exp > 0 )\n    {\n        split.d = split.d * 2;\n        --adj_exp;\n    }\n    /**/\n    return(split.d);\n}\n\n__PDPCLIB_API__ double modf(double value, double *iptr)\n{\n    int neg = 0;\n    long i;\n\n    if (value < 0)\n    {\n        neg = 1;\n        value = -value;\n    }\n    i = (long)value;\n    value -= i;\n    if (neg)\n    {\n        value = -value;\n        i = -i;\n    }\n    *iptr = i;\n    return (value);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMTEST": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  memtest.c - Test of ATL memory                                   */\n/*                                                                   */\n/*  This program does a quick test of 2 large blocks of memory,      */\n/*  one of 20 MB and one of 9 MB, and displays the address and       */\n/*  checksum of the blocks. The checksum should be exactly as        */\n/*  shown below (on an EBCDIC machine) but the addresses will vary   */\n/*  depending on the operating system.                               */\n/*                                                                   */\n/*  addr 4118360 approx 65 MB location                               */\n/*  checksum is -54967290                                            */\n/*  addr 542B0B0 approx 84 MB location                               */\n/*  checksum is 1908000006                                           */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BSIZE 20000000\n#define BSIZE2 9000000\n\nint main(int argc, char **argv)\n{\n    char *p;\n    int x;\n    int i;\n\n    x = 0;\n    p = malloc(BSIZE);\n    if (p == NULL)\n    {\n        printf(\"out of memory\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"addr %p approx %d MB location\\n\",\n           p, ((int)p)/1024/1024);\n    memset(p, 'M', BSIZE);\n    memcpy(p, \"ABC\", 3);\n    memcpy(p + BSIZE - 3 - 1, \"XYZ\", 3);\n    for (i = 0; i < BSIZE; i++)\n    {\n        x += p\u00ddi\u00a8;\n    }\n    printf(\"checksum is %d\\n\", x);\n\n    x = 0;\n    p = malloc(BSIZE2);\n    if (p == NULL)\n    {\n        printf(\"out of memory\\n\");\n        return (EXIT_FAILURE);\n    }\n    printf(\"addr %p approx %d MB location\\n\",\n           p, ((int)p)/1024/1024);\n    memset(p, 'M', BSIZE2);\n    memcpy(p, \"ABC\", 3);\n    memcpy(p + BSIZE2 - 3 - 1, \"XYZ\", 3);\n    for (i = 0; i < BSIZE2; i++)\n    {\n        x += p\u00ddi\u00a8;\n    }\n    printf(\"checksum is %d\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MUSSTART": {"ttr": 7433, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  MUSSTART - startup routines for MUSIC/SP                          *\n*  It is currently coded to work with GCC. To activate the C/370     *\n*  version change the \"&COMP\" switch.                                *\n*                                                                    *\n**********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n*\n         ENTRY @@CRT0\n@@CRT0   EQU   *\n         AIF ('&COMP' NE 'C370').NOCEES\n         ENTRY CEESTART\nCEESTART EQU   *\n.NOCEES  ANOP\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1\n         GETMAIN RU,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING STACK,R13\n*\n         LA    R1,0(R1)          Clean up address (is this required?)\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n         ST    R2,ARGPTR\n*\n         USING PSA,R0\n         L     R2,PSATOLD\n         USING TCB,R2\n         L     R7,TCBRBP\n         USING RBBASIC,R7\n         LA    R8,0\n         ICM   R8,B'0111',RBCDE1\n         USING CDENTRY,R8\n         MVC   PGMNAME,CDNAME\n*\n         L     R2,TCBJSCB\n         USING IEZJSCB,R2\n         LH    R2,JSCBTJID\n         ST    R2,TYPE\n         L     R2,0(R1)\n         LA    R2,0(R2)\n         ST    R2,ARGPTR\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&SYS' NE 'S380').N380ST1\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         BSM   R4,R0\n         ST    R4,SAVER4\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n*\n         AIF   ('&SYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n         DS    0H\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&SYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n         AIF   ('&OS' EQ 'MUSIC').MUSIC1\n*         CVT   DSECT=YES\n.MUSIC1  ANOP\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MUSSUPA": {"ttr": 7681, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*\n*  This program written by Paul Edwards.\n*  Released to the public domain\n*\n*  Extensively modified by others\n*\n***********************************************************************\n*\n*  MUSSUPA - Support routines for PDPCLIB under MUSIC\n*\n*  It is currently coded for GCC, but C/370 functionality is\n*  still there, it's just not being tested after any change.\n*\n***********************************************************************\n*\n* Note that the VBS support may not be properly implemented.\n* Note that this code issues WTOs. It should be changed to just\n* set a return code an exit gracefully instead. I'm not talking\n* about that dummy WTO. But on the subject of that dummy WTO - it\n* should be made consistent with the rest of PDPCLIB which doesn't\n* use that to set the RMODE/AMODE. It should be consistent one way\n* or the other.\n*\n* Here are some of the errors reported:\n*\n*  OPEN input failed return code is: -37\n*  OPEN output failed return code is: -39\n*\n* FIND input member return codes are:\n* Original, before the return and reason codes had\n* negative translations added refer to copyrighted:\n* DFSMS Macro Instructions for Data Sets\n* RC = 0 Member was found.\n* RC = -1024 Member not found.\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.\n* RC = -1032 PDSE share not available.\n* RC = -1036 PDSE is OPENed output to a different member.\n* RC = -2048 Directory I/O error.\n* RC = -2052 Out of virtual storage.\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.\n* RC = -2060 PDSE I/O error flushing system buffers.\n* RC = -2064 Invalid FIND, no DCB address.\n*\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT NOGEN\n         REGS\n         MUSVC\nSUBPOOL  EQU   0\n*\n***********************************************************************\n*\n*  AOPEN - Open a dataset\n*\n*  Note that under MUSIC, RECFM=F is the only reliable thing. It is\n*  possible to use RECFM=V like this:\n*  /file myin tape osrecfm(v) lrecl(32756) vol(PCTOMF) old\n*  but it is being used outside the normal MVS interface. All this\n*  stuff really needs to be rewritten per normal MUSIC coding.\n*\n*\n*  Note - more documentation for this and other I/O functions can\n*  be found halfway through the stdio.c file in PDPCLIB.\n*\n***********************************************************************\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  EQU   *\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n         AIF   ('&SYS' EQ 'S390').BELOW\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n.CHKBLWE ANOP\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR C/370\n*         L     R6,0(R4)\n         LTR   R6,R6\n         BNZ   WRITING\n* READING\n         USING IHADCB,R2\n         MVC   ZDCBAREA(INDCBLN),INDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         LA    R4,ENDFILE\n         ST    R4,DCBEODAD\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   OPENMB,OPENMAC\n*\n         RDJFCB ((R2),INPUT)\n         LTR   R9,R9\n         BZ    NOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nNOMEM    DS    0H\n*         OPEN  ((R2),INPUT),MF=(E,OPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),INPUT),MF=(E,OPENMB),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n         B     DONEOPEN\nWRITING  DS    0H\n         USING ZDCBAREA,R2\n         MVC   ZDCBAREA(OUTDCBLN),OUTDCB\n         LA    R10,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R10,B'1000',=X'87'\n         ST    R10,JFCBPTR\n         LA    R10,JFCBPTR\n         ST    R10,DCBEXLST\n         MVC   DCBDDNAM,0(R3)\n         MVC   WOPENMB,WOPENMAC\n*\n         RDJFCB ((R2),OUTPUT)\n*        LTR   R9,R9\n         BZ    WNOMEM\n         USING ZDCBAREA,R2\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\nWNOMEM   DS    0H\n*         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),MODE=31,TYPE=J\n* CAN'T USE MODE=31 ON MVS 3.8, OR WITH TYPE=J\n         OPEN  ((R2),OUTPUT),MF=(E,WOPENMB),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPEN            OPEN failed\n*\n* Handle will be returned in R7\n*\n         LR    R7,R2\n         AIF   ('&OUTM' NE 'M').NMM4\n         L     R6,=F'32768'\n* Give caller an internal buffer to write to. Below the line!\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&SYS' NE 'S370').MVT8090  If not S/370 then 380 or 390\n         GETMAIN R,LV=(R6),SP=SUBPOOL  No LOC= for S/370\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/380 or S/390\n         GETMAIN R,LV=(R6),SP=SUBPOOL,LOC=BELOW\n.GETOENE ANOP\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\n.NMM4    ANOP\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,DCBLRECL\n         ST    R6,0(R8)\n         TM    DCBRECFM,DCBRECF\n         BNO   VARIABLE\n* This looks really whacky, but is correct\n* We check for V, in order to split between F and U\n* Because U has both F and V\n         TM    DCBRECFM,DCBRECV\n         BNO   FIXED\n         L     R6,=F'2'\n         B     DONESET\nFIXED    DS    0H\n         L     R6,=F'0'\n         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         ENTRY @@AREAD\n@@AREAD  EQU   *\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&SYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&SYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GET   (R2)\n         ST    R1,0(R3)\n         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&SYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n*\n*\n*\n***********************************************************************\n*\n*  AWRITE - Write to an open dataset\n*\n***********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE EQU   *\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R4,8(,R1)          R4 points to the length\n         L     R4,0(,R4)          R4 now has actual length\n         USING ZDCBAREA,R2\n*        GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,SAVEADCB\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n*        USING WORKAREA,R13\n*\n         AIF   ('&SYS' NE 'S380').N380WR1\n         CALL  @@SETM24\n.N380WR1 ANOP\n*\n         STCM  R4,B'0011',DCBLRECL\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n* In move mode, always use our internal buffer. Ignore passed parm.\n         L     R3,ASMBUF\n         PUT   (R2),(R3)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R3)\n.NLM3    ANOP\n*\n         AIF   ('&SYS' NE 'S380').N380WR2\n         CALL  @@SETM31\n.N380WR2 ANOP\n*\n*        LR    R1,R13\n*        L     R13,SAVEAREA+4\n         L     R13,SAVEADCB+4\n*        FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n         RETURN (14,12),RC=0\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE EQU   *\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         AIF   ('&SYS' EQ 'S390').BELOW3\n* CAN'T USE \"BELOW\" ON MVS 3.8\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         AGO   .NOBEL3\n.BELOW3  ANOP\n         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n.NOBEL3  ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n         FREEMAIN RU,LV=(R6),A=(R5),SP=SUBPOOL\nNFRCL    DS    0H\n.NMM6    ANOP\n         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n         CLOSE ((R2)),MF=(E,CLOSEMB)\n         FREEPOOL ((R2))\n         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n***********************************************************************\n*\n*  GETM - GET MEMORY\n*\n***********************************************************************\n         ENTRY @@GETM\n@@GETM   EQU   *\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(,R1)\n         AIF ('&COMP' NE 'GCC').GETMC\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n         AGO   .GETMEND\n.GETMC   ANOP\n* THIS LINE IS FOR C/370\n         L     R3,0(,R2)\n.GETMEND ANOP\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n         AIF   ('&SYS' NE 'S380').N380GM1\n*         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n* Hardcode the ATL memory area provided by latest MUSIC.\n* Note that this function will only work if the C library\n* is compiled with MEMMGR option.\n         L     R1,=X'02000000'\n         AGO   .N380GM2\n.N380GM1 ANOP\n         GETMAIN RU,LV=(R3),SP=SUBPOOL\n.N380GM2 ANOP\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*\n*  FREEM - FREE MEMORY\n*\n***********************************************************************\n         ENTRY @@FREEM\n@@FREEM  EQU   *\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n         AIF   ('&SYS' NE 'S380').N380FM1\n* On S/380, nothing to free - using preallocated memory block\n*         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n         AGO   .N380FM2\n.N380FM1 ANOP\n         FREEMAIN RU,LV=(R3),A=(R2),SP=SUBPOOL\n.N380FM2 ANOP\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN\n*  ANY PARTICULAR WAY.\n*\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1\n*\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS\n*\n***********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK EQU   *\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*  dummy function for MUSIC - not sure if supported                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  LA    R15,0\n         BR    R14\n         SPACE 2\n*\n*\n*\n***********************************************************************\n*\n*  SYSTEM - execute another command\n*\n***********************************************************************\n         ENTRY @@SYSTEM\n@@SYSTEM EQU   *\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         MVC   CMDPREF,FIXEDPRF\n         L     R2,0(R1)\n         CL    R2,=F'200'\n         BL    LENOK\n         L     R2,=F'200'\nLENOK    DS    0H\n         STH   R2,CMDLEN\n         LA    R4,CMDTEXT\n         LR    R5,R2\n         L     R6,4(R1)\n         LR    R7,R2\n         MVCL  R4,R6\n         LA    R1,CMDPREF\n         SVC   $EXREQ\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)   Return to caller\n* For documentation on this fixed prefix, see SVC 221\n* documentation.\nFIXEDPRF DC    X'7F01E000000000'\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n***********************************************************************\n*\n*  TEXTLC - switch terminal to lower case mode\n*\n***********************************************************************\n         ENTRY @@TEXTLC\n@@TEXTLC EQU   *\n         SAVE  (14,12),,@@TEXTLC  Save caller's regs.\n         LR    R12,R15\n         USING @@TEXTLC,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         LA    R1,LCOPTS\n         SVC   $SETOPT\n*\nRETURNLC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0              Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\nLCOPTS   DC    X'A0'              Constant\n         DC    X'01'              Set bit on\n         DC    X'01'              Option byte 1 (1-based)\n         DC    X'06'              Bit number 6 (0-based)\n***********************************************************************\n*\n*  IDCAMS - dummy function to keep MVS happy\n*\n***********************************************************************\n         ENTRY @@IDCAMS\n@@IDCAMS EQU   *\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  CALL @@SVC99,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SVC99\n@@SVC99  EQU   *\n         SAVE  (14,12),,@@SVC99   Save caller's regs.\n         LR    R12,R15\n         USING @@SVC99,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(R1)\n         O     R2,=X'80000000'\n         ST    R2,0(R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12\n***********************************************************************\n*\n*  SETJ - SAVE REGISTERS INTO ENV\n*\n***********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*\n*  LONGJ - RESTORE REGISTERS FROM ENV\n*\n***********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&SYS' EQ 'S370').NOMODE  If S/370 we can't switch mode\n***********************************************************************\n*\n*  SETM24 - Set AMODE to 24\n*\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*\n*  SETM31 - Set AMODE to 31\n*\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n         IEZIOB                   Input/Output Block\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n*\n         DCBD  DSORG=PS,DEVD=DA   Map Data Control Block\n         ORG   IHADCB             Overlay the DCB DSECT\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         DS    CL(OUTDCBLN)\nOPENCLOS DS    F                  OPEN/CLOSE parameter list\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\n         IHADECB DSECT=NO         Data Event Control Block\nBLKSIZE  DS    F                  Save area for input DCB BLKSIZE\nLRECL    DS    F                  Save area for input DCB LRECL\nBUFFADDR DS    F                  Location of the BLOCK Buffer\nBUFFEND  DS    F                  Address after end of current block\nBUFFCURR DS    F                  Current record in the buffer\nVBSADDR  DS    F                  Location of the VBS record build area\nVBSEND   DS    F                  Addr. after end VBS record build area\nVBSCURR  DS    F                  Location to store next byte\nRDRECPTR DS    F                  Where to store record pointer\nRDLENPTR DS    F                  Where to store read length\nJFCBPTR  DS    F\nJFCB     DS    0F\n         IEFJFCBN LIST=YES        SYS1.AMODGEN JOB File Control Block\n* Format 1 Data Set Control Block\nDSCB     DS    0F\n         IECSDSL1 (1)             Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\nSAVEADCB DS    18F                Register save area for PUT\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTing data\nMEMBER24 DS    CL8\nZDCBLEN  EQU   *-ZDCBAREA\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSENDEC": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards                             */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  mvsendec - mvs encode and decode                                 */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n\n#define CHUNKSZ 40\n\nstatic char *ascii2l(char *buf);\nstatic int fasc(int asc);\n\nint main(int argc, char **argv)\n{\n    int enc = 0;\n    int dec = 0;\n    int text = 0;\n    FILE *fp;\n    FILE *fq;\n    char inbuf\u00ddCHUNKSZ * 2 + 1\u00a8;\n    char outbuf\u00ddCHUNKSZ * 2 + 1\u00a8;\n    size_t count;\n    size_t x;\n    static char tohex\u00dd\u00a8 = { '0', '1', '2', '3', '4', '5', '6', '7',\n                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n    static char fromhex\u00ddUCHAR_MAX + 1\u00a8;\n\n    if (argc < 4)\n    {\n        printf(\"usage: mvsendec <encb/decb/enct/dect> <infile> <outfile>\\n\");\n        return (EXIT_FAILURE);\n    }\n    if ((strcmp(*(argv + 1), \"encb\") == 0)\n        || (strcmp(*(argv + 1), \"ENCB\") == 0))\n    {\n        enc = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"enct\") == 0)\n             || (strcmp(*(argv + 1), \"ENCT\") == 0))\n    {\n        enc = 1;\n        text = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"decb\") == 0)\n             || (strcmp(*(argv + 1), \"DECB\") == 0))\n    {\n        dec = 1;\n    }\n    else if ((strcmp(*(argv + 1), \"dect\") == 0)\n             || (strcmp(*(argv + 1), \"DECT\") == 0))\n    {\n        dec = 1;\n        text = 1;\n    }\n    else\n    {\n        printf(\"need to specify encode or decode (binary or text)\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    fromhex\u00dd'0'\u00a8 = 0;\n    fromhex\u00dd'1'\u00a8 = 1;\n    fromhex\u00dd'2'\u00a8 = 2;\n    fromhex\u00dd'3'\u00a8 = 3;\n    fromhex\u00dd'4'\u00a8 = 4;\n    fromhex\u00dd'5'\u00a8 = 5;\n    fromhex\u00dd'6'\u00a8 = 6;\n    fromhex\u00dd'7'\u00a8 = 7;\n    fromhex\u00dd'8'\u00a8 = 8;\n    fromhex\u00dd'9'\u00a8 = 9;\n    fromhex\u00dd'A'\u00a8 = 10;\n    fromhex\u00dd'B'\u00a8 = 11;\n    fromhex\u00dd'C'\u00a8 = 12;\n    fromhex\u00dd'D'\u00a8 = 13;\n    fromhex\u00dd'E'\u00a8 = 14;\n    fromhex\u00dd'F'\u00a8 = 15;\n\n    if (enc)\n    {\n        fp = fopen(*(argv + 2), text ? \"r\" : \"rb\");\n        fq = fopen(*(argv + 3), \"w\");\n        if ((fp == NULL) || (fq == NULL))\n        {\n            printf(\"file open error\\n\");\n            return (EXIT_FAILURE);\n        }\n    }\n    else if (dec)\n    {\n        /* don't be tempted to open fp in binary mode knowing\n           that it will be 80-character records, as they might\n           have transferred the data into a LRECL=200 dataset\n           etc instead */\n        fp = fopen(*(argv + 2), \"r\");\n        fq = fopen(*(argv + 3), text ? \"w\" : \"wb\");\n        if ((fp == NULL) || (fq == NULL))\n        {\n            printf(\"file open error\\n\");\n            return (EXIT_FAILURE);\n        }\n    }\n\n    if (enc)\n    {\n        while (1)\n        {\n            count = fread(inbuf, 1, CHUNKSZ, fp);\n            for (x = 0; x < count; x++)\n            {\n                outbuf\u00ddx * 2\u00a8 = tohex\u00dd((unsigned char)inbuf\u00ddx\u00a8 & 0xf0) >> 4\u00a8;\n                outbuf\u00ddx * 2 + 1\u00a8 = tohex\u00dd(unsigned char)inbuf\u00ddx\u00a8 & 0x0f\u00a8;\n            }\n            if (count != 0)\n            {\n                outbuf\u00ddcount * 2\u00a8 = '\\n';\n                fwrite(outbuf, 1, count * 2 + 1, fq);\n            }\n            if (count < CHUNKSZ) break;\n        }\n    }\n    else if (dec)\n    {\n        while (1)\n        {\n            count = fread(inbuf, 1, CHUNKSZ * 2 + 1, fp);\n            for (x = 0; (x + 1) < count; x += 2)\n            {\n                if (!isxdigit((unsigned char)inbuf\u00ddx\u00a8)\n                    || !isxdigit((unsigned char)inbuf\u00ddx + 1\u00a8))\n                {\n                    count = x;\n                    break;\n                }\n                outbuf\u00ddx / 2\u00a8 = (fromhex\u00ddinbuf\u00ddx\u00a8\u00a8 << 4)\n                                | fromhex\u00ddinbuf\u00ddx + 1\u00a8\u00a8;\n            }\n            if (text)\n            {\n                outbuf\u00ddcount / 2\u00a8 = '\\0';\n                ascii2l(outbuf);\n            }\n            fwrite(outbuf, 1, count / 2, fq);\n            if (count < (CHUNKSZ * 2 + 1)) break;\n        }\n    }\n\n    fclose(fp);\n    fclose(fq);\n    return (0);\n}\n\nstatic char *ascii2l(char *buf)\n{\n    char *p;\n    int c;\n\n    p = buf;\n    while (*p != '\\0')\n    {\n        c = fasc(*p);\n        if (c == '\\0')\n        {\n            printf(\"error translating %x\\n\", c);\n            exit(0);\n        }\n        *p = c;\n        p++;\n    }\n    return (buf);\n}\n\nstatic int fasc(int asc)\n{\n  switch (asc)\n  {\n    case 0x09 : return('\\t');\n    case 0x0a : return('\\n');\n    case 0x0c : return('\\f');\n    case 0x0d : return('\\r');\n    case 0x20 : return(' ');\n    case 0x21 : return('!');\n    case 0x22 : return('\\\"');\n    case 0x23 : return('#');\n    case 0x24 : return('$');\n    case 0x25 : return('%');\n    case 0x26 : return('&');\n    case 0x27 : return('\\'');\n    case 0x28 : return('(');\n    case 0x29 : return(')');\n    case 0x2a : return('*');\n    case 0x2b : return('+');\n    case 0x2c : return(',');\n    case 0x2d : return('-');\n    case 0x2e : return('.');\n    case 0x2f : return('/');\n    case 0x30 : return('0');\n    case 0x31 : return('1');\n    case 0x32 : return('2');\n    case 0x33 : return('3');\n    case 0x34 : return('4');\n    case 0x35 : return('5');\n    case 0x36 : return('6');\n    case 0x37 : return('7');\n    case 0x38 : return('8');\n    case 0x39 : return('9');\n    case 0x3a : return(':');\n    case 0x3b : return(';');\n    case 0x3c : return('<');\n    case 0x3d : return('=');\n    case 0x3e : return('>');\n    case 0x3f : return('?');\n    case 0x40 : return('@');\n    case 0x41 : return('A');\n    case 0x42 : return('B');\n    case 0x43 : return('C');\n    case 0x44 : return('D');\n    case 0x45 : return('E');\n    case 0x46 : return('F');\n    case 0x47 : return('G');\n    case 0x48 : return('H');\n    case 0x49 : return('I');\n    case 0x4a : return('J');\n    case 0x4b : return('K');\n    case 0x4c : return('L');\n    case 0x4d : return('M');\n    case 0x4e : return('N');\n    case 0x4f : return('O');\n    case 0x50 : return('P');\n    case 0x51 : return('Q');\n    case 0x52 : return('R');\n    case 0x53 : return('S');\n    case 0x54 : return('T');\n    case 0x55 : return('U');\n    case 0x56 : return('V');\n    case 0x57 : return('W');\n    case 0x58 : return('X');\n    case 0x59 : return('Y');\n    case 0x5a : return('Z');\n    case 0x5b : return('\u00dd');\n    case 0x5c : return('\\\\');\n    case 0x5d : return('\u00a8');\n    case 0x5e : return('\u00ac');\n    case 0x5f : return('_');\n    case 0x60 : return('`');\n    case 0x61 : return('a');\n    case 0x62 : return('b');\n    case 0x63 : return('c');\n    case 0x64 : return('d');\n    case 0x65 : return('e');\n    case 0x66 : return('f');\n    case 0x67 : return('g');\n    case 0x68 : return('h');\n    case 0x69 : return('i');\n    case 0x6a : return('j');\n    case 0x6b : return('k');\n    case 0x6c : return('l');\n    case 0x6d : return('m');\n    case 0x6e : return('n');\n    case 0x6f : return('o');\n    case 0x70 : return('p');\n    case 0x71 : return('q');\n    case 0x72 : return('r');\n    case 0x73 : return('s');\n    case 0x74 : return('t');\n    case 0x75 : return('u');\n    case 0x76 : return('v');\n    case 0x77 : return('w');\n    case 0x78 : return('x');\n    case 0x79 : return('y');\n    case 0x7a : return('z');\n    case 0x7b : return('{');\n    case 0x7c : return('|');\n    case 0x7d : return('}');\n    case 0x7e : return('~');\n    default   : return(0);\n  }\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "MVSSTART": {"ttr": 7941, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MVSSTART TITLE 'M V S S T A R T  ***  STARTUP ROUTINE FOR C'\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                              *\n*  RELEASED TO THE PUBLIC DOMAIN                                      *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  MVSSTART - startup routines for MVS.                               *\n*  It is currently coded to work with GCC. To activate the C/370      *\n*  version change the \"&COMP\" switch.                                 *\n*                                                                     *\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n* YREGS IS NOT AVAILABLE WITH IFOX\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n*\n         ENTRY @@CRT0\n@@CRT0   EQU   *\n         AIF ('&COMP' NE 'C370').NOCEES\n         ENTRY CEESTART\nCEESTART EQU   *\n.NOCEES  ANOP\n         SAVE  (14,12),,@@CRT0\n         LR    R10,R15\n         USING @@CRT0,R10\n         LR    R11,R1\n         GETMAIN RU,LV=STACKLEN,SP=SUBPOOL\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING STACK,R13\n*\n         LA    R1,0(R1)          Clean up address (is this required?)\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n         ST    R2,ARGPTR\n*\n         USING PSA,R0\n         L     R2,PSATOLD\n         USING TCB,R2\n         L     R7,TCBRBP\n         USING RBBASIC,R7\n         LA    R8,0\n         ICM   R8,B'0111',RBCDE1\n         USING CDENTRY,R8\n         MVC   PGMNAME,CDNAME\n*\n         L     R2,TCBJSCB\n         USING IEZJSCB,R2\n         LH    R2,JSCBTJID\n         ST    R2,TYPE\n         L     R2,0(R1)\n         LA    R2,0(R2)\n         ST    R2,ARGPTR\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&SYS' NE 'S380').N380ST1\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         BSM   R4,R0\n         ST    R4,SAVER4\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n*\n         AIF   ('&SYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R15\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n         DS    0H\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&SYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEMAIN RU,LV=STACKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R14\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSSUPA": {"ttr": 7945, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "MVSSUPA  TITLE 'M V S S U P A  ***  MVS VERSION OF PDP CLIB SUPPORT'\n***********************************************************************\n*                                                                     *\n*  This program written by Paul Edwards.                              *\n*  Released to the public domain                                      *\n*                                                                     *\n*  Extensively modified by others                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  MVSSUPA - Support routines for PDPCLIB under MVS                   *\n*    Additional macros in PDPCLIB.MACLIB                              *\n*  It is currently coded for GCC, but C/370 functionality is          *\n*  still there, it's just not being tested after each change.         *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* Note that some of the functionality in here has not been exercised  *\n* to any great extent, since it is dependent on whether the C code    *\n* invokes it or not.                                                  *\n*                                                                     *\n* Note that this code issues WTOs. It should be changed to just       *\n* set a return code and exit gracefully instead.                      *\n*                                                                     *\n***********************************************************************\n*   Changes by Gerhard Postpischil:\n*     EQU * for entry points deleted (placed labels on SAVE) to avoid\n*       0C6 abends when EQU follows a LTORG\n*     Fixed 0C4 abend in RECFM=Vxxx processing; fixed PUT length error.\n*     Deleted unnecessary and duplicated instructions\n*     Added @@SYSTEM and @@DYNAL routines                2008-06-10\n*     Added @@IDCAMS non-reentrant, non-refreshable      2008-06-17\n*     Modified I/O for BSAM, EXCP, and terminal I/O\n***********************************************************************\n*\n*\n* Internal macros:\n*\n*\n         MACRO ,             PATTERN FOR @@DYNAL'S DYNAMIC WORK AREA\n&NM      DYNPAT &P=MISSING-PFX\n.*   NOTE THAT EXTRA FIELDS ARE DEFINED FOR FUTURE EXPANSION\n.*\n&NM      DS    0D            ALLOCATION FIELDS\n&P.ARBP  DC    0F'0',A(X'80000000'+&P.ARB) RB POINTER\n&P.ARB   DC    0F'0',AL1(20,S99VRBAL,0,0)\n         DC    A(0,&P.ATXTP,0,0)       SVC 99 REQUEST BLOCK\n&P.ATXTP DC    10A(0)\n&P.AXVOL DC    Y(DALVLSER,1,6)\n&P.AVOL  DC    CL6' '\n&P.AXDSN DC    Y(DALDSNAM,1,44)\n&P.ADSN  DC    CL44' '\n&P.AXMEM DC    Y(DALMEMBR,1,8)\n&P.AMEM  DC    CL8' '\n&P.AXDSP DC    Y(DALSTATS,1,1)\n&P.ADSP  DC    X'08'         DISP=SHR\n&P.AXFRE DC    Y(DALCLOSE,0)   FREE=CLOSE\n&P.AXDDN DC    Y(DALDDNAM,1,8)    DALDDNAM OR DALRTDDN\n&P.ADDN  DC    CL8' '        SUPPLIED OR RETURNED DDNAME\n&P.ALEN  EQU   *-&P.ARBP       LENGTH OF REQUEST BLOCK\n         SPACE 1\n&P.URBP  DC    0F'0',A(X'80000000'+&P.URB) RB POINTER\n&P.URB   DC    0F'0',AL1(20,S99VRBUN,0,0)\n         DC    A(0,&P.UTXTP,0,0)       SVC 99 REQUEST BLOCK\n&P.UTXTP DC    A(X'80000000'+&P.UXDDN)\n&P.UXDDN DC    Y(DUNDDNAM,1,8)\n&P.UDDN  DC    CL8' '        RETURNED DDNAME\n&P.ULEN  EQU   *-&P.URBP       LENGTH OF REQUEST BLOCK\n&P.DYNLN EQU   *-&P.ARBP     LENGTH OF ALL DATA\n         MEND  ,\n*\n*\n*\n         MACRO ,\n&NM      FIXWRITE ,\n&NM      L     R15,=A(TRUNCOUT)\n         BALR  R14,R15       TRUNCATE CURRENT WRITE BLOCK\n         MEND  ,\n*\n*\n*\n         SPACE 1\n         COPY  MVSMACS\n         COPY  PDPTOP\n         SPACE 1\n* For S/390 we need to deliberately request LOC=BELOW storage\n* in some places.\n* For S/380 we need to deliberately request LOC=ANY storage.\n* For all other environments, just let it naturally default\n* to LOC=RES\n*\n         CSECT ,\n         PRINT GEN\n         YREGS\n         SPACE 1\n*-----------------------ASSEMBLY OPTIONS------------------------------*\nSUBPOOL  EQU   0                                                      *\n*---------------------------------------------------------------------*\n         SPACE 1\n*\n*\n*\n* Start of functions\n*\n*\n***********************************************************************\n*                                                                     *\n*  AOPEN - Open a data set                                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  Parameters are:                                                    *\n*1 DDNAME - space-padded, 8 character DDNAME to be opened             *\n*2 MODE =  0 INPUT  1 OUTPUT  2 UPDAT   3 APPEND      Record mode     *\n*  MODE =  4 INOUT  5 OUTIN                                           *\n*  MODE = 8/9 Use EXCP for tape, BSAM otherwise (or 32<=JFCPNCP<=65)  *\n*  MODE + 10 = Use BLOCK mode (valid 10-15)                           *\n*  MODE = 80 = GETLINE, 81 = PUTLINE (other bits ignored)             *\n*    N.B.: see comments under Return value\n*3 RECFM - 0 = F, 1 = V, 2 = U. Default/preference set by caller;     *\n*                               actual value returned from open.      *\n*4 LRECL   - Default/preference set by caller; OPEN value returned.   *\n*5 BLKSIZE - Default/preference set by caller; OPEN value returned.   *\n*                                                                     *\n* August 2009 revision - caller will pass preferred RECFM (coded 0-2) *\n*    LRECL, and BLKSIZE values. DCB OPEN exit OCDCBEX will use these  *\n*    defaults when not specified on JCL or DSCB merge.                *\n*                                                                     *\n*6 ZBUFF2 - pointer to an area that may be written to (size is LRECL) *\n*7 MEMBER - *pointer* to space-padded, 8 character member name.       *\n*    A member name beginning with blank or hex zero is ignored.       *\n*    If pointer is 0 (NULL), no member is requested                   *\n*                                                                     *\n*  Return value:                                                      *\n*  An internal \"handle\" that allows the assembler routines to         *\n*  keep track of what's what, when READ etc are subsequently          *\n*  called.                                                            *\n*                                                                     *\n*  All passed parameters are subject to overrides based on device     *\n*  capabilities and capacities, e.g., blocking may be turned off.     *\n*  In particular, the MODE flag will have x'40' ORed in for a         *\n*  unit record device.                                                *\n*                                                                     *\n*                                                                     *\n*  Note - more documentation for this and other I/O functions can     *\n*  be found halfway through the stdio.c file in PDPCLIB.              *\n*                                                                     *\n* Here are some of the errors reported:                               *\n*                                                                     *\n*  OPEN input failed return code is: -37                              *\n*  OPEN output failed return code is: -39                             *\n*                                                                     *\n* FIND input member return codes are:                                 *\n* Original, before the return and reason codes had                    *\n* negative translations added refer to copyrighted:                   *\n* DFSMS Macro Instructions for Data Sets                              *\n* RC = 0 Member was found.                                            *\n* RC = -1024 Member not found.                                        *\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.                 *\n* RC = -1032 PDSE share not available.                                *\n* RC = -1036 PDSE is OPENed output to a different member.             *\n* RC = -2048 Directory I/O error.                                     *\n* RC = -2052 Out of virtual storage.                                  *\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.         *\n* RC = -2060 PDSE I/O error flushing system buffers.                  *\n* RC = -2064 Invalid FIND, no DCB address.                            *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n@@AOPEN  FUNHEAD SAVE=(WORKAREA,OPENLEN,SUBPOOL)\n         LR    R11,R1             KEEP R11 FOR PARAMETERS\n         USING PARMSECT,R11       MAKE IT EASIER TO READ\n         L     R3,PARM1           R3 POINTS TO DDNAME\n* Note that R5 is used as a scratch register\n         L     R8,PARM4           R8 POINTS TO LRECL\n* PARM5    has BLKSIZE\n* PARM6    has ZBUFF2 pointer\n         L     R9,PARM7           R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,00(,R9)         Strip off high-order bit or byte\n         TM    0(R9),255-X'40'    Either blank or zero?\n         BNZ   *+6                  No\n         SR    R9,R9              Set for no member\n         SPACE 1\n         L     R4,PARM2           R4 is the MODE.  0=input 1=output\n         CH    R4,=H'256'         Call with value?\n         BL    *+8                Yes; else pointer\n         L     R4,0(,R4)          Load C/370 MODE.  0=input 1=output\n         SPACE 1\n         AIF   ('&SYS' NE 'S390').NOLOW\n         GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL,LOC=BELOW\n         AGO   .FINLOW\n.NOLOW   GETMAIN R,LV=ZDCBLEN,SP=SUBPOOL\n.FINLOW  LR    R10,R1             Addr.of storage obtained to its base\n         USING IHADCB,R10         Give assembler DCB area base register\n         LR    R0,R10             Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LA    R15,0              Pad of X'00' and no input length\n         MVCL  R0,R14             Clear DCB area to binary zeroes\n*---------------------------------------------------------------------*\n*   GET USER'S DEFAULTS HERE, BECAUSE THEY MAY GET CHANGED\n*---------------------------------------------------------------------*\n         L     R5,PARM3    HAS RECFM code (0-FB 1-VB 2-U)\n         L     R14,0(,R5)         LOAD RECFM VALUE\n         STC   R14,FILEMODE       PASS TO OPEN\n         L     R14,0(,R8)         GET LRECL VALUE\n         ST    R14,LRECL          PASS TO OPEN\n         L     R14,PARM5          R14 POINTS TO BLKSIZE\n         L     R14,0(,R14)        GET BLOCK SIZE\n         ST    R14,BLKSIZE        PASS TO OPEN\n         SPACE 1\n*---------------------------------------------------------------------*\n*   DO THE DEVICE TYPE NOW TO CHECK WHETHER EXCP IS POSSIBLE\n*     ALSO BYPASS STUFF IF USER REQUESTED TERMINAL I/O\n*---------------------------------------------------------------------*\nOPCURSE  STC   R4,WWORK           Save to storage\n         STC   R4,WWORK+1         Save to storage\n         NI    WWORK+1,7          Retain only open mode bits\n         TM    WWORK,IOFTERM      Terminal I/O ?\n         BNZ   TERMOPEN           Yes; do completely different\n***> Consider forcing terminal mode if DD is a terminal?\n         MVC   DWDDNAM,0(R3)      Move below the line\n         DEVTYPE DWDDNAM,DWORK    Check device type\n         BXH   R15,R15,FAILDCB    DD missing\n         ICM   R0,15,DWORK+4      Any device size ?\n         BNZ   OPHVMAXS\n         MVC   DWORK+6(2),=H'32760'    Set default max\n         SPACE 1\nOPHVMAXS CLI   WWORK+1,3          Append requested ?\n         BNE   OPNOTAP            No\n         TM    DWORK+2,UCB3TAPE+UCB3DACC    TAPE or DISK ?\n         BM    OPNOTAP            Yes; supported\n         NI    WWORK,255-2        Change to plain output\n*OR-FAIL BNM   FAILDCB            No, not supported\n         SPACE 1\nOPNOTAP  CLI   WWORK+1,2          UPDAT request?\n         BNE   OPNOTUP            No\n         CLI   DWORK+2,UCB3DACC   DASD ?\n         BNE   FAILDCB            No, not supported\n         SPACE 1\nOPNOTUP  CLI   WWORK+1,4          INOUT or OUTIN ?\n         BL    OPNOTIO            No\n         TM    DWORK+2,UCB3TAPE+UCB3DACC    TAPE or DISK ?\n         BNM   FAILDCB            No; not supported\n         SPACE 1\nOPNOTIO  TM    WWORK,IOFEXCP      EXCP requested ?\n         BZ    OPFIXMD2\n         CLI   DWORK+2,UCB3TAPE   TAPE/CARTRIDGE device?\n         BE    OPFIXMD1           Yes; wonderful ?\nOPFIXMD0 NI    WWORK,255-IOFEXCP  Cancel EXCP request\n         B     OPFIXMD2\nOPFIXMD1 L     R0,BLKSIZE         GET USER'S SIZE\n         CH    R0,=H'32760'       NEED EXCP ?\n         BNH   OPFIXMD0           NO; USE BSAM\n         ST    R0,DWORK+4              Increase max size\n         ST    R0,LRECL           ALSO RECORD LENGTH\n         MVI   FILEMODE,2         FORCE RECFM=U\n         SPACE 1\nOPFIXMD2 IC    R4,WWORK           Fix up\nOPFIXMOD STC   R4,WWORK           Save to storage\n         MVC   IOMFLAGS,WWORK     Save for duration\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Do as much common code for input and output before splitting\n*   Set mode flag in Open/Close list\n*   Move BSAM, QSAM, or EXCP DCB to work area\n*---------------------------------------------------------------------*\n         STC   R4,OPENCLOS        Initialize MODE=24 OPEN/CLOSE list\n         NI    OPENCLOS,X'07'        For now\n*                  OPEN mode: IN OU UP AP IO OI\n         TR    OPENCLOS(1),=X'80,8F,84,8E,83,86,0,0'\n         CLI   OPENCLOS,0         NOT SUPPORTED ?\n         BE    FAILDCB            FAIL REQUEST\n         SPACE 1\n         TM    WWORK,IOFEXCP      EXCP mode ?\n         BZ    OPQRYBSM\n         MVC   ZDCBAREA(EXCPDCBL),EXCPDCB  Move DCB/IOB/CCW\n         LA    R15,TAPEIOB   FOR EASIER SETTINGS\n         USING IOBSTDRD,R15\n         MVI   IOBFLAG1,IOBDATCH+IOBCMDCH   COMMAND CHAINING IN USE\n         MVI   IOBFLAG2,IOBRRT2\n         LA    R1,TAPEECB\n         ST    R1,IOBECBPT\n         LA    R1,TAPECCW\n         ST    R1,IOBSTART   CCW ADDRESS\n         ST    R1,IOBRESTR   CCW ADDRESS\n         LA    R1,TAPEDCB\n         ST    R1,IOBDCBPT   DCB\n         LA    R1,TAPEIOB\n         STCM  R1,7,DCBIOBAA LINK IOB TO DCB FOR DUMP FORM.ING\n         LA    R0,1          SET BLOCK COUNT INCREMENT\n         STH   R0,IOBINCAM\n         DROP  R15\n         B     OPREPCOM\n         SPACE 1\nOPQRYBSM TM    WWORK,IOFBLOCK     Block mode ?\n         BNZ   OPREPBSM\n         TM    WWORK,X'01'        In or Out\n*DEFUNCT BNZ   OPREPQSM\nOPREPBSM MVC   ZDCBAREA(BSAMDCBL),BSAMDCB  Move DCB template to work\n         TM    DWORK+2,UCB3DACC+UCB3TAPE    Tape or Disk ?\n         BM    OPREPCOM           Either; keep RP,WP\n         NC    DCBMACR(2),=AL1(DCBMRRD,DCBMRWRT) Strip Point\n         B     OPREPCOM\n         SPACE 1\nOPREPQSM MVC   ZDCBAREA(QSAMDCBL),QSAMDCB\nOPREPCOM MVC   DCBDDNAM,0(R3)\n         MVC   DEVINFO(8),DWORK   Check device type\n         ICM   R0,15,DEVINFO+4    Any ?\n         BZ    FAILDCB            No DD card or ?\n         N     R4,=X'000000EF'    Reset block mode\n         TM    WWORK,IOFTERM      Terminal I/O?\n         BNZ   OPFIXMOD\n         TM    WWORK,IOFBLOCK           Blocked I/O?\n         BZ    OPREPJFC\n         CLI   DEVINFO+2,UCB3UREC Unit record?\n         BE    OPFIXMOD           Yes, may not block\n         SPACE 1\nOPREPJFC LA    R14,JFCB\n* EXIT TYPE 07 + 80 (END OF LIST INDICATOR)\n         ICM   R14,B'1000',=X'87'\n         ST    R14,DCBXLST+4\n         LA    R14,OCDCBEX        POINT TO DCB EXIT\n* Both S380 and S390 operate in 31-bit mode so need a stub\n         AIF   ('&SYS' EQ 'S370').NODP24\n         ST    R14,DOPE31         Address of 31-bit exit\n         OI    DOPE31,X'80'       Set high bit = AMODE 31\n         MVC   DOPE24,DOPEX24     Move in stub code\n         LA    R14,DOPE24         Switch to 24-bit stub\n.NODP24  ANOP  ,\n         ICM   R14,8,=X'05'         REQUEST IT\n         ST    R14,DCBXLST        AND SET IT BACK\n         LA    R14,DCBXLST\n         STCM  R14,B'0111',DCBEXLSA\n         MVC   EOFR24(EOFRLEN),ENDFILE   Put EOF code below the line\n         LA    R1,EOFR24\n         STCM  R1,B'0111',DCBEODA\n         RDJFCB ((R10)),MF=(E,OPENCLOS)  Read JOB File Control Blk\n*---------------------------------------------------------------------*\n*   If the caller did not request EXCP mode, but the user has BLKSIZE\n*   greater than 32760 on TAPE, then we set the EXCP bit in R4 and\n*   restart the OPEN. Otherwise MVS should fail?\n*   The system fails explicit BLKSIZE in excess of 32760, so we cheat.\n*   The NCP field is not otherwise honored, so if the value is 32 to\n*   64 inclusive, we use that times 1024 as a value (max 65535)\n*---------------------------------------------------------------------*\n         CLI   DEVINFO+2,UCB3TAPE TAPE DEVICE?\n         BNE   OPNOTBIG           NO\n         TM    WWORK,IOFEXCP      USER REQUESTED EXCP ?\n         BNZ   OPVOLCNT           NOTHING TO DO\n         CLI   JFCNCP,32          LESS THAN MIN ?\n         BL    OPNOTBIG           YES; IGNORE\n         CLI   JFCNCP,65          NOT TOO HIGH ?\n         BH    OPNOTBIG           TOO BAD\n*---------------------------------------------------------------------*\n*   Clear DCB wrk area and force RECFM=U,BLKSIZE>32K\n*     and restart the OPEN processing\n*---------------------------------------------------------------------*\n         LR    R0,R10             Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length\n         LA    R15,0              Pad of X'00'\n         MVCL  R0,R14             Clear DCB area to zeroes\n         SR    R0,R0\n         ICM   R0,1,JFCNCP        NUMBER OF CHANNEL PROGRAMS\n         SLL   R0,10              *1024\n         C     R0,=F'65535'       LARGER THAN CCW SUPPORTS?\n         BL    *+8                NO\n         L     R0,=F'65535'       LOAD MAX SUPPORTED\n         ST    R0,BLKSIZE         MAKE NEW VALUES THE DEFAULT\n         ST    R0,LRECL           MAKE NEW VALUES THE DEFAULT\n         MVI   FILEMODE,2         USE RECFM=U\n         LA    R0,IOFEXCP         GET EXCP OPTION\n         OR    R4,R0              ADD TO USER'S REQUEST\n         B     OPCURSE            AND RESTART THE OPEN\n         SPACE 1\nOPVOLCNT SR    R1,R1\n         ICM   R1,1,JFCBVLCT      GET VOLUME COUNT FROM DD\n         BNZ   *+8                OK\n         LA    R1,1               SET FOR ONE\n         ST    R1,ZXCPVOLS        SAVE FOR EOV\n         SPACE 1\nOPNOTBIG CLI   DEVINFO+2,UCB3DACC   Is it a DASD device?\n         BNE   OPNODSCB           No; no member name supported\n*---------------------------------------------------------------------*\n*   For a DASD resident file, get the format 1 DSCB\n*---------------------------------------------------------------------*\n* CAMLST CAMLST SEARCH,DSNAME,VOLSER,DSCB+44\n*\n         L     R14,CAMDUM         Get CAMLST flags\n         LA    R15,JFCBDSNM       Load address of output data set name\n         LA    R0,JFCBVOLS        Load addr. of output data set volser\n         LA    R1,DS1FMTID        Load address of where to put DSCB\n         STM   R14,R1,CAMLST      Complete CAMLST addresses\n         OBTAIN CAMLST            Read the VTOC record\n         SPACE 1\n* The member name may not be below the line, which may stuff up\n* the \"FIND\" macro, so make sure it is in 24-bit memory.\nOPNODSCB LTR   R9,R9              See if an address for the member name\n         BZ    NOMEM              No member name, skip copying\n         MVC   MEMBER24,0(R9)\n         LA    R9,MEMBER24\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Split READ and WRITE paths\n*     Note that all references to DCBRECFM, DCBLRECL, and DCBBLKSI\n*     have been replaced by ZRECFM, LRECL, and BLKSIZE for EXCP use.\n*---------------------------------------------------------------------*\nNOMEM    TM    WWORK,1            See if OPEN input or output\n         BNZ   WRITING\n*---------------------------------------------------------------------*\n*\n* READING\n*   N.B. moved RDJFCB prior to member test to allow uniform OPEN and\n*        other code. Makes debugging and maintenance easier\n*\n*---------------------------------------------------------------------*\n         OI    JFCBTSDM,JFCNWRIT  Don't mess with DSCB\n         CLI   DEVINFO+2,UCB3DACC   Is it a DASD device?\n         BNE   OPENVSEQ           No; no member name supported\n*---------------------------------------------------------------------*\n* See if DSORG=PO but no member; use member from JFCB if one\n*---------------------------------------------------------------------*\n         TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    OPENVSEQ           Not PDS, don't read PDS directory\n         TM    WWORK,X'07'   ANY NON-READ OPTION ?\n         BNZ   FAILDCB            NOT ALLOWED FOR PDS\n         LTR   R9,R9              See if an address for the member name\n         BNZ   OPENMEM            Is member name - BPAM access\n         TM    JFCBIND1,JFCPDS    See if a member name in JCL\n         BZ    OPENDIR            No; read directory\n         MVC   MEMBER24,JFCBELNM  Save the member name\n         NI    JFCBIND1,255-JFCPDS    Reset it\n         XC    JFCBELNM,JFCBELNM  Delete it in JFCB\n         LA    R9,MEMBER24        Force FIND to prevent 013 abend\n         B     OPENMEM            Change DCB to BPAM PO\n*---------------------------------------------------------------------*\n* At this point, we have a PDS but no member name requested.\n* Request must be to read the PDS directory\n*---------------------------------------------------------------------*\nOPENDIR  TM    OPENCLOS,X'0F'     Other than plain OPEN ?\n         BNZ   BADOPIN            No, fail (allow UPDAT later?)\n         LA    R0,256             Set size for Directory BLock\n         STH   R0,DCBBLKSI        Set DCB BLKSIZE to 256\n         STH   R0,DCBLRECL        Set DCB LRECL to 256\n         ST    R0,LRECL\n         ST    R0,BLKSIZE\n         MVI   DCBRECFM,DCBRECF   Set DCB RECFM to RECFM=F (notU?)\n         B     OPENIN\nOPENMEM  MVI   DCBDSRG1,DCBDSGPO  Replace DCB DSORG=PS with PO\n         OI    JFCBTSDM,JFCVSL    Force OPEN analysis of JFCB\n         B     OPENIN\nOPENVSEQ LTR   R9,R9              Member name for sequential?\n         BNZ   BADOPIN            Yes, fail\n         TM    IOMFLAGS,IOFEXCP   EXCP mode ?\n         BNZ   OPENIN             YES\n         OI    DCBOFLGS,DCBOFPPC  Allow unlike concatenation\nOPENIN   OPEN  MF=(E,OPENCLOS),TYPE=J  Open the data set\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPIN            OPEN failed, go return error code -37\n         LTR   R9,R9              See if an address for the member name\n         BZ    GETBUFF            No member name, skip finding it\n*\n         FIND  (R10),(R9),D       Point to the requested member\n*\n         LTR   R15,R15            See if member found\n         BZ    GETBUFF            Member found, go get an input buffer\n* If FIND return code not zero, process return and reason codes and\n* return to caller with a negative return code.\n         SLL   R15,8              Shift return code for reason code\n         OR    R15,R0             Combine return code and reason code\n         LR    R7,R15             Number to generate return and reason\n         CLOSE MF=(E,OPENCLOS)    Close, FREEPOOL not needed\n         B     FREEDCB\nBADOPIN  DS    0H\nBADOPOUT DS    0H\nFAILDCB  N     R4,=F'1'           Mask other option bits\n         LA    R7,37(R4,R4)       Preset OPEN error code\nFREEDCB  FREEMAIN R,LV=ZDCBLEN,A=(R10),SP=SUBPOOL  Free DCB area\n         LCR   R7,R7              Set return and reason code\n         B     RETURNOP           Go return to caller with negative RC\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Process for OUTPUT mode\n*---------------------------------------------------------------------*\nWRITING  LTR   R9,R9\n         BZ    WNOMEM\n         CLI   DEVINFO+2,UCB3DACC   DASD ?\n         BNE   BADOPOUT           Member name invalid\n         TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    BADOPOUT           Is not PDS, fail request\n         TM    WWORK,X'06'   ANY NON-RITE OPTION ?\n         BNZ   FAILDCB            NOT ALLOWED FOR PDS\n         MVC   JFCBELNM,0(R9)\n         OI    JFCBIND1,JFCPDS\n         OI    JFCBTSDM,JFCVSL    Just in case\n         B     WNOMEM2            Go to move DCB info\nWNOMEM   DS    0H\n         TM    JFCBIND1,JFCPDS    See if a member name in JCL\n         BO    WNOMEM2            Is member name, go to continue OPEN\n* See if DSORG=PO but no member so OPEN output would destroy directory\n         TM    DS1DSORG,DS1DSGPO  See if DSORG=PO\n         BZ    WNOMEM2            Is not PDS, go OPEN\n         WTO   'MVSSUPA - No member name for output PDS',ROUTCDE=11\n         WTO   'MVSSUPA - Refuses to write over PDS directory',        C\n               ROUTCDE=11\n         ABEND 123                Abend without a dump\n         SPACE 1\nWNOMEM2  OPEN  MF=(E,OPENCLOS),TYPE=J\n         TM    DCBOFLGS,DCBOFOPN  Did OPEN work?\n         BZ    BADOPOUT           OPEN failed, go return error code -39\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Acquire one BLKSIZE buffer for our I/O; and one LRECL buffer\n*   for use by caller for @@AWRITE, and us for @@AREAD.\n*---------------------------------------------------------------------*\nGETBUFF  L     R5,BLKSIZE         Load the input blocksize\n         LA    R6,4(,R5)          Add 4 in case RECFM=U buffer\n         GETMAIN R,LV=(R6),SP=SUBPOOL  Get input buffer storage\n         ST    R1,ZBUFF1          Save for cleanup\n         ST    R6,ZBUFF1+4           ditto\n         ST    R1,BUFFADDR        Save the buffer address for READ\n         XC    0(4,R1),0(R1)      Clear the RECFM=U Record Desc. Word\n         LA    R14,0(R5,R1)       Get end address\n         ST    R14,BUFFEND          for real\n         SPACE 1\n         L     R6,LRECL           Get record length\n         LA    R6,4(,R6)          Insurance\n         GETMAIN R,LV=(R6),SP=SUBPOOL  Get VBS build record area\n         ST    R1,ZBUFF2          Save for cleanup\n         ST    R6,ZBUFF2+4           ditto\n         LA    R14,4(,R1)\n         ST    R14,VBSADDR        Save the VBS read/user write\n         L     R5,PARM6           Get caller's BUFFER address\n         ST    R14,0(,R5)         and return work address\n         AR    R1,R6              Add size GETMAINed to find end\n         ST    R1,VBSEND          Save address after VBS rec.build area\n         B     DONEOPEN           Go return to caller with DCB info\n         SPACE 1\n         PUSH  USING\n*---------------------------------------------------------------------*\n*   Establish ZDCBAREA for either @@AWRITE or @@AREAD processing to\n*   a terminal, or SYSTSIN/SYSTERM in batch.\n*---------------------------------------------------------------------*\nTERMOPEN MVC   IOMFLAGS,WWORK     Save for duration\n         NI    IOMFLAGS,IOFTERM+IOFOUT      IGNORE ALL OTHERS\n         MVC   ZDCBAREA(TERMDCBL),TERMDCB  Move DCB/IOB/CCW\n         MVC   ZIODDNM,0(R3)      DDNAME FOR DEBUGGING, ETC.\n         LTR   R9,R9              See if an address for the member name\n         BNZ   FAILDCB            Yes; fail\n         L     R14,PSATOLD-PSA    GET MY TCB\n         USING TCB,R14\n         ICM   R15,15,TCBJSCB  LOOK FOR THE JSCB\n         BZ    FAILDCB       HUH ?\n         USING IEZJSCB,R15\n         ICM   R15,15,JSCBPSCB  PSCB PRESENT ?\n         BZ    FAILDCB       NO; NOT TSO\n         L     R1,TCBFSA     GET FIRST SAVE AREA\n         N     R1,=X'00FFFFFF'    IN CASE AM31\n         L     R1,24(,R1)         LOAD INVOCATION R1\n         USING CPPL,R1       DECLARE IT\n         MVC   ZIOECT,CPPLECT\n         MVC   ZIOUPT,CPPLUPT\n         SPACE 1\n         ICM   R6,15,BLKSIZE      Load the input blocksize\n         BP    *+12               Use it\n         LA    R6,1024            Arbitrary non-zero size\n         ST    R6,BLKSIZE         Return it\n         ST    R6,LRECL           Return it\n         LA    R6,4(,R6)          Add 4 in case RECFM=U buffer\n         GETMAIN R,LV=(R6),SP=SUBPOOL  Get input buffer storage\n         ST    R1,ZBUFF2          Save for cleanup\n         ST    R6,ZBUFF2+4           ditto\n         LA    R1,4(,R1)          Allow for RDW if not V\n         ST    R1,BUFFADDR        Save the buffer address for READ\n         L     R5,PARM6           R5 points to ZBUFF2\n         ST    R1,0(,R5)          save the pointer\n         XC    0(4,R1),0(R1)      Clear the RECFM=U Record Desc. Word\n         MVC   ZRECFM,FILEMODE    Requested format 0-2\n         NI    ZRECFM,3           Just in case\n         TR    ZRECFM,=X'8040C0C0'    Change to F / V / U\n         POP   USING\n         SPACE 1\n*   Lots of code tests DCBRECFM twice, to distinguish among F, V, and\n*     U formats. We set the index byte to 0,4,8 to allow a single test\n*     with a three-way branch.\nDONEOPEN LR    R7,R10             Return DCB/file handle address\n         LA    R0,8\n         TM    ZRECFM,DCBRECU     Undefined ?\n         BO    SETINDEX           Yes\n         BM    GETINDFV           No\n         TM    ZRECFM,DCBRECTO    RECFM=D\n         BZ    SETINDEX           No; treat as U\n         B     SETINDVD\nGETINDFV SR    R0,R0              Set for F\n         TM    ZRECFM,DCBRECF     Fixed ?\n         BNZ   SETINDEX           Yes\nSETINDVD LA    R0,4               Preset for V\nSETINDEX STC   R0,RECFMIX         Save for the duration\n         SRL   R0,2               Convert to caller's code\n         L     R5,PARM3           POINT TO RECFM\n         ST    R0,0(,R5)          Pass either RECFM F or V to caller\n         L     R1,LRECL           Load RECFM F or V max. record length\n         ST    R1,0(,R8)          Return record length back to caller\n         L     R5,PARM5           POINT TO BLKSIZE\n         L     R0,BLKSIZE         Load RECFM U maximum record length\n         ST    R0,0(,R5)          Pass new BLKSIZE\n         L     R5,PARM2           POINT TO MODE\n         MVC   3(1,R5),IOMFLAGS   Pass (updated) file mode back\n         CLI   DEVINFO+2,UCB3UREC\n         BNE   NOTUNREC           Not unit-record\n         OI    3(R5),IOFUREC      flag unit-record\nNOTUNREC DS    0H\n*\n* Finished with R5 now\n*\nRETURNOP FUNEXIT RC=(R7)          Return to caller\n*\n* This is not executed directly, but copied into 24-bit storage\nENDFILE  LA    R6,1               Indicate @@AREAD reached end-of-file\n         LNR   R6,R6              Make negative\n         BR    R14                Return to instruction after the GET\nEOFRLEN  EQU   *-ENDFILE\n*\n         LTORG ,\n         SPACE 1\nBSAMDCB  DCB   MACRF=(RP,WP),DSORG=PS,DDNAME=BSAMDCB, input and output *\n               EXLST=1-1          JFCB and DCB exits added later\nBSAMDCBN EQU   *-BSAMDCB\nREADDUM  READ  NONE,              Read record Data Event Control Block *\n               SF,                Read record Sequential Forward       *\n               ,       (R10),     Read record DCB address              *\n               ,       (R4),      Read record input buffer             *\n               ,       (R5),      Read BLKSIZE or 256 for PDS.Directory*\n               MF=L               List type MACRO\nREADLEN  EQU   *-READDUM\nBSAMDCBL EQU   *-BSAMDCB\n         SPACE 1\nEXCPDCB  DCB   DDNAME=EXCPDCB,MACRF=E,DSORG=PS,REPOS=Y,BLKSIZE=0,      *\n               DEVD=TA,EXLST=1-1,RECFM=U\n         DC    8XL4'0'         CLEAR UNUSED SPACE\n         ORG   EXCPDCB+84    LEAVE ROOM FOR DCBLRECL\n         DC    F'0'          VOLUME COUNT\nPATCCW   CCW   1,2-2,X'40',3-3\n         ORG   ,\nEXCPDCBL EQU   *-EXCPDCB     PATTERN TO MOVE\n         SPACE 1\nTERMDCB  PUTLINE MF=L        PATTERN FOR TERMINAL I/O\nTERMDCBL EQU   *-TERMDCB     SIZE OF IOPL\n         SPACE 1\nF65536   DC    F'65536'           Maximum VBS record GETMAIN length\n*\n* QSAMDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\nQSAMDCB  DCB   MACRF=P&OUTM.M,DSORG=PS,DDNAME=QSAMDCB\nQSAMDCBL EQU   *-QSAMDCB\n*\n*\n* CAMDUM CAMLST SEARCH,DSNAME,VOLSER,DSCB+44\nCAMDUM   CAMLST SEARCH,*-*,*-*,*-*\nCAMLEN   EQU   *-CAMDUM           Length of CAMLST Template\n         POP   USING\n         SPACE 1\n*---------------------------------------------------------------------*\n*   Expand OPEN options for reference\n*---------------------------------------------------------------------*\nADHOC    DSECT ,\nOPENREF  OPEN  (BSAMDCB,INPUT),MF=L    QSAM, BSAM, any DEVTYPE\n         OPEN  (BSAMDCB,OUTPUT),MF=L   QSAM, BSAM, any DEVTYPE\n         OPEN  (BSAMDCB,UPDAT),MF=L    QSAM, BSAM, DASD\n         OPEN  (BSAMDCB,EXTEND),MF=L   QSAM, BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,INOUT),MF=L          BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,OUTINX),MF=L         BSAM, DASD, TAPE\n         OPEN  (BSAMDCB,OUTIN),MF=L          BSAM, DASD, TAPE\n         SPACE 1\nPARMSECT DSECT ,             MAP CALL PARM\nPARM1    DS    A             FIRST PARM\nPARM2    DS    A              NEXT PARM\nPARM3    DS    A              NEXT PARM\nPARM4    DS    A              NEXT PARM\nPARM5    DS    A              NEXT PARM\nPARM6    DS    A              NEXT PARM\nPARM7    DS    A              NEXT PARM\nPARM8    DS    A              NEXT PARM\n         CSECT ,\n         SPACE 1\n         ORG   CAMDUM+4           Don't need rest\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    OPEN DCB EXIT - if RECFM, LRECL, BLKSIZE preset, no change       *\n*                     unless forced by device (e.g., unit record      *\n*                     not blocked)                                    *\n*                    for PDS directory read, F, 256, 256 are preset.  *\n*    a) device is unit record - default U, device size, device size   *\n*    b) all others - default to values passed to AOPEN                *\n*                                                                     *\n*    For FB, if LRECL > BLKSIZE, make LRECL=BLKSIZE                   *\n*    For VB, if LRECL+3 > BLKSIZE, set spanned                        *\n*                                                                     *\n*                                                                     *\n*    So, what this means is that if the DCBLRECL etc fields are set   *\n*    already by MVS (due to existing file, JCL statement etc),        *\n*    then these aren't changed. However, if they're not present,      *\n*    then start using the \"LRECL\" etc previously set up by C caller.  *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         USING OCDCBEX,R15\n         USING IHADCB,R1     DECLARE OUR DCB WORK SPACE\nOCDCBEX  LR    R11,R1        SAVE DCB ADDRESS AND OPEN FLAGS\n         N     R1,=X'00FFFFFF'   NO 0C4 ON DCB ACCESS IF AM31\n         TM    IOPFLAGS,IOFDCBEX  Been here before ?\n         BZ    OCDCBX1\n         OI    IOPFLAGS,IOFCONCT  Set unlike concatenation\n         OI    DCBOFLGS,DCBOFPPC  Keep them coming\nOCDCBX1  OI    IOPFLAGS,IOFDCBEX  Show exit entered\n         SR    R2,R2         FOR POSSIBLE DIVIDE (FB)\n         SR    R3,R3\n         ICM   R3,3,DCBBLKSI   GET CURRENT BLOCK SIZE\n         SR    R4,R4         FOR POSSIBLE LRECL=X\n         ICM   R4,3,DCBLRECL GET CURRENT RECORD LENGTH\n         NI    FILEMODE,3    MASK FILE MODE\n         MVC   ZRECFM,FILEMODE   GET OPTION BITS\n         TR    ZRECFM,=X'90,50,C0,C0'  0-FB  1-VB  2-U\n         TM    DCBRECFM,DCBRECLA  ANY RECORD FORMAT SPECIFIED?\n         BNZ   OCDCBFH       YES\n         CLI   DEVINFO+2,UCB3UREC  UNIT RECORD?\n         BNE   OCDCBFM       NO; USE OVERRIDE\nOCDCBFU  CLI   FILEMODE,0         DID USER REQUEST FB?\n         BE    OCDCBFM            YES; USE IT\n         OI    DCBRECFM,DCBRECU   SET U FOR READER/PUNCH/PRINTER\n         B     OCDCBFH\nOCDCBFM  MVC   DCBRECFM,ZRECFM\nOCDCBFH  LTR   R4,R4\n         BNZ   OCDCBLH       HAVE A RECORD LENGTH\n         L     R4,DEVINFO+4       SET DEVICE SIZE FOR UNIT RECORD\n         CLI   DEVINFO+2,UCB3UREC   UNIT RECORD?\n         BE    OCDCBLH       YES; USE IT\n*   REQUIRES CALLER TO SET LRECL=BLKSIZE FOR RECFM=U DEFAULT\n         ICM   R4,15,LRECL   SET LRECL=PREFERRED BLOCK SIZE\n         BNZ   *+8\n         L     R4,DEVINFO+4  ELSE USE DEVICE MAX\n         IC    R5,DCBRECFM   GET RECFM\n         N     R5,=X'000000C0'  RETAIN ONLY D,F,U,V\n         SRL   R5,6          CHANGE TO 0-D 1-V 2-F 3-U\n         MH    R5,=H'3'      PREPARE INDEX\n         SR    R6,R6\n         IC    R6,FILEMODE   GET USER'S VALUE\n         AR    R5,R6         DCB VS. DFLT ARRAY\n*     DCB RECFM:       --D--- --V--- --F--- --U---\n*     FILE MODE:       F V  U F V  U F  V U F  V U\n         LA    R6,=AL1(4,0,-4,4,0,-4,0,-4,0,0,-4,0)  LRECL ADJUST\n         AR    R6,R5         POINT TO ENTRY\n         ICM   R5,8,0(R6)    LOAD IT\n         SRA   R5,24         SHIFT WITH SIGN EXTENSION\n         AR    R4,R5         NEW LRECL\n         SPACE 1\n*   NOW CHECK BLOCK SIZE\nOCDCBLH  LTR   R3,R3         ANY ?\n         BNZ   *+8           YES\n         ICM   R3,15,BLKSIZE SET OUR PREFERRED SIZE\n         BNZ   *+8           OK\n         L     R3,DEVINFO+4  SET NON-ZERO\n         C     R3,DEVINFO+4  LEGAL ?\n         BNH   *+8\n         L     R3,DEVINFO+4  NO; SHORTEN\n         TM    DCBRECFM,DCBRECU   U?\n         BO    OCDCBBU       YES\n         TM    DCBRECFM,DCBRECF   FIXED ?\n         BZ    OCDCBBV       NO; CHECK VAR\n         DR    R2,R4\n         CH    R3,=H'1'      DID IT FIT ?\n         BE    OCDCBBF       BARELY\n         BH    OCDCBBB       ELSE LEAVE BLOCKED\n         LA    R3,1          SET ONE RECORD MINIMUM\nOCDCBBF  NI    DCBRECFM,255-DCBRECBR   BLOCKING NOT NEEDED\nOCDCBBB  MR    R2,R4         BLOCK SIZE NOW MULTIPLE OF LRECL\n         B     OCDCBXX       AND GET OUT\n*   VARIABLE\nOCDCBBV  LA    R5,4(,R4)     LRECL+4\n         CR    R5,R3         WILL IT FIT ?\n         BNH   *+8           YES\n         OI    DCBRECFM,DCBRECSB  SET SPANNED\n         B     OCDCBXX       AND EXIT\n*   UNDEFINED\nOCDCBBU  LR    R4,R3         FOR NEATNESS, SET LRECL = BLOCK SIZE\n*   EXEUNT  (Save DCB options for EXCP compatibility in main code)\nOCDCBXX  STH   R3,DCBBLKSI   UPDATE POSSIBLY CHANGED BLOCK SIZE\n         STH   R4,DCBLRECL     AND RECORD LENGTH\n         ST    R3,BLKSIZE    UPDATE POSSIBLY CHANGED BLOCK SIZE\n         ST    R4,LRECL        AND RECORD LENGTH\n         MVC   ZRECFM,DCBRECFM    DITTO\n         AIF   ('&SYS' EQ 'S370').NOOPSW\n         BSM   R0,R14\n         AGO   .OPNRET\n.NOOPSW  ANOP  ,\n         BR    R14           RETURN TO OPEN\n.OPNRET  ANOP  ,\n         POP   USING\n         SPACE 2\n*\n         AIF   ('&SYS' EQ 'S370').NODOP24\n***********************************************************************\n*                                                                     *\n*    OPEN DCB EXIT - 24 bit stub                                      *\n*    This code is not directly executed. It is copied below the line  *\n*    It is only needed for AMODE 31 programs (both S380 and S390      *\n*    execute in this mode).                                           *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         USING DOPEX24,R15\n*\n* This next line works because when we are actually executing,\n* we are executing inside that DSECT, so the address we want\n* follows the code. Also, it has already had the high bit set,\n* so it will switch to 31-bit mode.\n*\nDOPEX24  L     R15,DOPE31-DOPE24(,R15)  Load 31-bit routine address\n*\n* The following works because while the AMODE is saved in R14, the\n* rest of R14 isn't disturbed, so it is all set for a BSM to R14\n*\n         BSM   R14,R15                  Switch to 31-bit mode\nDOPELEN  EQU   *-DOPEX24\n         POP   USING\n.NODOP24 ANOP  ,\n*\n***********************************************************************\n*                                                                     *\n*  ALINE - See whether any more input is available                    *\n*     R15=0 EOF     R15=1 More data available                         *\n*                                                                     *\n***********************************************************************\n@@ALINE  FUNHEAD IO=YES,AM=YES,SAVE=(WORKAREA,WORKLEN,SUBPOOL)\n         FIXWRITE ,\n         TM    IOMFLAGS,IOFTERM   Terminal Input?\n         BNZ   ALINEYES             Always one more?\n         LA    R3,KEPTREC\n         LA    R4,KEPTREC+4\n         STM   R2,R4,DWORK   BUILD PARM LIST\n         LA    R15,@@AREAD\n         LA    R1,DWORK\n         BALR  R14,R15       GET NEXT RECORD\n         SR    R15,R15       SET EOF FLAG\n         LTR   R6,R6         HIT EOF ?\n         BM    ALINEX        YES; RETURN ZERO\n         OI    IOPFLAGS,IOFKEPT   SHOW WE'RE KEEPING A RECORD\nALINEYES LA    R15,1         ELSE RETURN ONE\nALINEX   FUNEXIT RC=(R15)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  AREAD - Read from an open data set                                 *\n*                                                                     *\n***********************************************************************\n@@AREAD  FUNHEAD IO=YES,AM=YES,SAVE=SAVEADCB,US=NO   READ / GET\n         L     R3,4(,R1)  R3 points to where to store record pointer\n         L     R4,8(,R1)  R4 points to where to store record length\n         SR    R0,R0\n         ST    R0,0(,R3)          Return null in case of EOF\n         ST    R0,0(,R4)          Return null in case of EOF\n         FIXWRITE ,               For OUTIN request\n         L     R6,=F'-1'          Prepare for EOF signal\n         TM    IOPFLAGS,IOFKEPT   Saved record ?\n         BZ    READQEOF           No; check for EOF\n         LM    R8,R9,KEPTREC      Get prior address & length\n         ST    R8,0(,R3)          Set address\n         ST    R9,0(,R4)            and length\n         XC    KEPTREC(8),KEPTREC Reset record info\n         NI    IOPFLAGS,IOFKEPT   Reset flag\n         SR    R6,R6              No EOF\n         B     READEXIT\n         SPACE 1\nREADQEOF TM    IOPFLAGS,IOFLEOF   Prior EOF ?\n         BNZ   READEXIT           Yes; don't abend\n         TM    IOMFLAGS,IOFTERM   GETLIN request?\n         BNZ   TGETREAD           Yes\n*   Return here for end-of-block or unlike concatenation\n*\nREREAD   SLR   R6,R6              Clear default end-of-file indicator\n         ICM   R8,B'1111',BUFFCURR  Load address of next record\n         BNZ   DEBLOCK            Block in memory, go de-block it\n         L     R8,BUFFADDR        Load address of input buffer\n         L     R9,BLKSIZE         Load block size to read\n         CLI   RECFMIX,4          RECFM=Vxx ?\n         BE    READ               No, deblock\n         LA    R8,4(,R8)          Room for fake RDW\nREAD     GO24  ,                  For old code\n         TM    IOMFLAGS,IOFEXCP   EXCP mode?\n         BZ    READBSAM           No, use BSAM\n*---------------------------------------------------------------------*\n*   EXCP read\n*---------------------------------------------------------------------*\nREADEXCP STCM  R8,7,TAPECCW+1     Read buffer\n         STH   R9,TAPECCW+6         max length\n         MVI   TAPECCW,2          READ\n         MVI   TAPECCW+4,X'20'    SILI bit\n         EXCP  TAPEIOB            Read\n         WAIT  ECB=TAPEECB        wait for completion\n         TM    TAPEECB,X'7F'      Good ?\n         BO    EXRDOK             Yes; calculate input length\n         CLI   TAPEECB,X'41'      Tape Mark read ?\n         BNE   EXRDBAD            NO\n         CLM   R9,3,IOBCSW+5-IOBSTDRD+TAPEIOB  All unread?\n         BNE   EXRDBAD            NO\n         L     R1,DCBBLKCT\n         BCTR  R1,0\n         ST    R1,DCBBLKCT        allow for tape mark\n         OI    DCBOFLGS,X'04'     Set tape mark found\n         L     R0,ZXCPVOLS        Get current volume count\n         SH    R0,=H'1'           Just processed one\n         ST    R0,ZXCPVOLS\n         BNP   READEOD            None left - take End File\n         EOV   TAPEDCB            switch volumes\n         B     READEXCP           and restart\n         SPACE 1\nEXRDBAD  ABEND 001,DUMP           bad way to show error?\n         SPACE 1\nEXRDOK   SR    R0,R0\n         ICM   R0,3,IOBCSW+5-IOBSTDRD+TAPEIOB\n         SR    R9,R0         LENGTH READ\n         BNP   BADBLOCK      NONE ?\n         AMUSE ,                  Restore caller's mode\n         LTR   R6,R6              See if end of input data set\n         BM    READEOD            Is end, go return to caller\n         B     POSTREAD           Go to common code\n         SPACE 1\n*---------------------------------------------------------------------*\n*   BSAM read\n*---------------------------------------------------------------------*\nREADBSAM SR    R6,R6              Reset EOF flag\n         GO24 ,                   Get low\n         READ  DECB,              Read record Data Event Control Block C\n               SF,                Read record Sequential Forward       C\n               (R10),             Read record DCB address              C\n               (R8),              Read record input buffer             C\n               (R9),              Read BLKSIZE or 256 for PDS.DirectoryC\n               MF=E               Execute a MF=L MACRO\n*                                 If EOF, R6 will be set to F'-1'\n         CHECK DECB               Wait for READ to complete\n         TM    IOPFLAGS,IOFCONCT  Did we hit concatenation?\n         BZ    READUSAM           No; restore user's AM\n         NI    IOPFLAGS,255-IOFCONCT   Reset for next time\n         ICM   R6,8,DCBRECFM\n         SRL   R6,24+2            Isolate top two bits\n         STC   R6,RECFMIX         Store\n         TR    RECFMIX,=X'01010002'    Filemode D, V, F, U\n         MVC   LRECL+2(2),DCBLRECL  Also return record length\n         MVC   ZRECFM,DCBRECFM    and format\n         B     READBSAM           Reissue the READ\n         SPACE 1\nREADUSAM AMUSE ,                  Restore caller's mode\n         LTR   R6,R6              See if end of input data set\n         BM    READEOD            Is end, go return to caller\n         L     R14,DECB+16    DECIOBPT\n         USING IOBSTDRD,R14       Give assembler IOB base\n         SLR   R1,R1              Clear residual amount work register\n         ICM   R1,B'0011',IOBCSW+5  Load residual count\n         DROP  R14                Don't need IOB address base anymore\n         SR    R9,R1              Provisionally return blocklen\n         SPACE 1\nPOSTREAD TM    IOMFLAGS,IOFBLOCK  Block mode ?\n         BNZ   POSTBLOK           Yes; process as such\n         TM    ZRECFM,DCBRECU     Also exit for U\n         BNO   POSTREED\nPOSTBLOK ST    R8,0(,R3)          Return address to user\n         ST    R9,0(,R4)          Return length to user\n         STM   R8,R9,KEPTREC      Remember record info\n         XC    BUFFCURR,BUFFCURR  Show READ required next call\n         B     READEXIT\nPOSTREED CLI   RECFMIX,4          See if RECFM=V\n         BNE   EXRDNOTV           Is RECFM=U or F, so not RECFM=V\n         ICM   R9,3,0(R8)         Get presumed block length\n         C     R9,BLKSIZE         Valid?\n         BH    BADBLOCK           No\n         ICM   R0,3,2(R8)         Garbage in BDW?\n         BNZ   BADBLOCK           Yes; fail\n         B     EXRDCOM\nEXRDNOTV LA    R0,4(,R9)          Fake length\n         SH    R8,=H'4'           Space to fake RDW\n         STH   R0,0(0,R8)         Fake RDW\n         LA    R9,4(,R9)          Up for fake RDW (F/U)\nEXRDCOM  LA    R8,4(,R8)          Bump buffer address past BDW\n         SH    R9,=H'4'             and adjust length to match\n         BNP   BADBLOCK           Oops\n         ST    R8,BUFFCURR        Indicate data available\n         ST    R8,0(,R3)          Return address to user\n         ST    R9,0(,R4)          Return length to user\n         STM   R8,R9,KEPTREC      Remember record info\n         LA    R7,0(R9,R8)        End address + 1\n         ST    R7,BUFFEND         Save end\n         SPACE 1\n         TM    IOMFLAGS,IOFBLOCK   Block mode?\n         BNZ   READEXIT           Yes; exit\n         TM    ZRECFM,DCBRECU     Also exit for U\n         BO    READEXIT\n*NEXT*   B     DEBLOCK            Else deblock\n         SPACE 1\n*        R8 has address of current record\nDEBLOCK  CLI   RECFMIX,4          Is data set RECFM=U\n         BL    DEBLOCKF           Is RECFM=Fx, go deblock it\n*\n* Must be RECFM=V, VB, VBS, VS, VA, VM, VBA, VBM, VSA, VSM, VBSA, VBSM\n*  VBS SDW ( Segment Descriptor Word ):\n*  REC+0 length 2 is segment length\n*  REC+2 0 is record not segmented\n*  REC+2 1 is first segment of record\n*  REC+2 2 is last seqment of record\n*  REC+2 3 is one of the middle segments of a record\n*        R5 has address of current record\nDEBLOCKV CLI   0(R8),X'80'   LOGICAL END OF BLOCK ?\n         BE    REREAD        YES; DONE WITH THIS BLOCK\n         LH    R9,0(,R8)     GET LENGTH FROM RDW\n         CH    R9,=H'4'      AT LEAST MINIMUM ?\n         BL    BADBLOCK      NO; BAD RECORD OR BAD BLOCK\n         C     R9,LRECL      VALID LENGTH ?\n         BH    BADBLOCK      NO\n         LA    R7,0(R9,R8)   SET ADDRESS OF LAST BYTE +1\n         C     R7,BUFFEND    WILL IT FIT INTO BUFFER ?\n         BL    DEBVCURR      LOW - LEAVE IT\n         BH    BADBLOCK      NO; FAIL\n         SR    R7,R7         PRESET FOR BLOCK DONE\nDEBVCURR ST    R7,BUFFCURR        for recursion\n         TM    3(R8),X'FF'   CLEAN RDW ?\n         BNZ   BADBLOCK\n         TM    IOPFLAGS,IOFLSDW   WAS PREVIOUS RECORD DONE ?\n         BO    DEBVAPND           NO\n         LH    R0,0(,R8)          Provisional length if simple\n         ST    R0,0(,R4)          Return length\n         ST    R0,KEPTREC+4       Remember record info\n         CLI   2(R8),1            What is this?\n         BL    SETCURR            Simple record\n         BH    BADBLOCK           Not=1; have a sequence error\n         OI    IOPFLAGS,IOFLSDW   Starting a new segment\n         L     R2,VBSADDR         Get start of buffer\n         MVC   0(4,R2),=X'00040000'   Preset null record\n         B     DEBVMOVE           And move this\nDEBVAPND CLI   2(R8),3            IS THIS A MIDDLE SEGMENT ?\n         BE    DEBVMOVE           YES, PUT IT OUT\n         CLI   2(R8),2            IS THIS THE LAST SEGMENT ?\n         BNE   BADBLOCK           No; bad segment sequence\n         NI    IOPFLAGS,255-IOFLSDW  INDICATE RECORD COMPLETE\nDEBVMOVE L     R2,VBSADDR         Get segment assembly area\n         SR    R1,R1              Never trust anyone\n         ICM   R1,3,0(R8)         Length of addition\n         SH    R1,=H'4'           Data length\n         LA    R0,4(,R8)          Skip SDW\n         SR    R15,R15\n         ICM   R15,3,0(R2)        Get amount used so far\n         LA    R14,0(R15,R2)      Address for next segment\n         LA    R8,0(R1,R15)       New length\n         STH   R8,0(,R2)          Update RDW\n         A     R8,VBSADDR         New end address\n         C     R8,VBSEND          Will it fit ?\n         BH    BADBLOCK\n         LR    R15,R1             Move all\n         MVCL  R14,R0             Append segment\n         TM    IOPFLAGS,IOFLSDW    Did last segment?\n         BNZ   REREAD             No; get next one\n         L     R8,VBSADDR         Give user the assembled record\n         SR    R0,R0\n         ICM   R0,3,0(R8)         Provisional length if simple\n         ST    R0,0(,R4)          Return length\n         ST    R0,KEPTREC+4       Remember record info\n         B     SETCURR            Done\n         SPACE 2\n* If RECFM=FB, bump address by lrecl\n*        R8 has address of current record\nDEBLOCKF L     R7,LRECL           Load RECFM=F DCB LRECL\n         ST    R7,0(,R4)          Return length\n         ST    R7,KEPTREC+4       Remember record info\n         AR    R7,R8              Find the next record address\n* If address=BUFFEND, zero BUFFCURR\nSETCURR  CL    R7,BUFFEND         Is it off end of block?\n         BL    SETCURS            Is not off, go store it\n         SR    R7,R7              Clear the next record address\nSETCURS  ST    R7,BUFFCURR        Store the next record address\n         ST    R8,0(,R3)          Store record address for caller\n         ST    R8,KEPTREC         Remember record info\n         B     READEXIT\n         SPACE 1\nTGETREAD L     R6,ZIOECT          RESTORE ECT ADDRESS\n         L     R7,ZIOUPT          RESTORE UPT ADDRESS\n         MVI   ZGETLINE+2,X'80'   EXPECTED FLAG\n         GO24\n         GETLINE PARM=ZGETLINE,ECT=(R6),UPT=(R7),ECB=ZIOECB,           *\n               MF=(E,ZIOPL)\n         GO31\n         LR    R6,R15             COPY RETURN CODE\n         CH    R6,=H'16'          HIT BARRIER ?\n         BE    READEOD2           YES; EOF, BUT ALLOW READS\n         CH    R6,=H'8'           SERIOUS ?\n         BNL   READEXNG           ATTENTION INTERRUPT OR WORSE\n         L     R1,ZGETLINE+4      GET INPUT LINE\n*---------------------------------------------------------------------*\n*   MVS 3.8 undocumented behavior: at end of input in batch execution,\n*   returns text of 'END' instead of return code 16. Needs DOC fix\n*---------------------------------------------------------------------*\n         CLC   =X'00070000C5D5C4',0(R1)  Undocumented EOF?\n         BNE   TGETNEOF\n         XC    KEPTREC(8),KEPTREC Clear saved record info\n         LA    R6,1\n         LNR   R6,R6              Signal EOF\n         B     TGETFREE           FREE BUFFER AND QUIT\nTGETNEOF L     R6,BUFFADDR        GET INPUT BUFFER\n         LR    R8,R1              INPUT LINE W/RDW\n         LH    R9,0(,R1)          GET LENGTH\n         LR    R7,R9               FOR V, IN LEN = OUT LEN\n         CLI   RECFMIX,4          RECFM=V ?\n         BE    TGETHAVE           YES\n         BL    TGETSKPF\n         SH    R7,=H'4'           ALLOW FOR RDW\n         B     TGETSKPV\nTGETSKPF L     R7,LRECL             FULL SIZE IF F\nTGETSKPV LA    R8,4(,R8)          SKIP RDW\n         SH    R9,=H'4'           LENGTH SANS RDW\nTGETHAVE ST    R6,0(,R3)          RETURN ADDRESS\n         ST    R7,0(,R4)            AND LENGTH\n         STM   R6,R7,KEPTREC      Remember record info\n         ICM   R9,8,=C' '           BLANK FILL\n         MVCL  R6,R8              PRESERVE IT FOR USER\n         SR    R6,R6              NO EOF\nTGETFREE LH    R0,0(,R1)          GET LENGTH\n         ICM   R0,8,=AL1(1)       SUBPOOL 1\n         FREEMAIN R,LV=(0),A=(1)  FREE SYSTEM BUFFER\n         B     READEXIT           TAKE NORMAL EXIT\n         SPACE 1\nREADEOD  OI    IOPFLAGS,IOFLEOF   Remember that we hit EOF\nREADEOD2 XC    KEPTREC(8),KEPTREC Clear saved record info\n         LA    R6,1\nREADEXNG LNR   R6,R6              Signal EOF\nREADEXIT FUNEXIT RC=(R6) =1-EOF   Return to caller\n*\nBADBLOCK WTO   'MVSSUPA - @@AREAD - problem processing RECFM=V(bs) file*\n               ',ROUTCDE=11       Send to programmer and listing\n         ABEND 1234,DUMP          Abend U1234 and allow a dump\n*\n         LTORG ,                  In case someone adds literals\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  AWRITE - Write to an open data set                                 *\n*                                                                     *\n***********************************************************************\n@@AWRITE FUNHEAD IO=YES,AM=YES,SAVE=SAVEADCB,US=NO   WRITE / PUT\n         LR    R11,R1             SAVE PARM LIST\nWRITMORE NI    IOPFLAGS,255-IOFCURSE   RESET RECURSION\n         L     R4,4(,R11)         R4 points to the record address\n         L     R4,0(,R4)          Get record address\n         L     R5,8(,R11)         R5 points to length of data to write\n         L     R5,0(,R5)          Length of data to write\n         TM    IOMFLAGS,IOFTERM   PUTLIN request?\n         BNZ   TPUTWRIT           Yes\n*\n         TM    IOMFLAGS,IOFBLOCK  Block mode?\n         BNZ   WRITBLK            Yes\n         CLI   OPENCLOS,X'84'     Running in update mode ?\n         BNE   WRITENEW           No\n         LM    R2,R3,KEPTREC      Get last record returned\n         LTR   R3,R3              Any?\n         BNP   WRITEEX            No; ignore (or abend?)\n         CLI   RECFMIX,4          RECFM=V...\n         BNE   WRITUPMV           NO\n         LA    R0,4               ADJUST FOR RDW\n         AR    R2,R0              KEEP OLD RDW\n         SR    R3,R0              ADJUST REPLACE LENGTH\n         AR    R4,R0              SKIP OVER USER'S RDW\n         SR    R5,R0              ADJUST LENGTH\nWRITUPMV MVCL  R2,R4              REPLACE DATA IN BUFFER\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         B     WRITEEX            REWRITE ON NEXT READ OR CLOSE\n         SPACE 1\nWRITENEW CLI   RECFMIX,4          V-FORMAT ?\n         BH    WRITBLK            U - WRITE BLOCK AS IS\n         BL    WRITEFIX           F - ADD RECORD TO BLOCK\n         CH    R5,0(,R4)          RDW LENGTH = REQUESTED LEN?\n         BNE   WRITEBAD           NO; FAIL\n         L     R8,BUFFADDR        GET BUFFER\n         ICM   R6,15,BUFFCURR     Get next record address\n         BNZ   WRITEVAT\n         LA    R0,4\n         STH   R0,0(,R8)          BUILD BDW\n         LA    R6,4(,R8)          SET TO FIRST RECORD POSITION\nWRITEVAT L     R9,BUFFEND         GET BUFFER END\n         SR    R9,R6              LESS CURRENT POSITION\n         TM    ZRECFM,DCBRECSB    SPANNED?\n         BZ    WRITEVAR           NO; ROUTINE VARIABLE WRITE\n         LA    R1,4(,R5)          GET RECORD + BDW LENGTH\n         C     R1,LRECL           VALID SIZE?\n         BH    WRITEBAD           NO; TAKE A DIVE\n         TM    IOPFLAGS,IOFLSDW   CONTINUATION ?\n         BNZ   WRITEVAW           YES; DO HERE\n         CR    R5,R9              WILL IT FIT AS IS?\n         BNH   WRITEVAS           YES; DON'T NEED TO SPLIT\nWRITEVAW CH    R9,=H'5'           AT LEAST FIVE BYTES LEFT ?\n         BL    WRITEVNU           NO; WRITE THIS BLOCK; RETRY\n         LR    R3,R6              SAVE START ADDRESS\n         LR    R7,R9              COPY LENGTH\n         CR    R7,R5              ROOM FOR ENTIRE SEGMENT ?\n         BL    *+4+2              NO\n         LR    R7,R5              USE ONLY WHAT'S AVAILABLE\n         MVCL  R6,R4              COPY RDW + DATA\n         ST    R6,BUFFCURR        UPDATE NEXT AVAILABLE\n         SR    R6,R8              LESS START\n         STH   R6,0(,R8)          UPDATE BDW\n         STH   R9,0(,R3)          FIX RDW LENGTH\n         MVC   2(2,R3),=X'0100'   SET FLAGS FOR START SEGMENT\n         TM    IOPFLAGS,IOFLSDW   DID START ?\n         BZ    *+4+6              NO; FIRST SEGMENT\n         MVI   2(R3),3            SHOW MIDDLE SEGMENT\n         LTR   R5,R5              DID WE FINISH THE RECORD ?\n         BP    WRITEWAY           NO\n         MVI   2(R3),2            SHOW LAST SEGMENT\n         NI    IOPFLAGS,255-IOFLSDW-IOFCURSE  RCD COMPLETE\n         OI    IOPFLAGS,IOFLDATA  SHOW WRITE DATA IN BUFFER\n         B     WRITEEX            DONE\nWRITEWAY SH    R9,=H'4'           ALLOW FOR EXTRA RDW\n         AR    R4,R9\n         SR    R5,R9\n         STM   R4,R5,KEPTREC      MAKE FAKE PARM LIST\n         LA    R11,KEPTREC-4      SET FOR RECURSION\n         OI    IOPFLAGS,IOFLSDW   SHOW RECORD INCOMPLETE\n         B     WRITEVNU           GO FOR MORE\n         SPACE 1\nWRITEVAR LA    R1,4(,R5)          GET RECORD + BDW LENGTH\n         C     R1,BLKSIZE         VALID SIZE?\n         BH    WRITEBAD           NO; TAKE A DIVE\n         L     R9,BUFFEND         GET BUFFER END\n         SR    R9,R6              LESS CURRENT POSITION\n         CR    R5,R9              WILL IT FIT ?\n         BH    WRITEVNU           NO; WRITE NOW AND RECURSE\nWRITEVAS LR    R7,R5              IN LENGTH = MOVE LENGTH\n         MVCL  R6,R4              MOVE USER'S RECORD\n         ST    R6,BUFFCURR        UPDATE NEXT AVAILABLE\n         SR    R6,R8              LESS START\n         STH   R6,0(,R8)          UPDATE BDW\n         OI    IOPFLAGS,IOFLDATA  SHOW WRITE DATA IN BUFFER\n         TM    DCBRECFM,DCBRECBR  BLOCKED?\n         BNZ   WRITEEX            YES, NORMAL\n         FIXWRITE ,               RECFM=V - WRITE IMMEDIATELY\n         B     WRITEEX\n         SPACE 1\nWRITEVNU OI    IOPFLAGS,IOFCURSE  SET RECURSION REQUEST\n         B     WRITPREP           SET ADDRESS/LENGTH TO WRITE\n         SPACE 1\nWRITEBAD ABEND 002,DUMP           INVALID REQUEST\n         SPACE 1\nWRITEFIX ICM   R6,15,BUFFCURR     Get next available record\n         BNZ   WRITEFAP           Not first\n         L     R6,BUFFADDR        Get buffer start\nWRITEFAP L     R7,LRECL           Record length\n         ICM   R5,8,=C' '         Request blank padding\n         MVCL  R6,R4              Copy record to buffer\n         ST    R6,BUFFCURR        Update new record address\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         C     R6,BUFFEND         Room for more ?\n         BL    WRITEEX            YES; RETURN\nWRITPREP L     R4,BUFFADDR        Start write address\n         LR    R5,R6              Current end of block\n         SR    R5,R4              Current length\n*NEXT*   B     WRITBLK            WRITE THE BLOCK\n         SPACE 1\nWRITBLK  AR    R5,R4              Set start and end of write\n         STM   R4,R5,BUFFADDR     Pass to physical writer\n         OI    IOPFLAGS,IOFLDATA  SHOW DATA IN BUFFER\n         FIXWRITE ,               Write physical block\n         B     WRITEEX            AND RETURN\n         SPACE 1\nTPUTWRIT CLI   RECFMIX,4          RECFM=V ?\n         BE    TPUTWRIV           YES\n         SH    R4,=H'4'           BACK UP TO RDW\n         LA    R5,4(,R5)          LENGTH WITH RDW\nTPUTWRIV STH   R5,0(,R4)          FILL RDW\n         STCM  R5,12,2(R4)          ZERO REST\n         L     R6,ZIOECT          RESTORE ECT ADDRESS\n         L     R7,ZIOUPT          RESTORE UPT ADDRESS\n         GO24\n         PUTLINE PARM=ZPUTLINE,ECT=(R6),UPT=(R7),ECB=ZIOECB,           *\n               OUTPUT=((R4),DATA),TERMPUT=EDIT,MF=(E,ZIOPL)\n         GO31\n         SPACE 1\nWRITEEX  TM    IOPFLAGS,IOFCURSE  RECURSION REQUESTED?\n         BNZ   WRITMORE\n         FUNEXIT RC=0\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ANOTE  - Remember the position in the data set (BSAM/BPAM only)    *\n*                                                                     *\n***********************************************************************\n@@ANOTE  FUNHEAD IO=YES,AM=YES,SAVE=SAVEADCB,US=NO   NOTE position\n         L     R3,4(,R1)          R3 points to the return value\n         FIXWRITE ,\n         GO24  ,                  For old code\n         TM    IOMFLAGS,IOFEXCP   EXCP mode?\n         BZ    NOTEBSAM           No\n         L     R4,DCBBLKCT        Return block count\n         B     NOTECOM\n         SPACE 1\nNOTEBSAM NOTE  (R10)              Note current position\n         LR    R4,R1              Save result\nNOTECOM  AMUSE ,\n         ST    R4,0(,R3)          Return TTR0 to user\n         FUNEXIT RC=0\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  APOINT - Restore the position in the data set (BSAM/BPAM only)     *\n*           Note that this does not fail; it just bombs on the        *\n*           next read or write if incorrect.                          *\n*                                                                     *\n***********************************************************************\n@@APOINT FUNHEAD IO=YES,AM=YES,SAVE=SAVEADCB,US=NO   NOTE position\n         L     R3,4(,R1)          R3 points to the TTR value\n         L     R3,0(,R3)          Get the TTR\n         ST    R3,ZWORK           Save below the line\n         FIXWRITE ,\n         GO24  ,                  For old code\n         TM    IOMFLAGS,IOFEXCP   EXCP mode ?\n         BZ    POINBSAM           No\n         L     R4,DCBBLKCT        Get current position\n         SR    R4,R3              Get new position's increment\n         BZ    POINCOM\n         BM    POINHEAD\nPOINBACK MVI   TAPECCW,X'27'      Backspace\n         B     POINECOM\nPOINHEAD MVI   TAPECCW,X'37'      Forward space\nPOINECOM LA    R0,1\n         STH   R0,TAPECCW+6\n         LPR   R4,R4\nPOINELUP EXCP  TAPEIOB\n         WAIT  ECB=TAPEECB\n         BCT   R4,POINELUP\n         ST    R3,DCBBLKCT\n         B     POINCOM\n         SPACE 1\nPOINBSAM POINT (R10),ZWORK        Request repositioning\nPOINCOM  AMUSE ,\n         NI    IOPFLAGS,255-IOFLEOF   Valid POINT resets EOF\n         XC    KEPTREC(8),KEPTREC      Also clear record data\n         FUNEXIT RC=0\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  ACLOSE - Close a data set                                          *\n*                                                                     *\n***********************************************************************\n@@ACLOSE FUNHEAD IO=YES,SAVE=(WORKAREA,WORKLEN,SUBPOOL)  CLOSE\n         TM    IOMFLAGS,IOFTERM   TERMINAL I/O MODE?\n         BNZ   FREEBUFF           YES; JUST FREE STUFF\n         FIXWRITE ,          WRITE FINAL BUFFER, IF ONE\nFREEBUFF LM    R1,R2,ZBUFF1       Look at first buffer\n         LTR   R0,R2              Any ?\n         BZ    FREEDBF1           No\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL  Free BLOCK buffer\nFREEDBF1 LM    R1,R2,ZBUFF2       Look at first buffer\n         LTR   R0,R2              Any ?\n         BZ    FREEDBF2           No\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL  Free RECRD buffer\nFREEDBF2 TM    IOMFLAGS,IOFTERM   TERMINAL I/O MODE?\n         BNZ   NOPOOL             YES; SKIP CLOSE/FREEPOOL\n         CLOSE MF=(E,OPENCLOS)\n         TM    DCBBUFCA+L'DCBBUFCA-1,1      BUFFER POOL?\n         BNZ   NOPOOL             NO, INVALIDATED\n         SR    R15,R15\n         ICM   R15,7,DCBBUFCA     DID WE GET A BUFFER?\n         BZ    NOPOOL             0-NO\n         FREEPOOL ((R10))\nNOPOOL   DS    0H\n         FREEMAIN R,LV=ZDCBLEN,A=(R10),SP=SUBPOOL\n         FUNEXIT RC=0\n         SPACE 2\n         PUSH  USING\n         DROP  ,\n*---------------------------------------------------------------------*\n*  Physical Write - called by @@ACLOSE, switch from output to input\n*    mode, and whenever output buffer is full or needs to be emptied.\n*  Works for EXCP and BSAM. Special processing for UPDAT mode\n*---------------------------------------------------------------------*\nTRUNCOUT B     *+14-TRUNCOUT(,R15)   SKIP LABEL\n         DC    AL1(9),CL(9)'TRUNCOUT' EXPAND LABEL\n         AIF   ('&SYS' NE 'S380').NOTRUBS\n         BSM   R14,R0             PRESERVE AMODE\n.NOTRUBS STM   R14,R12,12(R13)    SAVE CALLER'S REGISTERS\n         LR    R12,R15\n         USING TRUNCOUT,R12\n         LA    R15,ZIOSAVE2-ZDCBAREA(,R10)\n         ST    R15,8(,R13)\n         ST    R13,4(,R15)\n         LR    R13,R15\n         USING IHADCB,R10    COMMON I/O AREA SET BY CALLER\n         TM    IOPFLAGS,IOFLDATA   PENDING WRITE ?\n         BZ    TRUNCOEX      NO; JUST RETURN\n         NI    IOPFLAGS,255-IOFLDATA  Reset it\n         GO24  ,             GET LOW\n         LM    R4,R5,BUFFADDR  START/NEXT ADDRESS\n         CLI   RECFMIX,4          RECFM=V?\n         BNE   TRUNLEN5\n         SR    R5,R5\n         ICM   R5,3,0(R4)         USE BDW LENGTH\n         CH    R5,=H'8'           EMPTY ?\n         BNH   TRUNPOST           YES; IGNORE REQUEST\n         B     TRUNTMOD           CHECK OUTPUT TYPE\nTRUNLEN5 SR    R5,R4              CONVERT TO LENGTH\n         BNP   TRUNCOEX           NOTHING TO DO\nTRUNTMOD DS    0H\n         TM    IOMFLAGS,IOFEXCP   EXCP mode ?\n         BNZ   EXCPWRIT           Yes\n         CLI   OPENCLOS,X'84'     Update mode?\n         BE    TRUNSHRT             Yes; just rewrite as is\n         CLI   RECFMIX,4          RECFM=F ?\n         BNL   *+8                No; leave it alone\n         STH   R5,DCBBLKSI        Why do I need this?\n         WRITE DECB,SF,(R10),(R4),(R5),MF=E  Write block\n         B     TRUNCHK\nTRUNSHRT WRITE DECB,SF,MF=E       Rewrite block from READ\nTRUNCHK  CHECK DECB\n         B     TRUNPOST           Clean up\n         SPACE 1\nEXCPWRIT STH   R5,TAPECCW+6\n         STCM  R4,7,TAPECCW+1     WRITE FROM TEXT\n         NI    DCBIFLGS,255-DCBIFEC   ENABLE ERP\n         OI    DCBIFLGS,X'40'     SUPPRESS DDR\n         STCM  R5,12,IOBSENS0-IOBSTDRD+TAPEIOB   CLEAR SENSE\n         OI    DCBOFLGS-IHADCB+TAPEDCB,DCBOFLWR  SHOW WRITE\n         XC    TAPEECB,TAPEECB\n         EXCP  TAPEIOB\n         WAIT  ECB=TAPEECB\n         TM    TAPEECB,X'7F'      GOOD COMPLETION?\n         BO    TRUNPOST\n*NEXT*   BNO   EXWRN7F            NO\n         SPACE 1\nEXWRN7F  TM    IOBUSTAT-IOBSTDRD+TAPEIOB,IOBUSB7  END OF TAPE?\n         BNZ   EXWREND       YES; SWITCH TAPES\n         CLC   =X'1020',IOBSENS0-IOBSTDRD+TAPEIOB  EXCEEDED AWS/HET ?\n         BNE   EXWRB001\nEXWREND  L     R15,DCBBLKCT\n         SH    R15,=H'1'\n         ST    R15,DCBBLKCT       ALLOW FOR EOF 'RECORD'\n         EOV   TAPEDCB       TRY TO RECOVER\n         B     EXCPWRIT\n         SPACE 1\nEXWRB001 LA    R9,TAPEIOB    GET IOB FOR QUICK REFERENCE\n         ABEND 001,DUMP\n         SPACE 1\nTRUNPOST XC    BUFFCURR,BUFFCURR  CLEAR\n         CLI   RECFMIX,4          RECFM=V\n         BL    TRUNCOEX           F - JUST EXIT\n         LA    R4,4               BUILD BDW\n         L     R3,BUFFADDR        GET BUFFER\n         STH   R4,0(,R3)          UPDATE\nTRUNCOEX L     R13,4(,R13)\n         LM    R14,R12,12(R13)    Reload all\n         QBSM  0,R14              Return in caller's mode\n         LTORG ,\n         POP   USING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETM - GET MEMORY                                                  *\n*                                                                     *\n***********************************************************************\n@@GETM   FUNHEAD ,\n*\n         LDINT R3,0(,R1)          LOAD REQUESTED STORAGE SIZE\n         SLR   R1,R1              PRESET IN CASE OF ERROR\n         LTR   R4,R3              CHECK REQUEST\n         BNP   GETMEX             QUIT IF INVALID\n*\n* To reduce fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(8+(64-1))    OVERHEAD PLUS ROUNDING\n         N     R3,=X'FFFFFFC0'    MULTIPLE OF 64\n*\n         AIF   ('&SYS' NE 'S380').NOANY\n         GETMAIN RU,LV=(R3),SP=SUBPOOL,LOC=ANY\n         AGO   .FINANY\n.NOANY   ANOP  ,\n         GETMAIN RU,LV=(R3),SP=SUBPOOL\n.FINANY  ANOP  ,\n*\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(,R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(,R1)\n         A     R1,=F'8'\n*\nGETMEX   FUNEXIT RC=(R1)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  FREEM - FREE MEMORY                                                *\n*                                                                     *\n***********************************************************************\n@@FREEM  FUNHEAD ,\n*\n         L     R1,0(,R1)\n         S     R1,=F'8'\n         L     R0,0(,R1)\n*\n         FREEMAIN RC,LV=(0),A=(1),SP=SUBPOOL\n*\n         FUNEXIT RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN   *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN    *\n*  ANY PARTICULAR WAY.                                                *\n*                                                                     *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                                *\n*                                                                     *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01  *\n*  BY USING SOME EMPIRICALLY-DERIVED MAGIC NUMBERS                    *\n*                                                                     *\n***********************************************************************\n@@GETCLK FUNHEAD ,                GET TOD CLOCK VALUE\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n*\nRETURNGC FUNEXIT RC=(R5)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*                                                                     *\n***********************************************************************\n* @@GETTZ FUNHEAD ,                 get timezone offset\n*\n*         L     R3,CVTPTR\n*         USING CVT,R3\n*         L     R4,CVTTZ\n*\n* RETURNGS FUNEXIT RC=(R4)\n*         LTORG ,\n         ENTRY @@GETTZ\n@@GETTZ  L     R15,CVTPTR\n         L     R15,CVTTZ-CVTMAP(,R15)  GET GMT TIME-ZONE OFFSET\n         BR    R14\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    CALL @@SYSTEM,(req-type,pgm-len,pgm-name,parm-len,parm),VL       *\n*                                                                     *\n*    \"-len\" fields are self-defining values in the calling list,      *\n*        or else pointers to 32-bit signed integer values             *\n*                                                                     *\n*    \"pgm-name\" is the address of the name of the program to be       *\n*        executed (one to eight characters)                           *\n*                                                                     *\n*    \"parm\" is the address of a text string of length \"parm-len\",     *\n*        and may be zero to one hundred bytes (OS JCL limit)          *\n*                                                                     *\n*    \"req-type\" is or points to 1 for a program ATTACH                *\n*                               2 for TSO CP invocation               *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Author:  Gerhard Postpischil                                    *\n*                                                                     *\n*     This program is placed in the public domain.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Assembly: Any MVS or later assembler may be used.               *\n*        Requires SYS1.MACLIB. TSO CP support requires additional     *\n*        macros from SYS1.MODGEN (SYS1.AMODGEN in MVS).               *\n*        Intended to work in any 24 and 31-bit environment.           *\n*                                                                     *\n*     Linker/Binder: RENT,REFR,REUS                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*     Return codes:  when R15:0 R15:1-3 has return from program.      *\n*       R15 is 04806nnn  ATTACH failed                                *\n*       R15 is 1400000n  PARM list error: n= 1,2, or 3 (req/pgm/parm) *\n*       R15 is 80sss000 or 80000uuu Subtask ABENDED (SYS sss/User uuu)*\n*                                                                     *\n***********************************************************************\n@@SYSTEM FUNHEAD SAVE=(SYSATWRK,SYSATDLN,78)  ISSUE OS OR TSO COMMAND\n         L     R15,4(,R13)        GET CALLER'S SAVE AREA\n         LA    R11,16(,R15)       REMEMBER THE RETURN CODE ADDRESS\n         LR    R9,R1              SAVE PARAMETER LIST ADDRESS\n         SPACE 1\n         MVC   0(4,R11),=X'14000002'  PRESET FOR PARM ERROR\n         LDINT R4,0(,R9)          REQUEST TYPE\n         LDINT R5,4(,R9)          LENGTH OF PROGRAM NAME\n         L     R6,8(,R9)          -> PROGRAM NAME\n         LDINT R7,12(,R9)         LENGTH OF PARM\n         L     R8,16(,R9)         -> PARM TEXT\n         SPACE 1\n*   NOTE THAT THE CALLER IS EITHER COMPILER CODE, OR A COMPILER\n*   LIBRARY ROUTINE, SO WE DO MINIMAL VALIDITY CHECKING\n*\n*   EXAMINE PROGRAM NAME LENGTH AND STRING\n*\n         CH    R5,=H'8'           NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         SH    R5,=H'1'           LENGTH FOR EXECUTE\n         BM    SYSATEXT           NONE; OOPS\n         MVC   SYSATPGM(L'SYSATPGM+L'SYSATOTL+1),=CL11' '  PRE-BLANK\n         EX    R5,SYSAXPGM        MOVE PROGRAM NAME\n         CLC   SYSATPGM,=CL11' '  STILL BLANK ?\n         BE    SYSATEXT           YES; TOO BAD\n*   BRANCH AND PROCESS ACCORDING TO REQUEST TYPE\n*\n         MVI   3(R11),1           SET BAD REQUEST TYPE\n         CH    R4,=H'2'           CP PROGRAM ATTACH ?\n         BE    SYSATCP            YES\n         CH    R4,=H'1'           OS PROGRAM ATTACH ?\n         BNE   SYSATEXT           NO; HAVE ERROR CODE\n*   OS PROGRAM ATTACH - PREPARE PARM, ETC.\n*\n*   NOW LOOK AT PARM STRING\n         LTR   R7,R7              ANY LENGTH ?\n         BM    SYSATEXT           NO; OOPS\n         STH   R7,SYSATOTL        PASS LENGTH OF TEXT\n         BZ    SYSATNTX\n         CH    R7,=AL2(L'SYSATOTX)  NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         BCTR  R7,0\n         EX    R7,SYSAXTXT        MOVE PARM STRING\nSYSATNTX LA    R1,SYSATOTL        GET PARAMETER ADDRESS\n         ST    R1,SYSATPRM        SET IT\n         OI    SYSATPRM,X'80'     SET END OF LIST BIT\n         B     SYSATCOM           GO TO COMMON ATTACH ROUTINE\n*   TSO CP REQUEST - PREPARE PARM, CPPL, ETC.\n*\nSYSATCP  LTR   R7,R7              ANY LENGTH ?\n         BM    SYSATEXT           NO; OOPS\n         LA    R1,SYSATOTX-SYSATOPL(,R7)  LENGTH WITH HEADER\n         STH   R1,SYSATOPL        PASS LENGTH OF COMMAND TEXT\n         LA    R1,1(,R5)          BYTE AFTER COMMAND NAME\n         STH   R1,SYSATOPL+2      LENGTH PROCESSED BY PARSER\n         BZ    SYSATXNO\n         CH    R7,=AL2(L'SYSATOTX)  NOT TOO LONG ?\n         BH    SYSATEXT           TOO LONG; TOO BAD\n         BCTR  R7,0\n         EX    R7,SYSAXTXT        MOVE PARM STRING\nSYSATXNO LA    R1,SYSATOPL        GET PARAMETER ADDRESS\n         ST    R1,SYSATPRM        SET IT\n*   TO MAKE THIS WORK, WE NEED THE UPT, PSCB, AND ECT ADDRESS.\n*   THE FOLLOWING CODE WORKS PROVIDED THE CALLER WAS INVOKED AS A\n*   TSO CP, USED NORMAL SAVE AREA CONVENTIONS, AND HASN'T MESSED WITH\n*   THE TOP SAVE AREA.\n         MVI   3(R11),4           SET ERROR FOR BAD CP REQUEST\n         LA    R2,SYSATPRM+8      CPPLPSCB\n         EXTRACT (R2),FIELDS=PSB  GET THE PSCB\n         PUSH  USING\n         L     R1,PSATOLD-PSA     GET THE CURRENT TCB\n         USING TCB,R1\n         L     R1,TCBFSA          GET THE TOP LEVEL SAVE AREA\n         N     R1,=X'00FFFFFF'    KILL TCBIDF BYTE\n         POP   USING\n         L     R1,24(,R1)         ORIGINAL R1\n         LA    R1,0(,R1)            CLEAN IT\n         LTR   R1,R1              ANY?\n         BZ    SYSATEXT           NO; TOO BAD\n         TM    0(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         TM    4(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         TM    8(R1),X'80'        END OF LIST?\n         BNZ   SYSATEXT           YES; NOT CPPL\n         CLC   8(4,R1),SYSATPRM+8   MATCHES PSCB FROM EXTRACT?\n         BNE   SYSATEXT           NO; TOO BAD\n         MVC   SYSATPRM+4(3*4),4(R1)  COPY UPT, PSCB, ECT\n         L     R1,12(,R1)\n         LA    R1,0(,R1)     CLEAR EOL BIT IN EITHER AMODE\n         LTR   R1,R1         ANY ADDRESS?\n         BZ    SYSATCOM      NO; SKIP\n         PUSH  USING         (FOR LATER ADDITIONS?)\n         USING ECT,R1        DECLARE ECT\n         LM    R14,R15,SYSATPGM   GET COMMAND NAME\n         LA    R0,7          MAX TEST/SHIFT\nSYSATLCM CLM   R14,8,=CL11' '  LEADING BLANK ?\n         BNE   SYSATLSV      NO; SET COMMAND NAME\n         SLDL  R14,8         ELIMINATE LEADING BLANK\n         IC    R15,=CL11' '  REPLACE BY TRAILING BLANK\n         BCT   R0,SYSATLCM   TRY AGAIN\nSYSATLSV STM   R14,R15,ECTPCMD\n         NI    ECTSWS,255-ECTNOPD      SET FOR OPERANDS EXIST\n         EX    R7,SYSAXBLK   SEE IF ANY OPERANDS\n         BNE   SYSATCOM           HAVE SOMETHING\n         OI    ECTSWS,ECTNOPD     ALL BLANK\n         POP   USING\nSYSATCOM LA    R1,SYSATPRM        PASS ADDRESS OF PARM ADDRESS\n         LA    R2,SYSATPGM        POINT TO NAME\n         LA    R3,SYSATECB        AND ECB\n         ATTACH EPLOC=(R2),       INVOKE THE REQUESTED PROGRAM         *\n               ECB=(R3),SF=(E,SYSATLST)  SZERO=NO,SHSPV=78\n         LTR   R15,R15            CHECK RETURN CODE\n         BZ    SYSATWET           GOOD\n         MVC   0(4,R11),=X'04806000'  ATTACH FAILED\n         STC   R15,3(,R11)        SET ERROR CODE\n         B     SYSATEXT           FAIL\nSYSATWET ST    R1,SYSATTCB        SAVE FOR DETACH\n         WAIT  ECB=SYSATECB       WAIT FOR IT TO FINISH\n         L     R2,SYSATTCB        GET SUBTASK TCB\n         USING TCB,R2             DECLARE IT\n         MVC   0(4,R11),TCBCMP    COPY RETURN OR ABEND CODE\n         TM    TCBFLGS,TCBFA      ABENDED ?\n         BZ    *+8                NO\n         MVI   0(R11),X'80'       SET ABEND FLAG\n         DETACH SYSATTCB          GET RID OF SUBTASK\n         DROP  R2\n         B     SYSATEXT           AND RETURN\nSYSAXPGM OC    SYSATPGM(0),0(R6)  MOVE NAME AND UPPER CASE\nSYSAXTXT MVC   SYSATOTX(0),0(R8)    MOVE PARM TEXT\nSYSAXBLK CLC   SYSATOTX(0),SYSATOTX-1  TEST FOR OPERANDS\n*    PROGRAM EXIT, WITH APPROPRIATE RETURN CODES\n*\nSYSATEXT FUNEXIT ,           RESTORE REGS; SET RETURN CODES\n         SPACE 1             RETURN TO CALLER\n*    DYNAMICALLY ACQUIRED STORAGE\n*\nSYSATWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nSYSATCLR DS    0F            START OF CLEARED AREA\nSYSATLST ATTACH EPLOC=SYSATPGM,ECB=SYSATECB,SHSPV=78,SZERO=NO,SF=L\nSYSATECB DS    F             EVENT CONTROL FOR SUBTASK\nSYSATTCB DS    A             ATTACH TOKEN FOR CLEAN-UP\nSYSATPRM DS    4A            PREFIX FOR CP\nSYSATOPL DS    2Y     1/4    PARM LENGTH / LENGTH SCANNED\nSYSATPGM DS    CL8    2/4    PROGRAM NAME (SEPARATOR)\nSYSATOTL DS    Y      3/4    OS PARM LENGTH / BLANKS FOR CP CALL\nSYSATZER EQU   SYSATCLR,*-SYSATCLR,C'X'   ADDRESS & SIZE TO CLEAR\nSYSATOTX DS    CL247  4/4    NORMAL PARM TEXT STRING\nSYSATDLN EQU   *-SYSATWRK     LENGTH OF DYNAMIC STORAGE\n         CSECT ,             RESTORE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    INVOKE IDCAMS: CALL @@IDCAMS,(@LEN,@TEXT)                        *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n@@IDCAMS FUNHEAD SAVE=IDCSAVE     EXECUTE IDCAMS REQUEST\n         LA    R1,0(,R1)          ADDRESS OF IDCAMS REQUEST (V-CON)\n         ST    R1,IDC@REQ         SAVE REQUEST ADDRESS\n         MVI   EXFLAGS,0          INITIALIZE FLAGS\n         LA    R1,AMSPARM         PASS PARAMETER LIST\n         LINK  EP=IDCAMS          INVOKE UTILITY\n         FUNEXIT RC=(15)          RESTORE CALLER'S REGS\n         POP   USING\n         SPACE 1\n***********************************************************************\n*                                                                     *\n* XIDCAMS - ASYNCHRONOUS EXIT ROUTINE                                 *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\nXIDCAMS  STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING XIDCAMS,R12\n         LA    R9,XIDSAVE         SET MY SAVE AREA\n         ST    R13,4(,R9)         MAKE BACK LINK\n         ST    R9,8(,R13)         MAKE DOWN LINK\n         LR    R13,R9             MAKE ACTIVE SAVE AREA\n         SR    R15,R15            PRESET FOR GOOD RETURN\n         LM    R3,R5,0(R1)        LOAD PARM LIST ADDRESSES\n         SLR   R14,R14\n         IC    R14,0(,R4)         LOAD FUNCTION\n         B     *+4(R14)\n         B     XIDCEXIT   OPEN           CODE IN R14 = X'00'\n         B     XIDCEXIT   CLOSE          CODE IN R14 = X'04'\n         B     XIDCGET    GET SYSIN      CODE IN R14 = X'08'\n         B     XIDCPUT    PUT SYSPRINT   CODE IN R14 = X'0C'\nXIDCGET  TM    EXFLAGS,EXFGET            X'01' = PRIOR GET ISSUED ?\n         BNZ   XIDCGET4                  YES, SET RET CODE = 04\n         L     R1,IDC@REQ         GET REQUEST ADDRESS\n         LDINT R3,0(,R1)          LOAD LENGTH\n         L     R2,4(,R1)          LOAD TEXT POINTER\n         LA    R2,0(,R2)          CLEAR HIGH\n         STM   R2,R3,0(R5)        PLACE INTO IDCAMS LIST\n         OI    EXFLAGS,EXFGET            X'01' = A GET HAS BEEN ISSUED\n         B     XIDCEXIT\nXIDCGET4 LA    R15,4                     SET REG 15 = X'00000004'\n         B     XIDCEXIT\nXIDCPUT  TM    EXFLAGS,EXFSUPP+EXFSKIP  ANY FORM OF SUPPRESSION?\n         BNZ   XIDCPUTZ           YES; DON'T BOTHER WITH REST\n         LM    R4,R5,0(R5)\n         LA    R4,1(,R4)          SKIP CARRIAGE CONTROL CHARACTER\n         BCTR  R5,0               FIX LENGTH\n         ICM   R5,8,=C' '         BLANK FILL\n         LA    R14,XIDCTEXT\n         LA    R15,L'XIDCTEXT\n         MVCL  R14,R4\n         TM    EXFLAGS,EXFMALL    PRINT ALL MESSAGES?\n         BNZ   XIDCSHOW           YES; PUT THEM ALL OUT\n         CLC   =C'IDCAMS ',XIDCTEXT    IDCAMS TITLE ?\n         BE    XIDCEXIT           YES; SKIP\n         CLC   XIDCTEXT+1(L'XIDCTEXT-1),XIDCTEXT   ALL BLANK OR SOME?\n         BE    XIDCEXIT           YES; SKIP\n         CLC   =C'IDC0002I',XIDCTEXT   AMS PGM END\n         BE    XIDCEXIT           YES; SKIP\nXIDCSHOW DS    0H\n*DEBUG*  WTO   MF=(E,AMSPRINT)    SHOW MESSAGE\nXIDCPUTZ SR    R15,R15\n         B     XIDCEXIT\nXIDCSKIP OI    EXFLAGS,EXFSKIP    SKIP THIS AND REMAINING MESSAGES\n         SR    R15,R15\n*---------------------------------------------------------------------*\n* IDCAMS ASYNC EXIT ROUTINE - EXIT, CONSTANTS & WORKAREAS\n*---------------------------------------------------------------------*\nXIDCEXIT L     R13,4(,R13)        GET CALLER'S SAVE AREA\n         L     R14,12(,R13)\n         RETURN (0,12)            RESTORE AND RETURN TO IDCAMS\nIDCSAVE  DC    18F'0'             MAIN ROUTINE'S REG SAVEAREA\nXIDSAVE  DC    18F'0'             ASYNC ROUTINE'S REG SAVEAREA\nAMSPRINT DC    0A(0),AL2(4+L'XIDCTEXT,0)\nXIDCTEXT DC    CL132' '\nAMSPARM  DC    A(HALF00,HALF00,HALF00,X'80000000'+ADDRLIST)\nADDRLIST DC    F'2'\n         DC    A(DDNAME01)\n         DC    A(XIDCAMS)\nIDC@REQ  DC    A(0)               ADDRESS OF REQUEST POINTER\n         DC    A(DDNAME02)\n         DC    A(XIDCAMS)\n         DC    A(0)\nHALF00   DC    H'0'\nDDNAME01 DC    CL10'DDSYSIN   '\nDDNAME02 DC    CL10'DDSYSPRINT'\nEXFLAGS  DC    X'08'              EXIT PROCESSING FLAGS\nEXFGET   EQU   X'01'                PRIOR GET WAS ISSUED\nEXFNOM   EQU   X'04'                SUPPRESS ERROR WTOS\nEXFRET   EQU   X'08'                NO ABEND; RETURN WITH COND.CODE\nEXFMALL  EQU   X'10'                ALWAYS PRINT MESSAGES\nEXFSUPP  EQU   X'20'                ALWAYS SUPPRESS MESSAGES\nEXFSKIP  EQU   X'40'                SKIP SUBSEQUENT MESSAGES\nEXFGLOB  EQU   EXFMALL+EXFSUPP+EXFRET  GLOBAL FLAGS\n         POP   USING\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*    CALL @@DYNAL,(ddn-len,ddn-adr,dsn-len,dsn-adr),VL                *\n*                                                                     *\n*    \"-len\" fields are self-defining values in the calling list,      *\n*        or else pointers to 32-bit signed integer values             *\n*                                                                     *\n*    \"ddn-adr\"  is the address of the DD name to be used. When the    *\n*        contents is hex zero or blank, and len=8, gets assigned.     *\n*                                                                     *\n*    \"dsn-adr\" is the address of a 1 to 44 byte data set name of an   *\n*        existing file (sequential or partitioned).                   *\n*                                                                     *\n*    Calling @@DYNAL with a DDNAME and a zero length for the DSN      *\n*    results in unallocation of that DD (and a PARM error).           *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Author:  Gerhard Postpischil                                    *\n*                                                                     *\n*     This program is placed in the public domain.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*     Assembly: Any MVS or later assembler may be used.               *\n*        Requires SYS1.MACLIB                                         *\n*        Intended to work in any 24 and 31-bit environment.           *\n*                                                                     *\n*     Linker/Binder: RENT,REFR,REUS                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*     Return codes:  R15:04sssnnn   it's a program error code:        *\n*     04804 - GETMAIN failed;  1400000n   PARM list error             *\n*                                                                     *\n*     Otherwise R15:0-1  the primary allocation return code, and      *\n*       R15:2-3 the reason codes.                                     *\n***********************************************************************\n*  Maintenance:                                     new on 2008-06-07 *\n*                                                                     *\n***********************************************************************\n@@DYNAL  FUNHEAD ,                DYNAMIC ALLOCATION\n         LA    R11,16(,R13)       REMEMBER RETURN CODE ADDRESS\n         MVC   0(4,R11),=X'04804000'  PRESET\n         LR    R9,R1              SAVE PARAMETER LIST ADDRESS\n         LA    R0,DYNALDLN        GET LENGTH OF SAVE AND WORK AREA\n         GETMAIN RC,LV=(0)        GET STORAGE\n         LTR   R15,R15            SUCCESSFUL ?\n         BZ    DYNALHAV           YES\n         STC   R15,3(,R11)        SET RETURN VALUES\n         B     DYNALRET           RELOAD AND RETURN\n*\n*    CLEAR GOTTEN STORAGE AND ESTABLISH SAVE AREA\n*\nDYNALHAV ST    R1,8(,R13)         LINK OURS TO CALLER'S SAVE AREA\n         ST    R13,4(,R1)         LINK CALLER'S TO OUR AREA\n         LR    R13,R1\n         USING DYNALWRK,R13\n         MVC   0(4,R11),=X'14000001'  PRESET FOR PARM LIST ERROR\n         MVC   DYNLIST(ALLDYNLN),PATLIST  INITIALIZE EVERYTHING\n         LDINT R4,0(,R9)          DD NAME LENGTH\n         L     R5,4(,R9)          -> DD NAME\n         LDINT R6,8(,R9)          DSN LENGTH\n         L     R7,12(,R9)         -> DATA SET NAME\n*   NOTE THAT THE CALLER IS EITHER COMPILER CODE, OR A COMPILER\n*   LIBRARY ROUTINE, SO WE DO MINIMAL VALIDITY CHECKING\n*\n*   PREPARE DYNAMIC ALLOCATION REQUEST LISTS\n*\n         LA    R0,ALLARB\n         STCM  R0,7,ALLARBP+1     REQUEST POINTER\n         LA    R0,ALLATXTP\n         ST    R0,ALLARB+8        TEXT UNIT POINTER\n         LA    R0,ALLAXDSN\n         LA    R1,ALLAXDSP\n         LA    R2,ALLAXDDN\n         O     R2,=X'80000000'\n         STM   R0,R2,ALLATXTP     TEXT UNIT ADDRESSES\n*   COMPLETE REQUEST WITH CALLER'S DATA\n*\n         LTR   R4,R4              CHECK DDN LENGTH\n         BNP   DYNALEXT           OOPS\n         CH    R4,=AL2(L'ALLADDN)   REASONABLE SIZE ?\n         BH    DYNALEXT           NO\n         BCTR  R4,0\n         EX    R4,DYNAXDDN        MOVE DD NAME\n         OC    ALLADDN,=CL11' '   CONVERT HEX ZEROES TO BLANKS\n         CLC   ALLADDN,=CL11' '   NAME SUPPLIED ?\n         BNE   DYNALDDN           YES\n         MVI   ALLAXDDN+1,DALRTDDN  REQUEST RETURN OF DD NAME\n         CH    R4,=AL2(L'ALLADDN-1)   CORRECT SIZE FOR RETURN ?\n         BE    DYNALNDD           AND LEAVE R5 NON-ZERO\n         B     DYNALEXT           NO\nDYNALDDN SR    R5,R5              SIGNAL NO FEEDBACK\n*  WHEN USER SUPPLIES A DD NAME, DO AN UNCONDITIONAL UNALLOCATE ON IT\n         LA    R0,ALLURB\n         STCM  R0,7,ALLURBP+1     REQUEST POINTER\n         LA    R0,ALLUTXTP\n         ST    R0,ALLURB+8        TEXT UNIT POINTER\n         LA    R2,ALLUXDDN\n         O     R2,=X'80000000'\n         ST    R2,ALLUTXTP        TEXT UNIT ADDRESS\n         MVC   ALLUDDN,ALLADDN    SET DD NAME\n         LA    R1,ALLURBP         POINT TO REQUEST BLOCK POINTER\n         DYNALLOC ,               REQUEST ALLOCATION\nDYNALNDD LTR   R6,R6              CHECK DSN LENGTH\n         BNP   DYNALEXT           OOPS\n         CH    R6,=AL2(L'ALLADSN)   REASONABLE SIZE ?\n         BH    DYNALEXT           NO\n         STH   R6,ALLADSN-2       SET LENGTH INTO TEXT UNIT\n         BCTR  R6,0\n         EX    R6,DYNAXDSN        MOVE DS NAME\n*    ALLOCATE\n         LA    R1,ALLARBP         POINT TO REQUEST BLOCK POINTER\n         DYNALLOC ,               REQUEST ALLOCATION\n         STH   R15,0(,R11)        PRIMARY RETURN CODE\n         STH   R0,2(,R11)         REASON CODES\n         LTR   R5,R5              NEED TO RETURN DDN ?\n         BZ    DYNALEXT           NO\n         MVC   0(8,R5),ALLADDN    RETURN NEW DDN, IF ANY\n         B     DYNALEXT           AND RETURN\nDYNAXDDN MVC   ALLADDN(0),0(R5)   COPY DD NAME\nDYNAXDSN MVC   ALLADSN(0),0(R7)   COPY DATA SET NAME\n*    PROGRAM EXIT, WITH APPROPRIATE RETURN CODES\n*\nDYNALEXT LR    R1,R13        COPY STORAGE ADDRESS\n         L     R9,4(,R13)    GET CALLER'S SAVE AREA\n         LA    R0,DYNALDLN   GET ORIGINAL LENGTH\n         FREEMAIN R,A=(1),LV=(0)  AND RELEASE THE STORAGE\n         LR    R13,R9        RESTORE CALLER'S SAVE AREA\nDYNALRET FUNEXIT ,           RESTORE REGS; SET RETURN CODES\n         LTORG ,\n         PUSH  PRINT\n         PRINT NOGEN         DON'T NEED TWO COPIES\nPATLIST  DYNPAT P=PAT        EXPAND ALLOCATION DATA\n         POP   PRINT\n*    DYNAMICALLY ACQUIRED STORAGE\n*\nDYNALWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nDYNLIST  DYNPAT P=ALL        EXPAND ALLOCATION DATA\nDYNALDLN EQU   *-DYNALWRK     LENGTH OF DYNAMIC STORAGE\n         CSECT ,             RESTORE\n         SPACE 2\n*\n***********************************************************************\n*                                                                     *\n*  CALL @@SVC99,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         SAVE  (14,12),,@@SVC99   Save caller's regs.\n         LR    R12,R15\n         USING @@SVC99,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(R1)\n         O     R2,=X'80000000'\n         ST    R2,0(R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12\n         POP   USING\n*\n*\n* Keep this code last because it makes no difference - no USINGs\n*\n***********************************************************************\n*                                                                     *\n*  SETJ - SAVE REGISTERS INTO ENV                                     *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETJ\n@@SETJ   L     R15,0(,R1)         get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                 *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LONGJ\n@@LONGJ  L     R2,0(,R1)          get the env variable\n         L     R15,60(,R2)        get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         SPACE 2\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&SYS' EQ 'S370').NOMODE  If S/370 we can't switch mode\n         PUSH  USING\n         DROP  ,\n***********************************************************************\n*                                                                     *\n*  SETM24 - Set AMODE to 24                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 LA    R14,0(,R14)        Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n         POP   USING\n         SPACE 1\n         PUSH  USING\n         DROP  ,\n***********************************************************************\n*                                                                     *\n*  SETM31 - Set AMODE to 31                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Clobber entire high byte of R14\n*                                 This is necessary because if people\n*                                 use BALR in 24-bit mode, the address\n*                                 will have rubbish in the high byte.\n*                                 People switching between 24-bit and\n*                                 31-bit will be RMODE 24 anyway, so\n*                                 there is nothing to preserve in the\n*                                 high byte.\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n         POP   USING\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\n***********************************************************************\n***********************************************************************\n*                                                                     *\n* End of functions, start of data areas                               *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n         SPACE 2\n*\n***********************************************************************\n*                                                                     *\n*  The work area includes both a register save area and various       *\n*  variables used by the different routines.                          *\n*                                                                     *\n***********************************************************************\nWORKAREA DSECT\nSAVEAREA DS    18F\nDWORK    DS    D                  Extra work space\nWWORK    DS    D                  Extra work space\nDWDDNAM  DS    D                  Extra work space\nWORKLEN  EQU   *-WORKAREA\nJFCB     DS    0F\n         IEFJFCBN LIST=YES        Job File Control Block\nCAMLST   DS    XL(CAMLEN)         CAMLST for OBTAIN to get VTOC entry\n* Format 1 Data Set Control Block\n*   N.B. Current program logic does not use DS1DSNAM, leaving 44 bytes\n*     of available space\n         IECSDSL1 1               Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\nOPENLEN  EQU   *-WORKAREA         Length for @@AOPEN processing\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* ZDCBAREA - the address of this memory is used by the C caller       *\n* as a \"handle\". The block of memory has different contents depending *\n* on what sort of file is being opened, but it will be whatever the   *\n* assembler code is expecting, and the caller merely needs to         *\n* provide the handle (returned from AOPEN) in subsequent calls so     *\n* that the assembler can keep track of things.                        *\n*                                                                     *\n*   FILE ACCESS CONTROL BLOCK (N.B.-STARTS WITH DCBD DUE TO DSECT)    *\n*   CONTAINS DCB, DECB, JFCB, DSCB 1, BUFFER POINTERS, FLAGS, ETC.    *\n*                                                                     *\n***********************************************************************\n         DCBD  DSORG=PS,DEVD=(DA,TA)   Map Data Control Block\n         ORG   IHADCB             Overlay the DCB DSECT\nZDCBAREA DS    0H\n         DS    CL(BSAMDCBN)\n         READ  DECB,SF,IHADCB,2-2,3-3,MF=L  READ/WRITE BSAM\n         ORG   IHADCB             Only using one DCB\n         DS    CL(QSAMDCBL)         so overlay this one\n         ORG   IHADCB             Only using one DCB\nTAPEDCB  DCB   DDNAME=TAPE,MACRF=E,DSORG=PS,REPOS=Y,BLKSIZE=0,         *\n               DEVD=TA                 LARGE SIZE\n         ORG   TAPEDCB+84    LEAVE ROOM FOR DCBLRECL\nZXCPVOLS DC    F'0'          VOLUME COUNT\nTAPECCW  CCW   1,3-3,X'40',4-4\n         CCW   3,3-3,X'20',1\nTAPEXLEN EQU   *-TAPEDCB     PATTERN TO MOVE\nTAPEECB  DC    A(0)\nTAPEIOB  DC    X'42,00,00,00'\n         DC    A(TAPEECB)\n         DC    2A(0)\n         DC    A(TAPECCW)\n         DC    A(TAPEDCB)\n         DC    2A(0)\n         SPACE 1\n         ORG   IHADCB\nZPUTLINE PUTLINE MF=L        PATTERN FOR TERMINAL I/O\n*DSECT*  IKJIOPL ,\n         SPACE 1\nZIOPL    DS    0A            MANUAL EXPANSION TO AVOID DSECT\nIOPLUPT  DS    A        PTR TO UPT\nIOPLECT  DS    A        PTR TO ECT\nIOPLECB  DS    A        PTR TO USER'S ECB\nIOPLIOPB DS    A        PTR TO THE I/O SERVICE RTN PARM BLOCK\nZIOECB   DS    A                   TPUT ECB\nZIOECT   DS    A                   ORIGINATING ECT\nZIOUPT   DS    A                   UPT\nZIODDNM  DS    CL8      DD NAME AT OFFSET X'28' FOR DCB COMPAT.\nZGETLINE GETLINE MF=L             TWO WORD GTPB\n         ORG   ,\nOPENCLOS DS    A                  OPEN/CLOSE parameter list\nDCBXLST  DS    2A                 07 JFCB / 85 DCB EXIT\nEOFR24   DS    CL(EOFRLEN)\n         AIF   ('&SYS' EQ 'S370').NOD24  If S/370, no 24-bit OPEN exit\n         DS    0H\nDOPE24   DS    CL(DOPELEN)        DCB open 24-bit code\nDOPE31   DS    A                  Address of DCB open exit\n.NOD24   ANOP  ,\nZBUFF1   DS    A,F                Address, length of buffer\nZBUFF2   DS    A,F                Address, length of 2nd buffer\nKEPTREC  DS    A,F                Address & length of saved rcd\n*\nBLKSIZE  DS    F                  Save area for input DCB BLKSIZE\nLRECL    DS    F                  Save area for input DCB LRECL\nBUFFADDR DS    A     1/3          Location of the BLOCK Buffer\nBUFFCURR DS    A     2/3          Current record in the buffer\nBUFFEND  DS    A     3/3          Address after end of current block\nVBSADDR  DS    A                  Location of the VBS record build area\nVBSEND   DS    A                  Addr. after end VBS record build area\n         SPACE 1\nZWORK    DS    D             Below the line work storage\nDEVINFO  DS    2F                 UCB Type / Max block size\nMEMBER24 DS    CL8\nRECFMIX  DS    X             Record format index: 0-F 4-V 8-U\nIOMFLAGS DS    X             Remember open MODE\nIOFOUT   EQU   X'01'           Output mode\nIOFEXCP  EQU   X'08'           Use EXCP for TAPE\nIOFBLOCK EQU   X'10'           Using BSAM READ/WRITE mode\nIOFUREC  EQU   X'40'           DEVICE IS UNIT RECORD\nIOFTERM  EQU   X'80'           Using GETLINE/PUTLINE\nIOPFLAGS DS    X             Remember prior events\nIOFKEPT  EQU   X'01'           Record info kept\nIOFCONCT EQU   X'02'           Reread - unlike concatenation\nIOFDCBEX EQU   X'04'           DCB exit entered\nIOFCURSE EQU   X'08'           Write buffer recursion\nIOFLIOWR EQU   X'10'           Last I/O was Write type\nIOFLDATA EQU   X'20'           Output buffer has data\nIOFLSDW  EQU   X'40'           Spanned record incomplete\nIOFLEOF  EQU   X'80'           Encountered an End-of-File\nFILEMODE DS    X             AOPEN requested record format dftl\nFMFIX    EQU   0               Fixed RECFM (blocked)\nFMVAR    EQU   1               Variable (blocked)\nFMUND    EQU   2               Undefined\nZRECFM   DS    X             Equivalent RECFM bits\nZIOSAVE2 DS    18F           Save area for physical write\nSAVEADCB DS    18F                Register save area for PUT\nZDCBLEN  EQU   *-ZDCBAREA\n*\n* End of handle/DCB area\n*\n*\n*\n         SPACE 2\n         PRINT NOGEN\n         IHAPSA ,            MAP LOW STORAGE\n         CVT DSECT=YES\n         IKJTCB ,            MAP TASK CONTROL BLOCK\n         IKJECT ,            MAP ENV. CONTROL BLOCK\n         IKJPTPB ,           PUTLINE PARAMETER BLOCK\n         IKJCPPL ,\n         IKJPSCB ,\n         IEZJSCB ,\n         IEZIOB ,\n         IEFZB4D0 ,          MAP SVC 99 PARAMETER LIST\n         IEFZB4D2 ,          MAP SVC 99 PARAMETERS\n         IEFUCBOB ,\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSUNZIP": {"ttr": 1798, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards                             */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  mvsunzip - unzip files compressed with -0                        */\n/*  e.g. mvsunzip pdpclib.czip pdpclib.c                             */\n/*  or on cms, just \"mvsunzip pdpclib.czip\".                         */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#define MAXBUF 2000000L\n\nstatic void usage(void);\nstatic int onefile(FILE *infile);\nstatic char *ascii2l(char *buf);\nstatic int fasc(int asc);\nstatic int ins_strcmp(char *one, char *two);\n\n/* for MVS, pdsn is the optional PDS name. */\n#ifdef __MVS__\nstatic char *pdsn = NULL;\n#endif\nstatic int binary = 0;\n#ifdef __CMS__\nstatic int disk = '\\0';\n#endif\n#ifdef __VSE__\n/* this is required for VSE */\nstatic char *outdd = NULL;\nstatic char *zipm = NULL;\n#endif\n\nint main(int argc, char **argv)\n{\n    FILE *infile;\n    int aupto = 2;\n\n    if (argc <= 1) usage();\n\n/* check to see if we have a CMS minidisk provided */\n#ifdef __CMS__\n    if (argc > aupto)\n    {\n        if (strlen(argv\u00ddaupto\u00a8) == 1)\n        {\n            disk = argv\u00ddaupto\u00a8\u00dd0\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* VSE requires an output DDNAME, even for library output */\n#ifdef __VSE__\n    if (argc > aupto)\n    {\n        outdd = argv\u00ddaupto++\u00a8;\n    }\n    else\n    {\n        usage();\n    }\n#endif\n\n/* MVS has an optional pds for output */\n#ifdef __MVS__\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") != 0)\n        {\n            pdsn = argv\u00ddaupto\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* VSE may request just a single file - should probably enable\n   for other systems too */\n#ifdef __VSE__\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") != 0)\n        {\n            zipm = argv\u00ddaupto\u00a8;\n            aupto++;\n        }\n    }\n#endif\n\n/* all systems - see if this is a binary file */\n    if (argc > aupto)\n    {\n        if (ins_strcmp(argv\u00ddaupto\u00a8, \"binary\") == 0)\n        {\n            binary = 1;\n            aupto++;\n        }\n    }\n\n    if (argc > aupto) usage();\n\n    printf(\"processing data from %s\\n\", *(argv + 1));\n    infile = fopen(*(argv+1), \"rb\");\n    if (infile == NULL)\n    {\n       printf(\"Open Failed code %d\\n\", errno);\n       return (EXIT_FAILURE);\n    }\n    while (onefile(infile)) ;\n    return (0);\n}\n\nstatic void usage(void)\n{\n#if defined(__CMS__)\n    printf(\"usage: mvsunzip <infile> \u00dddisk\u00a8 \u00ddBINARY\u00a8\\n\");\n    printf(\"where infile is a sequential file\\n\");\n    printf(\"e.g. mvsunzip dd:input\\n\");\n#elif defined(__VSE__)\n    printf(\"usage: mvsunzip <infile> <outdd> \u00ddfile\u00a8 \u00ddbinary\u00a8\\n\");\n    printf(\"where outdd can be either a sequential file or library\\n\");\n    printf(\"and file is the name of the file in the zip archive\\n\");\n#else\n    printf(\"usage: mvsunzip <infile> \u00ddoutpds\u00a8 \u00ddbinary\u00a8\\n\");\n    printf(\"where infile is a sequential file\\n\");\n    printf(\"and outpds is a PDS (not supported on all systems)\\n\");\n    printf(\"e.g. mvsunzip dd:input dd:output\\n\");\n#endif\n    exit(EXIT_FAILURE);\n}\n\nstatic int onefile(FILE *infile)\n{\n    int c;\n    int x;\n    long size;\n    long size2;\n    int fnmlen;\n    char fnm\u00ddFILENAME_MAX\u00a8;\n    static char *buf = NULL;\n    char newfnm\u00ddFILENAME_MAX\u00a8;\n    FILE *newf;\n    int extra;\n    char *p;\n    int skip = 0;\n\n    if (buf == NULL)\n    {\n        buf = malloc(MAXBUF);\n        if (buf == NULL)\n        {\n            printf(\"out of memory error\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    if (fgetc(infile) != 0x50)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x4b)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x03)\n    {\n        return (0);\n    }\n    if (fgetc(infile) != 0x04)\n    {\n        return (0);\n    }\n    for (x = 0; x < 14; x++)\n    {\n        fgetc(infile);\n    }\n    c = fgetc(infile);\n    size = c;\n    c = fgetc(infile);\n    size = (c << 8) | size;\n    c = fgetc(infile);\n    size = (c << 16) | size;\n    c = fgetc(infile);\n    size = (c << 24) | size;\n    if ((size > MAXBUF) && !binary)\n    {\n        printf(\"warning - file is too big (%d) at pos %d - ending early\\n\",\n               size, ftell(infile));\n        return (0);\n    }\n    c = fgetc(infile);\n    size2 = c;\n    c = fgetc(infile);\n    size2 = (c << 8) | size2;\n    c = fgetc(infile);\n    size2 = (c << 16) | size2;\n    c = fgetc(infile);\n    size2 = (c << 24) | size2;\n    if (size != size2)\n    {\n        printf(\"warning - compressed file found - ending early\\n\");\n        return (0);\n    }\n    c = fgetc(infile);\n    fnmlen = c;\n    c = fgetc(infile);\n    fnmlen = (c << 8) | fnmlen;\n    c = fgetc(infile);\n    extra = c;\n    c = fgetc(infile);\n    extra = (c << 8) | extra;\n    if (fnmlen == 0) return (0);\n    fread(fnm, fnmlen, 1, infile);\n    fnm\u00ddfnmlen\u00a8 = '\\0';\n    fread(buf, extra, 1, infile);\n    ascii2l(fnm);\n    printf(\"fnm is %s\\n\", fnm);\n    if (!binary)\n    {\n        fread(buf, size, 1, infile);\n        buf\u00ddsize\u00a8 = '\\0';\n    }\n    p = strrchr(fnm, '/');\n    if (p != NULL)\n    {\n        p++;\n    }\n    else\n    {\n        p = fnm;\n    }\n\n    if (strrchr(p, '\\\\') != NULL)\n    {\n        p = strrchr(p, '\\\\') + 1;\n    }\n\n#if defined(__VSE__)\n    if (zipm != NULL)\n    {\n        if (ins_strcmp(p, zipm) != 0)\n        {\n            if (!binary) return (1);\n            for (x = 0; x < size; x += MAXBUF)\n            {\n                size_t y;\n\n                y = size - x;\n                if (y > MAXBUF)\n                {\n                    y = MAXBUF;\n                }\n                fread(buf, y, 1, infile);\n            }\n            return (1); /* skip this file */\n        }\n    }\n#endif\n\n/* for MVS, if no PDS name was provided, we use the zip member\n   unchanged, via dynamic allocation. Otherwise, needs to be mangled.\n   for VSE, we do not have dynamic allocation, and always have\n   an output DD. But we only need to construct a member\n   of a library when we have no zip member requested */\n\n#if defined(__MVS__)\n    if (pdsn != NULL)\n#elif defined(__VSE__)\n    if (zipm == NULL)\n#else\n    if (0)\n#endif\n    {\n        if (strchr(p, '.') != NULL) *strchr(p, '.') = '\\0';\n        while (strchr(p, '-') != NULL) *strchr(p, '-') = '@';\n        while (strchr(p, '_') != NULL) *strchr(p, '_') = '@';\n    }\n\n#if defined(__CMS__)\n    if (strchr(p, '.') != NULL) *strchr(p, '.') = ' ';\n    if (disk != '\\0')\n    {\n        if (strchr(p, ' ') != NULL)\n        {\n            sprintf(newfnm, \"%s %c\", p, disk);\n        }\n        else\n        {\n            sprintf(newfnm, \"%s FILE %c\", p, disk);\n        }\n    }\n    else\n    {\n        sprintf(newfnm, \"%s\", p);\n    }\n\n#elif defined(__VSE__)\n    if (zipm == NULL)\n    {\n        sprintf(newfnm, \"%s(%s)\", outdd, p);\n    }\n    else\n    {\n        strcpy(newfnm, outdd);\n    }\n\n#elif defined(__MVS__)\n    if (pdsn != NULL)\n    {\n        sprintf(newfnm, \"%s(%s)\", pdsn, p);\n    }\n    else\n    {\n        /* MVS will do dynamic allocation of the unchanged zip\n           file member. Note that PDOS relies heavily on this\n           style */\n        strcpy(newfnm, p);\n#if defined(MUSIC)\n        /* automatically truncate filenames down to MUSIC length */\n        if (strlen(newfnm) > 17)\n        {\n            p = strrchr(newfnm, '.');\n            if (p != NULL)\n            {\n                memmove(p - (strlen(newfnm) - 17), p, strlen(p) + 1);\n            }\n        }\n#endif\n    }\n#endif\n\n\n    if (binary)\n    {\n        size_t x;\n\n        newf = fopen(newfnm, \"wb\");\n        if (newf == NULL)\n        {\n            printf(\"file open failure on %s\\n\", newfnm);\n            exit(EXIT_FAILURE);\n        }\n        for (x = 0; x < size; x += MAXBUF)\n        {\n            size_t y;\n\n            y = size - x;\n            if (y > MAXBUF)\n            {\n                y = MAXBUF;\n            }\n            fread(buf, y, 1, infile);\n            fwrite(buf, y, 1, newf);\n        }\n    }\n    else\n    {\n        newf = fopen(newfnm, \"w\");\n        if (newf == NULL)\n        {\n            printf(\"file open failure on %s\\n\", newfnm);\n            exit(EXIT_FAILURE);\n        }\n        ascii2l(buf);\n        fwrite(buf, strlen(buf), 1, newf);\n    }\n    fclose(newf);\n    return (1);\n}\n\nstatic char *ascii2l(char *buf)\n{\n    char *p;\n    char *q;\n    int c;\n\n    p = buf;\n    q = buf;\n    while (*p != '\\0')\n    {\n        c = fasc(*p);\n        if (c == '\\0')\n        {\n            printf(\"warning - converting x'%02X' to space\\n\", *p);\n            c = ' ';\n        }\n        if (c != '\\r')\n        {\n            *q++ = (char)c;\n        }\n        p++;\n    }\n    *q = '\\0';\n    return (buf);\n}\n\nstatic int fasc(int asc)\n{\n  switch (asc)\n  {\n    case 0x09 : return('\\t');\n    case 0x0a : return('\\n');\n    case 0x0c : return('\\f');\n    case 0x0d : return('\\r');\n    case 0x20 : return(' ');\n    case 0x21 : return('!');\n    case 0x22 : return('\\\"');\n    case 0x23 : return('#');\n    case 0x24 : return('$');\n    case 0x25 : return('%');\n    case 0x26 : return('&');\n    case 0x27 : return('\\'');\n    case 0x28 : return('(');\n    case 0x29 : return(')');\n    case 0x2a : return('*');\n    case 0x2b : return('+');\n    case 0x2c : return(',');\n    case 0x2d : return('-');\n    case 0x2e : return('.');\n    case 0x2f : return('/');\n    case 0x30 : return('0');\n    case 0x31 : return('1');\n    case 0x32 : return('2');\n    case 0x33 : return('3');\n    case 0x34 : return('4');\n    case 0x35 : return('5');\n    case 0x36 : return('6');\n    case 0x37 : return('7');\n    case 0x38 : return('8');\n    case 0x39 : return('9');\n    case 0x3a : return(':');\n    case 0x3b : return(';');\n    case 0x3c : return('<');\n    case 0x3d : return('=');\n    case 0x3e : return('>');\n    case 0x3f : return('?');\n    case 0x40 : return('@');\n    case 0x41 : return('A');\n    case 0x42 : return('B');\n    case 0x43 : return('C');\n    case 0x44 : return('D');\n    case 0x45 : return('E');\n    case 0x46 : return('F');\n    case 0x47 : return('G');\n    case 0x48 : return('H');\n    case 0x49 : return('I');\n    case 0x4a : return('J');\n    case 0x4b : return('K');\n    case 0x4c : return('L');\n    case 0x4d : return('M');\n    case 0x4e : return('N');\n    case 0x4f : return('O');\n    case 0x50 : return('P');\n    case 0x51 : return('Q');\n    case 0x52 : return('R');\n    case 0x53 : return('S');\n    case 0x54 : return('T');\n    case 0x55 : return('U');\n    case 0x56 : return('V');\n    case 0x57 : return('W');\n    case 0x58 : return('X');\n    case 0x59 : return('Y');\n    case 0x5a : return('Z');\n    case 0x5b : return('\u00dd');\n    case 0x5c : return('\\\\');\n    case 0x5d : return('\u00a8');\n    case 0x5e : return('\u00ac');\n    case 0x5f : return('_');\n    case 0x60 : return('`');\n    case 0x61 : return('a');\n    case 0x62 : return('b');\n    case 0x63 : return('c');\n    case 0x64 : return('d');\n    case 0x65 : return('e');\n    case 0x66 : return('f');\n    case 0x67 : return('g');\n    case 0x68 : return('h');\n    case 0x69 : return('i');\n    case 0x6a : return('j');\n    case 0x6b : return('k');\n    case 0x6c : return('l');\n    case 0x6d : return('m');\n    case 0x6e : return('n');\n    case 0x6f : return('o');\n    case 0x70 : return('p');\n    case 0x71 : return('q');\n    case 0x72 : return('r');\n    case 0x73 : return('s');\n    case 0x74 : return('t');\n    case 0x75 : return('u');\n    case 0x76 : return('v');\n    case 0x77 : return('w');\n    case 0x78 : return('x');\n    case 0x79 : return('y');\n    case 0x7a : return('z');\n    case 0x7b : return('{');\n    case 0x7c : return('|');\n    case 0x7d : return('}');\n    case 0x7e : return('~');\n    default   : return(0);\n  }\n}\n\nstatic int ins_strcmp(char *one, char *two)\n{\n    while (toupper(*one) == toupper(*two))\n    {\n        if (*one == '\\0')\n        {\n            return (0);\n        }\n        one++;\n        two++;\n    }\n    if (toupper(*one) < toupper(*two))\n    {\n        return (-1);\n    }\n    return (1);\n}\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "NAMCSECT": {"ttr": 2053, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  namcsect - provide a name for a CSECT                            */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    char buf\u00dd500\u00a8;\n\n    if (argc < 2)\n    {\n        fprintf(stderr, \"usage: namcsect <csect name>\\n\");\n        fprintf(stderr, \"will read from stdin and write to stdout\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    while (fgets(buf, sizeof buf, stdin) != NULL)\n    {\n        if (memcmp(buf, \"         CSECT\", 14) == 0)\n        {\n            memcpy(buf, *(argv + 1), strlen(*(argv + 1)));\n        }\n        fputs(buf, stdout);\n    }\n\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "OSSTART": {"ttr": 8965, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; osstart.asm - startup code for C programs\n;\n; This program written by Paul Edwards\n; Released to the public domain\n; w/mods by Matthew Parker\n\n; This program is meant to be used as a stub for your C programs\n; It is designed for OS/2\n\n.386p\n\n.model flat\n\n;.stack 4000h\n\nextrn __start:near, DosExit:near\n\n_DATA   segment dword public use32 'DATA'\nifdef LINK386_FIX\n        org 20000h\nendif\nbanner  db  \"PDPCLIB\"\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n_STACK  segment dword stack use32 'STACK'\n        db 4000h dup(?)\n_STACK  ends\n\nDGROUP  group   _DATA,_BSS\n        assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\ntop:\n\n\npublic __main\n__intstart proc\n        mov eax, \u00ddesp+16\u00a8\n        push eax\n        call __start\n        sub sp,4\n        push eax\n        call __exita\n__intstart endp\n\n\npublic __exita\n__exita proc\n        pop eax\n        pop eax\n        push eax\n        push 1\n        call DosExit\n        sub sp,8\n__exita endp\n\n\n__main proc\n        ret\n__main endp\n\n\n; Note that setjmp/longjmp are untested under OS/2 since\n; I don't have that environment readily available at the\n; moment\n\npublic __setj\n__setj proc env:dword\n        mov eax, env\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax + 4\u00a8, ecx\n        mov \u00ddeax + 8\u00a8, edx\n        mov \u00ddeax + 12\u00a8, edi\n        mov \u00ddeax + 16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax + 20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp + 0\u00a8\n        mov \u00ddeax + 24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp + 4\u00a8     ; return address\n        mov \u00ddeax + 28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax + 0\u00a8, ebx\n        mov eax, 0\n\n        ret\n__setj endp\n\n\npublic __longj\n__longj proc env:dword\n        mov eax, env\n        mov ebp, \u00ddeax + 20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax + 28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax + 24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax + 0\u00a8\n        mov ecx, \u00ddeax + 4\u00a8\n        mov edx, \u00ddeax + 8\u00a8\n        mov edi, \u00ddeax + 12\u00a8\n        mov esi, \u00ddeax + 16\u00a8\n\n        mov eax, \u00ddeax + 32\u00a8    ; return value\n\n        ret\n__longj endp\n\n\n_TEXT ends\n\nend top\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDOSST32": {"ttr": 2055, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Startup code for PDOS */\n/* written by Paul Edwards */\n/* released to the public domain */\n\n/* We can get away with a minimal startup code, plus make it\n   a C program.  Do not put any string literals in here though,\n   as the code needs to start immediately.  This is IT!  */\n\nint __pdosst32(int i1, int i2, int i3, void *exep)\n{\n    int rc;\n\n    rc = __pstart(&i1, &i2, &i3, exep);\n    return (rc);\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDOSSUPC": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* written by Paul Edwards */\n/* released to the public domain */\n/* pdossupc - support routines for pdos */\n\n#include \"stddef.h\"\n\n#include <pos.h>\n#include <support.h>\n\nint __open(const char *filename, int mode, int *errind)\n{\n    int handle;\n    int ret;\n\n    ret = PosOpenFile(filename, mode, &handle);\n    *errind = ret;\n    return (handle);\n}\n\nint __read(int handle, void *buf, size_t len, int *errind)\n{\n    long readBytes;\n\n    PosReadFile(handle, buf, len, &readBytes);\n    *errind = 0;\n    return (readBytes);\n}\n\nint __write(int handle, const void *buf, size_t len, int *errind)\n{\n    int ret;\n\n    ret = PosWriteFile(handle, buf, len);\n    *errind = 0;\n    return (ret);\n}\n\nvoid __seek(int handle, long offset, int whence)\n{\n    PosMoveFilePointer(handle, offset, whence);\n    return;\n}\n\nvoid __close(int handle)\n{\n    PosCloseFile(handle);\n    return;\n}\n\nvoid __remove(const char *filename)\n{\n    PosDeleteFile(filename);\n    return;\n}\n\nvoid __rename(const char *old, const char *new)\n{\n    PosRenameFile(old, new);\n    return;\n}\n\nvoid __allocmem(size_t size, void **ptr)\n{\n    *ptr = PosAllocMem(size);\n    return;\n}\n\nvoid __freemem(void *ptr)\n{\n    PosFreeMem(ptr);\n    return;\n}\n\nvoid __exec(char *cmd, void *env)\n{\n    PosExec(cmd, env);\n    return;\n}\n\nvoid __datetime(void *ptr)\n{\n    int year, month, day, dow;\n    int hour, minute, second, hundredths;\n    int *iptr = ptr;\n\n    PosGetSystemDate(&year, &month, &day, &dow);\n    iptr\u00dd0\u00a8 = year;\n    iptr\u00dd1\u00a8 = month;\n    iptr\u00dd2\u00a8 = day;\n    iptr\u00dd3\u00a8 = dow;\n    PosGetSystemTime(&hour, &minute, &second, &hundredths);\n    iptr\u00dd4\u00a8 = hour;\n    iptr\u00dd5\u00a8 = minute;\n    iptr\u00dd6\u00a8 = second;\n    iptr\u00dd7\u00a8 = hundredths;\n    return;\n}\n\nint __pstart(int *i1, int *i2, int *i3, POS_EPARMS *exep)\n{\n    return (__start(i1, i2, i3, exep));\n}\n\n#ifdef PDOS_MAIN_ENTRY\nvoid __callback(void)\n{\n    __exit(0);\n    return;\n}\n#endif\n\n#ifdef PDOS_MAIN_ENTRY\nvoid __main(int ebp, int retaddr, int i1, int i2, int i3, POS_EPARMS *exep)\n{\n    __start(&i1, &i2, &i3, exep);\n    exep->callback = __callback;\n    return;\n}\n#else\nvoid __main(void)\n{\n    return;\n}\n#endif\n\nvoid __exita(int retcode)\n{\n#ifndef PDOS_RET_EXIT\n     PosTerminate(retcode);\n#endif\n    return;\n}\n\nvoid __displayc(void)\n{\n    *__vidptr = 'C';\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDPTEST": {"ttr": 2060, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  pdptest.c - Test of PDPCLIB                                      */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n#if 1\n    FILE *fp;\n    FILE *fq;\n    char buf\u00dd5000\u00a8;\n    size_t x;\n    int c;\n    time_t tt;\n#endif\n    int i;\n\n#if 0\n    fq = fopen(\"dd:outfile\", \"w\");\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fgets(buf, sizeof buf, stdin);\n    fputs(buf, fq);\n    fclose(fq);\n#endif\n    printf(\"hello there\\n\");\n    printf(\"argc = %d\\n\" , argc);\n    for (i = 0; i < argc; i++)\n    {\n        printf(\"arg %d is <%s>\\n\", i, argv\u00ddi\u00a8);\n    }\n#ifdef LOOP\n    /* note - we use two newlines because of PDPCLIB's MVS\n       implementation (MACRF=PL) */\n    printf(\"deliberately looping!\\n\\n\");\n    for (;;) ;\n#endif\n    return (0);\n#if 0\n    fp = fopen(\"pdptest.in\", \"r+b\");\n    if (fp == NULL)\n    {\n        printf(\"couldn't open input file\\n\");\n        return (0);\n    }\n    x = fread(buf, 1, 5, fp);\n    buf\u00ddx\u00a8 = '\\0';\n    printf(\"x is %d\\n\", x);\n    printf(\"buf is %s\\n\", buf);\n    fwrite(\"test\\ntest2\\n\", 1, 11, stdout);\n    printf(\"data is:\\n\");\n    printf(\"%s\\n\", buf);\n    printf(\"position is %ld\\n\", ftell(fp));\n    x = fseek(fp, 15, SEEK_SET);\n    fputc('Z', fp);\n    printf(\"x is %d\\n\", x);\n    x = fread(buf, 1, 5, fp);\n    printf(\"x is %d\\n\", x);\n    printf(\"%s\\n\", buf);\n    fclose(fp);\n    printf(\"This is a test of 342 %d!\\n\", 342);\n    printf(\"Please enter your name\\n\");\n/*    fgets(buf, sizeof buf, stdin);\n    printf(\"hello, %s\", buf); */\n    printf(\"is 'C' uppercase? %d\\n\", isupper('C'));\n    printf(\"is 'C' lowercase? %d\\n\", islower('C'));\n    printf(\"what is lowercase 'C'? %d\\n\", tolower('C'));\n    tt = time(NULL);\n    printf(\"time is %lu\\n\", tt);\n    fp = fopen(\"pdptest.in\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"failed to open file\\n\");\n        return (0);\n    }\n    c = getc(fp);\n    printf(\"c is %d\\n\", c);\n    while (fgets(buf, sizeof buf, fp) != NULL)\n    {\n        if (*buf != ',')\n        {\n            printf(buf);\n        }\n    }\n    fclose(fp);\n    printf(\"argc is %d\\n\", argc);\n    for (x = 0; x < argc; x++)\n    {\n        printf(\"argv\u00dd%d\u00a8 is %s\\n\", x, argv\u00ddx\u00a8);\n    }\n    sprintf(buf, \"%.4d-%.2d-%.2d\", 51, 41, 31);\n    printf(\"%s\\n\", buf);\n    printf(\"%-15s%s\\n\", \"hello\", \"there\");\n    printf(\"%-06dJJ\\n\", 37);\n    printf(\"%2d\\n\", 57);\n    printf(\"%2d\\n\", 7);\n    printf(\"%2d\\n\", -3);\n    printf(\"%d\\n\", -457);\n    printf(\"should be there %s\\n\", strstr(\"hello there\", \"there\"));\n#endif\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF1": {"ttr": 2063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to create a test file called \"temp.in\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    long x;\n\n    for (x = 0; x < 200000L; x++)\n    {\n        printf(\"123456789012345678901234567890\\n\");\n    }\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF2": {"ttr": 2065, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fgets\" */\n\n#include <stdio.h>\n\nint main(void)\n{\n    char buf\u00dd100\u00a8;\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"r\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fgets(buf, sizeof buf, fp) != NULL)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF3": {"ttr": 2306, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fread\" on binary files */\n\n#include <stdio.h>\n\nstatic char buf\u00dd20000\u00a8;\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PERF4": {"ttr": 2308, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Run this to test out \"fread\" on binary files,\n   for small reads */\n\n#include <stdio.h>\n\nstatic char buf\u00dd80\u00a8;\n\nint main(void)\n{\n    FILE *fp;\n    long x;\n\n    fp = fopen(\"temp.in\", \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open temp.in\\n\");\n        return (0);\n    }\n\n    x = 0;\n    while (fread(buf, sizeof buf, 1, fp) == 1)\n    {\n        x++;\n    }\n    fclose(fp);\n    printf(\"x is %ld\\n\", x);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SAPSTART": {"ttr": 8968, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "SAPSTART TITLE 'S A P S T A R T  ***  STARTUP ROUTINE FOR C'\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                              *\n*  RELEASED TO THE PUBLIC DOMAIN                                      *\n*                                                                     *\n***********************************************************************\n***********************************************************************\n*                                                                     *\n*  SAPSTART - startup routines for standalone programs                *\n*  It is currently coded to work with GCC. To activate the C/370      *\n*  version change the \"&COMP\" switch.                                 *\n*                                                                     *\n*  These routines are designed to work in conjunction with the        *\n*  Hercules/380 dasdload, which will create a disk with this program  *\n*  on cylinder 0, head 1, but only read the first record into low     *\n*  memory.  This startup code is required to read the remaining       *\n*  blocks, and looks for approximately 1 MB of them.                  *\n*                                                                     *\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         PRINT GEN\n         YREGS\n***********************************************************************\n*                                                                     *\n*  Equates                                                            *\n*                                                                     *\n***********************************************************************\nSTACKLOC EQU   X'080000'    The stack starts here (0.5 MiB)\nHEAPLOC  EQU   X'100000'    Where malloc etc come from (1 MiB)\nCHUNKSZ  EQU   18452        The executable is split into blocks\nMAXBLKS  EQU   40           Maximum number of blocks to read\nCODESTRT EQU   1024         Start of our real code\nENTSTRT  EQU   2048         Create a predictable usable entry point\n*\n*\n*\n         CSECT\n*\n* This program will be loaded by the IPL sequence to location 0\n* in memory. As such, we need to zero out the lower 512 bytes of\n* memory which the hardware will use. Except for the first 8\n* bytes, where we need to specify the new PSW.\n*\nORIGIN   DS    0D\n         DC    X'000C0000'  EC mode + Machine Check enabled\n         AIF   ('&SYS' EQ 'S370').MOD24A\n         DC    A(X'80000000'+POSTIPL)\n         AGO   .MOD31A\n.MOD24A  ANOP\n         DC    A(POSTIPL)   First bit of \"normal\" memory\n.MOD31A  ANOP\n*\n* Memory to be cleared.\n*\n         DC    (CODESTRT-*+ORIGIN)X'00'\n*\n* Start of our own, somewhat normal, code. Registers are not\n* defined at this point, so we need to create our own base\n* register.\n*\nPOSTIPL  DS    0H\n         BALR  R12,0\n         BCTR  R12,0\n         BCTR  R12,0\n         USING POSTIPL,R12\n         USING PSA,R0\n*\n* At this point, since it is post-IPL, all further interrupts\n* will occur to one of 4 locations (instead of location 0, the\n* IPL newpsw). Although we are only expecting, and only need,\n* the I/O interrupts, we set \"dummy\" values for the others in\n* case something unexpected happens, to give us some visibility\n* into the problem.\n*\n         MVC   FLCINPSW(8),NEWIO\n         MVC   FLCMNPSW(8),WAITER1\n         MVC   FLCSNPSW(8),WAITER2\n         MVC   FLCPNPSW(8),WAITER3\n* Save IPL address in R10\n         SLR   R10,R10\n         ICM   R10,B'1111',FLCIOA\n* R3 points to CCW chain\n         LA    R3,SEEK\n         ST    R3,FLCCAW    Store in CAW\n         LA    R4,1         R4 = Number of blocks read so far\n         L     R5,=A(CHUNKSZ) Current address\n         LA    R6,1         R6 = head\n         LA    R7,2         R7 = record\n         AIF   ('&SYS' EQ 'S390').SIO31A\n         SIO   0(R10)\n         AGO   .SIO24A\n.SIO31A  ANOP\n         LR    R1,R10       IPL subchannel needs to be in R1\n         LCTL  6,6,ALLIOINT CR6 needs to enable all interrupts\n         LA    R9,IRB\n         TSCH  0(R9)\n         LA    R10,ORB      R10 needs to point to ORB\n         SSCH  0(R10)\n.SIO24A  ANOP\n         LPSW  WAITNOER     Wait for an I/O interrupt\n         LTORG\n*\n*\n*\n         AIF   ('&SYS' NE 'S390').NOT390A\n         DS    0F\nALLIOINT DC    X'FF000000'\nIRB      DS    24F\nORB      DS    0F\n         DC    F'0'\n         DC    X'0000FF00'  Logical-Path Mask (enable all?)\n         DC    A(SEEK)\n         DC    5F'0'\n.NOT390A ANOP\n*\n*\n*\n         DS    0D\nWAITNOER DC    X'020E0000'  I/O, machine check, EC, wait\n         DC    X'00000000'  no error\nNEWIO    DC    X'000C0000'  machine check enabled + EC\n         AIF   ('&SYS' EQ 'S370').MOD24B\n         DC    A(X'80000000'+STAGE2)\n         AGO   .MOD31B\n.MOD24B  ANOP\n         DC    A(STAGE2)\n.MOD31B  ANOP\nWAITER1  DC    X'000E0000'  machine check, EC, wait\n         DC    X'00000111'  error 111\nWAITER2  DC    X'000E0000'  machine check, EC, wait\n         DC    X'00000222'  error 222\nWAITER3  DC    X'000E0000'  machine check, EC, wait\n         DC    X'00000333'  error 333\n         DS    0D\nSEEK     CCW   7,BBCCHH,X'40',6\nSEARCH   CCW   X'31',CCHHR,X'40',5\n         CCW   8,SEARCH,0,0\nLOADCCW  CCW   6,CHUNKSZ,X'20',32767\n         DS    0H\nBBCCHH   DC    X'000000000001'\n         ORG   *-2\nHH1      DS    CL2\nCCHHR    DC    X'0000000102'\n         ORG   *-3\nHH2      DS    CL2\nR        DS    C\n*\nSTAGE2   DS    0H\n         A     R5,=A(CHUNKSZ)\n         STCM  R5,B'0111',LOADCCW+1\n         LA    R7,1(R7)\n         C     R7,=F'4'     Don't read more than 3 blocks per track\n         BL    INRANGE\n         LA    R7,1\n         LA    R6,1(R6)\nINRANGE  DS    0H\n         STC   R7,R\n         STCM  R6,B'0011',HH1\n         STCM  R6,B'0011',HH2\n         LA    R4,1(R4)\n* Ideally we want to read up until we have a short block, or\n* an I/O error, but it's simpler to just force-read up to a\n* set maximum.\n         C     R4,=A(MAXBLKS)  R4=Maximum blocks to read\n         BH    STAGE3\n         AIF   ('&SYS' EQ 'S390').SIO31B\n         SIO   0(R10)       Read next block\n         AGO   .SIO24B\n.SIO31B  ANOP\n         TSCH  0(R9)\n         SSCH  0(R10)\n.SIO24B  ANOP\n         LPSW  WAITNOER\nSTAGE3   DS    0H\n* Go back to the original state, with I/O disabled, so that we\n* don't get any more noise unless explicitly requested\n         LPSW  ST4PSW\n         DS    0D\nST4PSW   DC    X'000C0000'  EC mode + Machine Check enabled\n         AIF   ('&SYS' EQ 'S370').MOD24C\n         DC    A(X'80000000'+STAGE4)\n         AGO   .MOD31C\n.MOD24C  ANOP\n         DC    A(STAGE4)\n.MOD31C  ANOP\nWAITSERR DC    X'000E0000'  EC mode + Machine Check enabled + wait\n         DC    X'00000444'  Severe error\n* At this point, we are in a \"normal\" post-IPL status,\n* with our bootloader loaded, and interrupts disabled,\n* and low memory should be considered to be in an\n* \"unknown\" state. We will however pass a parameter\n* block to the startup routine, with various bits of information\n* for it to interpret.\nSTAGE4   DS    0H\n* Since our program is less than 0.5 MB, set the stack at\n* location 0.5 MB. Note that the other thing to worry about\n* is the heap, which is set here, and returned in the sapsupa\n* GETM routine.\n         L     R13,=A(STACKLOC)  Stack location\n         LA    R2,0\n         ST    R2,4(R13)         backchain to nowhere\n         LR    R2,R13\n         A     R2,=F'120'        Get past save area etc\n         ST    R2,76(R13)        C needs to know where we're up to\n*\n         LA    R1,PRMPTR         MVS-style parm block (but to struct)\n         L     R15,=V(@@CRT0)\n         BALR  R14,R15\n* If they're dumb enough to return, load an error wait state\n         LPSW  WAITSERR\n         LTORG\nPRMPTR   DC    A(SAPBLK)\nSAPBLK   DS    0F\nSAPDUM   DC    F'0'\nSAPLEN   DC    F'4'              Length of following parameters\nHPLOC    DC    A(HEAPLOC)        Heap location\n         DROP  ,\n         DC    C'PDPCLIB!'\n*\n* This is the \"main\" entry point for standalone programs.\n* Control can reach here via a number of methods. It may have\n* been the result of booting from the card reader, with the\n* destination being location 0. Or it may have been loaded\n* by a stand-alone loader, and the destination is not location 0.\n* However, in either case (or other cases, e.g. the startup\n* code having to complete a load itself), the invoker of this\n* code will have given a somewhat MVS-style parameter list.\n* You can rely on R13 being a pointer to a save area, in\n* fact, an actual stack. R1 will point to a fullword of 0,\n* so that it looks like an empty parameter list, but following\n* that, there will also be extra data, starting with a fullword\n* which contains the length of that extra data block. R15 will\n* be the entry point.\n*\n* The intention of all this is to allow any arbitrary\n* stand alone program to be either loaded by a loader, anywhere\n* in memory, or to be directly loadable into location 0. Multiple\n* entry points, basically, but a common executable.\n*\n         DC    (ENTSTRT-*+ORIGIN)X'00'\n         ORG   *-12\n         DC    C'ZAPCONSL'\n* Just before ordinary entry point, create a zappable variable\n* to store a device number for a console.\n         ENTRY @@CONSDN\n@@CONSDN DC    F'0'\n         DS    0H\n         AIF ('&COMP' NE 'C370').NOCEES\n         ENTRY CEESTART\nCEESTART EQU   *\n.NOCEES  ANOP\n@@CRT0   PDPPRLG CINDEX=1,FRAME=120,BASER=12,ENTRY=YES\n         B     FEN1\n         LTORG\nFEN1     EQU   *\n         DROP  12\n         BALR  12,0\n         USING *,12\n         LR    11,1\n*\n* Clean base register\n         LA    R12,0(R12)\n*\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R7,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R7)         TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R7)        ADDR OF MEMORY ALLOCATION ROUTINE\n*         ST    R2,ARGPTR\n*\n         MVC   PGMNAME,=C'SAPLOAD '\n*\n         ST    R1,ARGPTR         pass the R1 directly on\n         L     R1,0(R1)          It's a pointer to a structure\n         L     R2,8(R1)          heap is available here\n         ST    R2,@@HPLOC        heap location used by GETM\n         LA    R2,PGMNAME\n         ST    R2,PGMNPTR\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         AIF   ('&SYS' NE 'S380').N380ST1\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         BSM   R4,R0\n         ST    R4,SAVER4\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n*\n         AIF   ('&SYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         PDPEPIL\nSAVER4   DC    F'0'\nSAVER13  DC    F'0'\n         LTORG\n*\n         ENTRY @@HPLOC\n@@HPLOC  DS    A\n         DROP  ,\n         DS    0H\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&SYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         PDPEPIL\n         LTORG\n*\n         CVT   DSECT=YES\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    65536F\nMAINLEN  EQU   *-MAINSTK\nSTACKLEN EQU   *-STACK\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAPSUPA": {"ttr": 9219, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*\n*  This program written by Paul Edwards.\n*  Released to the public domain\n*\n*  Extensively modified by others\n*\n***********************************************************************\n*\n*  MUSSUPA - Support routines for PDPCLIB under MUSIC\n*\n*  It is currently coded for GCC, but C/370 functionality is\n*  still there, it's just not being tested after any change.\n*\n***********************************************************************\n*\n* Note that the VBS support may not be properly implemented.\n* Note that this code issues WTOs. It should be changed to just\n* set a return code an exit gracefully instead. I'm not talking\n* about that dummy WTO. But on the subject of that dummy WTO - it\n* should be made consistent with the rest of PDPCLIB which doesn't\n* use that to set the RMODE/AMODE. It should be consistent one way\n* or the other.\n*\n* Here are some of the errors reported:\n*\n*  OPEN input failed return code is: -37\n*  OPEN output failed return code is: -39\n*\n* FIND input member return codes are:\n* Original, before the return and reason codes had\n* negative translations added refer to copyrighted:\n* DFSMS Macro Instructions for Data Sets\n* RC = 0 Member was found.\n* RC = -1024 Member not found.\n* RC = -1028 RACF allows PDSE EXECUTE, not PDSE READ.\n* RC = -1032 PDSE share not available.\n* RC = -1036 PDSE is OPENed output to a different member.\n* RC = -2048 Directory I/O error.\n* RC = -2052 Out of virtual storage.\n* RC = -2056 Invalid DEB or DEB not on TCB or TCBs DEB chain.\n* RC = -2060 PDSE I/O error flushing system buffers.\n* RC = -2064 Invalid FIND, no DCB address.\n*\n***********************************************************************\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT NOGEN\n         YREGS\nSUBPOOL  EQU   0\n         EXTRN @@CONSDN\n*\n***********************************************************************\n*\n*  AOPEN - Open a dataset\n*\n*  Note that under MUSIC, RECFM=F is the only reliable thing. It is\n*  possible to use RECFM=V like this:\n*  /file myin tape osrecfm(v) lrecl(32756) vol(PCTOMF) old\n*  but it is being used outside the normal MVS interface. All this\n*  stuff really needs to be rewritten per normal MUSIC coding.\n*\n*\n*  Note - more documentation for this and other I/O functions can\n*  be found halfway through the stdio.c file in PDPCLIB.\n*\n***********************************************************************\n**********************************************************************\n*                                                                    *\n*  AOPEN - Open a file                                               *\n*                                                                    *\n*  Parameters are:                                                   *\n*  DDNAME - space-padded, 8 character DDNAME to be opened            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)     *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function *\n*  LRECL - This function will determine the LRECL                    *\n*  BLKSIZE - This function will determine the block size             *\n*  ASMBUF - pointer to a 32K area which can be written to (only      *\n*    needs to be set in move mode)                                   *\n*  MEMBER - *pointer* to space-padded, 8 character member name.      *\n*    If pointer is 0 (NULL), no member is requested                  *\n*                                                                    *\n*  Return value:                                                     *\n*  An internal \"handle\" that allows the assembler routines to        *\n*  keep track of what's what when READ etc are subsequently          *\n*  called.                                                           *\n*                                                                    *\n*                                                                    *\n*  Note - more documentation for this and other I/O functions can    *\n*  be found halfway through the stdio.c file in PDPCLIB.             *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AOPEN\n@@AOPEN  EQU   *\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,WORKAREA\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)         R3 POINTS TO DDNAME\n         L     R4,4(R1)         R4 POINTS TO MODE\n         L     R4,0(R4)         R4 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n* Point directly to ZDCBAREA\n         LA    R1,ZDCBAREA\n         LR    R2,R1\n         LR    R0,R2              Load output DCB area address\n         LA    R1,ZDCBLEN         Load output length of DCB area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n* THIS LINE IS FOR GCC\n         LR    R6,R4\n* THIS LINE IS FOR C/370\n*         L     R6,0(R4)\n         LTR   R6,R6\n         LA    R1,ABRDW           point to RDW before ABUFFER\n*         LA    R1,ABUFFER\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* R5 now free again\n*\nDONEOPEN DS    0H\n         LR    R7,R2\n         SR    R6,R6\n         LH    R6,=H'254'         Hardcode to 250 bytes of data\n         ST    R6,0(R8)\nFIXED    DS    0H\n*         L     R6,=F'0'\n*         B     DONESET\nVARIABLE DS    0H\n         L     R6,=F'1'\nDONESET  DS    0H\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Finished with R5 now\n         LR    R15,R7\n         B     RETURNOP\nBADOPEN  DS    0H\n*         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL  Free DCB area\n         L     R15,=F'-1'\n         B     RETURNOP           Go return to caller with negative RC\n*\nENDFILE  LA    R6,1\n         ST    R6,RDEOF\n         BR    R14\nEOFRLEN  EQU   *-ENDFILE\n*\nRETURNOP DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n         POP   USING\n* OPENMAC  OPEN  (,INPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nOPENMAC  OPEN  (,INPUT),MF=L,TYPE=J\nOPENMLN  EQU   *-OPENMAC\n* WOPENMAC OPEN  (,OUTPUT),MF=L,MODE=31\n* CAN'T USE MODE=31 ON MVS 3.8\nWOPENMAC OPEN  (,OUTPUT),MF=L\nWOPENMLN EQU   *-WOPENMAC\n*INDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\n* LEAVE OUT EODAD AND EXLST, FILLED IN LATER\nINDCB    DCB   MACRF=GL,DSORG=PS,EODAD=ENDFILE,EXLST=JPTR\nINDCBLN  EQU   *-INDCB\nJPTR     DS    F\n*\n* OUTDCB changes depending on whether we are in LOCATE mode or\n* MOVE mode\n         AIF   ('&OUTM' NE 'L').NLM1\nOUTDCB   DCB   MACRF=PL,DSORG=PS\n.NLM1    ANOP\n         AIF   ('&OUTM' NE 'M').NMM1\nOUTDCB   DCB   MACRF=PM,DSORG=PS\n.NMM1    ANOP\nOUTDCBLN EQU   *-OUTDCB\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  AREAD - Read from file                                            *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AREAD\n@@AREAD  EQU   *\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n         AIF ('&SYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*         AIF   ('&SYS' NE 'S370').BELOW1\n* CAN'T USE \"BELOW\" ON MVS 3.8\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL\n*         AGO   .NOBEL1\n*.BELOW1  ANOP\n*         GETMAIN R,LV=WORKLEN,SP=SUBPOOL,LOC=BELOW\n*.NOBEL1  ANOP\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n         LA    R1,SAVEADCB\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*        L     R2,0(R1)         R2 CONTAINS HANDLE\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 point to a length\n         LA    R6,0\n         ST    R6,RDEOF\n         GET   (R2)\n         ST    R1,0(R3)\n*         LH    R5,DCBLRECL\n         L     R15,RDEOF\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*        FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         AIF ('&SYS' EQ 'S370').NOMOD2\n         CALL  @@SETM31\n.NOMOD2  ANOP\n         ST    R5,0(R4)         Tell caller the length read\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         POP   USING\n*\n*\n*\n***********************************************************************\n*\n*  AWRITE - Write to an open dataset\n*\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@AWRITE\n@@AWRITE EQU   *\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R4,8(,R1)          R4 points to the length\n         L     R4,0(,R4)          R4 now has actual length\n         USING ZDCBAREA,R2\n*        GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         LA    R1,SAVEADCB\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n*        USING WORKAREA,R13\n*\n         AIF   ('&SYS' NE 'S380').N380WR1\n*         CALL  @@SETM24\n.N380WR1 ANOP\n*\n*         STCM  R4,B'0011',DCBLRECL\n*\n         AIF   ('&OUTM' NE 'L').NLM2\n*         PUT   (R2)\n.NLM2    ANOP\n         AIF   ('&OUTM' NE 'M').NMM2\n         L     R7,=V(@@CONSDN)\n         L     R7,0(R7)\n         LTR   R7,R7\n         BZ    DODIAG\n         S     R4,=F'4'   assume RECFM=V\n         ST    R4,PARM1\n         L     R3,0(R3)\n         LA    R3,4(R3)   assume RECFM=V\n         ST    R3,PARM2\n         LA    R1,1\n         ST    R1,PARM3   set PARM3 = 1 = carriage return wanted\n         LA    R1,PARM1\n         CALL  @@CONSWR\n         B     DONEDIAG\nDODIAG   DS    0H\n* Extra 6 bytes for the MSG *, minus 4 for RDW\n         LA    R4,2(R4)\n* Move in MSG * prefix\n         MVC   ABMSG(6),MSGSTAR\n         LA    R6,ABMSG\n*         DIAG  6,4,0(8)\n         DC    X'83640008'\nDONEDIAG DS    0H\n         LA    R15,0\n*         PUT   (R2),(R6)\n.NMM2    ANOP\n         AIF   ('&OUTM' NE 'L').NLM3\n         ST    R1,0(R6)\n.NLM3    ANOP\n*\n         AIF   ('&SYS' NE 'S380').N380WR2\n*         CALL  @@SETM31\n.N380WR2 ANOP\n*\n*        LR    R1,R13\n*        L     R13,SAVEAREA+4\n         L     R13,SAVEADCB+4\n*        FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n         RETURN (14,12),RC=0\n         POP   USING\n*\n**********************************************************************\n*                                                                    *\n*  ACLOSE - Close file                                               *\n*                                                                    *\n**********************************************************************\n         PUSH  USING\n         DROP  ,\n         ENTRY @@ACLOSE\n@@ACLOSE EQU   *\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1\n         LA    R1,WORKAREA\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R2,0(R1)         R2 CONTAINS HANDLE\n         USING ZDCBAREA,R2\n* If we are doing move mode, free internal assembler buffer\n         AIF   ('&OUTM' NE 'M').NMM6\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'\n*         FREEMAIN RU,LV=(R6),A=(R5),SP=SUBPOOL\nNFRCL    DS    0H\n.NMM6    ANOP\n*         MVC   CLOSEMB,CLOSEMAC\n*         CLOSE ((R2)),MF=(E,CLOSEMB),MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\n*         CLOSE ((R2)),MF=(E,CLOSEMB)\n*         FREEPOOL ((R2))\n*         FREEMAIN RU,LV=ZDCBLEN,A=(R2),SP=SUBPOOL\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n*         FREEMAIN RU,LV=WORKLEN,A=(R1),SP=SUBPOOL\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n         POP   USING\n* CLOSEMAC CLOSE (),MF=L,MODE=31\n* CAN'T USE MODE=31 WITH MVS 3.8\nCLOSEMAC CLOSE (),MF=L\nCLOSEMLN EQU   *-CLOSEMAC\n*\n*\n*\n***********************************************************************\n*\n*  GETM - GET MEMORY\n*\n***********************************************************************\n         ENTRY @@GETM\n@@GETM   EQU   *\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         L     R2,0(,R1)\n         AIF ('&COMP' NE 'GCC').GETMC\n* THIS LINE IS FOR GCC\n         LR    R3,R2\n         AGO   .GETMEND\n.GETMC   ANOP\n* THIS LINE IS FOR C/370\n         L     R3,0(,R2)\n.GETMEND ANOP\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n* Assume heap location has been provided in global variable\n* Note that this function will only work if the C library\n* is compiled with MEMMGR option.\n         L     R1,=V(@@HPLOC)\n         L     R1,0(R1)\n* WE STORE THE AMOUNT WE REQUESTED FROM MVS INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*\n*  FREEM - FREE MEMORY\n*\n***********************************************************************\n         ENTRY @@FREEM\n@@FREEM  EQU   *\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n* Do nothing\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN\n*  ANY PARTICULAR WAY.\n*\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1\n*\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS\n*\n***********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK EQU   *\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from UTC offset in 1.048576 seconds         *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  EQU   *\n         SAVE  (14,12),,@@GETTZ\n         LR    R12,R15\n         USING @@GETTZ,R12\n*\n         LA    R15,0\n*\nRETURNGS DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG ,\n         SPACE 2\n***********************************************************************\n*\n*  SYSTEM - execute another command\n*\n***********************************************************************\n         ENTRY @@SYSTEM\n@@SYSTEM EQU   *\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         LA    R15,0\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)   Return to caller\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n***********************************************************************\n*\n*  IDCAMS - dummy function to keep MVS happy\n*\n***********************************************************************\n         ENTRY @@IDCAMS\n@@IDCAMS EQU   *\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  DIAG8 - do a diag 8                                               *\n*                                                                    *\n**********************************************************************\n         ENTRY @@DIAG8\n@@DIAG8  EQU   *\n         SAVE  (14,12),,@@DIAG8\n         LR    R12,R15\n         USING @@DIAG8,R12\n*\n         L     R6,0(R1)\n         L     R4,4(R1)\n*         DIAG  4,6,0(8)\n         DC    X'83460008'\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n**********************************************************************\n*                                                                    *\n*  @@CONSWR - write to console                                       *\n*                                                                    *\n*  parameter 1 = buffer length                                       *\n*  parameter 2 = buffer                                              *\n*                                                                    *\n**********************************************************************\n         ENTRY @@CONSWR\n@@CONSWR DS    0H\n         SAVE  (14,12),,@@CONSWR\n         LR    R12,R15\n         USING @@CONSWR,R12\n         USING PSA,R0\n*\n         L     R10,=V(@@CONSDN) Device number\n         L     R10,0(R10)\n         L     R7,0(R1)        Bytes to write\n         L     R2,4(R1)        Buffer to write\n         L     R8,8(R1)        Is CR required?\n         MVI   CCHAIN,X'01'    Assume no CR required\n         LTR   R8,R8\n         BZ    NOCRREQ\n         MVI   CCHAIN,X'09'    Need a CR\n* For some reason the CCW doesn't like an empty line of 0 bytes.\n* Need to find out why. Until then, assume that's the way that\n* it's meant to be, and force a space\n         LTR   R7,R7\n         BNZ   NOSPACE\n         LA    R2,=C' '\n         LA    R7,1\nNOSPACE  DS    0H\nNOCRREQ  DS    0H\n         AIF   ('&SYS' EQ 'S390').CHN390G\n         STCM  R2,B'0111',CCHAIN+1   This requires BTL buffer\n         STH   R7,CCHAIN+6     Store length in WRITE CCW\n         AGO   .CHN390H\n.CHN390G ANOP\n         ST    R2,CCHAIN+4\n         STH   R7,CCHAIN+2\n.CHN390H ANOP\n*\n* Interrupt needs to point to CCONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),CNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,CCHAIN\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&SYS' EQ 'S390').SIO31M\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .SIO24M\n.SIO31M  ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,CIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,CORB\n         MSCH  0(R10)\n         TSCH  0(R9)        Clear pending interrupts\n         SSCH  0(R10)\n.SIO24M  ANOP\n*\n*\n         LPSW  CWAITNER     Wait for an interrupt\n         DC    H'0'\nCCONT    DS    0H           Interrupt will automatically come here\n         AIF   ('&SYS' EQ 'S390').SIO31N\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(CFINCHN)\n         BE    CALLFIN\n         AGO   .SIO24N\n.SIO31N  ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(CFINCHN)\n         BE    CALLFIN\n.SIO24N  ANOP\n         L     R15,=F'-1'   error return\nCALLFIN  DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&SYS' NE 'S390').NOT390P\n         DS    0F\nCIRB     DS    24F\nCORB     DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(CCHAIN)\n         DC    5F'0'\n.NOT390P ANOP\n*\n*\n         DS    0D\n         AIF   ('&SYS' EQ 'S390').CHN390I\n* X'09' = write with automatic carriage return\nCCHAIN   CCW   X'09',0,X'20',0    20 = ignore length issues\n         AGO   .CHN390J\n.CHN390I ANOP\nCCHAIN   CCW1  X'09',0,X'20',0    20 = ignore length issues\n.CHN390J ANOP\nCFINCHN  EQU   *\n         DS    0D\nCWAITNER DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    X'00000000'  no error\nCNEWIO   DC    X'000C0000'  machine check, EC, DAT off\n         AIF   ('&SYS' EQ 'S370').MOD24Q\n         DC    A(X'80000000'+CCONT)  continuation after I/O request\n         AGO   .MOD31Q\n.MOD24Q  ANOP\n         DC    A(CCONT)     continuation after I/O request\n.MOD31Q  ANOP\n*\n         DROP  ,\n*\n*\n*\n*\n*\n**********************************************************************\n*                                                                    *\n*  @@CONSRD - read from console                                      *\n*                                                                    *\n*  parameter 1 = buffer length                                       *\n*  parameter 2 = buffer                                              *\n*                                                                    *\n**********************************************************************\n         ENTRY @@CONSRD\n@@CONSRD DS    0H\n         SAVE  (14,12),,@@CONSRD\n         LR    R12,R15\n         USING @@CONSRD,R12\n         USING PSA,R0\n*\n         L     R10,=V(@@CONSDN) Device number\n         L     R10,0(R10)\n         L     R7,0(R1)        Bytes to read\n         L     R2,4(R1)        Buffer to read into\n         AIF   ('&SYS' EQ 'S390').CRD390G\n         STCM  R2,B'0111',CRDCHN+1   This requires BTL buffer\n         STH   R7,CRDCHN+6     Store length in READ CCW\n         AGO   .CRD390H\n.CRD390G ANOP\n         ST    R2,CRDCHN+4\n         STH   R7,CRDCHN+2\n.CRD390H ANOP\n*\n* Interrupt needs to point to CRCONT now. Again, I would hope for\n* something more sophisticated in PDOS than this continual\n* initialization.\n*\n         MVC   FLCINPSW(8),CRNEWIO\n         STOSM FLCINPSW,X'00'  Work with DAT on or OFF\n* R3 points to CCW chain\n         LA    R3,CRDCHN\n         ST    R3,FLCCAW    Store in CAW\n*\n*\n         AIF   ('&SYS' EQ 'S390').CRD31M\n         SIO   0(R10)\n*         TIO   0(R10)\n         AGO   .CRD24M\n.CRD31M  ANOP\n         LR    R1,R10       R1 needs to contain subchannel\n         LA    R9,CRIRB\n         TSCH  0(R9)        Clear pending interrupts\n         LA    R10,CRORB\n         MSCH  0(R10)\n         TSCH  0(R9)        Clear pending interrupts\n         SSCH  0(R10)\n.CRD24M  ANOP\n*\n*\n         LPSW  CRWTNER      Wait for an interrupt\n         DC    H'0'\nCRCONT   DS    0H           Interrupt will automatically come here\n         AIF   ('&SYS' EQ 'S390').CRD31N\n         SH    R7,FLCCSW+6  Subtract residual count to get bytes read\n         LR    R15,R7\n* After a successful CCW chain, CSW should be pointing to end\n         CLC   FLCCSW(4),=A(CRDFCHN)\n         BE    CRALLFIN\n         AGO   .CRD24N\n.CRD31N  ANOP\n         TSCH  0(R9)\n         SH    R7,10(R9)\n         LR    R15,R7\n         CLC   4(4,R9),=A(CRDFCHN)\n         BE    CRALLFIN\n.CRD24N  ANOP\n         L     R15,=F'-1'   error return\nCRALLFIN DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n         AIF   ('&SYS' NE 'S390').CRD390P\n         DS    0F\nCRIRB    DS    24F\nCRORB    DS    0F\n         DC    F'0'\n         DC    X'0080FF00'  Logical-Path Mask (enable all?) + format-1\n         DC    A(CRDCHN)\n         DC    5F'0'\n.CRD390P ANOP\n*\n*\n         DS    0D\n         AIF   ('&SYS' EQ 'S390').CRD390I\n* X'0A' = read inquiry\nCRDCHN   CCW   X'0A',0,X'20',0    20 = ignore length issues\n         AGO   .CRD390J\n.CRD390I ANOP\nCRDCHN   CCW1  X'0A',0,X'20',0    20 = ignore length issues\n.CRD390J ANOP\nCRDFCHN  EQU   *\n         DS    0D\nCRWTNER  DC    X'060E0000'  I/O, machine check, EC, wait, DAT on\n         DC    X'00000000'  no error\nCRNEWIO  DC    X'000C0000'  machine check, EC, DAT off\n         AIF   ('&SYS' EQ 'S370').CRD24Q\n         DC    A(X'80000000'+CRCONT)  continuation after I/O request\n         AGO   .CRD31Q\n.CRD24Q  ANOP\n         DC    A(CRCONT)     continuation after I/O request\n.CRD31Q  ANOP\n*\n         DROP  ,\n*\n*\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  CALL @@DYNAL,(rb)                                                  *\n*                                                                     *\n*  Execute DYNALLOC (SVC 99)                                          *\n*                                                                     *\n*  Caller must provide a request block, in conformance with the       *\n*  MVS documentation for this (which is very complicated)             *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SVC99\n@@SVC99  DS    0H\n         ENTRY @@DYNAL\n@@DYNAL  DS    0H\n         SAVE  (14,12),,@@DYNAL   Save caller's regs.\n         LR    R12,R15\n         USING @@DYNAL,R12\n         LR    R11,R1\n*\n         GETMAIN RU,LV=WORKLEN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n* Note that the SVC requires a pointer to the pointer to the RB.\n* Because this function (not SVC) expects to receive a standard\n* parameter list, where R1 so happens to be a pointer to the\n* first parameter, which happens to be the address of the RB,\n* then we already have in R1 exactly what SVC 99 needs.\n*\n* Except for one thing. Technically, you're meant to have the\n* high bit of the pointer on. So we rely on the caller to have\n* the parameter in writable storage so that we can ensure that\n* we set that bit.\n*\n         L     R2,0(R1)\n         O     R2,=X'80000000'\n         ST    R2,0(R1)\n         SVC   99\n         LR    R2,R15\n*\nRETURN99 DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         FREEMAIN RU,LV=WORKLEN,A=(1),SP=SUBPOOL\n*\n         LR    R15,R2             Return success\n         RETURN (14,12),RC=(15)   Return to caller\n*\n         DROP  R12\n***********************************************************************\n*\n*  SETJ - SAVE REGISTERS INTO ENV\n*\n***********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*\n*  LONGJ - RESTORE REGISTERS FROM ENV\n*\n***********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&SYS' EQ 'S370').NOMODE  If S/370 we can't switch mode\n***********************************************************************\n*\n*  SETM24 - Set AMODE to 24\n*\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*\n*  SETM31 - Set AMODE to 31\n*\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\n         DS    0H\nMSGSTAR  DC    C'MSG * '\nABMSG    DS    2C                 Extra characters for MSG * move\nABRDW    DS    4C                 Storage for a RDW\nABUFFER  DS    CL250\nWORKAREA DS    0F\nSAVEAREA DS    18F\nPARM1    DS    F\nPARM2    DS    F\nPARM3    DS    F\nWORKLEN  EQU   *-WORKAREA\n*\nZDCBAREA DS    0H\n         DS    CL(INDCBLN)\n         DS    CL(OUTDCBLN)\nSAVEADCB DS    18F                Register save area for PUT\nRDEOF    DS    1F\nASMBUF   DS    A                  Pointer to an area for PUTing data\n         ORG   ZDCBAREA           Overlay the DCB DSECT\n*         DCBD  DSORG=PS,DEVD=DA  Map Data Control Block\n         ORG\nOPENCLOS DS    F                  OPEN/CLOSE parameter list\n         DS    0H\nEOFR24   DS    CL(EOFRLEN)\n*         IHADECB DSECT=NO         Data Event Control Block\nBLKSIZE  DS    F                  Save area for input DCB BLKSIZE\nLRECL    DS    F                  Save area for input DCB LRECL\nBUFFADDR DS    F                  Location of the BLOCK Buffer\nBUFFEND  DS    F                  Address after end of current block\nBUFFCURR DS    F                  Current record in the buffer\nVBSADDR  DS    F                  Location of the VBS record build area\nVBSEND   DS    F                  Addr. after end VBS record build area\nVBSCURR  DS    F                  Location to store next byte\nRDRECPTR DS    F                  Where to store record pointer\nRDLENPTR DS    F                  Where to store read length\nJFCBPTR  DS    F\nJFCB     DS    0F\n         IEFJFCBN LIST=YES        SYS1.AMODGEN JOB File Control Block\n* Format 1 Data Set Control Block\nDSCB     DS    0F\n*         IECSDSL1 (1)             Map the Format 1 DSCB\nDSCBCCHH DS    CL5                CCHHR of DSCB returned by OBTAIN\n         DS    CL47               Rest of OBTAIN's 148 byte work area\nCLOSEMB  DS    CL(CLOSEMLN)\n         DS    0F\nOPENMB   DS    CL(OPENMLN)\n         DS    0F\nWOPENMB  DS    CL(WOPENMLN)\nMEMBER24 DS    CL8\nZDCBLEN  EQU   *-ZDCBAREA\n         IEZIOB                   Input/Output Block\n*\n         CVT   DSECT=YES\n         IKJTCB\n         IEZJSCB\n         IHAPSA\n         IHARB\n         IHACDE\n         IHASVC\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETJMP": {"ttr": 2310, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  setjmp.c - implementation of stuff in setjmp.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"setjmp.h\"\n#include \"stddef.h\"\n\nint __longj(void *);\n\n__PDPCLIB_API__ void longjmp(jmp_buf env, int val)\n{\n    if (val == 0)\n    {\n        val = 1;\n    }\n    env\u00dd0\u00a8.retval = val;\n    /* load regs */\n    __longj(env);\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SIGNAL": {"ttr": 2312, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  signal.c - implementation of stuff in signal.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"signal.h\"\n#include \"stdlib.h\"\n#include \"stddef.h\"\n\nstatic void (*handlers\u00dd\u00a8)(int) = {\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl,\n    __sigdfl };\n\nvoid __sigdfl(int sig);\nvoid __sigerr(int sig);\nvoid __sigign(int sig);\n\n#define SIG_DFL __sigdfl\n#define SIG_ERR __sigerr\n#define SIG_IGN __sigign\n\n__PDPCLIB_API__ void (*signal(int sig, void (*func)(int)))(int)\n{\n    handlers\u00ddsig\u00a8 = func;\n    return (func);\n}\n\n\n__PDPCLIB_API__ int raise(int sig)\n{\n    (handlers\u00ddsig\u00a8)(sig);\n    return (0);\n}\n\n__PDPCLIB_API__ void __sigdfl(int sig)\n{\n    handlers\u00ddsig\u00a8 = SIG_DFL;\n    if (sig == SIGABRT)\n    {\n        exit(EXIT_FAILURE);\n    }\n    return;\n}\n\n__PDPCLIB_API__ void __sigerr(int sig)\n{\n    (void)sig;\n    return;\n}\n\n__PDPCLIB_API__ void __sigign(int sig)\n{\n    (void)sig;\n    return;\n}\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "START": {"ttr": 2314, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  start.c - startup/termination code                               */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\n#if USE_MEMMGR\n#include \"__memmgr.h\"\n#endif\n\nextern FILE *__userFiles\u00dd__NFILE\u00a8;\n\n#define MAXPARMS 50 /* maximum number of arguments we can handle */\n\n#ifdef __OS2__\n#define INCL_DOS\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if (defined(__MSDOS__) && defined(__WATCOMC__))\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\n\n#ifdef __MSDOS__\n/* Must be unsigned as it is used for array index */\nextern unsigned char *__envptr;\nextern unsigned short __osver;\n#endif\n\n#ifdef __VSE__\n#undef __CMS__\n#undef __MVS__\n#endif\n\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\nint __tso = 0; /* is this a TSO environment? */\nextern int __doperm; /* are we doing the permanent datasets? */\nint __upsi = 0; /* UPSI switches for VSE */\n#endif\n\n#ifdef __MAIN_FP__\nint (*__main_fp)(int argc, char **argv);\n\n__PDPCLIB_API__ void **__get_main_fp()\n    { return((void **)(&__main_fp)); }\n\n#else\nint main(int argc, char **argv);\n#endif\n\nvoid __exit(int status);\nvoid CTYP __exita(int status);\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\nstatic char buffer1\u00ddBUFSIZ + 8\u00a8;\nstatic char buffer2\u00ddBUFSIZ + 8\u00a8;\nstatic char buffer3\u00ddBUFSIZ + 8\u00a8;\n#endif\n\n#if defined(__PDOS__) && !defined(__MVS__)\n#include <support.h>\n#include <pos.h>\nint __abscor;\nunsigned char *__envptr;\nchar *__vidptr;\n#endif\n\n#if USE_MEMMGR\nextern void *__lastsup; /* last thing supplied to memmgr */\n#endif\n\nchar **__eplist;\nchar *__plist;\n\n#if defined(__CMS__)\nint __start(char *plist, char *pgmname, char **eplist)\n#elif defined(__VSE__)\nint __start(char *p, char *pgmname, char *ep)\n#elif defined(__MVS__)\nint __start(char *p, char *pgmname, int tso)\n#elif defined(__gnu_linux__)\nint __start(int argc, char **argv)\n#elif (defined(__PDOS__) && !defined(__MVS__))\nint __start(int *i1, int *i2, int *i3, POS_EPARMS *exep)\n#else\n__PDPCLIB_API__ int CTYP __start(char *p)\n#endif\n{\n#if (defined(__PDOS__) && !defined(__MVS__)) || defined(__CMS__)\n    char *p;\n#endif\n    int x;\n#if !defined(__gnu_linux__)\n    int argc;\n    static char *argv\u00ddMAXPARMS + 1\u00a8;\n#endif\n    int rc;\n#ifdef __OS2__\n    ULONG maxFH;\n    LONG reqFH;\n#endif\n#ifdef __MSDOS__\n    unsigned char *env;\n#endif\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    int parmLen;\n    int progLen;\n    char parmbuf\u00dd310\u00a8; /* z/VSE can have a PARM up to 300 characters */\n#endif\n\n#if defined(__PDOS__) && !defined(__MVS__)\n    p = exep->psp;\n    __abscor = exep->abscor;\n    __vidptr = ABSADDR(0xb8000);\n#endif\n\n#ifdef __WIN32__\n    p = GetCommandLine();\n#endif\n\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\n#ifdef __WIN32__\n    stdin->hfile = GetStdHandle(STD_INPUT_HANDLE);\n    stdout->hfile = GetStdHandle(STD_OUTPUT_HANDLE);\n    stderr->hfile = GetStdHandle(STD_ERROR_HANDLE);\n#else\n    stdin->hfile = 0;\n    stdout->hfile = 1;\n    stderr->hfile = 2;\n#endif\n\n    stdin->quickBin = 0;\n    stdin->quickText = 0;\n    stdin->textMode = 1;\n    stdin->intFno = 0;\n    stdin->bufStartR = 0;\n    stdin->bufTech = _IOLBF;\n    stdin->intBuffer = buffer1;\n    stdin->fbuf = stdin->intBuffer + 2;\n    *stdin->fbuf++ = '\\0';\n    *stdin->fbuf++ = '\\0';\n    stdin->szfbuf = BUFSIZ;\n    stdin->endbuf = stdin->fbuf + stdin->szfbuf;\n    *stdin->endbuf = '\\n';\n    stdin->noNl = 0;\n    stdin->upto = stdin->endbuf;\n    stdin->bufStartR = -stdin->szfbuf;\n    stdin->mode = __READ_MODE;\n    stdin->ungetCh = -1;\n    stdin->update = 0;\n    stdin->theirBuffer = 0;\n    stdin->permfile = 1;\n    stdin->isopen = 1;\n\n    stdout->quickBin = 0;\n    stdout->quickText = 0;\n    stdout->textMode = 1;\n    stdout->bufTech = _IOLBF;\n    stdout->intBuffer = buffer2;\n    stdout->fbuf = stdout->intBuffer;\n    *stdout->fbuf++ = '\\0';\n    *stdout->fbuf++ = '\\0';\n    stdout->szfbuf = BUFSIZ;\n    stdout->endbuf = stdout->fbuf + stdout->szfbuf;\n    *stdout->endbuf = '\\n';\n    stdout->noNl = 0;\n    stdout->upto = stdout->fbuf;\n    stdout->bufStartR = 0;\n    stdout->mode = __WRITE_MODE;\n    stdout->update = 0;\n    stdout->theirBuffer = 0;\n    stdout->permfile = 1;\n    stdout->isopen = 1;\n\n    stderr->quickBin = 0;\n    stderr->quickText = 0;\n    stderr->textMode = 1;\n    stderr->bufTech = _IOLBF;\n    stderr->intBuffer = buffer3;\n    stderr->fbuf = stderr->intBuffer;\n    *stderr->fbuf++ = '\\0';\n    *stderr->fbuf++ = '\\0';\n    stderr->szfbuf = BUFSIZ;\n    stderr->endbuf = stderr->fbuf + stderr->szfbuf;\n    *stderr->endbuf = '\\n';\n    stderr->noNl = 0;\n    stderr->upto = stderr->fbuf;\n    stderr->bufStartR = 0;\n    stderr->mode = __WRITE_MODE;\n    stderr->update = 0;\n    stderr->theirBuffer = 0;\n    stderr->permfile = 1;\n    stderr->isopen = 1;\n#else\n    int dyna_sysprint = 0;\n    int dyna_systerm = 0;\n    int dyna_sysin = 0;\n#if defined(__CMS__)\n/*\n  This code checks to see if DDs exist for SYSIN, SYSPRINT & SYSTERM\n  if not it issues FD to the terminal\n*/\n    char s202parm \u00dd800\u00a8; /* svc 202 buffer */\n    int code;\n    int parm;\n    int ret;\n    int have_sysparm;\n\n/*\n Now build the SVC 202 string for sysprint\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSPRINT\", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_sysprint = 1;\n    }\n\n/*\n Now build the SVC 202 string for systerm\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSTERM \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_systerm = 1;\n    }\n\n/*\n Now build the SVC 202 string for sysin\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSIN   \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n/*\n  and issue the SVC\n*/\n    ret = __SVC202 ( s202parm, &code, &parm );\n\n    if (ret == 24)\n    { /* we need to issue filedef */\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERM    \", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \", 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"LRECL   \", 8);\n        memcpy ( &s202parm\u00dd40\u00a8 , \"80      \", 8);\n        memcpy ( &s202parm\u00dd48\u00a8 , \"RECFM   \", 8);\n        memcpy ( &s202parm\u00dd56\u00a8 , \"F       \", 8);\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n\n        ret = __SVC202 ( s202parm, &code, &parm );\n        dyna_sysin = 1;\n    }\n\n#endif\n#if USE_MEMMGR\n    memmgrDefaults(&__memmgr);\n    memmgrInit(&__memmgr);\n#endif\n#if 0 /* MUSIC */\n    /* switch on lowercasing of input */\n    /* normal MUSIC default is to uppercase, and it's probably\n       better to let the user control that with the /TEXT LC\n       command instead */\n    __textlc();\n#endif\n#if defined(__MVS__)\n    /* need to know if this is a TSO environment straight away\n       because it determines how the permanent files will be\n       opened */\n    parmLen = ((unsigned int)p\u00dd0\u00a8 << 8) | (unsigned int)p\u00dd1\u00a8;\n    if ((parmLen > 0) && (p\u00dd2\u00a8 == 0))     /* assume TSO */\n    {\n        __tso = 1;\n    }\n#endif /* MVS */\n    __doperm = 1;\n    stdout = fopen(\"dd:SYSPRINT\", \"w\");\n    if (stdout == NULL)\n    {\n        __exita(EXIT_FAILURE);\n    }\n    stdout->permfile = 1;\n    stdout->dynal = dyna_sysprint;\n\n    stderr = fopen(\"dd:SYSTERM\", \"w\");\n    if (stderr == NULL)\n    {\n        printf(\"SYSTERM DD not defined\\n\");\n        fclose(stdout);\n        __exita(EXIT_FAILURE);\n    }\n    stderr->permfile = 1;\n    stderr->dynal = dyna_systerm;\n\n    stdin = fopen(\"dd:SYSIN\", \"r\");\n    if (stdin == NULL)\n    {\n        fprintf(stderr, \"SYSIN DD not defined\\n\");\n        fclose(stdout);\n        fclose(stderr);\n        __exita(EXIT_FAILURE);\n    }\n    stdin->permfile = 1;\n    stdin->dynal = dyna_sysin;\n    __doperm = 0;\n#if defined(__CMS__)\n    __eplist = eplist;\n    __plist = plist;\n\n    if (plist\u00dd0\u00a8 == '\\xff')  /* are we at the fence already? */\n    {\n        p = plist;   /* yes, this is also the start of the plist */\n    }\n    else\n    {\n        p = plist + 8; /* no, so jump past the command name */\n    }\n\n    /* Now build the SVC 202 string for sysparm */\n    memcpy ( &s202parm\u00dd0\u00a8 ,  \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 ,  \"SYSPARM \", 8);\n    memcpy ( &s202parm\u00dd16\u00a8 , \"(       \", 8);\n    memcpy ( &s202parm\u00dd24\u00a8 , \"NOCHANGE\", 8);\n    s202parm\u00dd32\u00a8=s202parm\u00dd33\u00a8=s202parm\u00dd34\u00a8=s202parm\u00dd35\u00a8=\n        s202parm\u00dd36\u00a8=s202parm\u00dd37\u00a8=s202parm\u00dd38\u00a8=s202parm\u00dd39\u00a8=0xff;\n    /* and issue the SVC */\n    ret = __SVC202 ( s202parm, &code, &parm );\n\n    have_sysparm = (ret != 24);\n\n\n    /* if no parameters are provided, the tokenized\n       plist will start with x'ff'. However, if they\n       have provided a SYSPARM, then we'll use that\n       as the parameter. But only if they haven't\n       provided any parameters! If they have provided\n       parameters then we instead lowercase everything\n       and go to special processing (useful when in\n       an EXEC with CONTROL MSG etc). */\n\n    /* No parameters */\n    if (p\u00dd0\u00a8 == 0xff)\n    {\n        parmLen = 0;\n\n        if (have_sysparm)\n        {\n            FILE *pf;\n\n            /* have a parameter file - let's use it */\n            pf = fopen(\"dd:SYSPARM\", \"r\");\n            if (pf != NULL)\n            {\n                fgets(parmbuf + 2, sizeof parmbuf - 2, pf);\n                fclose(pf);\n                p = strchr(parmbuf + 2, '\\n');\n                if (p != NULL)\n                {\n                    *p = '\\0';\n                }\n                parmLen = strlen(parmbuf + 2);\n            }\n        }\n    }\n    /* If there is no EPLIST, or there is a SYSPARM so\n       they are invoking special processing, then we\n       will be using the PLIST only. */\n    else if ((eplist == NULL) || have_sysparm)\n    {\n        /* copy across the tokenized plist, which\n           consists of 8 character chunks, space-padded,\n           and terminated by x'ff'. Note that the first\n           2 characters of parmbuf are reserved for an\n           (unused) length, so we must skip them */\n        for (x = 0; x < sizeof parmbuf / 9 - 1; x++)\n        {\n            if (p\u00ddx * 8\u00a8 == 0xff) break;\n            memcpy(parmbuf + 2 + x * 9, p + x * 8, 8);\n            parmbuf\u00dd2 + x * 9 + 8\u00a8 = ' ';\n        }\n        parmbuf\u00dd2 + x * 9\u00a8 = '\\0';\n        parmLen = strlen(parmbuf + 2);\n\n        /* even though we have a SYSPARM, we don't use it,\n           we just use it as a signal to do some serious\n           underscore searching! */\n        if (have_sysparm)\n        {\n            char *q;\n            char *r;\n            char *lock;\n            int cnt = 0;\n            int c;\n            int shift = 0;\n            int rev = 0; /* reverse logic */\n\n            q = parmbuf + 2;\n            r = q;\n            lock = q;\n\n            /* reverse the case switching when _+ is specified\n               as the first parameter */\n            if (memcmp(r, \"_+\", 2) == 0)\n            {\n                rev = 1;\n                cnt += 2;\n                r += 2;\n            }\n            while (*r != '\\0')\n            {\n                cnt++;\n                if (rev)\n                {\n                    c = toupper((unsigned char)*r);\n                }\n                else\n                {\n                    c = tolower((unsigned char)*r);\n                }\n                if (shift && (c != ' '))\n                {\n                    if (rev)\n                    {\n                        c = tolower((unsigned char)*r);\n                    }\n                    else\n                    {\n                        c = toupper((unsigned char)*r);\n                    }\n                    shift = 0;\n                }\n                if (c == '_')\n                {\n                    shift = 1;\n                }\n                /* if we've reached the inter-parameter space, then\n                   collapse it - a space requires a shift */\n                else if (cnt == 9)\n                {\n                    while (q > lock)\n                    {\n                        q--;\n                        if (*q != ' ')\n                        {\n                            q++;\n                            lock = q;\n                            break;\n                        }\n                    }\n                    cnt = 0;\n                    if (shift)\n                    {\n                        *q++ = ' ';\n                        shift = 0;\n                    }\n                }\n                else if (c != ' ')\n                {\n                    *q++ = c;\n                }\n                r++;\n            }\n            *q = '\\0';\n            parmLen = strlen(parmbuf + 2);\n        }\n    }\n    /* else, we have an eplist, and no sysparm, so use that */\n    else\n    {\n        parmLen = eplist\u00dd2\u00a8 - eplist\u00dd1\u00a8;\n        /* 2 bytes reserved for an unused length, 1 byte for NUL */\n        if (parmLen >= sizeof parmbuf - 2)\n        {\n            parmLen = sizeof parmbuf - 1 - 2;\n        }\n        memcpy(parmbuf + 2, eplist\u00dd1\u00a8, parmLen);\n    }\n#elif defined(__VSE__)\n    __upsi = pgmname\u00dd9\u00a8; /* we shouldn't really clump this */\n\n    if (ep != NULL)\n    {\n        ep = *(char **)ep;\n    }\n    /* The ep only has a genuine value if the top bit is set */\n    if (((unsigned int)ep & 0x80000000) != 0)\n    {\n        /* it is a 24-bit address */\n        ep = (char *)((unsigned int)ep & 0x00ffffff);\n        parmLen = *(short *)ep;\n        memcpy(parmbuf + 2, ep + 2, parmLen);\n    }\n    /* if no parm, use SYSPARM instead */\n    else if (p\u00dd0\u00a8 != 0)\n    {\n        /* in the special case of a \"?\", inspect the UPSI switches */\n        if ((p\u00dd0\u00a8 == 1) && (p\u00dd1\u00a8 == '?'))\n        {\n            /* user is required to set all switches to 0. All\n               are reserved, except for the first one, which\n               says that the parameter will be read from SYSINPT */\n            if (__upsi & 0x80)\n            {\n                fgets(parmbuf + 2, sizeof parmbuf - 2, stdin);\n                p = strchr(parmbuf + 2, '\\n');\n                if (p != NULL)\n                {\n                    *p = '\\0';\n                }\n                parmLen = strlen(parmbuf + 2);\n            }\n            else\n            {\n                parmLen = 0;\n            }\n        }\n        /* for all other parameter values, just use as-is */\n        else\n        {\n            parmLen = p\u00dd0\u00a8;\n            memcpy(parmbuf + 2, p + 1, parmLen);\n        }\n\n    }\n    /* otherwise there is no parm */\n    else\n    {\n        parmLen = 0;\n    }\n#else /* MVS etc */\n    parmLen = ((unsigned int)p\u00dd0\u00a8 << 8) | (unsigned int)p\u00dd1\u00a8;\n    if (parmLen >= sizeof parmbuf - 2)\n    {\n        parmLen = sizeof parmbuf - 1 - 2;\n    }\n    /* We copy the parameter into our own area because\n       the caller hasn't necessarily allocated room for\n       a terminating NUL, nor is it necessarily correct\n       to clobber the caller's area with NULs. */\n    memcpy(parmbuf, p, parmLen + 2);\n#endif\n    p = parmbuf;\n#ifdef __MVS__\n    if (__tso)\n#else\n    if (0)\n#endif\n    {\n        progLen = ((unsigned int)p\u00dd2\u00a8 << 8) | (unsigned int)p\u00dd3\u00a8;\n        parmLen -= (progLen + 4);\n        argv\u00dd0\u00a8 = p + 4;\n        p += (progLen + 4);\n        if (parmLen > 0)\n        {\n            *(p - 1) = '\\0';\n        }\n        else\n        {\n            *p = '\\0';\n        }\n        p\u00ddparmLen\u00a8 = '\\0';\n    }\n    else         /* batch or tso \"call\" */\n    {\n        progLen = 0;\n        p += 2;\n        argv\u00dd0\u00a8 = pgmname;\n        pgmname\u00dd8\u00a8 = '\\0';\n        pgmname = strchr(pgmname, ' ');\n        if (pgmname != NULL)\n        {\n            *pgmname = '\\0';\n        }\n        if (parmLen > 0)\n        {\n            p\u00ddparmLen\u00a8 = '\\0';\n        }\n        else\n        {\n            p = \"\";\n        }\n    }\n#endif\n\n#ifdef __OS2__\n    reqFH = 0;\n    DosSetRelMaxFH(&reqFH, &maxFH);\n    if (maxFH < (FOPEN_MAX + 10))\n    {\n        reqFH = FOPEN_MAX - maxFH + 10;\n        DosSetRelMaxFH(&reqFH, &maxFH);\n    }\n#endif\n    for (x=0; x < __NFILE; x++)\n    {\n        __userFiles\u00ddx\u00a8 = NULL;\n    }\n#ifdef __OS2__\n    argv\u00dd0\u00a8 = p;\n    p += strlen(p) + 1;\n#endif\n#ifdef __WIN32__\n    argv\u00dd0\u00a8 = p;\n    p = strchr(p, ' ');\n    if (p == NULL)\n    {\n        p = \"\";\n    }\n    else\n    {\n        *p = '\\0';\n        p++;\n    }\n#endif\n#if defined(__MSDOS__) || (defined(__PDOS__) && !defined(__MVS__))\n    argv\u00dd0\u00a8 = \"\";\n\n#ifdef __MSDOS__\n    if(__osver > 0x300)\n    {\n        env=__envptr;\n        while (1)\n        {\n            if (*env++ == '\\0' && *env++ == '\\0')\n            {\n                if (*(unsigned short *)env != 0)\n                {\n                    argv\u00dd0\u00a8 = (char *)env + 2;\n                }\n                break;\n            }\n        }\n    }\n#endif\n    p = p + 0x80;\n    p\u00dd*p + 1\u00a8 = '\\0';\n    p++;\n#endif\n#if !defined(__gnu_linux__)\n    while (*p == ' ')\n    {\n        p++;\n    }\n    if (*p == '\\0')\n    {\n        argv\u00dd1\u00a8 = NULL;\n        argc = 1;\n    }\n    else\n    {\n        for (x = 1; x < MAXPARMS; )\n        {\n            char srch = ' ';\n\n            if (*p == '\"')\n            {\n                p++;\n                srch = '\"';\n            }\n            argv\u00ddx\u00a8 = p;\n            x++;\n            p = strchr(p, srch);\n            if (p == NULL)\n            {\n                break;\n            }\n            else\n            {\n                *p = '\\0';\n                p++;\n                while (*p == ' ') p++;\n                if (*p == '\\0') break; /* strip trailing blanks */\n            }\n        }\n        argv\u00ddx\u00a8 = NULL;\n        argc = x;\n    }\n#endif\n#ifdef PDOS_MAIN_ENTRY\n    *i1 = argc;\n    *i2 = (int)argv;\n    return (0);\n#else\n\n#ifdef __MAIN_FP__\n    rc = __main_fp(argc, argv);\n#else\n    rc = main(argc, argv);\n#endif\n    __exit(rc);\n    return (rc);\n#endif\n}\n\nvoid __exit(int status)\n{\n    int x;\n\n#if 0\n    for (x = __NATEXIT - 1; x >= 0; x--)\n    {\n        if (__userExit\u00ddx\u00a8 != 0)\n        {\n            (__userExit\u00ddx\u00a8)();\n        }\n    }\n#endif\n\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles\u00ddx\u00a8 != NULL)\n        {\n#if defined(__VSE__)\n            /* this should be closed after the rest of the user files */\n            if (__userFiles\u00ddx\u00a8 != __stdpch)\n#endif\n            fclose(__userFiles\u00ddx\u00a8);\n        }\n    }\n\n#if defined(__VSE__)\n    if (__stdpch != NULL) fclose(__stdpch);\n#endif\n\n    if (stdout != NULL) fflush(stdout);\n    if (stderr != NULL) fflush(stderr);\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    if (stdin != NULL) fclose(stdin);\n    if (stdout != NULL) fclose(stdout);\n    if (stderr != NULL) fclose(stderr);\n#endif\n\n\n#if USE_MEMMGR\n    memmgrTerm(&__memmgr);\n\n/* release memory for most circumstances, although a\n   better solution will be required eventually */\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    if (__lastsup != NULL)\n    {\n        __freem(__lastsup);\n    }\n#endif\n#endif /* USE_MEMMGR */\n\n\n#ifdef __WIN32__\n    ExitProcess(status);\n#else\n    __exita(status);\n#endif\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STDIO": {"ttr": 2568, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*  Modifications by Dave Edwards, released to the Public Domain     */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdio.c - implementation of stuff in stdio.h                     */\n/*                                                                   */\n/*  The philosophy of the PC/Unix/ASCII implementation is explained  */\n/*  here. For the MVS/CMS/EBCDIC implementation, see halfway down    */\n/*  this source file (or search for \"design of MVS\").                */\n/*                                                                   */\n/*  There is a static array containing pointers to file objects.     */\n/*  This is required in order to close all the files on program      */\n/*  termination.                                                     */\n/*                                                                   */\n/*  In order to give speed absolute priority, so that people don't   */\n/*  resort to calling DosRead themselves, there is a special flag    */\n/*  in the FILE object called \"quickbin\".  If this flag is set to 1  */\n/*  it means that it is a binary file and there is nothing in the    */\n/*  buffer and there are no errors, so don't stuff around, just call */\n/*  DosRead.                                                         */\n/*                                                                   */\n/*  When a buffer exists, which is most of the time, fbuf will point */\n/*  to it.  The size of the buffer is given by szfbuf.  upto will    */\n/*  point to the next character to be read.  endbuf will point PAST  */\n/*  the last valid character in the buffer.  bufStartR represents    */\n/*  the position in the file that the first character in the buffer  */\n/*  is at.  This is only updated when a new buffer is read in.       */\n/*                                                                   */\n/*  After file open, for a file being read, bufStartR will actually  */\n/*  be a negative number, which if added to the position of upto     */\n/*  will get to 0.  On a file being written, bufStartR will be set   */\n/*  to 0, and upto will point to the start of the buffer.  The       */\n/*  reason for the difference on the read is in order to tell the    */\n/*  difference between an empty buffer and a buffer with data in it, */\n/*  but which hasn't been used yet.  The alternative would be to     */\n/*  either keep track of a flag, or make fopen read in an initial    */\n/*  buffer.  But we want to avoid reading in data that no-one has    */\n/*  yet requested.                                                   */\n/*                                                                   */\n/*  The buffer is organized as follows...                            */\n/*  What we have is an internal buffer, which is 8 characters        */\n/*  longer than the actually used buffer.  E.g. say BUFSIZ is        */\n/*  512 bytes, then we actually allocate 520 bytes.  The first       */\n/*  2 characters will be junk, the next 2 characters set to NUL,     */\n/*  for protection against some backward-compares.  The fourth-last  */\n/*  character is set to '\\n', to protect against overscan.  The      */\n/*  last 3 characters will be junk, to protect against memory        */\n/*  violation.  intBuffer is the internal buffer, but everyone       */\n/*  refers to fbuf, which is actually set to the &intBuffer\u00dd4\u00a8.      */\n/*  Also, szfbuf is the size of the \"visible\" buffer, not the        */\n/*  internal buffer.  The reason for the 2 junk characters at the    */\n/*  beginning is to align the buffer on a 4-byte boundary.           */\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n#include \"stdarg.h\"\n#include \"ctype.h\"\n#include \"errno.h\"\n#include \"float.h\"\n#include \"limits.h\"\n#include \"stddef.h\"\n\n/* VSE is similar to MVS at the moment */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* PDOS/x86 and MSDOS use the same interface most of the time */\n/* Note that PDOS is for the 32-bit version, since the 16-bit\n   version uses the MSDOS version since it is compatible with it */\n/* linux is pretty similar too */\n#if (defined(__PDOS__) && !defined(__MVS__)) || defined(__gnu_linux__)\n#define __MSDOS__\n#endif\n\n#if defined(__MSDOS__) && !defined(__gnu_linux__)\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nextern int CTYP __open(const char *filename, int mode, int *errind);\nextern int CTYP __read(int handle, void *buf, size_t len, int *errind);\nextern int CTYP __write(int handle, const void *buf, size_t len, int *errind);\nextern void CTYP __seek(int handle, long offset, int whence);\nextern void CTYP __close(int handle);\nextern void CTYP __remove(const char *filename);\nextern void CTYP __rename(const char *old, const char *newnam);\n#endif\n\n#ifdef __OS2__\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#define FIXED_BINARY 0\n#define VARIABLE_BINARY 1\n#define FIXED_TEXT 2\n#define VARIABLE_TEXT 3\n#endif\n\n#if defined(__gnu_linux__)\n\nextern int __open(const char *a, int b, int c);\nextern int __write(int a, const void *b, int c);\nextern int __read(int a, void *b, int c);\n\n#define O_WRONLY 0x1\n#define O_CREAT  0x40\n#define O_TRUNC  0x200\n#define O_RDONLY 0x0\n\nstatic int open(const char *a, int b, int *c)\n{\n    int ret;\n\n    *c = 0;\n    if (b)\n    {\n        ret = __open(a, O_WRONLY | O_CREAT | O_TRUNC, 0664);\n    }\n    else\n    {\n        ret = __open(a, O_RDONLY, 0);\n    }\n    if (ret < 0)\n    {\n        *c = 1;\n    }\n    return (ret);\n}\n\n#define __open(a,b,c) (open((a),(b),(c)))\n#define __write(a,b,c,d) (*(d) = 0, (__write)((a),(b),(c)))\n#define __read(a,b,c,d) (*(d) = 0, (__read)((a),(b),(c)))\n\n#endif\n\nstatic FILE permFiles\u00dd3\u00a8;\n\n#define unused(x) ((void)(x))\n#define outch(ch) ((fq == NULL) ? *s++ = (char)ch : putc(ch, fq))\n#define inch() ((fp == NULL) ? \\\n    (ch = (unsigned char)*s++) : (ch = getc(fp)))\n\n/* We need to choose whether we are doing move mode or\n   locate mode */\n#if !LOCMODE /* move mode */\n\n\n#if defined(__VSE__)\n\n/* for VSE, library files are actually written to memory\n   during processing */\n\n#define lbegwrite(stream, len) \\\n   ( \\\n    ((stream)->vselupto + (len) > (stream->vselend)) ? \\\n     (lenwrite = 0, dptr = NULL) : \\\n     (lenwrite = (len), dptr = (unsigned char *)(stream)->vselupto) \\\n   )\n#define lfinwrite(stream) (((stream)->vselupto += lenwrite), lenwrite)\n\n#define vbegwrite(stream, len) (lenwrite = (len), dptr = (stream)->asmbuf)\n#define vfinwrite(stream) (__awrite((stream)->hfile, &dptr, &lenwrite))\n\n#define begwrite(stream, len) ((stream)->vse_punch ? \\\n    lbegwrite((stream), (len)) : vbegwrite((stream), (len)))\n#define finwrite(stream) ((stream)->vse_punch ? \\\n    lfinwrite(stream) : vfinwrite(stream))\n\n#else\n#define begwrite(stream, len) (lenwrite = (len), dptr = (stream)->asmbuf)\n#define finwrite(stream) (__awrite((stream)->hfile, &dptr, &lenwrite))\n#endif\n\n#else /* locate mode */\n#define begwrite(stream, len) (lenwrite = (len), \\\n    __awrite((stream)->hfile, &dptr, &lenwrite))\n#define finwrite(stream)\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\nint __doperm = 0; /* are we doing the permanent datasets? */\nextern int __tso; /* are we in a TSO environment? */\nstatic unsigned char *dptr;\nstatic size_t lenwrite;\nstatic int    inseek = 0;\nstatic size_t lenread;\n#define __aread(a,b) ((__aread)((a),(b),&lenread))\n#endif\n\n\nFILE *__stdin = &permFiles\u00dd0\u00a8;\nFILE *__stdout = &permFiles\u00dd1\u00a8;\nFILE *__stderr = &permFiles\u00dd2\u00a8;\n\nFILE *__userFiles\u00dd__NFILE\u00a8;\nstatic FILE  *myfile;\nstatic int    spareSpot;\nstatic int    err;\nstatic int    inreopen = 0;\n\n/* for VSE library files being punched */\n#define VSE_LIB_LIM 1000000\nstatic char *__vsepb = NULL;\nFILE *__stdpch = NULL;\n\nstatic const char *fnm;\nstatic const char *modus;\nstatic int modeType;\n\n__PDPCLIB_API__ FILE **__gtin()\n    { return(&__stdin); }\n__PDPCLIB_API__ FILE **__gtout()\n    { return(&__stdout); }\n__PDPCLIB_API__ FILE **__gterr()\n    { return(&__stderr); }\n\nstatic void dblcvt(double num, char cnvtype, size_t nwidth,\n                   int nprecision, char *result);\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s);\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s);\nstatic void fopen2(void);\nstatic void fopen3(void);\nstatic void findSpareSpot(void);\nstatic void checkMode(void);\nstatic void osfopen(void);\n\n#if !defined(__MVS__) && !defined(__CMS__)\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten);\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten);\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead);\n#endif\n\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount);\n\n#if defined(__CMS__) || defined(__MVS__)\nstatic void filedef(char *fdddname, char *fnm, int mymode);\nstatic void fdclr(char *ddname);\n#endif\n#ifdef __CMS__\nextern void __SVC202 ( char *s202parm, int *code, int *parm );\nstatic int cmsrename(const char *old, const char *newnam);\nstatic int cmsremove(const char *filename);\nstatic char *int_strtok(char *s1, const char *s2);\n#define strtok int_strtok\n#endif\n\n\n__PDPCLIB_API__ int printf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vfprintf(stdout, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int fprintf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vfprintf(stream, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int vfprintf(FILE *stream, const char *format, va_list arg)\n{\n    int ret;\n\n    stream->quickText = 0;\n    ret = vvprintf(format, arg, stream, NULL);\n    return (ret);\n}\n\n__PDPCLIB_API__ FILE *fopen(const char *filename, const char *mode)\n{\n#if defined(__VSE__)\n    char *p;\n    char *q;\n    char memname\u00dd9\u00a8;\n    int memlen;\n    char phase\u00dd80\u00a8;\n\n    /* for VSE, we cannot write directly to a library, we\n       instead need to punch appropriate controls */\n    /* note that both w and wb are treated the same */\n    if ((*mode == 'w') && ((p = strchr(filename, '(')) != NULL))\n    {\n        q = strchr(filename, ')');\n        if (q <= p) return (NULL);\n        memlen = q - p - 1;\n        if (memlen > (sizeof memname - 1))\n        {\n            memlen = (sizeof memname - 1);\n        }\n        memcpy(memname, p + 1, memlen);\n        memname\u00ddmemlen\u00a8 = '\\0';\n        for (p = memname; *p != '\\0'; p++)\n        {\n            *p = toupper((unsigned char)*p);\n        }\n        if (__stdpch == NULL)\n        {\n            __vsepb = malloc(VSE_LIB_LIM + 4);\n            if (__vsepb == NULL) return (NULL);\n            __stdpch = fopen(\"dd:syspunch\", \"wb\");\n            if (__stdpch != NULL)\n            {\n                __stdpch->vse_punch = 2;\n                __stdpch->vselupto = __vsepb;\n                __stdpch->vselend = __vsepb + VSE_LIB_LIM;\n                __stdpch->reallyu = 1;\n            }\n        }\n        if (__stdpch != NULL)\n        {\n            __stdpch->vse_punch = 0;\n            memset(phase, ' ', sizeof phase);\n            sprintf(phase, \" PHASE %s,*\", memname);\n            phase\u00ddstrlen(phase)\u00a8 = ' ';\n            fwrite(phase, 1, sizeof phase, __stdpch);\n            __stdpch->vse_punch = 2; /* in an active file */\n        }\n        return (__stdpch);\n    }\n#endif\n    fnm = filename;\n    modus = mode;\n    err = 0;\n    findSpareSpot();\n    if (!err)\n    {\n        myfile = malloc(sizeof(FILE));\n        if (myfile == NULL)\n        {\n            err = 1;\n        }\n        else\n        {\n            fopen2();\n            if (err)\n            {\n                free(myfile);\n            }\n        }\n    }\n    if (err)\n    {\n        myfile = NULL;\n    }\n#if defined(__VSE__)\n    else\n    {\n        myfile->vse_punch = 0;\n    }\n#endif\n    return (myfile);\n}\n\nstatic void fopen2(void)\n{\n    checkMode();\n    if (!err)\n    {\n        strcpy(myfile->modeStr, modus);\n        osfopen();\n        if (!err)\n        {\n            __userFiles\u00ddspareSpot\u00a8 = myfile;\n            myfile->intFno = spareSpot;\n            fopen3();\n        }\n    }\n    return;\n}\n\nstatic void fopen3(void)\n{\n    myfile->intBuffer = malloc(BUFSIZ + 8);\n    if (myfile->intBuffer == NULL)\n    {\n        err = 1;\n    }\n    else\n    {\n        myfile->theirBuffer = 0;\n        myfile->fbuf = myfile->intBuffer + 2;\n        *myfile->fbuf++ = '\\0';\n        *myfile->fbuf++ = '\\0';\n        myfile->szfbuf = BUFSIZ;\n#if !defined(__MVS__) && !defined(__CMS__)\n        myfile->quickText = 0;\n#endif\n        myfile->noNl = 0;\n        myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n        *myfile->endbuf = '\\n';\n#if defined(__MVS__) || defined(__CMS__)\n        myfile->upto = myfile->fbuf;\n        myfile->szfbuf = myfile->lrecl;\n        myfile->endbuf = myfile->fbuf; /* for read only */\n#else\n        myfile->upto = myfile->endbuf;\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n        myfile->bufStartR = 0;\n#else\n        myfile->bufStartR = -(long)myfile->szfbuf;\n#endif\n        myfile->errorInd = 0;\n        myfile->eofInd = 0;\n        myfile->ungetCh = -1;\n        myfile->update = 0;\n        if (!inreopen)\n        {\n            myfile->permfile = 0;\n        }\n        myfile->isopen = 1;\n#if !defined(__MVS__) && !defined(__CMS__)\n        if (!myfile->textMode)\n        {\n            myfile->quickBin = 1;\n        }\n        else\n        {\n            myfile->quickBin = 0;\n        }\n#endif\n        myfile->mode = __READ_MODE;\n        switch (modeType)\n        {\n            case 2:\n            case 3:\n            case 5:\n            case 6:\n            case 8:\n            case 9:\n            case 11:\n            case 12:\n                myfile->bufStartR = 0;\n                myfile->upto = myfile->fbuf;\n                myfile->mode = __WRITE_MODE;\n#if defined(__MVS__) || defined(__CMS__)\n                myfile->endbuf = myfile->fbuf + myfile->szfbuf;\n#endif\n                break;\n        }\n        switch (modeType)\n        {\n            case 7:\n            case 8:\n            case 10:\n            case 11:\n            case 12:\n                myfile->update = 1;\n                break;\n        }\n    }\n    return;\n}\n\nstatic void findSpareSpot(void)\n{\n    int x;\n\n    for (x = 0; x < __NFILE; x++)\n    {\n        if (__userFiles\u00ddx\u00a8 == NULL)\n        {\n            break;\n        }\n    }\n    if (x == __NFILE)\n    {\n        err = 1;\n    }\n    else\n    {\n        spareSpot = x;\n    }\n    return;\n}\n\n/* checkMode - interpret mode string */\n/* r = 1 */\n/* w = 2 */\n/* a = 3 */\n/* rb = 4 */\n/* wb = 5 */\n/* ab = 6 */\n/* r+ = 7 */\n/* w+ = 8 */\n/* a+ = 9 */\n/* r+b or rb+ = 10 */\n/* w+b or wb+ = 11 */\n/* a+b or ab+ = 12 */\n\nstatic void checkMode(void)\n{\n    if (strncmp(modus, \"r+b\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"rb+\", 3) == 0)\n    {\n        modeType = 10;\n    }\n    else if (strncmp(modus, \"w+b\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"wb+\", 3) == 0)\n    {\n        modeType = 11;\n    }\n    else if (strncmp(modus, \"a+b\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"ab+\", 3) == 0)\n    {\n        modeType = 12;\n    }\n    else if (strncmp(modus, \"r+\", 2) == 0)\n    {\n        modeType = 7;\n    }\n    else if (strncmp(modus, \"w+\", 2) == 0)\n    {\n        modeType = 8;\n    }\n    else if (strncmp(modus, \"a+\", 2) == 0)\n    {\n        modeType = 9;\n    }\n    else if (strncmp(modus, \"rb\", 2) == 0)\n    {\n        modeType = 4;\n    }\n    else if (strncmp(modus, \"wb\", 2) == 0)\n    {\n        modeType = 5;\n    }\n    else if (strncmp(modus, \"ab\", 2) == 0)\n    {\n        modeType = 6;\n    }\n    else if (strncmp(modus, \"r\", 1) == 0)\n    {\n        modeType = 1;\n    }\n    else if (strncmp(modus, \"w\", 1) == 0)\n    {\n        modeType = 2;\n    }\n    else if (strncmp(modus, \"a\", 1) == 0)\n    {\n        modeType = 3;\n    }\n    else\n    {\n        err = 1;\n        return;\n    }\n    if ((modeType == 4)\n        || (modeType == 5)\n        || (modeType == 6)\n        || (modeType == 10)\n        || (modeType == 11)\n        || (modeType == 12))\n    {\n        myfile->textMode = 0;\n    }\n    else\n    {\n        myfile->textMode = 1;\n    }\n    return;\n}\n\nstatic void osfopen(void)\n{\n#ifdef __OS2__\n    APIRET rc;\n    ULONG  action;\n    ULONG  newsize = 0;\n    ULONG  fileAttr = 0;\n    ULONG  openAction = 0;\n    ULONG  openMode = 0;\n\n    if ((modeType == 1) || (modeType == 4) || (modeType == 7)\n        || (modeType == 10))\n    {\n        openAction |= OPEN_ACTION_FAIL_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    else if ((modeType == 2) || (modeType == 5) || (modeType == 8)\n             || (modeType == 11))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_REPLACE_IF_EXISTS;\n    }\n    else if ((modeType == 3) || (modeType == 6) || (modeType == 9)\n             || (modeType == 12))\n    {\n        openAction |= OPEN_ACTION_CREATE_IF_NEW;\n        openAction |= OPEN_ACTION_OPEN_IF_EXISTS;\n    }\n    openMode |= OPEN_SHARE_DENYWRITE;\n    if ((modeType == 1) || (modeType == 4))\n    {\n        openMode |= OPEN_ACCESS_READONLY;\n    }\n    else if ((modeType == 2) || (modeType == 3) || (modeType == 5)\n             || (modeType == 6))\n    {\n        openMode |= OPEN_ACCESS_WRITEONLY;\n    }\n    else\n    {\n        openMode |= OPEN_ACCESS_READWRITE;\n    }\n    if ((strlen(fnm) == 2)\n        && (fnm\u00dd1\u00a8 == ':')\n        && (openMode == OPEN_ACCESS_READONLY))\n    {\n        openMode |= OPEN_FLAGS_DASD;\n    }\n    rc = DosOpen((PSZ)fnm,\n                 &myfile->hfile,\n                 &action,\n                 newsize,\n                 fileAttr,\n                 openAction,\n                 openMode,\n                 NULL);\n    if (rc != 0)\n    {\n        err = 1;\n        errno = rc;\n    }\n#endif\n#ifdef __WIN32__\n    DWORD dwDesiredAccess = 0;\n    DWORD dwShareMode = FILE_SHARE_READ;\n    DWORD dwCreationDisposition = 0;\n    DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;\n\n    if ((modeType == 1) || (modeType == 4) || (modeType == 7)\n        || (modeType == 10))\n    {\n        dwCreationDisposition = OPEN_EXISTING;\n    }\n    else if ((modeType == 2) || (modeType == 5) || (modeType == 8)\n             || (modeType == 11))\n    {\n        dwCreationDisposition = CREATE_ALWAYS;\n    }\n    else if ((modeType == 3) || (modeType == 6) || (modeType == 9)\n             || (modeType == 12))\n    {\n        dwCreationDisposition = CREATE_ALWAYS;\n    }\n    if ((modeType == 1) || (modeType == 4))\n    {\n        dwDesiredAccess = GENERIC_READ;\n    }\n    else if ((modeType == 2) || (modeType == 3) || (modeType == 5)\n             || (modeType == 6))\n    {\n        dwDesiredAccess = GENERIC_WRITE;\n    }\n    else\n    {\n        dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n    }\n    myfile->hfile = CreateFile(fnm,\n                               dwDesiredAccess,\n                               dwShareMode,\n                               NULL,\n                               dwCreationDisposition,\n                               dwFlagsAndAttributes,\n                               NULL);\n    if (myfile->hfile == INVALID_HANDLE_VALUE)\n    {\n        err = 1;\n        errno = GetLastError();\n    }\n#endif\n#ifdef __MSDOS__\n    int mode;\n    int errind;\n\n    if ((modeType == 1) || (modeType == 4))\n    {\n        mode = 0; /* read */\n    }\n    else if ((modeType == 2) || (modeType == 5))\n    {\n        mode = 1; /* write */\n    }\n    else\n    {\n        mode = 2; /* update or otherwise unsupported */\n        /* because we don't have the ability to update files\n           at the moment on MSDOS, just return with an\n           error immediately */\n        err = 1;\n        errno = 2;\n        return;\n    }\n    myfile->hfile = __open(fnm, mode, &errind);\n    if (errind)\n    {\n        err = 1;\n        errno = myfile->hfile;\n    }\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    int mode;\n    char *p;\n    int len;\n    char newfnm\u00ddFILENAME_MAX\u00a8;\n    char tmpdd\u00dd9\u00a8;\n\n    if ((modeType == 1) || (modeType == 4))\n    {\n        mode = 0;\n    }\n    else if ((modeType == 2) || (modeType == 5))\n    {\n        mode = 1;\n    }\n    else\n    {\n        mode = 2;\n\n        /* because we don't have the ability to update files\n           at the moment on MVS or CMS, just return with an\n           error immediately */\n        err = 1;\n        errno = 2;\n        return;\n    }\n\n    myfile->pdsmem\u00dd0\u00a8 = '\\0'; /* seek needs to know if member provided */\n\n    if (!inseek)\n    {\n        myfile->dynal = 0;\n    }\n/* dw */\n/* This code needs changing for VM */\n    p = strchr(fnm, ':');\n    if ((p != NULL)\n        && ((strncmp(fnm, \"dd\", 2) == 0)\n            || (strncmp(fnm, \"DD\", 2) == 0)))\n    {\n        p++;\n    }\n    else\n/* if we are in here then there is no \"dd:\" on front of file */\n/* if its CMS generate a ddname and issue a filedef for the file */\n#if defined(__CMS__)\n    {\n/* create a DD from the handle number */\n        strcpy(newfnm, fnm);\n        p = newfnm;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        sprintf(tmpdd, \"PDP%03dHD\", spareSpot);\n        filedef(tmpdd, newfnm, mode);\n        myfile->dynal = 1;\n        p = tmpdd;\n    }\n#elif defined(__MVS__)\n\n#if !defined(MUSIC) /* for MUSIC, send everything through to SVC99 */\n    if ((strchr(fnm, '\\'') == NULL) && (strchr(fnm, '(') == NULL))\n#endif\n    {\n        strcpy(newfnm, fnm);\n        p = newfnm;\n\n        /* The SVC 99 interface on MVS requires an uppercase\n           filename in order to be found via a catalog search */\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        /* create a DD from the handle number */\n        sprintf(tmpdd, \"PDP%03dHD\", spareSpot);\n        fdclr(tmpdd); /* unconditionally clear */\n        filedef(tmpdd, newfnm, mode);\n        if (err) return;\n        myfile->dynal = 1;\n        p = tmpdd;\n    }\n\n#if !defined(MUSIC)\n    /* This is our traditional function for MVS. Keep it for now,\n       for the complex strings. For the simple strings, which\n       are always used on environments such as PDOS and MUSIC,\n       use the code above instead. */\n    else\n    {\n        char rawf\u00ddFILENAME_MAX\u00a8; /* file name without member,\n                                    suitable for dynamic allocation */\n\n        sprintf(newfnm, \"PDP%03dHD\", spareSpot);\n        strcpy(tmpdd, newfnm);\n\n        /* strip any single quote */\n        if (fnm\u00dd0\u00a8 == '\\'')\n        {\n            fnm++;\n        }\n        strcpy(rawf, fnm);\n\n        /* If we have a file such as \"'FRED.C(MARY)'\" we need to\n           convert this into PDP001HD(MARY) and do a dynamic\n           allocation of PDP001HD to \"FRED.C\". We don't yet have\n           the ability to add a prefix. So this involves\n           extracting the member name and then eliminating the member\n           name and any single quotes */\n        p = strchr(rawf, '(');\n        if (p != NULL)\n        {\n            *p = '\\0';\n            p++;\n            strcat(newfnm, \"(\");\n            strcat(newfnm, p);\n\n            p = strchr(newfnm, ')');\n            if (p != NULL)\n            {\n                *(p + 1) = '\\0';\n            }\n        }\n        else\n        {\n            /* strip any single quote */\n            p = strchr(rawf, '\\'');\n            if (p != NULL)\n            {\n                *p = '\\0';\n            }\n        }\n\n        /* MVS requires uppercase filenames */\n        p = rawf;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n\n        /* dynamically allocate file */\n        errno = __dynal(strlen(tmpdd), tmpdd, strlen(rawf), rawf);\n        if (errno != 0)\n        {\n            err = 1;\n            return;\n        }\n        myfile->dynal = 1;\n\n        p = newfnm;\n    }\n#endif /* MUSIC */\n\n#else\n    {\n        p = (char *)fnm;\n    }\n#endif\n    strcpy(myfile->ddname, \"        \");\n    len = strcspn(p, \"(\");\n    if (len > 8)\n    {\n        len = 8;\n    }\n    memcpy(myfile->ddname, p, len);\n    p = myfile->ddname;\n    while (*p != '\\0')\n    {\n        *p = toupper((unsigned char)*p);\n        p++;\n    }\n\n    p = strchr(fnm, '(');\n    if (p != NULL)\n    {\n        p++;\n        strcpy(myfile->pdsmem, \"        \");\n        len = strcspn(p, \")\");\n        if (len > 8)\n        {\n            len = 8;\n        }\n        memcpy(myfile->pdsmem, p, len);\n        p = myfile->pdsmem;\n        while (*p != '\\0')\n        {\n            *p = toupper((unsigned char)*p);\n            p++;\n        }\n        p = myfile->pdsmem;\n    }\n    myfile->reallyu = 0;\n    myfile->reallyt = 0;\n    myfile->asmbuf = 0;\n\n    /* Set some default DCB info. Stress - this will not interfere\n       in any way with DCB information the user provides in JCL,\n       or on an existing dataset. It is only used when all else\n       fails */\n    if (myfile->textMode)\n    {\n        myfile->recfm = __RECFM_V;\n        myfile->lrecl = 255;\n        myfile->blksize = 6233;\n    }\n    else\n    {\n        myfile->recfm = __RECFM_U;\n        myfile->lrecl = 0;\n        myfile->blksize = 6233;\n    }\n#if defined(__MVS__)\n    /* If we are dealing with SYSIN/SYSPRINT/SYSTERM and we are\n       in a TSO environment, then we should use GETLINE/PUTLINE\n       by default, as you would expect for any other TSO\n       command, like LISTCAT. If people don't want that, they\n       should do a \"CALL\" to invoke the program as a\n       non-TSO-command-processor */\n    if (__tso\n        && (__doperm\n            || (myfile->permfile && inreopen))\n       )\n    {\n        mode |= 0x80; /* use PUTLINE/GETLINE if available */\n    }\n#endif\n    myfile->hfile =\n        __aopen(myfile->ddname, &mode, &myfile->recfm, &myfile->lrecl,\n                &myfile->blksize, &myfile->asmbuf, p);\n#if defined(__MVS__)\n    mode &= ~0x80; /* don't expose other logic to GETLINE/PUTLINE */\n#endif\n    /* if this is a unit record device, note that */\n    myfile->line_buf = ((mode & 0x40) != 0);\n    mode &= ~0x40;\n\n    /* errors from MVS __aopen are negative numbers */\n    if ((int)myfile->hfile <= 0)\n    {\n        err = 1;\n        errno = -(int)myfile->hfile;\n        return;\n    }\n    /* if we have a RECFM=U, do special processing */\n    if (myfile->recfm == __RECFM_U)\n    {\n        myfile->reallyu = 1;\n        myfile->quickBin = 0; /* switch off to be on the safe side */\n\n        /* if open for writing, kludge to switch to fixed */\n        if (mode == 1)\n        {\n            myfile->recfm = __RECFM_F;\n        }\n        /* if open for reading, kludge to switch to variable */\n        else if (mode == 0)\n        {\n            myfile->recfm = __RECFM_V;\n        }\n        /* we need to work with a decent lrecl in case the\n           assembler routine set the real thing */\n        if (myfile->lrecl == 0)\n        {\n            myfile->lrecl = myfile->blksize;\n            if (myfile->lrecl == 0)\n            {\n                __aclose(myfile);\n                err = 1;\n                errno = 1;\n                return;\n            }\n        }\n    }\n    /* if we have RECFM=V, the usable lrecl is 4 bytes shorter\n       than we are told, so just adjust that here */\n    else if (myfile->recfm == __RECFM_V)\n    {\n       if (myfile->lrecl > 4)\n       {\n           myfile->lrecl -= 4;\n       }\n    }\n\n    if ((modeType == 4) || (modeType == 5))\n    {\n        myfile->style = 0; /* binary */\n    }\n    else\n    {\n        myfile->style = 2; /* text */\n        /* for RECFM=U we use binary mode when reading or writing\n           text files as we don't want any translation done. But\n           record the fact that it was really text mode */\n        if (myfile->reallyu)\n        {\n            myfile->reallyt = 1;\n            myfile->style = 0;\n        }\n    }\n\n    /* by the time we reach here, there is no RECFM=U, so\n       we only have 2 forms of binary (starting at 0) and\n       two forms of text (starting at 2), so we just need\n       to add the recfm (0 or 1) to the above. It should\n       probably be done in a less complicated manner! */\n    myfile->style += myfile->recfm;\n\n    if (myfile->style == VARIABLE_TEXT)\n    {\n        myfile->quickText = 1;\n    }\n    else\n    {\n        myfile->quickText = 0;\n    }\n    if (myfile->style == FIXED_BINARY)\n    {\n        myfile->quickBin = 1;\n    }\n    else\n    {\n        myfile->quickBin = 0;\n    }\n#endif\n    return;\n}\n\n\n#if defined(__VSE__)\n\n#define CARDLEN 80\n#define MAXCDATA 56  /* maximum data bytes on TXT record */\n#define MAXRLEN (MAXCDATA * 10 - 4) /* maximum length of a single record */\n    /* the 4 is to ensure the length is never on a card by itself */\n\nstatic int vseCloseLib(FILE *stream)\n{\n    char card\u00ddCARDLEN\u00a8;\n    size_t cnt;\n    size_t tot;\n    size_t rem;\n    size_t upto;\n    size_t x;\n    size_t r;\n    size_t subtot;\n\n    stream->vse_punch = 0;\n\n    tot = stream->vselupto - __vsepb;\n    /* The file needs an EOF marker */\n    memset(__vsepb + tot, 0x00, 4);\n    tot += 4;\n\n    memset(card, ' ', sizeof card);\n    memcpy(card, \"\\x02\" \"ESD\", 4);\n    *(short *)(card + 10) = 0x20; /* length of this ESD is the minimal 0x20 */\n    *(short *)(card + 14) = 1; /* CSECT 1 */\n    memset(card + 16, ' ', 8); /* name is blank */\n\n    *(int *)(card + 24) = 0; /* assembled origin = 0 */\n    *(card + 24) = 0x04; /* PC for some reason */\n    *(int *)(card + 28) = 0; /* AMODE + length - for some reason we\n        don't need to set the length properly. */\n\n#if 0\n    /* is this required? */\n    *(int *)(card + 28) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n#endif\n\n    memcpy(card + 32, \"TOTO    \", 8); /* total? */\n\n    /* is this required? */\n    *(int *)(card + 44) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n    fwrite(card, 1, sizeof card, stream);\n\n    subtot = 0;\n    for (upto = 0; upto < tot; upto += rem)\n    {\n        rem = tot - upto;\n        if (rem > MAXRLEN)\n        {\n            rem = MAXRLEN;\n        }\n        for (x = 0; x < rem; x += r)\n        {\n            r = rem - x;\n            if (r > MAXCDATA)\n            {\n                r = MAXCDATA;\n            }\n            if ((x == 0) && (r > (MAXCDATA - sizeof(int))))\n            {\n                r -= sizeof(int);\n            }\n            memset(card, ' ', sizeof card);\n            memcpy(card, \"\\x02\" \"TXT\", 4);\n            *(int *)(card + 4) = subtot; /* origin */\n            card\u00dd4\u00a8 = ' ';\n            *(short *)(card + 10) = r + ((x == 0) ? sizeof(int) : 0);\n                /* byte count */\n            *(int *)(card + 12) = 1; /* CSECT 1 */\n            if (x == 0)\n            {\n                *(int *)(card + 16) = rem;\n                if ((upto + rem) >= tot)\n                {\n                    *(int *)(card + 16) -= 4;\n                }\n                memcpy(card + 16 + sizeof(int), __vsepb + upto, r);\n                subtot += (r + sizeof(int));\n            }\n            else\n            {\n                memcpy(card + 16, __vsepb + upto + x, r);\n                subtot += r;\n            }\n            fwrite(card, 1, sizeof card, stream);\n        }\n    }\n    memset(card, ' ', sizeof card);\n    memcpy(card, \"\\x02\" \"END\", 4);\n#if 0\n    /* is this required? */\n    *(int *)(card + 24) = tot +\n        (tot/MAXRLEN + ((tot % MAXRLEN) != 0)) * sizeof(int);\n#endif\n    fwrite(card, 1, sizeof card, stream);\n\n    stream->vselupto = __vsepb;\n    stream->vse_punch = 1; /* still the punch, but not active */\n\n    return (0);\n}\n#endif\n\n\n__PDPCLIB_API__ int fclose(FILE *stream)\n{\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n    if (!stream->isopen)\n    {\n        return (EOF);\n    }\n    fflush(stream);\n#ifdef __VSE__\n    /* only take action if in an active file */\n    if (stream->vse_punch == 2)\n    {\n        stream->upto = stream->fbuf;\n        stream->bufStartR = 0;\n        return (vseCloseLib(stream));\n    }\n    /* closing an inactive punch must be the real thing, so free\n       the buffer and go through the rest of the close logic. */\n    else if (stream->vse_punch == 1)\n    {\n        free(__vsepb);\n        __vsepb = NULL;\n    }\n#endif\n#ifdef __OS2__\n    rc = DosClose(stream->hfile);\n#endif\n#ifdef __WIN32__\n    rc = CloseHandle(stream->hfile);\n#endif\n#ifdef __MSDOS__\n    __close(stream->hfile);\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    if ((stream->mode == __WRITE_MODE) && (stream->upto != stream->fbuf))\n    {\n        if (stream->reallyu)\n        {\n            /* we should not get to here, because the flush would\n               have taken care of it. perhaps we can generate an\n               internal error */\n        }\n        else if (stream->textMode)\n        {\n            putc('\\n', stream);\n        }\n        else\n        {\n            size_t remain;\n            size_t x;\n\n            remain = stream->endbuf - stream->upto;\n            for (x = 0; x < remain; x++)\n            {\n                putc(0x00, stream);\n            }\n        }\n    }\n    __aclose(stream->hfile);\n#ifdef __CMS__\n    if (stream->dynal && !inseek)\n    {\n        fdclr(stream->ddname);\n    }\n#endif\n#endif\n    if (!stream->theirBuffer)\n    {\n#if !defined(__MVS__) && !defined(__CMS__) && !defined(__VSE__)\n        /* on the PC, permanent files have a static buffer */\n        if (!stream->permfile)\n#endif\n        free(stream->intBuffer);\n    }\n    if (!stream->permfile && !inreopen)\n    {\n        __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        free(stream);\n    }\n    else\n    {\n#if defined(__MVS__) || defined(__CMS__)\n        /* if we're not in the middle of freopen ... */\n        __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        if (!inreopen)\n        {\n            free(stream);\n            /* need to protect against the app closing the file\n               which it is allowed to */\n            if (stream == stdin)\n            {\n                stdin = NULL;\n            }\n            else if (stream == stdout)\n            {\n                stdout = NULL;\n            }\n            else if (stream == stderr)\n            {\n                stderr = NULL;\n            }\n        }\n#else\n        stream->isopen = 0;\n#endif\n    }\n#ifdef __OS2__\n    if (rc != 0)\n    {\n        errno = rc;\n        return (EOF);\n    }\n#endif\n#ifdef __WIN32__\n    if (!rc)\n    {\n        errno = GetLastError();\n        return (EOF);\n    }\n#endif\n    return (0);\n}\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ size_t fread(void *ptr,\n                             size_t size,\n                             size_t nmemb,\n                             FILE *stream)\n{\n    size_t toread;\n    size_t elemRead;\n    size_t actualRead;\n#ifdef __OS2__\n    APIRET rc;\n    ULONG tempRead;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    DWORD tempRead;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t tempRead;\n#endif\n\n    if (nmemb == 1)\n    {\n        toread = size;\n    }\n    else if (size == 1)\n    {\n        toread = nmemb;\n    }\n    else\n    {\n        toread = size * nmemb;\n    }\n    if (toread < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n    }\n    if (stream->ungetCh != -1)\n    {\n        *--stream->upto = (char)stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n    if (!stream->quickBin)\n    {\n        if (stream->textMode)\n        {\n            freadSlowT(ptr, stream, toread, &actualRead);\n        }\n        else\n        {\n            if (toread <= (stream->endbuf - stream->upto))\n            {\n                memcpy(ptr, stream->upto, toread);\n                actualRead = toread;\n                stream->upto += toread;\n            }\n            else\n            {\n                freadSlowB(ptr, stream, toread, &actualRead);\n            }\n        }\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n        }\n        else\n        {\n            if (size == 0)\n            {\n                elemRead = 0;\n            }\n            else\n            {\n                elemRead = actualRead / size;\n            }\n        }\n        return (elemRead);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, ptr, toread, &tempRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      ptr,\n                      toread,\n                      &tempRead,\n                      NULL);\n        if (!rc)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile, ptr, toread, &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n        else\n        {\n            actualRead = tempRead;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualRead == size)\n            {\n                elemRead = 1;\n            }\n            else\n            {\n                elemRead = 0;\n                stream->eofInd = 1;\n            }\n        }\n        else if (size == 1)\n        {\n            elemRead = actualRead;\n            if (nmemb != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        else\n        {\n            if (size == 0)\n            {\n                elemRead = 0;\n            }\n            else\n            {\n                elemRead = actualRead / size;\n            }\n            if (toread != actualRead)\n            {\n                stream->eofInd = 1;\n            }\n        }\n        stream->bufStartR += actualRead;\n        return (elemRead);\n    }\n}\n\n\n/*\nwhile toread has not been satisfied\n{\n    scan stuff out of buffer, replenishing buffer as required\n}\n*/\n\nstatic void freadSlowT(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    int finReading = 0;\n    size_t avail;\n    size_t need;\n    char *p;\n    size_t got;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    *actualRead = 0;\n    while (!finReading)\n    {\n        if (stream->upto == stream->endbuf)\n        {\n#ifdef __OS2__\n            rc = DosRead(stream->hfile,\n                         stream->fbuf,\n                         stream->szfbuf,\n                         &tempRead);\n            if (rc != 0)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = rc;\n            }\n#endif\n#ifdef __WIN32__\n            rc = ReadFile(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &tempRead,\n                          NULL);\n            if (!rc)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = GetLastError();\n            }\n#endif\n#ifdef __MSDOS__\n            tempRead = __read(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &errind);\n            if (errind)\n            {\n                errno = tempRead;\n                tempRead = 0;\n                stream->errorInd = 1;\n            }\n#endif\n            if (tempRead == 0)\n            {\n                stream->eofInd = 1;\n                break;\n            }\n            stream->bufStartR += (stream->upto - stream->fbuf);\n            stream->endbuf = stream->fbuf + tempRead;\n            *stream->endbuf = '\\n';\n            stream->upto = stream->fbuf;\n        }\n        avail = (size_t)(stream->endbuf - stream->upto) + 1;\n        need = toread - *actualRead;\n        p = memchr(stream->upto, '\\n', avail);\n        got = (size_t)(p - stream->upto);\n        if (need < got)\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, need);\n            stream->upto += need;\n            *actualRead += need;\n        }\n        else\n        {\n            memcpy((char *)ptr + *actualRead, stream->upto, got);\n            stream->upto += got;\n            *actualRead += got;\n            if (p != stream->endbuf)\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *((char *)ptr + *actualRead - 1) = '\\n';\n                    stream->upto++;\n                }\n                else if (need != got)\n                {\n                    *((char *)ptr + *actualRead) = '\\n';\n                    *actualRead += 1;\n                    stream->upto++;\n                }\n            }\n            else\n            {\n                if (*(stream->upto - 1) == '\\r')\n                {\n                    *actualRead -= 1;\n                }\n            }\n        }\n        if (*actualRead == toread)\n        {\n            finReading = 1;\n        }\n    }\n    return;\n}\n\nstatic void freadSlowB(void *ptr,\n                       FILE *stream,\n                       size_t toread,\n                       size_t *actualRead)\n{\n    size_t avail;\n#ifdef __OS2__\n    ULONG tempRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempRead;\n    int errind;\n#endif\n\n    avail = (size_t)(stream->endbuf - stream->upto);\n    memcpy(ptr, stream->upto, avail);\n    *actualRead = avail;\n    stream->bufStartR += (stream->endbuf - stream->fbuf);\n    if (toread >= stream->szfbuf)\n    {\n        stream->upto = stream->endbuf;\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     (char *)ptr + *actualRead,\n                     toread - *actualRead,\n                     &tempRead);\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n            rc = ReadFile(stream->hfile,\n                          (char *)ptr + *actualRead,\n                          toread - *actualRead,\n                          &tempRead,\n                          NULL);\n            if (!rc)\n            {\n                tempRead = 0;\n                stream->errorInd = 1;\n                errno = GetLastError();\n            }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          (char *)ptr + *actualRead,\n                          toread - *actualRead,\n                          &errind);\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead != (toread - *actualRead))\n        {\n            stream->eofInd = 1;\n        }\n        *actualRead += tempRead;\n        stream->bufStartR += tempRead;\n    }\n    else\n    {\n        size_t left;\n\n        stream->upto = stream->fbuf;\n#ifdef __OS2__\n        rc = DosRead(stream->hfile,\n                     stream->fbuf,\n                     stream->szfbuf,\n                     &tempRead);\n        left = toread - *actualRead;\n        if (rc != 0)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      stream->fbuf,\n                      stream->szfbuf,\n                      &tempRead,\n                      NULL);\n        left = toread - *actualRead;\n        if (!rc)\n        {\n            tempRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        tempRead = __read(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n        left = toread - *actualRead;\n        if (errind)\n        {\n            errno = tempRead;\n            tempRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        else if (tempRead < left)\n        {\n            stream->eofInd = 1;\n        }\n        stream->endbuf = stream->fbuf + tempRead;\n        *stream->endbuf = '\\n';\n        avail = (size_t)(stream->endbuf - stream->upto);\n        if (avail > left)\n        {\n            avail = left;\n        }\n        memcpy((char *)ptr + *actualRead,\n               stream->upto,\n               avail);\n        stream->upto += avail;\n        *actualRead += avail;\n    }\n    return;\n}\n#endif\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ size_t fwrite(const void *ptr,\n                              size_t size,\n                              size_t nmemb,\n                              FILE *stream)\n{\n    size_t towrite;\n    size_t elemWritten;\n#ifdef __OS2__\n    ULONG actualWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD actualWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualWritten;\n    int errind;\n#endif\n\n    if (nmemb == 1)\n    {\n        towrite = size;\n    }\n    else if (size == 1)\n    {\n        towrite = nmemb;\n    }\n    else\n    {\n        towrite = size * nmemb;\n    }\n    if (towrite < stream->szfbuf)\n    {\n        stream->quickBin = 0;\n        if ((stream->bufTech == _IONBF) && !stream->textMode)\n        {\n            stream->quickBin = 1;\n        }\n    }\n    if (!stream->quickBin)\n    {\n        fwriteSlow(ptr, size, nmemb, stream, towrite, &elemWritten);\n        return (elemWritten);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile, (VOID *)ptr, towrite, &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile, ptr, towrite, &actualWritten, NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                ptr,\n                                towrite,\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            actualWritten = 0;\n            errno = actualWritten;\n        }\n#endif\n        if (nmemb == 1)\n        {\n            if (actualWritten == size)\n            {\n                elemWritten = 1;\n            }\n            else\n            {\n                elemWritten = 0;\n            }\n        }\n        else if (size == 1)\n        {\n            elemWritten = actualWritten;\n        }\n        else\n        {\n            elemWritten = actualWritten / size;\n        }\n        stream->bufStartR += actualWritten;\n        return (elemWritten);\n    }\n}\n\nstatic void fwriteSlow(const void *ptr,\n                       size_t size,\n                       size_t nmemb,\n                       FILE *stream,\n                       size_t towrite,\n                       size_t *elemWritten)\n{\n    size_t actualWritten;\n\n    /* Normally, on output, there will never be a situation where\n       the write buffer is full, but it hasn't been written out.\n       If we find this to be the case, then it is because we have\n       done an fseek, and didn't know whether we were going to do\n       a read or a write after it, so now that we know, we switch\n       the buffer to being set up for write.  We could use a flag,\n       but I thought it would be better to just put some magic\n       code in with a comment */\n    if (stream->upto == stream->endbuf)\n    {\n        stream->bufStartR += (stream->endbuf - stream->fbuf);\n        stream->upto = stream->fbuf;\n        stream->mode = __WRITE_MODE;\n    }\n    if ((stream->textMode) || (stream->bufTech == _IOLBF))\n    {\n        fwriteSlowT(ptr, stream, towrite, &actualWritten);\n    }\n    else\n    {\n        fwriteSlowB(ptr, stream, towrite, &actualWritten);\n    }\n    if (nmemb == 1)\n    {\n        if (actualWritten == size)\n        {\n            *elemWritten = 1;\n        }\n        else\n        {\n            *elemWritten = 0;\n        }\n    }\n    else if (size == 1)\n    {\n        *elemWritten = actualWritten;\n    }\n    else\n    {\n        *elemWritten = actualWritten / size;\n    }\n    return;\n}\n\n\n/* can still be called on binary files, if the binary file is\n   line buffered  */\n\nstatic void fwriteSlowT(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    char *p;\n    char *tptr;\n    char *oldp;\n    size_t diffp;\n    size_t rem;\n    int fin;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    *actualWritten = 0;\n    tptr = (char *)ptr;\n    p = tptr;\n    oldp = p;\n    p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    while (p != NULL)\n    {\n        diffp = (size_t)(p - oldp);\n        fin = 0;\n        while (!fin)\n        {\n            rem = (size_t)(stream->endbuf - stream->upto);\n            if (diffp < rem)\n            {\n                memcpy(stream->upto, oldp, diffp);\n                stream->upto += diffp;\n                *actualWritten += diffp;\n                fin = 1;\n            }\n            else\n            {\n                memcpy(stream->upto, oldp, rem);\n                oldp += rem;\n                diffp -= rem;\n#ifdef __OS2__\n                rc = DosWrite(stream->hfile,\n                              stream->fbuf,\n                              stream->szfbuf,\n                              &tempWritten);\n                if (rc != 0)\n                {\n                    stream->errorInd = 1;\n                    errno = rc;\n                    return;\n                }\n#endif\n#ifdef __WIN32__\n                rc = WriteFile(stream->hfile,\n                               stream->fbuf,\n                               stream->szfbuf,\n                               &tempWritten,\n                               NULL);\n                if (!rc)\n                {\n                    stream->errorInd = 1;\n                    errno = GetLastError();\n                    return;\n                }\n#endif\n#ifdef __MSDOS__\n                tempWritten = __write(stream->hfile,\n                                      stream->fbuf,\n                                      stream->szfbuf,\n                                      &errind);\n                if (errind)\n                {\n                    stream->errorInd = 1;\n                    return;\n                }\n#endif\n                else\n                {\n                    *actualWritten += rem;\n                    stream->upto = stream->fbuf;\n                    stream->bufStartR += tempWritten;\n                }\n            }\n        }\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (rem < 3)\n        {\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          (size_t)(stream->upto - stream->fbuf),\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __WIN32__\n            rc = WriteFile(stream->hfile,\n                           stream->fbuf,\n                           (size_t)(stream->upto - stream->fbuf),\n                           &tempWritten,\n                           NULL);\n            if (!rc)\n            {\n                stream->errorInd = 1;\n                errno = GetLastError();\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  (size_t)(stream->upto - stream->fbuf),\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            stream->upto = stream->fbuf;\n            stream->bufStartR += tempWritten;\n        }\n#ifndef __gnu_linux__\n        if (stream->textMode)\n        {\n            memcpy(stream->upto, \"\\r\\n\", 2);\n            stream->upto += 2;\n        }\n        else\n#endif\n        {\n            memcpy(stream->upto, \"\\n\", 1);\n            stream->upto += 1;\n        }\n        *actualWritten += 1;\n        oldp = p + 1;\n        p = (char *)memchr(oldp, '\\n', towrite - (size_t)(oldp - tptr));\n    }\n\n    if ((stream->bufTech == _IOLBF)\n        && (stream->upto != stream->fbuf)\n        && (oldp != tptr))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n\n    diffp = towrite - *actualWritten;\n    while (diffp != 0)\n    {\n        rem = (size_t)(stream->endbuf - stream->upto);\n        if (diffp < rem)\n        {\n            memcpy(stream->upto, oldp, diffp);\n            stream->upto += diffp;\n            *actualWritten += diffp;\n        }\n        else\n        {\n            memcpy(stream->upto, oldp, rem);\n#ifdef __OS2__\n            rc = DosWrite(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &tempWritten);\n            if (rc != 0)\n            {\n                stream->errorInd = 1;\n                errno = rc;\n                return;\n            }\n#endif\n#ifdef __WIN32__\n            rc = WriteFile(stream->hfile,\n                           stream->fbuf,\n                           stream->szfbuf,\n                           &tempWritten,\n                           NULL);\n            if (!rc)\n            {\n                stream->errorInd = 1;\n                errno = GetLastError();\n                return;\n            }\n#endif\n#ifdef __MSDOS__\n            tempWritten = __write(stream->hfile,\n                                  stream->fbuf,\n                                  stream->szfbuf,\n                                  &errind);\n            if (errind)\n            {\n                stream->errorInd = 1;\n                errno = tempWritten;\n                return;\n            }\n#endif\n            else\n            {\n                *actualWritten += rem;\n                stream->upto = stream->fbuf;\n            }\n            stream->bufStartR += tempWritten;\n            oldp += rem;\n        }\n        diffp = towrite - *actualWritten;\n    }\n    if ((stream->bufTech == _IONBF)\n        && (stream->upto != stream->fbuf))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      stream->fbuf,\n                      (size_t)(stream->upto - stream->fbuf),\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              stream->fbuf,\n                              (size_t)(stream->upto - stream->fbuf),\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        stream->upto = stream->fbuf;\n        stream->bufStartR += tempWritten;\n    }\n    return;\n}\n\n/* whilst write requests are smaller than a buffer, we do not turn\n   on quickbin */\n\nstatic void fwriteSlowB(const void *ptr,\n                        FILE *stream,\n                        size_t towrite,\n                        size_t *actualWritten)\n{\n    size_t spare;\n#ifdef __OS2__\n    ULONG tempWritten;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD tempWritten;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t tempWritten;\n    int errind;\n#endif\n\n    spare = (size_t)(stream->endbuf - stream->upto);\n    if (towrite < spare)\n    {\n        memcpy(stream->upto, ptr, towrite);\n        *actualWritten = towrite;\n        stream->upto += towrite;\n        return;\n    }\n    memcpy(stream->upto, ptr, spare);\n#ifdef __OS2__\n    rc = DosWrite(stream->hfile,\n                  stream->fbuf,\n                  stream->szfbuf,\n                  &tempWritten);\n    if (rc != 0)\n    {\n        stream->errorInd = 1;\n        errno = rc;\n        return;\n    }\n#endif\n#ifdef __WIN32__\n    rc = WriteFile(stream->hfile,\n                   stream->fbuf,\n                   stream->szfbuf,\n                   &tempWritten,\n                   NULL);\n    if (!rc)\n    {\n        stream->errorInd = 1;\n        errno = GetLastError();\n        return;\n    }\n#endif\n#ifdef __MSDOS__\n    tempWritten = __write(stream->hfile,\n                          stream->fbuf,\n                          stream->szfbuf,\n                          &errind);\n    if (errind)\n    {\n        stream->errorInd = 1;\n        errno = tempWritten;\n        return;\n    }\n#endif\n    *actualWritten = spare;\n    stream->upto = stream->fbuf;\n    stream->bufStartR += tempWritten;\n    if (towrite > stream->szfbuf)\n    {\n        stream->quickBin = 1;\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                      (char *)ptr + *actualWritten,\n                      towrite - *actualWritten,\n                      &tempWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return;\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       (char *)ptr + *actualWritten,\n                       towrite - *actualWritten,\n                       &tempWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return;\n        }\n#endif\n#ifdef __MSDOS__\n        tempWritten = __write(stream->hfile,\n                              (char *)ptr + *actualWritten,\n                              towrite - *actualWritten,\n                              &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = tempWritten;\n            return;\n        }\n#endif\n        *actualWritten += tempWritten;\n        stream->bufStartR += tempWritten;\n    }\n    else\n    {\n        memcpy(stream->fbuf,\n               (char *)ptr + *actualWritten,\n               towrite - *actualWritten);\n        stream->upto += (towrite - *actualWritten);\n        *actualWritten = towrite;\n    }\n    stream->bufStartR += *actualWritten;\n    return;\n}\n#endif\n\nstatic int vvprintf(const char *format, va_list arg, FILE *fq, char *s)\n{\n    int fin = 0;\n    int vint;\n    double vdbl;\n    unsigned int uvint;\n    const char *vcptr;\n    int chcount = 0;\n    size_t len;\n    char numbuf\u00dd50\u00a8;\n    char *nptr;\n    int *viptr;\n\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%')\n        {\n            format++;\n            if (*format == 'd')\n            {\n                vint = va_arg(arg, int);\n                if (vint < 0)\n                {\n                    uvint = -vint;\n                }\n                else\n                {\n                    uvint = vint;\n                }\n                nptr = numbuf;\n                do\n                {\n                    *nptr++ = (char)('0' + uvint % 10);\n                    uvint /= 10;\n                } while (uvint > 0);\n                if (vint < 0)\n                {\n                    *nptr++ = '-';\n                }\n                do\n                {\n                    nptr--;\n                    outch(*nptr);\n                    chcount++;\n                } while (nptr != numbuf);\n            }\n            else if (strchr(\"eEgGfF\", *format) != NULL && *format != 0)\n            {\n                vdbl = va_arg(arg, double);\n                dblcvt(vdbl, *format, 0, 6, numbuf);   /* 'e','f' etc. */\n                len = strlen(numbuf);\n                if (fq == NULL)\n                {\n                    memcpy(s, numbuf, len);\n                    s += len;\n                }\n                else\n                {\n                    fputs(numbuf, fq);\n                }\n                chcount += len;\n            }\n            else if (*format == 's')\n            {\n                vcptr = va_arg(arg, const char *);\n                if (vcptr == NULL)\n                {\n                    vcptr = \"(null)\";\n                }\n                if (fq == NULL)\n                {\n                    len = strlen(vcptr);\n                    memcpy(s, vcptr, len);\n                    s += len;\n                    chcount += len;\n                }\n                else\n                {\n                    fputs(vcptr, fq);\n                    chcount += strlen(vcptr);\n                }\n            }\n            else if (*format == 'c')\n            {\n                vint = va_arg(arg, int);\n                outch(vint);\n                chcount++;\n            }\n            else if (*format == 'n')\n            {\n                viptr = va_arg(arg, int *);\n                *viptr = chcount;\n            }\n            else if (*format == '%')\n            {\n                outch('%');\n                chcount++;\n            }\n            else\n            {\n                int extraCh;\n\n                extraCh = examine(&format, fq, s, &arg, chcount);\n                chcount += extraCh;\n                if (s != NULL)\n                {\n                    s += extraCh;\n                }\n            }\n        }\n        else\n        {\n            outch(*format);\n            chcount++;\n        }\n        format++;\n    }\n    return (chcount);\n}\n\nstatic int examine(const char **formt, FILE *fq, char *s, va_list *arg,\n                   int chcount)\n{\n    int extraCh = 0;\n    int flagMinus = 0;\n    int flagPlus = 0;\n    int flagSpace = 0;\n    int flagHash = 0;\n    int flagZero = 0;\n    int width = 0;\n    int precision = -1;\n    int half = 0;\n    int lng = 0;\n    int specifier = 0;\n    int fin;\n    long lvalue;\n    short int hvalue;\n    int ivalue;\n    unsigned long ulvalue;\n    double vdbl;\n    char *svalue;\n    char work\u00dd50\u00a8;\n    int x;\n    int y;\n    int rem;\n    const char *format;\n    int base;\n    int fillCh;\n    int neg;\n    int length;\n    size_t slen;\n\n    unused(chcount);\n    format = *formt;\n    /* processing flags */\n    fin = 0;\n    while (!fin)\n    {\n        switch (*format)\n        {\n            case '-': flagMinus = 1;\n                      break;\n            case '+': flagPlus = 1;\n                      break;\n            case ' ': flagSpace = 1;\n                      break;\n            case '#': flagHash = 1;\n                      break;\n            case '0': flagZero = 1;\n                      break;\n            case '*': width = va_arg(*arg, int);\n                      if (width < 0)\n                      {\n                          flagMinus = 1;\n                          width = -width;\n                      }\n                      break;\n            default:  fin = 1;\n                      break;\n        }\n        if (!fin)\n        {\n            format++;\n        }\n        else\n        {\n            if (flagSpace && flagPlus)\n            {\n                flagSpace = 0;\n            }\n            if (flagMinus)\n            {\n                flagZero = 0;\n            }\n        }\n    }\n\n    /* processing width */\n    if (isdigit((unsigned char)*format))\n    {\n        while (isdigit((unsigned char)*format))\n        {\n            width = width * 10 + (*format - '0');\n            format++;\n        }\n    }\n\n    /* processing precision */\n    if (*format == '.')\n    {\n        format++;\n        if (*format == '*')\n        {\n            precision = va_arg(*arg, int);\n            format++;\n        }\n        else\n        {\n            precision = 0;\n            while (isdigit((unsigned char)*format))\n            {\n                precision = precision * 10 + (*format - '0');\n                format++;\n            }\n        }\n    }\n\n    /* processing h/l/L */\n    if (*format == 'h')\n    {\n        /* all environments should promote shorts to ints,\n           so we should be able to ignore the 'h' specifier.\n           It will create problems otherwise. */\n        /* half = 1; */\n    }\n    else if (*format == 'l')\n    {\n        lng = 1;\n    }\n    else if (*format == 'L')\n    {\n        lng = 1;\n    }\n    else\n    {\n        format--;\n    }\n    format++;\n\n    /* processing specifier */\n    specifier = *format;\n\n    if (strchr(\"dxXuiop\", specifier) != NULL && specifier != 0)\n    {\n        if (precision < 0)\n        {\n            precision = 1;\n        }\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n        if (specifier == 'p')\n        {\n            lng = 1;\n        }\n#endif\n        if (lng)\n        {\n            lvalue = va_arg(*arg, long);\n        }\n        else if (half)\n        {\n            /* short is promoted to int, so use int */\n            hvalue = va_arg(*arg, int);\n            if (specifier == 'u') lvalue = (unsigned short)hvalue;\n            else lvalue = hvalue;\n        }\n        else\n        {\n            ivalue = va_arg(*arg, int);\n            if (specifier == 'u') lvalue = (unsigned int)ivalue;\n            else lvalue = ivalue;\n        }\n        ulvalue = (unsigned long)lvalue;\n        if ((lvalue < 0) && ((specifier == 'd') || (specifier == 'i')))\n        {\n            neg = 1;\n            ulvalue = -lvalue;\n        }\n        else\n        {\n            neg = 0;\n        }\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n        if (!lng)\n        {\n            ulvalue &= 0xffff;\n        }\n#endif\n        if ((specifier == 'X') || (specifier == 'x') || (specifier == 'p'))\n        {\n            base = 16;\n        }\n        else if (specifier == 'o')\n        {\n            base = 8;\n        }\n        else\n        {\n            base = 10;\n        }\n        if (specifier == 'p')\n        {\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n            precision = 9;\n#else\n            precision = 8;\n#endif\n        }\n        x = 0;\n        while (ulvalue > 0)\n        {\n            rem = (int)(ulvalue % base);\n            if (rem < 10)\n            {\n                work\u00ddx\u00a8 = (char)('0' + rem);\n            }\n            else\n            {\n                if ((specifier == 'X') || (specifier == 'p'))\n                {\n                    work\u00ddx\u00a8 = (char)('A' + (rem - 10));\n                }\n                else\n                {\n                    work\u00ddx\u00a8 = (char)('a' + (rem - 10));\n                }\n            }\n            x++;\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n            if ((x == 4) && (specifier == 'p'))\n            {\n                work\u00ddx\u00a8 = ':';\n                x++;\n            }\n#endif\n            ulvalue = ulvalue / base;\n        }\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n        if (specifier == 'p')\n        {\n            while (x < 5)\n            {\n                work\u00ddx\u00a8 = (x == 4) ? ':' : '0';\n                x++;\n            }\n        }\n#endif\n        while (x < precision)\n        {\n            work\u00ddx\u00a8 = '0';\n            x++;\n        }\n        if (neg)\n        {\n            work\u00ddx++\u00a8 = '-';\n        }\n        else if (flagPlus)\n        {\n            work\u00ddx++\u00a8 = '+';\n        }\n        if (flagZero)\n        {\n            fillCh = '0';\n        }\n        else\n        {\n            fillCh = ' ';\n        }\n        y = x;\n        if (!flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n        if (flagHash && (toupper((unsigned char)specifier) == 'X'))\n        {\n            outch('0');\n            outch('x');\n            extraCh += 2;\n        }\n        x--;\n        while (x >= 0)\n        {\n            outch(work\u00ddx\u00a8);\n            extraCh++;\n            x--;\n        }\n        if (flagMinus)\n        {\n            while (y < width)\n            {\n                outch(fillCh);\n                extraCh++;\n                y++;\n            }\n        }\n    }\n    else if (strchr(\"eEgGfF\", specifier) != NULL && specifier != 0)\n    {\n        if (precision < 0)\n        {\n            precision = 6;\n        }\n        vdbl = va_arg(*arg, double);\n        dblcvt(vdbl, specifier, width, precision, work);   /* 'e','f' etc. */\n        slen = strlen(work);\n        if (fq == NULL)\n        {\n            memcpy(s, work, slen);\n            s += slen;\n        }\n        else\n        {\n            fputs(work, fq);\n        }\n        extraCh += slen;\n    }\n    else if (specifier == 's')\n    {\n        svalue = va_arg(*arg, char *);\n        fillCh = ' ';\n        if (precision > 0)\n        {\n            char *p;\n\n            p = memchr(svalue, '\\0', precision);\n            if (p != NULL)\n            {\n                length = (int)(p - svalue);\n            }\n            else\n            {\n                length = precision;\n            }\n        }\n        else if (precision < 0)\n        {\n            length = strlen(svalue);\n        }\n        else\n        {\n            length = 0;\n        }\n        if (!flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n        for (x = 0; x < length; x++)\n        {\n            outch(svalue\u00ddx\u00a8);\n        }\n        extraCh += length;\n        if (flagMinus)\n        {\n            if (length < width)\n            {\n                extraCh += (width - length);\n                for (x = 0; x < (width - length); x++)\n                {\n                    outch(fillCh);\n                }\n            }\n        }\n    }\n    *formt = format;\n    return (extraCh);\n}\n\n__PDPCLIB_API__ int fputc(int c, FILE *stream)\n{\n    char buf\u00dd1\u00a8;\n\n#if !defined(__MVS__) && !defined(__CMS__)\n    stream->quickBin = 0;\n    if ((stream->upto < (stream->endbuf - 2))\n        && (stream->bufTech != _IONBF))\n    {\n        if (stream->textMode)\n        {\n            if (c == '\\n')\n            {\n                if (stream->bufTech == _IOFBF)\n                {\n                    *stream->upto++ = '\\r';\n                    *stream->upto++ = '\\n';\n                }\n                else\n                {\n                    buf\u00dd0\u00a8 = (char)c;\n                    if (fwrite(buf, 1, 1, stream) != 1)\n                    {\n                        return (EOF);\n                    }\n                }\n            }\n            else\n            {\n                *stream->upto++ = (char)c;\n            }\n        }\n        else\n        {\n            *stream->upto++ = (char)c;\n        }\n    }\n    else\n#endif\n    {\n        buf\u00dd0\u00a8 = (char)c;\n        if (fwrite(buf, 1, 1, stream) != 1)\n        {\n            return (EOF);\n        }\n    }\n    return (c);\n}\n\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ int fputs(const char *s, FILE *stream)\n{\n    size_t len;\n    size_t ret;\n\n    len = strlen(s);\n    ret = fwrite(s, len, 1, stream);\n    if (ret != 1) return (EOF);\n    else return (0);\n}\n#endif\n\n__PDPCLIB_API__ int remove(const char *filename)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosDelete((PSZ)filename);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __WIN32__\n    rc = DeleteFile(filename);\n    if (!rc)\n    {\n        ret = 1;\n        errno = GetLastError();\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __remove(filename);\n    ret = 0;\n#endif\n#ifdef __MVS__\n    char buf\u00ddFILENAME_MAX + 50\u00a8;\n    char *p;\n\n    sprintf(buf, \" DELETE %s\", filename);\n    p = buf;\n    while (*p != '\\0')\n    {\n       *p = toupper((unsigned char)*p);\n       p++;\n    }\n    ret = __idcams(strlen(buf), buf);\n#endif\n#ifdef __CMS__\n    ret = cmsremove(filename);\n#endif\n    return (ret);\n}\n\n__PDPCLIB_API__ int rename(const char *old, const char *newnam)\n{\n    int ret;\n#ifdef __OS2__\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n#endif\n\n#ifdef __OS2__\n    rc = DosMove((PSZ)old, (PSZ)newnam);\n    if (rc != 0)\n    {\n        ret = 1;\n        errno = rc;\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __WIN32__\n    rc = MoveFile(old, newnam);\n    if (!rc)\n    {\n        ret = 1;\n        errno = GetLastError();\n    }\n    else\n    {\n        ret = 0;\n    }\n#endif\n#ifdef __MSDOS__\n    __rename(old, newnam);\n    ret = 0;\n#endif\n#ifdef __MVS__\n    char buf\u00ddFILENAME_MAX + FILENAME_MAX + 50\u00a8;\n    char *p;\n\n    sprintf(buf, \" ALTER %s NEWNAME(%s)\", old, newnam);\n    p = buf;\n    while (*p != '\\0')\n    {\n       *p = toupper((unsigned char)*p);\n       p++;\n    }\n    ret = __idcams(strlen(buf), buf);\n#endif\n#ifdef __CMS__\n    ret = cmsrename(old, newnam);\n#endif\n    return (ret);\n}\n\n__PDPCLIB_API__ int sprintf(char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vsprintf(s, format, arg);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int vsprintf(char *s, const char *format, va_list arg)\n{\n    int ret;\n\n    ret = vvprintf(format, arg, NULL, s);\n    if (ret >= 0)\n    {\n        *(s + ret) = '\\0';\n    }\n    return (ret);\n}\n\n/*\n\nIn fgets, we have the following possibilites...\n\n1. we found a genuine '\\n' that terminated the search.\n2. we hit the '\\n' at the endbuf.\n3. we hit the '\\n' sentinel.\n\n*/\n#if !defined(__MVS__) && !defined(__CMS__)\n__PDPCLIB_API__ char *fgets(char *s, int n, FILE *stream)\n{\n    char *p;\n    register char *t;\n    register char *u = s;\n    int c;\n    int processed;\n#ifdef __OS2__\n    ULONG actualRead;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD actualRead;\n    BOOL rc;\n#endif\n#ifdef __MSDOS__\n    size_t actualRead;\n    int errind;\n#endif\n\n    if (stream->quickText)\n    {\n        p = stream->upto + n - 1;\n        t = stream->upto;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n#if defined(__OS2__) || defined(__WIN32__)\n            if (n < 8)\n            {\n#endif\n                while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n#if defined(__OS2__) || defined(__WIN32__)\n            }\n            else\n            {\n                register unsigned int *i1;\n                register unsigned int *i2;\n                register unsigned int z;\n\n                i1 = (unsigned int *)t;\n                i2 = (unsigned int *)u;\n                while (1)\n                {\n                    z = *i1;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    z >>= 8;\n                    if ((z & 0xffU) == '\\n') break;\n                    *i2++ = *i1++;\n                }\n                t = (char *)i1;\n                u = (char *)i2;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n#endif\n            *p = (char)c;\n            if (t <= p)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n            if (t <= stream->endbuf)\n            {\n                if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n                stream->upto = t;\n                return (s);\n            }\n            else\n            {\n                processed = (int)(t - stream->upto) - 1;\n                stream->upto = t - 1;\n                u--;\n            }\n        }\n    }\n    else\n    {\n        processed = 0;\n    }\n\n    if (n < 1)\n    {\n        return (NULL);\n    }\n    if (n < 2)\n    {\n        *u = '\\0';\n        return (s);\n    }\n    if (stream->ungetCh != -1)\n    {\n        processed++;\n        *u++ = (char)stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n    while (1)\n    {\n        t = stream->upto;\n        p = stream->upto + (n - processed) - 1;\n        if (p < stream->endbuf)\n        {\n            c = *p;\n            *p = '\\n';\n        }\n        if (stream->noNl)\n        {\n            while (((*u++ = *t) != '\\n') && (*t++ != '\\r')) ;\n            if (*(u - 1) == '\\n')\n            {\n                t++;\n            }\n            else\n            {\n                u--;\n                while ((*u++ = *t++) != '\\n') ;\n            }\n        }\n        else\n        {\n            while ((*u++ = *t++) != '\\n') ; /* tight inner loop */\n        }\n        if (p < stream->endbuf)\n        {\n            *p = (char)c;\n        }\n        if (((t <= p) && (p < stream->endbuf))\n           || ((t <= stream->endbuf) && (p >= stream->endbuf)))\n        {\n            if (stream->textMode)\n            {\n                if (stream->noNl)\n                {\n                    if ((*(t - 1) == '\\r') || (*(t - 1) == '\\n'))\n                    {\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        *u = '\\0';\n                    }\n                }\n                else if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                {\n                    *(u - 2) = '\\n';\n                    *(u - 1) = '\\0';\n                }\n                else\n                {\n                    *u = '\\0';\n                }\n            }\n            stream->upto = t;\n            if (stream->textMode)\n            {\n                stream->quickText = 1;\n            }\n            return (s);\n        }\n        else if (((t > p) && (p < stream->endbuf))\n                 || ((t > stream->endbuf) && (p >= stream->endbuf)))\n        {\n            int leave = 1;\n\n            if (stream->textMode)\n            {\n                if (t > stream->endbuf)\n                {\n                    if ((t - stream->upto) > 1)\n                    {\n                        if (*(t - 2) == '\\r') /* t is protected, u isn't */\n                        {\n                            processed -= 1; /* preparation for add */\n                        }\n                    }\n                    leave = 0;\n                }\n                else\n                {\n                    if ((*(t - 2) == '\\r') && (*(t - 1) == '\\n'))\n                    {\n                        *(u - 2) = '\\n';\n                        *(u - 1) = '\\0';\n                    }\n                    else\n                    {\n                        t--;\n                        *(u - 1) = '\\0';\n                    }\n                }\n            }\n            else if (t > stream->endbuf)\n            {\n                leave = 0;\n            }\n            else\n            {\n                *u = '\\0';\n            }\n            if (leave)\n            {\n                stream->upto = t;\n                if (stream->textMode)\n                {\n                    stream->quickText = 1;\n                }\n                return (s);\n            }\n        }\n        processed += (int)(t - stream->upto) - 1;\n        u--;\n        stream->bufStartR += (stream->endbuf - stream->fbuf);\n#ifdef __OS2__\n        rc = DosRead(stream->hfile, stream->fbuf, stream->szfbuf, &actualRead);\n        if (rc != 0)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = rc;\n        }\n#endif\n#ifdef __WIN32__\n        rc = ReadFile(stream->hfile,\n                      stream->fbuf,\n                      stream->szfbuf,\n                      &actualRead,\n                      NULL);\n        if (!rc)\n        {\n            actualRead = 0;\n            stream->errorInd = 1;\n            errno = GetLastError();\n        }\n#endif\n#ifdef __MSDOS__\n        actualRead = __read(stream->hfile,\n                            stream->fbuf,\n                            stream->szfbuf,\n                            &errind);\n        if (errind)\n        {\n            errno = actualRead;\n            actualRead = 0;\n            stream->errorInd = 1;\n        }\n#endif\n        stream->endbuf = stream->fbuf + actualRead;\n        *stream->endbuf = '\\n';\n        if (actualRead == 0)\n        {\n            *u = '\\0';\n            if ((u - s) <= 1)\n            {\n                stream->eofInd = 1;\n                return (NULL);\n            }\n            else\n            {\n                return (s);\n            }\n        }\n        stream->upto = stream->fbuf;\n    }\n}\n#endif\n\n__PDPCLIB_API__ int ungetc(int c, FILE *stream)\n{\n    if ((stream->ungetCh != -1) || (c == EOF))\n    {\n        return (EOF);\n    }\n    stream->ungetCh = (unsigned char)c;\n    stream->quickText = 0;\n    stream->quickBin = 0;\n    return ((unsigned char)c);\n}\n\n__PDPCLIB_API__ int fgetc(FILE *stream)\n{\n    unsigned char x\u00dd1\u00a8;\n    size_t ret;\n\n    ret = fread(x, 1, 1, stream);\n    if (ret == 0)\n    {\n        return (EOF);\n    }\n    return ((int)x\u00dd0\u00a8);\n}\n\n__PDPCLIB_API__ int fseek(FILE *stream, long int offset, int whence)\n{\n    long oldpos;\n    long newpos;\n#ifdef __OS2__\n    ULONG retpos;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    DWORD retpos;\n#endif\n\n    oldpos = stream->bufStartR + (stream->upto - stream->fbuf);\n    if (stream->mode == __WRITE_MODE)\n    {\n        fflush(stream);\n    }\n    if (whence == SEEK_SET)\n    {\n        newpos = offset;\n    }\n    else if (whence == SEEK_CUR)\n    {\n        newpos = oldpos + offset;\n    }\n\n    if (whence == SEEK_END)\n    {\n        char buf\u00dd1000\u00a8;\n\n        while (fread(buf, sizeof buf, 1, stream) == 1)\n        {\n            /* do nothing */\n        }\n    }\n    else if ((newpos >= stream->bufStartR)\n        && (newpos < (stream->bufStartR + (stream->endbuf - stream->fbuf)))\n        && (stream->update || (stream->mode == __READ_MODE)))\n    {\n        stream->upto = stream->fbuf + (size_t)(newpos - stream->bufStartR);\n    }\n    else\n    {\n#ifdef __OS2__\n        rc = DosSetFilePtr(stream->hfile, newpos, FILE_BEGIN, &retpos);\n        if ((rc != 0) || (retpos != newpos))\n        {\n            errno = rc;\n            return (-1);\n        }\n        else\n        {\n            stream->endbuf = stream->fbuf + stream->szfbuf;\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n#endif\n#ifdef __WIN32__\n        retpos = SetFilePointer(stream->hfile, newpos, NULL, FILE_BEGIN);\n        if (retpos != newpos)\n        {\n            errno = GetLastError();\n            return (-1);\n        }\n        else\n        {\n            stream->endbuf = stream->fbuf + stream->szfbuf;\n            stream->upto = stream->endbuf;\n            stream->bufStartR = newpos - stream->szfbuf;\n        }\n#endif\n#ifdef __MSDOS__\n        __seek(stream->hfile, newpos, whence);\n        stream->endbuf = stream->fbuf + stream->szfbuf;\n        stream->upto = stream->endbuf;\n        stream->bufStartR = newpos - stream->szfbuf;\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n        char fnm\u00ddFILENAME_MAX\u00a8;\n        long int x;\n        size_t y;\n        char buf\u00dd1000\u00a8;\n\n        oldpos = ftell(stream);\n        if (newpos < oldpos)\n        {\n            strcpy(fnm, \"dd:\");\n            strcat(fnm, stream->ddname);\n            if (stream->pdsmem\u00dd0\u00a8 != '\\0')\n            {\n                sprintf(fnm + strlen(fnm), \"(%s)\", stream->pdsmem);\n            }\n            inseek = 1;\n            if (freopen(fnm, stream->modeStr, stream) == NULL)\n            {\n                stream->errorInd = 1;\n                return (-1);\n            }\n            inseek = 0;\n            oldpos = 0;\n        }\n        y = (newpos - oldpos) % sizeof buf;\n        fread(buf, y, 1, stream);\n        for (x = oldpos + y; x < newpos; x += sizeof buf)\n        {\n            fread(buf, sizeof buf, 1, stream);\n        }\n        if (stream->errorInd)\n        {\n            return (-1);\n        }\n#endif\n    }\n    stream->quickBin = 0;\n    stream->quickText = 0;\n    stream->ungetCh = -1;\n    return (0);\n}\n\n__PDPCLIB_API__ long int ftell(FILE *stream)\n{\n    return (stream->bufStartR + (stream->upto - stream->fbuf));\n}\n\n__PDPCLIB_API__ int fsetpos(FILE *stream, const fpos_t *pos)\n{\n    fseek(stream, *pos, SEEK_SET);\n    return (0);\n}\n\n__PDPCLIB_API__ int fgetpos(FILE *stream, fpos_t *pos)\n{\n    *pos = ftell(stream);\n    return (0);\n}\n\n__PDPCLIB_API__ void rewind(FILE *stream)\n{\n    fseek(stream, 0L, SEEK_SET);\n    return;\n}\n\n__PDPCLIB_API__ void clearerr(FILE *stream)\n{\n    stream->errorInd = 0;\n    stream->eofInd = 0;\n    return;\n}\n\n__PDPCLIB_API__ void perror(const char *s)\n{\n    if ((s != NULL) && (*s != '\\0'))\n    {\n        printf(\"%s: \", s);\n    }\n    if (errno == 0)\n    {\n        printf(\"No error has occurred\\n\");\n    }\n    else\n    {\n        printf(\"An error has occurred\\n\");\n    }\n    return;\n}\n\n/*\nNULL + F = allocate, setup\nNULL + L = allocate, setup\nNULL + N = ignore, return success\nbuf  + F = setup\nbuf  + L = setup\nbuf  + N = ignore, return success\n*/\n\n__PDPCLIB_API__ int setvbuf(FILE *stream, char *buf, int mode, size_t size)\n{\n    char *mybuf;\n\n#if defined(__MVS__) || defined(__CMS__)\n    /* don't allow mucking around with buffers on MVS or CMS */\n    return (0);\n#endif\n\n    if (mode == _IONBF)\n    {\n        stream->bufTech = mode;\n        return (0);\n    }\n    if (buf == NULL)\n    {\n        if (size < 2)\n        {\n            return (-1);\n        }\n        mybuf = malloc(size + 8);\n        if (mybuf == NULL)\n        {\n            return (-1);\n        }\n    }\n    else\n    {\n        if (size < 10)\n        {\n            return (-1);\n        }\n        mybuf = buf;\n        stream->theirBuffer = 1;\n        size -= 8;\n    }\n    if (!stream->permfile)\n    {\n        free(stream->intBuffer);\n    }\n    stream->intBuffer = mybuf;\n    stream->fbuf = stream->intBuffer + 2;\n    *stream->fbuf++ = '\\0';\n    *stream->fbuf++ = '\\0';\n    stream->szfbuf = size;\n    stream->endbuf = stream->fbuf + stream->szfbuf;\n    *stream->endbuf = '\\n';\n    if (stream->mode == __WRITE_MODE)\n    {\n        stream->upto = stream->fbuf;\n    }\n    else\n    {\n        stream->upto = stream->endbuf;\n    }\n    stream->bufTech = mode;\n    if (!stream->textMode && (stream->bufTech == _IOLBF))\n    {\n        stream->quickBin = 0;\n    }\n    return (0);\n}\n\n__PDPCLIB_API__ int setbuf(FILE *stream, char *buf)\n{\n    int ret;\n\n    if (buf == NULL)\n    {\n        ret = setvbuf(stream, NULL, _IONBF, 0);\n    }\n    else\n    {\n        ret = setvbuf(stream, buf, _IOFBF, BUFSIZ);\n    }\n    return (ret);\n}\n\n__PDPCLIB_API__ FILE *freopen(const char *filename,\n                              const char *mode,\n                              FILE *stream)\n{\n    inreopen = 1;\n    fclose(stream);\n\n    myfile = stream;\n    fnm = filename;\n    modus = mode;\n    err = 0;\n    spareSpot = stream->intFno;\n    fopen2();\n    if (err && !stream->permfile)\n    {\n        __userFiles\u00ddstream->intFno\u00a8 = NULL;\n        free(stream);\n    }\n#if defined(__MVS__) || defined(__CMS__)\n    else if (err)\n    {\n        free(stream);\n        /* need to protect against the app closing the file\n           which it is allowed to */\n        if (stream == stdin)\n        {\n            stdin = NULL;\n        }\n        else if (stream == stdout)\n        {\n            stdout = NULL;\n        }\n        else if (stream == stderr)\n        {\n            stderr = NULL;\n        }\n    }\n#endif\n    inreopen = 0;\n    if (err)\n    {\n        return (NULL);\n    }\n    return (stream);\n}\n\n__PDPCLIB_API__ int fflush(FILE *stream)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    if ((stream->mode == __WRITE_MODE) && (stream->upto != stream->fbuf))\n    {\n        if (stream->reallyu)\n        {\n            size_t last;\n\n            last = stream->upto - stream->fbuf;\n            begwrite(stream, last);\n            memcpy(dptr, stream->fbuf, last);\n            finwrite(stream);\n            stream->upto = stream->fbuf;\n        }\n    }\n#else\n#ifdef __OS2__\n    APIRET rc;\n    ULONG actualWritten;\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    DWORD actualWritten;\n#endif\n#ifdef __MSDOS__\n    int errind;\n    size_t actualWritten;\n#endif\n\n    if ((stream->upto != stream->fbuf) && (stream->mode == __WRITE_MODE))\n    {\n#ifdef __OS2__\n        rc = DosWrite(stream->hfile,\n                     (VOID *)stream->fbuf,\n                     (size_t)(stream->upto - stream->fbuf),\n                     &actualWritten);\n        if (rc != 0)\n        {\n            stream->errorInd = 1;\n            errno = rc;\n            return (EOF);\n        }\n#endif\n#ifdef __WIN32__\n        rc = WriteFile(stream->hfile,\n                       stream->fbuf,\n                       (size_t)(stream->upto - stream->fbuf),\n                       &actualWritten,\n                       NULL);\n        if (!rc)\n        {\n            stream->errorInd = 1;\n            errno = GetLastError();\n            return (EOF);\n        }\n#endif\n#ifdef __MSDOS__\n        actualWritten = __write(stream->hfile,\n                                stream->fbuf,\n                                (size_t)(stream->upto - stream->fbuf),\n                                &errind);\n        if (errind)\n        {\n            stream->errorInd = 1;\n            errno = actualWritten;\n            return (EOF);\n        }\n#endif\n        stream->bufStartR += actualWritten;\n        stream->upto = stream->fbuf;\n    }\n#endif\n    return (0);\n}\n\n__PDPCLIB_API__ char *tmpnam(char *s)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    static char buf\u00dd\u00a8 = \"dd:ZZZZZZZA\";\n#else\n    static char buf\u00dd\u00a8 = \"ZZZZZZZA.$$$\";\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n    buf\u00dd10\u00a8++;\n#else\n    buf\u00dd7\u00a8++;\n#endif\n    if (s == NULL)\n    {\n        return (buf);\n    }\n    strcpy(s, buf);\n    return (s);\n}\n\n__PDPCLIB_API__ FILE *tmpfile(void)\n{\n#if defined(__MVS__) || defined(__CMS__)\n    return (fopen(\"dd:ZZZZZZZA\", \"wb+\"));\n#else\n    return (fopen(\"ZZZZZZZA.$$$\", \"wb+\"));\n#endif\n}\n\n__PDPCLIB_API__ int fscanf(FILE *stream, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, stream, NULL);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int scanf(const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, stdin, NULL);\n    va_end(arg);\n    return (ret);\n}\n\n__PDPCLIB_API__ int sscanf(const char *s, const char *format, ...)\n{\n    va_list arg;\n    int ret;\n\n    va_start(arg, format);\n    ret = vvscanf(format, arg, NULL, s);\n    va_end(arg);\n    return (ret);\n}\n\n/* vvscanf - the guts of the input scanning */\n/* several mods by Dave Edwards */\nstatic int vvscanf(const char *format, va_list arg, FILE *fp, const char *s)\n{\n    int ch;\n    int fin = 0;\n    int cnt = 0;\n    char *cptr;\n    int *iptr;\n    unsigned int *uptr;\n    long *lptr;\n    unsigned long *luptr;\n    short *hptr;\n    unsigned short *huptr;\n    double *dptr;\n    float *fptr;\n    long startpos;\n    const char *startp;\n    int skipvar; /* nonzero if we are skipping this variable */\n    int modlong;   /* nonzero if \"l\" modifier found */\n    int modshort;   /* nonzero if \"h\" modifier found */\n    int informatitem;  /* nonzero if % format item started */\n           /* informatitem is 1 if we have processed \"%l\" but not the\n              type letter (s,d,e,f,g,...) yet. */\n\n    if (fp != NULL)\n    {\n        startpos = ftell(fp);\n    }\n    else\n    {\n        startp = s;\n    }\n    inch();\n    informatitem = 0;   /* init */\n    if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0)) return EOF;\n                               /* initially at EOF or end of string */\n    while (!fin)\n    {\n        if (*format == '\\0')\n        {\n            fin = 1;\n        }\n        else if (*format == '%' || informatitem)\n        {\n            if(*format=='%')   /* starting a format item */\n            {\n                format++;\n                modlong=0;   /* init */\n                modshort=0;\n                skipvar = 0;\n                if (*format == '*')\n                {\n                    skipvar = 1;\n                    format++;\n                }\n            }\n            if (*format == '%')   /* %% */\n            {\n                if (ch != '%') return (cnt);\n                inch();\n                informatitem=0;\n            }\n            else if (*format == 'l')\n            {\n                /* Type modifier: l  (e.g. %ld or %lf) */\n                modlong=1;\n                informatitem=1;\n            }\n            else if (*format == 'h')\n            {\n                /* Type modifier: h (short int) */\n                modshort=1;\n                informatitem=1;\n            }\n            else    /* process a type character: */\n            {\n                informatitem=0;   /* end of format item */\n                if (*format == 's')\n                {\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0))\n                                         /* at EOF or end of string */\n                    {\n                        fin = 1;\n                        if (!skipvar)\n                        {\n                            *cptr = 0;   /* give a null string */\n                        }\n                    }\n                    else\n                    {\n                        for(;;)\n                        {\n                            if (isspace(ch)) break;\n                            if ((fp != NULL && ch == EOF)\n                                || (fp == NULL && ch == 0))\n                            {\n                                fin = 1;\n                                break;\n                            }\n                            if (!skipvar)\n                            {\n                                *cptr++ = (char)ch;\n                            }\n                            inch();\n                        }\n                        if (!skipvar)\n                        {\n                            *cptr = '\\0';\n                        }\n                        cnt++;\n                    }\n                }\n                else if (*format == '\u00dd')\n                {\n                    int reverse = 0;\n                    int found;\n                    const char *first;\n                    const char *last;\n                    size_t size;\n                    size_t mcnt = 0;\n\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    format++;\n                    if (*format == '\u00ac')\n                    {\n                        reverse = 1;\n                        format++;\n                    }\n                    if (*format == '\\0') break;\n                    first = format;\n                    format++;\n                    last = strchr(format, '\u00a8');\n                    if (last == NULL) return (cnt);\n                    size = (size_t)(last - first);\n                    while (1)\n                    {\n                        /* note that C90 doesn't require special\n                           processing for '-' so it hasn't been\n                           added */\n                        found = (memchr(first, ch, size) != NULL);\n                        if (found && reverse) break;\n                        if (!found && !reverse) break;\n                        if (!skipvar)\n                        {\n                            *cptr++ = (char)ch;\n                        }\n                        mcnt++;\n                        inch();\n                        /* if at EOF or end of string, bug out */\n                        if ((fp != NULL && ch == EOF)\n                            || (fp == NULL && ch == 0))\n                        {\n                            break;\n                        }\n                    }\n                    if (mcnt > 0)\n                    {\n                        if (!skipvar)\n                        {\n                            *cptr++ = '\\0';\n                        }\n                        cnt++;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                    format = last + 1;\n                }\n                else if (*format == 'c')\n                {\n                    if (!skipvar)\n                    {\n                        cptr = va_arg(arg, char *);\n                    }\n                    if ((fp != NULL && ch == EOF)\n                        || (fp == NULL && ch == 0)) fin = 1;\n                                          /* at EOF or end of string */\n                    else\n                    {\n                        if (!skipvar)\n                        {\n                            *cptr = ch;\n                        }\n                        cnt++;\n                        inch();\n                    }\n                }\n                else if (*format == 'n')\n                {\n                    uptr = va_arg(arg, unsigned int *);\n                    if (fp != NULL)\n                    {\n                        *uptr = (unsigned int)(ftell(fp) - startpos);\n                    }\n                    else\n                    {\n                        *uptr = (unsigned int)(startp - s);\n                    }\n                }\n                else if (*format == 'd' || *format == 'u'\n                         || *format == 'x' || *format == 'o'\n                         || *format == 'p'\n                         || *format == 'i')\n                {\n                    int neg = 0;\n                    unsigned long x = 0;\n                    int undecided = 0;\n                    int base = 10;\n                    int mcnt = 0;\n\n                    if (*format == 'x') base = 16;\n                    else if (*format == 'p') base = 16;\n                    else if (*format == 'o') base = 8;\n                    else if (*format == 'i') base = 0;\n                    if (!skipvar)\n                    {\n                        if ((*format == 'd') || (*format == 'i'))\n                        {\n                            if (modlong) lptr = va_arg(arg, long *);\n                            else if (modshort) hptr = va_arg(arg, short *);\n                            else iptr = va_arg(arg, int *);\n                        }\n                        else\n                        {\n                            if (modlong) luptr = va_arg(arg, unsigned long *);\n                            else if (modshort) huptr =\n                                     va_arg(arg, unsigned short *);\n                            else uptr = va_arg(arg, unsigned int *);\n                        }\n                    }\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if (ch == '-')\n                    {\n                        neg = 1;\n                        inch();\n                    }\n                    else if(ch == '+') inch();\n\n                    /* this logic is the same as strtoul so if you\n                       change this, change that one too */\n\n                    if (base == 0)\n                    {\n                        undecided = 1;\n                    }\n                    while (!((fp != NULL && ch == EOF)\n                             || (fp == NULL && ch == 0)))\n                    {\n                        if (isdigit((unsigned char)ch))\n                        {\n                            if (base == 0)\n                            {\n                                if (ch == '0')\n                                {\n                                    base = 8;\n                                }\n                                else\n                                {\n                                    base = 10;\n                                    undecided = 0;\n                                }\n                            }\n                            x = x * base + (ch - '0');\n                            inch();\n                        }\n/* DOS has a ':' in the pointer - skip that */\n#if defined(__MSDOS__) && \\\n    !(defined(__PDOS__) && !defined(__MVS__)) && \\\n    !defined(__gnu_linux__)\n                        else if ((*format == 'p') && (ch == ':'))\n                        {\n                            inch();\n                        }\n#endif\n                        else if (isalpha((unsigned char)ch))\n                        {\n                            if ((ch == 'X') || (ch == 'x'))\n                            {\n                                if ((base == 0) || ((base == 8) && undecided))\n                                {\n                                    base = 16;\n                                    undecided = 0;\n                                    inch();\n                                }\n                                else if (base == 16)\n                                {\n                                    /* hex values are allowed to have an\n                                       optional 0x */\n                                    inch();\n                                }\n                                else\n                                {\n                                    break;\n                                }\n                            }\n                            else if (base <= 10)\n                            {\n                                break;\n                            }\n                            else\n                            {\n                                x = x * base +\n                                    (toupper((unsigned char)ch) - 'A') + 10;\n                                inch();\n                            }\n                        }\n                        else\n                        {\n                            break;\n                        }\n                        mcnt++;\n                    }\n\n                    /* end of strtoul logic */\n\n                    /* If we didn't get any characters, don't go any\n                       further */\n                    if (mcnt == 0)\n                    {\n                        break;\n                    }\n\n\n                    if (!skipvar)\n                    {\n                        if ((*format == 'd') || (*format == 'i'))\n                        {\n                            long lval;\n\n                            if (neg)\n                            {\n                                lval = (long)-x;\n                            }\n                            else\n                            {\n                                lval = (long)x;\n                            }\n                            if (modlong) *lptr=lval;\n                                /* l modifier: assign to long */\n                            else if (modshort) *hptr = (short)lval;\n                                /* h modifier */\n                            else *iptr=(int)lval;\n                        }\n                        else\n                        {\n                            if (modlong) *luptr = (unsigned long)x;\n                            else if (modshort) *huptr = (unsigned short)x;\n                            else *uptr = (unsigned int)x;\n                        }\n                    }\n                    cnt++;\n                }\n                else if (*format=='e' || *format=='f' || *format=='g' ||\n                         *format=='E' || *format=='G')\n                {\n                    /* Floating-point (double or float) input item */\n                    int negsw1,negsw2,dotsw,expsw,ndigs1,ndigs2,nfdigs;\n                    int ntrailzer,expnum,expsignsw;\n                    double fpval,pow10;\n\n                    if (!skipvar)\n                    {\n                        if (modlong) dptr = va_arg(arg, double *);\n                        else fptr = va_arg(arg, float *);\n                    }\n                    negsw1=0;   /* init */\n                    negsw2=0;\n                    dotsw=0;\n                    expsw=0;\n                    ndigs1=0;\n                    ndigs2=0;\n                    nfdigs=0;\n                    ntrailzer=0;  /* # of trailing 0's unaccounted for */\n                    expnum=0;\n                    expsignsw=0;  /* nonzero means done +/- on exponent */\n                    fpval=0.0;\n                    /* Skip leading whitespace: */\n                    while (ch>=0 && isspace(ch)) inch();\n                    if (ch=='-')\n                    {\n                        negsw1=1;\n                        inch();\n                    }\n                    else if (ch=='+') inch();\n                    while (ch>0)\n                    {\n                        if (ch=='.' && dotsw==0 && expsw==0) dotsw=1;\n                        else if (isdigit(ch))\n                        {\n                            if(expsw)\n                            {\n                                ndigs2++;\n                                expnum=expnum*10+(ch-'0');\n                            }\n                            else\n                            {\n                                /* To avoid overflow or loss of precision,\n                                   skip leading and trailing zeros unless\n                                   really needed. (Automatic for leading\n                                   0's, since 0.0*10.0 is 0.0) */\n                                ndigs1++;\n                                if (dotsw) nfdigs++;\n                                if (ch=='0' && fpval!=0.)\n                                {\n                                    /* Possible trailing 0 */\n                                    ntrailzer++;\n                                }\n                                else\n                                {\n                                    /* Account for any preceding zeros */\n                                    while (ntrailzer>0)\n                                    {\n                                        fpval*=10.;\n                                        ntrailzer--;\n                                    }\n                                    fpval=fpval*10.0+(ch-'0');\n                                }\n                            }\n                        }\n                        else if ((ch=='e' || ch=='E') && expsw==0) expsw=1;\n                        else if ((ch=='+' || ch=='-') && expsw==1\n                                 && ndigs2==0 && expsignsw==0)\n                        {\n                            expsignsw=1;\n                            if (ch=='-') negsw2=1;\n                        }\n                        else break;   /* bad char: end of input item */\n                        inch();\n                    }\n                    if ((fp != NULL && ch == EOF)\n                        || (fp == NULL && ch == 0)) fin=1;\n                    /* Check for a valid fl-pt value: */\n                    if (ndigs1==0 || (expsw && ndigs2==0)) return(cnt);\n                    /* Complete the fl-pt value: */\n                    if (negsw2) expnum=-expnum;\n                    expnum+=ntrailzer-nfdigs;\n                    if (expnum!=0 && fpval!=0.0)\n                    {\n                        negsw2=0;\n                        if (expnum<0)\n                        {\n                            expnum=-expnum;\n                            negsw2=1;\n                        }\n                        /* Multiply or divide by 10.0**expnum, using\n                           bits of expnum (fast method) */\n                        pow10=10.0;\n                        for (;;)\n                        {\n                            if (expnum & 1)     /* low-order bit */\n                            {\n                                if (negsw2) fpval/=pow10;\n                                else fpval*=pow10;\n                            }\n                            expnum>>=1;   /* shift right 1 bit */\n                            if (expnum==0) break;\n                            pow10*=pow10;   /* 10.**n where n is power of 2 */\n                        }\n                    }\n                    if (negsw1) fpval=-fpval;\n                    if (!skipvar)\n                    {\n                        /* l modifier: assign to double */\n                        if (modlong) *dptr=fpval;\n                        else *fptr=(float)fpval;\n                    }\n                    cnt++;\n                }\n            }\n        }\n        else if (isspace((unsigned char)(*format)))\n        {\n            /* Whitespace char in format string: skip next whitespace\n               chars in input data. This supports input of multiple\n               data items. */\n            while (ch>=0 && isspace(ch))\n            {\n                inch();\n            }\n        }\n        else   /* some other character in the format string */\n        {\n            if (ch != *format) return (cnt);\n            inch();\n        }\n        format++;\n        if ((fp != NULL && ch == EOF) || (fp == NULL && ch == 0)) fin = 1;\n            /* EOF */\n    }\n    if (fp != NULL) ungetc(ch, fp);\n    return (cnt);\n}\n\n__PDPCLIB_API__ char *gets(char *s)\n{\n    char *ret;\n\n    stdin->quickText = 0;\n    stdin->noNl = 1;\n    ret = fgets(s, INT_MAX, stdin);\n    stdin->noNl = 0;\n    stdin->quickText = 1;\n    return (ret);\n}\n\n__PDPCLIB_API__ int puts(const char *s)\n{\n    int ret;\n\n    ret = fputs(s, stdout);\n    if (ret == EOF)\n    {\n        return (ret);\n    }\n    return (putc('\\n', stdout));\n}\n\n/* The following functions are implemented as macros */\n\n#undef getchar\n#undef putchar\n#undef getc\n#undef putc\n#undef feof\n#undef ferror\n\n__PDPCLIB_API__ int getc(FILE *stream)\n{\n    return (fgetc(stream));\n}\n\n__PDPCLIB_API__ int putc(int c, FILE *stream)\n{\n    return (fputc(c, stream));\n}\n\n__PDPCLIB_API__ int getchar(void)\n{\n    return (getc(stdin));\n}\n\n__PDPCLIB_API__ int putchar(int c)\n{\n    return (putc(c, stdout));\n}\n\n__PDPCLIB_API__ int feof(FILE *stream)\n{\n    return (stream->eofInd);\n}\n\n__PDPCLIB_API__ int ferror(FILE *stream)\n{\n    return (stream->errorInd);\n}\n\n#if 0\nDesign of MVS i/o routines\n\nThe broad objectives of the MVS implementation are as follows:\n\n1. An application doing a binary fread equal to LRECL should\nget speed equivalent to doing the GET macro.\n\n2. An application doing a text fgets equal to or greater than\nLRECL should get speed equivalent to the GET macro.\n\n3. Variable-block files are encapsulated in terms of RDW files.\nRDW files are what is produced by certain implementations of\nftp when the \"rdw\" option is chosen. Data is stored on the PC\nor whatever as a 2-byte big-endian length, then 2 NUL bytes,\nthen the data. See the S/380 documentation that comes with\nMVS/380 for more information on this format. So a binary read\nof a V or VB file will produce a RDW stream (basically, BDWs\nare stripped, but not RDWs).\n\n4. If a binary copy is done from a V dataset to a U dataset,\nthe RDW data stream will be preserved exactly. If the U data\nset is subsequently copied to an F dataset, there will\nnecessarily be NUL-padding. If this dataset is then copied\nto a V dataset, the extraneous NULs (which comprise an\ninvalid RDW) will be silently ignored/stripped.\n\n5. If a text copy is done from a V dataset to a U dataset,\nthe U dataset will get x'15' (EBCDIC newline) characters\nadded. The RDW will be stripped. Trailing spaces will be\npreserved. With one exception - a single blank character\non a line will be removed.  If this dataset is then copied\nto a F dataset, there will be trailing spaces added to fit\nthe LRECL. If this dataset is then copied to a V dataset,\nthe trailing spaces will all be truncated. If a line is\nempty, a single blank character will be inserted.\n\n6. If a long line is being written in text mode, it will\nbe silently truncated regardless of whether the output file\nis RECFM=V or F. In binary mode, when writing to a RECFM=F,\nthe data simply gets wrapped to the next record. For a binary\nwrite to a RECFM=V where the RDW signals a length greater\nthan the LRECL, the record will be silently truncated. If\nwriting to a RECFM=V in binary mode with insufficient data\nto match the RDW, it is considered an error. Similarly,\nmore data than the RDW will cause a new record to be\nstarted. An invalid RDW in the data stream is considered\na write error.\n\n7. In RECFM=U datasets, the block boundary is always ignored.\nWhen the application writes a newline character to the data\nstream, it is treated as just another character and dutifully\nwritten out. Newlines are never added or stripped by the\nC library when a block boundary is encountered - not even in\ntext mode. This marks a break from IBMs behaviour and is\nrequired in order to be able to read a RECFM=U in binary\nmode (e.g. the way zip would) and still preserve newline\ncharacters if the file being read happens to be a text file\n(as opposed to e.g. another zip file - something zip has\nno way of knowing). NULs encountered when reading\na RECFM=U in text mode may be stripped. Similarly, trailing\nNULs in the application data stream are stripped. This way,\nsomeone doing a binary copy of a file, and who has stored\nit in a RECFM=F dataset (where NUL padding is necessary),\nand then has copied it into a RECFM=U (where NULs must\nnecessarily be preserved if doing binary copies) will be\nstripped by the first person who does a text read or\nwrite.\n\n8. DCB information provided by the user in JCL, or on a\ndataset, always has priority and the C library will adjust\naround that. Only if there is no existing DCB information\navailable anywhere will the C library provide a default,\nwhich is RECFM=VB,LRECL=255,BLKSIZE=6233 for text, and\nRECFM=U,LRECL=0,BLKSIZE=6233 for binary. This blocksize\nis traditionally considered to be the universal blocksize.\n\n9. An open of a PDS with no member given will read the\ndirectory. Any attempt to open a PDS directory for writing\nwill fail.\n\n10. RECFM=U allows you to preserve the exact length of\ndata. RECFM=FB with a LRECL of 1 also achieves this, but\nis much more overhead. A special exception may be made in\nthe future for binary reading of FB datasets to provide\nthe same performance as RECFM=U.\n\n11. Data is processed by the C library one record at a time.\nThere is an intention to change to block reading in the\nfuture now that the assembler (for MVS at least) has that\nflexibility.\n\n\nThe implementation has been based around 4 different processing\nconcepts:\n\n1. Fixed text.\n2. Fixed binary.\n3. Variable text.\n4. Variable binary.\n\nRECFM=U was grafted on in terms of a faked variable binary\nfor reading and a faked fixed binary for writing. There is\na \"reallyu\" to record the fact that it was really U, and\nat various points the processing changes slightly to cope\nwith that. There is also a \"reallyt\" variable that notes\nthe fact that it was originally a text mode request, but\nthat has been switched (to avoid translation of newlines\ninto spaces or RDW etc).\n\nThe code has been designed to work in both locate mode\nand in move mode, although it would be rare for anyone to\nwant to use locate mode, and support for that may drop at\nsome point.\n\n\nThe main assembler functions are as follows (note that\n__aopen in C becomes @@AOPEN in assembler):\n\nvoid *__aopen(const char *ddname,\n              int *mode,\n              int *recfm,\n              int *lrecl,\n              int *blksize,\n              void **asmbuf,\n              const char *member);\n\nThis function opens an 8-character (right-padded with spaces)\nDDNAME. For dynamically-allocated datasets, a previous call\nto __dynal would have been done to a generated ddname of the\nform PDP001HD where 001 corresponds to a spare slot. The\nmode is passed by address. It is typically simply set to\nread or write, but if it is set to read, blocked, then the\nassembler routines have the option of setting this to just\nread, e.g. if the device is a terminal and block mode is\ninappropriate.\n\nMode values are as follows:\n0 = input (read)\n1 = output (write)\n2 = update (read and write, initally read)\n3 = append\n4 = inout = read and write, initially read (same as update)\n5 = outin = write, then reread\n\nAdditional mode flags:\n0x08 = Use EXCP if input file is tape.\n0x10 = Use block mode.\n0x80 = Use GETLINE/PUTLINE if TSO terminal detected\n\nrecfm values are:\n0 = fixed\n1 = variable\n2 = undefined\nAnd again, the C program provides defaults but the assembler\nfunction has the final say.\n\nlrecl = default record/line length set by caller, with\nassembler deciding what to really do.\n\nblksize - default block size set by caller, assembler deciding\nwhat to really use.\n\nasmbuf - if file is opened in write mode, in the normal move\nmode, then this will be set to point to a buffer large enough\nto store the lrecl. Storage will be below the line so it is\nsuitable for doing I/O from. Buffer will be freed when the\ndataset is closed.\n\nmember - pointer to a PDS member to be opened. Member should\nbe 8 characters, padded with spaces. If member is set to NULL,\nthen this open is not for a member of a PDS (so this parameter\nis probably normally NULL).\n\n__aopen returns a \"handle\" on success, or a negative value\n(when cast to int) on failure. These values will probably\nbe unclumped in the future.\n\n\nint __aread(void *handle, void *buf, size_t *len);\n\nThis function takes the handle previously returned from __aopen\nand reads into the provided buffer a single record. It is\nassumed that the buffer is big enough to hold the LRECL\npreviously returned by __aopen. *len will contain the length\nof the actual record returned, e.g. if RECFM=U, then while\nreading each record (block), the length might change.\nIn the case of RECFM=V, the record includes a RDW.\n\n__aread returns 0 on success, non-zero on failure.\n\n\nint __awrite(void *handle, unsigned char **buf, size_t *sz);\n\nThis function takes the handle previously returned from __aopen\nand writes the buffer pointed to by *buf. If operating in locate\nmode, it actually sets the *buf to where to write to, so the\napplication can subsequently write there. *sz provides the\nlength of the data to write, which is particularly necessary\nfor RECFM=U where there is no other way to know the length.\nIn the future, the assembler may update the size to reflect\nactual written in the case of a partial write.\n\n__awrite returns 0 on success, non-zero for failure.\n\n\nvoid __aclose(void *handle);\n\nThis function takes the handle previously returned from __aopen\nand closes the file and releases any buffers that were allocated\nin the open.\n\n\n\nHere is some old documentation that might be worth updating\none day:\n\nin/out function rec-type mode   method\nin     fread    fixed    bin    loop reading, remember remainder\nin     fread    fixed    text   loop reading + truncing, remember rem\nin     fread    var      bin    loop reading (+ len), remember remainder\nin     fread    var      text   loop reading (+ len), remember remainder\nin     fgets    fixed    bin    read, scan, remember remainder\nin     fgets    fixed    text   read, trunc, remember remainder\nin     fgets    var      bin    read, scan, rr\nin     fgets    var      text   read, rr\nin     fgetc    fixed    bin    read, rr\nin     fgetc    fixed    text   read, trunc, rr\nin     fgetc    var      bin    read, rr\nin     fgetc    var      text   read, rr\n\nout    fwrite   fixed    bin    loop doing put, rr\nout    fwrite   fixed    text   search newline, copy + pad, put, rr\nout    fwrite   var      bin    if nelem != 1 copy to max lrecl\nout    fwrite   var      text   loop search nl, put, rr\nout    fputs    fixed    bin    loop doing put, rr\nout    fputs    fixed    text   search newline, copy + pad, put, rr\nout    fputs    var      bin    put\nout    fputs    var      text   search newline, put, copy rem\nout    fputc    fixed    bin    copy to rr until rr == lrecl\nout    fputc    fixed    text   copy to rr until newline, then pad\nout    fputc    var      bin    copy to rr until rr == lrecl\nout    fputc    var      text   copy to rr until newline\n\n\nfread: if quickbin, if read elem size == lrecl, doit\nfgets: if variable record + no remainder\n       if buffer > record size, copy + add newline\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n__PDPCLIB_API__ char *fgets(char *s, int n, FILE *stream)\n{\n    unsigned char *eptr;\n    size_t len;\n    int cnt;\n    int c;\n\n    if (stream->quickText)\n    {\n        if (__aread(stream->hfile, &dptr) != 0)\n        {\n            stream->eofInd = 1;\n            stream->quickText = 0;\n            return (NULL);\n        }\n        len = ((dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8) - 4;\n        if ((len == 1) && (dptr\u00dd4\u00a8 == ' '))\n        {\n            len = 0;\n        }\n        if (n > (len + 1))\n        {\n            memcpy(s, dptr + 4, len);\n            memcpy(s + len, \"\\n\", 2);\n            stream->bufStartR += len + 1;\n            return (s);\n        }\n        else\n        {\n            memcpy(stream->fbuf, dptr + 4, len);\n            stream->upto = stream->fbuf;\n            stream->endbuf = stream->fbuf + len;\n            *(stream->endbuf++) = '\\n';\n            stream->quickText = 0;\n        }\n    }\n\n    if (stream->eofInd)\n    {\n        return (NULL);\n    }\n\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            if ((stream->endbuf == stream->fbuf)\n                && (n > (stream->lrecl + 2)))\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    return (NULL);\n                }\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n                eptr++;\n                memcpy(s, dptr, eptr - dptr);\n                memcpy(s + (eptr - dptr), \"\\n\", 2);\n                stream->bufStartR += (eptr - dptr) + 1;\n                return (s);\n            }\n            break;\n\n        default:\n            break;\n\n    }\n\n    /* Ok, the obvious optimizations have been done,\n       so now we switch to the slow generic version */\n\n    n--;\n    cnt = 0;\n    while (cnt < n)\n    {\n        c = getc(stream);\n        if (c == EOF) break;\n        s\u00ddcnt\u00a8 = c;\n        if (c == '\\n') break;\n        cnt++;\n    }\n    if ((cnt == 0) && (c == EOF)) return (NULL);\n    if (cnt < n) s\u00ddcnt++\u00a8 = '\\n';\n    s\u00ddcnt\u00a8 = '\\0';\n    return (s);\n}\n\n__PDPCLIB_API__ int fputs(const char *s, FILE *stream)\n{\n    const char *p;\n    size_t len;\n\n    if (stream->quickText)\n    {\n        p = strchr(s, '\\n');\n        if (p != NULL)\n        {\n            len = p - s;\n            if (len > stream->lrecl)\n            {\n                len = stream->lrecl;\n            }\n            begwrite(stream, len + 4);\n            memcpy(dptr + 4, s, len);\n            dptr\u00dd0\u00a8 = (len + 4) >> 8;\n            dptr\u00dd1\u00a8 = (len + 4) & 0xff;\n            dptr\u00dd2\u00a8 = 0;\n            dptr\u00dd3\u00a8 = 0;\n            finwrite(stream);\n            stream->bufStartR += (len + 1);\n            if (*(p + 1) == '\\0')\n            {\n                return (len + 1);\n            }\n            s = p + 1;\n            stream->quickText = 0;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            len = strlen(s);\n            if (len > 0)\n            {\n                len--;\n                if (((strchr(s, '\\n') - s) == len)\n                    && (stream->upto == stream->fbuf)\n                    && (len <= stream->lrecl))\n                {\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, s, len);\n                    memset(dptr + len, ' ', stream->szfbuf - len);\n                    finwrite(stream);\n                    stream->bufStartR += len;\n                }\n                else\n                {\n                    fwrite(s, len + 1, 1, stream);\n                }\n            }\n            break;\n\n        default:\n            len = strlen(s);\n            fwrite(s, len, 1, stream);\n            break;\n    }\n    return (0);\n}\n\n__PDPCLIB_API__ size_t fwrite(const void *ptr,\n                              size_t size,\n                              size_t nmemb,\n                              FILE *stream)\n{\n    size_t bytes;\n    size_t sz;\n    char *p;\n    int x;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            begwrite(stream, stream->lrecl);\n            memcpy(dptr, ptr, size);\n            finwrite(stream);\n            stream->bufStartR += size;\n            return (1);\n        }\n        else\n        {\n            stream->quickBin = 0;\n        }\n    }\n    switch (stream->style)\n    {\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            /* if we've exceed our buffer we need to write out\n               a record - but if we haven't written any data to\n               our internal buffer yet, don't bother going through\n               this code, it'll be handled later. */\n            if (((stream->endbuf - stream->upto) <= bytes)\n                && (stream->upto != stream->fbuf))\n            {\n                /* ready to write a record - request some space\n                   from MVS */\n                begwrite(stream, stream->lrecl);\n                sz = stream->endbuf - stream->upto;\n                memcpy(dptr, stream->fbuf, stream->szfbuf - sz);\n                memcpy(dptr + stream->szfbuf - sz, ptr, sz);\n                finwrite(stream);\n                ptr = (char *)ptr + sz;\n                bytes -= sz;\n                stream->upto = stream->fbuf;\n                stream->bufStartR += stream->szfbuf;\n            }\n            /* At this point, the internal buffer is empty if the\n               number of bytes to write is still greater than the\n               internal buffer. In which case, start writing directly\n               to an MVS-provided area. */\n            while (bytes >= stream->szfbuf)\n            {\n                begwrite(stream, stream->lrecl);\n                memcpy(dptr, ptr, stream->szfbuf);\n                finwrite(stream);\n                ptr = (char *)ptr + stream->szfbuf;\n                bytes -= stream->szfbuf;\n                stream->bufStartR += stream->szfbuf;\n            }\n\n            /* RECFM=U to a text file should write up to the most\n               recent newline */\n            if (stream->line_buf && stream->reallyu && stream->reallyt)\n            {\n                p = (char *)ptr + bytes - 1;\n                /* look for a newline somewhere in this new data */\n                /* since we write on both buffer full and newline\n                   found conditions */\n                while (p >= (char *)ptr)\n                {\n                    if (*p == '\\n') break;\n                    p--;\n                }\n                /* found a newline, write up to this point, including\n                   any data that may be in our internal buffer */\n                if (p >= (char *)ptr)\n                {\n                    p++; /* get past the newline */\n                    sz = stream->upto - stream->fbuf;\n                    stream->upto = stream->fbuf;\n                    begwrite(stream, sz + (p - (char *)ptr));\n                    memcpy(dptr, stream->fbuf, sz);\n                    memcpy(dptr + sz, ptr, (p - (char *)ptr));\n                    finwrite(stream);\n                    bytes -= (p - (char *)ptr);\n                    stream->bufStartR += (p - (char *)ptr);\n                    ptr = p;\n                    stream->upto = stream->fbuf;\n                }\n            }\n\n            /* any remainder needs to go into the internal buffer */\n            memcpy(stream->upto, ptr, bytes);\n            stream->upto += bytes;\n            break;\n\n        case VARIABLE_BINARY:\n            bytes = nmemb * size;\n            while (bytes > 0)\n            {\n                int fulllen;\n\n                if (stream->errorInd) break;\n                sz = stream->upto - stream->fbuf;\n                if (sz < 4)\n                {\n                    if ((bytes + sz) < 4)\n                    {\n                        memcpy(stream->upto, ptr, bytes);\n                        stream->upto += bytes;\n                        bytes = 0;\n                        break;\n                    }\n                    else\n                    {\n                        memcpy(stream->upto, ptr, 4 - sz);\n                        ptr = (char *)ptr + (4 - sz);\n                        bytes -= (4 - sz);\n                        stream->upto += (4 - sz);\n                        sz = 4;\n                        if (memcmp(stream->fbuf + 2, \"\\0\\0\", 2) != 0)\n                        {\n                            stream->errorInd = 1;\n                            break;\n                        }\n                        fulllen = (stream->fbuf\u00dd0\u00a8 << 8) | stream->fbuf\u00dd1\u00a8;\n                        if (fulllen == 0)\n                        {\n                            /* here we allow for the possibility that\n                               they are copying a data source that has\n                               terminating NULs added - so long as all\n                               remaining charactes are NUL, it will be\n                               allowed. Otherwise we rely on the above\n                               validation to catch a problem - checking\n                               2 bytes at a time, which shouldn't be a\n                               problem since this is only at the end of\n                               the file */\n                            stream->upto = stream->fbuf + 2;\n                            continue;\n                        }\n                        else if (fulllen < 4)\n                        {\n                            stream->errorInd = 1;\n                            break;\n                        }\n                    }\n                }\n\n                /* we have 4 bytes, validated */\n                fulllen = (stream->fbuf\u00dd0\u00a8 << 8) | stream->fbuf\u00dd1\u00a8;\n\n                /* If we have enough data, write it out */\n                if ((sz + bytes) >= fulllen)\n                {\n                    /* silently truncate long records to give\n                       user more flexibility */\n                    if (fulllen > stream->lrecl)\n                    {\n                        stream->fbuf\u00dd0\u00a8 = stream->lrecl >> 8;\n                        stream->fbuf\u00dd1\u00a8 = stream->lrecl & 0xff;\n                        begwrite(stream, stream->lrecl + 4);\n                        if (sz >= stream->lrecl)\n                        {\n                            memcpy(dptr, stream->fbuf, stream->lrecl);\n                        }\n                        else\n                        {\n                            memcpy(dptr, stream->fbuf, sz);\n                            memcpy(dptr + sz, ptr, stream->lrecl - sz);\n                        }\n                    }\n                    else\n                    {\n                        begwrite(stream, fulllen);\n                        memcpy(dptr, stream->fbuf, sz);\n                        memcpy(dptr + sz, ptr, fulllen - sz);\n                    }\n                    finwrite(stream);\n                    stream->bufStartR += fulllen;\n                    stream->upto = stream->fbuf;\n                    bytes -= (fulllen - sz);\n                    ptr = (char *)ptr + (fulllen - sz);\n                }\n\n                /* less data than required, store it, without\n                   overflowing our buffer */\n                else if ((sz + bytes) > stream->lrecl)\n                {\n                    memcpy(stream->upto,\n                           ptr,\n                           stream->lrecl - sz);\n                    /* here we allow upto to exceed our buffer.\n                       shouldn't be a problem as we never write\n                       to that memory. alternative is to make\n                       BUFSIZ 64k. */\n                    stream->upto += bytes;\n                    ptr = (char *)ptr + bytes;\n                    bytes = 0;\n                }\n\n                /* enough room to fit data */\n                else\n                {\n                    memcpy(stream->upto, ptr, bytes);\n                    stream->upto += bytes;\n                    ptr = (char *)ptr + bytes;\n                    bytes = 0;\n                }\n            }\n            break;\n\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, ptr, sz);\n                    memset(dptr + sz, ' ', stream->szfbuf - sz);\n                    finwrite(stream);\n                    stream->bufStartR += sz;\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, ptr, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    begwrite(stream, stream->lrecl);\n                    memcpy(dptr, stream->fbuf, sz);\n                    memset(dptr + sz, ' ', stream->lrecl - sz);\n                    finwrite(stream);\n                    stream->bufStartR += sz;\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        begwrite(stream, stream->lrecl);\n                        memcpy(dptr, ptr, sz);\n                        memset(dptr + sz, ' ', stream->szfbuf - sz);\n                        finwrite(stream);\n                        stream->bufStartR += sz;\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n\n        case VARIABLE_TEXT:\n            stream->quickText = 0;\n            bytes = nmemb * size;\n            p = memchr(ptr, '\\n', bytes);\n            if (p != NULL)\n            {\n                sz = p - (char *)ptr;\n                bytes -= sz + 1;\n                if (stream->upto == stream->fbuf)\n                {\n                    if (sz > stream->lrecl)\n                    {\n                        sz = stream->lrecl;\n                    }\n                    begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                    if(sz == 0)\n                    {\n                        dptr\u00dd0\u00a8 = 0;\n                        dptr\u00dd1\u00a8 = 5;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        dptr\u00dd4\u00a8 = ' ';\n                        finwrite(stream);\n                        /* note that the bufStartR needs to reflect\n                           just the newline, and not the dummy space\n                           we added */\n                        stream->bufStartR += 1;\n                    }\n                    else\n                    {\n                        dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                        dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        memcpy(dptr + 4, ptr, sz);\n                        finwrite(stream);\n                        stream->bufStartR += (sz + 1);\n                    }\n                }\n                else\n                {\n                    if (((stream->upto - stream->fbuf) + sz) > stream->lrecl)\n                    {\n                        sz = stream->lrecl - (stream->upto - stream->fbuf);\n                    }\n                    memcpy(stream->upto, ptr, sz);\n                    sz += (stream->upto - stream->fbuf);\n                    begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                    if(sz == 0)\n                    {\n                        dptr\u00dd0\u00a8 = 0;\n                        dptr\u00dd1\u00a8 = 5;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        dptr\u00dd4\u00a8 = ' ';\n                        finwrite(stream);\n                        stream->bufStartR += 1;\n                    }\n                    else\n                    {\n                        dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                        dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                        dptr\u00dd2\u00a8 = 0;\n                        dptr\u00dd3\u00a8 = 0;\n                        memcpy(dptr + 4, stream->fbuf, sz);\n                        finwrite(stream);\n                        stream->bufStartR += (sz + 1);\n                    }\n                    stream->upto = stream->fbuf;\n                }\n                ptr = (char *)p + 1;\n                if (bytes > 0)\n                {\n                    p = memchr(ptr, '\\n', bytes);\n                    while (p != NULL)\n                    {\n                        sz = p - (char *)ptr;\n                        bytes -= sz + 1;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        begwrite(stream, (sz == 0) ? 5 : sz + 4);\n                        if(sz == 0)\n                        {\n                            dptr\u00dd0\u00a8 = 0;\n                            dptr\u00dd1\u00a8 = 5;\n                            dptr\u00dd2\u00a8 = 0;\n                            dptr\u00dd3\u00a8 = 0;\n                            dptr\u00dd4\u00a8 = ' ';\n                            finwrite(stream);\n                            stream->bufStartR += 1;\n                        }\n                        else\n                        {\n                            dptr\u00dd0\u00a8 = (sz + 4) >> 8;\n                            dptr\u00dd1\u00a8 = (sz + 4) & 0xff;\n                            dptr\u00dd2\u00a8 = 0;\n                            dptr\u00dd3\u00a8 = 0;\n                            memcpy(dptr + 4, ptr, sz);\n                            finwrite(stream);\n                            stream->bufStartR += (sz + 1);\n                        }\n                        ptr = p + 1;\n                        p = memchr(ptr, '\\n', bytes);\n                    }\n                    if (bytes > 0)\n                    {\n                        sz = bytes;\n                        if (sz > stream->lrecl)\n                        {\n                            sz = stream->lrecl;\n                        }\n                        memcpy(stream->upto, ptr, sz);\n                        stream->upto += sz;\n                        bytes = 0;\n                    }\n                }\n            }\n            else /* p == NULL */\n            {\n                if (((stream->upto - stream->fbuf) + bytes) > stream->lrecl)\n                {\n                    bytes = stream->lrecl - (stream->upto - stream->fbuf);\n                }\n                memcpy(stream->upto, ptr, bytes);\n                stream->upto += bytes;\n            }\n            break;\n    }\n    return (nmemb);\n}\n\n__PDPCLIB_API__ size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n{\n    size_t bytes;\n    size_t read;\n    size_t totalread;\n    size_t extra;\n    unsigned char *eptr;\n\n    if (stream->quickBin)\n    {\n        if ((nmemb == 1) && (size == stream->lrecl))\n        {\n            if (__aread(stream->hfile, &dptr) != 0)\n            {\n                stream->eofInd = 1;\n                stream->quickBin = 0;\n                return (0);\n            }\n            memcpy(ptr, dptr, size);\n            return (1);\n        }\n        else\n        {\n            stream->quickBin = 0;\n        }\n    }\n    if (stream->eofInd)\n    {\n        return (0);\n    }\n\n    /* If we have an unget character, then write it into\n       the buffer in advance */\n    if (stream->ungetCh != -1)\n    {\n        stream->upto--;\n        *stream->upto = stream->ungetCh;\n        stream->ungetCh = -1;\n    }\n\n    switch (stream->style)\n    {\n        case FIXED_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                eptr = dptr + stream->lrecl - 1;\n                while ((*eptr == ' ') && (eptr >= dptr))\n                {\n                    eptr--;\n                }\n\n                read = eptr + 1 - dptr;\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                    stream->bufStartR++;\n                }\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case FIXED_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = stream->lrecl;\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case VARIABLE_TEXT:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                read = (dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8;\n                read -= 4;\n                dptr += 4;\n                if ((read == 1) && (dptr\u00dd0\u00a8 == ' '))\n                {\n                    read = 0;\n                }\n\n                if ((totalread + read) >= bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                    *stream->endbuf++ = '\\n';\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n                if (totalread < bytes)\n                {\n                    *((char *)ptr + totalread) = '\\n';\n                    totalread++;\n                    stream->bufStartR++;\n                }\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        case VARIABLE_BINARY:\n            bytes = nmemb * size;\n            read = stream->endbuf - stream->upto;\n            if (read > bytes)\n            {\n                memcpy(ptr, stream->upto, bytes);\n                stream->upto += bytes;\n                totalread = bytes;\n            }\n            else\n            {\n                memcpy(ptr, stream->upto, read);\n                stream->bufStartR += (stream->endbuf - stream->fbuf);\n                stream->upto = stream->endbuf = stream->fbuf;\n                totalread = read;\n            }\n\n            while (totalread < bytes)\n            {\n                if (__aread(stream->hfile, &dptr) != 0)\n                {\n                    stream->eofInd = 1;\n                    break;\n                }\n\n                if (!stream->reallyu)\n                {\n                    read = (dptr\u00dd0\u00a8 << 8) | dptr\u00dd1\u00a8;\n                }\n                else\n                {\n                    read = lenread;\n                    if (stream->reallyt)\n                    {\n                        unsigned char *p;\n\n                        /* get rid of any trailing NULs in text mode */\n                        p = memchr(dptr, '\\0', read);\n                        if (p != NULL)\n                        {\n                            read = p - dptr;\n                        }\n                    }\n                }\n\n                if ((totalread + read) > bytes)\n                {\n                    extra = (totalread + read) - bytes;\n                    read -= extra;\n                    memcpy(stream->fbuf, dptr + read, extra);\n                    stream->endbuf = stream->fbuf + extra;\n                }\n\n                memcpy((char *)ptr + totalread, dptr, read);\n                totalread += read;\n                stream->bufStartR += read;\n            }\n            return ((size == 0) ? 0 : (totalread / size));\n            break;\n\n        default:\n            break;\n    }\n    return (0);\n}\n\n#endif\n\n/*\n   filedef dynamically allocates a file (via SVC 99) on MVS-like\n   environments.\n*/\n\n#if defined(__MVS__)\n\nstatic struct {\n  char len; /* length of request block, always 20 */\n  char verb; /* dynamic allocation function requested */\n  char flag1;\n  char flag2;\n  short error_reason; /* returned */\n  short info_reason; /* returned */\n  void *tu_list; /* list of pointers to text units */\n  int reserved;\n  char moreflags\u00dd4\u00a8; /* extraflags */\n} rb;\n\nstatic void *tu_list\u00dd10\u00a8; /* pointers to text units */\n\nstatic struct {\n  short key; /* key defining what this text unit is */\n  short numparms; /* number of parms that follow */\n  short parm1_len;\n  char parm1\u00dd98\u00a8;\n  /* parm2_len etc would theoretically follow, but we\n  /* can't define them, because the length of 98 is probably\n     not correct in the first place */\n} tu\u00dd10\u00a8;\n\nstatic void filedef(char *fdddname, char *fnm, int mymode)\n{\n    memset(&rb, 0x00, sizeof rb);\n    rb.len = 20;\n    rb.verb = 0x01; /* allocate */\n    rb.tu_list = tu_list;\n\n    tu_list\u00dd0\u00a8 = &tu\u00dd0\u00a8;\n    tu\u00dd0\u00a8.key = 0x0001; /* ddname */\n    tu\u00dd0\u00a8.numparms = 1;\n    tu\u00dd0\u00a8.parm1_len = strlen(fdddname);\n    strcpy(tu\u00dd0\u00a8.parm1, fdddname);\n\n    tu_list\u00dd1\u00a8 = &tu\u00dd1\u00a8;\n    tu\u00dd1\u00a8.key = 0x0002; /* dsname */\n    tu\u00dd1\u00a8.numparms = 1;\n    tu\u00dd1\u00a8.parm1_len = strlen(fnm);\n    strcpy(tu\u00dd1\u00a8.parm1, fnm);\n\n    tu_list\u00dd2\u00a8 = &tu\u00dd2\u00a8;\n    tu\u00dd2\u00a8.key = 0x0004; /* disp */\n    tu\u00dd2\u00a8.numparms = 1;\n    tu\u00dd2\u00a8.parm1_len = 1;\n    tu\u00dd2\u00a8.parm1\u00dd0\u00a8 = 0x08; /* SHR */\n\n    tu_list\u00dd3\u00a8 = 0;\n    tu_list\u00dd4\u00a8 = 0;\n    tu_list\u00dd5\u00a8 = (void *)0x80000000;\n\n    errno = __svc99(&rb);\n\n    /* if we had an error, then for datasets open for write,\n       try allocating a new dataset (this will be the normal\n       situation - it is abnormal is to find the dataset already\n       pre-allocated */\n    if (errno)\n    {\n        /* if open for write */\n        if ( mymode )\n        {\n            tu\u00dd2\u00a8.parm1\u00dd0\u00a8 = 0x04; /* NEW */\n#if !defined(__PDOS__) /* PDOS uses RECFM=U by default */\n            /* if binary */\n            if (modeType == 5)\n            {\n                /* F80, which is default */\n            }\n            else\n            {\n                /* V255 */\n                tu_list\u00dd3\u00a8 = &tu\u00dd3\u00a8;\n                tu\u00dd3\u00a8.key = 0x49; /* RECFM */\n                tu\u00dd3\u00a8.numparms = 1;\n                tu\u00dd3\u00a8.parm1_len = 1;\n                tu\u00dd3\u00a8.parm1\u00dd0\u00a8 = 0x40; /* V */\n\n                tu_list\u00dd4\u00a8 = &tu\u00dd4\u00a8;\n                tu\u00dd4\u00a8.key = 0x42; /* LRECL */\n                tu\u00dd4\u00a8.numparms = 1;\n                tu\u00dd4\u00a8.parm1_len = 2;\n                tu\u00dd4\u00a8.parm1\u00dd0\u00a8 = 0; /* LRECL = 255 */\n                tu\u00dd4\u00a8.parm1\u00dd1\u00a8 = 255;\n            }\n#endif\n        }\n        errno = __svc99(&rb);\n    }\n    if (errno != 0)\n    {\n        if (rb.error_reason != 0)\n        {\n            errno = rb.error_reason;\n        }\n        err = 1;\n    }\n    return;\n}\n\nstatic void fdclr(char *ddname)\n{\n    memset(&rb, 0x00, sizeof rb);\n    rb.len = 20;\n    rb.verb = 0x02; /* unallocate */\n    rb.tu_list = tu_list;\n\n    tu_list\u00dd0\u00a8 = &tu\u00dd0\u00a8;\n    tu\u00dd0\u00a8.key = 0x0001; /* ddname */\n    tu\u00dd0\u00a8.numparms = 1;\n    tu\u00dd0\u00a8.parm1_len = strlen(ddname);\n    strcpy(tu\u00dd0\u00a8.parm1, ddname);\n\n    tu_list\u00dd1\u00a8 = (void *)0x80000000;\n\n    __svc99(&rb);\n    return;\n}\n#endif\n\n\n/*\n   Following code issues a FILEDEF for CMS\n*/\n\n#ifdef __CMS__\nstatic void filedef(char *fdddname, char *fnm, int mymode)\n{\n    char s202parm \u00dd800\u00a8;\n\n    int code;\n    int parm;\n    char *fname;\n    char *ftype;\n    char *fmode;\n    char *p;\n    int console;\n\n/*\n    Skip leading blanks because sometimes people do that in CMS\n*/\n    while (fnm\u00dd0\u00a8 == ' ') fnm++;\n\n/*\n    first parse the file name\n*/\n    console = 0;\n    if( fnm\u00dd0\u00a8 == '*') console = 1;\n    while ( NULL != (p = strchr(fnm, '.')) )*p=' '; /* replace . with   */\n    fname =  strtok(fnm, \" \");\n    ftype =  strtok(NULL, \" \");\n    if (ftype == NULL) ftype = \"\";\n    fmode =  strtok(NULL, \" \");\n    if (fmode == NULL) fmode = \"\";\n\n\n/*\n Now build the SVC 202 string\n*/\n    memcpy ( &s202parm\u00dd0\u00a8 , \"FILEDEF \", 8);\n    memcpy ( &s202parm\u00dd8\u00a8 , fdddname, 8);\n    if(console)\n    {\n        memcpy ( &s202parm\u00dd16\u00a8 , \"TERMINAL\", 8);\n        memcpy ( &s202parm\u00dd24\u00a8 , \"(       \" , 8 );\n        memcpy ( &s202parm\u00dd32\u00a8 , \"RECFM   \" , 8 );\n        memcpy ( &s202parm\u00dd40\u00a8 , \"V       \" , 8 );\n        memcpy ( &s202parm\u00dd48\u00a8 , \"LRECL   \" , 8 );\n        memcpy ( &s202parm\u00dd56\u00a8 , \"80      \" , 8 );\n        s202parm\u00dd64\u00a8=s202parm\u00dd65\u00a8=s202parm\u00dd66\u00a8=s202parm\u00dd67\u00a8=\n            s202parm\u00dd68\u00a8=s202parm\u00dd69\u00a8=s202parm\u00dd70\u00a8=s202parm\u00dd71\u00a8=0xff;\n    }\n    else\n    {\n        memcpy ( &s202parm\u00dd16\u00a8 , \"DISK    \", 8);\n/*\n  Clear PARMS area\n*/\n        memcpy ( &s202parm\u00dd24\u00a8 , \"        \" , 8);\n        memcpy ( &s202parm\u00dd32\u00a8 , \"        \" , 8);\n        if (mymode)\n        {\n            memcpy ( &s202parm\u00dd40\u00a8 , \"A1      \" , 8);\n            if (fmode\u00dd0\u00a8 != '\\0')\n            {\n                memcpy ( &s202parm\u00dd40\u00a8 , fmode, strlen(fmode));\n            }\n        }\n        else\n        {\n            memcpy ( &s202parm\u00dd40\u00a8 , \"*       \" , 8);\n            memcpy ( &s202parm\u00dd40\u00a8 , fmode , strlen(fmode) );\n        }\n\n        memcpy ( &s202parm\u00dd24\u00a8 , fname ,\n                 ( strlen(fname) > 8 ) ? 8 : strlen(fname)  );\n        memcpy ( &s202parm\u00dd32\u00a8 , ftype ,\n                 ( strlen(ftype) >8 ) ? 8 : strlen(ftype) );\n        if ( mymode )\n        {\n             memcpy ( &s202parm\u00dd48\u00a8 , \"(       \" , 8 );\n             memcpy ( &s202parm\u00dd56\u00a8 , \"RECFM   \" , 8 );\n             memcpy ( &s202parm\u00dd64\u00a8 , \"V       \" , 8 );\n             memcpy ( &s202parm\u00dd72\u00a8 , \"LRECL   \" , 8 );\n             memcpy ( &s202parm\u00dd80\u00a8 , \"2000    \" , 8 );\n             if (modeType == 5)\n             {\n                 memcpy ( &s202parm\u00dd64\u00a8 , \"F       \" , 8 );\n                 memcpy ( &s202parm\u00dd80\u00a8 , \"800     \" , 8 );\n             }\n             s202parm\u00dd88\u00a8=s202parm\u00dd89\u00a8=s202parm\u00dd90\u00a8=s202parm\u00dd91\u00a8=\n                 s202parm\u00dd92\u00a8=s202parm\u00dd93\u00a8=s202parm\u00dd94\u00a8=s202parm\u00dd95\u00a8=0xff;\n        }\n        else\n        {\n             s202parm\u00dd48\u00a8=s202parm\u00dd49\u00a8=s202parm\u00dd50\u00a8=s202parm\u00dd51\u00a8=\n                 s202parm\u00dd52\u00a8=s202parm\u00dd53\u00a8=s202parm\u00dd54\u00a8=s202parm\u00dd55\u00a8=0xff;\n        }\n    }\n    __SVC202 ( s202parm, &code, &parm );\n}\n\nstatic void fdclr(char *ddname)\n{\n    char s202parm \u00dd800\u00a8;\n    int code;\n    int parm;\n\n    /* build the SVC 202 string */\n    memcpy( &s202parm\u00dd0\u00a8 , \"FILEDEF \", 8);\n    memcpy( &s202parm\u00dd8\u00a8 , ddname, 8);\n    memcpy( &s202parm\u00dd16\u00a8 , \"CLEAR   \", 8);\n    memset( &s202parm\u00dd24\u00a8, 0xff, 8);\n\n    __SVC202 ( s202parm, &code, &parm );\n    return;\n}\n\n/*\n   Following code does a rename for CMS\n*/\n\nstatic int cmsrename(const char *old, const char *newnam)\n{\n    char s202parm\u00dd8*8\u00a8;\n    int code;\n    int parm;\n    const char *p;\n    const char *q;\n    const char *r;\n    const char *s;\n\n    memset(s202parm, ' ', sizeof s202parm);\n    p = strchr(old, ' ');\n    if (p == NULL) return (-1);\n    q = strchr(p + 1, ' ');\n    if (q == NULL) return (-1);\n    r = strchr(newnam, ' ');\n    if (r == NULL) return (-1);\n    s = strchr(r + 1, ' ');\n    if (s == NULL) return (-1);\n\n    /* build the SVC 202 string */\n    memcpy( &s202parm\u00dd0\u00a8 , \"RENAME  \", 8);\n    memcpy( &s202parm\u00dd8\u00a8 , old, p - old);\n    memcpy( &s202parm\u00dd16\u00a8 , p + 1, q - p - 1);\n    memcpy( &s202parm\u00dd24\u00a8 , q + 1, strlen(q + 1));\n    memcpy( &s202parm\u00dd32\u00a8 , newnam, r - newnam);\n    memcpy( &s202parm\u00dd40\u00a8 , r + 1, s - r - 1);\n    memcpy( &s202parm\u00dd48\u00a8 , s + 1, strlen(s + 1));\n    memset( &s202parm\u00dd56\u00a8, 0xff, 8);\n\n    __SVC202 ( s202parm, &code, &parm );\n    return (parm);\n}\n\n/*\n   Following code does a remove for CMS\n*/\n\nstatic int cmsremove(const char *filename)\n{\n    char s202parm\u00dd5*8\u00a8;\n    int code;\n    int parm;\n    const char *p;\n    const char *q;\n\n    memset(s202parm, ' ', sizeof s202parm);\n\n    /* build the SVC 202 string */\n    memcpy( &s202parm\u00dd0\u00a8 , \"ERASE   \", 8);\n\n    p = strchr(filename, ' ');\n    if (p == NULL)\n    {\n        memcpy( &s202parm\u00dd8\u00a8 , filename, strlen(filename));\n        memset( &s202parm\u00dd16\u00a8, 0xff, 8);\n    }\n    else\n    {\n        memcpy( &s202parm\u00dd8\u00a8 , filename, p - filename);\n        q = strchr(p + 1, ' ');\n        if (q == NULL)\n        {\n            memcpy( &s202parm\u00dd16\u00a8 , p + 1, strlen(p + 1));\n            memset( &s202parm\u00dd24\u00a8, 0xff, 8);\n        }\n        else\n        {\n            memcpy( &s202parm\u00dd16\u00a8 , p + 1, q - p - 1);\n            memcpy( &s202parm\u00dd24\u00a8 , q + 1, strlen(q + 1));\n            memset( &s202parm\u00dd32\u00a8, 0xff, 8);\n        }\n    }\n\n    __SVC202 ( s202parm, &code, &parm );\n    return (parm);\n}\n\nstatic char *int_strtok(char *s1, const char *s2)\n{\n    static char *old = NULL;\n    char *p;\n    size_t len;\n    size_t remain;\n\n    if (s1 != NULL) old = s1;\n    if (old == NULL) return (NULL);\n    p = old;\n    len = strspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (NULL); }\n    p += len;\n    len = strcspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (p); }\n    *(p + len) = '\\0';\n    old = p + len + 1;\n    return (p);\n}\n\n#endif\n\n\n/*\n\n The truely cludged piece of code was concocted by Dave Wade\n\n His erstwhile tutors are probably turning in their graves.\n\n It is however placed in the Public Domain so that any one\n who wishes to improve is free to do so\n\n*/\n\nstatic void dblcvt(double num, char cnvtype, size_t nwidth,\n            int nprecision, char *result)\n{\n    double b,round;\n    int i,j,exp,pdigits,format;\n    char sign, work\u00dd45\u00a8;\n\n    /* save original data & set sign */\n\n    if ( num < 0 )\n    {\n        b = -num;\n        sign = '-';\n    }\n    else\n    {\n        b = num;\n        sign = ' ';\n    }\n\n    /*\n      Now scale to get exponent\n    */\n\n    exp = 0;\n    if( b > 1.0 )\n    {\n        while ((b >= 10.0) && (exp < 35))\n        {\n            ++exp;\n            b=b / 10.0;\n        }\n    }\n    else if ( b == 0.0 )\n    {\n        exp=0;\n    }\n    /* 1.0 will get exp = 0 */\n    else if ( b < 1.0 )\n    {\n        while ((b < 1.0) && (exp > -35))\n        {\n            --exp;\n            b=b*10.0;\n        }\n    }\n    if ((exp <= -35) || (exp >= 35))\n    {\n        exp = 0;\n        b = 0.0;\n    }\n\n    /*\n      now decide how to print and save in FORMAT.\n         -1 => we need leading digits\n          0 => print in exp\n         +1 => we have digits before dp.\n    */\n\n    switch (cnvtype)\n    {\n        case 'E':\n        case 'e':\n            format = 0;\n            break;\n        case 'f':\n        case 'F':\n            if ( exp >= 0 )\n            {\n                format = 1;\n            }\n            else\n            {\n                format = -1;\n            }\n            break;\n        default:\n            /* Style e is used if the exponent from its\n               conversion is less than -4 or greater than\n               or equal to the precision.\n            */\n            if ( exp >= 0 )\n            {\n                if ( nprecision > exp )\n                {\n                    format=1;\n                }\n                else\n                {\n                    format=0;\n                }\n            }\n            else\n            {\n                /*  if ( nprecision > (-(exp+1) ) ) { */\n                if ( exp >= -4)\n                {\n                    format=-1;\n                }\n                else\n                {\n                    format=0;\n                }\n            }\n            break;\n    }\n    /*\n    Now round\n    */\n    switch (format)\n    {\n        case 0:    /* we are printing in standard form */\n            if (nprecision < DBL_MANT_DIG) /* we need to round */\n            {\n                j = nprecision;\n            }\n            else\n            {\n                j=DBL_MANT_DIG;\n            }\n            round = 1.0/2.0;\n            i = 0;\n            while (++i <= j)\n            {\n                round = round/10.0;\n            }\n            b = b + round;\n            if (b >= 10.0)\n            {\n                b = b/10.0;\n                exp = exp + 1;\n            }\n            break;\n\n        case 1:      /* we have a number > 1  */\n                         /* need to round at the exp + nprecisionth digit */\n                if (exp + nprecision < DBL_MANT_DIG) /* we need to round */\n                {\n                    j = exp + nprecision;\n                }\n                else\n                {\n                    j = DBL_MANT_DIG;\n                }\n                round = 0.5;\n                i = 0;\n                while (i++ < j)\n                {\n                    round = round/10;\n                }\n                b = b + round;\n                if (b >= 10.0)\n                {\n                    b = b/10.0;\n                    exp = exp + 1;\n                }\n                break;\n\n        case -1:   /* we have a number that starts 0.xxxx */\n            if (nprecision < DBL_MANT_DIG) /* we need to round */\n            {\n                j = nprecision + exp + 1;\n            }\n            else\n            {\n                j = DBL_MANT_DIG;\n            }\n            round = 5.0;\n            i = 0;\n            while (i++ < j)\n            {\n                round = round/10;\n            }\n            if (j >= 0)\n            {\n                b = b + round;\n            }\n            if (b >= 10.0)\n            {\n                b = b/10.0;\n                exp = exp + 1;\n            }\n            if (exp >= 0)\n            {\n                format = 1;\n            }\n            break;\n    }\n    /*\n       Now extract the requisite number of digits\n    */\n\n    if (format==-1)\n    {\n        /*\n             Number < 1.0 so we need to print the \"0.\"\n             and the leading zeros...\n        */\n        result\u00dd0\u00a8=sign;\n        result\u00dd1\u00a8='0';\n        result\u00dd2\u00a8='.';\n        result\u00dd3\u00a8=0x00;\n        while (++exp)\n        {\n            --nprecision;\n            strcat(result,\"0\");\n        }\n        i=b;\n        --nprecision;\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n\n        pdigits = nprecision;\n\n        while (pdigits-- > 0)\n        {\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n    /*\n       Number >= 1.0 just print the first digit\n    */\n    else if (format==+1)\n    {\n        i = b;\n        result\u00dd0\u00a8 = sign;\n        result\u00dd1\u00a8 = '\\0';\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n        nprecision = nprecision + exp;\n        pdigits = nprecision ;\n\n        while (pdigits-- > 0)\n        {\n            if ( ((nprecision-pdigits-1)==exp)  )\n            {\n                strcat(result,\".\");\n            }\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n    /*\n       printing in standard form\n    */\n    else\n    {\n        i = b;\n        result\u00dd0\u00a8 = sign;\n        result\u00dd1\u00a8 = '\\0';\n        work\u00dd0\u00a8 = (char)('0' + i % 10);\n        work\u00dd1\u00a8 = 0x00;\n        strcat(result,work);\n        strcat(result,\".\");\n\n        pdigits = nprecision;\n\n        while (pdigits-- > 0)\n        {\n            b = b - i;\n            b = b * 10.0;\n            i = b;\n            work\u00dd0\u00a8 = (char)('0' + i % 10);\n            work\u00dd1\u00a8 = 0x00;\n            strcat(result,work);\n        }\n    }\n\n    if (format==0)\n    { /* exp format - put exp on end */\n        work\u00dd0\u00a8 = 'E';\n        if ( exp < 0 )\n        {\n            exp = -exp;\n            work\u00dd1\u00a8= '-';\n        }\n        else\n        {\n            work\u00dd1\u00a8= '+';\n        }\n        work\u00dd2\u00a8 = (char)('0' + (exp/10) % 10);\n        work\u00dd3\u00a8 = (char)('0' + exp % 10);\n        work\u00dd4\u00a8 = 0x00;\n        strcat(result, work);\n    }\n    else\n    {\n        /* get rid of trailing zeros for g specifier */\n        if (cnvtype == 'G' || cnvtype == 'g')\n        {\n            char *p;\n\n            p = strchr(result, '.');\n            if (p != NULL)\n            {\n                p++;\n                p = p + strlen(p) - 1;\n                while (*p != '.' && *p == '0')\n                {\n                    *p = '\\0';\n                    p--;\n                }\n                if (*p == '.')\n                {\n                    *p = '\\0';\n                }\n            }\n        }\n     }\n    /* printf(\" Final Answer = <%s> fprintf gives=%g\\n\",\n                result,num); */\n    /*\n     do we need to pad\n    */\n    if(result\u00dd0\u00a8 == ' ')strcpy(work,result+1); else strcpy(work,result);\n    pdigits=nwidth-strlen(work);\n    result\u00dd0\u00a8= 0x00;\n    while(pdigits>0)\n    {\n        strcat(result,\" \");\n        pdigits--;\n    }\n    strcat(result,work);\n    return;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STDLIB": {"ttr": 5129, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdlib.c - implementation of stuff in stdlib.h                   */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdlib.h\"\n#include \"signal.h\"\n#include \"string.h\"\n#include \"ctype.h\"\n#include \"stddef.h\"\n\n/* VSE is similar to MVS */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* PDOS and MSDOS use the same interface most of the time */\n#if defined(__PDOS__) && !defined(__MVS__)\n#define __MSDOS__\n#endif\n\n#ifdef __OS2__\n#define INCL_DOSMISC\n#define INCL_DOSPROCESS\n#include <os2.h>\n#endif\n\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#endif\n\n#ifdef __MVS__\nextern int __tso;\n#endif\n\n#if USE_MEMMGR\n#include \"__memmgr.h\"\n/* GCCMVS 3.4.6 requires 49 MB minimum for full optimization */\n/* so we give it 60. GCCMVS 3.2.3 only requires 20 MB */\n/* Note that you can set MAX_CHUNK to less than REQ_CHUNK */\n/* But don't do this until MVS/380 etc have been changed to */\n/* allow multiple memory requests. */\n#if defined(MULMEM)\n#define MAX_CHUNK 60000000\n#define REQ_CHUNK 60000000\n#else\n#define MAX_CHUNK 60000000 /* maximum size we will store in memmgr */\n#define REQ_CHUNK 60000000 /* size that we request from OS */\n#endif\nvoid *__lastsup = NULL; /* last thing supplied to memmgr */\n#endif\n\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nvoid CTYP __allocmem(size_t size, void **ptr);\nvoid CTYP __freemem(void *ptr);\nextern unsigned char *__envptr;\nvoid CTYP __exec(char *cmd, void *env);\n#endif\n\n#ifdef __gnu_linux__\nvoid *__allocmem(size_t size);\n#endif\n\nvoid (*__userExit\u00dd__NATEXIT\u00a8)(void);\n\n__PDPCLIB_API__ void *malloc(size_t size)\n{\n#ifdef __OS2__\n    PVOID BaseAddress;\n    ULONG ulObjectSize;\n    ULONG ulAllocationFlags;\n    APIRET rc;\n\n    ulObjectSize = size + sizeof(size_t);\n    ulAllocationFlags = PAG_COMMIT | PAG_WRITE | PAG_READ;\n    rc = DosAllocMem(&BaseAddress, ulObjectSize, ulAllocationFlags);\n    if (rc != 0) return (NULL);\n    *(size_t *)BaseAddress = size;\n    BaseAddress = (char *)BaseAddress + sizeof(size_t);\n    return ((void *)BaseAddress);\n#endif\n#ifdef __MSDOS__\n    void *ptr;\n\n    __allocmem(size, &ptr);\n    return (ptr);\n#endif\n#if USE_MEMMGR\n    void *ptr;\n\n    if (size > MAX_CHUNK)\n    {\n#if defined(__MVS__) || defined(__CMS__) || defined(__gnu_linux__)\n#if defined(MULMEM)\n        /* If we support multiple memory requests */\n        ptr = __getm(size);\n#else\n        ptr = NULL;\n#endif\n#elif defined(__WIN32__)\n        ptr = GlobalAlloc(0, size + sizeof(size_t));\n        if (ptr != NULL)\n        {\n            *(size_t *)ptr = size;\n            ptr = (char *)ptr + sizeof(size_t);\n        }\n#elif defined(__gnu_linux__)\n        ptr = __allocmem(size + sizeof(size_t));\n        if (ptr != NULL)\n        {\n            *(size_t *)ptr = size;\n            ptr = (char *)ptr + sizeof(size_t);\n        }\n#endif\n    }\n    else\n    {\n        ptr = memmgrAllocate(&__memmgr, size, 0);\n        if (ptr == NULL)\n        {\n            void *ptr2;\n\n#if defined(__MVS__) || defined(__CMS__)\n            /* until MVS/380 is fixed, don't do an additional request,\n               unless MULMEM is defined */\n#if defined(MULMEM)\n            if (1)\n#else\n            if (__memmgr.start == NULL)\n#endif\n            {\n                ptr2 = __getm(REQ_CHUNK);\n            }\n            else\n            {\n                ptr2 = NULL;\n            }\n#elif defined(__WIN32__)\n            ptr2 = GlobalAlloc(0, REQ_CHUNK);\n            if (ptr2 != NULL)\n            {\n                *(size_t *)ptr2 = size;\n                ptr2 = (char *)ptr2 + sizeof(size_t);\n            }\n#elif defined(__gnu_linux__)\n            ptr2 = __allocmem(REQ_CHUNK);\n            if (ptr2 != NULL)\n            {\n                *(size_t *)ptr2 = size;\n                ptr2 = (char *)ptr2 + sizeof(size_t);\n            }\n#endif\n            if (ptr2 == NULL)\n            {\n                return (NULL);\n            }\n            __lastsup = ptr2;\n            memmgrSupply(&__memmgr, ptr2, REQ_CHUNK);\n            ptr = memmgrAllocate(&__memmgr, size, 0);\n        }\n    }\n    return (ptr);\n#else /* not MEMMGR */\n#if defined(__MVS__) || defined(__CMS__)\n    return (__getm(size));\n#elif defined(__WIN32__)\n    void *ptr;\n\n    ptr = GlobalAlloc(0, size + sizeof(size_t));\n    if (ptr != NULL)\n    {\n        *(size_t *)ptr = size;\n        ptr = (char *)ptr + sizeof(size_t);\n    }\n    return (ptr);\n#elif defined(__gnu_linux__)\n    void *ptr;\n\n    ptr = __allocmem(size + sizeof(size_t));\n    if (ptr != NULL)\n    {\n        *(size_t *)ptr = size;\n        ptr = (char *)ptr + sizeof(size_t);\n    }\n    return (ptr);\n#endif\n#endif /* not MEMMGR */\n}\n\n__PDPCLIB_API__ void *calloc(size_t nmemb, size_t size)\n{\n    void *ptr;\n    size_t total;\n\n    if (nmemb == 1)\n    {\n        total = size;\n    }\n    else if (size == 1)\n    {\n        total = nmemb;\n    }\n    else\n    {\n        total = nmemb * size;\n    }\n    ptr = malloc(total);\n    if (ptr != NULL)\n    {\n        memset(ptr, '\\0', total);\n    }\n    return (ptr);\n}\n\n__PDPCLIB_API__ void *realloc(void *ptr, size_t size)\n{\n    char *newptr;\n    size_t oldsize;\n\n    if (size == 0)\n    {\n        free(ptr);\n        return (NULL);\n    }\n#if USE_MEMMGR\n    if (memmgrRealloc(&__memmgr, ptr, size) == 0)\n    {\n        return (ptr);\n    }\n#endif\n    newptr = malloc(size);\n    if (newptr == NULL)\n    {\n        return (NULL);\n    }\n    if (ptr != NULL)\n    {\n        oldsize = *((size_t *)ptr - 1);\n        if (oldsize < size)\n        {\n            size = oldsize;\n        }\n        memcpy(newptr, ptr, size);\n        free(ptr);\n    }\n    return (newptr);\n}\n\n__PDPCLIB_API__ void free(void *ptr)\n{\n#ifdef __OS2__\n    if (ptr != NULL)\n    {\n        ptr = (char *)ptr - sizeof(size_t);\n        DosFreeMem((PVOID)ptr);\n    }\n#endif\n#ifdef __MSDOS__\n    if (ptr != NULL)\n    {\n        __freemem(ptr);\n    }\n#endif\n#if USE_MEMMGR\n    if (ptr != NULL)\n    {\n        size_t size;\n\n        size = *((size_t *)ptr - 1);\n        if (size > MAX_CHUNK)\n        {\n#if defined(__MVS__) || defined(__CMS__)\n#if defined(MULMEM)\n            /* Ignore, unless MULMEM is defined, until MVS/380 is fixed */\n            __freem(ptr);\n#endif\n#elif defined(__WIN32__)\n            GlobalFree(ptr);\n#endif\n        }\n        else\n        {\n            memmgrFree(&__memmgr, ptr);\n        }\n    }\n#else /* not using MEMMGR */\n#if defined(__MVS__) || defined(__CMS__)\n    if (ptr != NULL)\n    {\n        __freem(ptr);\n    }\n#endif\n#ifdef __WIN32__\n    if (ptr != NULL)\n    {\n        GlobalFree(ptr);\n    }\n#endif\n#endif /* not USE_MEMMGR */\n    return;\n}\n\n__PDPCLIB_API__ void abort(void)\n{\n    raise(SIGABRT);\n    exit(EXIT_FAILURE);\n#if !defined(__EMX__) && !defined(__GCC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\n    return;\n#endif\n}\n\n#if !defined(__EMX__) && !defined(__GCC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\nvoid __exit(int status);\n#else\nvoid __exit(int status) __attribute__((noreturn));\n#endif\n\n__PDPCLIB_API__ void exit(int status)\n{\n    __exit(status);\n#if !defined(__EMX__) && !defined(__GCC__) && !defined(__WIN32__) \\\n  && !defined(__gnu_linux__)\n    return;\n#endif\n}\n\n/* This qsort routine was obtained from libnix (also public domain),\n * and then reformatted.\n *\n * This qsort function does a little trick:\n * To reduce stackspace it iterates the larger interval instead of doing\n * the recursion on both intervals.\n * So stackspace is limited to 32*stack_for_1_iteration =\n * 32*4*(4 arguments+1 returnaddress+11 stored registers) = 2048 Bytes,\n * which is small enough for everybodys use.\n * (And this is the worst case if you own 4GB and sort an array of chars.)\n * Sparing the function calling overhead does improve performance, too.\n */\n\n__PDPCLIB_API__ void qsort(void *base,\n           size_t nmemb,\n           size_t size,\n           int (*compar)(const void *, const void *))\n{\n    char *base2 = (char *)base;\n    size_t i,a,b,c;\n\n    while (nmemb > 1)\n    {\n        a = 0;\n        b = nmemb-1;\n        c = (a+b)/2; /* Middle element */\n        for (;;)\n        {\n            while ((*compar)(&base2\u00ddsize*c\u00a8,&base2\u00ddsize*a\u00a8) > 0)\n            {\n                a++; /* Look for one >= middle */\n            }\n            while ((*compar)(&base2\u00ddsize*c\u00a8,&base2\u00ddsize*b\u00a8) < 0)\n            {\n                b--; /* Look for one <= middle */\n            }\n            if (a >= b)\n            {\n                break; /* We found no pair */\n            }\n            for (i=0; i<size; i++) /* swap them */\n            {\n                char tmp=base2\u00ddsize*a+i\u00a8;\n\n                base2\u00ddsize*a+i\u00a8=base2\u00ddsize*b+i\u00a8;\n                base2\u00ddsize*b+i\u00a8=tmp;\n            }\n            if (c == a) /* Keep track of middle element */\n            {\n                c = b;\n            }\n            else if (c == b)\n            {\n                c = a;\n            }\n            a++; /* These two are already sorted */\n            b--;\n        } /* a points to first element of right interval now\n             (b to last of left) */\n        b++;\n        if (b < nmemb-b) /* do recursion on smaller interval and\n                            iteration on larger one */\n        {\n            qsort(base2,b,size,compar);\n            base2=&base2\u00ddsize*b\u00a8;\n            nmemb=nmemb-b;\n        }\n        else\n        {\n            qsort(&base2\u00ddsize*b\u00a8,nmemb-b,size,compar);\n            nmemb=b;\n        }\n    }\n    return;\n}\n\n\nstatic unsigned long myseed = 1;\n\n__PDPCLIB_API__ void srand(unsigned int seed)\n{\n    myseed = seed;\n    return;\n}\n\n__PDPCLIB_API__ int rand(void)\n{\n    int ret;\n\n    myseed = myseed * 1103515245UL + 12345;\n    ret = (int)((myseed >> 16) & 0x8fff);\n    return (ret);\n}\n\n__PDPCLIB_API__ double atof(const char *nptr)\n{\n    return (strtod(nptr, (char **)NULL));\n}\n\n__PDPCLIB_API__ double strtod(const char *nptr, char **endptr)\n{\n    double x = 0.0;\n    double xs= 1.0;\n    double es = 1.0;\n    double xf = 0.0;\n    double xd = 1.0;\n\n    while( isspace( (unsigned char)*nptr ) ) ++nptr;\n    if(*nptr == '-')\n    {\n        xs = -1;\n        nptr++;\n    }\n    else if(*nptr == '+')\n    {\n        nptr++;\n    }\n\n\n    while (1)\n    {\n        if (isdigit((unsigned char)*nptr))\n        {\n            x = x * 10 + (*nptr - '0');\n            nptr++;\n        }\n        else\n        {\n            x = x * xs;\n            break;\n        }\n    }\n    if (*nptr == '.')\n    {\n        nptr++;\n        while (1)\n        {\n            if (isdigit((unsigned char)*nptr))\n            {\n                xf = xf * 10 + (*nptr - '0');\n                xd = xd * 10;\n            }\n            else\n            {\n                x = x + xs * (xf / xd);\n                break;\n            }\n            nptr++;\n        }\n    }\n    if ((*nptr == 'e') || (*nptr == 'E'))\n    {\n        nptr++;\n        if (*nptr == '-')\n        {\n            es = -1;\n            nptr++;\n        }\n        xd = 1;\n        xf = 0;\n        while (1)\n        {\n            if (isdigit((unsigned char)*nptr))\n            {\n                xf = xf * 10 + (*nptr - '0');\n                nptr++;\n            }\n            else\n            {\n                while (xf > 0)\n                {\n                    xd *= 10;\n                    xf--;\n                }\n                if (es < 0.0)\n                {\n                    x = x / xd;\n                }\n                else\n                {\n                    x = x * xd;\n                }\n                break;\n            }\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ int atoi(const char *nptr)\n{\n    return ((int)strtol(nptr, (char **)NULL, 10));\n}\n\n__PDPCLIB_API__ long int atol(const char *nptr)\n{\n    return (strtol(nptr, (char **)NULL, 10));\n}\n\n/* this logic is also in vvscanf - if you update this, update\n   that one too */\n\n__PDPCLIB_API__ unsigned long int strtoul(\n    const char *nptr, char **endptr, int base)\n{\n    unsigned long x = 0;\n    int undecided = 0;\n\n    if (base == 0)\n    {\n        undecided = 1;\n    }\n    while (isspace((unsigned char)*nptr))\n    {\n        nptr++;\n    }\n    while (1)\n    {\n        if (isdigit((unsigned char)*nptr))\n        {\n            if (base == 0)\n            {\n                if (*nptr == '0')\n                {\n                    base = 8;\n                }\n                else\n                {\n                    base = 10;\n                    undecided = 0;\n                }\n            }\n            x = x * base + (*nptr - '0');\n            nptr++;\n        }\n        else if (isalpha((unsigned char)*nptr))\n        {\n            if ((*nptr == 'X') || (*nptr == 'x'))\n            {\n                if ((base == 0) || ((base == 8) && undecided))\n                {\n                    base = 16;\n                    undecided = 0;\n                    nptr++;\n                }\n                else if (base == 16)\n                {\n                    /* hex values are allowed to have an optional 0x */\n                    nptr++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            else if (base <= 10)\n            {\n                break;\n            }\n            else\n            {\n                x = x * base + (toupper((unsigned char)*nptr) - 'A') + 10;\n                nptr++;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n    if (endptr != NULL)\n    {\n        *endptr = (char *)nptr;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ long int strtol(const char *nptr, char **endptr, int base)\n{\n    unsigned long y;\n    long x;\n    int neg = 0;\n\n    while (isspace((unsigned char)*nptr))\n    {\n        nptr++;\n    }\n    if (*nptr == '-')\n    {\n        neg = 1;\n        nptr++;\n    }\n    else if (*nptr == '+')\n    {\n        nptr++;\n    }\n    y = strtoul(nptr, endptr, base);\n    if (neg)\n    {\n        x = (long)-y;\n    }\n    else\n    {\n        x = (long)y;\n    }\n    return (x);\n}\n\n__PDPCLIB_API__ int mblen(const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\n__PDPCLIB_API__ int mbtowc(wchar_t *pwc, const char *s, size_t n)\n{\n    if (s == NULL)\n    {\n        return (0);\n    }\n    if (n == 1)\n    {\n        if (pwc != NULL)\n        {\n            *pwc = *s;\n        }\n        return (1);\n    }\n    else\n    {\n        return (-1);\n    }\n}\n\n__PDPCLIB_API__ int wctomb(char *s, wchar_t wchar)\n{\n    if (s != NULL)\n    {\n        *s = wchar;\n        return (1);\n    }\n    else\n    {\n        return (0);\n    }\n}\n\n__PDPCLIB_API__ size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n)\n{\n    strncpy((char *)pwcs, s, n);\n    if (strlen(s) >= n)\n    {\n        return (n);\n    }\n    return (strlen((char *)pwcs));\n}\n\n__PDPCLIB_API__ size_t wcstombs(char *s, const wchar_t *pwcs, size_t n)\n{\n    strncpy(s, (const char *)pwcs, n);\n    if (strlen((const char *)pwcs) >= n)\n    {\n        return (n);\n    }\n    return (strlen(s));\n}\n\n#ifdef abs\n#undef abs\n#endif\n__PDPCLIB_API__ int abs(int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\n__PDPCLIB_API__ div_t div(int numer, int denom)\n{\n    div_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\n#ifdef labs\n#undef labs\n#endif\n__PDPCLIB_API__ long int labs(long int j)\n{\n    if (j < 0)\n    {\n        j = -j;\n    }\n    return (j);\n}\n\n__PDPCLIB_API__ ldiv_t ldiv(long int numer, long int denom)\n{\n    ldiv_t x;\n\n    x.quot = numer / denom;\n    x.rem = numer % denom;\n    return (x);\n}\n\n__PDPCLIB_API__ int atexit(void (*func)(void))\n{\n    int x;\n\n    for (x = 0; x < __NATEXIT; x++)\n    {\n        if (__userExit\u00ddx\u00a8 == 0)\n        {\n            __userExit\u00ddx\u00a8 = func;\n            return (0);\n        }\n    }\n    return (-1);\n}\n\n__PDPCLIB_API__ char *getenv(const char *name)\n{\n#ifdef __OS2__\n    PSZ result;\n\n    if (DosScanEnv((void *)name, (void *)&result) == 0)\n    {\n        return ((char *)result);\n    }\n#endif\n#if defined(__MSDOS__) || defined(__WIN32__)\n    char *env;\n    size_t lenn;\n\n#ifdef __WIN32__\n    env = GetEnvironmentStrings();\n#else\n    env = (char *)__envptr;\n#endif\n    lenn = strlen(name);\n    while (*env != '\\0')\n    {\n        if (strncmp(env, name, lenn) == 0)\n        {\n            if (env\u00ddlenn\u00a8 == '=')\n            {\n                return (&env\u00ddlenn + 1\u00a8);\n            }\n        }\n        env = env + strlen(env) + 1;\n    }\n#endif\n    return (NULL);\n}\n\n/* The following code was taken from Paul Markham's \"EXEC\" program,\n   and adapted to create a system() function.  The code is all\n   public domain */\n\n__PDPCLIB_API__ int system(const char *string)\n{\n#ifdef __OS2__\n    char err_obj\u00dd100\u00a8;\n    APIRET rc;\n    RESULTCODES results;\n\n    if (string == NULL)\n    {\n        return (1);\n    }\n    rc = DosExecPgm(err_obj, sizeof err_obj, EXEC_SYNC,\n                    (PSZ)string, NULL, &results, (PSZ)string);\n    if (rc != 0)\n    {\n        return (rc);\n    }\n    return ((int)results.codeResult);\n#endif\n#ifdef __WIN32__\n    BOOL rc;\n    PROCESS_INFORMATION pi;\n    STARTUPINFO si;\n    DWORD ExitCode;\n\n    memset(&si, 0, sizeof si);\n    si.cb = sizeof si;\n    memset(&pi, 0, sizeof pi);\n    rc = CreateProcess(NULL,\n                       (char *)string,\n                       NULL,\n                       NULL,\n                       FALSE,\n                       0,\n                       NULL,\n                       NULL,\n                       &si,\n                       &pi);\n    if (!rc)\n    {\n        return (GetLastError());\n    }\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    GetExitCodeProcess(pi.hProcess, &ExitCode);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    return (ExitCode);\n#endif\n#ifdef __MSDOS__\n    static unsigned char cmdt\u00dd140\u00a8;\n    static struct {\n        int env;\n        unsigned char *cmdtail;\n        char *fcb1;\n        char *fcb2;\n    } parmblock = { 0, cmdt, NULL, NULL };\n    size_t len;\n    char *cmd;\n\n    if (string == NULL)\n    {\n        return (1);\n    }\n    len = strlen(string);\n    cmdt\u00dd0\u00a8 = (unsigned char)(len + 3);\n    memcpy(&cmdt\u00dd1\u00a8, \"/c \", 3);\n    memcpy(&cmdt\u00dd4\u00a8, string, len);\n    memcpy(&cmdt\u00ddlen + 4\u00a8, \"\\r\", 2);\n    cmd = getenv(\"COMSPEC\");\n    if (cmd == NULL)\n    {\n        cmd = \"\\\\command.com\";\n    }\n    __exec(cmd, &parmblock);\n    return (0);\n#endif\n#if defined(MUSIC)\n    return (__system(strlen(string), string));\n#elif defined(__MVS__)\n    char pgm\u00dd9\u00a8;\n    size_t pgm_len;\n    size_t cnt;\n    char *p;\n\n    p = strchr(string, ' ');\n    if (p == NULL)\n    {\n        p = strchr(string, '\\0');\n    }\n\n    pgm_len = p - string;\n    /* don't allow a program name greater than 8 */\n\n    if (pgm_len > 8)\n    {\n        return (-1);\n    }\n    memcpy(pgm, string, pgm_len);\n    pgm\u00ddpgm_len\u00a8 = '\\0';\n\n    /* uppercase the program name */\n    for (cnt = 0; cnt < pgm_len; cnt++)\n    {\n        pgm\u00ddcnt\u00a8 = toupper((unsigned char)pgm\u00ddcnt\u00a8);\n    }\n\n    /* point to parms */\n    if (*p != '\\0')\n    {\n        p++;\n    }\n\n    /* all parms now available */\n    /* we use 1 = batch or 2 = tso */\n    return (__system(__tso ? 2: 1, pgm_len, pgm, strlen(p), p));\n#endif\n#if defined(__CMS__)\n    /* not implemented yet */\n    return (0);\n#endif\n}\n\n__PDPCLIB_API__ void *bsearch(const void *key, const void *base,\n              size_t nmemb, size_t size,\n              int (*compar)(const void *, const void *))\n{\n    size_t try;\n    int res;\n    const void *ptr;\n\n    while (nmemb > 0)\n    {\n        try = nmemb / 2;\n        ptr = (void *)((char *)base + try * size);\n        res = compar(ptr, key);\n        if (res == 0)\n        {\n            return ((void *)ptr);\n        }\n        else if (res < 0)\n        {\n            nmemb = nmemb - try - 1;\n            base = (const void *)((const char *)ptr + size);\n        }\n        else\n        {\n            nmemb = try;\n        }\n    }\n    return (NULL);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 5638, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  string.c - implementation of routines in string.h                */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stddef.h\"\n\n#ifdef memmove\n#undef memmove\n#endif\n__PDPCLIB_API__ void *memmove(void *s1, const void *s2, size_t n)\n{\n    char *p = s1;\n    const char *cs2 = s2;\n    size_t x;\n\n    if (p <= cs2)\n    {\n        for (x=0; x < n; x++)\n        {\n            *p = *cs2;\n            p++;\n            cs2++;\n        }\n    }\n    else\n    {\n        if (n != 0)\n        {\n            for (x=n-1; x > 0; x--)\n            {\n                *(p+x) = *(cs2+x);\n            }\n            *(p+x) = *(cs2+x);\n        }\n    }\n    return (s1);\n}\n\n#ifdef strcpy\n#undef strcpy\n#endif\n__PDPCLIB_API__ char *strcpy(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while ((*p++ = *s2++) != '\\0') ;\n    return (s1);\n}\n\n#ifdef strncpy\n#undef strncpy\n#endif\n__PDPCLIB_API__ char *strncpy(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x;\n\n    for (x=0; x < n; x++)\n    {\n        *p = *s2;\n        if (*s2 == '\\0') break;\n        p++;\n        s2++;\n    }\n    for (; x < n; x++)\n    {\n        *p++ = '\\0';\n    }\n    return (s1);\n}\n\n#ifdef strcat\n#undef strcat\n#endif\n__PDPCLIB_API__ char *strcat(char *s1, const char *s2)\n{\n    char *p = s1;\n\n    while (*p != '\\0') p++;\n    while ((*p = *s2) != '\\0')\n    {\n        p++;\n        s2++;\n    }\n    return (s1);\n}\n\n#ifdef strncat\n#undef strncat\n#endif\n__PDPCLIB_API__ char *strncat(char *s1, const char *s2, size_t n)\n{\n    char *p = s1;\n    size_t x = 0;\n\n    while (*p != '\\0') p++;\n    while ((*s2 != '\\0') && (x < n))\n    {\n        *p = *s2;\n        p++;\n        s2++;\n        x++;\n    }\n    *p = '\\0';\n    return (s1);\n}\n\n#ifdef memcmp\n#undef memcmp\n#endif\n__PDPCLIB_API__ int memcmp(const void *s1, const void *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1\u00ddx\u00a8 < p2\u00ddx\u00a8) return (-1);\n        else if (p1\u00ddx\u00a8 > p2\u00ddx\u00a8) return (1);\n        x++;\n    }\n    return (0);\n}\n\n#ifdef strcmp\n#undef strcmp\n#endif\n__PDPCLIB_API__ int strcmp(const char *s1, const char *s2)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (*p1 != '\\0')\n    {\n        if (*p1 < *p2) return (-1);\n        else if (*p1 > *p2) return (1);\n        p1++;\n        p2++;\n    }\n    if (*p2 == '\\0') return (0);\n    else return (-1);\n}\n\n#ifdef strcoll\n#undef strcoll\n#endif\n__PDPCLIB_API__ int strcoll(const char *s1, const char *s2)\n{\n    return (strcmp(s1, s2));\n}\n\n#ifdef strncmp\n#undef strncmp\n#endif\n__PDPCLIB_API__ int strncmp(const char *s1, const char *s2, size_t n)\n{\n    const unsigned char *p1;\n    const unsigned char *p2;\n    size_t x = 0;\n\n    p1 = (const unsigned char *)s1;\n    p2 = (const unsigned char *)s2;\n    while (x < n)\n    {\n        if (p1\u00ddx\u00a8 < p2\u00ddx\u00a8) return (-1);\n        else if (p1\u00ddx\u00a8 > p2\u00ddx\u00a8) return (1);\n        else if (p1\u00ddx\u00a8 == '\\0') return (0);\n        x++;\n    }\n    return (0);\n}\n\n#ifdef strxfrm\n#undef strxfrm\n#endif\n__PDPCLIB_API__ size_t strxfrm(char *s1, const char *s2, size_t n)\n{\n    size_t oldlen;\n\n    oldlen = strlen(s2);\n    if (oldlen < n)\n    {\n        memcpy(s1, s2, oldlen);\n        s1\u00ddoldlen\u00a8 = '\\0';\n    }\n    return (oldlen);\n}\n\n#ifdef memchr\n#undef memchr\n#endif\n__PDPCLIB_API__ void *memchr(const void *s, int c, size_t n)\n{\n    const unsigned char *p;\n    size_t x = 0;\n\n    p = (const unsigned char *)s;\n    while (x < n)\n    {\n        if (*p == (unsigned char)c) return ((void *)p);\n        p++;\n        x++;\n    }\n    return (NULL);\n}\n\n#ifdef strchr\n#undef strchr\n#endif\n__PDPCLIB_API__ char *strchr(const char *s, int c)\n{\n    while (*s != '\\0')\n    {\n        if (*s == (char)c) return ((char *)s);\n        s++;\n    }\n    if (c == '\\0') return ((char *)s);\n    return (NULL);\n}\n\n#ifdef strcspn\n#undef strcspn\n#endif\n__PDPCLIB_API__ size_t strcspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((size_t)(p1 - s1));\n            p2++;\n        }\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\n#ifdef strpbrk\n#undef strpbrk\n#endif\n__PDPCLIB_API__ char *strpbrk(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) return ((char *)p1);\n            p2++;\n        }\n        p1++;\n    }\n    return (NULL);\n}\n\n#ifdef strrchr\n#undef strrchr\n#endif\n__PDPCLIB_API__ char *strrchr(const char *s, int c)\n{\n    const char *p;\n\n    p = s + strlen(s);\n    while (p >= s)\n    {\n        if (*p == (char)c) return ((char *)p);\n        p--;\n    }\n    return (NULL);\n}\n\n#ifdef strspn\n#undef strspn\n#endif\n__PDPCLIB_API__ size_t strspn(const char *s1, const char *s2)\n{\n    const char *p1;\n    const char *p2;\n\n    p1 = s1;\n    while (*p1 != '\\0')\n    {\n        p2 = s2;\n        while (*p2 != '\\0')\n        {\n            if (*p1 == *p2) break;\n            p2++;\n        }\n        if (*p2 == '\\0') return ((size_t)(p1 - s1));\n        p1++;\n    }\n    return ((size_t)(p1 - s1));\n}\n\n\n/* strstr by Frank Adam */\n/* modified by Paul Edwards */\n\n#ifdef strstr\n#undef strstr\n#endif\n__PDPCLIB_API__ char *strstr(const char *s1, const char *s2)\n{\n    const char *p = s1, *p1, *p2 = s2;\n\n    while (*p)\n    {\n        if (*p == *s2)\n        {\n            p1 = p;\n            p2 = s2;\n            while ((*p2 != '\\0') && (*p1 == *p2))\n            {\n                p1++;\n                p2++;\n            }\n            if (*p2 == '\\0')\n            {\n                return (char *)p;\n            }\n        }\n        p++;\n    }\n    return NULL;\n}\n\n#ifdef strtok\n#undef strtok\n#endif\n__PDPCLIB_API__ char *strtok(char *s1, const char *s2)\n{\n    static char *old = NULL;\n    char *p;\n    size_t len;\n    size_t remain;\n\n    if (s1 != NULL) old = s1;\n    if (old == NULL) return (NULL);\n    p = old;\n    len = strspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (NULL); }\n    p += len;\n    len = strcspn(p, s2);\n    remain = strlen(p);\n    if (remain <= len) { old = NULL; return (p); }\n    *(p + len) = '\\0';\n    old = p + len + 1;\n    return (p);\n}\n\n#ifdef memset\n#undef memset\n#endif\n__PDPCLIB_API__ void *memset(void *s, int c, size_t n)\n{\n    size_t x = 0;\n\n    for (x = 0; x < n; x++)\n    {\n        *((char *)s + x) = (unsigned char)c;\n    }\n    return (s);\n}\n\n#ifdef strerror\n#undef strerror\n#endif\n__PDPCLIB_API__ char *strerror(int errnum)\n{\n    if (errnum == 0) return (\"No error has occurred\\n\");\n    else return (\"An error has occurred\\n\");\n}\n\n#ifdef strlen\n#undef strlen\n#endif\n__PDPCLIB_API__ size_t strlen(const char *s)\n{\n    const char *p;\n\n    p = s;\n    while (*p != '\\0') p++;\n    return ((size_t)(p - s));\n}\n\n#ifndef USE_ASSEMBLER\n#ifdef memcpy\n#undef memcpy\n#endif\n#ifndef __32BIT__\n__PDPCLIB_API__ void *memcpy(void *s1, const void *s2, size_t n)\n{\n    register const unsigned char *f = s2;\n    register const unsigned char *fe;\n    register unsigned char *t = s1;\n\n    fe = f + n;\n    while (f != fe)\n    {\n        *t++ = *f++;\n    }\n    return (s1);\n}\n#else\n__PDPCLIB_API__ void *memcpy(void *s1, const void *s2, size_t n)\n{\n    register unsigned int *p = (unsigned int *)s1;\n    register unsigned int *cs2 = (unsigned int *)s2;\n    register unsigned int *endi;\n\n    endi = (unsigned int *)((char *)p + (n & ~0x03));\n    while (p != endi)\n    {\n        *p++ = *cs2++;\n    }\n    switch (n & 0x03)\n    {\n        case 0:\n            break;\n        case 1:\n            *(char *)p = *(char *)cs2;\n            break;\n        case 2:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n        case 3:\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            p = (unsigned int *)((char *)p + 1);\n            cs2 = (unsigned int *)((char *)cs2 + 1);\n            *(char *)p = *(char *)cs2;\n            break;\n    }\n    return (s1);\n}\n#endif /* 32BIT */\n#endif /* USE_ASSEMBLER */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRINGA": {"ttr": 9480, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; stringa.asm - string assembler functions\n;\n; This program written by Paul Edwards, kerravon@w3.to\n; Released to the public domain\n;\n; Mods by Rowan Crowe\n\n.386p\n\n.model flat\n\n_DATA   segment dword public use32 'DATA'\n_DATA   ends\n_BSS    segment dword public use32 'BSS'\n_BSS    ends\n\nDGROUP  group   _DATA,_BSS\n    assume cs:_TEXT,ds:DGROUP\n\n_TEXT segment 'CODE'\n\npublic memcpy\nmemcpy proc\npush ebp\nmov ebp, esp\npushf\npush edi\npush esi\npush ecx\nmov edi, \u00ddebp+8\u00a8\nmov eax, edi    ; used for return value\nmov esi, \u00ddebp+12\u00a8\nmov ecx, \u00ddebp+16\u00a8\ncld\nshr ecx, 2\nrep movsd\nmov cl, byte ptr \u00ddebp+16\u00a8 ; ECX = 0 so we can safely manipulate\nand cl, 3                 ; the bottom byte only\nrep movsb\npop ecx\npop esi\npop edi\npopf\npop ebp\nret\nmemcpy endp\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIME": {"ttr": 5893, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  time.c - implementation of stuff in time.h                       */\n/*                                                                   */\n/*********************************************************************/\n\n#include \"time.h\"\n#include \"stdarg.h\"\n#include \"stdio.h\"\n#include \"stddef.h\"\n\n/* just get VSE to use MVS for now */\n#if defined(__VSE__)\n#define __MVS__ 1\n#endif\n\n/* pdos and msdos use the same interface most of the time) */\n#if defined(__PDOS__) && !defined(__MVS__)\n#define __MSDOS__\n#endif\n\n#if defined(__MVS__) || defined(__CMS__)\n#include \"mvssupa.h\"\n#endif\n#ifdef __OS2__\n#include <os2.h>\n#endif\n#ifdef __WIN32__\n#include <windows.h>\n#endif\n#ifdef __MSDOS__\n#ifdef __WATCOMC__\n#define CTYP __cdecl\n#else\n#define CTYP\n#endif\nvoid CTYP __datetime(void *ptr);\n#endif\n\n#ifdef __gnu_linux__\nunsigned long __time(unsigned long *);\n#endif\n\n/* scalar date routines    --    public domain by Ray Gardner\n** These will work over the range 1-01-01 thru 14699-12-31\n** The functions written by Ray are isleap, months_to_days,\n** years_to_days, ymd_to_scalar, scalar_to_ymd.\n** modified slightly by Paul Edwards\n*/\n\nstatic int isleap(unsigned yr)\n{\n   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);\n}\n\nstatic unsigned months_to_days(unsigned month)\n{\n   return (month * 3057 - 3007) / 100;\n}\n\nstatic long years_to_days (unsigned yr)\n{\n   return yr * 365L + yr / 4 - yr / 100 + yr / 400;\n}\n\nstatic long ymd_to_scalar(unsigned yr, unsigned mo, unsigned day)\n{\n   long scalar;\n\n   scalar = day + months_to_days(mo);\n   if ( mo > 2 )                         /* adjust if past February */\n      scalar -= isleap(yr) ? 1 : 2;\n   yr--;\n   scalar += years_to_days(yr);\n   return (scalar);\n}\n\nstatic void scalar_to_ymd(long scalar,\n                          unsigned *pyr,\n                          unsigned *pmo,\n                          unsigned *pday)\n{\n   unsigned n;                /* compute inverse of years_to_days() */\n\n   n = (unsigned)((scalar * 400L) / 146097L);\n   while (years_to_days(n) < scalar)\n   {\n      n++;\n   }\n   for ( n = (unsigned)((scalar * 400L) / 146097L); years_to_days(n) < scalar; )\n      n++;                          /* 146097 == years_to_days(400) */\n   *pyr = n;\n   n = (unsigned)(scalar - years_to_days(n-1));\n   if ( n > 59 ) {                       /* adjust if past February */\n      n += 2;\n      if ( isleap(*pyr) )\n         n -= n > 62 ? 1 : 2;\n   }\n   *pmo = (n * 100 + 3007) / 3057;  /* inverse of months_to_days() */\n   *pday = n - months_to_days(*pmo);\n   return;\n}\n\n__PDPCLIB_API__ time_t time(time_t *timer)\n{\n    time_t tt;\n#ifdef __OS2__\n    DATETIME dt;\n    APIRET rc;\n#endif\n#ifdef __WIN32__\n    SYSTEMTIME dt;\n#endif\n#if defined(__MSDOS__)\n    struct {\n        int year;\n        int month;\n        int day;\n        int hours;\n        int minutes;\n        int seconds;\n        int hundredths;\n    } dt;\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    unsigned int clk\u00dd2\u00a8;\n#endif\n\n#ifdef __OS2__\n    rc = DosGetDateTime(&dt);\n    if (rc != 0)\n    {\n        tt = (time_t)-1;\n    }\n    else\n#endif\n#ifdef __WIN32__\n    GetSystemTime(&dt);\n    tt = ymd_to_scalar(dt.wYear, dt.wMonth, dt.wDay)\n         - ymd_to_scalar(1970, 1, 1);\n    tt = tt * 24 + dt.wHour;\n    tt = tt * 60 + dt.wMinute;\n    tt = tt * 60 + dt.wSecond;\n#endif\n#if defined(__MSDOS__)\n    __datetime(&dt);\n#endif\n#if defined(__MVS__) || defined(__CMS__)\n    tt = __getclk(clk);\n#elif defined(__gnu_linux__)\n    tt = __time(NULL);\n#elif !defined(__WIN32__)\n\n    {\n        tt = ymd_to_scalar(dt.year, dt.month, dt.day)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + dt.hours;\n        tt = tt * 60 + dt.minutes;\n        tt = tt * 60 + dt.seconds;\n    }\n#endif\n    if (timer != NULL)\n    {\n        *timer = tt;\n    }\n    return (tt);\n}\n\n__PDPCLIB_API__ clock_t clock(void)\n{\n    return ((clock_t)-1);\n}\n\n__PDPCLIB_API__ double difftime(time_t time1, time_t time0)\n{\n    return ((double)(time1 - time0));\n}\n\n__PDPCLIB_API__ time_t mktime(struct tm *timeptr)\n{\n    time_t tt;\n\n    if ((timeptr->tm_year < 70) || (timeptr->tm_year > 120))\n    {\n        tt = (time_t)-1;\n    }\n    else\n    {\n        tt = ymd_to_scalar(timeptr->tm_year + 1900,\n                           timeptr->tm_mon + 1,\n                           timeptr->tm_mday)\n             - ymd_to_scalar(1970, 1, 1);\n        tt = tt * 24 + timeptr->tm_hour;\n        tt = tt * 60 + timeptr->tm_min;\n        tt = tt * 60 + timeptr->tm_sec;\n    }\n    *timeptr = *gmtime(&tt);\n    return (tt);\n}\n\n__PDPCLIB_API__ char *asctime(const struct tm *timeptr)\n{\n    static const char wday_name\u00dd7\u00a8\u00dd3\u00a8 = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n    };\n    static const char mon_name\u00dd12\u00a8\u00dd3\u00a8 = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n          \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n    };\n    static char result\u00dd26\u00a8;\n\n    sprintf(result, \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n          wday_name\u00ddtimeptr->tm_wday\u00a8,\n          mon_name\u00ddtimeptr->tm_mon\u00a8,\n          timeptr->tm_mday, timeptr->tm_hour,\n          timeptr->tm_min, timeptr->tm_sec,\n          1900 + timeptr->tm_year);\n    return result;\n}\n\n__PDPCLIB_API__ char *ctime(const time_t *timer)\n{\n    return (asctime(localtime(timer)));\n}\n\n__PDPCLIB_API__ struct tm *localtime(const time_t *timer)\n{\n#ifdef __MVS__\n    time_t t;\n    int o;\n    int r;\n\n    t = *timer;\n    o = __gettz(); /* this function returns the local timezone\n                      offset in 1.048576 second increments. The\n                      maximum offset people have managed to define\n                      is 14 hours (Kirribati) and when mulplied\n                      by 16384, this doesn't exceed a 32-bit\n                      signed integer, so we're safe.\n\n                      Note that we have to take care of rounding\n                      on top of that too though. */\n    o = o * 16384;\n    r = o % 15625;\n    o /= 15625;\n    if ((o > 0) && (r > 7812))\n    {\n        o++;\n    }\n    else if ((o < 0) && (r < -7812))\n    {\n        o--;\n    }\n    t += o;\n    return (gmtime(&t));\n#else\n    return (gmtime(timer));\n#endif\n}\n\n/* dow - written by Paul Edwards, 1993-01-31 */\n/* Released to the Public Domain */\n/* This routine will work over the range 1-01-01 to 32767-12-31.\n   It assumes the current calendar system has always been in\n   place in that time.  If you pass 0 or negative years, then\n   it produces results on the assumption that there is a year\n   0.  It should always produce a value in the range of 0..6\n   if a valid month and day have been passed, no matter what\n   the year is.  However, it has not been tested for negative\n   years, because the results are meaningless anyway.  It is\n   mainly to stop people playing silly buggers and causing\n   the macro to crash on negative years. */\n\n#define dow(y,m,d) \\\n  ((((((m)+9)%12+1)<<4)%27 + (d) + 1 + \\\n  ((y)%400+400) + ((y)%400+400)/4 - ((y)%400+400)/100 + \\\n  (((m)<=2) ? ( \\\n  (((((y)%4)==0) && (((y)%100)!=0)) || (((y)%400)==0)) \\\n  ? 5 : 6) : 0)) % 7)\n\nstatic struct tm tms;\n\n__PDPCLIB_API__ struct tm *gmtime(const time_t *timer)\n{\n    unsigned yr, mo, da;\n    unsigned long secs;\n    unsigned long days;\n\n    days = *timer / (60L*60*24);\n    secs = *timer % (60L*60*24);\n    scalar_to_ymd(days + ymd_to_scalar(1970, 1, 1), &yr, &mo, &da);\n    tms.tm_year = yr - 1900;\n    tms.tm_mon = mo - 1;\n    tms.tm_mday = da;\n    tms.tm_yday = (int)(ymd_to_scalar(tms.tm_year + 1900, mo, da)\n                  - ymd_to_scalar(tms.tm_year + 1900, 1, 1));\n    tms.tm_wday = dow(tms.tm_year + 1900, mo, da);\n    tms.tm_isdst = -1;\n    tms.tm_sec = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_min = (int)(secs % 60);\n    secs /= 60;\n    tms.tm_hour = (int)secs;\n    return (&tms);\n}\n\n/*\n * strftime.c\n *\n * implements the iso c function strftime()\n *\n * written 1989-09-06 by jim nutt\n * released into the public domain by jim nutt\n *\n * modified 1989-10-21 by Rob Duff\n *\n * modified 1994-08-26 by Paul Edwards\n */\n\nstatic char *aday\u00dd\u00a8 = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n};\n\nstatic char *day\u00dd\u00a8 = {\n    \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n    \"Thursday\", \"Friday\", \"Saturday\"\n};\n\nstatic char *amonth\u00dd\u00a8 = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic char *month\u00dd\u00a8 = {\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\n\nstatic char *__tzname\u00dd2\u00a8 = { \"\" \"\" };\nstatic char buf\u00dd26\u00a8;\n\nstatic void strfmt(char *str, const char *fmt, ...);\n\n/**\n *\n * size_t strftime(char *str,\n *                 size_t maxs,\n *                 const char *fmt,\n *                 const struct tm *t)\n *\n *      this functions acts much like a sprintf for time/date output.\n *      given a pointer to an output buffer, a format string and a\n *      time, it copies the time to the output buffer formatted in\n *      accordance with the format string.  the parameters are used\n *      as follows:\n *\n *          str is a pointer to the output buffer, there should\n *          be at least maxs characters available at the address\n *          pointed to by str.\n *\n *          maxs is the maximum number of characters to be copied\n *          into the output buffer, included the '\\0' terminator\n *\n *          fmt is the format string.  a percent sign (%) is used\n *          to indicate that the following character is a special\n *          format character.  the following are valid format\n *          characters:\n *\n *              %A      full weekday name (Monday)\n *              %a      abbreviated weekday name (Mon)\n *              %B      full month name (January)\n *              %b      abbreviated month name (Jan)\n *              %c      standard date and time representation\n *              %d      day-of-month (01-31)\n *              %H      hour (24 hour clock) (00-23)\n *              %I      hour (12 hour clock) (01-12)\n *              %j      day-of-year (001-366)\n *              %M      minute (00-59)\n *              %m      month (01-12)\n *              %p      local equivalent of AM or PM\n *              %S      second (00-59)\n *              %U      week-of-year, first day sunday (00-53)\n *              %W      week-of-year, first day monday (00-53)\n *              %w      weekday (0-6, sunday is 0)\n *              %X      standard time representation\n *              %x      standard date representation\n *              %Y      year with century\n *              %y      year without century (00-99)\n *              %Z      timezone name\n *              %%      percent sign\n *\n *      the standard date string is equivalent to:\n *\n *          %a %b %d %Y\n *\n *      the standard time string is equivalent to:\n *\n *          %H:%M:%S\n *\n *      the standard date and time string is equivalent to:\n *\n *          %a %b %d %H:%M:%S %Y\n *\n *      strftime returns the number of characters placed in the\n *      buffer, not including the terminating \\0, or zero if more\n *      than maxs characters were produced.\n *\n**/\n\n__PDPCLIB_API__ size_t strftime(char *s,\n                                size_t maxs,\n                                const char *f,\n                                const struct tm *t)\n{\n      int w;\n      char *p, *q, *r;\n\n      p = s;\n      q = s + maxs - 1;\n      while ((*f != '\\0'))\n      {\n            if (*f++ == '%')\n            {\n                  r = buf;\n                  switch (*f++)\n                  {\n                  case '%' :\n                        r = \"%\";\n                        break;\n\n                  case 'a' :\n                        r = aday\u00ddt->tm_wday\u00a8;\n                        break;\n\n                  case 'A' :\n                        r = day\u00ddt->tm_wday\u00a8;\n                        break;\n\n                  case 'b' :\n                        r = amonth\u00ddt->tm_mon\u00a8;\n                        break;\n\n                  case 'B' :\n                        r = month\u00ddt->tm_mon\u00a8;\n                        break;\n\n                  case 'c' :\n                        strfmt(r, \"%0 %0 %2 %2:%2:%2 %4\",\n                              aday\u00ddt->tm_wday\u00a8, amonth\u00ddt->tm_mon\u00a8,\n                              t->tm_mday,t->tm_hour, t->tm_min,\n                              t->tm_sec, t->tm_year+1900);\n                        break;\n\n                  case 'd' :\n                        strfmt(r,\"%2\",t->tm_mday);\n                        break;\n\n                  case 'H' :\n                        strfmt(r,\"%2\",t->tm_hour);\n                        break;\n\n                  case 'I' :\n                        strfmt(r,\"%2\",(t->tm_hour%12)?t->tm_hour%12:12);\n                        break;\n\n                  case 'j' :\n                        strfmt(r,\"%3\",t->tm_yday+1);\n                        break;\n\n                  case 'm' :\n                        strfmt(r,\"%2\",t->tm_mon+1);\n                        break;\n\n                  case 'M' :\n                        strfmt(r,\"%2\",t->tm_min);\n                        break;\n\n                  case 'p' :\n                        r = (t->tm_hour>11)?\"PM\":\"AM\";\n                        break;\n\n                  case 'S' :\n                        strfmt(r,\"%2\",t->tm_sec);\n                        break;\n\n                  case 'U' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > t->tm_wday)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'W' :\n                        w = t->tm_yday/7;\n                        if (t->tm_yday%7 > (t->tm_wday+6)%7)\n                              w++;\n                        strfmt(r, \"%2\", w);\n                        break;\n\n                  case 'w' :\n                        strfmt(r,\"%1\",t->tm_wday);\n                        break;\n\n                  case 'x' :\n                        strfmt(r, \"%3s %3s %2 %4\", aday\u00ddt->tm_wday\u00a8,\n                              amonth\u00ddt->tm_mon\u00a8, t->tm_mday, t->tm_year+1900);\n                        break;\n\n                  case 'X' :\n                        strfmt(r, \"%2:%2:%2\", t->tm_hour,\n                              t->tm_min, t->tm_sec);\n                        break;\n\n                  case 'y' :\n                        strfmt(r,\"%2\",t->tm_year%100);\n                        break;\n\n                  case 'Y' :\n                        strfmt(r,\"%4\",t->tm_year+1900);\n                        break;\n\n                  case 'Z' :\n                        r = (t->tm_isdst) ? __tzname\u00dd1\u00a8 : __tzname\u00dd0\u00a8;\n                        break;\n\n                  default:\n                        buf\u00dd0\u00a8 = '%';     /* reconstruct the format */\n                        buf\u00dd1\u00a8 = f\u00dd-1\u00a8;\n                        buf\u00dd2\u00a8 = '\\0';\n                        if (buf\u00dd1\u00a8 == 0)\n                              f--;        /* back up if at end of string */\n                  }\n                  while (*r)\n                  {\n                        if (p == q)\n                        {\n                              *q = '\\0';\n                              return 0;\n                        }\n                        *p++ = *r++;\n                  }\n            }\n            else\n            {\n                  if (p == q)\n                  {\n                        *q = '\\0';\n                        return 0;\n                  }\n                  *p++ = f\u00dd-1\u00a8;\n            }\n      }\n      *p = '\\0';\n      return (size_t)(p - s);\n}\n\nstatic int pow\u00dd5\u00a8 = { 1, 10, 100, 1000, 10000 };\n\n/**\n * static void strfmt(char *str, char *fmt);\n *\n * simple sprintf for strftime\n *\n * each format descriptor is of the form %n\n * where n goes from zero to four\n *\n * 0    -- string %s\n * 1..4 -- int %?.?d\n *\n**/\n\nstatic void strfmt(char *str, const char *fmt, ...)\n{\n      int ival, ilen;\n      char *sval;\n      va_list vp;\n\n      va_start(vp, fmt);\n      while (*fmt)\n      {\n            if (*fmt++ == '%')\n            {\n                  ilen = *fmt++ - '0';\n                  if (ilen == 0)                /* zero means string arg */\n                  {\n                        sval = va_arg(vp, char*);\n                        while (*sval)\n                              *str++ = *sval++;\n                  }\n                  else                          /* always leading zeros */\n                  {\n                        ival = va_arg(vp, int);\n                        while (ilen)\n                        {\n                              ival %= pow\u00ddilen--\u00a8;\n                              *str++ = (char)('0' + ival / pow\u00ddilen\u00a8);\n                        }\n                  }\n            }\n            else  *str++ = fmt\u00dd-1\u00a8;\n      }\n      *str = '\\0';\n      va_end(vp);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSEMANIP": {"ttr": 6148, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  vsemanip - manipulate VSE files                                  */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd1000\u00a8;\n\nint main(int argc, char **argv)\n{\n    FILE *fp;\n    FILE *fq;\n    int arg_upto = 1;\n    int inlen = 81;\n    int outlen = 80;\n\n    if (argc <= 2)\n    {\n        printf(\"usage: vsemanip <in file> <out file>\\n\");\n        printf(\"by default it will trim 81-character files down to\\n\");\n        printf(\"80 by stripping a leading control character\\n\");\n        printf(\"use -i121 to override input length\\n\");\n        printf(\"e.g. vsemanip -i121 dd:sdi1 dd:sdo1\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (strncmp(argv\u00ddarg_upto\u00a8, \"-i\", 2) == 0)\n    {\n        inlen = atoi(&argv\u00ddarg_upto\u00a8\u00dd2\u00a8);\n        arg_upto++;\n    }\n\n    if ((inlen <= 0) || (inlen > sizeof buf))\n    {\n        printf(\"invalid length string %s\\n\", argv\u00ddarg_upto - 1\u00a8);\n        return (EXIT_FAILURE);\n    }\n\n    fp = fopen(*(argv + arg_upto), \"rb\");\n    if (fp == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + arg_upto));\n        return (EXIT_FAILURE);\n    }\n    arg_upto++;\n\n    fq = fopen(*(argv + arg_upto), \"wb\");\n    if (fq == NULL)\n    {\n        printf(\"can't open %s\\n\", *(argv + arg_upto));\n        return (EXIT_FAILURE);\n    }\n    arg_upto++;\n\n    while (fread(buf, inlen, 1, fp) == 1)\n    {\n        fwrite(buf + 1, outlen, 1, fq);\n    }\n\n    fclose(fq);\n    fclose(fp);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VSEPROC": {"ttr": 6150, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  vseproc - generate a compilation proc for VSE                    */\n/*                                                                   */\n/*********************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic char buf\u00dd10000\u00a8;\n\nint main(int argc, char **argv)\n{\n    size_t len;\n    FILE *fp;\n    FILE *fq;\n    char *jcl_start;\n    char *jcl_end;\n    char *fn_start;\n    char *fn_end;\n    char *p;\n    char *q;\n\n    if (argc <= 2)\n    {\n        printf(\"usage: vseproc <in file> <out file>\\n\");\n        printf(\"e.g. vseproc - dd:syspunch\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (strcmp(*(argv + 1), \"-\") == 0)\n    {\n        fp = stdin;\n    }\n    else\n    {\n        fp = fopen(*(argv + 1), \"r\");\n        if (fp == NULL)\n        {\n            printf(\"can't open %s\\n\", *(argv + 1));\n            return (EXIT_FAILURE);\n        }\n    }\n\n    if (strcmp(*(argv + 2), \"-\") == 0)\n    {\n        fq = stdout;\n    }\n    else\n    {\n        fq = fopen(*(argv + 2), \"w\");\n        if (fq == NULL)\n        {\n            printf(\"can't open %s\\n\", *(argv + 2));\n            return (EXIT_FAILURE);\n        }\n    }\n\n    len = fread(buf, 1, sizeof buf - 1, fp);\n    buf\u00ddlen\u00a8 = '\\0';\n    p = strchr(buf, '\\n');\n    if (p != NULL)\n    {\n        fn_start = p + 1;\n        p = strstr(fn_start, \"\\n-\");\n    }\n    if (p != NULL)\n    {\n        fn_end = p + 1;\n        p = strchr(fn_end, '\\n');\n    }\n    if (p != NULL)\n    {\n        jcl_start = p + 1;\n        p = strstr(jcl_start, \"\\n-----\");\n    }\n    if (p != NULL)\n    {\n        jcl_end = p + 1;\n        *jcl_end = '\\0';\n    }\n    if (p != NULL)\n    {\n        fprintf(fq, \" CATALP VSEPROC\\n\");\n        p = fn_start;\n        while (p != fn_end)\n        {\n            q = strchr(p, '\\n');\n            *q = '\\0';\n            fprintf(fq, jcl_start, p, p, p, p, p, p, p, p, p, p,\n                    p, p, p, p, p, p, p, p, p, p, p, p, p, p, p);\n            p = q + 1;\n        }\n        fprintf(fq, \"/+\\n\");\n    }\n    fclose(fq);\n    return (0);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "VSESTART": {"ttr": 9482, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "**********************************************************************\n*                                                                    *\n*  THIS PROGRAM WRITTEN BY PAUL EDWARDS.                             *\n*  RELEASED TO THE PUBLIC DOMAIN                                     *\n*                                                                    *\n**********************************************************************\n**********************************************************************\n*                                                                    *\n*  VSESTART - STARTUP ROUTINES FOR VSE FOR USE WITH GCC.             *\n*                                                                    *\n*  This code is able to handle z/VSE-style parameters. It saves the  *\n*  UPSI as well for later use by the C code.  The stack is allocated *\n*  here, below the line                                              *\n*                                                                    *\n**********************************************************************\n         COPY  PDPTOP\n         PRINT GEN\n* REGEQU IS NOT AVAILABLE ON DOS/VS\n*         YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSUBPOOL  EQU   0\n         CSECT\n*\n* Put an eyecatcher here to ensure program has been linked\n* correctly.\n         DC    C'PDPCLIB!'\n         ENTRY @@CRT0\n@@CRT0   EQU   *\n*         ENTRY CEESTART\n*CEESTART EQU   *\n*\n* DOS/VS doesn't require or allow saving of registers\n*         SAVE  (14,12),,@@CRT0\n*\n         BALR  R10,R0\n         LA    R10,0(R10)        clean address\n         BCTR  R10,0\n         BCTR  R10,0\n         USING @@CRT0,R10\n*\n         LR    R8,R15            save R15 so that we can get the PARM\n         LR    R11,R1            save R1 so we can get the PARM\n         GETVIS LENGTH=STACKLEN\n         LTR   R15,R15\n         BNZ   NOMEM\n         ST    R13,4(R1)\n         LR    R13,R1\n         USING STACK,R13\n*\n         LA    R2,0\n         ST    R2,DUMMYPTR       WHO KNOWS WHAT THIS IS USED FOR\n         LA    R2,MAINSTK\n         ST    R2,THEIRSTK       NEXT AVAILABLE SPOT IN STACK\n         LA    R12,ANCHOR\n         ST    R14,EXITADDR\n         L     R3,=A(MAINLEN)\n         AR    R2,R3\n         ST    R2,12(R12)        TOP OF STACK POINTER\n         LA    R2,0\n         ST    R2,116(R12)       ADDR OF MEMORY ALLOCATION ROUTINE\n*\n* Now let's get the parameter list\n*\n         COMRG                   get address of common region in R1\n         LR    R5,R1             use R5 to map common region\n         USING COMREG,R5         address common region\n         L     R2,SYSPAR         get access to SYSPARM\n         LA    R2,0(R2)          clean the address, just in case\n         ST    R2,ARGPTR         store SYSPARM\n         MVC   XUPSI,UPSI        move the UPSI switches in\n         LA    R2,0              default no VSE-style PARM\n         CR    R11,R8            compare original R15 and original R1\n         BE    CONTPARM          no difference = no VSE-style PARM\n         LR    R2,R11            R11 has PARM, now R2 does too\n* Note - do not clean the PARM, as we need access to the top bit\nCONTPARM DS    0H\n         ST    R2,ARGPTRE        store VSE-style PARM\n         L     R2,JAPART         address of job accounting table\n         USING ACCTABLE,R2       address accounting table\n         MVC   PGMNAME,ACCTEXEC  move program name into our own area\n         DROP  R5                no longer need common region\n         LA    R2,PGMNAME        address our program name\n         ST    R2,PGMNPTR        store program name\n         DROP  R2                no longer need accounting table\n*\n* Set R4 to true if we were called in 31-bit mode\n*\n         LA    R4,0\n         AIF   ('&SYS' EQ 'S370').NOBSM\n         BSM   R4,R0\n.NOBSM   ANOP\n         ST    R4,SAVER4\n*\n* FOR GCC WE NEED TO BE ABLE TO RESTORE R13\n         LA    R5,SAVEAREA\n         ST    R5,SAVER13\n*\n         LA    R1,PARMLIST\n*\n         AIF   ('&SYS' NE 'S380').N380ST1\n* If we were called in AMODE 31, don't bother setting mode now\n         LTR   R4,R4\n         BNZ   IN31\n         CALL  @@SETM31\nIN31     DS    0H\n.N380ST1 ANOP\n*\n         CALL  @@START\n         LR    R9,R15\n*\n         AIF   ('&SYS' NE 'S380').N380ST2\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31B\n         CALL  @@SETM24\nIN31B    DS    0H\n.N380ST2 ANOP\n*\nRETURNMS DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R14,R9\n         FREEVIS LENGTH=STACKLEN\n         LR    R15,R14\n         EOJ\nNOMEM    DS    0H\n         EXCP  CCB\n         WAIT  CCB\n         EOJ\nERRMSG   DC    C'PDPCLIB HAS INSUFFICIENT MEMORY - NO SIZE=AUTO?'\nCCB      CCB   SYSLOG,CCW\nCCW      CCW   X'09',ERRMSG,0,L'ERRMSG\nSAVER4   DS    F\nSAVER13  DS    F\n         LTORG\n*         ENTRY CEESG003\n*CEESG003 EQU   *\n         DS    0H\n         ENTRY @@EXITA\n@@EXITA  EQU   *\n* SWITCH BACK TO OUR OLD SAVE AREA\n         LR    R10,R15\n         USING @@EXITA,R10\n         L     R9,0(R1)\n         L     R13,=A(SAVER13)\n         L     R13,0(R13)\n*\n         AIF   ('&SYS' NE 'S380').N380ST3\n         L     R4,=A(SAVER4)\n         L     R4,0(R4)\n* If we were called in AMODE 31, don't switch back to 24-bit\n         LTR   R4,R4\n         BNZ   IN31C\n         CALL  @@SETM24\nIN31C    DS    0H\n.N380ST3 ANOP\n*\n         LR    R1,R13\n         L     R13,4(R13)\n         LR    R14,R9\n         FREEVIS LENGTH=STACKLEN\n         LR    R15,R14\n*         RETURN (14,12),RC=(15)\n         EOJ\n         LTORG\nSTACKLEN DC    A(STKLTMP)\n*\nSTACK    DSECT\nSAVEAREA DS    18F\nDUMMYPTR DS    F\nTHEIRSTK DS    F\nPARMLIST DS    0F\nARGPTR   DS    F\nPGMNPTR  DS    F\nARGPTRE  DS    F\nTYPE     DS    F\nPGMNAME  DS    CL8\nPGMNAMEN DS    C                 NUL BYTE FOR C\nXUPSI    DS    C                 UPSI switches\nANCHOR   DS    0F\nEXITADDR DS    F\n         DS    49F\nMAINSTK  DS    32000F\nMAINLEN  EQU   *-MAINSTK\nSTKLTMP  EQU   *-STACK\n*\nCOMREG   MAPCOMR\n*\n* MAPACCT - map ACCTABLE - from DOS/VS supervisor\n*\nACCTABLE DSECT                    PARTITION ACCOUNTING TABLE\nACCTWK1  DS    F                  WORK AREAS\nACCTWK2  DS    F\nACCTSVPT DS    F                       SAVE AREA FOR JOB CARD PTR\nACCTPART DS    X                       PARTITION SWITCH KEY\nACCTRES2 DS    X                       RESERVED\nACCTLEN  DS    H                  LENGTH OF SIO PART OF TABLE.\nACCTLOAD DS    3H                      INST TO SET LABEL AREA\nACCTRES3 DS    H                       RESERVED\nACCTLADD DS    A                       ADDR OF LABEL AREA\nACCTCPUT DS    F                       PARTITION CPU TIME COUNTER\nACCTOVHT DS    F                       OVERHEAD CPU COUNTER\nACCTBNDT DS    F                       WAIT TIME COUNTER\nACCTSVJN DS    CL8                     JOB NAME SAVE AREA\n*        REG 15 HAS ADDRESS OF FOLLOWING LABEL WHEN $JOBACCT CALLED.\nACCTJBNM DS    CL8                START OF USERS SECTION OF TABLE.\nACCTUSRS DS    CL16               USERS ACCOUNT INFORMATION\nACCTPTID DS    CL2                PARTITION ID\nACCTCNCL DS    XL1                CANCEL CODE FOR JOB STEP\nACCTYPER DS    XL1                TYPE OF ACCOUNTING RECORD\nACCTDATE DS    CL8                DATE OF JOB\nACCTSTRT DS    F                  JOB START TIME\nACCTSTOP DS    F                  JOB STOP TIME\nACCTRESV DS    F                  RESERVED\nACCTEXEC DS    CL8                JOB STEP PHASE NAME\nACCTHICR DS    F                  JOB STEP HI-CORE ADDRESS\nACCTIMES DS    3F                 EXECUTION TIME BREAKDOWN FIELDS\nACCTSIOS DS    X                  START OF SIO TABLE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSESUPA": {"ttr": 9733, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*                                                                     *\n*  This program written by Paul Edwards.                              *\n*  Released to the public domain                                      *\n*                                                                     *\n*  Contributions from Louis Millon et al also public domain.          *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*  VSESUPA - Support routines for PDPCLIB under DOS/VSE               *\n*                                                                     *\n*  This assembler code has a long history - starting off as C/370     *\n*  under MVS then modified for GCC, then ported to CMS, MUSIC/SP      *\n*  and then finally VSE. A rewrite by someone with deep VSE           *\n*  experience should be considered. Also, it will probably be         *\n*  necessary at some point to introduce a flag to say whether it is   *\n*  being built for z/VSE or DOS/VS R34, as new functionality like     *\n*  the use of LABEL/LPL for dynamic file allocation shouldn't be      *\n*  held back by the older DOS/VS. Perhaps dummy macros can be         *\n*  created rather than a flag, but either way, z/VSE should never be  *\n*  seriously compromised.                                             *\n*                                                                     *\n***********************************************************************\n*\n*\n* LDINT macro\n*\n         MACRO ,             COMPILER DEPENDENT LOAD INTEGER\n&NM      LDINT &R,&A         LOAD INTEGER VALUE FROM PARM LIST\n         GBLC  &COMP         COMPILER GCC OR C/370\n&NM      L     &R,&A         LOAD PARM VALUE\n         AIF ('&COMP' EQ 'GCC').MEND\n.* THIS LINE IS FOR ANYTHING NOT GCC: C/370\n         L     &R,0(,&R)     LOAD INTEGER VALUE\n.MEND    MEND  ,\n*\n*\n*\n         COPY  PDPTOP\n*\n         CSECT\n         PRINT GEN\n* REGEQU is not standard\n*         REGEQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*\n***********************************************************************\n*                                                                     *\n*  AOPEN - Open a file                                                *\n*                                                                     *\n*  Parameters are:                                                    *\n*  DDNAME - space-padded, 8 character DDNAME to be opened             *\n*    Note that in VSE, the DDNAME may be expanded to be more than 8   *\n*    bytes. It represents not just the 7-character filename on the    *\n*    DLBL, but may also include recfm, lrecl and blksize info.        *\n*    It is not expected that there is much call for that though,      *\n*    so there are reasonable defaults.                                *\n*    First we have a fairly fixed portion - e.g. SDO1, which is the   *\n*    disk label, which is also the macro name, the typefle (I or O)   *\n*    of the macro, and it's sequence number (currently statically     *\n*    defined, but potentially it will be dynamic).                    *\n*    All files are defined as RECFM=U, since that gives the program   *\n*    the flexibility to decide how to treat it, and in DOS there is   *\n*    no-one else who will disagree, with the info not stored in the   *\n*    VTOC or catalog or DCB or anywhere else.                         *\n*    The next bit of the DDNAME says how you want the file to be      *\n*    internally treated. The default is RECFM=U which for input files *\n*    is the maximum possible for a 3350, but on output it is a        *\n*    figure that is more flexible for the sort of data that may be    *\n*    stored - 6480 - a multiple of both 80 and 81, that fits on most  *\n*    disk types, while still being over 90% efficient on a 3390.      *\n*    Otherwise the user may specify FB80 which will treat the data    *\n*    as F80 records, blocked to 6480, which depending on other things *\n*    may trigger breakdown of records, stripping of blanks etc.       *\n*    For output only, F80 may be specified to force the data to be    *\n*    unblocked. It has no meaning (and is invalid) on input.          *\n*    A similar situation exists for tapes.                            *\n*    That's the theoretical input - sort of like an SDI1,FB,80,6480   *\n*    In practice we don't yet have the ability to deblock, so any     *\n*    FB80 file must in actual fact be F80.                            *\n*  MODE - 0 = READ, 1 = WRITE, 2 = UPDATE (update not supported)      *\n*  RECFM - 0 = F, 1 = V, 2 = U. This is an output from this function  *\n*  LRECL - This function will determine the LRECL                     *\n*  BLKSIZE - This function will determine the block size              *\n*  ASMBUF - pointer to a 32K area which can be written to (only       *\n*    needs to be set in move mode)                                    *\n*  MEMBER - *pointer* to space-padded, 8 character member name.       *\n*    If pointer is 0 (NULL), no member is requested                   *\n*                                                                     *\n*  Return value:                                                      *\n*  An internal \"handle\" that allows the assembler routines to         *\n*  keep track of what's what when READ etc are subsequently           *\n*  called.                                                            *\n*                                                                     *\n*                                                                     *\n*  Note - more documentation for this and other I/O functions can     *\n*  be found halfway through the stdio.c file in PDPCLIB.              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  In the general case of an open of a disk file, ideally the         *\n*  OPEN should allocate its storage area (ZDCBAREA - what \"handle\"    *\n*  points to, and then it should copy the DTFSD into part of that     *\n*  \"DCB area\" (it is called that for historical reasons and will      *\n*  probably be renamed). The OPEN macro, using register notation,     *\n*  points to that area, which will have first been modified to put    *\n*  in the DDNAME (DLBL) being opened. This way we only need a         *\n*  single DTFSD in the main code, which is reused any number of       *\n*  times. However, at the moment we have simply assumed a small       *\n*  number of files, which is sufficient to allow a C compile to go    *\n*  through.                                                           *\n*                                                                     *\n*  The stdin/stdout/stderr are treated differently - each of those    *\n*  has its own DTF, because they are special files (not disks).       *\n*  The special files are SYSIPT, SYSLST and SYSLOG respectively.      *\n*                                                                     *\n*  Another technique that has been used is for accessing members of   *\n*  a PDS - they are assumed to be in the CIL, and loaded, then        *\n*  data is read from them as if it was a RECFM=U dataset.             *\n*  It is expected that this technique will be expanded in the future  *\n*  to also allow a similar operation from a source statement          *\n*  library.                                                           *\n*                                                                     *\n*  Also note that the C code is totally flexible in that it will      *\n*  do whatever this assembler code tells it to. ie you can set any    *\n*  file to any RECFM/LRECL and it will do its work based on that.     *\n*  This makes it possible to change anything in here that isn't       *\n*  working to your satisfaction, without needing to change the C      *\n*  code at all.                                                       *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AOPEN\n@@AOPEN  EQU   *\n         SAVE  (14,12),,@@AOPEN\n         LR    R12,R15\n         USING @@AOPEN,R12\n         LR    R11,R1\n         L     R0,=A(ZDCBLEN)\n         AIF   ('&SYS' EQ 'S390').BELOW\n* USE DEFAULT LOC=RES for S/370 and S/380\n         GETVIS\n         AGO   .CHKBLWE\n.BELOW   ANOP\n         GETVIS LOC=BELOW\n.CHKBLWE ANOP\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,0(R1)           R3 POINTS TO DDNAME\n         L     R6,4(R1)\n         LDINT R6,0(R6)           R6 now has value of mode\n* 08(,R1) has RECFM\n* Note that R5 is used as a scratch register\n         L     R8,12(,R1)         R8 POINTS TO LRECL\n* 16(,R1) has BLKSIZE\n* 20(,R1) has ASMBUF pointer\n*\n         LA    R9,0\n         ST    R9,ISMEM\n         ST    R9,ISDI\n         L     R9,24(,R1)         R9 POINTS TO MEMBER NAME (OF PDS)\n         LA    R9,0(,R9)          Strip off high-order bit or byte\n*\n         LR    R2,R13             Access DCB\n         LA    R2,WORKLEN(R2)     Point past save area\n         LR    R0,R2              Load output DCB area address\n         L     R1,=A(ZDCBLEN)     Load output length of DCB area\n         S     R1,=A(WORKLEN)     Adjust for save area\n         LR    R5,R11             Preserve parameter list\n         LA    R11,0              Pad of X'00' and no input length\n         MVCL  R0,R10             Clear DCB area to binary zeroes\n         LR    R11,R5             Restore parameter list\n* R5 free again\n*\n*\n         LTR   R6,R6\n         BNZ   WRITING\n*\n* So now we're doing the reading code\n*\n* Something like RDJFCB would be good here, if VSE has such a thing\n*\n         LTR   R9,R9\n         BZ    NOMEM\n*\n* Although VSE doesn't have PDSes with members, it has something\n* similar - libraries. It is actually the Core Image library that\n* is the most flexible, allowing binary data to be stored.\n* Unfortunately this can't be directly read or written! But what\n* we can do is use LNKEDT to build a module, then load it later,\n* to be read as a file.\n*\n         ST    R9,ISMEM\n         MVC   MEMBER24,0(R9)\n         LA    R9,=C'OPEN    '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n*\n* We should be able to have 32k records here\n         L     R6,=F'19069'   +++ hardcode to 19069\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to recfm=U\n         ST    R6,DCBRECFM\n         B     DONEOPEN\nNOMEM    DS    0H\n*\n* Normal datasets just need to be opened - but unfortunately\n* we don't know what their DCB info is. What we basically do\n* to get around that problem is to hardcode DCB info based on\n* the DDNAME. There are various techniques that could be used\n* to work around this limitation, and one should be implemented.\n*\n* We use the register notation, because other than the standard\n* files, all files will read/write data from a field in ZDCBAREA\n* rather than a variable defined in this CSECT.\n*\n         CLC   0(8,R3),=C'SYSIN   '\n         BNE   NOTSYSI\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   sysin is device-independent\n         LA    R5,SYSIN\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSI  DS    0H\n*\n* All other files currently defined are RECFM=U\n*\n         L     R6,=F'19069'   +++ hardcode to 19069\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to recfm=U\n         ST    R6,DCBRECFM\n*\n* Here we need to choose tape or disk\n* There's probably a better way than looking at the name of\n* the DD, to see if it starts with \"MT\", as a convention,\n* but of course it would be better if this was\n* transparent to the programmer in the first place!\n*\n         CLC   0(2,R3),=C'MT'\n         BNE   NOTTAP\n         LA    R5,MTI1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTTAP   DS    0H\n*\n* Need to allow more input files, and DCB info\n*\n         CLC   0(8,R3),=C'SDI1FB80'\n         BNE   NFB80I1\n*\n* Warning - either this assembler code, or the calling C program,\n* should be made sophisticated enough to handle FB. But at the\n* moment, such deblocking is not available, so although the\n* syntax caters for FB, we actually only support F.\n*\n         LA    R6,0           +++ hardcode to recfm=F\n         ST    R6,DCBRECFM\n         L     R6,=F'80'      +++ hardcode to 80\n         ST    R6,DCBLRECL\nNFB80I1  DS    0H\n         LA    R5,SDI1\n         CLC   0(4,R3),=C'SDI1'\n         BE    GOTSDI1\n         LA    R5,SDI2        +++ assume SDI2\nGOTSDI1  DS    0H\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n* Can't reach here, since all files are currently considered valid\n         B     BADOPEN\n*\n*\n*\nWRITING  DS    0H\n*\n* Would be good if we could do a RDJFCB here to get DCB info.\n* Instead, we just assume it from the DD name.\n*\n* Writing to a member of a library is not directly supported in VSE,\n* and the workaround for this situation is done outside of this\n* assembler code, so nothing to see here folks!\n*\n* We use the register notation, because other than the standard\n* files, all files will read/write data from a field in ZDCBAREA\n* rather than a variable defined in this CSECT.\n*\nWNOMEM   DS    0H\n         CLC   0(8,R3),=C'SYSPRINT'\n         BNE   NOTSYSPR\n         LA    R6,120         lrecl = 120\n         ST    R6,DCBLRECL\n         LA    R6,0           recfm = fixed\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   sysprint is device-independent\n         L     R6,DCBLRECL\n         LA    R5,SYSPRT\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSPR DS    0H\n         CLC   0(8,R3),=C'SYSTERM '\n         BNE   NOTSYST\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n         LA    R5,SYSTRM\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYST  DS    0H\n         CLC   0(8,R3),=C'SYSPUNCH'\n         BNE   NOTSYSPU\n         LA    R6,80          lrecl = 80\n         ST    R6,DCBLRECL\n         LA    R6,0           recfm = fixe\n         ST    R6,DCBRECFM\n         LA    R6,1\n         ST    R6,ISDI   syspunch is device-independent\n         L     R6,DCBLRECL\n         LA    R5,SYSPCH\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTSYSPU DS    0H\n*\n* We should really make this smart enough to be allocated to\n* any SDO file, and for it to pick up the LRECL as well.\n*\n         CLC   0(8,R3),=C'SDO1F80 '\n         BNE   NOTF80O1\n         LA    R6,80          +++ hardcode to 80\n         ST    R6,DCBLRECL\n         LA    R6,0           +++ hardcode to fixed\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n         LA    R5,SDO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\nNOTF80O1 DS    0H\n*\n* Assume RECFM=U\n* Note that output files can't really use up to the full 19069\n* and 18452 is a better match for a 3390 anyway. However, this\n* is set to 80 * 81 for ease of use by other programs.\n* Also note that we need to cater for SDO2 etc too\n*\n         L     R6,=F'6480'    +++ hardcode to 6480\n         ST    R6,DCBLRECL\n         LA    R6,2           +++ hardcode to undefined\n         ST    R6,DCBRECFM\n         L     R6,DCBLRECL\n*\n*\n* Here we need to choose tape or disk. Actually only MTO1 is\n* currently supported, but we don't check for that.\n*\n         CLC   0(2,R3),=C'MT'\n         BNE   NOTTAPW\n         LA    R5,MTO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n*\n*\n*\nNOTTAPW  DS    0H\n         LA    R5,SDO1\n         ST    R5,PTRDTF\n         OPEN  (R5)\n         B     DONEOPEN\n* Can't reach here, since all files are currently considered valid\n         B     BADOPEN\n*\n*\n*\n*\nDONEOPEN DS    0H\n*\n* We've done the open (read or write), and now need to allocate a\n* buffer that the C code can write to (or in the case of read,\n* that the assembler code can use). The buffer needs to be below the\n* line, so it's simpler if the assembler code allocates it on\n* behalf of the C caller. We should really allocate a buffer size\n* based on what is actually required rather than this hardcoded\n* maximum possible.\n*\n         L     R6,=F'32768'\n*\n* S/370 can't handle LOC=BELOW\n*\n         AIF   ('&SYS' EQ 'S390').MVT8090  If not 390\n         GETVIS LENGTH=(R6)  Use default LOC=RES for S/370 and S/380\n         AGO   .GETOENE\n.MVT8090 ANOP  ,                  S/390\n         GETVIS LENGTH=(R6),LOC=BELOW\n.GETOENE ANOP\n*\n* Give this buffer pointer back to caller\n         ST    R1,ASMBUF\n         L     R5,20(,R11)        R5 points to ASMBUF\n         ST    R1,0(R5)           save the pointer\n* Note that in the case of read, the caller doesn't need to know\n* the address (something appropriate is returned in the read\n* function - and appropriate means that the assembler may have\n* deblocked the records and be pointing to that), but it seems\n* harmless to set the value anyway.\n*\n*\n* Set other values that the caller needs to know\n*\n* The LRECL\n         L     R6,DCBLRECL\n         ST    R6,0(R8)\n* The RECFM\n         L     R6,DCBRECFM\n         L     R5,8(,R11)         Point to RECFM\n         ST    R6,0(R5)\n* Now return success\n         B     RETURNOP\n*\n*\n* We failed to open the file, so free the allocated memory and\n* return an error.\n*\nBADOPEN  DS    0H\n         L     R0,=A(ZDCBLEN)\n         LR    R1,R13\n         L     R7,SAVEAREA+4\n         FREEVIS\n         L     R15,=F'-1'\n         LR    R13,R7\n         RETURN (14,12),RC=(15)\n*\n*\n* Good return - handle is in ZDCBAREA, which is R13. So we don't\n* want to free that memory!\n*\nRETURNOP DS    0H\n         LR    R15,R13\n         L     R13,SAVEAREA+4\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n***********************************************************************\n*                                                                     *\n*  AREAD - Read from file                                             *\n*                                                                     *\n*  This function takes 3 parameters:                                  *\n*                                                                     *\n*  1. A handle (previously returned by AOPEN)                         *\n*  2. A buffer pointer - this is an output variable - the assembler   *\n*     routine will read the data and then inform the caller where     *\n*     the data is located.                                            *\n*  3. Length of data (also output).                                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AREAD\n@@AREAD  EQU   *\n         SAVE  (14,12),,@@AREAD\n         LR    R12,R15\n         USING @@AREAD,R12\n         LR    R11,R1\n*\n         AIF ('&SYS' EQ 'S370').NOMOD1\n         CALL  @@SETM24\n.NOMOD1  ANOP\n*\n         L     R1,0(R1)         R1 CONTAINS HANDLE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n         L     R3,4(R1)         R3 POINTS TO BUF POINTER\n         L     R4,8(R1)         R4 points to a length\n*\n* See if this is a library file\n*\n         L     R9,ISMEM\n         LTR   R9,R9\n         BNZ   GMEM\n*\n* For non-library files, we read into an internal buffer that\n* was allocated earlier and is pointed to by the zdcbarea. Set\n* that fact immediately.\n*\n         L     R5,ASMBUF\n         ST    R5,0(R3)\n*\n* The DTF macro is expecting to get the maximum length in R8\n*\n         L     R8,DCBLRECL\n         L     R7,PTRDTF\n*\n         L     R9,ISDI            Is this device-independent?\n         LTR   R9,R9\n         BNZ   GDIR\n*\n* Normal file. GET needs the DTF pointer, the buffer, and our\n* DTF is expecting the length in R8\n*\n         GET   (R7),(R5)\n         B     DONEGET\n*\n* Got a device-indepentent DTF - we only support a RECSIZE of 80,\n* and do not support a file containing an intiial control\n* character, so if you have such a file you will need to trim\n* it down using a separate utility first.\n*\nGDIR     DS    0H          Got a device-independent\n         GET   (R7)\n         LA    R8,80     +++ hardcoded length of 80\n         MVC   0(80,R5),IO1  +++ hardcode IO1 and length\nDONEGET  DS    0H\n* If GET reaches EOF, the \"GOTEOF\" label will be branched to\n* automatically.\n         LA    R15,0             SUCCESS\n         ST    R8,0(R4)          store length actually read\n         B     FINFIL\n*\n* This is a library file, so we need to call VSEFIL\n*\nGMEM     DS    0H                got member\n         LA    R9,=C'GET     '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n* Let VSEFIL directly set our caller's parameters\n         ST    R3,P3VF\n         ST    R4,P4VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n         L     R9,0(R4)\n         LTR   R9,R9\n         BNZ   FINFIL\n         B     GOTEOF\nGOTEOF   DS    0H\n         LA    R15,1             FAIL\nFINFIL   DS    0H\n*\nRETURNAR DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n*\n         AIF ('&SYS' EQ 'S370').NOMOD2\n         LR    R7,R15            Preserve R15 over call\n         CALL  @@SETM31\n         LR    R15,R7\n.NOMOD2  ANOP\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n***********************************************************************\n*                                                                     *\n*  AWRITE - Write to file                                             *\n*                                                                     *\n*  This function takes 3 parameters:                                  *\n*                                                                     *\n*  1. A handle (previously returned by AOPEN)                         *\n*  2. Address of buffer to be written (also previously obtained       *\n*     from AOPEN).                                                    *\n*  3. Length of data to be written (which may be ignored for a file   *\n*     that is of an expected length, e.g. fixed 80)                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@AWRITE\n@@AWRITE EQU   *\n         SAVE  (14,12),,@@AWRITE\n         LR    R12,R15\n         USING @@AWRITE,R12\n         LR    R11,R1             SAVE\n*\n         AIF   ('&SYS' NE 'S380').N380WR1\n         CALL  @@SETM24\n.N380WR1 ANOP\n*\n         L     R1,0(R1)           R1 IS NOW HANDLE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11             RESTORE\n         USING WORKAREA,R13\n*\n         L     R2,0(,R1)          R2 contains GETMAINed address\n         L     R3,4(,R1)          R3 points to the record address\n         L     R3,0(,R3)          R3 now has actual buffer address\n         L     R8,8(,R1)          R8 points to the length\n         L     R8,0(,R8)          R8 now has actual length\n*\n         L     R5,PTRDTF\n         L     R9,ISDI            Is this device-independent?\n         LTR   R9,R9\n         BNZ   GDIW\n*\n* Normal file. PUT needs the DTF pointer, the buffer, and our\n* DTF is expecting the length in R8 (unless the DTF is fixed)\n*\n         PUT   (R5),(R3)\n         B     DONEPUT\n*\n* Got a device-independent DTF (which requires a control character)\n*\nGDIW     DS    0H\n         EX    R8,WRMOVE\n         MVI   IO1,C' '          space seems universal rather than V/W\n         PUT   (R5)\n*\n* We have written to file, but should really check for any error\n*\nDONEPUT  DS    0H\n*\n         AIF   ('&SYS' NE 'S380').N380WR2\n         CALL  @@SETM31\n.N380WR2 ANOP\n*\n         L     R13,4(R13)\n         LA    R15,0             +++ hardcode success\n         RETURN (14,12),RC=(15)\nWRMOVE   MVC   IO1+1(0),0(R3)    +++ hardcode IO1\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  ACLOSE - Close file                                                *\n*                                                                     *\n*  This routine takes a single parameter - a handle as given by the   *\n*  (successful) return from AOPEN.                                    *\n*                                                                     *\n***********************************************************************\n         ENTRY @@ACLOSE\n@@ACLOSE EQU   *\n         SAVE  (14,12),,@@ACLOSE\n         LR    R12,R15\n         USING @@ACLOSE,R12\n         LR    R11,R1           SAVE\n*\n* The CLOSE appears to be abending when called in 31-bit mode,\n* despite it being an SVC. So we need to switch to 24-bit mode\n         AIF   ('&SYS' NE 'S380').N380CL1\n         CALL  @@SETM24\n.N380CL1 ANOP\n*\n         L     R1,0(R1)         R1 CONTAINS HANDLE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING WORKAREA,R13\n*\n*\n         L     R5,ASMBUF\n         LTR   R5,R5\n         BZ    NFRCL\n         L     R6,=F'32768'     +++ hardcode length of ASMBUF\n         FREEVIS LENGTH=(R6),ADDRESS=(R5)\nNFRCL    DS    0H\n*\n*\n         L     R5,PTRDTF        Get DTF\n         LTR   R5,R5\n         BZ    NOTOPEN\n         L     R9,ISMEM         Is this a library member?\n         LTR   R9,R9\n         BNZ   GMEM2\n*\n* Normal file - just do a close.\n*\n         CLOSE (R5)\n         B     DONECLOS\n*\n* We have a library member, so call VSEFIL to close\n*\nGMEM2    DS    0H\n         LA    R9,=C'CLOSE   '\n         ST    R9,P1VF\n         LA    R9,MEMBER24\n         ST    R9,P2VF\n         LA    R1,PMVF\n         CALL  @@VSEFIL\n         B     DONECLOS\n*\n* We probably shouldn't have a specific detection for a close\n* of a file that is not open, as it's a logic error regardless.\n*\nNOTOPEN  DS    0H\n         LA    R15,1\n         B     RETURNAC\n*\n* We should have some error detection here, but for now, just\n* set success unconditionally\n*\nDONECLOS DS    0H\n         LA    R15,0\n*\nRETURNAC DS    0H\n         LR    R1,R13\n         L     R13,SAVEAREA+4\n         LR    R7,R15\n         L     R0,=A(ZDCBLEN)\n         FREEVIS\n*\n         AIF   ('&SYS' NE 'S380').N380CL2\n         CALL  @@SETM31\n.N380CL2 ANOP\n*\n         LR    R15,R7\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Note that a lot of these macros use the same storage buffer,\n* because by their nature, the C caller will always read or\n* write an entire block at a time.\n*\n*\n* This is for reading from stdin\nSYSIN    DTFDI DEVADDR=SYSIPT,IOAREA1=IO1,RECSIZE=80,EOFADDR=GOTEOF\n*\n* This is for writing to SYSPUNCH in a device-independent manner\n* Note that it is a requirement to allow for a control character\nSYSPCH   DTFDI DEVADDR=SYSPCH,IOAREA1=IO1,RECSIZE=81\n*\n* This is for writing to stdout (SYSPRINT)\nSYSPRT   DTFDI DEVADDR=SYSLST,IOAREA1=IO1,RECSIZE=121\n*\n* This is for writing to stderr (SYSTERM)\nSYSTRM   DTFPR CONTROL=YES,BLKSIZE=80,DEVADDR=SYS005,MODNAME=PRINTMOD, X\n               IOAREA1=IO1,RECFORM=FIXUNB,WORKA=YES\nPRINTMOD PRMOD CONTROL=YES,RECFORM=FIXUNB,WORKA=YES\n*\n* This is for reading from a sequential disk file\nSDI1     DTFSD BLKSIZE=19069,DEVADDR=SYS000,DEVICE=3350,               X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* Another SD\nSDI2     DTFSD BLKSIZE=19069,DEVADDR=SYS000,DEVICE=3350,               X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* This is for writing to a sequential disk file\nSDO1     DTFSD BLKSIZE=19069,DEVICE=3350,                              X\n               IOAREA1=WORKO1,RECFORM=UNDEF,WORKA=YES,                 X\n               TYPEFLE=OUTPUT,RECSIZE=(8)\n*\n* This is for reading from a tape\nMTI1     DTFMT BLKSIZE=19069,DEVADDR=SYS011,MODNAME=MTMOD,             X\n               IOAREA1=WORKI1,RECFORM=UNDEF,WORKA=YES,FILABL=NO,       X\n               TYPEFLE=INPUT,RECSIZE=(8),EOFADDR=GOTEOF\n*\n* This is for writing to a tape\nMTO1     DTFMT BLKSIZE=19069,DEVADDR=SYS011,MODNAME=MTMOD,             X\n               IOAREA1=WORKO1,RECFORM=UNDEF,WORKA=YES,FILABL=STD,      X\n               TYPEFLE=OUTPUT,RECSIZE=(8)\n*\n* For some reason this MOD can be shared by both input and\n* output, and in fact, there's not much choice, because otherwise\n* we get duplicate symbols.\nMTMOD    MTMOD WORKA=YES,RECFORM=UNDEF\n*\n* For the standard files, this is sufficient for input and output\nIO1      DS    CL200\n*\n*\n*\n* This is pretty crappy - storing large variables in the CSECT\n* instead of the dynamically-allocated DSECT. But at least the\n* fact that they are being shared makes it not so bad.\n* An extra 100 bytes to be helpful.\nWORKI1   DS    CL32767\nWORKO1   DS    CL32767\n*\n*\n***********************************************************************\n*                                                                     *\n*  GETM - GET MEMORY                                                  *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETM\n@@GETM   EQU   *\n         SAVE  (14,12),,@@GETM\n         LR    R12,R15\n         USING @@GETM,R12\n*\n         LDINT R3,0(,R1)          LOAD REQUESTED STORAGE SIZE\n         LR    R4,R3\n         LA    R3,8(,R3)\n*\n* To avoid fragmentation, round up size to 64 byte multiple\n*\n         A     R3,=A(64-1)\n         N     R3,=X'FFFFFFC0'\n*\n         AIF   ('&SYS' NE 'S380').N380GM1\n*\n* When in 380 mode, we need to keep the program below the\n* line, but we have the ability to use storage above the\n* line, and this is where we get it, with the LOC=ANY parameter.\n* For other environments, the default LOC=RES is fine.\n*\n         GETVIS LENGTH=(R3),LOC=ANY\n         AGO   .N380GM2\n.N380GM1 ANOP\n         GETVIS LENGTH=(R3)\n.N380GM2 ANOP\n*\n         LTR   R15,R15\n         BZ    GOODGM\n         LA    R15,0\n         B     RETURNGM\nGOODGM   DS    0H\n* WE STORE THE AMOUNT WE REQUESTED FROM VSE INTO THIS ADDRESS\n         ST    R3,0(R1)\n* AND JUST BELOW THE VALUE WE RETURN TO THE CALLER, WE SAVE\n* THE AMOUNT THEY REQUESTED\n         ST    R4,4(R1)\n         A     R1,=F'8'\n         LR    R15,R1\n*\nRETURNGM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  FREEM - FREE MEMORY                                                *\n*                                                                     *\n***********************************************************************\n         ENTRY @@FREEM\n@@FREEM  EQU   *\n         SAVE  (14,12),,@@FREEM\n         LR    R12,R15\n         USING @@FREEM,R12\n*\n         L     R2,0(,R1)\n         S     R2,=F'8'\n         L     R3,0(,R2)\n*\n         FREEVIS LENGTH=(R3),ADDRESS=(R2)\n*\nRETURNFM DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  GETCLCK - GET THE VALUE OF THE MVS CLOCK TIMER AND MOVE IT TO AN   *\n*  8-BYTE FIELD.  THIS 8-BYTE FIELD DOES NOT NEED TO BE ALIGNED IN    *\n*  ANY PARTICULAR WAY.                                                *\n*                                                                     *\n*  E.G. CALL 'GETCLCK' USING WS-CLOCK1                                *\n*                                                                     *\n*  THIS FUNCTION ALSO RETURNS THE NUMBER OF SECONDS SINCE 1970-01-01  *\n*  BY USING SOME EMPERICALLY-DERIVED MAGIC NUMBERS                    *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETCLK\n@@GETCLK EQU   *\n         SAVE  (14,12),,@@GETCLK\n         LR    R12,R15\n         USING @@GETCLK,R12\n*\n         L     R2,0(,R1)\n         STCK  0(R2)\n         L     R4,0(,R2)\n         L     R5,4(,R2)\n         SRDL  R4,12\n         SL    R4,=X'0007D910'\n         D     R4,=F'1000000'\n         SL    R5,=F'1220'\n         LR    R15,R5\n*\nRETURNGC DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  LOAD - load a module into memory                                   *\n*                                                                     *\n*  parm1 = program name                                               *\n*  parm2 = memory address                                             *\n*                                                                     *\n*  entry point address returned in R15                                *\n*                                                                     *\n*  Not currently used, but it might be!                               *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LOAD\n@@LOAD   EQU   *\n         SAVE  (14,12),,@@LOAD\n         LR    R12,R15\n         USING @@LOAD,R12\n*\n         L     R2,0(,R1)\n         L     R3,4(,R1)\n         LOAD  (R2),(R3)\n         LR    R15,R1\n*\nRETURNLD DS    0H\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  SYSTEM - execute another command                                   *\n*                                                                     *\n*  Not currently implemented, but ideally should be                   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SYSTEM\n@@SYSTEM EQU   *\n         SAVE  (14,12),,@@SYSTEM\n         LR    R12,R15\n         USING @@SYSTEM,R12\n         LR    R11,R1\n*\n*         GETVIS LENGTH=SYSTEMLN,SP=SUBPOOL\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         LR    R1,R11\n         USING SYSTMWRK,R13\n*\n         MVC   CMDPREF,FIXEDPRF\n         L     R2,0(R1)\n         CL    R2,=F'200'\n         BL    LENOK\n         L     R2,=F'200'\nLENOK    DS    0H\n         STH   R2,CMDLEN\n         LA    R4,CMDTEXT\n         LR    R5,R2\n         L     R6,4(R1)\n         LR    R7,R2\n         MVCL  R4,R6\n         LA    R1,CMDPREF\n*         SVC   $EXREQ\n*\nRETURNSY DS    0H\n         LR    R1,R13\n         L     R13,SYSTMWRK+4\n*         FREEMAIN RU,LV=SYSTEMLN,A=(1),SP=SUBPOOL\n*\n         LA    R15,0\n         RETURN (14,12),RC=(15)\n* For documentation on this fixed prefix, see SVC 221\n* documentation.\nFIXEDPRF DC    X'7F01E000000000'\n         LTORG\nSYSTMWRK DSECT ,             MAP STORAGE\n         DS    18A           OUR OS SAVE AREA\nCMDPREF  DS    CL8           FIXED PREFIX\nCMDLEN   DS    H             LENGTH OF COMMAND\nCMDTEXT  DS    CL200         COMMAND ITSELF\nSYSTEMLN EQU   *-SYSTMWRK    LENGTH OF DYNAMIC STORAGE\n         CSECT ,\n*\n***********************************************************************\n*                                                                     *\n*  IDCAMS - dummy function to keep VSE happy                          *\n*                                                                     *\n***********************************************************************\n         ENTRY @@IDCAMS\n@@IDCAMS EQU   *\n         SAVE  (14,12),,@@IDCAMS\n         LR    R12,R15\n         USING @@IDCAMS,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n***********************************************************************\n*                                                                     *\n*  DYNAL - dummy function to keep VSE happy                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@DYNAL\n@@DYNAL EQU   *\n         SAVE  (14,12),,@@DYNAL\n         LR    R12,R15\n         USING @@DYNAL,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n***********************************************************************\n*                                                                     *\n*  SVC99 - dummy function to keep VSE happy                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SVC99\n@@SVC99  EQU   *\n         SAVE  (14,12),,@@SVC99\n         LR    R12,R15\n         USING @@SVC99,R12\n*\n         LA    R15,0\n*\n         RETURN (14,12),RC=(15)\n         LTORG\n*\n*\n*\n* Keep the below functions last because they use different\n* base registers\n*\n         DROP  R12\n*\n*\n*\n* This is used by VSEFIL\n*\nTABDDN   DSECT\n         USING     *,R9\nDDN      DS        CL8\nPOINTER  DS        F\nTABLEN   EQU       *-TABDDN\n*\n         CSECT\n***********************************************************************\n*                                                                     *\n*  VSEFIL - contributed by Louis Millon                               *\n*                                                                     *\n*  Allows access to CIL in order to read RECFM=U binary files in a    *\n*  PDS-like manner.                                                   *\n*                                                                     *\n*  CALL      @@VSEFIL,(OPEN,DDN)                                      *\n*  CALL      @@VSEFIL,(GET,DDN,RECADDR,RECLEN)                        *\n*  CALL      @@VSEFIL,(CLOSE,DDN)                                     *\n*                                                                     *\n*  \"OPEN\" etc must be CL8 with that string. DDN is CL8. Other two F   *\n*                                                                     *\n***********************************************************************\n         ENTRY @@VSEFIL\n@@VSEFIL EQU   *\n         USING     *,R3\n         SAVE      (14,12)\n         LR        R3,R15\n         LR        R10,R1\n         B         DEBCODE\nMAXFILE  EQU       200                           NUMBER OF FILES\n*                                                WHICH MAY BE OPENED AT\n*                                                THE SAME TIME\nAREA     DC        (TABLEN*MAXFILE)X'00'\n         DC        F'-1'                         END OF TABLE\nFILENAME DS        CL8\nDEBCODE  DS        0H\n         L         R15,0(R10)                    FUNCTION\n         CLC       =C'GET',0(R15)\n         BE        GET\n         CLC       =C'OPEN',0(R15)\n         BE        OPEN\n         CLC       =C'CLOSE',0(R15)\n         BE        CLOSE\n         RETURN    (14,12),RC=8                  INVALID FUNCTION\nOPEN     DS        0H\n         L         R15,4(R10)\n         MVC       FILENAME,0(R15)               DDNAME\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPOPEN DS        0H\n         CLC       DDN,FILENAME\n         BE        ALREADY                       THIS FILE IS ALREADY\n*                                                OPENED\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPOPEN                  THE FILE IS NOT OPEN\n         LA        R9,AREA                       SEEK FOR A VACANT\n         LA        R15,MAXFILE                   POSITION IN THE ARRAY\nLOOPOPN2 DS        0H\n         CLC       DDN,=8X'0'                    POSITION IS FREE?\n         BE        OKOPEN                        YES\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPOPN2                  NEXT OCCURENCE\n         RETURN    (14,12),RC=12                 ARRAY IS FULL\nALREADY  RETURN    (14,12),RC=8                  FILE ALREADY OPENED\nOKOPEN   DS        0H\n         LA        R1,FILENAME\n         CDLOAD    (1)\n         ST        R0,POINTER\n         LTR       R15,R15\n         BZ        R15OK\n         LNR       R15,R15\n         RETURN    (14,12),RC=(15)              CDLOAD FAIL\nR15OK    EQU       *\n         MVC       DDN,FILENAME\n         RETURN    (14,12),RC=0\nCLOSE    DS        0H\n         L         R15,4(R10)\n         MVC       FILENAME,0(R15)\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPCLOS DS        0H\n         CLC       DDN,FILENAME\n         BE        OKCLOSE\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPCLOS\n         RETURN    (14,12),RC=8                  DDNAME NOTFND IN ARRAY\nOKCLOSE  DS        0H\n         LA        R1,FILENAME\n*\n* This function is not available on DOS/VS, which is a real\n* shame. It should probably be added to VSE/380 (at least as\n* a dummy) and then reinstated, so that it produces better\n* results on z/VSE.\n*         CDDELETE  (1)                       REMOVE PHASE FROM GETV\n         XC        DDN,DDN\n         XC        POINTER,POINTER\n         RETURN    (14,12),RC=0\nGET      DS        0H\n         LA        R15,FILENAME\n         MVC       FILENAME,0(R15)\n         LA        R9,AREA\n         LA        R15,MAXFILE\nLOOPGET  DS        0H\n         CLC       DDN,FILENAME\n         BE        OKGET\n         LA        R9,TABLEN(R9)\n         BCT       R15,LOOPGET\n         RETURN    (14,12),RC=12                 DDNAME NOTFND IN ARRAY\nOKGET    DS        0H\n         L         R15,POINTER\n         CLC       0(4,R15),=F'0'\n         BNE       NOEOF\n         RETURN    (14,12),RC=8                  EOF\nNOEOF    DS        0H\n         L         R14,POINTER\n         L         R15,12(R10)\n         MVC       0(4,R15),0(R14)               LENGTH OF RECORD\n         LA        R14,4(R14)                    SKIP RECLEN\n         L         R15,08(R10)\n         ST        R14,0(R15)                    AADR OF RECORD\n         L         R14,POINTER\n         AL        R14,0(R14)                    SKIP RECORD\n         LA        R14,4(R14)                    AND LENGTH\n         ST        R14,POINTER                   NEXT RECORD\n         RETURN    (14,12),RC=0\n         LTORG\n         DROP      R3\n*\n***********************************************************************\n*                                                                     *\n*  GETTZ - Get the offset from GMT in 1.048576 seconds                *\n*                                                                     *\n***********************************************************************\n         ENTRY @@GETTZ\n@@GETTZ  LA    R15,0\n         BR    R14\n*\n***********************************************************************\n*                                                                     *\n*  SETJ - SAVE REGISTERS INTO ENV                                     *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETJ\n         USING @@SETJ,R15\n@@SETJ   L     R15,0(R1)          get the env variable\n         STM   R0,R14,0(R15)      save registers to be restored\n         LA    R15,0              setjmp needs to return 0\n         BR    R14                return to caller\n         LTORG ,\n*\n***********************************************************************\n*                                                                     *\n*  LONGJ - RESTORE REGISTERS FROM ENV                                 *\n*                                                                     *\n***********************************************************************\n         ENTRY @@LONGJ\n         USING @@LONGJ,R15\n@@LONGJ  L     R2,0(R1)           get the env variable\n         L     R15,60(R2)         get the return code\n         LM    R0,R14,0(R2)       restore registers\n         BR    R14                return to caller\n         LTORG ,\n*\n* S/370 doesn't support switching modes so this code is useless,\n* and won't compile anyway because \"BSM\" is not known.\n*\n         AIF   ('&SYS' EQ 'S370').NOMODE  If S/370 we can't switch mode\n***********************************************************************\n*                                                                     *\n*  SETM24 - Set AMODE to 24                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM24\n         USING @@SETM24,R15\n@@SETM24 ICM   R14,8,=X'00'       Sure hope caller is below the line\n         BSM   0,R14              Return in amode 24\n*\n***********************************************************************\n*                                                                     *\n*  SETM31 - Set AMODE to 31                                           *\n*                                                                     *\n***********************************************************************\n         ENTRY @@SETM31\n         USING @@SETM31,R15\n@@SETM31 ICM   R14,8,=X'80'       Set to switch mode\n         BSM   0,R14              Return in amode 31\n         LTORG ,\n*\n.NOMODE  ANOP  ,                  S/370 doesn't support MODE switching\n*\n*\n*\nWORKAREA DSECT\nSAVEAREA DS    18F\nWORKLEN  EQU   *-WORKAREA\n* Note that the handle starts from the WORKAREA DSECT, but\n* initialization starts at ZDCBAREA (since we don't want to\n* initialize our save area). Some more appropriate names\n* should probably be found. And the WORKLEN is for functions\n* unrelated to I/O which don't need access to the DCB stuff.\n* ZDCBLEN includes the length of the work area, since the\n* I/O functions still need a save area.\nZDCBAREA DS    0H\nPTRDTF   DS    F                  Pointer to the DTF in use\nDCBLRECL DS    F                  Logical record length\nDCBRECFM DS    F                  Record format\n*\n* In the case of read, the internal assembler routines require\n* a buffer (below the line) to read into, before the data can\n* be given to the C caller.\n* In the case of write, the C caller needs a BTL buffer to\n* write to.\nASMBUF   DS    A                  Pointer to a 32k area for I/O\nMEMBER24 DS    CL8\nISMEM    DS    F                  Flag whether this is a PDS\nISDI     DS    F                  Flag whether this is dev-independent\nPMVF     DS    0F\nP1VF     DS    A\nP2VF     DS    A\nP3VF     DS    A\nP4VF     DS    A\nZDCBLEN  EQU   *-WORKAREA\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WINSUPA": {"ttr": 10245, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; winsupa.asm - support code for C programs for Win32\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n.386\n\n.model flat,c\n\n_DATA   segment dword 'DATA'\n_DATA   ends\n_BSS    segment dword 'BSS'\n_BSS    ends\n\n_TEXT segment 'CODE'\n\n\npublic __setj\n__setj proc env:dword\n        mov eax, env\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax + 4\u00a8, ecx\n        mov \u00ddeax + 8\u00a8, edx\n        mov \u00ddeax + 12\u00a8, edi\n        mov \u00ddeax + 16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax + 20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp + 0\u00a8\n        mov \u00ddeax + 24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp + 4\u00a8     ; return address\n        mov \u00ddeax + 28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax + 0\u00a8, ebx\n        mov eax, 0\n\n        ret\n__setj endp\n\n\npublic __longj\n__longj proc env:dword\n        mov eax, env\n        mov ebp, \u00ddeax + 20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax + 28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax + 24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax + 0\u00a8\n        mov ecx, \u00ddeax + 4\u00a8\n        mov edx, \u00ddeax + 8\u00a8\n        mov edi, \u00ddeax + 12\u00a8\n        mov esi, \u00ddeax + 16\u00a8\n\n        mov eax, \u00ddeax + 32\u00a8    ; return value\n\n        ret\n__longj endp\n\n\n_TEXT ends\n\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WINSUPB": {"ttr": 10247, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "; winsupb.asm - support code for C programs for Win32\n;\n; This program written by Paul Edwards\n; Released to the public domain\n\n;BGB: modify to NASM\n;BGB: this code fills me with uncertainty...\n\nglobal __setj\nglobal __longj\n\n\u00ddsection .text\u00a8\n\u00ddbits 32\u00a8\n\n__setj:\n        mov eax, \u00ddesp+4\u00a8\n        push ebx\n        mov ebx, esp\n        push ebx               ; esp\n\n        mov \u00ddeax+4\u00a8, ecx\n        mov \u00ddeax+8\u00a8, edx\n        mov \u00ddeax+12\u00a8, edi\n        mov \u00ddeax+16\u00a8, esi\n\n        pop ebx\n        mov \u00ddeax+20\u00a8, ebx    ; esp\n        mov ebx, \u00ddebp+0\u00a8\n        mov \u00ddeax+24\u00a8, ebx    ; ebp\n\n        mov ebx, \u00ddebp+4\u00a8     ; return address\n        mov \u00ddeax+28\u00a8, ebx    ; return address\n\n        pop ebx\n        mov \u00ddeax+0\u00a8, ebx\n        mov eax, 0\n\n        ret\n\n\n__longj:\n        mov eax, \u00ddesp+4\u00a8\n        mov ebp, \u00ddeax+20\u00a8\n        mov esp, ebp\n        pop ebx                ; position of old ebx\n        pop ebx                ; position of old ebp\n        pop ebx                ; position of old return address\n\n        mov ebx, \u00ddeax+28\u00a8    ; return address\n        push ebx\n\n        mov ebx, \u00ddeax+24\u00a8    ; ebp saved as normal\n        push ebx\n        mov ebp, esp\n\n        mov ebx, \u00ddeax+0\u00a8\n        mov ecx, \u00ddeax+4\u00a8\n        mov edx, \u00ddeax+8\u00a8\n        mov edi, \u00ddeax+12\u00a8\n        mov esi, \u00ddeax+16\u00a8\n\n        mov eax, \u00ddeax+32\u00a8    ; return value\n\n        ret\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "W32START": {"ttr": 6153, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  w32start - startup code for WIN32                                */\n/*                                                                   */\n/*********************************************************************/\n\n/* This is the main entry point of a console mode executable */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n\nint main(int argc, char **argv);\nvoid **__get_main_fp();\n\nvoid mainCRTStartup(void)\n{\n#ifdef __MAIN_FP__\n    (*(__get_main_fp()))=main;\n#endif\n    __start(0);\n    return;\n}\n\nvoid __main(void)\n{\n    return;\n}\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT853/CBT.V500.FILE853.PDS/PDPSRC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT853/CBT.V500.FILE853.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}