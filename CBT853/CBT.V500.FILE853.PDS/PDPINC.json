{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20110613192458000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 44, "INMDSNAM": "PDPCLIB.INCLUDE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 6249, "INMBLKSZ": 6253, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 255, "INMRECFM": "?"}}, "file": {"PDPCLIB.INCLUDE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6253, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "b'X\\x00/\\xb0\\x00\\x00\\x00\\x0b\\x00\\x0b\\x00\\x0b\\x00\\x0e\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@MEMMGR": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written By Paul Edwards.                            */\n/*  Released to the public domain.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef MEMMGR_INCLUDED\n#define MEMMGR_INCLUDED\n\n#include <stddef.h>\n\n/* Do you want memmgr to perform lots of integrity checks? */\n/* Note that this will slow down the system, but it doesn't\n   print out anything or change the functionality of your\n   application. */\n/* #define __MEMMGR_INTEGRITY 1 */\n\n/* Do you want lots of debugging output? */\n/* Note that you still need to set the memmgrDebug variable to 1\n   before it is actually activated */\n/* #define __MEMMGR_DEBUG 1 */\n\ntypedef struct memmgrn {\n#ifdef __MEMMGR_INTEGRITY\n    int eyecheck1;\n#endif\n    struct memmgrn *next;\n    struct memmgrn *prev;\n    struct memmgrn *nextf;\n    struct memmgrn *prevf;\n    int fixed;\n    size_t size; /* size of memory available to user */\n    int allocated;\n    int id;\n#ifdef __MEMMGR_INTEGRITY\n    int eyecheck2;\n#endif\n    size_t filler; /* we add this so that *(p - size_t) is writable */\n} MEMMGRN;\n\ntypedef struct {\n    MEMMGRN *start;\n    MEMMGRN *startf;\n} MEMMGR;\n\n/* What boundary we want the memmgr control block to be a multiple of */\n#define MEMMGR_ALIGN 8\n\n#define MEMMGRN_SZ \\\n  ((sizeof(MEMMGRN) % MEMMGR_ALIGN == 0) ? \\\n   sizeof(MEMMGRN) : \\\n   ((sizeof(MEMMGRN) / MEMMGR_ALIGN + 1) * MEMMGR_ALIGN))\n\n/* Let's make sure that the minimum free data area is at least\n   as big as the node itself, so that we don't have more than\n   50% of the available memory used up by control blocks due\n   to fragmentation */\n#define MEMMGR_MINFREE MEMMGRN_SZ\n\n/* total size of the minimum free area, including room for the\n   control block */\n#define MEMMGR_MINFRTOT (MEMMGRN_SZ + MEMMGR_MINFREE)\n\n/* do you want to crash whenever an integrity problem arises? */\n#ifndef MEMMGR_CRASH\n#define MEMMGR_CRASH 1\n#endif\n\n#define memmgrDefaults __mmDef\n#define memmgrInit __mmInit\n#define memmgrTerm __mmTerm\n#define memmgrSupply __mmSupply\n#define memmgrAllocate __mmAlloc\n#define memmgrFree __mmFree\n#define memmgrFreeId __mmFId\n#define memmgrMaxSize __mmMaxSize\n#define memmgrTotSize __mmTotSize\n#define memmgrIntegrity __mmIntegrity\n#define memmgrRealloc __mmRealloc\n#define memmgrDebug __mmDebug\n#define memmgrDebug2 __mmDbg2\n\nvoid memmgrDefaults(MEMMGR *memmgr);\nvoid memmgrInit(MEMMGR *memmgr);\nvoid memmgrTerm(MEMMGR *memmgr);\nvoid memmgrSupply(MEMMGR *memmgr, void *buffer, size_t szbuf);\nvoid *memmgrAllocate(MEMMGR *memmgr, size_t bytes, int id);\nvoid memmgrFree(MEMMGR *memmgr, void *ptr);\nvoid memmgrFreeId(MEMMGR *memmgr, int id);\nsize_t memmgrMaxSize(MEMMGR *memmgr);\nsize_t memmgrTotSize(MEMMGR *memmgr);\nvoid memmgrIntegrity(MEMMGR *memmgr);\nint memmgrRealloc(MEMMGR *memmgr, void *ptr, size_t newsize);\n\nextern int memmgrDebug;\nextern int memmgrDebug2;\n\nextern MEMMGR __memmgr;\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSERT": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  assert.h - assert header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __ASSERT_INCLUDED\n#define __ASSERT_INCLUDED\n\nint __assert(char *x, char *y, int z);\n\n#ifdef NDEBUG\n#define assert(ignore) ((void)0)\n#else\n#define assert(x) (x) ? ((void)0) : \\\n    __assert(#x, __FILE__, __LINE__)\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CTYPE": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  ctype.h - ctype header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __CTYPE_INCLUDED\n#define __CTYPE_INCLUDED\n\nextern unsigned short *__isbuf;\nextern short *__tolow;\nextern short *__toup;\n\n#define isalnum(c) (__isbuf\u00dd(c)\u00a8 & 0x0001U)\n#define isalpha(c) (__isbuf\u00dd(c)\u00a8 & 0x0002U)\n#define iscntrl(c) (__isbuf\u00dd(c)\u00a8 & 0x0004U)\n#define isdigit(c) (__isbuf\u00dd(c)\u00a8 & 0x0008U)\n#define isgraph(c) (__isbuf\u00dd(c)\u00a8 & 0x0010U)\n#define islower(c) (__isbuf\u00dd(c)\u00a8 & 0x0020U)\n#define isprint(c) (__isbuf\u00dd(c)\u00a8 & 0x0040U)\n#define ispunct(c) (__isbuf\u00dd(c)\u00a8 & 0x0080U)\n#define isspace(c) (__isbuf\u00dd(c)\u00a8 & 0x0100U)\n#define isupper(c) (__isbuf\u00dd(c)\u00a8 & 0x0200U)\n#define isxdigit(c) (__isbuf\u00dd(c)\u00a8 & 0x0400U)\n#define tolower(c) (__tolow\u00dd(c)\u00a8)\n#define toupper(c) (__toup\u00dd(c)\u00a8)\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ERRNO": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  errno.h - errno header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __ERRNO_INCLUDED\n#define __ERRNO_INCLUDED\n\n#define EDOM 1\n#define ERANGE 2\n\n/* extern int errno; */\n\n#define errno (*(__get_errno()))\n\nint *__get_errno(void);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FLOAT": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  float.h - float header file.                                     */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __FLOAT_INCLUDED\n#define __FLOAT_INCLUDED\n\n#if defined(__CMS__) || defined(__MVS__) || defined(__VSE__)\n/*\n  IBM 360 & 370 use \"HEX\" floating point\n  float is 32 bits, double & long double are 64 bit.\n  Although some models can do 128 bit (actually 120 bit)\n  GCC does not implement this and \"long double\" is same as \"double\"\n*/\n\n/* rounding direction is unpredictable */\n#define FLT_ROUNDS 0\n\n/* Floating point is HEX so RADIX is base 16 */\n#define FLT_RADIX 16\n\n/* Note FLT_RADIX is 16 these are smaller than normal*/\n#define FLT_MANT_DIG 6\n#define DBL_MANT_DIG 14\n/* don't use 128 bit floats so this is still 14 */\n#define LDBL_MANT_DIG 14\n\n\n/* As IBM uses hex float with \"wobbling precision\" these are approximate */\n#define FLT_DIG 7\n#define DBL_DIG 15\n#define LDBL_DIG 15\n\n\n#define FLT_MIN_EXP (-64)\n#define DBL_MIN_EXP (-64)\n#define LDBL_MIN_EXP (-64)\n\n#define FLT_MIN_10_EXP (-78)\n#define DBL_MIN_10_EXP (-78)\n#define LDBL_MIN_10_EXP (-78)\n\n#define FLT_MAX_EXP 63\n#define DBL_MAX_EXP 63\n#define LDBL_MAX_EXP 63\n\n#define FLT_MAX_10_EXP 75\n#define DBL_MAX_10_EXP 75\n#define LDBL_MAX_10_EXP 75\n\n/*\n  This is a temporary fiddle to get round bug in GCC\n  scanning of ASCII to Floats.\n*/\ntypedef union {\n    unsigned short _HexVal\u00dd4\u00a8;\n    double _Dval;\n    float  _Fval;\n    long _Lval;\n} _HexFloat;\n\nstatic _HexFloat _FltMax =  {{0x7fff, 0xffff ,0xffff ,0xffff}};\nstatic _HexFloat _FltMin =  {{0x0010, 0x0000 ,0x0000 ,0x0000}};\nstatic _HexFloat _DblMax =  {{0x7fff ,0xffff ,0xffff ,0xffff}};\nstatic _HexFloat _DblMin =  {{0x0010 ,0x0000 ,0x0000 ,0x0000}};\nstatic _HexFloat _FltEps =  {{0x3C10 ,0x0000 ,0x0000 ,0x0000}};\nstatic _HexFloat _DblEps =  {{0x3410 ,0x0000 ,0x0000 ,0x0000}};\n\n#define FLT_MAX _FltMax._Fval\n#define DBL_MAX _DblMax._Dval\n#define LDBL_MAX _DblMax._Lval\n\n#define FLT_MIN _FltMin._Fval\n#define DBL_MIN _DblMin._Fval\n#define LDBL_MIN _DblMin._Fval\n\n#define FLT_EPSILON _FltEps._Fval\n#define DBL_EPSILON _DblEps._Fval\n#define LDBL_EPSILON _DblEps._Fval\n\n\n\n#else\n/*\n original stuff from Paul for IEEE maths\n*/\n\n#define FLT_ROUNDS 1\n#define FLT_RADIX 2\n#define FLT_MANT_DIG 24\n#define DBL_MANT_DIG 53\n#define LDBL_MANT_DIG 53\n#define FLT_DIG 6\n#define DBL_DIG 10\n#define LDBL_DIG 10\n#define FLT_MIN_EXP -125\n#define DBL_MIN_EXP -1021\n#define LDBL_MIN_EXP -1021\n#define FLT_MIN_10_EXP -37\n#define DBL_MIN_10_EXP -37\n#define LDBL_MIN_10_EXP -37\n#define FLT_MAX_EXP +128\n#define DBL_MAX_EXP +1024\n#define LDBL_MAX_EXP +1024\n#define FLT_MAX_10_EXP +37\n#define DBL_MAX_10_EXP +37\n#define LDBL_MAX_10_EXP +37\n#define FLT_MAX 1E+37\n#define DBL_MAX 1E+37\n#define LDBL_MAX 1E+37\n#define FLT_EPSILON 1E-5\n#define DBL_EPSILON 1E-9\n#define LDBL_EPSILON 1E-9\n#define FLT_MIN 1E-37\n#define DBL_MIN 1E-37\n#define LDBL_MIN 1E-37\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIMITS": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  limits.h - limits header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __LIMITS_INCLUDED\n#define __LIMITS_INCLUDED\n\n#define CHAR_BIT 8\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n#define UCHAR_MAX 255\n#if ('\\x80' < 0)\n#define CHAR_MIN -128\n#define CHAR_MAX 127\n#else\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n#endif\n#define MB_LEN_MAX 1\n#define SHRT_MIN (-SHRT_MAX-1)\n#define SHRT_MAX 32767\n#define USHRT_MAX ((unsigned short)65535U)\n\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__VSE__) \\\n    || defined(__CMS__) || defined(__WIN32__) || defined(__gnu_linux__))\n#define INT_MIN (-INT_MAX-1)\n#define INT_MAX 21\n#define UINT_MAX 4294967295U\n#endif\n\n#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\n#define INT_MIN (-INT_MAX-1)\n#define INT_MAX 32767\n#define UINT_MAX 65535U\n#endif\n\n#define LONG_MIN (-LONG_MAX-1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 4294967295UL\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOCALE": {"ttr": 267, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  locale.h - locale header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __LOCALE_INCLUDED\n#define __LOCALE_INCLUDED\n\nstruct lconv {\n    char *decimal_point;\n    char *thousands_sep;\n    char *grouping;\n    char *int_curr_symbol;\n    char *currency_symbol;\n    char *mon_decimal_point;\n    char *mon_thousands_sep;\n    char *mon_grouping;\n    char *positive_sign;\n    char *negative_sign;\n    char int_frac_digits;\n    char frac_digits;\n    char p_cs_precedes;\n    char p_sep_by_space;\n    char n_cs_precedes;\n    char n_sep_by_space;\n    char p_sign_posn;\n    char n_sign_posn;\n};\n\n#define NULL ((void *)0)\n#define LC_ALL 1\n#define LC_COLLATE 2\n#define LC_CTYPE 3\n#define LC_MONETARY 4\n#define LC_NUMERIC 5\n#define LC_TIME 6\n\nchar *setlocale(int category, const char *locale);\nstruct lconv *localeconv(void);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MATH": {"ttr": 269, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  math.h - math header file.                                       */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __MATH_INCLUDED\n#define __MATH_INCLUDED\n\n/*\n  Some constants - at present these are only defined for IBM\n*/\n#if defined(__MVS__) || defined (__CMS__) || defined(__VSE__)\n/*\n This is about the nearest thing we can get to inf wthout\n*/\n#define HUGE_VAL 9.999999999999999999999E72\n\n#else\n\n#define HUGE_VAL 9.999999999999999999999E72\n\n#endif\n\ndouble ceil(double x);\ndouble fabs(double x);\ndouble floor(double x);\ndouble fmod(double x, double y);\n\n/* unimplemented: */\n\n\ndouble atan2(double y, double x);\ndouble frexp(double value, int *exp);\ndouble ldexp(double x, int exp);\ndouble modf(double value, double *iptr);\n\n/*\n  Implemented by d.wade - April 2006\n*/\n\ndouble pow(double x, double y);\ndouble sqrt(double x);\ndouble acos(double x);\ndouble asin(double x);\ndouble atan(double x);\ndouble cos(double x);\ndouble sin(double x);\ndouble tan(double x);\ndouble cosh(double x);\ndouble sinh(double x);\ndouble tanh(double x);\ndouble exp(double x);\ndouble log(double x);\ndouble log10(double x);\n\n\n#ifdef __WATCOMC__\n#pragma intrinsic(cos, sin, tan, exp, log, log10, sqrt)\n#endif\n\n#ifdef __IBMC__\ndouble _Builtin __fabs(double x);\n#define fabs(x) (__fabs((x)))\ndouble _Builtin __fsin(double x);\n#define sin(x) (__fsin((x)))\ndouble _Builtin __fcos(double x);\n#define cos(x) (__fcos((x)))\ndouble _Builtin __fptan(double x);\n#define tan(x) (__fptan((x)))\ndouble _Builtin __fpatan(double x);\n#define atan(x) (__fpatan((x)))\ndouble _Builtin __facos(double x);\n#define acos(x) (__facos((x)))\ndouble _Builtin __fasin(double x);\n#define asin(x) (__fasin((x)))\ndouble _Builtin __fsqrt(double x);\n#define sqrt(x) (__fsqrt((x)))\n#endif\n\n#ifdef __BORLANDC__\ndouble __sin__(double x);\n#define sin(x) (__sin__((x)))\ndouble __cos__(double x);\n#define cos(x) (__cos__((x)))\n#endif\n\n#endif\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVSSUPA": {"ttr": 271, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#include <stddef.h>\n\n#pragma linkage(__aopen, OS)\nvoid *__aopen(const char *ddname, int *mode, int *recfm,\n              int *lrecl, int *blksize, void **asmbuf, const char *member);\n#pragma linkage(__aread, OS)\nint __aread(void *handle, void *buf, size_t *len);\n#pragma linkage(__awrite, OS)\nint __awrite(void *handle, unsigned char **buf, size_t *sz);\n#pragma linkage(__aclose, OS)\nvoid __aclose(void *handle);\n#pragma linkage(__getclk, OS)\nunsigned int __getclk(void *buf);\n#pragma linkage(__gettz, OS)\nint __gettz(void);\n#pragma linkage(__getm, OS)\nvoid *__getm(size_t sz);\n#pragma linkage(__freem, OS)\nvoid __freem(void *ptr);\n\n#pragma linkage(__dynal, OS)\nint __dynal(size_t ddn_len, char *ddn, size_t dsn_len, char *dsn);\n\n#pragma linkage(__idcams, OS)\nint __idcams(size_t len, char *data);\n\n#pragma linkage(__system, OS)\n#ifdef MUSIC\nint __system(int len, const char *command);\nint __textlc(void);\nint __svc99(void *rb);\n#else\nint __system(int req_type,\n             size_t pgm_len,\n             char *pgm,\n             size_t parm_len,\n             char *parm);\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SETJMP": {"ttr": 273, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  setjmp.h - setjmp header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __SETJMP_INCLUDED\n#define __SETJMP_INCLUDED\n\ntypedef struct {\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n    int regs\u00dd15\u00a8;\n#elif defined(__WIN32__) || defined(__32BIT__) || defined(__OS2__) \\\n    || defined(__gnu_linux__)\n    int ebx;\n    int ecx;\n    int edx;\n    int edi;\n    int esi;\n    int esp;\n    int ebp;\n    int retaddr;\n#elif defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC)\n    int bx;\n    int cx;\n    int dx;\n    int di;\n    int si;\n    int sp;\n    int bp;\n    void *retaddr;\n    int ds;\n    int es;\n#endif\n    int retval;\n} jmp_buf\u00dd1\u00a8;\n\nint __setj(jmp_buf env);\n#define setjmp(x) (__setj(x))\nvoid longjmp(jmp_buf env, int val);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SIGNAL": {"ttr": 275, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  signal.h - signal header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __SIGNAL_INCLUDED\n#define __SIGNAL_INCLUDED\n\ntypedef int sig_atomic_t;\n\nvoid __sigdfl(int sig);\nvoid __sigerr(int sig);\nvoid __sigign(int sig);\n\n#define SIG_DFL __sigdfl\n#define SIG_ERR __sigerr\n#define SIG_IGN __sigign\n\n#define SIGABRT 1\n#define SIGFPE 2\n#define SIGILL 3\n#define SIGINT 4\n#define SIGSEGV 5\n#define SIGTERM 6\n\nvoid (*signal(int sig, void (*func)(int)))(int);\nint raise(int sig);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STDARG": {"ttr": 277, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdarg.h - stdarg header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDARG_INCLUDED\n#define __STDARG_INCLUDED\n\n/* don't use builtins on MVS until they have been implemented */\n#if defined(__GNUC__) && !defined(__MVS__) && !defined(__CMS__) \\\n    && !defined(__VSE__)\n\n#ifndef __GNUC_VA_LIST\n#define __GNUC_VA_LIST\ntypedef __builtin_va_list __gnuc_va_list;\n#endif\n\ntypedef __gnuc_va_list va_list;\n\n#define va_start(v,l)   __builtin_va_start(v,l)\n#define va_end(v)       __builtin_va_end(v)\n#define va_arg(v,l)     __builtin_va_arg(v,l)\n#if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L\n#define va_copy(d,s)    __builtin_va_copy(d,s)\n#endif\n#define __va_copy(d,s)  __builtin_va_copy(d,s)\n\n#else /* __GNUC__ */\n\ntypedef char * va_list;\n\n#define va_start(ap, parmN) ap = (char *)&parmN + 4\n#define va_arg(ap, type) *(type *)(ap += sizeof(type), ap - sizeof(type))\n#define va_end(ap) ap = 0\n\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STDDEF": {"ttr": 279, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stddef.h - assert header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDDEF_INCLUDED\n#define __STDDEF_INCLUDED\n\ntypedef int ptrdiff_t;\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__CMS__) || defined(__VSE__))\ntypedef unsigned long size_t;\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC) \\\n    || defined(__WIN32__) || defined(__gnu_linux__))\ntypedef unsigned int size_t;\n#endif\n#endif\n#ifndef __WCHAR_T_DEFINED\n#define __WCHAR_T_DEFINED\n#ifndef _WCHAR_T_DEFINED\n#define _WCHAR_T_DEFINED\n#endif\ntypedef char wchar_t;\n#endif\n\n#define NULL ((void *)0)\n#define offsetof(x, y) (size_t)&(((x *)0)->y)\n\n#ifdef __PDPCLIB_DLL\n#define __PDPCLIB_API__ __declspec(dllexport)\n#define __MAIN_FP__\n#else\n#define __PDPCLIB_API__\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STDIO": {"ttr": 281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdio.h - stdio header file                                      */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDIO_INCLUDED\n#define __STDIO_INCLUDED\n\n/* Perhaps should copy these definitions in instead */\n#include <stdarg.h>\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__CMS__) || defined(__VSE__))\ntypedef unsigned long size_t;\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC) \\\n    || defined(__WIN32__) || defined(__gnu_linux__))\ntypedef unsigned int size_t;\n#endif\n#endif\n\n/*\n    What we have is an internal buffer, which is 8 characters\n    longer than the actually used buffer.  E.g. say BUFSIZ is\n    512 bytes, then we actually allocate 520 bytes.  The first\n    2 characters will be junk, the next 2 characters set to NUL,\n    for protection against some backward-compares.  The fourth-last\n    character is set to '\\n', to protect against overscan.  The\n    last 3 characters will be junk, to protect against memory\n    violation.  intBuffer is the internal buffer, but everyone refers\n    to fbuf, which is actually set to the &intBuffer\u00dd4\u00a8.  Also,\n    szfbuf is the size of the \"visible\" buffer, not the internal\n    buffer.  The reason for the 2 junk characters at the beginning\n    is to align the buffer on a 4-byte boundary.\n\n    Here is what memory would look like after an fwrite of \"ABC\"\n    to an MVS LRECL=80, RECFM=F dataset:\n\n    intbuffer: x'50000'\n    fbuf:      x'50004'\n    upto:      x'50007'\n    endbuf:    x'58004'\n\n    x'50004' = x'C1'\n    x'50005' = x'C2'\n    x'50006' = x'C3'\n*/\n\ntypedef struct\n{\n#if (defined(__OS2__) || defined(__32BIT__))\n    unsigned long hfile;  /* OS/2 file handle */\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))\n    int hfile; /* dos file handle */\n#elif defined(__WIN32__)\n    void *hfile;\n#elif defined(__gnu_linux__)\n    int hfile;\n#endif\n#if (defined(__MVS__) || defined(__CMS__) || defined(__VSE__))\n    void *hfile;\n    void *asmbuf;\n    int recfm;\n    int style;\n    int lrecl;\n    int blksize;\n    char ddname\u00dd9\u00a8;\n    char pdsmem\u00dd9\u00a8;\n    int reallyu;    /* 1 = this is really a RECFM=U file */\n    int reallyt;    /* 1 = this is really a text file */\n    int dynal;      /* 1 = this file was dynamically allocated */\n    int line_buf;   /* 1 = this file is unit record device */\n#endif\n#if defined(__VSE__)\n    int vse_punch;  /* 1 = this is writing to a VSE library */\n    char *vselupto; /* where we are up to in the internal buffer */\n    char *vselend; /* end of the internal buffer */\n#endif\n    int quickBin;  /* 1 = do DosRead NOW!!!! */\n    int quickText; /* 1 = quick text mode */\n    int textMode; /* 1 = text mode, 0 = binary mode */\n    int intFno;   /* internal file number */\n    unsigned long bufStartR; /* buffer start represents, e.g. if we\n        have read in 3 buffers, each of 512 bytes, and we are\n        currently reading from the 3rd buffer, then the first\n        character in the buffer would be 1024, so that is what is\n        put in bufStartR. */\n    char *fbuf;     /* file buffer - this is what all the routines\n                       look at. */\n    size_t szfbuf;  /* size of file buffer (the one that the routines\n                       see, and the user allocates, and what is actually\n                       read in from disk) */\n    char *upto;     /* what character is next to read from buffer */\n    char *endbuf;   /* pointer PAST last character in buffer, ie it\n                       points to the '\\n' in the internal buffer */\n    int errorInd;   /* whether an error has occurred on this file */\n    int eofInd;     /* whether EOF has been reached on this file */\n    int ungetCh;    /* character pushed back, -1 if none */\n    int bufTech;    /* buffering technique, _IOFBF etc */\n    char *intBuffer; /* internal buffer */\n    int noNl;       /* When doing gets, we don't copy NL */\n    int mode;       /* __WRITE_MODE or __READ_MODE */\n    int update;     /* Is file update (read + write)? */\n    int theirBuffer; /* Is the buffer supplied by them? */\n    int permfile;   /* Is this stdin/stdout/stderr? */\n    int isopen;     /* Is this file open? */\n    char modeStr\u00dd4\u00a8; /* 2nd parameter to fopen */\n} FILE;\n\ntypedef unsigned long fpos_t;\n\n#define NULL ((void *)0)\n#define FILENAME_MAX 260\n#define FOPEN_MAX 256\n#define _IOFBF 1\n#define _IOLBF 2\n#define _IONBF 3\n\n/*#define BUFSIZ 409600*/\n/* #define BUFSIZ 8192 */\n/*#define BUFSIZ 5120*/\n\n#if defined(__MVS__) || defined(__VSE__)\n/* set it to maximum possible LRECL to simplify processing */\n/* also add in room for a RDW and dword align it just to be\n   on the safe side */\n#define BUFSIZ 32768\n#elif defined(__CMS__)\n/* similar considerations for CMS as MVS */\n#define BUFSIZ 65544\n#else\n#define BUFSIZ 6144\n#endif\n/* #define BUFSIZ 10 */\n/* #define BUFSIZ 512 */\n#define EOF -1\n#define L_tmpnam FILENAME_MAX\n#define TMP_MAX 25\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n#define __NFILE (FOPEN_MAX - 3)\n#define __WRITE_MODE 1\n#define __READ_MODE 2\n\n#define __RECFM_F 0\n#define __RECFM_V 1\n#define __RECFM_U 2\n\n#if 0\nextern FILE *stdin;\nextern FILE *stdout;\nextern FILE *stderr;\n\nextern FILE *__userFiles\u00dd__NFILE\u00a8;\n#endif\n\nFILE **__gtin(void);\nFILE **__gtout(void);\nFILE **__gterr(void);\n\n#define stdin (*(__gtin()))\n#define stdout (*(__gtout()))\n#define stderr (*(__gterr()))\n\n#if defined(__VSE__)\nextern FILE *__stdpch;\n#endif\n\nint printf(const char *format, ...);\nFILE *fopen(const char *filename, const char *mode);\nint fclose(FILE *stream);\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\nint fputc(int c, FILE *stream);\nint fputs(const char *s, FILE *stream);\nint fprintf(FILE *stream, const char *format, ...);\nint vfprintf(FILE *stream, const char *format, va_list arg);\nint remove(const char *filename);\nint rename(const char *old, const char *newnam);\nint sprintf(char *s, const char *format, ...);\nint vsprintf(char *s, const char *format, va_list arg);\nchar *fgets(char *s, int n, FILE *stream);\nint ungetc(int c, FILE *stream);\nint fgetc(FILE *stream);\nint fseek(FILE *stream, long int offset, int whence);\nlong int ftell(FILE *stream);\nint fsetpos(FILE *stream, const fpos_t *pos);\nint fgetpos(FILE *stream, fpos_t *pos);\nvoid rewind(FILE *stream);\nvoid clearerr(FILE *stream);\nvoid perror(const char *s);\nint setvbuf(FILE *stream, char *buf, int mode, size_t size);\nint setbuf(FILE *stream, char *buf);\nFILE *freopen(const char *filename, const char *mode, FILE *stream);\nint fflush(FILE *stream);\nchar *tmpnam(char *s);\nFILE *tmpfile(void);\nint fscanf(FILE *stream, const char *format, ...);\nint scanf(const char *format, ...);\nint sscanf(const char *s, const char *format, ...);\nchar *gets(char *s);\nint puts(const char *s);\n\n#ifndef __POWERC\nint getchar(void);\nint putchar(int c);\nint getc(FILE *stream);\nint putc(int c, FILE *stream);\nint feof(FILE *stream);\nint ferror(FILE *stream);\n#endif\n\n#define getchar() (getc(stdin))\n#define putchar(c) (putc((c), stdout))\n#define getc(stream) (fgetc((stream)))\n#define putc(c, stream) (fputc((c), (stream)))\n#define feof(stream) ((stream)->eofInd)\n#define ferror(stream) ((stream)->errorInd)\n\n#endif\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STDLIB": {"ttr": 284, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  stdlib.h - stdlib header file                                    */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STDLIB_INCLUDED\n#define __STDLIB_INCLUDED\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__CMS__) || defined(__VSE__))\ntypedef unsigned long size_t;\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC) \\\n    || defined(__WIN32__) || defined(__gnu_linux__))\ntypedef unsigned int size_t;\n#endif\n#endif\n#ifndef __WCHAR_T_DEFINED\n#define __WCHAR_T_DEFINED\n#ifndef _WCHAR_T_DEFINED\n#define _WCHAR_T_DEFINED\n#endif\ntypedef char wchar_t;\n#endif\ntypedef struct { int quot; int rem; } div_t;\ntypedef struct { long int quot; long int rem; } ldiv_t;\n\n#define NULL ((void *)0)\n#define EXIT_SUCCESS 0\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n#define EXIT_FAILURE 12\n#else\n#define EXIT_FAILURE 1\n#endif\n#define RAND_MAX 32767\n#define MB_CUR_MAX 1\n#define __NATEXIT 32\n\nextern void (*__userExit\u00dd__NATEXIT\u00a8)(void);\n\nvoid *malloc(size_t size);\nvoid *calloc(size_t nmemb, size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid free(void *ptr);\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\nvoid abort(void) __attribute__((noreturn));\nvoid exit(int status) __attribute__((noreturn));\n#else\nvoid abort(void);\nvoid exit(int status);\n#endif\nvoid qsort(void *, size_t, size_t,\n                           int (*)(const void *, const void *));\nvoid srand(unsigned int seed);\nint rand(void);\ndouble atof(const char *nptr);\ndouble strtod(const char *nptr, char **endptr);\nint atoi(const char *nptr);\nlong int atol(const char *nptr);\nlong int strtol(const char *nptr, char **endptr, int base);\nunsigned long int strtoul(const char *nptr, char **endptr, int base);\nint mblen(const char *s, size_t n);\nint mbtowc(wchar_t *pwc, const char *s, size_t n);\nint wctomb(char *s, wchar_t wchar);\nsize_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);\nsize_t wcstombs(char *s, const wchar_t *pwcs, size_t n);\nint abs(int j);\ndiv_t div(int numer, int denom);\nlong int labs(long int j);\nldiv_t ldiv(long int numer, long int denom);\nint atexit(void (*func)(void));\nchar *getenv(const char *name);\nint system(const char *string);\nvoid *bsearch(const void *key, const void *base,\n              size_t nmemb, size_t size,\n              int (*compar)(const void *, const void *));\n\n#ifdef __WATCOMC__\n#pragma intrinsic (abs,labs,div,ldiv)\n#endif\n\n#ifdef __IBMC__\nint _Builtin __abs(int j);\n#define abs(j) (__abs((j)))\nlong int _Builtin __labs(long int j);\n#define labs(j) (__labs((j)))\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STRING": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  string.h - string header file.                                   */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __STRING_INCLUDED\n#define __STRING_INCLUDED\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__CMS__) || defined(__VSE__))\ntypedef unsigned long size_t;\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC) \\\n    || defined(__WIN32__) || defined(__gnu_linux__))\ntypedef unsigned int size_t;\n#endif\n#endif\n\n#define NULL ((void *)0)\nvoid *memcpy(void *s1, const void *s2, size_t n);\nvoid *memmove(void *s1, const void *s2, size_t n);\nchar *strcpy(char *s1, const char *s2);\nchar *strncpy(char *s1, const char *s2, size_t n);\nchar *strcat(char *s1, const char *s2);\nchar *strncat(char *s1, const char *s2, size_t n);\nint memcmp(const void *s1, const void *s2, size_t n);\nint strcmp(const char *s1, const char *s2);\nint strcoll(const char *s1, const char *s2);\nint strncmp(const char *s1, const char *s2, size_t n);\nsize_t strxfrm(char *s1, const char *s2, size_t n);\nvoid *memchr(const void *s, int c, size_t n);\nchar *strchr(const char *s, int c);\nsize_t strcspn(const char *s1, const char *s2);\nchar *strpbrk(const char *s1, const char *s2);\nchar *strrchr(const char *s, int c);\nsize_t strspn(const char *s1, const char *s2);\nchar *strstr(const char *s1, const char *s2);\nchar *strtok(char *s1, const char *s2);\nvoid *memset(void *s, int c, size_t n);\nchar *strerror(int errnum);\nsize_t strlen(const char *s);\n\n#ifdef __WATCOMC__\n#ifdef __INLINE_FUNCTIONS__\n#pragma intrinsic(memchr, memcmp, memcpy, strcat, strcpy, strlen, strchr)\n#endif\n#endif\n\n#ifdef __IBMC__\nchar * _Builtin __strcat(char *s1, const char *s2);\n#define strcat(s1,s2) (__strcat((s1),(s2)))\nchar * _Builtin __strchr(const char *s, int c);\n#define strchr(s,c) (__strchr((s),(c)))\nint _Builtin __strcmp(const char *s1, const char *s2);\n#define strcmp(s1,s2) (__strcmp((s1),(s2)))\nint _Builtin __strcpy(char *s1, const char *s2);\n#define strcpy(s1,s2) (__strcpy((s1),(s2)))\nsize_t _Builtin __strlen(const char *s);\n#define strlen(s) (__strlen((s)))\nchar * _Builtin __strncat(char *s1, const char *s2, size_t n);\n#define strncat(s1,s2,n) (__strncat((s1),(s2),(n)))\nint _Builtin __strncmp(const char *s1, const char *s2, size_t n);\n#define strncmp(s1,s2,n) (__strncmp((s1),(s2),(n)))\nchar * _Builtin __strncpy(char *s1, const char *s2, size_t n);\n#define strncpy(s1,s2,n) (__strncpy((s1),(s2),(n)))\nchar * _Builtin __strrchr(const char *s, int c);\n#define strrchr(s,c) (__strrchr((s),(c)))\nvoid * _Builtin __memcpy(void *s1, const void *s2, size_t n);\n#define memcpy(a,b,c) (__memcpy((a),(b),(c)))\nvoid * _Builtin __memchr(const void *s, int c, size_t n);\n#define memchr(s,c,n) (__memchr((s),(c),(n)))\nint _Builtin __memcmp(const void *s1, const void *s2, size_t n);\n#define memcmp(s1,s2,n) (__memcmp((s1),(s2),(n)))\nvoid * _Builtin __memset(void *s, int c, size_t n);\n#define memset(s,c,n) (__memset((s),(c),(n)))\nvoid * _Builtin __memmove(void *s1, const void *s2, size_t n);\n#define memmove(s1,s2,n) (__memmove((s1),(s2),(n)))\n#endif\n\n#if defined (__GNUC__) && __GNUC__ >= 3\n#define memcpy(a,b,c) (__builtin_memcpy((a),(b),(c)))\n#define memcmp(s1,s2,n) (__builtin_memcmp((s1),(s2),(n)))\n#endif\n\n/* We don't activate these GCC builtins, because they\n   normally resort to a call to the normal function,\n   and when they do, they generate slightly worse\n   code! Also, they appear to be buggy on MVS. */\n\n#if 0\n#define strcat(s1,s2) (__builtin_strcat((s1),(s2)))\n#define strchr(s,c) (__builtin_strchr((s),(c)))\n#define strcmp(s1,s2) (__builtin_strcmp((s1),(s2)))\n#define strcpy(s1,s2) (__builtin_strcpy((s1),(s2)))\n#define strlen(s) (__builtin_strlen((s)))\n#define strncat(s1,s2,n) (__builtin_strncat((s1),(s2),(n)))\n#define strncmp(s1,s2,n) (__builtin_strncmp((s1),(s2),(n)))\n#define strncpy(s1,s2,n) (__builtin_strncpy((s1),(s2),(n)))\n#define strrchr(s,c) (__builtin_strrchr((s),(c)))\n#define memset(s,c,n) (__builtin_memset((s),(c),(n)))\n#define strstr(s1,s2) (__builtin_strstr((s1),(s2)))\n#define strpbrk(s1,s2) (__builtin_strpbrk((s1),(s2)))\n#define strspn(s1,s2) (__builtin_strspn((s1),(s2)))\n#define strcspn(s1,s2) (__builtin_strcspn((s1),(s2)))\n#endif\n\n#ifdef __BORLANDC__\n#ifdef __INLINE_FUNCTIONS__\nvoid *__memcpy__(void *s1, const void *s2, size_t n);\n#define memcpy(a,b,c) (__memcpy__((a),(b),(c)))\nvoid *__memchr__(const void *s, int c, size_t n);\n#define memchr(s,c,n) (__memchr__((s),(c),(n)))\nint __memcmp__(const void *s1, const void *s2, size_t n);\n#define memcmp(s1,s2,n) (__memcmp__((s1),(s2),(n)))\nvoid *__memset__(void *s, int c, size_t n);\n#define memset(s,c,n) (__memset__((s),(c),(n)))\nchar *__strcat__(char *s1, const char *s2);\n#define strcat(s1,s2) (__strcat__((s1),(s2)))\nchar *__strchr__(const char *s, int c);\n#define strchr(s,c) (__strchr__((s),(c)))\nint __strcmp__(const char *s1, const char *s2);\n#define strcmp(s1,s2) (__strcmp__((s1),(s2)))\nchar *__strcpy__(char *s1, const char *s2);\n#define strcpy(s1,s2) (__strcpy__((s1),(s2)))\nsize_t __strlen__(const char *s);\n#define strlen(s) (__strlen__((s)))\nchar *__strncat__(char *s1, const char *s2, size_t n);\n#define strncat(s1,s2,n) (__strncat__((s1),(s2),(n)))\nint __strncmp__(const char *s1, const char *s2, size_t n);\n#define strncmp(s1,s2,n) (__strncmp__((s1),(s2),(n)))\nchar *__strncpy__(char *s1, const char *s2, size_t n);\n#define strncpy(s1,s2,n) (__strncpy__((s1),(s2),(n)))\nchar *__strrchr__(const char *s, int c);\n#define strrchr(s,c) (__strrchr__((s),(c)))\n#endif\n#endif\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TIME": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*********************************************************************/\n/*                                                                   */\n/*  This Program Written by Paul Edwards.                            */\n/*  Released to the Public Domain                                    */\n/*                                                                   */\n/*********************************************************************/\n/*********************************************************************/\n/*                                                                   */\n/*  time.h - time header file.                                       */\n/*                                                                   */\n/*********************************************************************/\n\n#ifndef __TIME_INCLUDED\n#define __TIME_INCLUDED\n\n#define CLOCKS_PER_SEC 1000\n#define NULL ((void *)0)\n\ntypedef unsigned int clock_t;\n\n#ifndef __SIZE_T_DEFINED\n#define __SIZE_T_DEFINED\n#if (defined(__OS2__) || defined(__32BIT__) || defined(__MVS__) \\\n    || defined(__CMS__) || defined(__VSE__))\ntypedef unsigned long size_t;\n#elif (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC) \\\n    || defined(__WIN32__) || defined(__gnu_linux__))\ntypedef unsigned int size_t;\n#endif\n#endif\n\ntypedef unsigned long time_t;\n\nstruct tm\n{\n    int tm_sec;\n    int tm_min;\n    int tm_hour;\n    int tm_mday;\n    int tm_mon;\n    int tm_year;\n    int tm_wday;\n    int tm_yday;\n    int tm_isdst;\n};\n\ntime_t time(time_t *timer);\nclock_t clock(void);\ndouble difftime(time_t time1, time_t time0);\ntime_t mktime(struct tm *timeptr);\nchar *asctime(const struct tm *timeptr);\nchar *ctime(const time_t *timer);\nstruct tm *gmtime(const time_t *timer);\nstruct tm *localtime(const time_t *timer);\nsize_t strftime(char *s, size_t maxsize,\n                const char *format, const struct tm *timeptr);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT853/CBT.V500.FILE853.PDS/PDPINC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT853/CBT.V500.FILE853.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}