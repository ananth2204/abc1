{"INMR01": {"INMLRECL": 80, "INMFNODE": "ORIGNODE", "INMFUID": "ORIGUID", "INMTNODE": "DESTNODE", "INMTUID": "DESTUID", "INMFTIME": "20110613192457000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3409588, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 6233, "INMRECFM": "VB", "INMDIR": 44, "INMDSNAM": "GCC.INCLUDE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3409588, "INMDSORG": "PS", "INMLRECL": 6249, "INMBLKSZ": 6253, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3409588, "INMDSORG": "PS", "INMLRECL": 255, "INMRECFM": "?"}}, "file": {"GCC.INCLUDE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 6233, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 6253, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0, "DS1REFD": "000000", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x00\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x00\\x00'", "DS1TRBAL": "b''"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0cvD\\x04\\xa5\\x0c\\xd8'", "b'X\\x00/\\xb0\\x00\\x00\\x00\\x87\\x00\\n\\x00\\x8b\\x00\\x07\\x00:'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@HEADER": {"ttr": 13318, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "builtin-attrs.def builtina.h\nbuiltin-types.def builtint.h\nbuiltins.def builtind.h\nc-common.def ccommond.h\ndiagnostic.def diagndef.h\nmachmode.def machmodd.h\nparams.def paramsd.h\npredict.def predictd.h\nrtl.def rtld.h\nstab.def stabd.h\ntimevar.def timevard.h\ntree.def treed.h\ninsn-constants.h i-constants.h\nlanghooks-def.h langhdef.h\nhosthooks-def.h hosthdef.h\ngt-dwarf2asm.h gt-dwasm.h\ngcov-io.c gcovioc.h\nc-pretty-print.h c-pretty-prin.h\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ACCONFIG": {"ttr": 46, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define to `unsigned long' if <sys/types.h> doesn't define.  */\n#undef uintptr_t\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALLOC@PO": {"ttr": 258, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Functions to support a pool of allocatable objects\n   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004\n   Free Software Foundation, Inc.\n   Contributed by Daniel Berlin <dan@cgsoftware.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n#ifndef ALLOC_POOL_H\n#define ALLOC_POOL_H\n\ntypedef unsigned long ALLOC_POOL_ID_TYPE;\n\ntypedef struct alloc_pool_list_def\n{\n  struct alloc_pool_list_def *next;\n}\n *alloc_pool_list;\n\ntypedef struct alloc_pool_def\n{\n  const char *name;\n#ifdef ENABLE_CHECKING\n  ALLOC_POOL_ID_TYPE id;\n#endif\n  size_t elts_per_block;\n  alloc_pool_list free_list;\n  size_t elts_allocated;\n  size_t elts_free;\n  size_t blocks_allocated;\n  alloc_pool_list block_list;\n  size_t block_size;\n  size_t elt_size;\n}\n *alloc_pool;\n\nextern alloc_pool create_alloc_pool (const char *, size_t, size_t);\nextern void free_alloc_pool (alloc_pool);\nextern void *pool_alloc (alloc_pool);\nextern void pool_free (alloc_pool, void *);\nextern void dump_alloc_pool_statistics (void);\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ANSIDECL": {"ttr": 260, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* ANSI and traditional C compatability macros\n   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001\n   Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* ANSI and traditional C compatibility macros\n\n   ANSI C is assumed if __STDC__ is #defined.\n\n   Macro\t\tANSI C definition\tTraditional C definition\n   -----\t\t---- - ----------\t----------- - ----------\n   ANSI_PROTOTYPES\t1\t\t\tnot defined\n   PTR\t\t\t`void *'\t\t`char *'\n   PTRCONST\t\t`void *const'\t\t`char *'\n   LONG_DOUBLE\t\t`long double'\t\t`double'\n   const\t\tnot defined\t\t`'\n   volatile\t\tnot defined\t\t`'\n   signed\t\tnot defined\t\t`'\n   VA_START(ap, var)\tva_start(ap, var)\tva_start(ap)\n\n   Note that it is safe to write \"void foo();\" indicating a function\n   with no return value, in all K+R compilers we have been able to test.\n\n   For declaring functions with prototypes, we also provide these:\n\n   PARAMS ((prototype))\n   -- for functions which take a fixed number of arguments.  Use this\n   when declaring the function.  When defining the function, write a\n   K+R style argument list.  For example:\n\n\tchar *strcpy PARAMS ((char *dest, char *source));\n\t...\n\tchar *\n\tstrcpy (dest, source)\n\t     char *dest;\n\t     char *source;\n\t{ ... }\n\n\n   VPARAMS ((prototype, ...))\n   -- for functions which take a variable number of arguments.  Use\n   PARAMS to declare the function, VPARAMS to define it.  For example:\n\n\tint printf PARAMS ((const char *format, ...));\n\t...\n\tint\n\tprintf VPARAMS ((const char *format, ...))\n\t{\n\t   ...\n\t}\n\n   For writing functions which take variable numbers of arguments, we\n   also provide the VA_OPEN, VA_CLOSE, and VA_FIXEDARG macros.  These\n   hide the differences between K+R <varargs.h> and C89 <stdarg.h> more\n   thoroughly than the simple VA_START() macro mentioned above.\n\n   VA_OPEN and VA_CLOSE are used *instead of* va_start and va_end.\n   Immediately after VA_OPEN, put a sequence of VA_FIXEDARG calls\n   corresponding to the list of fixed arguments.  Then use va_arg\n   normally to get the variable arguments, or pass your va_list object\n   around.  You do not declare the va_list yourself; VA_OPEN does it\n   for you.\n\n   Here is a complete example:\n\n\tint\n\tprintf VPARAMS ((const char *format, ...))\n\t{\n\t   int result;\n\n\t   VA_OPEN (ap, format);\n\t   VA_FIXEDARG (ap, const char *, format);\n\n\t   result = vfprintf (stdout, format, ap);\n\t   VA_CLOSE (ap);\n\n\t   return result;\n\t}\n\n\n   You can declare variables either before or after the VA_OPEN,\n   VA_FIXEDARG sequence.  Also, VA_OPEN and VA_CLOSE are the beginning\n   and end of a block.  They must appear at the same nesting level,\n   and any variables declared after VA_OPEN go out of scope at\n   VA_CLOSE.  Unfortunately, with a K+R compiler, that includes the\n   argument list.  You can have multiple instances of VA_OPEN/VA_CLOSE\n   pairs in a single function in case you need to traverse the\n   argument list more than once.\n\n   For ease of writing code which uses GCC extensions but needs to be\n   portable to other compilers, we provide the GCC_VERSION macro that\n   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various\n   wrappers around __attribute__.  Also, __extension__ will be #defined\n   to nothing if it doesn't work.  See below.\n\n   This header also defines a lot of obsolete macros:\n   CONST, VOLATILE, SIGNED, PROTO, EXFUN, DEFUN, DEFUN_VOID,\n   AND, DOTS, NOARGS.  Don't use them.  */\n\n#ifndef\t_ANSIDECL_H\n#define _ANSIDECL_H\t1\n\n\n#ifdef PUREISO\n\n/* this builtin doesn't work on MVS */\n#define USE_C_ALLOCA 1\n\n#include \"unixio.h\"\n\n#ifndef NOSHORT\n#include \"mshort.h\"\n#endif\n\n#endif\n\n\n/* Every source file includes this file,\n   so they will all get the switch for lint.  */\n/* LINTLIBRARY */\n\n/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n   older preprocessors.  Thus we can't define something like this:\n\n#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n\nand then test \"#if HAVE_GCC_VERSION(2,7)\".\n\nSo instead we use the macro below and test it against specific values.  */\n\n/* This macro simplifies testing whether we are using gcc, and if it\n   is of a particular minimum version. (Both major & minor numbers are\n   significant.)  This macro will evaluate to 0 if we are not using\n   gcc at all.  */\n#ifndef GCC_VERSION\n#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n#endif /* GCC_VERSION */\n\n#if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32) || (defined(__alpha) && defined(__cplusplus))\n/* All known AIX compilers implement these things (but don't always\n   define __STDC__).  The RISC/OS MIPS compiler defines these things\n   in SVR4 mode, but does not define __STDC__.  */\n/* eraxxon@alumni.rice.edu: The Compaq C++ compiler, unlike many other\n   C++ compilers, does not define __STDC__, though it acts as if this\n   was so. (Verified versions: 5.7, 6.2, 6.3, 6.5) */\n\n#define ANSI_PROTOTYPES\t1\n#define PTR\t\tvoid *\n#define PTRCONST\tvoid *const\n#define LONG_DOUBLE\tlong double\n\n#define PARAMS(ARGS)\t\tARGS\n#define VPARAMS(ARGS)\t\tARGS\n#define VA_START(VA_LIST, VAR)\tva_start(VA_LIST, VAR)\n\n/* variadic function helper macros */\n/* \"struct Qdmy\" swallows the semicolon after VA_OPEN/VA_FIXEDARG's\n   use without inhibiting further decls and without declaring an\n   actual variable.  */\n#define VA_OPEN(AP, VAR)\t{ va_list AP; va_start(AP, VAR); { struct Qdmy\n#define VA_CLOSE(AP)\t\t} va_end(AP); }\n#define VA_FIXEDARG(AP, T, N)\tstruct Qdmy\n\n#undef const\n#undef volatile\n#undef signed\n\n/* inline requires special treatment; it's in C99, and GCC >=2.7 supports\n   it too, but it's not in C89.  */\n#undef inline\n#if __STDC_VERSION__ > 199901L\n/* it's a keyword */\n#else\n# if GCC_VERSION >= 2007\n#  define inline __inline__   /* __inline__ prevents -pedantic warnings */\n# else\n#  define inline  /* nothing */\n# endif\n#endif\n\n/* These are obsolete.  Do not use.  */\n#ifndef IN_GCC\n#define CONST\t\tconst\n#define VOLATILE\tvolatile\n#define SIGNED\t\tsigned\n\n#define PROTO(type, name, arglist)\ttype name arglist\n#define EXFUN(name, proto)\t\tname proto\n#define DEFUN(name, arglist, args)\tname(args)\n#define DEFUN_VOID(name)\t\tname(void)\n#define AND\t\t,\n#define DOTS\t\t, ...\n#define NOARGS\t\tvoid\n#endif /* ! IN_GCC */\n\n#else\t/* Not ANSI C.  */\n\n#undef  ANSI_PROTOTYPES\n#define PTR\t\tchar *\n#define PTRCONST\tPTR\n#define LONG_DOUBLE\tdouble\n\n#define PARAMS(args)\t\t()\n#define VPARAMS(args)\t\t(va_alist) va_dcl\n#define VA_START(va_list, var)\tva_start(va_list)\n\n#define VA_OPEN(AP, VAR)\t\t{ va_list AP; va_start(AP); { struct Qdmy\n#define VA_CLOSE(AP)\t\t\t} va_end(AP); }\n#define VA_FIXEDARG(AP, TYPE, NAME)\tTYPE NAME = va_arg(AP, TYPE)\n\n/* some systems define these in header files for non-ansi mode */\n#undef const\n#undef volatile\n#undef signed\n#undef inline\n#define const\n#define volatile\n#define signed\n#define inline\n\n#ifndef IN_GCC\n#define CONST\n#define VOLATILE\n#define SIGNED\n\n#define PROTO(type, name, arglist)\ttype name ()\n#define EXFUN(name, proto)\t\tname()\n#define DEFUN(name, arglist, args)\tname arglist args;\n#define DEFUN_VOID(name)\t\tname()\n#define AND\t\t;\n#define DOTS\n#define NOARGS\n#endif /* ! IN_GCC */\n\n#endif\t/* ANSI C.  */\n\n/* Define macros for some gcc attributes.  This permits us to use the\n   macros freely, and know that they will come into play for the\n   version of gcc in which they are supported.  */\n\n#if (GCC_VERSION < 2007)\n# define __attribute__(x)\n#endif\n\n/* Attribute __malloc__ on functions was valid as of gcc 2.96. */\n#ifndef ATTRIBUTE_MALLOC\n# if (GCC_VERSION >= 2096)\n#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n# else\n#  define ATTRIBUTE_MALLOC\n# endif /* GNUC >= 2.96 */\n#endif /* ATTRIBUTE_MALLOC */\n\n/* Attributes on labels were valid as of gcc 2.93. */\n#ifndef ATTRIBUTE_UNUSED_LABEL\n# if (GCC_VERSION >= 2093)\n#  define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED\n# else\n#  define ATTRIBUTE_UNUSED_LABEL\n# endif /* GNUC >= 2.93 */\n#endif /* ATTRIBUTE_UNUSED_LABEL */\n\n#ifndef ATTRIBUTE_UNUSED\n#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n#endif /* ATTRIBUTE_UNUSED */\n\n#ifndef ATTRIBUTE_NORETURN\n#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))\n#endif /* ATTRIBUTE_NORETURN */\n\n/* Attribute `nonnull' was valid as of gcc 3.3.  */\n#ifndef ATTRIBUTE_NONNULL\n# if (GCC_VERSION >= 3003)\n#  define ATTRIBUTE_NONNULL(m) __attribute__ ((__nonnull__ (m)))\n# else\n#  define ATTRIBUTE_NONNULL(m)\n# endif /* GNUC >= 3.3 */\n#endif /* ATTRIBUTE_NONNULL */\n\n/* Use ATTRIBUTE_PRINTF when the format specifier must not be NULL.\n   This was the case for the `printf' format attribute by itself\n   before GCC 3.3, but as of 3.3 we need to add the `nonnull'\n   attribute to retain this behavior.  */\n#ifndef ATTRIBUTE_PRINTF\n#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)\n#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)\n#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)\n#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)\n#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)\n#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)\n#endif /* ATTRIBUTE_PRINTF */\n\n/* Use ATTRIBUTE_NULL_PRINTF when the format specifier may be NULL.  A\n   NULL format specifier was allowed as of gcc 3.3.  */\n#ifndef ATTRIBUTE_NULL_PRINTF\n# if (GCC_VERSION >= 3003)\n#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))\n# else\n#  define ATTRIBUTE_NULL_PRINTF(m, n)\n# endif /* GNUC >= 3.3 */\n# define ATTRIBUTE_NULL_PRINTF_1 ATTRIBUTE_NULL_PRINTF(1, 2)\n# define ATTRIBUTE_NULL_PRINTF_2 ATTRIBUTE_NULL_PRINTF(2, 3)\n# define ATTRIBUTE_NULL_PRINTF_3 ATTRIBUTE_NULL_PRINTF(3, 4)\n# define ATTRIBUTE_NULL_PRINTF_4 ATTRIBUTE_NULL_PRINTF(4, 5)\n# define ATTRIBUTE_NULL_PRINTF_5 ATTRIBUTE_NULL_PRINTF(5, 6)\n#endif /* ATTRIBUTE_NULL_PRINTF */\n\n\n#ifndef ATTRIBUTE_ALIGNED_ALIGNOF\n# if (GCC_VERSION >= 3000)\n#  define ATTRIBUTE_ALIGNED_ALIGNOF(m) __attribute__ ((__aligned__ (__alignof__ (m))))\n# else\n#  define ATTRIBUTE_ALIGNED_ALIGNOF(m)\n# endif /* GNUC >= 3.0 */\n#endif /* ATTRIBUTE_ALIGNED_ALIGNOF */\n\n/* We use __extension__ in some places to suppress -pedantic warnings\n   about GCC extensions.  This feature didn't work properly before\n   gcc 2.8.  */\n#if GCC_VERSION < 2008\n#define __extension__\n#endif\n\n#endif\t/* ansidecl.h\t*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTO@HOS": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* auto-host.h.  Generated by configure.  */\n/* config.in.  Generated from configure.ac by autoheader.  */\n\n/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */\n#define BYTEORDER 4321\n\n/* Define as the number of bits in a byte, if \\`limits.h' doesn't. */\n/* #undef CHAR_BIT */\n\n/* Define 0/1 to force the choice for exception handling model. */\n/* #undef CONFIG_SJLJ_EXCEPTIONS */\n\n/* Define to enable the use of a default assembler. */\n/* #undef DEFAULT_ASSEMBLER */\n\n/* Define to enable the use of a default linker. */\n/* #undef DEFAULT_LINKER */\n\n/* Define if you want to use __cxa_atexit, rather than atexit, to register C++\n   destructors for local statics and global objects. This is essential for\n   fully standards-compliant handling of destructors, but requires\n   __cxa_atexit in libc. */\n/* #undef DEFAULT_USE_CXA_ATEXIT */\n\n/* Define if you want more run-time sanity checks. This one gets a grab bag of\n   miscellaneous but relatively cheap checks. */\n/* #undef ENABLE_CHECKING */\n\n/* Define if you want fold checked that it never destructs its argument. This\n   is quite expensive. */\n/* #undef ENABLE_FOLD_CHECKING */\n\n/* Define if you want the garbage collector to operate in maximally paranoid\n   mode, validating the entire heap and collecting garbage at every\n   opportunity. This is extremely expensive. */\n/* #undef ENABLE_GC_ALWAYS_COLLECT */\n\n/* Define if you want the garbage collector to do object poisoning and other\n   memory allocation checks. This is quite expensive. */\n/* #undef ENABLE_GC_CHECKING */\n\n/* Define to 1 if translation of program messages to the user's native\n   language is requested. */\n/* #undef ENABLE_NLS */\n\n/* Define if you want all operations on RTL (the basic data structure of the\n   optimizer and back end) to be checked for dynamic type safety at runtime.\n   This is quite expensive. */\n/* #undef ENABLE_RTL_CHECKING */\n\n/* Define if you want RTL flag accesses to be checked against the RTL codes\n   that are supported for each access macro. This is relatively cheap. */\n/* #undef ENABLE_RTL_FLAG_CHECKING */\n\n/* Define if you want all operations on trees (the basic data structure of the\n   front ends) to be checked for dynamic type safety at runtime. This is\n   moderately expensive. */\n/* #undef ENABLE_TREE_CHECKING */\n\n/* Define if you want to run subprograms and generated programs through\n   valgrind (a memory checker). This is extremely expensive. */\n/* #undef ENABLE_VALGRIND_CHECKING */\n\n/* Define to 1 if installation paths should be looked up in Windows32\n   Registry. Ignored on non windows32 hosts. */\n/* #undef ENABLE_WIN32_REGISTRY */\n\n/* Define to the name of a file containing a list of extra machine modes for\n   this architecture. */\n/* #undef EXTRA_MODES_FILE */\n\n/* Define to enable detailed memory allocation stats gathering. */\n/* #undef GATHER_STATISTICS */\n\n/* Define to the type of elements in the array set by `getgroups'. Usually\n   this is either `int' or `gid_t'. */\n#define GETGROUPS_T int\n\n/* Define to 1 if you have the `alphasort' function. */\n/* #undef HAVE_ALPHASORT */\n\n/* Define if your assembler supports dwarf2 .file/.loc directives, and\n   preserves file table indices exactly as given. */\n/* #undef HAVE_AS_DWARF2_DEBUG_LINE */\n\n/* Define if your assembler supports explicit relocations. */\n/* #undef HAVE_AS_EXPLICIT_RELOCS */\n\n/* Define if your assembler supports the --gdwarf2 option. */\n/* #undef HAVE_AS_GDWARF2_DEBUG_FLAG */\n\n/* Define true if the assembler supports '.long foo@GOTOFF'. */\n/* #undef HAVE_AS_GOTOFF_IN_DATA */\n\n/* Define if your assembler supports the --gstabs option. */\n/* #undef HAVE_AS_GSTABS_DEBUG_FLAG */\n\n/* Define if your assembler supports the Sun syntax for cmov. */\n/* #undef HAVE_AS_IX86_CMOV_SUN_SYNTAX */\n\n/* Define if your assembler supports the lituse_jsrdirect relocation. */\n/* #undef HAVE_AS_JSRDIRECT_RELOCS */\n\n/* Define if your assembler supports .sleb128 and .uleb128. */\n#define HAVE_AS_LEB128 1\n\n/* Define if your assembler supports ltoffx and ldxmov relocations. */\n/* #undef HAVE_AS_LTOFFX_LDXMOV_RELOCS */\n\n/* Define if your assembler supports mfcr field. */\n/* #undef HAVE_AS_MFCRF */\n\n/* Define if your assembler supports the -no-mul-bug-abort option. */\n/* #undef HAVE_AS_NO_MUL_BUG_ABORT_OPTION */\n\n/* Define if your assembler supports offsetable %lo(). */\n/* #undef HAVE_AS_OFFSETABLE_LO10 */\n\n/* Define if your assembler supports .register. */\n/* #undef HAVE_AS_REGISTER_PSEUDO_OP */\n\n/* Define if your assembler supports -relax option. */\n/* #undef HAVE_AS_RELAX_OPTION */\n\n/* Define if your assembler and linker support unaligned PC relative relocs.\n   */\n/* #undef HAVE_AS_SPARC_UA_PCREL */\n\n/* Define if your assembler and linker support unaligned PC relative relocs\n   against hidden symbols. */\n/* #undef HAVE_AS_SPARC_UA_PCREL_HIDDEN */\n\n/* Define if your assembler supports thread-local storage. */\n/* #undef HAVE_AS_TLS */\n\n/* Define to 1 if you have the `atoll' function. */\n/* #undef HAVE_ATOLL */\n\n/* Define to 1 if you have the `atoq' function. */\n/* #undef HAVE_ATOQ */\n\n/* Define to 1 if you have the `clock' function. */\n/* #undef HAVE_CLOCK */\n\n/* Define if <time.h> defines clock_t. */\n#define HAVE_CLOCK_T 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ABORT 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ATOF 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ATOL 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_BASENAME 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_CALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_CLOCK 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_ERRNO 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FPRINTF_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FPUTS_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FREE 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_FWRITE_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETCWD 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETENV 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETOPT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETRLIMIT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETRUSAGE 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_GETWD 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_LDGETNAME 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_MALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_PUTC_UNLOCKED 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_REALLOC 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_SBRK 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_SETRLIMIT 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_SNPRINTF 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_STRSIGNAL 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_STRSTR 1\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_TIMES 0\n\n/* Define to 1 if we found this declaration otherwise define to 0. */\n#define HAVE_DECL_VASPRINTF 0\n\n/* Define to 1 if you have the <direct.h> header file. */\n/* #undef HAVE_DIRECT_H */\n\n/* Define to 1 if you have the `dup2' function. */\n/* #undef HAVE_DUP2 */\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n/* #undef HAVE_FCNTL_H */\n\n/* Define to 1 if you have the `fork' function. */\n/* #undef HAVE_FORK */\n\n/* Define to 1 if you have the `fprintf_unlocked' function. */\n/* #undef HAVE_FPRINTF_UNLOCKED */\n\n/* Define to 1 if you have the `fputc_unlocked' function. */\n/* #undef HAVE_FPUTC_UNLOCKED */\n\n/* Define to 1 if you have the `fputs_unlocked' function. */\n/* #undef HAVE_FPUTS_UNLOCKED */\n\n/* Define to 1 if you have the `fwrite_unlocked' function. */\n/* #undef HAVE_FWRITE_UNLOCKED */\n\n/* Define if your assembler supports .balign and .p2align. */\n#define HAVE_GAS_BALIGN_AND_P2ALIGN 1\n\n/* Define if your assembler uses the new HImode fild and fist notation. */\n/* #undef HAVE_GAS_FILDS_FISTS */\n\n/* Define if your assembler and linker support .hidden. */\n#define HAVE_GAS_HIDDEN 1\n\n/* Define if your assembler supports specifying the maximum number of bytes to\n   skip when using the GAS .p2align command. */\n#define HAVE_GAS_MAX_SKIP_P2ALIGN 1\n\n/* Define if your assembler supports .nsubspa comdat option. */\n/* #undef HAVE_GAS_NSUBSPA_COMDAT */\n\n/* Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.\n   */\n#define HAVE_GAS_SHF_MERGE 1\n\n/* Define if your assembler supports .subsection and .subsection -1 starts\n   emitting at the beginning of your section. */\n#define HAVE_GAS_SUBSECTION_ORDERING 1\n\n/* Define if your assembler supports .weak. */\n#define HAVE_GAS_WEAK 1\n\n/* Define to 1 if you have the `getrlimit' function. */\n/* #undef HAVE_GETRLIMIT */\n\n/* Define to 1 if you have the `getrusage' function. */\n/* #undef HAVE_GETRUSAGE */\n\n/* Define to 1 if you have the `gettimeofday' function. */\n/* #undef HAVE_GETTIMEOFDAY */\n\n/* Define if you have the iconv() function. */\n/* #undef HAVE_ICONV */\n\n/* Define to 1 if you have the <iconv.h> header file. */\n/* #undef HAVE_ICONV_H */\n\n/* Define .init_array/.fini_array sections are available and working. */\n/* #undef HAVE_INITFINI_ARRAY */\n\n/* Define if you have a working <inttypes.h> header file. */\n/* #undef HAVE_INTTYPES_H */\n\n/* Define to 1 if you have the `kill' function. */\n/* #undef HAVE_KILL */\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n/* #undef HAVE_LANGINFO_H */\n\n/* Define if your <locale.h> file defines LC_MESSAGES. */\n/* #undef HAVE_LC_MESSAGES */\n\n/* Define to 1 if you have the <ldfcn.h> header file. */\n/* #undef HAVE_LDFCN_H */\n\n/* Define if your linker supports --as-needed and --no-as-needed options. */\n/* #undef HAVE_LD_AS_NEEDED */\n\n/* Define if your linker supports --eh-frame-hdr option. */\n#define HAVE_LD_EH_FRAME_HDR 1\n\n/* Define if your linker supports -pie option. */\n#define HAVE_LD_PIE 1\n\n/* Define if your linker links a mix of read-only and read-write sections into\n   a read-write section. */\n#define HAVE_LD_RO_RW_SECTION_MIXING 1\n\n/* Define if your linker supports -Bstatic/-Bdynamic option. */\n#define HAVE_LD_STATIC_DYNAMIC 1\n\n/* Define to 1 if you have the <limits.h> header file. */\n#define HAVE_LIMITS_H 1\n\n/* Define to 1 if you have the <locale.h> header file. */\n#define HAVE_LOCALE_H 1\n\n/* Define if your compiler supports the \\`long long' type. */\n/* #undef HAVE_LONG_LONG */\n\n/* Define to 1 if you have the <malloc.h> header file. */\n/* #undef HAVE_MALLOC_H */\n\n/* Define to 1 if you have the `mbstowcs' function. */\n/* #undef HAVE_MBSTOWCS */\n\n/* Define if valgrind's memcheck.h header is installed. */\n/* #undef HAVE_MEMCHECK_H */\n\n/* Define to 1 if you have the <memory.h> header file. */\n/* #undef HAVE_MEMORY_H */\n\n/* Define to 1 if you have the `mincore' function. */\n/* #undef HAVE_MINCORE */\n\n/* Define to 1 if you have the `mmap' function. */\n/* #undef HAVE_MMAP */\n\n/* Define if mmap with MAP_ANON(YMOUS) works. */\n/* #undef HAVE_MMAP_ANON */\n\n/* Define if mmap of /dev/zero works. */\n/* #undef HAVE_MMAP_DEV_ZERO */\n\n/* Define if read-only mmap of a plain file works. */\n/* #undef HAVE_MMAP_FILE */\n\n/* Define to 1 if you have the `nl_langinfo' function. */\n/* #undef HAVE_NL_LANGINFO */\n\n/* Define if printf supports \"%p\". */\n/* #undef HAVE_PRINTF_PTR */\n\n/* Define to 1 if you have the `putc_unlocked' function. */\n/* #undef HAVE_PUTC_UNLOCKED */\n\n/* Define to 1 if you have the `scandir' function. */\n/* #undef HAVE_SCANDIR */\n\n/* Define to 1 if you have the `setlocale' function. */\n/* #undef HAVE_SETLOCALE */\n\n/* Define to 1 if you have the `setrlimit' function. */\n/* #undef HAVE_SETRLIMIT */\n\n/* Define if you have a working <stdbool.h> header file. */\n/* #undef HAVE_STDBOOL_H */\n\n/* Define to 1 if you have the <stddef.h> header file. */\n#define HAVE_STDDEF_H 1\n\n/* Define to 1 if you have the <stdint.h> header file. */\n/* #undef HAVE_STDINT_H */\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#define HAVE_STDLIB_H 1\n\n/* Define to 1 if you have the <strings.h> header file. */\n/* #undef HAVE_STRINGS_H */\n\n/* Define to 1 if you have the <string.h> header file. */\n#define HAVE_STRING_H 1\n\n/* Define to 1 if you have the `strsignal' function. */\n/* #undef HAVE_STRSIGNAL */\n\n/* Define if <sys/times.h> defines struct tms. */\n/* #undef HAVE_STRUCT_TMS */\n\n/* Define to 1 if you have the `sysconf' function. */\n/* #undef HAVE_SYSCONF */\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n/* #undef HAVE_SYS_FILE_H */\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n/* #undef HAVE_SYS_MMAN_H */\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n/* #undef HAVE_SYS_PARAM_H */\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n/* #undef HAVE_SYS_RESOURCE_H */\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n/* #undef HAVE_SYS_STAT_H */\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n/* #undef HAVE_SYS_TIMES_H */\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n/* #undef HAVE_SYS_TIME_H */\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n/* #undef HAVE_SYS_TYPES_H */\n\n/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */\n/* #undef HAVE_SYS_WAIT_H */\n\n/* Define to 1 if you have the `times' function. */\n/* #undef HAVE_TIMES */\n\n/* Define to 1 if you have the <time.h> header file. */\n#define HAVE_TIME_H 1\n\n/* Define if <sys/types.h> defines \\`uchar'. */\n/* #undef HAVE_UCHAR */\n\n/* Define to 1 if you have the <unistd.h> header file. */\n/* #undef HAVE_UNISTD_H */\n\n/* Define if valgrind's valgrind/memcheck.h header is installed. */\n/* #undef HAVE_VALGRIND_MEMCHECK_H */\n\n/* Define to 1 if you have the `vfork' function. */\n/* #undef HAVE_VFORK */\n\n/* Define to 1 if you have the <vfork.h> header file. */\n/* #undef HAVE_VFORK_H */\n\n/* Define to 1 if you have the <wchar.h> header file. */\n/* #undef HAVE_WCHAR_H */\n\n/* Define to 1 if you have the `wcswidth' function. */\n/* #undef HAVE_WCSWIDTH */\n\n/* Define to 1 if `fork' works. */\n/* #undef HAVE_WORKING_FORK */\n\n/* Define this macro if mbstowcs does not crash when its first argument is\n   NULL. */\n/* #undef HAVE_WORKING_MBSTOWCS */\n\n/* Define to 1 if `vfork' works. */\n/* #undef HAVE_WORKING_VFORK */\n\n/* Define if the \\`_Bool' type is built-in. */\n#define HAVE__BOOL 1\n\n/* Define if your compiler supports the \\`__int64' type. */\n/* #undef HAVE___INT64 */\n\n/* Define if the host machine stores words of multi-word integers in\n   big-endian order. */\n#define HOST_WORDS_BIG_ENDIAN 1\n\n/* Define as const if the declaration of iconv() needs const. */\n/* #undef ICONV_CONST */\n\n/* Define if host mkdir takes a single argument. */\n#define MKDIR_TAKES_ONE_ARG 1\n\n/* Define to 1 if HOST_WIDE_INT must be 64 bits wide (see hwint.h). */\n/* #undef NEED_64BIT_HOST_WIDE_INT */\n\n/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n/* #undef NO_MINUS_C_MINUS_O */\n\n/* Define to the address where bug reports for this package should be sent. */\n#define PACKAGE_BUGREPORT \"\"\n\n/* Define to the full name of this package. */\n#define PACKAGE_NAME \"\"\n\n/* Define to the full name and version of this package. */\n#define PACKAGE_STRING \"\"\n\n/* Define to the one symbol short name of this package. */\n#define PACKAGE_TARNAME \"\"\n\n/* Define to the version of this package. */\n#define PACKAGE_VERSION \"\"\n\n/* Define to PREFIX/include if cpp should also search that directory. */\n#define PREFIX_INCLUDE_DIR \"/devel/mvshost/include\"\n\n/* The number of bytes in type int */\n#define SIZEOF_INT 4\n\n/* The number of bytes in type long */\n#define SIZEOF_LONG 4\n\n/* The number of bytes in type long long */\n/* #undef SIZEOF_LONG_LONG */\n\n/* The number of bytes in type short */\n#define SIZEOF_SHORT 2\n\n/* The number of bytes in type void * */\n#define SIZEOF_VOID_P 4\n\n/* The number of bytes in type __int64 */\n/* #undef SIZEOF___INT64 */\n\n/* Define to 1 if you have the ANSI C header files. */\n#define STDC_HEADERS 1\n\n/* Define if you can safely include both <string.h> and <strings.h>. */\n/* #undef STRING_WITH_STRINGS */\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n/* #undef TIME_WITH_SYS_TIME */\n\n/* Define if your assembler mis-optimizes .eh_frame data. */\n/* #undef USE_AS_TRADITIONAL_FORMAT */\n\n/* Define to be the last portion of registry key on windows hosts. */\n/* #undef WIN32_REGISTRY_KEY */\n\n/* whether byteorder is bigendian */\n#define WORDS_BIGENDIAN 1\n\n/* Always define this when using the GNU C Library */\n/* #undef _GNU_SOURCE */\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#define gid_t int\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n/* #undef inline */\n#endif\n\n/* Define to `int' if <sys/types.h> does not define. */\n#define pid_t int\n\n/* Define to \\`long' if <sys/resource.h> doesn't define. */\n#define rlim_t long\n\n/* Define to `int' if <sys/types.h> does not define. */\n#define ssize_t int\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#define uid_t int\n\n/* Define as `fork' if `vfork' does not work. */\n#define vfork fork\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BASIC@BL": {"ttr": 268, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define control and data flow tables, and regsets.\n   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_BASIC_BLOCK_H\n#define GCC_BASIC_BLOCK_H\n\n#include \"bitmap.h\"\n#include \"sbitmap.h\"\n#include \"varray.h\"\n#include \"partition.h\"\n#include \"hard-reg-set.h\"\n\n/* Head of register set linked list.  */\ntypedef bitmap_head regset_head;\n/* A pointer to a regset_head.  */\ntypedef bitmap regset;\n\n/* Initialize a new regset.  */\n#define INIT_REG_SET(HEAD) bitmap_initialize (HEAD, 1)\n\n/* Clear a register set by freeing up the linked list.  */\n#define CLEAR_REG_SET(HEAD) bitmap_clear (HEAD)\n\n/* Copy a register set to another register set.  */\n#define COPY_REG_SET(TO, FROM) bitmap_copy (TO, FROM)\n\n/* Compare two register sets.  */\n#define REG_SET_EQUAL_P(A, B) bitmap_equal_p (A, B)\n\n/* `and' a register set with a second register set.  */\n#define AND_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_AND)\n\n/* `and' the complement of a register set with a register set.  */\n#define AND_COMPL_REG_SET(TO, FROM) \\\n  bitmap_operation (TO, TO, FROM, BITMAP_AND_COMPL)\n\n/* Inclusive or a register set with a second register set.  */\n#define IOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_IOR)\n\n/* Exclusive or a register set with a second register set.  */\n#define XOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_XOR)\n\n/* Or into TO the register set FROM1 `and'ed with the complement of FROM2.  */\n#define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2) \\\n  bitmap_ior_and_compl (TO, FROM1, FROM2)\n\n/* Clear a single register in a register set.  */\n#define CLEAR_REGNO_REG_SET(HEAD, REG) bitmap_clear_bit (HEAD, REG)\n\n/* Set a single register in a register set.  */\n#define SET_REGNO_REG_SET(HEAD, REG) bitmap_set_bit (HEAD, REG)\n\n/* Return true if a register is set in a register set.  */\n#define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n\n/* Copy the hard registers in a register set to the hard register set.  */\nextern void reg_set_to_hard_reg_set (HARD_REG_SET *, bitmap);\n#define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n  reg_set_to_hard_reg_set (&TO, FROM);\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n   register number and executing CODE for all registers that are set.  */\n#define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n  EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, CODE)\n\n/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n   REGNUM to the register number and executing CODE for all registers that are\n   set in the first regset and not set in the second.  */\n#define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n  EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n\n/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n   REGNUM to the register number and executing CODE for all registers that are\n   set in both regsets.  */\n#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n  EXECUTE_IF_AND_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n\n/* Allocate a register set with oballoc.  */\n#define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)\n\n/* Initialize a register set.  Returns the new register set.  */\n#define INITIALIZE_REG_SET(HEAD) bitmap_initialize (&HEAD, 1)\n\n/* Do any cleanup needed on a regset when it is no longer used.  */\n#define FREE_REG_SET(REGSET) BITMAP_FREE(REGSET)\n\n/* Do any one-time initializations needed for regsets.  */\n#define INIT_ONCE_REG_SET() BITMAP_INIT_ONCE ()\n\n/* Grow any tables needed when the number of registers is calculated\n   or extended.  For the linked list allocation, nothing needs to\n   be done, other than zero the statistics on the first allocation.  */\n#define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P)\n\n/* Type we use to hold basic block counters.  Should be at least\n   64bit.  Although a counter cannot be negative, we use a signed\n   type, because erroneous negative counts can be generated when the\n   flow graph is manipulated by various optimizations.  A signed type\n   makes those easy to detect.  */\ntypedef HOST_WIDEST_INT gcov_type;\n\n/* Control flow edge information.  */\ntypedef struct edge_def {\n  /* Links through the predecessor and successor lists.  */\n  struct edge_def *pred_next, *succ_next;\n\n  /* The two blocks at the ends of the edge.  */\n  struct basic_block_def *src, *dest;\n\n  /* Instructions queued on the edge.  */\n  rtx insns;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  int flags;\t\t\t/* see EDGE_* below  */\n  int probability;\t\t/* biased by REG_BR_PROB_BASE */\n  gcov_type count;\t\t/* Expected number of executions calculated\n\t\t\t\t   in profile.c  */\n} *edge;\n\n#define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n#define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed\n\t\t\t\t\t   label, or eh */\n#define EDGE_ABNORMAL_CALL\t4\t/* Call with abnormal exit\n\t\t\t\t\t   like an exception, or sibcall */\n#define EDGE_EH\t\t\t8\t/* Exception throw */\n#define EDGE_FAKE\t\t16\t/* Not a real edge (profile.c) */\n#define EDGE_DFS_BACK\t\t32\t/* A backwards edge */\n#define EDGE_CAN_FALLTHRU\t64\t/* Candidate for straight line\n\t\t\t\t\t   flow.  */\n#define EDGE_IRREDUCIBLE_LOOP\t128\t/* Part of irreducible loop.  */\n#define EDGE_SIBCALL\t\t256\t/* Edge from sibcall to exit.  */\n#define EDGE_LOOP_EXIT\t\t512\t/* Exit of a loop.  */\n#define EDGE_ALL_FLAGS\t\t1023\n\n#define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n\n/* Counter summary from the last set of coverage counts read by\n   profile.c.  */\nextern const struct gcov_ctr_summary *profile_info;\n\n/* Declared in cfgloop.h.  */\nstruct loop;\nstruct loops;\n\n/* A basic block is a sequence of instructions with only entry and\n   only one exit.  If any one of the instructions are executed, they\n   will all be executed, and in sequence from first to last.\n\n   There may be COND_EXEC instructions in the basic block.  The\n   COND_EXEC *instructions* will be executed -- but if the condition\n   is false the conditionally executed *expressions* will of course\n   not be executed.  We don't consider the conditionally executed\n   expression (which might have side-effects) to be in a separate\n   basic block because the program counter will always be at the same\n   location after the COND_EXEC instruction, regardless of whether the\n   condition is true or not.\n\n   Basic blocks need not start with a label nor end with a jump insn.\n   For example, a previous basic block may just \"conditionally fall\"\n   into the succeeding basic block, and the last basic block need not\n   end with a jump insn.  Block 0 is a descendant of the entry block.\n\n   A basic block beginning with two labels cannot have notes between\n   the labels.\n\n   Data for jump tables are stored in jump_insns that occur in no\n   basic block even though these insns can follow or precede insns in\n   basic blocks.  */\n\n/* Basic block information indexed by block number.  */\ntypedef struct basic_block_def {\n  /* The first and last insns of the block.  */\n  rtx head_, end_;\n\n  /* The first and last trees of the block.  */\n  tree head_tree;\n  tree end_tree;\n\n  /* The edges into and out of the block.  */\n  edge pred, succ;\n\n  /* Liveness info.  */\n\n  /* The registers that are modified within this in block.  */\n  regset local_set;\n  /* The registers that are conditionally modified within this block.\n     In other words, registers that are set only as part of a\n     COND_EXEC.  */\n  regset cond_local_set;\n  /* The registers that are live on entry to this block.\n\n     Note that in SSA form, global_live_at_start does not reflect the\n     use of regs in phi functions, since the liveness of these regs\n     may depend on which edge was taken into the block.  */\n  regset global_live_at_start;\n  /* The registers that are live on exit from this block.  */\n  regset global_live_at_end;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  /* The index of this block.  */\n  int index;\n\n  /* Previous and next blocks in the chain.  */\n  struct basic_block_def *prev_bb, *next_bb;\n\n  /* The loop depth of this block.  */\n  int loop_depth;\n\n  /* Outermost loop containing the block.  */\n  struct loop *loop_father;\n\n  /* The dominance and postdominance information node.  */\n  struct et_node *dom\u00dd2\u00a8;\n\n  /* Expected number of executions: calculated in profile.c.  */\n  gcov_type count;\n\n  /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */\n  int frequency;\n\n  /* Various flags.  See BB_* below.  */\n  int flags;\n\n  /* Additional data maintained by cfg_layout routines.  */\n  struct reorder_block_def *rbi;\n} *basic_block;\n\n#define BB_FREQ_MAX 10000\n\n/* Masks for basic_block.flags.  */\n#define BB_DIRTY\t\t1\n#define BB_NEW\t\t\t2\n#define BB_REACHABLE\t\t4\n#define BB_VISITED\t\t8\n#define BB_IRREDUCIBLE_LOOP\t16\n#define BB_SUPERBLOCK\t\t32\n\n/* Number of basic blocks in the current function.  */\n\nextern int n_basic_blocks;\n\n/* First free basic block number.  */\n\nextern int last_basic_block;\n\n/* Number of edges in the current function.  */\n\nextern int n_edges;\n\n/* Index by basic block number, get basic block struct info.  */\n\nextern varray_type basic_block_info;\n\n#define BASIC_BLOCK(N)  (VARRAY_BB (basic_block_info, (N)))\n\n/* For iterating over basic blocks.  */\n#define FOR_BB_BETWEEN(BB, FROM, TO, DIR) \\\n  for (BB = FROM; BB != TO; BB = BB->DIR)\n\n#define FOR_EACH_BB(BB) \\\n  FOR_BB_BETWEEN (BB, ENTRY_BLOCK_PTR->next_bb, EXIT_BLOCK_PTR, next_bb)\n\n#define FOR_EACH_BB_REVERSE(BB) \\\n  FOR_BB_BETWEEN (BB, EXIT_BLOCK_PTR->prev_bb, ENTRY_BLOCK_PTR, prev_bb)\n\n/* Cycles through _all_ basic blocks, even the fake ones (entry and\n   exit block).  */\n\n#define FOR_ALL_BB(BB) \\\n  for (BB = ENTRY_BLOCK_PTR; BB; BB = BB->next_bb)\n\n/* What registers are live at the setjmp call.  */\n\nextern regset regs_live_at_setjmp;\n\n/* Special labels found during CFG build.  */\n\nextern GTY(()) rtx label_value_list;\nextern GTY(()) rtx tail_recursion_label_list;\n\nextern struct obstack flow_obstack;\n\n/* Indexed by n, gives number of basic block that  (REG n) is used in.\n   If the value is REG_BLOCK_GLOBAL (-2),\n   it means (REG n) is used in more than one basic block.\n   REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.\n   This information remains valid for the rest of the compilation\n   of the current function; it is used to control register allocation.  */\n\n#define REG_BLOCK_UNKNOWN -1\n#define REG_BLOCK_GLOBAL -2\n\n#define REG_BASIC_BLOCK(N) (VARRAY_REG (reg_n_info, N)->basic_block)\n\n/* Stuff for recording basic block info.  */\n\n#define BB_HEAD(B)      (B)->head_\n#define BB_END(B)       (B)->end_\n\n/* Special block numbers \u00ddmarkers\u00a8 for entry and exit.  */\n#define ENTRY_BLOCK (-1)\n#define EXIT_BLOCK (-2)\n\n/* Special block number not valid for any block.  */\n#define INVALID_BLOCK (-3)\n\n/* Similarly, block pointers for the edge list.  */\nextern struct basic_block_def entry_exit_blocks\u00dd2\u00a8;\n#define ENTRY_BLOCK_PTR\t(&entry_exit_blocks\u00dd0\u00a8)\n#define EXIT_BLOCK_PTR\t(&entry_exit_blocks\u00dd1\u00a8)\n\n#define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n#define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)\n\nextern void compute_bb_for_insn (void);\nextern void free_bb_for_insn (void);\nextern void update_bb_for_insn (basic_block);\n\nextern void free_basic_block_vars (int);\n\nextern void insert_insn_on_edge (rtx, edge);\nbool safe_insert_insn_on_edge (rtx, edge);\n\nextern void commit_edge_insertions (void);\nextern void commit_edge_insertions_watch_calls (void);\n\nextern void remove_fake_edges (void);\nextern void add_noreturn_fake_exit_edges (void);\nextern void connect_infinite_loops_to_exit (void);\nextern int flow_call_edges_add (sbitmap);\nextern edge unchecked_make_edge (basic_block, basic_block, int);\nextern edge cached_make_edge (sbitmap *, basic_block, basic_block, int);\nextern edge make_edge (basic_block, basic_block, int);\nextern edge make_single_succ_edge (basic_block, basic_block, int);\nextern void remove_edge (edge);\nextern void redirect_edge_succ (edge, basic_block);\nextern edge redirect_edge_succ_nodup (edge, basic_block);\nextern void redirect_edge_pred (edge, basic_block);\nextern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\nextern void clear_bb_flags (void);\nextern void tidy_fallthru_edge (edge, basic_block, basic_block);\nextern void tidy_fallthru_edges (void);\nextern void flow_reverse_top_sort_order_compute (int *);\nextern int flow_depth_first_order_compute (int *, int *);\nextern void flow_preorder_transversal_compute (int *);\nextern int dfs_enumerate_from (basic_block, int,\n\t\t\t       bool (*)(basic_block, void *),\n\t\t\t       basic_block *, int, void *);\nextern void dump_edge_info (FILE *, edge, int);\nextern void clear_edges (void);\nextern void mark_critical_edges (void);\nextern rtx first_insn_after_basic_block_note (basic_block);\n\n/* Structure to group all of the information to process IF-THEN and\n   IF-THEN-ELSE blocks for the conditional execution support.  This\n   needs to be in a public file in case the IFCVT macros call\n   functions passing the ce_if_block data structure.  */\n\ntypedef struct ce_if_block\n{\n  basic_block test_bb;\t\t\t/* First test block.  */\n  basic_block then_bb;\t\t\t/* THEN block.  */\n  basic_block else_bb;\t\t\t/* ELSE block or NULL.  */\n  basic_block join_bb;\t\t\t/* Join THEN/ELSE blocks.  */\n  basic_block last_test_bb;\t\t/* Last bb to hold && or || tests.  */\n  int num_multiple_test_blocks;\t\t/* # of && and || basic blocks.  */\n  int num_and_and_blocks;\t\t/* # of && blocks.  */\n  int num_or_or_blocks;\t\t\t/* # of || blocks.  */\n  int num_multiple_test_insns;\t\t/* # of insns in && and || blocks.  */\n  int and_and_p;\t\t\t/* Complex test is &&.  */\n  int num_then_insns;\t\t\t/* # of insns in THEN block.  */\n  int num_else_insns;\t\t\t/* # of insns in ELSE block.  */\n  int pass;\t\t\t\t/* Pass number.  */\n\n#ifdef IFCVT_EXTRA_FIELDS\n  IFCVT_EXTRA_FIELDS\t\t\t/* Any machine dependent fields.  */\n#endif\n\n} ce_if_block_t;\n\n/* This structure maintains an edge list vector.  */\nstruct edge_list\n{\n  int num_blocks;\n  int num_edges;\n  edge *index_to_edge;\n};\n\n/* This is the value which indicates no edge is present.  */\n#define EDGE_INDEX_NO_EDGE\t-1\n\n/* EDGE_INDEX returns an integer index for an edge, or EDGE_INDEX_NO_EDGE\n   if there is no edge between the 2 basic blocks.  */\n#define EDGE_INDEX(el, pred, succ) (find_edge_index ((el), (pred), (succ)))\n\n/* INDEX_EDGE_PRED_BB and INDEX_EDGE_SUCC_BB return a pointer to the basic\n   block which is either the pred or succ end of the indexed edge.  */\n#define INDEX_EDGE_PRED_BB(el, index)\t((el)->index_to_edge\u00dd(index)\u00a8->src)\n#define INDEX_EDGE_SUCC_BB(el, index)\t((el)->index_to_edge\u00dd(index)\u00a8->dest)\n\n/* INDEX_EDGE returns a pointer to the edge.  */\n#define INDEX_EDGE(el, index)           ((el)->index_to_edge\u00dd(index)\u00a8)\n\n/* Number of edges in the compressed edge list.  */\n#define NUM_EDGES(el)\t\t\t((el)->num_edges)\n\n/* BB is assumed to contain conditional jump.  Return the fallthru edge.  */\n#define FALLTHRU_EDGE(bb)\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n\t\t\t\t\t ? (bb)->succ : (bb)->succ->succ_next)\n\n/* BB is assumed to contain conditional jump.  Return the branch edge.  */\n#define BRANCH_EDGE(bb)\t\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n\t\t\t\t\t ? (bb)->succ->succ_next : (bb)->succ)\n\n/* Return expected execution frequency of the edge E.  */\n#define EDGE_FREQUENCY(e)\t\t(((e)->src->frequency \\\n\t\t\t\t\t  * (e)->probability \\\n\t\t\t\t\t  + REG_BR_PROB_BASE / 2) \\\n\t\t\t\t\t / REG_BR_PROB_BASE)\n\n/* Return nonzero if edge is critical.  */\n#define EDGE_CRITICAL_P(e)\t\t((e)->src->succ->succ_next \\\n\t\t\t\t\t && (e)->dest->pred->pred_next)\n\nstruct edge_list * create_edge_list (void);\nvoid free_edge_list (struct edge_list *);\nvoid print_edge_list (FILE *, struct edge_list *);\nvoid verify_edge_list (FILE *, struct edge_list *);\nint find_edge_index (struct edge_list *, basic_block, basic_block);\n\n\nenum update_life_extent\n{\n  UPDATE_LIFE_LOCAL = 0,\n  UPDATE_LIFE_GLOBAL = 1,\n  UPDATE_LIFE_GLOBAL_RM_NOTES = 2\n};\n\n/* Flags for life_analysis and update_life_info.  */\n\n#define PROP_DEATH_NOTES\t1\t/* Create DEAD and UNUSED notes.  */\n#define PROP_LOG_LINKS\t\t2\t/* Create LOG_LINKS.  */\n#define PROP_REG_INFO\t\t4\t/* Update regs_ever_live et al.  */\n#define PROP_KILL_DEAD_CODE\t8\t/* Remove dead code.  */\n#define PROP_SCAN_DEAD_CODE\t16\t/* Scan for dead code.  */\n#define PROP_ALLOW_CFG_CHANGES\t32\t/* Allow the CFG to be changed\n\t\t\t\t\t   by dead code removal.  */\n#define PROP_AUTOINC\t\t64\t/* Create autoinc mem references.  */\n#define PROP_EQUAL_NOTES\t128\t/* Take into account REG_EQUAL notes.  */\n#define PROP_SCAN_DEAD_STORES\t256\t/* Scan for dead code.  */\n#define PROP_ASM_SCAN\t\t512\t/* Internal flag used within flow.c\n\t\t\t\t\t   to flag analysis of asms.  */\n#define PROP_FINAL\t\t(PROP_DEATH_NOTES | PROP_LOG_LINKS  \\\n\t\t\t\t | PROP_REG_INFO | PROP_KILL_DEAD_CODE  \\\n\t\t\t\t | PROP_SCAN_DEAD_CODE | PROP_AUTOINC \\\n\t\t\t\t | PROP_ALLOW_CFG_CHANGES \\\n\t\t\t\t | PROP_SCAN_DEAD_STORES)\n#define PROP_POSTRELOAD\t\t(PROP_DEATH_NOTES  \\\n\t\t\t\t | PROP_KILL_DEAD_CODE  \\\n\t\t\t\t | PROP_SCAN_DEAD_CODE | PROP_AUTOINC \\\n\t\t\t\t | PROP_SCAN_DEAD_STORES)\n\n#define CLEANUP_EXPENSIVE\t1\t/* Do relatively expensive optimizations\n\t\t\t\t\t   except for edge forwarding */\n#define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n#define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need\n\t\t\t\t\t   to care REG_DEAD notes.  */\n#define CLEANUP_PRE_SIBCALL\t8\t/* Do not get confused by code hidden\n\t\t\t\t\t   inside call_placeholders..  */\n#define CLEANUP_PRE_LOOP\t16\t/* Take care to preserve syntactic loop\n\t\t\t\t\t   notes.  */\n#define CLEANUP_UPDATE_LIFE\t32\t/* Keep life information up to date.  */\n#define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n#define CLEANUP_NO_INSN_DEL\t128\t/* Do not try to delete trivially dead\n\t\t\t\t\t   insns.  */\n#define CLEANUP_CFGLAYOUT\t256\t/* Do cleanup in cfglayout mode.  */\n#define CLEANUP_LOG_LINKS\t512\t/* Update log links.  */\nextern void life_analysis (rtx, FILE *, int);\nextern int update_life_info (sbitmap, enum update_life_extent, int);\nextern int update_life_info_in_dirty_blocks (enum update_life_extent, int);\nextern int count_or_remove_death_notes (sbitmap, int);\nextern int propagate_block (basic_block, regset, regset, regset, int);\n\nstruct propagate_block_info;\nextern rtx propagate_one_insn (struct propagate_block_info *, rtx);\nextern struct propagate_block_info *init_propagate_block_info\n (basic_block, regset, regset, regset, int);\nextern void free_propagate_block_info (struct propagate_block_info *);\n\n/* In lcm.c */\nextern struct edge_list *pre_edge_lcm (FILE *, int, sbitmap *, sbitmap *,\n\t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n\t\t\t\t       sbitmap **);\nextern struct edge_list *pre_edge_rev_lcm (FILE *, int, sbitmap *,\n\t\t\t\t\t   sbitmap *, sbitmap *,\n\t\t\t\t\t   sbitmap *, sbitmap **,\n\t\t\t\t\t   sbitmap **);\nextern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\nextern int optimize_mode_switching (FILE *);\n\n/* In emit-rtl.c.  */\nextern rtx emit_block_insn_after (rtx, rtx, basic_block);\nextern rtx emit_block_insn_before (rtx, rtx, basic_block);\n\n/* In predict.c */\nextern void estimate_probability (struct loops *);\nextern void note_prediction_to_br_prob (void);\nextern void expected_value_to_br_prob (void);\nextern bool maybe_hot_bb_p (basic_block);\nextern bool probably_cold_bb_p (basic_block);\nextern bool probably_never_executed_bb_p (basic_block);\n\n/* In flow.c */\nextern void init_flow (void);\nextern void dump_bb (basic_block, FILE *);\nextern void debug_bb (basic_block);\nextern basic_block debug_bb_n (int);\nextern void dump_regset (regset, FILE *);\nextern void debug_regset (regset);\nextern void allocate_reg_life_data (void);\nextern void allocate_bb_life_data (void);\nextern void expunge_block (basic_block);\nextern void link_block (basic_block, basic_block);\nextern void unlink_block (basic_block);\nextern void compact_blocks (void);\nextern basic_block alloc_block (void);\nextern void find_unreachable_blocks (void);\nextern int delete_noop_moves (rtx);\nextern basic_block force_nonfallthru (edge);\nextern rtx block_label (basic_block);\nextern bool forwarder_block_p (basic_block);\nextern bool purge_all_dead_edges (int);\nextern bool purge_dead_edges (basic_block);\nextern void find_sub_basic_blocks (basic_block);\nextern void find_many_sub_basic_blocks (sbitmap);\nextern bool can_fallthru (basic_block, basic_block);\nextern void flow_nodes_print (const char *, const sbitmap, FILE *);\nextern void flow_edge_list_print (const char *, const edge *, int, FILE *);\nextern void alloc_aux_for_block (basic_block, int);\nextern void alloc_aux_for_blocks (int);\nextern void clear_aux_for_blocks (void);\nextern void free_aux_for_blocks (void);\nextern void alloc_aux_for_edge (edge, int);\nextern void alloc_aux_for_edges (int);\nextern void clear_aux_for_edges (void);\nextern void free_aux_for_edges (void);\n\n/* This function is always defined so it can be called from the\n   debugger, and it is declared extern so we don't get warnings about\n   it being unused.  */\nextern void verify_flow_info (void);\n\ntypedef struct conflict_graph_def *conflict_graph;\n\n/* Callback function when enumerating conflicts.  The arguments are\n   the smaller and larger regno in the conflict.  Returns zero if\n   enumeration is to continue, nonzero to halt enumeration.  */\ntypedef int (*conflict_graph_enum_fn) (int, int, void *);\n\n\n/* Prototypes of operations on conflict graphs.  */\n\nextern conflict_graph conflict_graph_new\n (int);\nextern void conflict_graph_delete (conflict_graph);\nextern int conflict_graph_add (conflict_graph, int, int);\nextern int conflict_graph_conflict_p (conflict_graph, int, int);\nextern void conflict_graph_enum (conflict_graph, int, conflict_graph_enum_fn,\n\t\t\t\t void *);\nextern void conflict_graph_merge_regs (conflict_graph, int, int);\nextern void conflict_graph_print (conflict_graph, FILE*);\nextern conflict_graph conflict_graph_compute (regset, partition);\nextern bool mark_dfs_back_edges (void);\nextern void set_edge_can_fallthru_flag (void);\nextern void update_br_prob_note (basic_block);\nextern void fixup_abnormal_edges (void);\nextern bool can_hoist_insn_p (rtx, rtx, regset);\nextern rtx hoist_insn_after (rtx, rtx, rtx, rtx);\nextern rtx hoist_insn_to_edge (rtx, edge, rtx, rtx);\nextern bool inside_basic_block_p (rtx);\nextern bool control_flow_insn_p (rtx);\n\n/* In bb-reorder.c */\nextern void reorder_basic_blocks (unsigned int);\n\n/* In dominance.c */\n\nenum cdi_direction\n{\n  CDI_DOMINATORS,\n  CDI_POST_DOMINATORS\n};\n\nenum dom_state\n{\n  DOM_NONE,\t\t/* Not computed at all.  */\n  DOM_CONS_OK,\t\t/* The data is conservatively OK, i.e. if it says you that A dominates B,\n\t\t\t   it indeed does.  */\n  DOM_NO_FAST_QUERY,\t/* The data is OK, but the fast query data are not usable.  */\n  DOM_OK\t\t/* Everything is ok.  */\n};\n\nextern enum dom_state dom_computed\u00dd2\u00a8;\n\nextern void calculate_dominance_info (enum cdi_direction);\nextern void free_dominance_info (enum cdi_direction);\nextern basic_block nearest_common_dominator (enum cdi_direction,\n\t\t\t\t\t     basic_block, basic_block);\nextern void set_immediate_dominator (enum cdi_direction, basic_block,\n\t\t\t\t     basic_block);\nextern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\nextern bool dominated_by_p (enum cdi_direction, basic_block, basic_block);\nextern int get_dominated_by (enum cdi_direction, basic_block, basic_block **);\nextern void add_to_dominance_info (enum cdi_direction, basic_block);\nextern void delete_from_dominance_info (enum cdi_direction, basic_block);\nbasic_block recount_dominator (enum cdi_direction, basic_block);\nextern void redirect_immediate_dominators (enum cdi_direction, basic_block,\n\t\t\t\t\t   basic_block);\nextern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);\nextern void verify_dominators (enum cdi_direction);\nextern basic_block first_dom_son (enum cdi_direction, basic_block);\nextern basic_block next_dom_son (enum cdi_direction, basic_block);\nextern bool try_redirect_by_replacing_jump (edge, basic_block, bool);\n\n#include \"cfghooks.h\"\n\n#endif /* GCC_BASIC_BLOCK_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BCONFIG": {"ttr": 517, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_BCONFIG_H\n#define GCC_BCONFIG_H\n#include \"auto-build.h\"\n#ifdef IN_GCC\n# include \"ansidecl.h\"\n#endif\n#endif /* GCC_BCONFIG_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BITMAP": {"ttr": 519, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Functions to support general ended bitmaps.\n   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_BITMAP_H\n#define GCC_BITMAP_H\n\n/* Fundamental storage type for bitmap.  */\n\n/* typedef unsigned HOST_WIDE_INT BITMAP_WORD; */\n/* #define nBITMAP_WORD_BITS HOST_BITS_PER_WIDE_INT */\ntypedef unsigned long BITMAP_WORD;\n#define nBITMAP_WORD_BITS (CHAR_BIT * SIZEOF_LONG)\n#define BITMAP_WORD_BITS (unsigned) nBITMAP_WORD_BITS\n\n/* Number of words to use for each element in the linked list.  */\n\n#ifndef BITMAP_ELEMENT_WORDS\n#define BITMAP_ELEMENT_WORDS ((128 + nBITMAP_WORD_BITS - 1) / nBITMAP_WORD_BITS)\n#endif\n\n/* Number of bits in each actual element of a bitmap.  We get slightly better\n   code for bit % BITMAP_ELEMENT_ALL_BITS and bit / BITMAP_ELEMENT_ALL_BITS if\n   bits is unsigned, assuming it is a power of 2.  */\n\n#define BITMAP_ELEMENT_ALL_BITS \\\n  ((unsigned) (BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS))\n\n/* Bitmap set element.  We use a linked list to hold only the bits that\n   are set.  This allows for use to grow the bitset dynamically without\n   having to realloc and copy a giant bit array.  The `prev' field is\n   undefined for an element on the free list.  */\n\ntypedef struct bitmap_element_def GTY(())\n{\n  struct bitmap_element_def *next;\t\t/* Next element.  */\n  struct bitmap_element_def *prev;\t\t/* Previous element.  */\n  unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS.  */\n  BITMAP_WORD bits\u00ddBITMAP_ELEMENT_WORDS\u00a8; /* Bits that are set.  */\n} bitmap_element;\n\n/* Head of bitmap linked list.  */\ntypedef struct bitmap_head_def GTY(()) {\n  bitmap_element *first;\t/* First element in linked list.  */\n  bitmap_element *current;\t/* Last element looked at.  */\n  unsigned int indx;\t\t/* Index of last element looked at.  */\n  int using_obstack;\t\t/* Are we using an obstack or ggc for\n                                   allocation?  */\n} bitmap_head;\ntypedef struct bitmap_head_def *bitmap;\n\n/* Enumeration giving the various operations we support.  */\nenum bitmap_bits {\n  BITMAP_AND,\t\t\t/* TO = FROM1 & FROM2 */\n  BITMAP_AND_COMPL,\t\t/* TO = FROM1 & ~ FROM2 */\n  BITMAP_IOR,\t\t\t/* TO = FROM1 | FROM2 */\n  BITMAP_XOR,\t\t\t/* TO = FROM1 \u00ac FROM2 */\n  BITMAP_IOR_COMPL\t\t\t/* TO = FROM1 | ~FROM2 */\n};\n\n/* Global data */\nextern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n\n/* Clear a bitmap by freeing up the linked list.  */\nextern void bitmap_clear (bitmap);\n\n/* Copy a bitmap to another bitmap.  */\nextern void bitmap_copy (bitmap, bitmap);\n\n/* True if two bitmaps are identical.  */\nextern int bitmap_equal_p (bitmap, bitmap);\n\n/* Perform an operation on two bitmaps, yielding a third.  */\nextern int bitmap_operation (bitmap, bitmap, bitmap, enum bitmap_bits);\n\n/* `or' into one bitmap the `and' of a second bitmap witih the complement\n   of a third.  */\nextern void bitmap_ior_and_compl (bitmap, bitmap, bitmap);\n\n/* Clear a single register in a register set.  */\nextern void bitmap_clear_bit (bitmap, int);\n\n/* Set a single register in a register set.  */\nextern void bitmap_set_bit (bitmap, int);\n\n/* Return true if a register is set in a register set.  */\nextern int bitmap_bit_p (bitmap, int);\n\n/* Debug functions to print a bitmap linked list.  */\nextern void debug_bitmap (bitmap);\nextern void debug_bitmap_file (FILE *, bitmap);\n\n/* Print a bitmap.  */\nextern void bitmap_print (FILE *, bitmap, const char *, const char *);\n\n/* Initialize a bitmap header.  If HEAD is NULL, a new header will be\n   allocated.  USING_OBSTACK indicates how elements should be allocated.  */\nextern bitmap bitmap_initialize (bitmap head, int using_obstack);\n\n/* Release all memory used by the bitmap obstack.  */\nextern void bitmap_release_memory (void);\n\n/* A few compatibility/functions macros for compatibility with sbitmaps */\n#define dump_bitmap(file, bitmap) bitmap_print (file, bitmap, \"\", \"\\n\")\n#define bitmap_zero(a) bitmap_clear (a)\n#define bitmap_a_or_b(a,b,c) bitmap_operation (a, b, c, BITMAP_IOR)\n#define bitmap_a_and_b(a,b,c) bitmap_operation (a, b, c, BITMAP_AND)\nextern int bitmap_union_of_diff (bitmap, bitmap, bitmap, bitmap);\nextern int bitmap_first_set_bit (bitmap);\nextern int bitmap_last_set_bit (bitmap);\n\n/* Allocate a bitmap with oballoc.  */\n#define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n  bitmap_initialize (obstack_alloc (OBSTACK, sizeof (bitmap_head)), 1)\n\n/* Allocate a bitmap with ggc_alloc.  */\n#define BITMAP_GGC_ALLOC()\t\t\t\\\n  bitmap_initialize (NULL, 0)\n\n/* Allocate a bitmap with xmalloc.  */\n#define BITMAP_XMALLOC()                                        \\\n  bitmap_initialize (xmalloc (sizeof (bitmap_head)), 1)\n\n/* Do any cleanup needed on a bitmap when it is no longer used.  */\n#define BITMAP_FREE(BITMAP)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (BITMAP)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      bitmap_clear (BITMAP);\t\t\t\\\n      (BITMAP) = 0;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* Do any cleanup needed on an xmalloced bitmap when it is no longer used.  */\n#define BITMAP_XFREE(BITMAP)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (BITMAP)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      bitmap_clear (BITMAP);\t\t\t\\\n      free (BITMAP);\t\t\t\t\\\n      (BITMAP) = 0;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* Do any one-time initializations needed for bitmaps.  */\n#define BITMAP_INIT_ONCE()\n\n/* Loop over all bits in BITMAP, starting with MIN, setting BITNUM to the\n   bit number and executing CODE for all bits that are set.  */\n\n#define EXECUTE_IF_SET_IN_BITMAP(BITMAP, MIN, BITNUM, CODE)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr_ = (BITMAP)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in.  */\t\t\t\t\\\n  while (ptr_ != 0 && ptr_->indx < indx_)\t\t\t\t\\\n    ptr_ = ptr_->next;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr_ != 0 && ptr_->indx != indx_)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr_ != 0; ptr_ = ptr_->next)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  BITMAP_WORD word_ = ptr_->bits\u00ddword_num_\u00a8;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr_->indx * BITMAP_ELEMENT_ALL_BITS  \\\n\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n   BITNUM to the bit number and executing CODE for all bits that are set in\n   the first bitmap and not set in the second.  */\n\n#define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* Advance BITMAP2 to the equivalent link, using an all\t\t\\\n\t zero element if an equivalent link doesn't exist.  */\t\t\\\n      bitmap_element *tmp2_;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      tmp2_ = ((ptr2_ != 0 && ptr2_->indx == ptr1_->indx)\t\t\\\n\t       ? ptr2_ : &bitmap_zero_bits);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  BITMAP_WORD word_ = (ptr1_->bits\u00ddword_num_\u00a8\t\t\t\\\n\t\t\t       & ~ tmp2_->bits\u00ddword_num_\u00a8);\t\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/* Loop over all bits in BITMAP1 and BITMAP2, starting with MIN, setting\n   BITNUM to the bit number and executing CODE for all bits that are set in\n   the both bitmaps.  */\n\n#define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, CODE)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  bitmap_element *ptr1_ = (BITMAP1)->first;\t\t\t\t\\\n  bitmap_element *ptr2_ = (BITMAP2)->first;\t\t\t\t\\\n  unsigned int indx_ = (MIN) / BITMAP_ELEMENT_ALL_BITS;\t\t\t\\\n  unsigned bit_num_ = (MIN) % BITMAP_WORD_BITS;\t\t\t\t\\\n  unsigned word_num_ = (MIN) / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\t\\\n\t\t\t\t\t\t\t\t\t\\\n  /* Find the block the minimum bit is in in the first bitmap.  */\t\\\n  while (ptr1_ != 0 && ptr1_->indx < indx_)\t\t\t\t\\\n    ptr1_ = ptr1_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  if (ptr1_ != 0 && ptr1_->indx != indx_)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      bit_num_ = 0;\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (; ptr1_ != 0 ; ptr1_ = ptr1_->next)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      /* Advance BITMAP2 to the equivalent link.  */\t\t\t\\\n      while (ptr2_ != 0 && ptr2_->indx < ptr1_->indx)\t\t\t\\\n\tptr2_ = ptr2_->next;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      if (ptr2_ == 0)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  /* If there are no more elements in BITMAP2, exit loop now.  */ \\\n\t  ptr1_ = (bitmap_element *)0;\t\t\t\t\t\\\n\t  break;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else if (ptr2_->indx > ptr1_->indx)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = word_num_ = 0;\t\t\t\t\t\\\n\t  continue;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      for (; word_num_ < BITMAP_ELEMENT_WORDS; word_num_++)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  BITMAP_WORD word_ = (ptr1_->bits\u00ddword_num_\u00a8\t\t\t\\\n\t\t\t       & ptr2_->bits\u00ddword_num_\u00a8);\t\t\\\n\t  if (word_ != 0)\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      for (; bit_num_ < BITMAP_WORD_BITS; bit_num_++)\t\t\\\n\t\t{\t\t\t\t\t\t\t\\\n\t\t  BITMAP_WORD mask_ = ((BITMAP_WORD) 1) << bit_num_;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t  if ((word_ & mask_) != 0)\t\t\t\t\\\n\t\t    {\t\t\t\t\t\t\t\\\n\t\t      word_ &= ~ mask_;\t\t\t\t\t\\\n\t\t      (BITNUM) = (ptr1_->indx * BITMAP_ELEMENT_ALL_BITS \\\n\t\t\t\t  + word_num_ * BITMAP_WORD_BITS\t\\\n\t\t\t\t  + bit_num_);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t      CODE;\t\t\t\t\t\t\\\n\t\t      if (word_ == 0)\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t  bit_num_ = 0;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      word_num_ = 0;\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#endif /* GCC_BITMAP_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTINA": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n   Contributed by Joseph Myers <jsm28@cam.ac.uk>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This header provides a declarative way of describing the attributes\n   that are applied to some functions by default.\n\n   Before including this header, you must define the following macros.\n   In each case where there is an ENUM, it is an identifier used to\n   reference the tree in subsequent definitions.\n\n   DEF_ATTR_NULL_TREE (ENUM)\n\n     Constructs a NULL_TREE.\n\n   DEF_ATTR_INT (ENUM, VALUE)\n\n     Constructs an INTEGER_CST with value VALUE (an integer representable\n     in HOST_WIDE_INT).\n\n   DEF_ATTR_IDENT (ENUM, STRING)\n\n     Constructs an IDENTIFIER_NODE for STRING.\n\n   DEF_ATTR_TREE_LIST (ENUM, PURPOSE, VALUE, CHAIN)\n\n     Constructs a TREE_LIST with given PURPOSE, VALUE and CHAIN (given\n     as previous ENUM names).  */\n\nDEF_ATTR_NULL_TREE (ATTR_NULL)\n\n/* Construct a tree for a given integer and a list containing it.  */\n#define DEF_ATTR_FOR_INT(VALUE)\t\t\t\t\t\\\n  DEF_ATTR_INT (ATTR_##VALUE, VALUE)\t\t\t\\\n  DEF_ATTR_TREE_LIST (ATTR_LIST_##VALUE, ATTR_NULL,\t\\\n\t\t      ATTR_##VALUE, ATTR_NULL)\nDEF_ATTR_FOR_INT (0)\nDEF_ATTR_FOR_INT (1)\nDEF_ATTR_FOR_INT (2)\nDEF_ATTR_FOR_INT (3)\nDEF_ATTR_FOR_INT (4)\n#undef DEF_ATTR_FOR_INT\n\n/* Construct a tree for a list of two integers.  */\n#define DEF_LIST_INT_INT(VALUE1, VALUE2)\t\t\t\t \\\n  DEF_ATTR_TREE_LIST (ATTR_LIST_##VALUE1##_##VALUE2, ATTR_NULL,\t\t \\\n\t\t      ATTR_##VALUE1, ATTR_LIST_##VALUE2)\nDEF_LIST_INT_INT (1,0)\nDEF_LIST_INT_INT (1,2)\nDEF_LIST_INT_INT (2,0)\nDEF_LIST_INT_INT (2,3)\nDEF_LIST_INT_INT (3,0)\nDEF_LIST_INT_INT (3,4)\n#undef DEF_LIST_INT_INT\n\n/* Construct tress for identifiers.  */\nDEF_ATTR_IDENT (ATTR_CONST, \"const\")\nDEF_ATTR_IDENT (ATTR_FORMAT, \"format\")\nDEF_ATTR_IDENT (ATTR_FORMAT_ARG, \"format_arg\")\nDEF_ATTR_IDENT (ATTR_MALLOC, \"malloc\")\nDEF_ATTR_IDENT (ATTR_NONNULL, \"nonnull\")\nDEF_ATTR_IDENT (ATTR_NORETURN, \"noreturn\")\nDEF_ATTR_IDENT (ATTR_NOTHROW, \"nothrow\")\nDEF_ATTR_IDENT (ATTR_PRINTF, \"printf\")\nDEF_ATTR_IDENT (ATTR_ASM_FPRINTF, \"asm_fprintf\")\nDEF_ATTR_IDENT (ATTR_GCC_DIAG, \"gcc_diag\")\nDEF_ATTR_IDENT (ATTR_GCC_CDIAG, \"gcc_cdiag\")\nDEF_ATTR_IDENT (ATTR_GCC_CXXDIAG, \"gcc_cxxdiag\")\nDEF_ATTR_IDENT (ATTR_PURE, \"pure\")\nDEF_ATTR_IDENT (ATTR_SCANF, \"scanf\")\nDEF_ATTR_IDENT (ATTR_STRFMON, \"strfmon\")\nDEF_ATTR_IDENT (ATTR_STRFTIME, \"strftime\")\n\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_LIST, ATTR_NOTHROW, ATTR_NULL, ATTR_NULL)\n\nDEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_LIST, ATTR_CONST,\t\\\n\t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\nDEF_ATTR_TREE_LIST (ATTR_PURE_NOTHROW_LIST, ATTR_PURE,\t\t\\\n\t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\nDEF_ATTR_TREE_LIST (ATTR_NORETURN_NOTHROW_LIST, ATTR_NORETURN,\t\\\n\t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\nDEF_ATTR_TREE_LIST (ATTR_MALLOC_NOTHROW_LIST, ATTR_MALLOC,\t\\\n\t\t\tATTR_NULL, ATTR_NOTHROW_LIST)\n\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_1, ATTR_NONNULL, ATTR_LIST_1, \\\n\t\t\tATTR_NOTHROW_LIST)\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_2, ATTR_NONNULL, ATTR_LIST_2, \\\n\t\t\tATTR_NOTHROW_LIST)\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_3, ATTR_NONNULL, ATTR_LIST_3, \\\n\t\t\tATTR_NOTHROW_LIST)\n/* Nothrow functions whose first and second parameters are nonnull pointers.  */\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_1_2, ATTR_NONNULL, ATTR_LIST_2, \\\n\t\t\tATTR_NOTHROW_NONNULL_1)\n/* Nothrow functions whose first and fourth parameters are nonnull pointers.  */\nDEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_1_4, ATTR_NONNULL, ATTR_LIST_4, \\\n\t\t\tATTR_NOTHROW_NONNULL_1)\n/* Nothrow const functions whose first parameter is a nonnull pointer.  */\nDEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL_1, ATTR_CONST, ATTR_NULL, \\\n\t\t\tATTR_NOTHROW_NONNULL_1)\n/* Nothrow pure functions whose first parameter is a nonnull pointer.  */\nDEF_ATTR_TREE_LIST (ATTR_PURE_NOTHROW_NONNULL_1, ATTR_PURE, ATTR_NULL, \\\n\t\t\tATTR_NOTHROW_NONNULL_1)\n/* Nothrow pure functions whose first and second parameters are nonnull pointers.  */\nDEF_ATTR_TREE_LIST (ATTR_PURE_NOTHROW_NONNULL_1_2, ATTR_PURE, ATTR_NULL, \\\n\t\t\tATTR_NOTHROW_NONNULL_1_2)\n/* Nothrow malloc functions whose first parameter is a nonnull pointer.  */\nDEF_ATTR_TREE_LIST (ATTR_MALLOC_NOTHROW_NONNULL_1, ATTR_MALLOC, ATTR_NULL, \\\n\t\t\tATTR_NOTHROW_NONNULL_1)\n\n/* Construct a tree for a format attribute.  */\n#define DEF_FORMAT_ATTRIBUTE(TYPE, FA, VALUES)\t\t\t\t \\\n  DEF_ATTR_TREE_LIST (ATTR_##TYPE##_##VALUES, ATTR_NULL,\t\t \\\n\t\t      ATTR_##TYPE, ATTR_LIST_##VALUES)\t\t\t \\\n  DEF_ATTR_TREE_LIST (ATTR_FORMAT_##TYPE##_##VALUES, ATTR_FORMAT,\t \\\n\t\t      ATTR_##TYPE##_##VALUES, ATTR_NOTHROW_NONNULL_##FA)\nDEF_FORMAT_ATTRIBUTE(PRINTF,1,1_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,1,1_2)\nDEF_FORMAT_ATTRIBUTE(PRINTF,2,2_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,2,2_3)\nDEF_FORMAT_ATTRIBUTE(PRINTF,3,3_0)\nDEF_FORMAT_ATTRIBUTE(PRINTF,3,3_4)\nDEF_FORMAT_ATTRIBUTE(SCANF,1,1_0)\nDEF_FORMAT_ATTRIBUTE(SCANF,1,1_2)\nDEF_FORMAT_ATTRIBUTE(SCANF,2,2_0)\nDEF_FORMAT_ATTRIBUTE(SCANF,2,2_3)\nDEF_FORMAT_ATTRIBUTE(STRFTIME,3,3_0)\nDEF_FORMAT_ATTRIBUTE(STRFMON,3,3_4)\n#undef DEF_FORMAT_ATTRIBUTE\n\n/* Construct a tree for a format_arg attribute.  */\n#define DEF_FORMAT_ARG_ATTRIBUTE(FA)\t\t\t\t\t\\\n  DEF_ATTR_TREE_LIST (ATTR_FORMAT_ARG_##FA, ATTR_FORMAT_ARG,\t\t\\\n\t\t      ATTR_LIST_##FA, ATTR_NOTHROW_NONNULL_##FA)\nDEF_FORMAT_ARG_ATTRIBUTE(1)\nDEF_FORMAT_ARG_ATTRIBUTE(2)\n#undef DEF_FORMAT_ARG_ATTRIBUTE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTIND": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   builtins used in the GNU compiler.\n   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Before including this file, you should define a macro:\n\n     DEF_BUILTIN (ENUM, NAME, CLASS, TYPE, LIBTYPE, BOTH_P,\n                  FALLBACK_P, NONANSI_P, ATTRS, IMPLICIT)\n\n   This macro will be called once for each builtin function.  The\n   ENUM will be of type `enum built_in_function', and will indicate\n   which builtin function is being processed.  The NAME of the builtin\n   function (which will always start with `__builtin_') is a string\n   literal.  The CLASS is of type `enum built_in_class' and indicates\n   what kind of builtin is being processed.\n\n   Some builtins are actually two separate functions.  For example,\n   for `strcmp' there are two builtin functions; `__builtin_strcmp'\n   and `strcmp' itself.  Both behave identically.  Other builtins\n   define only the `__builtin' variant.  If BOTH_P is TRUE, then this\n   builtin has both variants; otherwise, it is has only the first\n   variant.\n\n   TYPE indicates the type of the function.  The symbols correspond to\n   enumerals from builtin-types.def.  If BOTH_P is true, then LIBTYPE\n   is the type of the non-`__builtin_' variant.  Otherwise, LIBTYPE\n   should be ignored.\n\n   If FALLBACK_P is true then, if for some reason, the compiler cannot\n   expand the builtin function directly, it will call the\n   corresponding library function (which does not have the\n   `__builtin_' prefix.\n\n   If NONANSI_P is true, then the non-`__builtin_' variant is not an\n   ANSI/ISO library function, and so we should pretend it does not\n   exist when compiling in ANSI conformant mode.\n\n   ATTRs is an attribute list as defined in builtin-attrs.def that\n   describes the attributes of this builtin function.\n\n   IMPLICIT specifies condition when the builtin can be produced by\n   compiler.  For instance C90 reserves floorf function, but does not\n   define it's meaning.  When user uses floorf we may assume that the\n   floorf has the meaning we expect, but we can't produce floorf by\n   simplifying floor((double)float) since the runtime need not implement\n   it.  */\n\n/* A GCC builtin (like __builtin_saveregs) is provided by the\n   compiler, but does not correspond to a function in the standard\n   library.  */\n#undef DEF_GCC_BUILTIN\n#define DEF_GCC_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\\\n  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, BT_LAST,\t\\\n               false, false, false, ATTRS, true)\n\n/* A library builtin (like __builtin_strchr) is a builtin equivalent\n   of an ANSI/ISO standard library function.  In addition to the\n   `__builtin' version, we will create an ordinary version (e.g,\n   `strchr') as well.  If we cannot compute the answer using the\n   builtin function, we will fall back to the standard library\n   version.  */\n#undef DEF_LIB_BUILTIN\n#define DEF_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n\t       true, true, false, ATTRS, true)\n\n/* Like DEF_LIB_BUILTIN, except that the function is not one that is\n   specified by ANSI/ISO C.  So, when we're being fully conformant we\n   ignore the version of these builtins that does not begin with\n   __builtin.  */\n#undef DEF_EXT_LIB_BUILTIN\n#define DEF_EXT_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n   \t       true, true, true, ATTRS, false)\n\n/* Like DEF_LIB_BUILTIN, except that the function is only a part of\n   the standard in C99 or above.  */\n#undef DEF_C99_BUILTIN\n#define DEF_C99_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n   \t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS)\n\n/* Builtin that is specified by C99 and C90 reserve the name for future use.\n   We can still recognize the builtin in C90 mode but we can't produce it\n   implicitly.  */\n#undef DEF_C99_C90RES_BUILTIN\n#define DEF_C99_C90RES_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n   \t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS)\n\n/* Define an attribute list for math functions that are normally\n   \"impure\" because some of them may write into global memory for\n   `errno'.  If !flag_errno_math they are instead \"const\".  */\n#undef ATTR_MATHFN_ERRNO\n#define ATTR_MATHFN_ERRNO (flag_errno_math ? \\\n\tATTR_NOTHROW_LIST : ATTR_CONST_NOTHROW_LIST)\n\n/* Define an attribute list for math functions that are normally\n   \"pure\" but if flag_unsafe_math_optimizations is set they are\n   instead \"const\".  This distinction accounts for the fact that some\n   math functions check the rounding mode which is akin to examing\n   global memory.  In \"unsafe\" mode we can be less careful.  */\n#undef ATTR_MATHFN_FPROUNDING\n#define ATTR_MATHFN_FPROUNDING (flag_unsafe_math_optimizations ? \\\n\tATTR_CONST_NOTHROW_LIST : ATTR_PURE_NOTHROW_LIST)\n\n/* Define an attribute list for math functions that are normally\n   \"impure\" because some of them may write into global memory for\n   `errno'.  If !flag_errno_math, we can possibly use \"pure\" or\n   \"const\" depending on whether we care about FP rounding.  */\n#undef ATTR_MATHFN_FPROUNDING_ERRNO\n#define ATTR_MATHFN_FPROUNDING_ERRNO (flag_errno_math ? \\\n\tATTR_NOTHROW_LIST : ATTR_MATHFN_FPROUNDING)\n\n/* Define an attribute list for math functions that need to mind FP\n   rounding, but because they store into memory they are never \"const\"\n   or \"pure\".  Use of this macro is mainly for documentation and\n   maintenance purposes.  */\n#undef ATTR_MATHFN_FPROUNDING_STORE\n#define ATTR_MATHFN_FPROUNDING_STORE ATTR_NOTHROW_LIST\n\n/* Category: math builtins.  */\nDEF_LIB_BUILTIN        (BUILT_IN_ACOS, \"acos\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ACOSF, \"acosf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ACOSH, \"acosh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ACOSHF, \"acoshf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ACOSHL, \"acoshl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ACOSL, \"acosl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_ASIN, \"asin\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ASINF, \"asinf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ASINH, \"asinh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_ASINHF, \"asinhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_ASINHL, \"asinhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ASINL, \"asinl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_ATAN, \"atan\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_ATAN2, \"atan2\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ATAN2F, \"atan2f\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ATAN2L, \"atan2l\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ATANF, \"atanf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_ATANH, \"atanh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ATANHF, \"atanhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ATANHL, \"atanhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_ATANL, \"atanl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CBRT, \"cbrt\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CBRTF, \"cbrtf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CBRTL, \"cbrtl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_CEIL, \"ceil\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_CEILF, \"ceilf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_CEILL, \"ceill\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_COPYSIGN, \"copysign\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_COPYSIGNF, \"copysignf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_COPYSIGNL, \"copysignl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_COS, \"cos\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_COSF, \"cosf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_COSH, \"cosh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_COSHF, \"coshf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_COSHL, \"coshl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_COSL, \"cosl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_DREM, \"drem\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_DREMF, \"dremf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_DREML, \"dreml\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ERF, \"erf\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_ERFC, \"erfc\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ERFCF, \"erfcf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ERFCL, \"erfcl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ERFF, \"erff\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_ERFL, \"erfl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_EXP, \"exp\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_EXP10, \"exp10\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_EXP10F, \"exp10f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_EXP10L, \"exp10l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXP2, \"exp2\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXP2F, \"exp2f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXP2L, \"exp2l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_EXPF, \"expf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_EXPL, \"expl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXPM1, \"expm1\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXPM1F, \"expm1f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_EXPM1L, \"expm1l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_FABS, \"fabs\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FABSF, \"fabsf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FABSL, \"fabsl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FDIM, \"fdim\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_FDIMF, \"fdimf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_FDIML, \"fdiml\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_FLOOR, \"floor\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FLOORF, \"floorf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FLOORL, \"floorl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMA, \"fma\", BT_FN_DOUBLE_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_FMAF, \"fmaf\", BT_FN_FLOAT_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_FMAL, \"fmal\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_FMAX, \"fmax\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMAXF, \"fmaxf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMAXL, \"fmaxl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMIN, \"fmin\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMINF, \"fminf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_FMINL, \"fminl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_FMOD, \"fmod\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FMODF, \"fmodf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FMODL, \"fmodl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_FREXP, \"frexp\", BT_FN_DOUBLE_DOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FREXPF, \"frexpf\", BT_FN_FLOAT_FLOAT_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_FREXPL, \"frexpl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMA, \"gamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMAF, \"gammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_GAMMAL, \"gammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_GCC_BUILTIN        (BUILT_IN_HUGE_VAL, \"huge_val\", BT_FN_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_HUGE_VALF, \"huge_valf\", BT_FN_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_HUGE_VALL, \"huge_vall\", BT_FN_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_HYPOT, \"hypot\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_HYPOTF, \"hypotf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_HYPOTL, \"hypotl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ILOGB, \"ilogb\", BT_FN_INT_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ILOGBF, \"ilogbf\", BT_FN_INT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ILOGBL, \"ilogbl\", BT_FN_INT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_GCC_BUILTIN        (BUILT_IN_INF, \"inf\", BT_FN_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_INFF, \"inff\", BT_FN_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_INFL, \"infl\", BT_FN_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J0, \"j0\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J0F, \"j0f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J0L, \"j0l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J1, \"j1\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J1F, \"j1f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_J1L, \"j1l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_JN, \"jn\", BT_FN_DOUBLE_INT_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_JNF, \"jnf\", BT_FN_FLOAT_INT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_JNL, \"jnl\", BT_FN_LONGDOUBLE_INT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_LDEXP, \"ldexp\", BT_FN_DOUBLE_DOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LDEXPF, \"ldexpf\", BT_FN_FLOAT_FLOAT_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LDEXPL, \"ldexpl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LGAMMA, \"lgamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LGAMMAF, \"lgammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LGAMMAL, \"lgammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLRINT, \"llrint\", BT_FN_LONGLONG_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLRINTF, \"llrintf\", BT_FN_LONGLONG_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLRINTL, \"llrintl\", BT_FN_LONGLONG_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLROUND, \"llround\", BT_FN_LONGLONG_DOUBLE, ATTR_MATHFN_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLROUNDF, \"llroundf\", BT_FN_LONGLONG_FLOAT, ATTR_MATHFN_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LLROUNDL, \"llroundl\", BT_FN_LONGLONG_LONGDOUBLE, ATTR_MATHFN_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_LOG, \"log\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_LOG10, \"log10\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LOG10F, \"log10f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LOG10L, \"log10l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG1P, \"log1p\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG1PF, \"log1pf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG1PL, \"log1pl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG2, \"log2\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG2F, \"log2f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOG2L, \"log2l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOGB, \"logb\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOGBF, \"logbf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LOGBL, \"logbl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LOGF, \"logf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_LOGL, \"logl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LRINT, \"lrint\", BT_FN_LONG_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LRINTF, \"lrintf\", BT_FN_LONG_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LRINTL, \"lrintl\", BT_FN_LONG_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LROUND, \"lround\", BT_FN_LONG_DOUBLE, ATTR_MATHFN_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LROUNDF, \"lroundf\", BT_FN_LONG_FLOAT, ATTR_MATHFN_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_LROUNDL, \"lroundl\", BT_FN_LONG_LONGDOUBLE, ATTR_MATHFN_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_MODF, \"modf\", BT_FN_DOUBLE_DOUBLE_DOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_MODFF, \"modff\", BT_FN_FLOAT_FLOAT_FLOATPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_MODFL, \"modfl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_GCC_BUILTIN        (BUILT_IN_NAN, \"nan\", BT_FN_DOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_GCC_BUILTIN        (BUILT_IN_NANF, \"nanf\", BT_FN_FLOAT_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_GCC_BUILTIN        (BUILT_IN_NANL, \"nanl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_GCC_BUILTIN        (BUILT_IN_NANS, \"nans\", BT_FN_DOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_GCC_BUILTIN        (BUILT_IN_NANSF, \"nansf\", BT_FN_FLOAT_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_GCC_BUILTIN        (BUILT_IN_NANSL, \"nansl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL_1)\nDEF_C99_BUILTIN        (BUILT_IN_NEARBYINT, \"nearbyint\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_NEARBYINTF, \"nearbyintf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_NEARBYINTL, \"nearbyintl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTAFTER, \"nextafter\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTAFTERF, \"nextafterf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTAFTERL, \"nextafterl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARD, \"nexttoward\", BT_FN_DOUBLE_DOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARDF, \"nexttowardf\", BT_FN_FLOAT_FLOAT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_NEXTTOWARDL, \"nexttowardl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_POW, \"pow\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_POW10, \"pow10\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_POW10F, \"pow10f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_POW10L, \"pow10l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_POWF, \"powf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_POWL, \"powl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_REMAINDER, \"remainder\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_REMAINDERF, \"remainderf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_REMAINDERL, \"remainderl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_REMQUO, \"remquo\", BT_FN_DOUBLE_DOUBLE_DOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_BUILTIN        (BUILT_IN_REMQUOF, \"remquof\", BT_FN_FLOAT_FLOAT_FLOAT_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_BUILTIN        (BUILT_IN_REMQUOL, \"remquol\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_INTPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_BUILTIN        (BUILT_IN_RINT, \"rint\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_RINTF, \"rintf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_RINTL, \"rintl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_ROUND, \"round\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_ROUNDF, \"roundf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_ROUNDL, \"roundl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SCALB, \"scalb\", BT_FN_DOUBLE_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SCALBF, \"scalbf\", BT_FN_FLOAT_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SCALBL, \"scalbl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBLN, \"scalbln\", BT_FN_DOUBLE_DOUBLE_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBLNF, \"scalblnf\", BT_FN_FLOAT_FLOAT_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBLNL, \"scalblnl\", BT_FN_LONGDOUBLE_LONGDOUBLE_LONG, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBN, \"scalbn\", BT_FN_DOUBLE_DOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBNF, \"scalbnf\", BT_FN_FLOAT_FLOAT_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_SCALBNL, \"scalbnl\", BT_FN_LONGDOUBLE_LONGDOUBLE_INT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNIFICAND, \"significand\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNIFICANDF, \"significandf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SIGNIFICANDL, \"significandl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_SIN, \"sin\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SINCOS, \"sincos\", BT_FN_VOID_DOUBLE_DOUBLEPTR_DOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SINCOSF, \"sincosf\", BT_FN_VOID_FLOAT_FLOATPTR_FLOATPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_SINCOSL, \"sincosl\", BT_FN_VOID_LONGDOUBLE_LONGDOUBLEPTR_LONGDOUBLEPTR, ATTR_MATHFN_FPROUNDING_STORE)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SINF, \"sinf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_SINH, \"sinh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SINHF, \"sinhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SINHL, \"sinhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SINL, \"sinl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_SQRT, \"sqrt\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SQRTF, \"sqrtf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_SQRTL, \"sqrtl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_LIB_BUILTIN        (BUILT_IN_TAN, \"tan\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_TANF, \"tanf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_LIB_BUILTIN        (BUILT_IN_TANH, \"tanh\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_TANHF, \"tanhf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_TANHL, \"tanhl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_C90RES_BUILTIN (BUILT_IN_TANL, \"tanl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_TGAMMA, \"tgamma\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_TGAMMAF, \"tgammaf\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_TGAMMAL, \"tgammal\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_C99_BUILTIN        (BUILT_IN_TRUNC, \"trunc\", BT_FN_DOUBLE_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_TRUNCF, \"truncf\", BT_FN_FLOAT_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_TRUNCL, \"truncl\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y0, \"y0\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y0F, \"y0f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y0L, \"y0l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y1, \"y1\", BT_FN_DOUBLE_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y1F, \"y1f\", BT_FN_FLOAT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_Y1L, \"y1l\", BT_FN_LONGDOUBLE_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_YN, \"yn\", BT_FN_DOUBLE_INT_DOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_YNF, \"ynf\", BT_FN_FLOAT_INT_FLOAT, ATTR_MATHFN_FPROUNDING_ERRNO)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_YNL, \"ynl\", BT_FN_LONGDOUBLE_INT_LONGDOUBLE, ATTR_MATHFN_FPROUNDING_ERRNO)\n\n/* Category: _Complex math builtins.  */\n/* The C99 clog function conflicts with C++ iostreams clog, see\n   http://gcc.gnu.org/ml/gcc-patches/2003-09/msg00510.html  */\nDEF_C99_BUILTIN        (BUILT_IN_CABS, \"cabs\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CABSF, \"cabsf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CABSL, \"cabsl\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOS, \"cacos\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOSF, \"cacosf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOSH, \"cacosh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOSHF, \"cacoshf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOSHL, \"cacoshl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CACOSL, \"cacosl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CARG, \"carg\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CARGF, \"cargf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CARGL, \"cargl\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASIN, \"casin\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASINF, \"casinf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASINH, \"casinh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASINHF, \"casinhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASINHL, \"casinhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CASINL, \"casinl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATAN, \"catan\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATANF, \"catanf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATANH, \"catanh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATANHF, \"catanhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATANHL, \"catanhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CATANL, \"catanl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOS, \"ccos\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOSF, \"ccosf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOSH, \"ccosh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOSHF, \"ccoshf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOSHL, \"ccoshl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CCOSL, \"ccosl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CEXP, \"cexp\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CEXPF, \"cexpf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CEXPL, \"cexpl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CIMAG, \"cimag\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CIMAGF, \"cimagf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CIMAGL, \"cimagl\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\n/*DEF_C99_BUILTIN        (BUILT_IN_CLOG, \"clog\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)*/\n/*DEF_C99_BUILTIN        (BUILT_IN_CLOGF, \"clogf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)*/\n/*DEF_C99_BUILTIN        (BUILT_IN_CLOGL, \"clogl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)*/\nDEF_C99_BUILTIN        (BUILT_IN_CONJ, \"conj\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CONJF, \"conjf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CONJL, \"conjl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CPOW, \"cpow\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CPOWF, \"cpowf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CPOWL, \"cpowl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CPROJ, \"cproj\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CPROJF, \"cprojf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CPROJL, \"cprojl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CREAL, \"creal\", BT_FN_DOUBLE_COMPLEX_DOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CREALF, \"crealf\", BT_FN_FLOAT_COMPLEX_FLOAT, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CREALL, \"creall\", BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_CSIN, \"csin\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSINF, \"csinf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSINH, \"csinh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSINHF, \"csinhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSINHL, \"csinhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSINL, \"csinl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSQRT, \"csqrt\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSQRTF, \"csqrtf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CSQRTL, \"csqrtl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTAN, \"ctan\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTANF, \"ctanf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTANH, \"ctanh\", BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTANHF, \"ctanhf\", BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTANHL, \"ctanhl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\nDEF_C99_BUILTIN        (BUILT_IN_CTANL, \"ctanl\", BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, ATTR_MATHFN_FPROUNDING)\n\n/* Category: string/memory builtins.  */\n/* bcmp, bcopy and bzero have traditionally accepted NULL pointers\n   when the length parameter is zero, so don't apply attribute \"nonnull\".  */\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_BCMP, \"bcmp\", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_BCOPY, \"bcopy\", BT_FN_VOID_CONST_PTR_PTR_SIZE, ATTR_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_BZERO, \"bzero\", BT_FN_VOID_PTR_SIZE, ATTR_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FFS, \"ffs\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSL, \"ffsl\", BT_FN_INT_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSLL, \"ffsll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_INDEX, \"index\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_MEMCMP, \"memcmp\", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_MEMCPY, \"memcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_MEMMOVE, \"memmove\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_1_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY, \"mempcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_MEMSET, \"memset\", BT_FN_PTR_PTR_INT_SIZE, ATTR_NOTHROW_NONNULL_1)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_RINDEX, \"rindex\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_1)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY, \"stpcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRCAT, \"strcat\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRCHR, \"strchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_STRCMP, \"strcmp\", BT_FN_INT_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRCPY, \"strcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRCSPN, \"strcspn\", BT_FN_SIZE_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_STRDUP, \"strdup\", BT_FN_STRING_CONST_STRING, ATTR_MALLOC_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_STRLEN, \"strlen\", BT_FN_SIZE_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_STRNCAT, \"strncat\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRNCMP, \"strncmp\", BT_FN_INT_CONST_STRING_CONST_STRING_SIZE, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRNCPY, \"strncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRPBRK, \"strpbrk\", BT_FN_STRING_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRRCHR, \"strrchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_STRSPN, \"strspn\", BT_FN_SIZE_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_STRSTR, \"strstr\", BT_FN_STRING_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_1_2)\n\n/* Category: stdio builtins.  */\nDEF_LIB_BUILTIN        (BUILT_IN_FPRINTF, \"fprintf\", BT_FN_INT_PTR_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_2_3)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FPRINTF_UNLOCKED, \"fprintf_unlocked\", BT_FN_INT_PTR_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_2_3)\nDEF_LIB_BUILTIN        (BUILT_IN_FPUTC, \"fputc\", BT_FN_INT_INT_PTR, ATTR_NOTHROW_NONNULL_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FPUTC_UNLOCKED, \"fputc_unlocked\", BT_FN_INT_INT_PTR, ATTR_NOTHROW_NONNULL_2)\nDEF_LIB_BUILTIN        (BUILT_IN_FPUTS, \"fputs\", BT_FN_INT_CONST_STRING_PTR, ATTR_NOTHROW_NONNULL_1_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FPUTS_UNLOCKED, \"fputs_unlocked\", BT_FN_INT_CONST_STRING_PTR, ATTR_NOTHROW_NONNULL_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_FSCANF, \"fscanf\", BT_FN_INT_PTR_CONST_STRING_VAR, ATTR_FORMAT_SCANF_2_3)\nDEF_LIB_BUILTIN        (BUILT_IN_FWRITE, \"fwrite\", BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR, ATTR_NOTHROW_NONNULL_1_4)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_FWRITE_UNLOCKED, \"fwrite_unlocked\", BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR, ATTR_NOTHROW_NONNULL_1_4)\nDEF_LIB_BUILTIN        (BUILT_IN_PRINTF, \"printf\", BT_FN_INT_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_1_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_PRINTF_UNLOCKED, \"printf_unlocked\", BT_FN_INT_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_1_2)\nDEF_LIB_BUILTIN        (BUILT_IN_PUTCHAR, \"putchar\", BT_FN_INT_INT, ATTR_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_PUTCHAR_UNLOCKED, \"putchar_unlocked\", BT_FN_INT_INT, ATTR_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_PUTS, \"puts\", BT_FN_INT_CONST_STRING, ATTR_NOTHROW_NONNULL_1)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_PUTS_UNLOCKED, \"puts_unlocked\", BT_FN_INT_CONST_STRING, ATTR_NOTHROW_NONNULL_1)\nDEF_LIB_BUILTIN        (BUILT_IN_SCANF, \"scanf\", BT_FN_INT_CONST_STRING_VAR, ATTR_FORMAT_SCANF_1_2)\nDEF_C99_BUILTIN        (BUILT_IN_SNPRINTF, \"snprintf\", BT_FN_INT_STRING_SIZE_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_3_4)\nDEF_LIB_BUILTIN        (BUILT_IN_SPRINTF, \"sprintf\", BT_FN_INT_STRING_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_2_3)\nDEF_LIB_BUILTIN        (BUILT_IN_SSCANF, \"sscanf\", BT_FN_INT_CONST_STRING_CONST_STRING_VAR, ATTR_FORMAT_SCANF_2_3)\nDEF_LIB_BUILTIN        (BUILT_IN_VFPRINTF, \"vfprintf\", BT_FN_INT_PTR_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_2_0)\nDEF_C99_BUILTIN        (BUILT_IN_VFSCANF, \"vfscanf\", BT_FN_INT_PTR_CONST_STRING_VALIST_ARG, ATTR_FORMAT_SCANF_2_0)\nDEF_LIB_BUILTIN        (BUILT_IN_VPRINTF, \"vprintf\", BT_FN_INT_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_1_0)\nDEF_C99_BUILTIN        (BUILT_IN_VSCANF, \"vscanf\", BT_FN_INT_CONST_STRING_VALIST_ARG, ATTR_FORMAT_SCANF_1_0)\nDEF_C99_BUILTIN        (BUILT_IN_VSNPRINTF, \"vsnprintf\", BT_FN_INT_STRING_SIZE_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_3_0)\nDEF_LIB_BUILTIN        (BUILT_IN_VSPRINTF, \"vsprintf\", BT_FN_INT_STRING_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_2_0)\nDEF_C99_BUILTIN        (BUILT_IN_VSSCANF, \"vsscanf\", BT_FN_INT_CONST_STRING_CONST_STRING_VALIST_ARG, ATTR_FORMAT_SCANF_2_0)\n\n/* Category: miscellaneous builtins.  */\nDEF_LIB_BUILTIN        (BUILT_IN_ABORT, \"abort\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_ABS, \"abs\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_AGGREGATE_INCOMING_ADDRESS, \"aggregate_incoming_address\", BT_FN_PTR_VAR, ATTR_NULL)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_ALLOCA, \"alloca\", BT_FN_PTR_SIZE, ATTR_MALLOC_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_APPLY, \"apply\", BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_APPLY_ARGS, \"apply_args\", BT_FN_PTR_VAR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_ARGS_INFO, \"args_info\", BT_FN_INT_INT, ATTR_NULL)\nDEF_LIB_BUILTIN        (BUILT_IN_CALLOC, \"calloc\", BT_FN_PTR_SIZE_SIZE, ATTR_MALLOC_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CLASSIFY_TYPE, \"classify_type\", BT_FN_INT_VAR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_CLZ, \"clz\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CLZL, \"clzl\", BT_FN_INT_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CLZLL, \"clzll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CONSTANT_P, \"constant_p\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CTZ, \"ctz\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CTZL, \"ctzl\", BT_FN_INT_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_CTZLL, \"ctzll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_DCGETTEXT, \"dcgettext\", BT_FN_STRING_CONST_STRING_CONST_STRING_INT, ATTR_FORMAT_ARG_2)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_DGETTEXT, \"dgettext\", BT_FN_STRING_CONST_STRING_CONST_STRING, ATTR_FORMAT_ARG_2)\nDEF_GCC_BUILTIN        (BUILT_IN_DWARF_CFA, \"dwarf_cfa\", BT_FN_PTR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_DWARF_SP_COLUMN, \"dwarf_sp_column\", BT_FN_UNSIGNED, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_EH_RETURN, \"eh_return\", BT_FN_VOID_PTRMODE_PTR, ATTR_NORETURN_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_EH_RETURN_DATA_REGNO, \"eh_return_data_regno\", BT_FN_INT_INT, ATTR_NULL)\nDEF_LIB_BUILTIN        (BUILT_IN_EXIT, \"exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_EXPECT, \"expect\", BT_FN_LONG_LONG_LONG, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_EXTEND_POINTER, \"extend_pointer\", BT_FN_WORD_PTR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_EXTRACT_RETURN_ADDR, \"extract_return_addr\", BT_FN_PTR_PTR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_FRAME_ADDRESS, \"frame_address\", BT_FN_PTR_UNSIGNED, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_FROB_RETURN_ADDR, \"frob_return_addr\", BT_FN_PTR_PTR, ATTR_NULL)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_GETTEXT, \"gettext\", BT_FN_STRING_CONST_STRING, ATTR_FORMAT_ARG_1)\nDEF_C99_BUILTIN        (BUILT_IN_IMAXABS, \"imaxabs\", BT_FN_INTMAX_INTMAX, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_INIT_DWARF_REG_SIZES, \"init_dwarf_reg_size_table\", BT_FN_VOID_PTR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_ISGREATER, \"isgreater\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_ISGREATEREQUAL, \"isgreaterequal\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_ISLESS, \"isless\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_ISLESSEQUAL, \"islessequal\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_ISLESSGREATER, \"islessgreater\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_ISUNORDERED, \"isunordered\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_LABS, \"labs\", BT_FN_LONG_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN_LLABS, \"llabs\", BT_FN_LONGLONG_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_LONGJMP, \"longjmp\", BT_FN_VOID_PTR_INT, ATTR_NORETURN_NOTHROW_LIST)\nDEF_LIB_BUILTIN        (BUILT_IN_MALLOC, \"malloc\", BT_FN_PTR_SIZE, ATTR_MALLOC_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_NEXT_ARG, \"next_arg\", BT_FN_PTR_VAR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_PARITY, \"parity\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_PARITYL, \"parityl\", BT_FN_INT_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_PARITYLL, \"parityll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_POPCOUNT, \"popcount\", BT_FN_INT_INT, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTL, \"popcountl\", BT_FN_INT_LONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_POPCOUNTLL, \"popcountll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_PREFETCH, \"prefetch\", BT_FN_VOID_CONST_PTR_VAR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_RETURN, \"return\", BT_FN_VOID_PTR, ATTR_NORETURN_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_RETURN_ADDRESS, \"return_address\", BT_FN_PTR_UNSIGNED, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_SAVEREGS, \"saveregs\", BT_FN_PTR_VAR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_SETJMP, \"setjmp\", BT_FN_INT_PTR, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_STDARG_START, \"stdarg_start\", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN_STRFMON, \"strfmon\", BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR, ATTR_FORMAT_STRFMON_3_4)\nDEF_LIB_BUILTIN        (BUILT_IN_STRFTIME, \"strftime\", BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_PTR, ATTR_FORMAT_STRFTIME_3_0)\nDEF_GCC_BUILTIN        (BUILT_IN_TRAP, \"trap\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LIST)\nDEF_GCC_BUILTIN        (BUILT_IN_UNWIND_INIT, \"unwind_init\", BT_FN_VOID, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_VA_COPY, \"va_copy\", BT_FN_VOID_VALIST_REF_VALIST_ARG, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_VA_END, \"va_end\", BT_FN_VOID_VALIST_REF, ATTR_NULL)\nDEF_GCC_BUILTIN        (BUILT_IN_VA_START, \"va_start\", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)\nDEF_EXT_LIB_BUILTIN    (BUILT_IN__EXIT, \"_exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\nDEF_C99_BUILTIN        (BUILT_IN__EXIT2, \"_Exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILTINT": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This header provides a declaritive way of describing the types that\n   are used when declaring builtin functions.\n\n   Before including this header, you must define the following macros:\n\n   DEF_PRIMITIVE_TYPE (ENUM, TYPE)\n\n     The ENUM is an identifier indicating which type is being defined.\n     TYPE is an expression for a `tree' that represents the type.\n\n   DEF_FUNCTION_TYPE_0 (ENUM, RETURN)\n   DEF_FUNCTION_TYPE_1 (ENUM, RETURN, ARG1)\n   DEF_FUNCTION_TYPE_2 (ENUM, RETURN, ARG1, ARG2)\n   DEF_FUNCTION_TYPE_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n   DEF_FUNCTION_TYPE_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n\n     These macros describe function types.  ENUM is as above.  The\n     RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n     and ARG3 give the types of the arguments, similarly.\n\n   DEF_FUNCTION_TYPE_VAR_0 (ENUM, RETURN)\n   DEF_FUNCTION_TYPE_VAR_1 (ENUM, RETURN, ARG1)\n   DEF_FUNCTION_TYPE_VAR_2 (ENUM, RETURN, ARG1, ARG2)\n   DEF_FUNCTION_TYPE_VAR_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n\n     Similar, but for function types that take variable arguments.\n     For example:\n\n       DEF_FUNCTION_TYPE_1 (BT_INT_DOUBLE, BT_INT, BT_DOUBLE)\n\n     describes the type `int ()(double)', using the enumeral\n     BT_INT_DOUBLE, whereas:\n\n       DEF_FUNCTION_TYPE_VAR_1 (BT_INT_DOUBLE_VAR, BT_INT, BT_DOUBLE)\n\n     describes the type `int ()(double, ...)'.\n\n  DEF_POINTER_TYPE (ENUM, TYPE)\n\n    This macro describes a pointer type.  ENUM is as above; TYPE is\n    the type pointed to.  */\n\nDEF_PRIMITIVE_TYPE (BT_VOID, void_type_node)\nDEF_PRIMITIVE_TYPE (BT_INT, integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_UNSIGNED, unsigned_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONGLONG, long_long_integer_type_node)\nDEF_PRIMITIVE_TYPE (BT_WORD, (*lang_hooks.types.type_for_mode) (word_mode, 0))\nDEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)\nDEF_PRIMITIVE_TYPE (BT_INTMAX, intmax_type_node)\nDEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_FLOAT, complex_float_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_DOUBLE, complex_double_type_node)\nDEF_PRIMITIVE_TYPE (BT_COMPLEX_LONGDOUBLE, complex_long_double_type_node)\n\nDEF_PRIMITIVE_TYPE (BT_PTR, ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_CONST_PTR, const_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_PTRMODE, (*lang_hooks.types.type_for_mode)(ptr_mode, 0))\nDEF_PRIMITIVE_TYPE (BT_INT_PTR, integer_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_FLOAT_PTR, float_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_DOUBLE_PTR, double_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_LONGDOUBLE_PTR, long_double_ptr_type_node)\nDEF_PRIMITIVE_TYPE (BT_SIZE, size_type_node)\nDEF_PRIMITIVE_TYPE (BT_SSIZE, signed_size_type_node)\nDEF_PRIMITIVE_TYPE (BT_STRING, string_type_node)\nDEF_PRIMITIVE_TYPE (BT_CONST_STRING, const_string_type_node)\n\nDEF_PRIMITIVE_TYPE (BT_VALIST_REF, va_list_ref_type_node)\nDEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n\nDEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\nDEF_FUNCTION_TYPE_0 (BT_FN_PTR, BT_PTR)\nDEF_FUNCTION_TYPE_0 (BT_FN_UNSIGNED, BT_UNSIGNED)\nDEF_FUNCTION_TYPE_0 (BT_FN_FLOAT, BT_FLOAT)\nDEF_FUNCTION_TYPE_0 (BT_FN_DOUBLE, BT_DOUBLE)\n/* For \"long double\" we use LONGDOUBLE (not LONG_DOUBLE) to\n   distinguish it from two types in sequence, \"long\" followed by\n   \"double\".  */\nDEF_FUNCTION_TYPE_0 (BT_FN_LONGDOUBLE, BT_LONGDOUBLE)\n\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONG, BT_LONG, BT_LONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGLONG, BT_LONGLONG, BT_LONGLONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_INTMAX_INTMAX, BT_INTMAX, BT_INTMAX)\nDEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_FLOAT, BT_FLOAT, BT_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_DOUBLE, BT_DOUBLE, BT_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_LONGDOUBLE,\n\t             BT_LONGDOUBLE, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT,\n\t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n\t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n\t             BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_COMPLEX_FLOAT,\n                     BT_FLOAT, BT_COMPLEX_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_COMPLEX_DOUBLE,\n                     BT_DOUBLE, BT_COMPLEX_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n                     BT_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_UNSIGNED, BT_PTR, BT_UNSIGNED)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_SIZE, BT_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_LONG, BT_INT, BT_LONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_LONGLONG, BT_INT, BT_LONGLONG)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_PTR, BT_INT, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_FLOAT, BT_INT, BT_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_DOUBLE, BT_INT, BT_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_LONGDOUBLE, BT_INT, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_FLOAT, BT_LONG, BT_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_DOUBLE, BT_LONG, BT_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONG_LONGDOUBLE, BT_LONG, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_FLOAT, BT_LONGLONG, BT_FLOAT)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_DOUBLE, BT_LONGLONG, BT_DOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGDOUBLE, BT_LONGLONG, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_SIZE_CONST_STRING, BT_SIZE, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_INT_CONST_STRING, BT_INT, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_VALIST_REF, BT_VOID, BT_VALIST_REF)\nDEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\nDEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_CONST_STRING,\n\t\t     BT_LONGDOUBLE, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_STRING_CONST_STRING, BT_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_1 (BT_FN_WORD_PTR, BT_WORD, BT_PTR)\n\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING,\n                     BT_STRING, BT_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_CONST_STRING,\n\t             BT_INT, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_CONST_STRING,\n\t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_SIZE_CONST_STRING_CONST_STRING,\n\t             BT_SIZE, BT_CONST_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_INT,\n\t             BT_STRING, BT_CONST_STRING, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR,\n\t\t     BT_INT, BT_CONST_STRING, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_PTR,\n\t\t     BT_INT, BT_INT, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRMODE_PTR,\n\t\t     BT_VOID, BT_PTRMODE, BT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG,\n\t\t     BT_VOID, BT_VALIST_REF, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONG_LONG_LONG,\n\t\t     BT_LONG, BT_LONG, BT_LONG)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_PTR_CONST_STRING,\n\t\t     BT_INT, BT_PTR, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_SIZE,\n\t\t     BT_VOID, BT_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_FLOAT,\n\t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_DOUBLE,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_FLOATPTR,\n\t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_DOUBLEPTR,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLEPTR,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_LONGDOUBLE,\n\t\t     BT_FLOAT, BT_FLOAT, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_LONGDOUBLE,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_INT,\n\t\t     BT_FLOAT, BT_FLOAT, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_INT,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_INT,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_INTPTR,\n\t\t     BT_FLOAT, BT_FLOAT, BT_INT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_INTPTR,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_INT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_INTPTR,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT_PTR)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_INT_FLOAT,\n\t\t     BT_FLOAT, BT_INT, BT_FLOAT)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_INT_DOUBLE,\n\t\t     BT_DOUBLE, BT_INT, BT_DOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_INT_LONGDOUBLE,\n\t\t     BT_LONGDOUBLE, BT_INT, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_FLOAT_FLOAT_LONG,\n\t\t     BT_FLOAT, BT_FLOAT, BT_LONG)\nDEF_FUNCTION_TYPE_2 (BT_FN_DOUBLE_DOUBLE_LONG,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_LONG)\nDEF_FUNCTION_TYPE_2 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONG,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONG)\nDEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_VALIST_ARG,\n\t\t     BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_2 (BT_FN_PTR_SIZE_SIZE,\n\t\t     BT_PTR, BT_SIZE, BT_SIZE)\nDEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT,\n\t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\nDEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n\t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\nDEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n\t             BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n\nDEF_FUNCTION_TYPE_3 (BT_FN_STRING_STRING_CONST_STRING_SIZE,\n\t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_SIZE,\n\t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_CONST_PTR_SIZE,\n\t\t     BT_PTR, BT_PTR, BT_CONST_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_PTR_CONST_PTR_SIZE,\n\t             BT_INT, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_INT_SIZE,\n\t             BT_PTR, BT_PTR, BT_INT, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_INT_INT,\n\t\t     BT_VOID, BT_PTR, BT_INT, BT_INT)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_PTR_SIZE,\n\t\t     BT_VOID, BT_CONST_PTR, BT_PTR, BT_SIZE)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_STRING_CONST_STRING_VALIST_ARG,\n\t\t     BT_INT, BT_STRING, BT_CONST_STRING, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_VALIST_ARG,\n\t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_3 (BT_FN_INT_PTR_CONST_STRING_VALIST_ARG,\n\t\t     BT_INT, BT_PTR, BT_CONST_STRING, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_3 (BT_FN_STRING_CONST_STRING_CONST_STRING_INT,\n\t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING, BT_INT)\nDEF_FUNCTION_TYPE_3 (BT_FN_FLOAT_FLOAT_FLOAT_FLOAT,\n\t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT, BT_FLOAT)\nDEF_FUNCTION_TYPE_3 (BT_FN_DOUBLE_DOUBLE_DOUBLE_DOUBLE,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE, BT_DOUBLE)\nDEF_FUNCTION_TYPE_3 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE)\nDEF_FUNCTION_TYPE_3 (BT_FN_FLOAT_FLOAT_FLOAT_INTPTR,\n\t\t     BT_FLOAT, BT_FLOAT, BT_FLOAT, BT_INT_PTR)\nDEF_FUNCTION_TYPE_3 (BT_FN_DOUBLE_DOUBLE_DOUBLE_INTPTR,\n\t\t     BT_DOUBLE, BT_DOUBLE, BT_DOUBLE, BT_INT_PTR)\nDEF_FUNCTION_TYPE_3 (BT_FN_LONGDOUBLE_LONGDOUBLE_LONGDOUBLE_INTPTR,\n\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE, BT_LONGDOUBLE, BT_INT_PTR)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_FLOAT_FLOATPTR_FLOATPTR,\n\t\t     BT_VOID, BT_FLOAT, BT_FLOAT_PTR, BT_FLOAT_PTR)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_DOUBLE_DOUBLEPTR_DOUBLEPTR,\n\t\t     BT_VOID, BT_DOUBLE, BT_DOUBLE_PTR, BT_DOUBLE_PTR)\nDEF_FUNCTION_TYPE_3 (BT_FN_VOID_LONGDOUBLE_LONGDOUBLEPTR_LONGDOUBLEPTR,\n\t\t     BT_VOID, BT_LONGDOUBLE, BT_LONGDOUBLE_PTR, BT_LONGDOUBLE_PTR)\n\nDEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR,\n\t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_PTR)\nDEF_FUNCTION_TYPE_4 (BT_FN_INT_STRING_SIZE_CONST_STRING_VALIST_ARG,\n\t\tBT_INT, BT_STRING, BT_SIZE, BT_CONST_STRING, BT_VALIST_ARG)\nDEF_FUNCTION_TYPE_4 (BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_PTR,\n\t\tBT_SIZE, BT_STRING, BT_SIZE, BT_CONST_STRING, BT_CONST_PTR)\n\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\nDEF_FUNCTION_TYPE_VAR_0 (BT_FN_PTR_VAR, BT_PTR)\n\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_VALIST_REF_VAR,\n\t\t\t BT_VOID, BT_VALIST_REF)\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_CONST_PTR_VAR,\n\t\t\t BT_VOID, BT_CONST_PTR)\nDEF_FUNCTION_TYPE_VAR_1 (BT_FN_INT_CONST_STRING_VAR,\n\t                 BT_INT, BT_CONST_STRING)\n\nDEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_PTR_CONST_STRING_VAR,\n\t                 BT_INT, BT_PTR, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_STRING_CONST_STRING_VAR,\n\t\t\t BT_INT, BT_STRING, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_CONST_STRING_CONST_STRING_VAR,\n\t\t\t BT_INT, BT_CONST_STRING, BT_CONST_STRING)\n\nDEF_FUNCTION_TYPE_VAR_3 (BT_FN_INT_STRING_SIZE_CONST_STRING_VAR,\n\t\t\t BT_INT, BT_STRING, BT_SIZE, BT_CONST_STRING)\nDEF_FUNCTION_TYPE_VAR_3 (BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR,\n\t\t\t BT_SSIZE, BT_STRING, BT_SIZE, BT_CONST_STRING)\n\nDEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\nDEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n\t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@COMMON": {"ttr": 1027, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for c-common.c.\n   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_COMMON_H\n#define GCC_C_COMMON_H\n\n#include \"splay-tree.h\"\n#include \"cpplib.h\"\n#include \"ggc.h\"\n\n/* Usage of TREE_LANG_FLAG_?:\n   0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n      TREE_NEGATED_INT (in INTEGER_CST).\n      IDENTIFIER_MARKED (used by search routines).\n      SCOPE_BEGIN_P (in SCOPE_STMT)\n      DECL_PRETTY_FUNCTION_P (in VAR_DECL)\n      NEW_FOR_SCOPE_P (in FOR_STMT)\n      ASM_INPUT_P (in ASM_STMT)\n      STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n   1: C_DECLARED_LABEL_FLAG (in LABEL_DECL)\n      STMT_IS_FULL_EXPR_P (in _STMT)\n   2: STMT_LINENO_FOR_FN_P (in _STMT)\n   3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n      COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n      STMT_EXPR_WARN_UNUSED_RESULT (in STMT_EXPR)\n   4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n*/\n\n/* Reserved identifiers.  This is the union of all the keywords for C,\n   C++, and Objective-C.  All the type modifiers have to be in one\n   block at the beginning, because they are used as mask bits.  There\n   are 27 type modifiers; if we add many more we will have to redesign\n   the mask mechanism.  */\n\nenum rid\n{\n  /* Modifiers: */\n  /* C, in empirical order of frequency.  */\n  RID_STATIC = 0,\n  RID_UNSIGNED, RID_LONG,    RID_CONST, RID_EXTERN,\n  RID_REGISTER, RID_TYPEDEF, RID_SHORT, RID_INLINE,\n  RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,\n\n  /* C extensions */\n  RID_COMPLEX, RID_THREAD,\n\n  /* C++ */\n  RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n\n  /* ObjC */\n  RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n\n  /* C */\n  RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,\n  RID_ENUM,    RID_STRUCT, RID_UNION,    RID_IF,     RID_ELSE,\n  RID_WHILE,   RID_DO,     RID_FOR,      RID_SWITCH, RID_CASE,\n  RID_DEFAULT, RID_BREAK,  RID_CONTINUE, RID_RETURN, RID_GOTO,\n  RID_SIZEOF,\n\n  /* C extensions */\n  RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n  RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_PTRBASE,\n  RID_PTREXTENT, RID_PTRVALUE, RID_CHOOSE_EXPR, RID_TYPES_COMPATIBLE_P,\n\n  /* Too many ways of getting the name of a function as a string */\n  RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,\n\n  /* C++ */\n  RID_BOOL,     RID_WCHAR,    RID_CLASS,\n  RID_PUBLIC,   RID_PRIVATE,  RID_PROTECTED,\n  RID_TEMPLATE, RID_NULL,     RID_CATCH,\n  RID_DELETE,   RID_FALSE,    RID_NAMESPACE,\n  RID_NEW,      RID_OFFSETOF, RID_OPERATOR,\n  RID_THIS,     RID_THROW,    RID_TRUE,\n  RID_TRY,      RID_TYPENAME, RID_TYPEID,\n  RID_USING,\n\n  /* casts */\n  RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n\n  /* Objective-C */\n  RID_ID,          RID_AT_ENCODE,    RID_AT_END,\n  RID_AT_CLASS,    RID_AT_ALIAS,     RID_AT_DEFS,\n  RID_AT_PRIVATE,  RID_AT_PROTECTED, RID_AT_PUBLIC,\n  RID_AT_PROTOCOL, RID_AT_SELECTOR,\n  RID_AT_THROW,\t   RID_AT_TRY,       RID_AT_CATCH,\n  RID_AT_FINALLY,  RID_AT_SYNCHRONIZED,\n  RID_AT_INTERFACE,\n  RID_AT_IMPLEMENTATION,\n\n  RID_MAX,\n\n  RID_FIRST_MODIFIER = RID_STATIC,\n  RID_LAST_MODIFIER = RID_ONEWAY,\n\n  RID_FIRST_AT = RID_AT_ENCODE,\n  RID_LAST_AT = RID_AT_IMPLEMENTATION,\n  RID_FIRST_PQ = RID_IN,\n  RID_LAST_PQ = RID_ONEWAY\n};\n\n#define OBJC_IS_AT_KEYWORD(rid) \\\n  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_AT && \\\n   (unsigned int)(rid) <= (unsigned int)RID_LAST_AT)\n\n#define OBJC_IS_PQ_KEYWORD(rid) \\\n  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_PQ && \\\n   (unsigned int)(rid) <= (unsigned int)RID_LAST_PQ)\n\n/* The elements of `ridpointers' are identifier nodes for the reserved\n   type names and storage classes.  It is indexed by a RID_... value.  */\nextern GTY ((length (\"(int)RID_MAX\"))) tree *ridpointers;\n\n/* Standard named or nameless data types of the C compiler.  */\n\nenum c_tree_index\n{\n    CTI_WCHAR_TYPE,\n    CTI_SIGNED_WCHAR_TYPE,\n    CTI_UNSIGNED_WCHAR_TYPE,\n    CTI_WINT_TYPE,\n    CTI_SIGNED_SIZE_TYPE, /* For format checking only.  */\n    CTI_UNSIGNED_PTRDIFF_TYPE, /* For format checking only.  */\n    CTI_INTMAX_TYPE,\n    CTI_UINTMAX_TYPE,\n    CTI_WIDEST_INT_LIT_TYPE,\n    CTI_WIDEST_UINT_LIT_TYPE,\n\n    CTI_CHAR_ARRAY_TYPE,\n    CTI_WCHAR_ARRAY_TYPE,\n    CTI_INT_ARRAY_TYPE,\n    CTI_STRING_TYPE,\n    CTI_CONST_STRING_TYPE,\n\n    /* Type for boolean expressions (bool in C++, int in C).  */\n    CTI_TRUTHVALUE_TYPE,\n    CTI_TRUTHVALUE_TRUE,\n    CTI_TRUTHVALUE_FALSE,\n\n    CTI_DEFAULT_FUNCTION_TYPE,\n\n    CTI_G77_INTEGER_TYPE,\n    CTI_G77_UINTEGER_TYPE,\n    CTI_G77_LONGINT_TYPE,\n    CTI_G77_ULONGINT_TYPE,\n\n    /* These are not types, but we have to look them up all the time.  */\n    CTI_FUNCTION_NAME_DECL,\n    CTI_PRETTY_FUNCTION_NAME_DECL,\n    CTI_C99_FUNCTION_NAME_DECL,\n    CTI_SAVED_FUNCTION_NAME_DECLS,\n\n    CTI_VOID_ZERO,\n\n    CTI_MAX\n};\n\n#define C_RID_CODE(id)\t(((struct c_common_identifier *) (id))->node.rid_code)\n\n/* Identifier part common to the C front ends.  Inherits from\n   tree_identifier, despite appearances.  */\nstruct c_common_identifier GTY(())\n{\n  struct tree_common common;\n  struct cpp_hashnode node;\n};\n\n#define wchar_type_node\t\t\tc_global_trees\u00ddCTI_WCHAR_TYPE\u00a8\n#define signed_wchar_type_node\t\tc_global_trees\u00ddCTI_SIGNED_WCHAR_TYPE\u00a8\n#define unsigned_wchar_type_node\tc_global_trees\u00ddCTI_UNSIGNED_WCHAR_TYPE\u00a8\n#define wint_type_node\t\t\tc_global_trees\u00ddCTI_WINT_TYPE\u00a8\n#define signed_size_type_node\t\tc_global_trees\u00ddCTI_SIGNED_SIZE_TYPE\u00a8\n#define unsigned_ptrdiff_type_node\tc_global_trees\u00ddCTI_UNSIGNED_PTRDIFF_TYPE\u00a8\n#define intmax_type_node\t\tc_global_trees\u00ddCTI_INTMAX_TYPE\u00a8\n#define uintmax_type_node\t\tc_global_trees\u00ddCTI_UINTMAX_TYPE\u00a8\n#define widest_integer_literal_type_node c_global_trees\u00ddCTI_WIDEST_INT_LIT_TYPE\u00a8\n#define widest_unsigned_literal_type_node c_global_trees\u00ddCTI_WIDEST_UINT_LIT_TYPE\u00a8\n\n#define truthvalue_type_node\t\tc_global_trees\u00ddCTI_TRUTHVALUE_TYPE\u00a8\n#define truthvalue_true_node\t\tc_global_trees\u00ddCTI_TRUTHVALUE_TRUE\u00a8\n#define truthvalue_false_node\t\tc_global_trees\u00ddCTI_TRUTHVALUE_FALSE\u00a8\n\n#define char_array_type_node\t\tc_global_trees\u00ddCTI_CHAR_ARRAY_TYPE\u00a8\n#define wchar_array_type_node\t\tc_global_trees\u00ddCTI_WCHAR_ARRAY_TYPE\u00a8\n#define int_array_type_node\t\tc_global_trees\u00ddCTI_INT_ARRAY_TYPE\u00a8\n#define string_type_node\t\tc_global_trees\u00ddCTI_STRING_TYPE\u00a8\n#define const_string_type_node\t\tc_global_trees\u00ddCTI_CONST_STRING_TYPE\u00a8\n\n#define default_function_type\t\tc_global_trees\u00ddCTI_DEFAULT_FUNCTION_TYPE\u00a8\n\n/* g77 integer types, which which must be kept in sync with f/com.h */\n#define g77_integer_type_node\t\tc_global_trees\u00ddCTI_G77_INTEGER_TYPE\u00a8\n#define g77_uinteger_type_node\t\tc_global_trees\u00ddCTI_G77_UINTEGER_TYPE\u00a8\n#define g77_longint_type_node\t\tc_global_trees\u00ddCTI_G77_LONGINT_TYPE\u00a8\n#define g77_ulongint_type_node\t\tc_global_trees\u00ddCTI_G77_ULONGINT_TYPE\u00a8\n\n#define function_name_decl_node\t\tc_global_trees\u00ddCTI_FUNCTION_NAME_DECL\u00a8\n#define pretty_function_name_decl_node\tc_global_trees\u00ddCTI_PRETTY_FUNCTION_NAME_DECL\u00a8\n#define c99_function_name_decl_node\t\tc_global_trees\u00ddCTI_C99_FUNCTION_NAME_DECL\u00a8\n#define saved_function_name_decls\tc_global_trees\u00ddCTI_SAVED_FUNCTION_NAME_DECLS\u00a8\n\n/* A node for `((void) 0)'.  */\n#define void_zero_node                  c_global_trees\u00ddCTI_VOID_ZERO\u00a8\n\nextern GTY(()) tree c_global_trees\u00ddCTI_MAX\u00a8;\n\n/* In a RECORD_TYPE, a sorted array of the fields of the type, not a\n   tree for size reasons.  */\nstruct sorted_fields_type GTY(())\n{\n  int len;\n  tree GTY((length (\"%h.len\"))) elts\u00dd1\u00a8;\n};\n\n/* Mark which labels are explicitly declared.\n   These may be shadowed, and may be referenced from nested functions.  */\n#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n\n/* Flag strings given by __FUNCTION__ and __PRETTY_FUNCTION__ for a\n   warning if they undergo concatenation.  */\n#define C_ARTIFICIAL_STRING_P(NODE) TREE_LANG_FLAG_0 (NODE)\n\ntypedef enum c_language_kind\n{\n  clk_c\t\t= 0,\t\t/* C90, C94 or C99 */\n  clk_objc\t= 1,\t\t/* clk_c with ObjC features.  */\n  clk_cxx\t= 2,\t\t/* ANSI/ISO C++ */\n  clk_objcxx\t= 3\t\t/* clk_cxx with ObjC features.  */\n}\nc_language_kind;\n\n/* To test for a specific language use c_language, defined by each\n   front end.  For \"ObjC features\" or \"not C++\" use the macros.  */\nextern c_language_kind c_language;\n\n#define c_dialect_cxx()\t\t(c_language & clk_cxx)\n#define c_dialect_objc()\t(c_language & clk_objc)\n\n/* Information about a statement tree.  */\n\nstruct stmt_tree_s GTY(()) {\n  /* The last statement added to the tree.  */\n  tree x_last_stmt;\n  /* The type of the last expression statement.  (This information is\n     needed to implement the statement-expression extension.)  */\n  tree x_last_expr_type;\n  /* The last filename we recorded.  */\n  const char *x_last_expr_filename;\n  /* In C++, Nonzero if we should treat statements as full\n     expressions.  In particular, this variable is no-zero if at the\n     end of a statement we should destroy any temporaries created\n     during that statement.  Similarly, if, at the end of a block, we\n     should destroy any local variables in this block.  Normally, this\n     variable is nonzero, since those are the normal semantics of\n     C++.\n\n     However, in order to represent aggregate initialization code as\n     tree structure, we use statement-expressions.  The statements\n     within the statement expression should not result in cleanups\n     being run until the entire enclosing statement is complete.\n\n     This flag has no effect in C.  */\n  int stmts_are_full_exprs_p;\n};\n\ntypedef struct stmt_tree_s *stmt_tree;\n\n/* Global state pertinent to the current function.  Some C dialects\n   extend this structure with additional fields.  */\n\nstruct c_language_function GTY(()) {\n  /* While we are parsing the function, this contains information\n     about the statement-tree that we are building.  */\n  struct stmt_tree_s x_stmt_tree;\n  /* The stack of SCOPE_STMTs for the current function.  */\n  tree x_scope_stmt_stack;\n};\n\n/* When building a statement-tree, this is the last statement added to\n   the tree.  */\n\n#define last_tree (current_stmt_tree ()->x_last_stmt)\n\n/* The type of the last expression-statement we have seen.  */\n\n#define last_expr_type (current_stmt_tree ()->x_last_expr_type)\n\n/* The name of the last file we have seen.  */\n\n#define last_expr_filename (current_stmt_tree ()->x_last_expr_filename)\n\n/* LAST_TREE contains the last statement parsed.  These are chained\n   together through the TREE_CHAIN field, but often need to be\n   re-organized since the parse is performed bottom-up.  This macro\n   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n\n#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n  do {\t\t\t\t\t\t\\\n    substmt = TREE_CHAIN (stmt);\t\t\\\n    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n    last_tree = stmt;\t\t\t\t\\\n  } while (0)\n\n/* Language-specific hooks.  */\n\nextern void (*lang_expand_stmt) (tree);\nextern void (*lang_expand_decl_stmt) (tree);\nextern void (*lang_expand_function_end) (void);\n\n/* Callback that determines if it's ok for a function to have no\n   noreturn attribute.  */\nextern int (*lang_missing_noreturn_ok_p) (tree);\n\nextern int yyparse (void);\nextern stmt_tree current_stmt_tree (void);\nextern tree *current_scope_stmt_stack (void);\nextern void begin_stmt_tree (tree *);\nextern tree add_stmt (tree);\nextern void add_decl_stmt (tree);\nextern tree add_scope_stmt (int, int);\nextern void finish_stmt_tree (tree *);\n\nextern tree walk_stmt_tree (tree *, walk_tree_fn, void *);\nextern void prep_stmt (tree);\nextern void expand_stmt (tree);\nextern tree c_begin_if_stmt (void);\nextern tree c_begin_while_stmt (void);\nextern void c_finish_while_stmt_cond (tree, tree);\n\nextern int field_decl_cmp (const void *, const void *);\nextern void resort_sorted_fields (void *, void *, gt_pointer_operator,\n                                  void *);\n\n/* Switches common to the C front ends.  */\n\n/* Nonzero if prepreprocessing only.  */\n\nextern int flag_preprocess_only;\n\n/* Zero means that faster, ...NonNil variants of objc_msgSend...\n   calls will be used in ObjC; passing nil receivers to such calls\n   will most likely result in crashes.  */\nextern int flag_nil_receivers;\n\n/* Nonzero means that we will allow new ObjC exception syntax (@throw,\n   @try, etc.) in source code.  */\nextern int flag_objc_exceptions;\n\n/* Nonzero means that code generation will be altered to support\n   \"zero-link\" execution.  This currently affects ObjC only, but may\n   affect other languages in the future.  */\nextern int flag_zero_link;\n\n/* Nonzero means emit an '__OBJC, __image_info' for the current translation\n   unit.  It will inform the ObjC runtime that class definition(s) herein\n   contained are to replace one(s) previously loaded.  */\nextern int flag_replace_objc_classes;\n\n/* Nonzero means don't output line number information.  */\n\nextern char flag_no_line_commands;\n\n/* Nonzero causes -E output not to be done, but directives such as\n   #define that have side effects are still obeyed.  */\n\nextern char flag_no_output;\n\n/* Nonzero means dump macros in some fashion; contains the 'D', 'M' or\n   'N' of the command line switch.  */\n\nextern char flag_dump_macros;\n\n/* Nonzero means pass #include lines through to the output.  */\n\nextern char flag_dump_includes;\n\n/* The file name to which we should write a precompiled header, or\n   NULL if no header will be written in this compile.  */\n\nextern const char *pch_file;\n\n/* Nonzero if an ISO standard was selected.  It rejects macros in the\n   user's namespace.  */\n\nextern int flag_iso;\n\n/* Nonzero if -undef was given.  It suppresses target built-in macros\n   and assertions.  */\n\nextern int flag_undef;\n\n/* Nonzero means don't recognize the non-ANSI builtin functions.  */\n\nextern int flag_no_builtin;\n\n/* Nonzero means don't recognize the non-ANSI builtin functions.\n   -ansi sets this.  */\n\nextern int flag_no_nonansi_builtin;\n\n/* Nonzero means give `double' the same size as `float'.  */\n\nextern int flag_short_double;\n\n/* Nonzero means give `wchar_t' the same size as `short'.  */\n\nextern int flag_short_wchar;\n\n/* Nonzero means allow Microsoft extensions without warnings or errors.  */\nextern int flag_ms_extensions;\n\n/* Nonzero means don't recognize the keyword `asm'.  */\n\nextern int flag_no_asm;\n\n/* Nonzero means give string constants the type `const char *', as mandated\n   by the standard.  */\n\nextern int flag_const_strings;\n\n/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */\n\nextern int flag_signed_bitfields;\nextern int explicit_flag_signed_bitfields;\n\n/* Nonzero means warn about pointer casts that can drop a type qualifier\n   from the pointer target type.  */\n\nextern int warn_cast_qual;\n\n/* Warn about functions which might be candidates for format attributes.  */\n\nextern int warn_missing_format_attribute;\n\n/* Nonzero means warn about sizeof(function) or addition/subtraction\n   of function pointers.  */\n\nextern int warn_pointer_arith;\n\n/* Nonzero means warn for any global function def\n   without separate previous prototype decl.  */\n\nextern int warn_missing_prototypes;\n\n/* Warn if adding () is suggested.  */\n\nextern int warn_parentheses;\n\n/* Warn if initializer is not completely bracketed.  */\n\nextern int warn_missing_braces;\n\n/* Warn about comparison of signed and unsigned values.\n   If -1, neither -Wsign-compare nor -Wno-sign-compare has been specified.  */\n\nextern int warn_sign_compare;\n\n/* Nonzero means warn about usage of long long when `-pedantic'.  */\n\nextern int warn_long_long;\n\n/* Nonzero means warn about deprecated conversion from string constant to\n   `char *'.  */\n\nextern int warn_write_strings;\n\n/* Nonzero means warn about multiple (redundant) decls for the same single\n   variable or function.  */\n\nextern int warn_redundant_decls;\n\n/* Warn about testing equality of floating point numbers.  */\n\nextern int warn_float_equal;\n\n/* Warn about a subscript that has type char.  */\n\nextern int warn_char_subscripts;\n\n/* Warn if a type conversion is done that might have confusing results.  */\n\nextern int warn_conversion;\n\n/* Warn about #pragma directives that are not recognized.  */\n\nextern int warn_unknown_pragmas; /* Tri state variable.  */\n\n/* Warn about format/argument anomalies in calls to formatted I/O functions\n   (*printf, *scanf, strftime, strfmon, etc.).  */\n\nextern int warn_format;\n\n/* Warn about Y2K problems with strftime formats.  */\n\nextern int warn_format_y2k;\n\n/* Warn about excess arguments to formats.  */\n\nextern int warn_format_extra_args;\n\n/* Warn about zero-length formats.  */\n\nextern int warn_format_zero_length;\n\n/* Warn about non-literal format arguments.  */\n\nextern int warn_format_nonliteral;\n\n/* Warn about possible security problems with calls to format functions.  */\n\nextern int warn_format_security;\n\n\n/* C/ObjC language option variables.  */\n\n\n/* Nonzero means message about use of implicit function declarations;\n 1 means warning; 2 means error.  */\n\nextern int mesg_implicit_function_declaration;\n\n/* Nonzero means allow type mismatches in conditional expressions;\n   just make their values `void'.  */\n\nextern int flag_cond_mismatch;\n\n/* Nonzero means enable C89 Amendment 1 features.  */\n\nextern int flag_isoc94;\n\n/* Nonzero means use the ISO C99 dialect of C.  */\n\nextern int flag_isoc99;\n\n/* Nonzero means that we have builtin functions, and main is an int.  */\n\nextern int flag_hosted;\n\n/* Nonzero means warn when casting a function call to a type that does\n   not match the return type (e.g. (float)sqrt() or (anything*)malloc()\n   when there is no previous declaration of sqrt or malloc.  */\n\nextern int warn_bad_function_cast;\n\n/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n\nextern int warn_traditional;\n\n/* Nonzero means warn for a declaration found after a statement.  */\n\nextern int warn_declaration_after_statement;\n\n/* Nonzero means warn for non-prototype function decls\n   or non-prototyped defs without previous prototype.  */\n\nextern int warn_strict_prototypes;\n\n/* Nonzero means warn for any global function def\n   without separate previous decl.  */\n\nextern int warn_missing_declarations;\n\n/* Nonzero means warn about extern declarations of objects not at\n   file-scope level and about *all* declarations of functions (whether\n   extern or static) not at file-scope level.  Note that we exclude\n   implicit function declarations.  To get warnings about those, use\n   -Wimplicit.  */\n\nextern int warn_nested_externs;\n\n/* Warn if main is suspicious.  */\n\nextern int warn_main;\n\n/* Nonzero means warn about possible violations of sequence point rules.  */\n\nextern int warn_sequence_point;\n\n/* Nonzero means warn about uninitialized variable when it is initialized with itself.\n   For example: int i = i;, GCC will not warn about this when warn_init_self is nonzero.  */\n\nextern int warn_init_self;\n\n\n/* Nonzero means to warn about compile-time division by zero.  */\nextern int warn_div_by_zero;\n\n/* Nonzero means warn about use of implicit int.  */\n\nextern int warn_implicit_int;\n\n/* Warn about NULL being passed to argument slots marked as requiring\n   non-NULL.  */\n\nextern int warn_nonnull;\n\n/* Warn about old-style parameter declaration.  */\n\nextern int warn_old_style_definition;\n\n\n/* ObjC language option variables.  */\n\n\n/* Open and close the file for outputting class declarations, if\n   requested (ObjC).  */\n\nextern int flag_gen_declaration;\n\n/* Generate code for GNU or NeXT runtime environment.  */\n\nextern int flag_next_runtime;\n\n/* Tells the compiler that this is a special run.  Do not perform any\n   compiling, instead we are to test some platform dependent features\n   and output a C header file with appropriate definitions.  */\n\nextern int print_struct_values;\n\n/* ???.  Undocumented.  */\n\nextern const char *constant_string_class_name;\n\n/* Warn if multiple methods are seen for the same selector, but with\n   different argument types.  Performs the check on the whole selector\n   table at the end of compilation.  */\n\nextern int warn_selector;\n\n/* Warn if a @selector() is found, and no method with that selector\n   has been previously declared.  The check is done on each\n   @selector() as soon as it is found - so it warns about forward\n   declarations.  */\n\nextern int warn_undeclared_selector;\n\n/* Warn if methods required by a protocol are not implemented in the\n   class adopting it.  When turned off, methods inherited to that\n   class are also considered implemented.  */\n\nextern int warn_protocol;\n\n\n/* C++ language option variables.  */\n\n\n/* Nonzero means don't recognize any extension keywords.  */\n\nextern int flag_no_gnu_keywords;\n\n/* Nonzero means do emit exported implementations of functions even if\n   they can be inlined.  */\n\nextern int flag_implement_inlines;\n\n/* Nonzero means that implicit instantiations will be emitted if needed.  */\n\nextern int flag_implicit_templates;\n\n/* Nonzero means that implicit instantiations of inline templates will be\n   emitted if needed, even if instantiations of non-inline templates\n   aren't.  */\n\nextern int flag_implicit_inline_templates;\n\n/* Nonzero means generate separate instantiation control files and\n   juggle them at link time.  */\n\nextern int flag_use_repository;\n\n/* Nonzero if we want to issue diagnostics that the standard says are not\n   required.  */\n\nextern int flag_optional_diags;\n\n/* Nonzero means we should attempt to elide constructors when possible.  */\n\nextern int flag_elide_constructors;\n\n/* Nonzero means that member functions defined in class scope are\n   inline by default.  */\n\nextern int flag_default_inline;\n\n/* Controls whether compiler generates 'type descriptor' that give\n   run-time type information.  */\n\nextern int flag_rtti;\n\n/* Nonzero if we want to conserve space in the .o files.  We do this\n   by putting uninitialized data and runtime initialized data into\n   .common instead of .data at the expense of not flagging multiple\n   definitions.  */\n\nextern int flag_conserve_space;\n\n/* Nonzero if we want to obey access control semantics.  */\n\nextern int flag_access_control;\n\n/* Nonzero if we want to check the return value of new and avoid calling\n   constructors if it is a null pointer.  */\n\nextern int flag_check_new;\n\n/* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n   initialization variables.\n   0: Old rules, set by -fno-for-scope.\n   2: New ISO rules, set by -ffor-scope.\n   1: Try to implement new ISO rules, but with backup compatibility\n   (and warnings).  This is the default, for now.  */\n\nextern int flag_new_for_scope;\n\n/* Nonzero if we want to emit defined symbols with common-like linkage as\n   weak symbols where possible, in order to conform to C++ semantics.\n   Otherwise, emit them as local symbols.  */\n\nextern int flag_weak;\n\n/* 0 means we want the preprocessor to not emit line directives for\n   the current working directory.  1 means we want it to do it.  -1\n   means we should decide depending on whether debugging information\n   is being emitted or not.  */\n\nextern int flag_working_directory;\n\n/* Nonzero to use __cxa_atexit, rather than atexit, to register\n   destructors for local statics and global objects.  */\n\nextern int flag_use_cxa_atexit;\n\n/* Nonzero means make the default pedwarns warnings instead of errors.\n   The value of this flag is ignored if -pedantic is specified.  */\n\nextern int flag_permissive;\n\n/* Nonzero means to implement standard semantics for exception\n   specifications, calling unexpected if an exception is thrown that\n   doesn't match the specification.  Zero means to treat them as\n   assertions and optimize accordingly, but not check them.  */\n\nextern int flag_enforce_eh_specs;\n\n/* Nonzero means warn about things that will change when compiling\n   with an ABI-compliant compiler.  */\n\nextern int warn_abi;\n\n/* Nonzero means warn about invalid uses of offsetof.  */\n\nextern int warn_invalid_offsetof;\n\n/* Nonzero means warn about implicit declarations.  */\n\nextern int warn_implicit;\n\n/* Nonzero means warn when all ctors or dtors are private, and the class\n   has no friends.  */\n\nextern int warn_ctor_dtor_privacy;\n\n/* Nonzero means warn in function declared in derived class has the\n   same name as a virtual in the base class, but fails to match the\n   type signature of any virtual function in the base class.  */\n\nextern int warn_overloaded_virtual;\n\n/* Nonzero means warn when declaring a class that has a non virtual\n   destructor, when it really ought to have a virtual one.  */\n\nextern int warn_nonvdtor;\n\n/* Nonzero means warn when the compiler will reorder code.  */\n\nextern int warn_reorder;\n\n/* Nonzero means warn when synthesis behavior differs from Cfront's.  */\n\nextern int warn_synth;\n\n/* Nonzero means warn when we convert a pointer to member function\n   into a pointer to (void or function).  */\n\nextern int warn_pmf2ptr;\n\n/* Nonzero means warn about violation of some Effective C++ style rules.  */\n\nextern int warn_ecpp;\n\n/* Nonzero means warn where overload resolution chooses a promotion from\n   unsigned to signed over a conversion to an unsigned of the same size.  */\n\nextern int warn_sign_promo;\n\n/* Nonzero means warn when an old-style cast is used.  */\n\nextern int warn_old_style_cast;\n\n/* Nonzero means warn when non-templatized friend functions are\n   declared within a template */\n\nextern int warn_nontemplate_friend;\n\n/* Nonzero means complain about deprecated features.  */\n\nextern int warn_deprecated;\n\n/* Maximum template instantiation depth.  This limit is rather\n   arbitrary, but it exists to limit the time it takes to notice\n   infinite template instantiations.  */\n\nextern int max_tinst_depth;\n\n/* Nonzero means the expression being parsed will never be evaluated.\n   This is a count, since unevaluated expressions can nest.  */\n\nextern int skip_evaluation;\n\n/* C types are partitioned into three subsets: object, function, and\n   incomplete types.  */\n#define C_TYPE_OBJECT_P(type) \\\n  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type))\n\n#define C_TYPE_INCOMPLETE_P(type) \\\n  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type) == 0)\n\n#define C_TYPE_FUNCTION_P(type) \\\n  (TREE_CODE (type) == FUNCTION_TYPE)\n\n/* For convenience we define a single macro to identify the class of\n   object or incomplete types.  */\n#define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n  (!C_TYPE_FUNCTION_P (type))\n\n/* Record in each node resulting from a binary operator\n   what operator was specified for it.  */\n#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n\n/* Attribute table common to the C front ends.  */\nextern const struct attribute_spec c_common_attribute_table\u00dd\u00a8;\nextern const struct attribute_spec c_common_format_attribute_table\u00dd\u00a8;\n\n/* Pointer to function to lazily generate the VAR_DECL for __FUNCTION__ etc.\n   ID is the identifier to use, NAME is the string.\n   TYPE_DEP indicates whether it depends on type of the function or not\n   (i.e. __PRETTY_FUNCTION__).  */\n\nextern tree (*make_fname_decl) (tree, int);\n\nextern tree identifier_global_value (tree);\nextern void record_builtin_type (enum rid, const char *, tree);\nextern tree build_void_list_node (void);\nextern void start_fname_decls (void);\nextern void finish_fname_decls (void);\nextern const char *fname_as_string (int);\nextern tree fname_decl (unsigned, tree);\n\nextern void check_function_arguments (tree, tree);\nextern void check_function_arguments_recurse (void (*)\n\t\t\t\t\t      (void *, tree,\n\t\t\t\t\t       unsigned HOST_WIDE_INT),\n\t\t\t\t\t      void *, tree,\n\t\t\t\t\t      unsigned HOST_WIDE_INT);\nextern void check_function_format (int *, tree, tree);\nextern void set_Wformat (int);\nextern tree handle_format_attribute (tree *, tree, tree, int, bool *);\nextern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\nextern int c_common_handle_option (size_t code, const char *arg, int value);\nextern bool c_common_missing_argument (const char *opt, size_t code);\nextern tree c_common_type_for_mode (enum machine_mode, int);\nextern tree c_common_type_for_size (unsigned int, int);\nextern tree c_common_unsigned_type (tree);\nextern tree c_common_signed_type (tree);\nextern tree c_common_signed_or_unsigned_type (int, tree);\nextern tree c_common_truthvalue_conversion (tree);\nextern void c_apply_type_quals_to_decl (int, tree);\nextern tree c_sizeof_or_alignof_type (tree, enum tree_code, int);\nextern tree c_alignof_expr (tree);\n/* Print an error message for invalid operands to arith operation CODE.\n   NOP_EXPR is used as a special case (see truthvalue_conversion).  */\nextern void binary_op_error (enum tree_code);\n#define my_friendly_assert(EXP, N) (void) \\\n (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n\nextern tree c_expand_expr_stmt (tree);\nextern void c_expand_start_cond (tree, int, tree);\nextern void c_finish_then (void);\nextern void c_expand_start_else (void);\nextern void c_finish_else (void);\nextern void c_expand_end_cond (void);\n/* Validate the expression after `case' and apply default promotions.  */\nextern tree check_case_value (tree);\nextern tree fix_string_type (tree);\nstruct varray_head_tag;\nextern void constant_expression_warning (tree);\nextern tree convert_and_check (tree, tree);\nextern void overflow_warning (tree);\nextern void unsigned_conversion_warning (tree, tree);\n\n/* Read the rest of the current #-directive line.  */\nextern char *get_directive_line (void);\n#define GET_DIRECTIVE_LINE() get_directive_line ()\n#define c_sizeof(T)  c_sizeof_or_alignof_type (T, SIZEOF_EXPR, 1)\n#define c_alignof(T) c_sizeof_or_alignof_type (T, ALIGNOF_EXPR, 1)\n\n/* Subroutine of build_binary_op, used for comparison operations.\n   See if the operands have both been converted from subword integer types\n   and, if so, perhaps change them both back to their original type.  */\nextern tree shorten_compare (tree *, tree *, tree *, enum tree_code *);\n\nextern tree pointer_int_sum (enum tree_code, tree, tree);\nextern unsigned int min_precision (tree, int);\n\n/* Add qualifiers to a type, in the fashion for C.  */\nextern tree c_build_qualified_type (tree, int);\n\n/* Build tree nodes and builtin functions common to both C and C++ language\n   frontends.  */\nextern void c_common_nodes_and_builtins (void);\n\nextern void disable_builtin_function (const char *);\n\nextern tree build_va_arg (tree, tree);\n\nextern unsigned int c_common_init_options (unsigned int, const char **);\nextern bool c_common_post_options (const char **);\nextern bool c_common_init (void);\nextern void c_common_finish (void);\nextern void c_common_parse_file (int);\nextern HOST_WIDE_INT c_common_get_alias_set (tree);\nextern void c_register_builtin_type (tree, const char*);\nextern bool c_promoting_integer_type_p (tree);\nextern int self_promoting_args_p (tree);\nextern tree strip_array_types (tree);\nextern tree strip_pointer_operator (tree);\n\n/* This function resets the parsers' state in preparation for parsing\n   a new file.  */\nextern void c_reset_state (void);\n/* This is the basic parsing function.  */\nextern void c_parse_file (void);\n/* This is misnamed, it actually performs end-of-compilation processing.  */\nextern void finish_file\t(void);\n\n/* These macros provide convenient access to the various _STMT nodes.  */\n\n/* Nonzero if this statement should be considered a full-expression,\n   i.e., if temporaries created during this statement should have\n   their destructors run at the end of this statement.  (In C, this\n   will always be false, since there are no destructors.)  */\n#define STMT_IS_FULL_EXPR_P(NODE) TREE_LANG_FLAG_1 ((NODE))\n\n/* IF_STMT accessors. These give access to the condition of the if\n   statement, the then block of the if statement, and the else block\n   of the if statement if it exists.  */\n#define IF_COND(NODE)           TREE_OPERAND (IF_STMT_CHECK (NODE), 0)\n#define THEN_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 1)\n#define ELSE_CLAUSE(NODE)       TREE_OPERAND (IF_STMT_CHECK (NODE), 2)\n\n/* WHILE_STMT accessors. These give access to the condition of the\n   while statement and the body of the while statement, respectively.  */\n#define WHILE_COND(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n#define WHILE_BODY(NODE)        TREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n\n/* DO_STMT accessors. These give access to the condition of the do\n   statement and the body of the do statement, respectively.  */\n#define DO_COND(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n#define DO_BODY(NODE)           TREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n\n/* RETURN_STMT accessors. These give the expression associated with a\n   return statement, and whether it should be ignored when expanding\n   (as opposed to inlining).  */\n#define RETURN_STMT_EXPR(NODE)  TREE_OPERAND (RETURN_STMT_CHECK (NODE), 0)\n\n/* EXPR_STMT accessor. This gives the expression associated with an\n   expression statement.  */\n#define EXPR_STMT_EXPR(NODE)    TREE_OPERAND (EXPR_STMT_CHECK (NODE), 0)\n\n/* FOR_STMT accessors. These give access to the init statement,\n   condition, update expression, and body of the for statement,\n   respectively.  */\n#define FOR_INIT_STMT(NODE)     TREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n#define FOR_COND(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n#define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n#define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n\n/* SWITCH_STMT accessors. These give access to the condition, body and\n   original condition type (before any compiler conversions)\n   of the switch statement, respectively.  */\n#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n#define SWITCH_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n\n/* CASE_LABEL accessors. These give access to the high and low values\n   of a case label, respectively.  */\n#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n#define CASE_LABEL_DECL(NODE)   TREE_OPERAND (CASE_LABEL_CHECK (NODE), 2)\n\n/* GOTO_STMT accessor. This gives access to the label associated with\n   a goto statement.  */\n#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n/* True for goto created artificially by the compiler.  */\n#define GOTO_FAKE_P(NODE)\t(TREE_LANG_FLAG_0 (GOTO_STMT_CHECK (NODE)))\n\n/* COMPOUND_STMT accessor. This gives access to the TREE_LIST of\n   statements associated with a compound statement. The result is the\n   first statement in the list. Succeeding nodes can be accessed by\n   calling TREE_CHAIN on a node in the list.  */\n#define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n\n/* ASM_STMT accessors. ASM_STRING returns a STRING_CST for the\n   instruction (e.g., \"mov x, y\"). ASM_OUTPUTS, ASM_INPUTS, and\n   ASM_CLOBBERS represent the outputs, inputs, and clobbers for the\n   statement.  */\n#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n\n/* DECL_STMT accessor. This gives access to the DECL associated with\n   the given declaration statement.  */\n#define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n\n/* STMT_EXPR accessor.  */\n#define STMT_EXPR_STMT(NODE)    TREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n\n/* Nonzero if this statement-expression does not have an associated scope.  */\n#define STMT_EXPR_NO_SCOPE(NODE) \\\n   TREE_LANG_FLAG_0 (STMT_EXPR_CHECK (NODE))\n\n/* Nonzero if this statement-expression should cause warning if its result\n   is not used.  */\n#define STMT_EXPR_WARN_UNUSED_RESULT(NODE) \\\n   TREE_LANG_FLAG_3 (STMT_EXPR_CHECK (NODE))\n\n/* LABEL_STMT accessor. This gives access to the label associated with\n   the given label statement.  */\n#define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n\n/* COMPOUND_LITERAL_EXPR accessors.  */\n#define COMPOUND_LITERAL_EXPR_DECL_STMT(NODE)\t\t\\\n  TREE_OPERAND (COMPOUND_LITERAL_EXPR_CHECK (NODE), 0)\n#define COMPOUND_LITERAL_EXPR_DECL(NODE)\t\t\t\\\n  DECL_STMT_DECL (COMPOUND_LITERAL_EXPR_DECL_STMT (NODE))\n\n/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n#define SCOPE_BEGIN_P(NODE) \\\n  (TREE_LANG_FLAG_0 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n#define SCOPE_END_P(NODE) \\\n  (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n\n/* The BLOCK containing the declarations contained in this scope.  */\n#define SCOPE_STMT_BLOCK(NODE) \\\n  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n\n/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n#define SCOPE_NULLIFIED_P(NODE) \\\n  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n\n/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n   which should be treated as non-existent from the point of view of\n   running cleanup actions.  */\n#define SCOPE_NO_CLEANUPS_P(NODE) \\\n  (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n   For example, in:\n\n     S s;\n     l:\n     S s2;\n     goto l;\n\n   there is (implicitly) a new scope after `l', even though there are\n   no curly braces.  In particular, when we hit the goto, we must\n   destroy s2 and then re-construct it.  For the implicit scope,\n   SCOPE_PARTIAL_P will be set.  */\n#define SCOPE_PARTIAL_P(NODE) \\\n  (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n\n/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n#define ASM_VOLATILE_P(NODE)\t\t\t\\\n  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n\n/* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n#define CLEANUP_DECL(NODE) \\\n  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n/* The cleanup to run in a CLEANUP_STMT.  */\n#define CLEANUP_EXPR(NODE) \\\n  TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n\n/* The filename we are changing to as of this FILE_STMT.  */\n#define FILE_STMT_FILENAME_NODE(NODE) \\\n  (TREE_OPERAND (FILE_STMT_CHECK (NODE), 0))\n#define FILE_STMT_FILENAME(NODE) \\\n  (IDENTIFIER_POINTER (FILE_STMT_FILENAME_NODE (NODE)))\n\n/* The line-number at which a statement began.  But if\n   STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n   line number for the end of the current function instead.  */\n#define STMT_LINENO(NODE)\t\t\t\\\n  (TREE_COMPLEXITY ((NODE)))\n\n/* If nonzero, the STMT_LINENO for NODE is the line at which the\n   function ended.  */\n#define STMT_LINENO_FOR_FN_P(NODE)\t\t\\\n  (TREE_LANG_FLAG_2 ((NODE)))\n\n/* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n   initialization variables.  */\n#define NEW_FOR_SCOPE_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n\n/* Nonzero if we want to create an ASM_INPUT instead of an\n   ASM_OPERAND with no operands.  */\n#define ASM_INPUT_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n\n#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n\nenum c_tree_code {\n  C_DUMMY_TREE_CODE = LAST_AND_UNUSED_TREE_CODE,\n#include \"c-common.def\"\n  LAST_C_TREE_CODE\n};\n\n#undef DEFTREECODE\n\n#define c_common_stmt_codes\t\t\t\t\\\n   CLEANUP_STMT,\tEXPR_STMT,\tCOMPOUND_STMT,\t\\\n   DECL_STMT,\t\tIF_STMT,\tFOR_STMT,\t\\\n   WHILE_STMT,\t\tDO_STMT,\tRETURN_STMT,\t\\\n   BREAK_STMT,\t\tCONTINUE_STMT,\tSCOPE_STMT,\t\\\n   SWITCH_STMT,\t\tGOTO_STMT,\tLABEL_STMT,\t\\\n   ASM_STMT,\t\tFILE_STMT,\tCASE_LABEL\n\n/* TRUE if a code represents a statement.  The front end init\n   langhook should take care of initialization of this array.  */\nextern bool statement_code_p\u00ddMAX_TREE_CODES\u00a8;\n\n#define STATEMENT_CODE_P(CODE) statement_code_p\u00dd(int) (CODE)\u00a8\n\n#define INIT_STATEMENT_CODES(STMT_CODES)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    unsigned int i;\t\t\t\t\t\t\\\n    memset (&statement_code_p, 0, sizeof (statement_code_p));\t\\\n    for (i = 0; i < ARRAY_SIZE (STMT_CODES); i++)\t\t\\\n      statement_code_p\u00ddSTMT_CODES\u00ddi\u00a8\u00a8 = true;\t\t\t\\\n  } while (0)\n\nextern void genrtl_do_pushlevel (void);\nextern void genrtl_goto_stmt (tree);\nextern void genrtl_expr_stmt (tree);\nextern void genrtl_expr_stmt_value (tree, int, int);\nextern void genrtl_decl_stmt (tree);\nextern void genrtl_if_stmt (tree);\nextern void genrtl_while_stmt (tree);\nextern void genrtl_do_stmt (tree);\nextern void genrtl_return_stmt (tree);\nextern void genrtl_for_stmt (tree);\nextern void genrtl_break_stmt (void);\nextern void genrtl_continue_stmt (void);\nextern void genrtl_scope_stmt (tree);\nextern void genrtl_switch_stmt (tree);\nextern void genrtl_case_label (tree);\nextern void genrtl_compound_stmt (tree);\nextern void genrtl_asm_stmt (tree, tree, tree, tree, tree, int);\nextern void genrtl_cleanup_stmt (tree);\nextern int stmts_are_full_exprs_p (void);\nextern int anon_aggr_type_p (tree);\n\n/* For a VAR_DECL that is an anonymous union, these are the various\n   sub-variables that make up the anonymous union.  */\n#define DECL_ANON_UNION_ELEMS(NODE) DECL_ARGUMENTS ((NODE))\n\n/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n#define DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n#define SET_DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n#define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n\n/* In a VAR_DECL, nonzero if the decl is a register variable with\n   an explicit asm specification.  */\n#define DECL_C_HARD_REGISTER(DECL)  DECL_LANG_FLAG_4 (VAR_DECL_CHECK (DECL))\n\nextern void emit_local_var (tree);\nextern void make_rtl_for_local_static (tree);\nextern tree expand_cond (tree);\nextern tree c_expand_return (tree);\nextern tree do_case (tree, tree);\nextern tree build_stmt (enum tree_code, ...);\nextern tree build_case_label (tree, tree, tree);\nextern tree build_continue_stmt (void);\nextern tree build_break_stmt (void);\nextern tree build_return_stmt (tree);\n\n#define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n\n/* Used by the C++ frontend to mark the block around the member\n   initializers and cleanups.  */\n#define COMPOUND_STMT_BODY_BLOCK(NODE)\tTREE_LANG_FLAG_3 (NODE)\n\nextern void c_expand_asm_operands (tree, tree, tree, tree, int, location_t);\n\n/* These functions must be defined by each front-end which implements\n   a variant of the C language.  They are used in c-common.c.  */\n\nextern tree build_unary_op (enum tree_code, tree, int);\nextern tree build_binary_op (enum tree_code, tree, tree, int);\nextern int lvalue_p (tree);\nextern tree default_conversion (tree);\n\n/* Given two integer or real types, return the type for their sum.\n   Given two compatible ANSI C types, returns the merged type.  */\n\nextern tree common_type (tree, tree);\n\nextern tree expand_tree_builtin (tree, tree, tree);\n\nextern tree decl_constant_value (tree);\n\n/* Handle increment and decrement of boolean types.  */\nextern tree boolean_increment (enum tree_code, tree);\n\n/* Hook currently used only by the C++ front end to reset internal state\n   after entering or leaving a header file.  */\nextern void extract_interface_info (void);\n\nextern int case_compare (splay_tree_key, splay_tree_key);\n\nextern tree c_add_case_label (splay_tree, tree, tree, tree);\n\nextern tree build_function_call (tree, tree);\n\nextern tree finish_label_address_expr (tree);\n\n/* Same function prototype, but the C and C++ front ends have\n   different implementations.  Used in c-common.c.  */\nextern tree lookup_label (tree);\n\nextern int vector_types_convertible_p (tree t1, tree t2);\n\nextern rtx c_expand_expr (tree, rtx, enum machine_mode, int, rtx *);\n\nextern int c_safe_from_p (rtx, tree);\n\nextern int c_staticp (tree);\n\nextern int c_common_unsafe_for_reeval (tree);\n\nextern void init_c_lex (void);\n\nextern void c_cpp_builtins (cpp_reader *);\n\n/* Positive if an implicit `extern \"C\"' scope has just been entered;\n   negative if such a scope has just been exited.  */\nextern int pending_lang_change;\n\n/* Information recorded about each file examined during compilation.  */\n\nstruct c_fileinfo\n{\n  int time;\t/* Time spent in the file.  */\n  short interface_only;\t\t/* Flags - used only by C++ */\n  short interface_unknown;\n};\n\nstruct c_fileinfo *get_fileinfo (const char *);\nextern void dump_time_statistics (void);\n\nextern bool c_dump_tree (void *, tree);\n\nextern void pch_init (void);\nextern int c_common_valid_pch (cpp_reader *pfile, const char *name, int fd);\nextern void c_common_read_pch (cpp_reader *pfile, const char *name, int fd,\n\t\t\t       const char *orig);\nextern void c_common_write_pch (void);\nextern void c_common_no_more_pch (void);\nextern void builtin_define_with_value (const char *, const char *, int);\nextern void c_stddef_cpp_builtins (void);\nextern void fe_file_change (const struct line_map *);\nextern int c_estimate_num_insns (tree decl);\nextern bool c_decl_uninit (tree t);\nextern void c_parse_error (const char *, enum cpp_ttype, tree);\n\n/* The following have been moved here from c-tree.h, since they're needed\n   in the ObjC++ world, too.  What is more, stub-objc.c could use a few\n   prototypes.  */\nextern tree lookup_interface (tree);\nextern tree is_class_name (tree);\nextern tree objc_is_object_ptr (tree);\nextern void objc_check_decl (tree);\nextern int objc_comptypes (tree, tree, int);\nextern tree objc_message_selector (void);\nextern tree lookup_objc_ivar (tree);\nextern void *get_current_scope (void);\nextern void objc_mark_locals_volatile (void *);\n\n/* In c-ppoutput.c  */\nextern void init_pp_output (FILE *);\nextern void preprocess_file (cpp_reader *);\nextern void pp_file_change (const struct line_map *);\nextern void pp_dir_change (cpp_reader *, const char *);\n\n#endif /* ! GCC_C_COMMON_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@INCPAT": {"ttr": 1284, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Set up combined include path for the preprocessor.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\nextern void split_quote_chain (void);\nextern void add_path (char *, int, int);\nextern void register_include_chains (cpp_reader *, const char *,\n\t\t\t\t     const char *, int, int, int);\n\nenum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@PRAGMA": {"ttr": 1286, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Pragma related interfaces.\n   Copyright (C) 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_PRAGMA_H\n#define GCC_C_PRAGMA_H\n\n/* Cause the `yydebug' variable to be defined.  */\n#define YYDEBUG 1\nextern int yydebug;\n\nextern struct cpp_reader* parse_in;\n\n#define HANDLE_PRAGMA_WEAK SUPPORTS_WEAK\n\n#ifdef HANDLE_SYSV_PRAGMA\n/* We always support #pragma pack for SYSV pragmas.  */\n#ifndef HANDLE_PRAGMA_PACK\n#define HANDLE_PRAGMA_PACK 1\n#endif\n#endif /* HANDLE_SYSV_PRAGMA */\n\n\n#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n/* If we are supporting #pragma pack(push... then we automatically\n   support #pragma pack(<n>)  */\n#define HANDLE_PRAGMA_PACK 1\n#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n\nextern void init_pragma (void);\n\n/* Front-end wrapper for pragma registration to avoid dragging\n   cpplib.h in almost everywhere.  */\nextern void c_register_pragma (const char *, const char *,\n\t\t\t       void (*) (struct cpp_reader *));\nextern void maybe_apply_pragma_weak (tree);\nextern tree maybe_apply_renaming_pragma (tree, tree);\nextern void add_to_renaming_pragma_list (tree, tree);\n\nextern int c_lex (tree *);\nextern int c_lex_with_flags (tree *, unsigned char *);\n\n#endif /* GCC_C_PRAGMA_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@PRETTY": {"ttr": 1288, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Various declarations for the C and C++ pretty-printers.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n   Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_PRETTY_PRINTER\n#define GCC_C_PRETTY_PRINTER\n\n#include \"tree.h\"\n#include \"c-common.h\"\n#include \"pretty-print.h\"\n\n\ntypedef enum\n  {\n     pp_c_flag_abstract = 1 << 1,\n     pp_c_flag_last_bit = 2\n  } pp_c_pretty_print_flags;\n\n\n/* The data type used to bundle information necessary for pretty-printing\n   a C or C++ entity.  */\ntypedef struct c_pretty_print_info c_pretty_printer;\n\n/* The type of a C pretty-printer 'member' function.  */\ntypedef void (*c_pretty_print_fn) (c_pretty_printer *, tree);\n\n/* The datatype that contains information necessary for pretty-printing\n   a tree that represents a C construct.  Any pretty-printer for a\n   language using C/c++ syntax can derive from this datatype and reuse\n   facilities provided here.  It can do so by having a subobject of type\n   c_pretty_printer and override the macro pp_c_base to return a pointer\n   to that subobject.  Such a pretty-printer has the responsibility to\n   initialize the pp_base() part, then call pp_c_pretty_printer_init\n   to set up the components that are specific to the C pretty-printer.\n   A derived pretty-printer can override any function listed in the\n   vtable below.  See cp/cxx-pretty-print.h and cp/cxx-pretty-print.c\n   for an example of derivation.  */\nstruct c_pretty_print_info\n{\n  pretty_printer base;\n  /* Points to the first element of an array of offset-list.\n     Not used yet.  */\n  int *offset_list;\n\n  pp_flags flags;\n\n  /* These must be overridden by each of the C and C++ front-end to\n     reflect their understanding of syntactic productions when they differ.  */\n  c_pretty_print_fn declaration;\n  c_pretty_print_fn declaration_specifiers;\n  c_pretty_print_fn declarator;\n  c_pretty_print_fn abstract_declarator;\n  c_pretty_print_fn direct_abstract_declarator;\n  c_pretty_print_fn type_specifier_seq;\n  c_pretty_print_fn direct_declarator;\n  c_pretty_print_fn ptr_operator;\n  c_pretty_print_fn parameter_list;\n  c_pretty_print_fn type_id;\n  c_pretty_print_fn simple_type_specifier;\n  c_pretty_print_fn function_specifier;\n  c_pretty_print_fn storage_class_specifier;\n  c_pretty_print_fn initializer;\n\n  c_pretty_print_fn statement;\n\n  c_pretty_print_fn id_expression;\n  c_pretty_print_fn primary_expression;\n  c_pretty_print_fn postfix_expression;\n  c_pretty_print_fn unary_expression;\n  c_pretty_print_fn multiplicative_expression;\n  c_pretty_print_fn conditional_expression;\n  c_pretty_print_fn assignment_expression;\n  c_pretty_print_fn expression;\n};\n\n/* Override the pp_base macro.  Derived pretty-printers should not\n   touch this macro.  Instead they should override pp_c_base instead.  */\n#undef pp_base\n#define pp_base(PP)  (&pp_c_base (PP)->base)\n\n\n#define pp_c_tree_identifier(PPI, ID)              \\\n   pp_c_identifier (PPI, IDENTIFIER_POINTER (ID))\n\n#define pp_declaration(PPI, T)                    \\\n   pp_c_base (PPI)->declaration (pp_c_base (PPI), T)\n#define pp_declaration_specifiers(PPI, D)         \\\n   pp_c_base (PPI)->declaration_specifiers (pp_c_base (PPI), D)\n#define pp_abstract_declarator(PP, D)             \\\n   pp_c_base (PP)->abstract_declarator (pp_c_base (PP), D)\n#define pp_type_specifier_seq(PPI, D)             \\\n   pp_c_base (PPI)->type_specifier_seq (pp_c_base (PPI), D)\n#define pp_declarator(PPI, D)                     \\\n   pp_c_base (PPI)->declarator (pp_c_base (PPI), D)\n#define pp_direct_declarator(PPI, D)              \\\n   pp_c_base (PPI)->direct_declarator (pp_c_base (PPI), D)\n#define pp_direct_abstract_declarator(PP, D)      \\\n   pp_c_base (PP)->direct_abstract_declarator (pp_c_base (PP), D)\n#define pp_ptr_operator(PP, D)                    \\\n   pp_c_base (PP)->ptr_operator (pp_c_base (PP), D)\n#define pp_parameter_list(PPI, T)                 \\\n  pp_c_base (PPI)->parameter_list (pp_c_base (PPI), T)\n#define pp_type_id(PPI, D)                        \\\n  pp_c_base (PPI)->type_id (pp_c_base (PPI), D)\n#define pp_simple_type_specifier(PP, T)           \\\n  pp_c_base (PP)->simple_type_specifier (pp_c_base (PP), T)\n#define pp_function_specifier(PP, D)              \\\n  pp_c_base (PP)->function_specifier (pp_c_base (PP), D)\n#define pp_storage_class_specifier(PP, D)         \\\n  pp_c_base (PP)->storage_class_specifier (pp_c_base (PP), D);\n\n#define pp_statement(PPI, S)                      \\\n  pp_c_base (PPI)->statement (pp_c_base (PPI), S)\n\n#define pp_id_expression(PP, E)  \\\n  pp_c_base (PP)->id_expression (pp_c_base (PP), E)\n#define pp_primary_expression(PPI, E)             \\\n  pp_c_base (PPI)->primary_expression (pp_c_base (PPI), E)\n#define pp_postfix_expression(PPI, E)             \\\n  pp_c_base (PPI)->postfix_expression (pp_c_base (PPI), E)\n#define pp_unary_expression(PPI, E)               \\\n  pp_c_base (PPI)->unary_expression (pp_c_base (PPI), E)\n#define pp_initializer(PPI, E)                    \\\n  pp_c_base (PPI)->initializer (pp_c_base (PPI), E)\n#define pp_multiplicative_expression(PPI, E)      \\\n  pp_c_base (PPI)->multiplicative_expression (pp_c_base (PPI), E)\n#define pp_conditional_expression(PPI, E)         \\\n  pp_c_base (PPI)->conditional_expression (pp_c_base (PPI), E)\n#define pp_assignment_expression(PPI, E)          \\\n   pp_c_base (PPI)->assignment_expression (pp_c_base (PPI), E)\n#define pp_expression(PP, E)                      \\\n   pp_c_base (PP)->expression (pp_c_base (PP), E)\n\n\n/* Returns the c_pretty_printer base object of PRETTY-PRINTER.  This\n   macro must be overridden by any subclass of c_pretty_print_info.  */\n#define pp_c_base(PP)  (PP)\n\nextern void pp_c_pretty_printer_init (c_pretty_printer *);\nvoid pp_c_whitespace (c_pretty_printer *);\nvoid pp_c_left_paren (c_pretty_printer *);\nvoid pp_c_right_paren (c_pretty_printer *);\nvoid pp_c_left_brace (c_pretty_printer *);\nvoid pp_c_right_brace (c_pretty_printer *);\nvoid pp_c_dot (c_pretty_printer *);\nvoid pp_c_ampersand (c_pretty_printer *);\nvoid pp_c_arrow (c_pretty_printer *);\nvoid pp_c_semicolon (c_pretty_printer *);\nvoid pp_c_space_for_pointer_operator (c_pretty_printer *, tree);\n\n/* Declarations.  */\nvoid pp_c_function_definition (c_pretty_printer *, tree);\nvoid pp_c_attributes (c_pretty_printer *, tree);\nvoid pp_c_type_qualifier_list (c_pretty_printer *, tree);\nvoid pp_c_parameter_type_list (c_pretty_printer *, tree);\nvoid pp_c_declaration (c_pretty_printer *, tree);\nvoid pp_c_declaration_specifiers (c_pretty_printer *, tree);\nvoid pp_c_declarator (c_pretty_printer *, tree);\nvoid pp_c_direct_declarator (c_pretty_printer *, tree);\nvoid pp_c_specifier_qualifier_list (c_pretty_printer *, tree);\nvoid pp_c_function_specifier (c_pretty_printer *, tree);\nvoid pp_c_type_id (c_pretty_printer *, tree);\nvoid pp_c_direct_abstract_declarator (c_pretty_printer *, tree);\nvoid pp_c_type_specifier (c_pretty_printer *, tree);\nvoid pp_c_storage_class_specifier (c_pretty_printer *, tree);\n/* Statements.  */\nvoid pp_c_statement (c_pretty_printer *, tree);\n/* Expressions.  */\nvoid pp_c_expression (c_pretty_printer *, tree);\nvoid pp_c_logical_or_expression (c_pretty_printer *, tree);\nvoid pp_c_expression_list (c_pretty_printer *, tree);\nvoid pp_c_call_argument_list (c_pretty_printer *, tree);\nvoid pp_c_unary_expression (c_pretty_printer *, tree);\nvoid pp_c_cast_expression (c_pretty_printer *, tree);\nvoid pp_c_postfix_expression (c_pretty_printer *, tree);\nvoid pp_c_primary_expression (c_pretty_printer *, tree);\nvoid pp_c_init_declarator (c_pretty_printer *, tree);\nvoid pp_c_constant (c_pretty_printer *, tree);\nvoid pp_c_id_expression (c_pretty_printer *, tree);\nvoid pp_c_identifier (c_pretty_printer *, const char *);\nvoid pp_c_string_literal (c_pretty_printer *, tree);\n\n#endif /* GCC_C_PRETTY_PRINTER */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "C@TREE": {"ttr": 1291, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for C parsing and type checking.\n   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_C_TREE_H\n#define GCC_C_TREE_H\n\n#include \"c-common.h\"\n\n/* Language-dependent contents of an identifier.  */\n\n/* The limbo_value is used for block level extern declarations, which need\n   to be type checked against subsequent extern declarations.  They can't\n   be referenced after they fall out of scope, so they can't be global.\n\n   The rid_code field is used for keywords.  It is in all\n   lang_identifier nodes, because some keywords are only special in a\n   particular context.  */\n\nstruct lang_identifier GTY(())\n{\n  struct c_common_identifier common_id;\n  tree symbol_value;\n  tree tag_value;\n  tree label_value;\n};\n\n/* The resulting tree type.  */\n\nunion lang_tree_node\n  GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&%h.generic) : (union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n{\n  union tree_node GTY ((tag (\"0\"),\n\t\t\tdesc (\"tree_node_structure (&%h)\")))\n    generic;\n  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n};\n\n/* Language-specific declaration information.  */\n\nstruct lang_decl GTY(())\n{\n  /* The return types and parameter types may have variable size.\n     This is a list of any SAVE_EXPRs that need to be evaluated to\n     compute those sizes.  */\n  tree pending_sizes;\n};\n\n/* Macros for access to language-specific slots in an identifier.  */\n/* Each of these slots contains a DECL node or null.  */\n\n/* The value of the identifier in the namespace of \"ordinary identifiers\"\n   (data objects, enum constants, functions, typedefs).  */\n#define IDENTIFIER_SYMBOL_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->symbol_value)\n/* The value of the identifier in the namespace of struct, union,\n   and enum tags.  */\n#define IDENTIFIER_TAG_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->tag_value)\n/* The value of the identifier in the namespace of labels.  */\n#define IDENTIFIER_LABEL_VALUE(NODE)\t\\\n  (((struct lang_identifier *) (NODE))->label_value)\n\n/* In identifiers, C uses the following fields in a special way:\n   TREE_PUBLIC        to record that there was a previous local extern decl.\n   TREE_USED          to record that such a decl was used.\n   TREE_ADDRESSABLE   to record that the address of such a decl was used.  */\n\n/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is read-only.  */\n#define C_TYPE_FIELDS_READONLY(TYPE) TREE_LANG_FLAG_1 (TYPE)\n\n/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n#define C_TYPE_FIELDS_VOLATILE(TYPE) TREE_LANG_FLAG_2 (TYPE)\n\n/* In a RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE\n   nonzero if the definition of the type has already started.  */\n#define C_TYPE_BEING_DEFINED(TYPE) TYPE_LANG_FLAG_0 (TYPE)\n\n/* In an incomplete RECORD_TYPE or UNION_TYPE, a list of variable\n   declarations whose type would be completed by completing that type.  */\n#define C_TYPE_INCOMPLETE_VARS(TYPE) TYPE_VFIELD (TYPE)\n\n/* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n   keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n   and C_RID_YYCODE is the token number wanted by Yacc.  */\n#define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_0 (ID)\n\n/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\nstruct lang_type GTY(())\n{\n  struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\"))) s;\n};\n\n/* Record whether a type or decl was written with nonconstant size.\n   Note that TYPE_SIZE may have simplified to a constant.  */\n#define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n#define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n\n/* Store a value in that field.  */\n#define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n  (TREE_COMPLEXITY (EXP) = (int) (CODE))\n\n/* Record whether a typedef for type `int' was actually `signed int'.  */\n#define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n\n/* For a FUNCTION_DECL, nonzero if it was defined without an explicit\n   return type.  */\n#define C_FUNCTION_IMPLICIT_INT(EXP) DECL_LANG_FLAG_1 (EXP)\n\n/* For a FUNCTION_DECL, nonzero if it was an implicit declaration.  */\n#define C_DECL_IMPLICIT(EXP) DECL_LANG_FLAG_2 (EXP)\n\n/* Nonzero for a declaration of an external object which is not\n   currently in scope.  This is either a built-in declaration of\n   a library function, before a real declaration has been seen,\n   or a declaration that appeared in an inner scope that has ended.  */\n#define C_DECL_INVISIBLE(EXP) DECL_LANG_FLAG_3 (EXP)\n\n/* Nonzero for a decl which either doesn't exist or isn't a prototype.\n   N.B. Could be simplified if all built-in decls had complete prototypes\n   (but this is presently difficult because some of them need FILE*).  */\n#define C_DECL_ISNT_PROTOTYPE(EXP)\t\t\t\\\n       (EXP == 0\t\t\t\t\t\\\n\t|| (TYPE_ARG_TYPES (TREE_TYPE (EXP)) == 0\t\\\n\t    && !DECL_BUILT_IN (EXP)))\n\n/* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n   TYPE_ARG_TYPES for functions with prototypes, but created for functions\n   without prototypes.  */\n#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_BINFO (NODE)\n\n/* Values for the first parameter to poplevel.  */\n#define KEEP_NO\t\t0\n#define KEEP_YES\t1\n#define KEEP_MAYBE\t2\n\n/* Save and restore the variables in this file and elsewhere\n   that keep track of the progress of compilation of the current function.\n   Used for nested functions.  */\n\nstruct language_function GTY(())\n{\n  struct c_language_function base;\n  int returns_value;\n  int returns_null;\n  int returns_abnormally;\n  int warn_about_return_type;\n  int extern_inline;\n  int x_in_iteration_stmt;\n  int x_in_case_stmt;\n};\n\n\n/* in c-parse.in */\nextern void c_parse_init (void);\n\n/* in c-aux-info.c */\nextern void gen_aux_info_record (tree, int, int, int);\n\n/* in c-decl.c */\nextern int c_in_iteration_stmt;\nextern int c_in_case_stmt;\n\nextern int global_bindings_p (void);\nextern tree getdecls (void);\nextern void pushlevel (int);\nextern void insert_block (tree);\nextern void set_block (tree);\nextern tree pushdecl (tree);\nextern void c_expand_body (tree);\n\nextern void c_init_decl_processing (void);\nextern void c_dup_lang_specific_decl (tree);\nextern void c_print_identifier (FILE *, tree, int);\nextern tree build_array_declarator (tree, tree, int, int);\nextern tree build_enumerator (tree, tree);\nextern void check_for_loop_decls (void);\nextern void mark_forward_parm_decls (void);\nextern int  complete_array_type (tree, tree, int);\nextern void declare_parm_level (void);\nextern void undeclared_variable (tree);\nextern tree declare_label (tree);\nextern tree define_label (location_t, tree);\nextern void finish_decl (tree, tree, tree);\nextern tree finish_enum (tree, tree, tree);\nextern void finish_function (void);\nextern tree finish_struct (tree, tree, tree);\nextern tree get_parm_info (int);\nextern tree grokfield (tree, tree, tree);\nextern tree groktypename (tree);\nextern tree groktypename_in_parm_context (tree);\nextern tree implicitly_declare (tree);\nextern int  in_parm_level_p (void);\nextern void keep_next_level (void);\nextern tree lookup_name (tree);\nextern void pending_xref_error (void);\nextern void c_push_function_context (struct function *);\nextern void c_pop_function_context (struct function *);\nextern void push_parm_decl (tree);\nextern tree pushdecl_top_level (tree);\nextern void pushtag (tree, tree);\nextern tree set_array_declarator_type (tree, tree, int);\nextern void shadow_tag (tree);\nextern void shadow_tag_warned (tree, int);\nextern tree start_enum (tree);\nextern int  start_function (tree, tree, tree);\nextern tree start_decl (tree, tree, int, tree);\nextern tree start_struct (enum tree_code, tree);\nextern void store_parm_decls (void);\nextern tree xref_tag (enum tree_code, tree);\nextern tree c_begin_compound_stmt (void);\nextern void c_expand_deferred_function (tree);\nextern void c_expand_decl_stmt (tree);\nextern void c_static_assembler_name (tree);\nextern tree make_pointer_declarator (tree, tree);\nextern void merge_translation_unit_decls (void);\n\n/* in c-objc-common.c */\nextern int c_disregard_inline_limits (tree);\nextern int c_cannot_inline_tree_fn (tree *);\nextern bool c_objc_common_init (void);\nextern int c_missing_noreturn_ok_p (tree);\nextern void c_objc_common_finish_file (void);\nextern int defer_fn (tree);\nextern bool c_warn_unused_global_decl (tree);\n\n#define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n  c_build_qualified_type ((TYPE),\t\t\t\t  \\\n\t\t\t  ((CONST_P) ? TYPE_QUAL_CONST : 0) |\t  \\\n\t\t\t  ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n\n#define c_sizeof_nowarn(T)  c_sizeof_or_alignof_type (T, SIZEOF_EXPR, 0)\n\n/* in c-typeck.c */\n\n/* For use with comptypes.  */\nenum {\n  COMPARE_STRICT = 0\n};\n\nextern tree require_complete_type (tree);\nextern int comptypes (tree, tree, int);\nextern tree c_size_in_bytes (tree);\nextern bool c_mark_addressable (tree);\nextern void c_incomplete_type_error (tree, tree);\nextern tree c_type_promotes_to (tree);\nextern tree build_component_ref (tree, tree);\nextern tree build_indirect_ref (tree, const char *);\nextern tree build_array_ref (tree, tree);\nextern tree build_external_ref (tree, int);\nextern tree parser_build_binary_op (enum tree_code, tree, tree);\nextern int c_tree_expr_nonnegative_p (tree);\nextern void readonly_error (tree, const char *);\nextern tree build_conditional_expr (tree, tree, tree);\nextern tree build_compound_expr (tree);\nextern tree c_cast_expr (tree, tree);\nextern tree build_c_cast (tree, tree);\nextern tree build_modify_expr (tree, enum tree_code, tree);\nextern void store_init_value (tree, tree);\nextern void error_init (const char *);\nextern void pedwarn_init (const char *);\nextern void start_init (tree, tree, int);\nextern void finish_init (void);\nextern void really_start_incremental_init (tree);\nextern void push_init_level (int);\nextern tree pop_init_level (int);\nextern void set_init_index (tree, tree);\nextern void set_init_label (tree);\nextern void process_init_element (tree);\nextern tree build_compound_literal (tree, tree);\nextern void pedwarn_c90 (const char *, ...) ATTRIBUTE_PRINTF_1;\nextern void pedwarn_c99 (const char *, ...) ATTRIBUTE_PRINTF_1;\nextern tree c_start_case (tree);\nextern void c_finish_case (void);\nextern tree simple_asm_stmt (tree);\nextern tree build_asm_stmt (tree, tree, tree, tree, tree);\nextern tree c_convert_parm_for_inlining (tree, tree, tree, int);\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a return statement that specifies a return value is seen.  */\n\nextern int current_function_returns_value;\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a return statement with no argument is seen.  */\n\nextern int current_function_returns_null;\n\n/* Set to 0 at beginning of a function definition, set to 1 if\n   a call to a noreturn function is seen.  */\n\nextern int current_function_returns_abnormally;\n\n/* Nonzero means we are reading code that came from a system header file.  */\n\nextern int system_header_p;\n\n/* In c-decl.c */\nextern void c_finish_incomplete_decl (tree);\nextern void *get_current_scope (void);\nextern void objc_mark_locals_volatile (void *);\nextern void c_write_global_declarations (void);\n\nextern GTY(()) tree static_ctors;\nextern GTY(()) tree static_dtors;\n\n/* In order for the format checking to accept the C frontend\n   diagnostic framework extensions, you must include this file before\n   toplev.h, not after.  */\n#define GCC_DIAG_STYLE __gcc_cdiag__\n\n#endif /* ! GCC_C_TREE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCOMMOND": {"ttr": 1295, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   additional tree codes used in the GNU C++ compiler (see tree.def\n   for the standard codes).\n   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n   1999, 2000, 2001 Free Software Foundation, Inc.\n   Written by Benjamin Chelf <chelf@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Tree nodes relevant to both C and C++. These were originally in\ncp-tree.def in the cp subdir.  */\n\nDEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\nDEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\nDEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n\n/* Used to represent an expression statement.  Use `EXPR_STMT_EXPR' to\n   obtain the expression.  */\nDEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n\n/* Used to represent a brace-enclosed block.  The operand is\n   COMPOUND_BODY.  */\nDEFTREECODE (COMPOUND_STMT, \"compound_stmt\", 'e', 1)\n\n/* Used to represent a local declaration. The operand is\n   DECL_STMT_DECL.  */\nDEFTREECODE (DECL_STMT, \"decl_stmt\", 'e', 1)\n\n/* Represents an 'if' statement. The operands are IF_COND,\n   THEN_CLAUSE, and ELSE_CLAUSE, respectively.  */\nDEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n\n/* Used to represent a `for' statement. The operands are\n   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\nDEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n\n/* Used to represent a 'while' statement. The operands are WHILE_COND\n   and WHILE_BODY, respectively.  */\nDEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n\n/* Used to represent a 'do' statement. The operands are DO_BODY and\n   DO_COND, respectively.  */\nDEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n\n/* Used to represent a 'return' statement. The operand is\n   RETURN_STMT_EXPR.  */\nDEFTREECODE (RETURN_STMT, \"return_stmt\", 'e', 1)\n\n/* Used to represent a 'break' statement.  */\nDEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n\n/* Used to represent a 'continue' statement.  */\nDEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n\n/* Used to represent a 'switch' statement. The operands are\n   SWITCH_COND, SWITCH_BODY and SWITCH_TYPE, respectively.  */\nDEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 3)\n\n/* Used to represent a 'goto' statement. The operand is GOTO_DESTINATION.  */\nDEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n\n/* Used to represent a 'label' statement. The operand is a LABEL_DECL\n   and can be obtained through the macro LABEL_STMT_LABEL.  */\nDEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n\n/* Used to represent an inline assembly statement.  */\nDEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n\n/* A SCOPE_STMT marks the beginning or end of a scope.  If\n   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n   SCOPE_END_P holds, then this is the end of a scope.  If\n   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n   variables declared in this scope.  */\nDEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n\n/* A FILE_STMT marks the spot where a function changes files.  It has no\n   other semantics.  FILE_STMT_FILENAME gives the name.  */\nDEFTREECODE (FILE_STMT, \"file_stmt\", 'e', 1)\n\n/* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n   CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n   'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n   label.  The CASE_LABEL_DECL is a LABEL_DECL for this node.  */\nDEFTREECODE (CASE_LABEL, \"case_label\", 'e', 3)\n\n/* A STMT_EXPR represents a statement-expression.  The\n   STMT_EXPR_STMT is the statement given by the expression.  */\nDEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n\n/* A COMPOUND_LITERAL_EXPR represents a C99 compound literal.  The\n   COMPOUND_LITERAL_EXPR_DECL_STMT is the a DECL_STMT containing the decl\n   for the anonymous object represented by the COMPOUND_LITERAL;\n   the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes\n   the compound literal.  */\nDEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)\n\n/* A CLEANUP_STMT marks the point at which a declaration is fully\n   constructed.  If, after this point, the CLEANUP_DECL goes out of\n   scope, the CLEANUP_EXPR must be run.  */\nDEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CFGHOOKS": {"ttr": 1297, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Hooks for cfg representation specific functions.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n   Contributed by Sebastian Pop <s.pop@laposte.net>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_CFGHOOKS_H\n#define GCC_CFGHOOKS_H\n\nstruct cfg_hooks\n{\n  /* Debugging.  Do not use macros to hook these so they can be called from\n     debugger!  */\n  int (*cfgh_verify_flow_info) (void);\n  void (*dump_bb) (basic_block, FILE *);\n\n  /* Basic CFG manipulation.  */\n\n  /* Return new basic block.  */\n  basic_block (*create_basic_block) (void *head, void *end, basic_block after);\n\n  /* Redirect edge E to the given basic block B and update underlying program\n     representation.  Returns false when edge is not easily redirectable for\n     whatever reason.  */\n  bool (*redirect_edge_and_branch) (edge e, basic_block b);\n\n  /* Same as the above but allows redirecting of fallthru edges.  In that case\n     newly created forwarder basic block is returned.  It aborts when called\n     on abnormal edge.  */\n  basic_block (*redirect_edge_and_branch_force) (edge, basic_block);\n\n  /* Remove given basic block and all edges possibly pointing into it.  */\n  void (*delete_block) (basic_block);\n\n  /* Split basic block B after specified instruction I.  */\n  edge (*split_block) (basic_block b, void * i);\n\n  /* Return true when blocks A and B can be merged into single basic block.  */\n  bool (*can_merge_blocks_p) (basic_block a, basic_block b);\n\n  /* Merge blocks A and B.  */\n  void (*merge_blocks) (basic_block a, basic_block b);\n\n  /* Higher level functions representable by primitive operations above if\n     we didn't have some oddities in RTL and Tree representations.  */\n  basic_block (*cfgh_split_edge) (edge);\n};\n\n#define redirect_edge_and_branch(e,b)        cfg_hooks->redirect_edge_and_branch (e,b)\n#define redirect_edge_and_branch_force(e,b)  cfg_hooks->redirect_edge_and_branch_force (e,b)\n#define split_block(e,i)                     cfg_hooks->split_block (e,i)\n#define delete_block(b)\t\t\t     cfg_hooks->delete_block (b)\n#define split_edge(e)                        cfg_hooks->cfgh_split_edge (e)\n#define create_basic_block(h,e,a)            cfg_hooks->create_basic_block (h,e,a)\n#define can_merge_blocks_p(a,b)\t\t     cfg_hooks->can_merge_blocks_p (a,b)\n#define merge_blocks(a,b)\t\t     cfg_hooks->merge_blocks (a,b)\n\n/* Hooks containers.  */\nextern struct cfg_hooks rtl_cfg_hooks;\n\n/* A pointer to one of the hooks containers.  */\nextern struct cfg_hooks *cfg_hooks;\n\n/* Declarations.  */\nextern void rtl_register_cfg_hooks (void);\nextern void cfg_layout_rtl_register_cfg_hooks (void);\n\n#endif  /* GCC_CFGHOOKS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CFGLAYOU": {"ttr": 1299, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Basic block reordering routines for the GNU compiler.\n   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* Structure to hold information about the blocks during reordering.  */\ntypedef struct reorder_block_def\n{\n  rtx header;\n  rtx footer;\n  basic_block next;\n  basic_block original;\n  /* Used by loop copying.  */\n  basic_block copy;\n  int duplicated;\n\n  /* These fields are used by bb-reorder pass.  */\n  int visited;\n} *reorder_block_def;\n\nextern rtx cfg_layout_function_footer;\n\nextern void cfg_layout_initialize (unsigned int);\nextern void cfg_layout_finalize (void);\nextern bool cfg_layout_can_duplicate_bb_p (basic_block);\nextern basic_block cfg_layout_duplicate_bb (basic_block, edge);\nextern void insn_locators_initialize (void);\nextern void reemit_insn_block_notes (void);\nextern bool can_copy_bbs_p (basic_block *, unsigned);\nextern void copy_bbs (basic_block *, unsigned, basic_block *,\n\t\t      edge *, unsigned, edge *, struct loop *);\nextern void cfg_layout_initialize_rbi (basic_block);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CFGLOOP": {"ttr": 1537, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Natural loop functions\n   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Structure to hold decision about unrolling/peeling.  */\nenum lpt_dec\n{\n  LPT_NONE,\n  LPT_PEEL_COMPLETELY,\n  LPT_PEEL_SIMPLE,\n  LPT_UNROLL_CONSTANT,\n  LPT_UNROLL_RUNTIME,\n  LPT_UNROLL_STUPID\n};\n\nstruct lpt_decision\n{\n  enum lpt_dec decision;\n  unsigned times;\n};\n\n/* Description of loop for simple loop unrolling.  */\nstruct loop_desc\n{\n  int postincr;\t\t/* 1 if increment/decrement is done after loop exit condition.  */\n  rtx stride;\t\t/* Value added to VAR in each iteration.  */\n  rtx var;\t\t/* Loop control variable.  */\n  enum machine_mode inner_mode;\n\t\t\t/* The mode from that it is extended.  */\n  enum rtx_code extend;\t/* With this extend.  */\n  rtx var_alts;\t\t/* List of definitions of its initial value.  */\n  rtx lim;\t\t/* Expression var is compared with.  */\n  rtx lim_alts;\t\t/* List of definitions of its initial value.  */\n  bool const_iter;      /* True if it iterates constant number of times.  */\n  unsigned HOST_WIDE_INT niter;\n\t\t\t/* Number of iterations if it is constant.  */\n  bool may_be_zero;     /* If we cannot determine that the first iteration will pass.  */\n  enum rtx_code cond;\t/* Exit condition.  */\n  int neg;\t\t/* Set to 1 if loop ends when condition is satisfied.  */\n  edge out_edge;\t/* The exit edge.  */\n  edge in_edge;\t\t/* And the other one.  */\n  int n_branches;\t/* Number of branches inside the loop.  */\n};\n\n/* Structure to hold information for each natural loop.  */\nstruct loop\n{\n  /* Index into loops array.  */\n  int num;\n\n  /* Basic block of loop header.  */\n  basic_block header;\n\n  /* Basic block of loop latch.  */\n  basic_block latch;\n\n  /* Basic block of loop preheader or NULL if it does not exist.  */\n  basic_block pre_header;\n\n  /* For loop unrolling/peeling decision.  */\n  struct lpt_decision lpt_decision;\n\n  /* Simple loop description.  */\n  int simple;\n  struct loop_desc desc;\n  int has_desc;\n\n  /* Number of loop insns.  */\n  unsigned ninsns;\n\n  /* Average number of executed insns per iteration.  */\n  unsigned av_ninsns;\n\n  /* Array of edges along the preheader extended basic block trace.\n     The source of the first edge is the root node of preheader\n     extended basic block, if it exists.  */\n  edge *pre_header_edges;\n\n  /* Number of edges along the pre_header extended basic block trace.  */\n  int num_pre_header_edges;\n\n  /* The first block in the loop.  This is not necessarily the same as\n     the loop header.  */\n  basic_block first;\n\n  /* The last block in the loop.  This is not necessarily the same as\n     the loop latch.  */\n  basic_block last;\n\n  /* Bitmap of blocks contained within the loop.  */\n  sbitmap nodes;\n\n  /* Number of blocks contained within the loop.  */\n  unsigned num_nodes;\n\n  /* Array of edges that enter the loop.  */\n  edge *entry_edges;\n\n  /* Number of edges that enter the loop.  */\n  int num_entries;\n\n  /* Array of edges that exit the loop.  */\n  edge *exit_edges;\n\n  /* Number of edges that exit the loop.  */\n  int num_exits;\n\n  /* Bitmap of blocks that dominate all exits of the loop.  */\n  sbitmap exits_doms;\n\n  /* The loop nesting depth.  */\n  int depth;\n\n  /* Superloops of the loop.  */\n  struct loop **pred;\n\n  /* The height of the loop (enclosed loop levels) within the loop\n     hierarchy tree.  */\n  int level;\n\n  /* The outer (parent) loop or NULL if outermost loop.  */\n  struct loop *outer;\n\n  /* The first inner (child) loop or NULL if innermost loop.  */\n  struct loop *inner;\n\n  /* Link to the next (sibling) loop.  */\n  struct loop *next;\n\n  /* Loop that is copy of this loop.  */\n  struct loop *copy;\n\n  /* Nonzero if the loop is invalid (e.g., contains setjmp.).  */\n  int invalid;\n\n  /* Auxiliary info specific to a pass.  */\n  void *aux;\n\n  /* The following are currently used by loop.c but they are likely to\n     disappear as loop.c is converted to use the CFG.  */\n\n  /* Nonzero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n  rtx vtop;\n\n  /* Nonzero if the loop has a NOTE_INSN_LOOP_CONT.\n     A continue statement will generate a branch to NEXT_INSN (cont).  */\n  rtx cont;\n\n  /* The dominator of cont.  */\n  rtx cont_dominator;\n\n  /* The NOTE_INSN_LOOP_BEG.  */\n  rtx start;\n\n  /* The NOTE_INSN_LOOP_END.  */\n  rtx end;\n\n  /* For a rotated loop that is entered near the bottom,\n     this is the label at the top.  Otherwise it is zero.  */\n  rtx top;\n\n  /* Place in the loop where control enters.  */\n  rtx scan_start;\n\n  /* The position where to sink insns out of the loop.  */\n  rtx sink;\n\n  /* List of all LABEL_REFs which refer to code labels outside the\n     loop.  Used by routines that need to know all loop exits, such as\n     final_biv_value and final_giv_value.\n\n     This does not include loop exits due to return instructions.\n     This is because all bivs and givs are pseudos, and hence must be\n     dead after a return, so the presence of a return does not affect\n     any of the optimizations that use this info.  It is simpler to\n     just not include return instructions on this list.  */\n  rtx exit_labels;\n\n  /* The number of LABEL_REFs on exit_labels for this loop and all\n     loops nested inside it.  */\n  int exit_count;\n};\n\n/* Flags for state of loop structure.  */\nenum\n{\n  LOOPS_HAVE_PREHEADERS = 1,\n  LOOPS_HAVE_SIMPLE_LATCHES = 2,\n  LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4\n};\n\n/* Structure to hold CFG information about natural loops within a function.  */\nstruct loops\n{\n  /* Number of natural loops in the function.  */\n  unsigned num;\n\n  /* Maximum nested loop level in the function.  */\n  unsigned levels;\n\n  /* Array of natural loop descriptors (scanning this array in reverse order\n     will find the inner loops before their enclosing outer loops).  */\n  struct loop *array;\n\n  /* The above array is unused in new loop infrastructure and is kept only for\n     purposes of the old loop optimizer.  Instead we store just pointers to\n     loops here.  */\n  struct loop **parray;\n\n  /* Pointer to root of loop hierarchy tree.  */\n  struct loop *tree_root;\n\n  /* Information derived from the CFG.  */\n  struct cfg\n  {\n    /* The ordering of the basic blocks in a depth first search.  */\n    int *dfs_order;\n\n    /* The reverse completion ordering of the basic blocks found in a\n       depth first search.  */\n    int *rc_order;\n  } cfg;\n\n  /* Headers shared by multiple loops that should be merged.  */\n  sbitmap shared_headers;\n\n  /* State of loops.  */\n  int state;\n};\n\n/* Flags for loop discovery.  */\n\n#define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */\n#define LOOP_PRE_HEADER\t\t2\t/* Analyze loop preheader.  */\n#define LOOP_ENTRY_EDGES\t4\t/* Find entry edges.  */\n#define LOOP_EXIT_EDGES\t\t8\t/* Find exit edges.  */\n#define LOOP_EDGES\t\t(LOOP_ENTRY_EDGES | LOOP_EXIT_EDGES)\n#define LOOP_ALL\t       15\t/* All of the above  */\n\n/* Loop recognition.  */\nextern int flow_loops_find (struct loops *, int flags);\nextern int flow_loops_update (struct loops *, int flags);\nextern void flow_loops_free (struct loops *);\nextern void flow_loops_dump (const struct loops *, FILE *,\n\t\t\t     void (*)(const struct loop *, FILE *, int), int);\nextern void flow_loop_dump (const struct loop *, FILE *,\n\t\t\t    void (*)(const struct loop *, FILE *, int), int);\nextern int flow_loop_scan (struct loop *, int);\nextern void flow_loop_free (struct loop *);\nvoid mark_irreducible_loops (struct loops *);\n\n/* Loop data structure manipulation/querying.  */\nextern void flow_loop_tree_node_add (struct loop *, struct loop *);\nextern void flow_loop_tree_node_remove (struct loop *);\nextern bool flow_loop_outside_edge_p (const struct loop *, edge);\nextern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\nextern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\nextern struct loop * find_common_loop (struct loop *, struct loop *);\nextern int num_loop_insns (struct loop *);\nextern int average_num_loop_insns (struct loop *);\n\n/* Loops & cfg manipulation.  */\nextern basic_block *get_loop_body (const struct loop *);\nextern edge *get_loop_exit_edges (const struct loop *, unsigned *);\n\nextern edge loop_preheader_edge (const struct loop *);\nextern edge loop_latch_edge (const struct loop *);\n\nextern void add_bb_to_loop (basic_block, struct loop *);\nextern void remove_bb_from_loops (basic_block);\n\nextern void cancel_loop (struct loops *, struct loop *);\nextern void cancel_loop_tree (struct loops *, struct loop *);\n\nextern basic_block loop_split_edge_with (edge, rtx);\nextern int fix_loop_placement (struct loop *);\n\nenum\n{\n  CP_SIMPLE_PREHEADERS = 1\n};\n\nextern void create_preheaders (struct loops *, int);\nextern void force_single_succ_latches (struct loops *);\n\nextern void verify_loop_structure (struct loops *);\n\n/* Loop analysis.  */\nextern bool simple_loop_p (struct loop *, struct loop_desc *);\nextern rtx count_loop_iterations (struct loop_desc *, rtx, rtx);\nextern bool just_once_each_iteration_p (struct loop *, basic_block);\nextern unsigned expected_loop_iterations (const struct loop *);\n\n/* Loop manipulation.  */\nextern bool can_duplicate_loop_p (struct loop *loop);\n\n#define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n\t\t\t\t\t   duplicate_loop_to_header_edge.  */\n\nextern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n\t\t\t\t\t  unsigned, sbitmap, edge, edge *,\n\t\t\t\t\t  unsigned *, int);\nextern struct loop *loopify (struct loops *, edge, edge, basic_block);\nextern void unloop (struct loops *, struct loop *);\nextern bool remove_path (struct loops *, edge);\nextern edge split_loop_bb (basic_block, rtx);\n\n/* Loop optimizer initialization.  */\nextern struct loops *loop_optimizer_init (FILE *);\nextern void loop_optimizer_finalize (struct loops *, FILE *);\n\n/* Optimization passes.  */\nextern void unswitch_loops (struct loops *);\n\nenum\n{\n  UAP_PEEL = 1,\t\t/* Enables loop peeling.  */\n  UAP_UNROLL = 2,\t/* Enables peeling of loops if it seems profitable.  */\n  UAP_UNROLL_ALL = 4\t/* Enables peeling of all loops.  */\n};\n\nextern void unroll_and_peel_loops (struct loops *, int);\nextern bool is_bct_cond (rtx);\nextern rtx get_var_set_from_bct (rtx);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CGRAPH": {"ttr": 1540, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Callgraph handling code.\n   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n   Contributed by Jan Hubicka\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_CGRAPH_H\n#define GCC_CGRAPH_H\n\n/* Information about the function collected locally.\n   Available after function is analyzed.  */\n\nstruct cgraph_local_info GTY(())\n{\n  /* Size of the function before inlining.  */\n  int self_insns;\n\n  /* Set when function function is visible in current compilation unit only\n     and it's address is never taken.  */\n  bool local;\n  /* Set once it has been finalized so we consider it to be output.  */\n  bool finalized;\n\n  /* False when there something makes inlining impossible (such as va_arg).  */\n  bool inlinable;\n  /* True when function should be inlined independently on it's size.  */\n  bool disregard_inline_limits;\n  /* True when the function has been originally extern inline, but it is\n     redefined now.  */\n  bool redefined_extern_inline;\n};\n\n/* Information about the function that needs to be computed globally\n   once compilation is finished.  Available only with -funit-at-time.  */\n\nstruct cgraph_global_info GTY(())\n{\n  /* Estimated size of the function after inlining.  */\n  int insns;\n\n  /* Number of times given function will be cloned during output.  */\n  int cloned_times;\n\n  /* Set when the function will be inlined exactly once.  */\n  bool inline_once;\n\n  /* Set to true for all reachable functions before inlining is decided.\n     Once we inline all calls to the function and the function is local,\n     it is set to false.  */\n  bool will_be_output;\n\n  /* Set iff at least one of the caller edges has inline_call flag set.  */\n  bool inlined;\n};\n\n/* Information about the function that is propagated by the RTL backend.\n   Available only for functions that has been already assembled.  */\n\nstruct cgraph_rtl_info GTY(())\n{\n   bool const_function;\n   bool pure_function;\n   int preferred_incoming_stack_boundary;\n};\n\n\n/* The cgraph data structure.\n   Each function decl has assigned cgraph_node listing callees and callers.  */\n\nstruct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n{\n  tree decl;\n  struct cgraph_edge *callees;\n  struct cgraph_edge *callers;\n  struct cgraph_node *next;\n  struct cgraph_node *previous;\n  /* For nested functions points to function the node is nested in.  */\n  struct cgraph_node *origin;\n  /* Points to first nested function, if any.  */\n  struct cgraph_node *nested;\n  /* Pointer to the next function with same origin, if any.  */\n  struct cgraph_node *next_nested;\n  /* Pointer to the next function in cgraph_nodes_queue.  */\n  struct cgraph_node *next_needed;\n  PTR GTY ((skip (\"\"))) aux;\n\n  struct cgraph_local_info local;\n  struct cgraph_global_info global;\n  struct cgraph_rtl_info rtl;\n  /* Unique id of the node.  */\n  int uid;\n  /* Set when function must be output - it is externally visible\n     or it's address is taken.  */\n  bool needed;\n  /* Set when function is reachable by call from other function\n     that is either reachable or needed.  */\n  bool reachable;\n  /* Set once the function has been instantiated and its callee\n     lists created.  */\n  bool analyzed;\n  /* Set when function is scheduled to be assembled.  */\n  bool output;\n};\n\nstruct cgraph_edge GTY(())\n{\n  struct cgraph_node *caller;\n  struct cgraph_node *callee;\n  struct cgraph_edge *next_caller;\n  struct cgraph_edge *next_callee;\n  /* When NULL, inline this call.  When non-NULL, points to the explanation\n     why function was not inlined.  */\n  const char *inline_failed;\n};\n\n/* The cgraph_varpool data structure.\n   Each static variable decl has assigned cgraph_varpool_node.  */\n\nstruct cgraph_varpool_node GTY(())\n{\n  tree decl;\n  /* Pointer to the next function in cgraph_varpool_nodes_queue.  */\n  struct cgraph_varpool_node *next_needed;\n\n  /* Set when function must be output - it is externally visible\n     or it's address is taken.  */\n  bool needed;\n  /* Set once it has been finalized so we consider it to be output.  */\n  bool finalized;\n  /* Set when function is scheduled to be assembled.  */\n  bool output;\n};\n\nextern GTY(()) struct cgraph_node *cgraph_nodes;\nextern GTY(()) int cgraph_n_nodes;\nextern GTY(()) int cgraph_max_uid;\nextern bool cgraph_global_info_ready;\nextern GTY(()) struct cgraph_node *cgraph_nodes_queue;\nextern FILE *cgraph_dump_file;\n\nextern GTY(()) int cgraph_varpool_n_nodes;\nextern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n\n\n/* In cgraph.c  */\nvoid dump_cgraph (FILE *);\nvoid cgraph_remove_edge (struct cgraph_node *, struct cgraph_node *);\nvoid cgraph_remove_call (tree, tree);\nvoid cgraph_remove_node (struct cgraph_node *);\nstruct cgraph_edge *cgraph_record_call (tree, tree);\nstruct cgraph_node *cgraph_node (tree decl);\nstruct cgraph_node *cgraph_node_for_identifier (tree id);\nbool cgraph_calls_p (tree, tree);\nstruct cgraph_local_info *cgraph_local_info (tree);\nstruct cgraph_global_info *cgraph_global_info (tree);\nstruct cgraph_rtl_info *cgraph_rtl_info (tree);\nconst char * cgraph_node_name (struct cgraph_node *);\n\nstruct cgraph_varpool_node *cgraph_varpool_node (tree decl);\nstruct cgraph_varpool_node *cgraph_varpool_node_for_identifier (tree id);\nvoid cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\nvoid cgraph_varpool_finalize_decl (tree);\nbool cgraph_varpool_assemble_pending_decls (void);\n\nbool cgraph_function_possibly_inlined_p (tree);\n\n/* In cgraphunit.c  */\nbool cgraph_assemble_pending_functions (void);\nvoid cgraph_finalize_function (tree, bool);\nvoid cgraph_finalize_compilation_unit (void);\nvoid cgraph_create_edges (tree, tree);\nvoid cgraph_optimize (void);\nvoid cgraph_mark_needed_node (struct cgraph_node *);\nvoid cgraph_mark_reachable_node (struct cgraph_node *);\nbool cgraph_inline_p (tree, tree, const char **reason);\n\n#endif  /* GCC_CGRAPH_H  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLLECT2": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for collect/tlink routines.\n   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_COLLECT2_H\n#define GCC_COLLECT2_H\n\nextern void do_tlink (char **, char **);\n\nextern void collect_execute (const char *, char **, const char *);\n\nextern void collect_exit (int) ATTRIBUTE_NORETURN;\n\nextern int collect_wait (const char *);\n\nextern void dump_file (const char *);\n\nextern int file_exists (const char *);\n\nextern const char *ldout;\nextern const char *c_file_name;\nextern struct obstack temporary_obstack;\nextern char *temporary_firstobj;\nextern int vflag, debug;\n\nextern void fancy_abort (void) ATTRIBUTE_NORETURN;\nextern void error (const char *, ...) ATTRIBUTE_PRINTF_1;\nextern void notice (const char *, ...) ATTRIBUTE_PRINTF_1;\nextern void fatal (const char *, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\nextern void fatal_perror (const char *, ...)\n  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n\n#endif /* ! GCC_COLLECT2_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONDITIO": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for condition code handling in final.c and output routines.\n   Copyright (C) 1987 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* None of the things in the files exist if we don't use CC0.  */\n\n#ifdef HAVE_cc0\n\n/* The variable cc_status says how to interpret the condition code.\n   It is set by output routines for an instruction that sets the cc's\n   and examined by output routines for jump instructions.\n\n   cc_status contains two components named `value1' and `value2'\n   that record two equivalent expressions for the values that the\n   condition codes were set from.  (Either or both may be null if\n   there is no useful expression to record.)  These fields are\n   used for eliminating redundant test and compare instructions\n   in the cases where the condition codes were already set by the\n   previous instruction.\n\n   cc_status.flags contains flags which say that the condition codes\n   were set in a nonstandard manner.  The output of jump instructions\n   uses these flags to compensate and produce the standard result\n   with the nonstandard condition codes.  Standard flags are defined here.\n   The tm.h file can also define other machine-dependent flags.\n\n   cc_status also contains a machine-dependent component `mdep'\n   whose type, `CC_STATUS_MDEP', may be defined as a macro in the\n   tm.h file.  */\n\n#ifndef CC_STATUS_MDEP\n#define CC_STATUS_MDEP int\n#endif\n\n#ifndef CC_STATUS_MDEP_INIT\n#define CC_STATUS_MDEP_INIT 0\n#endif\n\ntypedef struct {int flags; rtx value1, value2; CC_STATUS_MDEP mdep;} CC_STATUS;\n\n/* While outputting an insn as assembler code,\n   this is the status BEFORE that insn.  */\nextern CC_STATUS cc_prev_status;\n\n/* While outputting an insn as assembler code,\n   this is being altered to the status AFTER that insn.  */\nextern CC_STATUS cc_status;\n\n/* These are the machine-independent flags:  */\n\n/* Set if the sign of the cc value is inverted:\n   output a following jump-if-less as a jump-if-greater, etc.  */\n#define CC_REVERSED 1\n\n/* This bit means that the current setting of the N bit is bogus\n   and conditional jumps should use the Z bit in its place.\n   This state obtains when an extraction of a signed single-bit field\n   or an arithmetic shift right of a byte by 7 bits\n   is turned into a btst, because btst does not set the N bit.  */\n#define CC_NOT_POSITIVE 2\n\n/* This bit means that the current setting of the N bit is bogus\n   and conditional jumps should pretend that the N bit is clear.\n   Used after extraction of an unsigned bit\n   or logical shift right of a byte by 7 bits is turned into a btst.\n   The btst does not alter the N bit, but the result of that shift\n   or extract is never negative.  */\n#define CC_NOT_NEGATIVE 4\n\n/* This bit means that the current setting of the overflow flag\n   is bogus and conditional jumps should pretend there is no overflow.  */\n/* ??? Note that for most targets this macro is misnamed as it applies\n   to the carry flag, not the overflow flag.  */\n#define CC_NO_OVERFLOW 010\n\n/* This bit means that what ought to be in the Z bit\n   should be tested as the complement of the N bit.  */\n#define CC_Z_IN_NOT_N 020\n\n/* This bit means that what ought to be in the Z bit\n   should be tested as the N bit.  */\n#define CC_Z_IN_N 040\n\n/* Nonzero if we must invert the sense of the following branch, i.e.\n   change EQ to NE.  This is not safe for IEEE floating point operations!\n   It is intended for use only when a combination of arithmetic\n   or logical insns can leave the condition codes set in a fortuitous\n   (though inverted) state.  */\n#define CC_INVERTED 0100\n\n/* Nonzero if we must convert signed condition operators to unsigned.\n   This is only used by machine description files.  */\n#define CC_NOT_SIGNED 0200\n\n/* This is how to initialize the variable cc_status.\n   final does this at appropriate moments.  */\n\n#define CC_STATUS_INIT  \\\n (cc_status.flags = 0, cc_status.value1 = 0, cc_status.value2 = 0,  \\\n  CC_STATUS_MDEP_INIT)\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONFIG": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_CONFIG_H\n#define GCC_CONFIG_H\n#ifndef POSIX\n# define POSIX\n#endif\n#include \"auto-host.h\"\n#ifdef IN_GCC\n# include \"ansidecl.h\"\n#endif\n#endif /* GCC_CONFIG_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONFIGAR": {"ttr": 1549, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically. */\nstatic const char configuration_arguments\u00dd\u00a8 = \"./configure --build=i686-linux --host=i370-mvspdp --target=i370-mvspdp --prefix=/devel/mvshost --enable-languages=c --disable-nls\";\nstatic const char thread_model\u00dd\u00a8 = \"single\";\n\nstatic const struct {\n  const char *name, *value;\n} configure_default_options\u00dd\u00a8 = { { NULL, NULL} };\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONVERT": {"ttr": 1551, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definition of functions in convert.c.\n   Copyright (C) 1993, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern tree convert_to_integer (tree, tree);\nextern tree convert_to_pointer (tree, tree);\nextern tree convert_to_real (tree, tree);\nextern tree convert_to_complex (tree, tree);\nextern tree convert_to_vector (tree, tree);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CORETYPE": {"ttr": 1553, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* GCC core type declarations.\n   Copyright (C) 2002 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Provide forward declarations of core types which are referred to by\n   most of the compiler.  This allows header files to use these types\n   (e.g. in function prototypes) without concern for whether the full\n   definitions are visible.  Some other declarations that need to be\n   universally visible are here, too.\n\n   In the context of tconfig.h, most of these have special definitions\n   which prevent them from being used except in further type\n   declarations.  This is a kludge; the right thing is to avoid\n   including the \"tm.h\" header set in the context of tconfig.h, but\n   we're not there yet.  */\n\n#ifndef GCC_CORETYPES_H\n#define GCC_CORETYPES_H\n\n#define GTY(x)  /* nothing - marker for gengtype */\n\n#ifndef USED_FOR_TARGET\n\nstruct rtx_def;\ntypedef struct rtx_def *rtx;\nstruct rtvec_def;\ntypedef struct rtvec_def *rtvec;\nunion tree_node;\ntypedef union tree_node *tree;\n\n/* Provide forward struct declaration so that we don't have to include\n   all of cpplib.h whenever a random prototype includes a pointer.\n   Note that the cpp_reader typedef remains part of cpplib.h.  */\n\nstruct cpp_reader;\n\n#else\n\nstruct _dont_use_rtx_here_;\nstruct _dont_use_rtvec_here_;\nunion _dont_use_tree_here_;\n#define rtx struct _dont_use_rtx_here_ *\n#define rtvec struct _dont_use_rtvec_here *\n#define tree union _dont_use_tree_here_ *\n\n#endif\n\n#endif /* coretypes.h */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COVERAGE": {"ttr": 1555, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* coverage.h - Defines data exported from coverage.c\n   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_COVERAGE_H\n#define GCC_COVERAGE_H\n\n#include \"gcov-io.h\"\n\nextern void coverage_init (const char *);\nextern void coverage_finish (void);\nextern void coverage_read_counts_file (void);\n\n/* Complete the coverage information for the current function. Once\n   per function.  */\nextern void coverage_end_function (void);\n\n/* Start outputting coverage information for the current\n   function. Repeatable per function.  */\nextern int coverage_begin_output (void);\n\n/* Allocate some counters. Repeatable per function.  */\nextern int coverage_counter_alloc (unsigned /*counter*/, unsigned/*num*/);\n/* Use a counter from the most recent allocation.  */\nextern rtx coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n\n/* Get all the counters for the current function.  */\nextern gcov_type *get_coverage_counts (unsigned /*counter*/,\n\t\t\t\t       unsigned /*expected*/,\n\t\t\t\t       const struct gcov_ctr_summary **);\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CP@DEMAN": {"ttr": 1557, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Internal demangler interface for g++ V3 ABI.\n   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n   Written by Ian Lance Taylor <ian@wasabisystems.com>.\n\n   This file is part of the libiberty library, which is part of GCC.\n\n   This file is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   In addition to the permissions in the GNU General Public License, the\n   Free Software Foundation gives you unlimited permission to link the\n   compiled version of this file into combinations with other programs,\n   and to distribute those combinations without any restriction coming\n   from the use of this file.  (The General Public License restrictions\n   do apply in other respects; for example, they cover modification of\n   the file, and distribution when not linked into a combined\n   executable.)\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n*/\n\n/* This file provides some definitions shared by cp-demangle.c and\n   cp-demint.c.  It should not be included by any other files.  */\n\n/* Information we keep for operators.  */\n\nstruct demangle_operator_info\n{\n  /* Mangled name.  */\n  const char *code;\n  /* Real name.  */\n  const char *name;\n  /* Length of real name.  */\n  int len;\n  /* Number of arguments.  */\n  int args;\n};\n\n/* How to print the value of a builtin type.  */\n\nenum d_builtin_type_print\n{\n  /* Print as (type)val.  */\n  D_PRINT_DEFAULT,\n  /* Print as integer.  */\n  D_PRINT_INT,\n  /* Print as unsigned integer, with trailing \"u\".  */\n  D_PRINT_UNSIGNED,\n  /* Print as long, with trailing \"l\".  */\n  D_PRINT_LONG,\n  /* Print as unsigned long, with trailing \"ul\".  */\n  D_PRINT_UNSIGNED_LONG,\n  /* Print as long long, with trailing \"ll\".  */\n  D_PRINT_LONG_LONG,\n  /* Print as unsigned long long, with trailing \"ull\".  */\n  D_PRINT_UNSIGNED_LONG_LONG,\n  /* Print as bool.  */\n  D_PRINT_BOOL,\n  /* Print as float--put value in square brackets.  */\n  D_PRINT_FLOAT,\n  /* Print in usual way, but here to detect void.  */\n  D_PRINT_VOID\n};\n\n/* Information we keep for a builtin type.  */\n\nstruct demangle_builtin_type_info\n{\n  /* Type name.  */\n  const char *name;\n  /* Length of type name.  */\n  int len;\n  /* Type name when using Java.  */\n  const char *java_name;\n  /* Length of java name.  */\n  int java_len;\n  /* How to print a value of this type.  */\n  enum d_builtin_type_print print;\n};\n\n/* The information structure we pass around.  */\n\nstruct d_info\n{\n  /* The string we are demangling.  */\n  const char *s;\n  /* The end of the string we are demangling.  */\n  const char *send;\n  /* The options passed to the demangler.  */\n  int options;\n  /* The next character in the string to consider.  */\n  const char *n;\n  /* The array of components.  */\n  struct demangle_component *comps;\n  /* The index of the next available component.  */\n  int next_comp;\n  /* The number of available component structures.  */\n  int num_comps;\n  /* The array of substitutions.  */\n  struct demangle_component **subs;\n  /* The index of the next substitution.  */\n  int next_sub;\n  /* The number of available entries in the subs array.  */\n  int num_subs;\n  /* The number of substitutions which we actually made from the subs\n     array, plus the number of template parameter references we\n     saw.  */\n  int did_subs;\n  /* The last name we saw, for constructors and destructors.  */\n  struct demangle_component *last_name;\n  /* A running total of the length of large expansions from the\n     mangled name to the demangled name, such as standard\n     substitutions and builtin types.  */\n  int expansion;\n};\n\n#define d_peek_char(di) (*((di)->n))\n#define d_peek_next_char(di) ((di)->n\u00dd1\u00a8)\n#define d_advance(di, i) ((di)->n += (i))\n#define d_next_char(di) (*((di)->n++))\n#define d_str(di) ((di)->n)\n\n/* Functions and arrays in cp-demangle.c which are referenced by\n   functions in cp-demint.c.  */\n\nextern const struct demangle_operator_info cplus_demangle_operators\u00dd\u00a8;\n\n#define D_BUILTIN_TYPE_COUNT (26)\n\nextern const struct demangle_builtin_type_info\ncplus_demangle_builtin_types\u00ddD_BUILTIN_TYPE_COUNT\u00a8;\n\nextern struct demangle_component *\ncplus_demangle_mangled_name PARAMS ((struct d_info *, int));\n\nextern struct demangle_component *\ncplus_demangle_type PARAMS ((struct d_info *));\n\nextern void\ncplus_demangle_init_info PARAMS ((const char *, int, size_t, struct d_info *));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPDEFAU": {"ttr": 1559, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* CPP Library.\n   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2003 Free Software Foundation, Inc.\n   Contributed by Per Bothner, 1994-95.\n   Based on CCCP program by Paul Rubin, June 1986\n   Adapted to ANSI C, Richard Stallman, Jan 1987\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_CPPDEFAULT_H\n#define GCC_CPPDEFAULT_H\n\n/* This is the default list of directories to search for include files.\n   It may be overridden by the various -I and -ixxx options.\n\n   #include \"file\" looks in the same directory as the current file,\n   then this list.\n   #include <file> just looks in this list.\n\n   All these directories are treated as `system' include directories\n   (they are not subject to pedantic warnings in some cases).  */\n\nstruct default_include\n{\n  const char *const fname;\t/* The name of the directory.  */\n  const char *const component;\t/* The component containing the directory\n\t\t\t\t   (see update_path in prefix.c) */\n  const char cplusplus;\t\t/* Only look here if we're compiling C++.  */\n  const char cxx_aware;\t\t/* Includes in this directory don't need to\n\t\t\t\t   be wrapped in extern \"C\" when compiling\n\t\t\t\t   C++.  */\n  const char add_sysroot;\t/* FNAME should be prefixed by\n\t\t\t\t   cpp_SYSROOT.  */\n};\n\nextern const struct default_include cpp_include_defaults\u00dd\u00a8;\nextern const char cpp_GCC_INCLUDE_DIR\u00dd\u00a8;\nextern const size_t cpp_GCC_INCLUDE_DIR_len;\n\nextern const char *cpp_SYSROOT;\n\n#endif /* ! GCC_CPPDEFAULT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPHASH": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Part of CPP library.\n   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* This header defines all the internal data structures and functions\n   that need to be visible across files.  It's called cpphash.h for\n   historical reasons.  */\n\n#ifndef GCC_CPPHASH_H\n#define GCC_CPPHASH_H\n\n#include \"hashtable.h\"\n\n#if defined HAVE_ICONV_H && defined HAVE_ICONV\n#include <iconv.h>\n#else\n#define HAVE_ICONV 0\ntypedef int iconv_t;  /* dummy */\n#endif\n\nstruct directive;\t\t/* Deliberately incomplete.  */\nstruct pending_option;\nstruct op;\nstruct _cpp_strbuf;\n\ntypedef bool (*convert_f) (iconv_t, const unsigned char *, size_t,\n\t\t\t   struct _cpp_strbuf *);\nstruct cset_converter\n{\n  convert_f func;\n  iconv_t cd;\n};\n\n#ifndef HAVE_UCHAR\ntypedef unsigned char uchar;\n#endif\n#define U (const uchar *)  /* Intended use: U\"string\" */\n\n#define BITS_PER_CPPCHAR_T (CHAR_BIT * sizeof (cppchar_t))\n\n/* Test if a sign is valid within a preprocessing number.  */\n#define VALID_SIGN(c, prevc) \\\n  (((c) == '+' || (c) == '-') && \\\n   ((prevc) == 'e' || (prevc) == 'E' \\\n    || (((prevc) == 'p' || (prevc) == 'P') \\\n        && CPP_OPTION (pfile, extended_numbers))))\n\n#define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n#define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n#define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base)\n#define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n\n/* Maximum nesting of cpp_buffers.  We use a static limit, partly for\n   efficiency, and partly to limit runaway recursion.  */\n#define CPP_STACK_MAX 200\n\n/* Host alignment handling.  */\nstruct dummy\n{\n  char c;\n  union\n  {\n    double d;\n    int *p;\n  } u;\n};\n\n#define DEFAULT_ALIGNMENT offsetof (struct dummy, u)\n#define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n#define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)\n\n/* Each macro definition is recorded in a cpp_macro structure.\n   Variadic macros cannot occur with traditional cpp.  */\nstruct cpp_macro\n{\n  /* Parameters, if any.  */\n  cpp_hashnode **params;\n\n  /* Replacement tokens (ISO) or replacement text (traditional).  See\n     comment at top of cpptrad.c for how traditional function-like\n     macros are encoded.  */\n  union\n  {\n    cpp_token *tokens;\n    const uchar *text;\n  } exp;\n\n  /* Definition line number.  */\n  fileline line;\n\n  /* Number of tokens in expansion, or bytes for traditional macros.  */\n  unsigned int count;\n\n  /* Number of parameters.  */\n  unsigned short paramc;\n\n  /* If a function-like macro.  */\n  unsigned int fun_like : 1;\n\n  /* If a variadic macro.  */\n  unsigned int variadic : 1;\n\n  /* If macro defined in system header.  */\n  unsigned int syshdr   : 1;\n\n  /* Nonzero if it has been expanded or had its existence tested.  */\n  unsigned int used     : 1;\n};\n\n#define _cpp_mark_macro_used(NODE) do {\t\t\t\t\t\\\n  if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN))\t\\\n    (NODE)->value.macro->used = 1; } while (0)\n\n/* A generic memory buffer, and operations on it.  */\ntypedef struct _cpp_buff _cpp_buff;\nstruct _cpp_buff\n{\n  struct _cpp_buff *next;\n  unsigned char *base, *cur, *limit;\n};\n\nextern _cpp_buff *_cpp_get_buff (cpp_reader *, size_t);\nextern void _cpp_release_buff (cpp_reader *, _cpp_buff *);\nextern void _cpp_extend_buff (cpp_reader *, _cpp_buff **, size_t);\nextern _cpp_buff *_cpp_append_extend_buff (cpp_reader *, _cpp_buff *, size_t);\nextern void _cpp_free_buff (_cpp_buff *);\nextern unsigned char *_cpp_aligned_alloc (cpp_reader *, size_t);\nextern unsigned char *_cpp_unaligned_alloc (cpp_reader *, size_t);\n\n#define BUFF_ROOM(BUFF) (size_t) ((BUFF)->limit - (BUFF)->cur)\n#define BUFF_FRONT(BUFF) ((BUFF)->cur)\n#define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n\n/* #include types.  */\nenum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE};\n\nunion utoken\n{\n  const cpp_token *token;\n  const cpp_token **ptoken;\n};\n\n/* A \"run\" of tokens; part of a chain of runs.  */\ntypedef struct tokenrun tokenrun;\nstruct tokenrun\n{\n  tokenrun *next, *prev;\n  cpp_token *base, *limit;\n};\n\n/* Accessor macros for struct cpp_context.  */\n#define FIRST(c) ((c)->u.iso.first)\n#define LAST(c) ((c)->u.iso.last)\n#define CUR(c) ((c)->u.trad.cur)\n#define RLIMIT(c) ((c)->u.trad.rlimit)\n\ntypedef struct cpp_context cpp_context;\nstruct cpp_context\n{\n  /* Doubly-linked list.  */\n  cpp_context *next, *prev;\n\n  union\n  {\n    /* For ISO macro expansion.  Contexts other than the base context\n       are contiguous tokens.  e.g. macro expansions, expanded\n       argument tokens.  */\n    struct\n    {\n      union utoken first;\n      union utoken last;\n    } iso;\n\n    /* For traditional macro expansion.  */\n    struct\n    {\n      const uchar *cur;\n      const uchar *rlimit;\n    } trad;\n  } u;\n\n  /* If non-NULL, a buffer used for storage related to this context.\n     When the context is popped, the buffer is released.  */\n  _cpp_buff *buff;\n\n  /* For a macro context, the macro node, otherwise NULL.  */\n  cpp_hashnode *macro;\n\n  /* True if utoken element is token, else ptoken.  */\n  bool direct_p;\n};\n\nstruct lexer_state\n{\n  /* Nonzero if first token on line is CPP_HASH.  */\n  unsigned char in_directive;\n\n  /* Nonzero if in a directive that will handle padding tokens itself.\n     #include needs this to avoid problems with computed include and\n     spacing between tokens.  */\n  unsigned char directive_wants_padding;\n\n  /* True if we are skipping a failed conditional group.  */\n  unsigned char skipping;\n\n  /* Nonzero if in a directive that takes angle-bracketed headers.  */\n  unsigned char angled_headers;\n\n  /* Nonzero if in a #if or #elif directive.  */\n  unsigned char in_expression;\n\n  /* Nonzero to save comments.  Turned off if discard_comments, and in\n     all directives apart from #define.  */\n  unsigned char save_comments;\n\n  /* Nonzero if lexing __VA_ARGS__ is valid.  */\n  unsigned char va_args_ok;\n\n  /* Nonzero if lexing poisoned identifiers is valid.  */\n  unsigned char poisoned_ok;\n\n  /* Nonzero to prevent macro expansion.  */\n  unsigned char prevent_expansion;\n\n  /* Nonzero when parsing arguments to a function-like macro.  */\n  unsigned char parsing_args;\n\n  /* Nonzero to skip evaluating part of an expression.  */\n  unsigned int skip_eval;\n};\n\n/* Special nodes - identifiers with predefined significance.  */\nstruct spec_nodes\n{\n  cpp_hashnode *n_defined;\t\t/* defined operator */\n  cpp_hashnode *n_true;\t\t\t/* C++ keyword true */\n  cpp_hashnode *n_false;\t\t/* C++ keyword false */\n  cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n};\n\ntypedef struct _cpp_line_note _cpp_line_note;\nstruct _cpp_line_note\n{\n  /* Location in the clean line the note refers to.  */\n  const uchar *pos;\n\n  /* Type of note.  The 9 'from' trigraph characters represent those\n     trigraphs, '\\\\' an escaped newline, ' ' an escaped newline with\n     intervening space, and anything else is invalid.  */\n  unsigned int type;\n};\n\n/* Represents the contents of a file cpplib has read in.  */\nstruct cpp_buffer\n{\n  const uchar *cur;\t\t/* Current location.  */\n  const uchar *line_base;\t/* Start of current physical line.  */\n  const uchar *next_line;\t/* Start of to-be-cleaned logical line.  */\n\n  const uchar *buf;\t\t/* Entire character buffer.  */\n  const uchar *rlimit;\t\t/* Writable byte at end of file.  */\n\n  _cpp_line_note *notes;\t/* Array of notes.  */\n  unsigned int cur_note;\t/* Next note to process.  */\n  unsigned int notes_used;\t/* Number of notes.  */\n  unsigned int notes_cap;\t/* Size of allocated array.  */\n\n  struct cpp_buffer *prev;\n\n  /* Pointer into the file table; non-NULL if this is a file buffer.\n     Used for include_next and to record control macros.  */\n  struct _cpp_file *file;\n\n  /* Value of if_stack at start of this file.\n     Used to prohibit unmatched #endif (etc) in an include file.  */\n  struct if_stack *if_stack;\n\n  /* True if we need to get the next clean line.  */\n  bool need_line;\n\n  /* True if we have already warned about C++ comments in this file.\n     The warning happens only for C89 extended mode with -pedantic on,\n     or for -Wtraditional, and only once per file (otherwise it would\n     be far too noisy).  */\n  unsigned char warned_cplusplus_comments;\n\n  /* True if we don't process trigraphs and escaped newlines.  True\n     for preprocessed input, command line directives, and _Pragma\n     buffers.  */\n  unsigned char from_stage3;\n\n  /* At EOF, a buffer is automatically popped.  If RETURN_AT_EOF is\n     true, a CPP_EOF token is then returned.  Otherwise, the next\n     token from the enclosing buffer is returned.  */\n  unsigned int return_at_eof : 1;\n\n  /* The directory of the this buffer's file.  Its NAME member is not\n     allocated, so we don't need to worry about freeing it.  */\n  struct cpp_dir dir;\n\n  /* Used for buffer overlays by cpptrad.c.  */\n  const uchar *saved_cur, *saved_rlimit;\n};\n\n/* A cpp_reader encapsulates the \"state\" of a pre-processor run.\n   Applying cpp_get_token repeatedly yields a stream of pre-processor\n   tokens.  Usually, there is only one cpp_reader object active.  */\nstruct cpp_reader\n{\n  /* Top of buffer stack.  */\n  cpp_buffer *buffer;\n\n  /* Overlaid buffer (can be different after processing #include).  */\n  cpp_buffer *overlaid_buffer;\n\n  /* Lexer state.  */\n  struct lexer_state state;\n\n  /* Source line tracking.  */\n  struct line_maps line_maps;\n  const struct line_map *map;\n  fileline line;\n\n  /* The line of the '#' of the current directive.  */\n  fileline directive_line;\n\n  /* Memory buffers.  */\n  _cpp_buff *a_buff;\t\t/* Aligned permanent storage.  */\n  _cpp_buff *u_buff;\t\t/* Unaligned permanent storage.  */\n  _cpp_buff *free_buffs;\t/* Free buffer chain.  */\n\n  /* Context stack.  */\n  struct cpp_context base_context;\n  struct cpp_context *context;\n\n  /* If in_directive, the directive if known.  */\n  const struct directive *directive;\n\n  /* Search paths for include files.  */\n  struct cpp_dir *quote_include;\t/* \"\" */\n  struct cpp_dir *bracket_include;\t/* <> */\n  struct cpp_dir no_search_path;\t/* No path.  */\n\n  /* Chain of all hashed _cpp_file instances.  */\n  struct _cpp_file *all_files;\n\n  struct _cpp_file *main_file;\n\n  /* File and directory hash table.  */\n  struct htab *file_hash;\n  struct htab *dir_hash;\n  struct file_hash_entry *file_hash_entries;\n  unsigned int file_hash_entries_allocated, file_hash_entries_used;\n\n  /* Nonzero means don't look for #include \"foo\" the source-file\n     directory.  */\n  bool quote_ignores_source_dir;\n\n  /* Nonzero if any file has contained #pragma once or #import has\n     been used.  */\n  bool seen_once_only;\n\n  /* Multiple include optimization.  */\n  const cpp_hashnode *mi_cmacro;\n  const cpp_hashnode *mi_ind_cmacro;\n  bool mi_valid;\n\n  /* Lexing.  */\n  cpp_token *cur_token;\n  tokenrun base_run, *cur_run;\n  unsigned int lookaheads;\n\n  /* Nonzero prevents the lexer from re-using the token runs.  */\n  unsigned int keep_tokens;\n\n  /* Error counter for exit code.  */\n  unsigned int errors;\n\n  /* Buffer to hold macro definition string.  */\n  unsigned char *macro_buffer;\n  unsigned int macro_buffer_len;\n\n  /* Descriptor for converting from the source character set to the\n     execution character set.  */\n  struct cset_converter narrow_cset_desc;\n\n  /* Descriptor for converting from the source character set to the\n     wide execution character set.  */\n  struct cset_converter wide_cset_desc;\n\n  /* Date and time text.  Calculated together if either is requested.  */\n  const uchar *date;\n  const uchar *time;\n\n  /* EOF token, and a token forcing paste avoidance.  */\n  cpp_token avoid_paste;\n  cpp_token eof;\n\n  /* Opaque handle to the dependencies of mkdeps.c.  */\n  struct deps *deps;\n\n  /* Obstack holding all macro hash nodes.  This never shrinks.\n     See cpphash.c */\n  struct obstack hash_ob;\n\n  /* Obstack holding buffer and conditional structures.  This is a\n     real stack.  See cpplib.c.  */\n  struct obstack buffer_ob;\n\n  /* Pragma table - dynamic, because a library user can add to the\n     list of recognized pragmas.  */\n  struct pragma_entry *pragmas;\n\n  /* Call backs to cpplib client.  */\n  struct cpp_callbacks cb;\n\n  /* Identifier hash table.  */\n  struct ht *hash_table;\n\n  /* Expression parser stack.  */\n  struct op *op_stack, *op_limit;\n\n  /* User visible options.  */\n  struct cpp_options opts;\n\n  /* Special nodes - identifiers with predefined significance to the\n     preprocessor.  */\n  struct spec_nodes spec_nodes;\n\n  /* Whether cpplib owns the hashtable.  */\n  bool our_hashtable;\n\n  /* Traditional preprocessing output buffer (a logical line).  */\n  struct\n  {\n    uchar *base;\n    uchar *limit;\n    uchar *cur;\n    fileline first_line;\n  } out;\n\n  /* Used to save the original line number during traditional\n     preprocessing.  */\n  unsigned int saved_line;\n\n  /* A saved list of the defined macros, for dependency checking\n     of precompiled headers.  */\n  struct cpp_savedstate *savedstate;\n};\n\n/* Character classes.  Based on the more primitive macros in safe-ctype.h.\n   If the definition of `numchar' looks odd to you, please look up the\n   definition of a pp-number in the C standard \u00ddsection 6.4.8 of C99\u00a8.\n\n   In the unlikely event that characters other than \\r and \\n enter\n   the set is_vspace, the macro handle_newline() in cpplex.c must be\n   updated.  */\n#define _dollar_ok(x)\t((x) == '$' && CPP_OPTION (pfile, dollars_in_ident))\n\n#define is_idchar(x)\t(ISIDNUM(x) || _dollar_ok(x))\n#define is_numchar(x)\tISIDNUM(x)\n#define is_idstart(x)\t(ISIDST(x) || _dollar_ok(x))\n#define is_numstart(x)\tISDIGIT(x)\n#define is_hspace(x)\tISBLANK(x)\n#define is_vspace(x)\tIS_VSPACE(x)\n#define is_nvspace(x)\tIS_NVSPACE(x)\n#define is_space(x)\tIS_SPACE_OR_NUL(x)\n\n/* This table is constant if it can be initialized at compile time,\n   which is the case if cpp was compiled with GCC >=2.7, or another\n   compiler that supports C99.  */\n#if HAVE_DESIGNATED_INITIALIZERS\nextern const unsigned char _cpp_trigraph_map\u00ddUCHAR_MAX + 1\u00a8;\n#else\nextern unsigned char _cpp_trigraph_map\u00ddUCHAR_MAX + 1\u00a8;\n#endif\n\n/* Macros.  */\n\n#define CPP_IN_SYSTEM_HEADER(PFILE) ((PFILE)->map && (PFILE)->map->sysp)\n#define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n#define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n\n/* In cpperror.c  */\nextern int _cpp_begin_message (cpp_reader *, int, fileline, unsigned int);\n\n/* In cppmacro.c */\nextern void _cpp_free_definition (cpp_hashnode *);\nextern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);\nextern void _cpp_pop_context (cpp_reader *);\nextern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *,\n\t\t\t\t    const uchar *, size_t);\nextern bool _cpp_save_parameter (cpp_reader *, cpp_macro *, cpp_hashnode *);\nextern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n\t\t\t       unsigned int);\nextern const uchar *_cpp_builtin_macro_text (cpp_reader *, cpp_hashnode *);\nint _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n/* In cpphash.c */\nextern void _cpp_init_hashtable (cpp_reader *, hash_table *);\nextern void _cpp_destroy_hashtable (cpp_reader *);\n\n/* In cppfiles.c */\ntypedef struct _cpp_file _cpp_file;\nextern _cpp_file *_cpp_find_file (cpp_reader *, const char *fname,\n\t\t\t\t  cpp_dir *start_dir, bool fake, int);\nextern bool _cpp_find_failed (_cpp_file *);\nextern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);\nextern void _cpp_fake_include (cpp_reader *, const char *);\nextern bool _cpp_stack_file (cpp_reader *, _cpp_file*, bool);\nextern bool _cpp_stack_include (cpp_reader *, const char *, int,\n\t\t\t\tenum include_type);\nextern int _cpp_compare_file_date (cpp_reader *, const char *, int);\nextern void _cpp_report_missing_guards (cpp_reader *);\nextern void _cpp_init_files (cpp_reader *);\nextern void _cpp_cleanup_files (cpp_reader *);\nextern void _cpp_pop_file_buffer (cpp_reader *, struct _cpp_file *);\n\n/* In cppexp.c */\nextern bool _cpp_parse_expr (cpp_reader *);\nextern struct op *_cpp_expand_op_stack (cpp_reader *);\n\n/* In cpplex.c */\nextern void _cpp_process_line_notes (cpp_reader *, int);\nextern void _cpp_clean_line (cpp_reader *);\nextern bool _cpp_get_fresh_line (cpp_reader *);\nextern bool _cpp_skip_block_comment (cpp_reader *);\nextern cpp_token *_cpp_temp_token (cpp_reader *);\nextern const cpp_token *_cpp_lex_token (cpp_reader *);\nextern cpp_token *_cpp_lex_direct (cpp_reader *);\nextern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);\nextern void _cpp_init_tokenrun (tokenrun *, unsigned int);\n\n/* In cppinit.c.  */\nextern void _cpp_maybe_push_include_file (cpp_reader *);\n\n/* In cpplib.c */\nextern int _cpp_test_assertion (cpp_reader *, unsigned int *);\nextern int _cpp_handle_directive (cpp_reader *, int);\nextern void _cpp_define_builtin (cpp_reader *, const char *);\nextern char ** _cpp_save_pragma_names (cpp_reader *);\nextern void _cpp_restore_pragma_names (cpp_reader *, char **);\nextern void _cpp_do__Pragma (cpp_reader *);\nextern void _cpp_init_directives (cpp_reader *);\nextern void _cpp_init_internal_pragmas (cpp_reader *);\nextern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n\t\t\t\t unsigned int, unsigned int);\nextern void _cpp_pop_buffer (cpp_reader *);\n\n/* In cpptrad.c.  */\nextern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *);\nextern bool _cpp_read_logical_line_trad (cpp_reader *);\nextern void _cpp_overlay_buffer (cpp_reader *pfile, const uchar *, size_t);\nextern void _cpp_remove_overlay (cpp_reader *);\nextern bool _cpp_create_trad_definition (cpp_reader *, cpp_macro *);\nextern bool _cpp_expansions_different_trad (const cpp_macro *,\n\t\t\t\t\t    const cpp_macro *);\nextern uchar *_cpp_copy_replacement_text (const cpp_macro *, uchar *);\nextern size_t _cpp_replacement_text_len (const cpp_macro *);\n\n/* In cppcharset.c.  */\nextern cppchar_t _cpp_valid_ucn (cpp_reader *, const uchar **,\n\t\t\t\t const uchar *, int);\nextern void _cpp_destroy_iconv (cpp_reader *);\nextern bool _cpp_interpret_string_notranslate (cpp_reader *,\n\t\t\t\t\t       const cpp_string *,\n\t\t\t\t\t       cpp_string *);\nextern uchar *_cpp_convert_input (cpp_reader *, const char *, uchar *,\n                                  size_t, size_t, off_t *);\nextern const char *_cpp_default_encoding (void);\n\n\n/* Utility routines and macros.  */\n#define DSC(str) (const uchar *)str, sizeof str - 1\n#define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n#define xcnew(T)\t(T *) xcalloc (1, sizeof(T))\n#define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n#define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n#define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n\n/* These are inline functions instead of macros so we can get type\n   checking.  */\nstatic inline int ustrcmp (const uchar *, const uchar *);\nstatic inline int ustrncmp (const uchar *, const uchar *, size_t);\nstatic inline size_t ustrlen (const uchar *);\nstatic inline uchar *uxstrdup (const uchar *);\nstatic inline uchar *ustrchr (const uchar *, int);\nstatic inline int ufputs (const uchar *, FILE *);\n\nstatic inline int\nustrcmp (const uchar *s1, const uchar *s2)\n{\n  return strcmp ((const char *)s1, (const char *)s2);\n}\n\nstatic inline int\nustrncmp (const uchar *s1, const uchar *s2, size_t n)\n{\n  return strncmp ((const char *)s1, (const char *)s2, n);\n}\n\nstatic inline size_t\nustrlen (const uchar *s1)\n{\n  return strlen ((const char *)s1);\n}\n\nstatic inline uchar *\nuxstrdup (const uchar *s1)\n{\n  return (uchar *) xstrdup ((const char *)s1);\n}\n\nstatic inline uchar *\nustrchr (const uchar *s1, int c)\n{\n  return (uchar *) strchr ((const char *)s1, c);\n}\n\nstatic inline int\nufputs (const uchar *s, FILE *f)\n{\n  return fputs ((const char *)s, f);\n}\n\n#endif /* ! GCC_CPPHASH_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPLIB": {"ttr": 1798, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for CPP library.\n   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n   Written by Per Bothner, 1994-95.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n#ifndef GCC_CPPLIB_H\n#define GCC_CPPLIB_H\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include \"hashtable.h\"\n#include \"line-map.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct cpp_reader cpp_reader;\ntypedef struct cpp_buffer cpp_buffer;\ntypedef struct cpp_options cpp_options;\ntypedef struct cpp_token cpp_token;\ntypedef struct cpp_string cpp_string;\ntypedef struct cpp_hashnode cpp_hashnode;\ntypedef struct cpp_macro cpp_macro;\ntypedef struct cpp_callbacks cpp_callbacks;\ntypedef struct cpp_dir cpp_dir;\n\nstruct answer;\n\n/* The first three groups, apart from '=', can appear in preprocessor\n   expressions (+= and -= are used to indicate unary + and - resp.).\n   This allows a lookup table to be implemented in _cpp_parse_expr.\n\n   The first group, to CPP_LAST_EQ, can be immediately followed by an\n   '='.  The lexer needs operators ending in '=', like \">>=\", to be in\n   the same order as their counterparts without the '=', like \">>\".  */\n\n/* Positions in the table.  */\n#define CPP_LAST_EQ CPP_MAX\n#define CPP_FIRST_DIGRAPH CPP_HASH\n#define CPP_LAST_PUNCTUATOR CPP_DOT_STAR\n#define CPP_LAST_CPP_OP CPP_LESS_EQ\n\n#define TTYPE_TABLE\t\t\t\t\\\n  OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n  OP(CPP_NOT,\t\t\"!\")\t\t\t\\\n  OP(CPP_GREATER,\t\">\")\t/* compare */\t\\\n  OP(CPP_LESS,\t\t\"<\")\t\t\t\\\n  OP(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n  OP(CPP_MINUS,\t\t\"-\")\t\t\t\\\n  OP(CPP_MULT,\t\t\"*\")\t\t\t\\\n  OP(CPP_DIV,\t\t\"/\")\t\t\t\\\n  OP(CPP_MOD,\t\t\"%\")\t\t\t\\\n  OP(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n  OP(CPP_OR,\t\t\"|\")\t\t\t\\\n  OP(CPP_XOR,\t\t\"\u00ac\")\t\t\t\\\n  OP(CPP_RSHIFT,\t\">>\")\t\t\t\\\n  OP(CPP_LSHIFT,\t\"<<\")\t\t\t\\\n  OP(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n  OP(CPP_MAX,\t\t\">?\")\t\t\t\\\n\\\n  OP(CPP_COMPL,\t\t\"~\")\t\t\t\\\n  OP(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n  OP(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n  OP(CPP_QUERY,\t\t\"?\")\t\t\t\\\n  OP(CPP_COLON,\t\t\":\")\t\t\t\\\n  OP(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n  OP(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n  OP(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n  TK(CPP_EOF,\t\tSPELL_NONE)\t\t\\\n  OP(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n  OP(CPP_NOT_EQ,\t\"!=\")\t\t\t\\\n  OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n  OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n\\\n  /* These two are unary + / - in preprocessor expressions.  */ \\\n  OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n  OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n\\\n  OP(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n  OP(CPP_DIV_EQ,\t\"/=\")\t\t\t\\\n  OP(CPP_MOD_EQ,\t\"%=\")\t\t\t\\\n  OP(CPP_AND_EQ,\t\"&=\")\t/* bit ops */\t\\\n  OP(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n  OP(CPP_XOR_EQ,\t\"\u00ac=\")\t\t\t\\\n  OP(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n  OP(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n  OP(CPP_MIN_EQ,\t\"<?=\")\t/* extension */\t\\\n  OP(CPP_MAX_EQ,\t\">?=\")\t\t\t\\\n  /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\\n  OP(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n  OP(CPP_PASTE,\t\t\"##\")\t\t\t\\\n  OP(CPP_OPEN_SQUARE,\t\"\u00dd\")\t\t\t\\\n  OP(CPP_CLOSE_SQUARE,\t\"\u00a8\")\t\t\t\\\n  OP(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n  OP(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n  /* The remainder of the punctuation.  Order is not significant.  */\t\\\n  OP(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n  OP(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n  OP(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n  OP(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n  OP(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n  OP(CPP_DOT,\t\t\".\")\t\t\t\\\n  OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n  OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n  OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n  OP(CPP_ATSIGN,\t\"@\")  /* used in Objective-C */ \\\n\\\n  TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n  TK(CPP_AT_NAME,       SPELL_IDENT)    /* @word - Objective-C */       \\\n  TK(CPP_NUMBER,\tSPELL_LITERAL)\t/* 34_be+ta  */\t\t\t\\\n\\\n  TK(CPP_CHAR,\t\tSPELL_LITERAL)\t/* 'char' */\t\t\t\\\n  TK(CPP_WCHAR,\t\tSPELL_LITERAL)\t/* L'char' */\t\t\t\\\n  TK(CPP_OTHER,\t\tSPELL_LITERAL)\t/* stray punctuation */\t\t\\\n\\\n  TK(CPP_STRING,\tSPELL_LITERAL)\t/* \"string\" */\t\t\t\\\n  TK(CPP_WSTRING,\tSPELL_LITERAL)\t/* L\"string\" */\t\t\t\\\n  TK(CPP_OBJC_STRING,   SPELL_LITERAL)  /* @\"string\" - Objective-C */\t\\\n  TK(CPP_HEADER_NAME,\tSPELL_LITERAL)\t/* <stdio.h> in #include */\t\\\n\\\n  TK(CPP_COMMENT,\tSPELL_LITERAL)\t/* Only if output comments.  */ \\\n                                        /* SPELL_LITERAL happens to DTRT.  */ \\\n  TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n  TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\n\n#define OP(e, s) e,\n#define TK(e, s) e,\nenum cpp_ttype\n{\n  TTYPE_TABLE\n  N_TTYPES\n};\n#undef OP\n#undef TK\n\n/* C language kind, used when calling cpp_reader_init.  */\nenum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_STDC89, CLK_STDC94, CLK_STDC99,\n\t     CLK_GNUCXX, CLK_CXX98, CLK_ASM};\n\n/* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */\nstruct cpp_string\n{\n  unsigned int len;\n  const unsigned char *text;\n};\n\n/* Flags for the cpp_token structure.  */\n#define PREV_WHITE\t(1 << 0) /* If whitespace before this token.  */\n#define DIGRAPH\t\t(1 << 1) /* If it was a digraph.  */\n#define STRINGIFY_ARG\t(1 << 2) /* If macro argument to be stringified.  */\n#define PASTE_LEFT\t(1 << 3) /* If on LHS of a ## operator.  */\n#define NAMED_OP\t(1 << 4) /* C++ named operators.  */\n#define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n#define BOL\t\t(1 << 6) /* Token at beginning of line.  */\n\n/* A preprocessing token.  This has been carefully packed and should\n   occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\nstruct cpp_token\n{\n  fileline line;\t\t/* Logical line of first char of token.  */\n  unsigned short col;\t\t/* Column of first char of token.  */\n  ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n  unsigned char flags;\t\t/* flags - see above */\n\n  union\n  {\n    cpp_hashnode *node;\t\t/* An identifier.  */\n    const cpp_token *source;\t/* Inherit padding from this token.  */\n    struct cpp_string str;\t/* A string, or number.  */\n    unsigned int arg_no;\t/* Argument no. for a CPP_MACRO_ARG.  */\n  } val;\n};\n\n/* A type wide enough to hold any multibyte source character.\n   cpplib's character constant interpreter requires an unsigned type.\n   Also, a typedef for the signed equivalent.\n   The width of this type is capped at 32 bits; there do exist targets\n   where wchar_t is 64 bits, but only in a non-default mode, and there\n   would be no meaningful interpretation for a wchar_t value greater\n   than 2\u00ac32 anyway -- the widest wide-character encoding around is\n   ISO 10646, which stops at 2\u00ac31.  */\n#if CHAR_BIT * SIZEOF_INT >= 32\n# define CPPCHAR_SIGNED_T int\n#elif CHAR_BIT * SIZEOF_LONG >= 32\n# define CPPCHAR_SIGNED_T long\n#else\n# error \"Cannot find a least-32-bit signed integer type\"\n#endif\ntypedef unsigned CPPCHAR_SIGNED_T cppchar_t;\ntypedef CPPCHAR_SIGNED_T cppchar_signed_t;\n\n/* This structure is nested inside struct cpp_reader, and\n   carries all the options visible to the command line.  */\nstruct cpp_options\n{\n  /* Characters between tab stops.  */\n  unsigned int tabstop;\n\n  /* The language we're preprocessing.  */\n  enum c_lang lang;\n\n  /* Nonzero means use extra default include directories for C++.  */\n  unsigned char cplusplus;\n\n  /* Nonzero means handle cplusplus style comments.  */\n  unsigned char cplusplus_comments;\n\n  /* Nonzero means define __OBJC__, treat @ as a special token, and\n     use the OBJC\u00ddPLUS\u00a8_INCLUDE_PATH environment variable.  */\n  unsigned char objc;\n\n  /* Nonzero means don't copy comments into the output file.  */\n  unsigned char discard_comments;\n\n  /* Nonzero means don't copy comments into the output file during\n     macro expansion.  */\n  unsigned char discard_comments_in_macro_exp;\n\n  /* Nonzero means process the ISO trigraph sequences.  */\n  unsigned char trigraphs;\n\n  /* Nonzero means process the ISO digraph sequences.  */\n  unsigned char digraphs;\n\n  /* Nonzero means to allow hexadecimal floats and LL suffixes.  */\n  unsigned char extended_numbers;\n\n  /* Nonzero means print names of header files (-H).  */\n  unsigned char print_include_names;\n\n  /* Nonzero means cpp_pedwarn causes a hard error.  */\n  unsigned char pedantic_errors;\n\n  /* Nonzero means don't print warning messages.  */\n  unsigned char inhibit_warnings;\n\n  /* Nonzero means complain about deprecated features.  */\n  unsigned char warn_deprecated;\n\n  /* Nonzero means don't suppress warnings from system headers.  */\n  unsigned char warn_system_headers;\n\n  /* Nonzero means don't print error messages.  Has no option to\n     select it, but can be set by a user of cpplib (e.g. fix-header).  */\n  unsigned char inhibit_errors;\n\n  /* Nonzero means warn if slash-star appears in a comment.  */\n  unsigned char warn_comments;\n\n  /* Nonzero means warn if there are any trigraphs.  */\n  unsigned char warn_trigraphs;\n\n  /* Nonzero means warn about multicharacter charconsts.  */\n  unsigned char warn_multichar;\n\n  /* Nonzero means warn about various incompatibilities with\n     traditional C.  */\n  unsigned char warn_traditional;\n\n  /* Nonzero means warn about long long numeric constants.  */\n  unsigned char warn_long_long;\n\n  /* Nonzero means warn about text after an #endif (or #else).  */\n  unsigned char warn_endif_labels;\n\n  /* Nonzero means warn about implicit sign changes owing to integer\n     promotions.  */\n  unsigned char warn_num_sign_change;\n\n  /* Nonzero means turn warnings into errors.  */\n  unsigned char warnings_are_errors;\n\n  /* Nonzero means we should look for header.gcc files that remap file\n     names.  */\n  unsigned char remap;\n\n  /* Zero means dollar signs are punctuation.  */\n  unsigned char dollars_in_ident;\n\n  /* True if we should warn about dollars in identifiers or numbers\n     for this translation unit.  */\n  unsigned char warn_dollars;\n\n  /* Nonzero means warn if undefined identifiers are evaluated in an #if.  */\n  unsigned char warn_undef;\n\n  /* Nonzero means warn of unused macros from the main file.  */\n  unsigned char warn_unused_macros;\n\n  /* Nonzero for the 1999 C Standard, including corrigenda and amendments.  */\n  unsigned char c99;\n\n  /* Nonzero if we are conforming to a specific C or C++ standard.  */\n  unsigned char std;\n\n  /* Nonzero means give all the error messages the ANSI standard requires.  */\n  unsigned char pedantic;\n\n  /* Nonzero means we're looking at already preprocessed code, so don't\n     bother trying to do macro expansion and whatnot.  */\n  unsigned char preprocessed;\n\n  /* Print column number in error messages.  */\n  unsigned char show_column;\n\n  /* Nonzero means handle C++ alternate operator names.  */\n  unsigned char operator_names;\n\n  /* True for traditional preprocessing.  */\n  unsigned char traditional;\n\n  /* Holds the name of the target (execution) character set.  */\n  const char *narrow_charset;\n\n  /* Holds the name of the target wide character set.  */\n  const char *wide_charset;\n\n  /* Holds the name of the input character set.  */\n  const char *input_charset;\n\n  /* True to warn about precompiled header files we couldn't use.  */\n  bool warn_invalid_pch;\n\n  /* True if dependencies should be restored from a precompiled header.  */\n  bool restore_pch_deps;\n\n  /* Dependency generation.  */\n  struct\n  {\n    /* Style of header dependencies to generate.  */\n    enum {DEPS_NONE = 0, DEPS_USER, DEPS_SYSTEM } style;\n\n    /* Assume missing files are generated files.  */\n    bool missing_files;\n\n    /* Generate phony targets for each dependency apart from the first\n       one.  */\n    bool phony_targets;\n\n    /* If true, no dependency is generated on the main file.  */\n    bool ignore_main_file;\n  } deps;\n\n  /* Target-specific features set by the front end or client.  */\n\n  /* Precision for target CPP arithmetic, target characters, target\n     ints and target wide characters, respectively.  */\n  size_t precision, char_precision, int_precision, wchar_precision;\n\n  /* True means chars (wide chars) are unsigned.  */\n  bool unsigned_char, unsigned_wchar;\n\n  /* True if the most significant byte in a word has the lowest\n     address in memory.  */\n  bool bytes_big_endian;\n\n  /* Nonzero means __STDC__ should have the value 0 in system headers.  */\n  unsigned char stdc_0_in_system_headers;\n};\n\n/* Call backs to cpplib client.  */\nstruct cpp_callbacks\n{\n  /* Called when a new line of preprocessed output is started.  */\n  void (*line_change) (cpp_reader *, const cpp_token *, int);\n\n  /* Called when switching to/from a new file.\n     The line_map is for the new file.  It is NULL if there is no new file.\n     (In C this happens when done with <built-in>+<command line> and also\n     when done with a main file.)  This can be used for resource cleanup.  */\n  void (*file_change) (cpp_reader *, const struct line_map *);\n\n  void (*dir_change) (cpp_reader *, const char *);\n  void (*include) (cpp_reader *, unsigned int, const unsigned char *,\n\t\t   const char *, int);\n  void (*define) (cpp_reader *, unsigned int, cpp_hashnode *);\n  void (*undef) (cpp_reader *, unsigned int, cpp_hashnode *);\n  void (*ident) (cpp_reader *, unsigned int, const cpp_string *);\n  void (*def_pragma) (cpp_reader *, unsigned int);\n  int (*valid_pch) (cpp_reader *, const char *, int);\n  void (*read_pch) (cpp_reader *, const char *, int, const char *);\n};\n\n/* Chain of directories to look for include files in.  */\nstruct cpp_dir\n{\n  /* NULL-terminated singly-linked list.  */\n  struct cpp_dir *next;\n\n  /* NAME of the directory, NUL-terminated.  */\n  char *name;\n  unsigned int len;\n\n  /* One if a system header, two if a system header that has extern\n     \"C\" guards for C++.  */\n  unsigned char sysp;\n\n  /* Mapping of file names for this directory for MS-DOS and related\n     platforms.  A NULL-terminated array of (from, to) pairs.  */\n  const char **name_map;\n\n  /* The C front end uses these to recognize duplicated\n     directories in the search path.  */\n  ino_t ino;\n  dev_t dev;\n};\n\n/* Name under which this program was invoked.  */\nextern const char *progname;\n\n/* The structure of a node in the hash table.  The hash table has\n   entries for all identifiers: either macros defined by #define\n   commands (type NT_MACRO), assertions created with #assert\n   (NT_ASSERTION), or neither of the above (NT_VOID).  Builtin macros\n   like __LINE__ are flagged NODE_BUILTIN.  Poisoned identifiers are\n   flagged NODE_POISONED.  NODE_OPERATOR (C++ only) indicates an\n   identifier that behaves like an operator such as \"xor\".\n   NODE_DIAGNOSTIC is for speed in lex_token: it indicates a\n   diagnostic may be required for this node.  Currently this only\n   applies to __VA_ARGS__ and poisoned identifiers.  */\n\n/* Hash node flags.  */\n#define NODE_OPERATOR\t(1 << 0)\t/* C++ named operator.  */\n#define NODE_POISONED\t(1 << 1)\t/* Poisoned identifier.  */\n#define NODE_BUILTIN\t(1 << 2)\t/* Builtin macro.  */\n#define NODE_DIAGNOSTIC (1 << 3)\t/* Possible diagnostic when lexed.  */\n#define NODE_WARN\t(1 << 4)\t/* Warn if redefined or undefined.  */\n#define NODE_DISABLED\t(1 << 5)\t/* A disabled macro.  */\n#define NODE_MACRO_ARG\t(1 << 6)\t/* Used during #define processing.  */\n\n/* Different flavors of hash node.  */\nenum node_type\n{\n  NT_VOID = 0,\t   /* No definition yet.  */\n  NT_MACRO,\t   /* A macro of some form.  */\n  NT_ASSERTION\t   /* Predicate for #assert.  */\n};\n\n/* Different flavors of builtin macro.  _Pragma is an operator, but we\n   handle it with the builtin code for efficiency reasons.  */\nenum builtin_type\n{\n  BT_SPECLINE = 0,\t\t/* `__LINE__' */\n  BT_DATE,\t\t\t/* `__DATE__' */\n  BT_FILE,\t\t\t/* `__FILE__' */\n  BT_BASE_FILE,\t\t\t/* `__BASE_FILE__' */\n  BT_INCLUDE_LEVEL,\t\t/* `__INCLUDE_LEVEL__' */\n  BT_TIME,\t\t\t/* `__TIME__' */\n  BT_STDC,\t\t\t/* `__STDC__' */\n  BT_PRAGMA\t\t\t/* `_Pragma' operator */\n};\n\n#define CPP_HASHNODE(HNODE)\t((cpp_hashnode *) (HNODE))\n#define HT_NODE(NODE)\t\t((ht_identifier *) (NODE))\n#define NODE_LEN(NODE)\t\tHT_LEN (&(NODE)->ident)\n#define NODE_NAME(NODE)\t\tHT_STR (&(NODE)->ident)\n\n/* The common part of an identifier node shared amongst all 3 C front\n   ends.  Also used to store CPP identifiers, which are a superset of\n   identifiers in the grammatical sense.  */\nstruct cpp_hashnode GTY(())\n{\n  struct ht_identifier ident;\n  unsigned int is_directive : 1;\n  unsigned int directive_index : 7;\t/* If is_directive,\n\t\t\t\t\t   then index into directive table.\n\t\t\t\t\t   Otherwise, a NODE_OPERATOR.  */\n  unsigned char rid_code;\t\t/* Rid code - for front ends.  */\n  ENUM_BITFIELD(node_type) type : 8;\t/* CPP node type.  */\n  unsigned char flags;\t\t\t/* CPP flags.  */\n\n  union _cpp_hashnode_value\n  {\n    /* If a macro.  */\n    cpp_macro * GTY((skip (\"\"))) macro;\n    /* Answers to an assertion.  */\n    struct answer * GTY ((skip (\"\"))) answers;\n    /* Code for a builtin macro.  */\n    enum builtin_type GTY ((tag (\"1\"))) builtin;\n    /* Macro argument index.  */\n    unsigned short GTY ((tag (\"0\"))) arg_index;\n  } GTY ((desc (\"0\"))) value;\n};\n\n/* Call this first to get a handle to pass to other functions.\n\n   If you want cpplib to manage its own hashtable, pass in a NULL\n   pointer.  Otherwise you should pass in an initialized hash table\n   that cpplib will share; this technique is used by the C front\n   ends.  */\nextern cpp_reader *cpp_create_reader (enum c_lang, struct ht *);\n\n/* Call this to change the selected language standard (e.g. because of\n   command line options).  */\nextern void cpp_set_lang (cpp_reader *, enum c_lang);\n\n/* Add a dependency TARGET.  Quote it for \"make\" if QUOTE.  Can be\n   called any number of times before cpp_read_main_file().  If no\n   targets have been added before cpp_read_main_file(), then the\n   default target is used.  */\nextern void cpp_add_dependency_target (cpp_reader *, const char *, int);\n\n/* Set the include paths.  */\nextern void cpp_set_include_chains (cpp_reader *, cpp_dir *, cpp_dir *, int);\n\n/* Call these to get pointers to the options and callback structures\n   for a given reader.  These pointers are good until you call\n   cpp_finish on that reader.  You can either edit the callbacks\n   through the pointer returned from cpp_get_callbacks, or set them\n   with cpp_set_callbacks.  */\nextern cpp_options *cpp_get_options (cpp_reader *);\nextern struct line_maps *cpp_get_line_maps (cpp_reader *);\nextern cpp_callbacks *cpp_get_callbacks (cpp_reader *);\nextern void cpp_set_callbacks (cpp_reader *, cpp_callbacks *);\n\n/* This function reads the file, but does not start preprocessing.  It\n   returns the name of the original file; this is the same as the\n   input file, except for preprocessed input.  This will generate at\n   least one file change callback, and possibly a line change callback\n   too.  If there was an error opening the file, it returns NULL. */\nextern const char *cpp_read_main_file (cpp_reader *, const char *);\n\n/* Set up built-ins like __FILE__.  */\nextern void cpp_init_builtins (cpp_reader *, int);\n\n/* This is called after options have been parsed, and partially\n   processed.  */\nextern void cpp_post_options (cpp_reader *);\n\n/* Set up translation to the target character set.  */\nextern void cpp_init_iconv (cpp_reader *);\n\n/* Call this to finish preprocessing.  If you requested dependency\n   generation, pass an open stream to write the information to,\n   otherwise NULL.  It is your responsibility to close the stream.\n\n   Returns cpp_errors (pfile).  */\nextern int cpp_finish (cpp_reader *, FILE *deps_stream);\n\n/* Call this to release the handle at the end of preprocessing.  Any\n   use of the handle after this function returns is invalid.  Returns\n   cpp_errors (pfile).  */\nextern void cpp_destroy (cpp_reader *);\n\n/* Error count.  */\nextern unsigned int cpp_errors (cpp_reader *);\n\nextern unsigned int cpp_token_len (const cpp_token *);\nextern unsigned char *cpp_token_as_text (cpp_reader *, const cpp_token *);\nextern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,\n\t\t\t\t       unsigned char *);\nextern void cpp_register_pragma (cpp_reader *, const char *, const char *,\n\t\t\t\t void (*) (cpp_reader *));\nextern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n\t\t\t    const cpp_token *);\nextern const cpp_token *cpp_get_token (cpp_reader *);\nextern const unsigned char *cpp_macro_definition (cpp_reader *,\n\t\t\t\t\t\t  const cpp_hashnode *);\nextern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n\n/* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\nextern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n\t\t\t\t\t  unsigned int *, int *);\n/* Evaluate a vector of CPP_STRING or CPP_WSTRING tokens.  */\nextern bool cpp_interpret_string (cpp_reader *,\n\t\t\t\t  const cpp_string *, size_t,\n\t\t\t\t  cpp_string *, bool);\n\n/* Used to register macros and assertions, perhaps from the command line.\n   The text is the same as the command line argument.  */\nextern void cpp_define (cpp_reader *, const char *);\nextern void cpp_assert (cpp_reader *, const char *);\nextern void cpp_undef (cpp_reader *, const char *);\nextern void cpp_unassert (cpp_reader *, const char *);\n\n/* Undefine all macros and assertions.  */\nextern void cpp_undef_all (cpp_reader *);\n\nextern cpp_buffer *cpp_push_buffer (cpp_reader *, const unsigned char *,\n\t\t\t\t    size_t, int);\nextern int cpp_defined (cpp_reader *, const unsigned char *, int);\n\n/* A preprocessing number.  Code assumes that any unused high bits of\n   the double integer are set to zero.  */\ntypedef unsigned HOST_WIDE_INT cpp_num_part;\ntypedef struct cpp_num cpp_num;\nstruct cpp_num\n{\n  cpp_num_part high;\n  cpp_num_part low;\n  bool unsignedp;  /* True if value should be treated as unsigned.  */\n  bool overflow;   /* True if the most recent calculation overflowed.  */\n};\n\n/* cpplib provides two interfaces for interpretation of preprocessing\n   numbers.\n\n   cpp_classify_number categorizes numeric constants according to\n   their field (integer, floating point, or invalid), radix (decimal,\n   octal, hexadecimal), and type suffixes.  */\n\n#define CPP_N_CATEGORY  0x000F\n#define CPP_N_INVALID\t0x0000\n#define CPP_N_INTEGER\t0x0001\n#define CPP_N_FLOATING\t0x0002\n\n#define CPP_N_WIDTH\t0x00F0\n#define CPP_N_SMALL\t0x0010\t/* int, float.  */\n#define CPP_N_MEDIUM\t0x0020\t/* long, double.  */\n#define CPP_N_LARGE\t0x0040\t/* long long, long double.  */\n\n#define CPP_N_RADIX\t0x0F00\n#define CPP_N_DECIMAL\t0x0100\n#define CPP_N_HEX\t0x0200\n#define CPP_N_OCTAL\t0x0400\n\n#define CPP_N_UNSIGNED\t0x1000\t/* Properties.  */\n#define CPP_N_IMAGINARY\t0x2000\n\n/* Classify a CPP_NUMBER token.  The return value is a combination of\n   the flags from the above sets.  */\nextern unsigned cpp_classify_number (cpp_reader *, const cpp_token *);\n\n/* Evaluate a token classified as category CPP_N_INTEGER.  */\nextern cpp_num cpp_interpret_integer (cpp_reader *, const cpp_token *,\n\t\t\t\t      unsigned int type);\n\n/* Sign extend a number, with PRECISION significant bits and all\n   others assumed clear, to fill out a cpp_num structure.  */\ncpp_num cpp_num_sign_extend (cpp_num, size_t);\n\n/* Diagnostic levels.  To get a diagnostic without associating a\n   position in the translation unit with it, use cpp_error_with_line\n   with a line number of zero.  */\n\n/* Warning, an error with -Werror.  */\n#define CPP_DL_WARNING\t\t0x00\n/* Same as CPP_DL_WARNING, except it is not suppressed in system headers.  */\n#define CPP_DL_WARNING_SYSHDR\t0x01\n/* Warning, an error with -pedantic-errors or -Werror.  */\n#define CPP_DL_PEDWARN\t\t0x02\n/* An error.  */\n#define CPP_DL_ERROR\t\t0x03\n/* An internal consistency check failed.  Prints \"internal error: \",\n   otherwise the same as CPP_DL_ERROR.  */\n#define CPP_DL_ICE\t\t0x04\n/* Extracts a diagnostic level from an int.  */\n#define CPP_DL_EXTRACT(l)\t(l & 0xf)\n/* Nonzero if a diagnostic level is one of the warnings.  */\n#define CPP_DL_WARNING_P(l)\t(CPP_DL_EXTRACT (l) >= CPP_DL_WARNING \\\n\t\t\t\t && CPP_DL_EXTRACT (l) <= CPP_DL_PEDWARN)\n\n/* N.B. The error-message-printer prototypes have not been nicely\n   formatted because exgettext needs to see 'msgid' on the same line\n   as the name of the function in order to work properly.  Only the\n   string argument gets a name in an effort to keep the lines from\n   getting ridiculously oversized.  */\n\n/* Output a diagnostic of some kind.  */\nextern void cpp_error (cpp_reader *, int, const char *msgid, ...)\n  ATTRIBUTE_PRINTF_3;\n\n/* Output a diagnostic with \"MSGID: \" preceding the\n   error string of errno.  No location is printed.  */\nextern void cpp_errno (cpp_reader *, int, const char *msgid);\n\n/* Same as cpp_error, except additionally specifies a position as a\n   (translation unit) physical line and physical column.  If the line is\n   zero, then no location is printed.  */\nextern void cpp_error_with_line (cpp_reader *, int, fileline, unsigned,\n\t\t\t\t const char *msgid, ...) ATTRIBUTE_PRINTF_5;\n\n/* In cpplex.c */\nextern int cpp_ideq (const cpp_token *, const char *);\nextern void cpp_output_line (cpp_reader *, FILE *);\nextern void cpp_output_token (const cpp_token *, FILE *);\nextern const char *cpp_type2name (enum cpp_ttype);\n/* Returns the value of an escape sequence, truncated to the correct\n   target precision.  PSTR points to the input pointer, which is just\n   after the backslash.  LIMIT is how much text we have.  WIDE is true\n   if the escape sequence is part of a wide character constant or\n   string literal.  Handles all relevant diagnostics.  */\nextern cppchar_t cpp_parse_escape (cpp_reader *, const unsigned char ** pstr,\n\t\t\t\t   const unsigned char *limit, int wide);\n\n/* In cpphash.c */\n\n/* Lookup an identifier in the hashtable.  Puts the identifier in the\n   table if it is not already there.  */\nextern cpp_hashnode *cpp_lookup (cpp_reader *, const unsigned char *,\n\t\t\t\t unsigned int);\n\ntypedef int (*cpp_cb) (cpp_reader *, cpp_hashnode *, void *);\nextern void cpp_forall_identifiers (cpp_reader *, cpp_cb, void *);\n\n/* In cppmacro.c */\nextern void cpp_scan_nooutput (cpp_reader *);\nextern int  cpp_sys_macro_p (cpp_reader *);\nextern unsigned char *cpp_quote_string (unsigned char *, const unsigned char *,\n\t\t\t\t\tunsigned int);\n\n/* In cppfiles.c */\nextern bool cpp_included (cpp_reader *, const char *);\nextern void cpp_make_system_header (cpp_reader *, int, int);\nextern bool cpp_push_include (cpp_reader *, const char *);\nextern void cpp_change_file (cpp_reader *, enum lc_reason, const char *);\n\n/* In cpppch.c */\nstruct save_macro_data;\nextern int cpp_save_state (cpp_reader *, FILE *);\nextern int cpp_write_pch_deps (cpp_reader *, FILE *);\nextern int cpp_write_pch_state (cpp_reader *, FILE *);\nextern int cpp_valid_state (cpp_reader *, const char *, int);\nextern void cpp_prepare_state (cpp_reader *, struct save_macro_data **);\nextern int cpp_read_state (cpp_reader *, const char *, FILE *,\n\t\t\t   struct save_macro_data *);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ! GCC_CPPLIB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPPUCNID": {"ttr": 2051, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Table of UCNs which are valid in identifiers.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* Automatically generated from cppucnid.tab, do not edit */\n\n/* This file reproduces the table in ISO/IEC 9899:1999 (C99) Annex\n   D, which is itself a reproduction from ISO/IEC TR 10176:1998, and\n   the similar table from ISO/IEC 14882:1988 (C++98) Annex E, which is\n   a reproduction of ISO/IEC PDTR 10176.  Unfortunately these tables\n   are not identical.  */\n\n#ifndef CPPUCNID_H\n#define CPPUCNID_H\n\n#define C99 1\n#define CXX 2\n#define DIG 4\n\nstruct ucnrange\n{\n  unsigned short lo, hi;\n  unsigned short flags;\n};\n\nstatic const struct ucnrange ucnranges\u00dd\u00a8 = {\n  { 0x00aa, 0x00aa,     C99     },  /* Latin */\n  { 0x00b5, 0x00b5,     C99     },  /* Special characters */\n  { 0x00b7, 0x00b7,     C99     },\n  { 0x00ba, 0x00ba,     C99     },  /* Latin */\n  { 0x00c0, 0x00d6, CXX|C99     },\n  { 0x00d8, 0x00f6, CXX|C99     },\n  { 0x00f8, 0x01f5, CXX|C99     },\n  { 0x01fa, 0x0217, CXX|C99     },\n  { 0x0250, 0x02a8, CXX|C99     },\n  { 0x02b0, 0x02b8,     C99     },  /* Special characters */\n  { 0x02bb, 0x02bb,     C99     },\n  { 0x02bd, 0x02c1,     C99     },\n  { 0x02d0, 0x02d1,     C99     },\n  { 0x02e0, 0x02e4,     C99     },\n  { 0x037a, 0x037a,     C99     },\n  { 0x0384, 0x0384, CXX         },  /* Greek */\n  { 0x0386, 0x0386,     C99     },\n  { 0x0388, 0x038a, CXX|C99     },\n  { 0x038c, 0x038c, CXX|C99     },\n  { 0x038e, 0x03a1, CXX|C99     },\n  { 0x03a3, 0x03ce, CXX|C99     },\n  { 0x03d0, 0x03d6, CXX|C99     },\n  { 0x03da, 0x03da, CXX|C99     },\n  { 0x03dc, 0x03dc, CXX|C99     },\n  { 0x03de, 0x03de, CXX|C99     },\n  { 0x03e0, 0x03e0, CXX|C99     },\n  { 0x03e2, 0x03f3, CXX|C99     },\n  { 0x0401, 0x040c, CXX|C99     },  /* Cyrillic */\n  { 0x040d, 0x040d, CXX         },\n  { 0x040e, 0x040e,     C99     },\n  { 0x040f, 0x044f, CXX|C99     },\n  { 0x0451, 0x045c, CXX|C99     },\n  { 0x045e, 0x0481, CXX|C99     },\n  { 0x0490, 0x04c4, CXX|C99     },\n  { 0x04c7, 0x04c8, CXX|C99     },\n  { 0x04cb, 0x04cc, CXX|C99     },\n  { 0x04d0, 0x04eb, CXX|C99     },\n  { 0x04ee, 0x04f5, CXX|C99     },\n  { 0x04f8, 0x04f9, CXX|C99     },\n  { 0x0531, 0x0556, CXX|C99     },  /* Armenian */\n  { 0x0559, 0x0559,     C99     },  /* Special characters */\n  { 0x0561, 0x0587, CXX|C99     },  /* Armenian */\n  { 0x05b0, 0x05b9,     C99     },  /* Hebrew */\n  { 0x05bb, 0x05bd,     C99     },\n  { 0x05bf, 0x05bf,     C99     },\n  { 0x05c1, 0x05c2,     C99     },\n  { 0x05d0, 0x05ea, CXX|C99     },\n  { 0x05f0, 0x05f2, CXX|C99     },\n  { 0x05f3, 0x05f4, CXX         },\n  { 0x0621, 0x063a, CXX|C99     },  /* Arabic */\n  { 0x0640, 0x0652, CXX|C99     },\n  { 0x0660, 0x0669,     C99|DIG },  /* Digits */\n  { 0x0670, 0x06b7, CXX|C99     },  /* Arabic */\n  { 0x06ba, 0x06be, CXX|C99     },\n  { 0x06c0, 0x06ce, CXX|C99     },\n  { 0x06d0, 0x06dc,     C99     },\n  { 0x06e5, 0x06e7, CXX|C99     },\n  { 0x06e8, 0x06e8,     C99     },\n  { 0x06ea, 0x06ed,     C99     },\n  { 0x06f0, 0x06f9,     C99|DIG },  /* Digits */\n  { 0x0901, 0x0903,     C99     },  /* Devanagari */\n  { 0x0905, 0x0939, CXX|C99     },\n  { 0x093d, 0x093d,     C99     },  /* Special characters */\n  { 0x093e, 0x094d,     C99     },  /* Devanagari */\n  { 0x0950, 0x0952,     C99     },\n  { 0x0958, 0x0962, CXX|C99     },\n  { 0x0963, 0x0963,     C99     },\n  { 0x0966, 0x096f,     C99|DIG },  /* Digits */\n  { 0x0981, 0x0983,     C99     },  /* Bengali */\n  { 0x0985, 0x098c, CXX|C99     },\n  { 0x098f, 0x0990, CXX|C99     },\n  { 0x0993, 0x09a8, CXX|C99     },\n  { 0x09aa, 0x09b0, CXX|C99     },\n  { 0x09b2, 0x09b2, CXX|C99     },\n  { 0x09b6, 0x09b9, CXX|C99     },\n  { 0x09be, 0x09c4,     C99     },\n  { 0x09c7, 0x09c8,     C99     },\n  { 0x09cb, 0x09cd,     C99     },\n  { 0x09dc, 0x09dd, CXX|C99     },\n  { 0x09df, 0x09e1, CXX|C99     },\n  { 0x09e2, 0x09e3,     C99     },\n  { 0x09e6, 0x09ef,     C99|DIG },  /* Digits */\n  { 0x09f0, 0x09f1, CXX|C99     },  /* Bengali */\n  { 0x0a02, 0x0a02,     C99     },  /* Gurmukhi */\n  { 0x0a05, 0x0a0a, CXX|C99     },\n  { 0x0a0f, 0x0a10, CXX|C99     },\n  { 0x0a13, 0x0a28, CXX|C99     },\n  { 0x0a2a, 0x0a30, CXX|C99     },\n  { 0x0a32, 0x0a33, CXX|C99     },\n  { 0x0a35, 0x0a36, CXX|C99     },\n  { 0x0a38, 0x0a39, CXX|C99     },\n  { 0x0a3e, 0x0a42,     C99     },\n  { 0x0a47, 0x0a48,     C99     },\n  { 0x0a4b, 0x0a4d,     C99     },\n  { 0x0a59, 0x0a5c, CXX|C99     },\n  { 0x0a5e, 0x0a5e, CXX|C99     },\n  { 0x0a66, 0x0a6f,     C99|DIG },  /* Digits */\n  { 0x0a74, 0x0a74,     C99     },  /* Gurmukhi */\n  { 0x0a81, 0x0a83,     C99     },  /* Gujarati */\n  { 0x0a85, 0x0a8b, CXX|C99     },\n  { 0x0a8d, 0x0a8d, CXX|C99     },\n  { 0x0a8f, 0x0a91, CXX|C99     },\n  { 0x0a93, 0x0aa8, CXX|C99     },\n  { 0x0aaa, 0x0ab0, CXX|C99     },\n  { 0x0ab2, 0x0ab3, CXX|C99     },\n  { 0x0ab5, 0x0ab9, CXX|C99     },\n  { 0x0abd, 0x0ac5,     C99     },\n  { 0x0ac7, 0x0ac9,     C99     },\n  { 0x0acb, 0x0acd,     C99     },\n  { 0x0ad0, 0x0ad0,     C99     },\n  { 0x0ae0, 0x0ae0, CXX|C99     },\n  { 0x0ae6, 0x0aef,     C99|DIG },  /* Digits */\n  { 0x0b01, 0x0b03,     C99     },  /* Oriya */\n  { 0x0b05, 0x0b0c, CXX|C99     },\n  { 0x0b0f, 0x0b10, CXX|C99     },\n  { 0x0b13, 0x0b28, CXX|C99     },\n  { 0x0b2a, 0x0b30, CXX|C99     },\n  { 0x0b32, 0x0b33, CXX|C99     },\n  { 0x0b36, 0x0b39, CXX|C99     },\n  { 0x0b3d, 0x0b3d,     C99     },  /* Special characters */\n  { 0x0b3e, 0x0b43,     C99     },  /* Oriya */\n  { 0x0b47, 0x0b48,     C99     },\n  { 0x0b4b, 0x0b4d,     C99     },\n  { 0x0b5c, 0x0b5d, CXX|C99     },\n  { 0x0b5f, 0x0b61, CXX|C99     },\n  { 0x0b66, 0x0b6f,     C99|DIG },  /* Digits */\n  { 0x0b82, 0x0b83,     C99     },  /* Tamil */\n  { 0x0b85, 0x0b8a, CXX|C99     },\n  { 0x0b8e, 0x0b90, CXX|C99     },\n  { 0x0b92, 0x0b95, CXX|C99     },\n  { 0x0b99, 0x0b9a, CXX|C99     },\n  { 0x0b9c, 0x0b9c, CXX|C99     },\n  { 0x0b9e, 0x0b9f, CXX|C99     },\n  { 0x0ba3, 0x0ba4, CXX|C99     },\n  { 0x0ba8, 0x0baa, CXX|C99     },\n  { 0x0bae, 0x0bb5, CXX|C99     },\n  { 0x0bb7, 0x0bb9, CXX|C99     },\n  { 0x0bbe, 0x0bc2,     C99     },\n  { 0x0bc6, 0x0bc8,     C99     },\n  { 0x0bca, 0x0bcd,     C99     },\n  { 0x0be7, 0x0bef,     C99|DIG },  /* Digits */\n  { 0x0c01, 0x0c03,     C99     },  /* Telugu */\n  { 0x0c05, 0x0c0c, CXX|C99     },\n  { 0x0c0e, 0x0c10, CXX|C99     },\n  { 0x0c12, 0x0c28, CXX|C99     },\n  { 0x0c2a, 0x0c33, CXX|C99     },\n  { 0x0c35, 0x0c39, CXX|C99     },\n  { 0x0c3e, 0x0c44,     C99     },\n  { 0x0c46, 0x0c48,     C99     },\n  { 0x0c4a, 0x0c4d,     C99     },\n  { 0x0c60, 0x0c61, CXX|C99     },\n  { 0x0c66, 0x0c6f,     C99|DIG },  /* Digits */\n  { 0x0c82, 0x0c83,     C99     },  /* Kannada */\n  { 0x0c85, 0x0c8c, CXX|C99     },\n  { 0x0c8e, 0x0c90, CXX|C99     },\n  { 0x0c92, 0x0ca8, CXX|C99     },\n  { 0x0caa, 0x0cb3, CXX|C99     },\n  { 0x0cb5, 0x0cb9, CXX|C99     },\n  { 0x0cbe, 0x0cc4,     C99     },\n  { 0x0cc6, 0x0cc8,     C99     },\n  { 0x0cca, 0x0ccd,     C99     },\n  { 0x0cde, 0x0cde,     C99     },\n  { 0x0ce0, 0x0ce1, CXX|C99     },\n  { 0x0ce6, 0x0cef,     C99|DIG },  /* Digits */\n  { 0x0d02, 0x0d03,     C99     },  /* Malayalam */\n  { 0x0d05, 0x0d0c, CXX|C99     },\n  { 0x0d0e, 0x0d10, CXX|C99     },\n  { 0x0d12, 0x0d28, CXX|C99     },\n  { 0x0d2a, 0x0d39, CXX|C99     },\n  { 0x0d3e, 0x0d43,     C99     },\n  { 0x0d46, 0x0d48,     C99     },\n  { 0x0d4a, 0x0d4d,     C99     },\n  { 0x0d60, 0x0d61, CXX|C99     },\n  { 0x0d66, 0x0d6f,     C99|DIG },  /* Digits */\n  { 0x0e01, 0x0e30, CXX|C99     },  /* Thai */\n  { 0x0e31, 0x0e31,     C99     },\n  { 0x0e32, 0x0e33, CXX|C99     },\n  { 0x0e34, 0x0e3a,     C99     },\n  { 0x0e40, 0x0e46, CXX|C99     },\n  { 0x0e47, 0x0e49,     C99     },\n  { 0x0e50, 0x0e59, CXX|C99|DIG },  /* Digits */\n  { 0x0e5a, 0x0e5b, CXX|C99     },  /* Thai */\n  { 0x0e81, 0x0e82, CXX|C99     },  /* Lao */\n  { 0x0e84, 0x0e84, CXX|C99     },\n  { 0x0e87, 0x0e88, CXX|C99     },\n  { 0x0e8a, 0x0e8a, CXX|C99     },\n  { 0x0e8d, 0x0e8d, CXX|C99     },\n  { 0x0e94, 0x0e97, CXX|C99     },\n  { 0x0e99, 0x0e9f, CXX|C99     },\n  { 0x0ea1, 0x0ea3, CXX|C99     },\n  { 0x0ea5, 0x0ea5, CXX|C99     },\n  { 0x0ea7, 0x0ea7, CXX|C99     },\n  { 0x0eaa, 0x0eab, CXX|C99     },\n  { 0x0ead, 0x0eae, CXX|C99     },\n  { 0x0eaf, 0x0eaf, CXX         },\n  { 0x0eb0, 0x0eb0, CXX|C99     },\n  { 0x0eb1, 0x0eb1,     C99     },\n  { 0x0eb2, 0x0eb3, CXX|C99     },\n  { 0x0eb4, 0x0eb9,     C99     },\n  { 0x0ebb, 0x0ebc,     C99     },\n  { 0x0ebd, 0x0ebd, CXX|C99     },\n  { 0x0ec0, 0x0ec4, CXX|C99     },\n  { 0x0ec6, 0x0ec6, CXX|C99     },\n  { 0x0ec8, 0x0ecd,     C99     },\n  { 0x0ed0, 0x0ed9,     C99|DIG },  /* Digits */\n  { 0x0edc, 0x0edd,     C99     },  /* Lao */\n  { 0x0f00, 0x0f00,     C99     },  /* Tibetan */\n  { 0x0f18, 0x0f19,     C99     },\n  { 0x0f20, 0x0f33,     C99|DIG },  /* Digits */\n  { 0x0f35, 0x0f35,     C99     },  /* Tibetan */\n  { 0x0f37, 0x0f37,     C99     },\n  { 0x0f39, 0x0f39,     C99     },\n  { 0x0f3e, 0x0f47,     C99     },\n  { 0x0f49, 0x0f69,     C99     },\n  { 0x0f71, 0x0f84,     C99     },\n  { 0x0f86, 0x0f8b,     C99     },\n  { 0x0f90, 0x0f95,     C99     },\n  { 0x0f97, 0x0f97,     C99     },\n  { 0x0f99, 0x0fad,     C99     },\n  { 0x0fb1, 0x0fb7,     C99     },\n  { 0x0fb9, 0x0fb9,     C99     },\n  { 0x10a0, 0x10c5, CXX|C99     },  /* Georgian */\n  { 0x10d0, 0x10f6, CXX|C99     },\n  { 0x1100, 0x1159, CXX         },  /* Hangul */\n  { 0x1161, 0x11a2, CXX         },\n  { 0x11a8, 0x11f9, CXX         },\n  { 0x1e00, 0x1e9a, CXX|C99     },  /* Latin */\n  { 0x1e9b, 0x1e9b,     C99     },\n  { 0x1ea0, 0x1ef9, CXX|C99     },\n  { 0x1f00, 0x1f15, CXX|C99     },  /* Greek */\n  { 0x1f18, 0x1f1d, CXX|C99     },\n  { 0x1f20, 0x1f45, CXX|C99     },\n  { 0x1f48, 0x1f4d, CXX|C99     },\n  { 0x1f50, 0x1f57, CXX|C99     },\n  { 0x1f59, 0x1f59, CXX|C99     },\n  { 0x1f5b, 0x1f5b, CXX|C99     },\n  { 0x1f5d, 0x1f5d, CXX|C99     },\n  { 0x1f5f, 0x1f7d, CXX|C99     },\n  { 0x1f80, 0x1fb4, CXX|C99     },\n  { 0x1fb6, 0x1fbc, CXX|C99     },\n  { 0x1fbe, 0x1fbe,     C99     },  /* Special characters */\n  { 0x1fc2, 0x1fc4, CXX|C99     },  /* Greek */\n  { 0x1fc6, 0x1fcc, CXX|C99     },\n  { 0x1fd0, 0x1fd3, CXX|C99     },\n  { 0x1fd6, 0x1fdb, CXX|C99     },\n  { 0x1fe0, 0x1fec, CXX|C99     },\n  { 0x1ff2, 0x1ff4, CXX|C99     },\n  { 0x1ff6, 0x1ffc, CXX|C99     },\n  { 0x203f, 0x2040,     C99     },  /* Special characters */\n  { 0x207f, 0x207f,     C99     },  /* Latin */\n  { 0x2102, 0x2102,     C99     },  /* Special characters */\n  { 0x2107, 0x2107,     C99     },\n  { 0x210a, 0x2113,     C99     },\n  { 0x2115, 0x2115,     C99     },\n  { 0x2118, 0x211d,     C99     },\n  { 0x2124, 0x2124,     C99     },\n  { 0x2126, 0x2126,     C99     },\n  { 0x2128, 0x2128,     C99     },\n  { 0x212a, 0x2131,     C99     },\n  { 0x2133, 0x2138,     C99     },\n  { 0x2160, 0x2182,     C99     },\n  { 0x3005, 0x3007,     C99     },\n  { 0x3021, 0x3029,     C99     },\n  { 0x3041, 0x3093, CXX|C99     },  /* Hiragana */\n  { 0x3094, 0x3094, CXX         },\n  { 0x309b, 0x309c, CXX|C99     },\n  { 0x309d, 0x309e, CXX         },\n  { 0x30a1, 0x30f6, CXX|C99     },  /* Katakana */\n  { 0x30f7, 0x30fa, CXX         },\n  { 0x30fb, 0x30fc, CXX|C99     },\n  { 0x30fd, 0x30fe, CXX         },\n  { 0x3105, 0x312c, CXX|C99     },  /* Bopomofo */\n  { 0x4e00, 0x9fa5, CXX|C99     },  /* CJK Unified Ideographs */\n  { 0xac00, 0xd7a3,     C99     },  /* Hangul */\n  { 0xf900, 0xfa2d, CXX         },  /* CJK Unified Ideographs */\n  { 0xfb1f, 0xfb36, CXX         },\n  { 0xfb38, 0xfb3c, CXX         },\n  { 0xfb3e, 0xfb3e, CXX         },\n  { 0xfb40, 0xfb44, CXX         },\n  { 0xfb46, 0xfbb1, CXX         },\n  { 0xfbd3, 0xfd3f, CXX         },\n  { 0xfd50, 0xfd8f, CXX         },\n  { 0xfd92, 0xfdc7, CXX         },\n  { 0xfdf0, 0xfdfb, CXX         },\n  { 0xfe70, 0xfe72, CXX         },\n  { 0xfe74, 0xfe74, CXX         },\n  { 0xfe76, 0xfefc, CXX         },\n  { 0xff21, 0xff3a, CXX         },\n  { 0xff41, 0xff5a, CXX         },\n  { 0xff66, 0xffbe, CXX         },\n  { 0xffc2, 0xffc7, CXX         },\n  { 0xffca, 0xffcf, CXX         },\n  { 0xffd2, 0xffd7, CXX         },\n  { 0xffda, 0xffdc, CXX         },\n};\n\n#endif /* cppucnid.h */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSELIB": {"ttr": 2055, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Common subexpression elimination for GNU compiler.\n   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Describe a value.  */\ntypedef struct cselib_val_struct GTY(())\n{\n  /* The hash value.  */\n  unsigned int value;\n  union cselib_val_u\n  {\n    /* A VALUE rtx that points back to this structure.  */\n    rtx GTY ((tag (\"1\"))) val_rtx;\n    /* Used to keep a list of free cselib_val structures.  */\n    struct cselib_val_struct * GTY ((skip (\"\"))) next_free;\n  } GTY ((desc (\"1\"))) u;\n\n  /* All rtl expressions that hold this value at the current time during a\n     scan.  */\n  struct elt_loc_list *locs;\n  /* If this value is used as an address, points to a list of values that\n     use it as an address in a MEM.  */\n  struct elt_list *addr_list;\n\n  struct cselib_val_struct *next_containing_mem;\n} cselib_val;\n\n/* A list of rtl expressions that hold the same value.  */\nstruct elt_loc_list GTY(())\n{\n  /* Next element in the list.  */\n  struct elt_loc_list *next;\n  /* An rtl expression that holds the value.  */\n  rtx loc;\n  rtx canon_loc;\n  /* The insn that made the equivalence.  */\n  rtx setting_insn;\n  /* True when setting insn is inside libcall.  */\n  bool in_libcall;\n};\n\n/* A list of cselib_val structures.  */\nstruct elt_list GTY(())\n{\n  struct elt_list *next;\n  cselib_val *elt;\n};\n\nextern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\nextern void cselib_update_varray_sizes (void);\nextern void cselib_init (void);\nextern void cselib_finish (void);\nextern void cselib_process_insn (rtx);\nextern enum machine_mode cselib_reg_set_mode (rtx);\nextern int rtx_equal_for_cselib_p (rtx, rtx);\nextern int references_value_p (rtx, int);\nextern rtx cselib_subst_to_values (rtx);\nextern void cselib_invalidate_rtx (rtx);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DBXOUT": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* dbxout.h - Various declarations for functions found in dbxout.c\n   Copyright (C) 1998, 1999, 2000, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern int dbxout_symbol (tree, int);\nextern void dbxout_parms (tree);\nextern void dbxout_reg_parms (tree);\nextern int dbxout_syms (tree);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEBUG": {"ttr": 2059, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Debug hooks for GCC.\n   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_DEBUG_H\n#define GCC_DEBUG_H\n\n/* This structure contains hooks for the debug information output\n   functions, accessed through the global instance debug_hooks set in\n   toplev.c according to command line options.  */\nstruct gcc_debug_hooks\n{\n  /* Initialize debug output.  MAIN_FILENAME is the name of the main\n     input file.  */\n  void (* init) (const char *main_filename);\n\n  /* Output debug symbols.  */\n  void (* finish) (const char *main_filename);\n\n  /* Macro defined on line LINE with name and expansion TEXT.  */\n  void (* define) (unsigned int line, const char *text);\n\n  /* MACRO undefined on line LINE.  */\n  void (* undef) (unsigned int line, const char *macro);\n\n  /* Record the beginning of a new source file FILE from LINE number\n     in the previous one.  */\n  void (* start_source_file) (unsigned int line, const char *file);\n\n  /* Record the resumption of a source file.  LINE is the line number\n     in the source file we are returning to.  */\n  void (* end_source_file) (unsigned int line);\n\n  /* Record the beginning of block N, counting from 1 and not\n     including the function-scope block, at LINE.  */\n  void (* begin_block) (unsigned int line, unsigned int n);\n\n  /* Record the end of a block.  Arguments as for begin_block.  */\n  void (* end_block) (unsigned int line, unsigned int n);\n\n  /* Returns nonzero if it is appropriate not to emit any debugging\n     information for BLOCK, because it doesn't contain any\n     instructions.  This may not be the case for blocks containing\n     nested functions, since we may actually call such a function even\n     though the BLOCK information is messed up.  Defaults to true.  */\n  bool (* ignore_block) (tree);\n\n  /* Record a source file location at (FILE, LINE).  */\n  void (* source_line) (unsigned int line, const char *file);\n\n  /* Called at start of prologue code.  LINE is the first line in the\n     function.  This has been given the same prototype as source_line,\n     so that the source_line hook can be substituted if appropriate.  */\n  void (* begin_prologue) (unsigned int line, const char *file);\n\n  /* Called at end of prologue code.  LINE is the first line in the\n     function.  */\n  void (* end_prologue) (unsigned int line, const char *file);\n\n  /* Record end of epilogue code.  */\n  void (* end_epilogue) (unsigned int line, const char *file);\n\n  /* Called at start of function DECL, before it is declared.  */\n  void (* begin_function) (tree decl);\n\n  /* Record end of function.  LINE is highest line number in function.  */\n  void (* end_function) (unsigned int line);\n\n  /* Debug information for a function DECL.  This might include the\n     function name (a symbol), its parameters, and the block that\n     makes up the function's body, and the local variables of the\n     function.  */\n  void (* function_decl) (tree decl);\n\n  /* Debug information for a global DECL.  Called from toplev.c after\n     compilation proper has finished.  */\n  void (* global_decl) (tree decl);\n\n  /* DECL is an inline function, whose body is present, but which is\n     not being output at this point.  */\n  void (* deferred_inline_function) (tree decl);\n\n  /* DECL is an inline function which is about to be emitted out of\n     line.  The hook is useful to, e.g., emit abstract debug info for\n     the inline before it gets mangled by optimization.  */\n  void (* outlining_inline_function) (tree decl);\n\n  /* Called from final_scan_insn for any CODE_LABEL insn whose\n     LABEL_NAME is non-null.  */\n  void (* label) (rtx);\n\n  /* Called after the start and before the end of writing a PCH file.\n     The parameter is 0 if after the start, 1 if before the end.  */\n  void (* handle_pch) (unsigned int);\n};\n\nextern const struct gcc_debug_hooks *debug_hooks;\n\n/* The do-nothing hooks.  */\nextern void debug_nothing_void (void);\nextern void debug_nothing_charstar (const char *);\nextern void debug_nothing_int_charstar (unsigned int, const char *);\nextern void debug_nothing_int (unsigned int);\nextern void debug_nothing_int_int (unsigned int, unsigned int);\nextern void debug_nothing_tree (tree);\nextern bool debug_true_tree (tree);\nextern void debug_nothing_rtx (rtx);\n\n/* Hooks for various debug formats.  */\nextern const struct gcc_debug_hooks do_nothing_debug_hooks;\nextern const struct gcc_debug_hooks dbx_debug_hooks;\nextern const struct gcc_debug_hooks sdb_debug_hooks;\nextern const struct gcc_debug_hooks xcoff_debug_hooks;\nextern const struct gcc_debug_hooks dwarf_debug_hooks;\nextern const struct gcc_debug_hooks dwarf2_debug_hooks;\nextern const struct gcc_debug_hooks vmsdbg_debug_hooks;\n\n/* Dwarf2 frame information.  */\n\nextern void dwarf2out_begin_prologue (unsigned int, const char *);\nextern void dwarf2out_end_epilogue (unsigned int, const char *);\nextern void dwarf2out_frame_init (void);\nextern void dwarf2out_frame_finish (void);\n/* Decide whether we want to emit frame unwind information for the current\n   translation unit.  */\nextern int dwarf2out_do_frame (void);\n\nextern void debug_flush_symbol_queue (void);\nextern void debug_queue_symbol (tree);\nextern void debug_free_queue (void);\nextern int debug_nesting;\nextern int symbol_queue_index;\n\n#endif /* !GCC_DEBUG_H  */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DEFAULTS": {"ttr": 2062, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of various defaults for tm.h macros.\n   Copyright (C) 1992, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n   Contributed by Ron Guilmette (rfg@monkeys.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_DEFAULTS_H\n#define GCC_DEFAULTS_H\n\n#ifndef GET_ENVIRONMENT\n#define GET_ENVIRONMENT(VALUE, NAME) do { (VALUE) = getenv (NAME); } while (0)\n#endif\n\n#define obstack_chunk_alloc\t((void *(*) (long)) xmalloc)\n#define obstack_chunk_free\t((void (*) (void *)) free)\n#define OBSTACK_CHUNK_SIZE\t0\n#define gcc_obstack_init(OBSTACK)\t\t\t\\\n  _obstack_begin ((OBSTACK), OBSTACK_CHUNK_SIZE, 0,\t\\\n\t\t  obstack_chunk_alloc,\t\t\t\\\n\t\t  obstack_chunk_free)\n\n/* Define default standard character escape sequences.  */\n#ifndef TARGET_BELL\n#  define TARGET_BELL 007\n#  define TARGET_BS 010\n#  define TARGET_TAB 011\n#  define TARGET_NEWLINE 012\n#  define TARGET_VT 013\n#  define TARGET_FF 014\n#  define TARGET_CR 015\n#  define TARGET_ESC 033\n#endif\n\n/* Store in OUTPUT a string (made with alloca) containing an\n   assembler-name for a local static variable or function named NAME.\n   LABELNO is an integer which is different for each call.  */\n\n#ifndef ASM_PN_FORMAT\n# ifndef NO_DOT_IN_LABEL\n#  define ASM_PN_FORMAT \"%s.%lu\"\n# else\n#  ifndef NO_DOLLAR_IN_LABEL\n#   define ASM_PN_FORMAT \"%s$%lu\"\n#  else\n#   define ASM_PN_FORMAT \"__%s_%lu\"\n#  endif\n# endif\n#endif /* ! ASM_PN_FORMAT */\n\n#ifndef ASM_FORMAT_PRIVATE_NAME\n# define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \\\n  do { const char *const name_ = (NAME); \\\n       char *const output_ = (OUTPUT) = alloca (strlen (name_) + 32);\\\n       sprintf (output_, ASM_PN_FORMAT, name_, (unsigned long)(LABELNO)); \\\n  } while (0)\n#endif\n\n#ifndef ASM_STABD_OP\n#define ASM_STABD_OP \"\\t.stabd\\t\"\n#endif\n\n/* This is how to output an element of a case-vector that is absolute.\n   Some targets don't use this, but we have to define it anyway.  */\n\n#ifndef ASM_OUTPUT_ADDR_VEC_ELT\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\ndo { fputs (integer_asm_op (POINTER_SIZE / UNITS_PER_WORD, TRUE), FILE); \\\n     (*targetm.asm_out.internal_label) (FILE, \"L\", (VALUE));\t\t\t\\\n     fputc ('\\n', FILE);\t\t\t\t\t\t\\\n   } while (0)\n#endif\n\n/* Choose a reasonable default for ASM_OUTPUT_ASCII.  */\n\n#ifndef ASM_OUTPUT_ASCII\n#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);\t      \\\n    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n      const unsigned char *p = _hide_p;\t\t\t\t\t      \\\n      int thissize = _hide_thissize;\t\t\t\t\t      \\\n      int i;\t\t\t\t\t\t\t\t      \\\n      fprintf (asm_out_file, \"\\t.ascii \\\"\");\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  int c = p\u00ddi\u00a8;\t\t\t   \t\t\t\t      \\\n\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n\t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n\t  if (ISPRINT(c))\t\t\t\t\t\t      \\\n\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n\t  else\t\t\t\t\t\t\t\t      \\\n\t    {\t\t\t\t\t\t\t\t      \\\n\t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n\t      /* After an octal-escape, if a digit follows,\t\t      \\\n\t\t terminate one string constant and start another.\t      \\\n\t\t The VAX assembler fails to stop reading the escape\t      \\\n\t\t after three digits, so this is the only way we\t\t      \\\n\t\t can get it to parse the data properly.  */\t\t      \\\n\t      if (i < thissize - 1 && ISDIGIT(p\u00ddi + 1\u00a8))\t\t      \\\n\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n      fprintf (asm_out_file, \"\\\"\\n\");\t\t\t\t\t      \\\n    }\t\t\t\t\t\t\t\t\t      \\\n  }\t\t\t\t\t\t\t\t\t      \\\n  while (0)\n#endif\n\n/* This is how we tell the assembler to equate two values.  */\n#ifdef SET_ASM_OP\n#ifndef ASM_OUTPUT_DEF\n#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n do {\tfprintf ((FILE), \"%s\", SET_ASM_OP);\t\t\t\t\\\n\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n\tfprintf (FILE, \",\");\t\t\t\t\t\t\\\n\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n  } while (0)\n#endif\n#endif\n\n/* Decide whether to defer emitting the assembler output for an equate\n   of two values.  The default is to not defer output.  */\n#ifndef TARGET_DEFERRED_OUTPUT_DEFS\n#define TARGET_DEFERRED_OUTPUT_DEFS(DECL,TARGET) false\n#endif\n\n/* This is how to output the definition of a user-level label named\n   NAME, such as the label on a static function or variable NAME.  */\n\n#ifndef ASM_OUTPUT_LABEL\n#define ASM_OUTPUT_LABEL(FILE,NAME) \\\n  do { assemble_name ((FILE), (NAME)); fputs (\":\\n\", (FILE)); } while (0)\n#endif\n\n/* This is how to output a reference to a user-level label named NAME.  */\n\n#ifndef ASM_OUTPUT_LABELREF\n#define ASM_OUTPUT_LABELREF(FILE,NAME)  asm_fprintf ((FILE), \"%U%s\", (NAME))\n#endif\n\n/* Allow target to print debug info labels specially.  This is useful for\n   VLIW targets, since debug info labels should go into the middle of\n   instruction bundles instead of breaking them.  */\n\n#ifndef ASM_OUTPUT_DEBUG_LABEL\n#define ASM_OUTPUT_DEBUG_LABEL(FILE, PREFIX, NUM) \\\n  (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM)\n#endif\n\n/* This is how we tell the assembler that a symbol is weak.  */\n#ifndef ASM_OUTPUT_WEAK_ALIAS\n#if defined (ASM_WEAKEN_LABEL) && defined (ASM_OUTPUT_DEF)\n#define ASM_OUTPUT_WEAK_ALIAS(STREAM, NAME, VALUE)\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      ASM_WEAKEN_LABEL (STREAM, NAME);\t\t\t\\\n      if (VALUE)\t\t\t\t\t\\\n        ASM_OUTPUT_DEF (STREAM, NAME, VALUE);\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n#endif\n#endif\n\n/* How to emit a .type directive.  */\n#ifndef ASM_OUTPUT_TYPE_DIRECTIVE\n#if defined TYPE_ASM_OP && defined TYPE_OPERAND_FMT\n#define ASM_OUTPUT_TYPE_DIRECTIVE(STREAM, NAME, TYPE)\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      fputs (TYPE_ASM_OP, STREAM);\t\t\t\\\n      assemble_name (STREAM, NAME);\t\t\t\\\n      fputs (\", \", STREAM);\t\t\t\t\\\n      fprintf (STREAM, TYPE_OPERAND_FMT, TYPE);\t\t\\\n      putc ('\\n', STREAM);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n#endif\n#endif\n\n/* How to emit a .size directive.  */\n#ifndef ASM_OUTPUT_SIZE_DIRECTIVE\n#ifdef SIZE_ASM_OP\n#define ASM_OUTPUT_SIZE_DIRECTIVE(STREAM, NAME, SIZE)\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      HOST_WIDE_INT size_ = (SIZE);\t\t\t\\\n      fputs (SIZE_ASM_OP, STREAM);\t\t\t\\\n      assemble_name (STREAM, NAME);\t\t\t\\\n      fprintf (STREAM, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", size_); \\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n\n#define ASM_OUTPUT_MEASURED_SIZE(STREAM, NAME)\t\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      fputs (SIZE_ASM_OP, STREAM);\t\t\t\\\n      assemble_name (STREAM, NAME);\t\t\t\\\n      fputs (\", .-\", STREAM);\t\t\t\t\\\n      assemble_name (STREAM, NAME);\t\t\t\\\n      putc ('\\n', STREAM);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n\n#endif\n#endif\n\n/* This determines whether or not we support weak symbols.  */\n#ifndef SUPPORTS_WEAK\n#if defined (ASM_WEAKEN_LABEL) || defined (ASM_WEAKEN_DECL)\n#define SUPPORTS_WEAK 1\n#else\n#define SUPPORTS_WEAK 0\n#endif\n#endif\n\n/* This determines whether or not we support link-once semantics.  */\n#ifndef SUPPORTS_ONE_ONLY\n#ifdef MAKE_DECL_ONE_ONLY\n#define SUPPORTS_ONE_ONLY 1\n#else\n#define SUPPORTS_ONE_ONLY 0\n#endif\n#endif\n\n/* By default, there is no prefix on user-defined symbols.  */\n#ifndef USER_LABEL_PREFIX\n#define USER_LABEL_PREFIX \"\"\n#endif\n\n/* If the target supports weak symbols, define TARGET_ATTRIBUTE_WEAK to\n   provide a weak attribute.  Else define it to nothing.\n\n   This would normally belong in ansidecl.h, but SUPPORTS_WEAK is\n   not available at that time.\n\n   Note, this is only for use by target files which we know are to be\n   compiled by GCC.  */\n#ifndef TARGET_ATTRIBUTE_WEAK\n# if SUPPORTS_WEAK\n#  define TARGET_ATTRIBUTE_WEAK __attribute__ ((weak))\n# else\n#  define TARGET_ATTRIBUTE_WEAK\n# endif\n#endif\n\n/* If the target supports init_priority C++ attribute, give\n   SUPPORTS_INIT_PRIORITY a nonzero value.  */\n#ifndef SUPPORTS_INIT_PRIORITY\n#define SUPPORTS_INIT_PRIORITY 1\n#endif /* SUPPORTS_INIT_PRIORITY */\n\n/* If duplicate library search directories can be removed from a\n   linker command without changing the linker's semantics, give this\n   symbol a nonzero.  */\n#ifndef LINK_ELIMINATE_DUPLICATE_LDIRECTORIES\n#define LINK_ELIMINATE_DUPLICATE_LDIRECTORIES 0\n#endif /* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */\n\n/* If we have a definition of INCOMING_RETURN_ADDR_RTX, assume that\n   the rest of the DWARF 2 frame unwind support is also provided.  */\n#if !defined (DWARF2_UNWIND_INFO) && defined (INCOMING_RETURN_ADDR_RTX)\n#define DWARF2_UNWIND_INFO 1\n#endif\n\n/* If we have named sections, and we're using crtstuff to run ctors,\n   use them for registering eh frame information.  */\n#if defined (TARGET_ASM_NAMED_SECTION) && DWARF2_UNWIND_INFO \\\n    && !defined(EH_FRAME_IN_DATA_SECTION)\n#ifndef EH_FRAME_SECTION_NAME\n#define EH_FRAME_SECTION_NAME \".eh_frame\"\n#endif\n#endif\n\n/* If we have named section and we support weak symbols, then use the\n   .jcr section for recording java classes which need to be registered\n   at program start-up time.  */\n#if defined (TARGET_ASM_NAMED_SECTION) && SUPPORTS_WEAK\n#ifndef JCR_SECTION_NAME\n#define JCR_SECTION_NAME \".jcr\"\n#endif\n#endif\n\n/* By default, we generate a label at the beginning and end of the\n   text section, and compute the size of the text section by\n   subtracting the two.  However, on some platforms that doesn't\n   work, and we use the section itself, rather than a label at the\n   beginning of it, to indicate the start of the section.  On such\n   platforms, define this to zero.  */\n#ifndef DWARF2_GENERATE_TEXT_SECTION_LABEL\n#define DWARF2_GENERATE_TEXT_SECTION_LABEL 1\n#endif\n\n/* Supply a default definition for PROMOTE_PROTOTYPES.  */\n#ifndef PROMOTE_PROTOTYPES\n#define PROMOTE_PROTOTYPES\t0\n#endif\n\n/* Number of hardware registers that go into the DWARF-2 unwind info.\n   If not defined, equals FIRST_PSEUDO_REGISTER  */\n\n#ifndef DWARF_FRAME_REGISTERS\n#define DWARF_FRAME_REGISTERS FIRST_PSEUDO_REGISTER\n#endif\n\n/* How to renumber registers for dbx and gdb.  If not defined, assume\n   no renumbering is necessary.  */\n\n#ifndef DBX_REGISTER_NUMBER\n#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n#endif\n\n/* Default sizes for base C types.  If the sizes are different for\n   your target, you should override these values by defining the\n   appropriate symbols in your tm.h file.  */\n\n#ifndef BITS_PER_UNIT\n#define BITS_PER_UNIT 8\n#endif\n\n#ifndef BITS_PER_WORD\n#define BITS_PER_WORD (BITS_PER_UNIT * UNITS_PER_WORD)\n#endif\n\n#ifndef CHAR_TYPE_SIZE\n#define CHAR_TYPE_SIZE BITS_PER_UNIT\n#endif\n\n#ifndef BOOL_TYPE_SIZE\n/* `bool' has size and alignment `1', on almost all platforms.  */\n#define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n#endif\n\n#ifndef SHORT_TYPE_SIZE\n#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n#endif\n\n#ifndef INT_TYPE_SIZE\n#define INT_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef LONG_TYPE_SIZE\n#define LONG_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef LONG_LONG_TYPE_SIZE\n#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n#ifndef WCHAR_TYPE_SIZE\n#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n#endif\n\n#ifndef FLOAT_TYPE_SIZE\n#define FLOAT_TYPE_SIZE BITS_PER_WORD\n#endif\n\n#ifndef DOUBLE_TYPE_SIZE\n#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n#ifndef LONG_DOUBLE_TYPE_SIZE\n#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n#endif\n\n/* Width in bits of a pointer.  Mind the value of the macro `Pmode'.  */\n#ifndef POINTER_SIZE\n#define POINTER_SIZE BITS_PER_WORD\n#endif\n\n#ifndef PIC_OFFSET_TABLE_REGNUM\n#define PIC_OFFSET_TABLE_REGNUM INVALID_REGNUM\n#endif\n\n/* By default, the preprocessor should be invoked the same way in C++\n   as in C.  */\n#ifndef CPLUSPLUS_CPP_SPEC\n#ifdef CPP_SPEC\n#define CPLUSPLUS_CPP_SPEC CPP_SPEC\n#endif\n#endif\n\n#ifndef ACCUMULATE_OUTGOING_ARGS\n#define ACCUMULATE_OUTGOING_ARGS 0\n#endif\n\n/* Supply a default definition for PUSH_ARGS.  */\n#ifndef PUSH_ARGS\n#ifdef PUSH_ROUNDING\n#define PUSH_ARGS\t!ACCUMULATE_OUTGOING_ARGS\n#else\n#define PUSH_ARGS\t0\n#endif\n#endif\n\n/* Decide whether a function's arguments should be processed\n   from first to last or from last to first.\n\n   They should if the stack and args grow in opposite directions, but\n   only if we have push insns.  */\n\n#ifdef PUSH_ROUNDING\n\n#ifndef PUSH_ARGS_REVERSED\n#if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)\n#define PUSH_ARGS_REVERSED  PUSH_ARGS\n#endif\n#endif\n\n#endif\n\n#ifndef PUSH_ARGS_REVERSED\n#define PUSH_ARGS_REVERSED 0\n#endif\n\n/* If PREFERRED_STACK_BOUNDARY is not defined, set it to STACK_BOUNDARY.\n   STACK_BOUNDARY is required.  */\n#ifndef PREFERRED_STACK_BOUNDARY\n#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n#endif\n\n/* By default, the C++ compiler will use function addresses in the\n   vtable entries.  Setting this nonzero tells the compiler to use\n   function descriptors instead.  The value of this macro says how\n   many words wide the descriptor is (normally 2).  It is assumed\n   that the address of a function descriptor may be treated as a\n   pointer to a function.  */\n#ifndef TARGET_VTABLE_USES_DESCRIPTORS\n#define TARGET_VTABLE_USES_DESCRIPTORS 0\n#endif\n\n/* By default, the vtable entries are void pointers, the so the alignment\n   is the same as pointer alignment.  The value of this macro specifies\n   the alignment of the vtable entry in bits.  It should be defined only\n   when special alignment is necessary.  */\n#ifndef TARGET_VTABLE_ENTRY_ALIGN\n#define TARGET_VTABLE_ENTRY_ALIGN POINTER_SIZE\n#endif\n\n/* There are a few non-descriptor entries in the vtable at offsets below\n   zero.  If these entries must be padded (say, to preserve the alignment\n   specified by TARGET_VTABLE_ENTRY_ALIGN), set this to the number of\n   words in each data entry.  */\n#ifndef TARGET_VTABLE_DATA_ENTRY_DISTANCE\n#define TARGET_VTABLE_DATA_ENTRY_DISTANCE 1\n#endif\n\n/* Select a format to encode pointers in exception handling data.  We\n   prefer those that result in fewer dynamic relocations.  Assume no\n   special support here and encode direct references.  */\n#ifndef ASM_PREFERRED_EH_DATA_FORMAT\n#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr\n#endif\n\n/* By default, the C++ compiler will use the lowest bit of the pointer\n   to function to indicate a pointer-to-member-function points to a\n   virtual member function.  However, if FUNCTION_BOUNDARY indicates\n   function addresses aren't always even, the lowest bit of the delta\n   field will be used.  */\n#ifndef TARGET_PTRMEMFUNC_VBIT_LOCATION\n#define TARGET_PTRMEMFUNC_VBIT_LOCATION \\\n  (FUNCTION_BOUNDARY >= 2 * BITS_PER_UNIT \\\n   ? ptrmemfunc_vbit_in_pfn : ptrmemfunc_vbit_in_delta)\n#endif\n\n#ifndef DEFAULT_GDB_EXTENSIONS\n#define DEFAULT_GDB_EXTENSIONS 1\n#endif\n\n/* If more than one debugging type is supported, you must define\n   PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.\n\n   This is one long line cause VAXC can't handle a \\-newline.  */\n#if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO) + defined (VMS_DEBUGGING_INFO))\n#ifndef PREFERRED_DEBUGGING_TYPE\nYou Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n#endif /* no PREFERRED_DEBUGGING_TYPE */\n#else /* Only one debugging format supported.  Define PREFERRED_DEBUGGING_TYPE\n\t so other code needn't care.  */\n#ifdef DBX_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n#endif\n#ifdef SDB_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n#endif\n#ifdef DWARF_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n#endif\n#ifdef DWARF2_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n#endif\n#ifdef VMS_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE VMS_AND_DWARF2_DEBUG\n#endif\n#ifdef XCOFF_DEBUGGING_INFO\n#define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG\n#endif\n#endif /* More than one debugger format enabled.  */\n\n/* If still not defined, must have been because no debugging formats\n   are supported.  */\n#ifndef PREFERRED_DEBUGGING_TYPE\n#define PREFERRED_DEBUGGING_TYPE NO_DEBUG\n#endif\n\n/* Define codes for all the float formats that we know of.  */\n#define UNKNOWN_FLOAT_FORMAT 0\n#define IEEE_FLOAT_FORMAT 1\n#define VAX_FLOAT_FORMAT 2\n#define IBM_FLOAT_FORMAT 3\n#define C4X_FLOAT_FORMAT 4\n\n/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n#ifndef TARGET_FLOAT_FORMAT\n#define\tTARGET_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n#endif\n\n/* Determine the register class for registers suitable to be the base\n   address register in a MEM.  Allow the choice to be dependent upon\n   the mode of the memory access.  */\n#ifndef MODE_BASE_REG_CLASS\n#define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n#endif\n\n#ifndef LARGEST_EXPONENT_IS_NORMAL\n#define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0\n#endif\n\n#ifndef ROUND_TOWARDS_ZERO\n#define ROUND_TOWARDS_ZERO 0\n#endif\n\n#ifndef MODE_HAS_NANS\n#define MODE_HAS_NANS(MODE)\t\t\t\t\t\\\n  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))\n#endif\n\n#ifndef MODE_HAS_INFINITIES\n#define MODE_HAS_INFINITIES(MODE)\t\t\t\t\\\n  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))\n#endif\n\n#ifndef MODE_HAS_SIGNED_ZEROS\n#define MODE_HAS_SIGNED_ZEROS(MODE) \\\n  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n#endif\n\n#ifndef MODE_HAS_SIGN_DEPENDENT_ROUNDING\n#define MODE_HAS_SIGN_DEPENDENT_ROUNDING(MODE)\t\t\t\\\n  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n   && !ROUND_TOWARDS_ZERO)\n#endif\n\n#ifndef FLOAT_LIB_COMPARE_RETURNS_BOOL\n#define FLOAT_LIB_COMPARE_RETURNS_BOOL(MODE, COMPARISON) false\n#endif\n\n/* If FLOAT_WORDS_BIG_ENDIAN is not defined in the header files,\n   then the word-endianness is the same as for integers.  */\n#ifndef FLOAT_WORDS_BIG_ENDIAN\n#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n#endif\n\n#ifndef TARGET_FLT_EVAL_METHOD\n#define TARGET_FLT_EVAL_METHOD 0\n#endif\n\n#ifndef HOT_TEXT_SECTION_NAME\n#define HOT_TEXT_SECTION_NAME \"text.hot\"\n#endif\n\n#ifndef UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \"text.unlikely\"\n#endif\n\n#ifndef VECTOR_MODE_SUPPORTED_P\n#define VECTOR_MODE_SUPPORTED_P(MODE) 0\n#endif\n\n/* Determine whether __cxa_atexit, rather than atexit, is used to\n   register C++ destructors for local statics and global objects.  */\n#ifndef DEFAULT_USE_CXA_ATEXIT\n#define DEFAULT_USE_CXA_ATEXIT 0\n#endif\n\n/* Determine whether extra constraint letter should be handled\n   via address reload (like 'o').  */\n#ifndef EXTRA_MEMORY_CONSTRAINT\n#define EXTRA_MEMORY_CONSTRAINT(C,STR) 0\n#endif\n\n/* Determine whether extra constraint letter should be handled\n   as an address (like 'p').  */\n#ifndef EXTRA_ADDRESS_CONSTRAINT\n#define EXTRA_ADDRESS_CONSTRAINT(C,STR) 0\n#endif\n\n/* When a port defines CONSTRAINT_LEN, it should use DEFAULT_CONSTRAINT_LEN\n   for all the characters that it does not want to change, so things like the\n  'length' of a digit in a matching constraint is an implementation detail,\n   and not part of the interface.  */\n#define DEFAULT_CONSTRAINT_LEN(C,STR) 1\n\n#ifndef CONSTRAINT_LEN\n#define CONSTRAINT_LEN(C,STR) DEFAULT_CONSTRAINT_LEN (C, STR)\n#endif\n\n#if defined (CONST_OK_FOR_LETTER_P) && ! defined (CONST_OK_FOR_CONSTRAINT_P)\n#define CONST_OK_FOR_CONSTRAINT_P(VAL,C,STR) CONST_OK_FOR_LETTER_P (VAL, C)\n#endif\n\n#if defined (CONST_DOUBLE_OK_FOR_LETTER_P) && ! defined (CONST_DOUBLE_OK_FOR_CONSTRAINT_P)\n#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(OP,C,STR) \\\n  CONST_DOUBLE_OK_FOR_LETTER_P (OP, C)\n#endif\n\n#ifndef REG_CLASS_FROM_CONSTRAINT\n#define REG_CLASS_FROM_CONSTRAINT(C,STR) REG_CLASS_FROM_LETTER (C)\n#endif\n\n#if defined (EXTRA_CONSTRAINT) && ! defined (EXTRA_CONSTRAINT_STR)\n#define EXTRA_CONSTRAINT_STR(OP, C,STR) EXTRA_CONSTRAINT (OP, C)\n#endif\n\n#ifndef REGISTER_MOVE_COST\n#define REGISTER_MOVE_COST(m, x, y) 2\n#endif\n\n/* Determine whether the the entire c99 runtime\n   is present in the runtime library.  */\n#ifndef TARGET_C99_FUNCTIONS\n#define TARGET_C99_FUNCTIONS 0\n#endif\n\n/* Indicate that CLZ and CTZ are undefined at zero.  */\n#ifndef CLZ_DEFINED_VALUE_AT_ZERO\n#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0\n#endif\n#ifndef CTZ_DEFINED_VALUE_AT_ZERO\n#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  0\n#endif\n\n/* Provide a default value for STORE_FLAG_VALUE.  */\n#ifndef STORE_FLAG_VALUE\n#define STORE_FLAG_VALUE  1\n#endif\n\n/* This macro is used to determine what the largest unit size that\n   move_by_pieces can use is.  */\n\n/* MOVE_MAX_PIECES is the number of bytes at a time which we can\n   move efficiently, as opposed to  MOVE_MAX which is the maximum\n   number of bytes we can move with a single instruction.  */\n\n#ifndef MOVE_MAX_PIECES\n#define MOVE_MAX_PIECES   MOVE_MAX\n#endif\n\n#ifndef STACK_POINTER_OFFSET\n#define STACK_POINTER_OFFSET    0\n#endif\n\n#ifndef LOCAL_REGNO\n#define LOCAL_REGNO(REGNO)  0\n#endif\n\n/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n   the stack pointer does not matter.  The value is tested only in\n   functions that have frame pointers.  */\n#ifndef EXIT_IGNORE_STACK\n#define EXIT_IGNORE_STACK 0\n#endif\n\n#endif  /* ! GCC_DEFAULTS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEMANGLE": {"ttr": 2308, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Defs for interface to demanglers.\n   Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002,\n   2003, 2004 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n\n#if !defined (DEMANGLE_H)\n#define DEMANGLE_H\n\n#include \"libiberty.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* Options passed to cplus_demangle (in 2nd parameter). */\n\n#define DMGL_NO_OPTS\t 0\t\t/* For readability... */\n#define DMGL_PARAMS\t (1 << 0)\t/* Include function args */\n#define DMGL_ANSI\t (1 << 1)\t/* Include const, volatile, etc */\n#define DMGL_JAVA\t (1 << 2)\t/* Demangle as Java rather than C++. */\n#define DMGL_VERBOSE\t (1 << 3)\t/* Include implementation details.  */\n#define DMGL_TYPES\t (1 << 4)\t/* Also try to demangle type encodings.  */\n\n#define DMGL_AUTO\t (1 << 8)\n#define DMGL_GNU\t (1 << 9)\n#define DMGL_LUCID\t (1 << 10)\n#define DMGL_ARM\t (1 << 11)\n#define DMGL_HP \t (1 << 12)       /* For the HP aCC compiler;\n                                            same as ARM except for\n                                            template arguments, etc. */\n#define DMGL_EDG\t (1 << 13)\n#define DMGL_GNU_V3\t (1 << 14)\n#define DMGL_GNAT\t (1 << 15)\n\n/* If none of these are set, use 'current_demangling_style' as the default. */\n#define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT)\n\n/* Enumeration of possible demangling styles.\n\n   Lucid and ARM styles are still kept logically distinct, even though\n   they now both behave identically.  The resulting style is actual the\n   union of both.  I.E. either style recognizes both \"__pt__\" and \"__rf__\"\n   for operator \"->\", even though the first is lucid style and the second\n   is ARM style. (FIXME?) */\n\nextern enum demangling_styles\n{\n  no_demangling = -1,\n  unknown_demangling = 0,\n  auto_demangling = DMGL_AUTO,\n  gnu_demangling = DMGL_GNU,\n  lucid_demangling = DMGL_LUCID,\n  arm_demangling = DMGL_ARM,\n  hp_demangling = DMGL_HP,\n  edg_demangling = DMGL_EDG,\n  gnu_v3_demangling = DMGL_GNU_V3,\n  java_demangling = DMGL_JAVA,\n  gnat_demangling = DMGL_GNAT\n} current_demangling_style;\n\n/* Define string names for the various demangling styles. */\n\n#define NO_DEMANGLING_STYLE_STRING            \"none\"\n#define AUTO_DEMANGLING_STYLE_STRING\t      \"auto\"\n#define GNU_DEMANGLING_STYLE_STRING    \t      \"gnu\"\n#define LUCID_DEMANGLING_STYLE_STRING\t      \"lucid\"\n#define ARM_DEMANGLING_STYLE_STRING\t      \"arm\"\n#define HP_DEMANGLING_STYLE_STRING\t      \"hp\"\n#define EDG_DEMANGLING_STYLE_STRING\t      \"edg\"\n#define GNU_V3_DEMANGLING_STYLE_STRING        \"gnu-v3\"\n#define JAVA_DEMANGLING_STYLE_STRING          \"java\"\n#define GNAT_DEMANGLING_STYLE_STRING          \"gnat\"\n\n/* Some macros to test what demangling style is active. */\n\n#define CURRENT_DEMANGLING_STYLE current_demangling_style\n#define AUTO_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_AUTO)\n#define GNU_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU)\n#define LUCID_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_LUCID)\n#define ARM_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_ARM)\n#define HP_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_HP)\n#define EDG_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_EDG)\n#define GNU_V3_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNU_V3)\n#define JAVA_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_JAVA)\n#define GNAT_DEMANGLING (((int) CURRENT_DEMANGLING_STYLE) & DMGL_GNAT)\n\n/* Provide information about the available demangle styles. This code is\n   pulled from gdb into libiberty because it is useful to binutils also.  */\n\nextern const struct demangler_engine\n{\n  const char *const demangling_style_name;\n  const enum demangling_styles demangling_style;\n  const char *const demangling_style_doc;\n} libiberty_demanglers\u00dd\u00a8;\n\nextern char *\ncplus_demangle PARAMS ((const char *mangled, int options));\n\nextern int\ncplus_demangle_opname PARAMS ((const char *opname, char *result, int options));\n\nextern const char *\ncplus_mangle_opname PARAMS ((const char *opname, int options));\n\n/* Note: This sets global state.  FIXME if you care about multi-threading. */\n\nextern void\nset_cplus_marker_for_demangling PARAMS ((int ch));\n\nextern enum demangling_styles\ncplus_demangle_set_style PARAMS ((enum demangling_styles style));\n\nextern enum demangling_styles\ncplus_demangle_name_to_style PARAMS ((const char *name));\n\n/* V3 ABI demangling entry points, defined in cp-demangle.c.  */\nextern char*\ncplus_demangle_v3 PARAMS ((const char* mangled, int options));\n\nextern char*\njava_demangle_v3 PARAMS ((const char* mangled));\n\n\nenum gnu_v3_ctor_kinds {\n  gnu_v3_complete_object_ctor = 1,\n  gnu_v3_base_object_ctor,\n  gnu_v3_complete_object_allocating_ctor\n};\n\n/* Return non-zero iff NAME is the mangled form of a constructor name\n   in the G++ V3 ABI demangling style.  Specifically, return an `enum\n   gnu_v3_ctor_kinds' value indicating what kind of constructor\n   it is.  */\nextern enum gnu_v3_ctor_kinds\n\tis_gnu_v3_mangled_ctor PARAMS ((const char *name));\n\n\nenum gnu_v3_dtor_kinds {\n  gnu_v3_deleting_dtor = 1,\n  gnu_v3_complete_object_dtor,\n  gnu_v3_base_object_dtor\n};\n\n/* Return non-zero iff NAME is the mangled form of a destructor name\n   in the G++ V3 ABI demangling style.  Specifically, return an `enum\n   gnu_v3_dtor_kinds' value, indicating what kind of destructor\n   it is.  */\nextern enum gnu_v3_dtor_kinds\n\tis_gnu_v3_mangled_dtor PARAMS ((const char *name));\n\n/* The V3 demangler works in two passes.  The first pass builds a tree\n   representation of the mangled name, and the second pass turns the\n   tree representation into a demangled string.  Here we define an\n   interface to permit a caller to build their own tree\n   representation, which they can pass to the demangler to get a\n   demangled string.  This can be used to canonicalize user input into\n   something which the demangler might output.  It could also be used\n   by other demanglers in the future.  */\n\n/* These are the component types which may be found in the tree.  Many\n   component types have one or two subtrees, referred to as left and\n   right (a component type with only one subtree puts it in the left\n   subtree).  */\n\nenum demangle_component_type\n{\n  /* A name, with a length and a pointer to a string.  */\n  DEMANGLE_COMPONENT_NAME,\n  /* A qualified name.  The left subtree is a class or namespace or\n     some such thing, and the right subtree is a name qualified by\n     that class.  */\n  DEMANGLE_COMPONENT_QUAL_NAME,\n  /* A local name.  The left subtree describes a function, and the\n     right subtree is a name which is local to that function.  */\n  DEMANGLE_COMPONENT_LOCAL_NAME,\n  /* A typed name.  The left subtree is a name, and the right subtree\n     describes that name as a function.  */\n  DEMANGLE_COMPONENT_TYPED_NAME,\n  /* A template.  The left subtree is a template name, and the right\n     subtree is a template argument list.  */\n  DEMANGLE_COMPONENT_TEMPLATE,\n  /* A template parameter.  This holds a number, which is the template\n     parameter index.  */\n  DEMANGLE_COMPONENT_TEMPLATE_PARAM,\n  /* A constructor.  This holds a name and the kind of\n     constructor.  */\n  DEMANGLE_COMPONENT_CTOR,\n  /* A destructor.  This holds a name and the kind of destructor.  */\n  DEMANGLE_COMPONENT_DTOR,\n  /* A vtable.  This has one subtree, the type for which this is a\n     vtable.  */\n  DEMANGLE_COMPONENT_VTABLE,\n  /* A VTT structure.  This has one subtree, the type for which this\n     is a VTT.  */\n  DEMANGLE_COMPONENT_VTT,\n  /* A construction vtable.  The left subtree is the type for which\n     this is a vtable, and the right subtree is the derived type for\n     which this vtable is built.  */\n  DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,\n  /* A typeinfo structure.  This has one subtree, the type for which\n     this is the tpeinfo structure.  */\n  DEMANGLE_COMPONENT_TYPEINFO,\n  /* A typeinfo name.  This has one subtree, the type for which this\n     is the typeinfo name.  */\n  DEMANGLE_COMPONENT_TYPEINFO_NAME,\n  /* A typeinfo function.  This has one subtree, the type for which\n     this is the tpyeinfo function.  */\n  DEMANGLE_COMPONENT_TYPEINFO_FN,\n  /* A thunk.  This has one subtree, the name for which this is a\n     thunk.  */\n  DEMANGLE_COMPONENT_THUNK,\n  /* A virtual thunk.  This has one subtree, the name for which this\n     is a virtual thunk.  */\n  DEMANGLE_COMPONENT_VIRTUAL_THUNK,\n  /* A covariant thunk.  This has one subtree, the name for which this\n     is a covariant thunk.  */\n  DEMANGLE_COMPONENT_COVARIANT_THUNK,\n  /* A Java class.  This has one subtree, the type.  */\n  DEMANGLE_COMPONENT_JAVA_CLASS,\n  /* A guard variable.  This has one subtree, the name for which this\n     is a guard variable.  */\n  DEMANGLE_COMPONENT_GUARD,\n  /* A reference temporary.  This has one subtree, the name for which\n     this is a temporary.  */\n  DEMANGLE_COMPONENT_REFTEMP,\n  /* A standard substitution.  This holds the name of the\n     substitution.  */\n  DEMANGLE_COMPONENT_SUB_STD,\n  /* The restrict qualifier.  The one subtree is the type which is\n     being qualified.  */\n  DEMANGLE_COMPONENT_RESTRICT,\n  /* The volatile qualifier.  The one subtree is the type which is\n     being qualified.  */\n  DEMANGLE_COMPONENT_VOLATILE,\n  /* The const qualifier.  The one subtree is the type which is being\n     qualified.  */\n  DEMANGLE_COMPONENT_CONST,\n  /* The restrict qualifier modifying a member function.  The one\n     subtree is the type which is being qualified.  */\n  DEMANGLE_COMPONENT_RESTRICT_THIS,\n  /* The volatile qualifier modifying a member function.  The one\n     subtree is the type which is being qualified.  */\n  DEMANGLE_COMPONENT_VOLATILE_THIS,\n  /* The const qualifier modifying a member function.  The one subtree\n     is the type which is being qualified.  */\n  DEMANGLE_COMPONENT_CONST_THIS,\n  /* A vendor qualifier.  The left subtree is the type which is being\n     qualified, and the right subtree is the name of the\n     qualifier.  */\n  DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,\n  /* A pointer.  The one subtree is the type which is being pointed\n     to.  */\n  DEMANGLE_COMPONENT_POINTER,\n  /* A reference.  The one subtree is the type which is being\n     referenced.  */\n  DEMANGLE_COMPONENT_REFERENCE,\n  /* A complex type.  The one subtree is the base type.  */\n  DEMANGLE_COMPONENT_COMPLEX,\n  /* An imaginary type.  The one subtree is the base type.  */\n  DEMANGLE_COMPONENT_IMAGINARY,\n  /* A builtin type.  This holds the builtin type information.  */\n  DEMANGLE_COMPONENT_BUILTIN_TYPE,\n  /* A vendor's builtin type.  This holds the name of the type.  */\n  DEMANGLE_COMPONENT_VENDOR_TYPE,\n  /* A function type.  The left subtree is the return type.  The right\n     subtree is a list of ARGLIST nodes.  Either or both may be\n     NULL.  */\n  DEMANGLE_COMPONENT_FUNCTION_TYPE,\n  /* An array type.  The left subtree is the dimension, which may be\n     NULL, or a string (represented as DEMANGLE_COMPONENT_NAME), or an\n     expression.  The right subtree is the element type.  */\n  DEMANGLE_COMPONENT_ARRAY_TYPE,\n  /* A pointer to member type.  The left subtree is the class type,\n     and the right subtree is the member type.  CV-qualifiers appear\n     on the latter.  */\n  DEMANGLE_COMPONENT_PTRMEM_TYPE,\n  /* An argument list.  The left subtree is the current argument, and\n     the right subtree is either NULL or another ARGLIST node.  */\n  DEMANGLE_COMPONENT_ARGLIST,\n  /* A template argument list.  The left subtree is the current\n     template argument, and the right subtree is either NULL or\n     another TEMPLATE_ARGLIST node.  */\n  DEMANGLE_COMPONENT_TEMPLATE_ARGLIST,\n  /* An operator.  This holds information about a standard\n     operator.  */\n  DEMANGLE_COMPONENT_OPERATOR,\n  /* An extended operator.  This holds the number of arguments, and\n     the name of the extended operator.  */\n  DEMANGLE_COMPONENT_EXTENDED_OPERATOR,\n  /* A typecast, represented as a unary operator.  The one subtree is\n     the type to which the argument should be cast.  */\n  DEMANGLE_COMPONENT_CAST,\n  /* A unary expression.  The left subtree is the operator, and the\n     right subtree is the single argument.  */\n  DEMANGLE_COMPONENT_UNARY,\n  /* A binary expression.  The left subtree is the operator, and the\n     right subtree is a BINARY_ARGS.  */\n  DEMANGLE_COMPONENT_BINARY,\n  /* Arguments to a binary expression.  The left subtree is the first\n     argument, and the right subtree is the second argument.  */\n  DEMANGLE_COMPONENT_BINARY_ARGS,\n  /* A trinary expression.  The left subtree is the operator, and the\n     right subtree is a TRINARY_ARG1.  */\n  DEMANGLE_COMPONENT_TRINARY,\n  /* Arguments to a trinary expression.  The left subtree is the first\n     argument, and the right subtree is a TRINARY_ARG2.  */\n  DEMANGLE_COMPONENT_TRINARY_ARG1,\n  /* More arguments to a trinary expression.  The left subtree is the\n     second argument, and the right subtree is the third argument.  */\n  DEMANGLE_COMPONENT_TRINARY_ARG2,\n  /* A literal.  The left subtree is the type, and the right subtree\n     is the value, represented as a DEMANGLE_COMPONENT_NAME.  */\n  DEMANGLE_COMPONENT_LITERAL,\n  /* A negative literal.  Like LITERAL, but the value is negated.\n     This is a minor hack: the NAME used for LITERAL points directly\n     to the mangled string, but since negative numbers are mangled\n     using 'n' instead of '-', we want a way to indicate a negative\n     number which involves neither modifying the mangled string nor\n     allocating a new copy of the literal in memory.  */\n  DEMANGLE_COMPONENT_LITERAL_NEG\n};\n\n/* Types which are only used internally.  */\n\nstruct demangle_operator_info;\nstruct demangle_builtin_type_info;\n\n/* A node in the tree representation is an instance of a struct\n   demangle_component.  Note that the field names of the struct are\n   not well protected against macros defined by the file including\n   this one.  We can fix this if it ever becomes a problem.  */\n\nstruct demangle_component\n{\n  /* The type of this component.  */\n  enum demangle_component_type type;\n\n  union\n  {\n    /* For DEMANGLE_COMPONENT_NAME.  */\n    struct\n    {\n      /* A pointer to the name (which need not NULL terminated) and\n\t its length.  */\n      const char *s;\n      int len;\n    } s_name;\n\n    /* For DEMANGLE_COMPONENT_OPERATOR.  */\n    struct\n    {\n      /* Operator.  */\n      const struct demangle_operator_info *op;\n    } s_operator;\n\n    /* For DEMANGLE_COMPONENT_EXTENDED_OPERATOR.  */\n    struct\n    {\n      /* Number of arguments.  */\n      int args;\n      /* Name.  */\n      struct demangle_component *name;\n    } s_extended_operator;\n\n    /* For DEMANGLE_COMPONENT_CTOR.  */\n    struct\n    {\n      /* Kind of constructor.  */\n      enum gnu_v3_ctor_kinds kind;\n      /* Name.  */\n      struct demangle_component *name;\n    } s_ctor;\n\n    /* For DEMANGLE_COMPONENT_DTOR.  */\n    struct\n    {\n      /* Kind of destructor.  */\n      enum gnu_v3_dtor_kinds kind;\n      /* Name.  */\n      struct demangle_component *name;\n    } s_dtor;\n\n    /* For DEMANGLE_COMPONENT_BUILTIN_TYPE.  */\n    struct\n    {\n      /* Builtin type.  */\n      const struct demangle_builtin_type_info *type;\n    } s_builtin;\n\n    /* For DEMANGLE_COMPONENT_SUB_STD.  */\n    struct\n    {\n      /* Standard substitution string.  */\n      const char* string;\n      /* Length of string.  */\n      int len;\n    } s_string;\n\n    /* For DEMANGLE_COMPONENT_TEMPLATE_PARAM.  */\n    struct\n    {\n      /* Template parameter index.  */\n      long number;\n    } s_number;\n\n    /* For other types.  */\n    struct\n    {\n      /* Left (or only) subtree.  */\n      struct demangle_component *left;\n      /* Right subtree.  */\n      struct demangle_component *right;\n    } s_binary;\n\n  } u;\n};\n\n/* People building mangled trees are expected to allocate instances of\n   struct demangle_component themselves.  They can then call one of\n   the following functions to fill them in.  */\n\n/* Fill in most component types with a left subtree and a right\n   subtree.  Returns non-zero on success, zero on failure, such as an\n   unrecognized or inappropriate component type.  */\n\nextern int\ncplus_demangle_fill_component PARAMS ((struct demangle_component *fill,\n\t\t\t\t       enum demangle_component_type,\n\t\t\t\t       struct demangle_component *left,\n\t\t\t\t       struct demangle_component *right));\n\n/* Fill in a DEMANGLE_COMPONENT_NAME.  Returns non-zero on success,\n   zero for bad arguments.  */\n\nextern int\ncplus_demangle_fill_name PARAMS ((struct demangle_component *fill,\n\t\t\t\t  const char *, int));\n\n/* Fill in a DEMANGLE_COMPONENT_BUILTIN_TYPE, using the name of the\n   builtin type (e.g., \"int\", etc.).  Returns non-zero on success,\n   zero if the type is not recognized.  */\n\nextern int\ncplus_demangle_fill_builtin_type PARAMS ((struct demangle_component *fill,\n\t\t\t\t\t  const char *typename));\n\n/* Fill in a DEMANGLE_COMPONENT_OPERATOR, using the name of the\n   operator and the number of arguments which it takes (the latter is\n   used to disambiguate operators which can be both binary and unary,\n   such as '-').  Returns non-zero on success, zero if the operator is\n   not recognized.  */\n\nextern int\ncplus_demangle_fill_operator PARAMS ((struct demangle_component *fill,\n\t\t\t\t      const char *opname, int args));\n\n/* Fill in a DEMANGLE_COMPONENT_EXTENDED_OPERATOR, providing the\n   number of arguments and the name.  Returns non-zero on success,\n   zero for bad arguments.  */\n\nextern int\ncplus_demangle_fill_extended_operator PARAMS ((struct demangle_component *fill,\n\t\t\t\t\t       int numargs,\n\t\t\t\t\t       struct demangle_component *nm));\n\n/* Fill in a DEMANGLE_COMPONENT_CTOR.  Returns non-zero on success,\n   zero for bad arguments.  */\n\nextern int\ncplus_demangle_fill_ctor PARAMS ((struct demangle_component *fill,\n\t\t\t\t  enum gnu_v3_ctor_kinds kind,\n\t\t\t\t  struct demangle_component *name));\n\n/* Fill in a DEMANGLE_COMPONENT_DTOR.  Returns non-zero on success,\n   zero for bad arguments.  */\n\nextern int\ncplus_demangle_fill_dtor PARAMS ((struct demangle_component *fill,\n\t\t\t\t  enum gnu_v3_dtor_kinds kind,\n\t\t\t\t  struct demangle_component *name));\n\n/* This function translates a mangled name into a struct\n   demangle_component tree.  The first argument is the mangled name.\n   The second argument is DMGL_* options.  This returns a pointer to a\n   tree on success, or NULL on failure.  On success, the third\n   argument is set to a block of memory allocated by malloc.  This\n   block should be passed to free when the tree is no longer\n   needed.  */\n\nextern struct demangle_component *\ncplus_demangle_v3_components PARAMS ((const char *mangled,\n\t\t\t\t      int options,\n\t\t\t\t      void **mem));\n\n/* This function takes a struct demangle_component tree and returns\n   the corresponding demangled string.  The first argument is DMGL_*\n   options.  The second is the tree to demangle.  The third is a guess\n   at the length of the demangled string, used to initially allocate\n   the return buffer.  The fourth is a pointer to a size_t.  On\n   success, this function returns a buffer allocated by malloc(), and\n   sets the size_t pointed to by the fourth argument to the size of\n   the allocated buffer (not the length of the returned string).  On\n   failure, this function returns NULL, and sets the size_t pointed to\n   by the fourth argument to 0 for an invalid tree, or to 1 for a\n   memory allocation error.  */\n\nextern char *\ncplus_demangle_print PARAMS ((int options,\n\t\t\t      const struct demangle_component *tree,\n\t\t\t      int estimated_length,\n\t\t\t      size_t *p_allocated_size));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif\t/* DEMANGLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DF": {"ttr": 2313, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Form lists of pseudo register references for autoinc optimization\n   for GNU compiler.  This is part of flow optimization.\n   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n   Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#define DF_RD\t\t 1\t/* Reaching definitions.  */\n#define DF_RU\t\t 2\t/* Reaching uses.  */\n#define DF_LR\t\t 4\t/* Live registers.  */\n#define DF_DU_CHAIN\t 8\t/* Def-use chain.  */\n#define DF_UD_CHAIN     16\t/* Use-def chain.  */\n#define DF_REG_INFO\t32\t/* Register info.  */\n#define DF_RD_CHAIN\t64\t/* Reg-def chain.  */\n#define DF_RU_CHAIN    128\t/* Reg-use chain.  */\n#define DF_ALL\t       255\n#define DF_HARD_REGS  1024\t/* Mark hard registers.  */\n#define DF_EQUIV_NOTES 2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n#define DF_FOR_REGALLOC 4096    /* If called for the register allocator.  */\n\nenum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n\t\t  DF_REF_REG_MEM_STORE};\n\n#define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n\n/* Link on a def-use or use-def chain.  */\nstruct df_link\n{\n  struct df_link *next;\n  struct ref *ref;\n};\n\nenum df_ref_flags\n  {\n    /* Read-modify-write refs generate both a use and a def and\n       these are marked with this flag to show that they are not\n       independent.  */\n    DF_REF_READ_WRITE = 1,\n\n    /* This flag is set on register references inside a subreg on\n       machines which have CANNOT_CHANGE_MODE_CLASS.\n       Note, that this flag can also be set on df_refs representing\n       the REG itself (i.e., one might not see the subreg anyore).\n       Also note, that this flag is set also for hardreg refs, i.e.,\n       you must check yourself if it's a pseudo.  */\n    DF_REF_MODE_CHANGE = 2,\n\n    /* This flag is set, if we stripped the subreg from the reference.\n       In this case we must make conservative guesses, at what the\n       outer mode was.  */\n    DF_REF_STRIPPED = 4,\n\n    /* This flag is set during register allocation if it's okay for\n    the reference's INSN to have one of its operands replaced with a\n    memory reference.  */\n    DF_REF_MEM_OK = 8\n  };\n\n\n/* Define a register reference structure.  One of these is allocated\n   for every register reference (use or def).  Note some register\n   references (e.g., post_inc, subreg) generate both a def and a use.  */\nstruct ref\n{\n  rtx reg;\t\t\t/* The register referenced.  */\n  rtx insn;\t\t\t/* Insn containing ref.  */\n  rtx *loc;\t\t\t/* The location of the reg.  */\n  struct df_link *chain;\t/* Head of def-use or use-def chain.  */\n  unsigned int id;\t\t/* Ref index.  */\n  enum df_ref_type type;\t/* Type of ref.  */\n  enum df_ref_flags flags;\t/* Various flags.  */\n};\n\n\n/* One of these structures is allocated for every insn.  */\nstruct insn_info\n{\n  struct df_link *defs;\t\t/* Head of insn-def chain.  */\n  struct df_link *uses;\t\t/* Head of insn-use chain.  */\n  /* ???? The following luid field should be considered private so that\n     we can change it on the fly to accommodate new insns?  */\n  int luid;\t\t\t/* Logical UID.  */\n};\n\n\n/* One of these structures is allocated for every reg.  */\nstruct reg_info\n{\n  struct df_link *defs;\t\t/* Head of reg-def chain.  */\n  struct df_link *uses;\t\t/* Head of reg-use chain.  */\n  int lifetime;\n  int n_defs;\n  int n_uses;\n};\n\n\n/* One of these structures is allocated for every basic block.  */\nstruct bb_info\n{\n  /* Reaching def bitmaps have def_id elements.  */\n  bitmap rd_kill;\n  bitmap rd_gen;\n  bitmap rd_in;\n  bitmap rd_out;\n  /* Reaching use bitmaps have use_id elements.  */\n  bitmap ru_kill;\n  bitmap ru_gen;\n  bitmap ru_in;\n  bitmap ru_out;\n  /* Live variable bitmaps have n_regs elements.  */\n  bitmap lr_def;\n  bitmap lr_use;\n  bitmap lr_in;\n  bitmap lr_out;\n  int rd_valid;\n  int ru_valid;\n  int lr_valid;\n};\n\n\nstruct df\n{\n  int flags;\t\t\t/* Indicates what's recorded.  */\n  struct bb_info *bbs;\t\t/* Basic block table.  */\n  struct ref **defs;\t\t/* Def table, indexed by def_id.  */\n  struct ref **uses;\t\t/* Use table, indexed by use_id.  */\n  struct ref **reg_def_last;\t/* Indexed by regno.  */\n  struct reg_info *regs;\t/* Regs table, index by regno.  */\n  unsigned int reg_size;\t/* Size of regs table.  */\n  struct insn_info *insns;\t/* Insn table, indexed by insn UID.  */\n  unsigned int insn_size;\t/* Size of insn table.  */\n  unsigned int def_id;\t\t/* Next def ID.  */\n  unsigned int def_size;\t/* Size of def table.  */\n  unsigned int n_defs;\t\t/* Size of def bitmaps.  */\n  unsigned int use_id;\t\t/* Next use ID.  */\n  unsigned int use_size;\t/* Size of use table.  */\n  unsigned int n_uses;\t\t/* Size of use bitmaps.  */\n  unsigned int n_bbs;\t\t/* Number of basic blocks.  */\n  unsigned int n_regs;\t\t/* Number of regs.  */\n  unsigned int def_id_save;\t/* Saved next def ID.  */\n  unsigned int use_id_save;\t/* Saved next use ID.  */\n  bitmap insns_modified;\t/* Insns that (may) have changed.  */\n  bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n  bitmap all_blocks;\t\t/* All blocks in CFG.  */\n  /* The sbitmap vector of dominators or NULL if not computed.\n     Ideally, this should be a pointer to a CFG object.  */\n  sbitmap *dom;\n  int *dfs_order;\t\t/* DFS order -> block number.  */\n  int *rc_order;\t\t/* Reverse completion order -> block number.  */\n  int *rts_order;\t\t/* Reverse top sort order -> block number.  */\n  int *inverse_rc_map;\t\t/* Block number -> reverse completion order.  */\n  int *inverse_dfs_map;\t\t/* Block number -> DFS order.  */\n  int *inverse_rts_map;\t\t/* Block number -> reverse top-sort order.  */\n};\n\n\nstruct df_map\n{\n  rtx old;\n  rtx new;\n};\n\n\n#define DF_BB_INFO(REFS, BB) (&REFS->bbs\u00dd(BB)->index\u00a8)\n\n\n/* Macros to access the elements within the ref structure.  */\n\n#define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n\t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n#define DF_REF_REGNO(REF) REGNO (DF_REF_REAL_REG (REF))\n#define DF_REF_REAL_LOC(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n\t\t\t        ? &SUBREG_REG ((REF)->reg) : ((REF)->loc))\n#define DF_REF_REG(REF) ((REF)->reg)\n#define DF_REF_LOC(REF) ((REF)->loc)\n#define DF_REF_BB(REF) (BLOCK_FOR_INSN ((REF)->insn))\n#define DF_REF_BBNO(REF) (BLOCK_FOR_INSN ((REF)->insn)->index)\n#define DF_REF_INSN(REF) ((REF)->insn)\n#define DF_REF_INSN_UID(REF) (INSN_UID ((REF)->insn))\n#define DF_REF_TYPE(REF) ((REF)->type)\n#define DF_REF_CHAIN(REF) ((REF)->chain)\n#define DF_REF_ID(REF) ((REF)->id)\n#define DF_REF_FLAGS(REF) ((REF)->flags)\n\n/* Macros to determine the reference type.  */\n\n#define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)\n#define DF_REF_REG_USE_P(REF) ((REF) && ! DF_REF_REG_DEF_P (REF))\n#define DF_REF_REG_MEM_STORE_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_STORE)\n#define DF_REF_REG_MEM_LOAD_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_LOAD)\n#define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n                               || DF_REF_REG_MEM_LOAD_P (REF))\n\n\n/* Macros to access the elements within the reg_info structure table.  */\n\n#define DF_REGNO_FIRST_DEF(DF, REGNUM) \\\n((DF)->regs\u00ddREGNUM\u00a8.defs ? (DF)->regs\u00ddREGNUM\u00a8.defs->ref : 0)\n#define DF_REGNO_LAST_USE(DF, REGNUM) \\\n((DF)->regs\u00ddREGNUM\u00a8.uses ? (DF)->regs\u00ddREGNUM\u00a8.uses->ref : 0)\n\n#define DF_REGNO_FIRST_BB(DF, REGNUM) \\\n(DF_REGNO_FIRST_DEF (DF, REGNUM) \\\n? DF_REF_BB (DF_REGNO_FIRST_DEF (DF, REGNUM)) : 0)\n#define DF_REGNO_LAST_BB(DF, REGNUM) \\\n(DF_REGNO_LAST_USE (DF, REGNUM) \\\n? DF_REF_BB (DF_REGNO_LAST_USE (DF, REGNUM)) : 0)\n\n\n/* Macros to access the elements within the insn_info structure table.  */\n\n#define DF_INSN_LUID(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.luid)\n#define DF_INSN_DEFS(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.defs)\n#define DF_INSN_USES(DF, INSN) ((DF)->insns\u00ddINSN_UID (INSN)\u00a8.uses)\n\n\n/* Functions to build and analyse dataflow information.  */\n\nextern struct df *df_init (void);\n\nextern int df_analyse (struct df *, bitmap, int);\n\nextern void df_finish (struct df *);\n\nextern void df_dump (struct df *, int, FILE *);\n\n\n/* Functions to modify insns.  */\n\nextern void df_insn_modify (struct df *, basic_block, rtx);\n\nextern rtx df_insn_delete (struct df *, basic_block, rtx);\n\nextern rtx df_pattern_emit_before (struct df *, rtx, basic_block, rtx);\n\nextern rtx df_jump_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n\nextern rtx df_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n\nextern rtx df_insn_move_before (struct df *, basic_block, rtx, basic_block,\n\t\t\t\trtx);\n\nextern int df_reg_replace (struct df *, bitmap, rtx, rtx);\n\nextern int df_ref_reg_replace (struct df *, struct ref *, rtx, rtx);\n\nextern int df_ref_remove (struct df *, struct ref *);\n\nextern int df_insn_reg_replace (struct df *, basic_block, rtx, rtx, rtx);\n\nextern int df_insn_mem_replace (struct df *, basic_block, rtx, rtx, rtx);\n\nextern struct ref *df_bb_def_use_swap (struct df *, basic_block, rtx, rtx,\n\t\t\t\t       unsigned int);\n\n\n/* Functions to query dataflow information.  */\n\nextern basic_block df_regno_bb (struct df *, unsigned int);\n\nextern int df_reg_lifetime (struct df *, rtx);\n\nextern int df_reg_global_p (struct df *, rtx);\n\nextern int df_insn_regno_def_p (struct df *, basic_block, rtx, unsigned int);\n\nextern int df_insn_dominates_all_uses_p (struct df *, basic_block, rtx);\n\nextern int df_insn_dominates_uses_p (struct df *, basic_block, rtx, bitmap);\n\nextern int df_bb_reg_live_start_p (struct df *, basic_block, rtx);\n\nextern int df_bb_reg_live_end_p (struct df *, basic_block, rtx);\n\nextern int df_bb_regs_lives_compare (struct df *, basic_block, rtx, rtx);\n\nextern rtx df_bb_single_def_use_insn_find (struct df *, basic_block, rtx,\n\t\t\t\t\t   rtx);\n\n\n/* Functions for debugging from GDB.  */\n\nextern void debug_df_insn (rtx);\n\nextern void debug_df_regno (unsigned int);\n\nextern void debug_df_reg (rtx);\n\nextern void debug_df_defno (unsigned int);\n\nextern void debug_df_useno (unsigned int);\n\nextern void debug_df_ref (struct ref *);\n\nextern void debug_df_chain (struct df_link *);\n\nextern void df_insn_debug (struct df *, rtx, FILE *);\n\nextern void df_insn_debug_regno (struct df *, rtx, FILE *);\n\n\n/* Meet over any path (UNION) or meet over all paths (INTERSECTION).  */\nenum df_confluence_op\n  {\n    DF_UNION,\n    DF_INTERSECTION\n  };\n\n\n/* Dataflow direction.  */\nenum df_flow_dir\n  {\n    DF_FORWARD,\n    DF_BACKWARD\n  };\n\n\ntypedef void (*transfer_function_sbitmap) (int, int *, sbitmap, sbitmap,\n\t\t\t\t\t   sbitmap, sbitmap, void *);\n\ntypedef void (*transfer_function_bitmap) (int, int *, bitmap, bitmap,\n\t\t\t\t\t  bitmap, bitmap, void *);\n\nextern void iterative_dataflow_sbitmap (sbitmap *, sbitmap *, sbitmap *,\n\t\t\t\t\tsbitmap *, bitmap, enum df_flow_dir,\n\t\t\t\t\tenum df_confluence_op,\n\t\t\t\t\ttransfer_function_sbitmap,\n\t\t\t\t\tint *, void *);\n\nextern void iterative_dataflow_bitmap (bitmap *, bitmap *, bitmap *,\n\t\t\t\t       bitmap *, bitmap,\n\t\t\t\t       enum df_flow_dir,\n\t\t\t\t       enum df_confluence_op,\n\t\t\t\t       transfer_function_bitmap,\n\t\t\t\t       int *, void *);\nextern bool read_modify_subreg_p (rtx);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIAGNDEF": {"ttr": 2317, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DEFINE_DIAGNOSTIC_KIND (DK_FATAL, \"fatal error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ICE, \"internal compiler error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ERROR, \"error: \")\nDEFINE_DIAGNOSTIC_KIND (DK_SORRY, \"sorry, unimplemented: \")\nDEFINE_DIAGNOSTIC_KIND (DK_WARNING, \"warning: \")\nDEFINE_DIAGNOSTIC_KIND (DK_ANACHRONISM, \"anachronism: \")\nDEFINE_DIAGNOSTIC_KIND (DK_NOTE, \"note: \")\nDEFINE_DIAGNOSTIC_KIND (DK_DEBUG, \"debug: \")\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DIAGNOST": {"ttr": 2561, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Various declarations for language-independent diagnostics subroutines.\n   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n   Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_DIAGNOSTIC_H\n#define GCC_DIAGNOSTIC_H\n\n#include \"pretty-print.h\"\n\n/* Constants used to discriminate diagnostics.  */\ntypedef enum\n{\n#define DEFINE_DIAGNOSTIC_KIND(K, msgid) K,\n#include \"diagnostic.def\"\n#undef DEFINE_DIAGNOSTIC_KIND\n  DK_LAST_DIAGNOSTIC_KIND\n} diagnostic_t;\n\n/* A diagnostic is described by the MESSAGE to send, the FILE and LINE of\n   its context and its KIND (ice, error, warning, note, ...)  See complete\n   list in diagnostic.def.  */\ntypedef struct\n{\n  text_info message;\n  location_t location;\n  /* The kind of diagnostic it is about.  */\n  diagnostic_t kind;\n} diagnostic_info;\n\n#define pedantic_error_kind() (flag_pedantic_errors ? DK_ERROR : DK_WARNING)\n\n\n/*  Forward declarations.  */\ntypedef struct diagnostic_context diagnostic_context;\ntypedef void (*diagnostic_starter_fn) (diagnostic_context *,\n\t\t\t\t       diagnostic_info *);\ntypedef diagnostic_starter_fn diagnostic_finalizer_fn;\n\n/* This data structure bundles altogether any information relevant to\n   the context of a diagnostic message.  */\nstruct diagnostic_context\n{\n  /* Where most of the diagnostic formatting work is done.  */\n  pretty_printer *printer;\n\n  /* The number of times we have issued diagnostics.  */\n  int diagnostic_count\u00ddDK_LAST_DIAGNOSTIC_KIND\u00a8;\n\n  /* True if we should display the \"warnings are being tread as error\"\n     message, usually displayed once per compiler run.  */\n  bool warnings_are_errors_message;\n\n  /* True if we should raise a SIGABRT on errors.  */\n  bool abort_on_error;\n\n  /* This function is called before any message is printed out.  It is\n     responsible for preparing message prefix and such.  For example, it\n     might say:\n     In file included from \"/usr/local/include/curses.h:5:\n                      from \"/home/gdr/src/nifty_printer.h:56:\n                      ...\n  */\n  diagnostic_starter_fn begin_diagnostic;\n\n  /* This function is called after the diagnostic message is printed.  */\n  diagnostic_finalizer_fn end_diagnostic;\n\n  /* Client hook to report an internal error.  */\n  void (*internal_error) (const char *, va_list *);\n\n  /* Function of last diagnostic message; more generally, function such that\n     if next diagnostic message is in it then we don't have to mention the\n     function name.  */\n  tree last_function;\n\n  /* Used to detect when input_file_stack has changed since last described.  */\n  int last_module;\n\n  int lock;\n\n  /* Hook for front-end extensions.  */\n  void *x_data;\n};\n\n/* Client supplied function to announce a diagnostic.  */\n#define diagnostic_starter(DC) (DC)->begin_diagnostic\n\n/* Client supplied function called after a diagnostic message is\n   displayed.  */\n#define diagnostic_finalizer(DC) (DC)->end_diagnostic\n\n/* Extension hook for client.  */\n#define diagnostic_auxiliary_data(DC) (DC)->x_data\n\n/* Same as pp_format_decoder.  Works on 'diagnostic_context *'.  */\n#define diagnostic_format_decoder(DC) ((DC)->printer->format_decoder)\n\n/* Same as output_prefixing_rule.  Works on 'diagnostic_context *'.  */\n#define diagnostic_prefixing_rule(DC) ((DC)->printer->prefixing_rule)\n\n/* Maximum characters per line in automatic line wrapping mode.\n   Zero means don't wrap lines.  */\n#define diagnostic_line_cutoff(DC) ((DC)->printer->ideal_maximum_length)\n\n#define diagnostic_flush_buffer(DC) pp_base_flush ((DC)->printer)\n\n/* True if the last function in which a diagnostic was reported is\n   different from the current one.  */\n#define diagnostic_last_function_changed(DC) \\\n  ((DC)->last_function != current_function_decl)\n\n/* Remember the current function as being the last one in which we report\n   a diagnostic.  */\n#define diagnostic_set_last_function(DC) \\\n  (DC)->last_function = current_function_decl\n\n/* True if the last module or file in which a diagnostic was reported is\n   different from the current one.  */\n#define diagnostic_last_module_changed(DC) \\\n  ((DC)->last_module != input_file_stack_tick)\n\n/* Remember the current module or file as being the last one in which we\n   report a diagnostic.  */\n#define diagnostic_set_last_module(DC) \\\n  (DC)->last_module = input_file_stack_tick\n\n/* Raise SIGABRT on any diagnostic of severity DK_ERROR or higher.  */\n#define diagnostic_abort_on_error(DC) \\\n  (DC)->abort_on_error = true\n\n/* This diagnostic_context is used by front-ends that directly output\n   diagnostic messages without going through `error', `warning',\n   and similar functions.  */\nextern diagnostic_context *global_dc;\n\n/* The total count of a KIND of diagnostics emitted so far.  */\n#define diagnostic_kind_count(DC, DK) (DC)->diagnostic_count\u00dd(int) (DK)\u00a8\n\n/* The number of errors that have been issued so far.  Ideally, these\n   would take a diagnostic_context as an argument.  */\n#define errorcount diagnostic_kind_count (global_dc, DK_ERROR)\n/* Similarly, but for warnings.  */\n#define warningcount diagnostic_kind_count (global_dc, DK_WARNING)\n/* Similarly, but for sorrys.  */\n#define sorrycount diagnostic_kind_count (global_dc, DK_SORRY)\n\n/* Returns nonzero if warnings should be emitted.  */\n#define diagnostic_report_warnings_p()\t\t\t\\\n  (!inhibit_warnings\t\t\t\t\t\\\n   && !(in_system_header && !warn_system_headers))\n\n#define report_diagnostic(D) diagnostic_report_diagnostic (global_dc, D)\n\n/* Diagnostic related functions.  */\nextern void diagnostic_initialize (diagnostic_context *);\nextern void diagnostic_report_current_module (diagnostic_context *);\nextern void diagnostic_report_current_function (diagnostic_context *);\nextern void diagnostic_report_diagnostic (diagnostic_context *,\n\t\t\t\t\t  diagnostic_info *);\nextern void diagnostic_set_info (diagnostic_info *, const char *, va_list *,\n\t\t\t\t location_t, diagnostic_t);\nextern char *diagnostic_build_prefix (diagnostic_info *);\n\n/* Pure text formatting support functions.  */\nextern void verbatim (const char *, ...);\nextern char *file_name_as_prefix (const char *);\n\n#endif /* ! GCC_DIAGNOSTIC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF": {"ttr": 2564, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations and definitions of codes relating to the DWARF symbolic\n   debugging information format.\n\n   Written by Ron Guilmette (rfg@netcom.com)\n\nCopyright (C) 1992 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is derived from the DWARF specification (a public document)\n   Revision 1.0.1 (April 8, 1992) developed by the UNIX International\n   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n   by UNIX International.  Copies of this specification are available from\n   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n*/\n\n/* Tag names and codes.  */\n\nenum dwarf_tag {\n    TAG_padding\t\t\t= 0x0000,\n    TAG_array_type\t\t= 0x0001,\n    TAG_class_type\t\t= 0x0002,\n    TAG_entry_point\t\t= 0x0003,\n    TAG_enumeration_type\t= 0x0004,\n    TAG_formal_parameter\t= 0x0005,\n    TAG_global_subroutine\t= 0x0006,\n    TAG_global_variable\t\t= 0x0007,\n    \t\t\t\t/* 0x0008 -- reserved */\n\t\t\t\t/* 0x0009 -- reserved */\n    TAG_label\t\t\t= 0x000a,\n    TAG_lexical_block\t\t= 0x000b,\n    TAG_local_variable\t\t= 0x000c,\n    TAG_member\t\t\t= 0x000d,\n\t\t\t\t/* 0x000e -- reserved */\n    TAG_pointer_type\t\t= 0x000f,\n    TAG_reference_type\t\t= 0x0010,\n    TAG_compile_unit\t\t= 0x0011,\n    TAG_string_type\t\t= 0x0012,\n    TAG_structure_type\t\t= 0x0013,\n    TAG_subroutine\t\t= 0x0014,\n    TAG_subroutine_type\t\t= 0x0015,\n    TAG_typedef\t\t\t= 0x0016,\n    TAG_union_type\t\t= 0x0017,\n    TAG_unspecified_parameters\t= 0x0018,\n    TAG_variant\t\t\t= 0x0019,\n    TAG_common_block\t\t= 0x001a,\n    TAG_common_inclusion\t= 0x001b,\n    TAG_inheritance\t\t= 0x001c,\n    TAG_inlined_subroutine\t= 0x001d,\n    TAG_module\t\t\t= 0x001e,\n    TAG_ptr_to_member_type\t= 0x001f,\n    TAG_set_type\t\t= 0x0020,\n    TAG_subrange_type\t\t= 0x0021,\n    TAG_with_stmt\t\t= 0x0022,\n\n    /* GNU extensions */\n\n    TAG_format_label\t\t= 0x8000,  /* for FORTRAN 77 and Fortran 90 */\n    TAG_namelist\t\t= 0x8001,  /* For Fortran 90 */\n    TAG_function_template\t= 0x8002,  /* for C++ */\n    TAG_class_template\t\t= 0x8003   /* for C++ */\n};\n\n#define TAG_lo_user\t0x8000  /* implementation-defined range start */\n#define TAG_hi_user\t0xffff  /* implementation-defined range end */\n#define TAG_source_file TAG_compile_unit  /* for backward compatibility */\n\n/* Form names and codes.  */\n\nenum dwarf_form {\n    FORM_ADDR\t= 0x1,\n    FORM_REF\t= 0x2,\n    FORM_BLOCK2\t= 0x3,\n    FORM_BLOCK4\t= 0x4,\n    FORM_DATA2\t= 0x5,\n    FORM_DATA4\t= 0x6,\n    FORM_DATA8\t= 0x7,\n    FORM_STRING\t= 0x8\n};\n\n/* Attribute names and codes.  */\n\nenum dwarf_attribute {\n    AT_sibling\t\t\t= (0x0010|FORM_REF),\n    AT_location\t\t\t= (0x0020|FORM_BLOCK2),\n    AT_name\t\t\t= (0x0030|FORM_STRING),\n    AT_fund_type\t\t= (0x0050|FORM_DATA2),\n    AT_mod_fund_type\t\t= (0x0060|FORM_BLOCK2),\n    AT_user_def_type\t\t= (0x0070|FORM_REF),\n    AT_mod_u_d_type\t\t= (0x0080|FORM_BLOCK2),\n    AT_ordering\t\t\t= (0x0090|FORM_DATA2),\n    AT_subscr_data\t\t= (0x00a0|FORM_BLOCK2),\n    AT_byte_size\t\t= (0x00b0|FORM_DATA4),\n    AT_bit_offset\t\t= (0x00c0|FORM_DATA2),\n    AT_bit_size\t\t\t= (0x00d0|FORM_DATA4),\n\t\t\t\t/* (0x00e0|FORM_xxxx) -- reserved */\n    AT_element_list\t\t= (0x00f0|FORM_BLOCK4),\n    AT_stmt_list\t\t= (0x0100|FORM_DATA4),\n    AT_low_pc\t\t\t= (0x0110|FORM_ADDR),\n    AT_high_pc\t\t\t= (0x0120|FORM_ADDR),\n    AT_language\t\t\t= (0x0130|FORM_DATA4),\n    AT_member\t\t\t= (0x0140|FORM_REF),\n    AT_discr\t\t\t= (0x0150|FORM_REF),\n    AT_discr_value\t\t= (0x0160|FORM_BLOCK2),\n\t\t\t\t/* (0x0170|FORM_xxxx) -- reserved */\n\t\t\t\t/* (0x0180|FORM_xxxx) -- reserved */\n    AT_string_length\t\t= (0x0190|FORM_BLOCK2),\n    AT_common_reference\t\t= (0x01a0|FORM_REF),\n    AT_comp_dir\t\t\t= (0x01b0|FORM_STRING),\n        AT_const_value_string\t= (0x01c0|FORM_STRING),\n        AT_const_value_data2\t= (0x01c0|FORM_DATA2),\n        AT_const_value_data4\t= (0x01c0|FORM_DATA4),\n        AT_const_value_data8\t= (0x01c0|FORM_DATA8),\n        AT_const_value_block2\t= (0x01c0|FORM_BLOCK2),\n        AT_const_value_block4\t= (0x01c0|FORM_BLOCK4),\n    AT_containing_type\t\t= (0x01d0|FORM_REF),\n        AT_default_value_addr\t= (0x01e0|FORM_ADDR),\n        AT_default_value_data2\t= (0x01e0|FORM_DATA2),\n        AT_default_value_data4\t= (0x01e0|FORM_DATA4),\n        AT_default_value_data8\t= (0x01e0|FORM_DATA8),\n        AT_default_value_string\t= (0x01e0|FORM_STRING),\n    AT_friends\t\t\t= (0x01f0|FORM_BLOCK2),\n    AT_inline\t\t\t= (0x0200|FORM_STRING),\n    AT_is_optional\t\t= (0x0210|FORM_STRING),\n        AT_lower_bound_ref\t= (0x0220|FORM_REF),\n        AT_lower_bound_data2\t= (0x0220|FORM_DATA2),\n        AT_lower_bound_data4\t= (0x0220|FORM_DATA4),\n        AT_lower_bound_data8\t= (0x0220|FORM_DATA8),\n    AT_private\t\t\t= (0x0240|FORM_STRING),\n    AT_producer\t\t\t= (0x0250|FORM_STRING),\n    AT_program\t\t\t= (0x0230|FORM_STRING),\n    AT_protected\t\t= (0x0260|FORM_STRING),\n    AT_prototyped\t\t= (0x0270|FORM_STRING),\n    AT_public\t\t\t= (0x0280|FORM_STRING),\n    AT_pure_virtual\t\t= (0x0290|FORM_STRING),\n    AT_return_addr\t\t= (0x02a0|FORM_BLOCK2),\n    AT_abstract_origin\t\t= (0x02b0|FORM_REF),\n    AT_start_scope\t\t= (0x02c0|FORM_DATA4),\n    AT_stride_size\t\t= (0x02e0|FORM_DATA4),\n        AT_upper_bound_ref\t= (0x02f0|FORM_REF),\n        AT_upper_bound_data2\t= (0x02f0|FORM_DATA2),\n        AT_upper_bound_data4\t= (0x02f0|FORM_DATA4),\n        AT_upper_bound_data8\t= (0x02f0|FORM_DATA8),\n    AT_virtual\t\t\t= (0x0300|FORM_STRING),\n\n    /* GNU extensions.  */\n\n    AT_sf_names\t\t\t= (0x8000|FORM_DATA4),\n    AT_src_info\t\t\t= (0x8010|FORM_DATA4),\n    AT_mac_info\t\t\t= (0x8020|FORM_DATA4),\n    AT_src_coords\t\t= (0x8030|FORM_DATA4),\n    AT_body_begin\t\t= (0x8040|FORM_ADDR),\n    AT_body_end\t\t\t= (0x8050|FORM_ADDR)\n};\n\n#define AT_lo_user\t0x2000\t/* implementation-defined range start */\n#define AT_hi_user\t0x3ff0\t/* implementation-defined range end */\n\n/* Location atom names and codes.  */\n\nenum dwarf_location_atom {\n    OP_REG\t= 0x01,\n    OP_BASEREG\t= 0x02,\n    OP_ADDR\t= 0x03,\n    OP_CONST\t= 0x04,\n    OP_DEREF2\t= 0x05,\n    OP_DEREF4\t= 0x06,\n    OP_ADD\t= 0x07,\n\n    /* GNU extensions.  */\n\n    OP_MULT\t= 0x80\n};\n\n#define OP_LO_USER\t0x80  /* implementation-defined range start */\n#define OP_HI_USER\t0xff  /* implementation-defined range end */\n\n/* Fundamental type names and codes.  */\n\nenum dwarf_fundamental_type {\n    FT_char\t\t= 0x0001,\n    FT_signed_char\t= 0x0002,\n    FT_unsigned_char\t= 0x0003,\n    FT_short\t\t= 0x0004,\n    FT_signed_short\t= 0x0005,\n    FT_unsigned_short\t= 0x0006,\n    FT_integer\t\t= 0x0007,\n    FT_signed_integer\t= 0x0008,\n    FT_unsigned_integer\t= 0x0009,\n    FT_long\t\t= 0x000a,\n    FT_signed_long\t= 0x000b,\n    FT_unsigned_long\t= 0x000c,\n    FT_pointer\t\t= 0x000d,  /* an alias for (void *) */\n    FT_float\t\t= 0x000e,\n    FT_dbl_prec_float\t= 0x000f,\n    FT_ext_prec_float\t= 0x0010,  /* breaks \"classic\" svr4 SDB */\n    FT_complex\t\t= 0x0011,  /* breaks \"classic\" svr4 SDB */\n    FT_dbl_prec_complex\t= 0x0012,  /* breaks \"classic\" svr4 SDB */\n\t\t\t/* 0x0013 -- reserved */\n    FT_void\t\t= 0x0014,\n    FT_boolean\t\t= 0x0015,  /* breaks \"classic\" svr4 SDB */\n    FT_ext_prec_complex\t= 0x0016,  /* breaks \"classic\" svr4 SDB */\n    FT_label\t\t= 0x0017,\n\n    /* GNU extensions\n       The low order byte must indicate the size (in bytes) for the type.\n       All of these types will probably break \"classic\" svr4 SDB */\n\n    FT_long_long\t= 0x8008,\n    FT_signed_long_long\t= 0x8108,\n    FT_unsigned_long_long = 0x8208,\n\n    FT_int8\t\t= 0x9001,\n    FT_signed_int8\t= 0x9101,\n    FT_unsigned_int8\t= 0x9201,\n    FT_int16\t\t= 0x9302,\n    FT_signed_int16\t= 0x9402,\n    FT_unsigned_int16\t= 0x9502,\n    FT_int32\t\t= 0x9604,\n    FT_signed_int32\t= 0x9704,\n    FT_unsigned_int32\t= 0x9804,\n    FT_int64\t\t= 0x9908,\n    FT_signed_int64\t= 0x9a08,\n    FT_unsigned_int64\t= 0x9b08,\n    FT_int128\t\t= 0x9c10,\n    FT_signed_int128\t= 0x9d10,\n    FT_unsigned_int128\t= 0x9e10,\n\n    FT_real32\t\t= 0xa004,\n    FT_real64\t\t= 0xa108,\n    FT_real96\t\t= 0xa20c,\n    FT_real128\t\t= 0xa310\n};\n\n#define FT_lo_user\t0x8000  /* implementation-defined range start */\n#define FT_hi_user\t0xffff  /* implementation defined range end */\n\n/* Type modifier names and codes.  */\n\nenum dwarf_type_modifier {\n    MOD_pointer_to\t= 0x01,\n    MOD_reference_to\t= 0x02,\n    MOD_const\t\t= 0x03,\n    MOD_volatile\t= 0x04\n};\n\n#define MOD_lo_user\t0x80  /* implementation-defined range start */\n#define MOD_hi_user\t0xff  /* implementation-defined range end */\n\n/* Array ordering names and codes.  */\n\nenum dwarf_array_dim_ordering {\n    ORD_row_major\t= 0,\n    ORD_col_major\t= 1\n};\n\n/* Array subscript format names and codes.  */\n\nenum dwarf_subscr_data_formats {\n    FMT_FT_C_C\t= 0x0,\n    FMT_FT_C_X\t= 0x1,\n    FMT_FT_X_C\t= 0x2,\n    FMT_FT_X_X\t= 0x3,\n    FMT_UT_C_C\t= 0x4,\n    FMT_UT_C_X\t= 0x5,\n    FMT_UT_X_C\t= 0x6,\n    FMT_UT_X_X\t= 0x7,\n    FMT_ET\t= 0x8\n};\n\n/* Derived from above for ease of use.  */\n\n#define FMT_CODE(_FUNDAMENTAL_TYPE_P, _LB_CONST_P, _UB_CONST_P) \\\n (((_FUNDAMENTAL_TYPE_P) ? 0 : 4)\t\\\n  | ((_LB_CONST_P) ? 0 : 2)\t\t\\\n  | ((_UB_CONST_P) ? 0 : 1))\n\n/* Source language names and codes.  */\n\nenum dwarf_source_language {\n    LANG_C89\t\t= 0x00000001,\n    LANG_C\t\t= 0x00000002,\n    LANG_ADA83\t\t= 0x00000003,\n    LANG_C_PLUS_PLUS\t= 0x00000004,\n    LANG_COBOL74\t= 0x00000005,\n    LANG_COBOL85\t= 0x00000006,\n    LANG_FORTRAN77\t= 0x00000007,\n    LANG_FORTRAN90\t= 0x00000008,\n    LANG_PASCAL83\t= 0x00000009,\n    LANG_MODULA2\t= 0x0000000a,\n    LANG_JAVA\t\t= 0x0000000b\n};\n\n#define LANG_lo_user\t0x00008000  /* implementation-defined range start */\n#define LANG_hi_user\t0x0000ffff  /* implementation-defined range end */\n\n/* Names and codes for GNU \"macinfo\" extension.  */\n\nenum dwarf_macinfo_record_type {\n    MACINFO_start\t= 's',\n    MACINFO_resume\t= 'r',\n    MACINFO_define\t= 'd',\n    MACINFO_undef\t= 'u'\n};\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2": {"ttr": 2567, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations and definitions of codes relating to the DWARF2 symbolic\n   debugging information format.\n   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n\n   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n   Office (AJPO), Florida State University and Silicon Graphics Inc.\n   provided support for this effort -- June 21, 1995.\n\n   Derived from the DWARF 1 implementation written by Ron Guilmette\n   (rfg@netcom.com), November 1990.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is derived from the DWARF specification (a public document)\n   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n   by UNIX International.  Copies of this specification are available from\n   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n\n   This file also now contains definitions from the DWARF 3 specification.  */\n\n/* This file is shared between GCC and GDB, and should not contain\n   prototypes.  */\n\n#ifndef GCC_DWARF2_H\n#define GCC_DWARF2_H\n\n/* Tag names and codes.  */\nenum dwarf_tag\n  {\n    DW_TAG_padding = 0x00,\n    DW_TAG_array_type = 0x01,\n    DW_TAG_class_type = 0x02,\n    DW_TAG_entry_point = 0x03,\n    DW_TAG_enumeration_type = 0x04,\n    DW_TAG_formal_parameter = 0x05,\n    DW_TAG_imported_declaration = 0x08,\n    DW_TAG_label = 0x0a,\n    DW_TAG_lexical_block = 0x0b,\n    DW_TAG_member = 0x0d,\n    DW_TAG_pointer_type = 0x0f,\n    DW_TAG_reference_type = 0x10,\n    DW_TAG_compile_unit = 0x11,\n    DW_TAG_string_type = 0x12,\n    DW_TAG_structure_type = 0x13,\n    DW_TAG_subroutine_type = 0x15,\n    DW_TAG_typedef = 0x16,\n    DW_TAG_union_type = 0x17,\n    DW_TAG_unspecified_parameters = 0x18,\n    DW_TAG_variant = 0x19,\n    DW_TAG_common_block = 0x1a,\n    DW_TAG_common_inclusion = 0x1b,\n    DW_TAG_inheritance = 0x1c,\n    DW_TAG_inlined_subroutine = 0x1d,\n    DW_TAG_module = 0x1e,\n    DW_TAG_ptr_to_member_type = 0x1f,\n    DW_TAG_set_type = 0x20,\n    DW_TAG_subrange_type = 0x21,\n    DW_TAG_with_stmt = 0x22,\n    DW_TAG_access_declaration = 0x23,\n    DW_TAG_base_type = 0x24,\n    DW_TAG_catch_block = 0x25,\n    DW_TAG_const_type = 0x26,\n    DW_TAG_constant = 0x27,\n    DW_TAG_enumerator = 0x28,\n    DW_TAG_file_type = 0x29,\n    DW_TAG_friend = 0x2a,\n    DW_TAG_namelist = 0x2b,\n    DW_TAG_namelist_item = 0x2c,\n    DW_TAG_packed_type = 0x2d,\n    DW_TAG_subprogram = 0x2e,\n    DW_TAG_template_type_param = 0x2f,\n    DW_TAG_template_value_param = 0x30,\n    DW_TAG_thrown_type = 0x31,\n    DW_TAG_try_block = 0x32,\n    DW_TAG_variant_part = 0x33,\n    DW_TAG_variable = 0x34,\n    DW_TAG_volatile_type = 0x35,\n    /* DWARF 3.  */\n    DW_TAG_dwarf_procedure = 0x36,\n    DW_TAG_restrict_type = 0x37,\n    DW_TAG_interface_type = 0x38,\n    DW_TAG_namespace = 0x39,\n    DW_TAG_imported_module = 0x3a,\n    DW_TAG_unspecified_type = 0x3b,\n    DW_TAG_partial_unit = 0x3c,\n    DW_TAG_imported_unit = 0x3d,\n    /* SGI/MIPS Extensions.  */\n    DW_TAG_MIPS_loop = 0x4081,\n    /* GNU extensions.  */\n    DW_TAG_format_label = 0x4101,\t/* For FORTRAN 77 and Fortran 90.  */\n    DW_TAG_function_template = 0x4102,\t/* For C++.  */\n    DW_TAG_class_template = 0x4103,\t/* For C++.  */\n    DW_TAG_GNU_BINCL = 0x4104,\n    DW_TAG_GNU_EINCL = 0x4105\n  };\n\n#define DW_TAG_lo_user\t0x4080\n#define DW_TAG_hi_user\t0xffff\n\n/* Flag that tells whether entry has a child or not.  */\n#define DW_children_no   0\n#define\tDW_children_yes  1\n\n/* Form names and codes.  */\nenum dwarf_form\n  {\n    DW_FORM_addr = 0x01,\n    DW_FORM_block2 = 0x03,\n    DW_FORM_block4 = 0x04,\n    DW_FORM_data2 = 0x05,\n    DW_FORM_data4 = 0x06,\n    DW_FORM_data8 = 0x07,\n    DW_FORM_string = 0x08,\n    DW_FORM_block = 0x09,\n    DW_FORM_block1 = 0x0a,\n    DW_FORM_data1 = 0x0b,\n    DW_FORM_flag = 0x0c,\n    DW_FORM_sdata = 0x0d,\n    DW_FORM_strp = 0x0e,\n    DW_FORM_udata = 0x0f,\n    DW_FORM_ref_addr = 0x10,\n    DW_FORM_ref1 = 0x11,\n    DW_FORM_ref2 = 0x12,\n    DW_FORM_ref4 = 0x13,\n    DW_FORM_ref8 = 0x14,\n    DW_FORM_ref_udata = 0x15,\n    DW_FORM_indirect = 0x16\n  };\n\n/* Attribute names and codes.  */\n\nenum dwarf_attribute\n  {\n    DW_AT_sibling = 0x01,\n    DW_AT_location = 0x02,\n    DW_AT_name = 0x03,\n    DW_AT_ordering = 0x09,\n    DW_AT_subscr_data = 0x0a,\n    DW_AT_byte_size = 0x0b,\n    DW_AT_bit_offset = 0x0c,\n    DW_AT_bit_size = 0x0d,\n    DW_AT_element_list = 0x0f,\n    DW_AT_stmt_list = 0x10,\n    DW_AT_low_pc = 0x11,\n    DW_AT_high_pc = 0x12,\n    DW_AT_language = 0x13,\n    DW_AT_member = 0x14,\n    DW_AT_discr = 0x15,\n    DW_AT_discr_value = 0x16,\n    DW_AT_visibility = 0x17,\n    DW_AT_import = 0x18,\n    DW_AT_string_length = 0x19,\n    DW_AT_common_reference = 0x1a,\n    DW_AT_comp_dir = 0x1b,\n    DW_AT_const_value = 0x1c,\n    DW_AT_containing_type = 0x1d,\n    DW_AT_default_value = 0x1e,\n    DW_AT_inline = 0x20,\n    DW_AT_is_optional = 0x21,\n    DW_AT_lower_bound = 0x22,\n    DW_AT_producer = 0x25,\n    DW_AT_prototyped = 0x27,\n    DW_AT_return_addr = 0x2a,\n    DW_AT_start_scope = 0x2c,\n    DW_AT_stride_size = 0x2e,\n    DW_AT_upper_bound = 0x2f,\n    DW_AT_abstract_origin = 0x31,\n    DW_AT_accessibility = 0x32,\n    DW_AT_address_class = 0x33,\n    DW_AT_artificial = 0x34,\n    DW_AT_base_types = 0x35,\n    DW_AT_calling_convention = 0x36,\n    DW_AT_count = 0x37,\n    DW_AT_data_member_location = 0x38,\n    DW_AT_decl_column = 0x39,\n    DW_AT_decl_file = 0x3a,\n    DW_AT_decl_line = 0x3b,\n    DW_AT_declaration = 0x3c,\n    DW_AT_discr_list = 0x3d,\n    DW_AT_encoding = 0x3e,\n    DW_AT_external = 0x3f,\n    DW_AT_frame_base = 0x40,\n    DW_AT_friend = 0x41,\n    DW_AT_identifier_case = 0x42,\n    DW_AT_macro_info = 0x43,\n    DW_AT_namelist_items = 0x44,\n    DW_AT_priority = 0x45,\n    DW_AT_segment = 0x46,\n    DW_AT_specification = 0x47,\n    DW_AT_static_link = 0x48,\n    DW_AT_type = 0x49,\n    DW_AT_use_location = 0x4a,\n    DW_AT_variable_parameter = 0x4b,\n    DW_AT_virtuality = 0x4c,\n    DW_AT_vtable_elem_location = 0x4d,\n    /* DWARF 3 values.  */\n    DW_AT_allocated     = 0x4e,\n    DW_AT_associated    = 0x4f,\n    DW_AT_data_location = 0x50,\n    DW_AT_stride        = 0x51,\n    DW_AT_entry_pc      = 0x52,\n    DW_AT_use_UTF8      = 0x53,\n    DW_AT_extension     = 0x54,\n    DW_AT_ranges        = 0x55,\n    DW_AT_trampoline    = 0x56,\n    DW_AT_call_column   = 0x57,\n    DW_AT_call_file     = 0x58,\n    DW_AT_call_line     = 0x59,\n    /* SGI/MIPS Extensions.  */\n    DW_AT_MIPS_fde = 0x2001,\n    DW_AT_MIPS_loop_begin = 0x2002,\n    DW_AT_MIPS_tail_loop_begin = 0x2003,\n    DW_AT_MIPS_epilog_begin = 0x2004,\n    DW_AT_MIPS_loop_unroll_factor = 0x2005,\n    DW_AT_MIPS_software_pipeline_depth = 0x2006,\n    DW_AT_MIPS_linkage_name = 0x2007,\n    DW_AT_MIPS_stride = 0x2008,\n    DW_AT_MIPS_abstract_name = 0x2009,\n    DW_AT_MIPS_clone_origin = 0x200a,\n    DW_AT_MIPS_has_inlines = 0x200b,\n    /* GNU extensions.  */\n    DW_AT_sf_names   = 0x2101,\n    DW_AT_src_info   = 0x2102,\n    DW_AT_mac_info   = 0x2103,\n    DW_AT_src_coords = 0x2104,\n    DW_AT_body_begin = 0x2105,\n    DW_AT_body_end   = 0x2106,\n    DW_AT_GNU_vector = 0x2107,\n    /* VMS Extensions.  */\n    DW_AT_VMS_rtnbeg_pd_address = 0x2201\n  };\n\n#define DW_AT_lo_user\t0x2000\t/* Implementation-defined range start.  */\n#define DW_AT_hi_user\t0x3ff0\t/* Implementation-defined range end.  */\n\n/* Location atom names and codes.  */\nenum dwarf_location_atom\n  {\n    DW_OP_addr = 0x03,\n    DW_OP_deref = 0x06,\n    DW_OP_const1u = 0x08,\n    DW_OP_const1s = 0x09,\n    DW_OP_const2u = 0x0a,\n    DW_OP_const2s = 0x0b,\n    DW_OP_const4u = 0x0c,\n    DW_OP_const4s = 0x0d,\n    DW_OP_const8u = 0x0e,\n    DW_OP_const8s = 0x0f,\n    DW_OP_constu = 0x10,\n    DW_OP_consts = 0x11,\n    DW_OP_dup = 0x12,\n    DW_OP_drop = 0x13,\n    DW_OP_over = 0x14,\n    DW_OP_pick = 0x15,\n    DW_OP_swap = 0x16,\n    DW_OP_rot = 0x17,\n    DW_OP_xderef = 0x18,\n    DW_OP_abs = 0x19,\n    DW_OP_and = 0x1a,\n    DW_OP_div = 0x1b,\n    DW_OP_minus = 0x1c,\n    DW_OP_mod = 0x1d,\n    DW_OP_mul = 0x1e,\n    DW_OP_neg = 0x1f,\n    DW_OP_not = 0x20,\n    DW_OP_or = 0x21,\n    DW_OP_plus = 0x22,\n    DW_OP_plus_uconst = 0x23,\n    DW_OP_shl = 0x24,\n    DW_OP_shr = 0x25,\n    DW_OP_shra = 0x26,\n    DW_OP_xor = 0x27,\n    DW_OP_bra = 0x28,\n    DW_OP_eq = 0x29,\n    DW_OP_ge = 0x2a,\n    DW_OP_gt = 0x2b,\n    DW_OP_le = 0x2c,\n    DW_OP_lt = 0x2d,\n    DW_OP_ne = 0x2e,\n    DW_OP_skip = 0x2f,\n    DW_OP_lit0 = 0x30,\n    DW_OP_lit1 = 0x31,\n    DW_OP_lit2 = 0x32,\n    DW_OP_lit3 = 0x33,\n    DW_OP_lit4 = 0x34,\n    DW_OP_lit5 = 0x35,\n    DW_OP_lit6 = 0x36,\n    DW_OP_lit7 = 0x37,\n    DW_OP_lit8 = 0x38,\n    DW_OP_lit9 = 0x39,\n    DW_OP_lit10 = 0x3a,\n    DW_OP_lit11 = 0x3b,\n    DW_OP_lit12 = 0x3c,\n    DW_OP_lit13 = 0x3d,\n    DW_OP_lit14 = 0x3e,\n    DW_OP_lit15 = 0x3f,\n    DW_OP_lit16 = 0x40,\n    DW_OP_lit17 = 0x41,\n    DW_OP_lit18 = 0x42,\n    DW_OP_lit19 = 0x43,\n    DW_OP_lit20 = 0x44,\n    DW_OP_lit21 = 0x45,\n    DW_OP_lit22 = 0x46,\n    DW_OP_lit23 = 0x47,\n    DW_OP_lit24 = 0x48,\n    DW_OP_lit25 = 0x49,\n    DW_OP_lit26 = 0x4a,\n    DW_OP_lit27 = 0x4b,\n    DW_OP_lit28 = 0x4c,\n    DW_OP_lit29 = 0x4d,\n    DW_OP_lit30 = 0x4e,\n    DW_OP_lit31 = 0x4f,\n    DW_OP_reg0 = 0x50,\n    DW_OP_reg1 = 0x51,\n    DW_OP_reg2 = 0x52,\n    DW_OP_reg3 = 0x53,\n    DW_OP_reg4 = 0x54,\n    DW_OP_reg5 = 0x55,\n    DW_OP_reg6 = 0x56,\n    DW_OP_reg7 = 0x57,\n    DW_OP_reg8 = 0x58,\n    DW_OP_reg9 = 0x59,\n    DW_OP_reg10 = 0x5a,\n    DW_OP_reg11 = 0x5b,\n    DW_OP_reg12 = 0x5c,\n    DW_OP_reg13 = 0x5d,\n    DW_OP_reg14 = 0x5e,\n    DW_OP_reg15 = 0x5f,\n    DW_OP_reg16 = 0x60,\n    DW_OP_reg17 = 0x61,\n    DW_OP_reg18 = 0x62,\n    DW_OP_reg19 = 0x63,\n    DW_OP_reg20 = 0x64,\n    DW_OP_reg21 = 0x65,\n    DW_OP_reg22 = 0x66,\n    DW_OP_reg23 = 0x67,\n    DW_OP_reg24 = 0x68,\n    DW_OP_reg25 = 0x69,\n    DW_OP_reg26 = 0x6a,\n    DW_OP_reg27 = 0x6b,\n    DW_OP_reg28 = 0x6c,\n    DW_OP_reg29 = 0x6d,\n    DW_OP_reg30 = 0x6e,\n    DW_OP_reg31 = 0x6f,\n    DW_OP_breg0 = 0x70,\n    DW_OP_breg1 = 0x71,\n    DW_OP_breg2 = 0x72,\n    DW_OP_breg3 = 0x73,\n    DW_OP_breg4 = 0x74,\n    DW_OP_breg5 = 0x75,\n    DW_OP_breg6 = 0x76,\n    DW_OP_breg7 = 0x77,\n    DW_OP_breg8 = 0x78,\n    DW_OP_breg9 = 0x79,\n    DW_OP_breg10 = 0x7a,\n    DW_OP_breg11 = 0x7b,\n    DW_OP_breg12 = 0x7c,\n    DW_OP_breg13 = 0x7d,\n    DW_OP_breg14 = 0x7e,\n    DW_OP_breg15 = 0x7f,\n    DW_OP_breg16 = 0x80,\n    DW_OP_breg17 = 0x81,\n    DW_OP_breg18 = 0x82,\n    DW_OP_breg19 = 0x83,\n    DW_OP_breg20 = 0x84,\n    DW_OP_breg21 = 0x85,\n    DW_OP_breg22 = 0x86,\n    DW_OP_breg23 = 0x87,\n    DW_OP_breg24 = 0x88,\n    DW_OP_breg25 = 0x89,\n    DW_OP_breg26 = 0x8a,\n    DW_OP_breg27 = 0x8b,\n    DW_OP_breg28 = 0x8c,\n    DW_OP_breg29 = 0x8d,\n    DW_OP_breg30 = 0x8e,\n    DW_OP_breg31 = 0x8f,\n    DW_OP_regx = 0x90,\n    DW_OP_fbreg = 0x91,\n    DW_OP_bregx = 0x92,\n    DW_OP_piece = 0x93,\n    DW_OP_deref_size = 0x94,\n    DW_OP_xderef_size = 0x95,\n    DW_OP_nop = 0x96,\n    /* DWARF 3 extensions.  */\n    DW_OP_push_object_address = 0x97,\n    DW_OP_call2 = 0x98,\n    DW_OP_call4 = 0x99,\n    DW_OP_call_ref = 0x9a,\n    /* GNU extensions.  */\n    DW_OP_GNU_push_tls_address = 0xe0\n  };\n\n#define DW_OP_lo_user\t0xe0\t/* Implementation-defined range start.  */\n#define DW_OP_hi_user\t0xff\t/* Implementation-defined range end.  */\n\n/* Type encodings.  */\nenum dwarf_type\n  {\n    DW_ATE_void = 0x0,\n    DW_ATE_address = 0x1,\n    DW_ATE_boolean = 0x2,\n    DW_ATE_complex_float = 0x3,\n    DW_ATE_float = 0x4,\n    DW_ATE_signed = 0x5,\n    DW_ATE_signed_char = 0x6,\n    DW_ATE_unsigned = 0x7,\n    DW_ATE_unsigned_char = 0x8,\n    /* DWARF 3.  */\n    DW_ATE_imaginary_float = 0x9\n  };\n\n#define\tDW_ATE_lo_user 0x80\n#define\tDW_ATE_hi_user 0xff\n\n/* Array ordering names and codes.  */\nenum dwarf_array_dim_ordering\n  {\n    DW_ORD_row_major = 0,\n    DW_ORD_col_major = 1\n  };\n\n/* Access attribute.  */\nenum dwarf_access_attribute\n  {\n    DW_ACCESS_public = 1,\n    DW_ACCESS_protected = 2,\n    DW_ACCESS_private = 3\n  };\n\n/* Visibility.  */\nenum dwarf_visibility_attribute\n  {\n    DW_VIS_local = 1,\n    DW_VIS_exported = 2,\n    DW_VIS_qualified = 3\n  };\n\n/* Virtuality.  */\nenum dwarf_virtuality_attribute\n  {\n    DW_VIRTUALITY_none = 0,\n    DW_VIRTUALITY_virtual = 1,\n    DW_VIRTUALITY_pure_virtual = 2\n  };\n\n/* Case sensitivity.  */\nenum dwarf_id_case\n  {\n    DW_ID_case_sensitive = 0,\n    DW_ID_up_case = 1,\n    DW_ID_down_case = 2,\n    DW_ID_case_insensitive = 3\n  };\n\n/* Calling convention.  */\nenum dwarf_calling_convention\n  {\n    DW_CC_normal = 0x1,\n    DW_CC_program = 0x2,\n    DW_CC_nocall = 0x3\n  };\n\n#define DW_CC_lo_user 0x40\n#define DW_CC_hi_user 0xff\n\n/* Inline attribute.  */\nenum dwarf_inline_attribute\n  {\n    DW_INL_not_inlined = 0,\n    DW_INL_inlined = 1,\n    DW_INL_declared_not_inlined = 2,\n    DW_INL_declared_inlined = 3\n  };\n\n/* Discriminant lists.  */\nenum dwarf_discrim_list\n  {\n    DW_DSC_label = 0,\n    DW_DSC_range = 1\n  };\n\n/* Line number opcodes.  */\nenum dwarf_line_number_ops\n  {\n    DW_LNS_extended_op = 0,\n    DW_LNS_copy = 1,\n    DW_LNS_advance_pc = 2,\n    DW_LNS_advance_line = 3,\n    DW_LNS_set_file = 4,\n    DW_LNS_set_column = 5,\n    DW_LNS_negate_stmt = 6,\n    DW_LNS_set_basic_block = 7,\n    DW_LNS_const_add_pc = 8,\n    DW_LNS_fixed_advance_pc = 9,\n    /* DWARF 3.  */\n    DW_LNS_set_prologue_end = 10,\n    DW_LNS_set_epilogue_begin = 11,\n    DW_LNS_set_isa = 12\n  };\n\n/* Line number extended opcodes.  */\nenum dwarf_line_number_x_ops\n  {\n    DW_LNE_end_sequence = 1,\n    DW_LNE_set_address = 2,\n    DW_LNE_define_file = 3\n  };\n\n/* Call frame information.  */\nenum dwarf_call_frame_info\n  {\n    DW_CFA_advance_loc = 0x40,\n    DW_CFA_offset = 0x80,\n    DW_CFA_restore = 0xc0,\n    DW_CFA_nop = 0x00,\n    DW_CFA_set_loc = 0x01,\n    DW_CFA_advance_loc1 = 0x02,\n    DW_CFA_advance_loc2 = 0x03,\n    DW_CFA_advance_loc4 = 0x04,\n    DW_CFA_offset_extended = 0x05,\n    DW_CFA_restore_extended = 0x06,\n    DW_CFA_undefined = 0x07,\n    DW_CFA_same_value = 0x08,\n    DW_CFA_register = 0x09,\n    DW_CFA_remember_state = 0x0a,\n    DW_CFA_restore_state = 0x0b,\n    DW_CFA_def_cfa = 0x0c,\n    DW_CFA_def_cfa_register = 0x0d,\n    DW_CFA_def_cfa_offset = 0x0e,\n\n    /* DWARF 3.  */\n    DW_CFA_def_cfa_expression = 0x0f,\n    DW_CFA_expression = 0x10,\n    DW_CFA_offset_extended_sf = 0x11,\n    DW_CFA_def_cfa_sf = 0x12,\n    DW_CFA_def_cfa_offset_sf = 0x13,\n\n    /* SGI/MIPS specific.  */\n    DW_CFA_MIPS_advance_loc8 = 0x1d,\n\n    /* GNU extensions.  */\n    DW_CFA_GNU_window_save = 0x2d,\n    DW_CFA_GNU_args_size = 0x2e,\n    DW_CFA_GNU_negative_offset_extended = 0x2f\n  };\n\n#define DW_CIE_ID\t  0xffffffff\n#define DW_CIE_VERSION\t  1\n\n#define DW_CFA_extended   0\n#define DW_CFA_low_user   0x1c\n#define DW_CFA_high_user  0x3f\n\n#define DW_CHILDREN_no\t\t     0x00\n#define DW_CHILDREN_yes\t\t     0x01\n\n#define DW_ADDR_none\t\t0\n\n/* Source language names and codes.  */\nenum dwarf_source_language\n  {\n    DW_LANG_C89 = 0x0001,\n    DW_LANG_C = 0x0002,\n    DW_LANG_Ada83 = 0x0003,\n    DW_LANG_C_plus_plus = 0x0004,\n    DW_LANG_Cobol74 = 0x0005,\n    DW_LANG_Cobol85 = 0x0006,\n    DW_LANG_Fortran77 = 0x0007,\n    DW_LANG_Fortran90 = 0x0008,\n    DW_LANG_Pascal83 = 0x0009,\n    DW_LANG_Modula2 = 0x000a,\n    DW_LANG_Java = 0x000b,\n    /* DWARF 3.  */\n    DW_LANG_C99 = 0x000c,\n    DW_LANG_Ada95 = 0x000d,\n    DW_LANG_Fortran95 = 0x000e,\n    /* MIPS.  */\n    DW_LANG_Mips_Assembler = 0x8001\n  };\n\n\n#define DW_LANG_lo_user 0x8000\t/* Implementation-defined range start.  */\n#define DW_LANG_hi_user 0xffff\t/* Implementation-defined range start.  */\n\n/* Names and codes for macro information.  */\nenum dwarf_macinfo_record_type\n  {\n    DW_MACINFO_define = 1,\n    DW_MACINFO_undef = 2,\n    DW_MACINFO_start_file = 3,\n    DW_MACINFO_end_file = 4,\n    DW_MACINFO_vendor_ext = 255\n  };\n\n/* @@@ For use with GNU frame unwind information.  */\n\n#define DW_EH_PE_absptr\t\t0x00\n#define DW_EH_PE_omit\t\t0xff\n\n#define DW_EH_PE_uleb128\t0x01\n#define DW_EH_PE_udata2\t\t0x02\n#define DW_EH_PE_udata4\t\t0x03\n#define DW_EH_PE_udata8\t\t0x04\n#define DW_EH_PE_sleb128\t0x09\n#define DW_EH_PE_sdata2\t\t0x0A\n#define DW_EH_PE_sdata4\t\t0x0B\n#define DW_EH_PE_sdata8\t\t0x0C\n#define DW_EH_PE_signed\t\t0x08\n\n#define DW_EH_PE_pcrel\t\t0x10\n#define DW_EH_PE_textrel\t0x20\n#define DW_EH_PE_datarel\t0x30\n#define DW_EH_PE_funcrel\t0x40\n#define DW_EH_PE_aligned\t0x50\n\n#define DW_EH_PE_indirect\t0x80\n\n#endif /* dwarf2.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2AS": {"ttr": 2572, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Dwarf2 assembler output helper routines.\n   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\nextern void dw2_assemble_integer (int, rtx);\n\nextern void dw2_asm_output_data (int, unsigned HOST_WIDE_INT,\n\t\t\t\t const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_delta (int, const char *, const char *,\n\t\t\t\t  const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_4;\n\nextern void dw2_asm_output_offset (int, const char *, const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_pcrel (int, const char *, const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_addr (int, const char *, const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_addr_rtx (int, rtx, const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_encoded_addr_rtx (int, rtx,\n\t\t\t\t\t     const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_nstring (const char *, size_t,\n\t\t\t\t    const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_data_uleb128\t(unsigned HOST_WIDE_INT,\n\t\t\t\t\t const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_2;\n\nextern void dw2_asm_output_data_sleb128\t(HOST_WIDE_INT,\n\t\t\t\t\t const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_2;\n\nextern void dw2_asm_output_delta_uleb128 (const char *, const char *,\n\t\t\t\t\t  const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern void dw2_asm_output_delta_sleb128 (const char *, const char *,\n\t\t\t\t\t  const char *, ...)\n     ATTRIBUTE_NULL_PRINTF_3;\n\nextern int size_of_uleb128 (unsigned HOST_WIDE_INT);\nextern int size_of_sleb128 (HOST_WIDE_INT);\nextern int size_of_encoded_value (int);\nextern const char *eh_data_format_name (int);\n\nextern void dw2_output_indirect_constants (void);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DWARF2OU": {"ttr": 2574, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* dwarf2out.h - Various declarations for functions found in dwarf2out.c\n   Copyright (C) 1998, 1999, 2000, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern void dwarf2out_decl (tree);\nextern void dwarf2out_frame_debug (rtx);\n\nextern void debug_dwarf (void);\nstruct die_struct;\nextern void debug_dwarf_die (struct die_struct *);\nextern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\nextern void dwarf2out_add_library_unit_info (const char *, const char *);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DYN@STRI": {"ttr": 2576, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* An abstract string datatype.\n   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell (mark@markmitchell.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\ntypedef struct dyn_string\n{\n  int allocated;\t/* The amount of space allocated for the string.  */\n  int length;\t\t/* The actual length of the string.  */\n  char *s;\t\t/* The string itself, NUL-terminated.  */\n}* dyn_string_t;\n\n/* The length STR, in bytes, not including the terminating NUL.  */\n#define dyn_string_length(STR)                                          \\\n  ((STR)->length)\n\n/* The NTBS in which the contents of STR are stored.  */\n#define dyn_string_buf(STR)                                             \\\n  ((STR)->s)\n\n/* Compare DS1 to DS2 with strcmp.  */\n#define dyn_string_compare(DS1, DS2)                                    \\\n  (strcmp ((DS1)->s, (DS2)->s))\n\n\n/* dyn_string functions are used in the demangling implementation\n   included in the G++ runtime library.  To prevent collisions with\n   names in user programs, the functions that are used in the\n   demangler are given implementation-reserved names.  */\n\n#if defined(IN_LIBGCC2) || defined(IN_GLIBCPP_V3)\n\n#define dyn_string_init                 __cxa_dyn_string_init\n#define dyn_string_new                  __cxa_dyn_string_new\n#define dyn_string_delete               __cxa_dyn_string_delete\n#define dyn_string_release              __cxa_dyn_string_release\n#define dyn_string_resize               __cxa_dyn_string_resize\n#define dyn_string_clear                __cxa_dyn_string_clear\n#define dyn_string_copy                 __cxa_dyn_string_copy\n#define dyn_string_copy_cstr            __cxa_dyn_string_copy_cstr\n#define dyn_string_prepend              __cxa_dyn_string_prepend\n#define dyn_string_prepend_cstr         __cxa_dyn_string_prepend_cstr\n#define dyn_string_insert               __cxa_dyn_string_insert\n#define dyn_string_insert_cstr          __cxa_dyn_string_insert_cstr\n#define dyn_string_insert_char          __cxa_dyn_string_insert_char\n#define dyn_string_append               __cxa_dyn_string_append\n#define dyn_string_append_cstr          __cxa_dyn_string_append_cstr\n#define dyn_string_append_char          __cxa_dyn_string_append_char\n#define dyn_string_substring            __cxa_dyn_string_substring\n#define dyn_string_eq                   __cxa_dyn_string_eq\n\n#endif /* IN_LIBGCC2 || IN_GLIBCPP_V3 */\n\n\nextern int dyn_string_init              PARAMS ((struct dyn_string *, int));\nextern dyn_string_t dyn_string_new      PARAMS ((int));\nextern void dyn_string_delete           PARAMS ((dyn_string_t));\nextern char *dyn_string_release         PARAMS ((dyn_string_t));\nextern dyn_string_t dyn_string_resize   PARAMS ((dyn_string_t, int));\nextern void dyn_string_clear            PARAMS ((dyn_string_t));\nextern int dyn_string_copy              PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_copy_cstr         PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_prepend           PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_prepend_cstr      PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_insert            PARAMS ((dyn_string_t, int,\n\t\t\t\t\t\t dyn_string_t));\nextern int dyn_string_insert_cstr       PARAMS ((dyn_string_t, int,\n\t\t\t\t\t\t const char *));\nextern int dyn_string_insert_char       PARAMS ((dyn_string_t, int, int));\nextern int dyn_string_append            PARAMS ((dyn_string_t, dyn_string_t));\nextern int dyn_string_append_cstr       PARAMS ((dyn_string_t, const char *));\nextern int dyn_string_append_char       PARAMS ((dyn_string_t, int));\nextern int dyn_string_substring         PARAMS ((dyn_string_t,\n\t\t\t\t\t\t dyn_string_t, int, int));\nextern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERRORS": {"ttr": 2817, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Basic error reporting routines.\n   Copyright (C) 1999, 2000, 2001, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* warning, error, and fatal.  These definitions are suitable for use\n   in the generator programs; eventually we would like to use them in\n   cc1 too, but that's a longer term project.\n\n   N.B. We cannot presently use ATTRIBUTE_PRINTF with these functions,\n   because they can be extended with additional format specifiers which\n   GCC does not know about.  */\n\n#ifndef GCC_ERRORS_H\n#define GCC_ERRORS_H\n\nextern void warning (const char *, ...);\nextern void error (const char *, ...);\nextern void fatal (const char *, ...) ATTRIBUTE_NORETURN;\nextern void internal_error (const char *, ...) ATTRIBUTE_NORETURN;\nextern const char *trim_filename (const char *);\nextern void fancy_abort (const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\n\nextern int have_error;\nextern const char *progname;\n\n#endif /* ! GCC_ERRORS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ET@FORES": {"ttr": 2819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Et-forest data structure implementation.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* This package implements ET forest data structure. Each tree in\n   the structure maintains a tree structure and offers logarithmic time\n   for tree operations (insertion and removal of nodes and edges) and\n   poly-logarithmic time for nearest common ancestor.\n\n   ET tree stores its structure as a sequence of symbols obtained\n   by dfs(root)\n\n   dfs (node)\n   {\n     s = node;\n     for each child c of node do\n       s = concat (s, c, node);\n     return s;\n   }\n\n   For example for tree\n\n            1\n          / | \\\n         2  3  4\n       / |\n      4  5\n\n   the sequence is 1 2 4 2 5 3 1 3 1 4 1.\n\n   The sequence is stored in a slightly modified splay tree.\n   In order to support various types of node values, a hashtable\n   is used to convert node values to the internal representation.  */\n\n#ifndef _ET_TREE_H\n#define _ET_TREE_H\n\n#include <ansidecl.h>\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n/* The node representing the node in an et tree.  */\nstruct et_node\n{\n  void *data;\t\t\t/* The data represented by the node.  */\n\n  int dfs_num_in, dfs_num_out;\t/* Number of the node in the dfs ordering.  */\n\n  struct et_node *father;\t/* Father of the node.  */\n  struct et_node *son;\t\t/* The first of the sons of the node.  */\n  struct et_node *left;\n  struct et_node *right;\t/* The brothers of the node.  */\n\n  struct et_occ *rightmost_occ;\t/* The rightmost occurence.  */\n  struct et_occ *parent_occ;\t/* The occurence of the parent node.  */\n};\n\nstruct et_node *et_new_tree (void *data);\nvoid et_free_tree (struct et_node *);\nvoid et_set_father (struct et_node *, struct et_node *);\nvoid et_split (struct et_node *);\nstruct et_node *et_nca (struct et_node *, struct et_node *);\nbool et_below (struct et_node *, struct et_node *);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _ET_TREE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXCEPT": {"ttr": 2821, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception Handling interface routines.\n   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n   Free Software Foundation, Inc.\n   Contributed by Mike Stump <mrs@cygnus.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\nstruct function;\n\nstruct inline_remap;\n\n/* Per-function EH data.  Used only in except.c, but GC and others\n   manipulate pointers to the opaque type.  */\nstruct eh_status;\n\n/* Internal structure describing a region.  */\nstruct eh_region;\n\n/* Test: is exception handling turned on?  */\nextern int doing_eh (int);\n\n/* Start an exception handling region.  All instructions emitted after\n   this point are considered to be part of the region until an\n   expand_eh_region_end variant is invoked.  */\nextern void expand_eh_region_start (void);\n\n/* End an exception handling region for a cleanup.  HANDLER is an\n   expression to expand for the cleanup.  */\nextern void expand_eh_region_end_cleanup (tree);\n\n/* End an exception handling region for a try block, and prepares\n   for subsequent calls to expand_start_catch.  */\nextern void expand_start_all_catch (void);\n\n/* Begin a catch clause.  TYPE is an object to be matched by the\n   runtime, or a list of such objects, or null if this is a catch-all\n   clause.  */\nextern void expand_start_catch (tree);\n\n/* End a catch clause.  Control will resume after the try/catch block.  */\nextern void expand_end_catch (void);\n\n/* End a sequence of catch handlers for a try block.  */\nextern void expand_end_all_catch (void);\n\n/* End an exception region for an exception type filter.  ALLOWED is a\n   TREE_LIST of TREE_VALUE objects to be matched by the runtime.\n   FAILURE is a function to invoke if a mismatch occurs.  */\nextern void expand_eh_region_end_allowed (tree, tree);\n\n/* End an exception region for a must-not-throw filter.  FAILURE is a\n   function to invoke if an uncaught exception propagates this far.  */\nextern void expand_eh_region_end_must_not_throw (tree);\n\n/* End an exception region for a throw.  No handling goes on here,\n   but it's the easiest way for the front-end to indicate what type\n   is being thrown.  */\nextern void expand_eh_region_end_throw (tree);\n\n/* End a fixup region.  Within this region the cleanups for the immediately\n   enclosing region are _not_ run.  This is used for goto cleanup to avoid\n   destroying an object twice.  */\nextern void expand_eh_region_end_fixup (tree);\n\n/* Note that the current EH region (if any) may contain a throw, or a\n   call to a function which itself may contain a throw.  */\nextern void note_eh_region_may_contain_throw (void);\n\n/* Invokes CALLBACK for every exception handler label.  Only used by old\n   loop hackery; should not be used by new code.  */\nextern void for_each_eh_label (void (*) (rtx));\n\n/* Determine if the given INSN can throw an exception.  */\nextern bool can_throw_internal (rtx);\nextern bool can_throw_external (rtx);\n\n/* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */\nextern void set_nothrow_function_flags (void);\n\n/* After initial rtl generation, call back to finish generating\n   exception support code.  */\nextern void finish_eh_generation (void);\n\nextern void init_eh (void);\nextern void init_eh_for_function (void);\n\nextern rtx reachable_handlers (rtx);\nextern void maybe_remove_eh_handler (rtx);\n\nextern void convert_from_eh_region_ranges (void);\nextern void convert_to_eh_region_ranges (void);\nextern void find_exception_handler_labels (void);\nextern bool current_function_has_exception_handlers (void);\nextern void output_function_exception_table (void);\n\nextern void expand_builtin_unwind_init (void);\nextern rtx expand_builtin_eh_return_data_regno (tree);\nextern rtx expand_builtin_extract_return_addr (tree);\nextern void expand_builtin_init_dwarf_reg_sizes (tree);\nextern rtx expand_builtin_frob_return_addr (tree);\nextern rtx expand_builtin_dwarf_sp_column (void);\nextern void expand_builtin_eh_return (tree, tree);\nextern void expand_eh_return (void);\nextern rtx expand_builtin_extend_pointer (tree);\nextern rtx get_exception_pointer (struct function *);\nextern int duplicate_eh_regions (struct function *, struct inline_remap *);\n\nextern void sjlj_emit_function_exit_after (rtx);\n\n\n/* If non-NULL, this is a function that returns an expression to be\n   executed if an unhandled exception is propagated out of a cleanup\n   region.  For example, in C++, an exception thrown by a destructor\n   during stack unwinding is required to result in a call to\n   `std::terminate', so the C++ version of this function returns a\n   CALL_EXPR for `std::terminate'.  */\nextern tree (*lang_protect_cleanup_actions) (void);\n\n/* Return true if type A catches type B.  */\nextern int (*lang_eh_type_covers) (tree a, tree b);\n\n/* Map a type to a runtime object to match type.  */\nextern tree (*lang_eh_runtime_type) (tree);\n\n\n/* Just because the user configured --with-sjlj-exceptions=no doesn't\n   mean that we can use call frame exceptions.  Detect that the target\n   has appropriate support.  */\n\n#ifndef MUST_USE_SJLJ_EXCEPTIONS\n# if !(defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n       && (defined (IA64_UNWIND_INFO)\t\t\t\\\n\t   || (DWARF2_UNWIND_INFO\t\t\t\\\n\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n\t\t   || defined (HAVE_eh_return)))))\n#  define MUST_USE_SJLJ_EXCEPTIONS\t1\n# else\n#  define MUST_USE_SJLJ_EXCEPTIONS\t0\n# endif\n#endif\n\n#ifdef CONFIG_SJLJ_EXCEPTIONS\n# if CONFIG_SJLJ_EXCEPTIONS == 1\n#  define USING_SJLJ_EXCEPTIONS\t\t1\n# endif\n# if CONFIG_SJLJ_EXCEPTIONS == 0\n#  define USING_SJLJ_EXCEPTIONS\t\t0\n#  ifndef EH_RETURN_DATA_REGNO\n    #error \"EH_RETURN_DATA_REGNO required\"\n#  endif\n#  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)\n    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n#  endif\n#  if !defined(DWARF2_UNWIND_INFO) && !defined(IA64_UNWIND_INFO)\n    #error \"{DWARF2,IA64}_UNWIND_INFO required\"\n#  endif\n# endif\n#else\n# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXPR": {"ttr": 2824, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* The default branch cost is 1.  */\n#ifndef BRANCH_COST\n#define BRANCH_COST 1\n#endif\n\n/* Macros to access the slots of a QUEUED rtx.\n   Here rather than in rtl.h because only the expansion pass\n   should ever encounter a QUEUED.  */\n\n/* The variable for which an increment is queued.  */\n#define QUEUED_VAR(P) XEXP (P, 0)\n/* If the increment has been emitted, this is the insn\n   that does the increment.  It is zero before the increment is emitted.\n   If more than one insn is emitted, this is the first insn.  */\n#define QUEUED_INSN(P) XEXP (P, 1)\n/* If a pre-increment copy has been generated, this is the copy\n   (it is a temporary reg).  Zero if no copy made yet.  */\n#define QUEUED_COPY(P) XEXP (P, 2)\n/* This is the body to use for the insn to do the increment.\n   It is used to emit the increment.  */\n#define QUEUED_BODY(P) XEXP (P, 3)\n/* Next QUEUED in the queue.  */\n#define QUEUED_NEXT(P) XEXP (P, 4)\n\n/* This is the 4th arg to `expand_expr'.\n   EXPAND_STACK_PARM means we are possibly expanding a call param onto\n   the stack.  Choosing a value of 2 isn't special;  It just allows\n   some code optimization in store_expr.\n   EXPAND_SUM means it is ok to return a PLUS rtx or MULT rtx.\n   EXPAND_INITIALIZER is similar but also record any labels on forced_labels.\n   EXPAND_CONST_ADDRESS means it is ok to return a MEM whose address\n    is a constant that is not a legitimate address.\n   EXPAND_WRITE means we are only going to write to the resulting rtx.\n   EXPAND_MEMORY means we are interested in a memory result, even if\n    the memory is constant and we could have propagated a constant value.  */\nenum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM = 2, EXPAND_SUM,\n\t\t      EXPAND_CONST_ADDRESS, EXPAND_INITIALIZER, EXPAND_WRITE,\n\t\t      EXPAND_MEMORY};\n\n/* Prevent the compiler from deferring stack pops.  See\n   inhibit_defer_pop for more information.  */\n#define NO_DEFER_POP (inhibit_defer_pop += 1)\n\n/* Allow the compiler to defer stack pops.  See inhibit_defer_pop for\n   more information.  */\n#define OK_DEFER_POP (inhibit_defer_pop -= 1)\n\n/* If a memory-to-memory move would take MOVE_RATIO or more simple\n   move-instruction sequences, we will do a movstr or libcall instead.  */\n\n#ifndef MOVE_RATIO\n#if defined (HAVE_movstrqi) || defined (HAVE_movstrhi) || defined (HAVE_movstrsi) || defined (HAVE_movstrdi) || defined (HAVE_movstrti)\n#define MOVE_RATIO 2\n#else\n/* If we are optimizing for space (-Os), cut down the default move ratio.  */\n#define MOVE_RATIO (optimize_size ? 3 : 15)\n#endif\n#endif\n\n/* If a clear memory operation would take CLEAR_RATIO or more simple\n   move-instruction sequences, we will do a clrstr or libcall instead.  */\n\n#ifndef CLEAR_RATIO\n#if defined (HAVE_clrstrqi) || defined (HAVE_clrstrhi) || defined (HAVE_clrstrsi) || defined (HAVE_clrstrdi) || defined (HAVE_clrstrti)\n#define CLEAR_RATIO 2\n#else\n/* If we are optimizing for space, cut down the default clear ratio.  */\n#define CLEAR_RATIO (optimize_size ? 3 : 15)\n#endif\n#endif\n\nenum direction {none, upward, downward};\n\n/* Structure to record the size of a sequence of arguments\n   as the sum of a tree-expression and a constant.  This structure is\n   also used to store offsets from the stack, which might be negative,\n   so the variable part must be ssizetype, not sizetype.  */\n\nstruct args_size\n{\n  HOST_WIDE_INT constant;\n  tree var;\n};\n\n/* Package up various arg related fields of struct args for\n   locate_and_pad_parm.  */\nstruct locate_and_pad_arg_data\n{\n  /* Size of this argument on the stack, rounded up for any padding it\n     gets.  If REG_PARM_STACK_SPACE is defined, then register parms are\n     counted here, otherwise they aren't.  */\n  struct args_size size;\n  /* Offset of this argument from beginning of stack-args.  */\n  struct args_size offset;\n  /* Offset to the start of the stack slot.  Different from OFFSET\n     if this arg pads downward.  */\n  struct args_size slot_offset;\n  /* The amount that the stack pointer needs to be adjusted to\n     force alignment for the next argument.  */\n  struct args_size alignment_pad;\n  /* Which way we should pad this arg.  */\n  enum direction where_pad;\n};\n\n/* Add the value of the tree INC to the `struct args_size' TO.  */\n\n#define ADD_PARM_SIZE(TO, INC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n  tree inc = (INC);\t\t\t\t\t\\\n  if (host_integerp (inc, 0))\t\t\t\t\\\n    (TO).constant += tree_low_cst (inc, 0);\t\t\\\n  else if ((TO).var == 0)\t\t\t\t\\\n    (TO).var = convert (ssizetype, inc);\t\t\\\n  else\t\t\t\t\t\t\t\\\n    (TO).var = size_binop (PLUS_EXPR, (TO).var,\t\t\\\n\t\t\t   convert (ssizetype, inc));\t\\\n} while (0)\n\n#define SUB_PARM_SIZE(TO, DEC)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n  tree dec = (DEC);\t\t\t\t\t\\\n  if (host_integerp (dec, 0))\t\t\t\t\\\n    (TO).constant -= tree_low_cst (dec, 0);\t\t\\\n  else if ((TO).var == 0)\t\t\t\t\\\n    (TO).var = size_binop (MINUS_EXPR, ssize_int (0),\t\\\n\t\t\t   convert (ssizetype, dec));\t\\\n  else\t\t\t\t\t\t\t\\\n    (TO).var = size_binop (MINUS_EXPR, (TO).var,\t\\\n\t\t\t   convert (ssizetype, dec));\t\\\n} while (0)\n\n/* Convert the implicit sum in a `struct args_size' into a tree\n   of type ssizetype.  */\n#define ARGS_SIZE_TREE(SIZE)\t\t\t\t\t\\\n((SIZE).var == 0 ? ssize_int ((SIZE).constant)\t\t\t\\\n : size_binop (PLUS_EXPR, convert (ssizetype, (SIZE).var),\t\\\n\t       ssize_int ((SIZE).constant)))\n\n/* Convert the implicit sum in a `struct args_size' into an rtx.  */\n#define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\\\n((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n : expand_expr (ARGS_SIZE_TREE (SIZE), NULL_RTX, VOIDmode, 0))\n\n/* Supply a default definition for FUNCTION_ARG_PADDING:\n   usually pad upward, but pad short args downward on\n   big-endian machines.  */\n\n#define DEFAULT_FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\\\n  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n   ? upward\t\t\t\t\t\t\t\t\\\n   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n      ? downward : upward))\n\n#ifndef FUNCTION_ARG_PADDING\n#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\\\n  DEFAULT_FUNCTION_ARG_PADDING ((MODE), (TYPE))\n#endif\n\n/* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n   FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n   alignment.  */\n\n#ifndef FUNCTION_ARG_BOUNDARY\n#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n#endif\n\ntree split_complex_types (tree);\ntree split_complex_values (tree);\n\n/* Nonzero if we do not know how to pass TYPE solely in registers.  */\nextern bool default_must_pass_in_stack (enum machine_mode, tree);\n#ifndef MUST_PASS_IN_STACK\n#define MUST_PASS_IN_STACK(MODE,TYPE) default_must_pass_in_stack(MODE, TYPE)\n#endif\n\n/* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n   Normally move_insn, so Pmode stack pointer.  */\n\n#ifndef STACK_SAVEAREA_MODE\n#define STACK_SAVEAREA_MODE(LEVEL) Pmode\n#endif\n\n/* Supply a default definition of STACK_SIZE_MODE for\n   allocate_dynamic_stack_space.  Normally PLUS/MINUS, so word_mode.  */\n\n#ifndef STACK_SIZE_MODE\n#define STACK_SIZE_MODE word_mode\n#endif\n\n/* Provide default values for the macros controlling stack checking.  */\n\n#ifndef STACK_CHECK_BUILTIN\n#define STACK_CHECK_BUILTIN 0\n#endif\n\n/* The default interval is one page.  */\n#ifndef STACK_CHECK_PROBE_INTERVAL\n#define STACK_CHECK_PROBE_INTERVAL 4096\n#endif\n\n/* The default is to do a store into the stack.  */\n#ifndef STACK_CHECK_PROBE_LOAD\n#define STACK_CHECK_PROBE_LOAD 0\n#endif\n\n/* This value is arbitrary, but should be sufficient for most machines.  */\n#ifndef STACK_CHECK_PROTECT\n#define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)\n#endif\n\n/* Make the maximum frame size be the largest we can and still only need\n   one probe per function.  */\n#ifndef STACK_CHECK_MAX_FRAME_SIZE\n#define STACK_CHECK_MAX_FRAME_SIZE \\\n  (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)\n#endif\n\n/* This is arbitrary, but should be large enough everywhere.  */\n#ifndef STACK_CHECK_FIXED_FRAME_SIZE\n#define STACK_CHECK_FIXED_FRAME_SIZE (4 * UNITS_PER_WORD)\n#endif\n\n/* Provide a reasonable default for the maximum size of an object to\n   allocate in the fixed frame.  We may need to be able to make this\n   controllable by the user at some point.  */\n#ifndef STACK_CHECK_MAX_VAR_SIZE\n#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n#endif\n\n/* Functions from optabs.c, commonly used, and without need for the optabs\n   tables:  */\n\n/* Passed to expand_simple_binop and expand_binop to say which options\n   to try to use if the requested operation can't be open-coded on the\n   requisite mode.  Either OPTAB_LIB or OPTAB_LIB_WIDEN says try using\n   a library call.  Either OPTAB_WIDEN or OPTAB_LIB_WIDEN says try\n   using a wider mode.  OPTAB_MUST_WIDEN says try widening and don't\n   try anything else.  */\n\nenum optab_methods\n{\n  OPTAB_DIRECT,\n  OPTAB_LIB,\n  OPTAB_WIDEN,\n  OPTAB_LIB_WIDEN,\n  OPTAB_MUST_WIDEN\n};\n\n/* Generate code for a simple binary or unary operation.  \"Simple\" in\n   this case means \"can be unambiguously described by a (mode, code)\n   pair and mapped to a single optab.\"  */\nextern rtx expand_simple_binop (enum machine_mode, enum rtx_code, rtx,\n\t\t\t\trtx, rtx, int, enum optab_methods);\nextern rtx expand_simple_unop (enum machine_mode, enum rtx_code, rtx, rtx,\n\t\t\t       int);\n\n/* Report whether the machine description contains an insn which can\n   perform the operation described by CODE and MODE.  */\nextern int have_insn_for (enum rtx_code, enum machine_mode);\n\n/* Emit code to make a call to a constant function or a library call.  */\nextern void emit_libcall_block (rtx, rtx, rtx, rtx);\n\n/* Create but don't emit one rtl instruction to perform certain operations.\n   Modes must match; operands must meet the operation's predicates.\n   Likewise for subtraction and for just copying.\n   These do not call protect_from_queue; caller must do so.  */\nextern rtx gen_add2_insn (rtx, rtx);\nextern rtx gen_add3_insn (rtx, rtx, rtx);\nextern rtx gen_sub2_insn (rtx, rtx);\nextern rtx gen_sub3_insn (rtx, rtx, rtx);\nextern rtx gen_move_insn (rtx, rtx);\nextern int have_add2_insn (rtx, rtx);\nextern int have_sub2_insn (rtx, rtx);\n\n/* Emit a pair of rtl insns to compare two rtx's and to jump\n   to a label if the comparison is true.  */\nextern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n\t\t\t\t     enum machine_mode, int, rtx);\n\n/* Generate code to indirectly jump to a location given in the rtx LOC.  */\nextern void emit_indirect_jump (rtx);\n\n#ifdef HAVE_conditional_move\n/* Emit a conditional move operation.  */\nrtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n\t\t\t   rtx, rtx, enum machine_mode, int);\n\n/* Return nonzero if the conditional move is supported.  */\nint can_conditionally_move_p (enum machine_mode mode);\n\n#endif\nrtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n\t\t\t  rtx, rtx, enum machine_mode, int);\n\n\n/* Functions from expmed.c:  */\n\n/* Arguments MODE, RTX: return an rtx for the negation of that value.\n   May emit insns.  */\nextern rtx negate_rtx (enum machine_mode, rtx);\n\n/* Expand a logical AND operation.  */\nextern rtx expand_and (enum machine_mode, rtx, rtx, rtx);\n\n/* Emit a store-flag operation.  */\nextern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n\t\t\t    int, int);\n\n/* Like emit_store_flag, but always succeeds.  */\nextern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n\t\t\t\t  enum machine_mode, int, int);\n\n/* Functions from loop.c:  */\n\n/* Given an insn and condition, return a canonical description of\n   the test being made.  */\nextern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int);\n\n/* Given a JUMP_INSN, return a canonical description of the test\n   being made.  */\nextern rtx get_condition (rtx, rtx *, int);\n\n/* Generate a conditional trap instruction.  */\nextern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n\n/* Functions from builtins.c:  */\nextern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\nextern tree std_build_builtin_va_list (void);\nextern void std_expand_builtin_va_start (tree, rtx);\nextern rtx std_expand_builtin_va_arg (tree, tree);\nextern rtx expand_builtin_va_arg (tree, tree);\nextern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\nextern void expand_builtin_setjmp_setup (rtx, rtx);\nextern void expand_builtin_setjmp_receiver (rtx);\nextern void expand_builtin_longjmp (rtx, rtx);\nextern rtx expand_builtin_saveregs (void);\nextern void expand_builtin_trap (void);\nextern HOST_WIDE_INT get_varargs_alias_set (void);\nextern HOST_WIDE_INT get_frame_alias_set (void);\nextern void record_base_value (unsigned int, rtx, int);\nextern void record_alias_subset (HOST_WIDE_INT, HOST_WIDE_INT);\nextern HOST_WIDE_INT new_alias_set (void);\nextern int can_address_p (tree);\n\n/* Functions from expr.c:  */\n\n/* This is run once per compilation to set up which modes can be used\n   directly in memory and to initialize the block move optab.  */\nextern void init_expr_once (void);\n\n/* This is run at the start of compiling a function.  */\nextern void init_expr (void);\n\n/* This is run at the end of compiling a function.  */\nextern void finish_expr_for_function (void);\n\n/* Use protect_from_queue to convert a QUEUED expression\n   into something that you can put immediately into an instruction.  */\nextern rtx protect_from_queue (rtx, int);\n\n/* Perform all the pending incrementations.  */\nextern void emit_queue (void);\n\n/* Tell if something has a queued subexpression.  */\nextern int queued_subexp_p (rtx);\n\n/* Emit some rtl insns to move data between rtx's, converting machine modes.\n   Both modes must be floating or both fixed.  */\nextern void convert_move (rtx, rtx, int);\n\n/* Convert an rtx to specified machine mode and return the result.  */\nextern rtx convert_to_mode (enum machine_mode, rtx, int);\n\n/* Convert an rtx to MODE from OLDMODE and return the result.  */\nextern rtx convert_modes (enum machine_mode, enum machine_mode, rtx, int);\n\n/* Emit code to move a block Y to a block X.  */\n\nenum block_op_methods\n{\n  BLOCK_OP_NORMAL,\n  BLOCK_OP_NO_LIBCALL,\n  BLOCK_OP_CALL_PARM\n};\n\nextern void init_block_move_fn (const char *);\nextern void init_block_clear_fn (const char *);\n\nextern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n\n/* Copy all or part of a value X into registers starting at REGNO.\n   The number of registers to be filled is NREGS.  */\nextern void move_block_to_reg (int, rtx, int, enum machine_mode);\n\n/* Copy all or part of a BLKmode value X out of registers starting at REGNO.\n   The number of registers to be filled is NREGS.  */\nextern void move_block_from_reg (int, rtx, int);\n\n/* Generate a non-consecutive group of registers represented by a PARALLEL.  */\nextern rtx gen_group_rtx (rtx);\n\n/* Load a BLKmode value into non-consecutive registers represented by a\n   PARALLEL.  */\nextern void emit_group_load (rtx, rtx, tree, int);\n\n/* Move a non-consecutive group of registers represented by a PARALLEL into\n   a non-consecutive group of registers represented by a PARALLEL.  */\nextern void emit_group_move (rtx, rtx);\n\n/* Store a BLKmode value from non-consecutive registers represented by a\n   PARALLEL.  */\nextern void emit_group_store (rtx, rtx, tree, int);\n\n/* Copy BLKmode object from a set of registers.  */\nextern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n\n/* Mark REG as holding a parameter for the next CALL_INSN.  */\nextern void use_reg (rtx *, rtx);\n\n/* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n   for the next CALL_INSN.  */\nextern void use_regs (rtx *, int, int);\n\n/* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\nextern void use_group_regs (rtx *, rtx);\n\n/* Write zeros through the storage of OBJECT.\n   If OBJECT has BLKmode, SIZE is its length in bytes.  */\nextern rtx clear_storage (rtx, rtx);\n\n/* Determine whether the LEN bytes can be moved by using several move\n   instructions.  Return nonzero if a call to move_by_pieces should\n   succeed.  */\nextern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n\n/* Return nonzero if it is desirable to store LEN bytes generated by\n   CONSTFUN with several move instructions by store_by_pieces\n   function.  CONSTFUNDATA is a pointer which will be passed as argument\n   in every CONSTFUN call.\n   ALIGN is maximum alignment we can assume.  */\nextern int can_store_by_pieces (unsigned HOST_WIDE_INT,\n\t\t\t\trtx (*) (void *, HOST_WIDE_INT,\n\t\t\t\t\t enum machine_mode),\n\t\t\t\tvoid *, unsigned int);\n\n/* Generate several move instructions to store LEN bytes generated by\n   CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n   pointer which will be passed as argument in every CONSTFUN call.\n   ALIGN is maximum alignment we can assume.\n   Returns TO + LEN.  */\nextern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT,\n\t\t\t    rtx (*) (void *, HOST_WIDE_INT, enum machine_mode),\n\t\t\t    void *, unsigned int, int);\n\n/* Emit insns to set X from Y.  */\nextern rtx emit_move_insn (rtx, rtx);\n\n/* Emit insns to set X from Y, with no frills.  */\nextern rtx emit_move_insn_1 (rtx, rtx);\n\n/* Push a block of length SIZE (perhaps variable)\n   and return an rtx to address the beginning of the block.  */\nextern rtx push_block (rtx, int, int);\n\n/* Generate code to push something onto the stack, given its mode and type.  */\nextern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,\n\t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n\n/* Expand an assignment that stores the value of FROM into TO.  */\nextern rtx expand_assignment (tree, tree, int);\n\n/* Generate code for computing expression EXP,\n   and storing the value into TARGET.\n   If SUGGEST_REG is nonzero, copy the value through a register\n   and return that register, if that is possible.  */\nextern rtx store_expr (tree, rtx, int);\n\n/* Given an rtx that may include add and multiply operations,\n   generate them as insns and return a pseudo-reg containing the value.\n   Useful after calling expand_expr with 1 as sum_ok.  */\nextern rtx force_operand (rtx, rtx);\n\n/* Return an object on the placeholder list that matches EXP, a\n   PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n   PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n   tree.def.  If no such object is found, abort.  If PLIST is nonzero, it is\n   a location which initially points to a starting location in the\n   placeholder list (zero means start of the list) and where a pointer into\n   the placeholder list at which the object is found is placed.  */\nextern tree find_placeholder (tree, tree *);\n\n/* Generate code for computing expression EXP.\n   An rtx for the computed value is returned.  The value is never null.\n   In the case of a void EXP, const0_rtx is returned.  */\n#define expand_expr(EXP, TARGET, MODE, MODIFIER) \\\n  expand_expr_real((EXP), (TARGET), (MODE), (MODIFIER), NULL)\nextern rtx expand_expr_real (tree, rtx, enum machine_mode,\n\t\t\t     enum expand_modifier, rtx *);\n\n/* At the start of a function, record that we have no previously-pushed\n   arguments waiting to be popped.  */\nextern void init_pending_stack_adjust (void);\n\n/* Discard any pending stack adjustment.  */\nextern void discard_pending_stack_adjust (void);\n\n/* When exiting from function, if safe, clear out any pending stack adjust\n   so the adjustment won't get done.  */\nextern void clear_pending_stack_adjust (void);\n\n/* Pop any previously-pushed arguments that have not been popped yet.  */\nextern void do_pending_stack_adjust (void);\n\n/* Return the tree node and offset if a given argument corresponds to\n   a string constant.  */\nextern tree string_constant (tree, tree *);\n\n/* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\nextern void jumpifnot (tree, rtx);\n\n/* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\nextern void jumpif (tree, rtx);\n\n/* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n   the result is zero, or IF_TRUE_LABEL if the result is one.  */\nextern void do_jump (tree, rtx, rtx);\n\n/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\nextern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,\n\t\t\t     rtx);\nextern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n\t\t\t\t     enum machine_mode, rtx, rtx, rtx);\n\n/* Two different ways of generating switch statements.  */\nextern int try_casesi (tree, tree, tree, tree, rtx, rtx);\nextern int try_tablejump (tree, tree, tree, tree, rtx, rtx);\n\n/* Smallest number of adjacent cases before we use a jump table.\n   XXX Should be a target hook.  */\nextern unsigned int case_values_threshold (void);\n\n\n/* rtl.h and tree.h were included.  */\n/* Return an rtx for the size in bytes of the value of an expr.  */\nextern rtx expr_size (tree);\n\n/* Return a wide integer for the size in bytes of the value of EXP, or -1\n   if the size can vary or is larger than an integer.  */\nextern HOST_WIDE_INT int_expr_size (tree);\n\nextern rtx lookup_static_chain (tree);\n\n/* Convert a stack slot address ADDR valid in function FNDECL\n   into an address valid in this function (using a static chain).  */\nextern rtx fix_lexical_addr (rtx, tree);\n\n/* Return the address of the trampoline for entering nested fn FUNCTION.  */\nextern rtx trampoline_address (tree);\n\n/* Return an rtx that refers to the value returned by a function\n   in its original home.  This becomes invalid if any more code is emitted.  */\nextern rtx hard_function_value (tree, tree, int);\n\nextern rtx prepare_call_address (rtx, tree, rtx *, int, int);\n\nextern rtx expand_call (tree, rtx, int);\n\n#ifdef TREE_CODE\nextern rtx expand_shift (enum tree_code, enum machine_mode, rtx, tree, rtx,\n\t\t\t int);\nextern rtx expand_divmod (int, enum tree_code, enum machine_mode, rtx, rtx,\n\t\t\t  rtx, int);\n#endif\n\nextern void locate_and_pad_parm (enum machine_mode, tree, int, int, tree,\n\t\t\t\t struct args_size *,\n\t\t\t\t struct locate_and_pad_arg_data *);\nextern rtx expand_inline_function (tree, tree, rtx, int, tree, rtx);\n\n/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\nextern rtx label_rtx (tree);\n\n/* As label_rtx, but additionally the label is placed on the forced label\n   list of its containing function (i.e. it is treated as reachable even\n   if how is not obvious).  */\nextern rtx force_label_rtx (tree);\n\n/* Indicate how an input argument register was promoted.  */\nextern rtx promoted_input_arg (unsigned int, enum machine_mode *, int *);\n\n/* Return an rtx like arg but sans any constant terms.\n   Returns the original rtx if it has no constant terms.\n   The constant terms are added and stored via a second arg.  */\nextern rtx eliminate_constant_term (rtx, rtx *);\n\n/* Convert arg to a valid memory address for specified machine mode,\n   by emitting insns to perform arithmetic if nec.  */\nextern rtx memory_address (enum machine_mode, rtx);\n\n/* Like `memory_address' but pretent `flag_force_addr' is 0.  */\nextern rtx memory_address_noforce (enum machine_mode, rtx);\n\n/* Set the alias set of MEM to SET.  */\nextern void set_mem_alias_set (rtx, HOST_WIDE_INT);\n\n/* Set the alignment of MEM to ALIGN bits.  */\nextern void set_mem_align (rtx, unsigned int);\n\n/* Set the expr for MEM to EXPR.  */\nextern void set_mem_expr (rtx, tree);\n\n/* Set the offset for MEM to OFFSET.  */\nextern void set_mem_offset (rtx, rtx);\n\n/* Set the size for MEM to SIZE.  */\nextern void set_mem_size (rtx, rtx);\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address changed to ADDR.\n   (VOIDmode means don't change the mode.\n   NULL for ADDR means don't change the address.)  */\nextern rtx change_address (rtx, enum machine_mode, rtx);\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address offset by OFFSET bytes.  */\n#define adjust_address(MEMREF, MODE, OFFSET) \\\n  adjust_address_1 (MEMREF, MODE, OFFSET, 1, 1)\n\n/* Likewise, but the reference is not required to be valid.  */\n#define adjust_address_nv(MEMREF, MODE, OFFSET) \\\n  adjust_address_1 (MEMREF, MODE, OFFSET, 0, 1)\n\n/* Return a memory reference like MEMREF, but with its mode changed\n   to MODE and its address changed to ADDR, which is assumed to be\n   increased by OFFSET bytes from MEMREF.  */\n#define adjust_automodify_address(MEMREF, MODE, ADDR, OFFSET) \\\n  adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 1)\n\n/* Likewise, but the reference is not required to be valid.  */\n#define adjust_automodify_address_nv(MEMREF, MODE, ADDR, OFFSET) \\\n  adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 0)\n\nextern rtx adjust_address_1 (rtx, enum machine_mode, HOST_WIDE_INT, int, int);\nextern rtx adjust_automodify_address_1 (rtx, enum machine_mode, rtx,\n\t\t\t\t\tHOST_WIDE_INT, int);\n\n/* Return a memory reference like MEMREF, but whose address is changed by\n   adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n   known to be in OFFSET (possibly 1).  */\nextern rtx offset_address (rtx, rtx, unsigned HOST_WIDE_INT);\n\n/* Return a memory reference like MEMREF, but with its address changed to\n   ADDR.  The caller is asserting that the actual piece of memory pointed\n   to is the same, just the form of the address is being changed, such as\n   by putting something into a register.  */\nextern rtx replace_equiv_address (rtx, rtx);\n\n/* Likewise, but the reference is not required to be valid.  */\nextern rtx replace_equiv_address_nv (rtx, rtx);\n\n/* Return a memory reference like MEMREF, but with its mode widened to\n   MODE and adjusted by OFFSET.  */\nextern rtx widen_memory_access (rtx, enum machine_mode, HOST_WIDE_INT);\n\n/* Return a memory reference like MEMREF, but which is known to have a\n   valid address.  */\nextern rtx validize_mem (rtx);\n\n/* Given REF, either a MEM or a REG, and T, either the type of X or\n   the expression corresponding to REF, set RTX_UNCHANGING_P if\n   appropriate.  */\nextern void maybe_set_unchanging (rtx, tree);\n\n/* Given REF, a MEM, and T, either the type of X or the expression\n   corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n   if we are making a new object of this type.  */\nextern void set_mem_attributes (rtx, tree, int);\n\n/* Similar, except that BITPOS has not yet been applied to REF, so if\n   we alter MEM_OFFSET according to T then we should subtract BITPOS\n   expecting that it'll be added back in later.  */\nextern void set_mem_attributes_minus_bitpos (rtx, tree, int, HOST_WIDE_INT);\n\n/* Assemble the static constant template for function entry trampolines.  */\nextern rtx assemble_trampoline_template (void);\n\n/* Given rtx, return new rtx whose address won't be affected by\n   any side effects.  It has been copied to a new temporary reg.  */\nextern rtx stabilize (rtx);\n\n/* Given an rtx, copy all regs it refers to into new temps\n   and return a modified copy that refers to the new temps.  */\nextern rtx copy_all_regs (rtx);\n\n/* Copy given rtx to a new temp reg and return that.  */\nextern rtx copy_to_reg (rtx);\n\n/* Like copy_to_reg but always make the reg Pmode.  */\nextern rtx copy_addr_to_reg (rtx);\n\n/* Like copy_to_reg but always make the reg the specified mode MODE.  */\nextern rtx copy_to_mode_reg (enum machine_mode, rtx);\n\n/* Copy given rtx to given temp reg and return that.  */\nextern rtx copy_to_suggested_reg (rtx, rtx, enum machine_mode);\n\n/* Copy a value to a register if it isn't already a register.\n   Args are mode (in case value is a constant) and the value.  */\nextern rtx force_reg (enum machine_mode, rtx);\n\n/* Return given rtx, copied into a new temp reg if it was in memory.  */\nextern rtx force_not_mem (rtx);\n\n/* Return mode and signedness to use when object is promoted.  */\nextern enum machine_mode promote_mode (tree, enum machine_mode, int *, int);\n\n/* Remove some bytes from the stack.  An rtx says how many.  */\nextern void adjust_stack (rtx);\n\n/* Add some bytes to the stack.  An rtx says how many.  */\nextern void anti_adjust_stack (rtx);\n\n/* This enum is used for the following two functions.  */\nenum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n\n/* Save the stack pointer at the specified level.  */\nextern void emit_stack_save (enum save_level, rtx *, rtx);\n\n/* Restore the stack pointer from a save area of the specified level.  */\nextern void emit_stack_restore (enum save_level, rtx, rtx);\n\n/* Allocate some space on the stack dynamically and return its address.  An rtx\n   says how many bytes.  */\nextern rtx allocate_dynamic_stack_space (rtx, rtx, int);\n\n/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n   subtract from the stack.  If SIZE is constant, this is done\n   with a fixed number of probes.  Otherwise, we must make a loop.  */\nextern void probe_stack_range (HOST_WIDE_INT, rtx);\n\n/* Return an rtx that refers to the value returned by a library call\n   in its original home.  This becomes invalid if any more code is emitted.  */\nextern rtx hard_libcall_value (enum machine_mode);\n\n/* Given an rtx, return an rtx for a value rounded up to a multiple\n   of STACK_BOUNDARY / BITS_PER_UNIT.  */\nextern rtx round_push (rtx);\n\n/* Return the mode desired by operand N of a particular bitfield\n   insert/extract insn, or MAX_MACHINE_MODE if no such insn is\n   available.  */\n\nenum extraction_pattern { EP_insv, EP_extv, EP_extzv };\nextern enum machine_mode\nmode_for_extraction (enum extraction_pattern, int);\n\nextern rtx store_bit_field (rtx, unsigned HOST_WIDE_INT,\n\t\t\t    unsigned HOST_WIDE_INT, enum machine_mode, rtx,\n\t\t\t    HOST_WIDE_INT);\nextern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n\t\t\t      enum machine_mode, enum machine_mode,\n\t\t\t      HOST_WIDE_INT);\nextern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);\nextern bool const_mult_add_overflow_p (rtx, rtx, rtx, enum machine_mode, int);\nextern rtx expand_mult_add (rtx, rtx, rtx, rtx,enum machine_mode, int);\nextern rtx expand_mult_highpart_adjust (enum machine_mode, rtx, rtx, rtx, rtx, int);\n\nextern rtx assemble_static_space (unsigned HOST_WIDE_INT);\nextern int safe_from_p (rtx, tree, int);\n\n/* Call this once to initialize the contents of the optabs\n   appropriately for the current target machine.  */\nextern void init_optabs (void);\nextern void init_all_optabs (void);\n\n/* Call this to initialize an optab function entry.  */\nextern rtx init_one_libfunc (const char *);\n\nextern void do_jump_by_parts_equality_rtx (rtx, rtx, rtx);\nextern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n\t\t\t\t\t  rtx, rtx);\n\nextern void mark_seen_cases (tree, unsigned char *, HOST_WIDE_INT, int);\n\nextern int vector_mode_valid_p (enum machine_mode);\n\nextern tree placeholder_list;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIBHEAP": {"ttr": 3073, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* A Fibonacci heap datatype.\n   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n   Contributed by Daniel Berlin (dan@cgsoftware.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* Fibonacci heaps are somewhat complex, but, there's an article in\n   DDJ that explains them pretty well:\n\n   http://www.ddj.com/articles/1997/9701/9701o/9701o.htm?topic=algoritms\n\n   Introduction to algorithms by Corman and Rivest also goes over them.\n\n   The original paper that introduced them is \"Fibonacci heaps and their\n   uses in improved network optimization algorithms\" by Tarjan and\n   Fredman (JACM 34(3), July 1987).\n\n   Amortized and real worst case time for operations:\n\n   ExtractMin: O(lg n) amortized. O(n) worst case.\n   DecreaseKey: O(1) amortized.  O(lg n) worst case.\n   Insert: O(2) amortized. O(1) actual.\n   Union: O(1) amortized. O(1) actual.  */\n\n#ifndef _FIBHEAP_H_\n#define _FIBHEAP_H_\n\n#include \"ansidecl.h\"\n\ntypedef long fibheapkey_t;\n\ntypedef struct fibheap\n{\n  size_t nodes;\n  struct fibnode *min;\n  struct fibnode *root;\n} *fibheap_t;\n\ntypedef struct fibnode\n{\n  struct fibnode *parent;\n  struct fibnode *child;\n  struct fibnode *left;\n  struct fibnode *right;\n  fibheapkey_t key;\n  void *data;\n#ifdef __GNUC__\n  __extension__ unsigned long int degree : 31;\n  __extension__ unsigned long int mark : 1;\n#else\n  unsigned int degree : 31;\n  unsigned int mark : 1;\n#endif\n} *fibnode_t;\n\nextern fibheap_t fibheap_new PARAMS ((void));\nextern fibnode_t fibheap_insert PARAMS ((fibheap_t, fibheapkey_t, void *));\nextern int fibheap_empty PARAMS ((fibheap_t));\nextern fibheapkey_t fibheap_min_key PARAMS ((fibheap_t));\nextern fibheapkey_t fibheap_replace_key PARAMS ((fibheap_t, fibnode_t,\n\t\t\t\t\t\t fibheapkey_t));\nextern void *fibheap_replace_key_data PARAMS ((fibheap_t, fibnode_t,\n\t\t\t\t\t       fibheapkey_t, void *));\nextern void *fibheap_extract_min PARAMS ((fibheap_t));\nextern void *fibheap_min PARAMS ((fibheap_t));\nextern void *fibheap_replace_data PARAMS ((fibheap_t, fibnode_t, void *));\nextern void *fibheap_delete_node PARAMS ((fibheap_t, fibnode_t));\nextern void fibheap_delete PARAMS ((fibheap_t));\nextern fibheap_t fibheap_union PARAMS ((fibheap_t, fibheap_t));\n\n#endif /* _FIBHEAP_H_ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILENAME": {"ttr": 3075, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Macros for taking apart, interpreting and processing file names.\n\n   These are here because some non-Posix (a.k.a. DOSish) systems have\n   drive letter brain-damage at the beginning of an absolute file name,\n   use forward- and back-slash in path names interchangeably, and\n   some of them have case-insensitive file names.\n\n   Copyright 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of BFD, the Binary File Descriptor library.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef FILENAMES_H\n#define FILENAMES_H\n\n#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)\n\n#ifndef HAVE_DOS_BASED_FILE_SYSTEM\n#define HAVE_DOS_BASED_FILE_SYSTEM 1\n#endif\n\n#define IS_DIR_SEPARATOR(c)\t((c) == '/' || (c) == '\\\\')\n/* Note that IS_ABSOLUTE_PATH accepts d:foo as well, although it is\n   only semi-absolute.  This is because the users of IS_ABSOLUTE_PATH\n   want to know whether to prepend the current working directory to\n   a file name, which should not be done with a name like d:foo.  */\n#define IS_ABSOLUTE_PATH(f)\t(IS_DIR_SEPARATOR((f)\u00dd0\u00a8) || (((f)\u00dd0\u00a8) && ((f)\u00dd1\u00a8 == ':')))\n#define FILENAME_CMP(s1, s2)\tstrcasecmp(s1, s2)\n\n#else  /* not DOSish */\n\n#define IS_DIR_SEPARATOR(c)\t((c) == '/')\n#define IS_ABSOLUTE_PATH(f)\t(IS_DIR_SEPARATOR((f)\u00dd0\u00a8))\n#define FILENAME_CMP(s1, s2)\tstrcmp(s1, s2)\n\n#endif /* not DOSish */\n\n#endif /* FILENAMES_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLAGS": {"ttr": 3077, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Compilation switch flag definitions for GCC.\n   Copyright (C) 1987, 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,\n   200\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_FLAGS_H\n#define GCC_FLAGS_H\n\nenum debug_info_type\n{\n  NO_DEBUG,\t    /* Write no debug info.  */\n  DBX_DEBUG,\t    /* Write BSD .stabs for DBX (using dbxout.c).  */\n  SDB_DEBUG,\t    /* Write COFF for (old) SDB (using sdbout.c).  */\n  DWARF_DEBUG,\t    /* Write Dwarf debug info (using dwarfout.c).  */\n  DWARF2_DEBUG,\t    /* Write Dwarf v2 debug info (using dwarf2out.c).  */\n  XCOFF_DEBUG,\t    /* Write IBM/Xcoff debug info (using dbxout.c).  */\n  VMS_DEBUG,        /* Write VMS debug info (using vmsdbgout.c).  */\n  VMS_AND_DWARF2_DEBUG /* Write VMS debug info (using vmsdbgout.c).\n                          and DWARF v2 debug info (using dwarf2out.c).  */\n};\n\n/* Specify which kind of debugging info to generate.  */\nextern enum debug_info_type write_symbols;\n\n/* Names of debug_info_type, for error messages.  */\nextern const char *const debug_type_names\u00dd\u00a8;\n\nenum debug_info_level\n{\n  DINFO_LEVEL_NONE,\t/* Write no debugging info.  */\n  DINFO_LEVEL_TERSE,\t/* Write minimal info to support tracebacks only.  */\n  DINFO_LEVEL_NORMAL,\t/* Write info for all declarations (and line table).  */\n  DINFO_LEVEL_VERBOSE\t/* Write normal info plus #define/#undef info.  */\n};\n\n/* Specify how much debugging info to generate.  */\nextern enum debug_info_level debug_info_level;\n\n/* Nonzero means use GNU-only extensions in the generated symbolic\n   debugging information.  */\nextern bool use_gnu_debug_info_extensions;\n\n/* Nonzero means emit debugging information only for symbols which are used.  */\nextern int flag_debug_only_used_symbols;\n\n/* Nonzero means do optimizations.  -opt.  */\n\nextern int optimize;\n\n/* Nonzero means optimize for size.  -Os.  */\n\nextern int optimize_size;\n\n/* Don't print functions as they are compiled and don't print\n   times taken by the various passes.  -quiet.  */\n\nextern int quiet_flag;\n\n/* Print memory still in use at end of compilation (which may have little\n   to do with peak memory consumption).  -fmem-report.  */\n\nextern int mem_report;\n\n/* Don't print warning messages.  -w.  */\n\nextern bool inhibit_warnings;\n\n/* Don't suppress warnings from system headers.  -Wsystem-headers.  */\n\nextern bool warn_system_headers;\n\n/* Do print extra warnings (such as for uninitialized variables).\n   -W/-Wextra.  */\n\nextern bool extra_warnings;\n\n/* If -Werror.  */\n\nextern bool warnings_are_errors;\n\n/* Nonzero to warn about unused variables, functions et.al.  Use\n   set_Wunused() to update the -Wunused-* flags that correspond to the\n   -Wunused option.  */\n\nextern void set_Wunused (int setting);\n\nextern bool warn_unused_function;\nextern bool warn_unused_label;\nextern bool warn_unused_parameter;\nextern bool warn_unused_variable;\nextern bool warn_unused_value;\n\n/* Nonzero to warn about code which is never reached.  */\n\nextern bool warn_notreached;\n\n/* Nonzero means warn if inline function is too large.  */\n\nextern bool warn_inline;\n\n/* Nonzero to warn about variables used before they are initialized.  */\n\nextern int warn_uninitialized;\n\n/* Nonzero means warn about all declarations which shadow others.  */\n\nextern bool warn_shadow;\n\n/* Warn if a switch on an enum, that does not have a default case,\n   fails to have a case for every enum value.  */\n\nextern bool warn_switch;\n\n/* Warn if a switch does not have a default case.  */\n\nextern bool warn_switch_default;\n\n/* Warn if a switch on an enum fails to have a case for every enum\n   value (regardless of the presence or otherwise of a default case).  */\n\nextern bool warn_switch_enum;\n\n/* Nonzero means warn about function definitions that default the return type\n   or that use a null return and have a return-type other than void.  */\n\nextern int warn_return_type;\n\n/* Warn about functions which might be candidates for attribute noreturn.  */\n\nextern bool warn_missing_noreturn;\n\n/* Nonzero means warn about pointer casts that increase the required\n   alignment of the target type (and might therefore lead to a crash\n   due to a misaligned access).  */\n\nextern bool warn_cast_align;\n\n/* Nonzero means warn about any objects definitions whose size is larger\n   than N bytes.  Also want about function definitions whose returned\n   values are larger than N bytes. The value N is in `larger_than_size'.  */\n\nextern bool warn_larger_than;\nextern HOST_WIDE_INT larger_than_size;\n\n/* Warn if a function returns an aggregate,\n   since there are often incompatible calling conventions for doing this.  */\n\nextern bool warn_aggregate_return;\n\n/* Warn if packed attribute on struct is unnecessary and inefficient.  */\n\nextern bool warn_packed;\n\n/* Warn when gcc pads a structure to an alignment boundary.  */\n\nextern bool warn_padded;\n\n/* Warn when an optimization pass is disabled.  */\n\nextern bool warn_disabled_optimization;\n\n/* Nonzero means warn about uses of __attribute__((deprecated))\n   declarations.  */\n\nextern bool warn_deprecated_decl;\n\n/* Nonzero means warn about constructs which might not be strict\n   aliasing safe.  */\n\nextern bool warn_strict_aliasing;\n\n/* Nonzero if generating code to do profiling.  */\n\nextern int profile_flag;\n\n/* Nonzero if generating code to profile program flow graph arcs.  */\n\nextern int profile_arc_flag;\n\n/* Nonzero if value profile should be measured.  */\n\nextern int flag_profile_values;\n\n#if IFOX\n/* used to work around the 399 identifier limit of IFOX */\nextern int gflags\u00dd64\u00a8;\n#endif\n\n#if !IFOX\n/* Nonzero if generating info for gcov to calculate line test coverage.  */\n\nextern int flag_test_coverage;\n\n/* Nonzero indicates that branch taken probabilities should be calculated.  */\n\nextern int flag_branch_probabilities;\n\n/* Nonzero if basic blocks should be reordered.  */\n\nextern int flag_reorder_blocks;\n\n/* Nonzero if functions should be reordered.  */\n\nextern int flag_reorder_functions;\n\n/* Nonzero if registers should be renamed.  */\n\nextern int flag_rename_registers;\n#endif\n\n/* Nonzero for -pedantic switch: warn about anything\n   that standard C forbids.  */\n\nextern int pedantic;\n\n/* Temporarily suppress certain warnings.\n   This is set while reading code from a system header file.  */\n\nextern int in_system_header;\n\n/* Nonzero for -dp: annotate the assembly with a comment describing the\n   pattern and alternative used.  */\n\nextern int flag_print_asm_name;\n\n/* Now the symbols that are set with `-f' switches.  */\n\n#if !IFOX\n/* Nonzero means `char' should be signed.  */\n\nextern int flag_signed_char;\n\n/* Nonzero means give an enum type only as many bytes as it needs.  */\n\nextern int flag_short_enums;\n\n/* Nonzero for -fcaller-saves: allocate values in regs that need to\n   be saved across function calls, if that produces overall better code.\n   Optional now, so people can test it.  */\n\nextern int flag_caller_saves;\n#endif\n\n/* Nonzero for -fpcc-struct-return: return values the same way PCC does.  */\n\nextern int flag_pcc_struct_return;\n\n#if !IFOX\n/* Nonzero for -fforce-mem: load memory value into a register\n   before arithmetic on it.  This makes better cse but slower compilation.  */\n\nextern int flag_force_mem;\n\n/* Nonzero for -fforce-addr: load memory address into a register before\n   reference to memory.  This makes better cse but slower compilation.  */\n\nextern int flag_force_addr;\n\n/* Nonzero for -fdefer-pop: don't pop args after each function call;\n   instead save them up to pop many calls' args with one insns.  */\n\nextern int flag_defer_pop;\n\n/* Nonzero for -ffloat-store: don't allocate floats and doubles\n   in extended-precision registers.  */\n\nextern int flag_float_store;\n\n/* Nonzero enables strength-reduction in loop.c.  */\n\nextern int flag_strength_reduce;\n\n/* Nonzero enables loop unrolling in unroll.c.  Only loops for which the\n   number of iterations can be calculated at compile-time (UNROLL_COMPLETELY,\n   UNROLL_MODULO) or at run-time (preconditioned to be UNROLL_MODULO) are\n   unrolled.  */\n\nextern int flag_old_unroll_loops;\n\n/* Nonzero enables loop unrolling in unroll.c.  All loops are unrolled.\n   This is generally not a win.  */\n\nextern int flag_old_unroll_all_loops;\n\n/* Nonzero forces all invariant computations in loops to be moved\n   outside the loop.  */\n\nextern int flag_move_all_movables;\n\n/* Nonzero enables prefetch optimizations for arrays in loops.  */\n\nextern int flag_prefetch_loop_arrays;\n\n/* Nonzero forces all general induction variables in loops to be\n   strength reduced.  */\n\nextern int flag_reduce_all_givs;\n\n/* Nonzero for -fcse-follow-jumps:\n   have cse follow jumps to do a more extensive job.  */\n\nextern int flag_cse_follow_jumps;\n\n/* Nonzero for -fcse-skip-blocks:\n   have cse follow a branch around a block.  */\n\nextern int flag_cse_skip_blocks;\n\n/* Nonzero for -fexpensive-optimizations:\n   perform miscellaneous relatively-expensive optimizations.  */\nextern int flag_expensive_optimizations;\n\n/* Nonzero for -fwritable-strings:\n   store string constants in data segment and don't uniquize them.  */\n\nextern int flag_writable_strings;\n\n/* Nonzero means don't put addresses of constant functions in registers.\n   Used for compiling the Unix kernel, where strange substitutions are\n   done on the assembly output.  */\n\nextern int flag_no_function_cse;\n\n/* Nonzero for -fomit-frame-pointer:\n   don't make a frame pointer in simple functions that don't require one.  */\n\nextern int flag_omit_frame_pointer;\n\n/* Nonzero to inhibit use of define_optimization peephole opts.  */\n\nextern int flag_no_peephole;\n\n/* Nonzero allows GCC to optimize sibling and tail recursive calls.  */\n\nextern int flag_optimize_sibling_calls;\n#endif\n\n/* Nonzero means the front end generally wants `errno' maintained by math\n   operations, like built-in SQRT.  */\n\nextern int flag_errno_math;\n\n/* Nonzero means that unsafe floating-point math optimizations are allowed\n   for the sake of speed.  IEEE compliance is not guaranteed, and operations\n   are allowed to assume that their arguments and results are \"normal\"\n   (e.g., nonnegative for SQRT).  */\n\nextern int flag_unsafe_math_optimizations;\n\n/* Nonzero means that no NaNs or +-Infs are expected.  */\n\nextern int flag_finite_math_only;\n\n/* Zero means that floating-point math operations cannot generate a\n   (user-visible) trap.  This is the case, for example, in nonstop\n   IEEE 754 arithmetic.  */\n\nextern int flag_trapping_math;\n\n#if !IFOX\n/* Nonzero means disable transformations that assume default floating\n   point rounding behavior.  */\n\nextern int flag_rounding_math;\n\n/* 0 means straightforward implementation of complex divide acceptable.\n   1 means wide ranges of inputs must work for complex divide.\n   2 means C99-like requirements for complex divide (not yet implemented).  */\n\nextern int flag_complex_divide_method;\n#endif\n\n/* Nonzero means to run loop optimizations twice.  */\n\nextern int flag_rerun_loop_opt;\n\n/* Nonzero means make functions that look like good inline candidates\n   go inline.  */\n\nextern int flag_inline_functions;\n\n/* Nonzero for -fkeep-inline-functions: even if we make a function\n   go inline everywhere, keep its definition around for debugging\n   purposes.  */\n\nextern int flag_keep_inline_functions;\n\n/* Nonzero means that functions declared `inline' will be treated\n   as `static'.  Prevents generation of zillions of copies of unused\n   static inline functions; instead, `inlines' are written out\n   only when actually used.  Used in conjunction with -g.  Also\n   does the right thing with #pragma interface.  */\n\nextern int flag_no_inline;\n\n/* Nonzero means that we don't want inlining by virtue of -fno-inline,\n   not just because the tree inliner turned us off.  */\n\nextern int flag_really_no_inline;\n\n#if !IFOX\n/* Nonzero if we are only using compiler to check syntax errors.  */\n\nextern int flag_syntax_only;\n#endif\n\n/* Nonzero means we should save auxiliary info into a .X file.  */\n\nextern int flag_gen_aux_info;\n\n#if !IFOX\n/* Nonzero means make the text shared if supported.  */\n\nextern int flag_shared_data;\n#endif\n\n/* flag_schedule_insns means schedule insns within basic blocks (before\n   local_alloc).\n   flag_schedule_insns_after_reload means schedule insns after\n   global_alloc.  */\n\nextern int flag_schedule_insns;\nextern int flag_schedule_insns_after_reload;\nextern int flag_sched2_use_superblocks;\nextern int flag_sched2_use_traces;\n\n/* The following flags have effect only for scheduling before register\n   allocation:\n\n   flag_schedule_interblock means schedule insns across basic blocks.\n   flag_schedule_speculative means allow speculative motion of non-load insns.\n   flag_schedule_speculative_load means allow speculative motion of some\n   load insns.\n   flag_schedule_speculative_load_dangerous allows speculative motion of more\n   load insns.  */\n\nextern int flag_schedule_interblock;\nextern int flag_schedule_speculative;\nextern int flag_schedule_speculative_load;\nextern int flag_schedule_speculative_load_dangerous;\n\n/* The following flags have an effect during scheduling after register\n   allocation:\n\n   sched_stalled_insns means that insns can be moved prematurely from the queue\n   of stalled insns into the ready list.\n\n   sched_stalled_insns_dep controls how many recently scheduled cycles will\n   be examined for a dependency on a stalled insn that is candidate for\n   premature removal from the queue of stalled insns into the ready list (has\n   an effect only if the flag 'sched_stalled_insns' is set).  */\n\nextern int flag_sched_stalled_insns;\nextern int flag_sched_stalled_insns_dep;\n\n/* flag_branch_on_count_reg means try to replace add-1,compare,branch tupple\n   by a cheaper branch, on a count register.  */\nextern int flag_branch_on_count_reg;\n\n/* This option is set to 1 on -fsingle-precision-constant option which is\n   used to convert the floating point constants to single precision\n   constants.  */\n\nextern int flag_single_precision_constant;\n\n/* Nonzero means put things in delayed-branch slots if supported.  */\n\nextern int flag_delayed_branch;\n\n/* Nonzero means suppress output of instruction numbers and line number\n   notes in debugging dumps.  */\n\nextern int flag_dump_unnumbered;\n\n/* Nonzero means change certain warnings into errors.\n   Usually these are warnings about failure to conform to some standard.  */\n\nextern int flag_pedantic_errors;\n\n/* Nonzero means generate position-independent code.  1 vs 2 for a\n   target-dependent \"small\" or \"large\" mode.  */\n\nextern int flag_pic;\n\n/* Nonzero if we are compiling position independent code for executable.\n   1 vs 2 for a target-dependent \"small\" or \"large\" mode.  */\n\nextern int flag_pie;\n\n/* Nonzero if we are compiling code for a shared library, zero for\n   executable.  */\n\nextern int flag_shlib;\n\n/* Nonzero means generate extra code for exception handling and enable\n   exception handling.  */\n\nextern int flag_exceptions;\n\n/* Nonzero means generate frame unwind info table when supported.  */\n\nextern int flag_unwind_tables;\n\n/* Nonzero means generate frame unwind info table exact at each insn boundary.  */\n\nextern int flag_asynchronous_unwind_tables;\n\n/* Nonzero means don't place uninitialized global data in common storage\n   by default.  */\n\nextern int flag_no_common;\n\n/* -finhibit-size-directive inhibits output of .size for ELF.\n   This is used only for compiling crtstuff.c,\n   and it may be extended to other effects\n   needed for crtstuff.c on other systems.  */\nextern int flag_inhibit_size_directive;\n\n#if !IFOX\n/* Nonzero means place each function into its own section on those platforms\n   which support arbitrary section names and unlimited numbers of sections.  */\n\nextern int flag_function_sections;\n\n/* ... and similar for data.  */\n\nextern int flag_data_sections;\n#endif\n\n/* -fverbose-asm causes extra commentary information to be produced in\n   the generated assembly code (to make it more readable).  This option\n   is generally only of use to those who actually need to read the\n   generated assembly code (perhaps while debugging the compiler itself).\n   -fno-verbose-asm, the default, causes the extra information\n   to not be added and is useful when comparing two assembler files.  */\n\nextern int flag_verbose_asm;\n\n/* -dA causes debug information to be produced in\n   the generated assembly code (to make it more readable).  This option\n   is generally only of use to those who actually need to read the\n   generated assembly code (perhaps while debugging the compiler itself).\n   Currently, this switch is only used by dwarfout.c; however, it is intended\n   to be a catchall for printing debug information in the assembler file.  */\n\nextern int flag_debug_asm;\n\nextern int flag_dump_rtl_in_asm;\n\n/* Greater than zero if user symbols are prepended by a leading underscore\n   in generated assembly code.  */\nextern int flag_leading_underscore;\n\n/* Tag all structures with __attribute__(packed) */\nextern int flag_pack_struct;\n\n/* This flag is only tested if alias checking is enabled.\n   0 if pointer arguments may alias each other.  True in C.\n   1 if pointer arguments may not alias each other but may alias\n   global variables.\n   2 if pointer arguments may not alias each other and may not\n   alias global variables.  True in Fortran.\n   The value is ignored if flag_alias_check is 0.  */\nextern int flag_argument_noalias;\n\n/* Nonzero if we should do (language-dependent) alias analysis.\n   Typically, this analysis will assume that expressions of certain\n   types do not alias expressions of certain other types.  Only used\n   if alias analysis (in general) is enabled.  */\nextern int flag_strict_aliasing;\n\n/* Emit code to probe the stack, to help detect stack overflow; also\n   may cause large objects to be allocated dynamically.  */\nextern int flag_stack_check;\n\n/* Do the full regmove optimization pass.  */\nextern int flag_regmove;\n\n/* Instrument functions with calls at entry and exit, for profiling.  */\nextern int flag_instrument_function_entry_exit;\n\n/* Perform a peephole pass before sched2.  */\nextern int flag_peephole2;\n\n/* Try to guess branch probabilities.  */\nextern int flag_guess_branch_prob;\n\n/* -fcheck-bounds causes gcc to generate array bounds checks.\n   For C, C++ and ObjC: defaults off.\n   For Java: defaults to on.\n   For Fortran: defaults to off.  */\nextern int flag_bounds_check;\n\n/* This will attempt to merge constant section constants, if 1 only\n   string constants and constants from constant pool, if 2 also constant\n   variables.  */\nextern int flag_merge_constants;\n\n/* If one, renumber instruction UIDs to reduce the number of\n   unused UIDs if there are a lot of instructions.  If greater than\n   one, unconditionally renumber instruction UIDs.  */\nextern int flag_renumber_insns;\n\n/* Other basic status info about current function.  */\n\n/* Nonzero means current function must be given a frame pointer.\n   Set in stmt.c if anything is allocated on the stack there.\n   Set in reload1.c if anything is allocated on the stack there.  */\n\nextern int frame_pointer_needed;\n\n/* Nonzero if the generated code should trap on signed overflow\n   for PLUS / SUB / MULT.  */\nextern int flag_trapv;\n\n/* Nonzero if the signed arithmetic overflow should wrap around.  */\nextern int flag_wrapv;\n\n/* Nonzero if subexpressions must be evaluated from left-to-right.  */\nextern int flag_evaluation_order;\n\n/* Value of the -G xx switch, and whether it was passed or not.  */\nextern unsigned HOST_WIDE_INT g_switch_value;\nextern bool g_switch_set;\n\n/* Values of the -falign-* flags: how much to align labels in code.\n   0 means `use default', 1 means `don't align'.\n   For each variable, there is an _log variant which is the power\n   of two not less than the variable, for .align output.  */\n\nextern int align_loops;\nextern int align_loops_log;\nextern int align_loops_max_skip;\nextern int align_jumps;\nextern int align_jumps_log;\nextern int align_jumps_max_skip;\nextern int align_labels;\nextern int align_labels_log;\nextern int align_labels_max_skip;\nextern int align_functions;\nextern int align_functions_log;\n\n/* Like align_functions_log above, but used by front-ends to force the\n   minimum function alignment.  Zero means no alignment is forced.  */\nextern int force_align_functions_log;\n\n/* Nonzero if we dump in VCG format, not plain text.  */\nextern int dump_for_graph;\n\n/* Selection of the graph form.  */\nenum graph_dump_types\n{\n  no_graph = 0,\n  vcg\n};\nextern enum graph_dump_types graph_dump_format;\n\n/* Nonzero means ignore `#ident' directives.  0 means handle them.\n   On SVR4 targets, it also controls whether or not to emit a\n   string identifying the compiler.  */\n\nextern int flag_no_ident;\n\n#if !IFOX\n/* Nonzero means perform global CSE.  */\n\nextern int flag_gcse;\n#endif\n\n/* Nonzero if we want to perform enhanced load motion during gcse.  */\n\nextern int flag_gcse_lm;\n\n/* Nonzero if we want to perform store motion after gcse.  */\n\nextern int flag_gcse_sm;\n\n/* Nonzero if we want to perform redundant load-after-store elimination\n   in gcse.  */\n\nextern int flag_gcse_las;\n\n#if !IFOX\n/* Nonzero if value histograms should be used to optimize code.  */\nextern int flag_value_profile_transformations;\n#endif\n\n/* Perform branch target register optimization before prologue / epilogue\n   threading.  */\n\nextern int flag_branch_target_load_optimize;\n\n/* Perform branch target register optimization after prologue / epilogue\n   threading and jump2.  */\n\nextern int flag_branch_target_load_optimize2;\n\n\n/* Nonzero means we should do dwarf2 duplicate elimination.  */\n\nextern int flag_eliminate_dwarf2_dups;\n\n/* Nonzero means we should do unused type elimination.  */\n\nextern int flag_eliminate_unused_debug_types;\n\n/* Nonzero means to collect statistics which might be expensive\n   and to print them when we are done.  */\nextern int flag_detailed_statistics;\n\n/* Nonzero means enable synchronous exceptions for non-call instructions.  */\nextern int flag_non_call_exceptions;\n\n/* Nonzero means put zero initialized data in the bss section.  */\nextern int flag_zero_initialized_in_bss;\n\n#if !IFOX\n/* Nonzero means disable transformations observable by signaling NaNs.  */\nextern int flag_signaling_nans;\n#endif\n\nextern int flag_unit_at_a_time;\n\n#if !IFOX\nextern int flag_web;\n#endif\n\n/* Nonzero means that we defer emitting functions until they are actually\n   used.  */\nextern int flag_remove_unreachable_functions;\n\n/* A string that's used when a random name is required.  NULL means\n   to make it really random.  */\n\nextern const char *flag_random_seed;\n\n/*  The version of the C++ ABI in use.  The following values are\n    allowed:\n\n    0: The version of the ABI believed most conformant with the\n       C++ ABI specification.  This ABI may change as bugs are\n       discovered and fixed.  Therefore, 0 will not necessarily\n       indicate the same ABI in different versions of G++.\n\n    1: The version of the ABI first used in G++ 3.2.\n\n    Additional positive integers will be assigned as new versions of\n    the ABI become the default version of the ABI.  */\n\nextern int flag_abi_version;\n\n/* Returns TRUE if generated code should match ABI version N or\n   greater is in use.  */\n\n#define abi_version_at_least(N) \\\n  (flag_abi_version == 0 || flag_abi_version >= (N))\n\n/* True if the given mode has a NaN representation and the treatment of\n   NaN operands is important.  Certain optimizations, such as folding\n   x * 0 into x, are not correct for NaN operands, and are normally\n   disabled for modes with NaNs.  The user can ask for them to be\n   done anyway using the -funsafe-math-optimizations switch.  */\n#define HONOR_NANS(MODE) \\\n  (MODE_HAS_NANS (MODE) && !flag_finite_math_only)\n\n/* Like HONOR_NANs, but true if we honor signaling NaNs (or sNaNs).  */\n#define HONOR_SNANS(MODE) (flag_signaling_nans && HONOR_NANS (MODE))\n\n/* As for HONOR_NANS, but true if the mode can represent infinity and\n   the treatment of infinite values is important.  */\n#define HONOR_INFINITIES(MODE) \\\n  (MODE_HAS_INFINITIES (MODE) && !flag_finite_math_only)\n\n/* Like HONOR_NANS, but true if the given mode distinguishes between\n   positive and negative zero, and the sign of zero is important.  */\n#define HONOR_SIGNED_ZEROS(MODE) \\\n  (MODE_HAS_SIGNED_ZEROS (MODE) && !flag_unsafe_math_optimizations)\n\n/* Like HONOR_NANS, but true if given mode supports sign-dependent rounding,\n   and the rounding mode is important.  */\n#define HONOR_SIGN_DEPENDENT_ROUNDING(MODE) \\\n  (MODE_HAS_SIGN_DEPENDENT_ROUNDING (MODE) && flag_rounding_math)\n\n#endif /* ! GCC_FLAGS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLOATFOR": {"ttr": 3083, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* IEEE floating point support declarations, for GDB, the GNU Debugger.\n   Copyright 1991, 1994, 1995, 1997, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GDB.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#if !defined (FLOATFORMAT_H)\n#define FLOATFORMAT_H 1\n\n#include \"ansidecl.h\"\n\n/* A floatformat consists of a sign bit, an exponent and a mantissa.  Once the\n   bytes are concatenated according to the byteorder flag, then each of those\n   fields is contiguous.  We number the bits with 0 being the most significant\n   (i.e. BITS_BIG_ENDIAN type numbering), and specify which bits each field\n   contains with the *_start and *_len fields.  */\n\n/* What is the order of the bytes. */\n\nenum floatformat_byteorders {\n\n  /* Standard little endian byte order.\n     EX: 1.2345678e10 => 00 00 80 c5 e0 fe 06 42 */\n\n  floatformat_little,\n\n  /* Standard big endian byte order.\n     EX: 1.2345678e10 => 42 06 fe e0 c5 80 00 00 */\n\n  floatformat_big,\n\n  /* Little endian byte order but big endian word order.\n     EX: 1.2345678e10 => e0 fe 06 42 00 00 80 c5 */\n\n  floatformat_littlebyte_bigword\n\n};\n\nenum floatformat_intbit { floatformat_intbit_yes, floatformat_intbit_no };\n\nstruct floatformat\n{\n  enum floatformat_byteorders byteorder;\n  unsigned int totalsize;\t/* Total size of number in bits */\n\n  /* Sign bit is always one bit long.  1 means negative, 0 means positive.  */\n  unsigned int sign_start;\n\n  unsigned int exp_start;\n  unsigned int exp_len;\n  /* Bias added to a \"true\" exponent to form the biased exponent.  It\n     is intentionally signed as, otherwize, -exp_bias can turn into a\n     very large number (e.g., given the exp_bias of 0x3fff and a 64\n     bit long, the equation (long)(1 - exp_bias) evaluates to\n     4294950914) instead of -16382).  */\n  int exp_bias;\n  /* Exponent value which indicates NaN.  This is the actual value stored in\n     the float, not adjusted by the exp_bias.  This usually consists of all\n     one bits.  */\n  unsigned int exp_nan;\n\n  unsigned int man_start;\n  unsigned int man_len;\n\n  /* Is the integer bit explicit or implicit?  */\n  enum floatformat_intbit intbit;\n\n  /* Internal name for debugging. */\n  const char *name;\n\n  /* Validator method.  */\n  int (*is_valid) PARAMS ((const struct floatformat *fmt, const char *from));\n};\n\n/* floatformats for IEEE single and double, big and little endian.  */\n\nextern const struct floatformat floatformat_ieee_single_big;\nextern const struct floatformat floatformat_ieee_single_little;\nextern const struct floatformat floatformat_ieee_double_big;\nextern const struct floatformat floatformat_ieee_double_little;\n\n/* floatformat for ARM IEEE double, little endian bytes and big endian words */\n\nextern const struct floatformat floatformat_ieee_double_littlebyte_bigword;\n\n/* floatformats for various extendeds.  */\n\nextern const struct floatformat floatformat_i387_ext;\nextern const struct floatformat floatformat_m68881_ext;\nextern const struct floatformat floatformat_i960_ext;\nextern const struct floatformat floatformat_m88110_ext;\nextern const struct floatformat floatformat_m88110_harris_ext;\nextern const struct floatformat floatformat_arm_ext_big;\nextern const struct floatformat floatformat_arm_ext_littlebyte_bigword;\n/* IA-64 Floating Point register spilt into memory.  */\nextern const struct floatformat floatformat_ia64_spill_big;\nextern const struct floatformat floatformat_ia64_spill_little;\nextern const struct floatformat floatformat_ia64_quad_big;\nextern const struct floatformat floatformat_ia64_quad_little;\n\n/* Convert from FMT to a double.\n   FROM is the address of the extended float.\n   Store the double in *TO.  */\n\nextern void\nfloatformat_to_double PARAMS ((const struct floatformat *, const char *, double *));\n\n/* The converse: convert the double *FROM to FMT\n   and store where TO points.  */\n\nextern void\nfloatformat_from_double PARAMS ((const struct floatformat *,\n\t\t\t\t const double *, char *));\n\n/* Return non-zero iff the data at FROM is a valid number in format FMT.  */\n\nextern int\nfloatformat_is_valid PARAMS ((const struct floatformat *fmt, const char *from));\n\n#endif\t/* defined (FLOATFORMAT_H) */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FNMATCH": {"ttr": 3085, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Copyright 1991, 1992, 1993, 1996 Free Software Foundation, Inc.\n\nNOTE: The canonical source of this file is maintained with the GNU C Library.\nBugs can be reported to bug-glibc@prep.ai.mit.edu.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef\t_FNMATCH_H\n\n#define\t_FNMATCH_H\t1\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)\n#undef\t__P\n#define\t__P(args)\targs\n#else /* Not C++ or ANSI C.  */\n#undef\t__P\n#define\t__P(args)\t()\n/* We can get away without defining `const' here only because in this file\n   it is used only inside the prototype for `fnmatch', which is elided in\n   non-ANSI C where `const' is problematical.  */\n#endif /* C++ or ANSI C.  */\n\n\n/* We #undef these before defining them because some losing systems\n   (HP-UX A.08.07 for example) define these in <unistd.h>.  */\n#undef\tFNM_PATHNAME\n#undef\tFNM_NOESCAPE\n#undef\tFNM_PERIOD\n\n/* Bits set in the FLAGS argument to `fnmatch'.  */\n#define\tFNM_PATHNAME\t(1 << 0) /* No wildcard can ever match `/'.  */\n#define\tFNM_NOESCAPE\t(1 << 1) /* Backslashes don't quote special chars.  */\n#define\tFNM_PERIOD\t(1 << 2) /* Leading `.' is matched only explicitly.  */\n\n#if !defined (_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 2 || defined (_GNU_SOURCE)\n#define\tFNM_FILE_NAME\tFNM_PATHNAME /* Preferred GNU name.  */\n#define\tFNM_LEADING_DIR\t(1 << 3) /* Ignore `/...' after a match.  */\n#define\tFNM_CASEFOLD\t(1 << 4) /* Compare without regard to case.  */\n#endif\n\n/* Value returned by `fnmatch' if STRING does not match PATTERN.  */\n#define\tFNM_NOMATCH\t1\n\n/* Match STRING against the filename pattern PATTERN,\n   returning zero if it matches, FNM_NOMATCH if not.  */\nextern int fnmatch __P ((const char *pattern, const char *string,\n\t\t\t int flags));\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* fnmatch.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FUNCTION": {"ttr": 3087, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Structure for saving state for a nested function.\n   Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_FUNCTION_H\n#define GCC_FUNCTION_H\n\nstruct var_refs_queue GTY(())\n{\n  rtx modified;\n  enum machine_mode promoted_mode;\n  int unsignedp;\n  struct var_refs_queue *next;\n};\n\n/* Stack of pending (incomplete) sequences saved by `start_sequence'.\n   Each element describes one pending sequence.\n   The main insn-chain is saved in the last element of the chain,\n   unless the chain is empty.  */\n\nstruct sequence_stack GTY(())\n{\n  /* First and last insns in the chain of the saved sequence.  */\n  rtx first;\n  rtx last;\n  tree sequence_rtl_expr;\n  struct sequence_stack *next;\n};\n\nextern struct sequence_stack *sequence_stack;\n\n/* Stack of single obstacks.  */\n\nstruct simple_obstack_stack\n{\n  struct obstack *obstack;\n  struct simple_obstack_stack *next;\n};\n\nstruct emit_status GTY(())\n{\n  /* This is reset to LAST_VIRTUAL_REGISTER + 1 at the start of each function.\n     After rtl generation, it is 1 plus the largest register number used.  */\n  int x_reg_rtx_no;\n\n  /* Lowest label number in current function.  */\n  int x_first_label_num;\n\n  /* The ends of the doubly-linked chain of rtl for the current function.\n     Both are reset to null at the start of rtl generation for the function.\n\n     start_sequence saves both of these on `sequence_stack' along with\n     `sequence_rtl_expr' and then starts a new, nested sequence of insns.  */\n  rtx x_first_insn;\n  rtx x_last_insn;\n\n  /* RTL_EXPR within which the current sequence will be placed.  Use to\n     prevent reuse of any temporaries within the sequence until after the\n     RTL_EXPR is emitted.  */\n  tree sequence_rtl_expr;\n\n  /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n     Each element describes one pending sequence.\n     The main insn-chain is saved in the last element of the chain,\n     unless the chain is empty.  */\n  struct sequence_stack *sequence_stack;\n\n  /* INSN_UID for next insn emitted.\n     Reset to 1 for each function compiled.  */\n  int x_cur_insn_uid;\n\n  /* Location the last line-number NOTE emitted.\n     This is used to avoid generating duplicates.  */\n  location_t x_last_location;\n\n  /* The length of the regno_pointer_align, regno_decl, and x_regno_reg_rtx\n     vectors.  Since these vectors are needed during the expansion phase when\n     the total number of registers in the function is not yet known, the\n     vectors are copied and made bigger when necessary.  */\n  int regno_pointer_align_length;\n\n  /* Indexed by pseudo register number, if nonzero gives the known alignment\n     for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n     Allocated in parallel with x_regno_reg_rtx.  */\n  unsigned char * GTY ((length (\"%h.x_reg_rtx_no\")))\n    regno_pointer_align;\n\n  /* Indexed by pseudo register number, gives the rtx for that pseudo.\n     Allocated in parallel with regno_pointer_align.\n\n     Note MEM expressions can appear in this array due to the actions\n     of put_var_into_stack.  */\n  rtx * GTY ((length (\"%h.x_reg_rtx_no\"))) x_regno_reg_rtx;\n};\n\n/* For backward compatibility... eventually these should all go away.  */\n#define reg_rtx_no (cfun->emit->x_reg_rtx_no)\n#define seq_rtl_expr (cfun->emit->sequence_rtl_expr)\n#define regno_reg_rtx (cfun->emit->x_regno_reg_rtx)\n#define seq_stack (cfun->emit->sequence_stack)\n\n#define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align\u00ddREGNO\u00a8)\n\nstruct expr_status GTY(())\n{\n  /* Number of units that we should eventually pop off the stack.\n     These are the arguments to function calls that have already returned.  */\n  int x_pending_stack_adjust;\n\n  /* Under some ABIs, it is the caller's responsibility to pop arguments\n     pushed for function calls.  A naive implementation would simply pop\n     the arguments immediately after each call.  However, if several\n     function calls are made in a row, it is typically cheaper to pop\n     all the arguments after all of the calls are complete since a\n     single pop instruction can be used.  Therefore, GCC attempts to\n     defer popping the arguments until absolutely necessary.  (For\n     example, at the end of a conditional, the arguments must be popped,\n     since code outside the conditional won't know whether or not the\n     arguments need to be popped.)\n\n     When INHIBIT_DEFER_POP is nonzero, however, the compiler does not\n     attempt to defer pops.  Instead, the stack is popped immediately\n     after each call.  Rather then setting this variable directly, use\n     NO_DEFER_POP and OK_DEFER_POP.  */\n  int x_inhibit_defer_pop;\n\n  /* If PREFERRED_STACK_BOUNDARY and PUSH_ROUNDING are defined, the stack\n     boundary can be momentarily unaligned while pushing the arguments.\n     Record the delta since last aligned boundary here in order to get\n     stack alignment in the nested function calls working right.  */\n  int x_stack_pointer_delta;\n\n  /* Nonzero means __builtin_saveregs has already been done in this function.\n     The value is the pseudoreg containing the value __builtin_saveregs\n     returned.  */\n  rtx x_saveregs_value;\n\n  /* Similarly for __builtin_apply_args.  */\n  rtx x_apply_args_value;\n\n  /* List of labels that must never be deleted.  */\n  rtx x_forced_labels;\n\n  /* Postincrements that still need to be expanded.  */\n  rtx x_pending_chain;\n};\n\n#define pending_stack_adjust (cfun->expr->x_pending_stack_adjust)\n#define inhibit_defer_pop (cfun->expr->x_inhibit_defer_pop)\n#define saveregs_value (cfun->expr->x_saveregs_value)\n#define apply_args_value (cfun->expr->x_apply_args_value)\n#define forced_labels (cfun->expr->x_forced_labels)\n#define pending_chain (cfun->expr->x_pending_chain)\n#define stack_pointer_delta (cfun->expr->x_stack_pointer_delta)\n\n/* This structure can save all the important global and static variables\n   describing the status of the current function.  */\n\nstruct function GTY(())\n{\n  struct eh_status *eh;\n  struct stmt_status *stmt;\n  struct expr_status *expr;\n  struct emit_status *emit;\n  struct varasm_status *varasm;\n\n  /* For function.c.  */\n\n  /* Points to the FUNCTION_DECL of this function.  */\n  tree decl;\n\n  /* Function containing this function, if any.  */\n  struct function *outer;\n\n  /* Number of bytes of args popped by function being compiled on its return.\n     Zero if no bytes are to be popped.\n     May affect compilation of return insn or of function epilogue.  */\n  int pops_args;\n\n  /* If function's args have a fixed size, this is that size, in bytes.\n     Otherwise, it is -1.\n     May affect compilation of return insn or of function epilogue.  */\n  int args_size;\n\n  /* # bytes the prologue should push and pretend that the caller pushed them.\n     The prologue must do this, but only if parms can be passed in\n     registers.  */\n  int pretend_args_size;\n\n  /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n     defined, the needed space is pushed by the prologue.  */\n  int outgoing_args_size;\n\n  /* This is the offset from the arg pointer to the place where the first\n     anonymous arg can be found, if there is one.  */\n  rtx arg_offset_rtx;\n\n  /* Quantities of various kinds of registers\n     used for the current function's args.  */\n  CUMULATIVE_ARGS args_info;\n\n  /* If nonzero, an RTL expression for the location at which the current\n     function returns its result.  If the current function returns its\n     result in a register, current_function_return_rtx will always be\n     the hard register containing the result.  */\n  rtx return_rtx;\n\n  /* The arg pointer hard register, or the pseudo into which it was copied.  */\n  rtx internal_arg_pointer;\n\n  /* Language-specific reason why the current function cannot be made\n     inline.  */\n  const char *cannot_inline;\n\n  /* Opaque pointer used by get_hard_reg_initial_val and\n     has_hard_reg_initial_val (see integrate.\u00ddhc\u00a8).  */\n  struct initial_value_struct *hard_reg_initial_vals;\n\n  /* Number of function calls seen so far in current function.  */\n  int x_function_call_count;\n\n  /* List (chain of TREE_LIST) of LABEL_DECLs for all nonlocal labels\n     (labels to which there can be nonlocal gotos from nested functions)\n     in this function.  */\n  tree x_nonlocal_labels;\n\n  /* List (chain of EXPR_LIST) of stack slots that hold the current handlers\n     for nonlocal gotos.  There is one for every nonlocal label in the\n     function; this list matches the one in nonlocal_labels.\n     Zero when function does not have nonlocal labels.  */\n  rtx x_nonlocal_goto_handler_slots;\n\n  /* List (chain of EXPR_LIST) of labels heading the current handlers for\n     nonlocal gotos.  */\n  rtx x_nonlocal_goto_handler_labels;\n\n  /* RTX for stack slot that holds the stack pointer value to restore\n     for a nonlocal goto.\n     Zero when function does not have nonlocal labels.  */\n  rtx x_nonlocal_goto_stack_level;\n\n  /* Label that will go on parm cleanup code, if any.\n     Jumping to this label runs cleanup code for parameters, if\n     such code must be run.  Following this code is the logical return\n     label.  */\n  rtx x_cleanup_label;\n\n  /* Label that will go on function epilogue.\n     Jumping to this label serves as a \"return\" instruction\n     on machines which require execution of the epilogue on all returns.  */\n  rtx x_return_label;\n\n  /* Label that will go on the end of function epilogue.\n     Jumping to this label serves as a \"naked return\" instruction\n     on machines which require execution of the epilogue on all returns.  */\n  rtx x_naked_return_label;\n\n  /* Label and register for unswitching computed gotos.  */\n  rtx computed_goto_common_label;\n  rtx computed_goto_common_reg;\n\n  /* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n     So we can mark them all live at the end of the function, if nonopt.  */\n  rtx x_save_expr_regs;\n\n  /* List (chain of EXPR_LISTs) of all stack slots in this function.\n     Made for the sake of unshare_all_rtl.  */\n  rtx x_stack_slot_list;\n\n  /* Chain of all RTL_EXPRs that have insns in them.  */\n  tree x_rtl_expr_chain;\n\n  /* Label to jump back to for tail recursion, or 0 if we have\n     not yet needed one for this function.  */\n  rtx x_tail_recursion_label;\n\n  /* Place after which to insert the tail_recursion_label if we need one.  */\n  rtx x_tail_recursion_reentry;\n\n  /* Location at which to save the argument pointer if it will need to be\n     referenced.  There are two cases where this is done: if nonlocal gotos\n     exist, or if vars stored at an offset from the argument pointer will be\n     needed by inner routines.  */\n  rtx x_arg_pointer_save_area;\n\n  /* If the function returns non-void, we will emit a clobber of the\n     return registers just in case the user fell off the end without\n     returning a proper value.  This is that insn.  */\n  rtx x_clobber_return_insn;\n\n  /* Offset to end of allocated area of stack frame.\n     If stack grows down, this is the address of the last stack slot allocated.\n     If stack grows up, this is the address for the next slot.  */\n  HOST_WIDE_INT x_frame_offset;\n\n  /* List (chain of TREE_LISTs) of static chains for containing functions.\n     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n     in an RTL_EXPR in the TREE_VALUE.  */\n  tree x_context_display;\n\n  /* List (chain of TREE_LISTs) of trampolines for nested functions.\n     The trampoline sets up the static chain and jumps to the function.\n     We supply the trampoline's address when the function's address is\n     requested.\n\n     Each link has a FUNCTION_DECL in the TREE_PURPOSE and a reg rtx\n     in an RTL_EXPR in the TREE_VALUE.  */\n  tree x_trampoline_list;\n\n  /* Insn after which register parms and SAVE_EXPRs are born, if nonopt.  */\n  rtx x_parm_birth_insn;\n\n  /* Last insn of those whose job was to put parms into their nominal\n     homes.  */\n  rtx x_last_parm_insn;\n\n  /* 1 + last pseudo register number possibly used for loading a copy\n     of a parameter of this function.  */\n  unsigned int x_max_parm_reg;\n\n  /* Vector indexed by REGNO, containing location on stack in which\n     to put the parm which is nominally in pseudo register REGNO,\n     if we discover that that parm must go in the stack.  The highest\n     element in this vector is one less than MAX_PARM_REG, above.  */\n  rtx * GTY ((length (\"%h.x_max_parm_reg\"))) x_parm_reg_stack_loc;\n\n  /* List of all temporaries allocated, both available and in use.  */\n  struct temp_slot *x_temp_slots;\n\n  /* Current nesting level for temporaries.  */\n  int x_temp_slot_level;\n\n  /* Current nesting level for variables in a block.  */\n  int x_var_temp_slot_level;\n\n  /* When temporaries are created by TARGET_EXPRs, they are created at\n     this level of temp_slot_level, so that they can remain allocated\n     until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n     of TARGET_EXPRs.  */\n  int x_target_temp_slot_level;\n\n  /* This slot is initialized as 0 and is added to\n     during the nested function.  */\n  struct var_refs_queue *fixup_var_refs_queue;\n\n  /* For integrate.c.  */\n  int inlinable;\n  int no_debugging_symbols;\n  rtvec original_arg_vector;\n  tree original_decl_initial;\n  /* Last insn of those whose job was to put parms into their nominal\n     homes.  */\n  rtx inl_last_parm_insn;\n  /* Highest label number in current function.  */\n  int inl_max_label_num;\n\n  /* Function sequence number for profiling, debugging, etc.  */\n  int funcdef_no;\n\n  /* For md files.  */\n\n  /* tm.h can use this to store whatever it likes.  */\n  struct machine_function * GTY ((maybe_undef (\"\"))) machine;\n  /* The largest alignment of slot allocated on the stack.  */\n  int stack_alignment_needed;\n  /* Preferred alignment of the end of stack frame.  */\n  int preferred_stack_boundary;\n  /* Set when the call to function itself has been emit.  */\n  bool recursive_call_emit;\n\n  /* Language-specific code can use this to store whatever it likes.  */\n  struct language_function * language;\n\n  /* For reorg.  */\n\n  /* If some insns can be deferred to the delay slots of the epilogue, the\n     delay list for them is recorded here.  */\n  rtx epilogue_delay_list;\n\n  /* How commonly executed the function is.  Initialized during branch\n     probabilities pass.  */\n  enum function_frequency {\n    /* This function most likely won't be executed at all.\n       (set only when profile feedback is available).  */\n    FUNCTION_FREQUENCY_UNLIKELY_EXECUTED,\n    /* The default value.  */\n    FUNCTION_FREQUENCY_NORMAL,\n    /* Optimize this function hard\n       (set only when profile feedback is available).  */\n    FUNCTION_FREQUENCY_HOT\n  } function_frequency;\n\n  /* Maximal number of entities in the single jumptable.  Used to estimate\n     final flowgraph size.  */\n  int max_jumptable_ents;\n\n  /* Collected bit flags.  */\n\n  /* Nonzero if function being compiled needs to be given an address\n     where the value should be stored.  */\n  unsigned int returns_struct : 1;\n\n  /* Nonzero if function being compiled needs to\n     return the address of where it has put a structure value.  */\n  unsigned int returns_pcc_struct : 1;\n\n  /* Nonzero if the current function returns a pointer type.  */\n  unsigned int returns_pointer : 1;\n\n  /* Nonzero if function being compiled needs to be passed a static chain.  */\n  unsigned int needs_context : 1;\n\n  /* Nonzero if function being compiled can call setjmp.  */\n  unsigned int calls_setjmp : 1;\n\n  /* Nonzero if function being compiled can call longjmp.  */\n  unsigned int calls_longjmp : 1;\n\n  /* Nonzero if function being compiled can call alloca,\n     either as a subroutine or builtin.  */\n  unsigned int calls_alloca : 1;\n\n  /* Nonzero if the function calls __builtin_eh_return.  */\n  unsigned int calls_eh_return : 1;\n\n  /* Nonzero if the function calls __builtin_constant_p.  */\n  unsigned int calls_constant_p : 1;\n\n  /* Nonzero if function being compiled receives nonlocal gotos\n     from nested functions.  */\n  unsigned int has_nonlocal_label : 1;\n\n  /* Nonzero if function being compiled has nonlocal gotos to parent\n     function.  */\n  unsigned int has_nonlocal_goto : 1;\n\n  /* Nonzero if function being compiled contains nested functions.  */\n  unsigned int contains_functions : 1;\n\n  /* Nonzero if the function being compiled issues a computed jump.  */\n  unsigned int has_computed_jump : 1;\n\n  /* Nonzero if the current function is a thunk, i.e., a lightweight\n     function implemented by the output_mi_thunk hook) that just\n     adjusts one of its arguments and forwards to another\n     function.  */\n  unsigned int is_thunk : 1;\n\n  /* This bit is used by the exception handling logic.  It is set if all\n     calls (if any) are sibling calls.  Such functions do not have to\n     have EH tables generated, as they cannot throw.  A call to such a\n     function, however, should be treated as throwing if any of its callees\n     can throw.  */\n  unsigned int all_throwers_are_sibcalls : 1;\n\n  /* Nonzero if instrumentation calls for function entry and exit should be\n     generated.  */\n  unsigned int instrument_entry_exit : 1;\n\n  /* Nonzero if profiling code should be generated.  */\n  unsigned int profile : 1;\n\n  /* Nonzero if stack limit checking should be enabled in the current\n     function.  */\n  unsigned int limit_stack : 1;\n\n  /* Nonzero if current function uses stdarg.h or equivalent.  */\n  unsigned int stdarg : 1;\n\n  /* Nonzero if this function is being processed in function-at-a-time\n     mode.  In other words, if all tree structure for this function,\n     including the BLOCK tree, is created before RTL generation\n     commences.  */\n  unsigned int x_whole_function_mode_p : 1;\n\n  /* Nonzero if the back-end should not keep track of expressions that\n     determine the size of variable-sized objects.  Normally, such\n     expressions are saved away, and then expanded when the next\n     function is started.  For example, if a parameter has a\n     variable-sized type, then the size of the parameter is computed\n     when the function body is entered.  However, some front-ends do\n     not desire this behavior.  */\n  unsigned int x_dont_save_pending_sizes_p : 1;\n\n  /* Nonzero if the current function uses the constant pool.  */\n  unsigned int uses_const_pool : 1;\n\n  /* Nonzero if the current function uses pic_offset_table_rtx.  */\n  unsigned int uses_pic_offset_table : 1;\n\n  /* Nonzero if the current function needs an lsda for exception handling.  */\n  unsigned int uses_eh_lsda : 1;\n\n  /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n  unsigned int arg_pointer_save_area_init : 1;\n\n  /* Flag for use by ther rtl inliner, to tell if the function has been\n     processed at least once.  */\n  unsigned int rtl_inline_init : 1;\n\n  /* Nonzero if the rtl inliner has saved the function for inlining.  */\n  unsigned int saved_for_inline : 1;\n};\n\n/* The function currently being compiled.  */\nextern GTY(()) struct function *cfun;\n\n/* Pointer to chain of `struct function' for containing functions.  */\nextern GTY(()) struct function *outer_function_chain;\n\n/* Nonzero if we've already converted virtual regs to hard regs.  */\nextern int virtuals_instantiated;\n\n/* Nonzero if at least one trampoline has been created.  */\nextern int trampolines_created;\n\n/* For backward compatibility... eventually these should all go away.  */\n#define current_function_pops_args (cfun->pops_args)\n#define current_function_returns_struct (cfun->returns_struct)\n#define current_function_returns_pcc_struct (cfun->returns_pcc_struct)\n#define current_function_returns_pointer (cfun->returns_pointer)\n#define current_function_needs_context (cfun->needs_context)\n#define current_function_calls_setjmp (cfun->calls_setjmp)\n#define current_function_calls_alloca (cfun->calls_alloca)\n#define current_function_calls_longjmp (cfun->calls_longjmp)\n#define current_function_calls_eh_return (cfun->calls_eh_return)\n#define current_function_calls_constant_p (cfun->calls_constant_p)\n#define current_function_has_computed_jump (cfun->has_computed_jump)\n#define current_function_contains_functions (cfun->contains_functions)\n#define current_function_is_thunk (cfun->is_thunk)\n#define current_function_args_info (cfun->args_info)\n#define current_function_args_size (cfun->args_size)\n#define current_function_pretend_args_size (cfun->pretend_args_size)\n#define current_function_outgoing_args_size (cfun->outgoing_args_size)\n#define current_function_arg_offset_rtx (cfun->arg_offset_rtx)\n#define current_function_stdarg (cfun->stdarg)\n#define current_function_internal_arg_pointer (cfun->internal_arg_pointer)\n#define current_function_return_rtx (cfun->return_rtx)\n#define current_function_instrument_entry_exit (cfun->instrument_entry_exit)\n#define current_function_profile (cfun->profile)\n#define current_function_funcdef_no (cfun->funcdef_no)\n#define current_function_limit_stack (cfun->limit_stack)\n#define current_function_uses_pic_offset_table (cfun->uses_pic_offset_table)\n#define current_function_uses_const_pool (cfun->uses_const_pool)\n#define current_function_cannot_inline (cfun->cannot_inline)\n#define current_function_epilogue_delay_list (cfun->epilogue_delay_list)\n#define current_function_has_nonlocal_label (cfun->has_nonlocal_label)\n#define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)\n\n#define max_parm_reg (cfun->x_max_parm_reg)\n#define parm_reg_stack_loc (cfun->x_parm_reg_stack_loc)\n#define cleanup_label (cfun->x_cleanup_label)\n#define return_label (cfun->x_return_label)\n#define naked_return_label (cfun->x_naked_return_label)\n#define save_expr_regs (cfun->x_save_expr_regs)\n#define stack_slot_list (cfun->x_stack_slot_list)\n#define parm_birth_insn (cfun->x_parm_birth_insn)\n#define frame_offset (cfun->x_frame_offset)\n#define tail_recursion_label (cfun->x_tail_recursion_label)\n#define tail_recursion_reentry (cfun->x_tail_recursion_reentry)\n#define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n#define rtl_expr_chain (cfun->x_rtl_expr_chain)\n#define last_parm_insn (cfun->x_last_parm_insn)\n#define context_display (cfun->x_context_display)\n#define trampoline_list (cfun->x_trampoline_list)\n#define function_call_count (cfun->x_function_call_count)\n#define temp_slots (cfun->x_temp_slots)\n#define temp_slot_level (cfun->x_temp_slot_level)\n#define target_temp_slot_level (cfun->x_target_temp_slot_level)\n#define var_temp_slot_level (cfun->x_var_temp_slot_level)\n#define nonlocal_labels (cfun->x_nonlocal_labels)\n#define nonlocal_goto_handler_slots (cfun->x_nonlocal_goto_handler_slots)\n#define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n#define nonlocal_goto_stack_level (cfun->x_nonlocal_goto_stack_level)\n\n/* The FUNCTION_DECL for an inline function currently being expanded.  */\nextern tree inline_function_decl;\n\n/* Given a function decl for a containing function,\n   return the `struct function' for it.  */\nstruct function *find_function_data (tree);\n\n/* Set NOTE_BLOCK for each block note in the current function.  */\nextern void identify_blocks (void);\n\n/* Identify BLOCKs referenced by more than one NOTE_INSN_BLOCK_{BEG,END},\n   and create duplicate blocks.  */\nextern void reorder_blocks (void);\n\n/* Set BLOCK_NUMBER for all the blocks in FN.  */\nextern void number_blocks (tree);\n\n/* Return size needed for stack frame based on slots so far allocated.\n   This size counts from zero.  It is not rounded to STACK_BOUNDARY;\n   the caller may have to do that.  */\nextern HOST_WIDE_INT get_frame_size (void);\n/* Likewise, but for a different than the current function.  */\nextern HOST_WIDE_INT get_func_frame_size (struct function *);\n\n/* A pointer to a function to create target specific, per-function\n   data structures.  */\nextern struct machine_function * (*init_machine_status) (void);\n\n/* Save and restore status information for a nested function.  */\nextern void restore_emit_status (struct function *);\nextern void free_after_parsing (struct function *);\nextern void free_after_compilation (struct function *);\n\nextern void init_varasm_status (struct function *);\n\n#ifdef RTX_CODE\nextern void diddle_return_value (void (*)(rtx, void*), void*);\nextern void clobber_return_register (void);\nextern void use_return_register (void);\n#endif\n\nextern rtx get_arg_pointer_save_area (struct function *);\n\nextern void init_virtual_regs (struct emit_status *);\n\n/* Returns the name of the current function.  */\nextern const char *current_function_name (void);\n\n/* Called once, at initialization, to initialize function.c.  */\nextern void init_function_once (void);\n\nextern void do_warn_unused_parameter (tree);\n\n#endif  /* GCC_FUNCTION_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GBL@CTOR": {"ttr": 3334, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions relating to the special __do_global_init function used\n   for getting g++ file-scope static objects constructed.  This file\n   will get included either by libgcc2.c (for systems that don't support\n   a .init section) or by crtstuff.c (for those that do).\n   Copyright (C) 1991, 1995, 1996, 1998, 1999, 2000, 2003\n   Free Software Foundation, Inc.\n   Contributed by Ron Guilmette (rfg@segfault.us.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n/*\tThis file contains definitions and declarations of things\n\trelating to the normal start-up-time invocation of C++\n\tfile-scope static object constructors.  These declarations\n\tand definitions are used by *both* libgcc2.c and by crtstuff.c.\n\n\tNote that this file should only be compiled with GCC.\n*/\n\n/*  Declare a pointer to void function type.  */\n\ntypedef void (*func_ptr) (void);\n\n/* Declare the set of symbols use as begin and end markers for the lists\n   of global object constructors and global object destructors.  */\n\nextern func_ptr __CTOR_LIST__\u00dd\u00a8;\nextern func_ptr __DTOR_LIST__\u00dd\u00a8;\n\n/* Declare the routine which needs to get invoked at program start time.  */\n\nextern void __do_global_ctors (void);\n\n/* Declare the routine which needs to get invoked at program exit time.  */\n\nextern void __do_global_dtors (void);\n\n/* Define a macro with the code which needs to be executed at program\n   start-up time.  This macro is used in two places in crtstuff.c (for\n   systems which support a .init section) and in one place in libgcc2.c\n   (for those system which do *not* support a .init section).  For all\n   three places where this code might appear, it must be identical, so\n   we define it once here as a macro to avoid various instances getting\n   out-of-sync with one another.  */\n\n/* Some systems place the number of pointers\n   in the first word of the table.\n   On other systems, that word is -1.\n   In all cases, the table is null-terminated.\n   If the length is not recorded, count up to the null.  */\n\n/* Some systems use a different strategy for finding the ctors.\n   For example, svr3.  */\n#ifndef DO_GLOBAL_CTORS_BODY\n#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  unsigned long nptrs = (unsigned long) __CTOR_LIST__\u00dd0\u00a8;\t\t\\\n  unsigned i;\t\t\t\t\t\t\t\t\\\n  if (nptrs == (unsigned long)-1)\t\t\t\t        \\\n    for (nptrs = 0; __CTOR_LIST__\u00ddnptrs + 1\u00a8 != 0; nptrs++);\t\t\\\n  for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n    __CTOR_LIST__\u00ddi\u00a8 ();\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCC": {"ttr": 3336, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for modules that link with gcc.c\n   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GCC_H\n#define GCC_GCC_H\n\n#include \"version.h\"\n\n/* The mapping of a spec function name to the C function that\n   implements it.  */\nstruct spec_function\n{\n  const char *name;\n  const char *(*func) (int, const char **);\n};\n\n/* This defines which switch letters take arguments.  */\n\n#define DEFAULT_SWITCH_TAKES_ARG(CHAR) \\\n  ((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \\\n   || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \\\n   || (CHAR) == 'I' || (CHAR) == 'm' || (CHAR) == 'x' \\\n   || (CHAR) == 'L' || (CHAR) == 'A' || (CHAR) == 'V' \\\n   || (CHAR) == 'B' || (CHAR) == 'b')\n\n/* This defines which multi-letter switches take arguments.  */\n\n#define DEFAULT_WORD_SWITCH_TAKES_ARG(STR)\t\t\\\n (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"Ttext\")\t\\\n  || !strcmp (STR, \"Tbss\") || !strcmp (STR, \"include\")\t\\\n  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"aux-info\") \\\n  || !strcmp (STR, \"idirafter\") || !strcmp (STR, \"iprefix\") \\\n  || !strcmp (STR, \"iwithprefix\") || !strcmp (STR, \"iwithprefixbefore\") \\\n  || !strcmp (STR, \"isystem\") || !strcmp (STR, \"-param\") \\\n  || !strcmp (STR, \"specs\") \\\n  || !strcmp (STR, \"MF\") || !strcmp (STR, \"MT\") || !strcmp (STR, \"MQ\"))\n\n\n/* These are exported by gcc.c.  */\nextern int do_spec (const char *);\nextern void record_temp_file (const char *, int, int);\n#ifdef SINGLE_EXECUTABLE\nstatic\n#else\nextern\n#endif\nvoid fancy_abort (void) ATTRIBUTE_NORETURN;\nextern void fatal (const char *, ...) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n#ifdef SINGLE_EXECUTABLE\nstatic\n#else\nextern\n#endif\nvoid error (const char *, ...) ATTRIBUTE_PRINTF_1;\nextern void pfatal_with_name (const char *) ATTRIBUTE_NORETURN;\nextern void set_input (const char *);\n\n/* Spec files linked with gcc.c must provide definitions for these.  */\n\n/* Called before processing to change/add/remove arguments.  */\nextern void lang_specific_driver (int *, const char *const **, int *);\n\n/* Called before linking.  Returns 0 on success and -1 on failure.  */\nextern int lang_specific_pre_link (void);\n\nextern int n_infiles;\n\n/* Number of extra output files that lang_specific_pre_link may generate.  */\nextern int lang_specific_extra_outfiles;\n\n/* Table of language-specific spec functions.  */\nextern const struct spec_function lang_specific_spec_functions\u00dd\u00a8;\n\n/* A vector of corresponding output files is made up later.  */\n\nextern const char **outfiles;\n\n#endif /* ! GCC_GCC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCOV@IO": {"ttr": 3338, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* File format for coverage information\n   Copyright (C) 1996, 1997, 1998, 2000, 2002,\n   2003, 2004 Free Software Foundation, Inc.\n   Contributed by Bob Manson <manson@cygnus.com>.\n   Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n/* Coverage information is held in two files.  A notes file, which is\n   generated by the compiler, and a data file, which is generated\n   by the program under test.  Both files use a similar structure.  We\n   do not attempt to make these files backwards compatible with\n   previous versions, as you only need coverage information when\n   developing a program.  We do hold version information, so that\n   mismatches can be detected, and we use a format that allows tools\n   to skip information they do not understand or are not interested\n   in.\n\n   Numbers are recorded in the 32 bit unsigned binary form of the\n   endianness of the machine generating the file. 64 bit numbers are\n   stored as two 32 bit numbers, the low part first.  Strings are\n   padded with 1 to 4 NUL bytes, to bring the length up to a multiple\n   of 4. The number of 4 bytes is stored, followed by the padded\n   string. Zero length and NULL strings are simply stored as\n   a length of zero (they have no trailing NUL or padding).\n\n   \tint32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3\n\tint64:  int32:low int32:high\n\tstring: int32:0 | int32:length char* char:0 padding\n\tpadding: | char:0 | char:0 char:0 | char:0 char:0 char:0\n\titem: int32 | int64 | string\n\n   The basic format of the files is\n\n   \tfile : int32:magic int32:version int32:stamp record*\n\n   The magic ident is different for the notes and the data files.  The\n   magic ident is used to determine the endianness of the file, when\n   reading.  The version is the same for both files and is derived\n   from gcc's version number. The stamp value is used to synchronize\n   note and data files and to synchronize merging within a data\n   file. It need not be an absolute time stamp, merely a ticker that\n   increments fast enough and cycles slow enough to distinguish\n   different compile/run/compile cycles.\n\n   Although the ident and version are formally 32 bit numbers, they\n   are derived from 4 character ASCII strings.  The version number\n   consists of the single character major version number, a two\n   character minor version number (leading zero for versions less than\n   10), and a single character indicating the status of the release.\n   That will be 'e' experimental, 'p' prerelease and 'r' for release.\n   Because, by good fortune, these are in alphabetical order, string\n   collating can be used to compare version strings.  Be aware that\n   the 'e' designation will (naturally) be unstable and might be\n   incompatible with itself.  For gcc 3.4 experimental, it would be\n   '304e' (0x33303465).  When the major version reaches 10, the\n   letters A-Z will be used.  Assuming minor increments releases every\n   6 months, we have to make a major increment every 50 years.\n   Assuming major increments releases every 5 years, we're ok for the\n   next 155 years -- good enough for me.\n\n   A record has a tag, length and variable amount of data.\n\n   \trecord: header data\n\theader: int32:tag int32:length\n\tdata: item*\n\n   Records are not nested, but there is a record hierarchy.  Tag\n   numbers reflect this hierarchy.  Tags are unique across note and\n   data files.  Some record types have a varying amount of data.  The\n   LENGTH is the number of 4bytes that follow and is usually used to\n   determine how much data.  The tag value is split into 4 8-bit\n   fields, one for each of four possible levels.  The most significant\n   is allocated first.  Unused levels are zero.  Active levels are\n   odd-valued, so that the LSB of the level is one.  A sub-level\n   incorporates the values of its superlevels.  This formatting allows\n   you to determine the tag hierarchy, without understanding the tags\n   themselves, and is similar to the standard section numbering used\n   in technical documents.  Level values \u00dd1..3f\u00a8 are used for common\n   tags, values \u00dd41..9f\u00a8 for the notes file and \u00dda1..ff\u00a8 for the data\n   file.\n\n   The basic block graph file contains the following records\n   \tnote: unit function-graph*\n\tunit: header int32:checksum string:source\n\tfunction-graph: announce_function basic_blocks {arcs | lines}*\n\tannounce_function: header int32:ident int32:checksum\n\t\tstring:name string:source int32:lineno\n\tbasic_block: header int32:flags*\n\tarcs: header int32:block_no arc*\n\tarc:  int32:dest_block int32:flags\n        lines: header int32:block_no line*\n               int32:0 string:NULL\n\tline:  int32:line_no | int32:0 string:filename\n\n   The BASIC_BLOCK record holds per-bb flags.  The number of blocks\n   can be inferred from its data length.  There is one ARCS record per\n   basic block.  The number of arcs from a bb is implicit from the\n   data length.  It enumerates the destination bb and per-arc flags.\n   There is one LINES record per basic block, it enumerates the source\n   lines which belong to that basic block.  Source file names are\n   introduced by a line number of 0, following lines are from the new\n   source file.  The initial source file for the function is NULL, but\n   the current source file should be remembered from one LINES record\n   to the next.  The end of a block is indicated by an empty filename\n   - this does not reset the current source file.  Note there is no\n   ordering of the ARCS and LINES records: they may be in any order,\n   interleaved in any manner.  The current filename follows the order\n   the LINES records are stored in the file, *not* the ordering of the\n   blocks they are for.\n\n   The data file contains the following records.\n        data: {unit function-data* summary:object summary:program*}*\n\tunit: header int32:checksum\n        function-data:\tannounce_function arc_counts\n\tannounce_function: header int32:ident int32:checksum\n\tarc_counts: header int64:count*\n\tsummary: int32:checksum {count-summary}GCOV_COUNTERS\n\tcount-summary:\tint32:num int32:runs int64:sum\n\t\t\tint64:max int64:sum_max\n\n   The ANNOUNCE_FUNCTION record is the same as that in the note file,\n   but without the source location.  The ARC_COUNTS gives the counter\n   values for those arcs that are instrumented.  The SUMMARY records\n   give information about the whole object file and about the whole\n   program.  The checksum is used for whole program summaries, and\n   disambiguates different programs which include the same\n   instrumented object file.  There may be several program summaries,\n   each with a unique checksum.  The object summary's checksum is zero.\n   Note that the data file might contain information from several runs\n   concatenated, or the data might be merged.\n\n   This file is included by both the compiler, gcov tools and the\n   runtime support library libgcov. IN_LIBGCOV and IN_GCOV are used to\n   distinguish which case is which.  If IN_LIBGCOV is nonzero,\n   libgcov is being built. If IN_GCOV is nonzero, the gcov tools are\n   being built. Otherwise the compiler is being built. IN_GCOV may be\n   positive or negative. If positive, we are compiling a tool that\n   requires additional functions (see the code for knowledge of what\n   those functions are).  */\n\n#ifndef GCC_GCOV_IO_H\n#define GCC_GCOV_IO_H\n\n#if IN_LIBGCOV\n/* About the target */\n\n#if BITS_PER_UNIT == 8\ntypedef unsigned gcov_unsigned_t __attribute__ ((mode (SI)));\ntypedef unsigned gcov_position_t __attribute__ ((mode (SI)));\n#if LONG_LONG_TYPE_SIZE > 32\ntypedef signed gcov_type __attribute__ ((mode (DI)));\n#else\ntypedef signed gcov_type __attribute__ ((mode (SI)));\n#endif\n#else\n#if BITS_PER_UNIT == 16\ntypedef unsigned gcov_unsigned_t __attribute__ ((mode (HI)));\ntypedef unsigned gcov_position_t __attribute__ ((mode (HI)));\n#if LONG_LONG_TYPE_SIZE > 32\ntypedef signed gcov_type __attribute__ ((mode (SI)));\n#else\ntypedef signed gcov_type __attribute__ ((mode (HI)));\n#endif\n#else\ntypedef unsigned gcov_unsigned_t __attribute__ ((mode (QI)));\ntypedef unsigned gcov_position_t __attribute__ ((mode (QI)));\n#if LONG_LONG_TYPE_SIZE > 32\ntypedef signed gcov_type __attribute__ ((mode (HI)));\n#else\ntypedef signed gcov_type __attribute__ ((mode (QI)));\n#endif\n#endif\n#endif\n\n\n#if defined (TARGET_HAS_F_SETLKW)\n#define GCOV_LOCKED 1\n#else\n#define GCOV_LOCKED 0\n#endif\n\n#else /* !IN_LIBGCOV */\n/* About the host */\n\ntypedef unsigned gcov_unsigned_t;\ntypedef unsigned gcov_position_t;\n/* gcov_type is typedef'd elsewhere for the compiler */\n#if IN_GCOV\n#define GCOV_LINKAGE static\ntypedef HOST_WIDEST_INT gcov_type;\n#if IN_GCOV > 0\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#endif\n#else /*!IN_GCOV */\n#if LONG_LONG_TYPE_SIZE > 32\n#define GCOV_TYPE_NODE intDI_type_node\n#else\n#define GCOV_TYPE_NODE intSI_type_node\n#endif\n#endif\n\n#if defined (HOST_HAS_F_SETLKW)\n#define GCOV_LOCKED 1\n#else\n#define GCOV_LOCKED 0\n#endif\n\n#endif /* !IN_LIBGCOV */\n\n/* In gcov we want function linkage to be static.  In the compiler we want\n   it extern, so that they can be accessed from elsewhere.  In libgcov we\n   need these functions to be extern, so prefix them with __gcov.  In\n   libgcov they must also be hidden so that the instance in the executable\n   is not also used in a DSO.  */\n#if IN_LIBGCOV\n\n#include \"auto-host.h\"   /* for HAVE_GAS_HIDDEN */\n\n#define gcov_var __gcov_var\n#define gcov_open __gcov_open\n#define gcov_close __gcov_close\n#define gcov_write_tag_length __gcov_write_tag_length\n#define gcov_position __gcov_position\n#define gcov_seek __gcov_seek\n#define gcov_rewrite __gcov_rewrite\n#define gcov_is_error __gcov_is_error\n#define gcov_is_eof __gcov_is_eof\n#define gcov_write_unsigned __gcov_write_unsigned\n#define gcov_write_counter __gcov_write_counter\n#define gcov_write_summary __gcov_write_summary\n#define gcov_read_unsigned __gcov_read_unsigned\n#define gcov_read_counter __gcov_read_counter\n#define gcov_read_summary __gcov_read_summary\n\n/* Poison these, so they don't accidentally slip in.  */\n#pragma GCC poison gcov_write_string gcov_write_tag gcov_write_length\n#pragma GCC poison gcov_read_string gcov_sync gcov_time gcov_magic\n\n#ifdef HAVE_GAS_HIDDEN\n#define ATTRIBUTE_HIDDEN  __attribute__ ((__visibility__ (\"hidden\")))\n#else\n#define ATTRIBUTE_HIDDEN\n#endif\n\n#else\n\n#define ATTRIBUTE_HIDDEN\n\n#endif\n\n#ifndef GCOV_LINKAGE\n#define GCOV_LINKAGE extern\n#endif\n\n/* File suffixes.  */\n#define GCOV_DATA_SUFFIX \".gcda\"\n#define GCOV_NOTE_SUFFIX \".gcno\"\n\n/* File magic. Must not be palindromes.  */\n#define GCOV_DATA_MAGIC ((gcov_unsigned_t)0x67636461) /* \"gcda\" */\n#define GCOV_NOTE_MAGIC ((gcov_unsigned_t)0x67636e6f) /* \"gcno\" */\n\n/* gcov-iov.h is automatically generated by the makefile from\n   version.c, it looks like\n   \t#define GCOV_VERSION ((gcov_unsigned_t)0x89abcdef)\n*/\n#include \"gcov-iov.h\"\n\n/* Convert a magic or version number to a 4 character string.  */\n#define GCOV_UNSIGNED2STRING(ARRAY,VALUE)\t\\\n  ((ARRAY)\u00dd0\u00a8 = (char)((VALUE) >> 24),\t\t\\\n   (ARRAY)\u00dd1\u00a8 = (char)((VALUE) >> 16),\t\t\\\n   (ARRAY)\u00dd2\u00a8 = (char)((VALUE) >> 8),\t\t\\\n   (ARRAY)\u00dd3\u00a8 = (char)((VALUE) >> 0))\n\n/* The record tags.  Values \u00dd1..3f\u00a8 are for tags which may be in either\n   file.  Values \u00dd41..9f\u00a8 for those in the note file and \u00dda1..ff\u00a8 for\n   the data file.  */\n\n#define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n#define GCOV_TAG_FUNCTION_LENGTH (2)\n#define GCOV_TAG_BLOCKS\t\t ((gcov_unsigned_t)0x01410000)\n#define GCOV_TAG_BLOCKS_LENGTH(NUM) (NUM)\n#define GCOV_TAG_BLOCKS_NUM(LENGTH) (LENGTH)\n#define GCOV_TAG_ARCS\t\t ((gcov_unsigned_t)0x01430000)\n#define GCOV_TAG_ARCS_LENGTH(NUM)  (1 + (NUM) * 2)\n#define GCOV_TAG_ARCS_NUM(LENGTH)  (((LENGTH) - 1) / 2)\n#define GCOV_TAG_LINES\t\t ((gcov_unsigned_t)0x01450000)\n#define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n#define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2)\n#define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n#define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n#define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)\n#define GCOV_TAG_SUMMARY_LENGTH  \\\n\t(1 + GCOV_COUNTERS_SUMMABLE * (2 + 3 * 2))\n\n/* Counters that are collected.  */\n#define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n#define GCOV_COUNTERS_SUMMABLE\t1  /* Counters which can be\n\t\t\t\t      summaried.  */\n#define GCOV_FIRST_VALUE_COUNTER 1 /* The first of counters used for value\n\t\t\t\t      profiling.  They must form a consecutive\n\t\t\t\t      interval and their order must match\n\t\t\t\t      the order of HIST_TYPEs in\n\t\t\t\t      value-prof.h.  */\n#define GCOV_COUNTER_V_INTERVAL\t1  /* Histogram of value inside an interval.  */\n#define GCOV_COUNTER_V_POW2\t2  /* Histogram of exact power2 logarithm\n\t\t\t\t      of a value.  */\n#define GCOV_COUNTER_V_SINGLE\t3  /* The most common value of expression.  */\n#define GCOV_COUNTER_V_DELTA\t4  /* The most common difference between\n\t\t\t\t      consecutive values of expression.  */\n#define GCOV_LAST_VALUE_COUNTER 4  /* The last of counters used for value\n\t\t\t\t      profiling.  */\n#define GCOV_COUNTERS\t\t5\n\n/* Number of counters used for value profiling.  */\n#define GCOV_N_VALUE_COUNTERS \\\n  (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n\n  /* A list of human readable names of the counters */\n#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \"delta\"}\n\n  /* Names of merge functions for counters.  */\n#define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n\t\t\t\t \"__gcov_merge_add\",\t\\\n\t\t\t\t \"__gcov_merge_add\",\t\\\n\t\t\t\t \"__gcov_merge_single\",\t\\\n\t\t\t\t \"__gcov_merge_delta\"}\n\n/* Convert a counter index to a tag.  */\n#define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n\t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))\n/* Convert a tag to a counter.  */\n#define GCOV_COUNTER_FOR_TAG(TAG)\t\t\t\t\t\\\n\t((unsigned)(((TAG) - GCOV_TAG_COUNTER_BASE) >> 17))\n/* Check whether a tag is a counter tag.  */\n#define GCOV_TAG_IS_COUNTER(TAG)\t\t\t\t\\\n\t(!((TAG) & 0xFFFF) && GCOV_COUNTER_FOR_TAG (TAG) < GCOV_COUNTERS)\n\n/* The tag level mask has 1's in the position of the inner levels, &\n   the lsb of the current level, and zero on the current and outer\n   levels.  */\n#define GCOV_TAG_MASK(TAG) (((TAG) - 1) \u00ac (TAG))\n\n/* Return nonzero if SUB is an immediate subtag of TAG.  */\n#define GCOV_TAG_IS_SUBTAG(TAG,SUB)\t\t\t\t\\\n\t(GCOV_TAG_MASK (TAG) >> 8 == GCOV_TAG_MASK (SUB) \t\\\n\t && !(((SUB) \u00ac (TAG)) & ~GCOV_TAG_MASK(TAG)))\n\n/* Return nonzero if SUB is at a sublevel to TAG.  */\n#define GCOV_TAG_IS_SUBLEVEL(TAG,SUB)\t\t\t\t\\\n     \t(GCOV_TAG_MASK (TAG) > GCOV_TAG_MASK (SUB))\n\n/* Basic block flags.  */\n#define GCOV_BLOCK_UNEXPECTED\t(1 << 1)\n\n/* Arc flags.  */\n#define GCOV_ARC_ON_TREE \t(1 << 0)\n#define GCOV_ARC_FAKE\t\t(1 << 1)\n#define GCOV_ARC_FALLTHROUGH\t(1 << 2)\n\n/* Structured records.  */\n\n/* Cumulative counter data.  */\nstruct gcov_ctr_summary\n{\n  gcov_unsigned_t num;\t\t/* number of counters.  */\n  gcov_unsigned_t runs;\t\t/* number of program runs */\n  gcov_type sum_all;\t\t/* sum of all counters accumulated.  */\n  gcov_type run_max;\t\t/* maximum value on a single run.  */\n  gcov_type sum_max;    \t/* sum of individual run max values.  */\n};\n\n/* Object & program summary record.  */\nstruct gcov_summary\n{\n  gcov_unsigned_t checksum;\t/* checksum of program */\n  struct gcov_ctr_summary ctrs\u00ddGCOV_COUNTERS_SUMMABLE\u00a8;\n};\n\n/* Structures embedded in coveraged program.  The structures generated\n   by write_profile must match these.  */\n\n#if IN_LIBGCOV\n/* Information about a single function.  This uses the trailing array\n   idiom. The number of counters is determined from the counter_mask\n   in gcov_info.  We hold an array of function info, so have to\n   explicitly calculate the correct array stride.  */\nstruct gcov_fn_info\n{\n  gcov_unsigned_t ident;\t/* unique ident of function */\n  gcov_unsigned_t checksum;\t/* function checksum */\n  unsigned n_ctrs\u00dd0\u00a8;\t\t/* instrumented counters */\n};\n\n/* Type of function used to merge counters.  */\ntypedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);\n\n/* Information about counters.  */\nstruct gcov_ctr_info\n{\n  gcov_unsigned_t num;\t\t/* number of counters.  */\n  gcov_type *values;\t\t/* their values.  */\n  gcov_merge_fn merge;  \t/* The function used to merge them.  */\n};\n\n/* Information about a single object file.  */\nstruct gcov_info\n{\n  gcov_unsigned_t version;\t/* expected version number */\n  struct gcov_info *next;\t/* link to next, used by libgcov */\n\n  gcov_unsigned_t stamp;\t/* uniquifying time stamp */\n  const char *filename;\t\t/* output file name */\n\n  unsigned n_functions;\t\t/* number of functions */\n  const struct gcov_fn_info *functions; /* table of functions */\n\n  unsigned ctr_mask;\t\t/* mask of counters instrumented.  */\n  struct gcov_ctr_info counts\u00dd0\u00a8; /* count data. The number of bits\n\t\t\t\t     set in the ctr_mask field\n\t\t\t\t     determines how big this array\n\t\t\t\t     is.  */\n};\n\n/* Register a new object file module.  */\nextern void __gcov_init (struct gcov_info *) ATTRIBUTE_HIDDEN;\n\n/* Called before fork, to avoid double counting.  */\nextern void __gcov_flush (void) ATTRIBUTE_HIDDEN;\n\n/* The merge function that just sums the counters.  */\nextern void __gcov_merge_add (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n\n/* The merge function to choose the most common value.  */\nextern void __gcov_merge_single (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n\n/* The merge function to choose the most common difference between\n   consecutive values.  */\nextern void __gcov_merge_delta (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n#endif /* IN_LIBGCOV */\n\n#if IN_LIBGCOV >= 0\n\n/* Optimum number of gcov_unsigned_t's read from or written to disk.  */\n#define GCOV_BLOCK_SIZE (1 << 10)\n\nGCOV_LINKAGE struct gcov_var\n{\n  FILE *file;\n  gcov_position_t start;\t/* Position of first byte of block */\n  unsigned offset;\t\t/* Read/write position within the block.  */\n  unsigned length;\t\t/* Read limit in the block.  */\n  unsigned overread;\t\t/* Number of words overread.  */\n  int error;\t\t\t/* < 0 overflow, > 0 disk error.  */\n  int mode;\t                /* < 0 writing, > 0 reading */\n#if IN_LIBGCOV\n  /* Holds one block plus 4 bytes, thus all coverage reads & writes\n     fit within this buffer and we always can transfer GCOV_BLOCK_SIZE\n     to and from the disk. libgcov never backtracks and only writes 4\n     or 8 byte objects.  */\n  gcov_unsigned_t buffer\u00ddGCOV_BLOCK_SIZE + 1\u00a8;\n#else\n  int endian;\t\t\t/* Swap endianness.  */\n  /* Holds a variable length block, as the compiler can write\n     strings and needs to backtrack.  */\n  size_t alloc;\n  gcov_unsigned_t *buffer;\n#endif\n} gcov_var ATTRIBUTE_HIDDEN;\n\n/* Functions for reading and writing gcov files. In libgcov you can\n   open the file for reading then writing. Elsewhere you can open the\n   file either for reading or for writing. When reading a file you may\n   use the gcov_read_* functions, gcov_sync, gcov_position, &\n   gcov_error. When writing a file you may use the gcov_write\n   functions, gcov_seek & gcov_error. When a file is to be rewritten\n   you use the functions for reading, then gcov_rewrite then the\n   functions for writing.  Your file may become corrupted if you break\n   these invariants.  */\n#if IN_LIBGCOV\nGCOV_LINKAGE int gcov_open (const char */*name*/) ATTRIBUTE_HIDDEN;\n#else\nGCOV_LINKAGE int gcov_open (const char */*name*/, int /*direction*/);\nGCOV_LINKAGE int gcov_magic (gcov_unsigned_t, gcov_unsigned_t);\n#endif\nGCOV_LINKAGE int gcov_close (void) ATTRIBUTE_HIDDEN;\n\n/* Available everywhere.  */\nstatic gcov_position_t gcov_position (void);\nstatic int gcov_is_error (void);\nstatic int gcov_is_eof (void);\n\nGCOV_LINKAGE gcov_unsigned_t gcov_read_unsigned (void) ATTRIBUTE_HIDDEN;\nGCOV_LINKAGE gcov_type gcov_read_counter (void) ATTRIBUTE_HIDDEN;\nGCOV_LINKAGE void gcov_read_summary (struct gcov_summary *) ATTRIBUTE_HIDDEN;\n\n#if IN_LIBGCOV\n/* Available only in libgcov */\nGCOV_LINKAGE void gcov_write_counter (gcov_type) ATTRIBUTE_HIDDEN;\nGCOV_LINKAGE void gcov_write_tag_length (gcov_unsigned_t, gcov_unsigned_t)\n    ATTRIBUTE_HIDDEN;\nGCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,\n\t\t\t\t      const struct gcov_summary *)\n    ATTRIBUTE_HIDDEN;\nstatic void gcov_truncate (void);\nstatic void gcov_rewrite (void);\nGCOV_LINKAGE void gcov_seek (gcov_position_t /*position*/) ATTRIBUTE_HIDDEN;\n#else\n/* Available outside libgcov */\nGCOV_LINKAGE const char *gcov_read_string (void);\nGCOV_LINKAGE void gcov_sync (gcov_position_t /*base*/,\n\t\t\t     gcov_unsigned_t /*length */);\n#endif\n\n#if !IN_GCOV\n/* Available outside gcov */\nGCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t) ATTRIBUTE_HIDDEN;\n#endif\n\n#if !IN_GCOV && !IN_LIBGCOV\n/* Available only in compiler */\nGCOV_LINKAGE void gcov_write_string (const char *);\nGCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\nGCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n#endif\n\n#if IN_GCOV > 0\n/* Available in gcov */\nGCOV_LINKAGE time_t gcov_time (void);\n#endif\n\n/* Make sure the library is used correctly.  */\n#if ENABLE_CHECKING\n#define GCOV_CHECK(expr) ((expr) ? (void)0 : (void)abort ())\n#else\n#define GCOV_CHECK(expr)\n#endif\n#define GCOV_CHECK_READING() GCOV_CHECK(gcov_var.mode > 0)\n#define GCOV_CHECK_WRITING() GCOV_CHECK(gcov_var.mode < 0)\n\n/* Save the current position in the gcov file.  */\n\nstatic inline gcov_position_t\ngcov_position (void)\n{\n  GCOV_CHECK_READING ();\n  return gcov_var.start + gcov_var.offset;\n}\n\n/* Return nonzero if we read to end of file.  */\n\nstatic inline int\ngcov_is_eof (void)\n{\n  return !gcov_var.overread;\n}\n\n/* Return nonzero if the error flag is set.  */\n\nstatic inline int\ngcov_is_error (void)\n{\n  return gcov_var.file ? gcov_var.error : 1;\n}\n\n#if IN_LIBGCOV\n/* Move to beginning of file and initialize for writing.  */\n\nstatic inline void\ngcov_rewrite (void)\n{\n  GCOV_CHECK_READING ();\n  gcov_var.mode = -1;\n  gcov_var.start = 0;\n  gcov_var.offset = 0;\n  fseek (gcov_var.file, 0L, SEEK_SET);\n}\n\n#ifdef __MINGW32__\n#define ftruncate _chsize\n#endif\nstatic inline void\ngcov_truncate (void)\n{\n  ftruncate (fileno (gcov_var.file), 0L);\n}\n#endif\n\n#endif /* IN_LIBGCOV >= 0 */\n\n#endif /* GCC_GCOV_IO_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCOV@IOV": {"ttr": 3588, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#define GCOV_VERSION 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GCOVIOC": {"ttr": 3590, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* File format for coverage information\n   Copyright (C) 1996, 1997, 1998, 2000, 2002,\n   2003  Free Software Foundation, Inc.\n   Contributed by Bob Manson <manson@cygnus.com>.\n   Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Routines declared in gcov-io.h.  This file should be #included by\n   another source file, after having #included gcov-io.h.  */\n\n#if !IN_GCOV\nstatic void gcov_write_block (unsigned);\nstatic gcov_unsigned_t *gcov_write_words (unsigned);\n#endif\nstatic const gcov_unsigned_t *gcov_read_words (unsigned);\n#if !IN_LIBGCOV\nstatic void gcov_allocate (unsigned);\n#endif\n\nstatic inline gcov_unsigned_t from_file (gcov_unsigned_t value)\n{\n#if !IN_LIBGCOV\n  if (gcov_var.endian)\n    {\n      value = (value >> 16) | (value << 16);\n      value = ((value & 0xff00ff) << 8) | ((value >> 8) & 0xff00ff);\n    }\n#endif\n  return value;\n}\n\n/* Open a gcov file. NAME is the name of the file to open and MODE\n   indicates whether a new file should be created, or an existing file\n   opened for modification. If MODE is >= 0 an existing file will be\n   opened, if possible, and if MODE is <= 0, a new file will be\n   created. Use MODE=0 to attempt to reopen an existing file and then\n   fall back on creating a new one.  Return zero on failure, >0 on\n   opening an existing file and <0 on creating a new one.  */\n\nGCOV_LINKAGE int\n#if IN_LIBGCOV\ngcov_open (const char *name)\n#else\ngcov_open (const char *name, int mode)\n#endif\n{\n#if IN_LIBGCOV\n  const int mode = 0;\n#endif\n#if GCOV_LOCKED\n  struct flock s_flock;\n  int fd;\n\n  s_flock.l_type = F_WRLCK;\n  s_flock.l_whence = SEEK_SET;\n  s_flock.l_start = 0;\n  s_flock.l_len = 0; /* Until EOF.  */\n  s_flock.l_pid = getpid ();\n#endif\n\n  if (gcov_var.file)\n    abort ();\n  gcov_var.start = 0;\n  gcov_var.offset = gcov_var.length = 0;\n  gcov_var.overread = -1u;\n  gcov_var.error = 0;\n#if !IN_LIBGCOV\n  gcov_var.endian = 0;\n#endif\n#if GCOV_LOCKED\n  if (mode > 0)\n    fd = open (name, O_RDWR);\n  else\n    fd = open (name, O_RDWR | O_CREAT, 0666);\n  if (fd < 0)\n    return 0;\n\n  while (fcntl (fd, F_SETLKW, &s_flock) && errno == EINTR)\n    continue;\n\n  gcov_var.file = fdopen (fd, \"r+b\");\n  if (!gcov_var.file)\n    {\n      close (fd);\n      return 0;\n    }\n\n  if (mode > 0)\n    gcov_var.mode = 1;\n  else if (mode == 0)\n    {\n      struct stat st;\n\n      if (fstat (fd, &st) < 0)\n\t{\n\t  fclose (gcov_var.file);\n\t  gcov_var.file = 0;\n\t  return 0;\n\t}\n      if (st.st_size != 0)\n\tgcov_var.mode = 1;\n      else\n\tgcov_var.mode = mode * 2 + 1;\n    }\n  else\n    gcov_var.mode = mode * 2 + 1;\n#else\n  if (mode >= 0)\n    gcov_var.file = fopen (name, \"r+b\");\n  if (gcov_var.file)\n    gcov_var.mode = 1;\n  else if (mode <= 0)\n    {\n      gcov_var.file = fopen (name, \"w+b\");\n      if (gcov_var.file)\n\tgcov_var.mode = mode * 2 + 1;\n    }\n  if (!gcov_var.file)\n    return 0;\n#endif\n\n  setbuf (gcov_var.file, (char *)0);\n\n  return 1;\n}\n\n/* Close the current gcov file. Flushes data to disk. Returns nonzero\n   on failure or error flag set.  */\n\nGCOV_LINKAGE int\ngcov_close (void)\n{\n  if (gcov_var.file)\n    {\n#if !IN_GCOV\n      if (gcov_var.offset && gcov_var.mode < 0)\n\tgcov_write_block (gcov_var.offset);\n#endif\n      fclose (gcov_var.file);\n      gcov_var.file = 0;\n      gcov_var.length = 0;\n    }\n#if !IN_LIBGCOV\n  free (gcov_var.buffer);\n  gcov_var.alloc = 0;\n  gcov_var.buffer = 0;\n#endif\n  gcov_var.mode = 0;\n  return gcov_var.error;\n}\n\n#if !IN_LIBGCOV\n/* Check if MAGIC is EXPECTED. Use it to determine endianness of the\n   file. Returns +1 for same endian, -1 for other endian and zero for\n   not EXPECTED.  */\n\nGCOV_LINKAGE int\ngcov_magic (gcov_unsigned_t magic, gcov_unsigned_t expected)\n{\n  if (magic == expected)\n    return 1;\n  magic = (magic >> 16) | (magic << 16);\n  magic = ((magic & 0xff00ff) << 8) | ((magic >> 8) & 0xff00ff);\n  if (magic == expected)\n    {\n      gcov_var.endian = 1;\n      return -1;\n    }\n  return 0;\n}\n#endif\n\n#if !IN_LIBGCOV\nstatic void\ngcov_allocate (unsigned length)\n{\n  size_t new_size = gcov_var.alloc;\n\n  if (!new_size)\n    new_size = GCOV_BLOCK_SIZE;\n  new_size += length;\n  new_size *= 2;\n\n  gcov_var.alloc = new_size;\n  gcov_var.buffer = xrealloc (gcov_var.buffer, new_size << 2);\n}\n#endif\n\n#if !IN_GCOV\n/* Write out the current block, if needs be.  */\n\nstatic void\ngcov_write_block (unsigned size)\n{\n  if (fwrite (gcov_var.buffer, size << 2, 1, gcov_var.file) != 1)\n    gcov_var.error = 1;\n  gcov_var.start += size;\n  gcov_var.offset -= size;\n}\n\n/* Allocate space to write BYTES bytes to the gcov file. Return a\n   pointer to those bytes, or NULL on failure.  */\n\nstatic gcov_unsigned_t *\ngcov_write_words (unsigned words)\n{\n  gcov_unsigned_t *result;\n\n  GCOV_CHECK_WRITING ();\n#if IN_LIBGCOV\n  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n    {\n      gcov_write_block (GCOV_BLOCK_SIZE);\n      if (gcov_var.offset)\n\t{\n\t  GCOV_CHECK (gcov_var.offset == 1);\n\t  memcpy (gcov_var.buffer, gcov_var.buffer + GCOV_BLOCK_SIZE, 4);\n\t}\n    }\n#else\n  if (gcov_var.offset + words > gcov_var.alloc)\n    gcov_allocate (gcov_var.offset + words);\n#endif\n  result = &gcov_var.buffer\u00ddgcov_var.offset\u00a8;\n  gcov_var.offset += words;\n\n  return result;\n}\n\n/* Write unsigned VALUE to coverage file.  Sets error flag\n   appropriately.  */\n\nGCOV_LINKAGE void\ngcov_write_unsigned (gcov_unsigned_t value)\n{\n  gcov_unsigned_t *buffer = gcov_write_words (1);\n\n  buffer\u00dd0\u00a8 = value;\n}\n\n/* Write counter VALUE to coverage file.  Sets error flag\n   appropriately.  */\n\n#if IN_LIBGCOV\nGCOV_LINKAGE void\ngcov_write_counter (gcov_type value)\n{\n  gcov_unsigned_t *buffer = gcov_write_words (2);\n\n  buffer\u00dd0\u00a8 = (gcov_unsigned_t) value;\n  if (sizeof (value) > sizeof (gcov_unsigned_t))\n    buffer\u00dd1\u00a8 = (gcov_unsigned_t) (value >> 32);\n  else\n    buffer\u00dd1\u00a8 = 0;\n\n  if (value < 0)\n    gcov_var.error = -1;\n}\n#endif /* IN_LIBGCOV */\n\n#if !IN_LIBGCOV\n/* Write STRING to coverage file.  Sets error flag on file\n   error, overflow flag on overflow */\n\nGCOV_LINKAGE void\ngcov_write_string (const char *string)\n{\n  unsigned length = 0;\n  unsigned alloc = 0;\n  gcov_unsigned_t *buffer;\n\n  if (string)\n    {\n      length = strlen (string);\n      alloc = (length + 4) >> 2;\n    }\n\n  buffer = gcov_write_words (1 + alloc);\n\n  buffer\u00dd0\u00a8 = alloc;\n  buffer\u00ddalloc\u00a8 = 0;\n  memcpy (&buffer\u00dd1\u00a8, string, length);\n}\n#endif\n\n#if !IN_LIBGCOV\n/* Write a tag TAG and reserve space for the record length. Return a\n   value to be used for gcov_write_length.  */\n\nGCOV_LINKAGE gcov_position_t\ngcov_write_tag (gcov_unsigned_t tag)\n{\n  gcov_position_t result = gcov_var.start + gcov_var.offset;\n  gcov_unsigned_t *buffer = gcov_write_words (2);\n\n  buffer\u00dd0\u00a8 = tag;\n  buffer\u00dd1\u00a8 = 0;\n\n  return result;\n}\n\n/* Write a record length using POSITION, which was returned by\n   gcov_write_tag.  The current file position is the end of the\n   record, and is restored before returning.  Returns nonzero on\n   overflow.  */\n\nGCOV_LINKAGE void\ngcov_write_length (gcov_position_t position)\n{\n  unsigned offset;\n  gcov_unsigned_t length;\n  gcov_unsigned_t *buffer;\n\n  GCOV_CHECK_WRITING ();\n  GCOV_CHECK (position + 2 <= gcov_var.start + gcov_var.offset);\n  GCOV_CHECK (position >= gcov_var.start);\n  offset = position - gcov_var.start;\n  length = gcov_var.offset - offset - 2;\n  buffer = (gcov_unsigned_t *) &gcov_var.buffer\u00ddoffset\u00a8;\n  buffer\u00dd1\u00a8 = length;\n  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n    gcov_write_block (gcov_var.offset);\n}\n\n#else /* IN_LIBGCOV */\n\n/* Write a tag TAG and length LENGTH.  */\n\nGCOV_LINKAGE void\ngcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n{\n  gcov_unsigned_t *buffer = gcov_write_words (2);\n\n  buffer\u00dd0\u00a8 = tag;\n  buffer\u00dd1\u00a8 = length;\n}\n\n/* Write a summary structure to the gcov file.  Return nonzero on\n   overflow.  */\n\nGCOV_LINKAGE void\ngcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n{\n  unsigned ix;\n  const struct gcov_ctr_summary *csum;\n\n  gcov_write_tag_length (tag, GCOV_TAG_SUMMARY_LENGTH);\n  gcov_write_unsigned (summary->checksum);\n  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n    {\n      gcov_write_unsigned (csum->num);\n      gcov_write_unsigned (csum->runs);\n      gcov_write_counter (csum->sum_all);\n      gcov_write_counter (csum->run_max);\n      gcov_write_counter (csum->sum_max);\n    }\n}\n#endif /* IN_LIBGCOV */\n\n#endif /*!IN_GCOV */\n\n/* Return a pointer to read BYTES bytes from the gcov file. Returns\n   NULL on failure (read past EOF).  */\n\nstatic const gcov_unsigned_t *\ngcov_read_words (unsigned words)\n{\n  const gcov_unsigned_t *result;\n  unsigned excess = gcov_var.length - gcov_var.offset;\n\n  GCOV_CHECK_READING ();\n  if (excess < words)\n    {\n      gcov_var.start += gcov_var.offset;\n#if IN_LIBGCOV\n      if (excess)\n\t{\n\t  GCOV_CHECK (excess == 1);\n\t  memcpy (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, 4);\n\t}\n#else\n      memmove (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, excess * 4);\n#endif\n      gcov_var.offset = 0;\n      gcov_var.length = excess;\n#if IN_LIBGCOV\n      GCOV_CHECK (!gcov_var.length || gcov_var.length == 1);\n      excess = GCOV_BLOCK_SIZE;\n#else\n      if (gcov_var.length + words > gcov_var.alloc)\n\tgcov_allocate (gcov_var.length + words);\n      excess = gcov_var.alloc - gcov_var.length;\n#endif\n      excess = fread (gcov_var.buffer + gcov_var.length,\n\t\t      1, excess << 2, gcov_var.file) >> 2;\n      gcov_var.length += excess;\n      if (gcov_var.length < words)\n\t{\n\t  gcov_var.overread += words - gcov_var.length;\n\t  gcov_var.length = 0;\n\t  return 0;\n\t}\n    }\n  result = &gcov_var.buffer\u00ddgcov_var.offset\u00a8;\n  gcov_var.offset += words;\n  return result;\n}\n\n/* Read unsigned value from a coverage file. Sets error flag on file\n   error, overflow flag on overflow */\n\nGCOV_LINKAGE gcov_unsigned_t\ngcov_read_unsigned (void)\n{\n  gcov_unsigned_t value;\n  const gcov_unsigned_t *buffer = gcov_read_words (1);\n\n  if (!buffer)\n    return 0;\n  value = from_file (buffer\u00dd0\u00a8);\n  return value;\n}\n\n/* Read counter value from a coverage file. Sets error flag on file\n   error, overflow flag on overflow */\n\nGCOV_LINKAGE gcov_type\ngcov_read_counter (void)\n{\n  gcov_type value;\n  const gcov_unsigned_t *buffer = gcov_read_words (2);\n\n  if (!buffer)\n    return 0;\n  value = from_file (buffer\u00dd0\u00a8);\n  if (sizeof (value) > sizeof (gcov_unsigned_t))\n#ifdef HAVE_LONG_LONG\n    value |= ((gcov_type) from_file (buffer\u00dd1\u00a8)) << 32;\n#else\n    ; /* nothing will be achieved if you don't have 64 bits */\n#endif\n  else if (buffer\u00dd1\u00a8)\n    gcov_var.error = -1;\n\n  if (value < 0)\n    gcov_var.error = -1;\n  return value;\n}\n\n/* Read string from coverage file. Returns a pointer to a static\n   buffer, or NULL on empty string. You must copy the string before\n   calling another gcov function.  */\n\n#if !IN_LIBGCOV\nGCOV_LINKAGE const char *\ngcov_read_string (void)\n{\n  unsigned length = gcov_read_unsigned ();\n\n  if (!length)\n    return 0;\n\n  return (const char *) gcov_read_words (length);\n}\n#endif\n\nGCOV_LINKAGE void\ngcov_read_summary (struct gcov_summary *summary)\n{\n  unsigned ix;\n  struct gcov_ctr_summary *csum;\n\n  summary->checksum = gcov_read_unsigned ();\n  for (csum = summary->ctrs, ix = GCOV_COUNTERS_SUMMABLE; ix--; csum++)\n    {\n      csum->num = gcov_read_unsigned ();\n      csum->runs = gcov_read_unsigned ();\n      csum->sum_all = gcov_read_counter ();\n      csum->run_max = gcov_read_counter ();\n      csum->sum_max = gcov_read_counter ();\n    }\n}\n\n#if !IN_LIBGCOV\n/* Reset to a known position.  BASE should have been obtained from\n   gcov_position, LENGTH should be a record length.  */\n\nGCOV_LINKAGE void\ngcov_sync (gcov_position_t base, gcov_unsigned_t length)\n{\n  GCOV_CHECK_READING ();\n  base += length;\n  if (base - gcov_var.start <= gcov_var.length)\n    gcov_var.offset = base - gcov_var.start;\n  else\n    {\n      gcov_var.offset = gcov_var.length = 0;\n      fseek (gcov_var.file, base << 2, SEEK_SET);\n      gcov_var.start = ftell (gcov_var.file) >> 2;\n    }\n}\n#endif\n\n#if IN_LIBGCOV\n/* Move to the a set position in a gcov file.  BASE is zero to move to\n   the end, and nonzero to move to that position.  */\n\nGCOV_LINKAGE void\ngcov_seek (gcov_position_t base)\n{\n  GCOV_CHECK_WRITING ();\n  if (gcov_var.offset)\n    gcov_write_block (gcov_var.offset);\n  fseek (gcov_var.file, base << 2, base ? SEEK_SET : SEEK_END);\n  gcov_var.start = ftell (gcov_var.file) >> 2;\n}\n#endif\n\n#if IN_GCOV > 0\n/* Return the modification time of the current gcov file.  */\n\nGCOV_LINKAGE time_t\ngcov_time (void)\n{\n  struct stat status;\n\n  if (fstat (fileno (gcov_var.file), &status))\n    return 0;\n  else\n    return status.st_mtime;\n}\n#endif /* IN_GCOV */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENATTRT": {"ttr": 3594, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* External definitions of source files of genattrtab.\n   Copyright (C)  2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* Name of function (attribute) to translate insn into number of insn\n   alternatives reservation.  */\n#define INSN_ALTS_FUNC_NAME \"insn_alts\"\n\n/* Defined in genattrtab.c: */\nextern rtx check_attr_test (rtx, int, int);\nextern rtx make_numeric_value (int);\nextern void make_internal_attr (const char *, rtx, int);\nextern char *attr_printf (unsigned int, const char *, ...)\n  ATTRIBUTE_PRINTF_2;\n\nextern int num_dfa_decls;\n\n/* Defined in genautomata.c: */\nextern void gen_cpu_unit (rtx);\nextern void gen_query_cpu_unit (rtx);\nextern void gen_bypass (rtx);\nextern void gen_excl_set (rtx);\nextern void gen_presence_set (rtx);\nextern void gen_final_presence_set (rtx);\nextern void gen_absence_set (rtx);\nextern void gen_final_absence_set (rtx);\nextern void gen_automaton (rtx);\nextern void gen_automata_option (rtx);\nextern void gen_reserv (rtx);\nextern void gen_insn_reserv (rtx);\nextern void initiate_automaton_gen (int, char **);\nextern void expand_automata (void);\nextern void write_automata (void);\n\n/* Flags for make_internal_attr's `special' parameter.  */\n#define ATTR_NONE\t\t0\n#define ATTR_SPECIAL\t\t(1 << 0)\n#define ATTR_NEGATIVE_OK\t(1 << 1)\n#define ATTR_UNSIGNED\t\t(1 << 2)\n#define ATTR_FUNC_UNITS\t\t(1 << 3)\n#define ATTR_BLOCKAGE\t\t(1 << 4)\n#define ATTR_STATIC\t\t(1 << 5)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENCHECK": {"ttr": 3596, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* empty file */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENGTYPE": {"ttr": 3600, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Process source files and output type information.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* A file position, mostly for error messages.\n   The FILE element may be compared using pointer equality.  */\nstruct fileloc {\n  const char *file;\n  int line;\n};\n\n/* Kinds of types we can understand.  */\nenum typekind {\n  TYPE_SCALAR,\n  TYPE_STRING,\n  TYPE_STRUCT,\n  TYPE_UNION,\n  TYPE_POINTER,\n  TYPE_ARRAY,\n  TYPE_LANG_STRUCT,\n  TYPE_PARAM_STRUCT\n};\n\n/* A way to pass data through to the output end.  */\ntypedef struct options {\n  struct options *next;\n  const char *name;\n  const void *info;\n} *options_p;\n\ntypedef struct pair *pair_p;\ntypedef struct type *type_p;\ntypedef unsigned lang_bitmap;\n\n/* A name and a type.  */\nstruct pair {\n  pair_p next;\n  const char *name;\n  type_p type;\n  struct fileloc line;\n  options_p opt;\n};\n\n#define NUM_PARAM 10\n\n/* A description of a type.  */\nstruct type {\n  enum typekind kind;\n  type_p next;\n  type_p pointer_to;\n  enum gc_used_enum {\n    GC_UNUSED = 0,\n    GC_USED,\n    GC_MAYBE_POINTED_TO,\n    GC_POINTED_TO\n  } gc_used;\n  union {\n    type_p p;\n    struct {\n      const char *tag;\n      struct fileloc line;\n      pair_p fields;\n      options_p opt;\n      lang_bitmap bitmap;\n      type_p lang_struct;\n    } s;\n    char *sc;\n    struct {\n      type_p p;\n      const char *len;\n    } a;\n    struct {\n      type_p stru;\n      type_p param\u00ddNUM_PARAM\u00a8;\n      struct fileloc line;\n    } param_struct;\n  } u;\n};\n\n#define UNION_P(x)\t\t\t\t\t\\\n ((x)->kind == TYPE_UNION || \t\t\t\t\\\n  ((x)->kind == TYPE_LANG_STRUCT \t\t\t\\\n   && (x)->u.s.lang_struct->kind == TYPE_UNION))\n#define UNION_OR_STRUCT_P(x)\t\t\t\\\n ((x)->kind == TYPE_UNION \t\t\t\\\n  || (x)->kind == TYPE_STRUCT \t\t\t\\\n  || (x)->kind == TYPE_LANG_STRUCT)\n\n/* The one and only TYPE_STRING.  */\nextern struct type string_type;\n\n/* Variables used to communicate between the lexer and the parser.  */\nextern int lexer_toplevel_done;\nextern struct fileloc lexer_line;\n\n/* Print an error message.  */\nextern void error_at_line\n  (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n\n/* Combines xmalloc() and vasprintf().  */\nextern int xvasprintf (char **, const char *, va_list)\n     ATTRIBUTE_PRINTF (2, 0);\n/* Like the above, but more convenient for quick coding.  */\nextern char * xasprintf (const char *, ...)\n     ATTRIBUTE_PRINTF_1;\n\n/* Constructor routines for types.  */\nextern void do_typedef (const char *s, type_p t, struct fileloc *pos);\nextern type_p resolve_typedef (const char *s, struct fileloc *pos);\nextern void new_structure (const char *name, int isunion,\n\t\t\t   struct fileloc *pos, pair_p fields,\n\t\t\t   options_p o);\nextern type_p find_structure (const char *s, int isunion);\nextern type_p create_scalar_type (const char *name, size_t name_len);\nextern type_p create_pointer (type_p t);\nextern type_p create_array (type_p t, const char *len);\nextern type_p adjust_field_type (type_p, options_p);\nextern void note_variable (const char *s, type_p t, options_p o,\n\t\t\t   struct fileloc *pos);\nextern void note_yacc_type (options_p o, pair_p fields,\n\t\t\t    pair_p typeinfo, struct fileloc *pos);\n\n/* Lexer and parser routines, most automatically generated.  */\nextern int yylex (void);\nextern void yyerror (const char *);\nextern int yyparse (void);\nextern void parse_file (const char *name);\n\n/* Output file handling.  */\n\n/* Structure representing an output file.  */\nstruct outf\n{\n  struct outf *next;\n  const char *name;\n  size_t buflength;\n  size_t bufused;\n  char *buf;\n};\n\ntypedef struct outf * outf_p;\n\n/* The output header file that is included into pretty much every\n   source file.  */\nextern outf_p header_file;\n\n/* An output file, suitable for definitions, that can see declarations\n   made in INPUT_FILE and is linked into every language that uses\n   INPUT_FILE.  */\nextern outf_p get_output_file_with_visibility\n   (const char *input_file);\nconst char *get_output_file_name (const char *);\n\n/* A list of output files suitable for definitions.  There is one\n   BASE_FILES entry for each language.  */\nextern outf_p base_files\u00dd\u00a8;\n\n/* A bitmap that specifies which of BASE_FILES should be used to\n   output a definition that is different for each language and must be\n   defined once in each language that uses INPUT_FILE.  */\nextern lang_bitmap get_base_file_bitmap (const char *input_file);\n\n/* Print, like fprintf, to O.  */\nextern void oprintf (outf_p o, const char *S, ...)\n     ATTRIBUTE_PRINTF_2;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENRTL": {"ttr": 3602, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by gengenrtl from rtl.def.  */\n\n#ifndef GCC_GENRTL_H\n#define GCC_GENRTL_H\n\nextern rtx gen_rtx_fmt_s\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0);\nextern rtx gen_rtx_fmt_ee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1);\nextern rtx gen_rtx_fmt_ue\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1);\nextern rtx gen_rtx_fmt_iss\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1,\n\t\t\t\t       const char *arg2);\nextern rtx gen_rtx_fmt_is\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1);\nextern rtx gen_rtx_fmt_i\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0);\nextern rtx gen_rtx_fmt_isE\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, const char *arg1,\n\t\t\t\t       rtvec arg2);\nextern rtx gen_rtx_fmt_iE\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtvec arg1);\nextern rtx gen_rtx_fmt_Ess\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, const char *arg1,\n\t\t\t\t       const char *arg2);\nextern rtx gen_rtx_fmt_sEss\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, rtvec arg1,\n\t\t\t\t       const char *arg2, const char *arg3);\nextern rtx gen_rtx_fmt_eE\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtvec arg1);\nextern rtx gen_rtx_fmt_E\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0);\nextern rtx gen_rtx_fmt_e\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0);\nextern rtx gen_rtx_fmt_ss\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1);\nextern rtx gen_rtx_fmt_sies\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, int arg1,\n\t\t\t\t       rtx arg2, const char *arg3);\nextern rtx gen_rtx_fmt_sse\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1,\n\t\t\t\t       rtx arg2);\nextern rtx gen_rtx_fmt_sE\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, rtvec arg1);\nextern rtx gen_rtx_fmt_ii\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, int arg1);\nextern rtx gen_rtx_fmt_iuuBieiee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       struct basic_block_def *arg3,\n\t\t\t\t       int arg4, rtx arg5, int arg6,\n\t\t\t\t       rtx arg7, rtx arg8);\nextern rtx gen_rtx_fmt_iuuBieiee0\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       struct basic_block_def *arg3,\n\t\t\t\t       int arg4, rtx arg5, int arg6,\n\t\t\t\t       rtx arg7, rtx arg8);\nextern rtx gen_rtx_fmt_iuuBieieee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       struct basic_block_def *arg3,\n\t\t\t\t       int arg4, rtx arg5, int arg6,\n\t\t\t\t       rtx arg7, rtx arg8, rtx arg9);\nextern rtx gen_rtx_fmt_iuu000000\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2);\nextern rtx gen_rtx_fmt_iuuB00is\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, rtx arg1, rtx arg2,\n\t\t\t\t       struct basic_block_def *arg3,\n\t\t\t\t       int arg4, const char *arg5);\nextern rtx gen_rtx_fmt_ssiEEsi\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0, const char *arg1,\n\t\t\t\t       int arg2, rtvec arg3, rtvec arg4,\n\t\t\t\t       const char *arg5, int arg6);\nextern rtx gen_rtx_fmt_Ei\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, int arg1);\nextern rtx gen_rtx_fmt_eEee0\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtvec arg1, rtx arg2,\n\t\t\t\t       rtx arg3);\nextern rtx gen_rtx_fmt_eee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2);\nextern rtx gen_rtx_fmt_\t (RTX_CODE, enum machine_mode mode);\nextern rtx gen_rtx_fmt_w\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       HOST_WIDE_INT arg0);\nextern rtx gen_rtx_fmt_0\t (RTX_CODE, enum machine_mode mode);\nextern rtx gen_rtx_fmt_i00\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0);\nextern rtx gen_rtx_fmt_ei\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, int arg1);\nextern rtx gen_rtx_fmt_e0\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0);\nextern rtx gen_rtx_fmt_u00\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0);\nextern rtx gen_rtx_fmt_s00\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       const char *arg0);\nextern rtx gen_rtx_fmt_eit\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, int arg1,\n\t\t\t\t       union tree_node *arg2);\nextern rtx gen_rtx_fmt_eeeee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3, rtx arg4);\nextern rtx gen_rtx_fmt_Ee\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtvec arg0, rtx arg1);\nextern rtx gen_rtx_fmt_uuEiiiiiibbii\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtvec arg2,\n\t\t\t\t       int arg3, int arg4, int arg5,\n\t\t\t\t       int arg6, int arg7, int arg8,\n\t\t\t\t       struct bitmap_head_def *arg9,\n\t\t\t\t       struct bitmap_head_def *arg10,\n\t\t\t\t       int arg11, int arg12);\nextern rtx gen_rtx_fmt_iiiiiiiitt\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       int arg0, int arg1, int arg2,\n\t\t\t\t       int arg3, int arg4, int arg5,\n\t\t\t\t       int arg6, int arg7,\n\t\t\t\t       union tree_node *arg8,\n\t\t\t\t       union tree_node *arg9);\nextern rtx gen_rtx_fmt_eti\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, union tree_node *arg1,\n\t\t\t\t       int arg2);\nextern rtx gen_rtx_fmt_bi\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       struct bitmap_head_def *arg0,\n\t\t\t\t       int arg1);\nextern rtx gen_rtx_fmt_uuuu\t (RTX_CODE, enum machine_mode mode,\n\t\t\t\t       rtx arg0, rtx arg1, rtx arg2,\n\t\t\t\t       rtx arg3);\n\n#define gen_rtx_INCLUDE(MODE, ARG0) \\\n  gen_rtx_fmt_s (INCLUDE, (MODE), (ARG0))\n#define gen_rtx_EXPR_LIST(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (EXPR_LIST, (MODE), (ARG0), (ARG1))\n#define gen_rtx_INSN_LIST(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ue (INSN_LIST, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_OPERAND(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_iss (MATCH_OPERAND, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_SCRATCH(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_is (MATCH_SCRATCH, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_DUP(MODE, ARG0) \\\n  gen_rtx_fmt_i (MATCH_DUP, (MODE), (ARG0))\n#define gen_rtx_MATCH_OPERATOR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_isE (MATCH_OPERATOR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_PARALLEL(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_isE (MATCH_PARALLEL, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_MATCH_OP_DUP(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_iE (MATCH_OP_DUP, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_PAR_DUP(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_iE (MATCH_PAR_DUP, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MATCH_INSN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_is (MATCH_INSN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_COMBINE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_Ess (DEFINE_COMBINE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_DEFINE_EXPAND(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_sEss (DEFINE_EXPAND, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_DEFINE_DELAY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_eE (DEFINE_DELAY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_COND_EXEC(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_Ess (DEFINE_COND_EXEC, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_SEQUENCE(MODE, ARG0) \\\n  gen_rtx_fmt_E (SEQUENCE, (MODE), (ARG0))\n#define gen_rtx_ADDRESS(MODE, ARG0) \\\n  gen_rtx_fmt_e (ADDRESS, (MODE), (ARG0))\n#define gen_rtx_EXCLUSION_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (EXCLUSION_SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PRESENCE_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (PRESENCE_SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_FINAL_PRESENCE_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (FINAL_PRESENCE_SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ABSENCE_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (ABSENCE_SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_FINAL_ABSENCE_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (FINAL_ABSENCE_SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_AUTOMATON(MODE, ARG0) \\\n  gen_rtx_fmt_s (DEFINE_AUTOMATON, (MODE), (ARG0))\n#define gen_rtx_AUTOMATA_OPTION(MODE, ARG0) \\\n  gen_rtx_fmt_s (AUTOMATA_OPTION, (MODE), (ARG0))\n#define gen_rtx_DEFINE_RESERVATION(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (DEFINE_RESERVATION, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DEFINE_INSN_RESERVATION(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_sies (DEFINE_INSN_RESERVATION, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_DEFINE_ATTR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_sse (DEFINE_ATTR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_ATTR(MODE, ARG0) \\\n  gen_rtx_fmt_s (ATTR, (MODE), (ARG0))\n#define gen_rtx_SET_ATTR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (SET_ATTR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SET_ATTR_ALTERNATIVE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_sE (SET_ATTR_ALTERNATIVE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_EQ_ATTR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ss (EQ_ATTR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_EQ_ATTR_ALT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ii (EQ_ATTR_ALT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ATTR_FLAG(MODE, ARG0) \\\n  gen_rtx_fmt_s (ATTR_FLAG, (MODE), (ARG0))\n#define gen_rtx_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) \\\n  gen_rtx_fmt_iuuBieiee (INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8))\n#define gen_rtx_JUMP_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) \\\n  gen_rtx_fmt_iuuBieiee0 (JUMP_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8))\n#define gen_rtx_CALL_INSN(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) \\\n  gen_rtx_fmt_iuuBieieee (CALL_INSN, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9))\n#define gen_rtx_BARRIER(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_iuu000000 (BARRIER, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_CODE_LABEL(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n  gen_rtx_fmt_iuuB00is (CODE_LABEL, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5))\n#define gen_rtx_COND_EXEC(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (COND_EXEC, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PARALLEL(MODE, ARG0) \\\n  gen_rtx_fmt_E (PARALLEL, (MODE), (ARG0))\n#define gen_rtx_ASM_INPUT(MODE, ARG0) \\\n  gen_rtx_fmt_s (ASM_INPUT, (MODE), (ARG0))\n#define gen_rtx_ASM_OPERANDS(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \\\n  gen_rtx_fmt_ssiEEsi (ASM_OPERANDS, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6))\n#define gen_rtx_UNSPEC(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ei (UNSPEC, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNSPEC_VOLATILE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ei (UNSPEC_VOLATILE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ADDR_VEC(MODE, ARG0) \\\n  gen_rtx_fmt_E (ADDR_VEC, (MODE), (ARG0))\n#define gen_rtx_ADDR_DIFF_VEC(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_eEee0 (ADDR_DIFF_VEC, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_PREFETCH(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (PREFETCH, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_SET(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SET, (MODE), (ARG0), (ARG1))\n#define gen_rtx_USE(MODE, ARG0) \\\n  gen_rtx_fmt_e (USE, (MODE), (ARG0))\n#define gen_rtx_CLOBBER(MODE, ARG0) \\\n  gen_rtx_fmt_e (CLOBBER, (MODE), (ARG0))\n#define gen_rtx_CALL(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (CALL, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RETURN(MODE) \\\n  gen_rtx_fmt_ (RETURN, (MODE))\n#define gen_rtx_TRAP_IF(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (TRAP_IF, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RESX(MODE, ARG0) \\\n  gen_rtx_fmt_i (RESX, (MODE), (ARG0))\n#define gen_rtx_raw_CONST_INT(MODE, ARG0) \\\n  gen_rtx_fmt_w (CONST_INT, (MODE), (ARG0))\n#define gen_rtx_raw_CONST_VECTOR(MODE, ARG0) \\\n  gen_rtx_fmt_E (CONST_VECTOR, (MODE), (ARG0))\n#define gen_rtx_CONST_STRING(MODE, ARG0) \\\n  gen_rtx_fmt_s (CONST_STRING, (MODE), (ARG0))\n#define gen_rtx_CONST(MODE, ARG0) \\\n  gen_rtx_fmt_e (CONST, (MODE), (ARG0))\n#define gen_rtx_PC(MODE) \\\n  gen_rtx_fmt_ (PC, (MODE))\n#define gen_rtx_VALUE(MODE) \\\n  gen_rtx_fmt_0 (VALUE, (MODE))\n#define gen_rtx_raw_REG(MODE, ARG0) \\\n  gen_rtx_fmt_i00 (REG, (MODE), (ARG0))\n#define gen_rtx_SCRATCH(MODE) \\\n  gen_rtx_fmt_0 (SCRATCH, (MODE))\n#define gen_rtx_raw_SUBREG(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ei (SUBREG, (MODE), (ARG0), (ARG1))\n#define gen_rtx_STRICT_LOW_PART(MODE, ARG0) \\\n  gen_rtx_fmt_e (STRICT_LOW_PART, (MODE), (ARG0))\n#define gen_rtx_CONCAT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (CONCAT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_raw_MEM(MODE, ARG0) \\\n  gen_rtx_fmt_e0 (MEM, (MODE), (ARG0))\n#define gen_rtx_LABEL_REF(MODE, ARG0) \\\n  gen_rtx_fmt_u00 (LABEL_REF, (MODE), (ARG0))\n#define gen_rtx_SYMBOL_REF(MODE, ARG0) \\\n  gen_rtx_fmt_s00 (SYMBOL_REF, (MODE), (ARG0))\n#define gen_rtx_CC0(MODE) \\\n  gen_rtx_fmt_ (CC0, (MODE))\n#define gen_rtx_ADDRESSOF(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eit (ADDRESSOF, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_QUEUED(MODE, ARG0, ARG1, ARG2, ARG3, ARG4) \\\n  gen_rtx_fmt_eeeee (QUEUED, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4))\n#define gen_rtx_IF_THEN_ELSE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (IF_THEN_ELSE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_COND(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_Ee (COND, (MODE), (ARG0), (ARG1))\n#define gen_rtx_COMPARE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (COMPARE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NEG(MODE, ARG0) \\\n  gen_rtx_fmt_e (NEG, (MODE), (ARG0))\n#define gen_rtx_MULT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MULT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_DIV(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (DIV, (MODE), (ARG0), (ARG1))\n#define gen_rtx_MOD(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (MOD, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UDIV(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UDIV, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMOD(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMOD, (MODE), (ARG0), (ARG1))\n#define gen_rtx_AND(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (AND, (MODE), (ARG0), (ARG1))\n#define gen_rtx_IOR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (IOR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_XOR(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (XOR, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NOT(MODE, ARG0) \\\n  gen_rtx_fmt_e (NOT, (MODE), (ARG0))\n#define gen_rtx_ASHIFT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ASHIFT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ROTATE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ROTATE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ASHIFTRT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ASHIFTRT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LSHIFTRT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LSHIFTRT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ROTATERT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ROTATERT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SMIN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SMIN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SMAX(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SMAX, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMIN(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMIN, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UMAX(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UMAX, (MODE), (ARG0), (ARG1))\n#define gen_rtx_PRE_DEC(MODE, ARG0) \\\n  gen_rtx_fmt_e (PRE_DEC, (MODE), (ARG0))\n#define gen_rtx_PRE_INC(MODE, ARG0) \\\n  gen_rtx_fmt_e (PRE_INC, (MODE), (ARG0))\n#define gen_rtx_POST_DEC(MODE, ARG0) \\\n  gen_rtx_fmt_e (POST_DEC, (MODE), (ARG0))\n#define gen_rtx_POST_INC(MODE, ARG0) \\\n  gen_rtx_fmt_e (POST_INC, (MODE), (ARG0))\n#define gen_rtx_PRE_MODIFY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (PRE_MODIFY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_POST_MODIFY(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (POST_MODIFY, (MODE), (ARG0), (ARG1))\n#define gen_rtx_NE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (NE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_EQ(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (EQ, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GEU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GEU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_GTU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (GTU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LEU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LEU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LTU(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LTU, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNORDERED(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNORDERED, (MODE), (ARG0), (ARG1))\n#define gen_rtx_ORDERED(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (ORDERED, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNEQ(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNEQ, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNGE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNGE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNGT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNGT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNLE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNLE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_UNLT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (UNLT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_LTGT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LTGT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SIGN_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (SIGN_EXTEND, (MODE), (ARG0))\n#define gen_rtx_ZERO_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (ZERO_EXTEND, (MODE), (ARG0))\n#define gen_rtx_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_FLOAT_EXTEND(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT_EXTEND, (MODE), (ARG0))\n#define gen_rtx_FLOAT_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT_TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_FLOAT(MODE, ARG0) \\\n  gen_rtx_fmt_e (FLOAT, (MODE), (ARG0))\n#define gen_rtx_FIX(MODE, ARG0) \\\n  gen_rtx_fmt_e (FIX, (MODE), (ARG0))\n#define gen_rtx_UNSIGNED_FLOAT(MODE, ARG0) \\\n  gen_rtx_fmt_e (UNSIGNED_FLOAT, (MODE), (ARG0))\n#define gen_rtx_UNSIGNED_FIX(MODE, ARG0) \\\n  gen_rtx_fmt_e (UNSIGNED_FIX, (MODE), (ARG0))\n#define gen_rtx_ABS(MODE, ARG0) \\\n  gen_rtx_fmt_e (ABS, (MODE), (ARG0))\n#define gen_rtx_SQRT(MODE, ARG0) \\\n  gen_rtx_fmt_e (SQRT, (MODE), (ARG0))\n#define gen_rtx_FFS(MODE, ARG0) \\\n  gen_rtx_fmt_e (FFS, (MODE), (ARG0))\n#define gen_rtx_CLZ(MODE, ARG0) \\\n  gen_rtx_fmt_e (CLZ, (MODE), (ARG0))\n#define gen_rtx_CTZ(MODE, ARG0) \\\n  gen_rtx_fmt_e (CTZ, (MODE), (ARG0))\n#define gen_rtx_POPCOUNT(MODE, ARG0) \\\n  gen_rtx_fmt_e (POPCOUNT, (MODE), (ARG0))\n#define gen_rtx_PARITY(MODE, ARG0) \\\n  gen_rtx_fmt_e (PARITY, (MODE), (ARG0))\n#define gen_rtx_SIGN_EXTRACT(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (SIGN_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_ZERO_EXTRACT(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (ZERO_EXTRACT, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_HIGH(MODE, ARG0) \\\n  gen_rtx_fmt_e (HIGH, (MODE), (ARG0))\n#define gen_rtx_LO_SUM(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (LO_SUM, (MODE), (ARG0), (ARG1))\n#define gen_rtx_RANGE_INFO(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n  gen_rtx_fmt_uuEiiiiiibbii (RANGE_INFO, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9), (ARG10), (ARG11), (ARG12))\n#define gen_rtx_RANGE_REG(MODE, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) \\\n  gen_rtx_fmt_iiiiiiiitt (RANGE_REG, (MODE), (ARG0), (ARG1), (ARG2), (ARG3), (ARG4), (ARG5), (ARG6), (ARG7), (ARG8), (ARG9))\n#define gen_rtx_RANGE_VAR(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eti (RANGE_VAR, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_RANGE_LIVE(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_bi (RANGE_LIVE, (MODE), (ARG0), (ARG1))\n#define gen_rtx_CONSTANT_P_RTX(MODE, ARG0) \\\n  gen_rtx_fmt_e (CONSTANT_P_RTX, (MODE), (ARG0))\n#define gen_rtx_CALL_PLACEHOLDER(MODE, ARG0, ARG1, ARG2, ARG3) \\\n  gen_rtx_fmt_uuuu (CALL_PLACEHOLDER, (MODE), (ARG0), (ARG1), (ARG2), (ARG3))\n#define gen_rtx_VEC_MERGE(MODE, ARG0, ARG1, ARG2) \\\n  gen_rtx_fmt_eee (VEC_MERGE, (MODE), (ARG0), (ARG1), (ARG2))\n#define gen_rtx_VEC_SELECT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (VEC_SELECT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_VEC_CONCAT(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (VEC_CONCAT, (MODE), (ARG0), (ARG1))\n#define gen_rtx_VEC_DUPLICATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (VEC_DUPLICATE, (MODE), (ARG0))\n#define gen_rtx_SS_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SS_PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_US_PLUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (US_PLUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SS_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (SS_MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_US_MINUS(MODE, ARG0, ARG1) \\\n  gen_rtx_fmt_ee (US_MINUS, (MODE), (ARG0), (ARG1))\n#define gen_rtx_SS_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (SS_TRUNCATE, (MODE), (ARG0))\n#define gen_rtx_US_TRUNCATE(MODE, ARG0) \\\n  gen_rtx_fmt_e (US_TRUNCATE, (MODE), (ARG0))\n\n#endif /* GCC_GENRTL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENSUPPO": {"ttr": 3844, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for rtx-reader support for gen* routines.\n   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GENSUPPORT_H\n#define GCC_GENSUPPORT_H\n\nstruct obstack;\nextern struct obstack *rtl_obstack;\n\nextern int init_md_reader_args (int, char **);\nextern int init_md_reader (const char *);\nextern rtx read_md_rtx (int *, int *);\n\nextern void message_with_line (int, const char *, ...)\n     ATTRIBUTE_PRINTF_2;\n\n/* Set this to 0 to disable automatic elision of insn patterns which\n   can never be used in this configuration.  See genconditions.c.\n   Must be set before calling init_md_reader.  */\nextern int insn_elision;\n\n/* If this is 1, the insn elision table doesn't even exist yet;\n   maybe_eval_c_test will always return -1.  This is distinct from\n   insn_elision because genflags and gencodes need to see all the\n   patterns, but treat elided patterns differently.  */\nextern const int insn_elision_unavailable;\n\n/* If the C test passed as the argument can be evaluated at compile\n   time, return its truth value; else return -1.  The test must have\n   appeared somewhere in the machine description when genconditions\n   was run.  */\nextern int maybe_eval_c_test (const char *);\n\n/* This table should not be accessed directly; use maybe_eval_c_test.  */\nstruct c_test\n{\n  const char *expr;\n  int value;\n};\n\nextern const struct c_test insn_conditions\u00dd\u00a8;\nextern const size_t n_insn_conditions;\n\n#ifdef __HASHTAB_H__\nextern hashval_t hash_c_test (const void *);\nextern int cmp_c_test (const void *, const void *);\n#endif\n\nextern int n_comma_elts\t(const char *);\nextern const char *scan_comma_elt (const char **);\n\n#endif /* GCC_GENSUPPORT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETOPT": {"ttr": 3846, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for getopt.\n   Copyright 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 2000,\n   2002 Free Software Foundation, Inc.\n\n   NOTE: The canonical source of this file is maintained with the GNU C Library.\n   Bugs can be reported to bug-glibc@gnu.org.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n\n#ifndef _GETOPT_H\n#define _GETOPT_H 1\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nextern char *optarg;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns -1, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\nextern int optind;\n\n/* Callers store zero here to inhibit the error message `getopt' prints\n   for unrecognized options.  */\n\nextern int opterr;\n\n/* Set to an option character which was unrecognized.  */\n\nextern int optopt;\n\n/* Describe the long-named options requested by the application.\n   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector\n   of `struct option' terminated by an element containing a name which is\n   zero.\n\n   The field `has_arg' is:\n   no_argument\t\t(or 0) if the option does not take an argument,\n   required_argument\t(or 1) if the option requires an argument,\n   optional_argument \t(or 2) if the option takes an optional argument.\n\n   If the field `flag' is not NULL, it points to a variable that is set\n   to the value given in the field `val' when the option is found, but\n   left unchanged if the option is not found.\n\n   To have a long-named option do something other than set an `int' to\n   a compiled-in constant, such as set a value from `optarg', set the\n   option's `flag' field to zero and its `val' field to a nonzero\n   value (the equivalent single-letter option character, if there is\n   one).  For long options that have a zero `flag' field, `getopt'\n   returns the contents of the `val' field.  */\n\nstruct option\n{\n#if defined (__STDC__) && __STDC__\n  const char *name;\n#else\n  char *name;\n#endif\n  /* has_arg can't be an enum because some compilers complain about\n     type mismatches in all the code that assumes it is an int.  */\n  int has_arg;\n  int *flag;\n  int val;\n};\n\n/* Names for the values of the `has_arg' field of `struct option'.  */\n\n#define\tno_argument\t\t0\n#define required_argument\t1\n#define optional_argument\t2\n\n#if defined (__STDC__) && __STDC__\n/* HAVE_DECL_* is a three-state macro: undefined, 0 or 1.  If it is\n   undefined, we haven't run the autoconf check so provide the\n   declaration without arguments.  If it is 0, we checked and failed\n   to find the declaration so provide a fully prototyped one.  If it\n   is 1, we found it so don't provide any declaration at all.  */\n#if !HAVE_DECL_GETOPT\n#if defined (__GNU_LIBRARY__) || defined (HAVE_DECL_GETOPT)\n/* Many other libraries have conflicting prototypes for getopt, with\n   differences in the consts, in unistd.h.  To avoid compilation\n   errors, only prototype getopt for the GNU C library.  */\nextern int getopt (int argc, char *const *argv, const char *shortopts);\n#else\n#ifndef __cplusplus\nextern int getopt ();\n#endif /* __cplusplus */\n#endif\n#endif /* !HAVE_DECL_GETOPT */\n\nextern int getopt_long (int argc, char *const *argv, const char *shortopts,\n\t\t        const struct option *longopts, int *longind);\nextern int getopt_long_only (int argc, char *const *argv,\n\t\t\t     const char *shortopts,\n\t\t             const struct option *longopts, int *longind);\n\n/* Internal only.  Users should not call this directly.  */\nextern int _getopt_internal (int argc, char *const *argv,\n\t\t\t     const char *shortopts,\n\t\t             const struct option *longopts, int *longind,\n\t\t\t     int long_only);\n#else /* not __STDC__ */\nextern int getopt ();\nextern int getopt_long ();\nextern int getopt_long_only ();\n\nextern int _getopt_internal ();\n#endif /* __STDC__ */\n\n#ifdef\t__cplusplus\n}\n#endif\n\n#endif /* getopt.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GGC": {"ttr": 3848, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Garbage collection for the GNU compiler.\n   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GGC_H\n#define GCC_GGC_H\n\n/* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n   an external gc library that might be linked in.  */\n\n/* Constants for general use.  */\nextern const char empty_string\u00dd\u00a8;\t/* empty string */\nextern const char digit_vector\u00dd\u00a8;\t/* \"0\" .. \"9\" */\n#define digit_string(d) (digit_vector + ((d) * 2))\n\n/* Internal functions and data structures used by the GTY\n   machinery.  */\n\n/* The first parameter is a pointer to a pointer, the second a cookie.  */\ntypedef void (*gt_pointer_operator) (void *, void *);\n\n#include \"gtype-desc.h\"\n\n/* One of these applies its third parameter (with cookie in the fourth\n   parameter) to each pointer in the object pointed to by the first\n   parameter, using the second parameter.  */\ntypedef void (*gt_note_pointers) (void *, void *, gt_pointer_operator,\n\t\t\t\t  void *);\n\n/* One of these is called before objects are re-ordered in memory.\n   The first parameter is the original object, the second is the\n   subobject that has had its pointers reordered, the third parameter\n   can compute the new values of a pointer when given the cookie in\n   the fourth parameter.  */\ntypedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,\n\t\t\t\t   void *);\n\n/* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\nextern int gt_pch_note_object (void *, void *, gt_note_pointers);\n\n/* Used by the gt_pch_n_* routines.  Register that an object has a reorder\n   function.  */\nextern void gt_pch_note_reorder (void *, void *, gt_handle_reorder);\n\n/* Mark the object in the first parameter and anything it points to.  */\ntypedef void (*gt_pointer_walker) (void *);\n\n/* Structures for the easy way to mark roots.\n   In an array, terminated by having base == NULL.  */\nstruct ggc_root_tab {\n  void *base;\n  size_t nelt;\n  size_t stride;\n  gt_pointer_walker cb;\n  gt_pointer_walker pchw;\n};\n#define LAST_GGC_ROOT_TAB { NULL, 0, 0, NULL, NULL }\n/* Pointers to arrays of ggc_root_tab, terminated by NULL.  */\nextern const struct ggc_root_tab * const gt_ggc_rtab\u00dd\u00a8;\nextern const struct ggc_root_tab * const gt_ggc_deletable_rtab\u00dd\u00a8;\nextern const struct ggc_root_tab * const gt_pch_cache_rtab\u00dd\u00a8;\nextern const struct ggc_root_tab * const gt_pch_scalar_rtab\u00dd\u00a8;\n\n/* Structure for hash table cache marking.  */\nstruct htab;\nstruct ggc_cache_tab {\n  struct htab * *base;\n  size_t nelt;\n  size_t stride;\n  gt_pointer_walker cb;\n  gt_pointer_walker pchw;\n  int (*marked_p) (const void *);\n};\n#define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL, NULL }\n/* Pointers to arrays of ggc_cache_tab, terminated by NULL.  */\nextern const struct ggc_cache_tab * const gt_ggc_cache_rtab\u00dd\u00a8;\n\n/* If EXPR is not NULL and previously unmarked, mark it and evaluate\n   to true.  Otherwise evaluate to false.  */\n#define ggc_test_and_set_mark(EXPR) \\\n  ((EXPR) != NULL && ((void *) (EXPR)) != (void *) 1 && ! ggc_set_mark (EXPR))\n\n#define ggc_mark(EXPR)\t\t\t\t\\\n  do {\t\t\t\t\t\t\\\n    const void *const a__ = (EXPR);\t\t\\\n    if (a__ != NULL && a__ != (void *) 1)\t\\\n      ggc_set_mark (a__);\t\t\t\\\n  } while (0)\n\n/* Actually set the mark on a particular region of memory, but don't\n   follow pointers.  This function is called by ggc_mark_*.  It\n   returns zero if the object was not previously marked; nonzero if\n   the object was already marked, or if, for any other reason,\n   pointers in this data structure should not be traversed.  */\nextern int ggc_set_mark\t(const void *);\n\n/* Return 1 if P has been marked, zero otherwise.\n   P must have been allocated by the GC allocator; it mustn't point to\n   static objects, stack variables, or memory allocated with malloc.  */\nextern int ggc_marked_p\t(const void *);\n\n/* Mark the entries in the string pool.  */\nextern void ggc_mark_stringpool\t(void);\n\n/* Call ggc_set_mark on all the roots.  */\n\nextern void ggc_mark_roots (void);\n\n/* Save and restore the string pool entries for PCH.  */\n\nextern void gt_pch_save_stringpool (void);\nextern void gt_pch_fixup_stringpool (void);\nextern void gt_pch_restore_stringpool (void);\n\n/* PCH and GGC handling for strings, mostly trivial.  */\n\nextern void gt_pch_p_S (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_n_S (const void *);\nextern void gt_ggc_m_S (void *);\n\n/* Initialize the string pool.  */\nextern void init_stringpool (void);\n\n/* A GC implementation must provide these functions.  They are internal\n   to the GC system.  */\n\n/* Forward declare the zone structure.  Only ggc_zone implements this.  */\nstruct alloc_zone;\n\n/* Initialize the garbage collector.  */\nextern void init_ggc (void);\n\n/* Start a new GGC zone.  */\nextern struct alloc_zone *new_ggc_zone (const char *);\n\n/* Free a complete GGC zone, destroying everything in it.  */\nextern void destroy_ggc_zone (struct alloc_zone *);\n\n/* Start a new GGC context.  Memory allocated in previous contexts\n   will not be collected while the new context is active.  */\nextern void ggc_push_context (void);\n\n/* Finish a GC context.  Any uncollected memory in the new context\n   will be merged with the old context.  */\nextern void ggc_pop_context (void);\n\nstruct ggc_pch_data;\n\n/* Return a new ggc_pch_data structure.  */\nextern struct ggc_pch_data *init_ggc_pch (void);\n\n/* The second parameter and third parameters give the address and size\n   of an object.  Update the ggc_pch_data structure with as much of\n   that information as is necessary. The last argument should be true\n   if the object is a string.  */\nextern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t, bool);\n\n/* Return the total size of the data to be written to hold all\n   the objects previously passed to ggc_pch_count_object.  */\nextern size_t ggc_pch_total_size (struct ggc_pch_data *);\n\n/* The objects, when read, will most likely be at the address\n   in the second parameter.  */\nextern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n\n/* Assuming that the objects really do end up at the address\n   passed to ggc_pch_this_base, return the address of this object.\n   The last argument should be true if the object is a string.  */\nextern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t, bool);\n\n/* Write out any initial information required.  */\nextern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);\n/* Write out this object, including any padding.  The last argument should be\n   true if the object is a string.  */\nextern void ggc_pch_write_object (struct ggc_pch_data *, FILE *, void *,\n\t\t\t\t  void *, size_t, bool);\n/* All objects have been written, write out any final information\n   required.  */\nextern void ggc_pch_finish (struct ggc_pch_data *, FILE *);\n\n/* A PCH file has just been read in at the address specified second\n   parameter.  Set up the GC implementation for the new objects.  */\nextern void ggc_pch_read (FILE *, void *);\n\n\n/* Allocation.  */\n\n/* For single pass garbage.  */\nextern struct alloc_zone *garbage_zone;\n/* For regular rtl allocations.  */\nextern struct alloc_zone *rtl_zone;\n/* For regular tree allocations.  */\nextern struct alloc_zone *tree_zone;\n\n/* The internal primitive.  */\nextern void *ggc_alloc (size_t);\n/* Allocate an object into the specified allocation zone.  */\nextern void *ggc_alloc_zone (size_t, struct alloc_zone *);\n/* Allocate an object of the specified type and size.  */\nextern void *ggc_alloc_typed (enum gt_types_enum, size_t);\n/* Like ggc_alloc, but allocates cleared memory.  */\nextern void *ggc_alloc_cleared (size_t);\n/* Like ggc_alloc_zone, but allocates cleared memory.  */\nextern void *ggc_alloc_cleared_zone (size_t, struct alloc_zone *);\n/* Resize a block.  */\nextern void *ggc_realloc (void *, size_t);\n/* Like ggc_alloc_cleared, but performs a multiplication.  */\nextern void *ggc_calloc (size_t, size_t);\n\n#define ggc_alloc_rtx(CODE)                    \\\n  ((rtx) ggc_alloc_typed (gt_ggc_e_7rtx_def, RTX_SIZE (CODE)))\n\n#define ggc_alloc_rtvec(NELT)\t\t\t\t\t\t  \\\n  ((rtvec) ggc_alloc_typed (gt_ggc_e_9rtvec_def, sizeof (struct rtvec_def) \\\n\t\t      + ((NELT) - 1) * sizeof (rtx)))\n\n#define ggc_alloc_tree(LENGTH) ((tree) ggc_alloc_zone (LENGTH, tree_zone))\n\n#define htab_create_ggc(SIZE, HASH, EQ, DEL) \\\n  htab_create_alloc (SIZE, HASH, EQ, DEL, ggc_calloc, NULL)\n\n#define splay_tree_new_ggc(COMPARE)\t\t\t\t\t \\\n  splay_tree_new_with_allocator (COMPARE, NULL, NULL,\t\t\t \\\n                                 &ggc_splay_alloc, &ggc_splay_dont_free, \\\n\t\t\t\t NULL)\nextern void *ggc_splay_alloc (int, void *);\nextern void ggc_splay_dont_free (void *, void *);\n\n/* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n   If LENGTH is -1, then CONTENTS is assumed to be a\n   null-terminated string and the memory sized accordingly.  */\nextern const char *ggc_alloc_string (const char *contents, int length);\n\n/* Make a copy of S, in GC-able memory.  */\n#define ggc_strdup(S) ggc_alloc_string((S), -1)\n\n/* Invoke the collector.  Garbage collection occurs only when this\n   function is called, not during allocations.  */\nextern void ggc_collect\t(void);\n\n/* Return the number of bytes allocated at the indicated address.  */\nextern size_t ggc_get_size (const void *);\n\n/* Write out all GCed objects to F.  */\nextern void gt_pch_save (FILE *f);\n\n/* Read objects previously saved with gt_pch_save from F.  */\nextern void gt_pch_restore (FILE *f);\n\n/* Statistics.  */\n\n/* This structure contains the statistics common to all collectors.\n   Particular collectors can extend this structure.  */\ntypedef struct ggc_statistics\n{\n  /* At present, we don't really gather any interesting statistics.  */\n  int unused;\n} ggc_statistics;\n\n/* Used by the various collectors to gather and print statistics that\n   do not depend on the collector in use.  */\nextern void ggc_print_common_statistics (FILE *, ggc_statistics *);\n\n/* Print allocation statistics.  */\nextern void ggc_print_statistics (void);\nextern void stringpool_statistics (void);\n\n/* Heuristics.  */\nextern int ggc_min_expand_heuristic (void);\nextern int ggc_min_heapsize_heuristic (void);\nextern void init_ggc_heuristics (void);\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GLIMITS": {"ttr": 3851, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef _LIMITS_H___\n#define _LIMITS_H___\n\n/* Number of bits in a `char'.  */\n#undef CHAR_BIT\n#define CHAR_BIT __CHAR_BIT__\n\n/* Maximum length of a multibyte character.  */\n#ifndef MB_LEN_MAX\n#define MB_LEN_MAX 1\n#endif\n\n/* Minimum and maximum values a `signed char' can hold.  */\n#undef SCHAR_MIN\n#define SCHAR_MIN (-SCHAR_MAX - 1)\n#undef SCHAR_MAX\n#define SCHAR_MAX __SCHAR_MAX__\n\n/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */\n#undef UCHAR_MAX\n#if __SCHAR_MAX__ == __INT_MAX__\n# define UCHAR_MAX (SCHAR_MAX * 2U + 1U)\n#else\n# define UCHAR_MAX (SCHAR_MAX * 2 + 1)\n#endif\n\n/* Minimum and maximum values a `char' can hold.  */\n#ifdef __CHAR_UNSIGNED__\n# undef CHAR_MIN\n# if __SCHAR_MAX__ == __INT_MAX__\n#  define CHAR_MIN 0U\n# else\n#  define CHAR_MIN 0\n# endif\n# undef CHAR_MAX\n# define CHAR_MAX UCHAR_MAX\n#else\n# undef CHAR_MIN\n# define CHAR_MIN SCHAR_MIN\n# undef CHAR_MAX\n# define CHAR_MAX SCHAR_MAX\n#endif\n\n/* Minimum and maximum values a `signed short int' can hold.  */\n#undef SHRT_MIN\n#define SHRT_MIN (-SHRT_MAX - 1)\n#undef SHRT_MAX\n#define SHRT_MAX __SHRT_MAX__\n\n/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */\n#undef USHRT_MAX\n#if __SHRT_MAX__ == __INT_MAX__\n# define USHRT_MAX (SHRT_MAX * 2U + 1U)\n#else\n# define USHRT_MAX (SHRT_MAX * 2 + 1)\n#endif\n\n/* Minimum and maximum values a `signed int' can hold.  */\n#undef INT_MIN\n#define INT_MIN (-INT_MAX - 1)\n#undef INT_MAX\n#define INT_MAX __INT_MAX__\n\n/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */\n#undef UINT_MAX\n#define UINT_MAX (INT_MAX * 2U + 1U)\n\n/* Minimum and maximum values a `signed long int' can hold.\n   (Same as `int').  */\n#undef LONG_MIN\n#define LONG_MIN (-LONG_MAX - 1L)\n#undef LONG_MAX\n#define LONG_MAX __LONG_MAX__\n\n/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */\n#undef ULONG_MAX\n#define ULONG_MAX (LONG_MAX * 2UL + 1UL)\n\n#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n/* Minimum and maximum values a `signed long long int' can hold.  */\n# undef LLONG_MIN\n# define LLONG_MIN (-LLONG_MAX - 1LL)\n# undef LLONG_MAX\n# define LLONG_MAX __LONG_LONG_MAX__\n\n/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */\n# undef ULLONG_MAX\n# define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)\n#endif\n\n#if defined (__GNU_LIBRARY__) ? defined (__USE_GNU) : !defined (__STRICT_ANSI__)\n/* Minimum and maximum values a `signed long long int' can hold.  */\n# undef LONG_LONG_MIN\n# define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)\n# undef LONG_LONG_MAX\n# define LONG_LONG_MAX __LONG_LONG_MAX__\n\n/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */\n# undef ULONG_LONG_MAX\n# define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)\n#endif\n\n#endif /* _LIMITS_H___ */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GRAPH": {"ttr": 3853, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for graph routines.\n   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_GRAPH_H\n#define GCC_GRAPH_H\n\nextern void print_rtl_graph_with_bb (const char *, const char *, rtx);\nextern void clean_graph_dump_file (const char *, const char *);\nextern void finish_graph_dump_file (const char *, const char *);\n\n#endif /* ! GCC_GRAPH_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GSTAB": {"ttr": 3855, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_GSTAB_H\n#define GCC_GSTAB_H\n\n#define __define_stab(NAME, CODE, STRING) NAME=CODE,\n\nenum __stab_debug_code\n{\n#include \"stab.def\"\nLAST_UNUSED_STAB_CODE\n};\n\n#undef __define_stab\n\n#endif /* ! GCC_GSTAB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GSYMS": {"ttr": 3857, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* For cross compilation, use the portable definitions from the COFF\n   documentation.  */\n\n#define __GNU_SYMS__\n\nenum sdb_storage_class\n{\n  C_EFCN = -1,\n  C_NULL = 0,\n  C_AUTO = 1,\n  C_EXT = 2,\n  C_STAT = 3,\n  C_REG = 4,\n  C_EXTDEF = 5,\n  C_LABEL = 6,\n  C_ULABEL = 7,\n  C_MOS = 8,\n  C_ARG = 9,\n  C_STRTAG = 10,\n  C_MOU = 11,\n  C_UNTAG = 12,\n  C_TPDEF = 13,\n  C_USTATIC = 14,\n  C_ENTAG = 15,\n  C_MOE = 16,\n  C_REGPARM = 17,\n  C_FIELD = 18,\n\n  C_BLOCK = 100,\n  C_FCN = 101,\n  C_EOS = 102,\n  C_FILE = 103,\n  C_LINE = 104,\n  C_ALIAS = 105,\n  C_HIDDEN = 106\n};\n\nenum sdb_type\n{\n  T_NULL = 0,\n  T_ARG = 1,\n  T_VOID = 1,\n  T_CHAR = 2,\n  T_SHORT = 3,\n  T_INT = 4,\n  T_LONG = 5,\n  T_FLOAT = 6,\n  T_DOUBLE = 7,\n  T_STRUCT = 8,\n  T_UNION = 9,\n  T_ENUM = 10,\n  T_MOE = 11,\n  T_UCHAR = 12,\n  T_USHORT = 13,\n  T_UINT = 14,\n  T_ULONG = 15\n#ifdef EXTENDED_SDB_BASIC_TYPES\n  , T_LNGDBL = 16\n#endif\n};\n\nenum sdb_type_class\n{\n  DT_NON = 0,\n  DT_PTR = 1,\n  DT_FCN = 2,\n  DT_ARY = 3\n};\n\nenum sdb_masks\n{\n#ifdef EXTENDED_SDB_BASIC_TYPES\n  N_BTMASK = 0x1f,\n  N_TMASK = 0x60,\n  N_TMASK1 = 0x300,\n  N_TMASK2 = 0x360,\n  N_BTSHFT = 5,\n#else\n  N_BTMASK = 017,\n  N_TMASK = 060,\n  N_TMASK1 = 0300,\n  N_TMASK2 = 0360,\n  N_BTSHFT = 4,\n#endif\n  N_TSHIFT = 2\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GSYSLIMI": {"ttr": 3859, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* syslimits.h stands for the system's own limits.h file.\n   If we can use it ok unmodified, then we install this text.\n   If fixincludes fixes it, then the fixed version is installed\n   instead of this text.  */\n\n#define _GCC_NEXT_LIMITS_H\t\t/* tell gcc's limits.h to recurse */\n#include_next <limits.h>\n#undef _GCC_NEXT_LIMITS_H\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@ALIAS": {"ttr": 3861, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for alias.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_alias_set_entry (void *x_p)\n{\n  struct alias_set_entry * const x = (struct alias_set_entry *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_II12splay_tree_s ((*x).children);\n    }\n}\n\nvoid\ngt_ggc_m_P15alias_set_entry15varray_head_tag (void *x_p)\n{\n  struct varray_head_tag * const x = (struct varray_head_tag *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      switch ((*x).type)\n        {\n        case VARRAY_DATA_C:\n          break;\n        case VARRAY_DATA_UC:\n          break;\n        case VARRAY_DATA_S:\n          break;\n        case VARRAY_DATA_US:\n          break;\n        case VARRAY_DATA_I:\n          break;\n        case VARRAY_DATA_U:\n          break;\n        case VARRAY_DATA_L:\n          break;\n        case VARRAY_DATA_UL:\n          break;\n        case VARRAY_DATA_HINT:\n          break;\n        case VARRAY_DATA_UHINT:\n          break;\n        case VARRAY_DATA_GENERIC:\n          {\n            size_t i10;\n            for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n              gt_ggc_m_15alias_set_entry ((*x).data.generic\u00ddi10\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CPTR:\n          {\n            size_t i11;\n            for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n            }\n          }\n          break;\n        case VARRAY_DATA_RTX:\n          {\n            size_t i12;\n            for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n              gt_ggc_m_7rtx_def ((*x).data.rtx\u00ddi12\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTVEC:\n          {\n            size_t i13;\n            for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n              gt_ggc_m_9rtvec_def ((*x).data.rtvec\u00ddi13\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_TREE:\n          {\n            size_t i14;\n            for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n              gt_ggc_m_9tree_node ((*x).data.tree\u00ddi14\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_BITMAP:\n          {\n            size_t i15;\n            for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n              gt_ggc_m_15bitmap_head_def ((*x).data.bitmap\u00ddi15\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CONST_EQUIV:\n          {\n            size_t i16;\n            for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n              gt_ggc_m_7rtx_def ((*x).data.const_equiv\u00ddi16\u00a8.rtx);\n            }\n          }\n          break;\n        case VARRAY_DATA_TE:\n          {\n            size_t i17;\n            for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n              gt_ggc_m_8elt_list ((*x).data.te\u00ddi17\u00a8);\n            }\n          }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_alias_set_entry (void *x_p)\n{\n  struct alias_set_entry * const x = (struct alias_set_entry *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_15alias_set_entry))\n    {\n      gt_pch_n_II12splay_tree_s ((*x).children);\n    }\n}\n\nvoid\ngt_pch_n_P15alias_set_entry15varray_head_tag (void *x_p)\n{\n  struct varray_head_tag * const x = (struct varray_head_tag *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P15alias_set_entry15varray_head_tag))\n    {\n      gt_pch_n_S ((*x).name);\n      switch ((*x).type)\n        {\n        case VARRAY_DATA_C:\n          break;\n        case VARRAY_DATA_UC:\n          break;\n        case VARRAY_DATA_S:\n          break;\n        case VARRAY_DATA_US:\n          break;\n        case VARRAY_DATA_I:\n          break;\n        case VARRAY_DATA_U:\n          break;\n        case VARRAY_DATA_L:\n          break;\n        case VARRAY_DATA_UL:\n          break;\n        case VARRAY_DATA_HINT:\n          break;\n        case VARRAY_DATA_UHINT:\n          break;\n        case VARRAY_DATA_GENERIC:\n          {\n            size_t i10;\n            for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n              gt_pch_n_15alias_set_entry ((*x).data.generic\u00ddi10\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CPTR:\n          {\n            size_t i11;\n            for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n              gt_pch_n_S ((*x).data.cptr\u00ddi11\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTX:\n          {\n            size_t i12;\n            for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n              gt_pch_n_7rtx_def ((*x).data.rtx\u00ddi12\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTVEC:\n          {\n            size_t i13;\n            for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n              gt_pch_n_9rtvec_def ((*x).data.rtvec\u00ddi13\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_TREE:\n          {\n            size_t i14;\n            for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n              gt_pch_n_9tree_node ((*x).data.tree\u00ddi14\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_BITMAP:\n          {\n            size_t i15;\n            for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n              gt_pch_n_15bitmap_head_def ((*x).data.bitmap\u00ddi15\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CONST_EQUIV:\n          {\n            size_t i16;\n            for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n              gt_pch_n_7rtx_def ((*x).data.const_equiv\u00ddi16\u00a8.rtx);\n            }\n          }\n          break;\n        case VARRAY_DATA_TE:\n          {\n            size_t i17;\n            for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n              gt_pch_n_8elt_list ((*x).data.te\u00ddi17\u00a8);\n            }\n          }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_p_15alias_set_entry (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct alias_set_entry * const x ATTRIBUTE_UNUSED = (struct alias_set_entry *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).children), cookie);\n}\n\nvoid\ngt_pch_p_P15alias_set_entry15varray_head_tag (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct varray_head_tag * const x ATTRIBUTE_UNUSED = (struct varray_head_tag *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).name), cookie);\n  switch ((*x).type)\n    {\n    case VARRAY_DATA_C:\n      break;\n    case VARRAY_DATA_UC:\n      break;\n    case VARRAY_DATA_S:\n      break;\n    case VARRAY_DATA_US:\n      break;\n    case VARRAY_DATA_I:\n      break;\n    case VARRAY_DATA_U:\n      break;\n    case VARRAY_DATA_L:\n      break;\n    case VARRAY_DATA_UL:\n      break;\n    case VARRAY_DATA_HINT:\n      break;\n    case VARRAY_DATA_UHINT:\n      break;\n    case VARRAY_DATA_GENERIC:\n      {\n        size_t i10;\n        for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.generic\u00ddi10\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_CPTR:\n      {\n        size_t i11;\n        for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.cptr\u00ddi11\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_RTX:\n      {\n        size_t i12;\n        for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.rtx\u00ddi12\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_RTVEC:\n      {\n        size_t i13;\n        for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.rtvec\u00ddi13\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_TREE:\n      {\n        size_t i14;\n        for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.tree\u00ddi14\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_BITMAP:\n      {\n        size_t i15;\n        for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.bitmap\u00ddi15\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_CONST_EQUIV:\n      {\n        size_t i16;\n        for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.const_equiv\u00ddi16\u00a8.rtx), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_TE:\n      {\n        size_t i17;\n        for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.te\u00ddi17\u00a8), cookie);\n        }\n      }\n      break;\n    default:\n      break;\n    }\n}\n\n/* GC roots.  */\n\nstatic void gt_ggc_ma_reg_known_value (void *);\nstatic void\ngt_ggc_ma_reg_known_value (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (reg_known_value != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(reg_known_value_size); i0++) {\n      gt_ggc_m_7rtx_def (reg_known_value\u00ddi0\u00a8);\n    }\n    ggc_mark (reg_known_value);\n  }\n}\n\nstatic void gt_pch_pa_reg_known_value\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_reg_known_value (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (reg_known_value != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(reg_known_value_size); i0++) {\n      if ((void *)(reg_known_value) == this_obj)\n        op (&(reg_known_value\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&reg_known_value) == this_obj)\n      op (&(reg_known_value), cookie);\n  }\n}\n\nstatic void gt_pch_na_reg_known_value (void *);\nstatic void\ngt_pch_na_reg_known_value (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (reg_known_value != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(reg_known_value_size); i1++) {\n      gt_pch_n_7rtx_def (reg_known_value\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (reg_known_value, &reg_known_value, gt_pch_pa_reg_known_value);\n  }\n}\n\nstatic void gt_ggc_ma_alias_invariant (void *);\nstatic void\ngt_ggc_ma_alias_invariant (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (alias_invariant != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(alias_invariant_size); i0++) {\n      gt_ggc_m_7rtx_def (alias_invariant\u00ddi0\u00a8);\n    }\n    ggc_mark (alias_invariant);\n  }\n}\n\nstatic void gt_pch_pa_alias_invariant\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_alias_invariant (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (alias_invariant != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(alias_invariant_size); i0++) {\n      if ((void *)(alias_invariant) == this_obj)\n        op (&(alias_invariant\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&alias_invariant) == this_obj)\n      op (&(alias_invariant), cookie);\n  }\n}\n\nstatic void gt_pch_na_alias_invariant (void *);\nstatic void\ngt_pch_na_alias_invariant (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (alias_invariant != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(alias_invariant_size); i1++) {\n      gt_pch_n_7rtx_def (alias_invariant\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (alias_invariant, &alias_invariant, gt_pch_pa_alias_invariant);\n  }\n}\n\nconst struct ggc_root_tab gt_ggc_r_gt_alias_h\u00dd\u00a8 = {\n  {\n    &alias_sets,\n    1,\n    sizeof (alias_sets),\n    &gt_ggc_m_P15alias_set_entry15varray_head_tag,\n    &gt_pch_n_P15alias_set_entry15varray_head_tag\n  },\n  {\n    &reg_known_value,\n    1,\n    sizeof (reg_known_value),\n    &gt_ggc_ma_reg_known_value,\n    &gt_pch_na_reg_known_value\n  },\n  {\n    &alias_invariant,\n    1,\n    sizeof (alias_invariant),\n    &gt_ggc_ma_alias_invariant,\n    &gt_pch_na_alias_invariant\n  },\n  {\n    &static_reg_base_value\u00dd0\u00a8,\n    1 * (FIRST_PSEUDO_REGISTER),\n    sizeof (static_reg_base_value\u00dd0\u00a8),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  {\n    &reg_base_value,\n    1,\n    sizeof (reg_base_value),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_ggc_rd_gt_alias_h\u00dd\u00a8 = {\n  { &old_reg_base_value, 1, sizeof (old_reg_base_value), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_alias_h\u00dd\u00a8 = {\n  { &frame_set, 1, sizeof (frame_set), NULL, NULL },\n  { &varargs_set, 1, sizeof (varargs_set), NULL, NULL },\n  { &last_alias_set, 1, sizeof (last_alias_set), NULL, NULL },\n  { &reg_known_value_size, 1, sizeof (reg_known_value_size), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@BITMA": {"ttr": 4100, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for bitmap.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_rd_gt_bitmap_h\u00dd\u00a8 = {\n  { &bitmap_ggc_free, 1, sizeof (bitmap_ggc_free), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@C@COM": {"ttr": 4102, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for c-common.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_sorted_fields_type (void *x_p)\n{\n  struct sorted_fields_type * const x = (struct sorted_fields_type *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).len); i0++) {\n          gt_ggc_m_9tree_node ((*x).elts\u00ddi0\u00a8);\n        }\n      }\n    }\n}\n\nvoid\ngt_pch_nx_sorted_fields_type (void *x_p)\n{\n  struct sorted_fields_type * const x = (struct sorted_fields_type *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_18sorted_fields_type))\n    {\n      {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).len); i0++) {\n          gt_pch_n_9tree_node ((*x).elts\u00ddi0\u00a8);\n        }\n      }\n    }\n}\n\nvoid\ngt_pch_p_18sorted_fields_type (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct sorted_fields_type * const x ATTRIBUTE_UNUSED = (struct sorted_fields_type *)x_p;\n  {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).len); i0++) {\n      if ((void *)(x) == this_obj)\n        op (&((*x).elts\u00ddi0\u00a8), cookie);\n    }\n  }\n}\n\n/* GC roots.  */\n\nstatic void gt_ggc_ma_ridpointers (void *);\nstatic void\ngt_ggc_ma_ridpointers (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (ridpointers != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)((int)RID_MAX); i0++) {\n      gt_ggc_m_9tree_node (ridpointers\u00ddi0\u00a8);\n    }\n    ggc_mark (ridpointers);\n  }\n}\n\nstatic void gt_pch_pa_ridpointers\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_ridpointers (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (ridpointers != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)((int)RID_MAX); i0++) {\n      if ((void *)(ridpointers) == this_obj)\n        op (&(ridpointers\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&ridpointers) == this_obj)\n      op (&(ridpointers), cookie);\n  }\n}\n\nstatic void gt_pch_na_ridpointers (void *);\nstatic void\ngt_pch_na_ridpointers (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (ridpointers != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)((int)RID_MAX); i1++) {\n      gt_pch_n_9tree_node (ridpointers\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (ridpointers, &ridpointers, gt_pch_pa_ridpointers);\n  }\n}\n\nconst struct ggc_root_tab gt_ggc_r_gt_c_common_h\u00dd\u00a8 = {\n  {\n    &vector_type_node_list,\n    1,\n    sizeof (vector_type_node_list),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &built_in_attributes\u00dd0\u00a8,\n    1 * ((int) ATTR_LAST),\n    sizeof (built_in_attributes\u00dd0\u00a8),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &registered_builtin_types,\n    1,\n    sizeof (registered_builtin_types),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &c_global_trees\u00dd0\u00a8,\n    1 * (CTI_MAX),\n    sizeof (c_global_trees\u00dd0\u00a8),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &ridpointers,\n    1,\n    sizeof (ridpointers),\n    &gt_ggc_ma_ridpointers,\n    &gt_pch_na_ridpointers\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@C@DEC": {"ttr": 4104, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for c-decl.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_c_scope (void *x_p)\n{\n  struct c_scope * const x = (struct c_scope *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_7c_scope ((*x).outer);\n      gt_ggc_m_7c_scope ((*x).outer_function);\n      gt_ggc_m_9tree_node ((*x).names);\n      gt_ggc_m_9tree_node ((*x).names_last);\n      gt_ggc_m_9tree_node ((*x).parms);\n      gt_ggc_m_9tree_node ((*x).parms_last);\n      gt_ggc_m_9tree_node ((*x).tags);\n      gt_ggc_m_9tree_node ((*x).shadowed);\n      gt_ggc_m_9tree_node ((*x).shadowed_tags);\n      gt_ggc_m_9tree_node ((*x).blocks);\n      gt_ggc_m_9tree_node ((*x).blocks_last);\n    }\n}\n\nvoid\ngt_ggc_mx_lang_tree_node (void *x_p)\n{\n  union lang_tree_node * x = (union lang_tree_node *)x_p;\n  union lang_tree_node * xlimit = x;\n  while (ggc_test_and_set_mark (xlimit))\n   xlimit = (TREE_CODE (&(*xlimit).generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&(*xlimit).generic) : (union lang_tree_node *)TREE_CHAIN (&(*xlimit).generic));\n  while (x != xlimit)\n    {\n      switch (TREE_CODE (&((*x)).generic) == IDENTIFIER_NODE)\n        {\n        case 0:\n          switch (tree_node_structure (&((*x).generic)))\n            {\n            case TS_COMMON:\n              gt_ggc_m_9tree_node ((*x).generic.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.common.type);\n              break;\n            case TS_INT_CST:\n              gt_ggc_m_9tree_node ((*x).generic.int_cst.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.int_cst.common.type);\n              break;\n            case TS_REAL_CST:\n              gt_ggc_m_9tree_node ((*x).generic.real_cst.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.real_cst.common.type);\n              gt_ggc_m_10real_value ((*x).generic.real_cst.real_cst_ptr);\n              break;\n            case TS_VECTOR:\n              gt_ggc_m_9tree_node ((*x).generic.vector.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.vector.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.vector.elements);\n              break;\n            case TS_STRING:\n              gt_ggc_m_9tree_node ((*x).generic.string.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.string.common.type);\n              break;\n            case TS_COMPLEX:\n              gt_ggc_m_9tree_node ((*x).generic.complex.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.complex.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.complex.real);\n              gt_ggc_m_9tree_node ((*x).generic.complex.imag);\n              break;\n            case TS_IDENTIFIER:\n              gt_ggc_m_9tree_node ((*x).generic.identifier.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.identifier.common.type);\n              break;\n            case TS_DECL:\n              gt_ggc_m_9tree_node ((*x).generic.decl.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.decl.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.decl.size);\n              gt_ggc_m_9tree_node ((*x).generic.decl.size_unit);\n              gt_ggc_m_9tree_node ((*x).generic.decl.name);\n              gt_ggc_m_9tree_node ((*x).generic.decl.context);\n              gt_ggc_m_9tree_node ((*x).generic.decl.arguments);\n              gt_ggc_m_9tree_node ((*x).generic.decl.result);\n              gt_ggc_m_9tree_node ((*x).generic.decl.initial);\n              gt_ggc_m_9tree_node ((*x).generic.decl.abstract_origin);\n              gt_ggc_m_9tree_node ((*x).generic.decl.assembler_name);\n              gt_ggc_m_9tree_node ((*x).generic.decl.section_name);\n              gt_ggc_m_9tree_node ((*x).generic.decl.attributes);\n              gt_ggc_m_7rtx_def ((*x).generic.decl.rtl);\n              switch (TREE_CODE((tree) &((*x))))\n                {\n                case FUNCTION_DECL:\n                  gt_ggc_m_8function ((*x).generic.decl.u2.f);\n                  break;\n                case PARM_DECL:\n                  gt_ggc_m_7rtx_def ((*x).generic.decl.u2.r);\n                  break;\n                case FIELD_DECL:\n                  gt_ggc_m_9tree_node ((*x).generic.decl.u2.t);\n                  break;\n                case VAR_DECL:\n                  break;\n                default:\n                  break;\n                }\n              gt_ggc_m_9tree_node ((*x).generic.decl.saved_tree);\n              gt_ggc_m_9tree_node ((*x).generic.decl.inlined_fns);\n              gt_ggc_m_9tree_node ((*x).generic.decl.vindex);\n              gt_ggc_m_9lang_decl ((*x).generic.decl.lang_specific);\n              break;\n            case TS_TYPE:\n              gt_ggc_m_9tree_node ((*x).generic.type.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.type.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.type.values);\n              gt_ggc_m_9tree_node ((*x).generic.type.size);\n              gt_ggc_m_9tree_node ((*x).generic.type.size_unit);\n              gt_ggc_m_9tree_node ((*x).generic.type.attributes);\n              gt_ggc_m_9tree_node ((*x).generic.type.pointer_to);\n              gt_ggc_m_9tree_node ((*x).generic.type.reference_to);\n              switch (debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0)\n                {\n                case 0:\n                  break;\n                case 1:\n                  break;\n                case 2:\n                  gt_ggc_m_10die_struct ((*x).generic.type.symtab.die);\n                  break;\n                default:\n                  break;\n                }\n              gt_ggc_m_9tree_node ((*x).generic.type.name);\n              gt_ggc_m_9tree_node ((*x).generic.type.minval);\n              gt_ggc_m_9tree_node ((*x).generic.type.maxval);\n              gt_ggc_m_9tree_node ((*x).generic.type.next_variant);\n              gt_ggc_m_9tree_node ((*x).generic.type.main_variant);\n              gt_ggc_m_9tree_node ((*x).generic.type.binfo);\n              gt_ggc_m_9tree_node ((*x).generic.type.context);\n              gt_ggc_m_9lang_type ((*x).generic.type.lang_specific);\n              break;\n            case TS_LIST:\n              gt_ggc_m_9tree_node ((*x).generic.list.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.list.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.list.purpose);\n              gt_ggc_m_9tree_node ((*x).generic.list.value);\n              break;\n            case TS_VEC:\n              gt_ggc_m_9tree_node ((*x).generic.vec.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.vec.common.type);\n              {\n                size_t i0;\n                for (i0 = 0; i0 < (size_t)(TREE_VEC_LENGTH ((tree)&((*x).generic.vec))); i0++) {\n                  gt_ggc_m_9tree_node ((*x).generic.vec.a\u00ddi0\u00a8);\n                }\n              }\n              break;\n            case TS_EXP:\n              gt_ggc_m_9tree_node ((*x).generic.exp.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.exp.common.type);\n              switch (TREE_CODE ((tree) &(*x)))\n                {\n                case WITH_CLEANUP_EXPR:\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd2\u00a8);\n                  gt_ggc_m_9tree_node ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_ggc_m_9tree_node ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case RTL_EXPR:\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case GOTO_SUBROUTINE_EXPR:\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case SAVE_EXPR:\n                  gt_ggc_m_7rtx_def ((*x).generic.exp.operands\u00dd2\u00a8);\n                  gt_ggc_m_9tree_node ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_ggc_m_9tree_node ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                default:\n                  {\n                    size_t i1;\n                    for (i1 = 0; i1 < (size_t)(TREE_CODE_LENGTH (TREE_CODE ((tree) &(*x)))); i1++) {\n                      gt_ggc_m_9tree_node ((*x).generic.exp.operands\u00ddi1\u00a8);\n                    }\n                  }\n                  break;\n                }\n              break;\n            case TS_BLOCK:\n              gt_ggc_m_9tree_node ((*x).generic.block.common.chain);\n              gt_ggc_m_9tree_node ((*x).generic.block.common.type);\n              gt_ggc_m_9tree_node ((*x).generic.block.vars);\n              gt_ggc_m_9tree_node ((*x).generic.block.subblocks);\n              gt_ggc_m_9tree_node ((*x).generic.block.supercontext);\n              gt_ggc_m_9tree_node ((*x).generic.block.abstract_origin);\n              gt_ggc_m_9tree_node ((*x).generic.block.fragment_origin);\n              gt_ggc_m_9tree_node ((*x).generic.block.fragment_chain);\n              break;\n            default:\n              break;\n            }\n          break;\n        case 1:\n          gt_ggc_m_9tree_node ((*x).identifier.common_id.common.chain);\n          gt_ggc_m_9tree_node ((*x).identifier.common_id.common.type);\n          switch (0)\n            {\n            case 1:\n              break;\n            case 0:\n              break;\n            default:\n              break;\n            }\n          gt_ggc_m_9tree_node ((*x).identifier.symbol_value);\n          gt_ggc_m_9tree_node ((*x).identifier.tag_value);\n          gt_ggc_m_9tree_node ((*x).identifier.label_value);\n          break;\n        default:\n          break;\n        }\n      x = (TREE_CODE (&(*x).generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&(*x).generic) : (union lang_tree_node *)TREE_CHAIN (&(*x).generic));\n    }\n}\n\nvoid\ngt_ggc_mx_lang_decl (void *x_p)\n{\n  struct lang_decl * const x = (struct lang_decl *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9tree_node ((*x).pending_sizes);\n    }\n}\n\nvoid\ngt_ggc_mx_lang_type (void *x_p)\n{\n  struct lang_type * const x = (struct lang_type *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_18sorted_fields_type ((*x).s);\n    }\n}\n\nvoid\ngt_ggc_mx_language_function (void *x_p)\n{\n  struct language_function * const x = (struct language_function *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9tree_node ((*x).base.x_stmt_tree.x_last_stmt);\n      gt_ggc_m_9tree_node ((*x).base.x_stmt_tree.x_last_expr_type);\n      gt_ggc_m_9tree_node ((*x).base.x_scope_stmt_stack);\n    }\n}\n\nvoid\ngt_pch_nx_c_scope (void *x_p)\n{\n  struct c_scope * const x = (struct c_scope *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_7c_scope))\n    {\n      gt_pch_n_7c_scope ((*x).outer);\n      gt_pch_n_7c_scope ((*x).outer_function);\n      gt_pch_n_9tree_node ((*x).names);\n      gt_pch_n_9tree_node ((*x).names_last);\n      gt_pch_n_9tree_node ((*x).parms);\n      gt_pch_n_9tree_node ((*x).parms_last);\n      gt_pch_n_9tree_node ((*x).tags);\n      gt_pch_n_9tree_node ((*x).shadowed);\n      gt_pch_n_9tree_node ((*x).shadowed_tags);\n      gt_pch_n_9tree_node ((*x).blocks);\n      gt_pch_n_9tree_node ((*x).blocks_last);\n    }\n}\n\nvoid\ngt_pch_nx_lang_tree_node (void *x_p)\n{\n  union lang_tree_node * x = (union lang_tree_node *)x_p;\n  union lang_tree_node * xlimit = x;\n  while (gt_pch_note_object (xlimit, xlimit, gt_pch_p_14lang_tree_node))\n   xlimit = (TREE_CODE (&(*xlimit).generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&(*xlimit).generic) : (union lang_tree_node *)TREE_CHAIN (&(*xlimit).generic));\n  while (x != xlimit)\n    {\n      switch (TREE_CODE (&((*x)).generic) == IDENTIFIER_NODE)\n        {\n        case 0:\n          switch (tree_node_structure (&((*x).generic)))\n            {\n            case TS_COMMON:\n              gt_pch_n_9tree_node ((*x).generic.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.common.type);\n              break;\n            case TS_INT_CST:\n              gt_pch_n_9tree_node ((*x).generic.int_cst.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.int_cst.common.type);\n              break;\n            case TS_REAL_CST:\n              gt_pch_n_9tree_node ((*x).generic.real_cst.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.real_cst.common.type);\n              gt_pch_n_10real_value ((*x).generic.real_cst.real_cst_ptr);\n              break;\n            case TS_VECTOR:\n              gt_pch_n_9tree_node ((*x).generic.vector.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.vector.common.type);\n              gt_pch_n_9tree_node ((*x).generic.vector.elements);\n              break;\n            case TS_STRING:\n              gt_pch_n_9tree_node ((*x).generic.string.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.string.common.type);\n              gt_pch_n_S ((*x).generic.string.pointer);\n              break;\n            case TS_COMPLEX:\n              gt_pch_n_9tree_node ((*x).generic.complex.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.complex.common.type);\n              gt_pch_n_9tree_node ((*x).generic.complex.real);\n              gt_pch_n_9tree_node ((*x).generic.complex.imag);\n              break;\n            case TS_IDENTIFIER:\n              gt_pch_n_9tree_node ((*x).generic.identifier.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.identifier.common.type);\n              gt_pch_n_S ((*x).generic.identifier.id.str);\n              break;\n            case TS_DECL:\n              gt_pch_n_9tree_node ((*x).generic.decl.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.decl.common.type);\n              gt_pch_n_S ((*x).generic.decl.locus.file);\n              gt_pch_n_9tree_node ((*x).generic.decl.size);\n              gt_pch_n_9tree_node ((*x).generic.decl.size_unit);\n              gt_pch_n_9tree_node ((*x).generic.decl.name);\n              gt_pch_n_9tree_node ((*x).generic.decl.context);\n              gt_pch_n_9tree_node ((*x).generic.decl.arguments);\n              gt_pch_n_9tree_node ((*x).generic.decl.result);\n              gt_pch_n_9tree_node ((*x).generic.decl.initial);\n              gt_pch_n_9tree_node ((*x).generic.decl.abstract_origin);\n              gt_pch_n_9tree_node ((*x).generic.decl.assembler_name);\n              gt_pch_n_9tree_node ((*x).generic.decl.section_name);\n              gt_pch_n_9tree_node ((*x).generic.decl.attributes);\n              gt_pch_n_7rtx_def ((*x).generic.decl.rtl);\n              switch (TREE_CODE((tree) &((*x))))\n                {\n                case FUNCTION_DECL:\n                  gt_pch_n_8function ((*x).generic.decl.u2.f);\n                  break;\n                case PARM_DECL:\n                  gt_pch_n_7rtx_def ((*x).generic.decl.u2.r);\n                  break;\n                case FIELD_DECL:\n                  gt_pch_n_9tree_node ((*x).generic.decl.u2.t);\n                  break;\n                case VAR_DECL:\n                  break;\n                default:\n                  break;\n                }\n              gt_pch_n_9tree_node ((*x).generic.decl.saved_tree);\n              gt_pch_n_9tree_node ((*x).generic.decl.inlined_fns);\n              gt_pch_n_9tree_node ((*x).generic.decl.vindex);\n              gt_pch_n_9lang_decl ((*x).generic.decl.lang_specific);\n              break;\n            case TS_TYPE:\n              gt_pch_n_9tree_node ((*x).generic.type.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.type.common.type);\n              gt_pch_n_9tree_node ((*x).generic.type.values);\n              gt_pch_n_9tree_node ((*x).generic.type.size);\n              gt_pch_n_9tree_node ((*x).generic.type.size_unit);\n              gt_pch_n_9tree_node ((*x).generic.type.attributes);\n              gt_pch_n_9tree_node ((*x).generic.type.pointer_to);\n              gt_pch_n_9tree_node ((*x).generic.type.reference_to);\n              switch (debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0)\n                {\n                case 0:\n                  break;\n                case 1:\n                  gt_pch_n_S ((*x).generic.type.symtab.pointer);\n                  break;\n                case 2:\n                  gt_pch_n_10die_struct ((*x).generic.type.symtab.die);\n                  break;\n                default:\n                  break;\n                }\n              gt_pch_n_9tree_node ((*x).generic.type.name);\n              gt_pch_n_9tree_node ((*x).generic.type.minval);\n              gt_pch_n_9tree_node ((*x).generic.type.maxval);\n              gt_pch_n_9tree_node ((*x).generic.type.next_variant);\n              gt_pch_n_9tree_node ((*x).generic.type.main_variant);\n              gt_pch_n_9tree_node ((*x).generic.type.binfo);\n              gt_pch_n_9tree_node ((*x).generic.type.context);\n              gt_pch_n_9lang_type ((*x).generic.type.lang_specific);\n              break;\n            case TS_LIST:\n              gt_pch_n_9tree_node ((*x).generic.list.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.list.common.type);\n              gt_pch_n_9tree_node ((*x).generic.list.purpose);\n              gt_pch_n_9tree_node ((*x).generic.list.value);\n              break;\n            case TS_VEC:\n              gt_pch_n_9tree_node ((*x).generic.vec.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.vec.common.type);\n              {\n                size_t i0;\n                for (i0 = 0; i0 < (size_t)(TREE_VEC_LENGTH ((tree)&((*x).generic.vec))); i0++) {\n                  gt_pch_n_9tree_node ((*x).generic.vec.a\u00ddi0\u00a8);\n                }\n              }\n              break;\n            case TS_EXP:\n              gt_pch_n_9tree_node ((*x).generic.exp.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.exp.common.type);\n              switch (TREE_CODE ((tree) &(*x)))\n                {\n                case WITH_CLEANUP_EXPR:\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd2\u00a8);\n                  gt_pch_n_9tree_node ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_pch_n_9tree_node ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case RTL_EXPR:\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case GOTO_SUBROUTINE_EXPR:\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                case SAVE_EXPR:\n                  gt_pch_n_7rtx_def ((*x).generic.exp.operands\u00dd2\u00a8);\n                  gt_pch_n_9tree_node ((*x).generic.exp.operands\u00dd1\u00a8);\n                  gt_pch_n_9tree_node ((*x).generic.exp.operands\u00dd0\u00a8);\n                  break;\n                default:\n                  {\n                    size_t i1;\n                    for (i1 = 0; i1 < (size_t)(TREE_CODE_LENGTH (TREE_CODE ((tree) &(*x)))); i1++) {\n                      gt_pch_n_9tree_node ((*x).generic.exp.operands\u00ddi1\u00a8);\n                    }\n                  }\n                  break;\n                }\n              break;\n            case TS_BLOCK:\n              gt_pch_n_9tree_node ((*x).generic.block.common.chain);\n              gt_pch_n_9tree_node ((*x).generic.block.common.type);\n              gt_pch_n_9tree_node ((*x).generic.block.vars);\n              gt_pch_n_9tree_node ((*x).generic.block.subblocks);\n              gt_pch_n_9tree_node ((*x).generic.block.supercontext);\n              gt_pch_n_9tree_node ((*x).generic.block.abstract_origin);\n              gt_pch_n_9tree_node ((*x).generic.block.fragment_origin);\n              gt_pch_n_9tree_node ((*x).generic.block.fragment_chain);\n              break;\n            default:\n              break;\n            }\n          break;\n        case 1:\n          gt_pch_n_9tree_node ((*x).identifier.common_id.common.chain);\n          gt_pch_n_9tree_node ((*x).identifier.common_id.common.type);\n          gt_pch_n_S ((*x).identifier.common_id.node.ident.str);\n          switch (0)\n            {\n            case 1:\n              break;\n            case 0:\n              break;\n            default:\n              break;\n            }\n          gt_pch_n_9tree_node ((*x).identifier.symbol_value);\n          gt_pch_n_9tree_node ((*x).identifier.tag_value);\n          gt_pch_n_9tree_node ((*x).identifier.label_value);\n          break;\n        default:\n          break;\n        }\n      x = (TREE_CODE (&(*x).generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&(*x).generic) : (union lang_tree_node *)TREE_CHAIN (&(*x).generic));\n    }\n}\n\nvoid\ngt_pch_nx_lang_decl (void *x_p)\n{\n  struct lang_decl * const x = (struct lang_decl *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9lang_decl))\n    {\n      gt_pch_n_9tree_node ((*x).pending_sizes);\n    }\n}\n\nvoid\ngt_pch_nx_lang_type (void *x_p)\n{\n  struct lang_type * const x = (struct lang_type *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9lang_type))\n    {\n      gt_pch_n_18sorted_fields_type ((*x).s);\n      gt_pch_note_reorder ((*x).s, (*x).s, resort_sorted_fields);\n    }\n}\n\nvoid\ngt_pch_nx_language_function (void *x_p)\n{\n  struct language_function * const x = (struct language_function *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_17language_function))\n    {\n      gt_pch_n_9tree_node ((*x).base.x_stmt_tree.x_last_stmt);\n      gt_pch_n_9tree_node ((*x).base.x_stmt_tree.x_last_expr_type);\n      gt_pch_n_S ((*x).base.x_stmt_tree.x_last_expr_filename);\n      gt_pch_n_9tree_node ((*x).base.x_scope_stmt_stack);\n    }\n}\n\nvoid\ngt_pch_p_7c_scope (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct c_scope * const x ATTRIBUTE_UNUSED = (struct c_scope *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).outer), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).outer_function), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).names), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).names_last), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).parms), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).parms_last), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).tags), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).shadowed), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).shadowed_tags), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).blocks), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).blocks_last), cookie);\n}\n\nvoid\ngt_pch_p_14lang_tree_node (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  union lang_tree_node * const x ATTRIBUTE_UNUSED = (union lang_tree_node *)x_p;\n  switch (TREE_CODE (&((*x)).generic) == IDENTIFIER_NODE)\n    {\n    case 0:\n      switch (tree_node_structure (&((*x).generic)))\n        {\n        case TS_COMMON:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.common.type), cookie);\n          break;\n        case TS_INT_CST:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.int_cst.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.int_cst.common.type), cookie);\n          break;\n        case TS_REAL_CST:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.real_cst.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.real_cst.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.real_cst.real_cst_ptr), cookie);\n          break;\n        case TS_VECTOR:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.vector.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.vector.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.vector.elements), cookie);\n          break;\n        case TS_STRING:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.string.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.string.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.string.pointer), cookie);\n          break;\n        case TS_COMPLEX:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.complex.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.complex.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.complex.real), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.complex.imag), cookie);\n          break;\n        case TS_IDENTIFIER:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.identifier.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.identifier.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.identifier.id.str), cookie);\n          break;\n        case TS_DECL:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.locus.file), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.size), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.size_unit), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.name), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.context), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.arguments), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.result), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.initial), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.abstract_origin), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.assembler_name), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.section_name), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.attributes), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.rtl), cookie);\n          switch (TREE_CODE((tree) &((*x))))\n            {\n            case FUNCTION_DECL:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.decl.u2.f), cookie);\n              break;\n            case PARM_DECL:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.decl.u2.r), cookie);\n              break;\n            case FIELD_DECL:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.decl.u2.t), cookie);\n              break;\n            case VAR_DECL:\n              break;\n            default:\n              break;\n            }\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.saved_tree), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.inlined_fns), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.vindex), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.decl.lang_specific), cookie);\n          break;\n        case TS_TYPE:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.values), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.size), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.size_unit), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.attributes), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.pointer_to), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.reference_to), cookie);\n          switch (debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0)\n            {\n            case 0:\n              break;\n            case 1:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.type.symtab.pointer), cookie);\n              break;\n            case 2:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.type.symtab.die), cookie);\n              break;\n            default:\n              break;\n            }\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.name), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.minval), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.maxval), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.next_variant), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.main_variant), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.binfo), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.context), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.type.lang_specific), cookie);\n          break;\n        case TS_LIST:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.list.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.list.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.list.purpose), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.list.value), cookie);\n          break;\n        case TS_VEC:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.vec.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.vec.common.type), cookie);\n          {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(TREE_VEC_LENGTH ((tree)&((*x).generic.vec))); i0++) {\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.vec.a\u00ddi0\u00a8), cookie);\n            }\n          }\n          break;\n        case TS_EXP:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.exp.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.exp.common.type), cookie);\n          switch (TREE_CODE ((tree) &(*x)))\n            {\n            case WITH_CLEANUP_EXPR:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd2\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd1\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd0\u00a8), cookie);\n              break;\n            case RTL_EXPR:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd1\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd0\u00a8), cookie);\n              break;\n            case GOTO_SUBROUTINE_EXPR:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd1\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd0\u00a8), cookie);\n              break;\n            case SAVE_EXPR:\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd2\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd1\u00a8), cookie);\n              if ((void *)(x) == this_obj)\n                op (&((*x).generic.exp.operands\u00dd0\u00a8), cookie);\n              break;\n            default:\n              {\n                size_t i1;\n                for (i1 = 0; i1 < (size_t)(TREE_CODE_LENGTH (TREE_CODE ((tree) &(*x)))); i1++) {\n                  if ((void *)(x) == this_obj)\n                    op (&((*x).generic.exp.operands\u00ddi1\u00a8), cookie);\n                }\n              }\n              break;\n            }\n          break;\n        case TS_BLOCK:\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.common.chain), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.common.type), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.vars), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.subblocks), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.supercontext), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.abstract_origin), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.fragment_origin), cookie);\n          if ((void *)(x) == this_obj)\n            op (&((*x).generic.block.fragment_chain), cookie);\n          break;\n        default:\n          break;\n        }\n      break;\n    case 1:\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.common_id.common.chain), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.common_id.common.type), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.common_id.node.ident.str), cookie);\n      switch (0)\n        {\n        case 1:\n          break;\n        case 0:\n          break;\n        default:\n          break;\n        }\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.symbol_value), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.tag_value), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).identifier.label_value), cookie);\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_9lang_decl (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct lang_decl * const x ATTRIBUTE_UNUSED = (struct lang_decl *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).pending_sizes), cookie);\n}\n\nvoid\ngt_pch_p_9lang_type (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct lang_type * const x ATTRIBUTE_UNUSED = (struct lang_type *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).s), cookie);\n}\n\nvoid\ngt_pch_p_17language_function (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct language_function * const x ATTRIBUTE_UNUSED = (struct language_function *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).base.x_stmt_tree.x_last_stmt), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).base.x_stmt_tree.x_last_expr_type), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).base.x_stmt_tree.x_last_expr_filename), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).base.x_scope_stmt_stack), cookie);\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_c_decl_h\u00dd\u00a8 = {\n  {\n    &global_scope,\n    1,\n    sizeof (global_scope),\n    &gt_ggc_mx_c_scope,\n    &gt_pch_nx_c_scope\n  },\n  {\n    &current_function_scope,\n    1,\n    sizeof (current_function_scope),\n    &gt_ggc_mx_c_scope,\n    &gt_pch_nx_c_scope\n  },\n  {\n    &current_scope,\n    1,\n    sizeof (current_scope),\n    &gt_ggc_mx_c_scope,\n    &gt_pch_nx_c_scope\n  },\n  {\n    &current_file_decl,\n    1,\n    sizeof (current_file_decl),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &last_builtin_decl,\n    1,\n    sizeof (last_builtin_decl),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &first_builtin_decl,\n    1,\n    sizeof (first_builtin_decl),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &truly_local_externals,\n    1,\n    sizeof (truly_local_externals),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &c_scope_stmt_stack,\n    1,\n    sizeof (c_scope_stmt_stack),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &c_stmt_tree.x_last_stmt,\n    1,\n    sizeof (c_stmt_tree),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &c_stmt_tree.x_last_expr_type,\n    1,\n    sizeof (c_stmt_tree),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &c_stmt_tree.x_last_expr_filename,\n    1,\n    sizeof (c_stmt_tree),\n    &gt_ggc_m_S,\n    (gt_pointer_walker) &gt_pch_n_S\n  },\n  {\n    &static_dtors,\n    1,\n    sizeof (static_dtors),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &static_ctors,\n    1,\n    sizeof (static_ctors),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_ggc_rd_gt_c_decl_h\u00dd\u00a8 = {\n  { &scope_freelist, 1, sizeof (scope_freelist), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_c_decl_h\u00dd\u00a8 = {\n  { &compound_literal_number, 1, sizeof (compound_literal_number), NULL, NULL },\n  { &c_stmt_tree, 1, sizeof (c_stmt_tree), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@C@PAR": {"ttr": 4356, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for c-parse.in.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_c_parse_h\u00dd\u00a8 = {\n  {\n    &declspec_stack,\n    1,\n    sizeof (declspec_stack),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &all_prefix_attributes,\n    1,\n    sizeof (all_prefix_attributes),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &prefix_attributes,\n    1,\n    sizeof (prefix_attributes),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &current_declspecs,\n    1,\n    sizeof (current_declspecs),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@C@PRA": {"ttr": 4358, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for c-pragma.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_align_stack (void *x_p)\n{\n  struct align_stack * const x = (struct align_stack *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9tree_node ((*x).id);\n      gt_ggc_m_11align_stack ((*x).prev);\n    }\n}\n\nvoid\ngt_pch_nx_align_stack (void *x_p)\n{\n  struct align_stack * const x = (struct align_stack *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_11align_stack))\n    {\n      gt_pch_n_9tree_node ((*x).id);\n      gt_pch_n_11align_stack ((*x).prev);\n    }\n}\n\nvoid\ngt_pch_p_11align_stack (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct align_stack * const x ATTRIBUTE_UNUSED = (struct align_stack *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).id), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).prev), cookie);\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_c_pragma_h\u00dd\u00a8 = {\n  {\n    &pragma_extern_prefix,\n    1,\n    sizeof (pragma_extern_prefix),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &pending_redefine_extname,\n    1,\n    sizeof (pending_redefine_extname),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &pending_weaks,\n    1,\n    sizeof (pending_weaks),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &alignment_stack,\n    1,\n    sizeof (alignment_stack),\n    &gt_ggc_mx_align_stack,\n    &gt_pch_nx_align_stack\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@CFGLA": {"ttr": 4360, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for cfglayout.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_cfglayout_h\u00dd\u00a8 = {\n  {\n    &file_locators_files,\n    1,\n    sizeof (file_locators_files),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &file_locators_locs,\n    1,\n    sizeof (file_locators_locs),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &line_locators_lines,\n    1,\n    sizeof (line_locators_lines),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &line_locators_locs,\n    1,\n    sizeof (line_locators_locs),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &block_locators_blocks,\n    1,\n    sizeof (block_locators_blocks),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &block_locators_locs,\n    1,\n    sizeof (block_locators_locs),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@CGRAP": {"ttr": 4362, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for cgraph.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_cgraph_h\u00dd\u00a8 = {\n  {\n    &cgraph_varpool_nodes,\n    1,\n    sizeof (cgraph_varpool_nodes),\n    &gt_ggc_mx_cgraph_varpool_node,\n    &gt_pch_nx_cgraph_varpool_node\n  },\n  {\n    &cgraph_varpool_hash,\n    1,\n    sizeof (cgraph_varpool_hash),\n    &gt_ggc_m_P19cgraph_varpool_node4htab,\n    &gt_pch_n_P19cgraph_varpool_node4htab\n  },\n  {\n    &cgraph_hash,\n    1,\n    sizeof (cgraph_hash),\n    &gt_ggc_m_P11cgraph_node4htab,\n    &gt_pch_n_P11cgraph_node4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@COVER": {"ttr": 4364, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for coverage.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_coverage_h\u00dd\u00a8 = {\n  {\n    &ctr_labels\u00dd0\u00a8,\n    1 * (GCOV_COUNTERS),\n    sizeof (ctr_labels\u00dd0\u00a8),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@CSELI": {"ttr": 4366, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for cselib.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_cselib_h\u00dd\u00a8 = {\n  {\n    &callmem,\n    1,\n    sizeof (callmem),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  {\n    &used_regs,\n    1,\n    sizeof (used_regs),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &reg_values,\n    1,\n    sizeof (reg_values),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &hash_table,\n    1,\n    sizeof (hash_table),\n    &gt_ggc_m_P17cselib_val_struct4htab,\n    &gt_pch_n_P17cselib_val_struct4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_ggc_rd_gt_cselib_h\u00dd\u00a8 = {\n  { &used_regs_old, 1, sizeof (used_regs_old), NULL, NULL },\n  { &reg_values_old, 1, sizeof (reg_values_old), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@DBXOU": {"ttr": 4368, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for dbxout.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_typeinfo (void *x_p)\n{\n  struct typeinfo * const x = (struct typeinfo *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_pch_nx_typeinfo (void *x_p)\n{\n  struct typeinfo * const x = (struct typeinfo *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_8typeinfo))\n    {\n    }\n}\n\nvoid\ngt_pch_p_8typeinfo (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct typeinfo * const x ATTRIBUTE_UNUSED = (struct typeinfo *)x_p;\n}\n\n/* GC roots.  */\n\nstatic void gt_ggc_ma_typevec (void *);\nstatic void\ngt_ggc_ma_typevec (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (typevec != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(typevec_len); i0++) {\n    }\n    ggc_mark (typevec);\n  }\n}\n\nstatic void gt_pch_pa_typevec\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_typevec (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (typevec != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(typevec_len); i0++) {\n    }\n    if ((void *)(&typevec) == this_obj)\n      op (&(typevec), cookie);\n  }\n}\n\nstatic void gt_pch_na_typevec (void *);\nstatic void\ngt_pch_na_typevec (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (typevec != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(typevec_len); i1++) {\n    }\n    gt_pch_note_object (typevec, &typevec, gt_pch_pa_typevec);\n  }\n}\n\nconst struct ggc_root_tab gt_ggc_r_gt_dbxout_h\u00dd\u00a8 = {\n  {\n    &lastfile,\n    1,\n    sizeof (lastfile),\n    &gt_ggc_m_S,\n    (gt_pointer_walker) &gt_pch_n_S\n  },\n  {\n    &typevec,\n    1,\n    sizeof (typevec),\n    &gt_ggc_ma_typevec,\n    &gt_pch_na_typevec\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_dbxout_h\u00dd\u00a8 = {\n  { &lastfile_is_base, 1, sizeof (lastfile_is_base), NULL, NULL },\n  { &source_label_number, 1, sizeof (source_label_number), NULL, NULL },\n  { &have_used_extensions, 1, sizeof (have_used_extensions), NULL, NULL },\n  { &dbxout_source_line_counter, 1, sizeof (dbxout_source_line_counter), NULL, NULL },\n  { &scope_labelno, 1, sizeof (scope_labelno), NULL, NULL },\n  { &next_file_number, 1, sizeof (next_file_number), NULL, NULL },\n  { &next_type_number, 1, sizeof (next_type_number), NULL, NULL },\n  { &typevec_len, 1, sizeof (typevec_len), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@DOJUM": {"ttr": 4370, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for dojump.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_dojump_h\u00dd\u00a8 = {\n  {\n    &shift_test,\n    1,\n    sizeof (shift_test),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  {\n    &and_test,\n    1,\n    sizeof (and_test),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  {\n    &and_reg,\n    1,\n    sizeof (and_reg),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@DWARF": {"ttr": 4372, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for dwarf2out.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_limbo_die_struct (void *x_p)\n{\n  struct limbo_die_struct * const x = (struct limbo_die_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_10die_struct ((*x).die);\n      gt_ggc_m_9tree_node ((*x).created_for);\n      gt_ggc_m_16limbo_die_struct ((*x).next);\n    }\n}\n\nvoid\ngt_ggc_mx_dw_ranges_struct (void *x_p)\n{\n  struct dw_ranges_struct * const x = (struct dw_ranges_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_ggc_mx_pubname_struct (void *x_p)\n{\n  struct pubname_struct * const x = (struct pubname_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_10die_struct ((*x).die);\n    }\n}\n\nvoid\ngt_ggc_mx_dw_separate_line_info_struct (void *x_p)\n{\n  struct dw_separate_line_info_struct * const x = (struct dw_separate_line_info_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_ggc_mx_dw_line_info_struct (void *x_p)\n{\n  struct dw_line_info_struct * const x = (struct dw_line_info_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_ggc_mx_dw_attr_struct (void *x_p)\n{\n  struct dw_attr_struct * const x = (struct dw_attr_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_14dw_attr_struct ((*x).dw_attr_next);\n      switch (((*x).dw_attr_val).val_class)\n        {\n        case dw_val_class_addr:\n          gt_ggc_m_7rtx_def ((*x).dw_attr_val.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_ggc_m_18dw_loc_list_struct ((*x).dw_attr_val.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_ggc_m_19dw_loc_descr_struct ((*x).dw_attr_val.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_attr_val.v.val_vec.array != NULL) {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(((*x).dw_attr_val.v.val_vec).length); i0++) {\n            }\n            ggc_mark ((*x).dw_attr_val.v.val_vec.array);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_ggc_m_10die_struct ((*x).dw_attr_val.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_ggc_m_20indirect_string_node ((*x).dw_attr_val.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_mx_dw_loc_list_struct (void *x_p)\n{\n  struct dw_loc_list_struct * const x = (struct dw_loc_list_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_18dw_loc_list_struct ((*x).dw_loc_next);\n      gt_ggc_m_19dw_loc_descr_struct ((*x).expr);\n    }\n}\n\nvoid\ngt_ggc_mx_queued_reg_save (void *x_p)\n{\n  struct queued_reg_save * const x = (struct queued_reg_save *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_15queued_reg_save ((*x).next);\n      gt_ggc_m_7rtx_def ((*x).reg);\n    }\n}\n\nvoid\ngt_ggc_mx_indirect_string_node (void *x_p)\n{\n  struct indirect_string_node * const x = (struct indirect_string_node *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_ggc_mx_dw_loc_descr_struct (void *x_p)\n{\n  struct dw_loc_descr_struct * const x = (struct dw_loc_descr_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_19dw_loc_descr_struct ((*x).dw_loc_next);\n      switch (((*x).dw_loc_oprnd1).val_class)\n        {\n        case dw_val_class_addr:\n          gt_ggc_m_7rtx_def ((*x).dw_loc_oprnd1.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_ggc_m_18dw_loc_list_struct ((*x).dw_loc_oprnd1.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_ggc_m_19dw_loc_descr_struct ((*x).dw_loc_oprnd1.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_loc_oprnd1.v.val_vec.array != NULL) {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(((*x).dw_loc_oprnd1.v.val_vec).length); i0++) {\n            }\n            ggc_mark ((*x).dw_loc_oprnd1.v.val_vec.array);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_ggc_m_10die_struct ((*x).dw_loc_oprnd1.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_ggc_m_20indirect_string_node ((*x).dw_loc_oprnd1.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n      switch (((*x).dw_loc_oprnd2).val_class)\n        {\n        case dw_val_class_addr:\n          gt_ggc_m_7rtx_def ((*x).dw_loc_oprnd2.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_ggc_m_18dw_loc_list_struct ((*x).dw_loc_oprnd2.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_ggc_m_19dw_loc_descr_struct ((*x).dw_loc_oprnd2.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_loc_oprnd2.v.val_vec.array != NULL) {\n            size_t i1;\n            for (i1 = 0; i1 < (size_t)(((*x).dw_loc_oprnd2.v.val_vec).length); i1++) {\n            }\n            ggc_mark ((*x).dw_loc_oprnd2.v.val_vec.array);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_ggc_m_10die_struct ((*x).dw_loc_oprnd2.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_ggc_m_20indirect_string_node ((*x).dw_loc_oprnd2.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_mx_dw_fde_struct (void *x_p)\n{\n  struct dw_fde_struct * const x = (struct dw_fde_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_13dw_cfi_struct ((*x).dw_fde_cfi);\n    }\n}\n\nvoid\ngt_ggc_mx_dw_cfi_struct (void *x_p)\n{\n  struct dw_cfi_struct * const x = (struct dw_cfi_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_13dw_cfi_struct ((*x).dw_cfi_next);\n      switch (dw_cfi_oprnd1_desc (((*x)).dw_cfi_opc))\n        {\n        case dw_cfi_oprnd_reg_num:\n          break;\n        case dw_cfi_oprnd_offset:\n          break;\n        case dw_cfi_oprnd_addr:\n          break;\n        case dw_cfi_oprnd_loc:\n          gt_ggc_m_19dw_loc_descr_struct ((*x).dw_cfi_oprnd1.dw_cfi_loc);\n          break;\n        default:\n          break;\n        }\n      switch (dw_cfi_oprnd2_desc (((*x)).dw_cfi_opc))\n        {\n        case dw_cfi_oprnd_reg_num:\n          break;\n        case dw_cfi_oprnd_offset:\n          break;\n        case dw_cfi_oprnd_addr:\n          break;\n        case dw_cfi_oprnd_loc:\n          gt_ggc_m_19dw_loc_descr_struct ((*x).dw_cfi_oprnd2.dw_cfi_loc);\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_mx_die_struct (void *x_p)\n{\n  struct die_struct * const x = (struct die_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_14dw_attr_struct ((*x).die_attr);\n      gt_ggc_m_10die_struct ((*x).die_parent);\n      gt_ggc_m_10die_struct ((*x).die_child);\n      gt_ggc_m_10die_struct ((*x).die_sib);\n      gt_ggc_m_10die_struct ((*x).die_definition);\n    }\n}\n\nvoid\ngt_ggc_m_P20indirect_string_node4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_ggc_m_20indirect_string_node ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_limbo_die_struct (void *x_p)\n{\n  struct limbo_die_struct * const x = (struct limbo_die_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_16limbo_die_struct))\n    {\n      gt_pch_n_10die_struct ((*x).die);\n      gt_pch_n_9tree_node ((*x).created_for);\n      gt_pch_n_16limbo_die_struct ((*x).next);\n    }\n}\n\nvoid\ngt_pch_nx_dw_ranges_struct (void *x_p)\n{\n  struct dw_ranges_struct * const x = (struct dw_ranges_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_16dw_ranges_struct))\n    {\n    }\n}\n\nvoid\ngt_pch_nx_pubname_struct (void *x_p)\n{\n  struct pubname_struct * const x = (struct pubname_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_14pubname_struct))\n    {\n      gt_pch_n_10die_struct ((*x).die);\n      gt_pch_n_S ((*x).name);\n    }\n}\n\nvoid\ngt_pch_nx_dw_separate_line_info_struct (void *x_p)\n{\n  struct dw_separate_line_info_struct * const x = (struct dw_separate_line_info_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_28dw_separate_line_info_struct))\n    {\n    }\n}\n\nvoid\ngt_pch_nx_dw_line_info_struct (void *x_p)\n{\n  struct dw_line_info_struct * const x = (struct dw_line_info_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_19dw_line_info_struct))\n    {\n    }\n}\n\nvoid\ngt_pch_nx_dw_attr_struct (void *x_p)\n{\n  struct dw_attr_struct * const x = (struct dw_attr_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_14dw_attr_struct))\n    {\n      gt_pch_n_14dw_attr_struct ((*x).dw_attr_next);\n      switch (((*x).dw_attr_val).val_class)\n        {\n        case dw_val_class_addr:\n          gt_pch_n_7rtx_def ((*x).dw_attr_val.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_pch_n_18dw_loc_list_struct ((*x).dw_attr_val.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_pch_n_19dw_loc_descr_struct ((*x).dw_attr_val.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_attr_val.v.val_vec.array != NULL) {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(((*x).dw_attr_val.v.val_vec).length); i0++) {\n            }\n            gt_pch_note_object ((*x).dw_attr_val.v.val_vec.array, x, gt_pch_p_14dw_attr_struct);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_pch_n_10die_struct ((*x).dw_attr_val.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_pch_n_20indirect_string_node ((*x).dw_attr_val.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          gt_pch_n_S ((*x).dw_attr_val.v.val_lbl_id);\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_dw_loc_list_struct (void *x_p)\n{\n  struct dw_loc_list_struct * const x = (struct dw_loc_list_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_18dw_loc_list_struct))\n    {\n      gt_pch_n_18dw_loc_list_struct ((*x).dw_loc_next);\n      gt_pch_n_S ((*x).begin);\n      gt_pch_n_S ((*x).end);\n      gt_pch_n_S ((*x).ll_symbol);\n      gt_pch_n_S ((*x).section);\n      gt_pch_n_19dw_loc_descr_struct ((*x).expr);\n    }\n}\n\nvoid\ngt_pch_nx_queued_reg_save (void *x_p)\n{\n  struct queued_reg_save * const x = (struct queued_reg_save *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_15queued_reg_save))\n    {\n      gt_pch_n_15queued_reg_save ((*x).next);\n      gt_pch_n_7rtx_def ((*x).reg);\n    }\n}\n\nvoid\ngt_pch_nx_indirect_string_node (void *x_p)\n{\n  struct indirect_string_node * const x = (struct indirect_string_node *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_20indirect_string_node))\n    {\n      gt_pch_n_S ((*x).str);\n      gt_pch_n_S ((*x).label);\n    }\n}\n\nvoid\ngt_pch_nx_dw_loc_descr_struct (void *x_p)\n{\n  struct dw_loc_descr_struct * const x = (struct dw_loc_descr_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_19dw_loc_descr_struct))\n    {\n      gt_pch_n_19dw_loc_descr_struct ((*x).dw_loc_next);\n      switch (((*x).dw_loc_oprnd1).val_class)\n        {\n        case dw_val_class_addr:\n          gt_pch_n_7rtx_def ((*x).dw_loc_oprnd1.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_pch_n_18dw_loc_list_struct ((*x).dw_loc_oprnd1.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_pch_n_19dw_loc_descr_struct ((*x).dw_loc_oprnd1.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_loc_oprnd1.v.val_vec.array != NULL) {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(((*x).dw_loc_oprnd1.v.val_vec).length); i0++) {\n            }\n            gt_pch_note_object ((*x).dw_loc_oprnd1.v.val_vec.array, x, gt_pch_p_19dw_loc_descr_struct);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_pch_n_10die_struct ((*x).dw_loc_oprnd1.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_pch_n_20indirect_string_node ((*x).dw_loc_oprnd1.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          gt_pch_n_S ((*x).dw_loc_oprnd1.v.val_lbl_id);\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n      switch (((*x).dw_loc_oprnd2).val_class)\n        {\n        case dw_val_class_addr:\n          gt_pch_n_7rtx_def ((*x).dw_loc_oprnd2.v.val_addr);\n          break;\n        case dw_val_class_offset:\n          break;\n        case dw_val_class_loc_list:\n          gt_pch_n_18dw_loc_list_struct ((*x).dw_loc_oprnd2.v.val_loc_list);\n          break;\n        case dw_val_class_loc:\n          gt_pch_n_19dw_loc_descr_struct ((*x).dw_loc_oprnd2.v.val_loc);\n          break;\n        default:\n          break;\n        case dw_val_class_unsigned_const:\n          break;\n        case dw_val_class_long_long:\n          break;\n        case dw_val_class_vec:\n          if ((*x).dw_loc_oprnd2.v.val_vec.array != NULL) {\n            size_t i1;\n            for (i1 = 0; i1 < (size_t)(((*x).dw_loc_oprnd2.v.val_vec).length); i1++) {\n            }\n            gt_pch_note_object ((*x).dw_loc_oprnd2.v.val_vec.array, x, gt_pch_p_19dw_loc_descr_struct);\n          }\n          break;\n        case dw_val_class_die_ref:\n          gt_pch_n_10die_struct ((*x).dw_loc_oprnd2.v.val_die_ref.die);\n          break;\n        case dw_val_class_fde_ref:\n          break;\n        case dw_val_class_str:\n          gt_pch_n_20indirect_string_node ((*x).dw_loc_oprnd2.v.val_str);\n          break;\n        case dw_val_class_lbl_id:\n          gt_pch_n_S ((*x).dw_loc_oprnd2.v.val_lbl_id);\n          break;\n        case dw_val_class_flag:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_dw_fde_struct (void *x_p)\n{\n  struct dw_fde_struct * const x = (struct dw_fde_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_13dw_fde_struct))\n    {\n      gt_pch_n_S ((*x).dw_fde_begin);\n      gt_pch_n_S ((*x).dw_fde_current_label);\n      gt_pch_n_S ((*x).dw_fde_end);\n      gt_pch_n_13dw_cfi_struct ((*x).dw_fde_cfi);\n    }\n}\n\nvoid\ngt_pch_nx_dw_cfi_struct (void *x_p)\n{\n  struct dw_cfi_struct * const x = (struct dw_cfi_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_13dw_cfi_struct))\n    {\n      gt_pch_n_13dw_cfi_struct ((*x).dw_cfi_next);\n      switch (dw_cfi_oprnd1_desc (((*x)).dw_cfi_opc))\n        {\n        case dw_cfi_oprnd_reg_num:\n          break;\n        case dw_cfi_oprnd_offset:\n          break;\n        case dw_cfi_oprnd_addr:\n          gt_pch_n_S ((*x).dw_cfi_oprnd1.dw_cfi_addr);\n          break;\n        case dw_cfi_oprnd_loc:\n          gt_pch_n_19dw_loc_descr_struct ((*x).dw_cfi_oprnd1.dw_cfi_loc);\n          break;\n        default:\n          break;\n        }\n      switch (dw_cfi_oprnd2_desc (((*x)).dw_cfi_opc))\n        {\n        case dw_cfi_oprnd_reg_num:\n          break;\n        case dw_cfi_oprnd_offset:\n          break;\n        case dw_cfi_oprnd_addr:\n          gt_pch_n_S ((*x).dw_cfi_oprnd2.dw_cfi_addr);\n          break;\n        case dw_cfi_oprnd_loc:\n          gt_pch_n_19dw_loc_descr_struct ((*x).dw_cfi_oprnd2.dw_cfi_loc);\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_die_struct (void *x_p)\n{\n  struct die_struct * const x = (struct die_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_10die_struct))\n    {\n      gt_pch_n_S ((*x).die_symbol);\n      gt_pch_n_14dw_attr_struct ((*x).die_attr);\n      gt_pch_n_10die_struct ((*x).die_parent);\n      gt_pch_n_10die_struct ((*x).die_child);\n      gt_pch_n_10die_struct ((*x).die_sib);\n      gt_pch_n_10die_struct ((*x).die_definition);\n    }\n}\n\nvoid\ngt_pch_n_P20indirect_string_node4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P20indirect_string_node4htab))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_pch_n_20indirect_string_node ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_P20indirect_string_node4htab);\n      }\n    }\n}\n\nvoid\ngt_pch_p_16limbo_die_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct limbo_die_struct * const x ATTRIBUTE_UNUSED = (struct limbo_die_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).die), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).created_for), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n}\n\nvoid\ngt_pch_p_16dw_ranges_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_ranges_struct * const x ATTRIBUTE_UNUSED = (struct dw_ranges_struct *)x_p;\n}\n\nvoid\ngt_pch_p_14pubname_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct pubname_struct * const x ATTRIBUTE_UNUSED = (struct pubname_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).die), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).name), cookie);\n}\n\nvoid\ngt_pch_p_28dw_separate_line_info_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_separate_line_info_struct * const x ATTRIBUTE_UNUSED = (struct dw_separate_line_info_struct *)x_p;\n}\n\nvoid\ngt_pch_p_19dw_line_info_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_line_info_struct * const x ATTRIBUTE_UNUSED = (struct dw_line_info_struct *)x_p;\n}\n\nvoid\ngt_pch_p_14dw_attr_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_attr_struct * const x ATTRIBUTE_UNUSED = (struct dw_attr_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_attr_next), cookie);\n  switch (((*x).dw_attr_val).val_class)\n    {\n    case dw_val_class_addr:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_addr), cookie);\n      break;\n    case dw_val_class_offset:\n      break;\n    case dw_val_class_loc_list:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_loc_list), cookie);\n      break;\n    case dw_val_class_loc:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_loc), cookie);\n      break;\n    default:\n      break;\n    case dw_val_class_unsigned_const:\n      break;\n    case dw_val_class_long_long:\n      break;\n    case dw_val_class_vec:\n      if ((*x).dw_attr_val.v.val_vec.array != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x).dw_attr_val.v.val_vec).length); i0++) {\n        }\n        if ((void *)(x) == this_obj)\n          op (&((*x).dw_attr_val.v.val_vec.array), cookie);\n      }\n      break;\n    case dw_val_class_die_ref:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_die_ref.die), cookie);\n      break;\n    case dw_val_class_fde_ref:\n      break;\n    case dw_val_class_str:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_str), cookie);\n      break;\n    case dw_val_class_lbl_id:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_attr_val.v.val_lbl_id), cookie);\n      break;\n    case dw_val_class_flag:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_18dw_loc_list_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_loc_list_struct * const x ATTRIBUTE_UNUSED = (struct dw_loc_list_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_loc_next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).begin), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).end), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).ll_symbol), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).section), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).expr), cookie);\n}\n\nvoid\ngt_pch_p_15queued_reg_save (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct queued_reg_save * const x ATTRIBUTE_UNUSED = (struct queued_reg_save *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).reg), cookie);\n}\n\nvoid\ngt_pch_p_20indirect_string_node (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct indirect_string_node * const x ATTRIBUTE_UNUSED = (struct indirect_string_node *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).str), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).label), cookie);\n}\n\nvoid\ngt_pch_p_19dw_loc_descr_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_loc_descr_struct * const x ATTRIBUTE_UNUSED = (struct dw_loc_descr_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_loc_next), cookie);\n  switch (((*x).dw_loc_oprnd1).val_class)\n    {\n    case dw_val_class_addr:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_addr), cookie);\n      break;\n    case dw_val_class_offset:\n      break;\n    case dw_val_class_loc_list:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_loc_list), cookie);\n      break;\n    case dw_val_class_loc:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_loc), cookie);\n      break;\n    default:\n      break;\n    case dw_val_class_unsigned_const:\n      break;\n    case dw_val_class_long_long:\n      break;\n    case dw_val_class_vec:\n      if ((*x).dw_loc_oprnd1.v.val_vec.array != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x).dw_loc_oprnd1.v.val_vec).length); i0++) {\n        }\n        if ((void *)(x) == this_obj)\n          op (&((*x).dw_loc_oprnd1.v.val_vec.array), cookie);\n      }\n      break;\n    case dw_val_class_die_ref:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_die_ref.die), cookie);\n      break;\n    case dw_val_class_fde_ref:\n      break;\n    case dw_val_class_str:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_str), cookie);\n      break;\n    case dw_val_class_lbl_id:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd1.v.val_lbl_id), cookie);\n      break;\n    case dw_val_class_flag:\n      break;\n    }\n  switch (((*x).dw_loc_oprnd2).val_class)\n    {\n    case dw_val_class_addr:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_addr), cookie);\n      break;\n    case dw_val_class_offset:\n      break;\n    case dw_val_class_loc_list:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_loc_list), cookie);\n      break;\n    case dw_val_class_loc:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_loc), cookie);\n      break;\n    default:\n      break;\n    case dw_val_class_unsigned_const:\n      break;\n    case dw_val_class_long_long:\n      break;\n    case dw_val_class_vec:\n      if ((*x).dw_loc_oprnd2.v.val_vec.array != NULL) {\n        size_t i1;\n        for (i1 = 0; i1 < (size_t)(((*x).dw_loc_oprnd2.v.val_vec).length); i1++) {\n        }\n        if ((void *)(x) == this_obj)\n          op (&((*x).dw_loc_oprnd2.v.val_vec.array), cookie);\n      }\n      break;\n    case dw_val_class_die_ref:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_die_ref.die), cookie);\n      break;\n    case dw_val_class_fde_ref:\n      break;\n    case dw_val_class_str:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_str), cookie);\n      break;\n    case dw_val_class_lbl_id:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_loc_oprnd2.v.val_lbl_id), cookie);\n      break;\n    case dw_val_class_flag:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_13dw_fde_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_fde_struct * const x ATTRIBUTE_UNUSED = (struct dw_fde_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_fde_begin), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_fde_current_label), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_fde_end), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_fde_cfi), cookie);\n}\n\nvoid\ngt_pch_p_13dw_cfi_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct dw_cfi_struct * const x ATTRIBUTE_UNUSED = (struct dw_cfi_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).dw_cfi_next), cookie);\n  switch (dw_cfi_oprnd1_desc (((*x)).dw_cfi_opc))\n    {\n    case dw_cfi_oprnd_reg_num:\n      break;\n    case dw_cfi_oprnd_offset:\n      break;\n    case dw_cfi_oprnd_addr:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_cfi_oprnd1.dw_cfi_addr), cookie);\n      break;\n    case dw_cfi_oprnd_loc:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_cfi_oprnd1.dw_cfi_loc), cookie);\n      break;\n    default:\n      break;\n    }\n  switch (dw_cfi_oprnd2_desc (((*x)).dw_cfi_opc))\n    {\n    case dw_cfi_oprnd_reg_num:\n      break;\n    case dw_cfi_oprnd_offset:\n      break;\n    case dw_cfi_oprnd_addr:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_cfi_oprnd2.dw_cfi_addr), cookie);\n      break;\n    case dw_cfi_oprnd_loc:\n      if ((void *)(x) == this_obj)\n        op (&((*x).dw_cfi_oprnd2.dw_cfi_loc), cookie);\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_10die_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct die_struct * const x ATTRIBUTE_UNUSED = (struct die_struct *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_symbol), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_attr), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_parent), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_child), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_sib), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).die_definition), cookie);\n}\n\nvoid\ngt_pch_p_P20indirect_string_node4htab (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct htab * const x ATTRIBUTE_UNUSED = (struct htab *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nstatic void gt_ggc_ma_ranges_table (void *);\nstatic void\ngt_ggc_ma_ranges_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (ranges_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(ranges_table_allocated); i0++) {\n    }\n    ggc_mark (ranges_table);\n  }\n}\n\nstatic void gt_pch_pa_ranges_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_ranges_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (ranges_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(ranges_table_allocated); i0++) {\n    }\n    if ((void *)(&ranges_table) == this_obj)\n      op (&(ranges_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_ranges_table (void *);\nstatic void\ngt_pch_na_ranges_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (ranges_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(ranges_table_allocated); i1++) {\n    }\n    gt_pch_note_object (ranges_table, &ranges_table, gt_pch_pa_ranges_table);\n  }\n}\n\nstatic void gt_ggc_ma_arange_table (void *);\nstatic void\ngt_ggc_ma_arange_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (arange_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(arange_table_allocated); i0++) {\n      gt_ggc_m_10die_struct (arange_table\u00ddi0\u00a8);\n    }\n    ggc_mark (arange_table);\n  }\n}\n\nstatic void gt_pch_pa_arange_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_arange_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (arange_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(arange_table_allocated); i0++) {\n      if ((void *)(arange_table) == this_obj)\n        op (&(arange_table\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&arange_table) == this_obj)\n      op (&(arange_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_arange_table (void *);\nstatic void\ngt_pch_na_arange_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (arange_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(arange_table_allocated); i1++) {\n      gt_pch_n_10die_struct (arange_table\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (arange_table, &arange_table, gt_pch_pa_arange_table);\n  }\n}\n\nstatic void gt_ggc_ma_pubname_table (void *);\nstatic void\ngt_ggc_ma_pubname_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (pubname_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(pubname_table_allocated); i0++) {\n      gt_ggc_m_10die_struct (pubname_table\u00ddi0\u00a8.die);\n    }\n    ggc_mark (pubname_table);\n  }\n}\n\nstatic void gt_pch_pa_pubname_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_pubname_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (pubname_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(pubname_table_allocated); i0++) {\n      if ((void *)(pubname_table) == this_obj)\n        op (&(pubname_table\u00ddi0\u00a8.die), cookie);\n      if ((void *)(pubname_table) == this_obj)\n        op (&(pubname_table\u00ddi0\u00a8.name), cookie);\n    }\n    if ((void *)(&pubname_table) == this_obj)\n      op (&(pubname_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_pubname_table (void *);\nstatic void\ngt_pch_na_pubname_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (pubname_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(pubname_table_allocated); i1++) {\n      gt_pch_n_10die_struct (pubname_table\u00ddi1\u00a8.die);\n      gt_pch_n_S (pubname_table\u00ddi1\u00a8.name);\n    }\n    gt_pch_note_object (pubname_table, &pubname_table, gt_pch_pa_pubname_table);\n  }\n}\n\nstatic void gt_ggc_ma_separate_line_info_table (void *);\nstatic void\ngt_ggc_ma_separate_line_info_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (separate_line_info_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(separate_line_info_table_allocated); i0++) {\n    }\n    ggc_mark (separate_line_info_table);\n  }\n}\n\nstatic void gt_pch_pa_separate_line_info_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_separate_line_info_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (separate_line_info_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(separate_line_info_table_allocated); i0++) {\n    }\n    if ((void *)(&separate_line_info_table) == this_obj)\n      op (&(separate_line_info_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_separate_line_info_table (void *);\nstatic void\ngt_pch_na_separate_line_info_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (separate_line_info_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(separate_line_info_table_allocated); i1++) {\n    }\n    gt_pch_note_object (separate_line_info_table, &separate_line_info_table, gt_pch_pa_separate_line_info_table);\n  }\n}\n\nstatic void gt_ggc_ma_line_info_table (void *);\nstatic void\ngt_ggc_ma_line_info_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (line_info_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(line_info_table_allocated); i0++) {\n    }\n    ggc_mark (line_info_table);\n  }\n}\n\nstatic void gt_pch_pa_line_info_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_line_info_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (line_info_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(line_info_table_allocated); i0++) {\n    }\n    if ((void *)(&line_info_table) == this_obj)\n      op (&(line_info_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_line_info_table (void *);\nstatic void\ngt_pch_na_line_info_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (line_info_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(line_info_table_allocated); i1++) {\n    }\n    gt_pch_note_object (line_info_table, &line_info_table, gt_pch_pa_line_info_table);\n  }\n}\n\nstatic void gt_ggc_ma_abbrev_die_table (void *);\nstatic void\ngt_ggc_ma_abbrev_die_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (abbrev_die_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(abbrev_die_table_allocated); i0++) {\n      gt_ggc_m_10die_struct (abbrev_die_table\u00ddi0\u00a8);\n    }\n    ggc_mark (abbrev_die_table);\n  }\n}\n\nstatic void gt_pch_pa_abbrev_die_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_abbrev_die_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (abbrev_die_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(abbrev_die_table_allocated); i0++) {\n      if ((void *)(abbrev_die_table) == this_obj)\n        op (&(abbrev_die_table\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&abbrev_die_table) == this_obj)\n      op (&(abbrev_die_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_abbrev_die_table (void *);\nstatic void\ngt_pch_na_abbrev_die_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (abbrev_die_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(abbrev_die_table_allocated); i1++) {\n      gt_pch_n_10die_struct (abbrev_die_table\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (abbrev_die_table, &abbrev_die_table, gt_pch_pa_abbrev_die_table);\n  }\n}\n\nstatic void gt_ggc_ma_decl_die_table (void *);\nstatic void\ngt_ggc_ma_decl_die_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (decl_die_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(decl_die_table_allocated); i0++) {\n      gt_ggc_m_10die_struct (decl_die_table\u00ddi0\u00a8);\n    }\n    ggc_mark (decl_die_table);\n  }\n}\n\nstatic void gt_pch_pa_decl_die_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_decl_die_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (decl_die_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(decl_die_table_allocated); i0++) {\n      if ((void *)(decl_die_table) == this_obj)\n        op (&(decl_die_table\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(&decl_die_table) == this_obj)\n      op (&(decl_die_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_decl_die_table (void *);\nstatic void\ngt_pch_na_decl_die_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (decl_die_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(decl_die_table_allocated); i1++) {\n      gt_pch_n_10die_struct (decl_die_table\u00ddi1\u00a8);\n    }\n    gt_pch_note_object (decl_die_table, &decl_die_table, gt_pch_pa_decl_die_table);\n  }\n}\n\nstatic void gt_ggc_ma_fde_table (void *);\nstatic void\ngt_ggc_ma_fde_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (fde_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(fde_table_allocated); i0++) {\n      gt_ggc_m_13dw_cfi_struct (fde_table\u00ddi0\u00a8.dw_fde_cfi);\n    }\n    ggc_mark (fde_table);\n  }\n}\n\nstatic void gt_pch_pa_fde_table\n    (void *, void *, gt_pointer_operator, void *);\nstatic void gt_pch_pa_fde_table (void *this_obj ATTRIBUTE_UNUSED,\n      void *x_p ATTRIBUTE_UNUSED,\n      gt_pointer_operator op ATTRIBUTE_UNUSED,\n      void *cookie ATTRIBUTE_UNUSED)\n{\n  if (fde_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(fde_table_allocated); i0++) {\n      if ((void *)(fde_table) == this_obj)\n        op (&(fde_table\u00ddi0\u00a8.dw_fde_begin), cookie);\n      if ((void *)(fde_table) == this_obj)\n        op (&(fde_table\u00ddi0\u00a8.dw_fde_current_label), cookie);\n      if ((void *)(fde_table) == this_obj)\n        op (&(fde_table\u00ddi0\u00a8.dw_fde_end), cookie);\n      if ((void *)(fde_table) == this_obj)\n        op (&(fde_table\u00ddi0\u00a8.dw_fde_cfi), cookie);\n    }\n    if ((void *)(&fde_table) == this_obj)\n      op (&(fde_table), cookie);\n  }\n}\n\nstatic void gt_pch_na_fde_table (void *);\nstatic void\ngt_pch_na_fde_table (void *x_p ATTRIBUTE_UNUSED)\n{\n  if (fde_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(fde_table_allocated); i1++) {\n      gt_pch_n_S (fde_table\u00ddi1\u00a8.dw_fde_begin);\n      gt_pch_n_S (fde_table\u00ddi1\u00a8.dw_fde_current_label);\n      gt_pch_n_S (fde_table\u00ddi1\u00a8.dw_fde_end);\n      gt_pch_n_13dw_cfi_struct (fde_table\u00ddi1\u00a8.dw_fde_cfi);\n    }\n    gt_pch_note_object (fde_table, &fde_table, gt_pch_pa_fde_table);\n  }\n}\n\nconst struct ggc_root_tab gt_ggc_r_gt_dwarf2out_h\u00dd\u00a8 = {\n  {\n    &ranges_table,\n    1,\n    sizeof (ranges_table),\n    &gt_ggc_ma_ranges_table,\n    &gt_pch_na_ranges_table\n  },\n  {\n    &arange_table,\n    1,\n    sizeof (arange_table),\n    &gt_ggc_ma_arange_table,\n    &gt_pch_na_arange_table\n  },\n  {\n    &pubname_table,\n    1,\n    sizeof (pubname_table),\n    &gt_ggc_ma_pubname_table,\n    &gt_pch_na_pubname_table\n  },\n  {\n    &separate_line_info_table,\n    1,\n    sizeof (separate_line_info_table),\n    &gt_ggc_ma_separate_line_info_table,\n    &gt_pch_na_separate_line_info_table\n  },\n  {\n    &line_info_table,\n    1,\n    sizeof (line_info_table),\n    &gt_ggc_ma_line_info_table,\n    &gt_pch_na_line_info_table\n  },\n  {\n    &abbrev_die_table,\n    1,\n    sizeof (abbrev_die_table),\n    &gt_ggc_ma_abbrev_die_table,\n    &gt_pch_na_abbrev_die_table\n  },\n  {\n    &decl_die_table,\n    1,\n    sizeof (decl_die_table),\n    &gt_ggc_ma_decl_die_table,\n    &gt_pch_na_decl_die_table\n  },\n  {\n    &file_table_emitted,\n    1,\n    sizeof (file_table_emitted),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &file_table,\n    1,\n    sizeof (file_table),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &limbo_die_list,\n    1,\n    sizeof (limbo_die_list),\n    &gt_ggc_mx_limbo_die_struct,\n    &gt_pch_nx_limbo_die_struct\n  },\n  {\n    &comp_unit_die,\n    1,\n    sizeof (comp_unit_die),\n    &gt_ggc_mx_die_struct,\n    &gt_pch_nx_die_struct\n  },\n  {\n    &queued_reg_saves,\n    1,\n    sizeof (queued_reg_saves),\n    &gt_ggc_mx_queued_reg_save,\n    &gt_pch_nx_queued_reg_save\n  },\n  {\n    &debug_str_hash,\n    1,\n    sizeof (debug_str_hash),\n    &gt_ggc_m_P20indirect_string_node4htab,\n    &gt_pch_n_P20indirect_string_node4htab\n  },\n  {\n    &cie_cfi_head,\n    1,\n    sizeof (cie_cfi_head),\n    &gt_ggc_mx_dw_cfi_struct,\n    &gt_pch_nx_dw_cfi_struct\n  },\n  {\n    &fde_table,\n    1,\n    sizeof (fde_table),\n    &gt_ggc_ma_fde_table,\n    &gt_pch_na_fde_table\n  },\n  {\n    &decl_scope_table,\n    1,\n    sizeof (decl_scope_table),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &incomplete_types,\n    1,\n    sizeof (incomplete_types),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &used_rtx_varray,\n    1,\n    sizeof (used_rtx_varray),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_dwarf2out_h\u00dd\u00a8 = {\n  { &label_num, 1, sizeof (label_num), NULL, NULL },\n  { &emitcount, 1, sizeof (emitcount), NULL, NULL },\n  { &have_location_lists, 1, sizeof (have_location_lists), NULL, NULL },\n  { &ranges_table_in_use, 1, sizeof (ranges_table_in_use), NULL, NULL },\n  { &ranges_table_allocated, 1, sizeof (ranges_table_allocated), NULL, NULL },\n  { &arange_table_in_use, 1, sizeof (arange_table_in_use), NULL, NULL },\n  { &arange_table_allocated, 1, sizeof (arange_table_allocated), NULL, NULL },\n  { &pubname_table_in_use, 1, sizeof (pubname_table_in_use), NULL, NULL },\n  { &pubname_table_allocated, 1, sizeof (pubname_table_allocated), NULL, NULL },\n  { &separate_line_info_table_in_use, 1, sizeof (separate_line_info_table_in_use), NULL, NULL },\n  { &separate_line_info_table_allocated, 1, sizeof (separate_line_info_table_allocated), NULL, NULL },\n  { &line_info_table_in_use, 1, sizeof (line_info_table_in_use), NULL, NULL },\n  { &line_info_table_allocated, 1, sizeof (line_info_table_allocated), NULL, NULL },\n  { &abbrev_die_table_in_use, 1, sizeof (abbrev_die_table_in_use), NULL, NULL },\n  { &abbrev_die_table_allocated, 1, sizeof (abbrev_die_table_allocated), NULL, NULL },\n  { &decl_die_table_in_use, 1, sizeof (decl_die_table_in_use), NULL, NULL },\n  { &decl_die_table_allocated, 1, sizeof (decl_die_table_allocated), NULL, NULL },\n  { &file_table_last_lookup_index, 1, sizeof (file_table_last_lookup_index), NULL, NULL },\n  { &dwarf2out_cfi_label_num, 1, sizeof (dwarf2out_cfi_label_num), NULL, NULL },\n  { &dw2_string_counter, 1, sizeof (dw2_string_counter), NULL, NULL },\n  { &fde_table_in_use, 1, sizeof (fde_table_in_use), NULL, NULL },\n  { &fde_table_allocated, 1, sizeof (fde_table_allocated), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@DWASM": {"ttr": 4616, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for dwarf2asm.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_dwarf2asm_h\u00dd\u00a8 = {\n  {\n    &indirect_pool,\n    1,\n    sizeof (indirect_pool),\n    &gt_ggc_m_SP9tree_node12splay_tree_s,\n    &gt_pch_n_SP9tree_node12splay_tree_s\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_dwarf2asm_h\u00dd\u00a8 = {\n  { &dw2_const_labelno, 1, sizeof (dw2_const_labelno), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@EMIT@": {"ttr": 4618, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for emit-rtl.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_emit_rtl_h\u00dd\u00a8 = {\n  {\n    &static_regno_reg_rtx\u00dd0\u00a8,\n    1 * (FIRST_PSEUDO_REGISTER),\n    sizeof (static_regno_reg_rtx\u00dd0\u00a8),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_ggc_rd_gt_emit_rtl_h\u00dd\u00a8 = {\n  { &free_sequence_stack, 1, sizeof (free_sequence_stack), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_cache_tab gt_ggc_rc_gt_emit_rtl_h\u00dd\u00a8 = {\n  {\n    &const_double_htab,\n    1,\n    sizeof (const_double_htab),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def,\n    &ggc_marked_p\n  },\n  {\n    &reg_attrs_htab,\n    1,\n    sizeof (reg_attrs_htab),\n    &gt_ggc_mx_reg_attrs,\n    &gt_pch_nx_reg_attrs,\n    &ggc_marked_p\n  },\n  {\n    &mem_attrs_htab,\n    1,\n    sizeof (mem_attrs_htab),\n    &gt_ggc_mx_mem_attrs,\n    &gt_pch_nx_mem_attrs,\n    &ggc_marked_p\n  },\n  {\n    &const_int_htab,\n    1,\n    sizeof (const_int_htab),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def,\n    &ggc_marked_p\n  },\n  LAST_GGC_CACHE_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rc_gt_emit_rtl_h\u00dd\u00a8 = {\n  {\n    &const_double_htab,\n    1,\n    sizeof (const_double_htab),\n    &gt_ggc_m_P7rtx_def4htab,\n    &gt_pch_n_P7rtx_def4htab\n  },\n  {\n    &reg_attrs_htab,\n    1,\n    sizeof (reg_attrs_htab),\n    &gt_ggc_m_P9reg_attrs4htab,\n    &gt_pch_n_P9reg_attrs4htab\n  },\n  {\n    &mem_attrs_htab,\n    1,\n    sizeof (mem_attrs_htab),\n    &gt_ggc_m_P9mem_attrs4htab,\n    &gt_pch_n_P9mem_attrs4htab\n  },\n  {\n    &const_int_htab,\n    1,\n    sizeof (const_int_htab),\n    &gt_ggc_m_P7rtx_def4htab,\n    &gt_pch_n_P7rtx_def4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_emit_rtl_h\u00dd\u00a8 = {\n  { &label_num, 1, sizeof (label_num), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@EXCEP": {"ttr": 4620, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for except.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_eh_region (void *x_p)\n{\n  struct eh_region * const x = (struct eh_region *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9eh_region ((*x).outer);\n      gt_ggc_m_9eh_region ((*x).inner);\n      gt_ggc_m_9eh_region ((*x).next_peer);\n      gt_ggc_m_15bitmap_head_def ((*x).aka);\n      switch ((*x).type)\n        {\n        case ERT_TRY:\n          gt_ggc_m_9eh_region ((*x).u.try.catch);\n          gt_ggc_m_9eh_region ((*x).u.try.last_catch);\n          gt_ggc_m_9eh_region ((*x).u.try.prev_try);\n          gt_ggc_m_7rtx_def ((*x).u.try.continue_label);\n          break;\n        case ERT_CATCH:\n          gt_ggc_m_9eh_region ((*x).u.catch.next_catch);\n          gt_ggc_m_9eh_region ((*x).u.catch.prev_catch);\n          gt_ggc_m_9tree_node ((*x).u.catch.type_list);\n          gt_ggc_m_9tree_node ((*x).u.catch.filter_list);\n          break;\n        case ERT_ALLOWED_EXCEPTIONS:\n          gt_ggc_m_9tree_node ((*x).u.allowed.type_list);\n          break;\n        case ERT_THROW:\n          gt_ggc_m_9tree_node ((*x).u.throw.type);\n          break;\n        case ERT_CLEANUP:\n          gt_ggc_m_9tree_node ((*x).u.cleanup.exp);\n          gt_ggc_m_9eh_region ((*x).u.cleanup.prev_try);\n          break;\n        case ERT_FIXUP:\n          gt_ggc_m_9tree_node ((*x).u.fixup.cleanup_exp);\n          gt_ggc_m_9eh_region ((*x).u.fixup.real_region);\n          break;\n        default:\n          break;\n        }\n      gt_ggc_m_7rtx_def ((*x).label);\n      gt_ggc_m_7rtx_def ((*x).landing_pad);\n      gt_ggc_m_7rtx_def ((*x).post_landing_pad);\n      gt_ggc_m_7rtx_def ((*x).resume);\n    }\n}\n\nvoid\ngt_ggc_mx_ehl_map_entry (void *x_p)\n{\n  struct ehl_map_entry * const x = (struct ehl_map_entry *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_7rtx_def ((*x).label);\n      gt_ggc_m_9eh_region ((*x).region);\n    }\n}\n\nvoid\ngt_ggc_mx_eh_status (void *x_p)\n{\n  struct eh_status * const x = (struct eh_status *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9eh_region ((*x).region_tree);\n      if ((*x).region_array != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).last_region_number); i0++) {\n          gt_ggc_m_9eh_region ((*x).region_array\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).region_array);\n      }\n      gt_ggc_m_9eh_region ((*x).cur_region);\n      gt_ggc_m_9eh_region ((*x).try_region);\n      gt_ggc_m_7rtx_def ((*x).filter);\n      gt_ggc_m_7rtx_def ((*x).exc_ptr);\n      gt_ggc_m_15varray_head_tag ((*x).ttype_data);\n      gt_ggc_m_15varray_head_tag ((*x).ehspec_data);\n      gt_ggc_m_15varray_head_tag ((*x).action_record_data);\n      gt_ggc_m_P13ehl_map_entry4htab ((*x).exception_handler_label_map);\n      if ((*x).call_site_data != NULL) {\n        size_t i1;\n        for (i1 = 0; i1 < (size_t)(((*x)).call_site_data_used); i1++) {\n          gt_ggc_m_7rtx_def ((*x).call_site_data\u00ddi1\u00a8.landing_pad);\n        }\n        ggc_mark ((*x).call_site_data);\n      }\n      gt_ggc_m_7rtx_def ((*x).ehr_stackadj);\n      gt_ggc_m_7rtx_def ((*x).ehr_handler);\n      gt_ggc_m_7rtx_def ((*x).ehr_label);\n      gt_ggc_m_7rtx_def ((*x).sjlj_fc);\n      gt_ggc_m_7rtx_def ((*x).sjlj_exit_after);\n    }\n}\n\nvoid\ngt_ggc_m_P13ehl_map_entry4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_ggc_m_13ehl_map_entry ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_eh_region (void *x_p)\n{\n  struct eh_region * const x = (struct eh_region *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9eh_region))\n    {\n      gt_pch_n_9eh_region ((*x).outer);\n      gt_pch_n_9eh_region ((*x).inner);\n      gt_pch_n_9eh_region ((*x).next_peer);\n      gt_pch_n_15bitmap_head_def ((*x).aka);\n      switch ((*x).type)\n        {\n        case ERT_TRY:\n          gt_pch_n_9eh_region ((*x).u.try.catch);\n          gt_pch_n_9eh_region ((*x).u.try.last_catch);\n          gt_pch_n_9eh_region ((*x).u.try.prev_try);\n          gt_pch_n_7rtx_def ((*x).u.try.continue_label);\n          break;\n        case ERT_CATCH:\n          gt_pch_n_9eh_region ((*x).u.catch.next_catch);\n          gt_pch_n_9eh_region ((*x).u.catch.prev_catch);\n          gt_pch_n_9tree_node ((*x).u.catch.type_list);\n          gt_pch_n_9tree_node ((*x).u.catch.filter_list);\n          break;\n        case ERT_ALLOWED_EXCEPTIONS:\n          gt_pch_n_9tree_node ((*x).u.allowed.type_list);\n          break;\n        case ERT_THROW:\n          gt_pch_n_9tree_node ((*x).u.throw.type);\n          break;\n        case ERT_CLEANUP:\n          gt_pch_n_9tree_node ((*x).u.cleanup.exp);\n          gt_pch_n_9eh_region ((*x).u.cleanup.prev_try);\n          break;\n        case ERT_FIXUP:\n          gt_pch_n_9tree_node ((*x).u.fixup.cleanup_exp);\n          gt_pch_n_9eh_region ((*x).u.fixup.real_region);\n          break;\n        default:\n          break;\n        }\n      gt_pch_n_7rtx_def ((*x).label);\n      gt_pch_n_7rtx_def ((*x).landing_pad);\n      gt_pch_n_7rtx_def ((*x).post_landing_pad);\n      gt_pch_n_7rtx_def ((*x).resume);\n    }\n}\n\nvoid\ngt_pch_nx_ehl_map_entry (void *x_p)\n{\n  struct ehl_map_entry * const x = (struct ehl_map_entry *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_13ehl_map_entry))\n    {\n      gt_pch_n_7rtx_def ((*x).label);\n      gt_pch_n_9eh_region ((*x).region);\n    }\n}\n\nvoid\ngt_pch_nx_eh_status (void *x_p)\n{\n  struct eh_status * const x = (struct eh_status *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9eh_status))\n    {\n      gt_pch_n_9eh_region ((*x).region_tree);\n      if ((*x).region_array != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).last_region_number); i0++) {\n          gt_pch_n_9eh_region ((*x).region_array\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).region_array, x, gt_pch_p_9eh_status);\n      }\n      gt_pch_n_9eh_region ((*x).cur_region);\n      gt_pch_n_9eh_region ((*x).try_region);\n      gt_pch_n_7rtx_def ((*x).filter);\n      gt_pch_n_7rtx_def ((*x).exc_ptr);\n      gt_pch_n_15varray_head_tag ((*x).ttype_data);\n      gt_pch_n_15varray_head_tag ((*x).ehspec_data);\n      gt_pch_n_15varray_head_tag ((*x).action_record_data);\n      gt_pch_n_P13ehl_map_entry4htab ((*x).exception_handler_label_map);\n      if ((*x).call_site_data != NULL) {\n        size_t i1;\n        for (i1 = 0; i1 < (size_t)(((*x)).call_site_data_used); i1++) {\n          gt_pch_n_7rtx_def ((*x).call_site_data\u00ddi1\u00a8.landing_pad);\n        }\n        gt_pch_note_object ((*x).call_site_data, x, gt_pch_p_9eh_status);\n      }\n      gt_pch_n_7rtx_def ((*x).ehr_stackadj);\n      gt_pch_n_7rtx_def ((*x).ehr_handler);\n      gt_pch_n_7rtx_def ((*x).ehr_label);\n      gt_pch_n_7rtx_def ((*x).sjlj_fc);\n      gt_pch_n_7rtx_def ((*x).sjlj_exit_after);\n    }\n}\n\nvoid\ngt_pch_n_P13ehl_map_entry4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P13ehl_map_entry4htab))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_pch_n_13ehl_map_entry ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_P13ehl_map_entry4htab);\n      }\n    }\n}\n\nvoid\ngt_pch_p_9eh_region (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct eh_region * const x ATTRIBUTE_UNUSED = (struct eh_region *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).outer), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).inner), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).next_peer), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).aka), cookie);\n  switch ((*x).type)\n    {\n    case ERT_TRY:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.try.catch), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.try.last_catch), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.try.prev_try), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.try.continue_label), cookie);\n      break;\n    case ERT_CATCH:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.catch.next_catch), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.catch.prev_catch), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.catch.type_list), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.catch.filter_list), cookie);\n      break;\n    case ERT_ALLOWED_EXCEPTIONS:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.allowed.type_list), cookie);\n      break;\n    case ERT_THROW:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.throw.type), cookie);\n      break;\n    case ERT_CLEANUP:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.cleanup.exp), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.cleanup.prev_try), cookie);\n      break;\n    case ERT_FIXUP:\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.fixup.cleanup_exp), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).u.fixup.real_region), cookie);\n      break;\n    default:\n      break;\n    }\n  if ((void *)(x) == this_obj)\n    op (&((*x).label), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).landing_pad), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).post_landing_pad), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).resume), cookie);\n}\n\nvoid\ngt_pch_p_13ehl_map_entry (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct ehl_map_entry * const x ATTRIBUTE_UNUSED = (struct ehl_map_entry *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).label), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).region), cookie);\n}\n\nvoid\ngt_pch_p_9eh_status (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct eh_status * const x ATTRIBUTE_UNUSED = (struct eh_status *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).region_tree), cookie);\n  if ((*x).region_array != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).last_region_number); i0++) {\n      if ((void *)((*x).region_array) == this_obj)\n        op (&((*x).region_array\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).region_array), cookie);\n  }\n  if ((void *)(x) == this_obj)\n    op (&((*x).cur_region), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).try_region), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).filter), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).exc_ptr), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).ttype_data), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).ehspec_data), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).action_record_data), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).exception_handler_label_map), cookie);\n  if ((*x).call_site_data != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(((*x)).call_site_data_used); i1++) {\n      if ((void *)((*x).call_site_data) == this_obj)\n        op (&((*x).call_site_data\u00ddi1\u00a8.landing_pad), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).call_site_data), cookie);\n  }\n  if ((void *)(x) == this_obj)\n    op (&((*x).ehr_stackadj), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).ehr_handler), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).ehr_label), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).sjlj_fc), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).sjlj_exit_after), cookie);\n}\n\nvoid\ngt_pch_p_P13ehl_map_entry4htab (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct htab * const x ATTRIBUTE_UNUSED = (struct htab *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_except_h\u00dd\u00a8 = {\n  {\n    &sjlj_fc_type_node,\n    1,\n    sizeof (sjlj_fc_type_node),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &type_to_runtime_map,\n    1,\n    sizeof (type_to_runtime_map),\n    &gt_ggc_m_P9tree_node4htab,\n    &gt_pch_n_P9tree_node4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_except_h\u00dd\u00a8 = {\n  { &call_site_base, 1, sizeof (call_site_base), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@EXPLO": {"ttr": 4868, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for explow.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_explow_h\u00dd\u00a8 = {\n  {\n    &stack_check_libfunc,\n    1,\n    sizeof (stack_check_libfunc),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@EXPR": {"ttr": 4870, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for expr.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_expr_h\u00dd\u00a8 = {\n  {\n    &block_clear_fn,\n    1,\n    sizeof (block_clear_fn),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &block_move_fn,\n    1,\n    sizeof (block_move_fn),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@FOLD@": {"ttr": 4872, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for fold-const.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_fold_const_h\u00dd\u00a8 = {\n  {\n    &new_const,\n    1,\n    sizeof (new_const),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_cache_tab gt_ggc_rc_gt_fold_const_h\u00dd\u00a8 = {\n  {\n    &size_htab,\n    1,\n    sizeof (size_htab),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node,\n    &ggc_marked_p\n  },\n  LAST_GGC_CACHE_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rc_gt_fold_const_h\u00dd\u00a8 = {\n  {\n    &size_htab,\n    1,\n    sizeof (size_htab),\n    &gt_ggc_m_P9tree_node4htab,\n    &gt_pch_n_P9tree_node4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@FUNCT": {"ttr": 4874, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for function.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_temp_slot (void *x_p)\n{\n  struct temp_slot * const x = (struct temp_slot *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9temp_slot ((*x).next);\n      gt_ggc_m_7rtx_def ((*x).slot);\n      gt_ggc_m_7rtx_def ((*x).address);\n      gt_ggc_m_9tree_node ((*x).type);\n      gt_ggc_m_9tree_node ((*x).rtl_expr);\n    }\n}\n\nvoid\ngt_pch_nx_temp_slot (void *x_p)\n{\n  struct temp_slot * const x = (struct temp_slot *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9temp_slot))\n    {\n      gt_pch_n_9temp_slot ((*x).next);\n      gt_pch_n_7rtx_def ((*x).slot);\n      gt_pch_n_7rtx_def ((*x).address);\n      gt_pch_n_9tree_node ((*x).type);\n      gt_pch_n_9tree_node ((*x).rtl_expr);\n    }\n}\n\nvoid\ngt_pch_p_9temp_slot (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct temp_slot * const x ATTRIBUTE_UNUSED = (struct temp_slot *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).slot), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).address), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).type), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).rtl_expr), cookie);\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_function_h\u00dd\u00a8 = {\n  {\n    &initial_trampoline,\n    1,\n    sizeof (initial_trampoline),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  {\n    &sibcall_epilogue,\n    1,\n    sizeof (sibcall_epilogue),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &epilogue,\n    1,\n    sizeof (epilogue),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  {\n    &prologue,\n    1,\n    sizeof (prologue),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_function_h\u00dd\u00a8 = {\n  { &next_block_index, 1, sizeof (next_block_index), NULL, NULL },\n  { &funcdef_no, 1, sizeof (funcdef_no), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@GCSE": {"ttr": 4876, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for gcse.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_gcse_h\u00dd\u00a8 = {\n  {\n    &test_insn,\n    1,\n    sizeof (test_insn),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@INTEG": {"ttr": 4878, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for integrate.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_initial_value_struct (void *x_p)\n{\n  struct initial_value_struct * const x = (struct initial_value_struct *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).num_entries); i0++) {\n          gt_ggc_m_7rtx_def ((*x).entries\u00ddi0\u00a8.hard_reg);\n          gt_ggc_m_7rtx_def ((*x).entries\u00ddi0\u00a8.pseudo);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_initial_value_struct (void *x_p)\n{\n  struct initial_value_struct * const x = (struct initial_value_struct *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_20initial_value_struct))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).num_entries); i0++) {\n          gt_pch_n_7rtx_def ((*x).entries\u00ddi0\u00a8.hard_reg);\n          gt_pch_n_7rtx_def ((*x).entries\u00ddi0\u00a8.pseudo);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_20initial_value_struct);\n      }\n    }\n}\n\nvoid\ngt_pch_p_20initial_value_struct (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct initial_value_struct * const x ATTRIBUTE_UNUSED = (struct initial_value_struct *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).num_entries); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8.hard_reg), cookie);\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8.pseudo), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_integrate_h\u00dd\u00a8 = {\n  {\n    &old_cfun,\n    1,\n    sizeof (old_cfun),\n    &gt_ggc_mx_function,\n    &gt_pch_nx_function\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@LANGH": {"ttr": 4880, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for langhooks.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_langhooks_h\u00dd\u00a8 = {\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_langhooks_h\u00dd\u00a8 = {\n  { &var_labelno, 1, sizeof (var_labelno), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@LISTS": {"ttr": 4882, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for lists.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_rd_gt_lists_h\u00dd\u00a8 = {\n  { &unused_expr_list, 1, sizeof (unused_expr_list), NULL, NULL },\n  { &unused_insn_list, 1, sizeof (unused_insn_list), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@OPTAB": {"ttr": 4884, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for optabs.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_optabs_h\u00dd\u00a8 = {\n  {\n    &trap_rtx,\n    1,\n    sizeof (trap_rtx),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@RA@BU": {"ttr": 4886, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for ra-build.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_ra_build_h\u00dd\u00a8 = {\n  {\n    &remat_test_insn,\n    1,\n    sizeof (remat_test_insn),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@REG@S": {"ttr": 4888, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for reg-stack.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_reg_stack_h\u00dd\u00a8 = {\n  {\n    &stack_regs_mentioned_data,\n    1,\n    sizeof (stack_regs_mentioned_data),\n    &gt_ggc_mx_varray_head_tag,\n    &gt_pch_nx_varray_head_tag\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@REGCL": {"ttr": 4890, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for regclass.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_regclass_h\u00dd\u00a8 = {\n  {\n    &top_of_stack\u00dd0\u00a8,\n    1 * (MAX_MACHINE_MODE),\n    sizeof (top_of_stack\u00dd0\u00a8),\n    &gt_ggc_mx_rtx_def,\n    &gt_pch_nx_rtx_def\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@SDBOU": {"ttr": 4892, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for sdbout.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_sdbout_h\u00dd\u00a8 = {\n  {\n    &anonymous_types,\n    1,\n    sizeof (anonymous_types),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_sdbout_h\u00dd\u00a8 = {\n  { &unnamed_struct_number, 1, sizeof (unnamed_struct_number), NULL, NULL },\n  { &sdbout_source_line_counter, 1, sizeof (sdbout_source_line_counter), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@STMT": {"ttr": 4894, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for stmt.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_goto_fixup (void *x_p)\n{\n  struct goto_fixup * const x = (struct goto_fixup *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_10goto_fixup ((*x).next);\n      gt_ggc_m_7rtx_def ((*x).before_jump);\n      gt_ggc_m_9tree_node ((*x).target);\n      gt_ggc_m_9tree_node ((*x).context);\n      gt_ggc_m_7rtx_def ((*x).target_rtl);\n      gt_ggc_m_7rtx_def ((*x).stack_level);\n      gt_ggc_m_9tree_node ((*x).cleanup_list_list);\n    }\n}\n\nvoid\ngt_ggc_mx_label_chain (void *x_p)\n{\n  struct label_chain * const x = (struct label_chain *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_11label_chain ((*x).next);\n      gt_ggc_m_9tree_node ((*x).label);\n    }\n}\n\nvoid\ngt_ggc_mx_nesting (void *x_p)\n{\n  struct nesting * const x = (struct nesting *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_7nesting ((*x).all);\n      gt_ggc_m_7nesting ((*x).next);\n      gt_ggc_m_7rtx_def ((*x).exit_label);\n      switch (((*x)).desc)\n        {\n        case COND_NESTING:\n          gt_ggc_m_7rtx_def ((*x).data.cond.endif_label);\n          gt_ggc_m_7rtx_def ((*x).data.cond.next_label);\n          break;\n        case LOOP_NESTING:\n          gt_ggc_m_7rtx_def ((*x).data.loop.start_label);\n          gt_ggc_m_7rtx_def ((*x).data.loop.end_label);\n          gt_ggc_m_7rtx_def ((*x).data.loop.continue_label);\n          break;\n        case BLOCK_NESTING:\n          gt_ggc_m_7rtx_def ((*x).data.block.stack_level);\n          gt_ggc_m_7rtx_def ((*x).data.block.first_insn);\n          gt_ggc_m_7nesting ((*x).data.block.innermost_stack_block);\n          gt_ggc_m_9tree_node ((*x).data.block.cleanups);\n          gt_ggc_m_9tree_node ((*x).data.block.outer_cleanups);\n          gt_ggc_m_11label_chain ((*x).data.block.label_chain);\n          gt_ggc_m_7rtx_def ((*x).data.block.last_unconditional_cleanup);\n          break;\n        case CASE_NESTING:\n          gt_ggc_m_7rtx_def ((*x).data.case_stmt.start);\n          gt_ggc_m_9case_node ((*x).data.case_stmt.case_list);\n          gt_ggc_m_9tree_node ((*x).data.case_stmt.default_label);\n          gt_ggc_m_9tree_node ((*x).data.case_stmt.index_expr);\n          gt_ggc_m_9tree_node ((*x).data.case_stmt.nominal_type);\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_mx_case_node (void *x_p)\n{\n  struct case_node * const x = (struct case_node *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9case_node ((*x).left);\n      gt_ggc_m_9case_node ((*x).right);\n      gt_ggc_m_9case_node ((*x).parent);\n      gt_ggc_m_9tree_node ((*x).low);\n      gt_ggc_m_9tree_node ((*x).high);\n      gt_ggc_m_9tree_node ((*x).code_label);\n    }\n}\n\nvoid\ngt_ggc_mx_stmt_status (void *x_p)\n{\n  struct stmt_status * const x = (struct stmt_status *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_7nesting ((*x).x_block_stack);\n      gt_ggc_m_7nesting ((*x).x_stack_block_stack);\n      gt_ggc_m_7nesting ((*x).x_cond_stack);\n      gt_ggc_m_7nesting ((*x).x_loop_stack);\n      gt_ggc_m_7nesting ((*x).x_case_stack);\n      gt_ggc_m_7nesting ((*x).x_nesting_stack);\n      gt_ggc_m_9tree_node ((*x).x_last_expr_type);\n      gt_ggc_m_7rtx_def ((*x).x_last_expr_value);\n      gt_ggc_m_7rtx_def ((*x).x_last_expr_alt_rtl);\n      gt_ggc_m_10goto_fixup ((*x).x_goto_fixup_chain);\n    }\n}\n\nvoid\ngt_pch_nx_goto_fixup (void *x_p)\n{\n  struct goto_fixup * const x = (struct goto_fixup *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_10goto_fixup))\n    {\n      gt_pch_n_10goto_fixup ((*x).next);\n      gt_pch_n_7rtx_def ((*x).before_jump);\n      gt_pch_n_9tree_node ((*x).target);\n      gt_pch_n_9tree_node ((*x).context);\n      gt_pch_n_7rtx_def ((*x).target_rtl);\n      gt_pch_n_7rtx_def ((*x).stack_level);\n      gt_pch_n_9tree_node ((*x).cleanup_list_list);\n    }\n}\n\nvoid\ngt_pch_nx_label_chain (void *x_p)\n{\n  struct label_chain * const x = (struct label_chain *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_11label_chain))\n    {\n      gt_pch_n_11label_chain ((*x).next);\n      gt_pch_n_9tree_node ((*x).label);\n    }\n}\n\nvoid\ngt_pch_nx_nesting (void *x_p)\n{\n  struct nesting * const x = (struct nesting *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_7nesting))\n    {\n      gt_pch_n_7nesting ((*x).all);\n      gt_pch_n_7nesting ((*x).next);\n      gt_pch_n_7rtx_def ((*x).exit_label);\n      switch (((*x)).desc)\n        {\n        case COND_NESTING:\n          gt_pch_n_7rtx_def ((*x).data.cond.endif_label);\n          gt_pch_n_7rtx_def ((*x).data.cond.next_label);\n          break;\n        case LOOP_NESTING:\n          gt_pch_n_7rtx_def ((*x).data.loop.start_label);\n          gt_pch_n_7rtx_def ((*x).data.loop.end_label);\n          gt_pch_n_7rtx_def ((*x).data.loop.continue_label);\n          break;\n        case BLOCK_NESTING:\n          gt_pch_n_7rtx_def ((*x).data.block.stack_level);\n          gt_pch_n_7rtx_def ((*x).data.block.first_insn);\n          gt_pch_n_7nesting ((*x).data.block.innermost_stack_block);\n          gt_pch_n_9tree_node ((*x).data.block.cleanups);\n          gt_pch_n_9tree_node ((*x).data.block.outer_cleanups);\n          gt_pch_n_11label_chain ((*x).data.block.label_chain);\n          gt_pch_n_7rtx_def ((*x).data.block.last_unconditional_cleanup);\n          break;\n        case CASE_NESTING:\n          gt_pch_n_7rtx_def ((*x).data.case_stmt.start);\n          gt_pch_n_9case_node ((*x).data.case_stmt.case_list);\n          gt_pch_n_9tree_node ((*x).data.case_stmt.default_label);\n          gt_pch_n_9tree_node ((*x).data.case_stmt.index_expr);\n          gt_pch_n_9tree_node ((*x).data.case_stmt.nominal_type);\n          gt_pch_n_S ((*x).data.case_stmt.printname);\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_case_node (void *x_p)\n{\n  struct case_node * const x = (struct case_node *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9case_node))\n    {\n      gt_pch_n_9case_node ((*x).left);\n      gt_pch_n_9case_node ((*x).right);\n      gt_pch_n_9case_node ((*x).parent);\n      gt_pch_n_9tree_node ((*x).low);\n      gt_pch_n_9tree_node ((*x).high);\n      gt_pch_n_9tree_node ((*x).code_label);\n    }\n}\n\nvoid\ngt_pch_nx_stmt_status (void *x_p)\n{\n  struct stmt_status * const x = (struct stmt_status *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_11stmt_status))\n    {\n      gt_pch_n_7nesting ((*x).x_block_stack);\n      gt_pch_n_7nesting ((*x).x_stack_block_stack);\n      gt_pch_n_7nesting ((*x).x_cond_stack);\n      gt_pch_n_7nesting ((*x).x_loop_stack);\n      gt_pch_n_7nesting ((*x).x_case_stack);\n      gt_pch_n_7nesting ((*x).x_nesting_stack);\n      gt_pch_n_9tree_node ((*x).x_last_expr_type);\n      gt_pch_n_7rtx_def ((*x).x_last_expr_value);\n      gt_pch_n_7rtx_def ((*x).x_last_expr_alt_rtl);\n      gt_pch_n_S ((*x).x_emit_locus.file);\n      gt_pch_n_10goto_fixup ((*x).x_goto_fixup_chain);\n    }\n}\n\nvoid\ngt_pch_p_10goto_fixup (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct goto_fixup * const x ATTRIBUTE_UNUSED = (struct goto_fixup *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).before_jump), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).target), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).context), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).target_rtl), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).stack_level), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).cleanup_list_list), cookie);\n}\n\nvoid\ngt_pch_p_11label_chain (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct label_chain * const x ATTRIBUTE_UNUSED = (struct label_chain *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).label), cookie);\n}\n\nvoid\ngt_pch_p_7nesting (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct nesting * const x ATTRIBUTE_UNUSED = (struct nesting *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).all), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).exit_label), cookie);\n  switch (((*x)).desc)\n    {\n    case COND_NESTING:\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.cond.endif_label), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.cond.next_label), cookie);\n      break;\n    case LOOP_NESTING:\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.loop.start_label), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.loop.end_label), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.loop.continue_label), cookie);\n      break;\n    case BLOCK_NESTING:\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.stack_level), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.first_insn), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.innermost_stack_block), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.cleanups), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.outer_cleanups), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.label_chain), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.block.last_unconditional_cleanup), cookie);\n      break;\n    case CASE_NESTING:\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.start), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.case_list), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.default_label), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.index_expr), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.nominal_type), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).data.case_stmt.printname), cookie);\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_9case_node (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct case_node * const x ATTRIBUTE_UNUSED = (struct case_node *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).left), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).right), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).parent), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).low), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).high), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).code_label), cookie);\n}\n\nvoid\ngt_pch_p_11stmt_status (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct stmt_status * const x ATTRIBUTE_UNUSED = (struct stmt_status *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_block_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_stack_block_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_cond_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_loop_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_case_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_nesting_stack), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_last_expr_type), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_last_expr_value), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_last_expr_alt_rtl), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_emit_locus.file), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_goto_fixup_chain), cookie);\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@STOR@": {"ttr": 5124, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for stor-layout.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_stor_layout_h\u00dd\u00a8 = {\n  {\n    &pending_sizes,\n    1,\n    sizeof (pending_sizes),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GT@STRIN": {"ttr": 5126, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for stringpool.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_string_pool_data (void *x_p)\n{\n  struct string_pool_data * const x = (struct string_pool_data *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).nslots); i0++) {\n          gt_ggc_m_9tree_node ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_string_pool_data (void *x_p)\n{\n  struct string_pool_data * const x = (struct string_pool_data *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_16string_pool_data))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).nslots); i0++) {\n          gt_pch_n_9tree_node ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_16string_pool_data);\n      }\n    }\n}\n\nvoid\ngt_pch_p_16string_pool_data (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct string_pool_data * const x ATTRIBUTE_UNUSED = (struct string_pool_data *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).nslots); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_stringpool_h\u00dd\u00a8 = {\n  {\n    &spd,\n    1,\n    sizeof (spd),\n    &gt_ggc_mx_string_pool_data,\n    &gt_pch_nx_string_pool_data\n  },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@TREE": {"ttr": 5128, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for tree.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_type_hash (void *x_p)\n{\n  struct type_hash * const x = (struct type_hash *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9tree_node ((*x).type);\n    }\n}\n\nvoid\ngt_ggc_m_P9type_hash4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_ggc_m_9type_hash ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_type_hash (void *x_p)\n{\n  struct type_hash * const x = (struct type_hash *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_9type_hash))\n    {\n      gt_pch_n_9tree_node ((*x).type);\n    }\n}\n\nvoid\ngt_pch_n_P9type_hash4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P9type_hash4htab))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_pch_n_9type_hash ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_P9type_hash4htab);\n      }\n    }\n}\n\nvoid\ngt_pch_p_9type_hash (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct type_hash * const x ATTRIBUTE_UNUSED = (struct type_hash *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).type), cookie);\n}\n\nvoid\ngt_pch_p_P9type_hash4htab (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct htab * const x ATTRIBUTE_UNUSED = (struct htab *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_tree_h\u00dd\u00a8 = {\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_cache_tab gt_ggc_rc_gt_tree_h\u00dd\u00a8 = {\n  {\n    &type_hash_table,\n    1,\n    sizeof (type_hash_table),\n    &gt_ggc_mx_type_hash,\n    &gt_pch_nx_type_hash,\n    &type_hash_marked_p\n  },\n  LAST_GGC_CACHE_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rc_gt_tree_h\u00dd\u00a8 = {\n  {\n    &type_hash_table,\n    1,\n    sizeof (type_hash_table),\n    &gt_ggc_m_P9type_hash4htab,\n    &gt_pch_n_P9type_hash4htab\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_tree_h\u00dd\u00a8 = {\n  { &next_type_uid, 1, sizeof (next_type_uid), NULL, NULL },\n  { &next_decl_uid, 1, sizeof (next_decl_uid), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GT@VARAS": {"ttr": 5130, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for varasm.c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\nvoid\ngt_ggc_mx_output_def_pair (void *x_p)\n{\n  struct output_def_pair * const x = (struct output_def_pair *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_9tree_node ((*x).decl);\n      gt_ggc_m_9tree_node ((*x).target);\n    }\n}\n\nvoid\ngt_ggc_mx_constant_descriptor_tree (void *x_p)\n{\n  struct constant_descriptor_tree * const x = (struct constant_descriptor_tree *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_7rtx_def ((*x).rtl);\n      gt_ggc_m_9tree_node ((*x).value);\n    }\n}\n\nvoid\ngt_ggc_mx_in_named_entry (void *x_p)\n{\n  struct in_named_entry * const x = (struct in_named_entry *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n    }\n}\n\nvoid\ngt_ggc_mx_pool_constant (void *x_p)\n{\n  struct pool_constant * const x = (struct pool_constant *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_23constant_descriptor_rtx ((*x).desc);\n      gt_ggc_m_13pool_constant ((*x).next);\n      gt_ggc_m_13pool_constant ((*x).next_sym);\n      gt_ggc_m_7rtx_def ((*x).constant);\n    }\n}\n\nvoid\ngt_ggc_mx_constant_descriptor_rtx (void *x_p)\n{\n  struct constant_descriptor_rtx * const x = (struct constant_descriptor_rtx *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      gt_ggc_m_23constant_descriptor_rtx ((*x).next);\n      gt_ggc_m_7rtx_def ((*x).rtl);\n      switch (((*x).value).kind >= RTX_INT)\n        {\n        case 4:\n          break;\n        case 1:\n          gt_ggc_m_7rtx_def ((*x).value.un.addr.base);\n          break;\n        case 0:\n          break;\n        case 2:\n          {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(16); i0++) {\n            }\n          }\n          break;\n        case 3:\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_mx_varasm_status (void *x_p)\n{\n  struct varasm_status * const x = (struct varasm_status *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).x_const_rtx_hash_table != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(MAX_RTX_HASH_TABLE); i0++) {\n          gt_ggc_m_23constant_descriptor_rtx ((*x).x_const_rtx_hash_table\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).x_const_rtx_hash_table);\n      }\n      if ((*x).x_const_rtx_sym_hash_table != NULL) {\n        size_t i1;\n        for (i1 = 0; i1 < (size_t)(MAX_RTX_HASH_TABLE); i1++) {\n          gt_ggc_m_13pool_constant ((*x).x_const_rtx_sym_hash_table\u00ddi1\u00a8);\n        }\n        ggc_mark ((*x).x_const_rtx_sym_hash_table);\n      }\n      gt_ggc_m_13pool_constant ((*x).x_first_pool);\n      gt_ggc_m_13pool_constant ((*x).x_last_pool);\n    }\n}\n\nvoid\ngt_ggc_m_P15output_def_pair15varray_head_tag (void *x_p)\n{\n  struct varray_head_tag * const x = (struct varray_head_tag *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      switch ((*x).type)\n        {\n        case VARRAY_DATA_C:\n          break;\n        case VARRAY_DATA_UC:\n          break;\n        case VARRAY_DATA_S:\n          break;\n        case VARRAY_DATA_US:\n          break;\n        case VARRAY_DATA_I:\n          break;\n        case VARRAY_DATA_U:\n          break;\n        case VARRAY_DATA_L:\n          break;\n        case VARRAY_DATA_UL:\n          break;\n        case VARRAY_DATA_HINT:\n          break;\n        case VARRAY_DATA_UHINT:\n          break;\n        case VARRAY_DATA_GENERIC:\n          {\n            size_t i10;\n            for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n              gt_ggc_m_15output_def_pair ((*x).data.generic\u00ddi10\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CPTR:\n          {\n            size_t i11;\n            for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n            }\n          }\n          break;\n        case VARRAY_DATA_RTX:\n          {\n            size_t i12;\n            for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n              gt_ggc_m_7rtx_def ((*x).data.rtx\u00ddi12\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTVEC:\n          {\n            size_t i13;\n            for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n              gt_ggc_m_9rtvec_def ((*x).data.rtvec\u00ddi13\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_TREE:\n          {\n            size_t i14;\n            for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n              gt_ggc_m_9tree_node ((*x).data.tree\u00ddi14\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_BITMAP:\n          {\n            size_t i15;\n            for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n              gt_ggc_m_15bitmap_head_def ((*x).data.bitmap\u00ddi15\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CONST_EQUIV:\n          {\n            size_t i16;\n            for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n              gt_ggc_m_7rtx_def ((*x).data.const_equiv\u00ddi16\u00a8.rtx);\n            }\n          }\n          break;\n        case VARRAY_DATA_TE:\n          {\n            size_t i17;\n            for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n              gt_ggc_m_8elt_list ((*x).data.te\u00ddi17\u00a8);\n            }\n          }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_ggc_m_P24constant_descriptor_tree4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_ggc_m_24constant_descriptor_tree ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_ggc_m_P14in_named_entry4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (ggc_test_and_set_mark (x))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_ggc_m_14in_named_entry ((*x).entries\u00ddi0\u00a8);\n        }\n        ggc_mark ((*x).entries);\n      }\n    }\n}\n\nvoid\ngt_pch_nx_output_def_pair (void *x_p)\n{\n  struct output_def_pair * const x = (struct output_def_pair *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_15output_def_pair))\n    {\n      gt_pch_n_9tree_node ((*x).decl);\n      gt_pch_n_9tree_node ((*x).target);\n    }\n}\n\nvoid\ngt_pch_nx_constant_descriptor_tree (void *x_p)\n{\n  struct constant_descriptor_tree * const x = (struct constant_descriptor_tree *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_24constant_descriptor_tree))\n    {\n      gt_pch_n_7rtx_def ((*x).rtl);\n      gt_pch_n_9tree_node ((*x).value);\n    }\n}\n\nvoid\ngt_pch_nx_in_named_entry (void *x_p)\n{\n  struct in_named_entry * const x = (struct in_named_entry *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_14in_named_entry))\n    {\n      gt_pch_n_S ((*x).name);\n    }\n}\n\nvoid\ngt_pch_nx_pool_constant (void *x_p)\n{\n  struct pool_constant * const x = (struct pool_constant *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_13pool_constant))\n    {\n      gt_pch_n_23constant_descriptor_rtx ((*x).desc);\n      gt_pch_n_13pool_constant ((*x).next);\n      gt_pch_n_13pool_constant ((*x).next_sym);\n      gt_pch_n_7rtx_def ((*x).constant);\n    }\n}\n\nvoid\ngt_pch_nx_constant_descriptor_rtx (void *x_p)\n{\n  struct constant_descriptor_rtx * const x = (struct constant_descriptor_rtx *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_23constant_descriptor_rtx))\n    {\n      gt_pch_n_23constant_descriptor_rtx ((*x).next);\n      gt_pch_n_7rtx_def ((*x).rtl);\n      switch (((*x).value).kind >= RTX_INT)\n        {\n        case 4:\n          break;\n        case 1:\n          gt_pch_n_7rtx_def ((*x).value.un.addr.base);\n          gt_pch_n_S ((*x).value.un.addr.symbol);\n          break;\n        case 0:\n          break;\n        case 2:\n          {\n            size_t i0;\n            for (i0 = 0; i0 < (size_t)(16); i0++) {\n            }\n          }\n          break;\n        case 3:\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_nx_varasm_status (void *x_p)\n{\n  struct varasm_status * const x = (struct varasm_status *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_13varasm_status))\n    {\n      if ((*x).x_const_rtx_hash_table != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(MAX_RTX_HASH_TABLE); i0++) {\n          gt_pch_n_23constant_descriptor_rtx ((*x).x_const_rtx_hash_table\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).x_const_rtx_hash_table, x, gt_pch_p_13varasm_status);\n      }\n      if ((*x).x_const_rtx_sym_hash_table != NULL) {\n        size_t i1;\n        for (i1 = 0; i1 < (size_t)(MAX_RTX_HASH_TABLE); i1++) {\n          gt_pch_n_13pool_constant ((*x).x_const_rtx_sym_hash_table\u00ddi1\u00a8);\n        }\n        gt_pch_note_object ((*x).x_const_rtx_sym_hash_table, x, gt_pch_p_13varasm_status);\n      }\n      gt_pch_n_13pool_constant ((*x).x_first_pool);\n      gt_pch_n_13pool_constant ((*x).x_last_pool);\n    }\n}\n\nvoid\ngt_pch_n_P15output_def_pair15varray_head_tag (void *x_p)\n{\n  struct varray_head_tag * const x = (struct varray_head_tag *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P15output_def_pair15varray_head_tag))\n    {\n      gt_pch_n_S ((*x).name);\n      switch ((*x).type)\n        {\n        case VARRAY_DATA_C:\n          break;\n        case VARRAY_DATA_UC:\n          break;\n        case VARRAY_DATA_S:\n          break;\n        case VARRAY_DATA_US:\n          break;\n        case VARRAY_DATA_I:\n          break;\n        case VARRAY_DATA_U:\n          break;\n        case VARRAY_DATA_L:\n          break;\n        case VARRAY_DATA_UL:\n          break;\n        case VARRAY_DATA_HINT:\n          break;\n        case VARRAY_DATA_UHINT:\n          break;\n        case VARRAY_DATA_GENERIC:\n          {\n            size_t i10;\n            for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n              gt_pch_n_15output_def_pair ((*x).data.generic\u00ddi10\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CPTR:\n          {\n            size_t i11;\n            for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n              gt_pch_n_S ((*x).data.cptr\u00ddi11\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTX:\n          {\n            size_t i12;\n            for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n              gt_pch_n_7rtx_def ((*x).data.rtx\u00ddi12\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_RTVEC:\n          {\n            size_t i13;\n            for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n              gt_pch_n_9rtvec_def ((*x).data.rtvec\u00ddi13\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_TREE:\n          {\n            size_t i14;\n            for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n              gt_pch_n_9tree_node ((*x).data.tree\u00ddi14\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_BITMAP:\n          {\n            size_t i15;\n            for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n              gt_pch_n_15bitmap_head_def ((*x).data.bitmap\u00ddi15\u00a8);\n            }\n          }\n          break;\n        case VARRAY_DATA_CONST_EQUIV:\n          {\n            size_t i16;\n            for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n              gt_pch_n_7rtx_def ((*x).data.const_equiv\u00ddi16\u00a8.rtx);\n            }\n          }\n          break;\n        case VARRAY_DATA_TE:\n          {\n            size_t i17;\n            for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n              gt_pch_n_8elt_list ((*x).data.te\u00ddi17\u00a8);\n            }\n          }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\nvoid\ngt_pch_n_P24constant_descriptor_tree4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P24constant_descriptor_tree4htab))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_pch_n_24constant_descriptor_tree ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_P24constant_descriptor_tree4htab);\n      }\n    }\n}\n\nvoid\ngt_pch_n_P14in_named_entry4htab (void *x_p)\n{\n  struct htab * const x = (struct htab *)x_p;\n  if (gt_pch_note_object (x, x, gt_pch_p_P14in_named_entry4htab))\n    {\n      if ((*x).entries != NULL) {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n          gt_pch_n_14in_named_entry ((*x).entries\u00ddi0\u00a8);\n        }\n        gt_pch_note_object ((*x).entries, x, gt_pch_p_P14in_named_entry4htab);\n      }\n    }\n}\n\nvoid\ngt_pch_p_15output_def_pair (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct output_def_pair * const x ATTRIBUTE_UNUSED = (struct output_def_pair *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).decl), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).target), cookie);\n}\n\nvoid\ngt_pch_p_24constant_descriptor_tree (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct constant_descriptor_tree * const x ATTRIBUTE_UNUSED = (struct constant_descriptor_tree *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).rtl), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).value), cookie);\n}\n\nvoid\ngt_pch_p_14in_named_entry (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct in_named_entry * const x ATTRIBUTE_UNUSED = (struct in_named_entry *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).name), cookie);\n}\n\nvoid\ngt_pch_p_13pool_constant (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct pool_constant * const x ATTRIBUTE_UNUSED = (struct pool_constant *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).desc), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).next_sym), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).constant), cookie);\n}\n\nvoid\ngt_pch_p_23constant_descriptor_rtx (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct constant_descriptor_rtx * const x ATTRIBUTE_UNUSED = (struct constant_descriptor_rtx *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).next), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).rtl), cookie);\n  switch (((*x).value).kind >= RTX_INT)\n    {\n    case 4:\n      break;\n    case 1:\n      if ((void *)(x) == this_obj)\n        op (&((*x).value.un.addr.base), cookie);\n      if ((void *)(x) == this_obj)\n        op (&((*x).value.un.addr.symbol), cookie);\n      break;\n    case 0:\n      break;\n    case 2:\n      {\n        size_t i0;\n        for (i0 = 0; i0 < (size_t)(16); i0++) {\n        }\n      }\n      break;\n    case 3:\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_13varasm_status (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct varasm_status * const x ATTRIBUTE_UNUSED = (struct varasm_status *)x_p;\n  if ((*x).x_const_rtx_hash_table != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(MAX_RTX_HASH_TABLE); i0++) {\n      if ((void *)((*x).x_const_rtx_hash_table) == this_obj)\n        op (&((*x).x_const_rtx_hash_table\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).x_const_rtx_hash_table), cookie);\n  }\n  if ((*x).x_const_rtx_sym_hash_table != NULL) {\n    size_t i1;\n    for (i1 = 0; i1 < (size_t)(MAX_RTX_HASH_TABLE); i1++) {\n      if ((void *)((*x).x_const_rtx_sym_hash_table) == this_obj)\n        op (&((*x).x_const_rtx_sym_hash_table\u00ddi1\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).x_const_rtx_sym_hash_table), cookie);\n  }\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_first_pool), cookie);\n  if ((void *)(x) == this_obj)\n    op (&((*x).x_last_pool), cookie);\n}\n\nvoid\ngt_pch_p_P15output_def_pair15varray_head_tag (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct varray_head_tag * const x ATTRIBUTE_UNUSED = (struct varray_head_tag *)x_p;\n  if ((void *)(x) == this_obj)\n    op (&((*x).name), cookie);\n  switch ((*x).type)\n    {\n    case VARRAY_DATA_C:\n      break;\n    case VARRAY_DATA_UC:\n      break;\n    case VARRAY_DATA_S:\n      break;\n    case VARRAY_DATA_US:\n      break;\n    case VARRAY_DATA_I:\n      break;\n    case VARRAY_DATA_U:\n      break;\n    case VARRAY_DATA_L:\n      break;\n    case VARRAY_DATA_UL:\n      break;\n    case VARRAY_DATA_HINT:\n      break;\n    case VARRAY_DATA_UHINT:\n      break;\n    case VARRAY_DATA_GENERIC:\n      {\n        size_t i10;\n        for (i10 = 0; i10 < (size_t)((*x).num_elements); i10++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.generic\u00ddi10\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_CPTR:\n      {\n        size_t i11;\n        for (i11 = 0; i11 < (size_t)((*x).num_elements); i11++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.cptr\u00ddi11\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_RTX:\n      {\n        size_t i12;\n        for (i12 = 0; i12 < (size_t)((*x).num_elements); i12++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.rtx\u00ddi12\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_RTVEC:\n      {\n        size_t i13;\n        for (i13 = 0; i13 < (size_t)((*x).num_elements); i13++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.rtvec\u00ddi13\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_TREE:\n      {\n        size_t i14;\n        for (i14 = 0; i14 < (size_t)((*x).num_elements); i14++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.tree\u00ddi14\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_BITMAP:\n      {\n        size_t i15;\n        for (i15 = 0; i15 < (size_t)((*x).num_elements); i15++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.bitmap\u00ddi15\u00a8), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_CONST_EQUIV:\n      {\n        size_t i16;\n        for (i16 = 0; i16 < (size_t)((*x).num_elements); i16++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.const_equiv\u00ddi16\u00a8.rtx), cookie);\n        }\n      }\n      break;\n    case VARRAY_DATA_TE:\n      {\n        size_t i17;\n        for (i17 = 0; i17 < (size_t)((*x).num_elements); i17++) {\n          if ((void *)(x) == this_obj)\n            op (&((*x).data.te\u00ddi17\u00a8), cookie);\n        }\n      }\n      break;\n    default:\n      break;\n    }\n}\n\nvoid\ngt_pch_p_P24constant_descriptor_tree4htab (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct htab * const x ATTRIBUTE_UNUSED = (struct htab *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\nvoid\ngt_pch_p_P14in_named_entry4htab (void *this_obj ATTRIBUTE_UNUSED,\n\tvoid *x_p,\n\tgt_pointer_operator op ATTRIBUTE_UNUSED,\n\tvoid *cookie ATTRIBUTE_UNUSED)\n{\n  struct htab * const x ATTRIBUTE_UNUSED = (struct htab *)x_p;\n  if ((*x).entries != NULL) {\n    size_t i0;\n    for (i0 = 0; i0 < (size_t)(((*x)).size); i0++) {\n      if ((void *)((*x).entries) == this_obj)\n        op (&((*x).entries\u00ddi0\u00a8), cookie);\n    }\n    if ((void *)(x) == this_obj)\n      op (&((*x).entries), cookie);\n  }\n}\n\n/* GC roots.  */\n\nconst struct ggc_root_tab gt_ggc_r_gt_varasm_h\u00dd\u00a8 = {\n  {\n    &output_defs,\n    1,\n    sizeof (output_defs),\n    &gt_ggc_m_P15output_def_pair15varray_head_tag,\n    &gt_pch_n_P15output_def_pair15varray_head_tag\n  },\n  {\n    &weak_decls,\n    1,\n    sizeof (weak_decls),\n    &gt_ggc_mx_tree_node,\n    &gt_pch_nx_tree_node\n  },\n  {\n    &const_desc_htab,\n    1,\n    sizeof (const_desc_htab),\n    &gt_ggc_m_P24constant_descriptor_tree4htab,\n    &gt_pch_n_P24constant_descriptor_tree4htab\n  },\n  {\n    &in_named_htab,\n    1,\n    sizeof (in_named_htab),\n    &gt_ggc_m_P14in_named_entry4htab,\n    &gt_pch_n_P14in_named_entry4htab\n  },\n  {\n    &in_named_name,\n    1,\n    sizeof (in_named_name),\n    &gt_ggc_m_S,\n    (gt_pointer_walker) &gt_pch_n_S\n  },\n  LAST_GGC_ROOT_TAB\n};\n\nconst struct ggc_root_tab gt_pch_rs_gt_varasm_h\u00dd\u00a8 = {\n  { &in_section, 1, sizeof (in_section), NULL, NULL },\n  { &const_labelno, 1, sizeof (const_labelno), NULL, NULL },\n  LAST_GGC_ROOT_TAB\n};\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR": {"ttr": 5641, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_H\n#define GCC_GTHR_H\n\n/* If this file is compiled with threads support, it must\n       #define __GTHREADS 1\n   to indicate that threads support is present.  Also it has define\n   function\n     int __gthread_active_p ()\n   that returns 1 if thread system is active, 0 if not.\n\n   The threads interface must define the following types:\n     __gthread_key_t\n     __gthread_once_t\n     __gthread_mutex_t\n\n   The threads interface must define the following macros:\n\n     __GTHREAD_ONCE_INIT\n     \t\tto initialize __gthread_once_t\n     __GTHREAD_MUTEX_INIT\n     \t\tto initialize __gthread_mutex_t to get a fast\n\t\tnon-recursive mutex.\n     __GTHREAD_MUTEX_INIT_FUNCTION\n     \t\tsome systems can't initialize a mutex without a\n\t\tfunction call.  On such systems, define this to a\n\t\tfunction which looks like this:\n\t\t  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)\n\t\tDon't define __GTHREAD_MUTEX_INIT in this case\n\n   The threads interface must define the following static functions:\n\n     int __gthread_once (__gthread_once_t *once, void (*func) ())\n\n     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))\n     int __gthread_key_delete (__gthread_key_t key)\n\n     void *__gthread_getspecific (__gthread_key_t key)\n     int __gthread_setspecific (__gthread_key_t key, const void *ptr)\n\n     int __gthread_mutex_lock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);\n     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);\n\n   All functions returning int should return zero on success or the error\n   number.  If the operation is not supported, -1 is returned.\n\n   Currently supported threads packages are\n     POSIX threads with -D_PTHREADS\n     DCE threads with -D_DCE_THREADS\n     Solaris/UI threads with -D_SOLARIS_THREADS\n*/\n\n/* Check first for thread specific defines.  */\n#if _PTHREADS\n#include \"gthr-posix.h\"\n#elif _DCE_THREADS\n#include \"gthr-dce.h\"\n#elif _SOLARIS_THREADS\n#include \"gthr-solaris.h\"\n\n/* Include GTHREAD_FILE if one is defined.  */\n#elif defined(HAVE_GTHR_DEFAULT)\n#if SUPPORTS_WEAK\n#ifndef GTHREAD_USE_WEAK\n#define GTHREAD_USE_WEAK 1\n#endif\n#endif\n#include \"gthr-default.h\"\n\n/* Fallback to single thread definitions.  */\n#else\n#include \"gthr-single.h\"\n#endif\n\n#endif /* ! GCC_GTHR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@AIX": {"ttr": 5135, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_AIX_H\n#define GCC_GTHR_AIX_H\n\n#ifdef _THREAD_SAFE\n#include \"gthr-posix.h\"\n#else\n#include \"gthr-single.h\"\n#endif\n\n#endif /* GCC_GTHR_AIX_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@DCE": {"ttr": 5377, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_DCE_H\n#define GCC_GTHR_DCE_H\n\n/* If _DCE_THREADS is not defined, then we're building the single\n   threaded version of the libraries and do not want to reference\n   anything related to pthreads or dce.  */\n#ifndef _DCE_THREADS\n#include \"gthr-single.h\"\n#else\n/* DCE threads interface.\n   DCE threads are based on POSIX threads draft 4, and many things\n   have changed since then.  */\n\n#define __GTHREADS 1\n\n#include <pthread.h>\n\n#ifdef __cplusplus\n#define UNUSED(x) x\n#else\n#define UNUSED(x) x __attribute__((unused))\n#endif\n\ntypedef pthread_key_t __gthread_key_t;\ntypedef pthread_once_t __gthread_once_t;\ntypedef pthread_mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT pthread_once_init\n\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n\n#define __GTHREAD_MUTEX_INIT_DEFAULT pthread_once_init\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak pthread_once\n#pragma weak pthread_once_init\n#pragma weak pthread_keycreate\n#pragma weak pthread_key_delete\n#pragma weak pthread_getspecific\n#pragma weak pthread_setspecific\n#pragma weak pthread_create\n#pragma weak pthread_mutex_init\n#pragma weak pthread_mutex_lock\n#pragma weak pthread_mutex_trylock\n#pragma weak pthread_mutex_unlock\n\n#ifdef _LIBOBJC\n/* Objective-C.  */\n#pragma weak pthread_cond_broadcast\n#pragma weak pthread_cond_destroy\n#pragma weak pthread_cond_init\n#pragma weak pthread_cond_signal\n#pragma weak pthread_cond_wait\n#pragma weak pthread_exit\n#pragma weak pthread_getunique_np\n#pragma weak pthread_mutex_destroy\n#pragma weak pthread_self\n#pragma weak pthread_yield\n#endif\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &pthread_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* Key structure for maintaining thread specific storage */\nstatic pthread_key_t _objc_thread_storage;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system (void)\n{\n  if (__gthread_active_p ())\n    /* Initialize the thread storage key */\n    return pthread_keycreate (&_objc_thread_storage, NULL);\n  else\n    return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system (void)\n{\n  if (__gthread_active_p ())\n    return 0;\n  else\n    return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  pthread_t new_thread_handle;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if (!(pthread_create (&new_thread_handle, pthread_attr_default,\n\t\t\t(void *) func, arg)))\n    {\n      /* ??? May not work! (64bit) */\n      thread_id = *(objc_thread_t *) &new_thread_handle;\n      pthread_detach (&new_thread_handle); /* Fully detach thread.  */\n    }\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority (int priority)\n{\n  int sys_priority = 0;\n\n  if (!__gthread_active_p ())\n    return -1;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n      break;\n    }\n\n  /* Change the priority.  */\n  if (pthread_setprio (pthread_self (), sys_priority) >= 0)\n    return 0;\n  else\n    /* Failed */\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority (void)\n{\n  int sys_priority;\n\n  if (__gthread_active_p ())\n    {\n      if ((sys_priority = pthread_getprio (pthread_self ())) >= 0)\n\t{\n\t  if (sys_priority >= PRI_FG_MIN_NP\n\t      && sys_priority <= PRI_FG_MAX_NP)\n\t    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\t  if (sys_priority >= PRI_BG_MIN_NP\n\t      && sys_priority <= PRI_BG_MAX_NP)\n\t    return OBJC_THREAD_BACKGROUND_PRIORITY;\n\t  return OBJC_THREAD_LOW_PRIORITY;\n\t}\n\n      /* Failed */\n      return -1;\n    }\n  else\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield (void)\n{\n  if (__gthread_active_p ())\n    pthread_yield ();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit (void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    pthread_exit (&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id (void)\n{\n  if (__gthread_active_p ())\n    {\n      pthread_t self = pthread_self ();\n\n      return (objc_thread_t) pthread_getunique_np (&self);\n    }\n  else\n    return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data (void *value)\n{\n  if (__gthread_active_p ())\n    return pthread_setspecific (_objc_thread_storage, value);\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data (void)\n{\n  void *value = NULL;\n\n  if (__gthread_active_p ())\n    {\n      if (!(pthread_getspecific (_objc_thread_storage, &value)))\n\treturn value;\n\n      return NULL;\n    }\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n\n      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend,\n\t\t\t      pthread_mutexattr_default))\n\t{\n\t  objc_free (mutex->backend);\n\t  mutex->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n\treturn -1;\n\n      objc_free (mutex->backend);\n      mutex->backend = NULL;\n    }\n\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock ((pthread_mutex_t *) mutex->backend);\n  else\n    return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 1)\n    return -1;\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n  else\n    return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    /* Unimplemented.  */\n    return -1;\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (__gthread_active_p ())\n    return pthread_once (once, func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return pthread_keycreate (key, dtor);\n}\n\nstatic inline int\n__gthread_key_delete (UNUSED (__gthread_key_t key))\n{\n  /* Operation is not supported.  */\n  return -1;\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  void *ptr;\n  if (pthread_getspecific (key, &ptr) == 0)\n    return ptr;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return pthread_setspecific (key, (void *) ptr);\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    pthread_mutex_init (mutex, pthread_mutexattr_default);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#undef UNUSED\n\n#endif\n#endif /* ! GCC_GTHR_DCE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@GNA": {"ttr": 5381, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_GNAT_H\n#define GCC_GTHR_GNAT_H\n\n/* Just provide compatibility for mutex handling.  */\n\ntypedef int __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT 0\n\nextern void __gnat_install_locks (void (*lock) (void), void (*unlock) (void));\nextern int __gthread_active_p (void);\nextern int __gthread_mutex_lock (__gthread_mutex_t *);\nextern int __gthread_mutex_unlock (__gthread_mutex_t *);\n\n#endif /* ! GCC_GTHR_GNAT_H */\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GTHR@POS": {"ttr": 5383, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2001, 2002, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_POSIX_H\n#define GCC_GTHR_POSIX_H\n\n/* POSIX threads specific definitions.\n   Easy, since the interface is just one-to-one mapping.  */\n\n#define __GTHREADS 1\n\n/* Some implementations of <pthread.h> require this to be defined.  */\n#ifndef _REENTRANT\n#define _REENTRANT 1\n#endif\n\n#include <pthread.h>\n#include <unistd.h>\n\ntypedef pthread_key_t __gthread_key_t;\ntypedef pthread_once_t __gthread_once_t;\ntypedef pthread_mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER\n#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak pthread_once\n#pragma weak pthread_key_create\n#pragma weak pthread_key_delete\n#pragma weak pthread_getspecific\n#pragma weak pthread_setspecific\n#pragma weak pthread_create\n\n#pragma weak pthread_mutex_lock\n#pragma weak pthread_mutex_trylock\n#pragma weak pthread_mutex_unlock\n\n#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)\n/* Objective-C.  */\n#pragma weak pthread_cond_broadcast\n#pragma weak pthread_cond_destroy\n#pragma weak pthread_cond_init\n#pragma weak pthread_cond_signal\n#pragma weak pthread_cond_wait\n#pragma weak pthread_exit\n#pragma weak pthread_mutex_init\n#pragma weak pthread_mutex_destroy\n#pragma weak pthread_self\n/* These really should be protected by _POSIX_PRIORITY_SCHEDULING, but\n   we use them inside a _POSIX_THREAD_PRIORITY_SCHEDULING block.  */\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n#pragma weak sched_get_priority_max\n#pragma weak sched_get_priority_min\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#pragma weak sched_yield\n#pragma weak pthread_attr_destroy\n#pragma weak pthread_attr_init\n#pragma weak pthread_attr_setdetachstate\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n#pragma weak pthread_getschedparam\n#pragma weak pthread_setschedparam\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n#endif /* _LIBOBJC || _LIBOBJC_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &pthread_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* This is the config.h file in libobjc/ */\n#include <config.h>\n\n#ifdef HAVE_SCHED_H\n# include <sched.h>\n#endif\n\n/* Key structure for maintaining thread specific storage */\nstatic pthread_key_t _objc_thread_storage;\nstatic pthread_attr_t _objc_thread_attribs;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system (void)\n{\n  if (__gthread_active_p ())\n    {\n      /* Initialize the thread storage key */\n      if (pthread_key_create (&_objc_thread_storage, NULL) == 0)\n\t{\n\t  /* The normal default detach state for threads is\n\t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n\t   * when you think they should.  */\n\t  if (pthread_attr_init (&_objc_thread_attribs) == 0\n\t      && pthread_attr_setdetachstate (&_objc_thread_attribs,\n\t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n\t    return 0;\n\t}\n    }\n\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system (void)\n{\n  if (__gthread_active_p ()\n      && pthread_key_delete (_objc_thread_storage) == 0\n      && pthread_attr_destroy (&_objc_thread_attribs) == 0)\n    return 0;\n\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  pthread_t new_thread_handle;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if (!(pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n    thread_id = (objc_thread_t) new_thread_handle;\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority (int priority)\n{\n  if (!__gthread_active_p ())\n    return -1;\n  else\n    {\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n      pthread_t thread_id = pthread_self ();\n      int policy;\n      struct sched_param params;\n      int priority_min, priority_max;\n\n      if (pthread_getschedparam (thread_id, &policy, &params) == 0)\n\t{\n\t  if ((priority_max = sched_get_priority_max (policy)) == -1)\n\t    return -1;\n\n\t  if ((priority_min = sched_get_priority_min (policy)) == -1)\n\t    return -1;\n\n\t  if (priority > priority_max)\n\t    priority = priority_max;\n\t  else if (priority < priority_min)\n\t    priority = priority_min;\n\t  params.sched_priority = priority;\n\n\t  /*\n\t   * The solaris 7 and several other man pages incorrectly state that\n\t   * this should be a pointer to policy but pthread.h is universally\n\t   * at odds with this.\n\t   */\n\t  if (pthread_setschedparam (thread_id, policy, &params) == 0)\n\t    return 0;\n\t}\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n      return -1;\n    }\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority (void)\n{\n#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n  if (__gthread_active_p ())\n    {\n      int policy;\n      struct sched_param params;\n\n      if (pthread_getschedparam (pthread_self (), &policy, &params) == 0)\n\treturn params.sched_priority;\n      else\n\treturn -1;\n    }\n  else\n#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield (void)\n{\n  if (__gthread_active_p ())\n    sched_yield ();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit (void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    pthread_exit (&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id (void)\n{\n  if (__gthread_active_p ())\n    return (objc_thread_t) pthread_self ();\n  else\n    return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data (void *value)\n{\n  if (__gthread_active_p ())\n    return pthread_setspecific (_objc_thread_storage, value);\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data (void)\n{\n  if (__gthread_active_p ())\n    return pthread_getspecific (_objc_thread_storage);\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n\n      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n\t{\n\t  objc_free (mutex->backend);\n\t  mutex->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    {\n      int count;\n\n      /*\n       * Posix Threads specifically require that the thread be unlocked\n       * for pthread_mutex_destroy to work.\n       */\n\n      do\n\t{\n\t  count = pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n\t  if (count < 0)\n\t    return -1;\n\t}\n      while (count);\n\n      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n\treturn -1;\n\n      objc_free (mutex->backend);\n      mutex->backend = NULL;\n    }\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n    {\n      return -1;\n    }\n\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      condition->backend = objc_malloc (sizeof (pthread_cond_t));\n\n      if (pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n\t{\n\t  objc_free (condition->backend);\n\t  condition->backend = NULL;\n\t  return -1;\n\t}\n    }\n\n  return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    {\n      if (pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n\treturn -1;\n\n      objc_free (condition->backend);\n      condition->backend = NULL;\n    }\n  return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_wait ((pthread_cond_t *) condition->backend,\n\t\t\t      (pthread_mutex_t *) mutex->backend);\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return pthread_cond_signal ((pthread_cond_t *) condition->backend);\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (__gthread_active_p ())\n    return pthread_once (once, func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return pthread_key_create (key, dtor);\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return pthread_key_delete (key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  return pthread_getspecific (key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return pthread_setspecific (key, ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return pthread_mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_POSIX_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@RTE": {"ttr": 5387, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* RTEMS threads compatibility routines for libgcc2 and libobjc.\n   by: Rosimildo da Silva( rdasilva@connecttel.com ) */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_RTEMS_H\n#define GCC_GTHR_RTEMS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define __GTHREADS 1\n\n#define __GTHREAD_ONCE_INIT  0\n#define __GTHREAD_MUTEX_INIT 0\n#define __GTHREAD_MUTEX_INIT_FUNCTION  rtems_gxx_mutex_init\n\n/* Avoid dependency on rtems specific headers.  */\ntypedef void *__gthread_key_t;\ntypedef int   __gthread_once_t;\ntypedef void *__gthread_mutex_t;\n\n/*\n * External functions provided by RTEMS. They are very similar to their POSIX\n * counterparts. A \"Wrapper API\" is being use to avoid dependency on any RTEMS\n * header files.\n */\n\n/* generic per task variables */\nextern int rtems_gxx_once (__gthread_once_t *once, void (*func) (void));\nextern int rtems_gxx_key_create (__gthread_key_t *key, void (*dtor) (void *));\nextern int rtems_gxx_key_delete (__gthread_key_t key);\nextern void *rtems_gxx_getspecific (__gthread_key_t key);\nextern int rtems_gxx_setspecific (__gthread_key_t key, const void *ptr);\n\n/* mutex support */\nextern void rtems_gxx_mutex_init (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_lock (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_trylock (__gthread_mutex_t *mutex);\nextern int rtems_gxx_mutex_unlock (__gthread_mutex_t *mutex);\n\n\n/* RTEMS threading is always active */\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n/* Wrapper calls */\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n   return rtems_gxx_once( once, func );\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return rtems_gxx_key_create( key, dtor );\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return rtems_gxx_key_delete (key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  return rtems_gxx_getspecific (key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return rtems_gxx_setspecific (key, ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_lock (mutex);\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_trylock (mutex);\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n    return rtems_gxx_mutex_unlock( mutex );\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ! GCC_GTHR_RTEMS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@SIN": {"ttr": 5389, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_SINGLE_H\n#define GCC_GTHR_SINGLE_H\n\n/* Just provide compatibility for mutex handling.  */\n\ntypedef int __gthread_mutex_t;\n\n#define __GTHREAD_MUTEX_INIT 0\n\n#ifdef __cplusplus\n#define UNUSED(x)\n#else\n#define UNUSED(x) x __attribute__((unused))\n#endif\n\n#ifdef _LIBOBJC\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system (void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system (void)\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach (void (* func)(void *), void * UNUSED(arg))\n{\n  /* No thread support available */\n  return NULL;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority (int UNUSED(priority))\n{\n  /* No thread support available */\n  return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority (void)\n{\n  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield (void)\n{\n  return;\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit (void)\n{\n  /* No thread support available */\n  /* Should we really exit the program */\n  /* exit (&__objc_thread_exit_status); */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id (void)\n{\n  /* No thread support, use 1.  */\n  return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data (void *value)\n{\n  thread_local_storage = value;\n  return 0;\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data (void)\n{\n  return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate (objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate (objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock (objc_mutex_t UNUSED(mutex))\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock (objc_mutex_t UNUSED(mutex))\n{\n  /* There can only be one thread, so we always get the lock */\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock (objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate (objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate (objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait (objc_condition_t UNUSED(condition),\n\t\t\t       objc_mutex_t UNUSED(mutex))\n{\n  return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast (objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal (objc_condition_t UNUSED(condition))\n{\n  return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t * UNUSED(mutex))\n{\n  return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#undef UNUSED\n\n#endif /* ! GCC_GTHR_SINGLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@SOL": {"ttr": 5391, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_SOLARIS_H\n#define GCC_GTHR_SOLARIS_H\n\n/* Solaris threads as found in Solaris 2.\u00dd456\u00a8.\n   Actually these are Unix International (UI) threads, but I don't\n   know if anyone else implements these.  */\n\n#define __GTHREADS 1\n\n#include <thread.h>\n#include <errno.h>\n\ntypedef thread_key_t __gthread_key_t;\ntypedef struct {\n  mutex_t mutex;\n  int once;\n} __gthread_once_t;\ntypedef mutex_t __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT { DEFAULTMUTEX, 0 }\n#define __GTHREAD_MUTEX_INIT DEFAULTMUTEX\n\n#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n\n#pragma weak thr_keycreate\n#pragma weak thr_getspecific\n#pragma weak thr_setspecific\n#pragma weak thr_create\n\n#pragma weak mutex_lock\n#pragma weak mutex_trylock\n#pragma weak mutex_unlock\n\n#ifdef _LIBOBJC\n#pragma weak thr_exit\n#pragma weak thr_keycreate\n#pragma weak thr_getprio\n#pragma weak thr_self\n#pragma weak thr_setprio\n#pragma weak thr_yield\n\n#pragma weak cond_init\n#pragma weak cond_destroy\n#pragma weak cond_wait\n#pragma weak cond_broadcast\n#pragma weak cond_signal\n\n#pragma weak mutex_init\n#pragma weak mutex_destroy\n#endif\n\n/* This will not actually work in Solaris 2.5, since libc contains\n   dummy symbols of all thr_* routines.  */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  static void *const __gthread_active_ptr = (void *) &thr_create;\n  return __gthread_active_ptr != 0;\n}\n\n#else /* not SUPPORTS_WEAK */\n\nstatic inline int\n__gthread_active_p (void)\n{\n  return 1;\n}\n\n#endif /* SUPPORTS_WEAK */\n\n#ifdef _LIBOBJC\n\n/* Key structure for maintaining thread specific storage */\nstatic thread_key_t _objc_thread_storage;\n\n/* Thread local storage for a single thread */\nstatic void *thread_local_storage = NULL;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nstatic inline int\n__gthread_objc_init_thread_system (void)\n{\n  /* Initialize the thread storage key */\n  if (__gthread_active_p ()\n      && thr_keycreate (&_objc_thread_storage, NULL) == 0)\n    return 0;\n\n  return -1;\n}\n\n/* Close the threads subsystem.  */\nstatic inline int\n__gthread_objc_close_thread_system (void)\n{\n  if (__gthread_active_p ())\n    return 0;\n  else\n    return -1;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n{\n  objc_thread_t thread_id;\n  thread_t new_thread_id = 0;\n\n  if (!__gthread_active_p ())\n    return NULL;\n\n  if (thr_create (NULL, 0, (void *) func, arg,\n\t\t  THR_DETACHED | THR_NEW_LWP,\n\t\t  &new_thread_id) == 0)\n    thread_id = *(objc_thread_t *) &new_thread_id;\n  else\n    thread_id = NULL;\n\n  return thread_id;\n}\n\n/* Set the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_set_priority (int priority)\n{\n  int sys_priority = 0;\n\n  if (!__gthread_active_p ())\n    return -1;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = 300;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = 200;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = 1000;\n      break;\n    }\n\n  /* Change priority */\n  if (thr_setprio (thr_self (), sys_priority) == 0)\n    return 0;\n  else\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nstatic inline int\n__gthread_objc_thread_get_priority (void)\n{\n  int sys_priority;\n\n  if (!__gthread_active_p ())\n    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\n  if (thr_getprio (thr_self (), &sys_priority) == 0)\n    {\n      if (sys_priority >= 250)\n\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n      else if (sys_priority >= 150)\n\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n      return OBJC_THREAD_LOW_PRIORITY;\n    }\n\n  /* Couldn't get priority.  */\n  return -1;\n}\n\n/* Yield our process time to another thread.  */\nstatic inline void\n__gthread_objc_thread_yield (void)\n{\n  if (__gthread_active_p ())\n    thr_yield ();\n}\n\n/* Terminate the current thread.  */\nstatic inline int\n__gthread_objc_thread_exit (void)\n{\n  if (__gthread_active_p ())\n    /* exit the thread */\n    thr_exit (&__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nstatic inline objc_thread_t\n__gthread_objc_thread_id (void)\n{\n  if (__gthread_active_p ())\n    return (objc_thread_t) thr_self ();\n  else\n    return (objc_thread_t) 1;\n}\n\n/* Sets the thread's local storage pointer.  */\nstatic inline int\n__gthread_objc_thread_set_data (void *value)\n{\n  if (__gthread_active_p ())\n    {\n      if (thr_setspecific (_objc_thread_storage, value) == 0)\n\treturn 0;\n      else\n\treturn -1;\n    }\n  else\n    {\n      thread_local_storage = value;\n      return 0;\n    }\n}\n\n/* Returns the thread's local storage pointer.  */\nstatic inline void *\n__gthread_objc_thread_get_data (void)\n{\n  void *value = NULL;\n\n  if (__gthread_active_p ())\n    {\n      if (thr_getspecific (_objc_thread_storage, &value) == 0)\n\treturn value;\n      else\n\treturn NULL;\n    }\n  else\n    return thread_local_storage;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_init ((mutex_t *) (&(mutex->backend)), USYNC_THREAD, 0))\n    return -1;\n\n  return 0;\n}\n\n/* Deallocate a mutex.  */\nstatic inline int\n__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    mutex_destroy ((mutex_t *) (&(mutex->backend)));\n\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_lock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_lock ((mutex_t *) (&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nstatic inline int\n__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_trylock ((mutex_t *) (&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Unlock the mutex */\nstatic inline int\n__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n{\n  if (__gthread_active_p ()\n      && mutex_unlock ((mutex_t *) (&(mutex->backend))) != 0)\n    return -1;\n\n  return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nstatic inline int\n__gthread_objc_condition_allocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_init ((cond_t *) (&(condition->backend)), USYNC_THREAD,\n\t\t      NULL);\n  else\n    return 0;\n}\n\n/* Deallocate a condition.  */\nstatic inline int\n__gthread_objc_condition_deallocate (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_destroy ((cond_t *) (&(condition->backend)));\n  else\n    return 0;\n}\n\n/* Wait on the condition */\nstatic inline int\n__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n{\n  if (__gthread_active_p ())\n    return cond_wait ((cond_t *) (&(condition->backend)),\n\t\t      (mutex_t *) (&(mutex->backend)));\n  else\n    return 0;\n}\n\n/* Wake up all threads waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_broadcast (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_broadcast ((cond_t *) (&(condition->backend)));\n  else\n    return 0;\n}\n\n/* Wake up one thread waiting on this condition.  */\nstatic inline int\n__gthread_objc_condition_signal (objc_condition_t condition)\n{\n  if (__gthread_active_p ())\n    return cond_signal ((cond_t *) (&(condition->backend)));\n  else\n    return 0;\n}\n\n#else /* _LIBOBJC */\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (! __gthread_active_p ())\n    return -1;\n\n  if (once == 0 || func == 0)\n    return EINVAL;\n\n  if (once->once == 0)\n    {\n      int status = mutex_lock (&once->mutex);\n      if (status != 0)\n\treturn status;\n      if (once->once == 0)\n\t{\n\t  (*func) ();\n\t  once->once++;\n\t}\n      mutex_unlock (&once->mutex);\n    }\n  return 0;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  /* Solaris 2.5 contains thr_* routines no-op in libc, so test if we actually\n     got a reasonable key value, and if not, fail.  */\n  *key = -1;\n  if (thr_keycreate (key, dtor) != 0 || *key == -1)\n    return -1;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  /* Not possible.  */\n  return -1;\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  void *ptr;\n  if (thr_getspecific (key, &ptr) == 0)\n    return ptr;\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return thr_setspecific (key, (void *) ptr);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_SOLARIS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@VXW": {"ttr": 5635, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc for VxWorks.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n   Contributed by Mike Stump <mrs@wrs.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_VXWORKS_H\n#define GCC_GTHR_VXWORKS_H\n\n#ifdef _LIBOBJC\n\n/* libobjc requires the optional pthreads component.  */\n#include \"gthr-posix.h\"\n\n#else\n\n#define __GTHREADS 1\n#define __gthread_active_p() 1\n\n/* Mutexes are easy, except that they need to be initialized at runtime.  */\n\n#include <semLib.h>\n\ntypedef SEM_ID __gthread_mutex_t;\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  *mutex = semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE | SEM_DELETE_SAFE);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  return semTake (*mutex, WAIT_FOREVER);\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  return semTake (*mutex, NO_WAIT);\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  return semGive (*mutex);\n}\n\n/* pthread_once is complicated enough that it's implemented\n   out-of-line.  See config/vxlib.c.  */\n\ntypedef struct\n{\n  volatile unsigned char busy;\n  volatile unsigned char done;\n}\n__gthread_once_t;\n\n#define __GTHREAD_ONCE_INIT { 0, 0 }\n\nextern int __gthread_once (__gthread_once_t *once, void (*func)(void));\n\n/* Thread-specific data requires a great deal of effort, since VxWorks\n   is not really set up for it.  See config/vxlib.c for the gory\n   details.  All the TSD routines are sufficiently complex that they\n   need to be implemented out of line.  */\n\ntypedef unsigned int __gthread_key_t;\n\nextern int __gthread_key_create (__gthread_key_t *keyp, void (*dtor)(void *));\nextern int __gthread_key_delete (__gthread_key_t key);\n\nextern void *__gthread_getspecific (__gthread_key_t key);\nextern int __gthread_setspecific (__gthread_key_t key, void *ptr);\n\n#endif /* not _LIBOBJC */\n\n#endif /* gthr-vxworks.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTHR@WIN": {"ttr": 5637, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Threads compatibility routines for libgcc2 and libobjc.  */\n/* Compile this one with gcc.  */\n/* Copyright (C) 1999, 2000, 2002, 2003, 2004  Free Software Foundation, Inc.\n   Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_GTHR_WIN32_H\n#define GCC_GTHR_WIN32_H\n\n/* Windows32 threads specific definitions. The windows32 threading model\n   does not map well into pthread-inspired gcc's threading model, and so\n   there are caveats one needs to be aware of.\n\n   1. The destructor supplied to __gthread_key_create is ignored for\n      generic x86-win32 ports. This will certainly cause memory leaks\n      due to unreclaimed eh contexts (sizeof (eh_context) is at least\n      24 bytes for x86 currently).\n\n      This memory leak may be significant for long-running applications\n      that make heavy use of C++ EH.\n\n      However, Mingw runtime (version 0.3 or newer) provides a mechanism\n      to emulate pthreads key dtors; the runtime provides a special DLL,\n      linked in if -mthreads option is specified, that runs the dtors in\n      the reverse order of registration when each thread exits. If\n      -mthreads option is not given, a stub is linked in instead of the\n      DLL, which results in memory leak. Other x86-win32 ports can use\n      the same technique of course to avoid the leak.\n\n   2. The error codes returned are non-POSIX like, and cast into ints.\n      This may cause incorrect error return due to truncation values on\n      hw where sizeof (DWORD) > sizeof (int).\n\n   3. We are currently using a special mutex instead of the Critical\n      Sections, since Win9x does not support TryEnterCriticalSection\n      (while NT does).\n\n   The basic framework should work well enough. In the long term, GCC\n   needs to use Structured Exception Handling on Windows32.  */\n\n#define __GTHREADS 1\n\n#include <errno.h>\n#ifdef __MINGW32__\n#include <_mingw.h>\n#endif\n\n#ifdef _LIBOBJC\n\n/* This is necessary to prevent windef.h (included from windows.h) from\n   defining it's own BOOL as a typedef.  */\n#ifndef __OBJC__\n#define __OBJC__\n#endif\n#include <windows.h>\n/* Now undef the windows BOOL.  */\n#undef BOOL\n\n/* Key structure for maintaining thread specific storage */\nstatic DWORD\t__gthread_objc_data_tls = (DWORD) -1;\n\n/* Backend initialization functions */\n\n/* Initialize the threads subsystem.  */\nint\n__gthread_objc_init_thread_system (void)\n{\n  /* Initialize the thread storage key */\n  if ((__gthread_objc_data_tls = TlsAlloc ()) != (DWORD) -1)\n    return 0;\n  else\n    return -1;\n}\n\n/* Close the threads subsystem.  */\nint\n__gthread_objc_close_thread_system (void)\n{\n  if (__gthread_objc_data_tls != (DWORD) -1)\n    TlsFree (__gthread_objc_data_tls);\n  return 0;\n}\n\n/* Backend thread functions */\n\n/* Create a new thread of execution.  */\nobjc_thread_t\n__gthread_objc_thread_detach (void (*func)(void *arg), void *arg)\n{\n  DWORD\tthread_id = 0;\n  HANDLE win32_handle;\n\n  if (!(win32_handle = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) func,\n\t\t\t\t     arg, 0, &thread_id)))\n    thread_id = 0;\n\n  return (objc_thread_t) thread_id;\n}\n\n/* Set the current thread's priority.  */\nint\n__gthread_objc_thread_set_priority (int priority)\n{\n  int sys_priority = 0;\n\n  switch (priority)\n    {\n    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n      sys_priority = THREAD_PRIORITY_NORMAL;\n      break;\n    default:\n    case OBJC_THREAD_BACKGROUND_PRIORITY:\n      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n      break;\n    case OBJC_THREAD_LOW_PRIORITY:\n      sys_priority = THREAD_PRIORITY_LOWEST;\n      break;\n    }\n\n  /* Change priority */\n  if (SetThreadPriority (GetCurrentThread (), sys_priority))\n    return 0;\n  else\n    return -1;\n}\n\n/* Return the current thread's priority.  */\nint\n__gthread_objc_thread_get_priority (void)\n{\n  int sys_priority;\n\n  sys_priority = GetThreadPriority (GetCurrentThread ());\n\n  switch (sys_priority)\n    {\n    case THREAD_PRIORITY_HIGHEST:\n    case THREAD_PRIORITY_TIME_CRITICAL:\n    case THREAD_PRIORITY_ABOVE_NORMAL:\n    case THREAD_PRIORITY_NORMAL:\n      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n\n    default:\n    case THREAD_PRIORITY_BELOW_NORMAL:\n      return OBJC_THREAD_BACKGROUND_PRIORITY;\n\n    case THREAD_PRIORITY_IDLE:\n    case THREAD_PRIORITY_LOWEST:\n      return OBJC_THREAD_LOW_PRIORITY;\n    }\n\n  /* Couldn't get priority.  */\n  return -1;\n}\n\n/* Yield our process time to another thread.  */\nvoid\n__gthread_objc_thread_yield (void)\n{\n  Sleep (0);\n}\n\n/* Terminate the current thread.  */\nint\n__gthread_objc_thread_exit (void)\n{\n  /* exit the thread */\n  ExitThread (__objc_thread_exit_status);\n\n  /* Failed if we reached here */\n  return -1;\n}\n\n/* Returns an integer value which uniquely describes a thread.  */\nobjc_thread_t\n__gthread_objc_thread_id (void)\n{\n  return (objc_thread_t) GetCurrentThreadId ();\n}\n\n/* Sets the thread's local storage pointer.  */\nint\n__gthread_objc_thread_set_data (void *value)\n{\n  if (TlsSetValue (__gthread_objc_data_tls, value))\n    return 0;\n  else\n    return -1;\n}\n\n/* Returns the thread's local storage pointer.  */\nvoid *\n__gthread_objc_thread_get_data (void)\n{\n  DWORD lasterror;\n  void *ptr;\n\n  lasterror = GetLastError ();\n\n  ptr = TlsGetValue (__gthread_objc_data_tls);          /* Return thread data.  */\n\n  SetLastError (lasterror);\n\n  return ptr;\n}\n\n/* Backend mutex functions */\n\n/* Allocate a mutex.  */\nint\n__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n{\n  if ((mutex->backend = (void *) CreateMutex (NULL, 0, NULL)) == NULL)\n    return -1;\n  else\n    return 0;\n}\n\n/* Deallocate a mutex.  */\nint\n__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n{\n  CloseHandle ((HANDLE) (mutex->backend));\n  return 0;\n}\n\n/* Grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_lock (objc_mutex_t mutex)\n{\n  int status;\n\n  status = WaitForSingleObject ((HANDLE) (mutex->backend), INFINITE);\n  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n    return -1;\n  else\n    return 0;\n}\n\n/* Try to grab a lock on a mutex.  */\nint\n__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n{\n  int status;\n\n  status = WaitForSingleObject ((HANDLE) (mutex->backend), 0);\n  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n    return -1;\n  else\n    return 0;\n}\n\n/* Unlock the mutex */\nint\n__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n{\n  if (ReleaseMutex ((HANDLE) (mutex->backend)) == 0)\n    return -1;\n  else\n    return 0;\n}\n\n/* Backend condition mutex functions */\n\n/* Allocate a condition.  */\nint\n__gthread_objc_condition_allocate (objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Deallocate a condition.  */\nint\n__gthread_objc_condition_deallocate (objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wait on the condition */\nint\n__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wake up all threads waiting on this condition.  */\nint\n__gthread_objc_condition_broadcast (objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n/* Wake up one thread waiting on this condition.  */\nint\n__gthread_objc_condition_signal (objc_condition_t condition)\n{\n  /* Unimplemented.  */\n  return -1;\n}\n\n#else /* _LIBOBJC */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef unsigned long __gthread_key_t;\n\ntypedef struct {\n  int done;\n  long started;\n} __gthread_once_t;\n\ntypedef struct {\n  long counter;\n  void *sema;\n} __gthread_mutex_t;\n\n#define __GTHREAD_ONCE_INIT {0, -1}\n#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n#define __GTHREAD_MUTEX_INIT_DEFAULT {-1, 0}\n\n#if __MINGW32_MAJOR_VERSION >= 1 || \\\n  (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n#define MINGW32_SUPPORTS_MT_EH 1\n/* Mingw runtime >= v0.3 provides a magic variable that is set to nonzero\n   if -mthreads option was specified, or 0 otherwise. This is to get around\n   the lack of weak symbols in PE-COFF.  */\nextern int _CRT_MT;\nextern int __mingwthr_key_dtor (unsigned long, void (*) (void *));\n#endif /* __MINGW32__ version */\n\n#ifdef __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n\nstatic inline long\n__gthr_i486_lock_cmp_xchg(long *dest, long xchg, long comperand)\n{\n  long result;\n  __asm__ __volatile__ (\"\\n\\\n\tlock\\n\\\n\tcmpxchg{l} {%4, %1|%1, %4}\\n\"\n\t: \"=a\" (result), \"=m\" (*dest)\n\t: \"0\" (comperand), \"m\" (*dest), \"r\" (xchg)\n\t: \"cc\");\n  return result;\n}\n\n#define __GTHR_W32_InterlockedCompareExchange __gthr_i486_lock_cmp_xchg\n\n#else  /* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */\n\n#define __GTHR_W32_InterlockedCompareExchange InterlockedCompareExchange\n\n#endif /* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */\n\nstatic inline int\n__gthread_active_p (void)\n{\n#ifdef MINGW32_SUPPORTS_MT_EH\n  return _CRT_MT;\n#else\n  return 1;\n#endif\n}\n\n#if __GTHREAD_HIDE_WIN32API\n\n/* The implementations are in config/i386/gthr-win32.c in libgcc.a.\n   Only stubs are exposed to avoid polluting the C++ namespace with\n   windows api definitions.  */\n\nextern int __gthr_win32_once (__gthread_once_t *, void (*) (void));\nextern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));\nextern int __gthr_win32_key_delete (__gthread_key_t);\nextern void * __gthr_win32_getspecific (__gthread_key_t);\nextern int __gthr_win32_setspecific (__gthread_key_t, const void *);\nextern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);\nextern int __gthr_win32_mutex_lock (__gthread_mutex_t *);\nextern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);\nextern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (__gthread_active_p ())\n    return __gthr_win32_once (once, func);\n  else\n    return -1;\n}\n\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  return __gthr_win32_key_create (key, dtor);\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return __gthr_win32_key_delete (key);\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  return __gthr_win32_getspecific (key);\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return __gthr_win32_setspecific (key, ptr);\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  __gthr_win32_mutex_init_function (mutex);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return __gthr_win32_mutex_lock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return __gthr_win32_mutex_trylock (mutex);\n  else\n    return 0;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    return __gthr_win32_mutex_unlock (mutex);\n  else\n    return 0;\n}\n\n#else /* ! __GTHREAD_HIDE_WIN32API */\n\n#include <windows.h>\n#include <errno.h>\n\nstatic inline int\n__gthread_once (__gthread_once_t *once, void (*func) (void))\n{\n  if (! __gthread_active_p ())\n    return -1;\n  else if (once == NULL || func == NULL)\n    return EINVAL;\n\n  if (! once->done)\n    {\n      if (InterlockedIncrement (&(once->started)) == 0)\n\t{\n\t  (*func) ();\n\t  once->done = TRUE;\n\t}\n      else\n\t{\n\t  /* Another thread is currently executing the code, so wait for it\n\t     to finish; yield the CPU in the meantime.  If performance\n\t     does become an issue, the solution is to use an Event that\n\t     we wait on here (and set above), but that implies a place to\n\t     create the event before this routine is called.  */\n\t  while (! once->done)\n\t    Sleep (0);\n\t}\n    }\n\n  return 0;\n}\n\n/* Windows32 thread local keys don't support destructors; this leads to\n   leaks, especially in threaded applications making extensive use of\n   C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\nstatic inline int\n__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n{\n  int status = 0;\n  DWORD tls_index = TlsAlloc ();\n  if (tls_index != 0xFFFFFFFF)\n    {\n      *key = tls_index;\n#ifdef MINGW32_SUPPORTS_MT_EH\n      /* Mingw runtime will run the dtors in reverse order for each thread\n         when the thread exits.  */\n      status = __mingwthr_key_dtor (*key, dtor);\n#endif\n    }\n  else\n    status = (int) GetLastError ();\n  return status;\n}\n\nstatic inline int\n__gthread_key_delete (__gthread_key_t key)\n{\n  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n}\n\nstatic inline void *\n__gthread_getspecific (__gthread_key_t key)\n{\n  DWORD lasterror;\n  void *ptr;\n\n  lasterror = GetLastError ();\n\n  ptr = TlsGetValue (key);\n\n  SetLastError (lasterror);\n\n  return ptr;\n}\n\nstatic inline int\n__gthread_setspecific (__gthread_key_t key, const void *ptr)\n{\n  return (TlsSetValue (key, (void*) ptr) != 0) ? 0 : (int) GetLastError ();\n}\n\nstatic inline void\n__gthread_mutex_init_function (__gthread_mutex_t *mutex)\n{\n  mutex->counter = -1;\n  mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n}\n\nstatic inline int\n__gthread_mutex_lock (__gthread_mutex_t *mutex)\n{\n  int status = 0;\n\n  if (__gthread_active_p ())\n    {\n      if (InterlockedIncrement (&mutex->counter) == 0 ||\n\t  WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n\tstatus = 0;\n      else\n\t{\n\t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n\t     some best-effort cleanup here.  */\n\t  InterlockedDecrement (&mutex->counter);\n\t  status = 1;\n\t}\n    }\n  return status;\n}\n\nstatic inline int\n__gthread_mutex_trylock (__gthread_mutex_t *mutex)\n{\n  int status = 0;\n\n  if (__gthread_active_p ())\n    {\n      if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n\tstatus = 0;\n      else\n\tstatus = 1;\n    }\n  return status;\n}\n\nstatic inline int\n__gthread_mutex_unlock (__gthread_mutex_t *mutex)\n{\n  if (__gthread_active_p ())\n    {\n      if (InterlockedDecrement (&mutex->counter) >= 0)\n\treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n    }\n  return 0;\n}\n\n#endif /*  __GTHREAD_HIDE_WIN32API */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _LIBOBJC */\n\n#endif /* ! GCC_GTHR_WIN32_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTYP@GEN": {"ttr": 5643, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file is machine generated.  Do not edit.  */\nstatic const char *const srcdir =\n\".\"\n;\nstatic const char *const lang_files\u00dd\u00a8 = {\n\"./c-lang.c\",\n\"./c-parse.in\",\n\"./c-tree.h\",\n\"./c-decl.c\",\n\"./c-common.c\",\n\"./c-common.h\",\n\"./c-pragma.c\",\n\"./c-objc-common.c\",\nNULL};\nstatic const char *const langs_for_lang_files\u00dd\u00a8 = {\n\"c\",\n\"c\",\n\"c\",\n\"c\",\n\"c\",\n\"c\",\n\"c\",\n\"c\",\nNULL};\nstatic const char *const all_files\u00dd\u00a8 = {\n\"./input.h\",\n\"./coretypes.h\",\n\"./cpplib.h\",\n\"auto-host.h\",\n\"./../include/ansidecl.h\",\n\"./config/i370/mvspdp.h\",\n\"./config/i370/i370.h\",\n\"./defaults.h\",\n\"./../include/hashtab.h\",\n\"./../include/splay-tree.h\",\n\"./bitmap.h\",\n\"./coverage.c\",\n\"./function.h\",\n\"./rtl.h\",\n\"./optabs.h\",\n\"./tree.h\",\n\"./libfuncs.h\",\n\"./hashtable.h\",\n\"./real.h\",\n\"./varray.h\",\n\"./insn-addr.h\",\n\"./cselib.h\",\n\"./basic-block.h\",\n\"./cgraph.h\",\n\"./c-common.h\",\n\"./c-tree.h\",\n\"./alias.c\",\n\"./bitmap.c\",\n\"./cselib.c\",\n\"./cgraph.c\",\n\"./dbxout.c\",\n\"./dwarf2out.c\",\n\"./dwarf2asm.c\",\n\"./dojump.c\",\n\"./emit-rtl.c\",\n\"./except.c\",\n\"./explow.c\",\n\"./expr.c\",\n\"./fold-const.c\",\n\"./function.c\",\n\"./gcse.c\",\n\"./integrate.c\",\n\"./lists.c\",\n\"./optabs.c\",\n\"./profile.c\",\n\"./ra-build.c\",\n\"./regclass.c\",\n\"./reg-stack.c\",\n\"./cfglayout.c\",\n\"./langhooks.c\",\n\"./sdbout.c\",\n\"./stmt.c\",\n\"./stor-layout.c\",\n\"./stringpool.c\",\n\"./tree.c\",\n\"./varasm.c\",\n\"./config/i370/i370.c\",\n\"./c-lang.c\",\n\"./c-parse.in\",\n\"./c-tree.h\",\n\"./c-decl.c\",\n\"./c-common.c\",\n\"./c-common.h\",\n\"./c-pragma.c\",\n\"./c-objc-common.c\",\n NULL};\nstatic const char *const lang_dir_names\u00dd\u00a8 = { \"c\",\nNULL};\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GTYPE@C": {"ttr": 5645, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for c.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\nextern const struct ggc_root_tab gt_ggc_r_gt_coverage_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gtype_desc_c\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_alias_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_cselib_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_cgraph_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_dbxout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_dwarf2out_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_dwarf2asm_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_dojump_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_emit_rtl_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_except_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_explow_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_expr_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_fold_const_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_function_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_gcse_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_integrate_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_optabs_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_ra_build_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_regclass_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_reg_stack_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_cfglayout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_langhooks_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_sdbout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_stor_layout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_stringpool_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_tree_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_varasm_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_c_parse_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_c_decl_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_c_common_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_r_gt_c_pragma_h\u00dd\u00a8;\nconst struct ggc_root_tab * const gt_ggc_rtab\u00dd\u00a8 = {\n  gt_ggc_r_gt_coverage_h,\n  gt_ggc_r_gtype_desc_c,\n  gt_ggc_r_gt_alias_h,\n  gt_ggc_r_gt_cselib_h,\n  gt_ggc_r_gt_cgraph_h,\n  gt_ggc_r_gt_dbxout_h,\n  gt_ggc_r_gt_dwarf2out_h,\n  gt_ggc_r_gt_dwarf2asm_h,\n  gt_ggc_r_gt_dojump_h,\n  gt_ggc_r_gt_emit_rtl_h,\n  gt_ggc_r_gt_except_h,\n  gt_ggc_r_gt_explow_h,\n  gt_ggc_r_gt_expr_h,\n  gt_ggc_r_gt_fold_const_h,\n  gt_ggc_r_gt_function_h,\n  gt_ggc_r_gt_gcse_h,\n  gt_ggc_r_gt_integrate_h,\n  gt_ggc_r_gt_optabs_h,\n  gt_ggc_r_gt_ra_build_h,\n  gt_ggc_r_gt_regclass_h,\n  gt_ggc_r_gt_reg_stack_h,\n  gt_ggc_r_gt_cfglayout_h,\n  gt_ggc_r_gt_langhooks_h,\n  gt_ggc_r_gt_sdbout_h,\n  gt_ggc_r_gt_stor_layout_h,\n  gt_ggc_r_gt_stringpool_h,\n  gt_ggc_r_gt_tree_h,\n  gt_ggc_r_gt_varasm_h,\n  gt_ggc_r_gt_c_parse_h,\n  gt_ggc_r_gt_c_decl_h,\n  gt_ggc_r_gt_c_common_h,\n  gt_ggc_r_gt_c_pragma_h,\n  NULL\n};\nextern const struct ggc_root_tab gt_ggc_rd_gt_alias_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_rd_gt_bitmap_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_rd_gt_cselib_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_rd_gt_emit_rtl_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_rd_gt_lists_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_ggc_rd_gt_c_decl_h\u00dd\u00a8;\nconst struct ggc_root_tab * const gt_ggc_deletable_rtab\u00dd\u00a8 = {\n  gt_ggc_rd_gt_alias_h,\n  gt_ggc_rd_gt_bitmap_h,\n  gt_ggc_rd_gt_cselib_h,\n  gt_ggc_rd_gt_emit_rtl_h,\n  gt_ggc_rd_gt_lists_h,\n  gt_ggc_rd_gt_c_decl_h,\n  NULL\n};\nextern const struct ggc_cache_tab gt_ggc_rc_gt_emit_rtl_h\u00dd\u00a8;\nextern const struct ggc_cache_tab gt_ggc_rc_gt_fold_const_h\u00dd\u00a8;\nextern const struct ggc_cache_tab gt_ggc_rc_gt_tree_h\u00dd\u00a8;\nconst struct ggc_cache_tab * const gt_ggc_cache_rtab\u00dd\u00a8 = {\n  gt_ggc_rc_gt_emit_rtl_h,\n  gt_ggc_rc_gt_fold_const_h,\n  gt_ggc_rc_gt_tree_h,\n  NULL\n};\nextern const struct ggc_root_tab gt_pch_rc_gt_emit_rtl_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rc_gt_fold_const_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rc_gt_tree_h\u00dd\u00a8;\nconst struct ggc_root_tab * const gt_pch_cache_rtab\u00dd\u00a8 = {\n  gt_pch_rc_gt_emit_rtl_h,\n  gt_pch_rc_gt_fold_const_h,\n  gt_pch_rc_gt_tree_h,\n  NULL\n};\nextern const struct ggc_root_tab gt_pch_rs_gtype_desc_c\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_alias_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_dbxout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_dwarf2out_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_dwarf2asm_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_emit_rtl_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_except_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_function_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_langhooks_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_sdbout_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_tree_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_varasm_h\u00dd\u00a8;\nextern const struct ggc_root_tab gt_pch_rs_gt_c_decl_h\u00dd\u00a8;\nconst struct ggc_root_tab * const gt_pch_scalar_rtab\u00dd\u00a8 = {\n  gt_pch_rs_gtype_desc_c,\n  gt_pch_rs_gt_alias_h,\n  gt_pch_rs_gt_dbxout_h,\n  gt_pch_rs_gt_dwarf2out_h,\n  gt_pch_rs_gt_dwarf2asm_h,\n  gt_pch_rs_gt_emit_rtl_h,\n  gt_pch_rs_gt_except_h,\n  gt_pch_rs_gt_function_h,\n  gt_pch_rs_gt_langhooks_h,\n  gt_pch_rs_gt_sdbout_h,\n  gt_pch_rs_gt_tree_h,\n  gt_pch_rs_gt_varasm_h,\n  gt_pch_rs_gt_c_decl_h,\n  NULL\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GTYPE@DE": {"ttr": 5648, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Type information for GCC.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* This file is machine generated.  Do not edit.  */\n\n/* Enumeration of types known.  */\nenum gt_types_enum {\n gt_ggc_e_11align_stack,\n gt_ggc_e_7c_scope,\n gt_ggc_e_15output_def_pair,\n gt_ggc_e_24constant_descriptor_tree,\n gt_ggc_e_14in_named_entry,\n gt_ggc_e_13pool_constant,\n gt_ggc_e_23constant_descriptor_rtx,\n gt_ggc_e_9type_hash,\n gt_ggc_e_16string_pool_data,\n gt_ggc_e_10goto_fixup,\n gt_ggc_e_11label_chain,\n gt_ggc_e_7nesting,\n gt_ggc_e_9case_node,\n gt_ggc_e_9eh_region,\n gt_ggc_e_13ehl_map_entry,\n gt_ggc_e_16limbo_die_struct,\n gt_ggc_e_16dw_ranges_struct,\n gt_ggc_e_14pubname_struct,\n gt_ggc_e_28dw_separate_line_info_struct,\n gt_ggc_e_19dw_line_info_struct,\n gt_ggc_e_14dw_attr_struct,\n gt_ggc_e_18dw_loc_list_struct,\n gt_ggc_e_15queued_reg_save,\n gt_ggc_e_20indirect_string_node,\n gt_ggc_e_19dw_loc_descr_struct,\n gt_ggc_e_13dw_fde_struct,\n gt_ggc_e_13dw_cfi_struct,\n gt_ggc_e_8typeinfo,\n gt_ggc_e_15alias_set_entry,\n gt_ggc_e_18sorted_fields_type,\n gt_ggc_e_19cgraph_varpool_node,\n gt_ggc_e_11cgraph_edge,\n gt_ggc_e_11cgraph_node,\n gt_ggc_e_12elt_loc_list,\n gt_ggc_e_17cselib_val_struct,\n gt_ggc_e_15varray_head_tag,\n gt_ggc_e_8elt_list,\n gt_ggc_e_12reg_info_def,\n gt_ggc_e_14lang_tree_node,\n gt_ggc_e_9lang_decl,\n gt_ggc_e_9lang_type,\n gt_ggc_e_10die_struct,\n gt_ggc_e_10real_value,\n gt_ggc_e_13convert_optab,\n gt_ggc_e_5optab,\n gt_ggc_e_15basic_block_def,\n gt_ggc_e_9reg_attrs,\n gt_ggc_e_9mem_attrs,\n gt_ggc_e_17language_function,\n gt_ggc_e_9temp_slot,\n gt_ggc_e_20initial_value_struct,\n gt_ggc_e_13varasm_status,\n gt_ggc_e_11stmt_status,\n gt_ggc_e_9eh_status,\n gt_ggc_e_8function,\n gt_ggc_e_11expr_status,\n gt_ggc_e_11emit_status,\n gt_ggc_e_14sequence_stack,\n gt_ggc_e_14var_refs_queue,\n gt_ggc_e_15bitmap_head_def,\n gt_ggc_e_18bitmap_element_def,\n gt_ggc_e_6answer,\n gt_ggc_e_9cpp_macro,\n gt_ggc_e_9tree_node,\n gt_ggc_e_9rtvec_def,\n gt_ggc_e_7rtx_def,\n gt_e_II17splay_tree_node_s,\n gt_e_SP9tree_node17splay_tree_node_s,\n gt_e_P15output_def_pair15varray_head_tag,\n gt_e_P24constant_descriptor_tree4htab,\n gt_e_P14in_named_entry4htab,\n gt_e_P9type_hash4htab,\n gt_e_P13ehl_map_entry4htab,\n gt_e_P9tree_node4htab,\n gt_e_P9reg_attrs4htab,\n gt_e_P9mem_attrs4htab,\n gt_e_P7rtx_def4htab,\n gt_e_SP9tree_node12splay_tree_s,\n gt_e_P20indirect_string_node4htab,\n gt_e_P19cgraph_varpool_node4htab,\n gt_e_P11cgraph_node4htab,\n gt_e_P17cselib_val_struct4htab,\n gt_e_P15alias_set_entry15varray_head_tag,\n gt_e_II12splay_tree_s,\n gt_types_enum_last\n};\n\n/* GC marker procedures.  */\n#define gt_ggc_m_11align_stack(X) do { \\\n  if (X != NULL) gt_ggc_mx_align_stack (X);\\\n  } while (0)\nextern void gt_ggc_mx_align_stack (void *);\n#define gt_ggc_m_7c_scope(X) do { \\\n  if (X != NULL) gt_ggc_mx_c_scope (X);\\\n  } while (0)\nextern void gt_ggc_mx_c_scope (void *);\n#define gt_ggc_m_15output_def_pair(X) do { \\\n  if (X != NULL) gt_ggc_mx_output_def_pair (X);\\\n  } while (0)\nextern void gt_ggc_mx_output_def_pair (void *);\n#define gt_ggc_m_24constant_descriptor_tree(X) do { \\\n  if (X != NULL) gt_ggc_mx_constant_descriptor_tree (X);\\\n  } while (0)\nextern void gt_ggc_mx_constant_descriptor_tree (void *);\n#define gt_ggc_m_14in_named_entry(X) do { \\\n  if (X != NULL) gt_ggc_mx_in_named_entry (X);\\\n  } while (0)\nextern void gt_ggc_mx_in_named_entry (void *);\n#define gt_ggc_m_13pool_constant(X) do { \\\n  if (X != NULL) gt_ggc_mx_pool_constant (X);\\\n  } while (0)\nextern void gt_ggc_mx_pool_constant (void *);\n#define gt_ggc_m_23constant_descriptor_rtx(X) do { \\\n  if (X != NULL) gt_ggc_mx_constant_descriptor_rtx (X);\\\n  } while (0)\nextern void gt_ggc_mx_constant_descriptor_rtx (void *);\n#define gt_ggc_m_9type_hash(X) do { \\\n  if (X != NULL) gt_ggc_mx_type_hash (X);\\\n  } while (0)\nextern void gt_ggc_mx_type_hash (void *);\n#define gt_ggc_m_16string_pool_data(X) do { \\\n  if (X != NULL) gt_ggc_mx_string_pool_data (X);\\\n  } while (0)\nextern void gt_ggc_mx_string_pool_data (void *);\n#define gt_ggc_m_10goto_fixup(X) do { \\\n  if (X != NULL) gt_ggc_mx_goto_fixup (X);\\\n  } while (0)\nextern void gt_ggc_mx_goto_fixup (void *);\n#define gt_ggc_m_11label_chain(X) do { \\\n  if (X != NULL) gt_ggc_mx_label_chain (X);\\\n  } while (0)\nextern void gt_ggc_mx_label_chain (void *);\n#define gt_ggc_m_7nesting(X) do { \\\n  if (X != NULL) gt_ggc_mx_nesting (X);\\\n  } while (0)\nextern void gt_ggc_mx_nesting (void *);\n#define gt_ggc_m_9case_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_case_node (X);\\\n  } while (0)\nextern void gt_ggc_mx_case_node (void *);\n#define gt_ggc_m_9eh_region(X) do { \\\n  if (X != NULL) gt_ggc_mx_eh_region (X);\\\n  } while (0)\nextern void gt_ggc_mx_eh_region (void *);\n#define gt_ggc_m_13ehl_map_entry(X) do { \\\n  if (X != NULL) gt_ggc_mx_ehl_map_entry (X);\\\n  } while (0)\nextern void gt_ggc_mx_ehl_map_entry (void *);\n#define gt_ggc_m_16limbo_die_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_limbo_die_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_limbo_die_struct (void *);\n#define gt_ggc_m_16dw_ranges_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_ranges_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_ranges_struct (void *);\n#define gt_ggc_m_14pubname_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_pubname_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_pubname_struct (void *);\n#define gt_ggc_m_28dw_separate_line_info_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_separate_line_info_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_separate_line_info_struct (void *);\n#define gt_ggc_m_19dw_line_info_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_line_info_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_line_info_struct (void *);\n#define gt_ggc_m_14dw_attr_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_attr_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_attr_struct (void *);\n#define gt_ggc_m_18dw_loc_list_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_loc_list_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_loc_list_struct (void *);\n#define gt_ggc_m_15queued_reg_save(X) do { \\\n  if (X != NULL) gt_ggc_mx_queued_reg_save (X);\\\n  } while (0)\nextern void gt_ggc_mx_queued_reg_save (void *);\n#define gt_ggc_m_20indirect_string_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_indirect_string_node (X);\\\n  } while (0)\nextern void gt_ggc_mx_indirect_string_node (void *);\n#define gt_ggc_m_19dw_loc_descr_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_loc_descr_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_loc_descr_struct (void *);\n#define gt_ggc_m_13dw_fde_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_fde_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_fde_struct (void *);\n#define gt_ggc_m_13dw_cfi_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_dw_cfi_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_dw_cfi_struct (void *);\n#define gt_ggc_m_8typeinfo(X) do { \\\n  if (X != NULL) gt_ggc_mx_typeinfo (X);\\\n  } while (0)\nextern void gt_ggc_mx_typeinfo (void *);\n#define gt_ggc_m_15alias_set_entry(X) do { \\\n  if (X != NULL) gt_ggc_mx_alias_set_entry (X);\\\n  } while (0)\nextern void gt_ggc_mx_alias_set_entry (void *);\n#define gt_ggc_m_18sorted_fields_type(X) do { \\\n  if (X != NULL) gt_ggc_mx_sorted_fields_type (X);\\\n  } while (0)\nextern void gt_ggc_mx_sorted_fields_type (void *);\n#define gt_ggc_m_19cgraph_varpool_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_cgraph_varpool_node (X);\\\n  } while (0)\nextern void gt_ggc_mx_cgraph_varpool_node (void *);\n#define gt_ggc_m_11cgraph_edge(X) do { \\\n  if (X != NULL) gt_ggc_mx_cgraph_edge (X);\\\n  } while (0)\nextern void gt_ggc_mx_cgraph_edge (void *);\n#define gt_ggc_m_11cgraph_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_cgraph_node (X);\\\n  } while (0)\nextern void gt_ggc_mx_cgraph_node (void *);\n#define gt_ggc_m_12elt_loc_list(X) do { \\\n  if (X != NULL) gt_ggc_mx_elt_loc_list (X);\\\n  } while (0)\nextern void gt_ggc_mx_elt_loc_list (void *);\n#define gt_ggc_m_17cselib_val_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_cselib_val_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_cselib_val_struct (void *);\n#define gt_ggc_m_15varray_head_tag(X) do { \\\n  if (X != NULL) gt_ggc_mx_varray_head_tag (X);\\\n  } while (0)\nextern void gt_ggc_mx_varray_head_tag (void *);\n#define gt_ggc_m_8elt_list(X) do { \\\n  if (X != NULL) gt_ggc_mx_elt_list (X);\\\n  } while (0)\nextern void gt_ggc_mx_elt_list (void *);\n#define gt_ggc_m_12reg_info_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_reg_info_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_reg_info_def (void *);\n#define gt_ggc_m_14lang_tree_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_lang_tree_node (X);\\\n  } while (0)\nextern void gt_ggc_mx_lang_tree_node (void *);\n#define gt_ggc_m_9lang_decl(X) do { \\\n  if (X != NULL) gt_ggc_mx_lang_decl (X);\\\n  } while (0)\nextern void gt_ggc_mx_lang_decl (void *);\n#define gt_ggc_m_9lang_type(X) do { \\\n  if (X != NULL) gt_ggc_mx_lang_type (X);\\\n  } while (0)\nextern void gt_ggc_mx_lang_type (void *);\n#define gt_ggc_m_10die_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_die_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_die_struct (void *);\n#define gt_ggc_m_10real_value(X) do { \\\n  if (X != NULL) gt_ggc_mx_real_value (X);\\\n  } while (0)\nextern void gt_ggc_mx_real_value (void *);\n#define gt_ggc_m_13convert_optab(X) do { \\\n  if (X != NULL) gt_ggc_mx_convert_optab (X);\\\n  } while (0)\nextern void gt_ggc_mx_convert_optab (void *);\n#define gt_ggc_m_5optab(X) do { \\\n  if (X != NULL) gt_ggc_mx_optab (X);\\\n  } while (0)\nextern void gt_ggc_mx_optab (void *);\n#define gt_ggc_m_15basic_block_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_basic_block_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_basic_block_def (void *);\n#define gt_ggc_m_9reg_attrs(X) do { \\\n  if (X != NULL) gt_ggc_mx_reg_attrs (X);\\\n  } while (0)\nextern void gt_ggc_mx_reg_attrs (void *);\n#define gt_ggc_m_9mem_attrs(X) do { \\\n  if (X != NULL) gt_ggc_mx_mem_attrs (X);\\\n  } while (0)\nextern void gt_ggc_mx_mem_attrs (void *);\n#define gt_ggc_m_17language_function(X) do { \\\n  if (X != NULL) gt_ggc_mx_language_function (X);\\\n  } while (0)\nextern void gt_ggc_mx_language_function (void *);\n#define gt_ggc_m_9temp_slot(X) do { \\\n  if (X != NULL) gt_ggc_mx_temp_slot (X);\\\n  } while (0)\nextern void gt_ggc_mx_temp_slot (void *);\n#define gt_ggc_m_20initial_value_struct(X) do { \\\n  if (X != NULL) gt_ggc_mx_initial_value_struct (X);\\\n  } while (0)\nextern void gt_ggc_mx_initial_value_struct (void *);\n#define gt_ggc_m_13varasm_status(X) do { \\\n  if (X != NULL) gt_ggc_mx_varasm_status (X);\\\n  } while (0)\nextern void gt_ggc_mx_varasm_status (void *);\n#define gt_ggc_m_11stmt_status(X) do { \\\n  if (X != NULL) gt_ggc_mx_stmt_status (X);\\\n  } while (0)\nextern void gt_ggc_mx_stmt_status (void *);\n#define gt_ggc_m_9eh_status(X) do { \\\n  if (X != NULL) gt_ggc_mx_eh_status (X);\\\n  } while (0)\nextern void gt_ggc_mx_eh_status (void *);\n#define gt_ggc_m_8function(X) do { \\\n  if (X != NULL) gt_ggc_mx_function (X);\\\n  } while (0)\nextern void gt_ggc_mx_function (void *);\n#define gt_ggc_m_11expr_status(X) do { \\\n  if (X != NULL) gt_ggc_mx_expr_status (X);\\\n  } while (0)\nextern void gt_ggc_mx_expr_status (void *);\n#define gt_ggc_m_11emit_status(X) do { \\\n  if (X != NULL) gt_ggc_mx_emit_status (X);\\\n  } while (0)\nextern void gt_ggc_mx_emit_status (void *);\n#define gt_ggc_m_14sequence_stack(X) do { \\\n  if (X != NULL) gt_ggc_mx_sequence_stack (X);\\\n  } while (0)\nextern void gt_ggc_mx_sequence_stack (void *);\n#define gt_ggc_m_14var_refs_queue(X) do { \\\n  if (X != NULL) gt_ggc_mx_var_refs_queue (X);\\\n  } while (0)\nextern void gt_ggc_mx_var_refs_queue (void *);\n#define gt_ggc_m_15bitmap_head_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_bitmap_head_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_bitmap_head_def (void *);\n#define gt_ggc_m_18bitmap_element_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_bitmap_element_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_bitmap_element_def (void *);\n#define gt_ggc_m_6answer(X) do { \\\n  if (X != NULL) gt_ggc_mx_answer (X);\\\n  } while (0)\nextern void gt_ggc_mx_answer (void *);\n#define gt_ggc_m_9cpp_macro(X) do { \\\n  if (X != NULL) gt_ggc_mx_cpp_macro (X);\\\n  } while (0)\nextern void gt_ggc_mx_cpp_macro (void *);\n#define gt_ggc_m_9tree_node(X) do { \\\n  if (X != NULL) gt_ggc_mx_tree_node (X);\\\n  } while (0)\n#define gt_ggc_mx_tree_node gt_ggc_mx_lang_tree_node\n#define gt_ggc_m_9rtvec_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_rtvec_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_rtvec_def (void *);\n#define gt_ggc_m_7rtx_def(X) do { \\\n  if (X != NULL) gt_ggc_mx_rtx_def (X);\\\n  } while (0)\nextern void gt_ggc_mx_rtx_def (void *);\nextern void gt_ggc_m_II17splay_tree_node_s (void *);\nextern void gt_ggc_m_SP9tree_node17splay_tree_node_s (void *);\nextern void gt_ggc_m_P15output_def_pair15varray_head_tag (void *);\nextern void gt_ggc_m_P24constant_descriptor_tree4htab (void *);\nextern void gt_ggc_m_P14in_named_entry4htab (void *);\nextern void gt_ggc_m_P9type_hash4htab (void *);\nextern void gt_ggc_m_P13ehl_map_entry4htab (void *);\nextern void gt_ggc_m_P9tree_node4htab (void *);\nextern void gt_ggc_m_P9reg_attrs4htab (void *);\nextern void gt_ggc_m_P9mem_attrs4htab (void *);\nextern void gt_ggc_m_P7rtx_def4htab (void *);\nextern void gt_ggc_m_SP9tree_node12splay_tree_s (void *);\nextern void gt_ggc_m_P20indirect_string_node4htab (void *);\nextern void gt_ggc_m_P19cgraph_varpool_node4htab (void *);\nextern void gt_ggc_m_P11cgraph_node4htab (void *);\nextern void gt_ggc_m_P17cselib_val_struct4htab (void *);\nextern void gt_ggc_m_P15alias_set_entry15varray_head_tag (void *);\nextern void gt_ggc_m_II12splay_tree_s (void *);\n\n/* PCH type-walking procedures.  */\n#define gt_pch_n_11align_stack(X) do { \\\n  if (X != NULL) gt_pch_nx_align_stack (X);\\\n  } while (0)\nextern void gt_pch_nx_align_stack (void *);\n#define gt_pch_n_7c_scope(X) do { \\\n  if (X != NULL) gt_pch_nx_c_scope (X);\\\n  } while (0)\nextern void gt_pch_nx_c_scope (void *);\n#define gt_pch_n_15output_def_pair(X) do { \\\n  if (X != NULL) gt_pch_nx_output_def_pair (X);\\\n  } while (0)\nextern void gt_pch_nx_output_def_pair (void *);\n#define gt_pch_n_24constant_descriptor_tree(X) do { \\\n  if (X != NULL) gt_pch_nx_constant_descriptor_tree (X);\\\n  } while (0)\nextern void gt_pch_nx_constant_descriptor_tree (void *);\n#define gt_pch_n_14in_named_entry(X) do { \\\n  if (X != NULL) gt_pch_nx_in_named_entry (X);\\\n  } while (0)\nextern void gt_pch_nx_in_named_entry (void *);\n#define gt_pch_n_13pool_constant(X) do { \\\n  if (X != NULL) gt_pch_nx_pool_constant (X);\\\n  } while (0)\nextern void gt_pch_nx_pool_constant (void *);\n#define gt_pch_n_23constant_descriptor_rtx(X) do { \\\n  if (X != NULL) gt_pch_nx_constant_descriptor_rtx (X);\\\n  } while (0)\nextern void gt_pch_nx_constant_descriptor_rtx (void *);\n#define gt_pch_n_9type_hash(X) do { \\\n  if (X != NULL) gt_pch_nx_type_hash (X);\\\n  } while (0)\nextern void gt_pch_nx_type_hash (void *);\n#define gt_pch_n_16string_pool_data(X) do { \\\n  if (X != NULL) gt_pch_nx_string_pool_data (X);\\\n  } while (0)\nextern void gt_pch_nx_string_pool_data (void *);\n#define gt_pch_n_10goto_fixup(X) do { \\\n  if (X != NULL) gt_pch_nx_goto_fixup (X);\\\n  } while (0)\nextern void gt_pch_nx_goto_fixup (void *);\n#define gt_pch_n_11label_chain(X) do { \\\n  if (X != NULL) gt_pch_nx_label_chain (X);\\\n  } while (0)\nextern void gt_pch_nx_label_chain (void *);\n#define gt_pch_n_7nesting(X) do { \\\n  if (X != NULL) gt_pch_nx_nesting (X);\\\n  } while (0)\nextern void gt_pch_nx_nesting (void *);\n#define gt_pch_n_9case_node(X) do { \\\n  if (X != NULL) gt_pch_nx_case_node (X);\\\n  } while (0)\nextern void gt_pch_nx_case_node (void *);\n#define gt_pch_n_9eh_region(X) do { \\\n  if (X != NULL) gt_pch_nx_eh_region (X);\\\n  } while (0)\nextern void gt_pch_nx_eh_region (void *);\n#define gt_pch_n_13ehl_map_entry(X) do { \\\n  if (X != NULL) gt_pch_nx_ehl_map_entry (X);\\\n  } while (0)\nextern void gt_pch_nx_ehl_map_entry (void *);\n#define gt_pch_n_16limbo_die_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_limbo_die_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_limbo_die_struct (void *);\n#define gt_pch_n_16dw_ranges_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_ranges_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_ranges_struct (void *);\n#define gt_pch_n_14pubname_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_pubname_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_pubname_struct (void *);\n#define gt_pch_n_28dw_separate_line_info_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_separate_line_info_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_separate_line_info_struct (void *);\n#define gt_pch_n_19dw_line_info_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_line_info_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_line_info_struct (void *);\n#define gt_pch_n_14dw_attr_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_attr_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_attr_struct (void *);\n#define gt_pch_n_18dw_loc_list_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_loc_list_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_loc_list_struct (void *);\n#define gt_pch_n_15queued_reg_save(X) do { \\\n  if (X != NULL) gt_pch_nx_queued_reg_save (X);\\\n  } while (0)\nextern void gt_pch_nx_queued_reg_save (void *);\n#define gt_pch_n_20indirect_string_node(X) do { \\\n  if (X != NULL) gt_pch_nx_indirect_string_node (X);\\\n  } while (0)\nextern void gt_pch_nx_indirect_string_node (void *);\n#define gt_pch_n_19dw_loc_descr_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_loc_descr_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_loc_descr_struct (void *);\n#define gt_pch_n_13dw_fde_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_fde_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_fde_struct (void *);\n#define gt_pch_n_13dw_cfi_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_dw_cfi_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_dw_cfi_struct (void *);\n#define gt_pch_n_8typeinfo(X) do { \\\n  if (X != NULL) gt_pch_nx_typeinfo (X);\\\n  } while (0)\nextern void gt_pch_nx_typeinfo (void *);\n#define gt_pch_n_15alias_set_entry(X) do { \\\n  if (X != NULL) gt_pch_nx_alias_set_entry (X);\\\n  } while (0)\nextern void gt_pch_nx_alias_set_entry (void *);\n#define gt_pch_n_18sorted_fields_type(X) do { \\\n  if (X != NULL) gt_pch_nx_sorted_fields_type (X);\\\n  } while (0)\nextern void gt_pch_nx_sorted_fields_type (void *);\n#define gt_pch_n_19cgraph_varpool_node(X) do { \\\n  if (X != NULL) gt_pch_nx_cgraph_varpool_node (X);\\\n  } while (0)\nextern void gt_pch_nx_cgraph_varpool_node (void *);\n#define gt_pch_n_11cgraph_edge(X) do { \\\n  if (X != NULL) gt_pch_nx_cgraph_edge (X);\\\n  } while (0)\nextern void gt_pch_nx_cgraph_edge (void *);\n#define gt_pch_n_11cgraph_node(X) do { \\\n  if (X != NULL) gt_pch_nx_cgraph_node (X);\\\n  } while (0)\nextern void gt_pch_nx_cgraph_node (void *);\n#define gt_pch_n_12elt_loc_list(X) do { \\\n  if (X != NULL) gt_pch_nx_elt_loc_list (X);\\\n  } while (0)\nextern void gt_pch_nx_elt_loc_list (void *);\n#define gt_pch_n_17cselib_val_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_cselib_val_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_cselib_val_struct (void *);\n#define gt_pch_n_15varray_head_tag(X) do { \\\n  if (X != NULL) gt_pch_nx_varray_head_tag (X);\\\n  } while (0)\nextern void gt_pch_nx_varray_head_tag (void *);\n#define gt_pch_n_8elt_list(X) do { \\\n  if (X != NULL) gt_pch_nx_elt_list (X);\\\n  } while (0)\nextern void gt_pch_nx_elt_list (void *);\n#define gt_pch_n_12reg_info_def(X) do { \\\n  if (X != NULL) gt_pch_nx_reg_info_def (X);\\\n  } while (0)\nextern void gt_pch_nx_reg_info_def (void *);\n#define gt_pch_n_14lang_tree_node(X) do { \\\n  if (X != NULL) gt_pch_nx_lang_tree_node (X);\\\n  } while (0)\nextern void gt_pch_nx_lang_tree_node (void *);\n#define gt_pch_n_9lang_decl(X) do { \\\n  if (X != NULL) gt_pch_nx_lang_decl (X);\\\n  } while (0)\nextern void gt_pch_nx_lang_decl (void *);\n#define gt_pch_n_9lang_type(X) do { \\\n  if (X != NULL) gt_pch_nx_lang_type (X);\\\n  } while (0)\nextern void gt_pch_nx_lang_type (void *);\n#define gt_pch_n_10die_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_die_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_die_struct (void *);\n#define gt_pch_n_10real_value(X) do { \\\n  if (X != NULL) gt_pch_nx_real_value (X);\\\n  } while (0)\nextern void gt_pch_nx_real_value (void *);\n#define gt_pch_n_13convert_optab(X) do { \\\n  if (X != NULL) gt_pch_nx_convert_optab (X);\\\n  } while (0)\nextern void gt_pch_nx_convert_optab (void *);\n#define gt_pch_n_5optab(X) do { \\\n  if (X != NULL) gt_pch_nx_optab (X);\\\n  } while (0)\nextern void gt_pch_nx_optab (void *);\n#define gt_pch_n_15basic_block_def(X) do { \\\n  if (X != NULL) gt_pch_nx_basic_block_def (X);\\\n  } while (0)\nextern void gt_pch_nx_basic_block_def (void *);\n#define gt_pch_n_9reg_attrs(X) do { \\\n  if (X != NULL) gt_pch_nx_reg_attrs (X);\\\n  } while (0)\nextern void gt_pch_nx_reg_attrs (void *);\n#define gt_pch_n_9mem_attrs(X) do { \\\n  if (X != NULL) gt_pch_nx_mem_attrs (X);\\\n  } while (0)\nextern void gt_pch_nx_mem_attrs (void *);\n#define gt_pch_n_17language_function(X) do { \\\n  if (X != NULL) gt_pch_nx_language_function (X);\\\n  } while (0)\nextern void gt_pch_nx_language_function (void *);\n#define gt_pch_n_9temp_slot(X) do { \\\n  if (X != NULL) gt_pch_nx_temp_slot (X);\\\n  } while (0)\nextern void gt_pch_nx_temp_slot (void *);\n#define gt_pch_n_20initial_value_struct(X) do { \\\n  if (X != NULL) gt_pch_nx_initial_value_struct (X);\\\n  } while (0)\nextern void gt_pch_nx_initial_value_struct (void *);\n#define gt_pch_n_13varasm_status(X) do { \\\n  if (X != NULL) gt_pch_nx_varasm_status (X);\\\n  } while (0)\nextern void gt_pch_nx_varasm_status (void *);\n#define gt_pch_n_11stmt_status(X) do { \\\n  if (X != NULL) gt_pch_nx_stmt_status (X);\\\n  } while (0)\nextern void gt_pch_nx_stmt_status (void *);\n#define gt_pch_n_9eh_status(X) do { \\\n  if (X != NULL) gt_pch_nx_eh_status (X);\\\n  } while (0)\nextern void gt_pch_nx_eh_status (void *);\n#define gt_pch_n_8function(X) do { \\\n  if (X != NULL) gt_pch_nx_function (X);\\\n  } while (0)\nextern void gt_pch_nx_function (void *);\n#define gt_pch_n_11expr_status(X) do { \\\n  if (X != NULL) gt_pch_nx_expr_status (X);\\\n  } while (0)\nextern void gt_pch_nx_expr_status (void *);\n#define gt_pch_n_11emit_status(X) do { \\\n  if (X != NULL) gt_pch_nx_emit_status (X);\\\n  } while (0)\nextern void gt_pch_nx_emit_status (void *);\n#define gt_pch_n_14sequence_stack(X) do { \\\n  if (X != NULL) gt_pch_nx_sequence_stack (X);\\\n  } while (0)\nextern void gt_pch_nx_sequence_stack (void *);\n#define gt_pch_n_14var_refs_queue(X) do { \\\n  if (X != NULL) gt_pch_nx_var_refs_queue (X);\\\n  } while (0)\nextern void gt_pch_nx_var_refs_queue (void *);\n#define gt_pch_n_15bitmap_head_def(X) do { \\\n  if (X != NULL) gt_pch_nx_bitmap_head_def (X);\\\n  } while (0)\nextern void gt_pch_nx_bitmap_head_def (void *);\n#define gt_pch_n_18bitmap_element_def(X) do { \\\n  if (X != NULL) gt_pch_nx_bitmap_element_def (X);\\\n  } while (0)\nextern void gt_pch_nx_bitmap_element_def (void *);\n#define gt_pch_n_6answer(X) do { \\\n  if (X != NULL) gt_pch_nx_answer (X);\\\n  } while (0)\nextern void gt_pch_nx_answer (void *);\n#define gt_pch_n_9cpp_macro(X) do { \\\n  if (X != NULL) gt_pch_nx_cpp_macro (X);\\\n  } while (0)\nextern void gt_pch_nx_cpp_macro (void *);\n#define gt_pch_n_9tree_node(X) do { \\\n  if (X != NULL) gt_pch_nx_tree_node (X);\\\n  } while (0)\n#define gt_pch_nx_tree_node gt_pch_nx_lang_tree_node\n#define gt_pch_n_9rtvec_def(X) do { \\\n  if (X != NULL) gt_pch_nx_rtvec_def (X);\\\n  } while (0)\nextern void gt_pch_nx_rtvec_def (void *);\n#define gt_pch_n_7rtx_def(X) do { \\\n  if (X != NULL) gt_pch_nx_rtx_def (X);\\\n  } while (0)\nextern void gt_pch_nx_rtx_def (void *);\nextern void gt_pch_n_II17splay_tree_node_s (void *);\nextern void gt_pch_n_SP9tree_node17splay_tree_node_s (void *);\nextern void gt_pch_n_P15output_def_pair15varray_head_tag (void *);\nextern void gt_pch_n_P24constant_descriptor_tree4htab (void *);\nextern void gt_pch_n_P14in_named_entry4htab (void *);\nextern void gt_pch_n_P9type_hash4htab (void *);\nextern void gt_pch_n_P13ehl_map_entry4htab (void *);\nextern void gt_pch_n_P9tree_node4htab (void *);\nextern void gt_pch_n_P9reg_attrs4htab (void *);\nextern void gt_pch_n_P9mem_attrs4htab (void *);\nextern void gt_pch_n_P7rtx_def4htab (void *);\nextern void gt_pch_n_SP9tree_node12splay_tree_s (void *);\nextern void gt_pch_n_P20indirect_string_node4htab (void *);\nextern void gt_pch_n_P19cgraph_varpool_node4htab (void *);\nextern void gt_pch_n_P11cgraph_node4htab (void *);\nextern void gt_pch_n_P17cselib_val_struct4htab (void *);\nextern void gt_pch_n_P15alias_set_entry15varray_head_tag (void *);\nextern void gt_pch_n_II12splay_tree_s (void *);\n\n/* Local pointer-walking routines.  */\nextern void gt_pch_p_11align_stack\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_7c_scope\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_15output_def_pair\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_24constant_descriptor_tree\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14in_named_entry\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13pool_constant\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_23constant_descriptor_rtx\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9type_hash\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_16string_pool_data\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_10goto_fixup\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11label_chain\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_7nesting\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9case_node\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9eh_region\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13ehl_map_entry\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_16limbo_die_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_16dw_ranges_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14pubname_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_28dw_separate_line_info_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_19dw_line_info_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14dw_attr_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_18dw_loc_list_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_15queued_reg_save\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_20indirect_string_node\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_19dw_loc_descr_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13dw_fde_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13dw_cfi_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_8typeinfo\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_15alias_set_entry\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_18sorted_fields_type\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_19cgraph_varpool_node\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11cgraph_edge\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11cgraph_node\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_12elt_loc_list\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_17cselib_val_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_15varray_head_tag\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_8elt_list\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14lang_tree_node\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9lang_decl\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9lang_type\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_10die_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_10real_value\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13convert_optab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_5optab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9reg_attrs\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9mem_attrs\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_17language_function\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9temp_slot\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_20initial_value_struct\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_13varasm_status\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11stmt_status\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_9eh_status\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_8function\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11expr_status\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_11emit_status\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14sequence_stack\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_14var_refs_queue\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_15bitmap_head_def\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_18bitmap_element_def\n    (void *, void *, gt_pointer_operator, void *);\n#define gt_pch_p_9tree_node gt_pch_p_14lang_tree_node\nextern void gt_pch_p_9rtvec_def\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_7rtx_def\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_II17splay_tree_node_s\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_SP9tree_node17splay_tree_node_s\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P15output_def_pair15varray_head_tag\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P24constant_descriptor_tree4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P14in_named_entry4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P9type_hash4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P13ehl_map_entry4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P9tree_node4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P9reg_attrs4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P9mem_attrs4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P7rtx_def4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_SP9tree_node12splay_tree_s\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P20indirect_string_node4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P19cgraph_varpool_node4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P11cgraph_node4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P17cselib_val_struct4htab\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_P15alias_set_entry15varray_head_tag\n    (void *, void *, gt_pointer_operator, void *);\nextern void gt_pch_p_II12splay_tree_s\n    (void *, void *, gt_pointer_operator, void *);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HARD@REG": {"ttr": 5895, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Sets (bit vectors) of hard registers, and operations on them.\n   Copyright (C) 1987, 1992, 1994, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_HARD_REG_SET_H\n#define GCC_HARD_REG_SET_H\n\n/* Define the type of a set of hard registers.  */\n\n/* HARD_REG_ELT_TYPE is a typedef of the unsigned integral type which\n   will be used for hard reg sets, either alone or in an array.\n\n   If HARD_REG_SET is a macro, its definition is HARD_REG_ELT_TYPE,\n   and it has enough bits to represent all the target machine's hard\n   registers.  Otherwise, it is a typedef for a suitably sized array\n   of HARD_REG_ELT_TYPEs.  HARD_REG_SET_LONGS is defined as how many.\n\n   Note that lots of code assumes that the first part of a regset is\n   the same format as a HARD_REG_SET.  To help make sure this is true,\n   we only try the widest integer mode (HOST_WIDE_INT) instead of all the\n   smaller types.  This approach loses only if there are a very few\n   registers and then only in the few cases where we have an array of\n   HARD_REG_SETs, so it needn't be as complex as it used to be.  */\n\ntypedef unsigned HOST_WIDE_INT HARD_REG_ELT_TYPE;\n\n#if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n\n#define HARD_REG_SET HARD_REG_ELT_TYPE\n\n#else\n\n#define HARD_REG_SET_LONGS \\\n ((FIRST_PSEUDO_REGISTER + HOST_BITS_PER_WIDE_INT - 1)\t\\\n  / HOST_BITS_PER_WIDE_INT)\ntypedef HARD_REG_ELT_TYPE HARD_REG_SET\u00ddHARD_REG_SET_LONGS\u00a8;\n\n#endif\n\n/* HARD_CONST is used to cast a constant to the appropriate type\n   for use with a HARD_REG_SET.  */\n\n#define HARD_CONST(X) ((HARD_REG_ELT_TYPE) (X))\n\n/* Define macros SET_HARD_REG_BIT, CLEAR_HARD_REG_BIT and TEST_HARD_REG_BIT\n   to set, clear or test one bit in a hard reg set of type HARD_REG_SET.\n   All three take two arguments: the set and the register number.\n\n   In the case where sets are arrays of longs, the first argument\n   is actually a pointer to a long.\n\n   Define two macros for initializing a set:\n   CLEAR_HARD_REG_SET and SET_HARD_REG_SET.\n   These take just one argument.\n\n   Also define macros for copying hard reg sets:\n   COPY_HARD_REG_SET and COMPL_HARD_REG_SET.\n   These take two arguments TO and FROM; they read from FROM\n   and store into TO.  COMPL_HARD_REG_SET complements each bit.\n\n   Also define macros for combining hard reg sets:\n   IOR_HARD_REG_SET and AND_HARD_REG_SET.\n   These take two arguments TO and FROM; they read from FROM\n   and combine bitwise into TO.  Define also two variants\n   IOR_COMPL_HARD_REG_SET and AND_COMPL_HARD_REG_SET\n   which use the complement of the set FROM.\n\n   Also define GO_IF_HARD_REG_SUBSET (X, Y, TO):\n   if X is a subset of Y, go to TO.\n*/\n\n#ifdef HARD_REG_SET\n\n#define SET_HARD_REG_BIT(SET, BIT)  \\\n ((SET) |= HARD_CONST (1) << (BIT))\n#define CLEAR_HARD_REG_BIT(SET, BIT)  \\\n ((SET) &= ~(HARD_CONST (1) << (BIT)))\n#define TEST_HARD_REG_BIT(SET, BIT)  \\\n (!!((SET) & (HARD_CONST (1) << (BIT))))\n\n#define CLEAR_HARD_REG_SET(TO) ((TO) = HARD_CONST (0))\n#define SET_HARD_REG_SET(TO) ((TO) = ~ HARD_CONST (0))\n\n#define COPY_HARD_REG_SET(TO, FROM) ((TO) = (FROM))\n#define COMPL_HARD_REG_SET(TO, FROM) ((TO) = ~(FROM))\n\n#define IOR_HARD_REG_SET(TO, FROM) ((TO) |= (FROM))\n#define IOR_COMPL_HARD_REG_SET(TO, FROM) ((TO) |= ~ (FROM))\n#define AND_HARD_REG_SET(TO, FROM) ((TO) &= (FROM))\n#define AND_COMPL_HARD_REG_SET(TO, FROM) ((TO) &= ~ (FROM))\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO) if (HARD_CONST (0) == ((X) & ~(Y))) goto TO\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO) if ((X) == (Y)) goto TO\n\n#else\n\n#define UHOST_BITS_PER_WIDE_INT ((unsigned) HOST_BITS_PER_WIDE_INT)\n\n#define SET_HARD_REG_BIT(SET, BIT)\t\t\\\n  ((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n   |= HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))\n\n#define CLEAR_HARD_REG_BIT(SET, BIT)\t\t\\\n  ((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n   &= ~(HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT)))\n\n#define TEST_HARD_REG_BIT(SET, BIT)\t\t\\\n  (!!((SET)\u00dd(BIT) / UHOST_BITS_PER_WIDE_INT\u00a8\t\\\n      & (HARD_CONST (1) << ((BIT) % UHOST_BITS_PER_WIDE_INT))))\n\n#if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else\n#if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = scan_fp_\u00dd2\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= scan_fp_\u00dd2\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= scan_fp_\u00dd2\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= ~ scan_fp_\u00dd2\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd2\u00a8 & ~ scan_yp_\u00dd2\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd2\u00a8 == scan_yp_\u00dd2\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else\n#if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDE_INT\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = 0;\t\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     scan_tp_\u00dd0\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = -1;\t\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n     scan_tp_\u00dd0\u00a8 = scan_fp_\u00dd0\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = scan_fp_\u00dd1\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = scan_fp_\u00dd2\u00a8;\t\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = scan_fp_\u00dd3\u00a8; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 = ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 = ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 = ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 = ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 &= scan_fp_\u00dd3\u00a8; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 &= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 &= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 &= ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 &= ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 |= scan_fp_\u00dd3\u00a8; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     scan_tp_\u00dd0\u00a8 |= ~ scan_fp_\u00dd0\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd1\u00a8 |= ~ scan_fp_\u00dd1\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd2\u00a8 |= ~ scan_fp_\u00dd2\u00a8;\t\t\t\t\\\n     scan_tp_\u00dd3\u00a8 |= ~ scan_fp_\u00dd3\u00a8; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((0 == (scan_xp_\u00dd0\u00a8 & ~ scan_yp_\u00dd0\u00a8))\t\t\t\\\n\t && (0 == (scan_xp_\u00dd1\u00a8 & ~ scan_yp_\u00dd1\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd2\u00a8 & ~ scan_yp_\u00dd2\u00a8))\t\t\\\n\t && (0 == (scan_xp_\u00dd3\u00a8 & ~ scan_yp_\u00dd3\u00a8)))\t\t\\\n\tgoto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     if ((scan_xp_\u00dd0\u00a8 == scan_yp_\u00dd0\u00a8)\t\t\t\t\\\n\t && (scan_xp_\u00dd1\u00a8 == scan_yp_\u00dd1\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd2\u00a8 == scan_yp_\u00dd2\u00a8)\t\t\t\\\n\t && (scan_xp_\u00dd3\u00a8 == scan_yp_\u00dd3\u00a8))\t\t\t\\\n\tgoto TO; } while (0)\n\n#else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDE_INT */\n\n#define CLEAR_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = 0; } while (0)\n\n#define SET_HARD_REG_SET(TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = -1; } while (0)\n\n#define COPY_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = *scan_fp_++; } while (0)\n\n#define COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n\n#define AND_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ &= *scan_fp_++; } while (0)\n\n#define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n\n#define IOR_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ |= *scan_fp_++; } while (0)\n\n#define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\ndo { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n\n#define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       if (0 != (*scan_xp_++ & ~ *scan_yp_++)) break;\t\t\\\n     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n\n#define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\ndo { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n     int i;\t\t\t\t\t\t\t\\\n     for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n       if (*scan_xp_++ != *scan_yp_++) break;\t\t\t\\\n     if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n\n#endif\n#endif\n#endif\n#endif\n\n/* Define some standard sets of registers.  */\n\n/* Indexed by hard register number, contains 1 for registers\n   that are fixed use (stack pointer, pc, frame pointer, etc.).\n   These are the registers that cannot be used to allocate\n   a pseudo reg whose life does not cross calls.  */\n\nextern char fixed_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET fixed_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers\n   that are fixed use or are clobbered by function calls.\n   These are the registers that cannot be used to allocate\n   a pseudo reg whose life crosses calls.  */\n\nextern char call_used_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n#ifdef CALL_REALLY_USED_REGISTERS\nextern char call_really_used_regs\u00dd\u00a8;\n#endif\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET call_used_reg_set;\n\n/* Registers that we don't want to caller save.  */\nextern HARD_REG_SET losing_caller_save_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers that are\n   fixed use -- i.e. in fixed_regs -- or a function value return register\n   or TARGET_STRUCT_VALUE_RTX or STATIC_CHAIN_REGNUM.  These are the\n   registers that cannot hold quantities across calls even if we are\n   willing to save and restore them.  */\n\nextern char call_fixed_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The same info as a HARD_REG_SET.  */\n\nextern HARD_REG_SET call_fixed_reg_set;\n\n/* Indexed by hard register number, contains 1 for registers\n   that are being used for global register decls.\n   These must be exempt from ordinary flow analysis\n   and are also considered fixed.  */\n\nextern char global_regs\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Contains 1 for registers that are set or clobbered by calls.  */\n/* ??? Ideally, this would be just call_used_regs plus global_regs, but\n   for someone's bright idea to have call_used_regs strictly include\n   fixed_regs.  Which leaves us guessing as to the set of fixed_regs\n   that are actually preserved.  We know for sure that those associated\n   with the local stack frame are safe, but scant others.  */\n\nextern HARD_REG_SET regs_invalidated_by_call;\n\n#ifdef REG_ALLOC_ORDER\n/* Table of register numbers in the order in which to try to use them.  */\n\nextern int reg_alloc_order\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* The inverse of reg_alloc_order.  */\n\nextern int inv_reg_alloc_order\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n#endif\n\n/* For each reg class, a HARD_REG_SET saying which registers are in it.  */\n\nextern HARD_REG_SET reg_class_contents\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, number of regs it contains.  */\n\nextern unsigned int reg_class_size\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, table listing all the containing classes.  */\n\nextern enum reg_class reg_class_superclasses\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each reg class, table listing all the classes contained in it.  */\n\nextern enum reg_class reg_class_subclasses\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each pair of reg classes,\n   a largest reg class contained in their union.  */\n\nextern enum reg_class reg_class_subunion\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* For each pair of reg classes,\n   the smallest reg class that contains their union.  */\n\nextern enum reg_class reg_class_superunion\u00ddN_REG_CLASSES\u00a8\u00ddN_REG_CLASSES\u00a8;\n\n/* Number of non-fixed registers.  */\n\nextern int n_non_fixed_regs;\n\n/* Vector indexed by hardware reg giving its name.  */\n\nextern const char * reg_names\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Given a hard REGN a FROM mode and a TO mode, return nonzero if\n   REGN cannot change modes between the specified modes.  */\n#define REG_CANNOT_CHANGE_MODE_P(REGN, FROM, TO)                          \\\n         CANNOT_CHANGE_MODE_CLASS (FROM, TO, REGNO_REG_CLASS (REGN))\n\n#endif /* ! GCC_HARD_REG_SET_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HASHTAB": {"ttr": 6145, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* An expandable hash tables datatype.\n   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n   Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* This package implements basic hash table functionality.  It is possible\n   to search for an entry, create an entry and destroy an entry.\n\n   Elements in the table are generic pointers.\n\n   The size of the table is not fixed; if the occupancy of the table\n   grows too high the hash table will be expanded.\n\n   The abstract data implementation is based on generalized Algorithm D\n   from Knuth's book \"The art of computer programming\".  Hash table is\n   expanded by creation of new hash table and transferring elements from\n   the old table to the new table.  */\n\n#ifndef __HASHTAB_H__\n#define __HASHTAB_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include \"ansidecl.h\"\n\n#ifndef GTY\n#define GTY(X)\n#endif\n\n/* The type for a hash code.  */\ntypedef unsigned int hashval_t;\n\n/* Callback function pointer types.  */\n\n/* Calculate hash of a table entry.  */\ntypedef hashval_t (*htab_hash) PARAMS ((const void *));\n\n/* Compare a table entry with a possible entry.  The entry already in\n   the table always comes first, so the second element can be of a\n   different type (but in this case htab_find and htab_find_slot\n   cannot be used; instead the variants that accept a hash value\n   must be used).  */\ntypedef int (*htab_eq) PARAMS ((const void *, const void *));\n\n/* Cleanup function called whenever a live element is removed from\n   the hash table.  */\ntypedef void (*htab_del) PARAMS ((void *));\n\n/* Function called by htab_traverse for each live element.  The first\n   arg is the slot of the element (which can be passed to htab_clear_slot\n   if desired), the second arg is the auxiliary pointer handed to\n   htab_traverse.  Return 1 to continue scan, 0 to stop.  */\ntypedef int (*htab_trav) PARAMS ((void **, void *));\n\n/* Memory-allocation function, with the same functionality as calloc().\n   Iff it returns NULL, the hash table implementation will pass an error\n   code back to the user, so if your code doesn't handle errors,\n   best if you use xcalloc instead.  */\ntypedef PTR (*htab_alloc) PARAMS ((size_t, size_t));\n\n/* We also need a free() routine.  */\ntypedef void (*htab_free) PARAMS ((PTR));\n\n/* Memory allocation and deallocation; variants which take an extra\n   argument.  */\ntypedef PTR (*htab_alloc_with_arg) PARAMS ((void *, size_t, size_t));\ntypedef void (*htab_free_with_arg) PARAMS ((void *, void *));\n\n/* Hash tables are of the following type.  The structure\n   (implementation) of this type is not needed for using the hash\n   tables.  All work with hash table should be executed only through\n   functions mentioned below.  The size of this structure is subject to\n   change.  */\n\nstruct htab GTY(())\n{\n  /* Pointer to hash function.  */\n  htab_hash hash_f;\n\n  /* Pointer to comparison function.  */\n  htab_eq eq_f;\n\n  /* Pointer to cleanup function.  */\n  htab_del del_f;\n\n  /* Table itself.  */\n  PTR * GTY ((use_param (\"\"), length (\"%h.size\"))) entries;\n\n  /* Current size (in entries) of the hash table */\n  size_t size;\n\n  /* Current number of elements including also deleted elements */\n  size_t n_elements;\n\n  /* Current number of deleted elements in the table */\n  size_t n_deleted;\n\n  /* The following member is used for debugging. Its value is number\n     of all calls of `htab_find_slot' for the hash table. */\n  unsigned int searches;\n\n  /* The following member is used for debugging.  Its value is number\n     of collisions fixed for time of work with the hash table. */\n  unsigned int collisions;\n\n  /* Pointers to allocate/free functions.  */\n  htab_alloc alloc_f;\n  htab_free free_f;\n\n  /* Alternate allocate/free functions, which take an extra argument.  */\n  PTR GTY((skip (\"\"))) alloc_arg;\n  htab_alloc_with_arg alloc_with_arg_f;\n  htab_free_with_arg free_with_arg_f;\n};\n\ntypedef struct htab *htab_t;\n\n/* An enum saying whether we insert into the hash table or not.  */\nenum insert_option {NO_INSERT, INSERT};\n\n/* The prototypes of the package functions. */\n\nextern htab_t\thtab_create_alloc\tPARAMS ((size_t, htab_hash,\n\t\t\t\t\t\t htab_eq, htab_del,\n\t\t\t\t\t\t htab_alloc, htab_free));\n\nextern htab_t\thtab_create_alloc_ex\tPARAMS ((size_t, htab_hash,\n\t\t\t\t\t\t    htab_eq, htab_del,\n\t\t\t\t\t\t    PTR, htab_alloc_with_arg,\n\t\t\t\t\t\t    htab_free_with_arg));\n\n/* Backward-compatibility functions.  */\nextern htab_t htab_create PARAMS ((size_t, htab_hash, htab_eq, htab_del));\nextern htab_t htab_try_create PARAMS ((size_t, htab_hash, htab_eq, htab_del));\n\nextern void\thtab_set_functions_ex\tPARAMS ((htab_t, htab_hash,\n\t\t\t\t\t\t htab_eq, htab_del,\n\t\t\t\t\t\t PTR, htab_alloc_with_arg,\n\t\t\t\t\t\t htab_free_with_arg));\n\nextern void\thtab_delete\tPARAMS ((htab_t));\nextern void\thtab_empty\tPARAMS ((htab_t));\n\nextern PTR\thtab_find\tPARAMS ((htab_t, const void *));\nextern PTR     *htab_find_slot\tPARAMS ((htab_t, const void *,\n\t\t\t\t\t enum insert_option));\nextern PTR\thtab_find_with_hash\t  PARAMS ((htab_t, const void *,\n\t\t\t\t\t\t   hashval_t));\nextern PTR     *htab_find_slot_with_hash  PARAMS ((htab_t, const void *,\n\t\t\t\t\t\t   hashval_t,\n\t\t\t\t\t\t   enum insert_option));\nextern void\thtab_clear_slot\tPARAMS ((htab_t, void **));\nextern void\thtab_remove_elt\tPARAMS ((htab_t, void *));\n\nextern void\thtab_traverse\tPARAMS ((htab_t, htab_trav, void *));\nextern void\thtab_traverse_noresize\tPARAMS ((htab_t, htab_trav, void *));\n\nextern size_t\thtab_size\tPARAMS ((htab_t));\nextern size_t\thtab_elements\tPARAMS ((htab_t));\nextern double\thtab_collisions\tPARAMS ((htab_t));\n\n/* A hash function for pointers.  */\nextern htab_hash htab_hash_pointer;\n\n/* An equality function for pointers.  */\nextern htab_eq htab_eq_pointer;\n\n/* A hash function for null-terminated strings.  */\nextern hashval_t htab_hash_string PARAMS ((const PTR));\n\n/* An iterative hash function for arbitrary data.  */\nextern hashval_t iterative_hash PARAMS ((const PTR, size_t, hashval_t));\n/* Shorthand for hashing something with an intrinsic size.  */\n#define iterative_hash_object(OB,INIT) iterative_hash (&OB, sizeof (OB), INIT)\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* __HASHTAB_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HASHTABL": {"ttr": 6148, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Hash tables.\n   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef GCC_HASHTABLE_H\n#define GCC_HASHTABLE_H\n\n#include \"obstack.h\"\n#define GTY(x) /* nothing */\n\n/* This is what each hash table entry points to.  It may be embedded\n   deeply within another object.  */\ntypedef struct ht_identifier ht_identifier;\nstruct ht_identifier GTY(())\n{\n  const unsigned char *str;\n  unsigned int len;\n  unsigned int hash_value;\n};\n\n#define HT_LEN(NODE) ((NODE)->len)\n#define HT_STR(NODE) ((NODE)->str)\n\ntypedef struct ht hash_table;\ntypedef struct ht_identifier *hashnode;\n\nenum ht_lookup_option {HT_NO_INSERT = 0, HT_ALLOC, HT_ALLOCED};\n\n/* An identifier hash table for cpplib and the front ends.  */\nstruct ht\n{\n  /* Identifiers are allocated from here.  */\n  struct obstack stack;\n\n  hashnode *entries;\n  /* Call back.  */\n  hashnode (*alloc_node) (hash_table *);\n\n  unsigned int nslots;\t\t/* Total slots in the entries array.  */\n  unsigned int nelements;\t/* Number of live elements.  */\n\n  /* Link to reader, if any.  For the benefit of cpplib.  */\n  struct cpp_reader *pfile;\n\n  /* Table usage statistics.  */\n  unsigned int searches;\n  unsigned int collisions;\n};\n\n/* Initialize the hashtable with 2 \u00ac order entries.  */\nextern hash_table *ht_create (unsigned int order);\n\n/* Frees all memory associated with a hash table.  */\nextern void ht_destroy (hash_table *);\n\nextern hashnode ht_lookup (hash_table *, const unsigned char *,\n\t\t\t   size_t, enum ht_lookup_option);\n\n/* For all nodes in TABLE, make a callback.  The callback takes\n   TABLE->PFILE, the node, and a PTR, and the callback sequence stops\n   if the callback returns zero.  */\ntypedef int (*ht_cb) (struct cpp_reader *, hashnode, const void *);\nextern void ht_forall (hash_table *, ht_cb, const void *);\n\n/* Dump allocation statistics to stderr.  */\nextern void ht_dump_statistics (hash_table *);\n\n#endif /* GCC_HASHTABLE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOOKS": {"ttr": 6150, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* General-purpose hooks.\n   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_HOOKS_H\n#define GCC_HOOKS_H\n\nextern bool hook_bool_void_false (void);\nextern bool hook_bool_bool_false (bool);\nextern bool hook_bool_tree_false (tree);\nextern bool hook_bool_tree_true (tree);\nextern bool hook_bool_tree_hwi_hwi_tree_false (tree, HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t\ttree);\nextern bool hook_bool_tree_hwi_hwi_tree_true (tree, HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t\t       tree);\nextern bool hook_bool_rtx_false (rtx);\nextern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\nextern bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\nextern bool hook_bool_constcharptr_size_t_false (const char *, size_t);\n\nextern void hook_void_tree_int (tree, int);\nextern void hook_void_void (void);\nextern void hook_void_FILEptr_constcharptr (FILE *, const char *);\nextern void hook_void_tree (tree);\nextern void hook_void_tree_treeptr (tree, tree *);\nextern void hook_void_constcharptr (const char *);\n\nextern int hook_int_tree_tree_1 (tree, tree);\nextern int hook_int_rtx_0 (rtx);\nextern int hook_int_void_0 (void);\nextern int hook_int_size_t_constcharptr_int_0 (size_t, const char *, int);\nextern int hook_int_void_no_regs (void);\n\nextern unsigned hook_uint_uint_constcharptrptr_0 (unsigned, const char **);\n\nextern bool default_can_output_mi_thunk_no_vcall (tree, HOST_WIDE_INT,\n\t\t\t\t\t   HOST_WIDE_INT, tree);\n\nextern bool hook_bool_tree_tree_false (tree, tree);\n\nextern rtx hook_rtx_rtx_identity (rtx);\nextern rtx hook_rtx_rtx_null (rtx);\nextern rtx hook_rtx_tree_int_null (tree, int);\nextern const char *hook_constcharptr_tree_null (tree);\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOSTHDEF": {"ttr": 6152, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default macros to initialize the lang_hooks data structure.\n   Copyright 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_HOST_HOOKS_DEF_H\n#define GCC_HOST_HOOKS_DEF_H\n\n#include \"hooks.h\"\n\n#define HOST_HOOKS_EXTRA_SIGNALS hook_void_void\n#if HAVE_MMAP_FILE\n#define HOST_HOOKS_GT_PCH_GET_ADDRESS mmap_gt_pch_get_address\n#define HOST_HOOKS_GT_PCH_USE_ADDRESS mmap_gt_pch_use_address\n#else\n#define HOST_HOOKS_GT_PCH_GET_ADDRESS default_gt_pch_get_address\n#define HOST_HOOKS_GT_PCH_USE_ADDRESS default_gt_pch_use_address\n#endif\n\nextern void* default_gt_pch_get_address (size_t, int);\nextern int default_gt_pch_use_address (void *, size_t, int, size_t);\nextern void* mmap_gt_pch_get_address (size_t, int);\nextern int mmap_gt_pch_use_address (void *, size_t, int, size_t);\n\n/* The structure is defined in hosthooks.h.  */\n#define HOST_HOOKS_INITIALIZER {\t\t\\\n  HOST_HOOKS_EXTRA_SIGNALS,\t\t\t\\\n  HOST_HOOKS_GT_PCH_GET_ADDRESS,\t\t\\\n  HOST_HOOKS_GT_PCH_USE_ADDRESS\t\t\t\\\n}\n\n#endif /* GCC_HOST_HOOKS_DEF_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOSTHOOK": {"ttr": 6154, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* The host_hooks data structure.\n   Copyright 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_HOST_HOOKS_H\n#define GCC_HOST_HOOKS_H\n\nstruct host_hooks\n{\n  void (*extra_signals) (void);\n\n  /* Identify an address that's likely to be free in a subsequent invocation\n     of the compiler.  The area should be able to hold SIZE bytes.  FD is an\n     open file descriptor if the host would like to probe with mmap.  */\n  void * (*gt_pch_get_address) (size_t size, int fd);\n\n  /* ADDR is an address returned by gt_pch_get_address.  Attempt to allocate\n     SIZE bytes at the same address and load it with the data from FD at\n     OFFSET.  Return -1 if we couldn't allocate memory at ADDR, return 0\n     if the memory is allocated but the data not loaded, return 1 if done.  */\n  int (*gt_pch_use_address) (void *addr, size_t size, int fd, size_t offset);\n\n  /* Whenever you add entries here, make sure you adjust hosthooks-def.h.  */\n};\n\n/* Each host provides its own.  */\nextern const struct host_hooks host_hooks;\n\n#endif /* GCC_LANG_HOOKS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HWINT": {"ttr": 6156, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* HOST_WIDE_INT definitions for the GNU compiler.\n   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   Provide definitions for macros which depend on HOST_BITS_PER_INT\n   and HOST_BITS_PER_LONG.  */\n\n#ifndef GCC_HWINT_H\n#define GCC_HWINT_H\n\n/* This describes the machine the compiler is hosted on.  */\n#define HOST_BITS_PER_CHAR  CHAR_BIT\n#define HOST_BITS_PER_SHORT (CHAR_BIT * SIZEOF_SHORT)\n#define HOST_BITS_PER_INT   (CHAR_BIT * SIZEOF_INT)\n#define HOST_BITS_PER_LONG  (CHAR_BIT * SIZEOF_LONG)\n\n/* If HAVE_LONG_LONG and SIZEOF_LONG_LONG aren't defined, but\n   GCC_VERSION >= 3000, assume this is the second or later stage of a\n   bootstrap, we do have long long, and it's 64 bits.  (This is\n   required by C99; we do have some ports that violate that assumption\n   but they're all cross-compile-only.)  Just in case, force a\n   constraint violation if that assumption is incorrect.  */\n#if !defined HAVE_LONG_LONG\n# if GCC_VERSION >= 3000 && !PUREISO && !USE_ONLY32\n#  define HAVE_LONG_LONG 1\n#  define SIZEOF_LONG_LONG 8\nextern char sizeof_long_long_must_be_8\u00ddsizeof(long long) == 8 ? 1 : -1\u00a8;\n# endif\n#endif\n\n#ifdef HAVE_LONG_LONG\n# define HOST_BITS_PER_LONGLONG (CHAR_BIT * SIZEOF_LONG_LONG)\n#endif\n#ifdef HAVE___INT64\n# define HOST_BITS_PER___INT64 (CHAR_BIT * SIZEOF___INT64)\n#endif\n\n/* Set HOST_WIDE_INT.  This should be the widest efficient host\n   integer type.  It can be 32 or 64 bits, except that if we are\n   targeting a machine with 64-bit size_t then it has to be 64 bits.\n\n   With a sane ABI, 'long' is the largest efficient host integer type.\n   Thus, we use that unless we have to use 'long long' or '__int64'\n   because we're targeting a 64-bit machine from a 32-bit host.  */\n\n#if HOST_BITS_PER_LONG >= 64 || !defined NEED_64BIT_HOST_WIDE_INT\n#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n#   define HOST_WIDE_INT long\n#else\n# if HOST_BITS_PER_LONGLONG >= 64\n#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONGLONG\n#   define HOST_WIDE_INT long long\n# else\n#  if HOST_BITS_PER___INT64 >= 64\n#   define HOST_BITS_PER_WIDE_INT HOST_BITS_PER___INT64\n#   define HOST_WIDE_INT __int64\n#  else\n    #error \"Unable to find a suitable type for HOST_WIDE_INT\"\n#  endif\n# endif\n#endif\n\n/* Various printf format strings for HOST_WIDE_INT.  */\n\n#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n# define HOST_WIDE_INT_PRINT \"l\"\n# define HOST_WIDE_INT_PRINT_C \"L\"\n  /* 'long' might be 32 or 64 bits, and the number of leading zeroes\n     must be tweaked accordingly.  */\n# if HOST_BITS_PER_WIDE_INT == 64\n#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%lx%016lx\"\n# else\n#  define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%lx%08lx\"\n# endif\n#else\n# define HOST_WIDE_INT_PRINT \"ll\"\n# define HOST_WIDE_INT_PRINT_C \"LL\"\n  /* We can assume that 'long long' is at least 64 bits.  */\n# define HOST_WIDE_INT_PRINT_DOUBLE_HEX \"0x%llx%016llx\"\n#endif /* HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG */\n\n#define HOST_WIDE_INT_PRINT_DEC \"%\" HOST_WIDE_INT_PRINT \"d\"\n#define HOST_WIDE_INT_PRINT_DEC_C HOST_WIDE_INT_PRINT_DEC HOST_WIDE_INT_PRINT_C\n#define HOST_WIDE_INT_PRINT_UNSIGNED \"%\" HOST_WIDE_INT_PRINT \"u\"\n#define HOST_WIDE_INT_PRINT_HEX \"0x%\" HOST_WIDE_INT_PRINT \"x\"\n\n/* Set HOST_WIDEST_INT.  This is a 64-bit type unless the compiler\n   in use has no 64-bit type at all; in that case it's 32 bits.  */\n\n#if HOST_BITS_PER_WIDE_INT >= 64 \\\n    || (HOST_BITS_PER_LONGLONG < 64 && HOST_BITS_PER___INT64 < 64)\n# define HOST_WIDEST_INT\t\t      HOST_WIDE_INT\n# define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_WIDE_INT\n# define HOST_WIDEST_INT_PRINT_DEC\t      HOST_WIDE_INT_PRINT_DEC\n# define HOST_WIDEST_INT_PRINT_DEC_C\t      HOST_WIDE_INT_PRINT_DEC_C\n# define HOST_WIDEST_INT_PRINT_UNSIGNED\t      HOST_WIDE_INT_PRINT_UNSIGNED\n# define HOST_WIDEST_INT_PRINT_HEX\t      HOST_WIDE_INT_PRINT_HEX\n# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     HOST_WIDE_INT_PRINT_DOUBLE_HEX\n#else\n# if HOST_BITS_PER_LONGLONG >= 64\n#  define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER_LONGLONG\n#  define HOST_WIDEST_INT\t\t      long long\n# else\n#  if HOST_BITS_PER___INT64 >= 64\n#   define HOST_BITS_PER_WIDEST_INT\t      HOST_BITS_PER___INT64\n#   define HOST_WIDEST_INT\t\t      __int64\n#  else\n    #error \"This line should be impossible to reach\"\n#  endif\n# endif\n# define HOST_WIDEST_INT_PRINT_DEC\t      \"%lld\"\n# define HOST_WIDEST_INT_PRINT_DEC_C\t      \"%lldLL\"\n# define HOST_WIDEST_INT_PRINT_UNSIGNED\t      \"%llu\"\n# define HOST_WIDEST_INT_PRINT_HEX\t      \"0x%llx\"\n# define HOST_WIDEST_INT_PRINT_DOUBLE_HEX     \"0x%llx%016llx\"\n#endif\n\n#endif /* ! GCC_HWINT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I@CONSTA": {"ttr": 6158, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genconstants'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CONSTANTS_H\n#define GCC_INSN_CONSTANTS_H\n\n\n#endif /* GCC_INSN_CONSTANTS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INPUT": {"ttr": 6661, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for variables relating to reading the source file.\n   Used by parsers, lexical analyzers, and error message routines.\n   Copyright (C) 1993, 1997, 1998, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_INPUT_H\n#define GCC_INPUT_H\n\n/* The data structure used to record a location in a translation unit.  */\n/* Long-term, we want to get rid of this and typedef fileline location_t.  */\nstruct location_s GTY (())\n{\n  /* The name of the source file involved.  */\n  const char *file;\n\n  /* The line-location in the source file.  */\n  int line;\n};\ntypedef struct location_s location_t;\n\nstruct file_stack\n{\n  struct file_stack *next;\n  location_t location;\n};\n\n/* Top-level source file.  */\nextern const char *main_input_filename;\n\nextern location_t input_location;\n#define input_line (input_location.line)\n#define input_filename (input_location.file)\n\n/* Stack of currently pending input files.\n   The line member is not accurate for the innermost file on the stack.  */\nextern struct file_stack *input_file_stack;\n\n/* Stack of EXPR_WITH_FILE_LOCATION nested expressions.  */\nextern struct file_stack *expr_wfl_stack;\n\n/* Incremented on each change to input_file_stack.  */\nextern int input_file_stack_tick;\n\nextern void push_srcloc (const char *name, int line);\nextern void pop_srcloc (void);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@ADD": {"ttr": 6663, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Macros to support INSN_ADDRESSES\n   Copyright (C) 2000 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_INSN_ADDR_H\n#define GCC_INSN_ADDR_H\n\n#include \"varray.h\"\n\nextern GTY(()) varray_type insn_addresses_;\nextern int insn_current_address;\n\n#define INSN_ADDRESSES_DEFN() varray_type insn_addresses_\n#define INSN_ADDRESSES(id) VARRAY_INT (insn_addresses_, (id))\n#define INSN_ADDRESSES_ALLOC(size) \\\n  VARRAY_INT_INIT (insn_addresses_, (size), \"insn_addresses\")\n#define INSN_ADDRESSES_FREE() (insn_addresses_ = 0)\n#define INSN_ADDRESSES_SET_P() (insn_addresses_ != 0)\n#define INSN_ADDRESSES_SIZE() VARRAY_SIZE (insn_addresses_)\n#define INSN_ADDRESSES_NEW(insn, addr) do \\\n  {\t\t\t\t\t\t\t\t\t\\\n    unsigned insn_uid__ = INSN_UID ((insn));\t\t\t\t\\\n    int insn_addr__ = (addr);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (INSN_ADDRESSES_SET_P ())\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tif (INSN_ADDRESSES_SIZE () <= insn_uid__)\t\t\t\\\n\t  VARRAY_GROW (insn_addresses_, insn_uid__ + 1);\t\t\\\n\tINSN_ADDRESSES (insn_uid__) = insn_addr__;\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\nwhile (0)\n\n#endif /* ! GCC_INSN_ADDR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSN@ATT": {"ttr": 6665, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genattr'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_ATTR_H\n#define GCC_INSN_ATTR_H\n\n#define HAVE_ATTR_alternative\n#define get_attr_alternative(insn) which_alternative\n#define HAVE_ATTR_length\nextern int get_attr_length (rtx);\nextern void shorten_branches (rtx);\nextern int insn_default_length (rtx);\nextern int insn_variable_length_p (rtx);\nextern int insn_current_length (rtx);\n\n#include \"insn-addr.h\"\n\ntypedef void *state_t;\n\n\n#define ATTR_FLAG_forward\t0x1\n#define ATTR_FLAG_backward\t0x2\n#define ATTR_FLAG_likely\t0x4\n#define ATTR_FLAG_very_likely\t0x8\n#define ATTR_FLAG_unlikely\t0x10\n#define ATTR_FLAG_very_unlikely\t0x20\n\n#endif /* GCC_INSN_ATTR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSN@COD": {"ttr": 6667, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `gencodes'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CODES_H\n#define GCC_INSN_CODES_H\n\nenum insn_code {\n  CODE_FOR_tstdi = 0,\n  CODE_FOR_tstsi = 1,\n  CODE_FOR_tsthi = 2,\n  CODE_FOR_tstdf = 3,\n  CODE_FOR_tstsf = 4,\n  CODE_FOR_cmpsi = 5,\n  CODE_FOR_cmphi = 6,\n  CODE_FOR_cmpqi = 8,\n  CODE_FOR_cmpdf = 9,\n  CODE_FOR_cmpsf = 10,\n  CODE_FOR_cmpmemsi_1 = 12,\n  CODE_FOR_movdi = 14,\n  CODE_FOR_movsi = 15,\n  CODE_FOR_movhi = 17,\n  CODE_FOR_movqi = 19,\n  CODE_FOR_movstricthi = 20,\n  CODE_FOR_movdf = 22,\n  CODE_FOR_movsf = 24,\n  CODE_FOR_movstrsi_1 = 26,\n  CODE_FOR_extendhisi2 = 27,\n  CODE_FOR_extendqisi2 = 28,\n  CODE_FOR_extendqihi2 = 29,\n  CODE_FOR_zero_extendhisi2 = 30,\n  CODE_FOR_zero_extendqisi2 = 31,\n  CODE_FOR_zero_extendqihi2 = 32,\n  CODE_FOR_truncsihi2 = 33,\n  CODE_FOR_fix_truncdfsi2 = 34,\n  CODE_FOR_floatsidf2 = 35,\n  CODE_FOR_truncdfsf2 = 36,\n  CODE_FOR_extendsfdf2 = 37,\n  CODE_FOR_addsi3 = 41,\n  CODE_FOR_addhi3 = 42,\n  CODE_FOR_addqi3 = 43,\n  CODE_FOR_adddf3 = 44,\n  CODE_FOR_addsf3 = 45,\n  CODE_FOR_subsi3 = 47,\n  CODE_FOR_subhi3 = 48,\n  CODE_FOR_subqi3 = 49,\n  CODE_FOR_subdf3 = 50,\n  CODE_FOR_subsf3 = 51,\n  CODE_FOR_muldf3 = 54,\n  CODE_FOR_mulsf3 = 55,\n  CODE_FOR_divdf3 = 57,\n  CODE_FOR_divsf3 = 58,\n  CODE_FOR_andsi3 = 61,\n  CODE_FOR_andhi3 = 63,\n  CODE_FOR_andqi3 = 65,\n  CODE_FOR_iorsi3 = 67,\n  CODE_FOR_iorhi3 = 69,\n  CODE_FOR_iorqi3 = 71,\n  CODE_FOR_xorsi3 = 73,\n  CODE_FOR_xorhi3 = 75,\n  CODE_FOR_xorqi3 = 77,\n  CODE_FOR_negsi2 = 78,\n  CODE_FOR_neghi2 = 79,\n  CODE_FOR_negdf2 = 80,\n  CODE_FOR_negsf2 = 81,\n  CODE_FOR_abssi2 = 82,\n  CODE_FOR_abshi2 = 83,\n  CODE_FOR_absdf2 = 84,\n  CODE_FOR_abssf2 = 85,\n  CODE_FOR_one_cmplsi2 = 87,\n  CODE_FOR_one_cmplhi2 = 89,\n  CODE_FOR_one_cmplqi2 = 91,\n  CODE_FOR_ashldi3 = 92,\n  CODE_FOR_ashrdi3 = 93,\n  CODE_FOR_ashlsi3 = 94,\n  CODE_FOR_ashrsi3 = 95,\n  CODE_FOR_ashlhi3 = 96,\n  CODE_FOR_ashrhi3 = 97,\n  CODE_FOR_ashlqi3 = 98,\n  CODE_FOR_ashrqi3 = 99,\n  CODE_FOR_lshrdi3 = 100,\n  CODE_FOR_lshrsi3 = 101,\n  CODE_FOR_lshrhi3 = 102,\n  CODE_FOR_lshrqi3 = 103,\n  CODE_FOR_beq = 104,\n  CODE_FOR_bne = 105,\n  CODE_FOR_bgt = 106,\n  CODE_FOR_bgtu = 107,\n  CODE_FOR_blt = 108,\n  CODE_FOR_bltu = 109,\n  CODE_FOR_bge = 110,\n  CODE_FOR_bgeu = 111,\n  CODE_FOR_ble = 112,\n  CODE_FOR_bleu = 113,\n  CODE_FOR_jump = 126,\n  CODE_FOR_indirect_jump = 127,\n  CODE_FOR_tablejump = 128,\n  CODE_FOR_call = 129,\n  CODE_FOR_call_value = 130,\n  CODE_FOR_nop = 133,\n  CODE_FOR_cmpmemsi = 134,\n  CODE_FOR_clrstrsi = 135,\n  CODE_FOR_movstrsi = 136,\n  CODE_FOR_extendsidi2 = 137,\n  CODE_FOR_zero_extendsidi2 = 138,\n  CODE_FOR_mulsi3 = 139,\n  CODE_FOR_divsi3 = 140,\n  CODE_FOR_udivsi3 = 141,\n  CODE_FOR_modsi3 = 142,\n  CODE_FOR_umodsi3 = 143,\n  CODE_FOR_untyped_call = 144,\n  CODE_FOR_nothing\n};\n\n#endif /* GCC_INSN_CODES_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@CON": {"ttr": 6669, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genconfig'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_CONFIG_H\n#define GCC_INSN_CONFIG_H\n\n#define MAX_RECOG_OPERANDS 30\n#define MAX_DUP_OPERANDS 4\n#ifndef MAX_INSNS_PER_SPLIT\n#define MAX_INSNS_PER_SPLIT 1\n#endif\n#define HAVE_cc0 1\n#define CC0_P(X) ((X) == cc0_rtx)\n\n#endif /* GCC_INSN_CONFIG_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@FLA": {"ttr": 6671, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genflags'\n   from the machine description file `md'.  */\n\n#ifndef GCC_INSN_FLAGS_H\n#define GCC_INSN_FLAGS_H\n\n#define HAVE_tstdi 1\n#define HAVE_tstsi 1\n#define HAVE_tsthi 1\n#define HAVE_tstdf 1\n#define HAVE_tstsf 1\n#define HAVE_cmpsi 1\n#define HAVE_cmphi 1\n#define HAVE_cmpqi 1\n#define HAVE_cmpdf 1\n#define HAVE_cmpsf 1\n#define HAVE_cmpmemsi_1 1\n#define HAVE_movdi 1\n#define HAVE_movsi 1\n#define HAVE_movhi 1\n#define HAVE_movqi 1\n#define HAVE_movstricthi 1\n#define HAVE_movdf 1\n#define HAVE_movsf 1\n#define HAVE_movstrsi_1 1\n#define HAVE_extendhisi2 1\n#define HAVE_extendqisi2 1\n#define HAVE_extendqihi2 1\n#define HAVE_zero_extendhisi2 1\n#define HAVE_zero_extendqisi2 1\n#define HAVE_zero_extendqihi2 1\n#define HAVE_truncsihi2 1\n#define HAVE_fix_truncdfsi2 1\n#define HAVE_floatsidf2 1\n#define HAVE_truncdfsf2 1\n#define HAVE_extendsfdf2 1\n#define HAVE_addsi3 1\n#define HAVE_addhi3 1\n#define HAVE_addqi3 1\n#define HAVE_adddf3 1\n#define HAVE_addsf3 1\n#define HAVE_subsi3 1\n#define HAVE_subhi3 1\n#define HAVE_subqi3 1\n#define HAVE_subdf3 1\n#define HAVE_subsf3 1\n#define HAVE_muldf3 1\n#define HAVE_mulsf3 1\n#define HAVE_divdf3 1\n#define HAVE_divsf3 1\n#define HAVE_andsi3 1\n#define HAVE_andhi3 1\n#define HAVE_andqi3 1\n#define HAVE_iorsi3 1\n#define HAVE_iorhi3 1\n#define HAVE_iorqi3 1\n#define HAVE_xorsi3 1\n#define HAVE_xorhi3 1\n#define HAVE_xorqi3 1\n#define HAVE_negsi2 1\n#define HAVE_neghi2 1\n#define HAVE_negdf2 1\n#define HAVE_negsf2 1\n#define HAVE_abssi2 1\n#define HAVE_abshi2 1\n#define HAVE_absdf2 1\n#define HAVE_abssf2 1\n#define HAVE_one_cmplsi2 1\n#define HAVE_one_cmplhi2 1\n#define HAVE_one_cmplqi2 1\n#define HAVE_ashldi3 1\n#define HAVE_ashrdi3 1\n#define HAVE_ashlsi3 1\n#define HAVE_ashrsi3 1\n#define HAVE_ashlhi3 1\n#define HAVE_ashrhi3 1\n#define HAVE_ashlqi3 1\n#define HAVE_ashrqi3 1\n#define HAVE_lshrdi3 1\n#define HAVE_lshrsi3 1\n#define HAVE_lshrhi3 1\n#define HAVE_lshrqi3 1\n#define HAVE_beq 1\n#define HAVE_bne 1\n#define HAVE_bgt 1\n#define HAVE_bgtu 1\n#define HAVE_blt 1\n#define HAVE_bltu 1\n#define HAVE_bge 1\n#define HAVE_bgeu 1\n#define HAVE_ble 1\n#define HAVE_bleu 1\n#define HAVE_jump 1\n#define HAVE_indirect_jump 1\n#define HAVE_tablejump 1\n#define HAVE_call 1\n#define HAVE_call_value 1\n#define HAVE_nop 1\n#define HAVE_cmpmemsi 1\n#define HAVE_clrstrsi 1\n#define HAVE_movstrsi 1\n#define HAVE_extendsidi2 1\n#define HAVE_zero_extendsidi2 1\n#define HAVE_mulsi3 1\n#define HAVE_divsi3 1\n#define HAVE_udivsi3 1\n#define HAVE_modsi3 1\n#define HAVE_umodsi3 1\n#define HAVE_untyped_call 1\nextern rtx        gen_tstdi            (rtx);\nextern rtx        gen_tstsi            (rtx);\nextern rtx        gen_tsthi            (rtx);\nextern rtx        gen_tstdf            (rtx);\nextern rtx        gen_tstsf            (rtx);\nextern rtx        gen_cmpsi            (rtx, rtx);\nextern rtx        gen_cmphi            (rtx, rtx);\nextern rtx        gen_cmpqi            (rtx, rtx);\nextern rtx        gen_cmpdf            (rtx, rtx);\nextern rtx        gen_cmpsf            (rtx, rtx);\nextern rtx        gen_cmpmemsi_1       (rtx, rtx, rtx);\nextern rtx        gen_movdi            (rtx, rtx);\nextern rtx        gen_movsi            (rtx, rtx);\nextern rtx        gen_movhi            (rtx, rtx);\nextern rtx        gen_movqi            (rtx, rtx);\nextern rtx        gen_movstricthi      (rtx, rtx);\nextern rtx        gen_movdf            (rtx, rtx);\nextern rtx        gen_movsf            (rtx, rtx);\nextern rtx        gen_movstrsi_1       (rtx, rtx);\nextern rtx        gen_extendhisi2      (rtx, rtx);\nextern rtx        gen_extendqisi2      (rtx, rtx);\nextern rtx        gen_extendqihi2      (rtx, rtx);\nextern rtx        gen_zero_extendhisi2 (rtx, rtx);\nextern rtx        gen_zero_extendqisi2 (rtx, rtx);\nextern rtx        gen_zero_extendqihi2 (rtx, rtx);\nextern rtx        gen_truncsihi2       (rtx, rtx);\nextern rtx        gen_fix_truncdfsi2   (rtx, rtx);\nextern rtx        gen_floatsidf2       (rtx, rtx);\nextern rtx        gen_truncdfsf2       (rtx, rtx);\nextern rtx        gen_extendsfdf2      (rtx, rtx);\nextern rtx        gen_addsi3           (rtx, rtx, rtx);\nextern rtx        gen_addhi3           (rtx, rtx, rtx);\nextern rtx        gen_addqi3           (rtx, rtx, rtx);\nextern rtx        gen_adddf3           (rtx, rtx, rtx);\nextern rtx        gen_addsf3           (rtx, rtx, rtx);\nextern rtx        gen_subsi3           (rtx, rtx, rtx);\nextern rtx        gen_subhi3           (rtx, rtx, rtx);\nextern rtx        gen_subqi3           (rtx, rtx, rtx);\nextern rtx        gen_subdf3           (rtx, rtx, rtx);\nextern rtx        gen_subsf3           (rtx, rtx, rtx);\nextern rtx        gen_muldf3           (rtx, rtx, rtx);\nextern rtx        gen_mulsf3           (rtx, rtx, rtx);\nextern rtx        gen_divdf3           (rtx, rtx, rtx);\nextern rtx        gen_divsf3           (rtx, rtx, rtx);\nextern rtx        gen_andsi3           (rtx, rtx, rtx);\nextern rtx        gen_andhi3           (rtx, rtx, rtx);\nextern rtx        gen_andqi3           (rtx, rtx, rtx);\nextern rtx        gen_iorsi3           (rtx, rtx, rtx);\nextern rtx        gen_iorhi3           (rtx, rtx, rtx);\nextern rtx        gen_iorqi3           (rtx, rtx, rtx);\nextern rtx        gen_xorsi3           (rtx, rtx, rtx);\nextern rtx        gen_xorhi3           (rtx, rtx, rtx);\nextern rtx        gen_xorqi3           (rtx, rtx, rtx);\nextern rtx        gen_negsi2           (rtx, rtx);\nextern rtx        gen_neghi2           (rtx, rtx);\nextern rtx        gen_negdf2           (rtx, rtx);\nextern rtx        gen_negsf2           (rtx, rtx);\nextern rtx        gen_abssi2           (rtx, rtx);\nextern rtx        gen_abshi2           (rtx, rtx);\nextern rtx        gen_absdf2           (rtx, rtx);\nextern rtx        gen_abssf2           (rtx, rtx);\nextern rtx        gen_one_cmplsi2      (rtx, rtx);\nextern rtx        gen_one_cmplhi2      (rtx, rtx);\nextern rtx        gen_one_cmplqi2      (rtx, rtx);\nextern rtx        gen_ashldi3          (rtx, rtx, rtx);\nextern rtx        gen_ashrdi3          (rtx, rtx, rtx);\nextern rtx        gen_ashlsi3          (rtx, rtx, rtx);\nextern rtx        gen_ashrsi3          (rtx, rtx, rtx);\nextern rtx        gen_ashlhi3          (rtx, rtx, rtx);\nextern rtx        gen_ashrhi3          (rtx, rtx, rtx);\nextern rtx        gen_ashlqi3          (rtx, rtx, rtx);\nextern rtx        gen_ashrqi3          (rtx, rtx, rtx);\nextern rtx        gen_lshrdi3          (rtx, rtx, rtx);\nextern rtx        gen_lshrsi3          (rtx, rtx, rtx);\nextern rtx        gen_lshrhi3          (rtx, rtx, rtx);\nextern rtx        gen_lshrqi3          (rtx, rtx, rtx);\nextern rtx        gen_beq              (rtx);\nextern rtx        gen_bne              (rtx);\nextern rtx        gen_bgt              (rtx);\nextern rtx        gen_bgtu             (rtx);\nextern rtx        gen_blt              (rtx);\nextern rtx        gen_bltu             (rtx);\nextern rtx        gen_bge              (rtx);\nextern rtx        gen_bgeu             (rtx);\nextern rtx        gen_ble              (rtx);\nextern rtx        gen_bleu             (rtx);\nextern rtx        gen_jump             (rtx);\nextern rtx        gen_indirect_jump    (rtx);\nextern rtx        gen_tablejump        (rtx, rtx);\n#define GEN_CALL(A, B, C, D) gen_call ((A), (B))\nextern rtx        gen_call             (rtx, rtx);\n#define GEN_CALL_VALUE(A, B, C, D, E) gen_call_value ((A), (B), (C))\nextern rtx        gen_call_value       (rtx, rtx, rtx);\nextern rtx        gen_nop              (void);\nextern rtx        gen_cmpmemsi         (rtx, rtx, rtx, rtx, rtx);\nextern rtx        gen_clrstrsi         (rtx, rtx, rtx);\nextern rtx        gen_movstrsi         (rtx, rtx, rtx, rtx);\nextern rtx        gen_extendsidi2      (rtx, rtx);\nextern rtx        gen_zero_extendsidi2 (rtx, rtx);\nextern rtx        gen_mulsi3           (rtx, rtx, rtx);\nextern rtx        gen_divsi3           (rtx, rtx, rtx);\nextern rtx        gen_udivsi3          (rtx, rtx, rtx);\nextern rtx        gen_modsi3           (rtx, rtx, rtx);\nextern rtx        gen_umodsi3          (rtx, rtx, rtx);\nextern rtx        gen_untyped_call     (rtx, rtx, rtx);\n\n#endif /* GCC_INSN_FLAGS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSN@MOD": {"ttr": 6674, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically from machmode.def\n   by genmodes.  */\n\n#ifndef GCC_INSN_MODES_H\n#define GCC_INSN_MODES_H\n\nenum machine_mode\n{\n  VOIDmode,                /* machmode.def:146 */\n  BLKmode,                 /* machmode.def:150 */\n  CCmode,                  /* machmode.def:178 */\n  BImode,                  /* machmode.def:153 */\n  QImode,                  /* machmode.def:158 */\n  HImode,                  /* machmode.def:159 */\n  SImode,                  /* machmode.def:160 */\n  DImode,                  /* machmode.def:161 */\n  TImode,                  /* machmode.def:162 */\n  SFmode,                  /* machmode.def:173 */\n  DFmode,                  /* machmode.def:174 */\n  CQImode,                 /* machmode.def:186 */\n  CHImode,                 /* machmode.def:186 */\n  CSImode,                 /* machmode.def:186 */\n  CDImode,                 /* machmode.def:186 */\n  CTImode,                 /* machmode.def:186 */\n  SCmode,                  /* machmode.def:187 */\n  DCmode,                  /* machmode.def:187 */\n  V2QImode,                /* machmode.def:190 */\n  V4QImode,                /* machmode.def:191 */\n  V2HImode,                /* machmode.def:191 */\n  V8QImode,                /* machmode.def:192 */\n  V4HImode,                /* machmode.def:192 */\n  V2SImode,                /* machmode.def:192 */\n  V1DImode,                /* machmode.def:206 */\n  V16QImode,               /* machmode.def:193 */\n  V8HImode,                /* machmode.def:193 */\n  V4SImode,                /* machmode.def:193 */\n  V2DImode,                /* machmode.def:193 */\n  V8SImode,                /* machmode.def:197 */\n  V4DImode,                /* machmode.def:198 */\n  V8DImode,                /* machmode.def:199 */\n  V2SFmode,                /* machmode.def:209 */\n  V4SFmode,                /* machmode.def:210 */\n  V2DFmode,                /* machmode.def:210 */\n  V8SFmode,                /* machmode.def:214 */\n  V4DFmode,                /* machmode.def:216 */\n  V16SFmode,               /* machmode.def:215 */\n  V8DFmode,                /* machmode.def:217 */\n  MAX_MACHINE_MODE,\n\n  MIN_MODE_RANDOM = VOIDmode,\n  MAX_MODE_RANDOM = BLKmode,\n\n  MIN_MODE_CC = CCmode,\n  MAX_MODE_CC = CCmode,\n\n  MIN_MODE_INT = QImode,\n  MAX_MODE_INT = TImode,\n\n  MIN_MODE_PARTIAL_INT = VOIDmode,\n  MAX_MODE_PARTIAL_INT = VOIDmode,\n\n  MIN_MODE_FLOAT = SFmode,\n  MAX_MODE_FLOAT = DFmode,\n\n  MIN_MODE_COMPLEX_INT = CQImode,\n  MAX_MODE_COMPLEX_INT = CTImode,\n\n  MIN_MODE_COMPLEX_FLOAT = SCmode,\n  MAX_MODE_COMPLEX_FLOAT = DCmode,\n\n  MIN_MODE_VECTOR_INT = V2QImode,\n  MAX_MODE_VECTOR_INT = V8DImode,\n\n  MIN_MODE_VECTOR_FLOAT = V2SFmode,\n  MAX_MODE_VECTOR_FLOAT = V8DFmode,\n\n  NUM_MACHINE_MODES = MAX_MACHINE_MODE\n};\n\n#define CONST_MODE_SIZE const\n#define CONST_MODE_BASE_ALIGN const\n\n#endif /* insn-modes.h */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INTEGRAT": {"ttr": 6913, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Function integration definitions for GCC\n   Copyright (C) 1990, 1995, 1998, 1999, 2000, 2001, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"varray.h\"\n\n/* This structure is used to remap objects in the function being inlined to\n   those belonging to the calling function.  It is passed by\n   expand_inline_function to its children.\n\n   This structure is also used when unrolling loops and otherwise\n   replicating code, although not all fields are needed in this case;\n   only those fields needed by copy_rtx_and_substitute() and its children\n   are used.\n\n   This structure is used instead of static variables because\n   expand_inline_function may be called recursively via expand_expr.  */\n\nstruct inline_remap\n{\n  /* True if we are doing function integration, false otherwise.\n     Used to control whether RTX_UNCHANGING bits are copied by\n     copy_rtx_and_substitute.  */\n  int integrating;\n  /* Definition of function be inlined.  */\n  tree fndecl;\n  /* Place to put insns needed at start of function.  */\n  rtx insns_at_start;\n  /* Mapping from old BLOCKs to new BLOCKs.  */\n  varray_type block_map;\n  /* Mapping from old registers to new registers.\n     It is allocated and deallocated in `expand_inline_function' */\n  rtx *reg_map;\n#if defined (LEAF_REGISTERS) && defined (LEAF_REG_REMAP)\n  /* Mapping from old leaf registers to new leaf registers.  */\n  rtx leaf_reg_map\u00ddFIRST_PSEUDO_REGISTER\u00a8\u00ddNUM_MACHINE_MODES\u00a8;\n#endif\n  /* Mapping from old code-labels to new code-labels.\n     The first element of this map is label_map\u00ddmin_labelno\u00a8.  */\n  rtx *label_map;\n  /* Mapping from old insn uid's to copied insns.  The first element\n   of this map is insn_map\u00ddmin_insnno\u00a8; the last element is\n   insn_map\u00ddmax_insnno\u00a8.  We keep the bounds here for when the map\n   only covers a partial range of insns (such as loop unrolling or\n   code replication).  */\n  rtx *insn_map;\n  int min_insnno, max_insnno;\n\n  /* Map pseudo reg number in calling function to equivalent constant.  We\n     cannot in general substitute constants into parameter pseudo registers,\n     since some machine descriptions (many RISCs) won't always handle\n     the resulting insns.  So if an incoming parameter has a constant\n     equivalent, we record it here, and if the resulting insn is\n     recognizable, we go with it.\n\n     We also use this mechanism to convert references to incoming arguments\n     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n     incoming argument and virtual stacked variables registers with new\n     pseudos that contain pointers into the replacement area allocated for\n     this inline instance.  These pseudos are then marked as being equivalent\n     to the appropriate address and substituted if valid.  */\n  varray_type const_equiv_varray;\n  /* This is incremented for each new basic block.\n     It is used to store in the age field to record the domain of validity\n     of each entry in const_equiv_varray.\n     A value of -1 indicates an entry for a reg which is a parm.\n     All other values are \"positive\".  */\n#define CONST_AGE_PARM (-1)\n  unsigned int const_age;\n\n  /* Target of the inline function being expanded, or NULL if none.  */\n  rtx inline_target;\n  /* When an insn is being copied by copy_rtx_and_substitute,\n     this is nonzero if we have copied an ASM_OPERANDS.\n     In that case, it is the original input-operand vector.  */\n  rtvec orig_asm_operands_vector;\n  /* When an insn is being copied by copy_rtx_and_substitute,\n     this is nonzero if we have copied an ASM_OPERANDS.\n     In that case, it is the copied input-operand vector.  */\n  rtvec copy_asm_operands_vector;\n  /* Likewise, this is the copied constraints vector.  */\n  rtvec copy_asm_constraints_vector;\n\n  /* Target of a return insn, if needed and inlining.  */\n  rtx local_return_label;\n\n  /* Indications for regs being pointers and their alignment.  */\n  unsigned char *regno_pointer_align;\n  rtx *x_regno_reg_rtx;\n\n  /* The next few fields are used for subst_constants to record the SETs\n     that it saw.  */\n  int num_sets;\n  struct equiv_table\n    {\n      rtx dest;\n      rtx equiv;\n    }  equiv_sets\u00ddMAX_RECOG_OPERANDS\u00a8;\n  /* Record the last thing assigned to pc.  This is used for folded\n     conditional branch insns.  */\n  rtx last_pc_value;\n#ifdef HAVE_cc0\n  /* Record the last thing assigned to cc0.  */\n  rtx last_cc0_value;\n#endif\n  /* Note mode of COMPARE if the mode would be otherwise lost (comparing of\n     two VOIDmode constants.  */\n  rtx compare_src;\n  enum machine_mode compare_mode;\n};\n\n/* Return a copy of an rtx (as needed), substituting pseudo-register,\n   labels, and frame-pointer offsets as necessary.  */\nextern rtx copy_rtx_and_substitute (rtx, struct inline_remap *, int);\n\n/* Return a pseudo that corresponds to the value in the specified hard\n   reg as of the start of the function (for inlined functions, the\n   value at the start of the parent function).  */\nextern rtx get_hard_reg_initial_val (enum machine_mode, int);\n/* Likewise, but for a different than the current function, or\n   arbitrary expression.  */\nextern rtx get_func_hard_reg_initial_val (struct function *, rtx);\n/* Likewise, but iff someone else has caused it to become allocated.  */\nextern rtx has_func_hard_reg_initial_val (struct function *, rtx);\n/* Likewise, but for common cases.  */\nextern rtx has_hard_reg_initial_val (enum machine_mode, int);\n/* If a pseudo represents an initial hard reg (or expression), return\n   it, else return NULL_RTX.  */\nextern rtx get_hard_reg_initial_reg (struct function *, rtx);\n/* Called from rest_of_compilation.  */\nextern void emit_initial_value_sets (void);\nextern void allocate_initial_values (rtx *);\n\n/* Copy a declaration when one function is substituted inline into\n   another.  */\nextern tree copy_decl_for_inlining (tree, tree, tree);\n\n/* Check whether there's any attribute in a function declaration that\n   makes the function uninlinable.  Returns false if it finds any,\n   true otherwise.  */\nextern bool function_attribute_inlinable_p (tree);\n\nextern void try_constants (rtx, struct inline_remap *);\n\n/* Return the label indicated.  */\nextern rtx get_label_from_map (struct inline_remap *, int);\n\n/* Set the label indicated.  */\n#define set_label_in_map(MAP, I, X) ((MAP)->label_map\u00ddI\u00a8 = (X))\n\n/* Unfortunately, we need a global copy of const_equiv varray for\n   communication with a function called from note_stores.  Be *very*\n   careful that this is used properly in the presence of recursion.  */\n\nextern varray_type global_const_equiv_varray;\n\n#define MAYBE_EXTEND_CONST_EQUIV_VARRAY(MAP,MAX)\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    if ((size_t)(MAX) >= VARRAY_SIZE ((MAP)->const_equiv_varray))\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n        int is_global = (global_const_equiv_varray\t\t\t\\\n\t\t\t == (MAP)->const_equiv_varray);\t\t\t\\\n        VARRAY_GROW ((MAP)->const_equiv_varray, (MAX)+1);\t\t\\\n\tif (is_global)\t\t\t\t\t\t\t\\\n\t   global_const_equiv_varray = (MAP)->const_equiv_varray;\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  }\n\n#define SET_CONST_EQUIV_DATA(MAP,REG,RTX,AGE)\t\t\t\t\\\n  {\t\t\t\t\t\t\t\t\t\\\n    struct const_equiv_data *p;\t\t\t\t\t\t\\\n    MAYBE_EXTEND_CONST_EQUIV_VARRAY ((MAP), REGNO (REG));\t\t\\\n    p = &VARRAY_CONST_EQUIV ((MAP)->const_equiv_varray, REGNO (REG));\t\\\n    p->rtx = (RTX);\t\t\t\t\t\t\t\\\n    p->age = (AGE);\t\t\t\t\t\t\t\\\n  }\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INTL": {"ttr": 6916, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* intl.h - internationalization\n   Copyright 1998, 2001, 2003 Free Software Foundation, Inc.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#ifndef GCC_INTL_H\n#define GCC_INTL_H\n\n#ifdef HAVE_LOCALE_H\n# include <locale.h>\n#endif\n\n#ifndef HAVE_SETLOCALE\n# define setlocale(category, locale) (locale)\n#endif\n\n#ifdef ENABLE_NLS\n#include <libintl.h>\nextern void gcc_init_libintl (void);\nextern size_t gcc_gettext_width (const char *);\n#else\n/* Stubs.  */\n# undef textdomain\n# define textdomain(domain) (domain)\n# undef bindtextdomain\n# define bindtextdomain(domain, directory) (domain)\n# undef gettext\n# define gettext(msgid) (msgid)\n# define gcc_init_libintl()\t/* nothing */\n# define gcc_gettext_width(s) strlen(s)\n#endif\n\n#ifndef _\n# define _(msgid) gettext (msgid)\n#endif\n\n#ifndef N_\n# define N_(msgid) msgid\n#endif\n\n#endif /* intl.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I370": {"ttr": 6162, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n   2003 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Modified for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_I370_H\n#define GCC_I370_H\n\n/* Target CPU builtins.  */\n#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      builtin_define_std (\"GCC\");\t\t\\\n      builtin_define_std (\"gcc\");\t\t\\\n      builtin_assert (\"machine=i370\");\t\t\\\n      builtin_assert (\"cpu=i370\");\t\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n\n/* Run-time compilation parameters selecting different hardware subsets.  */\n\nextern int target_flags;\n\n/* The sizes of the code and literals on the current page.  */\n\nextern int mvs_page_code, mvs_page_lit;\n\n/* The length of code used by case labels */\n\nextern int mvs_case_code;\n\n/* Specify that we need to be an entry point.  */\n\nextern int mvs_need_entry;\nextern int mvs_gotmain;\nextern int mvs_need_to_globalize;\n\n/* The current page number and the base page number for the function.  */\n\nextern int mvs_page_num, function_base_page;\n\n/* The name of the current function.  */\n\nextern char *mvs_function_name;\n\n/* The length of the function name malloc'd area.  */\n\nextern size_t mvs_function_name_length;\n\n/* The desired CSECT name */\n\nextern char *mvs_csect_name;\n\n/* The source file module.  */\n\nextern char *mvs_module;\n\n/* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n   these are more than twice as fast as load-op-store.\n   On 3090 don't use this since load-op-store is much faster.  */\n\n#define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)\n\n/* Compile experimental position independent code */\n#define TARGET_PIC (target_flags & 2)\nextern int i370_enable_pic;\n\n/* Default target switches */\n\n#define TARGET_DEFAULT 1\n\n/* We're not targetting 64 bit */\n\n#define TARGET_64BIT 0\n\n/* Macro to define tables used to set the flags.  This is a list in braces\n   of pairs in braces, each pair being { \"NAME\", VALUE }\n   where VALUE is the bits to set or minus the bits to clear.\n   An empty string NAME is used to identify the default VALUE.  */\n\n#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n{ { \"char-instructions\", 1, N_(\"Generate char instructions\")},            \\\n  { \"no-char-instructions\", -1, N_(\"Do not generate char instructions\")}, \\\n  { \"pickax\", 2, \"Experimental i370 PIC\"}, \\\n  { \"no-pickax\", -2, \"Disable experimental i370 PIC\"}, \\\n  { \"\", TARGET_DEFAULT, 0} }\n\n#define TARGET_OPTIONS \\\n{ { \"csect=\", (const char **)&mvs_csect_name, \\\n    N_(\"Set CSECT name\")},     \\\n  SUBTARGET_OPTIONS    \\\n}\n\n#define SUBTARGET_OPTIONS\n\nextern void i370_override_options (void);\n#define OVERRIDE_OPTIONS i370_override_options()\n\n/* To use IBM supplied macro function prologue and epilogue, define the\n   following to 1.  Should only be needed if IBM changes the definition\n   of their prologue and epilogue.  */\n\n#define MACROPROLOGUE 0\n#define MACROEPILOGUE 0\n\n/* Target machine storage layout */\n\n/* Define this if most significant bit is lowest numbered in instructions\n   that operate on numbered bit-fields.  */\n\n#define BITS_BIG_ENDIAN 1\n\n/* Define this if most significant byte of a word is the lowest numbered.  */\n\n#define BYTES_BIG_ENDIAN 1\n\n/* Define this if MS word of a multiword is the lowest numbered.  */\n\n#define WORDS_BIG_ENDIAN 1\n\n/* Width of a word, in units (bytes).  */\n\n#define UNITS_PER_WORD 4\n\n/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n\n#define POINTER_BOUNDARY 32\n\n/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n\n#define PARM_BOUNDARY 32\n\n/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n\n#define STACK_BOUNDARY 64\n\n/* Allocation boundary (in *bits*) for the code of a function.  */\n\n#define FUNCTION_BOUNDARY 32\n\n/* There is no point aligning anything to a rounder boundary than this.  */\n\n#define BIGGEST_ALIGNMENT 64\n\n/* Alignment of field after `int : 0' in a structure.  */\n\n#define EMPTY_FIELD_BOUNDARY 8\n\n/* Define this if move instructions will actually fail to work when given\n   unaligned data.  */\n\n#define STRICT_ALIGNMENT 0\n\n/* Define target floating point format.  */\n\n#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n\n/* Define character mapping for cross-compiling.  */\n/* but only define it if really needed, since otherwise it will break builds */\n\n#ifndef ASCTOEBC\n#define ASCTOEBC(c) (c)\n#endif\n#ifndef EBCTOASC\n#define EBCTOASC(c) (c)\n#endif\n\n#ifdef TARGET_EBCDIC\n#ifdef HOST_EBCDIC\n#define MAP_OUTCHAR(c) (c)\n#define MAP_INCHAR(c) (c)\n#else\n#define MAP_OUTCHAR(c) (ASCTOEBC (c))\n#define MAP_INCHAR(c) (EBCTOASC (c))\n#endif\n#else\n#ifdef HOST_EBCDIC\n#define MAP_OUTCHAR(c) ((char)EBCTOASC (c))\n#define MAP_INCHAR(c) (ASCTOEBC (c))\n#endif\n#endif\n\n#ifdef TARGET_HLASM\n/* HLASM requires #pragma map.  */\n#define REGISTER_TARGET_PRAGMAS() \\\n  do { \\\n  c_register_pragma (0, \"map\", i370_pr_map); \\\n  c_register_pragma (0, \"nomargins\", i370_pr_skipit); \\\n  c_register_pragma (0, \"nosequence\", i370_pr_skipit); \\\n  c_register_pragma (0, \"checkout\", i370_pr_checkout); \\\n  c_register_pragma (0, \"linkage\", i370_pr_linkage); \\\n  } while(0)\n#endif /* TARGET_HLASM */\n\n/* Define maximum length of page minus page escape overhead.  */\n\n#define MAX_MVS_PAGE_LENGTH 4068\n\n#define PREDICATE_CODES \\\n  {\"r_or_s_operand\", { REG, SUBREG, MEM }}, \\\n  {\"s_operand\", { MEM }},\n\n/* Conservative page size when considering literals and overhead. */\n\n#define MVS_PAGE_CONSERVATIVE 4060\n\n/* Define special register allocation order desired. */\n\n#define REG_ALLOC_ORDER \\\n   { 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 10, 15, 14, 12, 16, 17, 18, 19, 11, 13 }\n\n/* Standard register usage.  */\n\n/* Number of actual hardware registers.  The hardware registers are\n   assigned numbers for the compiler from 0 to just below\n   FIRST_PSEUDO_REGISTER.\n   All registers that the compiler knows about must be given numbers,\n   even those that are not normally considered general registers.\n   For the 370, we give the data registers numbers 0-15,\n   and the floating point registers numbers 16-19.  */\n\n#define FIRST_PSEUDO_REGISTER 20\n\n/* Define base and page registers.  */\n\n#define BASE_REGISTER 3\n#define PAGE_REGISTER 4\n#define PIC_BASE_REGISTER 12\n\n#ifdef TARGET_HLASM\n/* 1 for registers that have pervasive standard uses and are not available\n   for the register allocator.  These are registers that must have fixed,\n   valid values stored in them for the entire length of the subroutine call,\n   and must not in any way be moved around, jiggered with, etc. That is,\n   they must never be clobbered, and, if clobbered, the register allocator\n   will never restore them back.\n\n   For the LE/370 mode, we use five registers in this special way:\n   -- R3 which is used as the base register\n   -- R4 the page origin table pointer used to load R3,\n   -- R11 the arg pointer.\n   -- R12 the TCA pointer\n   -- R13 the stack (DSA) pointer\n\n   For TARGET_DIGNUS or TARGET_PDPMAC mode:\n   -- R10 the page origin table pointer used to load R3,\n   -- R11 the arg pointer.\n   -- R12 the base register.\n   -- R13 the stack pointer\n\n   A fifth register is also exceptional: R14 is used in many branch\n   instructions to hold the target of the branch.  Technically, this\n   does not qualify R14 as a register with a long-term meaning; it should\n   be enough, theoretically, to note that these instructions clobber\n   R14, and let the compiler deal with that.  In practice, however,\n   the \"clobber\" directive acts as a barrier to optimization, and the\n   optimizer appears to be unable to perform optimizations around branches.\n   Thus, a much better strategy appears to give R14 a pervasive use;\n   this eliminates it from the register pool witout hurting optimization.\n\n   There are other registers which have special meanings, but its OK\n   for them to get clobbered, since other allocator config below will\n   make sure that they always have the right value.  These are for\n   example:\n   -- R1 the returned structure pointer.\n   -- R10 the static chain reg.\n   -- R15 holds the value a subroutine returns.\n\n   Notice that it is *almost* safe to mark R11 as available to the allocator.\n   By marking it as a call_used_register, in most cases, the compiler\n   can handle it being clobbered.  However, there are a few rare\n   circumstances where the register allocator will allocate r11 and\n   also try to use it as the arg pointer ... thus it must be marked fixed.\n   I think this is a bug, but I can't track it down...\n */\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#undef PAGE_REGISTER\n#undef BASE_REGISTER\n#define PAGE_REGISTER 10\n#define BASE_REGISTER 12\n\n#ifdef TARGET_PDPMAC\n/* made register 1 fixed because it is used\n   for parameter passing, otherwise we DO\n   have a problem! */\n/* also made register 0 fixed, because I am using that\n   for the struct, instead of 1.  Why would anyone\n   choose 1 for the struct when it is being used\n   already for the parameters? */\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#else\n#define FIXED_REGISTERS                         \\\n{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n/* 1 for registers not available across function calls.  These must include\n   the FIXED_REGISTERS and also any registers that can be used without being\n   saved.\n   The latter must include the registers where values are returned\n   and the register where structure-value addresses are passed.\n   NOTE: all floating registers are undefined across calls.\n*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n#ifdef TARGET_LE\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n/* 1 for registers not available across function calls.  These must include\n   the FIXED_REGISTERS and also any registers that can be used without being\n   saved.\n   The latter must include the registers where values are returned\n   and the register where structure-value addresses are passed.\n   NOTE: all floating registers are undefined across calls.\n*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif /* TARGET_LE */\n\n#if !defined(TARGET_DIGNUS) && !defined(TARGET_PDPMAC) && !defined(TARGET_LE)\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n#endif\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n/* The Linux/ELF ABI uses the same register layout as the\n   the MVS/OE version, with the following exceptions:\n   -- r4 is not used; its role is taken by 0(r13)\n   -- r13 is used as a combined argument & frame pointer\n   -- r11 is used to point to the top of the stack.\n   -- r12 is used as a base pointer into the data section\n      but only if i370_enable_pic is true; otherwise we can\n      free up this register.\n\n   Note that the ELF calling convention is radically different\n   than the MVS/OE convention.  In particular, r11 always points\n   to the top of the stack, and r13 always points to the bottom\n   of the stack.  Thus, r13 can be used as a dual arg & frame\n   pointer for all occasions, whereas r11 can be used for alloca\n   and other stack-dynamic allocations.\n\n   XXX Future enhancment possible: When a function doesn't have\n   any args, and doesn't use alloca(), then r11 is not really needed.\n */\n\n#define FIXED_REGISTERS \t\t\t\t\t\t\\\n{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n{ 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n\n#endif /* TARGET_LINUX */\n/* ================= */\n\n\n/* Return number of consecutive hard regs needed starting at reg REGNO\n   to hold something of mode MODE.\n   This is ordinarily the length in words of a value of mode MODE\n   but can be less for certain modes in special long registers.\n   Note that DCmode (complex double) needs two regs.  */\n\n#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n  ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n   (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n\n/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n   On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n   even registers can hold DI.  The floating point registers can hold\n   either SF, DF, SC or DC.  */\n\n#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n  ((REGNO) < 16 ? (((REGNO) & 1) == 0 || \t\t\t\t\\\n\t\t  (((MODE) != DImode) && ((MODE) != DFmode)))\t\t\\\n\t\t: ((MODE) == SFmode || (MODE) == DFmode) ||\t\t\\\n                   (MODE) == SCmode || (MODE) == DCmode)\n\n/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n   mode MODE1 and one has mode MODE2.\n   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n   for any hard reg, then this must be 0 for correct output.  */\n\n#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n  (((MODE1) == SFmode || (MODE1) == DFmode)\t\t\t\t\\\n   == ((MODE2) == SFmode || (MODE2) == DFmode))\n\n/* Specify the registers used for certain standard purposes.\n   The values of these macros are register numbers.  */\n\n/* 370 PC isn't overloaded on a register.  */\n\n/* #define PC_REGNUM */\n\n/* ------------------------------------------------------------------- */\n/* ================= */\n#ifdef TARGET_HLASM\n\n/* Register to use for pushing function arguments.  */\n\n#define STACK_POINTER_REGNUM 13\n\n/* Base register for access to local variables of the function.  */\n\n#define FRAME_POINTER_REGNUM 13\n\n/* Value should be nonzero if functions must have frame pointers.\n   Zero means the frame pointer need not be set up (and parms may be\n   accessed via the stack pointer) in functions that seem suitable.\n   This is computed in `reload', in reload1.c.  */\n\n#define FRAME_POINTER_REQUIRED 1\n\n/* Base register for access to arguments of the function.  */\n\n#define ARG_POINTER_REGNUM 11\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n\n/* Register to use for pushing function arguments.  */\n\n#define STACK_POINTER_REGNUM 11\n\n/* Base register for access to local variables of the function.\n   A separate stack and frame pointer is required for any function\n   that calls alloca() or does other pushing onto the stack. */\n\n#define FRAME_POINTER_REGNUM 13\n\n/* Value should be nonzero if functions must have frame pointers.\n   Zero means the frame pointer need not be set up (and parms may be\n   accessed via the stack pointer) in functions that seem suitable.\n   This is computed in `reload', in reload1.c.  */\n\n#define FRAME_POINTER_REQUIRED 1\n\n/* Function epilogue uses the frame pointer to restore the context */\n#define EXIT_IGNORE_STACK 1\n\n/* Base register for access to arguments of the function.\n   We will use the frame pointer as the arg pointer. */\n\n#define ARG_POINTER_REGNUM 13\n\n#endif /* TARGET_LINUX */\n/* ================= */\n/* ------------------------------------------------------------------- */\n\n/* R10 is register in which static-chain is passed to a function.\n   Static-chaining is done when a nested function references as a global\n   a stack variable of its parent: e.g.\n        int parent_func (int arg) {\n             int x;                            // x is in parents stack\n             void child_func (void) { x++: }   // child references x as global var\n             ...\n        }\n */\n\n#define STATIC_CHAIN_REGNUM 10\n\n/* R1 is register in which address to store a structure value is passed to\n   a function.  This is used only when returning 64-bit long-long in a 32-bit arch\n   and when calling functions that return structs by value. e.g.\n        typedef struct A_s { int a,b,c; } A_t;\n        A_t fun_returns_value (void) {\n            A_t a; a.a=1; a.b=2 a.c=3;\n            return a;\n        }\n   In the above, the storage for the return value is in the callers stack, and\n   the R1 points at that mem location.\n */\n\n#ifdef TARGET_PDPMAC\n#define STRUCT_VALUE_REGNUM 0\n#else\n#define STRUCT_VALUE_REGNUM 1\n#endif\n\n/* Define the classes of registers for register constraints in the\n   machine description.  Also define ranges of constants.\n\n   One of the classes must always be named ALL_REGS and include all hard regs.\n   If there is more than one class, another class must be named NO_REGS\n   and contain no registers.\n\n   The name GENERAL_REGS must be the name of a class (or an alias for\n   another name such as ALL_REGS).  This is the class of registers\n   that is allowed by \"g\" or \"r\" in a register constraint.\n   Also, registers outside this class are allocated only when\n   instructions express preferences for them.\n\n   The classes must be numbered in nondecreasing order; that is,\n   a larger-numbered class must never be contained completely\n   in a smaller-numbered class.\n\n   For any two classes, it is very desirable that there be another\n   class that represents their union.  */\n\nenum reg_class\n  {\n    NO_REGS, ADDR_REGS, DATA_REGS,\n    FP_REGS, ALL_REGS, LIM_REG_CLASSES\n  };\n\n#define GENERAL_REGS DATA_REGS\n#define N_REG_CLASSES (int) LIM_REG_CLASSES\n\n/* Give names of register classes as strings for dump file.  */\n\n#define REG_CLASS_NAMES \t\t\t\t\t\t\\\n{ \"NO_REGS\", \"ADDR_REGS\", \"DATA_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n\n/* Define which registers fit in which classes.  This is an initializer for\n   a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n\n#define REG_CLASS_CONTENTS {{0}, {0x0fffe}, {0x0ffff}, {0xf0000}, {0xfffff}}\n\n/* The same information, inverted:\n   Return the class number of the smallest class containing\n   reg number REGNO.  This could be a conditional expression\n   or could index an array.  */\n\n#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n  ((REGNO) >= 16 ? FP_REGS : (REGNO) != 0 ? ADDR_REGS : DATA_REGS)\n\n/* The class value for index registers, and the one for base regs.  */\n\n#define INDEX_REG_CLASS ADDR_REGS\n#define BASE_REG_CLASS ADDR_REGS\n\n/* Get reg_class from a letter such as appears in the machine description.  */\n\n#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n  ((C) == 'a' ? ADDR_REGS :\t\t\t\t\t\t\\\n  ((C) == 'd' ? DATA_REGS :\t\t\t\t\t\t\\\n  ((C) == 'f' ? FP_REGS   : NO_REGS)))\n\n/* The letters I, J, K, L and M in a register constraint string can be used\n   to stand for particular ranges of immediate operands.\n   This macro defines what the ranges are.\n   C is the letter, and VALUE is a constant value.\n   Return 1 if VALUE is in the range specified by C.  */\n\n#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n  ((C) == 'I' ? (unsigned) (VALUE) < 256 :\t\t\t\t\\\n   (C) == 'J' ? (unsigned) (VALUE) < 4096 :\t\t\t\t\\\n   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 : 0)\n\n/* Similar, but for floating constants, and defining letters G and H.\n   Here VALUE is the CONST_DOUBLE rtx itself.  */\n\n#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n\n/* see recog.c for details */\n#define EXTRA_CONSTRAINT(OP,C)\t\t\t\t\t\t\\\n   ((C) == 'R' ? r_or_s_operand (OP, GET_MODE(OP)) :\t\t\t\\\n    (C) == 'S' ? s_operand (OP, GET_MODE(OP)) :\t0)\t\t\t\\\n\n/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n   return the class of reg to actually use.  In general this is just CLASS;\n   but on some machines in some cases it is preferable to use a more\n   restrictive class.\n\n   XXX We reload CONST_INT's into ADDR not DATA regs because on certain\n   rare occasions when lots of egisters are spilled, reload() will try\n   to put a const int into r0 and then use r0 as an index register.\n*/\n\n#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n    (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n     GET_CODE(X) == CONST_INT ? (reload_in_progress ? ADDR_REGS : DATA_REGS) :\t\\\n     GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n     GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n     GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n\n/* Return the maximum number of consecutive registers needed to represent\n   mode MODE in a register of class CLASS.\n   Note that DCmode (complex double) needs two regs.\n*/\n\n#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n  ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n   (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n\n/* Stack layout; function entry, exit and calling.  */\n\n/* Define this if pushing a word on the stack makes the stack pointer a\n   smaller address.  */\n\n/* #define STACK_GROWS_DOWNWARD */\n\n/* Define this if the nominal address of the stack frame is at the\n   high-address end of the local variables; that is, each additional local\n   variable allocated goes at a more negative offset in the frame.  */\n\n/* #define FRAME_GROWS_DOWNWARD */\n\n\n/* ------------------------------------------------------------------- */\n/* ================= */\n#ifdef TARGET_HLASM\n\n/* Define offset from stack pointer, to location where a parm can be\n   pushed.  */\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define STACK_POINTER_OFFSET 88\n#else\n#define STACK_POINTER_OFFSET 148\n#endif\n\n#define STACK_FRAME_BASE 88\n\n\n/* used in i370.md for temp scratch area */\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define CONVLO \"80\"\n#define CONVHI \"84\"\n#else\n#define CONVLO \"140\"\n#define CONVHI \"144\"\n#endif\n\n/* Offset within stack frame to start allocating local variables at.\n   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n   first local allocated.  Otherwise, it is the offset to the BEGINNING\n   of the first local allocated.  */\n\n#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n\n#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n\n/* Offset of first parameter from the argument pointer register value.  */\n\n#define FIRST_PARM_OFFSET(FNDECL) 0\n\n/* Accumulate the outgoing argument count so we can request the right\n   DSA size and determine stack offset.  */\n\n#define ACCUMULATE_OUTGOING_ARGS 1\n\n#endif /* TARGET_HLASM */\n\n/* ================= */\n#ifdef TARGET_LINUX\n/* Here's the stack layout as currently designed:\n\n   r11 -- top of stack aka stack pointer\n   -4(r11) -- last local (stack) variable)\n   ...          ...\n   88+4*nargs(r13) -- first local (stack) variable.\n   ...          ...\n   92(r13) -- second incoming (callee) argument\n   88(r13) -- first incoming (callee) argument\n   84(r13) -- volatile scratch area\n   80(r13) -- volatile scratch area\n   76(r13) -- not used (frame size)\n   72(r13) -- not used\n   68(r13) -- saved callers r12\n   64(r13) -- saved callers r11\n   ...          ...\n   28(r13) -- saved callers r2\n   24(r13) -- saved callers r1\n   20(r13) -- saved callers r0\n   16(r13) -- saved callers r15\n   12(r13) -- saved callers r14\n   8(r13)  -- saved callers r13\n   4(r13)  -- not used\n   0(r13)  -- code page table pointer\n   r13 -- bottom of stack aka frame pointer aka arg pointer\n\n   Note that this bears superficial similarity to the MVS/OE stack layout,\n   but in fact it is very very different.  In particular, under MVS/OE\n   the roles of r11 and r13 are quite different.\n\n   Note that the use of varargs/stdarg is limited to 512 bytes of\n   of arguments.  This is the price that is paid for freeing up a\n   register and having a more efficient function return.\n*/\n\n/* Define size of the calling convention register save area.\n   This includes room for the 16 GPR's, a saved frame size, and\n   a (floating point math) scratch area */\n#define I370_SAVE_AREA_SIZE 88\n\n/* Define the size of the amount of room reserved for varargs */\n#define I370_VARARGS_AREA_SIZE 512\n\n/* Used in i370.md for temp scratch area. Must be that last two words\n   of the I370_SAVE_AREA. */\n#define CONVLO \"80\"\n#define CONVHI \"84\"\n\n/* Define offset from stack pointer, to location where a parm can be\n   pushed.  */\n\n#define STACK_POINTER_OFFSET I370_SAVE_AREA_SIZE\n\n#define STACK_DYNAMIC_OFFSET(FNDECL) 0\n\n/* Offset within frame to start allocating local variables at.\n   It is the offset to the BEGINNING of the first local allocated.  */\n\n#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n     ((current_function_varargs || current_function_stdarg) ?\t\t\\\n     (I370_SAVE_AREA_SIZE + I370_VARARGS_AREA_SIZE):\t\t\t\\\n     (I370_SAVE_AREA_SIZE + current_function_args_size))\n\n#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n\n/* Offset of first incoming parameter from the arg ptr register value.  */\n#define FIRST_PARM_OFFSET(FNDECL) I370_SAVE_AREA_SIZE\n\n/* The ACCUMULATE_OUTGOING_ARGS flag seems to have some funny side effects\n   that we need.  Specifically, if it is set, then the stack pointer is\n   not bumped when args are placed on the stack, which is just how we want\n   it. */\n#define ACCUMULATE_OUTGOING_ARGS 1\n\n#endif /* TARGET_LINUX */\n\n/* ================= */\n/* ------------------------------------------------------------------- */\n\n/* If we generate an insn to push BYTES bytes, this says how many the stack\n   pointer really advances by.  On the 370, we have no push instruction.  */\n\n/* #define PUSH_ROUNDING(BYTES) */\n\n#ifdef TARGET_LE\n#define STACK_POINTER_OFFSET 148\n#define STACK_FRAME_BASE 28\n#endif\n\n/* Offset of first parameter from the argument pointer register value.  */\n\n#define FIRST_PARM_OFFSET(FNDECL) 0\n\n/* 1 if N is a possible register number for function argument passing.\n   On the 370, no registers are used in this way.  */\n\n#define FUNCTION_ARG_REGNO_P(N) 0\n\n/* Define a data type for recording info about an argument list during\n   the scan of that argument list.  This data type should hold all\n   necessary information about the function itself and about the args\n   processed so far, enough to enable macros such as FUNCTION_ARG to\n   determine where the next arg should go.  */\n\n#define CUMULATIVE_ARGS int\n\n/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n   a function whose data type is FNTYPE.\n   For a library call, FNTYPE is 0.  */\n\n#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n  ((CUM) = 0)\n\n/* Update the data in CUM to advance over an argument of mode MODE and\n   data type TYPE.  (TYPE is null for libcalls where that information\n   may not be available.) */\n\n#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n ((CUM) += ((MODE) == DFmode || (MODE) == SFmode\t\t\t\\\n\t    ? 256\t\t\t\t\t\t\t\\\n\t    : (MODE) != BLKmode                 \t\t\t\\\n\t    ? (GET_MODE_SIZE (MODE) + 3) / 4 \t\t\t\t\\\n\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n\n/* Define where to put the arguments to a function.  Value is zero to push\n   the argument on the stack, or a hard register in which to store the\n   argument.  */\n\n#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n\n/* For an arg passed partly in registers and partly in memory, this is the\n   number of registers used.  For args passed entirely in registers or\n   entirely in memory, zero.  */\n\n#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n\n/* Define if returning from a function call automatically pops the\n   arguments described by the number-of-args field in the call.  */\n\n#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n\n/* The FUNCTION_VALUE macro defines how to find the value returned by a\n   function.  VALTYPE is the data type of the value (as a tree).\n   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n   otherwise, FUNC is NULL.\n\n   On the 370 the return value is in R15 or R16.  However,\n   DImode (64-bit ints) scalars need to get returned on the stack,\n   with r15 pointing to the location.  To accomplish this, we define\n   the RETURN_IN_MEMORY macro to be true for both blockmode (structures)\n   and the DImode scalars.\n */\n\n#define RET_REG(MODE)\t\\\n    (((MODE) == DCmode || (MODE) == SCmode \\\n      || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n\n#define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n  gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))\n\n#define RETURN_IN_MEMORY(VALTYPE)  \\\n  ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n\n/* Define how to find the value returned by a library function assuming\n   the value has mode MODE.  */\n\n#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, RET_REG (MODE))\n\n/* 1 if N is a possible register number for a function value.\n   On the 370 under C/370, R15 and R16 are thus used.  */\n\n#define FUNCTION_VALUE_REGNO_P(N) ((N) == 15 || (N) == 16)\n\n/* This macro definition sets up a default value for `main' to return.  */\n\n#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n\n\n/* Output assembler code for a block containing the constant parts of a\n   trampoline, leaving space for the variable parts.\n\n   On the 370, the trampoline contains these instructions:\n\n        BALR  14,0\n        USING *,14\n        L     STATIC_CHAIN_REGISTER,X\n        L     15,Y\n        BR    15\n   X    DS    0F\n   Y    DS    0F  */\n/*\n   I am confused as to why this emitting raw binary, instead of instructions ...\n   see for example, rs6000/rs000.c for an example of a different way to\n   do this ... especially since BASR should probably be substituted for BALR.\n */\n\n#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x05E0));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n  assemble_aligned_integer (2, GEN_INT (0xE00A));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x58F0)); \t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0xE00E));\t\t\t\\\n  assemble_aligned_integer (2, GEN_INT (0x07FF));\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n}\n\n/* Length in units of the trampoline for entering a nested function.  */\n\n#define TRAMPOLINE_SIZE 20\n\n/* Determine whether to use move_by_pieces or block move insn.  */\n\n#define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\\\n  ( (SIZE) == 1 || (SIZE) == 2 || (SIZE) == 4\t\\\n    || (TARGET_64BIT && (SIZE) == 8) )\n\n/* Emit RTL insns to initialize the variable parts of a trampoline.  */\n\n#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n}\n\n/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n   pointer does not matter (provided there is a frame pointer).  */\n\n#define EXIT_IGNORE_STACK\t1\n\n/* Addressing modes, and classification of registers for them.  */\n\n/* These assume that REGNO is a hard or pseudo reg number.  They give\n   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n   reg currently allocated to a suitable hard reg.\n   These definitions are NOT overridden anywhere.  */\n\n#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n  (((REGNO) > 0 && (REGNO) < 16)\t\t\t\t\t\\\n    || (reg_renumber\u00ddREGNO\u00a8 > 0 && reg_renumber\u00ddREGNO\u00a8 < 16))\n\n#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P(REGNO)\n\n#define REGNO_OK_FOR_DATA_P(REGNO) \t\t\t\t\t\\\n  ((REGNO) < 16 || (unsigned) reg_renumber\u00ddREGNO\u00a8 < 16)\n\n#define REGNO_OK_FOR_FP_P(REGNO) \t\t\t\t\t\\\n  ((unsigned) ((REGNO) - 16) < 4 || (unsigned) (reg_renumber\u00ddREGNO\u00a8 - 16) < 4)\n\n/* Now macros that check whether X is a register and also,\n   strictly, whether it is in a specified class.  */\n\n/* 1 if X is a data register.  */\n\n#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n\n/* 1 if X is an fp register.  */\n\n#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n\n/* 1 if X is an address register.  */\n\n#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n\n/* Maximum number of registers that can appear in a valid memory address.  */\n\n#define MAX_REGS_PER_ADDRESS 2\n\n/* Recognize any constant value that is a valid address.  */\n\n#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n\t  && !SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (X, 0), 0))))\n\n/* Nonzero if the constant value X is a legitimate general operand.\n   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n\n#define LEGITIMATE_CONSTANT_P(X) 1\n\n/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n   its validity for a certain class.  We have two alternate definitions\n   for each of them.  The usual definition accepts all pseudo regs; the\n   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n   definition to be used.\n\n   Most source files want to accept pseudo regs in the hope that they will\n   get allocated to the class that the insn wants them to be in.\n   Some source files that are used after register allocation\n   need to be strict.  */\n\n#ifndef REG_OK_STRICT\n\n/* Nonzero if X is a hard reg that can be used as an index or if it is\n  a pseudo reg.  */\n\n#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n  ((REGNO(X) > 0 && REGNO(X) < 16) || REGNO(X) >= 20)\n\n/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n   a pseudo reg.  */\n\n#define REG_OK_FOR_BASE_P(X)\tREG_OK_FOR_INDEX_P(X)\n\n#else /* REG_OK_STRICT */\n\n/* Nonzero if X is a hard reg that can be used as an index.  */\n\n#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n\n/* Nonzero if X is a hard reg that can be used as a base reg.  */\n\n#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P(REGNO(X))\n\n#endif /* REG_OK_STRICT */\n\n/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n   valid memory address for an instruction.\n   The MODE argument is the machine mode for the MEM expression\n   that wants to use this address.\n\n   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n   except for CONSTANT_ADDRESS_P which is actually machine-independent.\n*/\n\n#define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n if (REG_P (X)) {\t\t\t\t\t\t\t\\\n   if (REG_OK_FOR_BASE_P (X)) REGS += 1;\t\t\t\t\\\n   else goto FAIL;\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n   goto FAIL;\n\n#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n    goto ADDR;\t\t\t\t\t\t\t\t\\\n  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      int regs = 0;\t\t\t\t\t\t\t\\\n      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n      rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n      if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (XEXP (x0, 0), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (XEXP (x0, 1), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n\t  if (regs == 2)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else if (GET_CODE (x1) == PLUS)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n\t  COUNT_REGS (XEXP (x1, 0), regs, FAIL);\t\t\t\\\n\t  COUNT_REGS (XEXP (x1, 1), regs, FAIL);\t\t\t\\\n\t  if (regs == 2)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n\t  if (regs != 0)\t\t\t\t\t\t\\\n\t    goto ADDR;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  FAIL: ;\t\t\t\t\t\t\t\t\\\n}\n\n/* The 370 has no mode dependent addresses.  */\n\n#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n\n/* Macro: LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n   Try machine-dependent ways of modifying an illegitimate address\n   to be legitimate.  If we find one, return the new, valid address.\n   This macro is used in only one place: `memory_address' in explow.c.\n\n   Several comments:\n   (1) It's not obvious that this macro results in better code\n       than its omission does. For historical reasons we leave it in.\n\n   (2) This macro may be (???) implicated in the accidental promotion\n       or RS operand to RX operands, which bombs out any RS, SI, SS\n       instruction that was expecting a simple address.  Note that\n       this occurs fairly rarely ...\n\n   (3) There is a bug somewhere that causes either r4 to be spilled,\n       or causes r0 to be used as a base register.  Changeing the macro\n       below will make the bug move around, but will not make it go away\n       ... Note that this is a rare bug ...\n\n */\n\n#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n\t\t\tforce_operand (XEXP (X, 0), 0));\t\t\\\n  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n\t\t\tforce_operand (XEXP (X, 1), 0));\t\t\\\n  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n    goto WIN;\t\t\t\t\t\t\t\t\\\n}\n\n/* Specify the machine mode that this machine uses for the index in the\n   tablejump instruction.  */\n\n#define CASE_VECTOR_MODE SImode\n\n/* Define this if the tablejump instruction expects the table to contain\n   offsets from the address of the table.\n   Do not define this if the table should contain absolute addresses.  */\n\n/* #define CASE_VECTOR_PC_RELATIVE */\n\n/* Define this if fixuns_trunc is the same as fix_trunc.  */\n\n#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n\n/* We use \"unsigned char\" as default.  */\n\n#define DEFAULT_SIGNED_CHAR 0\n\n/* Max number of bytes we can move from memory to memory in one reasonably\n   fast instruction.  */\n\n#define MOVE_MAX 256\n\n/* Nonzero if access to memory by bytes is slow and undesirable.  */\n\n#define SLOW_BYTE_ACCESS 1\n\n/* Define if shifts truncate the shift count which implies one can omit\n   a sign-extension or zero-extension of a shift count.  */\n\n/* #define SHIFT_COUNT_TRUNCATED */\n\n/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n   is done just by pretending it is already truncated.  */\n\n#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t(OUTPREC != 16)\n\n/* ??? Investigate defining STORE_FLAG_VALUE to (-1).  */\n\n/* When a prototype says `char' or `short', really pass an `int'.  */\n\n#define PROMOTE_PROTOTYPES 1\n\n/* Don't perform CSE on function addresses.  */\n\n#define NO_FUNCTION_CSE\n\n/* Specify the machine mode that pointers have.\n   After generation of rtl, the compiler makes no further distinction\n   between pointers and any other objects of this machine mode.  */\n\n#define Pmode SImode\n\n/* A function address in a call instruction is a byte address (for\n   indexing purposes) so give the MEM rtx a byte's mode.  */\n\n#define FUNCTION_MODE QImode\n\n/*   A C statement (sans semicolon) to update the integer variable COST\n     based on the relationship between INSN that is dependent on\n     DEP_INSN through the dependence LINK.  The default is to make no\n     adjustment to COST.  This can be used for example to specify to\n     the scheduler that an output- or anti-dependence does not incur\n     the same cost as a data-dependence.\n\n     We will want to use this to indicate that there is a cost associated\n     with the loading, followed by use of base registers ...\n#define ADJUST_COST (INSN, LINK, DEP_INSN, COST)\n */\n\n/* Tell final.c how to eliminate redundant test instructions.  */\n\n/* Here we define machine-dependent flags and fields in cc_status\n   (see `conditions.h').  */\n\n/* Store in cc_status the expressions that the condition codes will\n   describe after execution of an instruction whose pattern is EXP.\n   Do not alter them if the instruction would not alter the cc's.\n\n   On the 370, load insns do not alter the cc's.  However, in some\n   cases these instructions can make it possibly invalid to use the\n   saved cc's.  In those cases we clear out some or all of the saved\n   cc's so they won't be used.\n\n   Note that only some arith instructions set the CC.  These include\n   add, subtract, complement, various shifts.  Note that multiply\n   and divide do *not* set set the CC.  Therefore, in the code below,\n   don't set the status for MUL, DIV, etc.\n\n   Note that the bitwise ops set the condition code, but not in a\n   way that we can make use of it. So we treat these as clobbering,\n   rather than setting the CC.  These are clobbered in the individual\n   instruction patterns that use them.  Use CC_STATUS_INIT to clobber.\n*/\n\n#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx exp = (EXP);\t\t\t\t\t\t\t\\\n  if (GET_CODE (exp) == PARALLEL) /* Check this */\t\t\t\\\n    exp = XVECEXP (exp, 0, 0);\t\t\t\t\t\t\\\n  if (GET_CODE (exp) != SET)\t\t\t\t\t\t\\\n    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (XEXP (exp, 0) == cc0_rtx)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  cc_status.value1 = XEXP (exp, 0);\t\t\t\t\\\n\t  cc_status.value2 = XEXP (exp, 1);\t\t\t\t\\\n\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (cc_status.value1\t\t\t\t\t\t\\\n\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value1))\t\\\n\t    cc_status.value1 = 0;\t\t\t\t\t\\\n\t  if (cc_status.value2\t\t\t\t\t\t\\\n\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value2))\t\\\n\t    cc_status.value2 = 0;\t\t\t\t\t\\\n\t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      case PLUS:     case MINUS: case NEG:    \t\t\t\\\n\t      case NOT:\t case ABS:\t\t\t\t\t\\\n\t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n              /* mult and div don't set any cc codes !! */\t\t\\\n\t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n              /* and, or and xor set the cc's the wrong way !! */\t\\\n\t      case AND:   case IOR:    case XOR:  \t\t\t\\\n              /* some shifts set the CC some don't.  */\t\t\t\\\n              case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n                 do {} while (0);\t\t\t\t\t\\\n              default:\t\t\t\t\t\t\t\\\n                break;\t\t\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n\n#define CC_STATUS_SET(V1, V2)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  cc_status.flags = 0;\t\t\t\t\t\t\t\\\n  cc_status.value1 = (V1);\t\t\t\t\t\t\\\n  cc_status.value2 = (V2);\t\t\t\t\t\t\\\n  if (cc_status.value1\t\t\t\t\t\t\t\\\n      && reg_mentioned_p (cc_status.value1, cc_status.value2))\t\t\\\n    cc_status.value2 = 0;\t\t\t\t\t\t\\\n}\n\n#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n{ if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n\n/* ------------------------------------------ */\n/* Control the assembler format that we output.  */\n\n/* Define standard character escape sequences for non-ASCII targets\n   only.  */\n\n#ifdef TARGET_EBCDIC\n#define TARGET_ESC\t39\n#define TARGET_BELL\t47\n#define TARGET_BS\t22\n#define TARGET_TAB\t5\n#define TARGET_NEWLINE\t21\n#define TARGET_VT\t11\n#define TARGET_FF\t12\n#define TARGET_CR\t13\n#endif\n\n/* ======================================================== */\n\n#ifdef TARGET_HLASM\n\n#define TEXT_SECTION_ASM_OP \"* Program text area\"\n#define DATA_SECTION_ASM_OP \"* Program data area\"\n#define INIT_SECTION_ASM_OP \"* Program initialization area\"\n#define SHARED_SECTION_ASM_OP \"* Program shared data\"\n#define CTOR_LIST_BEGIN\t\t/* NO OP */\n#define CTOR_LIST_END\t\t/* NO OP */\n#define MAX_MVS_LABEL_SIZE 8\n\n/* How to refer to registers in assembler output.  This sequence is\n   indexed by compiler's hard-register-number (see above).  */\n\n#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n{ \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\t\t\t\\\n  \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\t\\\n  \"0\",  \"2\",  \"4\",  \"6\"\t\t\t\t\t\t\t\\\n}\n\n\n#define ASM_COMMENT_START \"*\"\n#define ASM_APP_OFF \"\"\n#define ASM_APP_ON \"\"\n\n#define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n{ assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n\n#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, NAME)\t\t\t\t\\\n  mvs_need_to_globalize = 0; \\\n  mvs_need_entry = 0\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#endif\n\n\n/* MVS externals are limited to 8 characters, upper case only.\n   The '_' is mapped to '@', except for MVS functions, then '#'.  */\n\n\n#ifdef TARGET_ALIASES\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n  if (mvs_function_check (temp))\t\t\t\t\t\\\n    ch = '#';\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#else /* !TARGET_ALIASES */\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#ifdef TARGET_LE\n#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char *bp, ch, temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\\\n  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n    strcpy (temp, NAME);\t\t\t\t\t\t\\\n  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n  if (mvs_function_check (temp))\t\t\t\t\t\\\n    ch = '#';\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    ch = '@';\t\t\t\t\t\t\t\t\\\n  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n}\n#endif\n#endif /* TARGET_ALIASES */\n\n#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n\n/* Generate case label.  For HLASM we can change to the data CSECT\n   and put the vectors out of the code body. The assembler just\n   concatenates CSECTs with the same name.  */\n\n#ifdef TARGET_ALIASES\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  fprintf (FILE,\"@DATA\\tCSECT\\n\");                                      \\\n  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#else /* !TARGET_ALIASES */\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tLTORG\\n\");                                          \\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  mvs_case_code = 0;\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#else\n#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n  fprintf (FILE,\"$%s\\tCSECT\\n\", mvs_module);                            \\\n  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n#endif\n#endif /* TARGET_ALIASES */\n\n/* Put the CSECT back to the code body */\n\n#ifdef TARGET_ALIASES\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  fputs (\"@CODE\\tCSECT\\n\", FILE);\n#else /* !TARGET_ALIASES */\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  mvs_page_code += mvs_case_code;\t\t\t\t\t\\\n  mvs_check_page (FILE, 0, 0);\t\t\t\t\t\t\\\n  mvs_case_code = 0;\n#else\n#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n  fprintf (FILE, \"@%s\\tCSECT\\n\", mvs_module);\n#endif\n#endif /* TARGET_ALIASES */\n\n/* This is how to output an element of a case-vector that is absolute.  */\n\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n  mvs_case_code += 4;\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDC\\tA(L%d)\\n\", VALUE)\n\n/* This is how to output an element of a case-vector that is relative.  */\n\n#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n  fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n\n/* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.\n   Right now, PUSH & POP are used only when profiling is enabled,\n   and then, only to push the static chain reg and the function struct\n   value reg, and only if those are used.  Since profiling is not\n   supported anyway, punt on this.  */\n\n#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n  mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n     reg_names\u00ddREGNO\u00a8, STACK_POINTER_OFFSET)\n\n/* This is how to output an insn to pop a register from the stack.\n   It need not be very fast code.  */\n\n#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n  mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n     reg_names\u00ddREGNO\u00a8, STACK_POINTER_OFFSET)\n\n/* This outputs a text string.  The string are chopped up to fit into\n   an 80 byte record.  Also, control and special characters, interpreted\n   by the IBM assembler, are output numerically.  */\n\n#define MVS_ASCII_TEXT_LENGTH 48\n\n#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  size_t i, limit = (LEN);\t\t\t\t\t\t\\\n  int j;\t\t\t\t\t\t\t\t\\\n  for (j = 0, i = 0; i < limit; j++, i++)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      int c = (PTR)\u00ddi\u00a8;\t\t\t\t\t\t\t\\\n      c = MAP_INCHAR(c);\t\t\t\t\t\t\t\\\n      if (!IS_ISOBASIC (c) || ISCNTRL(c) || c == '&')\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH != 0 )\t\t\t\t\\\n\t    fprintf (FILE, \"'\\n\");\t\t\t\t\t\\\n\t  j = -1;\t\t\t\t\t\t\t\\\n\t  c = MAP_OUTCHAR (c); \t\t\t\t\t\t\\\n\t  fprintf (FILE, \"\\tDC\\tX'%X'\\n\", c );\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n            fprintf (FILE, \"\\tDC\\tC'\");\t\t\t\t\t\\\n          if ( c == '\\'' )                                       \t\\\n\t    {\t/* we are going to print 2 chars - is there space */\t\\\n\t  if( j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)   \\\n          { /* not enough space */\t\t\t\t\t\\\n\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n            fprintf (FILE, \"\\tDC\\tC'\");\t++j;}\t\t\t\t\\\n               fprintf (FILE, \"%c%c\", c, c);++j;}                   \t\\\n\t  else                                                   \t\\\n\t    fprintf (FILE, \"%c\", c);                             \t\\\n\t  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)\t\\\n\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (j % MVS_ASCII_TEXT_LENGTH != 0)\t\t\t\t\t\\\n    fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n}\n\n/* This is how to output an assembler line that says to advance the\n   location counter to a multiple of 2**LOG bytes.  */\n\n#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\t\t\t\\\n  if (LOG)\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if ((LOG) == 1)\t\t\t\t\t\t\t\\\n        fprintf (FILE, \"\\tDS\\t0H\\n\" );\t\t\t\t\t\\\n      else \t\t\t\t\t\t\t\t\\\n        fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n\n/* The maximum length of memory that the IBM assembler will allow in one\n   DS operation.  */\n\n#define MAX_CHUNK 32767\n\n/* A C statement to output to the stdio stream FILE an assembler\n   instruction to advance the location counter by SIZE bytes. Those\n   bytes should be zero when loaded.  */\n\n#ifdef TARGET_PDPMAC\n#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  int s, k;\t\t\t\t\t\t\t\t\\\n  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\tk = s;\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\tDC\\t%dX'00'\\n\", k);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#else\n#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  unsigned HOST_WIDE_INT s;\t\t\t\t\t\t\\\n  int  k;\t\t\t\t\t\t\t\t\\\n  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n\tk = s;\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\tDS\\tXL%d\\n\", k);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n#endif\n\n/* A C statement (sans semicolon) to output to the stdio stream\n   FILE the assembler definition of a common-label named NAME whose\n   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n   to whatever alignment the caller wants.  */\n\n#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  char temp\u00ddMAX_MVS_LABEL_SIZE + 1\u00a8;\t\t\t\t\t\\\n  if (mvs_check_alias(NAME, temp) == 2)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  fprintf(FILE, \"* X-var %s\\n\", NAME); \\\n  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n\n/* A C statement (sans semicolon) to output to the stdio stream\n   FILE the assembler definition of a local-common-label named NAME\n   whose size is SIZE bytes.  The variable ROUNDED is the size\n   rounded up to whatever alignment the caller wants.  */\n\n#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n}\n\n#define ASM_PN_FORMAT \"%s\"\n\n/* Print operand XV (an rtx) in assembler syntax to file FILE.\n   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n\n#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      static char curreg\u00dd4\u00a8;\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tif (CODE == 'N')\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV) + 1\u00a8);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV)\u00a8);\t\t\t\\\n\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case MEM:\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n\t  if (CODE == 'O')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (XEXP (addr, 0))\u00a8);\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (addr)\u00a8);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else\t\t\t\t\t\t\t\t\\\n\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n      case LABEL_REF:\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_EXTERNAL_P (XV))\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t    mvs_mark_alias (XSTR(XV,0));\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_INT:\t\t\t\t\t        \t\\\n\tif (CODE == 'B')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n\telse if (CODE == 'X')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n\telse if (CODE == 'h')\t\t\t\t\t\t\\\n\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n\telse if (CODE == 'H')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'K')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'W')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n            } else {\t\t\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n            }\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_DOUBLE:\t\t\t\t\t\t\\\n\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (CODE == 'M')\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (CODE == 'L')\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (XV),\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV));\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  { \t\t\t\t\t\t\t\t\\\n            char buf\u00dd50\u00a8;\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else /* VOIDmode */\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST:\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tint xx = INTVAL (XEXP (XEXP (XV, 0), 1));\t\t\\\n\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t\tif ((unsigned)xx < 4096)\t\t\t\t\\\n\t\t  fprintf (FILE, \")\\n\\tLA\\t%s,%d(0,%s)\", curreg,\t\\\n\t\t\t\t  xx,\t\t\t\t\t\\\n\t\t\t\t  curreg);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  fprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n\t\t\t\t  xx);\t\t\t\t\t\\\n\t\tmvs_mark_alias (XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tabort();\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n  \t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tfprintf (FILE, \"0(%s)\", reg_names\u00ddREGNO (ADDR)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case PLUS:\t\t\t\t\t\t\t\\\n\tbreg = 0;\t\t\t\t\t\t\t\\\n\txreg = 0;\t\t\t\t\t\t\t\\\n\toffset = 0;\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (breg)\t\t\t\t\t\t\t\\\n\t      xreg = plus;\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      breg = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    offset = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (offset)\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      output_addr_const (FILE, offset);\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n\tif (xreg)\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n\t\t    reg_names\u00ddREGNO (xreg)\u00a8, reg_names\u00ddREGNO (breg)\u00a8); \t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"(%s)\", reg_names\u00ddREGNO (breg)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_EXTERNAL_P (ADDR))\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, ADDR);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t    mvs_mark_alias (XSTR (ADDR, 0));\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t    output_addr_const (FILE, ADDR);\t\t\t\t\\\n\t    fprintf (FILE, \")\");\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#ifdef TARGET_LE\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  /* Save a copy of the function name. We need it later */\t\t\\\n  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n}\n#endif\n\n#if defined(TARGET_DIGNUS) || defined(TARGET_PDPMAC)\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n  mvs_need_to_globalize = 1;\t\t\t\t\t\t\\\n}\n#endif\n\n/* Output assembler code to FILE to increment profiler label # LABELNO\n   for profiling a function entry.  */\n\n#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n  fprintf (FILE, \"Error: No profiling available.\\n\")\n\n#endif /* TARGET_HLASM */\n\n/* ======================================================== */\n\n#ifdef TARGET_LINUX\n\n/* How to refer to registers in assembler output.  This sequence is\n   indexed by compiler's hard-register-number (see above).  */\n\n#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n{ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n  \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n  \"f0\",  \"f2\",  \"f4\",  \"f6\"\t\t\t\t\t\t\\\n}\n\n/* Print operand XV (an rtx) in assembler syntax to file FILE.\n   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n\n#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      static char curreg\u00dd4\u00a8;\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tif (CODE == 'N')\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV) + 1\u00a8);\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t    strcpy (curreg, reg_names\u00ddREGNO (XV)\u00a8);\t\t\t\\\n\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case MEM:\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n\t  if (CODE == 'O')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n\t    {\t\t\t\t\t\t\t\t\\\n\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (XEXP (addr, 0))\u00a8);\\\n\t      else\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"%s\", reg_names\u00ddREGNO (addr)\u00a8);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t  else\t\t\t\t\t\t\t\t\\\n\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n      case LABEL_REF:\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n        if (SYMBOL_REF_EXTERNAL_P (XV)) fprintf (FILE, \"=V(\");\t\t\\\n        else                      fprintf (FILE, \"=A(\");                \\\n        output_addr_const (FILE, XV);                                   \\\n        fprintf (FILE, \")\");                                            \\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_INT:\t\t\t\t\t        \t\\\n\tif (CODE == 'B')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n\telse if (CODE == 'X')\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n\telse if (CODE == 'h')\t\t\t\t\t\t\\\n\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n\telse if (CODE == 'H')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'K')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (CODE == 'W')\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n            } else {\t\t\t\t\t\t\t\\\n\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n            }\t\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST_DOUBLE:\t\t\t\t\t\t\\\n\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (CODE == 'M')\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (CODE == 'L')\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=yyyyXL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  { \t\t\t\t\t\t\t\t\\\n            char buf\u00dd50\u00a8;\t\t\t\t\t\t\\\n\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t        REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n\t        REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else /* VOIDmode */\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case CONST:\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", \\\n\t\t\t curreg, INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"=bogus_bad_F'\");\t\t\t\t\\\n\t    output_addr_const (FILE, XV);\t\t\t\t\\\n\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n/* XXX hack alert this gets gen'd in -fPIC code in relation to a tablejump */  \\\n/* but its somehow fundamentally broken, I can't make any sense out of it */  \\\ndebug_rtx (XV); \\\nabort(); \\\n\t  }\t\t\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tabort();\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n  \t\t\t\t\t\t\t\t\t\\\n  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      case REG:\t\t\t\t\t\t\t\t\\\n\tfprintf (FILE, \"0(%s)\", reg_names\u00ddREGNO (ADDR)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      case PLUS:\t\t\t\t\t\t\t\\\n\tbreg = 0;\t\t\t\t\t\t\t\\\n\txreg = 0;\t\t\t\t\t\t\t\\\n\toffset = 0;\t\t\t\t\t\t\t\\\n\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tif (breg)\t\t\t\t\t\t\\\n\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (breg)\t\t\t\t\t\t\t\\\n\t      xreg = plus;\t\t\t\t\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      breg = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    offset = plus;\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\tif (offset)\t\t\t\t\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n\t    else\t\t\t\t\t\t\t\\\n\t      output_addr_const (FILE, offset);\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n\tif (xreg)\t\t\t\t\t\t\t\\\n\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n\t\t    reg_names\u00ddREGNO (xreg)\u00a8, reg_names\u00ddREGNO (breg)\u00a8); \t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t  fprintf (FILE, \"(%s)\", reg_names\u00ddREGNO (breg)\u00a8);\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n      default:\t\t\t\t\t\t\t\t\\\n\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n\tif (SYMBOL_REF_EXTERNAL_P (ADDR)) fprintf (FILE, \"=V(\");\t\\\n\telse                        fprintf (FILE, \"=A(\");\t\t\\\n\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n}\n\n#ifdef ASM_DECLARE_FUNCTION_NAME\n#undef ASM_DECLARE_FUNCTION_NAME\n#endif\n#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  /* Save a copy of the function name. We need it later */\t\t\\\n  if (strlen (NAME) +1 > mvs_function_name_length)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      if (mvs_function_name)\t\t\t\t\t\t\\\n\tfree (mvs_function_name);\t\t\t\t\t\\\n      mvs_function_name = 0;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  if (!mvs_function_name)\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n}\n\n/* This macro generates the assembly code for function exit, on machines\n   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n   return instructions are generated for each return statement.  Args are\n   same as for FUNCTION_PROLOGUE.\n\n   The function epilogue should not depend on the current stack pointer!\n   It should use the frame pointer only.  This is mandatory because\n   of alloca; we also take advantage of it to omit stack adjustments\n   before returning.  */\n\n#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  int i;\t\t\t\t\t\t\t\t\\\n  check_label_emit();\t\t\t\t\t\t\t\\\n  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"# Function epilogue\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\tr14,12(,r13)\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tLM\\t2,12,28(r13)\\n\");\t\t\t\t\\\n  fprintf (FILE, \"\\tL\\tr13,8(,r13)\\n\");\t\t\t\t\t\\\n  fprintf (FILE, \"\\tBASR\\tr1,r14\\n\");\t\t\t\t\t\\\n  fprintf (FILE, \"# Function literal pool\\n\");\t\t\t\t\\\n  if (i370_enable_pic)\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \".data\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPOOL%d:\\n\",mvs_page_num);\t\t\t\\\n      fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"# Function page table\\n\");\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n      mvs_page_num++;\t\t\t\t\t\t\t\\\n      for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPOOL%d\\n\", i);\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n      /* fprintf (FILE, \".previous\\n\");\t */\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \"# Function page table\\n\");\t\t\t\\\n      fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n      fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n      mvs_page_num++;\t\t\t\t\t\t\t\\\n      for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\\\n        {\t\t\t\t\t\t\t\t\\\n          fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  mvs_free_label_list();\t\t\t\t\t\t\\\n}\n\n#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n\n/* Output assembler code to FILE to increment profiler label # LABELNO\n   for profiling a function entry.  */\n/* Make it a no-op for now, so we can at least compile glibc */\n#define FUNCTION_PROFILER(FILE, LABELNO)  {\t\t\t\t\\\n  mvs_check_page (FILE, 24, 4);\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tSTM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n     fprintf (FILE, \"\\tLA\\tr1,1(0,0)\\n\"); \t\t\t\t\\\n     fprintf (FILE, \"\\tL\\tr2,=A(.LP%d)\\n\", LABELNO);\t\t\t\\\n     fprintf (FILE, \"\\tA\\tr1,0(r2)\\n\");\t\t\t \t\t\\\n     fprintf (FILE, \"\\tST\\tr1,0(r2)\\n\");\t\t \t\t\\\n     fprintf (FILE, \"\\tLM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n}\n\n/* Don't bother to output .extern pseudo-ops.  They are not needed by\n   ELF assemblers.  */\n\n#undef ASM_OUTPUT_EXTERNAL\n\n#define ASM_DOUBLE \"\\t.double\"\n\n/* #define ASM_OUTPUT_LABELREF(FILE, NAME) */\t/* use gas -- defaults.h */\n\n/* let config/svr4.h define this ...\n *  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n *    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n */\n\n/* This is how to output an element of a case-vector that is absolute.  */\n#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\t.long\\t.L%d\\n\", VALUE)\n\n/* This is how to output an element of a case-vector that is relative.  */\n#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n  fprintf (FILE, \"\\t.long\\t.L%d-.L%d\\n\", VALUE, REL)\n\n/* Right now, PUSH & POP are used only when profiling is enabled,\n   and then, only to push the static chain reg and the function struct\n   value reg, and only if those are used by the function being profiled.\n   We don't need this for profiling, so punt.  */\n#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\n#define ASM_OUTPUT_REG_POP(FILE, REGNO)\n\n\n/* Indicate that jump tables go in the text section.  This is\n   necessary when compiling PIC code.  */\n#define JUMP_TABLES_IN_TEXT_SECTION 1\n\n/* Define macro used to output shift-double opcodes when the shift\n   count is in %cl.  Some assemblers require %cl as an argument;\n   some don't.\n\n   GAS requires the %cl argument, so override i386/unix.h.  */\n\n#undef SHIFT_DOUBLE_OMITS_COUNT\n#define SHIFT_DOUBLE_OMITS_COUNT 0\n\n/* Implicit library calls should use memcpy, not bcopy, etc.  */\n#define TARGET_MEM_FUNCTIONS\n\n/* Output before read-only data.  */\n#define TEXT_SECTION_ASM_OP \"\\t.text\"\n\n/* Output before writable (initialized) data.  */\n#define DATA_SECTION_ASM_OP \"\\t.data\"\n\n/* Output before writable (uninitialized) data.  */\n#define BSS_SECTION_ASM_OP \"\\t.bss\"\n\n/* In the past there was confusion as to what the argument to .align was\n   in GAS.  For the last several years the rule has been this: for a.out\n   file formats that argument is LOG, and for all other file formats the\n   argument is 1<<LOG.\n\n   However, GAS now has .p2align and .balign pseudo-ops so to remove any\n   doubt or guess work, and since this file is used for both a.out and other\n   file formats, we use one of them.  */\n\n#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n  if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n\n/* Globalizing directive for a label.  */\n#define GLOBAL_ASM_OP \".globl \"\n\n/* This says how to output an assembler line\n   to define a global common symbol.  */\n\n#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n( fputs (\".comm \", (FILE)),                     \\\n  assemble_name ((FILE), (NAME)),               \\\n  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n\n/* This says how to output an assembler line\n   to define a local common symbol.  */\n\n#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n( fputs (\".lcomm \", (FILE)),                    \\\n  assemble_name ((FILE), (NAME)),               \\\n  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n\n#endif /* TARGET_LINUX */\n#endif /* ! GCC_I370_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I370@PRO": {"ttr": 6160, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 2000 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_I370_PROTOS_H\n#define GCC_I370_PROTOS_H\n\nextern void override_options (void);\n\n#ifdef RTX_CODE\nextern int i370_branch_dest (rtx);\nextern int i370_branch_length (rtx);\nextern int i370_short_branch (rtx);\nextern int s_operand (rtx, enum machine_mode);\nextern int r_or_s_operand (rtx, enum machine_mode);\nextern int unsigned_jump_follows_p (rtx);\n#endif /* RTX_CODE */\n\n#ifdef TREE_CODE\nextern int handle_pragma (int (*)(void), void (*)(int), const char *);\n#endif /* TREE_CODE */\n\nextern void mvs_add_label (int);\nextern int mvs_check_label (int);\nextern int mvs_check_page (FILE *, int, int);\nextern int mvs_function_check (const char *);\nextern void mvs_add_alias (const char *, const char *, int);\nextern int mvs_need_alias (const char *);\nextern int mvs_mark_alias (const char *);\nextern int mvs_dump_alias (FILE *);\nextern int mvs_get_alias (const char *, char *);\nextern int mvs_check_alias (const char *, char *);\nextern void check_label_emit (void);\nextern void mvs_free_label_list (void);\n/*extern void i370_output_ascii (FILE *, const char *, size_t);*/\n\n#ifdef GCC_C_PRAGMA_H\nextern void i370_pr_map       (struct cpp_reader *);\nextern void i370_pr_skipit    (struct cpp_reader *);\nextern void i370_pr_linkage   (struct cpp_reader *);\nextern void i370_pr_checkout  (struct cpp_reader *);\n#endif\n\n#endif /* ! GCC_I370_PROTOS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LANGHDEF": {"ttr": 6918, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default macros to initialize the lang_hooks data structure.\n   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LANG_HOOKS_DEF_H\n#define GCC_LANG_HOOKS_DEF_H\n\n#include \"hooks.h\"\n\nstruct diagnostic_context;\n\n/* Provide a hook routine for alias sets that always returns 1.  This is\n   used by languages that haven't deal with alias sets yet.  */\nextern HOST_WIDE_INT hook_get_alias_set_0 (tree);\n\n/* Note to creators of new hooks:\n\n   The macros in this file should NOT be surrounded by a\n   #ifdef...#endif pair, since this file declares the defaults.  Each\n   front end overrides any hooks it wishes to, in the file containing\n   its struct lang_hooks, AFTER including this file.  */\n\n/* See langhooks.h for the definition and documentation of each hook.  */\n\nextern void lhd_do_nothing (void);\nextern void lhd_do_nothing_t (tree);\nextern void lhd_do_nothing_i (int);\nextern void lhd_do_nothing_f (struct function *);\nextern bool lhd_post_options (const char **);\nextern HOST_WIDE_INT lhd_get_alias_set (tree);\nextern tree lhd_return_tree (tree);\nextern tree lhd_return_null_tree_v (void);\nextern tree lhd_return_null_tree (tree);\nextern tree lhd_do_nothing_iii_return_null_tree (int, int, int);\nextern int lhd_safe_from_p (rtx, tree);\nextern int lhd_staticp (tree);\nextern int lhd_unsafe_for_reeval (tree);\nextern void lhd_clear_binding_stack (void);\nextern void lhd_print_tree_nothing (FILE *, tree, int);\nextern const char *lhd_decl_printable_name (tree, int);\nextern rtx lhd_expand_expr (tree, rtx, enum machine_mode, int, rtx *);\nextern void lhd_print_error_function (struct diagnostic_context *,\n\t\t\t\t      const char *);\nextern void lhd_set_decl_assembler_name (tree);\nextern bool lhd_can_use_bit_fields_p (void);\nextern bool lhd_warn_unused_global_decl (tree);\nextern void lhd_incomplete_type_error (tree, tree);\nextern tree lhd_type_promotes_to (tree);\nextern void lhd_register_builtin_type (tree, const char *);\nextern bool lhd_decl_ok_for_sibcall (tree);\nextern tree lhd_expr_size (tree);\nextern bool lhd_decl_uninit (tree);\nextern tree lhd_get_callee_fndecl (tree);\nextern size_t lhd_tree_size (enum tree_code);\n\n/* Declarations of default tree inlining hooks.  */\nextern tree lhd_tree_inlining_walk_subtrees (tree *, int *, walk_tree_fn,\n\t\t\t\t\t     void *, void *);\nextern int lhd_tree_inlining_cannot_inline_tree_fn (tree *);\nextern int lhd_tree_inlining_disregard_inline_limits (tree);\nextern tree lhd_tree_inlining_add_pending_fn_decls (void *, tree);\nextern int lhd_tree_inlining_tree_chain_matters_p (tree);\nextern int lhd_tree_inlining_auto_var_in_fn_p (tree, tree);\nextern tree lhd_tree_inlining_copy_res_decl_for_inlining (tree, tree, tree,\n\t\t\t\t\t\t\t  void *, int *, tree);\nextern int lhd_tree_inlining_anon_aggr_type_p (tree);\nextern int lhd_tree_inlining_start_inlining (tree);\nextern void lhd_tree_inlining_end_inlining (tree);\nextern tree lhd_tree_inlining_convert_parm_for_inlining (tree, tree, tree, int);\nextern void lhd_initialize_diagnostics (struct diagnostic_context *);\nextern tree lhd_callgraph_analyze_expr (tree *, int *, tree);\n\n\n#define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n#define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n#define LANG_HOOKS_INIT\t\t\thook_bool_void_false\n#define LANG_HOOKS_FINISH\t\tlhd_do_nothing\n#define LANG_HOOKS_PARSE_FILE\t\tlhd_do_nothing_i\n#define LANG_HOOKS_CLEAR_BINDING_STACK\tlhd_clear_binding_stack\n#define LANG_HOOKS_INIT_OPTIONS\t\thook_uint_uint_constcharptrptr_0\n#define LANG_HOOKS_INITIALIZE_DIAGNOSTICS lhd_initialize_diagnostics\n#define LANG_HOOKS_HANDLE_OPTION\thook_int_size_t_constcharptr_int_0\n#define LANG_HOOKS_MISSING_ARGUMENT\thook_bool_constcharptr_size_t_false\n#define LANG_HOOKS_POST_OPTIONS\t\tlhd_post_options\n#define LANG_HOOKS_GET_ALIAS_SET\tlhd_get_alias_set\n#define LANG_HOOKS_EXPAND_CONSTANT\tlhd_return_tree\n#define LANG_HOOKS_EXPAND_EXPR\t\tlhd_expand_expr\n#define LANG_HOOKS_SAFE_FROM_P\t\tlhd_safe_from_p\n#define LANG_HOOKS_FINISH_INCOMPLETE_DECL lhd_do_nothing_t\n#define LANG_HOOKS_UNSAFE_FOR_REEVAL\tlhd_unsafe_for_reeval\n#define LANG_HOOKS_STATICP\t\tlhd_staticp\n#define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n#define LANG_HOOKS_UNSAVE_EXPR_NOW\tlhd_unsave_expr_now\n#define LANG_HOOKS_MAYBE_BUILD_CLEANUP\tlhd_return_null_tree\n#define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME lhd_set_decl_assembler_name\n#define LANG_HOOKS_CAN_USE_BIT_FIELDS_P lhd_can_use_bit_fields_p\n#define LANG_HOOKS_HONOR_READONLY\tfalse\n#define LANG_HOOKS_NO_BODY_BLOCKS\tfalse\n#define LANG_HOOKS_PRINT_STATISTICS\tlhd_do_nothing\n#define LANG_HOOKS_PRINT_XNODE\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_DECL\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_TYPE\t\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_IDENTIFIER\tlhd_print_tree_nothing\n#define LANG_HOOKS_PRINT_ERROR_FUNCTION lhd_print_error_function\n#define LANG_HOOKS_DECL_PRINTABLE_NAME\tlhd_decl_printable_name\n#define LANG_HOOKS_GET_CALLEE_FNDECL\tlhd_return_null_tree\n#define LANG_HOOKS_EXPR_SIZE\t\tlhd_expr_size\n#define LANG_HOOKS_DECL_UNINIT\t\tlhd_decl_uninit\n#define LANG_HOOKS_TREE_SIZE\t\tlhd_tree_size\n\n#define LANG_HOOKS_FUNCTION_INIT\tlhd_do_nothing_f\n#define LANG_HOOKS_FUNCTION_FINAL\tlhd_do_nothing_f\n#define LANG_HOOKS_FUNCTION_ENTER_NESTED lhd_do_nothing_f\n#define LANG_HOOKS_FUNCTION_LEAVE_NESTED lhd_do_nothing_f\n\n#define LANG_HOOKS_RTL_EXPAND_START\tlhd_do_nothing\n#define LANG_HOOKS_RTL_EXPAND_STMT\t(void (*) (tree)) abort\n#define LANG_HOOKS_RTL_EXPAND_END\tlhd_do_nothing\n\n/* Attribute hooks.  */\n#define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n#define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\tNULL\n#define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\tNULL\n\n/* Tree inlining hooks.  */\n#define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES lhd_tree_inlining_walk_subtrees\n#define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n  lhd_tree_inlining_cannot_inline_tree_fn\n#define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n  lhd_tree_inlining_disregard_inline_limits\n#define LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS \\\n  lhd_tree_inlining_add_pending_fn_decls\n#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n  lhd_tree_inlining_tree_chain_matters_p\n#define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n  lhd_tree_inlining_auto_var_in_fn_p\n#define LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING \\\n  lhd_tree_inlining_copy_res_decl_for_inlining\n#define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n  lhd_tree_inlining_anon_aggr_type_p\n#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P \\\n  hook_bool_tree_false\n#define LANG_HOOKS_TREE_INLINING_START_INLINING \\\n  lhd_tree_inlining_start_inlining\n#define LANG_HOOKS_TREE_INLINING_END_INLINING \\\n  lhd_tree_inlining_end_inlining\n#define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n  lhd_tree_inlining_convert_parm_for_inlining\n#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS \\\n  NULL\n\n#define LANG_HOOKS_TREE_INLINING_INITIALIZER { \\\n  LANG_HOOKS_TREE_INLINING_WALK_SUBTREES, \\\n  LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN, \\\n  LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS, \\\n  LANG_HOOKS_TREE_INLINING_ADD_PENDING_FN_DECLS, \\\n  LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P, \\\n  LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P, \\\n  LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P, \\\n  LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P, \\\n  LANG_HOOKS_TREE_INLINING_START_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_END_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING, \\\n  LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS \\\n}\n\n#define LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR lhd_callgraph_analyze_expr\n#define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION NULL\n\n#define LANG_HOOKS_CALLGRAPH_INITIALIZER { \\\n  LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR, \\\n  LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION, \\\n}\n\n#define LANG_HOOKS_FUNCTION_INITIALIZER {\t\\\n  LANG_HOOKS_FUNCTION_INIT,\t\t\t\\\n  LANG_HOOKS_FUNCTION_FINAL,\t\t\t\\\n  LANG_HOOKS_FUNCTION_ENTER_NESTED,\t\t\\\n  LANG_HOOKS_FUNCTION_LEAVE_NESTED\t\t\\\n}\n\n#define LANG_HOOKS_RTL_EXPAND_INITIALIZER {\t\\\n  LANG_HOOKS_RTL_EXPAND_START,\t\t\t\\\n  LANG_HOOKS_RTL_EXPAND_STMT,\t\t\t\\\n  LANG_HOOKS_RTL_EXPAND_END\t\t\t\\\n}\n\n/* Tree dump hooks.  */\nextern bool lhd_tree_dump_dump_tree (void *, tree);\nextern int lhd_tree_dump_type_quals (tree);\n\n#define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN lhd_tree_dump_dump_tree\n#define LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN lhd_tree_dump_type_quals\n\n#define LANG_HOOKS_TREE_DUMP_INITIALIZER { \\\n  LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN, \\\n  LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN \\\n}\n\n/* Types hooks.  There are no reasonable defaults for most of them,\n   so we create a compile-time error instead.  */\n#define LANG_HOOKS_MAKE_TYPE make_node\n#define LANG_HOOKS_INCOMPLETE_TYPE_ERROR lhd_incomplete_type_error\n#define LANG_HOOKS_TYPE_PROMOTES_TO lhd_type_promotes_to\n#define LANG_HOOKS_REGISTER_BUILTIN_TYPE lhd_register_builtin_type\n\n#define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n  LANG_HOOKS_MAKE_TYPE, \\\n  LANG_HOOKS_TYPE_FOR_MODE, \\\n  LANG_HOOKS_TYPE_FOR_SIZE, \\\n  LANG_HOOKS_UNSIGNED_TYPE, \\\n  LANG_HOOKS_SIGNED_TYPE, \\\n  LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE, \\\n  LANG_HOOKS_TYPE_PROMOTES_TO, \\\n  LANG_HOOKS_REGISTER_BUILTIN_TYPE, \\\n  LANG_HOOKS_INCOMPLETE_TYPE_ERROR \\\n}\n\n/* Declaration hooks.  */\n#define LANG_HOOKS_PUSHLEVEL\tpushlevel\n#define LANG_HOOKS_POPLEVEL\tpoplevel\n#define LANG_HOOKS_GLOBAL_BINDINGS_P global_bindings_p\n#define LANG_HOOKS_INSERT_BLOCK\tinsert_block\n#define LANG_HOOKS_SET_BLOCK\tset_block\n#define LANG_HOOKS_PUSHDECL\tpushdecl\n#define LANG_HOOKS_GETDECLS\tgetdecls\n#define LANG_HOOKS_BUILTIN_TYPE_DECLS lhd_return_null_tree_v\n#define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL lhd_warn_unused_global_decl\n#define LANG_HOOKS_WRITE_GLOBALS write_global_declarations\n#define LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE NULL\n#define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n\n#define LANG_HOOKS_DECLS { \\\n  LANG_HOOKS_PUSHLEVEL, \\\n  LANG_HOOKS_POPLEVEL, \\\n  LANG_HOOKS_GLOBAL_BINDINGS_P, \\\n  LANG_HOOKS_INSERT_BLOCK, \\\n  LANG_HOOKS_SET_BLOCK, \\\n  LANG_HOOKS_PUSHDECL, \\\n  LANG_HOOKS_GETDECLS, \\\n  LANG_HOOKS_BUILTIN_TYPE_DECLS, \\\n  LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL, \\\n  LANG_HOOKS_WRITE_GLOBALS, \\\n  LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE, \\\n  LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n}\n\n/* The whole thing.  The structure is defined in langhooks.h.  */\n#define LANG_HOOKS_INITIALIZER { \\\n  LANG_HOOKS_NAME, \\\n  LANG_HOOKS_IDENTIFIER_SIZE, \\\n  LANG_HOOKS_TREE_SIZE, \\\n  LANG_HOOKS_INIT_OPTIONS, \\\n  LANG_HOOKS_INITIALIZE_DIAGNOSTICS, \\\n  LANG_HOOKS_HANDLE_OPTION, \\\n  LANG_HOOKS_MISSING_ARGUMENT, \\\n  LANG_HOOKS_POST_OPTIONS, \\\n  LANG_HOOKS_INIT, \\\n  LANG_HOOKS_FINISH, \\\n  LANG_HOOKS_PARSE_FILE, \\\n  LANG_HOOKS_CLEAR_BINDING_STACK, \\\n  LANG_HOOKS_GET_ALIAS_SET, \\\n  LANG_HOOKS_EXPAND_CONSTANT, \\\n  LANG_HOOKS_EXPAND_EXPR, \\\n  LANG_HOOKS_TRUTHVALUE_CONVERSION, \\\n  LANG_HOOKS_SAFE_FROM_P, \\\n  LANG_HOOKS_FINISH_INCOMPLETE_DECL, \\\n  LANG_HOOKS_UNSAFE_FOR_REEVAL, \\\n  LANG_HOOKS_MARK_ADDRESSABLE, \\\n  LANG_HOOKS_STATICP, \\\n  LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\\n  LANG_HOOKS_UNSAVE_EXPR_NOW, \\\n  LANG_HOOKS_MAYBE_BUILD_CLEANUP, \\\n  LANG_HOOKS_SET_DECL_ASSEMBLER_NAME, \\\n  LANG_HOOKS_CAN_USE_BIT_FIELDS_P, \\\n  LANG_HOOKS_HONOR_READONLY, \\\n  LANG_HOOKS_NO_BODY_BLOCKS, \\\n  LANG_HOOKS_PRINT_STATISTICS, \\\n  LANG_HOOKS_PRINT_XNODE, \\\n  LANG_HOOKS_PRINT_DECL, \\\n  LANG_HOOKS_PRINT_TYPE, \\\n  LANG_HOOKS_PRINT_IDENTIFIER, \\\n  LANG_HOOKS_DECL_PRINTABLE_NAME, \\\n  LANG_HOOKS_GET_CALLEE_FNDECL, \\\n  LANG_HOOKS_PRINT_ERROR_FUNCTION, \\\n  LANG_HOOKS_EXPR_SIZE, \\\n  LANG_HOOKS_DECL_UNINIT, \\\n  LANG_HOOKS_ATTRIBUTE_TABLE, \\\n  LANG_HOOKS_COMMON_ATTRIBUTE_TABLE, \\\n  LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE, \\\n  LANG_HOOKS_FUNCTION_INITIALIZER, \\\n  LANG_HOOKS_TREE_INLINING_INITIALIZER, \\\n  LANG_HOOKS_CALLGRAPH_INITIALIZER, \\\n  LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n  LANG_HOOKS_DECLS, \\\n  LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n  LANG_HOOKS_RTL_EXPAND_INITIALIZER \\\n}\n\n#endif /* GCC_LANG_HOOKS_DEF_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LANGHOOK": {"ttr": 6922, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* The lang_hooks data structure.\n   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LANG_HOOKS_H\n#define GCC_LANG_HOOKS_H\n\n/* This file should be #include-d after tree.h.  */\n\nstruct diagnostic_context;\n\n/* A print hook for print_tree ().  */\ntypedef void (*lang_print_tree_hook) (FILE *, tree, int indent);\n\n/* The following hooks are documented in langhooks.c.  Must not be\n   NULL.  */\n\nstruct lang_hooks_for_tree_inlining\n{\n  tree (*walk_subtrees) (tree *, int *,\n\t\t\t tree (*) (tree *, int *, void *),\n\t\t\t void *, void *);\n  int (*cannot_inline_tree_fn) (tree *);\n  int (*disregard_inline_limits) (tree);\n  tree (*add_pending_fn_decls) (void *, tree);\n  int (*tree_chain_matters_p) (tree);\n  int (*auto_var_in_fn_p) (tree, tree);\n  tree (*copy_res_decl_for_inlining) (tree, tree, tree,\n\t\t\t\t      void *, int *, tree);\n  int (*anon_aggr_type_p) (tree);\n  bool (*var_mod_type_p) (tree);\n  int (*start_inlining) (tree);\n  void (*end_inlining) (tree);\n  tree (*convert_parm_for_inlining) (tree, tree, tree, int);\n  int (*estimate_num_insns) (tree);\n};\n\nstruct lang_hooks_for_callgraph\n{\n  /* The node passed is a language-specific tree node.  If its contents\n     are relevant to use of other declarations, mark them.  */\n  tree (*analyze_expr) (tree *, int *, tree);\n\n  /* Produce RTL for function passed as argument.  */\n  void (*expand_function) (tree);\n};\n\n/* Lang hooks for management of language-specific data or status\n   when entering / leaving functions etc.  */\nstruct lang_hooks_for_functions\n{\n  /* Called when entering a function.  */\n  void (*init) (struct function *);\n\n  /* Called when leaving a function.  */\n  void (*final) (struct function *);\n\n  /* Called when entering a nested function.  */\n  void (*enter_nested) (struct function *);\n\n  /* Called when leaving a nested function.  */\n  void (*leave_nested) (struct function *);\n};\n\n/* Lang hooks for rtl code generation.  */\nstruct lang_hooks_for_rtl_expansion\n{\n  /* Called after expand_function_start, but before expanding the body.  */\n  void (*start) (void);\n\n  /* Called to expand each statement.  */\n  void (*stmt) (tree);\n\n  /* Called after expanding the body but before expand_function_end.  */\n  void (*end) (void);\n};\n\n/* The following hooks are used by tree-dump.c.  */\n\nstruct lang_hooks_for_tree_dump\n{\n  /* Dump language-specific parts of tree nodes.  Returns nonzero if it\n     does not want the usual dumping of the second argument.  */\n  bool (*dump_tree) (void *, tree);\n\n  /* Determine type qualifiers in a language-specific way.  */\n  int (*type_quals) (tree);\n};\n\n/* Hooks related to types.  */\n\nstruct lang_hooks_for_types\n{\n  /* Return a new type (with the indicated CODE), doing whatever\n     language-specific processing is required.  */\n  tree (*make_type) (enum tree_code);\n\n  /* Given MODE and UNSIGNEDP, return a suitable type-tree with that\n     mode.  */\n  tree (*type_for_mode) (enum machine_mode, int);\n\n  /* Given PRECISION and UNSIGNEDP, return a suitable type-tree for an\n     integer type with at least that precision.  */\n  tree (*type_for_size) (unsigned, int);\n\n  /* Given an integer type T, return a type like T but unsigned.\n     If T is unsigned, the value is T.  */\n  tree (*unsigned_type) (tree);\n\n  /* Given an integer type T, return a type like T but signed.\n     If T is signed, the value is T.  */\n  tree (*signed_type) (tree);\n\n  /* Return a type the same as TYPE except unsigned or signed\n     according to UNSIGNEDP.  */\n  tree (*signed_or_unsigned_type) (int, tree);\n\n  /* Given a type, apply default promotions to unnamed function\n     arguments and return the new type.  Return the same type if no\n     change.  Required by any language that supports variadic\n     arguments.  The default hook aborts.  */\n  tree (*type_promotes_to) (tree);\n\n  /* Register TYPE as a builtin type with the indicated NAME.  The\n     TYPE is placed in the outermost lexical scope.  The semantics\n     should be analogous to:\n\n       typedef TYPE NAME;\n\n     in C.  The default hook ignores the declaration.  */\n  void (*register_builtin_type) (tree, const char *);\n\n  /* This routine is called in tree.c to print an error message for\n     invalid use of an incomplete type.  VALUE is the expression that\n     was used (or 0 if that isn't known) and TYPE is the type that was\n     invalid.  */\n  void (*incomplete_type_error) (tree value, tree type);\n};\n\n/* Language hooks related to decls and the symbol table.  */\n\nstruct lang_hooks_for_decls\n{\n  /* Enter a new lexical scope.  Argument is always zero when called\n     from outside the front end.  */\n  void (*pushlevel) (int);\n\n  /* Exit a lexical scope and return a BINDING for that scope.\n     Takes three arguments:\n     KEEP -- nonzero if there were declarations in this scope.\n     REVERSE -- reverse the order of decls before returning them.\n     FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n  tree (*poplevel) (int, int, int);\n\n  /* Returns nonzero if we are in the global binding level.  Ada\n     returns -1 for an undocumented reason used in stor-layout.c.  */\n  int (*global_bindings_p) (void);\n\n  /* Insert BLOCK at the end of the list of subblocks of the\n     current binding level.  This is used when a BIND_EXPR is expanded,\n     to handle the BLOCK node inside the BIND_EXPR.  */\n  void (*insert_block) (tree);\n\n  /* Set the BLOCK node for the current scope level.  */\n  void (*set_block) (tree);\n\n  /* Function to add a decl to the current scope level.  Takes one\n     argument, a decl to add.  Returns that decl, or, if the same\n     symbol is already declared, may return a different decl for that\n     name.  */\n  tree (*pushdecl) (tree);\n\n  /* Returns the chain of decls so far in the current scope level.  */\n  tree (*getdecls) (void);\n\n  /* Returns a chain of TYPE_DECLs for built-in types.  */\n  tree (*builtin_type_decls) (void);\n\n  /* Returns true when we should warn for an unused global DECL.\n     We will already have checked that it has static binding.  */\n  bool (*warn_unused_global) (tree);\n\n  /* Obtain a list of globals and do final output on them at end\n     of compilation */\n  void (*final_write_globals) (void);\n\n  /* Do necessary preparations before assemble_variable can proceed.  */\n  void (*prepare_assemble_variable) (tree);\n\n  /* True if this decl may be called via a sibcall.  */\n  bool (*ok_for_sibcall) (tree);\n};\n\n/* Language-specific hooks.  See langhooks-def.h for defaults.  */\n\nstruct lang_hooks\n{\n  /* String identifying the front end.  e.g. \"GNU C++\".  */\n  const char *name;\n\n  /* sizeof (struct lang_identifier), so make_node () creates\n     identifier nodes long enough for the language-specific slots.  */\n  size_t identifier_size;\n\n  /* Determines the size of any language-specific 'x' or 'c' nodes.\n     Since it is called from make_node, the only information available\n     is the tree code.  Expected to abort on unrecognized codes.  */\n  size_t (*tree_size) (enum tree_code);\n\n  /* The first callback made to the front end, for simple\n     initialization needed before any calls to handle_option.  Return\n     the language mask to filter the switch array with.  */\n  unsigned int (*init_options) (unsigned int argc, const char **argv);\n\n  /* Callback used to perform language-specific initialization for the\n     global diagnostic context structure.  */\n  void (*initialize_diagnostics) (struct diagnostic_context *);\n\n  /* Handle the switch CODE, which has real type enum opt_code from\n     options.h.  If the switch takes an argument, it is passed in ARG\n     which points to permanent storage.  The handler is responsible for\n     checking whether ARG is NULL, which indicates that no argument\n     was in fact supplied.  For -f and -W switches, VALUE is 1 or 0\n     for the positive and negative forms respectively.\n\n     Return 1 if the switch is valid, 0 if invalid, and -1 if it's\n     valid and should not be treated as language-independent too.  */\n  int (*handle_option) (size_t code, const char *arg, int value);\n\n  /* Return false to use the default complaint about a missing\n     argument, otherwise output a complaint and return true.  */\n  bool (*missing_argument) (const char *opt, size_t code);\n\n  /* Called when all command line options have been parsed to allow\n     further processing and initialization\n\n     Should return true to indicate that a compiler back-end is\n     not required, such as with the -E option.\n\n     If errorcount is nonzero after this call the compiler exits\n     immediately and the finish hook is not called.  */\n  bool (*post_options) (const char **);\n\n  /* Called after post_options to initialize the front end.  Return\n     false to indicate that no further compilation be performed, in\n     which case the finish hook is called immediately.  */\n  bool (*init) (void);\n\n  /* Called at the end of compilation, as a finalizer.  */\n  void (*finish) (void);\n\n  /* Parses the entire file.  The argument is nonzero to cause bison\n     parsers to dump debugging information during parsing.  */\n  void (*parse_file) (int);\n\n  /* Called immediately after parsing to clear the binding stack.  */\n  void (*clear_binding_stack) (void);\n\n  /* Called to obtain the alias set to be used for an expression or type.\n     Returns -1 if the language does nothing special for it.  */\n  HOST_WIDE_INT (*get_alias_set) (tree);\n\n  /* Called with an expression that is to be processed as a constant.\n     Returns either the same expression or a language-independent\n     constant equivalent to its input.  */\n  tree (*expand_constant) (tree);\n\n  /* Called by expand_expr for language-specific tree codes.\n     Fourth argument is actually an enum expand_modifier.  */\n  rtx (*expand_expr) (tree, rtx, enum machine_mode, int, rtx *);\n\n  /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n     operation.\n\n     This preparation consists of taking the ordinary representation\n     of an expression expr and producing a valid tree boolean\n     expression describing whether expr is nonzero.  We could simply\n     always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n     but we optimize comparisons, &&, ||, and !.\n\n     The result should be an expression of boolean type (if not an\n     error_mark_node).  */\n  tree (*truthvalue_conversion) (tree);\n\n  /* Hook called by safe_from_p for language-specific tree codes.  It is\n     up to the language front-end to install a hook if it has any such\n     codes that safe_from_p needs to know about.  Since same_from_p will\n     recursively explore the TREE_OPERANDs of an expression, this hook\n     should not reexamine those pieces.  This routine may recursively\n     call safe_from_p; it should always pass `0' as the TOP_P\n     parameter.  */\n  int (*safe_from_p) (rtx, tree);\n\n  /* Function to finish handling an incomplete decl at the end of\n     compilation.  Default hook is does nothing.  */\n  void (*finish_incomplete_decl) (tree);\n\n  /* Function used by unsafe_for_reeval.  A non-negative number is\n     returned directly from unsafe_for_reeval, a negative number falls\n     through.  The default hook returns a negative number.  */\n  int (*unsafe_for_reeval) (tree);\n\n  /* Mark EXP saying that we need to be able to take the address of\n     it; it should not be allocated in a register.  Return true if\n     successful.  */\n  bool (*mark_addressable) (tree);\n\n  /* Hook called by staticp for language-specific tree codes.  */\n  int (*staticp) (tree);\n\n  /* Replace the DECL_LANG_SPECIFIC data, which may be NULL, of the\n     DECL_NODE with a newly GC-allocated copy.  */\n  void (*dup_lang_specific_decl) (tree);\n\n  /* Called before its argument, an UNSAVE_EXPR, is to be\n     unsaved.  Modify it in-place so that all the evaluate only once\n     things are cleared out.  */\n  tree (*unsave_expr_now) (tree);\n\n  /* Called by expand_expr to build and return the cleanup-expression\n     for the passed TARGET_EXPR.  Return NULL if there is none.  */\n  tree (*maybe_build_cleanup) (tree);\n\n  /* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of\n     thing that the assembler should talk about, set\n     DECL_ASSEMBLER_NAME to an appropriate IDENTIFIER_NODE.\n     Otherwise, set it to the ERROR_MARK_NODE to ensure that the\n     assembler does not talk about it.  */\n  void (*set_decl_assembler_name) (tree);\n\n  /* Return nonzero if fold-const is free to use bit-field\n     optimizations, for instance in fold_truthop().  */\n  bool (*can_use_bit_fields_p) (void);\n\n  /* Nonzero if TYPE_READONLY and TREE_READONLY should always be honored.  */\n  bool honor_readonly;\n\n  /* Nonzero if this front end does not generate a dummy BLOCK between\n     the outermost scope of the function and the FUNCTION_DECL.  See\n     is_body_block in stmt.c, and its callers.  */\n  bool no_body_blocks;\n\n  /* The front end can add its own statistics to -fmem-report with\n     this hook.  It should output to stderr.  */\n  void (*print_statistics) (void);\n\n  /* Called by print_tree when there is a tree of class 'x' that it\n     doesn't know how to display.  */\n  lang_print_tree_hook print_xnode;\n\n  /* Called to print language-dependent parts of a class 'd', class\n     't', and IDENTIFIER_NODE nodes.  */\n  lang_print_tree_hook print_decl;\n  lang_print_tree_hook print_type;\n  lang_print_tree_hook print_identifier;\n\n  /* Computes the name to use to print a declaration.  DECL is the\n     non-NULL declaration in question.  VERBOSITY determines what\n     information will be printed: 0: DECL_NAME, demangled as\n     necessary.  1: and scope information.  2: and any other\n     information that might be interesting, such as function parameter\n     types in C++.  */\n  const char *(*decl_printable_name) (tree decl, int verbosity);\n\n  /* Given a CALL_EXPR, return a function decl that is its target.  */\n  tree (*lang_get_callee_fndecl) (tree);\n\n  /* Called by report_error_function to print out function name.  */\n  void (*print_error_function) (struct diagnostic_context *, const char *);\n\n  /* Called from expr_size to calculate the size of the value of an\n     expression in a language-dependent way.  Returns a tree for the size\n     in bytes.  A frontend can call lhd_expr_size to get the default\n     semantics in cases that it doesn't want to handle specially.  */\n  tree (*expr_size) (tree);\n\n  /* Called from uninitialized_vars_warning to find out if a variable is\n     uninitialized based on DECL_INITIAL.  */\n  bool (*decl_uninit) (tree);\n\n  /* Pointers to machine-independent attribute tables, for front ends\n     using attribs.c.  If one is NULL, it is ignored.  Respectively, a\n     table of attributes specific to the language, a table of\n     attributes common to two or more languages (to allow easy\n     sharing), and a table of attributes for checking formats.  */\n  const struct attribute_spec *attribute_table;\n  const struct attribute_spec *common_attribute_table;\n  const struct attribute_spec *format_attribute_table;\n\n  /* Function-related language hooks.  */\n  struct lang_hooks_for_functions function;\n\n  struct lang_hooks_for_tree_inlining tree_inlining;\n\n  struct lang_hooks_for_callgraph callgraph;\n\n  struct lang_hooks_for_tree_dump tree_dump;\n\n  struct lang_hooks_for_decls decls;\n\n  struct lang_hooks_for_types types;\n\n  struct lang_hooks_for_rtl_expansion rtl_expand;\n\n  /* Whenever you add entries here, make sure you adjust langhooks-def.h\n     and langhooks.c accordingly.  */\n};\n\n/* Each front end provides its own.  */\nextern const struct lang_hooks lang_hooks;\n\n#endif /* GCC_LANG_HOOKS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBFUNCS": {"ttr": 6926, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_LIBFUNCS_H\n#define GCC_LIBFUNCS_H\n\n/* Enumeration of indexes into libfunc_table.  */\nenum libfunc_index\n{\n  LTI_abort,\n  LTI_memcpy,\n  LTI_memmove,\n  LTI_bcopy,\n  LTI_memcmp,\n  LTI_bcmp,\n  LTI_memset,\n  LTI_bzero,\n  LTI_setbits,\n\n  LTI_unwind_resume,\n  LTI_eh_personality,\n  LTI_setjmp,\n  LTI_longjmp,\n  LTI_unwind_sjlj_register,\n  LTI_unwind_sjlj_unregister,\n\n  LTI_profile_function_entry,\n  LTI_profile_function_exit,\n\n  LTI_gcov_flush,\n  LTI_gcov_init,\n\n  LTI_MAX\n};\n\n/* SYMBOL_REF rtx's for the library functions that are called\n   implicitly and not via optabs.  */\nextern GTY(()) rtx libfunc_table\u00ddLTI_MAX\u00a8;\n\n/* Accessor macros for libfunc_table.  */\n\n#define abort_libfunc\t(libfunc_table\u00ddLTI_abort\u00a8)\n#define memcpy_libfunc\t(libfunc_table\u00ddLTI_memcpy\u00a8)\n#define memmove_libfunc\t(libfunc_table\u00ddLTI_memmove\u00a8)\n#define bcopy_libfunc\t(libfunc_table\u00ddLTI_bcopy\u00a8)\n#define memcmp_libfunc\t(libfunc_table\u00ddLTI_memcmp\u00a8)\n#define bcmp_libfunc\t(libfunc_table\u00ddLTI_bcmp\u00a8)\n#define memset_libfunc\t(libfunc_table\u00ddLTI_memset\u00a8)\n#define bzero_libfunc\t(libfunc_table\u00ddLTI_bzero\u00a8)\n#define setbits_libfunc\t(libfunc_table\u00ddLTI_setbits\u00a8)\n\n#define unwind_resume_libfunc\t(libfunc_table\u00ddLTI_unwind_resume\u00a8)\n#define eh_personality_libfunc\t(libfunc_table\u00ddLTI_eh_personality\u00a8)\n#define setjmp_libfunc\t(libfunc_table\u00ddLTI_setjmp\u00a8)\n#define longjmp_libfunc\t(libfunc_table\u00ddLTI_longjmp\u00a8)\n#define unwind_sjlj_register_libfunc (libfunc_table\u00ddLTI_unwind_sjlj_register\u00a8)\n#define unwind_sjlj_unregister_libfunc \\\n  (libfunc_table\u00ddLTI_unwind_sjlj_unregister\u00a8)\n\n#define profile_function_entry_libfunc\t(libfunc_table\u00ddLTI_profile_function_entry\u00a8)\n#define profile_function_exit_libfunc\t(libfunc_table\u00ddLTI_profile_function_exit\u00a8)\n\n#define gcov_flush_libfunc\t(libfunc_table\u00ddLTI_gcov_flush\u00a8)\n#define gcov_init_libfunc\t(libfunc_table\u00ddLTI_gcov_init\u00a8)\n\n#endif /* GCC_LIBFUNCS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBGCC2": {"ttr": 7169, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Header file for libgcc2.c.  */\n/* Copyright (C) 2000, 2001\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n\n#ifndef GCC_LIBGCC2_H\n#define GCC_LIBGCC2_H\n\nextern int __gcc_bcmp (const unsigned char *, const unsigned char *, size_t);\nextern void __clear_cache (char *, char *);\nextern void __eprintf (const char *, const char *, unsigned int, const char *)\n  __attribute__ ((__noreturn__));\n\nstruct exception_descriptor;\nextern short int __get_eh_table_language (struct exception_descriptor *);\nextern short int __get_eh_table_version (struct exception_descriptor *);\n\n/* Permit the tm.h file to select the endianness to use just for this\n   file.  This is used when the endianness is determined when the\n   compiler is run.  */\n\n#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n#endif\n\n#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n#endif\n\n#ifndef MIN_UNITS_PER_WORD\n#define MIN_UNITS_PER_WORD UNITS_PER_WORD\n#endif\n\n/* In the first part of this file, we are interfacing to calls generated\n   by the compiler itself.  These calls pass values into these routines\n   which have very specific modes (rather than very specific types), and\n   these compiler-generated calls also expect any return values to have\n   very specific modes (rather than very specific types).  Thus, we need\n   to avoid using regular C language type names in this part of the file\n   because the sizes for those types can be configured to be anything.\n   Instead we use the following special type names.  */\n\ntypedef\t\t int QItype\t__attribute__ ((mode (QI)));\ntypedef unsigned int UQItype\t__attribute__ ((mode (QI)));\ntypedef\t\t int HItype\t__attribute__ ((mode (HI)));\ntypedef unsigned int UHItype\t__attribute__ ((mode (HI)));\n#if MIN_UNITS_PER_WORD > 1\n/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1.  */\ntypedef \t int SItype\t__attribute__ ((mode (SI)));\ntypedef unsigned int USItype\t__attribute__ ((mode (SI)));\n#if LONG_LONG_TYPE_SIZE > 32\n/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2.  */\ntypedef\t\t int DItype\t__attribute__ ((mode (DI)));\ntypedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n#if MIN_UNITS_PER_WORD > 4\n/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 4.  */\ntypedef\t\t int TItype\t__attribute__ ((mode (TI)));\ntypedef unsigned int UTItype\t__attribute__ ((mode (TI)));\n#endif\n#endif\n#endif\n\n#if BITS_PER_UNIT == 8\n\ntypedef \tfloat SFtype\t__attribute__ ((mode (SF)));\ntypedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\ntypedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n#endif\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\ntypedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n#endif\n\n#else /* BITS_PER_UNIT != 8 */\n\n/* On dsp's there are usually qf/hf/tqf modes used instead of the above.\n   For now we don't support them in libgcc2.c.  */\n\n#undef L_fixdfdi\n#undef L_fixsfdi\n#undef L_fixtfdi\n#undef L_fixunsdfdi\n#undef L_fixunsdfsi\n#undef L_fixunssfdi\n#undef L_fixunssfsi\n#undef L_fixunstfdi\n#undef L_fixunsxfdi\n#undef L_fixunsxfsi\n#undef L_fixxfdi\n#undef L_floatdidf\n#undef L_floatdisf\n#undef L_floatditf\n#undef L_floatdixf\n\n#endif /* BITS_PER_UNIT != 8 */\n\ntypedef int word_type __attribute__ ((mode (__word__)));\n\n/* Make sure that we don't accidentally use any normal C language built-in\n   type names in the first part of this file.  Instead we want to use *only*\n   the type names defined above.  The following macro definitions insure\n   that if we *do* accidentally use some normal C language built-in type name,\n   we will get a syntax error.  */\n\n#define char bogus_type\n#define short bogus_type\n#define int bogus_type\n#define long bogus_type\n#define unsigned bogus_type\n#define float bogus_type\n#define double bogus_type\n\n/* Versions prior to 3.4.4 were not taking into account the word size for\n   the 5 trapping arithmetic functions absv, addv, subv, mulv and negv.  As\n   a consequence, the si and di variants were always and the only ones emitted.\n   To maintain backward compatibility, COMPAT_SIMODE_TRAPPING_ARITHMETIC is\n   defined on platforms where it makes sense to still have the si variants\n   emitted.  As a bonus, their implementation is now correct.  Note that the\n   same mechanism should have been implemented for the di variants, but it\n   turns out that no platform would define COMPAT_DIMODE_TRAPPING_ARITHMETIC\n   if it existed.  */\n\n#if MIN_UNITS_PER_WORD > 4\n#define W_TYPE_SIZE (8 * BITS_PER_UNIT)\n#define Wtype\tDItype\n#define UWtype\tUDItype\n#define HWtype\tDItype\n#define UHWtype\tUDItype\n#define DWtype\tTItype\n#define UDWtype\tUTItype\n#define __NW(a,b)\t__ ## a ## di ## b\n#define __NDW(a,b)\t__ ## a ## ti ## b\n#define COMPAT_SIMODE_TRAPPING_ARITHMETIC\n#elif MIN_UNITS_PER_WORD > 2 \\\n      || (MIN_UNITS_PER_WORD > 1 && LONG_LONG_TYPE_SIZE > 32)\n#define W_TYPE_SIZE (4 * BITS_PER_UNIT)\n#define Wtype\tSItype\n#define UWtype\tUSItype\n#define HWtype\tSItype\n#define UHWtype\tUSItype\n#define DWtype\tDItype\n#define UDWtype\tUDItype\n#define __NW(a,b)\t__ ## a ## si ## b\n#define __NDW(a,b)\t__ ## a ## di ## b\n#elif MIN_UNITS_PER_WORD > 1\n#define W_TYPE_SIZE (2 * BITS_PER_UNIT)\n#define Wtype\tHItype\n#define UWtype\tUHItype\n#define HWtype\tHItype\n#define UHWtype\tUHItype\n#define DWtype\tSItype\n#define UDWtype\tUSItype\n#define __NW(a,b)\t__ ## a ## hi ## b\n#define __NDW(a,b)\t__ ## a ## si ## b\n#else\n#define W_TYPE_SIZE BITS_PER_UNIT\n#define Wtype\tQItype\n#define UWtype  UQItype\n#define HWtype\tQItype\n#define UHWtype\tUQItype\n#define DWtype\tHItype\n#define UDWtype\tUHItype\n#define __NW(a,b)\t__ ## a ## qi ## b\n#define __NDW(a,b)\t__ ## a ## hi ## b\n#endif\n\n#define Wtype_MAX ((Wtype)(((UWtype)1 << (W_TYPE_SIZE - 1)) - 1))\n#define Wtype_MIN (- Wtype_MAX - 1)\n\n#define __muldi3\t__NDW(mul,3)\n#define __divdi3\t__NDW(div,3)\n#define __udivdi3\t__NDW(udiv,3)\n#define __moddi3\t__NDW(mod,3)\n#define __umoddi3\t__NDW(umod,3)\n#define __negdi2\t__NDW(neg,2)\n#define __lshrdi3\t__NDW(lshr,3)\n#define __ashldi3\t__NDW(ashl,3)\n#define __ashrdi3\t__NDW(ashr,3)\n#define __cmpdi2\t__NDW(cmp,2)\n#define __ucmpdi2\t__NDW(ucmp,2)\n#define __udivmoddi4\t__NDW(udivmod,4)\n#define __fixunstfDI\t__NDW(fixunstf,)\n#define __fixtfdi\t__NDW(fixtf,)\n#define __fixunsxfDI\t__NDW(fixunsxf,)\n#define __fixxfdi\t__NDW(fixxf,)\n#define __fixunsdfDI\t__NDW(fixunsdf,)\n#define __fixdfdi\t__NDW(fixdf,)\n#define __fixunssfDI\t__NDW(fixunssf,)\n#define __fixsfdi\t__NDW(fixsf,)\n#define __floatdixf\t__NDW(float,xf)\n#define __floatditf\t__NDW(float,tf)\n#define __floatdidf\t__NDW(float,df)\n#define __floatdisf\t__NDW(float,sf)\n#define __fixunsxfSI\t__NW(fixunsxf,)\n#define __fixunstfSI\t__NW(fixunstf,)\n#define __fixunsdfSI\t__NW(fixunsdf,)\n#define __fixunssfSI\t__NW(fixunssf,)\n\n#define __absvSI2\t__NW(absv,2)\n#define __addvSI3\t__NW(addv,3)\n#define __subvSI3\t__NW(subv,3)\n#define __mulvSI3\t__NW(mulv,3)\n#define __negvSI2\t__NW(negv,2)\n#define __absvDI2\t__NDW(absv,2)\n#define __addvDI3\t__NDW(addv,3)\n#define __subvDI3\t__NDW(subv,3)\n#define __mulvDI3\t__NDW(mulv,3)\n#define __negvDI2\t__NDW(negv,2)\n\n#define __ffsSI2\t__NW(ffs,2)\n#define __clzSI2\t__NW(clz,2)\n#define __ctzSI2\t__NW(ctz,2)\n#define __popcountSI2\t__NW(popcount,2)\n#define __paritySI2\t__NW(parity,2)\n#define __ffsDI2\t__NDW(ffs,2)\n#define __clzDI2\t__NDW(clz,2)\n#define __ctzDI2\t__NDW(ctz,2)\n#define __popcountDI2\t__NDW(popcount,2)\n#define __parityDI2\t__NDW(parity,2)\n\nextern DWtype __muldi3 (DWtype, DWtype);\nextern DWtype __divdi3 (DWtype, DWtype);\nextern UDWtype __udivdi3 (UDWtype, UDWtype);\nextern UDWtype __umoddi3 (UDWtype, UDWtype);\nextern DWtype __moddi3 (DWtype, DWtype);\n\n/* __udivmoddi4 is static inline when building other libgcc2 portions.  */\n#if (!defined (L_udivdi3) && !defined (L_divdi3) && \\\n     !defined (L_umoddi3) && !defined (L_moddi3))\nextern UDWtype __udivmoddi4 (UDWtype, UDWtype, UDWtype *);\n#endif\n\n/* __negdi2 is static inline when building other libgcc2 portions.  */\n#if !defined(L_divdi3) && !defined(L_moddi3)\nextern DWtype __negdi2 (DWtype);\n#endif\n\nextern DWtype __lshrdi3 (DWtype, word_type);\nextern DWtype __ashldi3 (DWtype, word_type);\nextern DWtype __ashrdi3 (DWtype, word_type);\n\n/* __udiv_w_sdiv is static inline when building other libgcc2 portions.  */\n#if (!defined(L_udivdi3) && !defined(L_divdi3) && \\\n     !defined(L_umoddi3) && !defined(L_moddi3))\nextern UWtype __udiv_w_sdiv (UWtype *, UWtype, UWtype, UWtype);\n#endif\n\nextern word_type __cmpdi2 (DWtype, DWtype);\nextern word_type __ucmpdi2 (DWtype, DWtype);\n\nextern Wtype __absvSI2 (Wtype);\nextern Wtype __addvSI3 (Wtype, Wtype);\nextern Wtype __subvSI3 (Wtype, Wtype);\nextern Wtype __mulvSI3 (Wtype, Wtype);\nextern Wtype __negvSI2 (Wtype);\nextern DWtype __absvDI2 (DWtype);\nextern DWtype __addvDI3 (DWtype, DWtype);\nextern DWtype __subvDI3 (DWtype, DWtype);\nextern DWtype __mulvDI3 (DWtype, DWtype);\nextern DWtype __negvDI2 (DWtype);\n\n#ifdef COMPAT_SIMODE_TRAPPING_ARITHMETIC\nextern SItype __absvsi2 (SItype);\nextern SItype __addvsi3 (SItype, SItype);\nextern SItype __subvsi3 (SItype, SItype);\nextern SItype __mulvsi3 (SItype, SItype);\nextern SItype __negvsi2 (SItype);\n#endif /* COMPAT_SIMODE_TRAPPING_ARITHMETIC */\n\n#if BITS_PER_UNIT == 8\nextern DWtype __fixdfdi (DFtype);\nextern DWtype __fixsfdi (SFtype);\nextern DFtype __floatdidf (DWtype);\nextern SFtype __floatdisf (DWtype);\nextern UWtype __fixunsdfSI (DFtype);\nextern UWtype __fixunssfSI (SFtype);\nextern DWtype __fixunsdfDI (DFtype);\nextern DWtype __fixunssfDI (SFtype);\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\nextern DWtype __fixxfdi (XFtype);\nextern DWtype __fixunsxfDI (XFtype);\nextern XFtype __floatdixf (DWtype);\nextern UWtype __fixunsxfSI (XFtype);\n#endif\n\n#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\nextern DWtype __fixunstfDI (TFtype);\nextern DWtype __fixtfdi (TFtype);\nextern TFtype __floatditf (DWtype);\n#endif\n#endif /* BITS_PER_UNIT == 8 */\n\n/* DWstructs are pairs of Wtype values in the order determined by\n   LIBGCC2_WORDS_BIG_ENDIAN.  */\n\n#if LIBGCC2_WORDS_BIG_ENDIAN\n  struct DWstruct {Wtype high, low;};\n#else\n  struct DWstruct {Wtype low, high;};\n#endif\n\n/* We need this union to unpack/pack DImode values, since we don't have\n   any arithmetic yet.  Incoming DImode parameters are stored into the\n   `ll' field, and the unpacked result is read from the struct `s'.  */\n\ntypedef union\n{\n  struct DWstruct s;\n  DWtype ll;\n} DWunion;\n\n#include \"longlong.h\"\n\n#endif /* ! GCC_LIBGCC2_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBIBERT": {"ttr": 7173, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Function declarations for libiberty.\n\n   Copyright 2001, 2002 Free Software Foundation, Inc.\n\n   Note - certain prototypes declared in this header file are for\n   functions whoes implementation copyright does not belong to the\n   FSF.  Those prototypes are present in this file for reference\n   purposes only and their presence in this file should not construed\n   as an indication of ownership by the FSF of the implementation of\n   those functions in any way or form whatsoever.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.\n\n   Written by Cygnus Support, 1994.\n\n   The libiberty library provides a number of functions which are\n   missing on some operating systems.  We do not declare those here,\n   to avoid conflicts with the system header files on operating\n   systems that do support those functions.  In this file we only\n   declare those functions which are specific to libiberty.  */\n\n#ifndef LIBIBERTY_H\n#define LIBIBERTY_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"ansidecl.h\"\n\n#ifdef ANSI_PROTOTYPES\n/* Get a definition for size_t.  */\n#include <stddef.h>\n/* Get a definition for va_list.  */\n#include <stdarg.h>\n#endif\n\n/* Build an argument vector from a string.  Allocates memory using\n   malloc.  Use freeargv to free the vector.  */\n\nextern char **buildargv PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Free a vector returned by buildargv.  */\n\nextern void freeargv PARAMS ((char **));\n\n/* Duplicate an argument vector. Allocates memory using malloc.  Use\n   freeargv to free the vector.  */\n\nextern char **dupargv PARAMS ((char **)) ATTRIBUTE_MALLOC;\n\n\n/* Return the last component of a path name.  Note that we can't use a\n   prototype here because the parameter is declared inconsistently\n   across different systems, sometimes as \"char *\" and sometimes as\n   \"const char *\" */\n\n/* HAVE_DECL_* is a three-state macro: undefined, 0 or 1.  If it is\n   undefined, we haven't run the autoconf check so provide the\n   declaration without arguments.  If it is 0, we checked and failed\n   to find the declaration so provide a fully prototyped one.  If it\n   is 1, we found it so don't provide any declaration at all.  */\n#if !HAVE_DECL_BASENAME\n#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (HAVE_DECL_BASENAME)\nextern char *basename PARAMS ((const char *));\n#else\nextern char *basename ();\n#endif\n#endif\n\n/* A well-defined basename () that is always compiled in.  */\n\nextern const char *lbasename PARAMS ((const char *));\n\n/* A well-defined realpath () that is always compiled in.  */\n\nextern char *lrealpath PARAMS ((const char *));\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using xmalloc.  */\n\nextern char *concat PARAMS ((const char *, ...)) ATTRIBUTE_MALLOC;\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using xmalloc.  The first argument is\n   not one of the strings to be concatenated, but if not NULL is a\n   pointer to be freed after the new string is created, similar to the\n   way xrealloc works.  */\n\nextern char *reconcat PARAMS ((char *, const char *, ...)) ATTRIBUTE_MALLOC;\n\n/* Determine the length of concatenating an arbitrary number of\n   strings.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  */\n\nextern unsigned long concat_length PARAMS ((const char *, ...));\n\n/* Concatenate an arbitrary number of strings into a SUPPLIED area of\n   memory.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  The supplied memory is assumed\n   to be large enough.  */\n\nextern char *concat_copy PARAMS ((char *, const char *, ...));\n\n/* Concatenate an arbitrary number of strings into a GLOBAL area of\n   memory.  You must pass NULL as the last argument of this function,\n   to terminate the list of strings.  The supplied memory is assumed\n   to be large enough.  */\n\nextern char *concat_copy2 PARAMS ((const char *, ...));\n\n/* This is the global area used by concat_copy2.  */\n\nextern char *libiberty_concat_ptr;\n\n/* Concatenate an arbitrary number of strings.  You must pass NULL as\n   the last argument of this function, to terminate the list of\n   strings.  Allocates memory using alloca.  The arguments are\n   evaluated twice!  */\n#define ACONCAT(ACONCAT_PARAMS) \\\n  (libiberty_concat_ptr = alloca (concat_length ACONCAT_PARAMS + 1), \\\n   concat_copy2 ACONCAT_PARAMS)\n\n/* Check whether two file descriptors refer to the same file.  */\n\nextern int fdmatch PARAMS ((int fd1, int fd2));\n\n/* Get the working directory.  The result is cached, so don't call\n   chdir() between calls to getpwd().  */\n\nextern char * getpwd PARAMS ((void));\n\n/* Get the amount of time the process has run, in microseconds.  */\n\nextern long get_run_time PARAMS ((void));\n\n/* Generate a relocated path to some installation directory.  Allocates\n   return value using malloc.  */\n\nextern char *make_relative_prefix PARAMS ((const char *, const char *,\n\t\t\t\t\t   const char *));\n\n/* Choose a temporary directory to use for scratch files.  */\n\nextern char *choose_temp_base PARAMS ((void)) ATTRIBUTE_MALLOC;\n\n/* Return a temporary file name or NULL if unable to create one.  */\n\nextern char *make_temp_file PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Allocate memory filled with spaces.  Allocates using malloc.  */\n\nextern const char *spaces PARAMS ((int count));\n\n/* Return the maximum error number for which strerror will return a\n   string.  */\n\nextern int errno_max PARAMS ((void));\n\n/* Return the name of an errno value (e.g., strerrno (EINVAL) returns\n   \"EINVAL\").  */\n\nextern const char *strerrno PARAMS ((int));\n\n/* Given the name of an errno value, return the value.  */\n\nextern int strtoerrno PARAMS ((const char *));\n\n/* ANSI's strerror(), but more robust.  */\n\nextern char *xstrerror PARAMS ((int));\n\n/* Return the maximum signal number for which strsignal will return a\n   string.  */\n\nextern int signo_max PARAMS ((void));\n\n/* Return a signal message string for a signal number\n   (e.g., strsignal (SIGHUP) returns something like \"Hangup\").  */\n/* This is commented out as it can conflict with one in system headers.\n   We still document its existence though.  */\n\n/*extern const char *strsignal PARAMS ((int));*/\n\n/* Return the name of a signal number (e.g., strsigno (SIGHUP) returns\n   \"SIGHUP\").  */\n\nextern const char *strsigno PARAMS ((int));\n\n/* Given the name of a signal, return its number.  */\n\nextern int strtosigno PARAMS ((const char *));\n\n/* case-insensitive string comparison */\n\nextern int strcasecmp(const char *s1, const char *s2);\n\n/* get page size */\n\nint getpagesize(void);\n\n/* Register a function to be run by xexit.  Returns 0 on success.  */\n\nextern int xatexit PARAMS ((void (*fn) (void)));\n\n/* Exit, calling all the functions registered with xatexit.  */\n\nextern void xexit PARAMS ((int status)) ATTRIBUTE_NORETURN;\n\n/* Set the program name used by xmalloc.  */\n\nextern void xmalloc_set_program_name PARAMS ((const char *));\n\n/* Report an allocation failure.  */\nextern void xmalloc_failed PARAMS ((size_t)) ATTRIBUTE_NORETURN;\n\n/* Allocate memory without fail.  If malloc fails, this will print a\n   message to stderr (using the name set by xmalloc_set_program_name,\n   if any) and then call xexit.  */\n\nextern PTR xmalloc PARAMS ((size_t)) ATTRIBUTE_MALLOC;\n\n/* Reallocate memory without fail.  This works like xmalloc.  Note,\n   realloc type functions are not suitable for attribute malloc since\n   they may return the same address across multiple calls. */\n\nextern PTR xrealloc PARAMS ((PTR, size_t));\n\n/* Allocate memory without fail and set it to zero.  This works like\n   xmalloc.  */\n\nextern PTR xcalloc PARAMS ((size_t, size_t)) ATTRIBUTE_MALLOC;\n\n/* Copy a string into a memory buffer without fail.  */\n\nextern char *xstrdup PARAMS ((const char *)) ATTRIBUTE_MALLOC;\n\n/* Copy an existing memory buffer to a new memory buffer without fail.  */\n\nextern PTR xmemdup PARAMS ((const PTR, size_t, size_t)) ATTRIBUTE_MALLOC;\n\n/* Physical memory routines.  Return values are in BYTES.  */\nextern double physmem_total PARAMS ((void));\nextern double physmem_available PARAMS ((void));\n\n/* hex character manipulation routines */\n\n#define _hex_array_size 256\n#define _hex_bad\t99\nextern const unsigned char _hex_value\u00dd_hex_array_size\u00a8;\nextern void hex_init PARAMS ((void));\n#define hex_p(c)\t(hex_value (c) != _hex_bad)\n/* If you change this, note well: Some code relies on side effects in\n   the argument being performed exactly once.  */\n#define hex_value(c)\t((unsigned int) _hex_value\u00dd(unsigned char) (c)\u00a8)\n\n/* Definitions used by the pexecute routine.  */\n\n#define PEXECUTE_FIRST   1\n#define PEXECUTE_LAST    2\n#define PEXECUTE_ONE     (PEXECUTE_FIRST + PEXECUTE_LAST)\n#define PEXECUTE_SEARCH  4\n#define PEXECUTE_VERBOSE 8\n\n/* Execute a program.  */\n\nextern int pexecute PARAMS ((const char *, char * const *, const char *,\n\t\t\t    const char *, char **, char **, int));\n\n/* Wait for pexecute to finish.  */\n\nextern int pwait PARAMS ((int, int *, int));\n\n#if !HAVE_DECL_ASPRINTF\n/* Like sprintf but provides a pointer to malloc'd storage, which must\n   be freed by the caller.  */\n\nextern int asprintf PARAMS ((char **, const char *, ...)) ATTRIBUTE_PRINTF_2;\n#endif\n\n#if !HAVE_DECL_VASPRINTF\n/* Like vsprintf but provides a pointer to malloc'd storage, which\n   must be freed by the caller.  */\n\nextern int vasprintf PARAMS ((char **, const char *, va_list))\n  ATTRIBUTE_PRINTF(2,0);\n#endif\n\n#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)\u00dd0\u00a8))\n\n/* Drastically simplified alloca configurator.  If we're using GCC,\n   we use __builtin_alloca; otherwise we use the C alloca.  The C\n   alloca is always available.  You can override GCC by defining\n   USE_C_ALLOCA yourself.  The canonical autoconf macro C_ALLOCA is\n   also set/unset as it is often used to indicate whether code needs\n   to call alloca(0).  */\nextern PTR C_alloca PARAMS ((size_t)) ATTRIBUTE_MALLOC;\n#undef alloca\n#if GCC_VERSION >= 2000 && !defined USE_C_ALLOCA\n# define alloca(x) __builtin_alloca(x)\n# undef C_ALLOCA\n# define ASTRDUP(X) \\\n  (__extension__ ({ const char *const libiberty_optr = (X); \\\n   const unsigned long libiberty_len = strlen (libiberty_optr) + 1; \\\n   char *const libiberty_nptr = alloca (libiberty_len); \\\n   (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len); }))\n#else\n# define alloca(x) C_alloca(x)\n# undef USE_C_ALLOCA\n# define USE_C_ALLOCA 1\n# undef C_ALLOCA\n# define C_ALLOCA 1\nextern const char *libiberty_optr;\nextern char *libiberty_nptr;\nextern unsigned long libiberty_len;\n# define ASTRDUP(X) \\\n  (libiberty_optr = (X), \\\n   libiberty_len = strlen (libiberty_optr) + 1, \\\n   libiberty_nptr = alloca (libiberty_len), \\\n   (char *) memcpy (libiberty_nptr, libiberty_optr, libiberty_len))\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif /* ! defined (LIBIBERTY_H) */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIMITX": {"ttr": 7177, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This administrivia gets added to the beginning of limits.h\n   if the system has its own version of limits.h.  */\n\n/* We use _GCC_LIMITS_H_ because we want this not to match\n   any macros that the system's limits.h uses for its own purposes.  */\n#ifndef _GCC_LIMITS_H_  /* Terminated in limity.h.  */\n#define _GCC_LIMITS_H_\n\n#ifndef _LIBC_LIMITS_H_\n/* Use \"...\" so that we find syslimits.h only in this same directory.  */\n#include \"syslimits.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIMITY": {"ttr": 7179, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This administrivia gets added to the end of limits.h\n   if the system has its own version of limits.h.  */\n\n#else /* not _GCC_LIMITS_H_ */\n\n#ifdef _GCC_NEXT_LIMITS_H\n#include_next <limits.h>\t\t/* recurse down to the real one */\n#endif\n\n#endif /* not _GCC_LIMITS_H_ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINE@MAP": {"ttr": 7181, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Map logical line numbers to (source file, line number) pairs.\n   Copyright (C) 2001, 2003\n   Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_LINE_MAP_H\n#define GCC_LINE_MAP_H\n\n/* Reason for adding a line change with add_line_map ().  LC_ENTER is\n   when including a new file, e.g. a #include directive in C.\n   LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file\n   name or line number changes for neither of the above reasons\n   (e.g. a #line directive in C).  */\nenum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n\n/* A logical line number, i,e, an \"index\" into a line_map.  */\n/* Long-term, we want to use this to replace struct location_s (in input.h),\n   and effectively typedef source_location location_t.  */\ntypedef unsigned int source_location;\ntypedef source_location fileline; /* deprecated name */\n\n/* The logical line FROM_LINE maps to physical source file TO_FILE at\n   line TO_LINE, and subsequently one-to-one until the next line_map\n   structure in the set.  INCLUDED_FROM is an index into the set that\n   gives the line mapping at whose end the current one was included.\n   File(s) at the bottom of the include stack have this set to -1.\n   REASON is the reason for creation of this line map, SYSP is one for\n   a system header, two for a C system header file that therefore\n   needs to be extern \"C\" protected in C++, and zero otherwise.  */\nstruct line_map\n{\n  const char *to_file;\n  unsigned int to_line;\n  source_location from_line;\n  int included_from;\n  ENUM_BITFIELD (lc_reason) reason : CHAR_BIT;\n  unsigned char sysp;\n};\n\n/* A set of chronological line_map structures.  */\nstruct line_maps\n{\n  struct line_map *maps;\n  unsigned int allocated;\n  unsigned int used;\n\n  /* The most recently listed include stack, if any, starts with\n     LAST_LISTED as the topmost including file.  -1 indicates nothing\n     has been listed yet.  */\n  int last_listed;\n\n  /* Depth of the include stack, including the current file.  */\n  unsigned int depth;\n\n  /* If true, prints an include trace a la -H.  */\n  bool trace_includes;\n};\n\n/* Initialize a line map set.  */\nextern void linemap_init (struct line_maps *);\n\n/* Free a line map set.  */\nextern void linemap_free (struct line_maps *);\n\n/* Add a mapping of logical source line to physical source file and\n   line number.\n\n   The text pointed to by TO_FILE must have a lifetime\n   at least as long as the final call to lookup_line ().  An empty\n   TO_FILE means standard input.  If reason is LC_LEAVE, and\n   TO_FILE is NULL, then TO_FILE, TO_LINE and SYSP are given their\n   natural values considering the file we are returning to.\n\n   FROM_LINE should be monotonic increasing across calls to this\n   function.  A call to this function can relocate the previous set of\n   maps, so any stored line_map pointers should not be used.  */\nextern const struct line_map *linemap_add\n  (struct line_maps *, enum lc_reason, unsigned int sysp,\n   source_location from_line, const char *to_file, unsigned int to_line);\n\n/* Given a logical line, returns the map from which the corresponding\n   (source file, line) pair can be deduced.  */\nextern const struct line_map *linemap_lookup\n  (struct line_maps *, source_location);\n\n/* Print the file names and line numbers of the #include commands\n   which led to the map MAP, if any, to stderr.  Nothing is output if\n   the most recently listed stack is the same as the current one.  */\nextern void linemap_print_containing_files (struct line_maps *,\n\t\t\t\t\t    const struct line_map *);\n\n/* Converts a map and logical line to source line.  */\n#define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)\n\n/* Returns the last source line within a map.  This is the (last) line\n   of the #include, or other directive, that caused a map change.  */\n#define LAST_SOURCE_LINE(MAP) SOURCE_LINE ((MAP), (MAP)\u00dd1\u00a8.from_line - 1)\n\n/* Returns the map a given map was included from.  */\n#define INCLUDED_FROM(SET, MAP) (&(SET)->maps\u00dd(MAP)->included_from\u00a8)\n\n/* Nonzero if the map is at the bottom of the include stack.  */\n#define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n\n/* The current line map.  Saves a call to lookup_line if the caller is\n   sure he is in the scope of the current map.  */\n#define CURRENT_LINE_MAP(MAPS) ((MAPS)->maps + (MAPS)->used - 1)\n\n#endif /* !GCC_LINE_MAP_H  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINUX": {"ttr": 7183, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002\n   Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for Linux/390 by Linas Vepstas (linas@linas.org)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\n#define TARGET_VERSION fprintf (stderr, \" (i370 GNU/Linux with ELF)\");\n\n/* Specify that we're generating code for a Linux port to 370 */\n\n#define TARGET_LINUX\n#define LINUX_DEFAULT_ELF\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()\n\n/* Options for this target machine.  */\n\n#define LIBGCC_SPEC \"libgcc.a%s\"\n\n#ifdef SOME_FUTURE_DAY\n\n#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE} %(cpp_sysv) %(cpp_endian_big) \\\n%{mcall-linux: %(cpp_os_linux) } \\\n%{!mcall-linux: %(cpp_os_default) }\"\n\n#define LIB_SPEC \"\\\n%{mcall-linux: %(lib_linux) } \\\n%{!mcall-linux:%(lib_default) }\"\n\n#define STARTFILE_SPEC \"\\\n%{mcall-linux: %(startfile_linux) } \\\n%{!mcall-linux: %(startfile_default) }\"\n\n#define ENDFILE_SPEC \"\\\n%{mcall-linux: %(endfile_linux) } \\\n%{!mcall-linux: %(endfile_default) }\"\n\n/* GNU/Linux support.  */\n#ifndef LIB_LINUX_SPEC\n#define LIB_LINUX_SPEC \"%{mnewlib: --start-group -llinux -lc --end-group } %{!mnewlib: -lc }\"\n#endif\n\n#ifndef STARTFILE_LINUX_SPEC\n#define STARTFILE_LINUX_SPEC \"\\\n%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n%{mnewlib: ecrti.o%s} \\\n%{!mnewlib: crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n#endif\n\n#ifndef ENDFILE_LINUX_SPEC\n#define ENDFILE_LINUX_SPEC \"\\\n%{mnewlib: ecrtn.o%s} \\\n%{!mnewlib: %{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s}\"\n#endif\n\n#ifndef LINK_START_LINUX_SPEC\n#define LINK_START_LINUX_SPEC \"-Ttext 0x10000\"\n#endif\n\n#ifndef LINK_OS_LINUX_SPEC\n#define LINK_OS_LINUX_SPEC \"\"\n#endif\n\n#ifndef CPP_OS_LINUX_SPEC\n#define CPP_OS_LINUX_SPEC \"-D__unix__ -D__gnu_linux__ -D__linux__ \\\n%{!ansi: -Dunix -Dlinux } \\\n-Asystem=unix -Asystem=linux\"\n#endif\n\n#ifndef CPP_OS_LINUX_SPEC\n#define CPP_OS_LINUX_SPEC \"\"\n#endif\n\n\n/* Define any extra SPECS that the compiler needs to generate.  */\n#undef  SUBTARGET_EXTRA_SPECS\n#define SUBTARGET_EXTRA_SPECS                                           \\\n  { \"lib_linux\",                LIB_LINUX_SPEC },                       \\\n  { \"lib_default\",              LIB_DEFAULT_SPEC },                     \\\n  { \"startfile_linux\",          STARTFILE_LINUX_SPEC },                 \\\n  { \"startfile_default\",        STARTFILE_DEFAULT_SPEC },               \\\n  { \"endfile_linux\",            ENDFILE_LINUX_SPEC },                   \\\n  { \"endfile_default\",          ENDFILE_DEFAULT_SPEC },                 \\\n  { \"link_shlib\",               LINK_SHLIB_SPEC },                      \\\n  { \"link_target\",              LINK_TARGET_SPEC },                     \\\n  { \"link_start\",               LINK_START_SPEC },                      \\\n  { \"link_start_linux\",         LINK_START_LINUX_SPEC },                \\\n  { \"link_os\",                  LINK_OS_SPEC },                         \\\n  { \"link_os_linux\",            LINK_OS_LINUX_SPEC },                   \\\n  { \"link_os_default\",          LINK_OS_DEFAULT_SPEC },                 \\\n  { \"cpp_endian_big\",           CPP_ENDIAN_BIG_SPEC },                  \\\n  { \"cpp_os_linux\",             CPP_OS_LINUX_SPEC },                    \\\n  { \"cpp_os_default\",           CPP_OS_DEFAULT_SPEC },\n\n#endif /* SOME_FUTURE_DAY */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LONGLONG": {"ttr": 7185, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* longlong.h -- definitions for mixed size 32/64 bit arithmetic.\n   Copyright (C) 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n   2005 Free Software Foundation, Inc.\n\n   This definition file is free software; you can redistribute it\n   and/or modify it under the terms of the GNU General Public\n   License as published by the Free Software Foundation; either\n   version 2, or (at your option) any later version.\n\n   This definition file is distributed in the hope that it will be\n   useful, but WITHOUT ANY WARRANTY; without even the implied\n   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n   See the GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* You have to define the following before including this file:\n\n   UWtype -- An unsigned type, default type for operations (typically a \"word\")\n   UHWtype -- An unsigned type, at least half the size of UWtype.\n   UDWtype -- An unsigned type, at least twice as large a UWtype\n   W_TYPE_SIZE -- size in bits of UWtype\n\n   UQItype -- Unsigned 8 bit type.\n   SItype, USItype -- Signed and unsigned 32 bit types.\n   DItype, UDItype -- Signed and unsigned 64 bit types.\n\n   On a 32 bit machine UWtype should typically be USItype;\n   on a 64 bit machine, UWtype should typically be UDItype.\n*/\n\n#define __BITS4 (W_TYPE_SIZE / 4)\n#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))\n#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))\n#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))\n\n#ifndef W_TYPE_SIZE\n#define W_TYPE_SIZE\t32\n#define UWtype\t\tUSItype\n#define UHWtype\t\tUSItype\n#define UDWtype\t\tUDItype\n#endif\n\n/* Define auxiliary asm macros.\n\n   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two\n   UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype\n   word product in HIGH_PROD and LOW_PROD.\n\n   2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a\n   UDWtype product.  This is just a variant of umul_ppmm.\n\n   3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n   denominator) divides a UDWtype, composed by the UWtype integers\n   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient\n   in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less\n   than DENOMINATOR for correct operation.  If, in addition, the most\n   significant bit of DENOMINATOR must be 1, then the pre-processor symbol\n   UDIV_NEEDS_NORMALIZATION is defined to 1.\n\n   4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n   denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient\n   is rounded towards 0.\n\n   5) count_leading_zeros(count, x) counts the number of zero-bits from the\n   msb to the first nonzero bit in the UWtype X.  This is the number of\n   steps X needs to be shifted left to set the msb.  Undefined for X == 0,\n   unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.\n\n   6) count_trailing_zeros(count, x) like count_leading_zeros, but counts\n   from the least significant end.\n\n   7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,\n   high_addend_2, low_addend_2) adds two UWtype integers, composed by\n   HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2\n   respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow\n   (i.e. carry out) is not stored anywhere, and is lost.\n\n   8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,\n   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,\n   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and\n   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE\n   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n   and is lost.\n\n   If any of these macros are left undefined for a particular CPU,\n   C macros are used.  */\n\n/* The CPUs come in alphabetical order below.\n\n   Please add support for more CPUs here, or improve the current support\n   for the CPUs below!\n   (E.g. WE32100, IBM360.)  */\n\n#if defined (__GNUC__) && !defined (NO_ASM)\n\n/* We sometimes need to clobber \"cc\" with gcc2, but that would not be\n   understood by gcc1.  Use cpp to avoid major code duplication.  */\n#if __GNUC__ < 2\n#define __CLOBBER_CC\n#define __AND_CLOBBER_CC\n#else /* __GNUC__ >= 2 */\n#define __CLOBBER_CC : \"cc\"\n#define __AND_CLOBBER_CC , \"cc\"\n#endif /* __GNUC__ < 2 */\n\n#if defined (__alpha) && W_TYPE_SIZE == 64\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    (ph) = __builtin_alpha_umulh (__m0, __m1);\t\t\t\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 46\n#ifndef LONGLONG_STANDALONE\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  do { UDItype __r;\t\t\t\t\t\t\t\\\n    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));\t\t\t\t\\\n    (r) = __r;\t\t\t\t\t\t\t\t\\\n  } while (0)\nextern UDItype __udiv_qrnnd (UDItype *, UDItype, UDItype, UDItype);\n#define UDIV_TIME 220\n#endif /* LONGLONG_STANDALONE */\n#ifdef __alpha_cix__\n#define count_leading_zeros(COUNT,X)\t((COUNT) = __builtin_clzl (X))\n#define count_trailing_zeros(COUNT,X)\t((COUNT) = __builtin_ctzl (X))\n#define COUNT_LEADING_ZEROS_0 64\n#else\nextern const UQItype __clz_tab\u00dd\u00a8 ATTRIBUTE_HIDDEN;\n#define count_leading_zeros(COUNT,X) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n    __t = __builtin_alpha_cmpbge (0, __xr);\t\t\t\t\\\n    __a = __clz_tab\u00dd__t \u00ac 0xff\u00a8 - 1;\t\t\t\t\t\\\n    __t = __builtin_alpha_extbl (__xr, __a);\t\t\t\t\\\n    (COUNT) = 64 - (__clz_tab\u00dd__t\u00a8 + __a*8);\t\t\t\t\\\n  } while (0)\n#define count_trailing_zeros(COUNT,X) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __xr = (X), __t, __a;\t\t\t\t\t\\\n    __t = __builtin_alpha_cmpbge (0, __xr);\t\t\t\t\\\n    __t = ~__t & -~__t;\t\t\t\t\t\t\t\\\n    __a = ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n    __t = __builtin_alpha_extbl (__xr, __a);\t\t\t\t\\\n    __a <<= 3;\t\t\t\t\t\t\t\t\\\n    __t &= -__t;\t\t\t\t\t\t\t\\\n    __a += ((__t & 0xCC) != 0) * 2;\t\t\t\t\t\\\n    __a += ((__t & 0xF0) != 0) * 4;\t\t\t\t\t\\\n    __a += ((__t & 0xAA) != 0);\t\t\t\t\t\t\\\n    (COUNT) = __a;\t\t\t\t\t\t\t\\\n  } while (0)\n#endif /* __alpha_cix__ */\n#endif /* __alpha */\n\n#if defined (__arc__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add.f\t%1, %4, %5\\n\\tadc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub.f\t%1, %4, %5\\n\\tsbc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rIJ\" ((USItype) (bl)))\n/* Call libgcc routine.  */\n#define umul_ppmm(w1, w0, u, v) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n  DWunion __w;\t\t\t\t\t\t\t\t\\\n  __w.ll = __umulsidi3 (u, v);\t\t\t\t\t\t\\\n  w1 = __w.s.high;\t\t\t\t\t\t\t\\\n  w0 = __w.s.low;\t\t\t\t\t\t\t\\\n} while (0)\n#define __umulsidi3 __umulsidi3\nUDItype __umulsidi3 (USItype, USItype);\n#endif\n\n#if defined (__arm__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"adds\t%1, %4, %5\\n\\tadc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subs\t%1, %4, %5\\n\\tsbc\t%0, %2, %3\"\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl)))\n#define umul_ppmm(xh, xl, a, b) \\\n{register USItype __t0, __t1, __t2;\t\t\t\t\t\\\n  __asm__ (\"%@ Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\t   \"\tmov\t%2, %5, lsr #16\\n\"\t\t\t\t\\\n\t   \"\tmov\t%0, %6, lsr #16\\n\"\t\t\t\t\\\n\t   \"\tbic\t%3, %5, %2, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tbic\t%4, %6, %0, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tmul\t%1, %3, %4\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%4, %2, %4\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%3, %0, %3\\n\"\t\t\t\t\t\\\n\t   \"\tmul\t%0, %2, %0\\n\"\t\t\t\t\t\\\n\t   \"\tadds\t%3, %4, %3\\n\"\t\t\t\t\t\\\n\t   \"\taddcs\t%0, %0, #65536\\n\"\t\t\t\t\\\n\t   \"\tadds\t%1, %1, %3, lsl #16\\n\"\t\t\t\t\\\n\t   \"\tadc\t%0, %0, %3, lsr #16\"\t\t\t\t\\\n\t   : \"=&r\" ((USItype) (xh)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (xl)),\t\t\t\t\t\\\n\t     \"=&r\" (__t0), \"=&r\" (__t1), \"=r\" (__t2)\t\t\t\\\n\t   : \"r\" ((USItype) (a)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (b)));}\n#define UMUL_TIME 20\n#define UDIV_TIME 100\n#endif /* __arm__ */\n\n#if defined (__hppa) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add %4,%5,%1\\n\\taddc %2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rM\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rM\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub %4,%5,%1\\n\\tsubb %2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rM\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rM\" ((USItype) (bl)))\n#if defined (_PA_RISC1_1)\n#define umul_ppmm(w1, w0, u, v) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tUDItype __f;\t\t\t\t\t\t\t\\\n\tstruct {USItype __w1, __w0;} __w1w0;\t\t\t\t\\\n      } __t;\t\t\t\t\t\t\t\t\\\n    __asm__ (\"xmpyu %1,%2,%0\"\t\t\t\t\t\t\\\n\t     : \"=x\" (__t.__f)\t\t\t\t\t\t\\\n\t     : \"x\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"x\" ((USItype) (v)));\t\t\t\t\t\\\n    (w1) = __t.__w1w0.__w1;\t\t\t\t\t\t\\\n    (w0) = __t.__w1w0.__w0;\t\t\t\t\t\t\\\n     } while (0)\n#define UMUL_TIME 8\n#else\n#define UMUL_TIME 30\n#endif\n#define UDIV_TIME 40\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __tmp;\t\t\t\t\t\t\t\\\n    __asm__ (\t\t\t\t\t\t\t\t\\\n       \"ldi\t\t1,%0\\n\"\t\t\t\t\t\t\\\n\"\textru,=\t\t%1,15,16,%%r0\t\t; Bits 31..16 zero?\\n\"\t\\\n\"\textru,tr\t%1,15,16,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t16(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,23,8,%%r0\t\t; Bits 15..8 zero?\\n\"\t\\\n\"\textru,tr\t%1,23,8,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t8(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,27,4,%%r0\t\t; Bits 7..4 zero?\\n\"\t\\\n\"\textru,tr\t%1,27,4,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t4(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru,=\t\t%1,29,2,%%r0\t\t; Bits 3..2 zero?\\n\"\t\\\n\"\textru,tr\t%1,29,2,%1\t\t; No.  Shift down, skip add.\\n\"\\\n\"\tldo\t\t2(%0),%0\t\t; Yes.  Perform add.\\n\"\t\\\n\"\textru\t\t%1,30,1,%1\t\t; Extract bit 1.\\n\"\t\\\n\"\tsub\t\t%0,%1,%0\t\t; Subtract it.\\n\"\t\\\n\t: \"=r\" (count), \"=r\" (__tmp) : \"1\" (x));\t\t\t\\\n  } while (0)\n#endif\n\n#if (defined (__i370__) || defined(__s390__) \\\n     || defined (__VSE__) \\\n     || defined (__MVS__) || defined(__CMS__)) && W_TYPE_SIZE == 32\n#define smul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __x;\t\t\t\t\t\t\t\\\n    __asm__ (\"lr %N0,%1\\n\\tmr %0,%2\"\t\t\t\t\t\\\n\t     : \"=&r\" (__x.__ll)\t\t\t\t\t\t\\\n\t     : \"r\" (m0), \"r\" (m1));\t\t\t\t\t\\\n    (xh) = __x.__i.__h; (xl) = __x.__i.__l;\t\t\t\t\\\n  } while (0)\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __x;\t\t\t\t\t\t\t\\\n    __x.__i.__h = n1; __x.__i.__l = n0;\t\t\t\t\t\\\n    __asm__ (\"dr %0,%2\"\t\t\t\t\t\t\t\\\n\t     : \"=r\" (__x.__ll)\t\t\t\t\t\t\\\n\t     : \"0\" (__x.__ll), \"r\" (d));\t\t\t\t\\\n    (q) = __x.__i.__l; (r) = __x.__i.__h;\t\t\t\t\\\n  } while (0)\n#endif\n\n#if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addl %5,%1\\n\\tadcl %3,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subl %5,%1\\n\\tsbbl %3,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"mull %3\"\t\t\t\t\t\t\t\\\n\t   : \"=a\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"rm\" ((USItype) (v)))\n#define udiv_qrnnd(q, r, n1, n0, dv) \\\n  __asm__ (\"divl %4\"\t\t\t\t\t\t\t\\\n\t   : \"=a\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"rm\" ((USItype) (dv)))\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __cbtmp;\t\t\t\t\t\t\t\\\n    __asm__ (\"bsrl %1,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__cbtmp) : \"rm\" ((USItype) (x)));\t\t\t\\\n    (count) = __cbtmp \u00ac 31;\t\t\t\t\t\t\\\n  } while (0)\n#define count_trailing_zeros(count, x) \\\n  __asm__ (\"bsfl %1,%0\" : \"=r\" (count) : \"rm\" ((USItype)(x)))\n#define UMUL_TIME 40\n#define UDIV_TIME 40\n#endif /* 80x86 */\n\n#if defined (__i960__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n\t   : \"=d\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define __umulsidi3(u, v) \\\n  ({UDItype __w;\t\t\t\t\t\t\t\\\n    __asm__ (\"emul\t%2,%1,%0\"\t\t\t\t\t\\\n\t     : \"=d\" (__w)\t\t\t\t\t\t\\\n\t     : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n    __w; })\n#endif /* __i960__ */\n\n#if defined (__M32R__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  /* The cmp clears the condition bit.  */ \\\n  __asm__ (\"cmp %0,%0\\n\\taddx %1,%5\\n\\taddx %0,%3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl))\t\t\t\t\t\\\n\t   : \"cbit\")\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  /* The cmp clears the condition bit.  */ \\\n  __asm__ (\"cmp %0,%0\\n\\tsubx %1,%5\\n\\tsubx %0,%3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl))\t\t\t\t\t\\\n\t   : \"cbit\")\n#endif /* __M32R__ */\n\n#if defined (__mc68000__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add%.l %5,%1\\n\\taddx%.l %3,%0\"\t\t\t\t\\\n\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub%.l %5,%1\\n\\tsubx%.l %3,%0\"\t\t\t\t\\\n\t   : \"=d\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&d\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n\n/* The '020, '030, '040 and CPU32 have 32x32->64 and 64/32->32q-32r.  */\n#if defined (__mc68020__) || defined(mc68020) \\\n\t|| defined(__mc68030__) || defined(mc68030) \\\n\t|| defined(__mc68040__) || defined(mc68040) \\\n\t|| defined(__mcpu32__) || defined(mcpu32)\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"mulu%.l %3,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (v)))\n#define UMUL_TIME 45\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"divu%.l %4,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (d)))\n#define UDIV_TIME 90\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"divs%.l %4,%1:%0\"\t\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=d\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"dmi\" ((USItype) (d)))\n\n#else /* not mc68020 */\n#if defined(__mcoldfire__)\n#define umul_ppmm(xh, xl, a, b) \\\n  __asm__ (\"| Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%3,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d1,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d1\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d3,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d1,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d4,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tclr%.w\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d3,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tjcc\t1f\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%#65536,%/d1\\n\"\t\t\t\t\t\\\n\t   \"1:\tswap\t%/d2\\n\"\t\t\t\t\t\t\\\n\t   \"\tmoveq\t%#0,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d4,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d2,%1\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d1,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (xh)),\t\t\t\t\t\\\n\t     \"=g\" ((USItype) (xl))\t\t\t\t\t\\\n\t   : \"g\" ((USItype) (a)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (b))\t\t\t\t\t\\\n\t   : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\")\n#define UMUL_TIME 100\n#define UDIV_TIME 400\n#else /* not ColdFire */\n/* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */\n#define umul_ppmm(xh, xl, a, b) \\\n  __asm__ (\"| Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%3,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d1,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d1\\n\"\t\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d3,%/d4\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d1,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d3\\n\"\t\t\t\t\t\\\n\t   \"\tmulu\t%/d0,%/d1\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d4,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\teor%.w\t%/d0,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tswap\t%/d0\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d0,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d3,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tjcc\t1f\\n\"\t\t\t\t\t\t\\\n\t   \"\tadd%.l\t%#65536,%/d1\\n\"\t\t\t\t\t\\\n\t   \"1:\tswap\t%/d2\\n\"\t\t\t\t\t\t\\\n\t   \"\tmoveq\t%#0,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d2,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.w\t%/d4,%/d2\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d2,%1\\n\"\t\t\t\t\t\\\n\t   \"\tadd%.l\t%/d1,%/d0\\n\"\t\t\t\t\t\\\n\t   \"\tmove%.l\t%/d0,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (xh)),\t\t\t\t\t\\\n\t     \"=g\" ((USItype) (xl))\t\t\t\t\t\\\n\t   : \"g\" ((USItype) (a)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (b))\t\t\t\t\t\\\n\t   : \"d0\", \"d1\", \"d2\", \"d3\", \"d4\")\n#define UMUL_TIME 100\n#define UDIV_TIME 400\n#endif /* not ColdFire */\n#endif /* not mc68020 */\n\n/* The '020, '030, '040 and '060 have bitfield insns.\n   cpu32 disguises as a 68020, but lacks them.  */\n#if ( defined (__mc68020__) || defined(mc68020) \\\n\t\t|| defined(__mc68030__) || defined(mc68030) \\\n\t\t|| defined(__mc68040__) || defined(mc68040) \\\n\t\t|| defined(__mc68060__) || defined(mc68060) ) \\\n\t&& !defined(__mcpu32__)\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"bfffo %1{%b2:%b2},%0\"\t\t\t\t\t\\\n\t   : \"=d\" ((USItype) (count))\t\t\t\t\t\\\n\t   : \"od\" ((USItype) (x)), \"n\" (0))\n#endif\n#endif /* mc68000 */\n\n#if defined (__m88000__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addu.co %1,%r4,%r5\\n\\taddu.ci %0,%r2,%r3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subu.co %1,%r4,%r5\\n\\tsubu.ci %0,%r2,%r3\"\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (bl)))\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __cbtmp;\t\t\t\t\t\t\t\\\n    __asm__ (\"ff1 %0,%1\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__cbtmp)\t\t\t\t\t\t\\\n\t     : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n    (count) = __cbtmp \u00ac 31;\t\t\t\t\t\t\\\n  } while (0)\n#define COUNT_LEADING_ZEROS_0 63 /* sic */\n#if defined (__mc88110__)\n#define umul_ppmm(wh, wl, u, v) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    __asm__ (\"mulu.d\t%0,%1,%2\"\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t     : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"r\" ((USItype) (v)));\t\t\t\t\t\\\n    (wh) = __xx.__i.__h;\t\t\t\t\t\t\\\n    (wl) = __xx.__i.__l;\t\t\t\t\t\t\\\n  } while (0)\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  USItype __q;\t\t\t\t\t\t\t\t\\\n  __xx.__i.__h = (n1); __xx.__i.__l = (n0);\t\t\t\t\\\n  __asm__ (\"divu.d %0,%1,%2\"\t\t\t\t\t\t\\\n\t   : \"=r\" (__q)\t\t\t\t\t\t\t\\\n\t   : \"r\" (__xx.__ll),\t\t\t\t\t\t\\\n\t     \"r\" ((USItype) (d)));\t\t\t\t\t\\\n  (r) = (n0) - __q * (d); (q) = __q; })\n#define UMUL_TIME 5\n#define UDIV_TIME 25\n#else\n#define UMUL_TIME 17\n#define UDIV_TIME 150\n#endif /* __mc88110__ */\n#endif /* __m88000__ */\n\n#if defined (__mips__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"multu %2,%3\"\t\t\t\t\t\t\\\n\t   : \"=l\" ((USItype) (w0)),\t\t\t\t\t\\\n\t     \"=h\" ((USItype) (w1))\t\t\t\t\t\\\n\t   : \"d\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"d\" ((USItype) (v)))\n#define UMUL_TIME 10\n#define UDIV_TIME 100\n#endif /* __mips__ */\n\n#if defined (__ns32000__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\t\\\n\t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (v)));\t\t\t\t\t\\\n  (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n#define __umulsidi3(u, v) \\\n  ({UDItype __w;\t\t\t\t\t\t\t\\\n    __asm__ (\"meid %2,%0\"\t\t\t\t\t\t\\\n\t     : \"=g\" (__w)\t\t\t\t\t\t\\\n\t     : \"%0\" ((USItype) (u)),\t\t\t\t\t\\\n\t       \"g\" ((USItype) (v)));\t\t\t\t\t\\\n    __w; })\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  ({union {UDItype __ll;\t\t\t\t\t\t\\\n\t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n  __xx.__i.__h = (n1); __xx.__i.__l = (n0);\t\t\t\t\\\n  __asm__ (\"deid %2,%0\"\t\t\t\t\t\t\t\\\n\t   : \"=g\" (__xx.__ll)\t\t\t\t\t\t\\\n\t   : \"0\" (__xx.__ll),\t\t\t\t\t\t\\\n\t     \"g\" ((USItype) (d)));\t\t\t\t\t\\\n  (r) = __xx.__i.__l; (q) = __xx.__i.__h; })\n#define count_trailing_zeros(count,x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    __asm__ (\"ffsd     %2,%0\"\t\t\t\t\t\t\\\n            : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n            : \"0\" ((USItype) 0),\t\t\t\t\t\\\n              \"r\" ((USItype) (x)));\t\t\t\t\t\\\n  } while (0)\n#endif /* __ns32000__ */\n\n/* FIXME: We should test _IBMR2 here when we add assembly support for the\n   system vendor compilers.\n   FIXME: What's needed for gcc PowerPC VxWorks?  __vxworks__ is not good\n   enough, since that hits ARM and m68k too.  */\n#if (defined (_ARCH_PPC)\t/* AIX */\t\t\t\t\\\n     || defined (_ARCH_PWR)\t/* AIX */\t\t\t\t\\\n     || defined (_ARCH_COM)\t/* AIX */\t\t\t\t\\\n     || defined (__powerpc__)\t/* gcc */\t\t\t\t\\\n     || defined (__POWERPC__)\t/* BEOS */\t\t\t\t\\\n     || defined (__ppc__)\t/* Darwin */\t\t\t\t\\\n     || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */    \\\n     || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */               \\\n         && CPU_FAMILY == PPC)                                                \\\n     ) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"%r\" (al), \"rI\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"%r\" (al), \"rI\" (bl));\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{a%I5|add%I5c} %1,%4,%5\\n\\t{ae|adde} %0,%2,%3\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl)\t\t\t\t\t\\\n\t     : \"%r\" (ah), \"r\" (bh), \"%r\" (al), \"rI\" (bl));\t\t\\\n  } while (0)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (ah) && (ah) == 0)\t\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfze|subfze} %0,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (bh), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (ah) && (ah) == ~(USItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfme|subfme} %0,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (bh), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == ~(USItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"rI\" (al), \"r\" (bl));\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{sf%I4|subf%I4c} %1,%5,%4\\n\\t{sfe|subfe} %0,%3,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl)\t\t\t\t\t\\\n\t       : \"r\" (ah), \"r\" (bh), \"rI\" (al), \"r\" (bl));\t\t\\\n  } while (0)\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"{cntlz|cntlzw} %0,%1\" : \"=r\" (count) : \"r\" (x))\n#define COUNT_LEADING_ZEROS_0 32\n#if defined (_ARCH_PPC) || defined (__powerpc__) || defined (__POWERPC__) \\\n  || defined (__ppc__)                                                    \\\n  || (defined (PPC) && ! defined (CPU_FAMILY)) /* gcc 2.7.x GNU&SysV */       \\\n  || (defined (PPC) && defined (CPU_FAMILY)    /* VxWorks */                  \\\n         && CPU_FAMILY == PPC)\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhwu %0,%1,%2\" : \"=r\" (ph) : \"%r\" (m0), \"r\" (m1));\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 15\n#define smul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    SItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhw %0,%1,%2\" : \"=r\" (ph) : \"%r\" (m0), \"r\" (m1));\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define SMUL_TIME 14\n#define UDIV_TIME 120\n#elif defined (_ARCH_PWR)\n#define UMUL_TIME 8\n#define smul_ppmm(xh, xl, m0, m1) \\\n  __asm__ (\"mul %0,%2,%3\" : \"=r\" (xh), \"=q\" (xl) : \"r\" (m0), \"r\" (m1))\n#define SMUL_TIME 4\n#define sdiv_qrnnd(q, r, nh, nl, d) \\\n  __asm__ (\"div %0,%2,%4\" : \"=r\" (q), \"=q\" (r) : \"r\" (nh), \"1\" (nl), \"r\" (d))\n#define UDIV_TIME 100\n#endif\n#endif /* 32-bit POWER architecture variants.  */\n\n/* We should test _IBMR2 here when we add assembly support for the system\n   vendor compilers.  */\n#if (defined (_ARCH_PPC64) || defined (__powerpc64__)) && W_TYPE_SIZE == 64\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"%r\" (al), \"rI\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)\t\t\\\n      __asm__ (\"{a%I4|add%I4c} %1,%3,%4\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"%r\" (al), \"rI\" (bl));\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{a%I5|add%I5c} %1,%4,%5\\n\\t{ae|adde} %0,%2,%3\"\t\t\\\n\t     : \"=r\" (sh), \"=&r\" (sl)\t\t\t\t\t\\\n\t     : \"%r\" (ah), \"r\" (bh), \"%r\" (al), \"rI\" (bl));\t\t\\\n  } while (0)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if (__builtin_constant_p (ah) && (ah) == 0)\t\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfze|subfze} %0,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (bh), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (ah) && (ah) == ~(UDItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{sfme|subfme} %0,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (bh), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == 0)\t\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{ame|addme} %0,%2\"\t\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"rI\" (al), \"r\" (bl));\\\n    else if (__builtin_constant_p (bh) && (bh) == ~(UDItype) 0)\t\t\\\n      __asm__ (\"{sf%I3|subf%I3c} %1,%4,%3\\n\\t{aze|addze} %0,%2\"\t\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl) : \"r\" (ah), \"rI\" (al), \"r\" (bl));\\\n    else\t\t\t\t\t\t\t\t\\\n      __asm__ (\"{sf%I4|subf%I4c} %1,%5,%4\\n\\t{sfe|subfe} %0,%3,%2\"\t\\\n\t       : \"=r\" (sh), \"=&r\" (sl)\t\t\t\t\t\\\n\t       : \"r\" (ah), \"r\" (bh), \"rI\" (al), \"r\" (bl));\t\t\\\n  } while (0)\n#define count_leading_zeros(count, x) \\\n  __asm__ (\"cntlzd %0,%1\" : \"=r\" (count) : \"r\" (x))\n#define COUNT_LEADING_ZEROS_0 64\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UDItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhdu %0,%1,%2\" : \"=r\" (ph) : \"%r\" (m0), \"r\" (m1));\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 15\n#define smul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    DItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"mulhd %0,%1,%2\" : \"=r\" (ph) : \"%r\" (m0), \"r\" (m1));\t\\\n    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n  } while (0)\n#define SMUL_TIME 14  /* ??? */\n#define UDIV_TIME 120 /* ??? */\n#endif /* 64-bit PowerPC.  */\n\n#if defined (__ibm032__) /* RT/ROMP */ && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"a %1,%5\\n\\tae %0,%3\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"s %1,%5\\n\\tse %0,%3\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (bl)))\n#define umul_ppmm(ph, pl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\t\t\t\t\t\t\t\t\\\n       \"s\tr2,r2\\n\"\t\t\t\t\t\t\\\n\"\tmts\tr10,%2\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tm\tr2,%3\\n\"\t\t\t\t\t\t\\\n\"\tcas\t%0,r2,r0\\n\"\t\t\t\t\t\t\\\n\"\tmfs\tr10,%1\"\t\t\t\t\t\t\t\\\n\t     : \"=r\" ((USItype) (ph)),\t\t\t\t\t\\\n\t       \"=r\" ((USItype) (pl))\t\t\t\t\t\\\n\t     : \"%r\" (__m0),\t\t\t\t\t\t\\\n\t\t\"r\" (__m1)\t\t\t\t\t\t\\\n\t     : \"r2\");\t\t\t\t\t\t\t\\\n    (ph) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 20\n#define UDIV_TIME 200\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    if ((x) >= 0x10000)\t\t\t\t\t\t\t\\\n      __asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n\t       : \"=r\" ((USItype) (count))\t\t\t\t\\\n\t       : \"r\" ((USItype) (x) >> 16));\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__asm__ (\"clz\t%0,%1\"\t\t\t\t\t\t\\\n\t\t : \"=r\" ((USItype) (count))\t\t\t\t\\\n\t\t : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n\t(count) += 16;\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if defined (__sh2__) && W_TYPE_SIZE == 32\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\t\t\t\t\t\t\t\t\\\n       \"dmulu.l\t%2,%3\\n\\tsts\tmacl,%1\\n\\tsts\tmach,%0\"\t\t\\\n\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype)(v))\t\t\t\t\t\t\\\n\t   : \"macl\", \"mach\")\n#define UMUL_TIME 5\n#endif\n\n#if defined (__SH5__) && __SHMEDIA__ && W_TYPE_SIZE == 32\n#define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)\n#define count_leading_zeros(count, x) \\\n  do\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      UDItype x_ = (USItype)(x);\t\t\t\t\t\\\n      SItype c_;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      __asm__ (\"nsb %1, %0\" : \"=r\" (c_) : \"r\" (x_));\t\t\t\\\n      (count) = c_ - 31;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n  while (0)\n#define COUNT_LEADING_ZEROS_0 32\n#endif\n\n#if defined (__sparc__) && !defined (__arch64__) && !defined (__sparcv9) \\\n    && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addcc %r4,%5,%1\\n\\taddx %r2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n\t   __CLOBBER_CC)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subcc %r4,%5,%1\\n\\tsubx %r2,%3,%0\"\t\t\t\t\\\n\t   : \"=r\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"rJ\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"rJ\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (bl))\t\t\t\t\t\\\n\t   __CLOBBER_CC)\n#if defined (__sparc_v8__)\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v)))\n#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \\\n  __asm__ (\"mov %2,%%y;nop;nop;nop;udiv %3,%4,%0;umul %0,%4,%1;sub %3,%1,%1\"\\\n\t   : \"=&r\" ((USItype) (__q)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (__r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (__n1)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (__n0)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (__d)))\n#else\n#if defined (__sparclite__)\n/* This has hardware multiply but not divide.  It also has two additional\n   instructions scan (ffs from high bit) and divscc.  */\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"umul %2,%3,%1;rd %%y,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v)))\n#define udiv_qrnnd(q, r, n1, n0, d) \\\n  __asm__ (\"! Inlined udiv_qrnnd\\n\"\t\t\t\t\t\\\n\"\twr\t%%g0,%2,%%y\t! Not a delayed write for sparclite\\n\"\t\\\n\"\ttst\t%%g0\\n\"\t\t\t\t\t\t\t\\\n\"\tdivscc\t%3,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tdivscc\t%%g1,%4,%0\\n\"\t\t\t\t\t\t\\\n\"\trd\t%%y,%1\\n\"\t\t\t\t\t\t\\\n\"\tbl,a 1f\\n\"\t\t\t\t\t\t\t\\\n\"\tadd\t%1,%4,%1\\n\"\t\t\t\t\t\t\\\n\"1:\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (q)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (n1)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (n0)),\t\t\t\t\t\\\n\t     \"rI\" ((USItype) (d))\t\t\t\t\t\\\n\t   : \"g1\" __AND_CLOBBER_CC)\n#define UDIV_TIME 37\n#define count_leading_zeros(count, x) \\\n  do {                                                                  \\\n  __asm__ (\"scan %1,1,%0\"                                               \\\n           : \"=r\" ((USItype) (count))                                   \\\n           : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n  } while (0)\n/* Early sparclites return 63 for an argument of 0, but they warn that future\n   implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0\n   undefined.  */\n#else\n/* SPARC without integer multiplication and divide instructions.\n   (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */\n#define umul_ppmm(w1, w0, u, v) \\\n  __asm__ (\"! Inlined umul_ppmm\\n\"\t\t\t\t\t\\\n\"\twr\t%%g0,%2,%%y\t! SPARC has 0-3 delay insn after a wr\\n\"\\\n\"\tsra\t%3,31,%%o5\t! Don't move this insn\\n\"\t\t\\\n\"\tand\t%2,%%o5,%%o5\t! Don't move this insn\\n\"\t\t\\\n\"\tandcc\t%%g0,0,%%g1\t! Don't move this insn\\n\"\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,%3,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tmulscc\t%%g1,0,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tadd\t%%g1,%%o5,%0\\n\"\t\t\t\t\t\t\\\n\"\trd\t%%y,%1\"\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n\t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n\t   : \"%rI\" ((USItype) (u)),\t\t\t\t\t\\\n\t     \"r\" ((USItype) (v))\t\t\t\t\t\t\\\n\t   : \"g1\", \"o5\" __AND_CLOBBER_CC)\n#define UMUL_TIME 39\t\t/* 39 instructions */\n/* It's quite necessary to add this much assembler for the sparc.\n   The default udiv_qrnnd (in C) is more than 10 times slower!  */\n#define udiv_qrnnd(__q, __r, __n1, __n0, __d) \\\n  __asm__ (\"! Inlined udiv_qrnnd\\n\"\t\t\t\t\t\\\n\"\tmov\t32,%%g1\\n\"\t\t\t\t\t\t\\\n\"\tsubcc\t%1,%2,%%g0\\n\"\t\t\t\t\t\t\\\n\"1:\tbcs\t5f\\n\"\t\t\t\t\t\t\t\\\n\"\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\\n\"\t\\\n\"\tsub\t%1,%2,%1\t! this kills msb of n\\n\"\t\t\\\n\"\taddx\t%1,%1,%1\t! so this can't give carry\\n\"\t\t\\\n\"\tsubcc\t%%g1,1,%%g1\\n\"\t\t\t\t\t\t\\\n\"2:\tbne\t1b\\n\"\t\t\t\t\t\t\t\\\n\"\t subcc\t%1,%2,%%g0\\n\"\t\t\t\t\t\t\\\n\"\tbcs\t3f\\n\"\t\t\t\t\t\t\t\\\n\"\t addxcc %0,%0,%0\t! shift n1n0 and a q-bit in lsb\\n\"\t\\\n\"\tb\t3f\\n\"\t\t\t\t\t\t\t\\\n\"\t sub\t%1,%2,%1\t! this kills msb of n\\n\"\t\t\\\n\"4:\tsub\t%1,%2,%1\\n\"\t\t\t\t\t\t\\\n\"5:\taddxcc\t%1,%1,%1\\n\"\t\t\t\t\t\t\\\n\"\tbcc\t2b\\n\"\t\t\t\t\t\t\t\\\n\"\t subcc\t%%g1,1,%%g1\\n\"\t\t\t\t\t\t\\\n\"! Got carry from n.  Subtract next step to cancel this carry.\\n\"\t\\\n\"\tbne\t4b\\n\"\t\t\t\t\t\t\t\\\n\"\t addcc\t%0,%0,%0\t! shift n1n0 and a 0-bit in lsb\\n\"\t\\\n\"\tsub\t%1,%2,%1\\n\"\t\t\t\t\t\t\\\n\"3:\txnor\t%0,0,%0\\n\"\t\t\t\t\t\t\\\n\"\t! End of inline udiv_qrnnd\"\t\t\t\t\t\\\n\t   : \"=&r\" ((USItype) (__q)),\t\t\t\t\t\\\n\t     \"=&r\" ((USItype) (__r))\t\t\t\t\t\\\n\t   : \"r\" ((USItype) (__d)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (__n1)),\t\t\t\t\t\\\n\t     \"0\" ((USItype) (__n0)) : \"g1\" __AND_CLOBBER_CC)\n#define UDIV_TIME (3+7*32)\t/* 7 instructions/iteration. 32 iterations.  */\n#endif /* __sparclite__ */\n#endif /* __sparc_v8__ */\n#endif /* sparc32 */\n\n#if ((defined (__sparc__) && defined (__arch64__)) || defined (__sparcv9)) \\\n    && W_TYPE_SIZE == 64\n#define add_ssaaaa(sh, sl, ah, al, bh, bl)\t\t\t\t\\\n  __asm__ (\"addcc %r4,%5,%1\\n\\t\"\t\t\t\t\t\\\n   \t   \"add %r2,%3,%0\\n\\t\"\t\t\t\t\t\t\\\n   \t   \"bcs,a,pn %%xcc, 1f\\n\\t\"\t\t\t\t\t\\\n   \t   \"add %0, 1, %0\\n\"\t\t\t\t\t\t\\\n\t   \"1:\"\t\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n\t   : \"%rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n\t     \"%rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n\t   __CLOBBER_CC)\n\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \t\t\t\t\\\n  __asm__ (\"subcc %r4,%5,%1\\n\\t\"\t\t\t\t\t\\\n   \t   \"sub %r2,%3,%0\\n\\t\"\t\t\t\t\t\t\\\n   \t   \"bcs,a,pn %%xcc, 1f\\n\\t\"\t\t\t\t\t\\\n   \t   \"sub %0, 1, %0\\n\\t\"\t\t\t\t\t\t\\\n\t   \"1:\"\t\t\t\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n\t   : \"rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n\t     \"rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n\t   __CLOBBER_CC)\n\n#define umul_ppmm(wh, wl, u, v)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n\t  UDItype tmp1, tmp2, tmp3, tmp4;\t\t\t\t\\\n\t  __asm__ __volatile__ (\t\t\t\t\t\\\n\t\t   \"srl %7,0,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %3,%6,%1\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %6,32,%2\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %2,%3,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sllx %4,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srl %6,0,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sub %1,%5,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %5,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"addcc %4,%5,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %7,32,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %3,%5,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"mulx %2,%5,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sethi %%hi(0x80000000),%2\\n\\t\"\t\t\t\\\n\t\t   \"addcc %4,%3,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"srlx %4,32,%4\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %2,%2,%2\\n\\t\"\t\t\t\t\t\\\n\t\t   \"movcc %%xcc,%%g0,%2\\n\\t\"\t\t\t\t\\\n\t\t   \"addcc %5,%4,%5\\n\\t\"\t\t\t\t\t\\\n\t\t   \"sllx %3,32,%3\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %1,%3,%1\\n\\t\"\t\t\t\t\t\\\n\t\t   \"add %5,%2,%0\"\t\t\t\t\t\\\n\t   : \"=r\" ((UDItype)(wh)),\t\t\t\t\t\\\n\t     \"=&r\" ((UDItype)(wl)),\t\t\t\t\t\\\n\t     \"=&r\" (tmp1), \"=&r\" (tmp2), \"=&r\" (tmp3), \"=&r\" (tmp4)\t\\\n\t   : \"r\" ((UDItype)(u)),\t\t\t\t\t\\\n\t     \"r\" ((UDItype)(v))\t\t\t\t\t\t\\\n\t   __CLOBBER_CC);\t\t\t\t\t\t\\\n  } while (0)\n#define UMUL_TIME 96\n#define UDIV_TIME 230\n#endif /* sparc64 */\n\n#if defined (__vax__) && W_TYPE_SIZE == 32\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"addl2 %5,%1\\n\\tadwc %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"%0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"%1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"subl2 %5,%1\\n\\tsbwc %3,%0\"\t\t\t\t\t\\\n\t   : \"=g\" ((USItype) (sh)),\t\t\t\t\t\\\n\t     \"=&g\" ((USItype) (sl))\t\t\t\t\t\\\n\t   : \"0\" ((USItype) (ah)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bh)),\t\t\t\t\t\\\n\t     \"1\" ((USItype) (al)),\t\t\t\t\t\\\n\t     \"g\" ((USItype) (bl)))\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {\t\t\t\t\t\t\t\t\\\n\tUDItype __ll;\t\t\t\t\t\t\t\\\n\tstruct {USItype __l, __h;} __i;\t\t\t\t\t\\\n      } __xx;\t\t\t\t\t\t\t\t\\\n    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n    __asm__ (\"emul %1,%2,$0,%0\"\t\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n\t     : \"g\" (__m0),\t\t\t\t\t\t\\\n\t       \"g\" (__m1));\t\t\t\t\t\t\\\n    (xh) = __xx.__i.__h;\t\t\t\t\t\t\\\n    (xl) = __xx.__i.__l;\t\t\t\t\t\t\\\n    (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n  } while (0)\n#define sdiv_qrnnd(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {DItype __ll;\t\t\t\t\t\t\t\\\n\t   struct {SItype __l, __h;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    __xx.__i.__h = n1; __xx.__i.__l = n0;\t\t\t\t\\\n    __asm__ (\"ediv %3,%2,%0,%1\"\t\t\t\t\t\t\\\n\t     : \"=g\" (q), \"=g\" (r)\t\t\t\t\t\\\n\t     : \"g\" (__xx.__ll), \"g\" (d));\t\t\t\t\\\n  } while (0)\n#endif /* __vax__ */\n\n#if defined (__z8000__) && W_TYPE_SIZE == 16\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"add\t%H1,%H5\\n\\tadc\t%H0,%H3\"\t\t\t\t\\\n\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n\t   : \"%0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n\t     \"%1\" ((unsigned int)(al)),\t\t\t\t\t\\\n\t     \"rQR\" ((unsigned int)(bl)))\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  __asm__ (\"sub\t%H1,%H5\\n\\tsbc\t%H0,%H3\"\t\t\t\t\\\n\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n\t   : \"0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n\t     \"1\" ((unsigned int)(al)),\t\t\t\t\t\\\n\t     \"rQR\" ((unsigned int)(bl)))\n#define umul_ppmm(xh, xl, m0, m1) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    union {long int __ll;\t\t\t\t\t\t\\\n\t   struct {unsigned int __h, __l;} __i;\t\t\t\t\\\n\t  } __xx;\t\t\t\t\t\t\t\\\n    unsigned int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n    __asm__ (\"mult\t%S0,%H3\"\t\t\t\t\t\\\n\t     : \"=r\" (__xx.__i.__h),\t\t\t\t\t\\\n\t       \"=r\" (__xx.__i.__l)\t\t\t\t\t\\\n\t     : \"%1\" (__m0),\t\t\t\t\t\t\\\n\t       \"rQR\" (__m1));\t\t\t\t\t\t\\\n    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n    (xh) += ((((signed int) __m0 >> 15) & __m1)\t\t\t\t\\\n\t     + (((signed int) __m1 >> 15) & __m0));\t\t\t\\\n  } while (0)\n#endif /* __z8000__ */\n\n#endif /* __GNUC__ */\n\n/* If this machine has no inline assembler, use C macros.  */\n\n#if !defined (add_ssaaaa)\n#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x;\t\t\t\t\t\t\t\t\\\n    __x = (al) + (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) + (bh) + (__x < (al));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n#if !defined (sub_ddmmss)\n#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x;\t\t\t\t\t\t\t\t\\\n    __x = (al) - (bl);\t\t\t\t\t\t\t\\\n    (sh) = (ah) - (bh) - (__x > (al));\t\t\t\t\t\\\n    (sl) = __x;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n/* If we lack umul_ppmm but have smul_ppmm, define umul_ppmm in terms of\n   smul_ppmm.  */\n#if !defined (umul_ppmm) && defined (smul_ppmm)\n#define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __w1;\t\t\t\t\t\t\t\\\n    UWtype __xm0 = (u), __xm1 = (v);\t\t\t\t\t\\\n    smul_ppmm (__w1, w0, __xm0, __xm1);\t\t\t\t\t\\\n    (w1) = __w1 + (-(__xm0 >> (W_TYPE_SIZE - 1)) & __xm1)\t\t\\\n\t\t+ (-(__xm1 >> (W_TYPE_SIZE - 1)) & __xm0);\t\t\\\n  } while (0)\n#endif\n\n/* If we still don't have umul_ppmm, define it using plain C.  */\n#if !defined (umul_ppmm)\n#define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __x0, __x1, __x2, __x3;\t\t\t\t\t\\\n    UHWtype __ul, __vl, __uh, __vh;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __ul = __ll_lowpart (u);\t\t\t\t\t\t\\\n    __uh = __ll_highpart (u);\t\t\t\t\t\t\\\n    __vl = __ll_lowpart (v);\t\t\t\t\t\t\\\n    __vh = __ll_highpart (v);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __x0 = (UWtype) __ul * __vl;\t\t\t\t\t\\\n    __x1 = (UWtype) __ul * __vh;\t\t\t\t\t\\\n    __x2 = (UWtype) __uh * __vl;\t\t\t\t\t\\\n    __x3 = (UWtype) __uh * __vh;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __x1 += __ll_highpart (__x0);/* this can't give carry */\t\t\\\n    __x1 += __x2;\t\t/* but this indeed can */\t\t\\\n    if (__x1 < __x2)\t\t/* did we get it? */\t\t\t\\\n      __x3 += __ll_B;\t\t/* yes, add it in the proper pos.  */\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (w1) = __x3 + __ll_highpart (__x1);\t\t\t\t\t\\\n    (w0) = __ll_lowpart (__x1) * __ll_B + __ll_lowpart (__x0);\t\t\\\n  } while (0)\n#endif\n\n#if !defined (__umulsidi3)\n#define __umulsidi3(u, v) \\\n  ({DWunion __w;\t\t\t\t\t\t\t\\\n    umul_ppmm (__w.s.high, __w.s.low, u, v);\t\t\t\t\\\n    __w.ll; })\n#endif\n\n/* Define this unconditionally, so it can be used for debugging.  */\n#define __udiv_qrnnd_c(q, r, n1, n0, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __d1, __d0, __q1, __q0;\t\t\t\t\t\\\n    UWtype __r1, __r0, __m;\t\t\t\t\t\t\\\n    __d1 = __ll_highpart (d);\t\t\t\t\t\t\\\n    __d0 = __ll_lowpart (d);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __r1 = (n1) % __d1;\t\t\t\t\t\t\t\\\n    __q1 = (n1) / __d1;\t\t\t\t\t\t\t\\\n    __m = (UWtype) __q1 * __d0;\t\t\t\t\t\t\\\n    __r1 = __r1 * __ll_B | __ll_highpart (n0);\t\t\t\t\\\n    if (__r1 < __m)\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__q1--, __r1 += (d);\t\t\t\t\t\t\\\n\tif (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\\\n\t  if (__r1 < __m)\t\t\t\t\t\t\\\n\t    __q1--, __r1 += (d);\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    __r1 -= __m;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    __r0 = __r1 % __d1;\t\t\t\t\t\t\t\\\n    __q0 = __r1 / __d1;\t\t\t\t\t\t\t\\\n    __m = (UWtype) __q0 * __d0;\t\t\t\t\t\t\\\n    __r0 = __r0 * __ll_B | __ll_lowpart (n0);\t\t\t\t\\\n    if (__r0 < __m)\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__q0--, __r0 += (d);\t\t\t\t\t\t\\\n\tif (__r0 >= (d))\t\t\t\t\t\t\\\n\t  if (__r0 < __m)\t\t\t\t\t\t\\\n\t    __q0--, __r0 += (d);\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    __r0 -= __m;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (q) = (UWtype) __q1 * __ll_B | __q0;\t\t\t\t\\\n    (r) = __r0;\t\t\t\t\t\t\t\t\\\n  } while (0)\n\n/* If the processor has no udiv_qrnnd but sdiv_qrnnd, go through\n   __udiv_w_sdiv (defined in libgcc or elsewhere).  */\n#if !defined (udiv_qrnnd) && defined (sdiv_qrnnd)\n#define udiv_qrnnd(q, r, nh, nl, d) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    USItype __r;\t\t\t\t\t\t\t\\\n    (q) = __udiv_w_sdiv (&__r, nh, nl, d);\t\t\t\t\\\n    (r) = __r;\t\t\t\t\t\t\t\t\\\n  } while (0)\n#endif\n\n/* If udiv_qrnnd was not defined for this processor, use __udiv_qrnnd_c.  */\n#if !defined (udiv_qrnnd)\n#define UDIV_NEEDS_NORMALIZATION 1\n#define udiv_qrnnd __udiv_qrnnd_c\n#endif\n\n#if !defined (count_leading_zeros)\nextern const UQItype __clz_tab\u00dd\u00a8 ATTRIBUTE_HIDDEN;\n#define count_leading_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __xr = (x);\t\t\t\t\t\t\t\\\n    UWtype __a;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    if (W_TYPE_SIZE <= 32)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\t__a = __xr < ((UWtype)1<<2*__BITS4)\t\t\t\t\\\n\t  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)\t\t\t\\\n\t  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n    else\t\t\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n\tfor (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)\t\t\t\\\n\t  if (((__xr >> __a) & 0xff) != 0)\t\t\t\t\\\n\t    break;\t\t\t\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    (count) = W_TYPE_SIZE - (__clz_tab\u00dd__xr >> __a\u00a8 + __a);\t\t\\\n  } while (0)\n#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE\n#endif\n\n#if !defined (count_trailing_zeros)\n/* Define count_trailing_zeros using count_leading_zeros.  The latter might be\n   defined in asm, but if it is not, the C version above is good enough.  */\n#define count_trailing_zeros(count, x) \\\n  do {\t\t\t\t\t\t\t\t\t\\\n    UWtype __ctz_x = (x);\t\t\t\t\t\t\\\n    UWtype __ctz_c;\t\t\t\t\t\t\t\\\n    count_leading_zeros (__ctz_c, __ctz_x & -__ctz_x);\t\t\t\\\n    (count) = W_TYPE_SIZE - 1 - __ctz_c;\t\t\t\t\\\n  } while (0)\n#endif\n\n#ifndef UDIV_NEEDS_NORMALIZATION\n#define UDIV_NEEDS_NORMALIZATION 0\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOP": {"ttr": 7681, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Loop optimization definitions for GCC\n   Copyright (C) 1991, 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#include \"bitmap.h\"\n#include \"sbitmap.h\"\n#include \"hard-reg-set.h\"\n#include \"basic-block.h\"\n\n/* Flags passed to loop_optimize.  */\n#define LOOP_UNROLL 1\n#define LOOP_BCT 2\n#define LOOP_PREFETCH 4\n#define LOOP_AUTO_UNROLL 8\n\n/* Get the loop info pointer of a loop.  */\n#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n\n/* Get a pointer to the loop movables structure.  */\n#define LOOP_MOVABLES(LOOP) (&LOOP_INFO (LOOP)->movables)\n\n/* Get a pointer to the loop registers structure.  */\n#define LOOP_REGS(LOOP) (&LOOP_INFO (LOOP)->regs)\n\n/* Get a pointer to the loop induction variables structure.  */\n#define LOOP_IVS(LOOP) (&LOOP_INFO (LOOP)->ivs)\n\n/* Get the luid of an insn.  Catch the error of trying to reference the LUID\n   of an insn added during loop, since these don't have LUIDs.  */\n\n#define INSN_LUID(INSN)\t\t\t\\\n  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid\u00ddINSN_UID (INSN)\u00a8 \\\n   : (abort (), -1))\n\n#define REGNO_FIRST_LUID(REGNO)\t\t\t\\\n  (REGNO_FIRST_UID (REGNO) < max_uid_for_loop\t\\\n\t? uid_luid\u00ddREGNO_FIRST_UID (REGNO)\u00a8\t\\\n\t: 0)\n#define REGNO_LAST_LUID(REGNO)\t\t\t\\\n  (REGNO_LAST_UID (REGNO) < max_uid_for_loop\t\\\n\t? uid_luid\u00ddREGNO_LAST_UID (REGNO)\u00a8\t\\\n\t: INT_MAX)\n\n/* A \"basic induction variable\" or biv is a pseudo reg that is set\n   (within this loop) only by incrementing or decrementing it.  */\n/* A \"general induction variable\" or giv is a pseudo reg whose\n   value is a linear function of a biv.  */\n\n/* Bivs are recognized by `basic_induction_var';\n   Givs by `general_induction_var'.  */\n\n/* An enum for the two different types of givs, those that are used\n   as memory addresses and those that are calculated into registers.  */\nenum g_types\n{\n  DEST_ADDR,\n  DEST_REG\n};\n\n\n/* A `struct induction' is created for every instruction that sets\n   an induction variable (either a biv or a giv).  */\n\nstruct induction\n{\n  rtx insn;\t\t\t/* The insn that sets a biv or giv */\n  rtx new_reg;\t\t\t/* New register, containing strength reduced\n\t\t\t\t   version of this giv.  */\n  rtx src_reg;\t\t\t/* Biv from which this giv is computed.\n\t\t\t\t   (If this is a biv, then this is the biv.) */\n  enum g_types giv_type;\t/* Indicate whether DEST_ADDR or DEST_REG */\n  rtx dest_reg;\t\t\t/* Destination register for insn: this is the\n\t\t\t\t   register which was the biv or giv.\n\t\t\t\t   For a biv, this equals src_reg.\n\t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n  rtx *location;\t\t/* Place in the insn where this giv occurs.\n\t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n\t\t\t\t/* For a biv, this is the place where add_val\n\t\t\t\t   was found.  */\n  enum machine_mode mode;\t/* The mode of this biv or giv */\n  rtx mem;\t\t\t/* For DEST_ADDR, the memory object.  */\n  rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n  rtx add_val;\t\t\t/* Additive constant for that product.  */\n  int benefit;\t\t\t/* Gain from eliminating this insn.  */\n  rtx final_value;\t\t/* If the giv is used outside the loop, and its\n\t\t\t\t   final value could be calculated, it is put\n\t\t\t\t   here, and the giv is made replaceable.  Set\n\t\t\t\t   the giv to this value before the loop.  */\n  unsigned combined_with;\t/* The number of givs this giv has been\n\t\t\t\t   combined with.  If nonzero, this giv\n\t\t\t\t   cannot combine with any other giv.  */\n  unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n\t\t\t\t   variable for the original variable.\n\t\t\t\t   0 means they must be kept separate and the\n\t\t\t\t   new one must be copied into the old pseudo\n\t\t\t\t   reg each time the old one is set.  */\n  unsigned not_replaceable : 1;\t/* Used to prevent duplicating work.  This is\n\t\t\t\t   1 if we know that the giv definitely can\n\t\t\t\t   not be made replaceable, in which case we\n\t\t\t\t   don't bother checking the variable again\n\t\t\t\t   even if further info is available.\n\t\t\t\t   Both this and the above can be zero.  */\n  unsigned ignore : 1;\t\t/* 1 prohibits further processing of giv */\n  unsigned always_computable : 1;/* 1 if this value is computable every\n\t\t\t\t    iteration.  */\n  unsigned always_executed : 1; /* 1 if this set occurs each iteration.  */\n  unsigned maybe_multiple : 1;\t/* Only used for a biv and  1 if this biv\n\t\t\t\t   update may be done multiple times per\n\t\t\t\t   iteration.  */\n  unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n\t\t\t\t   another giv.  This occurs in many cases\n\t\t\t\t   where a giv's lifetime spans an update to\n\t\t\t\t   a biv.  */\n  unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n\t\t\t\t   we won't use it to eliminate a biv, it\n\t\t\t\t   would probably lose.  */\n  unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n\t\t\t\t   to it to try to form an auto-inc address.  */\n  unsigned unrolled : 1;\t/* 1 if new register has been allocated and\n\t\t\t\t   initialized in unrolled loop.  */\n  unsigned shared : 1;\n  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const.  */\n  int lifetime;\t\t\t/* Length of life of this giv */\n  rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n\t\t\t\t   subtracted from add_val when this giv\n\t\t\t\t   derives another.  This occurs when the\n\t\t\t\t   giv spans a biv update by incrementation.  */\n  rtx ext_dependent;\t\t/* If nonzero, is a sign or zero extension\n\t\t\t\t   if a biv on which this giv is dependent.  */\n  struct induction *next_iv;\t/* For givs, links together all givs that are\n\t\t\t\t   based on the same biv.  For bivs, links\n\t\t\t\t   together all biv entries that refer to the\n\t\t\t\t   same biv register.  */\n  struct induction *same;\t/* For givs, if the giv has been combined with\n\t\t\t\t   another giv, this points to the base giv.\n\t\t\t\t   The base giv will have COMBINED_WITH nonzero.\n\t\t\t\t   For bivs, if the biv has the same LOCATION\n\t\t\t\t   than another biv, this points to the base\n\t\t\t\t   biv.  */\n  HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n\t\t\t\t   is split, and a constant is eliminated from\n\t\t\t\t   the address, the -constant is stored here\n\t\t\t\t   for later use.  */\n  struct induction *same_insn;\t/* If there are multiple identical givs in\n\t\t\t\t   the same insn, then all but one have this\n\t\t\t\t   field set, and they all point to the giv\n\t\t\t\t   that doesn't have this field set.  */\n  rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n\t\t\t\t   a substitute for the lifetime information.  */\n};\n\n\n/* A `struct iv_class' is created for each biv.  */\n\nstruct iv_class\n{\n  unsigned int regno;\t\t/* Pseudo reg which is the biv.  */\n  int biv_count;\t\t/* Number of insns setting this reg.  */\n  struct induction *biv;\t/* List of all insns that set this reg.  */\n  int giv_count;\t\t/* Number of DEST_REG givs computed from this\n\t\t\t\t   biv.  The resulting count is only used in\n\t\t\t\t   check_dbra_loop.  */\n  struct induction *giv;\t/* List of all insns that compute a giv\n\t\t\t\t   from this reg.  */\n  int total_benefit;\t\t/* Sum of BENEFITs of all those givs.  */\n  rtx initial_value;\t\t/* Value of reg at loop start.  */\n  rtx initial_test;\t\t/* Test performed on BIV before loop.  */\n  rtx final_value;\t\t/* Value of reg at loop end, if known.  */\n  struct iv_class *next;\t/* Links all class structures together.  */\n  rtx init_insn;\t\t/* insn which initializes biv, 0 if none.  */\n  rtx init_set;\t\t\t/* SET of INIT_INSN, if any.  */\n  unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n  unsigned eliminable : 1;\t/* 1 if plausible candidate for\n                                   elimination.  */\n  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for\n                                   this.  */\n  unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n\t\t\t\t   biv controls.  */\n  unsigned all_reduced : 1;\t/* 1 if all givs using this biv have\n                                   been reduced.  */\n};\n\n\n/* Definitions used by the basic induction variable discovery code.  */\nenum iv_mode\n{\n  UNKNOWN_INDUCT,\n  BASIC_INDUCT,\n  NOT_BASIC_INDUCT,\n  GENERAL_INDUCT\n};\n\n\n/* A `struct iv' is created for every register.  */\n\nstruct iv\n{\n  enum iv_mode type;\n  union\n  {\n    struct iv_class *class;\n    struct induction *info;\n  } iv;\n};\n\n\n#define REG_IV_TYPE(ivs, n) ivs->regs\u00ddn\u00a8.type\n#define REG_IV_INFO(ivs, n) ivs->regs\u00ddn\u00a8.iv.info\n#define REG_IV_CLASS(ivs, n) ivs->regs\u00ddn\u00a8.iv.class\n\n\nstruct loop_ivs\n{\n  /* Indexed by register number, contains pointer to `struct\n     iv' if register is an induction variable.  */\n  struct iv *regs;\n\n  /* Size of regs array.  */\n  unsigned int n_regs;\n\n  /* The head of a list which links together (via the next field)\n     every iv class for the current loop.  */\n  struct iv_class *list;\n};\n\n\ntypedef struct loop_mem_info\n{\n  rtx mem;      /* The MEM itself.  */\n  rtx reg;      /* Corresponding pseudo, if any.  */\n  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n} loop_mem_info;\n\n\n\nstruct loop_reg\n{\n  /* Number of times the reg is set during the loop being scanned.\n     During code motion, a negative value indicates a reg that has\n     been made a candidate; in particular -2 means that it is an\n     candidate that we know is equal to a constant and -1 means that\n     it is a candidate not known equal to a constant.  After code\n     motion, regs moved have 0 (which is accurate now) while the\n     failed candidates have the original number of times set.\n\n     Therefore, at all times, == 0 indicates an invariant register;\n     < 0 a conditionally invariant one.  */\n  int set_in_loop;\n\n  /* Original value of set_in_loop; same except that this value\n     is not set negative for a reg whose sets have been made candidates\n     and not set to 0 for a reg that is moved.  */\n  int n_times_set;\n\n  /* Contains the insn in which a register was used if it was used\n     exactly once; contains const0_rtx if it was used more than once.  */\n  rtx single_usage;\n\n  /* Nonzero indicates that the register cannot be moved or strength\n     reduced.  */\n  char may_not_optimize;\n\n  /* Nonzero means reg N has already been moved out of one loop.\n     This reduces the desire to move it out of another.  */\n  char moved_once;\n};\n\n\nstruct loop_regs\n{\n  int num;\t\t\t/* Number of regs used in table.  */\n  int size;\t\t\t/* Size of table.  */\n  struct loop_reg *array;\t/* Register usage info. array.  */\n  int multiple_uses;\t\t/* Nonzero if a reg has multiple uses.  */\n};\n\n\n\nstruct loop_movables\n{\n  /* Head of movable chain.  */\n  struct movable *head;\n  /* Last movable in chain.  */\n  struct movable *last;\n};\n\n\n/* Information pertaining to a loop.  */\n\nstruct loop_info\n{\n  /* Nonzero if there is a subroutine call in the current loop.  */\n  int has_call;\n  /* Nonzero if there is a libcall in the current loop.  */\n  int has_libcall;\n  /* Nonzero if there is a non constant call in the current loop.  */\n  int has_nonconst_call;\n  /* Nonzero if there is a prefetch instruction in the current loop.  */\n  int has_prefetch;\n  /* Nonzero if there is a volatile memory reference in the current\n     loop.  */\n  int has_volatile;\n  /* Nonzero if there is a tablejump in the current loop.  */\n  int has_tablejump;\n  /* Nonzero if there are ways to leave the loop other than falling\n     off the end.  */\n  int has_multiple_exit_targets;\n  /* Nonzero if there is an indirect jump in the current function.  */\n  int has_indirect_jump;\n  /* Whether loop unrolling has emitted copies of the loop body so\n     that the main loop needs no exit tests.  */\n  int preconditioned;\n  /* Register or constant initial loop value.  */\n  rtx initial_value;\n  /* Register or constant value used for comparison test.  */\n  rtx comparison_value;\n  /* Register or constant approximate final value.  */\n  rtx final_value;\n  /* Register or constant initial loop value with term common to\n     final_value removed.  */\n  rtx initial_equiv_value;\n  /* Register or constant final loop value with term common to\n     initial_value removed.  */\n  rtx final_equiv_value;\n  /* Register corresponding to iteration variable.  */\n  rtx iteration_var;\n  /* Constant loop increment.  */\n  rtx increment;\n  enum rtx_code comparison_code;\n  /* Holds the number of loop iterations.  It is zero if the number\n     could not be calculated.  Must be unsigned since the number of\n     iterations can be as high as 2\u00acwordsize - 1.  For loops with a\n     wider iterator, this number will be zero if the number of loop\n     iterations is too large for an unsigned integer to hold.  */\n  unsigned HOST_WIDE_INT n_iterations;\n  /* The number of times the loop body was unrolled.  */\n  unsigned int unroll_number;\n  int used_count_register;\n  /* The loop iterator induction variable.  */\n  struct iv_class *iv;\n  /* List of MEMs that are stored in this loop.  */\n  rtx store_mems;\n  /* Array of MEMs that are used (read or written) in this loop, but\n     cannot be aliased by anything in this loop, except perhaps\n     themselves.  In other words, if mems\u00ddi\u00a8 is altered during\n     the loop, it is altered by an expression that is rtx_equal_p to\n     it.  */\n  loop_mem_info *mems;\n  /* The index of the next available slot in MEMS.  */\n  int mems_idx;\n  /* The number of elements allocated in MEMS.  */\n  int mems_allocated;\n  /* Nonzero if we don't know what MEMs were changed in the current\n     loop.  This happens if the loop contains a call (in which case\n     `has_call' will also be set) or if we store into more than\n     NUM_STORES MEMs.  */\n  int unknown_address_altered;\n  /* The above doesn't count any readonly memory locations that are\n     stored.  This does.  */\n  int unknown_constant_address_altered;\n  /* Count of memory write instructions discovered in the loop.  */\n  int num_mem_sets;\n  /* The insn where the first of these was found.  */\n  rtx first_loop_store_insn;\n  /* The chain of movable insns in loop.  */\n  struct loop_movables movables;\n  /* The registers used the in loop.  */\n  struct loop_regs regs;\n  /* The induction variable information in loop.  */\n  struct loop_ivs ivs;\n  /* Nonzero if call is in pre_header extended basic block.  */\n  int pre_header_has_call;\n};\n\n\n/* Variables declared in loop.c, but also needed in unroll.c.  */\n\nextern int *uid_luid;\nextern int max_uid_for_loop;\nextern unsigned int max_reg_before_loop;\nextern struct loop **uid_loop;\nextern FILE *loop_dump_stream;\n\n\n/* Forward declarations for non-static functions declared in loop.c and\n   unroll.c.  */\nextern int loop_invariant_p (const struct loop *, rtx);\nextern rtx get_condition_for_loop (const struct loop *, rtx);\nextern void loop_iv_add_mult_hoist (const struct loop *, rtx, rtx, rtx, rtx);\nextern void loop_iv_add_mult_sink (const struct loop *, rtx, rtx, rtx, rtx);\nextern void loop_iv_add_mult_emit_before (const struct loop *, rtx, rtx,\n\t\t\t\t\t  rtx, rtx, basic_block, rtx);\nextern rtx express_from (struct induction *, struct induction *);\nextern rtx extend_value_for_giv (struct induction *, rtx);\n\nextern void unroll_loop (struct loop *, int, int);\nextern rtx biv_total_increment (const struct iv_class *);\nextern unsigned HOST_WIDE_INT loop_iterations (struct loop *);\nextern int precondition_loop_p (const struct loop *, rtx *, rtx *, rtx *,\n\t\t\t\tenum machine_mode *mode);\nextern rtx final_biv_value (const struct loop *, struct iv_class *);\nextern rtx final_giv_value (const struct loop *, struct induction *);\nextern void emit_unrolled_add (rtx, rtx, rtx);\nextern int back_branch_in_range_p (const struct loop *, rtx);\n\nextern int loop_insn_first_p (rtx, rtx);\ntypedef rtx (*loop_insn_callback) (struct loop *, rtx, int, int);\nextern void for_each_insn_in_loop (struct loop *, loop_insn_callback);\nextern rtx loop_insn_emit_before (const struct loop *, basic_block, rtx, rtx);\nextern rtx loop_insn_sink (const struct loop *, rtx);\nextern rtx loop_insn_hoist (const struct loop *, rtx);\n\n/* Forward declarations for non-static functions declared in doloop.c.  */\nextern rtx doloop_condition_get (rtx);\nextern int doloop_optimize (const struct loop *);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACHMODD": {"ttr": 7685, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   machine modes used in the GNU compiler.\n   Copyright (C) 1987, 1992, 1994, 1997, 1998, 2000, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* This file defines all the MACHINE MODES used by GCC.\n\n   A machine mode specifies a size and format of data\n   at the machine level.\n\n   Each RTL expression has a machine mode.\n\n   At the syntax tree level, each ..._TYPE and each ..._DECL node\n   has a machine mode which describes data of that type or the\n   data of the variable declared.  */\n\n/* This file is included by the genmodes program.  Its text is the\n   body of a function.  Do not rely on this, it will change in the\n   future.\n\n   The following statements can be used in this file -- all have\n   the form of a C macro call.  In their arguments:\n\n   A CLASS argument must be one of the constants defined in\n   mode-classes.def, less the leading MODE_ prefix; some statements\n   that take CLASS arguments have restructions on which classes are\n   acceptable.  For instance, INT.\n\n   A MODE argument must be the printable name of a machine mode,\n   without quotation marks or trailing \"mode\".  For instance, SI.\n\n   A PRECISION, BYTESIZE, or COUNT argument must be a positive integer\n   constant.\n\n   A FORMAT argument must be one of the real_mode_format structures\n   declared in real.h, or else a literal 0.  Do not put a leading &\n   on the argument.\n\n   An EXPR argument must be a syntactically valid C expression.\n   If an EXPR contains commas, you may need to write an extra pair of\n   parentheses around it, so it appears to be a single argument to the\n   statement.\n\n   This file defines only those modes which are of use on almost all\n   machines.  Other modes can be defined in the target-specific\n   mode definition file, config/ARCH/ARCH-modes.def.\n\n   Order matters in this file in so far as statements which refer to\n   other modes must appear after the modes they refer to.  However,\n   statements which do not refer to other modes may appear in any\n   order.\n\n     RANDOM_MODE (MODE);\n        declares MODE to be of class RANDOM.\n\n     CC_MODE (MODE);\n        declares MODE to be of class CC.\n\n     INT_MODE (MODE, BYTESIZE);\n        declares MODE to be of class INT and BYTESIZE bytes wide.\n\tAll of the bits of its representation are significant.\n\n     FRACTIONAL_INT_MODE (MODE, PRECISION, BYTESIZE);\n        declares MODE to be of class INT, BYTESIZE bytes wide in\n\tstorage, but with only PRECISION significant bits.\n\n     FLOAT_MODE (MODE, BYTESIZE, FORMAT);\n        declares MODE to be of class FLOAT and BYTESIZE bytes wide,\n\tusing floating point format FORMAT.\n\tAll of the bits of its representation are significant.\n\n     FRACTIONAL_FLOAT_MODE (MODE, PRECISION, BYTESIZE, FORMAT);\n        declares MODE to be of class FLOAT, BYTESIZE bytes wide in\n\tstorage, but with only PRECISION significant bits, using\n\tfloating point format FORMAT.\n\n     RESET_FLOAT_FORMAT (MODE, FORMAT);\n\tchanges the format of MODE, which must be class FLOAT,\n\tto FORMAT.  Use in an ARCH-modes.def to reset the format\n\tof one of the float modes defined in this file.\n\n     PARTIAL_INT_MODE (MODE);\n        declares a mode of class PARTIAL_INT with the same size as\n\tMODE (which must be an INT mode).  The name of the new mode\n\tis made by prefixing a P to the name MODE.  This statement\n\tmay grow a PRECISION argument in the future.\n\n     VECTOR_MODE (CLASS, MODE, COUNT);\n        Declare a vector mode whose component mode is MODE (of class\n\tCLASS) with COUNT components.  CLASS must be INT or FLOAT.\n\tThe name of the vector mode takes the form VnX where n is\n\tCOUNT in decimal and X is MODE.\n\n     VECTOR_MODES (CLASS, WIDTH);\n        For all modes presently declared in class CLASS, construct\n\tcorresponding vector modes having width WIDTH.  Modes whose\n\tbyte sizes do not evenly divide WIDTH are ignored, as are\n\tmodes that would produce vector modes with only one component,\n\tand modes smaller than one byte (if CLASS is INT) or smaller\n\tthan two bytes (if CLASS is FLOAT).  CLASS must be INT or\n\tFLOAT.  The names follow the same rule as VECTOR_MODE uses.\n\n     COMPLEX_MODES (CLASS);\n        For all modes presently declared in class CLASS, construct\n\tcorresponding complex modes.  Modes smaller than one byte\n\tare ignored.  For FLOAT modes, the names are derived by\n\treplacing the 'F' in the mode name with a 'C'.  (It is an\n\terror if there is no 'F'.  For INT modes, the names are\n\tderived by prefixing a C to the name.\n\n     ADJUST_BYTESIZE (MODE, EXPR);\n     ADJUST_ALIGNMENT (MODE, EXPR);\n     ADJUST_FLOAT_FORMAT (MODE, EXPR);\n        Arrange for the byte size, alignment, or floating point format\n\tof MODE to be adjustable at run time.  EXPR will be executed\n\tonce after processing all command line options, and should\n\tevaluate to the desired byte size, alignment, or format.\n\n\tUnlike a FORMAT argument, if you are adjusting a float format\n\tyou must put an & in front of the name of each format structure.\n\n   Note: If a mode is ever made which is more than 255 bytes wide,\n   machmode.h and genmodes.c will have to be changed to allocate\n   more space for the mode_size and mode_alignment arrays.  */\n\n/* VOIDmode is used when no mode needs to be specified,\n   as for example on CONST_INT RTL expressions.  */\nRANDOM_MODE (VOID);\n\n/* BLKmode is used for structures, arrays, etc.\n   that fit no more specific mode.  */\nRANDOM_MODE (BLK);\n\n/* Single bit mode used for booleans.  */\nFRACTIONAL_INT_MODE (BI, 1, 1);\n\n/* Basic integer modes.  We go up to TI in generic code (128 bits).\n   The name OI is reserved for a 256-bit type (needed by some back ends).\n   FIXME TI shouldn't be generically available either.  */\nINT_MODE (QI, 1);\nINT_MODE (HI, 2);\nINT_MODE (SI, 4);\nINT_MODE (DI, 8);\nINT_MODE (TI, 16);\n\n/* No partial integer modes are defined by default.  */\n\n/* Basic floating point modes.  SF and DF are the only modes provided\n   by default.  The names QF, HF, XF, and TF are reserved for targets\n   that need 1-word, 2-word, 80-bit, or 128-bit float types respectively.\n\n   These are the IEEE mappings.  They can be overridden with\n   RESET_FLOAT_FORMAT or at runtime (in OVERRIDE_OPTIONS).  */\n\nFLOAT_MODE (SF, 4, ieee_single_format);\nFLOAT_MODE (DF, 8, ieee_double_format);\n\n/* Basic CC modes.\n   FIXME define this only for targets that need it.  */\nCC_MODE (CC);\n\n/* Allow the target to specify additional modes of various kinds.  */\n#if HAVE_EXTRA_MODES\n# include EXTRA_MODES_FILE\n#endif\n\n/* Complex modes.  */\nCOMPLEX_MODES (INT);\nCOMPLEX_MODES (FLOAT);\n\n/* Vector modes.  */\nVECTOR_MODES (INT, 2);        /*                 V2QI */\nVECTOR_MODES (INT, 4);        /*            V4QI V2HI */\nVECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\nVECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n/* VECTOR_MODES (INT, 32);             V8SI V4DI      */\n/* VECTOR_MODES (INT, 64);             V8DI           */\n\nVECTOR_MODE (INT, SI, 8)\nVECTOR_MODE (INT, DI, 4);\nVECTOR_MODE (INT, DI, 8);\n\n/* PPC uses this to distinguish between DImode passed in\n   float registers and DImode passed in vector registers.\n   It would be in rs6000-modes.def but it's referenced in\n   c-common.c.  FIXME.  */\n\nVECTOR_MODE (INT, DI, 1);\n\nVECTOR_MODES (FLOAT, 4);      /*                 V2HF */\nVECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\nVECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */\n/* VECTOR_MODES (FLOAT, 32);           V8SF V4DF      */\n/* VECTOR_MODES (FLOAT, 64);     V16SF V8DF           */\n\nVECTOR_MODE (FLOAT, SF, 8);\nVECTOR_MODE (FLOAT, SF, 16);\nVECTOR_MODE (FLOAT, DF, 4);\nVECTOR_MODE (FLOAT, DF, 8);\n\n/* The symbol Pmode stands for one of the above machine modes (usually SImode).\n   The tm.h file specifies which one.  It is not a distinct mode.  */\n\n/*\nLocal variables:\nmode:c\nversion-control: t\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACHMODE": {"ttr": 7688, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Machine mode definitions for GCC; included by rtl.h and tree.h.\n   Copyright (C) 1991, 1993, 1994, 1996, 1998, 1999, 2000, 2001, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef HAVE_MACHINE_MODES\n#define HAVE_MACHINE_MODES\n\n/* Make an enum class that gives all the machine modes.  */\n#include \"insn-modes.h\"\n\n/* Get the name of mode MODE as a string.  */\n\nextern const char * const mode_name\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_NAME(MODE)  mode_name\u00ddMODE\u00a8\n\n/* Mode classes.  */\n\n#include \"mode-classes.def\"\n#define DEF_MODE_CLASS(M) M\nenum mode_class { MODE_CLASSES, MAX_MODE_CLASS };\n#undef DEF_MODE_CLASS\n#undef MODE_CLASSES\n\n/* Get the general kind of object that mode MODE represents\n   (integer, floating, complex, etc.)  */\n\nextern const unsigned char mode_class\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_CLASS(MODE)  mode_class\u00ddMODE\u00a8\n\n/* Nonzero if MODE is an integral mode.  */\n#define INTEGRAL_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT \\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT \\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_INT)\n\n/* Nonzero if MODE is a floating-point mode.  */\n#define FLOAT_MODE_P(MODE)\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n\n/* Nonzero if MODE is a complex mode.  */\n#define COMPLEX_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n\n/* Nonzero if MODE is a vector mode.  */\n#define VECTOR_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n\n/* Nonzero if MODE is a scalar integral mode.  */\n#define SCALAR_INT_MODE_P(MODE)\t\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT)\n\n/* Nonzero if MODE is a scalar floating point mode.  */\n#define SCALAR_FLOAT_MODE_P(MODE)\t\t\\\n  (GET_MODE_CLASS (MODE) == MODE_FLOAT)\n\n/* Get the size in bytes and bits of an object of mode MODE.  */\n\nextern CONST_MODE_SIZE unsigned char mode_size\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_SIZE(MODE)    ((unsigned short) mode_size\u00ddMODE\u00a8)\n#define GET_MODE_BITSIZE(MODE) ((unsigned short) (GET_MODE_SIZE (MODE) * BITS_PER_UNIT))\n\n/* Get the number of value bits of an object of mode MODE.  */\nextern const unsigned short mode_precision\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_PRECISION(MODE)  mode_precision\u00ddMODE\u00a8\n\n/* Get a bitmask containing 1 for all bits in a word\n   that fit within mode MODE.  */\n\nextern const unsigned HOST_WIDE_INT mode_mask_array\u00ddNUM_MACHINE_MODES\u00a8;\n\n#define GET_MODE_MASK(MODE) mode_mask_array\u00ddMODE\u00a8\n\n/* Return the mode of the inner elements in a vector.  */\n\nextern const unsigned char mode_inner\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_INNER(MODE) mode_inner\u00ddMODE\u00a8\n\n/* Get the size in bytes of the basic parts of an object of mode MODE.  */\n\n#define GET_MODE_UNIT_SIZE(MODE)\t\t\\\n  (GET_MODE_INNER (MODE) == VOIDmode\t\t\\\n   ? GET_MODE_SIZE (MODE)\t\t\t\\\n   : GET_MODE_SIZE (GET_MODE_INNER (MODE)))\n\n/* Get the number of units in the object.  */\n\nextern const unsigned char mode_nunits\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_NUNITS(MODE)  mode_nunits\u00ddMODE\u00a8\n\n/* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n\nextern const unsigned char mode_wider\u00ddNUM_MACHINE_MODES\u00a8;\n#define GET_MODE_WIDER_MODE(MODE) mode_wider\u00ddMODE\u00a8\n\n/* Return the mode for data of a given size SIZE and mode class CLASS.\n   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n   The value is BLKmode if no other mode is found.  */\n\nextern enum machine_mode mode_for_size (unsigned int, enum mode_class, int);\n\n/* Similar, but find the smallest mode for a given width.  */\n\nextern enum machine_mode smallest_mode_for_size (unsigned int,\n\t\t\t\t\t\t enum mode_class);\n\n\n/* Return an integer mode of the exact same size as the input mode,\n   or BLKmode on failure.  */\n\nextern enum machine_mode int_mode_for_mode (enum machine_mode);\n\n/* Find the best mode to use to access a bit field.  */\n\nextern enum machine_mode get_best_mode (int, int, unsigned int,\n\t\t\t\t\tenum machine_mode, int);\n\n/* Determine alignment, 1<=result<=BIGGEST_ALIGNMENT.  */\n\nextern CONST_MODE_BASE_ALIGN unsigned char mode_base_align\u00ddNUM_MACHINE_MODES\u00a8;\n\nextern unsigned get_mode_alignment (enum machine_mode);\n\n#define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n\n/* For each class, get the narrowest mode in that class.  */\n\nextern const unsigned char class_narrowest_mode\u00ddMAX_MODE_CLASS\u00a8;\n#define GET_CLASS_NARROWEST_MODE(CLASS) class_narrowest_mode\u00ddCLASS\u00a8\n\n/* Define the integer modes whose sizes are BITS_PER_UNIT and BITS_PER_WORD\n   and the mode whose class is Pmode and whose size is POINTER_SIZE.  */\n\nextern enum machine_mode byte_mode;\nextern enum machine_mode word_mode;\nextern enum machine_mode ptr_mode;\n\n/* Target-dependent machine mode initialization - in insn-modes.c.  */\nextern void init_adjust_machine_modes (void);\n\n#endif /* not HAVE_MACHINE_MODES */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MD5": {"ttr": 7691, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* md5.h - Declaration of functions and data types used for MD5 sum\n   computing library functions.\n   Copyright 1995, 1996, 2000 Free Software Foundation, Inc.\n   NOTE: The canonical source of this file is maintained with the GNU C\n   Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef _MD5_H\n#define _MD5_H 1\n\n#include <stdio.h>\n\n#if defined HAVE_LIMITS_H || _LIBC\n# include <limits.h>\n#endif\n\n#include \"ansidecl.h\"\n\n/* The following contortions are an attempt to use the C preprocessor\n   to determine an unsigned integral type that is 32 bits wide.  An\n   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but\n   doing that would require that the configure script compile and *run*\n   the resulting executable.  Locally running cross-compiled executables\n   is usually not possible.  */\n\n#ifdef _LIBC\n# include <sys/types.h>\ntypedef u_int32_t md5_uint32;\ntypedef uintptr_t md5_uintptr;\n#else\n#  define INT_MAX_32_BITS 21\n\n/* If UINT_MAX isn't defined, assume it's a 32-bit type.\n   This should be valid for all systems GNU cares about because\n   that doesn't include 16-bit systems, and only modern systems\n   (that certainly have <limits.h>) have 64+-bit integral types.  */\n\n# ifndef INT_MAX\n#  define INT_MAX INT_MAX_32_BITS\n# endif\n\n# if INT_MAX == INT_MAX_32_BITS\n   typedef unsigned int md5_uint32;\n# else\n#  if SHRT_MAX == INT_MAX_32_BITS\n    typedef unsigned short md5_uint32;\n#  else\n#   if LONG_MAX == INT_MAX_32_BITS\n     typedef unsigned long md5_uint32;\n#   else\n     /* The following line is intended to evoke an error.\n        Using #error is not portable enough.  */\n     \"Cannot determine unsigned 32-bit data type.\"\n#   endif\n#  endif\n# endif\n/* We have to make a guess about the integer type equivalent in size\n   to pointers which should always be correct.  */\ntypedef unsigned long int md5_uintptr;\n#endif\n\n#undef __P\n#if defined (__STDC__) && __STDC__\n#define\t__P(x) x\n#else\n#define\t__P(x) ()\n#endif\n\n/* Structure to save state of computation between the single steps.  */\nstruct md5_ctx\n{\n  md5_uint32 A;\n  md5_uint32 B;\n  md5_uint32 C;\n  md5_uint32 D;\n\n  md5_uint32 total\u00dd2\u00a8;\n  md5_uint32 buflen;\n  char buffer\u00dd128\u00a8 ATTRIBUTE_ALIGNED_ALIGNOF(md5_uint32);\n};\n\n/*\n * The following three functions are build up the low level used in\n * the functions `md5_stream' and `md5_buffer'.\n */\n\n/* Initialize structure containing state of computation.\n   (RFC 1321, 3.3: Step 3)  */\nextern void md5_init_ctx __P ((struct md5_ctx *ctx));\n\n/* Starting with the result of former calls of this function (or the\n   initialization function update the context for the next LEN bytes\n   starting at BUFFER.\n   It is necessary that LEN is a multiple of 64!!! */\nextern void md5_process_block __P ((const void *buffer, size_t len,\n\t\t\t\t    struct md5_ctx *ctx));\n\n/* Starting with the result of former calls of this function (or the\n   initialization function update the context for the next LEN bytes\n   starting at BUFFER.\n   It is NOT required that LEN is a multiple of 64.  */\nextern void md5_process_bytes __P ((const void *buffer, size_t len,\n\t\t\t\t    struct md5_ctx *ctx));\n\n/* Process the remaining bytes in the buffer and put result from CTX\n   in first 16 bytes following RESBUF.  The result is always in little\n   endian byte order, so that a byte-wise output yields to the wanted\n   ASCII representation of the message digest.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32 bits value.  */\nextern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));\n\n\n/* Put result from CTX in first 16 bytes following RESBUF.  The result is\n   always in little endian byte order, so that a byte-wise output yields\n   to the wanted ASCII representation of the message digest.\n\n   IMPORTANT: On some systems it is required that RESBUF is correctly\n   aligned for a 32 bits value.  */\nextern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));\n\n\n/* Compute MD5 message digest for bytes read from STREAM.  The\n   resulting message digest number will be written into the 16 bytes\n   beginning at RESBLOCK.  */\nextern int md5_stream __P ((FILE *stream, void *resblock));\n\n/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The\n   result is always in little endian byte order, so that a byte-wise\n   output yields to the wanted ASCII representation of the message\n   digest.  */\nextern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MKDEPS": {"ttr": 7693, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Dependency generator for Makefile fragments.\n   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.\n   Contributed by Zack Weinberg, Mar 2000\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n#ifndef GCC_MKDEPS_H\n#define GCC_MKDEPS_H\n\n/* This is the data structure used by all the functions in mkdeps.c.\n   It's quite straightforward, but should be treated as opaque.  */\n\nstruct deps;\n\n/* Create a deps buffer.  */\nextern struct deps *deps_init (void);\n\n/* Destroy a deps buffer.  */\nextern void deps_free (struct deps *);\n\n/* Add a target (appears on left side of the colon) to the deps list.  Takes\n   a boolean indicating whether to quote the target for MAKE.  */\nextern void deps_add_target (struct deps *, const char *, int);\n\n/* Sets the default target if none has been given already.  An empty\n   string as the default target is interpreted as stdin.  */\nextern void deps_add_default_target (struct deps *, const char *);\n\n/* Add a dependency (appears on the right side of the colon) to the\n   deps list.  Dependencies will be printed in the order that they\n   were entered with this function.  By convention, the first\n   dependency entered should be the primary source file.  */\nextern void deps_add_dep (struct deps *, const char *);\n\n/* Write out a deps buffer to a specified file.  The third argument\n   is the number of columns to word-wrap at (0 means don't wrap).  */\nextern void deps_write (const struct deps *, FILE *, unsigned int);\n\n/* Write out a deps buffer to a file, in a form that can be read back\n   with deps_restore.  Returns nonzero on error, in which case the\n   error number will be in errno.  */\nextern int deps_save (struct deps *, FILE *);\n\n/* Read back dependency information written with deps_save into\n   the deps buffer.  The third argument may be NULL, in which case\n   the dependency information is just skipped, or it may be a filename,\n   in which case that filename is skipped.  */\nextern int deps_restore (struct deps *, FILE *, const char *);\n\n/* For each dependency *except the first*, emit a dummy rule for that\n   file, causing it to depend on nothing.  This is used to work around\n   the intermediate-file deletion misfeature in Make, in some\n   automatic dependency schemes.  */\nextern void deps_phony_targets (const struct deps *, FILE *);\n\n#endif /* ! GCC_MKDEPS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MODE@CLA": {"ttr": 13320, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Machine mode class definitions for GCC.\n   Copyright (C) 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#define MODE_CLASSES\t\t\t\t\t\t\t   \\\n  DEF_MODE_CLASS (MODE_RANDOM),\t\t/* other */\t\t\t   \\\n  DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n  DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n  DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */\t   \\\n  DEF_MODE_CLASS (MODE_FLOAT),\t\t/* floating point */\t\t   \\\n  DEF_MODE_CLASS (MODE_COMPLEX_INT), \t/* complex numbers */\t\t   \\\n  DEF_MODE_CLASS (MODE_COMPLEX_FLOAT),\t\t\t\t\t   \\\n  DEF_MODE_CLASS (MODE_VECTOR_INT),\t/* SIMD vectors */\t\t   \\\n  DEF_MODE_CLASS (MODE_VECTOR_FLOAT)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSHORT": {"ttr": 7937, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#define address_cost ZZZ_1\n#define address_operand ZZZ_2\n#define add_insn ZZZ_3\n#define add_insn_after ZZZ_4\n#define add_insn_before ZZZ_5\n#define adjust_address_1 ZZZ_6\n#define adjust_automodify_address_1 ZZZ_7\n#define align_functions ZZZ_8\n#define align_functions_log ZZZ_9\n#define align_jumps ZZZ_10\n#define align_jumps_log ZZZ_11\n#define align_jumps_max_skip ZZZ_12\n#define align_labels ZZZ_13\n#define align_labels_log ZZZ_14\n#define align_labels_max_skip ZZZ_15\n#define align_loops ZZZ_16\n#define align_loops_log ZZZ_17\n#define align_loops_max_skip ZZZ_18\n#define allocate_bb_life_data ZZZ_19\n#define allocate_dynamic_stack_space ZZZ_20\n#define allocate_initial_values ZZZ_21\n#define allocate_reg_info ZZZ_22\n#define allocate_reg_life_data ZZZ_23\n#define allocate_struct_function ZZZ_24\n#define alloc_aux_for_block ZZZ_25\n#define alloc_aux_for_blocks ZZZ_26\n#define alloc_aux_for_edge ZZZ_27\n#define alloc_aux_for_edges ZZZ_28\n#define assemble_alias ZZZ_29\n#define assemble_align ZZZ_30\n#define assemble_asm ZZZ_31\n#define assemble_end_function ZZZ_32\n#define assemble_external ZZZ_33\n#define assemble_external_libcall ZZZ_34\n#define assemble_integer ZZZ_35\n#define assemble_integer_with_op ZZZ_36\n#define assemble_label ZZZ_37\n#define assemble_name ZZZ_38\n#define assemble_real ZZZ_39\n#define assemble_start_function ZZZ_40\n#define assemble_static_space ZZZ_41\n#define assemble_string ZZZ_42\n#define assemble_trampoline_template ZZZ_43\n#define assemble_variable ZZZ_44\n#define assemble_zeros ZZZ_45\n#define assign_stack_local ZZZ_46\n#define assign_stack_temp ZZZ_47\n#define assign_stack_temp_for_type ZZZ_48\n#define attribute_hash_list ZZZ_49\n#define attribute_list_contained ZZZ_50\n#define attribute_list_equal ZZZ_51\n#define aux_info_file ZZZ_52\n#define aux_info_file_name ZZZ_53\n#define bitmap_clear ZZZ_54\n#define bitmap_clear_bit ZZZ_55\n#define bitmap_copy ZZZ_56\n#define bitmap_initialize ZZZ_57\n#define bitmap_ior_and_compl ZZZ_58\n#define build_array_declarator ZZZ_59\n#define build_array_ref ZZZ_60\n#define build_array_type ZZZ_61\n#define build_common_tree_nodes ZZZ_62\n#define build_common_tree_nodes_2 ZZZ_63\n#define build_complex ZZZ_64\n#define build_complex_type ZZZ_65\n#define build_component_ref ZZZ_66\n#define build_compound_expr ZZZ_67\n#define build_compound_literal ZZZ_68\n#define build_conditional_expr ZZZ_69\n#define build_constructor ZZZ_70\n#define build_continue_stmt ZZZ_71\n#define build_decl ZZZ_72\n#define build_decl_attribute_variant ZZZ_73\n#define build_expr_wfl ZZZ_74\n#define build_external_ref ZZZ_75\n#define build_function_call ZZZ_76\n#define build_function_call_expr ZZZ_77\n#define build_function_type ZZZ_78\n#define build_function_type_list ZZZ_79\n#define build_index_2_type ZZZ_80\n#define build_index_type ZZZ_81\n#define build_indirect_ref ZZZ_82\n#define build_insn_chain ZZZ_83\n#define build_int_2_wide ZZZ_84\n#define build_method_type ZZZ_85\n#define build_method_type_directly ZZZ_86\n#define build_pointer_type ZZZ_87\n#define build_pointer_type_for_mode ZZZ_88\n#define build_real ZZZ_89\n#define build_real_from_int_cst ZZZ_90\n#define build_reference_type ZZZ_91\n#define build_reference_type_for_mode ZZZ_92\n#define build_return_stmt ZZZ_93\n#define build_stmt ZZZ_94\n#define build_string ZZZ_95\n#define build_type_attribute_variant ZZZ_96\n#define build_type_copy ZZZ_97\n#define build_type_no_quals ZZZ_98\n#define builtin_define_std ZZZ_99\n#define builtin_define_with_value ZZZ_100\n#define builtin_function ZZZ_101\n#define builtin_mathfn_code ZZZ_102\n#define built_in_class_names ZZZ_103\n#define built_in_decls ZZZ_104\n#define built_in_names ZZZ_105\n#define call_fixed_regs ZZZ_106\n#define call_fixed_reg_set ZZZ_107\n#define call_used_regs ZZZ_108\n#define call_used_reg_set ZZZ_109\n#define cancel_loop ZZZ_110\n#define cancel_loop_tree ZZZ_111\n#define can_copy_bbs_p ZZZ_112\n#define can_copy_p ZZZ_113\n#define can_throw_external ZZZ_114\n#define can_throw_internal ZZZ_115\n#define cfg_layout_can_duplicate_bb_p ZZZ_116\n#define cfg_layout_duplicate_bb ZZZ_117\n#define cfg_layout_finalize ZZZ_118\n#define cfg_layout_function_footer ZZZ_119\n#define cfg_layout_function_header ZZZ_120\n#define cfg_layout_initialize ZZZ_121\n#define cfg_layout_initialize_rbi ZZZ_122\n#define cfg_layout_pool ZZZ_123\n#define cfg_layout_rtl_cfg_hooks ZZZ_124\n#define cfg_layout_rtl_register_cfg_hooks ZZZ_125\n#define cgraph_calls_p ZZZ_126\n#define cgraph_create_edges ZZZ_127\n#define cgraph_finalize_compilation_unit ZZZ_128\n#define cgraph_finalize_function ZZZ_129\n#define cgraph_function_possibly_inlined_p ZZZ_130\n#define cgraph_global_info ZZZ_131\n#define cgraph_global_info_ready ZZZ_132\n#define cgraph_mark_needed_node ZZZ_133\n#define cgraph_mark_reachable_node ZZZ_134\n#define cgraph_max_uid ZZZ_135\n#define cgraph_node ZZZ_136\n#define cgraph_nodes ZZZ_137\n#define cgraph_nodes_queue ZZZ_138\n#define cgraph_node_for_identifier ZZZ_139\n#define cgraph_node_name ZZZ_140\n#define cgraph_n_nodes ZZZ_141\n#define cgraph_record_call ZZZ_142\n#define cgraph_remove_call ZZZ_143\n#define cgraph_remove_edge ZZZ_144\n#define cgraph_remove_node ZZZ_145\n#define cgraph_rtl_info ZZZ_146\n#define cgraph_varpool_assemble_pending_decls ZZZ_147\n#define cgraph_varpool_finalize_decl ZZZ_148\n#define cgraph_varpool_mark_needed_node ZZZ_149\n#define cgraph_varpool_node ZZZ_150\n#define cgraph_varpool_nodes_queue ZZZ_151\n#define cgraph_varpool_node_for_identifier ZZZ_152\n#define cgraph_varpool_n_nodes ZZZ_153\n#define check_for_full_enumeration_handling ZZZ_154\n#define check_for_loop_decls ZZZ_155\n#define check_function_arguments ZZZ_156\n#define check_function_arguments_recurse ZZZ_157\n#define check_function_format ZZZ_158\n#define check_function_return_warnings ZZZ_159\n#define cleanup_barriers ZZZ_160\n#define cleanup_cfg ZZZ_161\n#define cleanup_subreg_operands ZZZ_162\n#define clear_aux_for_blocks ZZZ_163\n#define clear_aux_for_edges ZZZ_164\n#define cl_options ZZZ_165\n#define cl_options_count ZZZ_166\n#define combine_instructions ZZZ_167\n#define combine_stack_adjustments ZZZ_168\n#define combine_temp_slots ZZZ_169\n#define commit_edge_insertions ZZZ_170\n#define commit_edge_insertions_watch_calls ZZZ_171\n#define compare_from_rtx ZZZ_172\n#define compare_tree_int ZZZ_173\n#define comparison_dominates_p ZZZ_174\n#define comparison_operator ZZZ_175\n#define compute_alignments ZZZ_176\n#define compute_available ZZZ_177\n#define compute_bb_for_insn ZZZ_178\n#define compute_record_mode ZZZ_179\n#define compute_reloc_for_constant ZZZ_180\n#define compute_use_by_pseudos ZZZ_181\n#define concat_copy ZZZ_182\n#define concat_copy2 ZZZ_183\n#define condjump_in_parallel_p ZZZ_184\n#define condjump_label ZZZ_185\n#define condjump_p ZZZ_186\n#define conflict_graph_add ZZZ_187\n#define conflict_graph_compute ZZZ_188\n#define conflict_graph_conflict_p ZZZ_189\n#define conflict_graph_delete ZZZ_190\n#define conflict_graph_enum ZZZ_191\n#define conflict_graph_merge_regs ZZZ_192\n#define conflict_graph_new ZZZ_193\n#define conflict_graph_print ZZZ_194\n#define constant_expression_warning ZZZ_195\n#define constant_pool_reference_p ZZZ_196\n#define constant_string_class_name ZZZ_197\n#define constrain_operands ZZZ_198\n#define constrain_operands_cached ZZZ_199\n#define constructor_no_implicit ZZZ_200\n#define constructor_range_stack ZZZ_201\n#define constructor_stack ZZZ_202\n#define const_double_from_real_value ZZZ_203\n#define const_double_operand ZZZ_204\n#define const_int_operand ZZZ_205\n#define const_int_rtx ZZZ_206\n#define convert_and_check ZZZ_207\n#define convert_from_eh_region_ranges ZZZ_208\n#define convert_memory_address ZZZ_209\n#define convert_modes ZZZ_210\n#define convert_move ZZZ_211\n#define convert_optab_table ZZZ_212\n#define convert_to_complex ZZZ_213\n#define convert_to_eh_region_ranges ZZZ_214\n#define convert_to_integer ZZZ_215\n#define convert_to_mode ZZZ_216\n#define convert_to_pointer ZZZ_217\n#define convert_to_real ZZZ_218\n#define convert_to_vector ZZZ_219\n#define copy_insn ZZZ_220\n#define copy_insn_1 ZZZ_221\n#define copy_rtx ZZZ_222\n#define copy_rtx_and_substitute ZZZ_223\n#define copy_rtx_if_shared ZZZ_224\n#define copy_to_mode_reg ZZZ_225\n#define copy_to_reg ZZZ_226\n#define copy_to_suggested_reg ZZZ_227\n#define coverage_begin_output ZZZ_228\n#define coverage_counter_alloc ZZZ_229\n#define coverage_counter_ref ZZZ_230\n#define coverage_end_function ZZZ_231\n#define coverage_finish ZZZ_232\n#define coverage_init ZZZ_233\n#define cplus_demangle ZZZ_234\n#define cplus_demangle_builtin_types ZZZ_235\n#define cplus_demangle_fill_builtin_type ZZZ_236\n#define cplus_demangle_fill_component ZZZ_237\n#define cplus_demangle_fill_ctor ZZZ_238\n#define cplus_demangle_fill_dtor ZZZ_239\n#define cplus_demangle_fill_extended_operator ZZZ_240\n#define cplus_demangle_fill_name ZZZ_241\n#define cplus_demangle_fill_operator ZZZ_242\n#define cplus_demangle_init_info ZZZ_243\n#define cplus_demangle_mangled_name ZZZ_244\n#define cplus_demangle_name_to_style ZZZ_245\n#define cplus_demangle_operators ZZZ_246\n#define cplus_demangle_opname ZZZ_247\n#define cplus_demangle_print ZZZ_248\n#define cplus_demangle_set_style ZZZ_249\n#define cplus_demangle_type ZZZ_250\n#define cplus_demangle_v3 ZZZ_251\n#define cplus_demangle_v3_components ZZZ_252\n#define cpp_define ZZZ_253\n#define cpp_defined ZZZ_254\n#define cpp_error ZZZ_255\n#define cpp_errors ZZZ_256\n#define cpp_error_with_line ZZZ_257\n#define cpp_GCC_INCLUDE_DIR ZZZ_258\n#define cpp_GCC_INCLUDE_DIR_len ZZZ_259\n#define cpp_get_callbacks ZZZ_260\n#define cpp_get_line_maps ZZZ_261\n#define cpp_get_options ZZZ_262\n#define cpp_get_token ZZZ_263\n#define cpp_included ZZZ_264\n#define cpp_include_defaults ZZZ_265\n#define cpp_init_builtins ZZZ_266\n#define cpp_init_iconv ZZZ_267\n#define cpp_interpret_charconst ZZZ_268\n#define cpp_interpret_integer ZZZ_269\n#define cpp_interpret_string ZZZ_270\n#define cpp_output_line ZZZ_271\n#define cpp_output_token ZZZ_272\n#define cpp_push_buffer ZZZ_273\n#define cpp_push_include ZZZ_274\n#define cpp_read_main_file ZZZ_275\n#define cpp_read_state ZZZ_276\n#define cpp_set_callbacks ZZZ_277\n#define cpp_set_include_chains ZZZ_278\n#define cpp_set_lang ZZZ_279\n#define cpp_token_as_text ZZZ_280\n#define cpp_token_len ZZZ_281\n#define cpp_undef ZZZ_282\n#define cpp_undef_all ZZZ_283\n#define cpp_write_pch_deps ZZZ_284\n#define cpp_write_pch_state ZZZ_285\n#define cselib_init ZZZ_286\n#define cselib_invalidate_rtx ZZZ_287\n#define current_demangling_style ZZZ_288\n#define current_function_decl ZZZ_289\n#define current_function_func_begin_label ZZZ_290\n#define current_function_has_exception_handlers ZZZ_291\n#define current_function_is_leaf ZZZ_292\n#define current_function_name ZZZ_293\n#define current_function_nothrow ZZZ_294\n#define current_function_returns_abnormally ZZZ_295\n#define current_function_returns_null ZZZ_296\n#define current_function_returns_value ZZZ_297\n#define current_function_sp_is_unchanging ZZZ_298\n#define current_function_uses_only_leaf_regs ZZZ_299\n#define current_nesting_level ZZZ_300\n#define current_output_insn ZZZ_301\n#define current_sched_info ZZZ_302\n#define current_scope_stmt_stack ZZZ_303\n#define current_stmt_tree ZZZ_304\n#define c_begin_compound_stmt ZZZ_305\n#define c_begin_if_stmt ZZZ_306\n#define c_begin_while_stmt ZZZ_307\n#define c_common_attribute_table ZZZ_308\n#define c_common_finish ZZZ_309\n#define c_common_format_attribute_table ZZZ_310\n#define c_common_get_alias_set ZZZ_311\n#define c_common_handle_option ZZZ_312\n#define c_common_init ZZZ_313\n#define c_common_init_options ZZZ_314\n#define c_common_missing_argument ZZZ_315\n#define c_common_nodes_and_builtins ZZZ_316\n#define c_common_no_more_pch ZZZ_317\n#define c_common_parse_file ZZZ_318\n#define c_common_post_options ZZZ_319\n#define c_common_read_pch ZZZ_320\n#define c_common_signed_or_unsigned_type ZZZ_321\n#define c_common_signed_type ZZZ_322\n#define c_common_truthvalue_conversion ZZZ_323\n#define c_common_type_for_mode ZZZ_324\n#define c_common_type_for_size ZZZ_325\n#define c_common_unsafe_for_reeval ZZZ_326\n#define c_common_unsigned_type ZZZ_327\n#define c_common_valid_pch ZZZ_328\n#define c_common_write_pch ZZZ_329\n#define c_expand_asm_operands ZZZ_330\n#define c_expand_body ZZZ_331\n#define c_expand_decl_stmt ZZZ_332\n#define c_expand_deferred_function ZZZ_333\n#define c_expand_end_cond ZZZ_334\n#define c_expand_expr ZZZ_335\n#define c_expand_expr_stmt ZZZ_336\n#define c_expand_return ZZZ_337\n#define c_expand_start_cond ZZZ_338\n#define c_expand_start_else ZZZ_339\n#define c_finish_case ZZZ_340\n#define c_finish_else ZZZ_341\n#define c_finish_incomplete_decl ZZZ_342\n#define c_finish_then ZZZ_343\n#define c_finish_while_stmt_cond ZZZ_344\n#define c_objc_common_finish_file ZZZ_345\n#define c_objc_common_init ZZZ_346\n#define c_parse_error ZZZ_347\n#define c_parse_file ZZZ_348\n#define c_parse_init ZZZ_349\n#define c_register_builtin_type ZZZ_350\n#define c_register_pragma ZZZ_351\n#define c_staticp ZZZ_352\n#define c_static_assembler_name ZZZ_353\n#define dead_or_set_p ZZZ_354\n#define dead_or_set_regno_p ZZZ_355\n#define debug_bb ZZZ_356\n#define debug_bb_n ZZZ_357\n#define debug_bitmap ZZZ_358\n#define debug_bitmap_file ZZZ_359\n#define debug_biv ZZZ_360\n#define debug_df_chain ZZZ_361\n#define debug_df_defno ZZZ_362\n#define debug_df_insn ZZZ_363\n#define debug_df_ref ZZZ_364\n#define debug_df_reg ZZZ_365\n#define debug_df_regno ZZZ_366\n#define debug_df_useno ZZZ_367\n#define debug_flow_info ZZZ_368\n#define debug_flush_symbol_queue ZZZ_369\n#define debug_ivs ZZZ_370\n#define debug_iv_class ZZZ_371\n#define debug_loop ZZZ_372\n#define debug_loops ZZZ_373\n#define debug_nesting ZZZ_374\n#define debug_new_regalloc ZZZ_375\n#define debug_nothing_charstar ZZZ_376\n#define debug_nothing_int ZZZ_377\n#define debug_nothing_int_charstar ZZZ_378\n#define debug_nothing_int_int ZZZ_379\n#define debug_nothing_rtx ZZZ_380\n#define debug_nothing_tree ZZZ_381\n#define debug_nothing_void ZZZ_382\n#define debug_no_type_hash ZZZ_383\n#define debug_regset ZZZ_384\n#define debug_reload ZZZ_385\n#define debug_reload_to_stream ZZZ_386\n#define debug_rtx ZZZ_387\n#define debug_rtx_count ZZZ_388\n#define debug_rtx_find ZZZ_389\n#define debug_rtx_list ZZZ_390\n#define debug_rtx_range ZZZ_391\n#define debug_tree ZZZ_392\n#define debug_true_tree ZZZ_393\n#define declare_label ZZZ_394\n#define declare_nonlocal_label ZZZ_395\n#define declare_parm_level ZZZ_396\n#define declare_weak ZZZ_397\n#define decl_readonly_section ZZZ_398\n#define decl_readonly_section_1 ZZZ_399\n#define default_address_cost ZZZ_400\n#define default_assemble_integer ZZZ_401\n#define default_assemble_visibility ZZZ_402\n#define default_binds_local_p ZZZ_403\n#define default_binds_local_p_1 ZZZ_404\n#define default_can_output_mi_thunk_no_vcall ZZZ_405\n#define default_cc_modes_compatible ZZZ_406\n#define default_coff_asm_named_section ZZZ_407\n#define default_conversion ZZZ_408\n#define default_eh_frame_section ZZZ_409\n#define default_elf_asm_named_section ZZZ_410\n#define default_elf_select_rtx_section ZZZ_411\n#define default_elf_select_section ZZZ_412\n#define default_elf_select_section_1 ZZZ_413\n#define default_encode_section_info ZZZ_414\n#define default_exception_section ZZZ_415\n#define default_expand_builtin ZZZ_416\n#define default_expand_builtin_saveregs ZZZ_417\n#define default_external_libcall ZZZ_418\n#define default_file_start ZZZ_419\n#define default_function_pro_epilogue ZZZ_420\n#define default_get_pch_validity ZZZ_421\n#define default_gt_pch_get_address ZZZ_422\n#define default_gt_pch_use_address ZZZ_423\n#define default_internal_label ZZZ_424\n#define default_must_pass_in_stack ZZZ_425\n#define default_named_section_asm_out_constructor ZZZ_426\n#define default_named_section_asm_out_destructor ZZZ_427\n#define default_no_named_section ZZZ_428\n#define default_pch_valid_p ZZZ_429\n#define default_pe_asm_named_section ZZZ_430\n#define default_pretend_outgoing_varargs_named ZZZ_431\n#define default_promote_function_args ZZZ_432\n#define default_promote_function_return ZZZ_433\n#define default_promote_prototypes ZZZ_434\n#define default_return_in_memory ZZZ_435\n#define default_section_type_flags ZZZ_436\n#define default_section_type_flags_1 ZZZ_437\n#define default_select_rtx_section ZZZ_438\n#define default_select_section ZZZ_439\n#define default_setup_incoming_varargs ZZZ_440\n#define default_stabs_asm_out_constructor ZZZ_441\n#define default_stabs_asm_out_destructor ZZZ_442\n#define default_strict_argument_naming ZZZ_443\n#define default_strip_name_encoding ZZZ_444\n#define default_struct_value_rtx ZZZ_445\n#define default_unique_section ZZZ_446\n#define default_unique_section_1 ZZZ_447\n#define default_valid_pointer_mode ZZZ_448\n#define delete_for_peephole ZZZ_449\n#define delete_from_dominance_info ZZZ_450\n#define delete_insn ZZZ_451\n#define delete_insns_since ZZZ_452\n#define delete_insn_and_edges ZZZ_453\n#define delete_insn_chain ZZZ_454\n#define delete_insn_chain_and_edges ZZZ_455\n#define delete_noop_moves ZZZ_456\n#define delete_null_pointer_checks ZZZ_457\n#define deps_add_default_target ZZZ_458\n#define deps_add_dep ZZZ_459\n#define deps_add_target ZZZ_460\n#define df_bb_regs_lives_compare ZZZ_461\n#define df_bb_reg_live_end_p ZZZ_462\n#define df_bb_reg_live_start_p ZZZ_463\n#define df_insn_debug ZZZ_464\n#define df_insn_debug_regno ZZZ_465\n#define df_insn_delete ZZZ_466\n#define df_insn_dominates_all_uses_p ZZZ_467\n#define df_insn_dominates_uses_p ZZZ_468\n#define df_insn_mem_replace ZZZ_469\n#define df_insn_modify ZZZ_470\n#define df_insn_move_before ZZZ_471\n#define df_insn_regno_def_p ZZZ_472\n#define df_pattern_emit_after ZZZ_473\n#define df_pattern_emit_before ZZZ_474\n#define df_ref_reg_replace ZZZ_475\n#define df_ref_remove ZZZ_476\n#define diagnostic_build_prefix ZZZ_477\n#define diagnostic_initialize ZZZ_478\n#define diagnostic_report_current_function ZZZ_479\n#define diagnostic_report_current_module ZZZ_480\n#define diagnostic_report_diagnostic ZZZ_481\n#define diagnostic_set_info ZZZ_482\n#define do_jump_by_parts_equality_rtx ZZZ_483\n#define do_jump_by_parts_greater_rtx ZZZ_484\n#define dump_combine_stats ZZZ_485\n#define dump_combine_total_stats ZZZ_486\n#define dump_flag ZZZ_487\n#define dump_flag_name ZZZ_488\n#define dump_igraph ZZZ_489\n#define dump_igraph_machine ZZZ_490\n#define dump_sbitmap ZZZ_491\n#define dump_sbitmap_file ZZZ_492\n#define dump_sbitmap_vector ZZZ_493\n#define dump_web_conflicts ZZZ_494\n#define dump_web_insns ZZZ_495\n#define duplicate_eh_regions ZZZ_496\n#define duplicate_loop_to_header_edge ZZZ_497\n#define dw2_asm_output_addr ZZZ_498\n#define dw2_asm_output_addr_rtx ZZZ_499\n#define dw2_asm_output_data ZZZ_500\n#define dw2_asm_output_data_sleb128 ZZZ_501\n#define dw2_asm_output_data_uleb128 ZZZ_502\n#define dw2_asm_output_delta ZZZ_503\n#define dw2_asm_output_delta_sleb128 ZZZ_504\n#define dw2_asm_output_delta_uleb128 ZZZ_505\n#define dw2_asm_output_encoded_addr_rtx ZZZ_506\n#define dw2_asm_output_nstring ZZZ_507\n#define dw2_asm_output_offset ZZZ_508\n#define dw2_asm_output_pcrel ZZZ_509\n#define dyn_string_append ZZZ_510\n#define dyn_string_append_char ZZZ_511\n#define dyn_string_append_cstr ZZZ_512\n#define dyn_string_clear ZZZ_513\n#define dyn_string_copy ZZZ_514\n#define dyn_string_copy_cstr ZZZ_515\n#define dyn_string_delete ZZZ_516\n#define dyn_string_eq ZZZ_517\n#define dyn_string_init ZZZ_518\n#define dyn_string_insert ZZZ_519\n#define dyn_string_insert_char ZZZ_520\n#define dyn_string_insert_cstr ZZZ_521\n#define dyn_string_new ZZZ_522\n#define dyn_string_prepend ZZZ_523\n#define dyn_string_prepend_cstr ZZZ_524\n#define dyn_string_release ZZZ_525\n#define dyn_string_resize ZZZ_526\n#define dyn_string_substring ZZZ_527\n#define eliminate_constant_term ZZZ_528\n#define eliminate_regs ZZZ_529\n#define emit_barrier ZZZ_530\n#define emit_barrier_after ZZZ_531\n#define emit_barrier_before ZZZ_532\n#define emit_call_insn ZZZ_533\n#define emit_call_insn_after ZZZ_534\n#define emit_call_insn_after_noloc ZZZ_535\n#define emit_call_insn_after_setloc ZZZ_536\n#define emit_call_insn_before ZZZ_537\n#define emit_call_insn_before_noloc ZZZ_538\n#define emit_call_insn_before_setloc ZZZ_539\n#define emit_cmp_and_jump_insns ZZZ_540\n#define emit_cmp_insn ZZZ_541\n#define emit_group_load ZZZ_542\n#define emit_group_move ZZZ_543\n#define emit_group_store ZZZ_544\n#define emit_insn ZZZ_545\n#define emit_insn_after ZZZ_546\n#define emit_insn_after_noloc ZZZ_547\n#define emit_insn_after_setloc ZZZ_548\n#define emit_insn_after_with_line_notes ZZZ_549\n#define emit_insn_before ZZZ_550\n#define emit_insn_before_noloc ZZZ_551\n#define emit_insn_before_setloc ZZZ_552\n#define emit_jump ZZZ_553\n#define emit_jump_insn ZZZ_554\n#define emit_jump_insn_after ZZZ_555\n#define emit_jump_insn_after_noloc ZZZ_556\n#define emit_jump_insn_after_setloc ZZZ_557\n#define emit_jump_insn_before ZZZ_558\n#define emit_jump_insn_before_noloc ZZZ_559\n#define emit_jump_insn_before_setloc ZZZ_560\n#define emit_label ZZZ_561\n#define emit_label_after ZZZ_562\n#define emit_label_before ZZZ_563\n#define emit_libcall_block ZZZ_564\n#define emit_library_call ZZZ_565\n#define emit_library_call_value ZZZ_566\n#define emit_move_insn ZZZ_567\n#define emit_move_insn_1 ZZZ_568\n#define emit_note ZZZ_569\n#define emit_note_after ZZZ_570\n#define emit_note_before ZZZ_571\n#define emit_note_copy ZZZ_572\n#define emit_note_copy_after ZZZ_573\n#define emit_stack_restore ZZZ_574\n#define emit_stack_save ZZZ_575\n#define emit_store_flag ZZZ_576\n#define emit_store_flag_force ZZZ_577\n#define epilogue_completed ZZZ_578\n#define epilogue_locator ZZZ_579\n#define exact_real_inverse ZZZ_580\n#define exact_real_truncate ZZZ_581\n#define expand_abs ZZZ_582\n#define expand_abs_nojump ZZZ_583\n#define expand_and ZZZ_584\n#define expand_anon_union_decl ZZZ_585\n#define expand_asm ZZZ_586\n#define expand_asm_operands ZZZ_587\n#define expand_assignment ZZZ_588\n#define expand_binop ZZZ_589\n#define expand_builtin ZZZ_590\n#define expand_builtin_eh_return ZZZ_591\n#define expand_builtin_eh_return_data_regno ZZZ_592\n#define expand_builtin_expect_jump ZZZ_593\n#define expand_builtin_extend_pointer ZZZ_594\n#define expand_builtin_extract_return_addr ZZZ_595\n#define expand_builtin_frob_return_addr ZZZ_596\n#define expand_builtin_longjmp ZZZ_597\n#define expand_builtin_return_addr ZZZ_598\n#define expand_builtin_saveregs ZZZ_599\n#define expand_builtin_setjmp_receiver ZZZ_600\n#define expand_builtin_setjmp_setup ZZZ_601\n#define expand_builtin_trap ZZZ_602\n#define expand_builtin_unwind_init ZZZ_603\n#define expand_builtin_va_arg ZZZ_604\n#define expand_call ZZZ_605\n#define expand_complex_abs ZZZ_606\n#define expand_computed_goto ZZZ_607\n#define expand_cond ZZZ_608\n#define expand_continue_loop ZZZ_609\n#define expand_dec ZZZ_610\n#define expand_decl ZZZ_611\n#define expand_decl_cleanup ZZZ_612\n#define expand_decl_cleanup_eh ZZZ_613\n#define expand_decl_init ZZZ_614\n#define expand_divmod ZZZ_615\n#define expand_dummy_function_end ZZZ_616\n#define expand_eh_region_end_allowed ZZZ_617\n#define expand_eh_region_end_cleanup ZZZ_618\n#define expand_eh_region_end_fixup ZZZ_619\n#define expand_eh_region_end_must_not_throw ZZZ_620\n#define expand_eh_region_end_throw ZZZ_621\n#define expand_eh_region_start ZZZ_622\n#define expand_eh_return ZZZ_623\n#define expand_elseif ZZZ_624\n#define expand_end_all_catch ZZZ_625\n#define expand_end_bindings ZZZ_626\n#define expand_end_case_type ZZZ_627\n#define expand_end_catch ZZZ_628\n#define expand_end_cond ZZZ_629\n#define expand_end_loop ZZZ_630\n#define expand_end_null_loop ZZZ_631\n#define expand_end_stmt_expr ZZZ_632\n#define expand_end_target_temps ZZZ_633\n#define expand_exit_loop ZZZ_634\n#define expand_exit_loop_if_false ZZZ_635\n#define expand_exit_loop_top_cond ZZZ_636\n#define expand_exit_something ZZZ_637\n#define expand_expr_real ZZZ_638\n#define expand_expr_stmt ZZZ_639\n#define expand_expr_stmt_value ZZZ_640\n#define expand_fix ZZZ_641\n#define expand_fixups ZZZ_642\n#define expand_float ZZZ_643\n#define expand_function_end ZZZ_644\n#define expand_function_start ZZZ_645\n#define expand_inc ZZZ_646\n#define expand_inline_function ZZZ_647\n#define expand_label ZZZ_648\n#define expand_loop_continue_here ZZZ_649\n#define expand_main_function ZZZ_650\n#define expand_mult ZZZ_651\n#define expand_mult_add ZZZ_652\n#define expand_mult_highpart ZZZ_653\n#define expand_mult_highpart_adjust ZZZ_654\n#define expand_naked_return ZZZ_655\n#define expand_null_return ZZZ_656\n#define expand_shift ZZZ_657\n#define expand_simple_binop ZZZ_658\n#define expand_simple_unop ZZZ_659\n#define expand_start_all_catch ZZZ_660\n#define expand_start_bindings_and_block ZZZ_661\n#define expand_start_case ZZZ_662\n#define expand_start_case_dummy ZZZ_663\n#define expand_start_catch ZZZ_664\n#define expand_start_cond ZZZ_665\n#define expand_start_else ZZZ_666\n#define expand_start_elseif ZZZ_667\n#define expand_start_loop ZZZ_668\n#define expand_start_loop_continue_elsewhere ZZZ_669\n#define expand_start_null_loop ZZZ_670\n#define expand_start_stmt_expr ZZZ_671\n#define expand_start_target_temps ZZZ_672\n#define expand_stmt ZZZ_673\n#define expand_tree_builtin ZZZ_674\n#define expand_twoval_binop ZZZ_675\n#define expected_loop_iterations ZZZ_676\n#define expected_value_to_br_prob ZZZ_677\n#define extract_bit_field ZZZ_678\n#define extract_constrain_insn_cached ZZZ_679\n#define extract_insn ZZZ_680\n#define extract_insn_cached ZZZ_681\n#define extract_interface_info ZZZ_682\n#define fibheap_delete ZZZ_683\n#define fibheap_delete_node ZZZ_684\n#define fibheap_empty ZZZ_685\n#define fibheap_extract_min ZZZ_686\n#define fibheap_insert ZZZ_687\n#define fibheap_min ZZZ_688\n#define fibheap_min_key ZZZ_689\n#define fibheap_new ZZZ_690\n#define fibheap_replace_data ZZZ_691\n#define fibheap_replace_key ZZZ_692\n#define fibheap_replace_key_data ZZZ_693\n#define fibheap_union ZZZ_694\n#define find_base_term ZZZ_695\n#define find_basic_blocks ZZZ_696\n#define find_regno_fusage ZZZ_697\n#define find_regno_note ZZZ_698\n#define find_reg_equal_equiv_note ZZZ_699\n#define find_reg_fusage ZZZ_700\n#define find_reg_note ZZZ_701\n#define find_subweb ZZZ_702\n#define find_subweb_2 ZZZ_703\n#define find_sub_basic_blocks ZZZ_704\n#define finish_eh_generation ZZZ_705\n#define finish_enum ZZZ_706\n#define finish_expr_for_function ZZZ_707\n#define finish_file ZZZ_708\n#define finish_fname_decls ZZZ_709\n#define finish_function ZZZ_710\n#define finish_stmt_tree ZZZ_711\n#define finish_struct ZZZ_712\n#define fixed_regs ZZZ_713\n#define fixed_reg_set ZZZ_714\n#define flag_branch_on_count_reg ZZZ_715\n#define flag_branch_probabilities ZZZ_716\n#define flag_branch_target_load_optimize ZZZ_717\n#define flag_branch_target_load_optimize2 ZZZ_718\n#define flag_cond_mismatch ZZZ_719\n#define flag_conserve_space ZZZ_720\n#define flag_const_strings ZZZ_721\n#define flag_cse_follow_jumps ZZZ_722\n#define flag_cse_skip_blocks ZZZ_723\n#define flag_debug_asm ZZZ_724\n#define flag_debug_only_used_symbols ZZZ_725\n#define flag_default_inline ZZZ_726\n#define flag_defer_pop ZZZ_727\n#define flag_delayed_branch ZZZ_728\n#define flag_delete_null_pointer_checks ZZZ_729\n#define flag_dump_includes ZZZ_730\n#define flag_dump_macros ZZZ_731\n#define flag_dump_rtl_in_asm ZZZ_732\n#define flag_dump_unnumbered ZZZ_733\n#define flag_elide_constructors ZZZ_734\n#define flag_eliminate_dwarf2_dups ZZZ_735\n#define flag_eliminate_unused_debug_types ZZZ_736\n#define flag_force_addr ZZZ_737\n#define flag_force_mem ZZZ_738\n#define flag_gcse ZZZ_739\n#define flag_gcse_las ZZZ_740\n#define flag_gcse_lm ZZZ_741\n#define flag_gcse_sm ZZZ_742\n#define flag_gen_aux_info ZZZ_743\n#define flag_gen_declaration ZZZ_744\n#define flag_if_conversion ZZZ_745\n#define flag_if_conversion2 ZZZ_746\n#define flag_implement_inlines ZZZ_747\n#define flag_implicit_inline_templates ZZZ_748\n#define flag_implicit_templates ZZZ_749\n#define flag_inline_functions ZZZ_750\n#define flag_inline_trees ZZZ_751\n#define flag_iso ZZZ_752\n#define flag_isoc94 ZZZ_753\n#define flag_isoc99 ZZZ_754\n#define flag_keep_inline_functions ZZZ_755\n#define flag_keep_static_consts ZZZ_756\n#define flag_new_for_scope ZZZ_757\n#define flag_new_regalloc ZZZ_758\n#define flag_no_asm ZZZ_759\n#define flag_no_builtin ZZZ_760\n#define flag_no_common ZZZ_761\n#define flag_no_function_cse ZZZ_762\n#define flag_no_gnu_keywords ZZZ_763\n#define flag_no_ident ZZZ_764\n#define flag_no_inline ZZZ_765\n#define flag_no_line_commands ZZZ_766\n#define flag_no_nonansi_builtin ZZZ_767\n#define flag_no_output ZZZ_768\n#define flag_no_peephole ZZZ_769\n#define flag_old_unroll_all_loops ZZZ_770\n#define flag_old_unroll_loops ZZZ_771\n#define flag_optimize_sibling_calls ZZZ_772\n#define flag_optional_diags ZZZ_773\n#define flag_peel_loops ZZZ_774\n#define flag_peephole2 ZZZ_775\n#define flag_prefetch_loop_arrays ZZZ_776\n#define flag_preprocess_only ZZZ_777\n#define flag_ra_biased ZZZ_778\n#define flag_ra_break_aliases ZZZ_779\n#define flag_ra_dump_notes ZZZ_780\n#define flag_ra_improved_spilling ZZZ_781\n#define flag_ra_ir_spilling ZZZ_782\n#define flag_ra_merge_spill_costs ZZZ_783\n#define flag_ra_optimistic_coalescing ZZZ_784\n#define flag_ra_spill_every_use ZZZ_785\n#define flag_rename_registers ZZZ_786\n#define flag_renumber_insns ZZZ_787\n#define flag_reorder_blocks ZZZ_788\n#define flag_reorder_functions ZZZ_789\n#define flag_rerun_cse_after_loop ZZZ_790\n#define flag_rerun_loop_opt ZZZ_791\n#define flag_sched2_use_superblocks ZZZ_792\n#define flag_sched2_use_traces ZZZ_793\n#define flag_schedule_insns ZZZ_794\n#define flag_schedule_insns_after_reload ZZZ_795\n#define flag_schedule_interblock ZZZ_796\n#define flag_schedule_speculative ZZZ_797\n#define flag_schedule_speculative_load ZZZ_798\n#define flag_schedule_speculative_load_dangerous ZZZ_799\n#define flag_sched_stalled_insns ZZZ_800\n#define flag_sched_stalled_insns_dep ZZZ_801\n#define flag_short_double ZZZ_802\n#define flag_short_enums ZZZ_803\n#define flag_short_wchar ZZZ_804\n#define flag_signaling_nans ZZZ_805\n#define flag_signed_bitfields ZZZ_806\n#define flag_signed_char ZZZ_807\n#define flag_strength_reduce ZZZ_808\n#define flag_strict_aliasing ZZZ_809\n#define flag_tracer ZZZ_810\n#define flag_trapping_math ZZZ_811\n#define flag_trapv ZZZ_812\n#define flag_unroll_all_loops ZZZ_813\n#define flag_unroll_loops ZZZ_814\n#define flag_unsafe_math_optimizations ZZZ_815\n#define flag_unswitch_loops ZZZ_816\n#define flag_use_cxa_atexit ZZZ_817\n#define flag_use_repository ZZZ_818\n#define flag_zero_initialized_in_bss ZZZ_819\n#define flag_zero_link ZZZ_820\n#define floatformat_arm_ext_big ZZZ_821\n#define floatformat_arm_ext_littlebyte_bigword ZZZ_822\n#define floatformat_from_double ZZZ_823\n#define floatformat_i387_ext ZZZ_824\n#define floatformat_i960_ext ZZZ_825\n#define floatformat_ia64_quad_big ZZZ_826\n#define floatformat_ia64_quad_little ZZZ_827\n#define floatformat_ia64_spill_big ZZZ_828\n#define floatformat_ia64_spill_little ZZZ_829\n#define floatformat_ieee_double_big ZZZ_830\n#define floatformat_ieee_double_little ZZZ_831\n#define floatformat_ieee_double_littlebyte_bigword ZZZ_832\n#define floatformat_ieee_single_big ZZZ_833\n#define floatformat_ieee_single_little ZZZ_834\n#define floatformat_is_valid ZZZ_835\n#define floatformat_m68881_ext ZZZ_836\n#define floatformat_m88110_ext ZZZ_837\n#define floatformat_m88110_harris_ext ZZZ_838\n#define floatformat_to_double ZZZ_839\n#define flow_loops_dump ZZZ_840\n#define flow_loops_find ZZZ_841\n#define flow_loops_free ZZZ_842\n#define flow_loops_update ZZZ_843\n#define flow_loop_dump ZZZ_844\n#define flow_loop_free ZZZ_845\n#define flow_loop_nested_p ZZZ_846\n#define flow_loop_outside_edge_p ZZZ_847\n#define flow_loop_scan ZZZ_848\n#define flow_loop_tree_node_add ZZZ_849\n#define flow_loop_tree_node_remove ZZZ_850\n#define force_nonfallthru ZZZ_851\n#define force_nonfallthru_and_redirect ZZZ_852\n#define force_not_mem ZZZ_853\n#define for_each_eh_label ZZZ_854\n#define for_each_insn_in_loop ZZZ_855\n#define for_each_rtx ZZZ_856\n#define free_after_compilation ZZZ_857\n#define free_after_parsing ZZZ_858\n#define free_aux_for_blocks ZZZ_859\n#define free_aux_for_edges ZZZ_860\n#define free_EXPR_LIST_list ZZZ_861\n#define free_EXPR_LIST_node ZZZ_862\n#define free_INSN_LIST_list ZZZ_863\n#define free_INSN_LIST_node ZZZ_864\n#define free_profiled_values ZZZ_865\n#define free_propagate_block_info ZZZ_866\n#define free_temps_for_rtl_expr ZZZ_867\n#define free_temp_slots ZZZ_868\n#define function_attribute_inlinable_p ZZZ_869\n#define function_base_page ZZZ_870\n#define function_cannot_inline_p ZZZ_871\n#define function_invariant_p ZZZ_872\n#define function_section ZZZ_873\n#define gcov_read_counter ZZZ_874\n#define gcov_read_string ZZZ_875\n#define gcov_read_summary ZZZ_876\n#define gcov_read_unsigned ZZZ_877\n#define gcov_write_length ZZZ_878\n#define gcov_write_string ZZZ_879\n#define gcov_write_tag ZZZ_880\n#define gcov_write_unsigned ZZZ_881\n#define genrtl_case_label ZZZ_882\n#define genrtl_cleanup_stmt ZZZ_883\n#define genrtl_compound_stmt ZZZ_884\n#define genrtl_continue_stmt ZZZ_885\n#define genrtl_decl_stmt ZZZ_886\n#define genrtl_do_pushlevel ZZZ_887\n#define genrtl_do_stmt ZZZ_888\n#define genrtl_expr_stmt ZZZ_889\n#define genrtl_expr_stmt_value ZZZ_890\n#define genrtl_scope_stmt ZZZ_891\n#define genrtl_switch_stmt ZZZ_892\n#define gen_abssf2 ZZZ_893\n#define gen_abssi2 ZZZ_894\n#define gen_adddf3 ZZZ_895\n#define gen_adddi3 ZZZ_896\n#define gen_addsf3 ZZZ_897\n#define gen_addsi3 ZZZ_898\n#define gen_ashldi3 ZZZ_899\n#define gen_ashlhi3 ZZZ_900\n#define gen_ashlqi3 ZZZ_901\n#define gen_ashlsi3 ZZZ_902\n#define gen_ashrdi3 ZZZ_903\n#define gen_ashrhi3 ZZZ_904\n#define gen_ashrqi3 ZZZ_905\n#define gen_ashrsi3 ZZZ_906\n#define gen_call ZZZ_907\n#define gen_call_value ZZZ_908\n#define gen_cmpmemsi ZZZ_909\n#define gen_cmpmemsi_1 ZZZ_910\n#define gen_cmpsf ZZZ_911\n#define gen_cmpsi ZZZ_912\n#define gen_divsf3 ZZZ_913\n#define gen_divsi3 ZZZ_914\n#define gen_extendhisi2 ZZZ_915\n#define gen_extendqihi2 ZZZ_916\n#define gen_extendqisi2 ZZZ_917\n#define gen_extendsfdf2 ZZZ_918\n#define gen_extendsidi2 ZZZ_919\n#define gen_extend_insn ZZZ_920\n#define gen_highpart ZZZ_921\n#define gen_highpart_mode ZZZ_922\n#define gen_lowpart_common ZZZ_924\n#define gen_lowpart_if_possible ZZZ_925\n#define gen_lowpart_SUBREG ZZZ_926\n#define gen_lshrdi3 ZZZ_927\n#define gen_lshrhi3 ZZZ_928\n#define gen_lshrqi3 ZZZ_929\n#define gen_lshrsi3 ZZZ_930\n#define gen_movdf ZZZ_931\n#define gen_movdi ZZZ_932\n#define gen_movsf ZZZ_933\n#define gen_movsi ZZZ_934\n#define gen_movstricthi ZZZ_935\n#define gen_movstrsi ZZZ_936\n#define gen_movstrsi_1 ZZZ_937\n#define gen_mulsf3 ZZZ_938\n#define gen_mulsi3 ZZZ_939\n#define gen_negsf2 ZZZ_940\n#define gen_negsi2 ZZZ_941\n#define gen_one_cmplhi2 ZZZ_942\n#define gen_one_cmplqi2 ZZZ_943\n#define gen_one_cmplsi2 ZZZ_944\n#define gen_rtvec ZZZ_945\n#define gen_rtvec_v ZZZ_946\n#define gen_rtx_CONST_INT ZZZ_947\n#define gen_rtx_CONST_VECTOR ZZZ_948\n#define gen_rtx_fmt_ ZZZ_949\n#define gen_rtx_fmt_0 ZZZ_950\n#define gen_rtx_fmt_bi ZZZ_951\n#define gen_rtx_fmt_E ZZZ_952\n#define gen_rtx_fmt_e ZZZ_953\n#define gen_rtx_fmt_e0 ZZZ_954\n#define gen_rtx_fmt_Ee ZZZ_955\n#define gen_rtx_fmt_eE ZZZ_956\n#define gen_rtx_fmt_ee ZZZ_957\n#define gen_rtx_fmt_eee ZZZ_958\n#define gen_rtx_fmt_eEee0 ZZZ_959\n#define gen_rtx_fmt_eeeee ZZZ_960\n#define gen_rtx_fmt_Ei ZZZ_961\n#define gen_rtx_fmt_ei ZZZ_962\n#define gen_rtx_fmt_eit ZZZ_963\n#define gen_rtx_fmt_Ess ZZZ_964\n#define gen_rtx_fmt_eti ZZZ_965\n#define gen_rtx_fmt_i ZZZ_966\n#define gen_rtx_fmt_i00 ZZZ_967\n#define gen_rtx_fmt_iE ZZZ_968\n#define gen_rtx_fmt_ii ZZZ_969\n#define gen_rtx_fmt_iiiiiiiitt ZZZ_970\n#define gen_rtx_fmt_is ZZZ_971\n#define gen_rtx_fmt_isE ZZZ_972\n#define gen_rtx_fmt_iss ZZZ_973\n#define gen_rtx_fmt_iuu000000 ZZZ_974\n#define gen_rtx_fmt_iuuB00is ZZZ_975\n#define gen_rtx_fmt_iuuBieiee ZZZ_976\n#define gen_rtx_fmt_iuuBieiee0 ZZZ_977\n#define gen_rtx_fmt_iuuBieieee ZZZ_978\n#define gen_rtx_fmt_s ZZZ_979\n#define gen_rtx_fmt_s00 ZZZ_980\n#define gen_rtx_fmt_sE ZZZ_981\n#define gen_rtx_fmt_sEss ZZZ_982\n#define gen_rtx_fmt_sies ZZZ_983\n#define gen_rtx_fmt_ss ZZZ_984\n#define gen_rtx_fmt_sse ZZZ_985\n#define gen_rtx_fmt_ssiEEsi ZZZ_986\n#define gen_rtx_fmt_u00 ZZZ_987\n#define gen_rtx_fmt_ue ZZZ_988\n#define gen_rtx_fmt_uuEiiiiiibbii ZZZ_989\n#define gen_rtx_fmt_uuuu ZZZ_990\n#define gen_rtx_fmt_w ZZZ_991\n#define gen_rtx_MEM ZZZ_992\n#define gen_rtx_REG ZZZ_993\n#define gen_rtx_REG_offset ZZZ_994\n#define gen_rtx_SUBREG ZZZ_995\n#define gen_subsf3 ZZZ_996\n#define gen_subsi3 ZZZ_997\n#define gen_truncdfsf2 ZZZ_998\n#define gen_truncsihi2 ZZZ_999\n#define gen_tstdf ZZZ_1000\n#define gen_tstdi ZZZ_1001\n#define gen_tstsf ZZZ_1002\n#define gen_tstsi ZZZ_1003\n#define gen_zero_extendhisi2 ZZZ_1004\n#define gen_zero_extendqihi2 ZZZ_1005\n#define gen_zero_extendqisi2 ZZZ_1006\n#define gen_zero_extendsidi2 ZZZ_1007\n#define getopt_long ZZZ_1008\n#define getopt_long_only ZZZ_1009\n#define get_condition ZZZ_1010\n#define get_condition_for_loop ZZZ_1011\n#define get_fileinfo ZZZ_1012\n#define get_file_function_name ZZZ_1013\n#define get_file_function_name_long ZZZ_1014\n#define get_first_label_num ZZZ_1015\n#define get_first_nonnote_insn ZZZ_1016\n#define get_first_nonparm_insn ZZZ_1017\n#define get_frame_alias_set ZZZ_1018\n#define get_frame_size ZZZ_1019\n#define get_func_frame_size ZZZ_1020\n#define get_func_hard_reg_initial_val ZZZ_1021\n#define get_hard_reg_initial_reg ZZZ_1022\n#define get_hard_reg_initial_val ZZZ_1023\n#define get_identifier_with_length ZZZ_1025\n#define get_inner_array_type ZZZ_1026\n#define get_inner_reference ZZZ_1027\n#define get_insns ZZZ_1028\n#define get_insn_name ZZZ_1029\n#define get_insn_template ZZZ_1030\n#define get_label_after ZZZ_1031\n#define get_label_before ZZZ_1032\n#define get_label_from_map ZZZ_1033\n#define get_last_insn ZZZ_1034\n#define get_last_insn_anywhere ZZZ_1035\n#define get_last_nonnote_insn ZZZ_1036\n#define get_loop_body ZZZ_1037\n#define get_loop_exit_edges ZZZ_1038\n#define get_pool_constant ZZZ_1039\n#define get_pool_constant_for_function ZZZ_1040\n#define get_pool_constant_mark ZZZ_1041\n#define get_pool_mode ZZZ_1042\n#define get_pool_mode_for_function ZZZ_1043\n#define get_pool_offset ZZZ_1044\n#define get_pool_size ZZZ_1045\n#define get_reg_known_equiv_p ZZZ_1046\n#define get_reg_known_value ZZZ_1047\n#define get_set_constructor_bits ZZZ_1048\n#define get_set_constructor_bytes ZZZ_1049\n#define ggc_alloc ZZZ_1050\n#define ggc_alloc_cleared ZZZ_1051\n#define ggc_alloc_string ZZZ_1052\n#define ggc_alloc_typed ZZZ_1053\n#define ggc_alloc_zone ZZZ_1054\n#define ggc_marked_p ZZZ_1055\n#define ggc_mark_roots ZZZ_1056\n#define ggc_mark_stringpool ZZZ_1057\n#define ggc_min_expand_heuristic ZZZ_1058\n#define ggc_min_heapsize_heuristic ZZZ_1059\n#define ggc_pch_alloc_object ZZZ_1060\n#define ggc_pch_count_object ZZZ_1061\n#define ggc_pch_finish ZZZ_1062\n#define ggc_pch_prepare_write ZZZ_1063\n#define ggc_pch_read ZZZ_1064\n#define ggc_pch_this_base ZZZ_1065\n#define ggc_pch_total_size ZZZ_1066\n#define ggc_pch_write_object ZZZ_1067\n#define ggc_print_common_statistics ZZZ_1068\n#define ggc_print_statistics ZZZ_1069\n#define ggc_splay_alloc ZZZ_1070\n#define ggc_splay_dont_free ZZZ_1071\n#define global_regs ZZZ_1072\n#define global_reg_mentioned_p ZZZ_1073\n#define global_rtl ZZZ_1074\n#define groktypename ZZZ_1075\n#define groktypename_in_parm_context ZZZ_1076\n#define gt_ggc_mx_alias_set_entry ZZZ_1077\n#define gt_ggc_mx_align_stack ZZZ_1078\n#define gt_ggc_mx_bitmap_element_def ZZZ_1079\n#define gt_ggc_mx_bitmap_head_def ZZZ_1080\n#define gt_ggc_mx_case_node ZZZ_1081\n#define gt_ggc_mx_cgraph_edge ZZZ_1082\n#define gt_ggc_mx_cgraph_node ZZZ_1083\n#define gt_ggc_mx_cgraph_varpool_node ZZZ_1084\n#define gt_ggc_mx_constant_descriptor_rtx ZZZ_1085\n#define gt_ggc_mx_constant_descriptor_tree ZZZ_1086\n#define gt_ggc_mx_convert_optab ZZZ_1087\n#define gt_ggc_mx_cselib_val_struct ZZZ_1088\n#define gt_ggc_mx_c_scope ZZZ_1089\n#define gt_ggc_mx_die_struct ZZZ_1090\n#define gt_ggc_mx_dw_attr_struct ZZZ_1091\n#define gt_ggc_mx_dw_cfi_struct ZZZ_1092\n#define gt_ggc_mx_dw_fde_struct ZZZ_1093\n#define gt_ggc_mx_dw_line_info_struct ZZZ_1094\n#define gt_ggc_mx_dw_loc_descr_struct ZZZ_1095\n#define gt_ggc_mx_dw_loc_list_struct ZZZ_1096\n#define gt_ggc_mx_dw_ranges_struct ZZZ_1097\n#define gt_ggc_mx_dw_separate_line_info_struct ZZZ_1098\n#define gt_ggc_mx_ehl_map_entry ZZZ_1099\n#define gt_ggc_mx_eh_region ZZZ_1100\n#define gt_ggc_mx_eh_status ZZZ_1101\n#define gt_ggc_mx_elt_list ZZZ_1102\n#define gt_ggc_mx_elt_loc_list ZZZ_1103\n#define gt_ggc_mx_emit_status ZZZ_1104\n#define gt_ggc_mx_expr_status ZZZ_1105\n#define gt_ggc_mx_function ZZZ_1106\n#define gt_ggc_mx_goto_fixup ZZZ_1107\n#define gt_ggc_mx_indirect_string_node ZZZ_1108\n#define gt_ggc_mx_initial_value_struct ZZZ_1109\n#define gt_ggc_mx_in_named_entry ZZZ_1110\n#define gt_ggc_mx_label_chain ZZZ_1111\n#define gt_ggc_mx_language_function ZZZ_1112\n#define gt_ggc_mx_lang_decl ZZZ_1113\n#define gt_ggc_mx_lang_tree_node ZZZ_1114\n#define gt_ggc_mx_lang_type ZZZ_1115\n#define gt_ggc_mx_limbo_die_struct ZZZ_1116\n#define gt_ggc_mx_mem_attrs ZZZ_1117\n#define gt_ggc_mx_nesting ZZZ_1118\n#define gt_ggc_mx_optab ZZZ_1119\n#define gt_ggc_mx_output_def_pair ZZZ_1120\n#define gt_ggc_mx_pool_constant ZZZ_1121\n#define gt_ggc_mx_pubname_struct ZZZ_1122\n#define gt_ggc_mx_queued_reg_save ZZZ_1123\n#define gt_ggc_mx_real_value ZZZ_1124\n#define gt_ggc_mx_reg_attrs ZZZ_1125\n#define gt_ggc_mx_rtvec_def ZZZ_1126\n#define gt_ggc_mx_rtx_def ZZZ_1127\n#define gt_ggc_mx_sequence_stack ZZZ_1128\n#define gt_ggc_mx_sorted_fields_type ZZZ_1129\n#define gt_ggc_mx_stmt_status ZZZ_1130\n#define gt_ggc_mx_string_pool_data ZZZ_1131\n#define gt_ggc_mx_temp_slot ZZZ_1132\n#define gt_ggc_mx_typeinfo ZZZ_1133\n#define gt_ggc_mx_type_hash ZZZ_1134\n#define gt_ggc_mx_varasm_status ZZZ_1135\n#define gt_ggc_mx_varray_head_tag ZZZ_1136\n#define gt_ggc_mx_var_refs_queue ZZZ_1137\n#define gt_ggc_m_II12splay_tree_s ZZZ_1138\n#define gt_ggc_m_II17splay_tree_node_s ZZZ_1139\n#define gt_ggc_m_P11cgraph_node4htab ZZZ_1140\n#define gt_ggc_m_P13ehl_map_entry4htab ZZZ_1141\n#define gt_ggc_m_P14in_named_entry4htab ZZZ_1142\n#define gt_ggc_m_P15alias_set_entry15varray_head_tag ZZZ_1143\n#define gt_ggc_m_P15output_def_pair15varray_head_tag ZZZ_1144\n#define gt_ggc_m_P17cselib_val_struct4htab ZZZ_1145\n#define gt_ggc_m_P19cgraph_varpool_node4htab ZZZ_1146\n#define gt_ggc_m_P20indirect_string_node4htab ZZZ_1147\n#define gt_ggc_m_P24constant_descriptor_tree4htab ZZZ_1148\n#define gt_ggc_m_P7rtx_def4htab ZZZ_1149\n#define gt_ggc_m_P9mem_attrs4htab ZZZ_1150\n#define gt_ggc_m_P9reg_attrs4htab ZZZ_1151\n#define gt_ggc_m_P9tree_node4htab ZZZ_1152\n#define gt_ggc_m_P9type_hash4htab ZZZ_1153\n#define gt_ggc_m_S ZZZ_1154\n#define gt_ggc_m_SP9tree_node12splay_tree_s ZZZ_1155\n#define gt_ggc_m_SP9tree_node17splay_tree_node_s ZZZ_1156\n#define gt_ggc_rc_gt_emit_rtl_h ZZZ_1157\n#define gt_ggc_rc_gt_fold_const_h ZZZ_1158\n#define gt_ggc_rc_gt_tree_h ZZZ_1159\n#define gt_ggc_rd_gt_alias_h ZZZ_1160\n#define gt_ggc_rd_gt_bitmap_h ZZZ_1161\n#define gt_ggc_rd_gt_cselib_h ZZZ_1162\n#define gt_ggc_rd_gt_c_decl_h ZZZ_1163\n#define gt_ggc_rd_gt_emit_rtl_h ZZZ_1164\n#define gt_ggc_rd_gt_lists_h ZZZ_1165\n#define gt_ggc_rtab ZZZ_1166\n#define gt_ggc_r_gtype_desc_c ZZZ_1167\n#define gt_ggc_r_gt_alias_h ZZZ_1168\n#define gt_ggc_r_gt_cfglayout_h ZZZ_1169\n#define gt_ggc_r_gt_cgraph_h ZZZ_1170\n#define gt_ggc_r_gt_coverage_h ZZZ_1171\n#define gt_ggc_r_gt_cselib_h ZZZ_1172\n#define gt_ggc_r_gt_c_common_h ZZZ_1173\n#define gt_ggc_r_gt_c_decl_h ZZZ_1174\n#define gt_ggc_r_gt_c_parse_h ZZZ_1175\n#define gt_ggc_r_gt_c_pragma_h ZZZ_1176\n#define gt_ggc_r_gt_dbxout_h ZZZ_1177\n#define gt_ggc_r_gt_dojump_h ZZZ_1178\n#define gt_ggc_r_gt_dwarf2asm_h ZZZ_1179\n#define gt_ggc_r_gt_dwarf2out_h ZZZ_1180\n#define gt_ggc_r_gt_emit_rtl_h ZZZ_1181\n#define gt_ggc_r_gt_except_h ZZZ_1182\n#define gt_ggc_r_gt_explow_h ZZZ_1183\n#define gt_ggc_r_gt_expr_h ZZZ_1184\n#define gt_ggc_r_gt_fold_const_h ZZZ_1185\n#define gt_ggc_r_gt_function_h ZZZ_1186\n#define gt_ggc_r_gt_gcse_h ZZZ_1187\n#define gt_ggc_r_gt_integrate_h ZZZ_1188\n#define gt_ggc_r_gt_langhooks_h ZZZ_1189\n#define gt_ggc_r_gt_optabs_h ZZZ_1190\n#define gt_ggc_r_gt_ra_build_h ZZZ_1191\n#define gt_ggc_r_gt_regclass_h ZZZ_1192\n#define gt_ggc_r_gt_reg_stack_h ZZZ_1193\n#define gt_ggc_r_gt_sdbout_h ZZZ_1194\n#define gt_ggc_r_gt_stor_layout_h ZZZ_1195\n#define gt_ggc_r_gt_stringpool_h ZZZ_1196\n#define gt_ggc_r_gt_tree_h ZZZ_1197\n#define gt_ggc_r_gt_varasm_h ZZZ_1198\n#define gt_pch_note_object ZZZ_1199\n#define gt_pch_note_reorder ZZZ_1200\n#define gt_pch_nx_alias_set_entry ZZZ_1201\n#define gt_pch_nx_align_stack ZZZ_1202\n#define gt_pch_nx_bitmap_element_def ZZZ_1203\n#define gt_pch_nx_bitmap_head_def ZZZ_1204\n#define gt_pch_nx_case_node ZZZ_1205\n#define gt_pch_nx_cgraph_edge ZZZ_1206\n#define gt_pch_nx_cgraph_node ZZZ_1207\n#define gt_pch_nx_cgraph_varpool_node ZZZ_1208\n#define gt_pch_nx_constant_descriptor_rtx ZZZ_1209\n#define gt_pch_nx_constant_descriptor_tree ZZZ_1210\n#define gt_pch_nx_convert_optab ZZZ_1211\n#define gt_pch_nx_cselib_val_struct ZZZ_1212\n#define gt_pch_nx_c_scope ZZZ_1213\n#define gt_pch_nx_die_struct ZZZ_1214\n#define gt_pch_nx_dw_attr_struct ZZZ_1215\n#define gt_pch_nx_dw_cfi_struct ZZZ_1216\n#define gt_pch_nx_dw_fde_struct ZZZ_1217\n#define gt_pch_nx_dw_line_info_struct ZZZ_1218\n#define gt_pch_nx_dw_loc_descr_struct ZZZ_1219\n#define gt_pch_nx_dw_loc_list_struct ZZZ_1220\n#define gt_pch_nx_dw_ranges_struct ZZZ_1221\n#define gt_pch_nx_dw_separate_line_info_struct ZZZ_1222\n#define gt_pch_nx_ehl_map_entry ZZZ_1223\n#define gt_pch_nx_eh_region ZZZ_1224\n#define gt_pch_nx_eh_status ZZZ_1225\n#define gt_pch_nx_elt_list ZZZ_1226\n#define gt_pch_nx_elt_loc_list ZZZ_1227\n#define gt_pch_nx_emit_status ZZZ_1228\n#define gt_pch_nx_expr_status ZZZ_1229\n#define gt_pch_nx_function ZZZ_1230\n#define gt_pch_nx_goto_fixup ZZZ_1231\n#define gt_pch_nx_indirect_string_node ZZZ_1232\n#define gt_pch_nx_initial_value_struct ZZZ_1233\n#define gt_pch_nx_in_named_entry ZZZ_1234\n#define gt_pch_nx_label_chain ZZZ_1235\n#define gt_pch_nx_language_function ZZZ_1236\n#define gt_pch_nx_lang_decl ZZZ_1237\n#define gt_pch_nx_lang_tree_node ZZZ_1238\n#define gt_pch_nx_lang_type ZZZ_1239\n#define gt_pch_nx_limbo_die_struct ZZZ_1240\n#define gt_pch_nx_mem_attrs ZZZ_1241\n#define gt_pch_nx_nesting ZZZ_1242\n#define gt_pch_nx_optab ZZZ_1243\n#define gt_pch_nx_output_def_pair ZZZ_1244\n#define gt_pch_nx_pool_constant ZZZ_1245\n#define gt_pch_nx_pubname_struct ZZZ_1246\n#define gt_pch_nx_queued_reg_save ZZZ_1247\n#define gt_pch_nx_real_value ZZZ_1248\n#define gt_pch_nx_reg_attrs ZZZ_1249\n#define gt_pch_nx_rtvec_def ZZZ_1250\n#define gt_pch_nx_rtx_def ZZZ_1251\n#define gt_pch_nx_sequence_stack ZZZ_1252\n#define gt_pch_nx_sorted_fields_type ZZZ_1253\n#define gt_pch_nx_stmt_status ZZZ_1254\n#define gt_pch_nx_string_pool_data ZZZ_1255\n#define gt_pch_nx_temp_slot ZZZ_1256\n#define gt_pch_nx_typeinfo ZZZ_1257\n#define gt_pch_nx_type_hash ZZZ_1258\n#define gt_pch_nx_varasm_status ZZZ_1259\n#define gt_pch_nx_varray_head_tag ZZZ_1260\n#define gt_pch_nx_var_refs_queue ZZZ_1261\n#define gt_pch_n_II12splay_tree_s ZZZ_1262\n#define gt_pch_n_II17splay_tree_node_s ZZZ_1263\n#define gt_pch_n_P11cgraph_node4htab ZZZ_1264\n#define gt_pch_n_P13ehl_map_entry4htab ZZZ_1265\n#define gt_pch_n_P14in_named_entry4htab ZZZ_1266\n#define gt_pch_n_P15alias_set_entry15varray_head_tag ZZZ_1267\n#define gt_pch_n_P15output_def_pair15varray_head_tag ZZZ_1268\n#define gt_pch_n_P17cselib_val_struct4htab ZZZ_1269\n#define gt_pch_n_P19cgraph_varpool_node4htab ZZZ_1270\n#define gt_pch_n_P20indirect_string_node4htab ZZZ_1271\n#define gt_pch_n_P24constant_descriptor_tree4htab ZZZ_1272\n#define gt_pch_n_P7rtx_def4htab ZZZ_1273\n#define gt_pch_n_P9mem_attrs4htab ZZZ_1274\n#define gt_pch_n_P9reg_attrs4htab ZZZ_1275\n#define gt_pch_n_P9tree_node4htab ZZZ_1276\n#define gt_pch_n_P9type_hash4htab ZZZ_1277\n#define gt_pch_n_S ZZZ_1278\n#define gt_pch_n_SP9tree_node12splay_tree_s ZZZ_1279\n#define gt_pch_n_SP9tree_node17splay_tree_node_s ZZZ_1280\n#define gt_pch_p_10die_struct ZZZ_1281\n#define gt_pch_p_10goto_fixup ZZZ_1282\n#define gt_pch_p_10real_value ZZZ_1283\n#define gt_pch_p_11align_stack ZZZ_1284\n#define gt_pch_p_11cgraph_edge ZZZ_1285\n#define gt_pch_p_11cgraph_node ZZZ_1286\n#define gt_pch_p_11emit_status ZZZ_1287\n#define gt_pch_p_11expr_status ZZZ_1288\n#define gt_pch_p_11label_chain ZZZ_1289\n#define gt_pch_p_11stmt_status ZZZ_1290\n#define gt_pch_p_12elt_loc_list ZZZ_1291\n#define gt_pch_p_13convert_optab ZZZ_1292\n#define gt_pch_p_13dw_cfi_struct ZZZ_1293\n#define gt_pch_p_13dw_fde_struct ZZZ_1294\n#define gt_pch_p_13ehl_map_entry ZZZ_1295\n#define gt_pch_p_13pool_constant ZZZ_1296\n#define gt_pch_p_13varasm_status ZZZ_1297\n#define gt_pch_p_14dw_attr_struct ZZZ_1298\n#define gt_pch_p_14in_named_entry ZZZ_1299\n#define gt_pch_p_14lang_tree_node ZZZ_1300\n#define gt_pch_p_14pubname_struct ZZZ_1301\n#define gt_pch_p_14sequence_stack ZZZ_1302\n#define gt_pch_p_14var_refs_queue ZZZ_1303\n#define gt_pch_p_15alias_set_entry ZZZ_1304\n#define gt_pch_p_15bitmap_head_def ZZZ_1305\n#define gt_pch_p_15output_def_pair ZZZ_1306\n#define gt_pch_p_15queued_reg_save ZZZ_1307\n#define gt_pch_p_15varray_head_tag ZZZ_1308\n#define gt_pch_p_16dw_ranges_struct ZZZ_1309\n#define gt_pch_p_16limbo_die_struct ZZZ_1310\n#define gt_pch_p_16string_pool_data ZZZ_1311\n#define gt_pch_p_17cselib_val_struct ZZZ_1312\n#define gt_pch_p_17language_function ZZZ_1313\n#define gt_pch_p_18bitmap_element_def ZZZ_1314\n#define gt_pch_p_18dw_loc_list_struct ZZZ_1315\n#define gt_pch_p_18sorted_fields_type ZZZ_1316\n#define gt_pch_p_19cgraph_varpool_node ZZZ_1317\n#define gt_pch_p_19dw_line_info_struct ZZZ_1318\n#define gt_pch_p_19dw_loc_descr_struct ZZZ_1319\n#define gt_pch_p_20indirect_string_node ZZZ_1320\n#define gt_pch_p_20initial_value_struct ZZZ_1321\n#define gt_pch_p_23constant_descriptor_rtx ZZZ_1322\n#define gt_pch_p_24constant_descriptor_tree ZZZ_1323\n#define gt_pch_p_28dw_separate_line_info_struct ZZZ_1324\n#define gt_pch_p_5optab ZZZ_1325\n#define gt_pch_p_7c_scope ZZZ_1326\n#define gt_pch_p_7nesting ZZZ_1327\n#define gt_pch_p_7rtx_def ZZZ_1328\n#define gt_pch_p_8elt_list ZZZ_1329\n#define gt_pch_p_8function ZZZ_1330\n#define gt_pch_p_8typeinfo ZZZ_1331\n#define gt_pch_p_9case_node ZZZ_1332\n#define gt_pch_p_9eh_region ZZZ_1333\n#define gt_pch_p_9eh_status ZZZ_1334\n#define gt_pch_p_9lang_decl ZZZ_1335\n#define gt_pch_p_9lang_type ZZZ_1336\n#define gt_pch_p_9mem_attrs ZZZ_1337\n#define gt_pch_p_9reg_attrs ZZZ_1338\n#define gt_pch_p_9rtvec_def ZZZ_1339\n#define gt_pch_p_9temp_slot ZZZ_1340\n#define gt_pch_p_9type_hash ZZZ_1341\n#define gt_pch_p_II12splay_tree_s ZZZ_1342\n#define gt_pch_p_II17splay_tree_node_s ZZZ_1343\n#define gt_pch_p_P11cgraph_node4htab ZZZ_1344\n#define gt_pch_p_P13ehl_map_entry4htab ZZZ_1345\n#define gt_pch_p_P14in_named_entry4htab ZZZ_1346\n#define gt_pch_p_P15alias_set_entry15varray_head_tag ZZZ_1347\n#define gt_pch_p_P15output_def_pair15varray_head_tag ZZZ_1348\n#define gt_pch_p_P17cselib_val_struct4htab ZZZ_1349\n#define gt_pch_p_P19cgraph_varpool_node4htab ZZZ_1350\n#define gt_pch_p_P20indirect_string_node4htab ZZZ_1351\n#define gt_pch_p_P24constant_descriptor_tree4htab ZZZ_1352\n#define gt_pch_p_P7rtx_def4htab ZZZ_1353\n#define gt_pch_p_P9mem_attrs4htab ZZZ_1354\n#define gt_pch_p_P9reg_attrs4htab ZZZ_1355\n#define gt_pch_p_P9tree_node4htab ZZZ_1356\n#define gt_pch_p_P9type_hash4htab ZZZ_1357\n#define gt_pch_p_S ZZZ_1358\n#define gt_pch_p_SP9tree_node12splay_tree_s ZZZ_1359\n#define gt_pch_p_SP9tree_node17splay_tree_node_s ZZZ_1360\n#define gt_pch_rc_gt_emit_rtl_h ZZZ_1361\n#define gt_pch_rc_gt_fold_const_h ZZZ_1362\n#define gt_pch_rc_gt_tree_h ZZZ_1363\n#define gt_pch_restore ZZZ_1364\n#define gt_pch_restore_stringpool ZZZ_1365\n#define gt_pch_rs_gtype_desc_c ZZZ_1366\n#define gt_pch_rs_gt_alias_h ZZZ_1367\n#define gt_pch_rs_gt_c_decl_h ZZZ_1368\n#define gt_pch_rs_gt_dbxout_h ZZZ_1369\n#define gt_pch_rs_gt_dwarf2asm_h ZZZ_1370\n#define gt_pch_rs_gt_dwarf2out_h ZZZ_1371\n#define gt_pch_rs_gt_emit_rtl_h ZZZ_1372\n#define gt_pch_rs_gt_except_h ZZZ_1373\n#define gt_pch_rs_gt_function_h ZZZ_1374\n#define gt_pch_rs_gt_langhooks_h ZZZ_1375\n#define gt_pch_rs_gt_sdbout_h ZZZ_1376\n#define gt_pch_rs_gt_tree_h ZZZ_1377\n#define gt_pch_rs_gt_varasm_h ZZZ_1378\n#define gt_pch_save ZZZ_1379\n#define gt_pch_save_stringpool ZZZ_1380\n#define gt_pch_scalar_rtab ZZZ_1381\n#define g_switch_set ZZZ_1382\n#define g_switch_value ZZZ_1383\n#define handle_format_arg_attribute ZZZ_1384\n#define handle_format_attribute ZZZ_1385\n#define hard_regs_count ZZZ_1386\n#define hard_regs_intersect_p ZZZ_1387\n#define hoist_insn_after ZZZ_1388\n#define hoist_insn_to_edge ZZZ_1389\n#define hook_bool_bool_false ZZZ_1390\n#define hook_bool_constcharptr_size_t_false ZZZ_1391\n#define hook_bool_CUMULATIVE_ARGS_true ZZZ_1392\n#define hook_bool_machine_mode_true ZZZ_1393\n#define hook_bool_rtx_false ZZZ_1394\n#define hook_bool_rtx_int_int_intp_false ZZZ_1395\n#define hook_bool_tree_false ZZZ_1396\n#define hook_bool_tree_hwi_hwi_tree_false ZZZ_1397\n#define hook_bool_tree_hwi_hwi_tree_true ZZZ_1398\n#define hook_bool_tree_tree_false ZZZ_1399\n#define hook_bool_tree_true ZZZ_1400\n#define hook_bool_uintp_uintp_false ZZZ_1401\n#define hook_bool_void_false ZZZ_1402\n#define hook_int_rtx_0 ZZZ_1403\n#define hook_int_size_t_constcharptr_int_0 ZZZ_1404\n#define hook_int_tree_tree_1 ZZZ_1405\n#define hook_int_void_0 ZZZ_1406\n#define hook_int_void_no_regs ZZZ_1407\n#define hook_rtx_rtx_identity ZZZ_1408\n#define hook_rtx_rtx_null ZZZ_1409\n#define hook_rtx_tree_int_null ZZZ_1410\n#define hook_void_constcharptr ZZZ_1411\n#define hook_void_FILEptr_constcharptr ZZZ_1412\n#define hook_void_tree ZZZ_1413\n#define hook_void_tree_int ZZZ_1414\n#define hook_void_tree_treeptr ZZZ_1415\n#define hook_void_void ZZZ_1416\n#define htab_create_alloc ZZZ_1418\n#define htab_create_alloc_ex ZZZ_1419\n#define htab_find ZZZ_1420\n#define htab_find_slot ZZZ_1421\n#define htab_find_slot_with_hash ZZZ_1422\n#define htab_find_with_hash ZZZ_1423\n#define htab_hash_pointer ZZZ_1424\n#define htab_hash_string ZZZ_1425\n#define htab_traverse ZZZ_1426\n#define htab_traverse_noresize ZZZ_1427\n#define i370_branch_dest ZZZ_1428\n#define i370_branch_length ZZZ_1429\n#define i370_pr_checkout ZZZ_1430\n#define i370_pr_linkage ZZZ_1431\n#define i370_pr_map ZZZ_1432\n#define i370_pr_skipit ZZZ_1433\n#define ieee_extended_intel_128_format ZZZ_1434\n#define ieee_extended_intel_96_format ZZZ_1435\n#define ieee_extended_intel_96_round_53_format ZZZ_1436\n#define ieee_extended_motorola_format ZZZ_1437\n#define immediate_operand ZZZ_1438\n#define immediate_size_expand ZZZ_1439\n#define implicitly_declare ZZZ_1440\n#define implicit_built_in_decls ZZZ_1441\n#define indirect_operand ZZZ_1442\n#define indirect_symref_ok ZZZ_1443\n#define initializer_constant_valid_p ZZZ_1444\n#define initializer_stack ZZZ_1445\n#define initializer_zerop ZZZ_1446\n#define initialize_sizetypes ZZZ_1447\n#define initialize_uninitialized_subregs ZZZ_1448\n#define init_alias_analysis ZZZ_1449\n#define init_alias_once ZZZ_1450\n#define init_block_clear_fn ZZZ_1451\n#define init_block_move_fn ZZZ_1452\n#define init_emit ZZZ_1453\n#define init_emit_once ZZZ_1454\n#define init_expmed ZZZ_1455\n#define init_expr ZZZ_1456\n#define init_expr_once ZZZ_1457\n#define init_function_for_compilation ZZZ_1458\n#define init_function_once ZZZ_1459\n#define init_function_start ZZZ_1460\n#define init_ggc ZZZ_1461\n#define init_ggc_heuristics ZZZ_1462\n#define init_ggc_pch ZZZ_1463\n#define init_recog ZZZ_1464\n#define init_recog_no_volatile ZZZ_1465\n#define init_regs ZZZ_1466\n#define init_reg_modes_once ZZZ_1467\n#define init_reg_sets ZZZ_1468\n#define init_varasm_once ZZZ_1469\n#define init_varasm_status ZZZ_1470\n#define input_filename_length ZZZ_1471\n#define input_file_stack ZZZ_1472\n#define input_file_stack_tick ZZZ_1473\n#define insn_current_address ZZZ_1474\n#define insn_current_align ZZZ_1475\n#define insn_current_length ZZZ_1476\n#define insn_current_reference_address ZZZ_1477\n#define integer_all_onesp ZZZ_1478\n#define integer_asm_op ZZZ_1479\n#define integer_nonzerop ZZZ_1480\n#define integer_onep ZZZ_1481\n#define integer_pow2p ZZZ_1482\n#define integer_types ZZZ_1483\n#define integer_zerop ZZZ_1484\n#define internal_error ZZZ_1485\n#define internal_reference_types ZZZ_1486\n#define invert_jump ZZZ_1487\n#define invert_jump_1 ZZZ_1488\n#define is_gnu_v3_mangled_ctor ZZZ_1489\n#define is_gnu_v3_mangled_dtor ZZZ_1490\n#define iterative_dataflow_bitmap ZZZ_1491\n#define iterative_dataflow_sbitmap ZZZ_1492\n#define iterative_hash ZZZ_1493\n#define iterative_hash_expr ZZZ_1494\n#define lang_eh_runtime_type ZZZ_1495\n#define lang_eh_type_covers ZZZ_1496\n#define lang_expand_decl_stmt ZZZ_1497\n#define lang_expand_function_end ZZZ_1498\n#define lang_expand_stmt ZZZ_1499\n#define lang_specific_driver ZZZ_1500\n#define lang_specific_extra_outfiles ZZZ_1501\n#define lang_specific_pre_link ZZZ_1502\n#define lang_specific_spec_functions ZZZ_1503\n#define lhd_decl_ok_for_sibcall ZZZ_1504\n#define lhd_decl_printable_name ZZZ_1505\n#define lhd_decl_uninit ZZZ_1506\n#define lhd_do_nothing ZZZ_1507\n#define lhd_do_nothing_f ZZZ_1508\n#define lhd_do_nothing_i ZZZ_1509\n#define lhd_do_nothing_iii_return_null_tree ZZZ_1510\n#define lhd_do_nothing_t ZZZ_1511\n#define lhd_print_error_function ZZZ_1512\n#define lhd_print_tree_nothing ZZZ_1513\n#define lhd_return_null_tree ZZZ_1514\n#define lhd_return_null_tree_v ZZZ_1515\n#define lhd_return_tree ZZZ_1516\n#define lhd_tree_dump_dump_tree ZZZ_1517\n#define lhd_tree_dump_type_quals ZZZ_1518\n#define lhd_tree_inlining_add_pending_fn_decls ZZZ_1519\n#define lhd_tree_inlining_anon_aggr_type_p ZZZ_1520\n#define lhd_tree_inlining_auto_var_in_fn_p ZZZ_1521\n#define lhd_tree_inlining_cannot_inline_tree_fn ZZZ_1522\n#define lhd_tree_inlining_convert_parm_for_inlining ZZZ_1523\n#define lhd_tree_inlining_copy_res_decl_for_inlining ZZZ_1524\n#define lhd_tree_inlining_disregard_inline_limits ZZZ_1525\n#define lhd_tree_inlining_end_inlining ZZZ_1526\n#define lhd_tree_inlining_start_inlining ZZZ_1527\n#define lhd_tree_inlining_tree_chain_matters_p ZZZ_1528\n#define lhd_tree_inlining_walk_subtrees ZZZ_1529\n#define lhd_tree_size ZZZ_1530\n#define lhd_unsafe_for_reeval ZZZ_1531\n#define lhd_unsave_expr_now ZZZ_1532\n#define libiberty_concat_ptr ZZZ_1533\n#define libiberty_demanglers ZZZ_1534\n#define libiberty_len ZZZ_1535\n#define libiberty_nptr ZZZ_1536\n#define libiberty_optr ZZZ_1537\n#define linemap_add ZZZ_1538\n#define linemap_free ZZZ_1539\n#define linemap_init ZZZ_1540\n#define linemap_lookup ZZZ_1541\n#define linemap_print_containing_files ZZZ_1542\n#define locator_file ZZZ_1543\n#define locator_line ZZZ_1544\n#define loop_insn_emit_before ZZZ_1545\n#define loop_insn_first_p ZZZ_1546\n#define loop_insn_hoist ZZZ_1547\n#define loop_insn_sink ZZZ_1548\n#define loop_iv_add_mult_emit_before ZZZ_1549\n#define loop_iv_add_mult_hoist ZZZ_1550\n#define loop_iv_add_mult_sink ZZZ_1551\n#define loop_optimize ZZZ_1552\n#define loop_optimizer_finalize ZZZ_1553\n#define loop_optimizer_init ZZZ_1554\n#define make_decl_one_only ZZZ_1555\n#define make_decl_rtl ZZZ_1556\n#define make_tree ZZZ_1557\n#define make_tree_vec ZZZ_1558\n#define mark_referenced ZZZ_1559\n#define mark_referenced_resources ZZZ_1560\n#define max_entry_count ZZZ_1561\n#define max_entry_frequency ZZZ_1562\n#define max_reg_before_loop ZZZ_1563\n#define max_reg_num ZZZ_1564\n#define maybe_apply_pragma_weak ZZZ_1565\n#define maybe_apply_renaming_pragma ZZZ_1566\n#define md5_process_block ZZZ_1567\n#define md5_process_bytes ZZZ_1568\n#define memory_address ZZZ_1569\n#define memory_address_noforce ZZZ_1570\n#define memory_address_p ZZZ_1571\n#define mergeable_constant_section ZZZ_1572\n#define mergeable_string_section ZZZ_1573\n#define mode_for_extraction ZZZ_1574\n#define mode_for_size ZZZ_1575\n#define mode_for_size_tree ZZZ_1576\n#define modified_between_p ZZZ_1577\n#define modified_in_p ZZZ_1578\n#define move_block_from_reg ZZZ_1579\n#define move_block_to_reg ZZZ_1580\n#define mvs_add_alias ZZZ_1581\n#define mvs_add_label ZZZ_1582\n#define mvs_check_alias ZZZ_1583\n#define mvs_check_label ZZZ_1584\n#define mvs_check_page ZZZ_1585\n#define mvs_function_check ZZZ_1586\n#define mvs_function_name ZZZ_1587\n#define mvs_function_name_length ZZZ_1588\n#define mvs_need_alias ZZZ_1589\n#define mvs_need_base_reload ZZZ_1590\n#define mvs_need_entry ZZZ_1591\n#define mvs_need_to_globalize ZZZ_1592\n#define mvs_page_code ZZZ_1593\n#define mvs_page_lit ZZZ_1594\n#define mvs_page_num ZZZ_1595\n#define named_section ZZZ_1596\n#define named_section_eh_frame_section ZZZ_1597\n#define named_section_first_declaration ZZZ_1598\n#define named_section_flags ZZZ_1599\n#define next_insn ZZZ_1600\n#define next_insn_tests_no_inequality ZZZ_1601\n#define normalize_offset ZZZ_1602\n#define normalize_rli ZZZ_1603\n#define objalloc_create ZZZ_1604\n#define objalloc_free ZZZ_1605\n#define objalloc_free_block ZZZ_1606\n#define obstack_alloc_failed_handler ZZZ_1607\n#define obstack_exit_failure ZZZ_1608\n#define offsettable_address_p ZZZ_1610\n#define offsettable_memref_p ZZZ_1611\n#define offsettable_nonstrict_memref_p ZZZ_1612\n#define operand_equal_p ZZZ_1613\n#define operand_subword ZZZ_1614\n#define operand_subword_force ZZZ_1615\n#define optimize ZZZ_1616\n#define optimize_inline_calls ZZZ_1617\n#define optimize_sibling_and_tail_recursive_calls ZZZ_1618\n#define optimize_size ZZZ_1619\n#define optimize_tail_recursion ZZZ_1620\n#define output_address ZZZ_1621\n#define output_addr_const ZZZ_1622\n#define output_asm_insn ZZZ_1623\n#define output_asm_label ZZZ_1624\n#define output_constant ZZZ_1625\n#define output_constant_def ZZZ_1626\n#define output_constant_pool ZZZ_1627\n#define output_file_directive ZZZ_1628\n#define output_function_exception_table ZZZ_1629\n#define parse_in ZZZ_1630\n#define parse_input_constraint ZZZ_1631\n#define partition_delete ZZZ_1632\n#define partition_new ZZZ_1633\n#define partition_print ZZZ_1634\n#define partition_union ZZZ_1635\n#define pedantic ZZZ_1636\n#define pedantic_lvalues ZZZ_1637\n#define pedantic_non_lvalue ZZZ_1638\n#define pedwarn_c90 ZZZ_1639\n#define pedwarn_c99 ZZZ_1640\n#define pedwarn_init ZZZ_1641\n#define pending_invalid_xref ZZZ_1642\n#define pending_invalid_xref_location ZZZ_1643\n#define pending_lang_change ZZZ_1644\n#define pending_xref_error ZZZ_1645\n#define physmem_available ZZZ_1646\n#define physmem_total ZZZ_1647\n#define pop_function_context ZZZ_1648\n#define pop_function_context_from ZZZ_1649\n#define pp_base_append_text ZZZ_1650\n#define pp_base_character ZZZ_1651\n#define pp_base_clear_output_area ZZZ_1652\n#define pp_base_destroy_prefix ZZZ_1653\n#define pp_base_emit_prefix ZZZ_1654\n#define pp_base_flush ZZZ_1655\n#define pp_base_formatted_text ZZZ_1656\n#define pp_base_format_text ZZZ_1657\n#define pp_base_format_verbatim ZZZ_1658\n#define pp_base_indent ZZZ_1659\n#define pp_base_last_position_in_text ZZZ_1660\n#define pp_base_newline ZZZ_1661\n#define pp_base_remaining_character_count_for_line ZZZ_1662\n#define pp_base_set_line_maximum_length ZZZ_1663\n#define pp_base_set_prefix ZZZ_1664\n#define pp_base_string ZZZ_1665\n#define pp_c_declaration ZZZ_1666\n#define pp_c_declaration_specifiers ZZZ_1667\n#define pp_c_declarator ZZZ_1668\n#define pp_c_direct_abstract_declarator ZZZ_1669\n#define pp_c_direct_declarator ZZZ_1670\n#define pp_c_expression ZZZ_1671\n#define pp_c_expression_list ZZZ_1672\n#define pp_c_function_definition ZZZ_1673\n#define pp_c_function_specifier ZZZ_1674\n#define pp_c_left_brace ZZZ_1675\n#define pp_c_left_paren ZZZ_1676\n#define pp_c_right_brace ZZZ_1677\n#define pp_c_right_paren ZZZ_1678\n#define pp_c_type_id ZZZ_1679\n#define pp_c_type_qualifier_list ZZZ_1680\n#define pp_c_type_specifier ZZZ_1681\n#define predict_edge ZZZ_1682\n#define predict_edge_def ZZZ_1683\n#define predict_insn ZZZ_1684\n#define predict_insn_def ZZZ_1685\n#define prepare_call_address ZZZ_1686\n#define prepare_operand ZZZ_1687\n#define preprocess_constraints ZZZ_1688\n#define preprocess_file ZZZ_1689\n#define preserve_rtl_expr_result ZZZ_1690\n#define preserve_subexpressions_p ZZZ_1691\n#define preserve_temp_slots ZZZ_1692\n#define pre_edge_lcm ZZZ_1693\n#define pre_edge_rev_lcm ZZZ_1694\n#define print_node ZZZ_1695\n#define print_node_brief ZZZ_1696\n#define print_rtl ZZZ_1697\n#define print_rtl_graph_with_bb ZZZ_1698\n#define print_rtl_single ZZZ_1699\n#define print_rtl_with_bb ZZZ_1700\n#define print_rtx_head ZZZ_1701\n#define probably_cold_bb_p ZZZ_1702\n#define probably_never_executed_bb_p ZZZ_1703\n#define process_init_element ZZZ_1704\n#define process_pending_assemble_output_defs ZZZ_1705\n#define profile_arc_flag ZZZ_1706\n#define profile_flag ZZZ_1707\n#define profile_info ZZZ_1708\n#define prologue_epilogue_contains ZZZ_1709\n#define prologue_locator ZZZ_1710\n#define propagate_block ZZZ_1711\n#define propagate_one_insn ZZZ_1712\n#define pushcase ZZZ_1713\n#define pushcase_range ZZZ_1714\n#define pushdecl ZZZ_1715\n#define pushdecl_top_level ZZZ_1716\n#define push_function_context ZZZ_1717\n#define push_function_context_to ZZZ_1718\n#define push_to_full_sequence ZZZ_1719\n#define push_to_sequence ZZZ_1720\n#define put_pending_size ZZZ_1721\n#define put_pending_sizes ZZZ_1722\n#define queue_and_dump_index ZZZ_1723\n#define queue_and_dump_type ZZZ_1724\n#define ra_build_free ZZZ_1725\n#define ra_build_free_all ZZZ_1726\n#define ra_build_realloc ZZZ_1727\n#define ra_colorize_free_all ZZZ_1728\n#define ra_colorize_graph ZZZ_1729\n#define ra_colorize_init ZZZ_1730\n#define ra_debug_bbi ZZZ_1731\n#define ra_debug_insns ZZZ_1732\n#define ra_debug_msg ZZZ_1733\n#define ra_debug_rtx ZZZ_1734\n#define ra_print_rtl_with_bb ZZZ_1735\n#define ra_print_rtx ZZZ_1736\n#define ra_print_rtx_top ZZZ_1737\n#define readonly_data_section ZZZ_1738\n#define readonly_error ZZZ_1739\n#define readonly_fields_p ZZZ_1740\n#define real_arithmetic ZZZ_1741\n#define real_arithmetic2 ZZZ_1742\n#define real_from_integer ZZZ_1743\n#define real_from_string ZZZ_1744\n#define real_from_string2 ZZZ_1745\n#define real_from_target ZZZ_1746\n#define real_from_target_fmt ZZZ_1747\n#define real_isnan ZZZ_1748\n#define real_isneg ZZZ_1749\n#define real_isnegzero ZZZ_1750\n#define real_to_decimal ZZZ_1751\n#define real_to_hexadecimal ZZZ_1752\n#define real_to_integer ZZZ_1753\n#define real_to_integer2 ZZZ_1754\n#define real_to_target ZZZ_1755\n#define real_to_target_fmt ZZZ_1756\n#define real_value_from_int_cst ZZZ_1757\n#define real_value_truncate ZZZ_1758\n#define record_base_value ZZZ_1759\n#define record_builtin_type ZZZ_1760\n#define record_component_aliases ZZZ_1761\n#define record_conflict ZZZ_1762\n#define redirect_edge_pred ZZZ_1763\n#define redirect_edge_succ ZZZ_1764\n#define redirect_edge_succ_nodup ZZZ_1765\n#define redirect_immediate_dominators ZZZ_1766\n#define redirect_jump ZZZ_1767\n#define redirect_jump_1 ZZZ_1768\n#define refers_to_mem_for_reload_p ZZZ_1769\n#define refers_to_regno_for_reload_p ZZZ_1770\n#define refers_to_regno_p ZZZ_1771\n#define regclass ZZZ_1772\n#define regclass_init ZZZ_1773\n#define register_include_chains ZZZ_1774\n#define register_operand ZZZ_1775\n#define regno_clobbered_at_setjmp ZZZ_1776\n#define regno_clobbered_p ZZZ_1777\n#define reg_alloc ZZZ_1778\n#define reg_alloc_order ZZZ_1779\n#define reg_classes_intersect_p ZZZ_1780\n#define reg_class_contents ZZZ_1781\n#define reg_class_size ZZZ_1782\n#define reg_class_subclasses ZZZ_1783\n#define reg_class_subset_p ZZZ_1784\n#define reg_class_subunion ZZZ_1785\n#define reg_class_superclasses ZZZ_1786\n#define reg_class_superunion ZZZ_1787\n#define reg_equiv_address ZZZ_1788\n#define reg_equiv_constant ZZZ_1789\n#define reg_equiv_mem ZZZ_1790\n#define reg_equiv_memory_loc ZZZ_1791\n#define reg_overlap_mentioned_for_reload_p ZZZ_1792\n#define reg_overlap_mentioned_p ZZZ_1793\n#define reg_referenced_between_p ZZZ_1794\n#define reg_referenced_p ZZZ_1795\n#define reg_scan ZZZ_1796\n#define reg_scan_update ZZZ_1797\n#define reg_set_between_p ZZZ_1798\n#define reg_set_last ZZZ_1799\n#define reg_set_p ZZZ_1800\n#define reg_set_to_hard_reg_set ZZZ_1801\n#define reload_completed ZZZ_1802\n#define reload_cse_regs ZZZ_1803\n#define reload_firstobj ZZZ_1804\n#define reload_first_uid ZZZ_1805\n#define reload_inheritance_insn ZZZ_1806\n#define reload_inherited ZZZ_1807\n#define reload_insn_chain ZZZ_1808\n#define reload_in_optab ZZZ_1809\n#define reload_in_progress ZZZ_1810\n#define reload_obstack ZZZ_1811\n#define reload_out_optab ZZZ_1812\n#define reload_override_in ZZZ_1813\n#define reload_spill_index ZZZ_1814\n#define reload_startobj ZZZ_1815\n#define remove_node_from_expr_list ZZZ_1816\n#define remove_note ZZZ_1817\n#define reorder_basic_blocks ZZZ_1818\n#define reorder_blocks ZZZ_1819\n#define reorder_insns ZZZ_1820\n#define reorder_insns_nobb ZZZ_1821\n#define reorder_insns_with_line_notes ZZZ_1822\n#define replace_call_placeholder ZZZ_1823\n#define replace_equiv_address ZZZ_1824\n#define replace_equiv_address_nv ZZZ_1825\n#define replace_label ZZZ_1826\n#define replace_regs ZZZ_1827\n#define replace_rtx ZZZ_1828\n#define resolve_asm_operand_names ZZZ_1829\n#define resolve_unique_section ZZZ_1830\n#define restore_emit_status ZZZ_1831\n#define restore_line_number_status ZZZ_1832\n#define rest_of_compilation ZZZ_1833\n#define rest_of_decl_compilation ZZZ_1834\n#define rest_of_type_compilation ZZZ_1835\n#define reversed_comparison_code ZZZ_1836\n#define reversed_comparison_code_parts ZZZ_1837\n#define reverse_comparison ZZZ_1838\n#define reverse_condition ZZZ_1839\n#define reverse_condition_maybe_unordered ZZZ_1840\n#define rli_size_so_far ZZZ_1841\n#define rli_size_unit_so_far ZZZ_1842\n#define rtl_dump_and_exit ZZZ_1843\n#define rtl_dump_file ZZZ_1844\n#define rtx_addr_can_trap_p ZZZ_1845\n#define rtx_addr_varies_p ZZZ_1846\n#define rtx_equal_for_cselib_p ZZZ_1847\n#define rtx_equal_function_value_matters ZZZ_1848\n#define rtx_equal_p ZZZ_1849\n#define safe_from_earlyclobber ZZZ_1850\n#define safe_from_p ZZZ_1851\n#define sbitmap_alloc ZZZ_1852\n#define sbitmap_a_and_b ZZZ_1853\n#define sbitmap_a_and_b_cg ZZZ_1854\n#define sbitmap_a_and_b_or_c ZZZ_1855\n#define sbitmap_a_and_b_or_c_cg ZZZ_1856\n#define sbitmap_a_or_b ZZZ_1857\n#define sbitmap_a_or_b_and_c ZZZ_1858\n#define sbitmap_a_or_b_and_c_cg ZZZ_1859\n#define sbitmap_a_or_b_cg ZZZ_1860\n#define sbitmap_a_subset_b_p ZZZ_1861\n#define sbitmap_a_xor_b ZZZ_1862\n#define sbitmap_a_xor_b_cg ZZZ_1863\n#define sbitmap_copy ZZZ_1864\n#define sbitmap_difference ZZZ_1865\n#define sbitmap_equal ZZZ_1866\n#define sbitmap_first_set_bit ZZZ_1867\n#define sbitmap_intersection_of_preds ZZZ_1868\n#define sbitmap_intersection_of_succs ZZZ_1869\n#define sbitmap_last_set_bit ZZZ_1870\n#define sbitmap_not ZZZ_1871\n#define sbitmap_ones ZZZ_1872\n#define sbitmap_resize ZZZ_1873\n#define sbitmap_union_of_diff ZZZ_1874\n#define sbitmap_union_of_diff_cg ZZZ_1875\n#define sbitmap_union_of_preds ZZZ_1876\n#define sbitmap_union_of_succs ZZZ_1877\n#define sbitmap_vector_alloc ZZZ_1878\n#define sbitmap_vector_ones ZZZ_1879\n#define sbitmap_vector_zero ZZZ_1880\n#define sbitmap_zero ZZZ_1881\n#define setjmp_protect ZZZ_1882\n#define setjmp_protect_args ZZZ_1883\n#define set_decl_abstract_flags ZZZ_1884\n#define set_decl_origin_self ZZZ_1885\n#define set_decl_rtl ZZZ_1886\n#define set_init_index ZZZ_1887\n#define set_init_label ZZZ_1888\n#define set_mem_alias_set ZZZ_1889\n#define set_mem_align ZZZ_1890\n#define set_mem_attributes ZZZ_1891\n#define set_mem_attributes_minus_bitpos ZZZ_1892\n#define set_mem_attrs_from_reg ZZZ_1893\n#define set_mem_expr ZZZ_1894\n#define set_mem_offset ZZZ_1895\n#define set_mem_size ZZZ_1896\n#define set_new_first_and_last_insn ZZZ_1897\n#define set_new_last_label_num ZZZ_1898\n#define set_reg_attrs_for_parm ZZZ_1899\n#define set_reg_attrs_from_mem ZZZ_1900\n#define shadow_tag ZZZ_1901\n#define shadow_tag_warned ZZZ_1902\n#define shorten_branches ZZZ_1903\n#define shorten_compare ZZZ_1904\n#define simple_cst_equal ZZZ_1905\n#define simple_cst_list_equal ZZZ_1906\n#define simplify_binary_operation ZZZ_1907\n#define simplify_gen_binary ZZZ_1908\n#define simplify_gen_relational ZZZ_1909\n#define simplify_gen_subreg ZZZ_1910\n#define simplify_gen_ternary ZZZ_1911\n#define simplify_gen_unary ZZZ_1912\n#define simplify_relational_operation ZZZ_1913\n#define simplify_replace_rtx ZZZ_1914\n#define simplify_rtx ZZZ_1915\n#define simplify_subreg ZZZ_1916\n#define simplify_subtraction ZZZ_1917\n#define simplify_ternary_operation ZZZ_1918\n#define simplify_unary_operation ZZZ_1919\n#define size_int_type_wide ZZZ_1920\n#define size_int_wide ZZZ_1921\n#define size_of_encoded_value ZZZ_1922\n#define size_of_sleb128 ZZZ_1923\n#define size_of_uleb128 ZZZ_1924\n#define splay_tree_compare_ints ZZZ_1925\n#define splay_tree_compare_pointers ZZZ_1926\n#define splay_tree_delete ZZZ_1927\n#define splay_tree_foreach ZZZ_1928\n#define splay_tree_insert ZZZ_1929\n#define splay_tree_lookup ZZZ_1930\n#define splay_tree_max ZZZ_1931\n#define splay_tree_min ZZZ_1932\n#define splay_tree_new ZZZ_1933\n#define splay_tree_new_with_allocator ZZZ_1934\n#define splay_tree_predecessor ZZZ_1935\n#define splay_tree_remove ZZZ_1936\n#define splay_tree_successor ZZZ_1937\n#define split_all_insns ZZZ_1938\n#define split_all_insns_noflow ZZZ_1939\n#define split_complex_types ZZZ_1940\n#define split_complex_values ZZZ_1941\n#define stabilize ZZZ_1942\n#define stabilize_reference ZZZ_1943\n#define stabilize_reference_1 ZZZ_1944\n#define start_sequence ZZZ_1945\n#define start_sequence_for_rtl_expr ZZZ_1946\n#define static_chain_incoming_rtx ZZZ_1947\n#define static_chain_rtx ZZZ_1948\n#define static_ctors ZZZ_1949\n#define std_expand_builtin_va_arg ZZZ_1950\n#define std_expand_builtin_va_start ZZZ_1951\n#define subreg_hard_regno ZZZ_1952\n#define subreg_highpart_offset ZZZ_1953\n#define subreg_lowpart_offset ZZZ_1954\n#define subreg_lowpart_p ZZZ_1955\n#define subreg_lsb ZZZ_1956\n#define subreg_realpart_p ZZZ_1957\n#define subreg_regno ZZZ_1958\n#define subreg_regno_offset ZZZ_1959\n#define target_flags ZZZ_1960\n#define target_flags_explicit ZZZ_1961\n#define ternary_cleanup ZZZ_1962\n#define ternary_insert ZZZ_1963\n#define ternary_search ZZZ_1964\n#define tidy_fallthru_edge ZZZ_1965\n#define tidy_fallthru_edges ZZZ_1966\n#define timevar_get ZZZ_1967\n#define timevar_init ZZZ_1968\n#define timevar_pop ZZZ_1969\n#define timevar_print ZZZ_1970\n#define timevar_push ZZZ_1971\n#define timevar_start ZZZ_1972\n#define timevar_stop ZZZ_1973\n#define trampolines_created ZZZ_1974\n#define trampoline_address ZZZ_1975\n#define tree_code_length ZZZ_1976\n#define tree_code_name ZZZ_1977\n#define tree_code_type ZZZ_1978\n#define tree_int_cst_compare ZZZ_1979\n#define tree_int_cst_equal ZZZ_1980\n#define tree_int_cst_lt ZZZ_1981\n#define tree_int_cst_msb ZZZ_1982\n#define tree_int_cst_sgn ZZZ_1983\n#define type_hash_add ZZZ_1984\n#define type_hash_canon ZZZ_1985\n#define type_hash_list ZZZ_1986\n#define type_hash_lookup ZZZ_1987\n#define unsave_expr ZZZ_1988\n#define unsave_expr_1 ZZZ_1989\n#define unshare_all_rtl ZZZ_1990\n#define unshare_all_rtl_again ZZZ_1991\n#define unshare_all_rtl_in_chain ZZZ_1992\n#define unsigned_condition ZZZ_1993\n#define unsigned_conversion_warning ZZZ_1994\n#define unsigned_jump_follows_p ZZZ_1995\n#define update_bb_for_insn ZZZ_1996\n#define update_br_prob_note ZZZ_1997\n#define update_life_info ZZZ_1998\n#define update_life_info_in_dirty_blocks ZZZ_1999\n#define validate_change ZZZ_2000\n#define validate_replace_rtx ZZZ_2001\n#define validate_replace_rtx_group ZZZ_2002\n#define validate_replace_rtx_subexp ZZZ_2003\n#define validate_replace_src ZZZ_2004\n#define validate_replace_src_group ZZZ_2005\n#define variable_section ZZZ_2006\n#define variable_size ZZZ_2007\n#define version_flag ZZZ_2008\n#define volatile_insn_p ZZZ_2010\n#define volatile_ok ZZZ_2011\n#define volatile_refs_p ZZZ_2012\n#define walk_tree ZZZ_2013\n#define walk_tree_without_duplicates ZZZ_2014\n#define warn_cast_align ZZZ_2015\n#define warn_cast_qual ZZZ_2016\n#define warn_deprecated ZZZ_2017\n#define warn_deprecated_decl ZZZ_2018\n#define warn_deprecated_use ZZZ_2019\n#define warn_format ZZZ_2020\n#define warn_format_extra_args ZZZ_2021\n#define warn_format_nonliteral ZZZ_2022\n#define warn_format_security ZZZ_2023\n#define warn_format_y2k ZZZ_2024\n#define warn_format_zero_length ZZZ_2025\n#define warn_implicit ZZZ_2026\n#define warn_implicit_int ZZZ_2027\n#define warn_missing_braces ZZZ_2028\n#define warn_missing_declarations ZZZ_2029\n#define warn_missing_format_attribute ZZZ_2030\n#define warn_missing_noreturn ZZZ_2031\n#define warn_missing_prototypes ZZZ_2032\n#define warn_nonnull ZZZ_2033\n#define warn_nontemplate_friend ZZZ_2034\n#define warn_nonvdtor ZZZ_2035\n#define warn_old_style_cast ZZZ_2036\n#define warn_old_style_definition ZZZ_2037\n#define warn_sign_compare ZZZ_2038\n#define warn_sign_promo ZZZ_2039\n#define warn_strict_aliasing ZZZ_2040\n#define warn_strict_prototypes ZZZ_2041\n#define warn_switch ZZZ_2042\n#define warn_switch_default ZZZ_2043\n#define warn_switch_enum ZZZ_2044\n#define warn_unused_function ZZZ_2045\n#define warn_unused_label ZZZ_2046\n#define warn_unused_parameter ZZZ_2047\n#define warn_unused_value ZZZ_2048\n#define warn_unused_variable ZZZ_2049\n#define xmalloc_failed ZZZ_2050\n#define xmalloc_set_program_name ZZZ_2051\n#define _cpp_cleanup_files ZZZ_2052\n#define _cpp_clean_line ZZZ_2053\n#define _cpp_create_definition ZZZ_2054\n#define _cpp_create_trad_definition ZZZ_2055\n#define _cpp_default_encoding ZZZ_2056\n#define _cpp_define_builtin ZZZ_2057\n#define _cpp_destroy_hashtable ZZZ_2058\n#define _cpp_destroy_iconv ZZZ_2059\n#define _cpp_do_file_change ZZZ_2060\n#define _cpp_do__Pragma ZZZ_2061\n#define _cpp_expand_op_stack ZZZ_2062\n#define _cpp_expansions_different_trad ZZZ_2063\n#define _cpp_find_failed ZZZ_2064\n#define _cpp_find_file ZZZ_2065\n#define _cpp_free_buff ZZZ_2066\n#define _cpp_free_definition ZZZ_2067\n#define _cpp_get_buff ZZZ_2068\n#define _cpp_get_fresh_line ZZZ_2069\n#define _cpp_init_directives ZZZ_2070\n#define _cpp_init_files ZZZ_2071\n#define _cpp_init_hashtable ZZZ_2072\n#define _cpp_init_internal_pragmas ZZZ_2073\n#define _cpp_init_tokenrun ZZZ_2074\n#define _cpp_lex_direct ZZZ_2075\n#define _cpp_lex_token ZZZ_2076\n#define _cpp_pop_buffer ZZZ_2077\n#define _cpp_pop_context ZZZ_2078\n#define _cpp_pop_file_buffer ZZZ_2079\n#define _cpp_replacement_text_len ZZZ_2080\n#define _cpp_report_missing_guards ZZZ_2081\n#define _cpp_save_parameter ZZZ_2082\n#define _cpp_save_pragma_names ZZZ_2083\n#define _cpp_stack_file ZZZ_2084\n#define _cpp_stack_include ZZZ_2085\n#define _fatal_insn ZZZ_2086\n#define _fatal_insn_not_found ZZZ_2087\n#define _obstack ZZZ_2088\n#define _obstack_allocated_p ZZZ_2089\n#define _obstack_begin ZZZ_2090\n#define _obstack_begin_1 ZZZ_2091\n#define _obstack_free ZZZ_2092\n#define _obstack_memory_used ZZZ_2093\n#define _obstack_newchunk ZZZ_2094\n#define _sch_ebcasc ZZZ_2095\n#define _sch_ebcistable ZZZ_2096\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MULTILIB": {"ttr": 8200, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "static const char *const multilib_raw\u00dd\u00a8 = {\n\". ;\",\nNULL\n};\n\nstatic const char *const multilib_matches_raw\u00dd\u00a8 = {\nNULL\n};\n\nstatic const char *multilib_extra = \"\";\n\nstatic const char *const multilib_exclusions_raw\u00dd\u00a8 = {\nNULL\n};\n\nstatic const char *multilib_options = \"\";\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVS": {"ttr": 8202, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n   Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION printf (\" (370/MVS)\");\n\n/* Specify that we're generating code for the Language Environment */\n\n#define LE370 1\n#define TARGET_EBCDIC 1\n#define TARGET_HLASM 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()\t\t\\\n    do {\t\t\t\t\t\\\n\tbuiltin_define_std (\"MVS\");\t\t\\\n\tbuiltin_define_std (\"mvs\");\t\t\\\n\tMAYBE_LE370_MACROS();\t\t\t\\\n\tbuiltin_assert (\"system=mvs\");\t\t\\\n    } while (0)\n\n#if defined(LE370)\n# define MAYBE_LE370_MACROS() do {builtin_define_std (\"LE370\");} while (0)\n#else\n# define MAYBE_LE370_MACROS()\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSDIGNU": {"ttr": 8206, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION printf (\" (370/MVS-DIGNUS)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Dignus runtime library.  */\n\n#define TARGET_DIGNUS 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n#define STARTFILE_SPEC \"\"\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"DIGNUS\");          \\\n        builtin_define_std (\"dignus\");          \\\n        builtin_define_std (\"MVS\");             \\\n\tbuiltin_define_std (\"mvs\");             \\\n\tbuiltin_assert (\"system=mvs\");          \\\n    } while (0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSLE": {"ttr": 8208, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION printf (\" (370/MVS-LE)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Language Environment runtime.  */\n\n#define TARGET_LE 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n/*#define TARGET_MACROS 1*/\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n#define STARTFILE_SPEC \"\"\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"LE370\");           \\\n        builtin_define_std (\"le370\");           \\\n        builtin_define_std (\"MVS\");             \\\n\tbuiltin_define_std (\"mvs\");             \\\n\tbuiltin_assert (\"system=mvs\");          \\\n    } while (0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSPDP": {"ttr": 8449, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n   Modified for use with PDPCLIB by Paul Edwards.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef MVSPDP_INCLUDED\n#define MVSPDP_INCLUDED 1\n\n#ifdef TARGET_CMS\n#define TARGET_VERSION fprintf (stderr, \" (370/CMS-PDP)\");\n\n/* Specify that we're generating code for MVS.  */\n/* (even though it's really CMS) */\n\n#define TARGET_MVS 1\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"PDPMAC\");          \\\n        builtin_define_std (\"pdpmac\");          \\\n        builtin_define_std (\"CMS\");             \\\n\tbuiltin_define_std (\"cms\");             \\\n\tbuiltin_assert (\"system=cms\");          \\\n    } while (0)\n\n#elif defined(TARGET_VSE)\n#define TARGET_VERSION fprintf (stderr, \" (370/VSE-PDP)\");\n\n/* Specify that we're generating code for MVS.  */\n/* (even though it's really VSE) */\n\n#define TARGET_MVS 1\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"PDPMAC\");          \\\n        builtin_define_std (\"pdpmac\");          \\\n        builtin_define_std (\"VSE\");             \\\n\tbuiltin_define_std (\"vse\");             \\\n\tbuiltin_assert (\"system=vse\");          \\\n    } while (0)\n\n#else /* not CMS or VSE, must be MVS */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/MVS-PDP)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"PDPMAC\");          \\\n        builtin_define_std (\"pdpmac\");          \\\n        builtin_define_std (\"MVS\");             \\\n\tbuiltin_define_std (\"mvs\");             \\\n\tbuiltin_assert (\"system=mvs\");          \\\n    } while (0)\n\n#endif\n\n\n/* common stuff */\n\n#include <stdio.h>\n#include <stdarg.h>\n\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the PDP macros */\n\n#define TARGET_PDPMAC 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n#define STARTFILE_SPEC \"\"\n\n\n/* The generated files don't expect detabbing, and\n   configure won't handle a single executable being\n   created. So only enable these options if a pure\n   ISO environment has been requested in the compile\n   script, and we're not doing a generated file. */\n\n#if defined(PUREISO) && !defined(GENERATOR_FILE)\n#define SINGLE_EXECUTABLE 1\n#define DETAB 1\n#endif\n\n/* If running on MVS, need some EBCDIC-related differences */\n#if defined(__MVS__) || defined(__CMS__) || defined(__VSE__)\n#define HOST_EBCDIC 1\n#endif\n\n#undef INCLUDE_DEFAULTS\n#define INCLUDE_DEFAULTS \\\n    { \\\n    { 0, 0, 0, 0 } \\\n    }\n\n#ifdef PUREISO\n#include \"pureiso.h\"\n#endif\n\n\n/* unfortunately toplev.c doesn't compile with IFOX\n   because there are more than 399 external references.\n   You get an error message like this:\n   IFO264      TOO MANY ESD ENTRIES\n   To combat this problem, we index into an array\n   instead. */\n#if IFOX\n#undef flag_test_coverage\n#undef flag_branch_probabilities\n#undef flag_reorder_blocks\n#undef flag_reorder_functions\n#undef flag_rename_registers\n#undef flag_force_mem\n#undef flag_force_addr\n#undef flag_defer_pop\n#undef flag_float_store\n#undef flag_strength_reduce\n#undef flag_old_unroll_loops\n#undef flag_old_unroll_all_loops\n#undef flag_move_all_movables\n#undef flag_prefetch_loop_arrays\n#undef flag_reduce_all_givs\n#undef flag_writable_strings\n#undef flag_no_function_cse\n#undef flag_omit_frame_pointer\n#undef flag_function_sections\n#undef flag_data_sections\n#undef flag_no_peephole\n#undef flag_optimize_sibling_calls\n#undef flag_value_profile_transformations\n#undef flag_signed_char\n#undef flag_short_enums\n#undef flag_caller_saves\n#undef flag_cse_follow_jumps\n#undef flag_cse_skip_blocks\n#undef flag_expensive_optimizations\n#undef flag_rounding_math\n#undef flag_signaling_nans\n#undef flag_complex_divide_method\n#undef flag_syntax_only\n#undef flag_web\n#undef flag_loop_optimize\n#undef flag_crossjumping\n#undef flag_if_conversion\n#undef flag_if_conversion2\n#undef flag_delete_null_pointer_checks\n#undef flag_gcse\n#undef flag_peel_loops\n#undef flag_unroll_loops\n#undef flag_unroll_all_loops\n#undef flag_unswitch_loops\n#undef flag_shared_data\n\n#define flag_test_coverage gflags\u00dd0\u00a8\n#define flag_branch_probabilities gflags\u00dd1\u00a8\n#define flag_reorder_blocks gflags\u00dd2\u00a8\n#define flag_reorder_functions gflags\u00dd3\u00a8\n#define flag_rename_registers gflags\u00dd4\u00a8\n#define flag_force_mem gflags\u00dd5\u00a8\n#define flag_force_addr gflags\u00dd6\u00a8\n#define flag_defer_pop gflags\u00dd7\u00a8\n#define flag_float_store gflags\u00dd8\u00a8\n#define flag_strength_reduce gflags\u00dd9\u00a8\n#define flag_old_unroll_loops gflags\u00dd10\u00a8\n#define flag_old_unroll_all_loops gflags\u00dd11\u00a8\n#define flag_move_all_movables gflags\u00dd12\u00a8\n#define flag_prefetch_loop_arrays gflags\u00dd13\u00a8\n#define flag_reduce_all_givs gflags\u00dd14\u00a8\n#define flag_writable_strings gflags\u00dd15\u00a8\n#define flag_no_function_cse gflags\u00dd16\u00a8\n#define flag_omit_frame_pointer gflags\u00dd17\u00a8\n#define flag_function_sections gflags\u00dd18\u00a8\n#define flag_data_sections gflags\u00dd19\u00a8\n#define flag_no_peephole gflags\u00dd20\u00a8\n#define flag_optimize_sibling_calls gflags\u00dd21\u00a8\n#define flag_value_profile_transformations gflags\u00dd22\u00a8\n#define flag_signed_char gflags\u00dd23\u00a8\n#define flag_short_enums gflags\u00dd24\u00a8\n#define flag_caller_saves gflags\u00dd25\u00a8\n#define flag_cse_follow_jumps gflags\u00dd26\u00a8\n#define flag_cse_skip_blocks gflags\u00dd27\u00a8\n#define flag_expensive_optimizations gflags\u00dd28\u00a8\n#define flag_rounding_math gflags\u00dd29\u00a8\n#define flag_signaling_nans gflags\u00dd30\u00a8\n#define flag_complex_divide_method gflags\u00dd31\u00a8\n#define flag_syntax_only gflags\u00dd32\u00a8\n#define flag_web gflags\u00dd33\u00a8\n#define flag_loop_optimize gflags\u00dd34\u00a8\n#define flag_crossjumping gflags\u00dd35\u00a8\n#define flag_if_conversion gflags\u00dd36\u00a8\n#define flag_if_conversion2 gflags\u00dd37\u00a8\n#define flag_delete_null_pointer_checks gflags\u00dd38\u00a8\n#define flag_gcse gflags\u00dd39\u00a8\n#define flag_peel_loops gflags\u00dd40\u00a8\n#define flag_unroll_loops gflags\u00dd41\u00a8\n#define flag_unroll_all_loops gflags\u00dd42\u00a8\n#define flag_unswitch_loops gflags\u00dd43\u00a8\n#define flag_shared_data gflags\u00dd44\u00a8\n#endif\n\n\n#ifdef DETAB\n#define fputs t_fputs\n#define fprintf t_fprintf\n#define vfprintf t_vfprintf\n#define fwrite t_fwrite\n#define fputc t_fputc\n#undef putc\n#define putc t_fputc\n\nint t_fputs (const char *str, FILE *file);\nint t_fprintf (FILE *file, const char *format, ...);\nint t_vfprintf (FILE *file, const char *format, va_list arg);\nsize_t t_fwrite (const void *ptr, size_t size, size_t nmemb, FILE *file);\nint t_fputc (int c, FILE *file);\n#endif\n\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSTEST": {"ttr": 8452, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "int x;\n\n#define mary printf\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVS38": {"ttr": 8204, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION printf (\" (370/MVS38)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the Dignus runtime library.  */\n\n#define TARGET_DIGNUS 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n        builtin_define_std (\"MVS\");             \\\n\tbuiltin_define_std (\"mvs\");             \\\n\tbuiltin_assert (\"system=mvs\");          \\\n    } while (0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBJALLOC": {"ttr": 8454, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* objalloc.h -- routines to allocate memory for objects\n   Copyright 1997, 2001 Free Software Foundation, Inc.\n   Written by Ian Lance Taylor, Cygnus Solutions.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef OBJALLOC_H\n#define OBJALLOC_H\n\n#include \"ansidecl.h\"\n\n/* These routines allocate space for an object.  The assumption is\n   that the object will want to allocate space as it goes along, but\n   will never want to free any particular block.  There is a function\n   to free a block, which also frees all more recently allocated\n   blocks.  There is also a function to free all the allocated space.\n\n   This is essentially a specialization of obstacks.  The main\n   difference is that a block may not be allocated a bit at a time.\n   Another difference is that these routines are always built on top\n   of malloc, and always pass an malloc failure back to the caller,\n   unlike more recent versions of obstacks.  */\n\n/* This is what an objalloc structure looks like.  Callers should not\n   refer to these fields, nor should they allocate these structure\n   themselves.  Instead, they should only create them via\n   objalloc_init, and only access them via the functions and macros\n   listed below.  The structure is only defined here so that we can\n   access it via macros.  */\n\nstruct objalloc\n{\n  char *current_ptr;\n  unsigned int current_space;\n  PTR chunks;\n};\n\n/* Work out the required alignment.  */\n\nstruct objalloc_align { char x; double d; };\n\n#if defined (__STDC__) && __STDC__\n#ifndef offsetof\n#include <stddef.h>\n#endif\n#endif\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)\n#endif\n#define OBJALLOC_ALIGN offsetof (struct objalloc_align, d)\n\n/* Create an objalloc structure.  Returns NULL if malloc fails.  */\n\nextern struct objalloc *objalloc_create PARAMS ((void));\n\n/* Allocate space from an objalloc structure.  Returns NULL if malloc\n   fails.  */\n\nextern PTR _objalloc_alloc PARAMS ((struct objalloc *, unsigned long));\n\n/* The macro version of objalloc_alloc.  We only define this if using\n   gcc, because otherwise we would have to evaluate the arguments\n   multiple times, or use a temporary field as obstack.h does.  */\n\n#if defined (__GNUC__) && defined (__STDC__) && __STDC__\n\n/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n   does not implement __extension__.  But that compiler doesn't define\n   __GNUC_MINOR__.  */\n#if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n#define __extension__\n#endif\n\n#define objalloc_alloc(o, l)\t\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct objalloc *__o = (o);\t\t\t\t\t\\\n     unsigned long __len = (l);\t\t\t\t\t\t\\\n     if (__len == 0)\t\t\t\t\t\t\t\\\n       __len = 1;\t\t\t\t\t\t\t\\\n     __len = (__len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);\t\\\n     (__len <= __o->current_space\t\t\t\t\t\\\n      ? (__o->current_ptr += __len,\t\t\t\t\t\\\n\t __o->current_space -= __len,\t\t\t\t\t\\\n\t (PTR) (__o->current_ptr - __len))\t\t\t\t\\\n      : _objalloc_alloc (__o, __len)); })\n\n#else /* ! __GNUC__ */\n\n#define objalloc_alloc(o, l) _objalloc_alloc ((o), (l))\n\n#endif /* ! __GNUC__ */\n\n/* Free an entire objalloc structure.  */\n\nextern void objalloc_free PARAMS ((struct objalloc *));\n\n/* Free a block allocated by objalloc_alloc.  This also frees all more\n   recently allocated blocks.  */\n\nextern void objalloc_free_block PARAMS ((struct objalloc *, PTR));\n\n#endif /* OBJALLOC_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OBSTACK": {"ttr": 8456, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* obstack.h - object stack macros\n   Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,\n   1999, 2000\n   Free Software Foundation, Inc.\n\n\n   NOTE: The canonical source of this file is maintained with the GNU C Library.\n   Bugs can be reported to bug-glibc@gnu.org.\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n\n/* Summary:\n\nAll the apparent functions defined here are macros. The idea\nis that you would use these pre-tested macros to solve a\nvery specific set of problems, and they would run fast.\nCaution: no side-effects in arguments please!! They may be\nevaluated MANY times!!\n\nThese macros operate a stack of objects.  Each object starts life\nsmall, and may grow to maturity.  (Consider building a word syllable\nby syllable.)  An object can move while it is growing.  Once it has\nbeen \"finished\" it never changes address again.  So the \"top of the\nstack\" is typically an immature growing object, while the rest of the\nstack is of mature, fixed size and fixed address objects.\n\nThese routines grab large chunks of memory, using a function you\nsupply, called `obstack_chunk_alloc'.  On occasion, they free chunks,\nby calling `obstack_chunk_free'.  You must define them and declare\nthem before using any obstack macros.\n\nEach independent stack is represented by a `struct obstack'.\nEach of the obstack macros expects a pointer to such a structure\nas the first argument.\n\nOne motivation for this package is the problem of growing char strings\nin symbol tables.  Unless you are \"fascist pig with a read-only mind\"\n--Gosper's immortal quote from HAKMEM item 154, out of context--you\nwould not like to put any arbitrary upper limit on the length of your\nsymbols.\n\nIn practice this often means you will build many short symbols and a\nfew long symbols.  At the time you are reading a symbol you don't know\nhow long it is.  One traditional method is to read a symbol into a\nbuffer, realloc()ating the buffer every time you try to read a symbol\nthat is longer than the buffer.  This is beaut, but you still will\nwant to copy the symbol from the buffer to a more permanent\nsymbol-table entry say about half the time.\n\nWith obstacks, you can work differently.  Use one obstack for all symbol\nnames.  As you read a symbol, grow the name in the obstack gradually.\nWhen the name is complete, finalize it.  Then, if the symbol exists already,\nfree the newly read name.\n\nThe way we do this is to take a large chunk, allocating memory from\nlow addresses.  When you want to build a symbol in the chunk you just\nadd chars above the current \"high water mark\" in the chunk.  When you\nhave finished adding chars, because you got to the end of the symbol,\nyou know how long the chars are, and you can create a new object.\nMostly the chars will not burst over the highest address of the chunk,\nbecause you would typically expect a chunk to be (say) 100 times as\nlong as an average object.\n\nIn case that isn't clear, when we have enough chars to make up\nthe object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)\nso we just point to it where it lies.  No moving of chars is\nneeded and this is the second win: potentially long strings need\nnever be explicitly shuffled. Once an object is formed, it does not\nchange its address during its lifetime.\n\nWhen the chars burst over a chunk boundary, we allocate a larger\nchunk, and then copy the partly formed object from the end of the old\nchunk to the beginning of the new larger chunk.  We then carry on\naccreting characters to the end of the object as we normally would.\n\nA special macro is provided to add a single char at a time to a\ngrowing object.  This allows the use of register variables, which\nbreak the ordinary 'growth' macro.\n\nSummary:\n\tWe allocate large chunks.\n\tWe carve out one object at a time from the current chunk.\n\tOnce carved, an object never moves.\n\tWe are free to append data of any size to the currently\n\t  growing object.\n\tExactly one object is growing in an obstack at any one time.\n\tYou can run one obstack per control block.\n\tYou may have as many control blocks as you dare.\n\tBecause of the way we do it, you can `unwind' an obstack\n\t  back to a previous state. (You may remove objects much\n\t  as you would with a stack.)\n*/\n\n\n/* Don't do the contents of this file more than once.  */\n\n#ifndef _OBSTACK_H\n#define _OBSTACK_H 1\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* We use subtraction of (char *) 0 instead of casting to int\n   because on word-addressable machines a simple cast to int\n   may ignore the byte-within-word field of the pointer.  */\n\n#ifndef __PTR_TO_INT\n# define __PTR_TO_INT(P) ((P) - (char *) 0)\n#endif\n\n#ifndef __INT_TO_PTR\n# define __INT_TO_PTR(P) ((P) + (char *) 0)\n#endif\n\n/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is\n   defined, as with GNU C, use that; that way we don't pollute the\n   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is\n   available, include it and use ptrdiff_t.  In traditional C, long is\n   the best that we can do.  */\n\n#ifdef __PTRDIFF_TYPE__\n# define PTR_INT_TYPE __PTRDIFF_TYPE__\n#else\n# ifdef HAVE_STDDEF_H\n#  include <stddef.h>\n#  define PTR_INT_TYPE ptrdiff_t\n# else\n#  define PTR_INT_TYPE long\n# endif\n#endif\n\n#if defined _LIBC || defined HAVE_STRING_H\n# include <string.h>\n# if defined __STDC__ && __STDC__\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n# else\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n# endif\n#else\n# ifdef memcpy\n#  define _obstack_memcpy(To, From, N) memcpy ((To), (char *)(From), (N))\n# else\n#  define _obstack_memcpy(To, From, N) bcopy ((char *)(From), (To), (N))\n# endif\n#endif\n\nstruct _obstack_chunk\t\t/* Lives at front of each chunk. */\n{\n  char  *limit;\t\t\t/* 1 past end of this chunk */\n  struct _obstack_chunk *prev;\t/* address of prior chunk or NULL */\n  char\tcontents\u00dd4\u00a8;\t\t/* objects begin here */\n};\n\nstruct obstack\t\t/* control current object in current chunk */\n{\n  long\tchunk_size;\t\t/* preferred size to allocate chunks in */\n  struct _obstack_chunk *chunk;\t/* address of current struct obstack_chunk */\n  char\t*object_base;\t\t/* address of object we are building */\n  char\t*next_free;\t\t/* where to add next char to current object */\n  char\t*chunk_limit;\t\t/* address of char after current chunk */\n  PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n  int   alignment_mask;\t\t/* Mask of alignment for each object. */\n#if defined __STDC__ && __STDC__\n  /* These prototypes vary based on `use_extra_arg', and we use\n     casts to the prototypeless function type in all assignments,\n     but having prototypes here quiets -Wstrict-prototypes.  */\n  struct _obstack_chunk *(*chunkfun) (void *, long);\n  void (*freefun) (void *, struct _obstack_chunk *);\n  void *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n#else\n  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */\n  void (*freefun) ();\t\t/* User's function to free a chunk.  */\n  char *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n#endif\n  unsigned use_extra_arg:1;\t/* chunk alloc/dealloc funcs take extra arg */\n  unsigned maybe_empty_object:1;/* There is a possibility that the current\n\t\t\t\t   chunk contains a zero-length object.  This\n\t\t\t\t   prevents freeing the chunk if we allocate\n\t\t\t\t   a bigger chunk to replace it. */\n  unsigned alloc_failed:1;\t/* No longer used, as we now call the failed\n\t\t\t\t   handler on error, but retained for binary\n\t\t\t\t   compatibility.  */\n};\n\n/* Declare the external functions we use; they are in obstack.c.  */\n\n#if defined __STDC__ && __STDC__\nextern void _obstack_newchunk (struct obstack *, int);\nextern void _obstack_free (struct obstack *, void *);\nextern int _obstack_begin (struct obstack *, int, int,\n\t\t\t    void *(*) (long), void (*) (void *));\nextern int _obstack_begin_1 (struct obstack *, int, int,\n\t\t\t     void *(*) (void *, long),\n\t\t\t     void (*) (void *, void *), void *);\nextern int _obstack_memory_used (struct obstack *);\n#else\nextern void _obstack_newchunk ();\nextern void _obstack_free ();\nextern int _obstack_begin ();\nextern int _obstack_begin_1 ();\nextern int _obstack_memory_used ();\n#endif\n\n#if defined __STDC__ && __STDC__\n\n/* Do the function-declarations after the structs\n   but before defining the macros.  */\n\nvoid obstack_init (struct obstack *obstack);\n\nvoid * obstack_alloc (struct obstack *obstack, int size);\n\nvoid * obstack_copy (struct obstack *obstack, void *address, int size);\nvoid * obstack_copy0 (struct obstack *obstack, void *address, int size);\n\nvoid obstack_free (struct obstack *obstack, void *block);\n\nvoid obstack_blank (struct obstack *obstack, int size);\n\nvoid obstack_grow (struct obstack *obstack, void *data, int size);\nvoid obstack_grow0 (struct obstack *obstack, void *data, int size);\n\nvoid obstack_1grow (struct obstack *obstack, int data_char);\nvoid obstack_ptr_grow (struct obstack *obstack, void *data);\nvoid obstack_int_grow (struct obstack *obstack, int data);\n\nvoid * obstack_finish (struct obstack *obstack);\n\nint obstack_object_size (struct obstack *obstack);\n\nint obstack_room (struct obstack *obstack);\nvoid obstack_make_room (struct obstack *obstack, int size);\nvoid obstack_1grow_fast (struct obstack *obstack, int data_char);\nvoid obstack_ptr_grow_fast (struct obstack *obstack, void *data);\nvoid obstack_int_grow_fast (struct obstack *obstack, int data);\nvoid obstack_blank_fast (struct obstack *obstack, int size);\n\nvoid * obstack_base (struct obstack *obstack);\nvoid * obstack_next_free (struct obstack *obstack);\nint obstack_alignment_mask (struct obstack *obstack);\nint obstack_chunk_size (struct obstack *obstack);\nint obstack_memory_used (struct obstack *obstack);\n\n#endif /* __STDC__ */\n\n/* Non-ANSI C cannot really support alternative functions for these macros,\n   so we do not declare them.  */\n\n/* Error handler called when `obstack_chunk_alloc' failed to allocate\n   more memory.  This can be set to a user defined function.  The\n   default action is to print a message and abort.  */\n#if defined __STDC__ && __STDC__\nextern void (*obstack_alloc_failed_handler) (void);\n#else\nextern void (*obstack_alloc_failed_handler) ();\n#endif\n\n/* Exit value used when `print_and_abort' is used.  */\nextern int obstack_exit_failure;\n\n/* Pointer to beginning of object being allocated or to be allocated next.\n   Note that this might not be the final address of the object\n   because a new chunk might be needed to hold the final size.  */\n\n#define obstack_base(h) ((h)->object_base)\n\n/* Size for allocating ordinary chunks.  */\n\n#define obstack_chunk_size(h) ((h)->chunk_size)\n\n/* Pointer to next byte not yet allocated in current chunk.  */\n\n#define obstack_next_free(h)\t((h)->next_free)\n\n/* Mask specifying low bits that should be clear in address of an object.  */\n\n#define obstack_alignment_mask(h) ((h)->alignment_mask)\n\n/* To prevent prototype warnings provide complete argument list in\n   standard C version.  */\n#if defined __STDC__ && __STDC__\n\n# define obstack_init(h) \\\n  _obstack_begin ((h), 0, 0, \\\n\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n\n# define obstack_begin(h, size) \\\n  _obstack_begin ((h), (size), 0, \\\n\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n\n# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n  _obstack_begin ((h), (size), (alignment), \\\n\t\t    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))\n\n# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n  _obstack_begin_1 ((h), (size), (alignment), \\\n\t\t    (void *(*) (void *, long)) (chunkfun), \\\n\t\t    (void (*) (void *, void *)) (freefun), (arg))\n\n# define obstack_chunkfun(h, newchunkfun) \\\n  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))\n\n# define obstack_freefun(h, newfreefun) \\\n  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n\n#else\n\n# define obstack_init(h) \\\n  _obstack_begin ((h), 0, 0, \\\n\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n\n# define obstack_begin(h, size) \\\n  _obstack_begin ((h), (size), 0, \\\n\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n\n# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n  _obstack_begin ((h), (size), (alignment), \\\n\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))\n\n# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n  _obstack_begin_1 ((h), (size), (alignment), \\\n\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))\n\n# define obstack_chunkfun(h, newchunkfun) \\\n  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))\n\n# define obstack_freefun(h, newfreefun) \\\n  ((h) -> freefun = (void (*)()) (newfreefun))\n\n#endif\n\n#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))\n\n#define obstack_blank_fast(h,n) ((h)->next_free += (n))\n\n#define obstack_memory_used(h) _obstack_memory_used (h)\n\n#if defined __GNUC__ && defined __STDC__ && __STDC__\n/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n   does not implement __extension__.  But that compiler doesn't define\n   __GNUC_MINOR__.  */\n# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n#  define __extension__\n# endif\n\n/* For GNU C, if not -traditional,\n   we can define these macros to compute all args only once\n   without using a global variable.\n   Also, we can avoid using the `temp' slot, to make faster code.  */\n\n# define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (unsigned) (__o->next_free - __o->object_base); })\n\n# define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (unsigned) (__o->chunk_limit - __o->next_free); })\n\n# define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n\n# define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->next_free + __len > __o->chunk_limit)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n   __o->next_free += __len;\t\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->next_free + __len + 1 > __o->chunk_limit)\t\t\t\\\n     _obstack_newchunk (__o, __len + 1);\t\t\t\t\\\n   _obstack_memcpy (__o->next_free, (where), __len);\t\t\t\\\n   __o->next_free += __len;\t\t\t\t\t\t\\\n   *(__o->next_free)++ = 0;\t\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + 1 > __o->chunk_limit)\t\t\t\t\\\n     _obstack_newchunk (__o, 1);\t\t\t\t\t\\\n   obstack_1grow_fast (__o, datum);\t\t\t\t\t\\\n   (void) 0; })\n\n/* These assume that the obstack alignment is good enough for pointers or ints,\n   and that the data added so far to the current object\n   shares that much alignment.  */\n\n# define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + sizeof (void *) > __o->chunk_limit)\t\t\\\n     _obstack_newchunk (__o, sizeof (void *));\t\t\t\t\\\n   obstack_ptr_grow_fast (__o, datum); })\n\n# define obstack_int_grow(OBSTACK,datum)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   if (__o->next_free + sizeof (int) > __o->chunk_limit)\t\t\\\n     _obstack_newchunk (__o, sizeof (int));\t\t\t\t\\\n   obstack_int_grow_fast (__o, datum); })\n\n# define obstack_ptr_grow_fast(OBSTACK,aptr)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   *(const void **) __o1->next_free = (aptr);\t\t\t\t\\\n   __o1->next_free += sizeof (const void *);\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_int_grow_fast(OBSTACK,aint)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   *(int *) __o1->next_free = (aint);\t\t\t\t\t\\\n   __o1->next_free += sizeof (int);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   int __len = (length);\t\t\t\t\t\t\\\n   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n   obstack_blank_fast (__o, __len);\t\t\t\t\t\\\n   (void) 0; })\n\n# define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_blank (__h, (length));\t\t\t\t\t\\\n   obstack_finish (__h); })\n\n# define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_grow (__h, (where), (length));\t\t\t\t\\\n   obstack_finish (__h); })\n\n# define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n   obstack_grow0 (__h, (where), (length));\t\t\t\t\\\n   obstack_finish (__h); })\n\n/* The local variable is named __o1 to avoid a name conflict\n   when obstack_blank is called.  */\n# define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n   void *value;\t\t\t\t\t\t\t\t\\\n   value = (void *) __o1->object_base;\t\t\t\t\t\\\n   if (__o1->next_free == value)\t\t\t\t\t\\\n     __o1->maybe_empty_object = 1;\t\t\t\t\t\\\n   __o1->next_free\t\t\t\t\t\t\t\\\n     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\\\n\t\t     & ~ (__o1->alignment_mask));\t\t\t\\\n   if (__o1->next_free - (char *)__o1->chunk\t\t\t\t\\\n       > __o1->chunk_limit - (char *)__o1->chunk)\t\t\t\\\n     __o1->next_free = __o1->chunk_limit;\t\t\t\t\\\n   __o1->object_base = __o1->next_free;\t\t\t\t\t\\\n   value; })\n\n# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n__extension__\t\t\t\t\t\t\t\t\\\n({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n   void *__obj = (OBJ);\t\t\t\t\t\t\t\\\n   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \\\n     __o->next_free = __o->object_base = __obj;\t\t\t\t\\\n   else (obstack_free) (__o, __obj); })\n\n#else /* not __GNUC__ or not __STDC__ */\n\n# define obstack_object_size(h) \\\n (unsigned) ((h)->next_free - (h)->object_base)\n\n# define obstack_room(h)\t\t\\\n (unsigned) ((h)->chunk_limit - (h)->next_free)\n\n# define obstack_empty_p(h) \\\n ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n\n/* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n   so that we can avoid having void expressions\n   in the arms of the conditional expression.\n   Casting the third operand to void was tried before,\n   but some compilers won't accept it.  */\n\n# define obstack_make_room(h,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))\n\n# define obstack_grow(h,where,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n  (h)->next_free += (h)->temp)\n\n# define obstack_grow0(h,where,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),\t\t\t\\\n  _obstack_memcpy ((h)->next_free, (where), (h)->temp),\t\t\t\\\n  (h)->next_free += (h)->temp,\t\t\t\t\t\t\\\n  *((h)->next_free)++ = 0)\n\n# define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n( (((h)->next_free + 1 > (h)->chunk_limit)\t\t\t\t\\\n   ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t\\\n  obstack_1grow_fast (h, datum))\n\n# define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)\t\t\\\n   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t\\\n  obstack_ptr_grow_fast (h, datum))\n\n# define obstack_int_grow(h,datum)\t\t\t\t\t\\\n( (((h)->next_free + sizeof (int) > (h)->chunk_limit)\t\t\t\\\n   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t\\\n  obstack_int_grow_fast (h, datum))\n\n# define obstack_ptr_grow_fast(h,aptr)\t\t\t\t\t\\\n  (((const void **) ((h)->next_free += sizeof (void *)))\u00dd-1\u00a8 = (aptr))\n\n# define obstack_int_grow_fast(h,aint)\t\t\t\t\t\\\n  (((int *) ((h)->next_free += sizeof (int)))\u00dd-1\u00a8 = (aptr))\n\n# define obstack_blank(h,length)\t\t\t\t\t\\\n( (h)->temp = (length),\t\t\t\t\t\t\t\\\n  (((h)->chunk_limit - (h)->next_free < (h)->temp)\t\t\t\\\n   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n  obstack_blank_fast (h, (h)->temp))\n\n# define obstack_alloc(h,length)\t\t\t\t\t\\\n (obstack_blank ((h), (length)), obstack_finish ((h)))\n\n# define obstack_copy(h,where,length)\t\t\t\t\t\\\n (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_copy0(h,where,length)\t\t\t\t\t\\\n (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n\n# define obstack_finish(h)  \t\t\t\t\t\t\\\n( ((h)->next_free == (h)->object_base\t\t\t\t\t\\\n   ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t\t\\\n   : 0),\t\t\t\t\t\t\t\t\\\n  (h)->temp = __PTR_TO_INT ((h)->object_base),\t\t\t\t\\\n  (h)->next_free\t\t\t\t\t\t\t\\\n    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)\t\\\n\t\t    & ~ ((h)->alignment_mask)),\t\t\t\t\\\n  (((h)->next_free - (char *) (h)->chunk\t\t\t\t\\\n    > (h)->chunk_limit - (char *) (h)->chunk)\t\t\t\t\\\n   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t\\\n  (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n  __INT_TO_PTR ((h)->temp))\n\n# if defined __STDC__ && __STDC__\n#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))\n# else\n#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))\n# endif\n\n#endif /* not __GNUC__ or not __STDC__ */\n\n#ifdef __cplusplus\n}\t/* C++ */\n#endif\n\n#endif /* obstack.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OE": {"ttr": 8462, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION printf (\" (370/OpenEdition)\");\n\n/* Specify that we're generating code for OpenEdition.  */\n\n#define TARGET_OE 1\n#define TARGET_XA 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n#define TARGET_ALIASES 1\n\n/* Specify that we're using the Language Environment runtime.  */\n\n#define TARGET_LE 1\n\n/* Specify that we're using macro prolog/epilog.  */\n\n/*#define TARGET_MACROS 1*/\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Options for this target machine.  */\n\n#define LIB_SPEC \"\"\n#define LIBGCC_SPEC \"\"\n#define STARTFILE_SPEC \"/usr/local/lib/gccmain.o\"\n\n/* Target OS preprocessor built-ins.  */\n#define TARGET_OS_CPP_BUILTINS()                \\\n    do {                                        \\\n\tbuiltin_define_std (\"unix\");            \\\n\tbuiltin_define_std (\"UNIX\");            \\\n        builtin_define_std (\"openedition\");     \\\n\tbuiltin_define (\"__i370__\");            \\\n\tbuiltin_assert (\"system=openedition\");  \\\n        builtin_assert (\"system=unix\");         \\\n     } while (0)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPTABS": {"ttr": 8464, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for code generation pass of GNU compiler.\n   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_OPTABS_H\n#define GCC_OPTABS_H\n\n#include \"insn-codes.h\"\n\n/* Optabs are tables saying how to generate insn bodies\n   for various machine modes and numbers of operands.\n   Each optab applies to one operation.\n   For example, add_optab applies to addition.\n\n   The insn_code slot is the enum insn_code that says how to\n   generate an insn for this operation on a particular machine mode.\n   It is CODE_FOR_nothing if there is no such insn on the target machine.\n\n   The `lib_call' slot is the name of the library function that\n   can be used to perform the operation.\n\n   A few optabs, such as move_optab and cmp_optab, are used\n   by special code.  */\n\nstruct optab_handlers GTY(())\n{\n  enum insn_code insn_code;\n  rtx libfunc;\n};\n\nstruct optab GTY(())\n{\n  enum rtx_code code;\n  struct optab_handlers handlers\u00ddNUM_MACHINE_MODES\u00a8;\n};\ntypedef struct optab * optab;\n\n/* A convert_optab is for some sort of conversion operation between\n   modes.  The first array index is the destination mode, the second\n   is the source mode.  */\nstruct convert_optab GTY(())\n{\n  enum rtx_code code;\n  struct optab_handlers handlers\u00ddNUM_MACHINE_MODES\u00a8\u00ddNUM_MACHINE_MODES\u00a8;\n};\ntypedef struct convert_optab *convert_optab;\n\n/* Given an enum insn_code, access the function to construct\n   the body of that kind of insn.  */\n#define GEN_FCN(CODE) (insn_data\u00ddCODE\u00a8.genfun)\n\n/* Enumeration of valid indexes into optab_table.  */\nenum optab_index\n{\n  OTI_add,\n  OTI_addv,\n  OTI_sub,\n  OTI_subv,\n\n  /* Signed and fp multiply */\n  OTI_smul,\n  OTI_smulv,\n  /* Signed multiply, return high word */\n  OTI_smul_highpart,\n  OTI_umul_highpart,\n  /* Signed multiply with result one machine mode wider than args */\n  OTI_smul_widen,\n  OTI_umul_widen,\n\n  /* Signed divide */\n  OTI_sdiv,\n  OTI_sdivv,\n  /* Signed divide-and-remainder in one */\n  OTI_sdivmod,\n  OTI_udiv,\n  OTI_udivmod,\n  /* Signed remainder */\n  OTI_smod,\n  OTI_umod,\n  /* Convert float to integer in float fmt */\n  OTI_ftrunc,\n\n  /* Logical and */\n  OTI_and,\n  /* Logical or */\n  OTI_ior,\n  /* Logical xor */\n  OTI_xor,\n\n  /* Arithmetic shift left */\n  OTI_ashl,\n  /* Logical shift right */\n  OTI_lshr,\n  /* Arithmetic shift right */\n  OTI_ashr,\n  /* Rotate left */\n  OTI_rotl,\n  /* Rotate right */\n  OTI_rotr,\n  /* Signed and floating-point minimum value */\n  OTI_smin,\n  /* Signed and floating-point maximum value */\n  OTI_smax,\n  /* Unsigned minimum value */\n  OTI_umin,\n  /* Unsigned maximum value */\n  OTI_umax,\n  /* Power */\n  OTI_pow,\n  /* Arc tangent of y/x */\n  OTI_atan2,\n\n  /* Move instruction.  */\n  OTI_mov,\n  /* Move, preserving high part of register.  */\n  OTI_movstrict,\n\n  /* Unary operations */\n  /* Negation */\n  OTI_neg,\n  OTI_negv,\n  /* Abs value */\n  OTI_abs,\n  OTI_absv,\n  /* Bitwise not */\n  OTI_one_cmpl,\n  /* Bit scanning and counting */\n  OTI_ffs,\n  OTI_clz,\n  OTI_ctz,\n  OTI_popcount,\n  OTI_parity,\n  /* Square root */\n  OTI_sqrt,\n  /* Sine */\n  OTI_sin,\n  /* Cosine */\n  OTI_cos,\n  /* Exponential */\n  OTI_exp,\n  /* Natural Logarithm */\n  OTI_log,\n  /* Rounding functions */\n  OTI_floor,\n  OTI_ceil,\n  OTI_trunc,\n  OTI_round,\n  OTI_nearbyint,\n  /* Tangent */\n  OTI_tan,\n  /* Inverse tangent */\n  OTI_atan,\n\n  /* Compare insn; two operands.  */\n  OTI_cmp,\n  /* Used only for libcalls for unsigned comparisons.  */\n  OTI_ucmp,\n  /* tst insn; compare one operand against 0 */\n  OTI_tst,\n\n  /* Floating point comparison optabs - used primarily for libfuncs */\n  OTI_eq,\n  OTI_ne,\n  OTI_gt,\n  OTI_ge,\n  OTI_lt,\n  OTI_le,\n  OTI_unord,\n\n  /* String length */\n  OTI_strlen,\n\n  /* Combined compare & jump/store flags/move operations.  */\n  OTI_cbranch,\n  OTI_cmov,\n  OTI_cstore,\n\n  /* Push instruction.  */\n  OTI_push,\n\n  /* Conditional add instruction.  */\n  OTI_addcc,\n\n  /* Set specified field of vector operand.  */\n  OTI_vec_set,\n  /* Extract specified field of vector operand.  */\n  OTI_vec_extract,\n  /* Initialize vector operand.  */\n  OTI_vec_init,\n\n  OTI_MAX\n};\n\nextern GTY(()) optab optab_table\u00ddOTI_MAX\u00a8;\n\n#define add_optab (optab_table\u00ddOTI_add\u00a8)\n#define sub_optab (optab_table\u00ddOTI_sub\u00a8)\n#define smul_optab (optab_table\u00ddOTI_smul\u00a8)\n#define addv_optab (optab_table\u00ddOTI_addv\u00a8)\n#define subv_optab (optab_table\u00ddOTI_subv\u00a8)\n#define smul_highpart_optab (optab_table\u00ddOTI_smul_highpart\u00a8)\n#define umul_highpart_optab (optab_table\u00ddOTI_umul_highpart\u00a8)\n#define smul_widen_optab (optab_table\u00ddOTI_smul_widen\u00a8)\n#define umul_widen_optab (optab_table\u00ddOTI_umul_widen\u00a8)\n#define sdiv_optab (optab_table\u00ddOTI_sdiv\u00a8)\n#define smulv_optab (optab_table\u00ddOTI_smulv\u00a8)\n#define sdivv_optab (optab_table\u00ddOTI_sdivv\u00a8)\n#define sdivmod_optab (optab_table\u00ddOTI_sdivmod\u00a8)\n#define udiv_optab (optab_table\u00ddOTI_udiv\u00a8)\n#define udivmod_optab (optab_table\u00ddOTI_udivmod\u00a8)\n#define smod_optab (optab_table\u00ddOTI_smod\u00a8)\n#define umod_optab (optab_table\u00ddOTI_umod\u00a8)\n#define ftrunc_optab (optab_table\u00ddOTI_ftrunc\u00a8)\n#define and_optab (optab_table\u00ddOTI_and\u00a8)\n#define ior_optab (optab_table\u00ddOTI_ior\u00a8)\n#define xor_optab (optab_table\u00ddOTI_xor\u00a8)\n#define ashl_optab (optab_table\u00ddOTI_ashl\u00a8)\n#define lshr_optab (optab_table\u00ddOTI_lshr\u00a8)\n#define ashr_optab (optab_table\u00ddOTI_ashr\u00a8)\n#define rotl_optab (optab_table\u00ddOTI_rotl\u00a8)\n#define rotr_optab (optab_table\u00ddOTI_rotr\u00a8)\n#define smin_optab (optab_table\u00ddOTI_smin\u00a8)\n#define smax_optab (optab_table\u00ddOTI_smax\u00a8)\n#define umin_optab (optab_table\u00ddOTI_umin\u00a8)\n#define umax_optab (optab_table\u00ddOTI_umax\u00a8)\n#define pow_optab (optab_table\u00ddOTI_pow\u00a8)\n#define atan2_optab (optab_table\u00ddOTI_atan2\u00a8)\n\n#define mov_optab (optab_table\u00ddOTI_mov\u00a8)\n#define movstrict_optab (optab_table\u00ddOTI_movstrict\u00a8)\n\n#define neg_optab (optab_table\u00ddOTI_neg\u00a8)\n#define negv_optab (optab_table\u00ddOTI_negv\u00a8)\n#define abs_optab (optab_table\u00ddOTI_abs\u00a8)\n#define absv_optab (optab_table\u00ddOTI_absv\u00a8)\n#define one_cmpl_optab (optab_table\u00ddOTI_one_cmpl\u00a8)\n#define ffs_optab (optab_table\u00ddOTI_ffs\u00a8)\n#define clz_optab (optab_table\u00ddOTI_clz\u00a8)\n#define ctz_optab (optab_table\u00ddOTI_ctz\u00a8)\n#define popcount_optab (optab_table\u00ddOTI_popcount\u00a8)\n#define parity_optab (optab_table\u00ddOTI_parity\u00a8)\n#define sqrt_optab (optab_table\u00ddOTI_sqrt\u00a8)\n#define sin_optab (optab_table\u00ddOTI_sin\u00a8)\n#define cos_optab (optab_table\u00ddOTI_cos\u00a8)\n#define exp_optab (optab_table\u00ddOTI_exp\u00a8)\n#define log_optab (optab_table\u00ddOTI_log\u00a8)\n#define floor_optab (optab_table\u00ddOTI_floor\u00a8)\n#define ceil_optab (optab_table\u00ddOTI_ceil\u00a8)\n#define btrunc_optab (optab_table\u00ddOTI_trunc\u00a8)\n#define round_optab (optab_table\u00ddOTI_round\u00a8)\n#define nearbyint_optab (optab_table\u00ddOTI_nearbyint\u00a8)\n#define tan_optab (optab_table\u00ddOTI_tan\u00a8)\n#define atan_optab (optab_table\u00ddOTI_atan\u00a8)\n\n#define cmp_optab (optab_table\u00ddOTI_cmp\u00a8)\n#define ucmp_optab (optab_table\u00ddOTI_ucmp\u00a8)\n#define tst_optab (optab_table\u00ddOTI_tst\u00a8)\n\n#define eq_optab (optab_table\u00ddOTI_eq\u00a8)\n#define ne_optab (optab_table\u00ddOTI_ne\u00a8)\n#define gt_optab (optab_table\u00ddOTI_gt\u00a8)\n#define ge_optab (optab_table\u00ddOTI_ge\u00a8)\n#define lt_optab (optab_table\u00ddOTI_lt\u00a8)\n#define le_optab (optab_table\u00ddOTI_le\u00a8)\n#define unord_optab (optab_table\u00ddOTI_unord\u00a8)\n\n#define strlen_optab (optab_table\u00ddOTI_strlen\u00a8)\n\n#define cbranch_optab (optab_table\u00ddOTI_cbranch\u00a8)\n#define cmov_optab (optab_table\u00ddOTI_cmov\u00a8)\n#define cstore_optab (optab_table\u00ddOTI_cstore\u00a8)\n#define push_optab (optab_table\u00ddOTI_push\u00a8)\n#define addcc_optab (optab_table\u00ddOTI_addcc\u00a8)\n\n#define vec_set_optab (optab_table\u00ddOTI_vec_set\u00a8)\n#define vec_extract_optab (optab_table\u00ddOTI_vec_extract\u00a8)\n#define vec_init_optab (optab_table\u00ddOTI_vec_init\u00a8)\n\n/* Conversion optabs have their own table and indexes.  */\nenum convert_optab_index\n{\n  CTI_sext,\n  CTI_zext,\n  CTI_trunc,\n\n  CTI_sfix,\n  CTI_ufix,\n\n  CTI_sfixtrunc,\n  CTI_ufixtrunc,\n\n  CTI_sfloat,\n  CTI_ufloat,\n\n  CTI_MAX\n};\n\nextern GTY(()) convert_optab convert_optab_table\u00ddCTI_MAX\u00a8;\n\n#define sext_optab (convert_optab_table\u00ddCTI_sext\u00a8)\n#define zext_optab (convert_optab_table\u00ddCTI_zext\u00a8)\n#define trunc_optab (convert_optab_table\u00ddCTI_trunc\u00a8)\n#define sfix_optab (convert_optab_table\u00ddCTI_sfix\u00a8)\n#define ufix_optab (convert_optab_table\u00ddCTI_ufix\u00a8)\n#define sfixtrunc_optab (convert_optab_table\u00ddCTI_sfixtrunc\u00a8)\n#define ufixtrunc_optab (convert_optab_table\u00ddCTI_ufixtrunc\u00a8)\n#define sfloat_optab (convert_optab_table\u00ddCTI_sfloat\u00a8)\n#define ufloat_optab (convert_optab_table\u00ddCTI_ufloat\u00a8)\n\n/* These arrays record the insn_code of insns that may be needed to\n   perform input and output reloads of special objects.  They provide a\n   place to pass a scratch register.  */\nextern enum insn_code reload_in_optab\u00ddNUM_MACHINE_MODES\u00a8;\nextern enum insn_code reload_out_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* Contains the optab used for each rtx code.  */\nextern GTY(()) optab code_to_optab\u00ddNUM_RTX_CODE + 1\u00a8;\n\n\ntypedef rtx (*rtxfun) (rtx);\n\n/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n   gives the gen_function to make a branch to test that condition.  */\n\nextern rtxfun bcc_gen_fctn\u00ddNUM_RTX_CODE\u00a8;\n\n/* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n   gives the insn code to make a store-condition insn\n   to test that condition.  */\n\nextern enum insn_code setcc_gen_code\u00ddNUM_RTX_CODE\u00a8;\n\n#ifdef HAVE_conditional_move\n/* Indexed by the machine mode, gives the insn code to make a conditional\n   move insn.  */\n\nextern enum insn_code movcc_gen_code\u00ddNUM_MACHINE_MODES\u00a8;\n#endif\n\n/* This array records the insn_code of insns to perform block moves.  */\nextern enum insn_code movstr_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* This array records the insn_code of insns to perform block clears.  */\nextern enum insn_code clrstr_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* These arrays record the insn_code of two different kinds of insns\n   to perform block compares.  */\nextern enum insn_code cmpstr_optab\u00ddNUM_MACHINE_MODES\u00a8;\nextern enum insn_code cmpmem_optab\u00ddNUM_MACHINE_MODES\u00a8;\n\n/* Define functions given in optabs.c.  */\n\n/* Expand a binary operation given optab and rtx operands.  */\nextern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n\t\t\t enum optab_methods);\n\n/* Expand a binary operation with both signed and unsigned forms.  */\nextern rtx sign_expand_binop (enum machine_mode, optab, optab, rtx, rtx,\n\t\t\t      rtx, int, enum optab_methods);\n\n/* Generate code to perform an operation on two operands with two results.  */\nextern int expand_twoval_binop (optab, rtx, rtx, rtx, rtx, int);\n\n/* Expand a unary arithmetic operation given optab rtx operand.  */\nextern rtx expand_unop (enum machine_mode, optab, rtx, rtx, int);\n\n/* Expand the absolute value operation.  */\nextern rtx expand_abs_nojump (enum machine_mode, rtx, rtx, int);\nextern rtx expand_abs (enum machine_mode, rtx, rtx, int, int);\n\n/* Expand the complex absolute value operation.  */\nextern rtx expand_complex_abs (enum machine_mode, rtx, rtx, int);\n\n/* Generate an instruction with a given INSN_CODE with an output and\n   an input.  */\nextern void emit_unop_insn (int, rtx, rtx, enum rtx_code);\n\n/* Emit code to perform a series of operations on a multi-word quantity, one\n   word at a time.  */\nextern rtx emit_no_conflict_block (rtx, rtx, rtx, rtx, rtx);\n\n/* Emit one rtl instruction to store zero in specified rtx.  */\nextern void emit_clr_insn (rtx);\n\n/* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\nextern void emit_0_to_1_insn (rtx);\n\n/* Emit one rtl insn to compare two rtx's.  */\nextern void emit_cmp_insn (rtx, rtx, enum rtx_code, rtx, enum machine_mode,\n\t\t\t   int);\n\n/* The various uses that a comparison can have; used by can_compare_p:\n   jumps, conditional moves, store flag operations.  */\nenum can_compare_purpose\n{\n  ccp_jump,\n  ccp_cmov,\n  ccp_store_flag\n};\n\n/* Nonzero if a compare of mode MODE can be done straightforwardly\n   (without splitting it into pieces).  */\nextern int can_compare_p (enum rtx_code, enum machine_mode,\n\t\t\t  enum can_compare_purpose);\n\nextern rtx prepare_operand (int, rtx, int, enum machine_mode,\n\t\t\t    enum machine_mode, int);\n\n/* Return the INSN_CODE to use for an extend operation.  */\nextern enum insn_code can_extend_p (enum machine_mode, enum machine_mode, int);\n\n/* Generate the body of an insn to extend Y (with mode MFROM)\n   into X (with mode MTO).  Do zero-extension if UNSIGNEDP is nonzero.  */\nextern rtx gen_extend_insn (rtx, rtx, enum machine_mode,\n\t\t\t    enum machine_mode, int);\n\n/* Initialize the tables that control conversion between fixed and\n   floating values.  */\nextern void init_fixtab (void);\nextern void init_floattab (void);\n\n/* Call this to reset the function entry for one optab.  */\nextern void set_optab_libfunc (optab, enum machine_mode, const char *);\nextern void set_conv_libfunc (convert_optab, enum machine_mode,\n\t\t\t      enum machine_mode, const char *);\n\n/* Generate code for a FLOAT_EXPR.  */\nextern void expand_float (rtx, rtx, int);\n\n/* Generate code for a FIX_EXPR.  */\nextern void expand_fix (rtx, rtx, int);\n\n#endif /* GCC_OPTABS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPTIONS": {"ttr": 8708, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file is auto-generated by opts.sh.  */\n\n#define CL_C       (1 << 0)\n#define CL_CXX     (1 << 1)\n#define CL_ObjC    (1 << 2)\n#define CL_ObjCXX  (1 << 3)\n\nenum opt_code\n{\n  OPT__help,                              /* --help */\n  OPT__output_pch_,                       /* --output-pch= */\n  OPT__param,                             /* --param */\n  OPT__target_help,                       /* --target-help */\n  OPT__version,                           /* --version */\n  OPT_A,                                  /* -A */\n  OPT_C,                                  /* -C */\n  OPT_CC,                                 /* -CC */\n  OPT_D,                                  /* -D */\n  OPT_E,                                  /* -E */\n  OPT_G,                                  /* -G */\n  OPT_H,                                  /* -H */\n  OPT_I,                                  /* -I */\n  OPT_M,                                  /* -M */\n  OPT_MD,                                 /* -MD */\n  OPT_MF,                                 /* -MF */\n  OPT_MG,                                 /* -MG */\n  OPT_MM,                                 /* -MM */\n  OPT_MMD,                                /* -MMD */\n  OPT_MP,                                 /* -MP */\n  OPT_MQ,                                 /* -MQ */\n  OPT_MT,                                 /* -MT */\n  OPT_O,                                  /* -O */\n  OPT_Os,                                 /* -Os */\n  OPT_P,                                  /* -P */\n  OPT_U,                                  /* -U */\n  OPT_W,                                  /* -W */\n  OPT_Wabi,                               /* -Wabi */\n  OPT_Waggregate_return,                  /* -Waggregate-return */\n  OPT_Wall,                               /* -Wall */\n  OPT_Wbad_function_cast,                 /* -Wbad-function-cast */\n  OPT_Wcast_align,                        /* -Wcast-align */\n  OPT_Wcast_qual,                         /* -Wcast-qual */\n  OPT_Wchar_subscripts,                   /* -Wchar-subscripts */\n  OPT_Wcomment,                           /* -Wcomment */\n  OPT_Wcomments,                          /* -Wcomments */\n  OPT_Wconversion,                        /* -Wconversion */\n  OPT_Wctor_dtor_privacy,                 /* -Wctor-dtor-privacy */\n  OPT_Wdeclaration_after_statement,       /* -Wdeclaration-after-statement */\n  OPT_Wdeprecated,                        /* -Wdeprecated */\n  OPT_Wdeprecated_declarations,           /* -Wdeprecated-declarations */\n  OPT_Wdisabled_optimization,             /* -Wdisabled-optimization */\n  OPT_Wdiv_by_zero,                       /* -Wdiv-by-zero */\n  OPT_Weffc__,                            /* -Weffc++ */\n  OPT_Wendif_labels,                      /* -Wendif-labels */\n  OPT_Werror,                             /* -Werror */\n  OPT_Werror_implicit_function_declaration,/* -Werror-implicit-function-declaration */\n  OPT_Wextra,                             /* -Wextra */\n  OPT_Wfloat_equal,                       /* -Wfloat-equal */\n  OPT_Wformat,                            /* -Wformat */\n  OPT_Wformat_extra_args,                 /* -Wformat-extra-args */\n  OPT_Wformat_nonliteral,                 /* -Wformat-nonliteral */\n  OPT_Wformat_security,                   /* -Wformat-security */\n  OPT_Wformat_y2k,                        /* -Wformat-y2k */\n  OPT_Wformat_zero_length,                /* -Wformat-zero-length */\n  OPT_Wformat_,                           /* -Wformat= */\n  OPT_Wimplicit,                          /* -Wimplicit */\n  OPT_Wimplicit_function_declaration,     /* -Wimplicit-function-declaration */\n  OPT_Wimplicit_int,                      /* -Wimplicit-int */\n  OPT_Wimport,                            /* -Wimport */\n  OPT_Winit_self,                         /* -Winit-self */\n  OPT_Winline,                            /* -Winline */\n  OPT_Winvalid_offsetof,                  /* -Winvalid-offsetof */\n  OPT_Winvalid_pch,                       /* -Winvalid-pch */\n  OPT_Wlarger_than_,                      /* -Wlarger-than- */\n  OPT_Wlong_long,                         /* -Wlong-long */\n  OPT_Wmain,                              /* -Wmain */\n  OPT_Wmissing_braces,                    /* -Wmissing-braces */\n  OPT_Wmissing_declarations,              /* -Wmissing-declarations */\n  OPT_Wmissing_format_attribute,          /* -Wmissing-format-attribute */\n  OPT_Wmissing_noreturn,                  /* -Wmissing-noreturn */\n  OPT_Wmissing_prototypes,                /* -Wmissing-prototypes */\n  OPT_Wmultichar,                         /* -Wmultichar */\n  OPT_Wnested_externs,                    /* -Wnested-externs */\n  OPT_Wnon_template_friend,               /* -Wnon-template-friend */\n  OPT_Wnon_virtual_dtor,                  /* -Wnon-virtual-dtor */\n  OPT_Wnonnull,                           /* -Wnonnull */\n  OPT_Wold_style_cast,                    /* -Wold-style-cast */\n  OPT_Wold_style_definition,              /* -Wold-style-definition */\n  OPT_Woverloaded_virtual,                /* -Woverloaded-virtual */\n  OPT_Wpacked,                            /* -Wpacked */\n  OPT_Wpadded,                            /* -Wpadded */\n  OPT_Wparentheses,                       /* -Wparentheses */\n  OPT_Wpmf_conversions,                   /* -Wpmf-conversions */\n  OPT_Wpointer_arith,                     /* -Wpointer-arith */\n  OPT_Wprotocol,                          /* -Wprotocol */\n  OPT_Wredundant_decls,                   /* -Wredundant-decls */\n  OPT_Wreorder,                           /* -Wreorder */\n  OPT_Wreturn_type,                       /* -Wreturn-type */\n  OPT_Wselector,                          /* -Wselector */\n  OPT_Wsequence_point,                    /* -Wsequence-point */\n  OPT_Wshadow,                            /* -Wshadow */\n  OPT_Wsign_compare,                      /* -Wsign-compare */\n  OPT_Wsign_promo,                        /* -Wsign-promo */\n  OPT_Wstrict_aliasing,                   /* -Wstrict-aliasing */\n  OPT_Wstrict_prototypes,                 /* -Wstrict-prototypes */\n  OPT_Wswitch,                            /* -Wswitch */\n  OPT_Wswitch_default,                    /* -Wswitch-default */\n  OPT_Wswitch_enum,                       /* -Wswitch-enum */\n  OPT_Wsynth,                             /* -Wsynth */\n  OPT_Wsystem_headers,                    /* -Wsystem-headers */\n  OPT_Wtraditional,                       /* -Wtraditional */\n  OPT_Wtrigraphs,                         /* -Wtrigraphs */\n  OPT_Wundeclared_selector,               /* -Wundeclared-selector */\n  OPT_Wundef,                             /* -Wundef */\n  OPT_Wuninitialized,                     /* -Wuninitialized */\n  OPT_Wunknown_pragmas,                   /* -Wunknown-pragmas */\n  OPT_Wunreachable_code,                  /* -Wunreachable-code */\n  OPT_Wunused,                            /* -Wunused */\n  OPT_Wunused_function,                   /* -Wunused-function */\n  OPT_Wunused_label,                      /* -Wunused-label */\n  OPT_Wunused_macros,                     /* -Wunused-macros */\n  OPT_Wunused_parameter,                  /* -Wunused-parameter */\n  OPT_Wunused_value,                      /* -Wunused-value */\n  OPT_Wunused_variable,                   /* -Wunused-variable */\n  OPT_Wwrite_strings,                     /* -Wwrite-strings */\n  OPT_ansi,                               /* -ansi */\n  OPT_aux_info,                           /* -aux-info */\n  OPT_aux_info_,                          /* -aux-info= */\n  OPT_auxbase,                            /* -auxbase */\n  OPT_auxbase_strip,                      /* -auxbase-strip */\n  OPT_d,                                  /* -d */\n  OPT_dumpbase,                           /* -dumpbase */\n  OPT_fPIC,                               /* -fPIC */\n  OPT_fPIE,                               /* -fPIE */\n  OPT_fabi_version_,                      /* -fabi-version= */\n  OPT_faccess_control,                    /* -faccess-control */\n  OPT_falign_functions,                   /* -falign-functions */\n  OPT_falign_functions_,                  /* -falign-functions= */\n  OPT_falign_jumps,                       /* -falign-jumps */\n  OPT_falign_jumps_,                      /* -falign-jumps= */\n  OPT_falign_labels,                      /* -falign-labels */\n  OPT_falign_labels_,                     /* -falign-labels= */\n  OPT_falign_loops,                       /* -falign-loops */\n  OPT_falign_loops_,                      /* -falign-loops= */\n  OPT_fall_virtual,                       /* -fall-virtual */\n  OPT_falt_external_templates,            /* -falt-external-templates */\n  OPT_fargument_alias,                    /* -fargument-alias */\n  OPT_fargument_noalias,                  /* -fargument-noalias */\n  OPT_fargument_noalias_global,           /* -fargument-noalias-global */\n  OPT_fasm,                               /* -fasm */\n  OPT_fasynchronous_unwind_tables,        /* -fasynchronous-unwind-tables */\n  OPT_fbounds_check,                      /* -fbounds-check */\n  OPT_fbranch_count_reg,                  /* -fbranch-count-reg */\n  OPT_fbranch_probabilities,              /* -fbranch-probabilities */\n  OPT_fbranch_target_load_optimize,       /* -fbranch-target-load-optimize */\n  OPT_fbranch_target_load_optimize2,      /* -fbranch-target-load-optimize2 */\n  OPT_fbuiltin,                           /* -fbuiltin */\n  OPT_fbuiltin_,                          /* -fbuiltin- */\n  OPT_fcall_saved_,                       /* -fcall-saved- */\n  OPT_fcall_used_,                        /* -fcall-used- */\n  OPT_fcaller_saves,                      /* -fcaller-saves */\n  OPT_fcheck_new,                         /* -fcheck-new */\n  OPT_fcommon,                            /* -fcommon */\n  OPT_fcond_mismatch,                     /* -fcond-mismatch */\n  OPT_fconserve_space,                    /* -fconserve-space */\n  OPT_fconst_strings,                     /* -fconst-strings */\n  OPT_fconstant_string_class_,            /* -fconstant-string-class= */\n  OPT_fcprop_registers,                   /* -fcprop-registers */\n  OPT_fcrossjumping,                      /* -fcrossjumping */\n  OPT_fcse_follow_jumps,                  /* -fcse-follow-jumps */\n  OPT_fcse_skip_blocks,                   /* -fcse-skip-blocks */\n  OPT_fdata_sections,                     /* -fdata-sections */\n  OPT_fdefault_inline,                    /* -fdefault-inline */\n  OPT_fdefer_pop,                         /* -fdefer-pop */\n  OPT_fdelayed_branch,                    /* -fdelayed-branch */\n  OPT_fdelete_null_pointer_checks,        /* -fdelete-null-pointer-checks */\n  OPT_fdiagnostics_show_location_,        /* -fdiagnostics-show-location= */\n  OPT_fdollars_in_identifiers,            /* -fdollars-in-identifiers */\n  OPT_fdump_,                             /* -fdump- */\n  OPT_fdump_unnumbered,                   /* -fdump-unnumbered */\n  OPT_felide_constructors,                /* -felide-constructors */\n  OPT_feliminate_dwarf2_dups,             /* -feliminate-dwarf2-dups */\n  OPT_feliminate_unused_debug_symbols,    /* -feliminate-unused-debug-symbols */\n  OPT_feliminate_unused_debug_types,      /* -feliminate-unused-debug-types */\n  OPT_fenforce_eh_specs,                  /* -fenforce-eh-specs */\n  OPT_fenum_int_equiv,                    /* -fenum-int-equiv */\n  OPT_fexceptions,                        /* -fexceptions */\n  OPT_fexec_charset_,                     /* -fexec-charset= */\n  OPT_fexpensive_optimizations,           /* -fexpensive-optimizations */\n  OPT_fexternal_templates,                /* -fexternal-templates */\n  OPT_ffast_math,                         /* -ffast-math */\n  OPT_ffinite_math_only,                  /* -ffinite-math-only */\n  OPT_ffixed_,                            /* -ffixed- */\n  OPT_ffixed_form,                        /* -ffixed-form */\n  OPT_ffixed_line_length_,                /* -ffixed-line-length- */\n  OPT_ffloat_store,                       /* -ffloat-store */\n  OPT_ffor_scope,                         /* -ffor-scope */\n  OPT_fforce_addr,                        /* -fforce-addr */\n  OPT_fforce_mem,                         /* -fforce-mem */\n  OPT_ffreestanding,                      /* -ffreestanding */\n  OPT_ffunction_cse,                      /* -ffunction-cse */\n  OPT_ffunction_sections,                 /* -ffunction-sections */\n  OPT_fgcse,                              /* -fgcse */\n  OPT_fgcse_las,                          /* -fgcse-las */\n  OPT_fgcse_lm,                           /* -fgcse-lm */\n  OPT_fgcse_sm,                           /* -fgcse-sm */\n  OPT_fgnu_keywords,                      /* -fgnu-keywords */\n  OPT_fgnu_runtime,                       /* -fgnu-runtime */\n  OPT_fguess_branch_probability,          /* -fguess-branch-probability */\n  OPT_fguiding_decls,                     /* -fguiding-decls */\n  OPT_fhandle_exceptions,                 /* -fhandle-exceptions */\n  OPT_fhonor_std,                         /* -fhonor-std */\n  OPT_fhosted,                            /* -fhosted */\n  OPT_fhuge_objects,                      /* -fhuge-objects */\n  OPT_fident,                             /* -fident */\n  OPT_fif_conversion,                     /* -fif-conversion */\n  OPT_fif_conversion2,                    /* -fif-conversion2 */\n  OPT_fimplement_inlines,                 /* -fimplement-inlines */\n  OPT_fimplicit_inline_templates,         /* -fimplicit-inline-templates */\n  OPT_fimplicit_templates,                /* -fimplicit-templates */\n  OPT_finhibit_size_directive,            /* -finhibit-size-directive */\n  OPT_finline,                            /* -finline */\n  OPT_finline_functions,                  /* -finline-functions */\n  OPT_finline_limit_,                     /* -finline-limit- */\n  OPT_finline_limit_eq,                     /* -finline-limit= */\n  OPT_finput_charset_,                    /* -finput-charset= */\n  OPT_finstrument_functions,              /* -finstrument-functions */\n  OPT_fkeep_inline_functions,             /* -fkeep-inline-functions */\n  OPT_fkeep_static_consts,                /* -fkeep-static-consts */\n  OPT_flabels_ok,                         /* -flabels-ok */\n  OPT_fleading_underscore,                /* -fleading-underscore */\n  OPT_floop_optimize,                     /* -floop-optimize */\n  OPT_fmath_errno,                        /* -fmath-errno */\n  OPT_fmem_report,                        /* -fmem-report */\n  OPT_fmerge_all_constants,               /* -fmerge-all-constants */\n  OPT_fmerge_constants,                   /* -fmerge-constants */\n  OPT_fmessage_length_,                   /* -fmessage-length= */\n  OPT_fmove_all_movables,                 /* -fmove-all-movables */\n  OPT_fms_extensions,                     /* -fms-extensions */\n  OPT_fname_mangling_version_,            /* -fname-mangling-version- */\n  OPT_fnew_abi,                           /* -fnew-abi */\n  OPT_fnew_ra,                            /* -fnew-ra */\n  OPT_fnext_runtime,                      /* -fnext-runtime */\n  OPT_fnil_receivers,                     /* -fnil-receivers */\n  OPT_fnon_call_exceptions,               /* -fnon-call-exceptions */\n  OPT_fnonansi_builtins,                  /* -fnonansi-builtins */\n  OPT_fnonnull_objects,                   /* -fnonnull-objects */\n  OPT_fobjc_exceptions,                   /* -fobjc-exceptions */\n  OPT_fold_unroll_all_loops,              /* -fold-unroll-all-loops */\n  OPT_fold_unroll_loops,                  /* -fold-unroll-loops */\n  OPT_fomit_frame_pointer,                /* -fomit-frame-pointer */\n  OPT_foperator_names,                    /* -foperator-names */\n  OPT_foptimize_register_move,            /* -foptimize-register-move */\n  OPT_foptimize_sibling_calls,            /* -foptimize-sibling-calls */\n  OPT_foptional_diags,                    /* -foptional-diags */\n  OPT_fpack_struct,                       /* -fpack-struct */\n  OPT_fpcc_struct_return,                 /* -fpcc-struct-return */\n  OPT_fpch_deps,                          /* -fpch-deps */\n  OPT_fpeel_loops,                        /* -fpeel-loops */\n  OPT_fpeephole,                          /* -fpeephole */\n  OPT_fpeephole2,                         /* -fpeephole2 */\n  OPT_fpermissive,                        /* -fpermissive */\n  OPT_fpic,                               /* -fpic */\n  OPT_fpie,                               /* -fpie */\n  OPT_fprefetch_loop_arrays,              /* -fprefetch-loop-arrays */\n  OPT_fpreprocessed,                      /* -fpreprocessed */\n  OPT_fprofile,                           /* -fprofile */\n  OPT_fprofile_arcs,                      /* -fprofile-arcs */\n  OPT_fprofile_generate,                  /* -fprofile-generate */\n  OPT_fprofile_use,                       /* -fprofile-use */\n  OPT_fprofile_values,                    /* -fprofile-values */\n  OPT_frandom_seed,                       /* -frandom-seed */\n  OPT_frandom_seed_,                      /* -frandom-seed= */\n  OPT_freduce_all_givs,                   /* -freduce-all-givs */\n  OPT_freg_struct_return,                 /* -freg-struct-return */\n  OPT_fregmove,                           /* -fregmove */\n  OPT_frename_registers,                  /* -frename-registers */\n  OPT_freorder_blocks,                    /* -freorder-blocks */\n  OPT_freorder_functions,                 /* -freorder-functions */\n  OPT_freplace_objc_classes,              /* -freplace-objc-classes */\n  OPT_frepo,                              /* -frepo */\n  OPT_frerun_cse_after_loop,              /* -frerun-cse-after-loop */\n  OPT_frerun_loop_opt,                    /* -frerun-loop-opt */\n  OPT_frounding_math,                     /* -frounding-math */\n  OPT_frtti,                              /* -frtti */\n  OPT_fsched_interblock,                  /* -fsched-interblock */\n  OPT_fsched_spec,                        /* -fsched-spec */\n  OPT_fsched_spec_load,                   /* -fsched-spec-load */\n  OPT_fsched_spec_load_dangerous,         /* -fsched-spec-load-dangerous */\n  OPT_fsched_stalled_insns,               /* -fsched-stalled-insns */\n  OPT_fsched_stalled_insns_dep,           /* -fsched-stalled-insns-dep */\n  OPT_fsched_stalled_insns_dep_,          /* -fsched-stalled-insns-dep= */\n  OPT_fsched_stalled_insns_,              /* -fsched-stalled-insns= */\n  OPT_fsched_verbose_,                    /* -fsched-verbose= */\n  OPT_fsched2_use_superblocks,            /* -fsched2-use-superblocks */\n  OPT_fsched2_use_traces,                 /* -fsched2-use-traces */\n  OPT_fschedule_insns,                    /* -fschedule-insns */\n  OPT_fschedule_insns2,                   /* -fschedule-insns2 */\n  OPT_fshared_data,                       /* -fshared-data */\n  OPT_fshort_double,                      /* -fshort-double */\n  OPT_fshort_enums,                       /* -fshort-enums */\n  OPT_fshort_wchar,                       /* -fshort-wchar */\n  OPT_fshow_column,                       /* -fshow-column */\n  OPT_fsignaling_nans,                    /* -fsignaling-nans */\n  OPT_fsigned_bitfields,                  /* -fsigned-bitfields */\n  OPT_fsigned_char,                       /* -fsigned-char */\n  OPT_fsingle_precision_constant,         /* -fsingle-precision-constant */\n  OPT_fsquangle,                          /* -fsquangle */\n  OPT_fstack_check,                       /* -fstack-check */\n  OPT_fstack_limit,                       /* -fstack-limit */\n  OPT_fstack_limit_register_,             /* -fstack-limit-register= */\n  OPT_fstack_limit_symbol_,               /* -fstack-limit-symbol= */\n  OPT_fstats,                             /* -fstats */\n  OPT_fstrength_reduce,                   /* -fstrength-reduce */\n  OPT_fstrict_aliasing,                   /* -fstrict-aliasing */\n  OPT_fstrict_prototype,                  /* -fstrict-prototype */\n  OPT_fsyntax_only,                       /* -fsyntax-only */\n  OPT_ftabstop_,                          /* -ftabstop= */\n  OPT_ftemplate_depth_,                   /* -ftemplate-depth- */\n  OPT_ftest_coverage,                     /* -ftest-coverage */\n  OPT_fthis_is_variable,                  /* -fthis-is-variable */\n  OPT_fthread_jumps,                      /* -fthread-jumps */\n  OPT_ftime_report,                       /* -ftime-report */\n  OPT_ftls_model_,                        /* -ftls-model= */\n  OPT_ftracer,                            /* -ftracer */\n  OPT_ftrapping_math,                     /* -ftrapping-math */\n  OPT_ftrapv,                             /* -ftrapv */\n  OPT_funit_at_a_time,                    /* -funit-at-a-time */\n  OPT_funroll_all_loops,                  /* -funroll-all-loops */\n  OPT_funroll_loops,                      /* -funroll-loops */\n  OPT_funsafe_math_optimizations,         /* -funsafe-math-optimizations */\n  OPT_funsigned_bitfields,                /* -funsigned-bitfields */\n  OPT_funsigned_char,                     /* -funsigned-char */\n  OPT_funswitch_loops,                    /* -funswitch-loops */\n  OPT_funwind_tables,                     /* -funwind-tables */\n  OPT_fuse_cxa_atexit,                    /* -fuse-cxa-atexit */\n  OPT_fverbose_asm,                       /* -fverbose-asm */\n  OPT_fvpt,                               /* -fvpt */\n  OPT_fvtable_gc,                         /* -fvtable-gc */\n  OPT_fvtable_thunks,                     /* -fvtable-thunks */\n  OPT_fweak,                              /* -fweak */\n  OPT_fweb,                               /* -fweb */\n  OPT_fwide_exec_charset_,                /* -fwide-exec-charset= */\n  OPT_fworking_directory,                 /* -fworking-directory */\n  OPT_fwrapv,                             /* -fwrapv */\n  OPT_fwritable_strings,                  /* -fwritable-strings */\n  OPT_fxref,                              /* -fxref */\n  OPT_fzero_initialized_in_bss,           /* -fzero-initialized-in-bss */\n  OPT_fzero_link,                         /* -fzero-link */\n  OPT_g,                                  /* -g */\n  OPT_gcoff,                              /* -gcoff */\n  OPT_gdwarf_2,                           /* -gdwarf-2 */\n  OPT_gen_decls,                          /* -gen-decls */\n  OPT_ggdb,                               /* -ggdb */\n  OPT_gstabs,                             /* -gstabs */\n  OPT_gstabs_,                            /* -gstabs+ */\n  OPT_gvms,                               /* -gvms */\n  OPT_gxcoff,                             /* -gxcoff */\n  OPT_gxcoff_,                            /* -gxcoff+ */\n  OPT_idirafter,                          /* -idirafter */\n  OPT_imacros,                            /* -imacros */\n  OPT_include,                            /* -include */\n  OPT_iprefix,                            /* -iprefix */\n  OPT_isysroot,                           /* -isysroot */\n  OPT_isystem,                            /* -isystem */\n  OPT_iwithprefix,                        /* -iwithprefix */\n  OPT_iwithprefixbefore,                  /* -iwithprefixbefore */\n  OPT_lang_asm,                           /* -lang-asm */\n  OPT_lang_objc,                          /* -lang-objc */\n  OPT_m,                                  /* -m */\n  OPT_nostdinc,                           /* -nostdinc */\n  OPT_nostdinc__,                         /* -nostdinc++ */\n  OPT_o,                                  /* -o */\n  OPT_p,                                  /* -p */\n  OPT_pedantic,                           /* -pedantic */\n  OPT_pedantic_errors,                    /* -pedantic-errors */\n  OPT_print_objc_runtime_info,            /* -print-objc-runtime-info */\n  OPT_quiet,                              /* -quiet */\n  OPT_remap,                              /* -remap */\n  OPT_std_c__98,                          /* -std=c++98 */\n  OPT_std_c89,                            /* -std=c89 */\n  OPT_std_c99,                            /* -std=c99 */\n  OPT_std_c9x,                            /* -std=c9x */\n  OPT_std_gnu__98,                        /* -std=gnu++98 */\n  OPT_std_gnu89,                          /* -std=gnu89 */\n  OPT_std_gnu99,                          /* -std=gnu99 */\n  OPT_std_gnu9x,                          /* -std=gnu9x */\n  OPT_std_iso9899_1990,                   /* -std=iso9899:1990 */\n  OPT_std_iso9899_199409,                 /* -std=iso9899:199409 */\n  OPT_std_iso9899_1999,                   /* -std=iso9899:1999 */\n  OPT_std_iso9899_199x,                   /* -std=iso9899:199x */\n  OPT_traditional_cpp,                    /* -traditional-cpp */\n  OPT_trigraphs,                          /* -trigraphs */\n  OPT_undef,                              /* -undef */\n  OPT_v,                                  /* -v */\n  OPT_version,                            /* -version */\n  OPT_w,                                  /* -w */\n  N_OPTS\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OPTS": {"ttr": 8714, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Command line option handling.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_OPTS_H\n#define GCC_OPTS_H\n\n#include \"config.h\"\nextern void decode_options (unsigned int argc, const char **argv);\nextern void add_input_filename (const char *filename);\n\nstruct cl_option\n{\n  const char *opt_text;\n  const char *help;\n  unsigned short back_chain;\n  unsigned char opt_len;\n  unsigned int flags;\n};\n\nextern struct cl_option cl_options\u00dd\u00a8;\nextern const unsigned int cl_options_count;\nextern const char *const lang_names\u00dd\u00a8;\n\n#define CL_JOINED\t\t(1 << 24) /* If takes joined argument.  */\n#define CL_SEPARATE\t\t(1 << 25) /* If takes a separate argument.  */\n#define CL_REJECT_NEGATIVE\t(1 << 26) /* Reject no- form.  */\n#define CL_MISSING_OK\t\t(1 << 27) /* Missing argument OK (joined).  */\n#define CL_UINTEGER\t\t(1 << 28) /* Argument is an integer >=0.  */\n#define CL_COMMON\t\t(1 << 29) /* Language-independent.  */\n#define CL_UNDOCUMENTED\t\t(1 << 30) /* Do not output with --help.  */\n\n/* Input file names.  */\n\nextern const char **in_fnames;\n\n/* The count of input filenames.  */\n\nextern unsigned num_in_fnames;\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OUTPUT": {"ttr": 8716, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for insn-output.c.  These functions are defined in recog.c,\n   final.c, and varasm.c.\n   Copyright (C) 1987, 1991, 1994, 1997, 1998,\n   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_OUTPUT_H\n#define GCC_OUTPUT_H\n\n/* Compute branch alignments based on frequency information in the CFG.  */\nextern void compute_alignments (void);\n\n/* Initialize data in final at the beginning of a compilation.  */\nextern void init_final (const char *);\n\n/* Enable APP processing of subsequent output.\n   Used before the output from an `asm' statement.  */\nextern void app_enable (void);\n\n/* Disable APP processing of subsequent output.\n   Called from varasm.c before most kinds of output.  */\nextern void app_disable (void);\n\n/* Return the number of slots filled in the current\n   delayed branch sequence (we don't count the insn needing the\n   delay slot).   Zero if not in a delayed branch sequence.  */\nextern int dbr_sequence_length (void);\n\n/* Indicate that branch shortening hasn't yet been done.  */\nextern void init_insn_lengths (void);\n\n/* Obtain the current length of an insn.  If branch shortening has been done,\n   get its actual length.  Otherwise, get its maximum length.  */\nextern int get_attr_length (rtx);\n\n/* Make a pass over all insns and compute their actual lengths by shortening\n   any branches of variable length if possible.  */\nextern void shorten_branches (rtx);\n\n/* Output assembler code for the start of a function,\n   and initialize some of the variables in this file\n   for the new function.  The label for the function and associated\n   assembler pseudo-ops have already been output in\n   `assemble_start_function'.  */\nextern void final_start_function (rtx, FILE *, int);\n\n/* Output assembler code for the end of a function.\n   For clarity, args are same as those of `final_start_function'\n   even though not all of them are needed.  */\nextern void final_end_function (void);\n\n/* Output assembler code for some insns: all or part of a function.  */\nextern void final (rtx, FILE *, int, int);\n\n/* The final scan for one insn, INSN.  Args are same as in `final', except\n   that INSN is the insn being scanned.  Value returned is the next insn to\n   be scanned.  */\nextern rtx final_scan_insn (rtx, FILE *, int, int, int, int *);\n\n/* Replace a SUBREG with a REG or a MEM, based on the thing it is a\n   subreg of.  */\nextern rtx alter_subreg (rtx *);\n\n/* Report inconsistency between the assembler template and the operands.\n   In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\nextern void output_operand_lossage (const char *, ...) ATTRIBUTE_PRINTF_1;\n\n/* Output a string of assembler code, substituting insn operands.\n   Defined in final.c.  */\nextern void output_asm_insn (const char *, rtx *);\n\n/* Compute a worst-case reference address of a branch so that it\n   can be safely used in the presence of aligned labels.\n   Defined in final.c.  */\nextern int insn_current_reference_address (rtx);\n\n/* Find the alignment associated with a CODE_LABEL.\n   Defined in final.c.  */\nextern int label_to_alignment (rtx);\n\n/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */\nextern void output_asm_label (rtx);\n\n/* Print a memory reference operand for address X\n   using machine-dependent assembler syntax.  */\nextern void output_address (rtx);\n\n/* Print an integer constant expression in assembler syntax.\n   Addition and subtraction are the only arithmetic\n   that may appear in these expressions.  */\nextern void output_addr_const (FILE *, rtx);\n\n/* Output a string of assembler code, substituting numbers, strings\n   and fixed syntactic prefixes.  */\n#if GCC_VERSION >= 3004\n#define ATTRIBUTE_ASM_FPRINTF(m, n) __attribute__ ((__format__ (__asm_fprintf__, m, n))) ATTRIBUTE_NONNULL(m)\n/* This is a magic identifier which allows GCC to figure out the type\n   of HOST_WIDE_INT for %wd specifier checks.  You must issue this\n   typedef before using the __asm_fprintf__ format attribute.  */\ntypedef HOST_WIDE_INT __gcc_host_wide_int__;\n#else\n#define ATTRIBUTE_ASM_FPRINTF(m, n) ATTRIBUTE_NONNULL(m)\n#endif\n\nextern void asm_fprintf (FILE *file, const char *p, ...)\n     ATTRIBUTE_ASM_FPRINTF(2, 3);\n\n/* Split up a CONST_DOUBLE or integer constant rtx into two rtx's for single\n   words.  */\nextern void split_double (rtx, rtx *, rtx *);\n\n/* Return nonzero if this function has no function calls.  */\nextern int leaf_function_p (void);\n\n/* Return 1 if branch is a forward branch.\n   Uses insn_shuid array, so it works only in the final pass.  May be used by\n   output templates to add branch prediction hints, for example.  */\nextern int final_forward_branch_p (rtx);\n\n/* Return 1 if this function uses only the registers that can be\n   safely renumbered.  */\nextern int only_leaf_regs_used (void);\n\n/* Scan IN_RTX and its subexpressions, and renumber all regs into those\n   available in leaf functions.  */\nextern void leaf_renumber_regs_insn (rtx);\n\n/* Locate the proper template for the given insn-code.  */\nextern const char *get_insn_template (int, rtx);\n\n/* Add function NAME to the weak symbols list.  VALUE is a weak alias\n   associated with NAME.  */\nextern int add_weak (tree, const char *, const char *);\n\n/* Functions in flow.c */\nextern void allocate_for_life_analysis (void);\nextern int regno_uninitialized (unsigned int);\nextern int regno_clobbered_at_setjmp (int);\nextern void find_basic_blocks (rtx, int, FILE *);\nextern bool cleanup_cfg (int);\nextern bool delete_unreachable_blocks (void);\nextern void check_function_return_warnings (void);\n\n/* Functions in varasm.c.  */\n\n/* Tell assembler to switch to text section.  */\nextern void text_section (void);\n\n/* Tell assembler to switch to data section.  */\nextern void data_section (void);\n\n/* Tell assembler to switch to read-only data section.  This is normally\n   the text section.  */\nextern void readonly_data_section (void);\n\n/* Determine if we're in the text section.  */\nextern int in_text_section (void);\n\n#ifdef CTORS_SECTION_ASM_OP\nextern void ctors_section (void);\n#endif\n\n#ifdef DTORS_SECTION_ASM_OP\nextern void dtors_section (void);\n#endif\n\n#ifdef BSS_SECTION_ASM_OP\nextern void bss_section (void);\n#endif\n\n#ifdef INIT_SECTION_ASM_OP\nextern void init_section (void);\n#endif\n\n#ifdef FINI_SECTION_ASM_OP\nextern void fini_section (void);\n#endif\n\n#ifdef EXPORTS_SECTION_ASM_OP\nextern void exports_section (void);\n#endif\n\n#ifdef DRECTVE_SECTION_ASM_OP\nextern void drectve_section (void);\n#endif\n\n#ifdef SDATA_SECTION_ASM_OP\nextern void sdata_section (void);\n#endif\n\n/* Tell assembler to change to section NAME for DECL.\n   If DECL is NULL, just switch to section NAME.\n   If NAME is NULL, get the name from DECL.\n   If RELOC is 1, the initializer for DECL contains relocs.  */\nextern void named_section (tree, const char *, int);\n\n/* Tell assembler to switch to the section for function DECL.  */\nextern void function_section (tree);\n\n/* Tell assembler to switch to the section for string merging.  */\nextern void mergeable_string_section (tree, unsigned HOST_WIDE_INT,\n\t\t\t\t      unsigned int);\n\n/* Tell assembler to switch to the section for constant merging.  */\nextern void mergeable_constant_section (enum machine_mode,\n\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned int);\n\n/* Declare DECL to be a weak symbol.  */\nextern void declare_weak (tree);\n/* Merge weak status.  */\nextern void merge_weak (tree, tree);\n\n/* Emit any pending weak declarations.  */\nextern void weak_finish (void);\n\n/* Decode an `asm' spec for a declaration as a register name.\n   Return the register number, or -1 if nothing specified,\n   or -2 if the ASMSPEC is not `cc' or `memory' and is not recognized,\n   or -3 if ASMSPEC is `cc' and is not recognized,\n   or -4 if ASMSPEC is `memory' and is not recognized.\n   Accept an exact spelling or a decimal number.\n   Prefixes such as % are optional.  */\nextern int decode_reg_name (const char *);\n\n/* Make the rtl for variable VAR be volatile.\n   Use this only for static variables.  */\nextern void make_var_volatile (tree);\n\nextern void assemble_alias (tree, tree);\n\nextern void default_assemble_visibility (tree, int);\n\n/* Output a string of literal assembler code\n   for an `asm' keyword used between functions.  */\nextern void assemble_asm (tree);\n\n/* Output assembler code for the constant pool of a function and associated\n   with defining the name of the function.  DECL describes the function.\n   NAME is the function's name.  For the constant pool, we use the current\n   constant pool data.  */\nextern void assemble_start_function (tree, const char *);\n\n/* Output assembler code associated with defining the size of the\n   function.  DECL describes the function.  NAME is the function's name.  */\nextern void assemble_end_function (tree, const char *);\n\n/* Assemble everything that is needed for a variable or function declaration.\n   Not used for automatic variables, and not used for function definitions.\n   Should not be called for variables of incomplete structure type.\n\n   TOP_LEVEL is nonzero if this variable has file scope.\n   AT_END is nonzero if this is the special handling, at end of compilation,\n   to define things that have had only tentative definitions.\n   DONT_OUTPUT_DATA if nonzero means don't actually output the\n   initial value (that will be done by the caller).  */\nextern void assemble_variable (tree, int, int, int);\n\n/* Output something to declare an external symbol to the assembler.\n   (Most assemblers don't need this, so we normally output nothing.)\n   Do nothing if DECL is not external.  */\nextern void assemble_external (tree);\n\n/* Assemble code to leave SIZE bytes of zeros.  */\nextern void assemble_zeros (unsigned HOST_WIDE_INT);\n\n/* Assemble an alignment pseudo op for an ALIGN-bit boundary.  */\nextern void assemble_align (int);\nextern void assemble_eh_align (int);\n\n/* Assemble a string constant with the specified C string as contents.  */\nextern void assemble_string (const char *, int);\n\n/* Similar, for calling a library function FUN.  */\nextern void assemble_external_libcall (rtx);\n\n/* Assemble a label named NAME.  */\nextern void assemble_label (const char *);\nextern void assemble_eh_label (const char *);\n\n/* Output to FILE a reference to the assembler name of a C-level name NAME.\n   If NAME starts with a *, the rest of NAME is output verbatim.\n   Otherwise NAME is transformed in an implementation-defined way\n   (usually by the addition of an underscore).\n   Many macros in the tm file are defined to call this function.  */\nextern void assemble_name (FILE *, const char *);\n\n/* Return the assembler directive for creating a given kind of integer\n   object.  SIZE is the number of bytes in the object and ALIGNED_P\n   indicates whether it is known to be aligned.  Return NULL if the\n   assembly dialect has no such directive.\n\n   The returned string should be printed at the start of a new line and\n   be followed immediately by the object's initial value.  */\nextern const char *integer_asm_op (int, int);\n\n/* Use directive OP to assemble an integer object X.  Print OP at the\n   start of the line, followed immediately by the value of X.  */\nextern void assemble_integer_with_op (const char *, rtx);\n\n/* The default implementation of the asm_out.integer target hook.  */\nextern bool default_assemble_integer (rtx, unsigned int, int);\n\n/* Assemble the integer constant X into an object of SIZE bytes.  ALIGN is\n   the alignment of the integer in bits.  Return 1 if we were able to output\n   the constant, otherwise 0.  If FORCE is nonzero, abort if we can't output\n   the constant.  */\nextern bool assemble_integer (rtx, unsigned, unsigned, int);\n\n/* An interface to assemble_integer for the common case in which a value is\n   fully aligned and must be printed.  VALUE is the value of the integer\n   object and SIZE is the number of bytes it contains.  */\n#define assemble_aligned_integer(SIZE, VALUE) \\\n  assemble_integer (VALUE, SIZE, (SIZE) * BITS_PER_UNIT, 1)\n\n#ifdef REAL_VALUE_TYPE_SIZE\n/* Assemble the floating-point constant D into an object of size MODE.  */\nextern void assemble_real (REAL_VALUE_TYPE, enum machine_mode, unsigned);\n#endif\n\n/* Return the size of the constant pool.  */\nextern int get_pool_size (void);\n\n#ifdef HAVE_peephole\nextern rtx peephole (rtx);\n#endif\n\n/* Write all the constants in the constant pool.  */\nextern void output_constant_pool (const char *, tree);\n\n/* Return nonzero if VALUE is a valid constant-valued expression\n   for use in initializing a static variable; one that can be an\n   element of a \"constant\" initializer.\n\n   Return null_pointer_node if the value is absolute;\n   if it is relocatable, return the variable that determines the relocation.\n   We assume that VALUE has been folded as much as possible;\n   therefore, we do not need to check for such things as\n   arithmetic-combinations of integers.  */\nextern tree initializer_constant_valid_p (tree, tree);\n\n/* Output assembler code for constant EXP to FILE, with no label.\n   This includes the pseudo-op such as \".int\" or \".byte\", and a newline.\n   Assumes output_addressed_constants has been done on EXP already.\n\n   Generate exactly SIZE bytes of assembler data, padding at the end\n   with zeros if necessary.  SIZE must always be specified.\n\n   ALIGN is the alignment in bits that may be assumed for the data.  */\nextern void output_constant (tree, unsigned HOST_WIDE_INT, unsigned int);\n\n/* When outputting delayed branch sequences, this rtx holds the\n   sequence being output.  It is null when no delayed branch\n   sequence is being output, so it can be used as a test in the\n   insn output code.\n\n   This variable is defined  in final.c.  */\nextern rtx final_sequence;\n\n/* The line number of the beginning of the current function.  Various\n   md code needs this so that it can output relative linenumbers.  */\n\n#ifdef SDB_DEBUGGING_INFO /* Avoid undef sym in certain broken linkers.  */\nextern int sdb_begin_function_line;\n#endif\n\n/* File in which assembler code is being written.  */\n\n#ifdef BUFSIZ\nextern FILE *asm_out_file;\n#endif\n\n/* The first global object in the file.  */\nextern const char *first_global_object_name;\n\n/* The first weak object in the file.  */\nextern const char *weak_global_object_name;\n\n/* Nonzero if function being compiled doesn't contain any calls\n   (ignoring the prologue and epilogue).  This is set prior to\n   local register allocation and is valid for the remaining\n   compiler passes.  */\n\nextern int current_function_is_leaf;\n\n/* Nonzero if function being compiled doesn't contain any instructions\n   that can throw an exception.  This is set prior to final.  */\n\nextern int current_function_nothrow;\n\n/* Nonzero if function being compiled doesn't modify the stack pointer\n   (ignoring the prologue and epilogue).  This is only valid after\n   life_analysis has run.  */\n\nextern int current_function_sp_is_unchanging;\n\n/* Nonzero if the function being compiled is a leaf function which only\n   uses leaf registers.  This is valid after reload (specifically after\n   sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n\nextern int current_function_uses_only_leaf_regs;\n\n/* Default file in which to dump debug output.  */\n\n#ifdef BUFSIZ\nextern FILE *rtl_dump_file;\n#endif\n\n/* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */\nextern rtx current_insn_predicate;\n\n/* Last insn processed by final_scan_insn.  */\nextern rtx current_output_insn;\n\n/* Nonzero while outputting an `asm' with operands.\n   This means that inconsistencies are the user's fault, so don't abort.\n   The precise value is the insn being output, to pass to error_for_asm.  */\nextern rtx this_is_asm_operands;\n\n/* Decide whether DECL needs to be in a writable section.\n   RELOC is the same as for SELECT_SECTION.  */\nextern bool decl_readonly_section (tree, int);\nextern bool decl_readonly_section_1 (tree, int, int);\n\n/* This can be used to compute RELOC for the function above, when\n   given a constant expression.  */\nextern int compute_reloc_for_constant (tree);\n\n/* User label prefix in effect for this compilation.  */\nextern const char *user_label_prefix;\n\n/* Default target function prologue and epilogue assembler output.  */\nextern void default_function_pro_epilogue (FILE *, HOST_WIDE_INT);\n\n/* Tell assembler to switch to the section for the exception table.  */\nextern void default_exception_section (void);\n\n/* Tell assembler to switch to the section for the EH frames.  */\nextern void named_section_eh_frame_section (void);\nextern void collect2_eh_frame_section (void);\nextern void default_eh_frame_section (void);\n\n/* Default target hook that outputs nothing to a stream.  */\nextern void no_asm_to_stream (FILE *);\n\n/* Flags controlling properties of a section.  */\n#define SECTION_ENTSIZE\t 0x000ff\t/* entity size in section */\n#define SECTION_CODE\t 0x00100\t/* contains code */\n#define SECTION_WRITE\t 0x00200\t/* data is writable */\n#define SECTION_DEBUG\t 0x00400\t/* contains debug data */\n#define SECTION_LINKONCE 0x00800\t/* is linkonce */\n#define SECTION_SMALL\t 0x01000\t/* contains \"small data\" */\n#define SECTION_BSS\t 0x02000\t/* contains zeros only */\n#define SECTION_FORGET\t 0x04000\t/* forget that we've entered the section */\n#define SECTION_MERGE\t 0x08000\t/* contains mergeable data */\n#define SECTION_STRINGS  0x10000\t/* contains zero terminated strings without\n\t\t\t\t\t   embedded zeros */\n#define SECTION_OVERRIDE 0x20000\t/* allow override of default flags */\n#define SECTION_TLS\t 0x40000\t/* contains thread-local storage */\n#define SECTION_NOTYPE\t 0x80000\t/* don't output @progbits */\n#define SECTION_MACH_DEP 0x100000\t/* subsequent bits reserved for target */\n\nextern unsigned int get_named_section_flags (const char *);\nextern bool set_named_section_flags (const char *, unsigned int);\nextern void named_section_flags (const char *, unsigned int);\nextern bool named_section_first_declaration (const char *);\nextern unsigned int default_section_type_flags (tree, const char *, int);\nextern unsigned int default_section_type_flags_1 (tree, const char *, int, int);\n\nextern void default_no_named_section (const char *, unsigned int);\nextern void default_elf_asm_named_section (const char *, unsigned int);\nextern void default_coff_asm_named_section (const char *, unsigned int);\nextern void default_pe_asm_named_section (const char *, unsigned int);\n\nextern void default_stabs_asm_out_destructor (rtx, int);\nextern void default_named_section_asm_out_destructor (rtx, int);\nextern void default_dtor_section_asm_out_destructor (rtx, int);\nextern void default_stabs_asm_out_constructor (rtx, int);\nextern void default_named_section_asm_out_constructor (rtx, int);\nextern void default_ctor_section_asm_out_constructor (rtx, int);\n\nextern void default_select_section (tree, int, unsigned HOST_WIDE_INT);\nextern void default_elf_select_section (tree, int, unsigned HOST_WIDE_INT);\nextern void default_elf_select_section_1 (tree, int,\n\t\t\t\t\t  unsigned HOST_WIDE_INT, int);\nextern void default_unique_section (tree, int);\nextern void default_unique_section_1 (tree, int, int);\nextern void default_select_rtx_section (enum machine_mode, rtx,\n\t\t\t\t\tunsigned HOST_WIDE_INT);\nextern void default_elf_select_rtx_section (enum machine_mode, rtx,\n\t\t\t\t\t    unsigned HOST_WIDE_INT);\nextern void default_encode_section_info (tree, rtx, int);\nextern const char *default_strip_name_encoding (const char *);\nextern bool default_binds_local_p (tree);\nextern bool default_binds_local_p_1 (tree, int);\nextern void default_globalize_label (FILE *, const char *);\nextern void default_internal_label (FILE *, const char *, unsigned long);\nextern void default_file_start (void);\nextern void file_end_indicate_exec_stack (void);\nextern bool default_valid_pointer_mode (enum machine_mode);\n\nextern int default_address_cost (rtx);\n\n#endif /* ! GCC_OUTPUT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARAMS": {"ttr": 8965, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* params.h - Run-time parameters.\n   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.\n\n*/\n\n/* This module provides a means for setting integral parameters\n   dynamically.  Instead of encoding magic numbers in various places,\n   use this module to organize all the magic numbers in a single\n   place.  The values of the parameters can be set on the\n   command-line, thereby providing a way to control the amount of\n   effort spent on particular optimization passes, or otherwise tune\n   the behavior of the compiler.\n\n   Since their values can be set on the command-line, these parameters\n   should not be used for non-dynamic memory allocation.  */\n\n#ifndef GCC_PARAMS_H\n#define GCC_PARAMS_H\n\n/* No parameter shall have this value.  */\n\n#define INVALID_PARAM_VAL (-1)\n\n/* The information associated with each parameter.  */\n\ntypedef struct param_info\n{\n  /* The name used with the `--param <name>=<value>' switch to set this\n     value.  */\n  const char *const option;\n  /* The associated value.  */\n  int value;\n  /* A short description of the option.  */\n  const char *const help;\n} param_info;\n\n/* An array containing the compiler parameters and their current\n   values.  */\n\nextern param_info *compiler_params;\n\n/* Add the N PARAMS to the current list of compiler parameters.  */\n\nextern void add_params (const param_info params\u00dd\u00a8, size_t n);\n\n/* Set the VALUE associated with the parameter given by NAME.  */\n\nextern void set_param_value (const char *name, int value);\n\n\n/* The parameters in use by language-independent code.  */\n\ntypedef enum compiler_param\n{\n#define DEFPARAM(enumerator, option, msgid, default) \\\n  enumerator,\n#include \"params.def\"\n#undef DEFPARAM\n  LAST_PARAM\n} compiler_param;\n\n/* The value of the parameter given by ENUM.  */\n#define PARAM_VALUE(ENUM) \\\n  (compiler_params\u00dd(int) ENUM\u00a8.value)\n\n/* Macros for the various parameters.  */\n#define MAX_INLINE_INSNS_SINGLE \\\n  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)\n#define MAX_INLINE_INSNS \\\n  PARAM_VALUE (PARAM_MAX_INLINE_INSNS)\n#define MAX_INLINE_SLOPE \\\n  PARAM_VALUE (PARAM_MAX_INLINE_SLOPE)\n#define MIN_INLINE_INSNS \\\n  PARAM_VALUE (PARAM_MIN_INLINE_INSNS)\n#define MAX_INLINE_INSNS_AUTO \\\n  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO)\n#define MAX_INLINE_INSNS_RTL \\\n  PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RTL)\n#define MAX_DELAY_SLOT_INSN_SEARCH \\\n  PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n#define MAX_DELAY_SLOT_LIVE_SEARCH \\\n  PARAM_VALUE (PARAM_MAX_DELAY_SLOT_LIVE_SEARCH)\n#define MAX_PENDING_LIST_LENGTH \\\n  PARAM_VALUE (PARAM_MAX_PENDING_LIST_LENGTH)\n#define MAX_GCSE_MEMORY \\\n  ((size_t) PARAM_VALUE (PARAM_MAX_GCSE_MEMORY))\n#define MAX_GCSE_PASSES \\\n  PARAM_VALUE (PARAM_MAX_GCSE_PASSES)\n#define MAX_UNROLLED_INSNS \\\n  PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS)\n#define MAX_LAST_VALUE_RTL \\\n  PARAM_VALUE (PARAM_MAX_LAST_VALUE_RTL)\n#endif /* ! GCC_PARAMS_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARAMSD": {"ttr": 8967, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* params.def - Run-time parameters.\n   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.\n\n*/\n\n/* This file contains definitions for language-independent\n   parameters.  The DEFPARAM macro takes 4 arguments:\n\n     - The enumeral corresponding to this parameter.\n\n     - The name that can be used to set this parameter using the\n       command-line option `--param <name>=<value>'.\n\n     - A help string explaining how the parameter is used.\n\n     - A default value for the parameter.\n\n   Be sure to add an entry to invoke.texi summarizing the parameter.  */\n\n/* The single function inlining limit. This is the maximum size\n   of a function counted in internal gcc instructions (not in\n   real machine instructions) that is eligible for inlining\n   by the tree inliner.\n   The default value is 500.\n   Only functions marked inline (or methods defined in the class\n   definition for C++) are affected by this, unless you set the\n   -finline-functions (included in -O3) compiler option.\n   There are more restrictions to inlining: If inlined functions\n   call other functions, the already inlined instructions are\n   counted and once the recursive inline limit (see\n   \"max-inline-insns\" parameter) is exceeded, the acceptable size\n   gets decreased.  */\nDEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n\t  \"max-inline-insns-single\",\n\t  \"The maximum number of instructions in a single function eligible for inlining\",\n\t  500)\n\n/* The single function inlining limit for functions that are\n   inlined by virtue of -finline-functions (-O3).\n   This limit should be chosen to be below or equal to the limit\n   that is applied to functions marked inlined (or defined in the\n   class declaration in C++) given by the \"max-inline-insns-single\"\n   parameter.\n   The default value is 150.  */\nDEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n\t  \"max-inline-insns-auto\",\n\t  \"The maximum number of instructions when automatically inlining\",\n\t  100)\n\n/* For languages that (still) use the RTL inliner, we can specify\n   limits for the RTL inliner separately.\n   The parameter here defines the maximum number of RTL instructions\n   a function may have to be eligible for inlining in the RTL inliner.\n   The default value is 600.  */\nDEFPARAM (PARAM_MAX_INLINE_INSNS_RTL,\n\t  \"max-inline-insns-rtl\",\n\t  \"The maximum number of instructions for the RTL inliner\",\n\t  600)\n\n/* The maximum number of instructions to consider when looking for an\n   instruction to fill a delay slot.  If more than this arbitrary\n   number of instructions is searched, the time savings from filling\n   the delay slot will be minimal so stop searching.  Increasing\n   values mean more aggressive optimization, making the compile time\n   increase with probably small improvement in executable run time.  */\nDEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,\n\t  \"max-delay-slot-insn-search\",\n\t  \"The maximum number of instructions to consider to fill a delay slot\",\n\t  100)\n\n/* When trying to fill delay slots, the maximum number of instructions\n   to consider when searching for a block with valid live register\n   information.  Increasing this arbitrarily chosen value means more\n   aggressive optimization, increasing the compile time.  This\n   parameter should be removed when the delay slot code is rewritten\n   to maintain the control-flow graph.  */\nDEFPARAM(PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,\n\t \"max-delay-slot-live-search\",\n\t \"The maximum number of instructions to consider to find accurate live register information\",\n\t 333)\n\n/* This parameter limits the number of branch elements that the\n   scheduler will track anti-dependencies through without resetting\n   the tracking mechanism.  Large functions with few calls or barriers\n   can generate lists containing many 1000's of dependencies.  Generally\n   the compiler either uses all available memory, or runs for far too long.  */\nDEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n\t \"max-pending-list-length\",\n\t \"The maximum length of scheduling's pending operations list\",\n\t 32)\n\nDEFPARAM(PARAM_LARGE_FUNCTION_INSNS,\n\t \"large-function-insns\",\n\t \"The size of function body to be considered large\",\n\t 3000)\nDEFPARAM(PARAM_LARGE_FUNCTION_GROWTH,\n\t \"large-function-growth\",\n\t \"Maximal growth due to inlining of large function (in percent)\",\n\t 100)\nDEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n\t \"inline-unit-growth\",\n\t \"how much can given compilation unit grow because of the inlining (in percent)\",\n\t 50)\n\n/* The GCSE optimization will be disabled if it would require\n   significantly more memory than this value.  */\nDEFPARAM(PARAM_MAX_GCSE_MEMORY,\n\t \"max-gcse-memory\",\n\t \"The maximum amount of memory to be allocated by GCSE\",\n\t 50 * 1024 * 1024)\n/* The number of repetitions of copy/const prop and PRE to run.  */\nDEFPARAM(PARAM_MAX_GCSE_PASSES,\n\t\"max-gcse-passes\",\n\t\"The maximum number of passes to make when doing GCSE\",\n\t1)\n\n/* This parameter limits the number of insns in a loop that will be unrolled,\n   and by how much the loop is unrolled.\n\n   This limit should be at most half of the peeling limits:  loop unroller\n   decides to not unroll loops that iterate fewer than 2*number of allowed\n   unrollings and thus we would have loops that are neither peeled or unrooled\n   otherwise.  */\nDEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n\t \"max-unrolled-insns\",\n\t \"The maximum number of instructions to consider to unroll in a loop\",\n\t 200)\n/* This parameter limits how many times the loop is unrolled depending\n   on number of insns really executed in each iteration.  */\nDEFPARAM(PARAM_MAX_AVERAGE_UNROLLED_INSNS,\n\t \"max-average-unrolled-insns\",\n\t \"The maximum number of instructions to consider to unroll in a loop on average\",\n\t 80)\n/* The maximum number of unrollings of a single loop.  */\nDEFPARAM(PARAM_MAX_UNROLL_TIMES,\n\t\"max-unroll-times\",\n\t\"The maximum number of unrollings of a single loop\",\n\t8)\n/* The maximum number of insns of a peeled loop.  */\nDEFPARAM(PARAM_MAX_PEELED_INSNS,\n\t\"max-peeled-insns\",\n\t\"The maximum number of insns of a peeled loop\",\n\t400)\n/* The maximum number of peelings of a single loop.  */\nDEFPARAM(PARAM_MAX_PEEL_TIMES,\n\t\"max-peel-times\",\n\t\"The maximum number of peelings of a single loop\",\n\t16)\n/* The maximum number of insns of a peeled loop.  */\nDEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,\n\t\"max-completely-peeled-insns\",\n\t\"The maximum number of insns of a completely peeled loop\",\n\t400)\n/* The maximum number of peelings of a single loop that is peeled completely.  */\nDEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES,\n\t\"max-completely-peel-times\",\n\t\"The maximum number of peelings of a single loop that is peeled completely\",\n\t16)\n/* The maximum number of insns of a peeled loop that rolls only once.  */\nDEFPARAM(PARAM_MAX_ONCE_PEELED_INSNS,\n\t\"max-once-peeled-insns\",\n\t\"The maximum number of insns of a peeled loop that rolls only once\",\n\t400)\n\n/* The maximum number of insns of an unswitched loop.  */\nDEFPARAM(PARAM_MAX_UNSWITCH_INSNS,\n\t\"max-unswitch-insns\",\n\t\"The maximum number of insns of an unswitched loop\",\n\t50)\n/* The maximum level of recursion in unswitch_single_loop.  */\nDEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,\n\t\"max-unswitch-level\",\n\t\"The maximum number of unswitchings in a single loop\",\n\t3)\n\nDEFPARAM(HOT_BB_COUNT_FRACTION,\n\t \"hot-bb-count-fraction\",\n\t \"Select fraction of the maximal count of repetitions of basic block in \\\nprogram given basic block needs to have to be considered hot\",\n\t 10000)\nDEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n\t \"hot-bb-frequency-fraction\",\n\t \"Select fraction of the maximal frequency of executions of basic \\\nblock in function given basic block needs to have to be considered hot\",\n\t 1000)\nDEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,\n\t \"tracer-dynamic-coverage-feedback\",\n\t \"The percentage of function, weighted by execution frequency, that \\\nmust be covered by trace formation. Used when profile feedback is available\",\n\t 95)\nDEFPARAM(TRACER_DYNAMIC_COVERAGE,\n\t \"tracer-dynamic-coverage\",\n\t \"The percentage of function, weighted by execution frequency, that \\\nmust be covered by trace formation. Used when profile feedback is not available\",\n\t 75)\nDEFPARAM(TRACER_MAX_CODE_GROWTH,\n\t \"tracer-max-code-growth\",\n\t \"Maximal code growth caused by tail duplication (in percent)\",\n\t 100)\nDEFPARAM(TRACER_MIN_BRANCH_RATIO,\n\t \"tracer-min-branch-ratio\",\n\t \"Stop reverse growth if the reverse probability of best edge is less \\\nthan this threshold (in percent)\",\n\t 10)\nDEFPARAM(TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,\n\t \"tracer-min-branch-probability-feedback\",\n\t \"Stop forward growth if the probability of best edge is less than \\\nthis threshold (in percent). Used when profile feedback is available\",\n\t 80)\nDEFPARAM(TRACER_MIN_BRANCH_PROBABILITY,\n\t \"tracer-min-branch-probability\",\n\t \"Stop forward growth if the probability of best edge is less than \\\nthis threshold (in percent). Used when profile feedback is not available\",\n\t 50)\n\n/* The maximum number of incoming edges to consider for crossjumping.  */\nDEFPARAM(PARAM_MAX_CROSSJUMP_EDGES,\n\t \"max-crossjump-edges\",\n\t \"The maximum number of incoming edges to consider for crossjumping\",\n\t 100)\n\n/* The maximum length of path considered in cse.  */\nDEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,\n\t \"max-cse-path-length\",\n\t \"The maximum length of path considered in cse\",\n\t 10)\n\nDEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,\n\t \"max-cselib-memory-locations\",\n\t \"The maximum memory locations recorded by cselib\",\n\t 500)\n\nDEFPARAM(PARAM_MAX_LAST_VALUE_RTL,\n\t \"max-last-value-rtl\",\n\t \"The maximum number of RTL nodes that can be recorded as \\\ncombiner's last value\",\n\t 10000)\n\n  /* INTEGER_CST nodes are shared for values \u00dd{-1,0} .. N) for\n     {signed,unsigned} integral types.  This determines N.\n     Experimentation shows 256 to be a good value.  */\n#ifdef ENABLE_GC_ALWAYS_COLLECT\n# define GGC_MIN_EXPAND_DEFAULT 0\n# define GGC_MIN_HEAPSIZE_DEFAULT 0\n#else\n# define GGC_MIN_EXPAND_DEFAULT 30\n# define GGC_MIN_HEAPSIZE_DEFAULT 4096\n#endif\n\nDEFPARAM(GGC_MIN_EXPAND,\n\t \"ggc-min-expand\",\n\t \"Minimum heap expansion to trigger garbage collection, as \\\na percentage of the total size of the heap\",\n\t GGC_MIN_EXPAND_DEFAULT)\n\nDEFPARAM(GGC_MIN_HEAPSIZE,\n\t \"ggc-min-heapsize\",\n\t \"Minimum heap size before we start collecting garbage, in kilobytes\",\n\t GGC_MIN_HEAPSIZE_DEFAULT)\n\n#undef GGC_MIN_EXPAND_DEFAULT\n#undef GGC_MIN_HEAPSIZE_DEFAULT\n\nDEFPARAM(PARAM_MAX_RELOAD_SEARCH_INSNS,\n\t \"max-reload-search-insns\",\n\t \"The maximum number of instructions to search backward when looking for equivalent reload\",\n\t 100)\n\n/*\nLocal variables:\nmode:c\nEnd: */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARTITIO": {"ttr": 8970, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* List implementation of a partition of consecutive integers.\n   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n   Contributed by CodeSourcery, LLC.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to\n   the Free Software Foundation, 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This package implements a partition of consecutive integers.  The\n   elements are partitioned into classes.  Each class is represented\n   by one of its elements, the canonical element, which is chosen\n   arbitrarily from elements in the class.  The principal operations\n   on a partition are FIND, which takes an element, determines its\n   class, and returns the canonical element for that class, and UNION,\n   which unites the two classes that contain two given elements into a\n   single class.\n\n   The list implementation used here provides constant-time finds.  By\n   storing the size of each class with the class's canonical element,\n   it is able to perform unions over all the classes in the partition\n   in O (N log N) time.  */\n\n#ifndef _PARTITION_H\n#define _PARTITION_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include \"ansidecl.h\"\n#include <stdio.h>\n\nstruct partition_elem\n{\n  /* The canonical element that represents the class containing this\n     element.  */\n  int class_element;\n  /* The next element in this class.  Elements in each class form a\n     circular list.  */\n  struct partition_elem* next;\n  /* The number of elements in this class.  Valid only if this is the\n     canonical element for its class.  */\n  unsigned class_count;\n};\n\ntypedef struct partition_def\n{\n  /* The number of elements in this partition.  */\n  int num_elements;\n  /* The elements in the partition.  */\n  struct partition_elem elements\u00dd1\u00a8;\n} *partition;\n\nextern partition partition_new          PARAMS((int));\nextern void partition_delete            PARAMS((partition));\nextern int partition_union              PARAMS((partition,\n\t\t\t\t\t\tint,\n\t\t\t\t\t\tint));\nextern void partition_print             PARAMS((partition,\n\t\t\t\t\t\tFILE*));\n\n/* Returns the canonical element corresponding to the class containing\n   ELEMENT__ in PARTITION__.  */\n\n#define partition_find(partition__, element__) \\\n    ((partition__)->elements\u00dd(element__)\u00a8.class_element)\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _PARTITION_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PEX@COMM": {"ttr": 8972, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Utilities to execute a program in a subprocess (possibly linked by pipes\n   with other subprocesses), and wait for it.  Shared logic.\n   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of the libiberty library.\nLibiberty is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Library General Public\nLicense as published by the Free Software Foundation; either\nversion 2 of the License, or (at your option) any later version.\n\nLibiberty is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with libiberty; see the file COPYING.LIB.  If not,\nwrite to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef PEX_COMMON_H\n#define PEX_COMMON_H\n\n#include \"config.h\"\n#include \"libiberty.h\"\n\n#define install_error_msg \"installation problem, cannot exec `%s'\"\n\n/* stdin file number.  */\n#define STDIN_FILE_NO 0\n\n/* stdout file number.  */\n#define STDOUT_FILE_NO 1\n\n/* value of `pipe': port index for reading.  */\n#define READ_PORT 0\n\n/* value of `pipe': port index for writing.  */\n#define WRITE_PORT 1\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREDICT": {"ttr": 8974, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for branch prediction routines in the GNU compiler.\n   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#define DEF_PREDICTOR(ENUM, NAME, HITRATE, FLAGS) ENUM,\nenum br_predictor\n{\n#include \"predict.def\"\n\n  /* Upper bound on non-language-specific builtins.  */\n  END_PREDICTORS\n};\n#undef DEF_PREDICTOR\nenum prediction\n{\n   NOT_TAKEN,\n   TAKEN\n};\n\n/* Flags for NOTE_PREDICTION */\n#define IS_TAKEN 1\t\t/* Predict edges to the block as taken.  */\n\nextern void predict_insn_def (rtx, enum br_predictor, enum prediction);\nextern void predict_insn (rtx, enum br_predictor, int);\n\n/* Avoid unneeded dependency on basic_block.h.  */\n#ifdef BASIC_BLOCK\nextern void predict_edge (edge, enum br_predictor, int);\nextern void predict_edge_def (edge, enum br_predictor, enum prediction);\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREDICTD": {"ttr": 8976, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for the branch prediction routines in the GNU compiler.\n   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Before including this file, you should define a macro:\n\n     DEF_PREDICTOR (ENUM, NAME, HITRATE)\n\n   This macro will be called once for each predictor.  The ENUM will\n   be of type `enum predictor', and will enumerate all supported\n   predictors.  The order of DEF_PREDICTOR calls is important, as\n   in the first match combining heuristics, the predictor appearing\n   first in this file will win.\n\n   NAME is used in the debugging output to determine predictor type.\n\n   HITRATE is the probability that edge predicted by predictor as taken\n   will be really taken (so it should be always above\n   REG_BR_PROB_BASE / 2).  */\n\n\n/* A value used as final outcome of all heuristics.  */\nDEF_PREDICTOR (PRED_COMBINED, \"combined\", PROB_ALWAYS, 0)\n\n/* An outcome estimated by Dempster-Shaffer theory.  */\nDEF_PREDICTOR (PRED_DS_THEORY, \"DS theory\", PROB_ALWAYS, 0)\n\n/* An combined heuristics using probability determined by first\n   matching heuristics from this list.  */\nDEF_PREDICTOR (PRED_FIRST_MATCH, \"first match\", PROB_ALWAYS, 0)\n\n/* Heuristic applying when no heuristic below applies.  */\nDEF_PREDICTOR (PRED_NO_PREDICTION, \"no prediction\", PROB_ALWAYS, 0)\n\n/* Mark unconditional jump as taken.  */\nDEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Use number of loop iterations determined by loop unroller to set\n   probability.  We don't want to use Dempster-Shaffer theory here,\n   as the predictions is exact.  */\nDEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Hints dropped by user via __builtin_expect feature.  */\nDEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Branch containing goto is probably not taken.  */\nDEF_PREDICTOR (PRED_CONTINUE, \"continue\", HITRATE (56), 0)\n\n/* Branch to basic block containing call marked by noreturn attribute.  */\nDEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", HITRATE (99),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Loopback edge is taken.  */\nDEF_PREDICTOR (PRED_LOOP_BRANCH, \"loop branch\", HITRATE (89),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Edge causing loop to terminate is probably not taken.  */\nDEF_PREDICTOR (PRED_LOOP_EXIT, \"loop exit\", HITRATE (90),\n\t       PRED_FLAG_FIRST_MATCH)\n\n/* Condition emitted by preconditiong code to ensure that variable\n   setting number of iterations is greater than initial value of iterator.  */\nDEF_PREDICTOR (PRED_LOOP_CONDITION, \"loop condition\", PROB_VERY_LIKELY, 0)\n\n/* Preconditioning makes linear list of branches.  */\nDEF_PREDICTOR (PRED_LOOP_PRECONDITIONING, \"loop preconditioning\", PROB_VERY_LIKELY, 0)\n\n/* Copied condition for the first iteration of loop is probably true.  */\nDEF_PREDICTOR (PRED_LOOP_HEADER, \"loop header\", HITRATE (64), 0)\n\n/* Pointers are usually not NULL.  */\nDEF_PREDICTOR (PRED_POINTER, \"pointer\", HITRATE (81), 0)\n\n/* NE is probable, EQ not etc...  */\nDEF_PREDICTOR (PRED_OPCODE_POSITIVE, \"opcode values positive\", HITRATE (79), 0)\nDEF_PREDICTOR (PRED_OPCODE_NONEQUAL, \"opcode values nonequal\", HITRATE (71), 0)\nDEF_PREDICTOR (PRED_FPOPCODE, \"fp_opcode\", HITRATE (90), 0)\n\n/* Branch guarding call is probably taken.  */\nDEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)\n\n/* Branch causing function to terminate is probably not taken.  */\nDEF_PREDICTOR (PRED_EARLY_RETURN, \"early return\", HITRATE (67), 0)\n\n/* Branch containing goto is probably not taken.  */\nDEF_PREDICTOR (PRED_GOTO, \"goto\", HITRATE (70), 0)\n\n/* Branch ending with return constant is probably not taken.  */\nDEF_PREDICTOR (PRED_CONST_RETURN, \"const return\", HITRATE (95), 0)\n\n/* Branch ending with return negative constant is probably not taken.  */\nDEF_PREDICTOR (PRED_NEGATIVE_RETURN, \"negative return\", HITRATE (96), 0)\n\n/* Branch ending with return; is probably not taken */\nDEF_PREDICTOR (PRED_NULL_RETURN, \"null return\", HITRATE (90), 0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREFIX": {"ttr": 8978, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Provide prototypes for functions exported from prefix.c.\n   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Library General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or (at\nyour option) any later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n\n#ifndef GCC_PREFIX_H\n#define GCC_PREFIX_H\n\n/* Update PATH using KEY if PATH starts with PREFIX.  The returned\n   string is always malloc-ed, and the caller is responsible for\n   freeing it.  */\nextern char *update_path (const char *path, const char *key);\nextern void set_std_prefix (const char *, int);\n\n#endif /* ! GCC_PREFIX_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRETTY@P": {"ttr": 9217, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Various declarations for language-independent pretty-print subroutines.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n   Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_PRETTY_PRINT_H\n#define GCC_PRETTY_PRINT_H\n\n#include \"obstack.h\"\n#include \"input.h\"\n\n/* The type of a text to be formatted according a format specification\n   along with a list of things.  */\ntypedef struct\n{\n  const char *format_spec;\n  va_list *args_ptr;\n  int err_no;  /* for %m */\n} text_info;\n\n/* How often diagnostics are prefixed by their locations:\n   o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n   o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;\n   o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical\n   line is started.  */\ntypedef enum\n{\n  DIAGNOSTICS_SHOW_PREFIX_ONCE       = 0x0,\n  DIAGNOSTICS_SHOW_PREFIX_NEVER      = 0x1,\n  DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2\n} diagnostic_prefixing_rule_t;\n\n/* The output buffer datatype.  This is best seen as an abstract datatype\n   whose fields should not be accessed directly by clients.  */\ntypedef struct\n{\n  /* The obstack where the text is built up.  */\n  struct obstack obstack;\n\n  /* Where to output formatted text.  */\n  FILE *stream;\n\n  /* The amount of characters output so far.  */\n  int line_length;\n\n  /* This must be large enough to hold any printed integer or\n     floating-point value.  */\n  char digit_buffer\u00dd128\u00a8;\n} output_buffer;\n\n/* The type of pretty-printer flags passed to clients.  */\ntypedef unsigned int pp_flags;\n\ntypedef enum\n{\n  pp_none, pp_before, pp_after\n} pp_padding;\n\n/* The type of a hook that formats client-specific data onto a pretty_pinter.\n   A client-supplied formatter returns true if everything goes well,\n   otherwise it returns false.  */\ntypedef struct pretty_print_info pretty_printer;\ntypedef bool (*printer_fn) (pretty_printer *, text_info *);\n\n/* Client supplied function used to decode formats.  */\n#define pp_format_decoder(PP) pp_base (PP)->format_decoder\n\n/* TRUE if a newline character needs to be added before further\n   formatting.  */\n#define pp_needs_newline(PP)  pp_base (PP)->need_newline\n\n/* Maximum characters per line in automatic line wrapping mode.\n   Zero means don't wrap lines.  */\n#define pp_line_cutoff(PP)  pp_base (PP)->ideal_maximum_length\n\n/* True if PRETTY-PTINTER is in line-wrapping mode.  */\n#define pp_is_wrapping_line(PP) (pp_line_cutoff (PP) > 0)\n\n/* Prefixing rule used in formatting a diagnostic message.  */\n#define pp_prefixing_rule(PP)  pp_base (PP)->prefixing_rule\n\n/* The amount of whitespace to be emitted when starting a new line.  */\n#define pp_indentation(PP) pp_base (PP)->indent_skip\n\n/* The data structure that contains the bare minimum required to do\n   proper pretty-printing.  Clients may derived from this structure\n   and add additional fields they need.  */\nstruct pretty_print_info\n{\n  /* Where we print external representation of ENTITY.  */\n  output_buffer *buffer;\n\n  /* The prefix for each new line.  */\n  const char *prefix;\n\n  /* Where to put whitespace around the entity being formatted.  */\n  pp_padding padding;\n\n  /* The real upper bound of number of characters per line, taking into\n     account the case of a very very looong prefix.  */\n  int maximum_length;\n\n  /* The ideal upper bound of number of characters per line, as suggested\n     by front-end.  */\n  int ideal_maximum_length;\n\n  /* Indentation count.  */\n  int indent_skip;\n\n  /* Current prefixing rule.  */\n  diagnostic_prefixing_rule_t prefixing_rule;\n\n  /* If non-NULL, this function formats a TEXT into the BUFFER.  When called,\n     TEXT->format_spec points to a format code.  FORMAT_DECODER should call\n     pp_string (and related functions) to add data to the BUFFER.\n     FORMAT_DECODER can read arguments from *TEXT->args_pts using VA_ARG.\n     If the BUFFER needs additional characters from the format string, it\n     should advance the TEXT->format_spec as it goes.  When FORMAT_DECODER\n     returns, TEXT->format_spec should point to the last character processed.\n  */\n  printer_fn format_decoder;\n\n  /* Nonzero if current PREFIX was emitted at least once.  */\n  bool emitted_prefix;\n\n  /* Nonzero means one should emit a newline before outputting anything.  */\n  bool need_newline;\n};\n\n#define pp_set_line_maximum_length(PP, L) \\\n   pp_base_set_line_maximum_length (pp_base (PP), L)\n#define pp_set_prefix(PP, P)    pp_base_set_prefix (pp_base (PP), P)\n#define pp_destroy_prefix(PP)   pp_base_destroy_prefix (pp_base (PP))\n#define pp_remaining_character_count_for_line(PP) \\\n  pp_base_remaining_character_count_for_line (pp_base (PP))\n#define pp_clear_output_area(PP) \\\n  pp_base_clear_output_area (pp_base (PP))\n#define pp_formatted_text(PP)   pp_base_formatted_text (pp_base (PP))\n#define pp_last_position_in_text(PP) \\\n  pp_base_last_position_in_text (pp_base (PP))\n#define pp_emit_prefix(PP)      pp_base_emit_prefix (pp_base (PP))\n#define pp_append_text(PP, B, E) \\\n  pp_base_append_text (pp_base (PP), B, E)\n#define pp_flush(PP)            pp_base_flush (pp_base (PP))\n#define pp_format_text(PP, TI)  pp_base_format_text (pp_base (PP), TI)\n#define pp_format_verbatim(PP, TI) \\\n  pp_base_format_verbatim (pp_base (PP), TI)\n\n#define pp_character(PP, C)     pp_base_character (pp_base (PP), C)\n#define pp_string(PP, S)        pp_base_string (pp_base (PP), S)\n#define pp_newline(PP)          pp_base_newline (pp_base (PP))\n\n#define pp_space(PP)            pp_character (PP, ' ')\n#define pp_left_paren(PP)       pp_character (PP, '(')\n#define pp_right_paren(PP)      pp_character (PP, ')')\n#define pp_left_bracket(PP)     pp_character (PP, '\u00dd')\n#define pp_right_bracket(PP)    pp_character (PP, '\u00a8')\n#define pp_left_brace(PP)       pp_character (PP, '{')\n#define pp_right_brace(PP)      pp_character (PP, '}')\n#define pp_semicolon(PP)        pp_character (PP, ';')\n#define pp_comma(PP)            pp_string (PP, \", \")\n#define pp_dot(PP)              pp_character (PP, '.')\n#define pp_colon(PP)            pp_character (PP, ':')\n#define pp_colon_colon(PP)      pp_string (PP, \"::\")\n#define pp_arrow(PP)            pp_string (PP, \"->\")\n#define pp_equal(PP)            pp_character (PP, '=')\n#define pp_question(PP)         pp_character (PP, '?')\n#define pp_bar(PP)              pp_character (PP, '|')\n#define pp_carret(PP)           pp_character (PP, '\u00ac')\n#define pp_ampersand(PP)        pp_character (PP, '&')\n#define pp_less(PP)             pp_character (PP, '<')\n#define pp_greater(PP)          pp_character (PP, '>')\n#define pp_plus(PP)             pp_character (PP, '+')\n#define pp_minus(PP)            pp_character (PP, '-')\n#define pp_star(PP)             pp_character (PP, '*')\n#define pp_slash(PP)            pp_character (PP, '/')\n#define pp_modulo(PP)           pp_character (PP, '%')\n#define pp_exclamation(PP)      pp_character (PP, '!')\n#define pp_complement(PP)       pp_character (PP, '~')\n#define pp_quote(PP)            pp_character (PP, '\\'')\n#define pp_backquote(PP)        pp_character (PP, '`')\n#define pp_doublequote(PP)      pp_character (PP, '\"')\n#define pp_newline_and_indent(PP, N) \\\n  do {                               \\\n    pp_indentation (PP) += N;        \\\n    pp_newline (PP);                 \\\n    pp_base_indent (pp_base (PP));   \\\n    pp_needs_newline (PP) = false;   \\\n  } while (0)\n#define pp_maybe_newline_and_indent(PP, N) \\\n  if (pp_needs_newline (PP)) pp_newline_and_indent (PP, N)\n#define pp_separate_with(PP, C)     \\\n   do {                             \\\n     pp_character (PP, C);          \\\n     pp_space (PP);                 \\\n   } while (0)\n#define pp_scalar(PP, FORMAT, SCALAR)\t                      \\\n  do\t\t\t\t\t        \t      \\\n    {\t\t\t         \t\t\t      \\\n      sprintf (pp_buffer (PP)->digit_buffer, FORMAT, SCALAR); \\\n      pp_string (PP, pp_buffer (PP)->digit_buffer);           \\\n    }\t\t\t\t\t\t              \\\n  while (0)\n#define pp_decimal_int(PP, I)  pp_scalar (PP, \"%d\", I)\n#define pp_wide_integer(PP, I) \\\n   pp_scalar (PP, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) I)\n#define pp_pointer(PP, P)      pp_scalar (PP, \"%p\", P)\n\n#define pp_identifier(PP, ID)  pp_string (PP, ID)\n#define pp_tree_identifier(PP, T)                      \\\n  pp_append_text(PP, IDENTIFIER_POINTER (T), \\\n                 IDENTIFIER_POINTER (T) + IDENTIFIER_LENGTH (T))\n\n#define pp_unsupported_tree(PP, T)                         \\\n  pp_verbatim (pp_base (PP), \"#`%s' not supported by %s#\", \\\n               tree_code_name\u00dd(int) TREE_CODE (T)\u00a8, __FUNCTION__)\n\n\n#define pp_buffer(PP) pp_base (PP)->buffer\n/* Clients that directly derive from pretty_printer need to override\n   this macro to return a pointer to the base pretty_printer structure.  */\n#define pp_base(PP) (PP)\n\nextern void pp_construct (pretty_printer *, const char *, int);\nextern void pp_base_set_line_maximum_length (pretty_printer *, int);\nextern void pp_base_set_prefix (pretty_printer *, const char *);\nextern void pp_base_destroy_prefix (pretty_printer *);\nextern int pp_base_remaining_character_count_for_line (pretty_printer *);\nextern void pp_base_clear_output_area (pretty_printer *);\nextern const char *pp_base_formatted_text (pretty_printer *);\nextern const char *pp_base_last_position_in_text (const pretty_printer *);\nextern void pp_base_emit_prefix (pretty_printer *);\nextern void pp_base_append_text (pretty_printer *, const char *, const char *);\nextern void pp_printf (pretty_printer *, const char *, ...) ATTRIBUTE_PRINTF_2;\nextern void pp_verbatim (pretty_printer *, const char *, ...);\nextern void pp_base_flush (pretty_printer *);\nextern void pp_base_format_text (pretty_printer *, text_info *);\nextern void pp_base_format_verbatim (pretty_printer *, text_info *);\n\nextern void pp_base_indent (pretty_printer *);\nextern void pp_base_newline (pretty_printer *);\nextern void pp_base_character (pretty_printer *, int);\nextern void pp_base_string (pretty_printer *, const char *);\n\n#endif /* GCC_PRETTY_PRINT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PUREISO": {"ttr": 9220, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#define DEFAULT_TARGET_VERSION \"3.4.6\"\n#define DEFAULT_TARGET_MACHINE \"i370-ibm-mvspdp\"\n#define STANDARD_EXEC_PREFIX \"\"\n#define STANDARD_STARTFILE_PREFIX \"\"\n#define TOOLDIR_BASE_PREFIX \"\"\n#define STANDARD_BINDIR_PREFIX \"\"\n#define STANDARD_LIBEXEC_PREFIX \"\"\n#ifndef TARGET_NAME\n#define TARGET_NAME \"i370-mvspdp\"\n#endif\n#ifndef HOST_MACHINE\n#define HOST_MACHINE \"i370-ibm-mvspdp\"\n#endif\n#define TARGET_MACHINE \"i370-ibm-mvspdp\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RA": {"ttr": 9222, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Graph coloring register allocator\n   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n   Contributed by Michael Matz <matz@suse.de>\n   and Daniel Berlin <dan@cgsoftware.com>.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it under the\n   terms of the GNU General Public License as published by the Free Software\n   Foundation; either version 2, or (at your option) any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n   details.\n\n   You should have received a copy of the GNU General Public License along\n   with GCC; see the file COPYING.  If not, write to the Free Software\n   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n/* Double linked list to implement the per-type lists of webs\n   and moves.  */\nstruct dlist\n{\n  struct dlist *prev;\n  struct dlist *next;\n  union\n    {\n      struct web *web;\n      struct move *move;\n    } value;\n};\n/* Simple helper macros for ease of misuse.  */\n#define DLIST_WEB(l) ((l)->value.web)\n#define DLIST_MOVE(l) ((l)->value.move)\n\n/* Classification of a given node (i.e. what state it's in).  */\nenum node_type\n{\n  INITIAL = 0, FREE,\n  PRECOLORED,\n  SIMPLIFY, SIMPLIFY_SPILL, SIMPLIFY_FAT, FREEZE, SPILL,\n  SELECT,\n  SPILLED, COALESCED, COLORED,\n  LAST_NODE_TYPE\n};\n\n/* A list of conflict bitmaps, factorized on the exact part of\n   the source, which conflicts with the DEFs, whose ID are noted in\n   the bitmap.  This is used while building web-parts with conflicts.  */\nstruct tagged_conflict\n{\n  struct tagged_conflict *next;\n  bitmap conflicts;\n\n  /* If the part of source identified by size S, byteoffset O conflicts,\n     then size_word == S | (O << 16).  */\n  unsigned int size_word;\n};\n\n/* Such a structure is allocated initially for each def and use.\n   In the process of building the interference graph web parts are\n   connected together, if they have common instructions and reference the\n   same register.  That way live ranges are build (by connecting defs and\n   uses) and implicitly complete webs (by connecting web parts in common\n   uses).  */\nstruct web_part\n{\n  /* The def or use for this web part.  */\n  struct ref *ref;\n  /* The uplink implementing the disjoint set.  */\n  struct web_part *uplink;\n\n  /* Here dynamic information associated with each def/use is saved.\n     This all is only valid for root web parts (uplink==NULL).\n     That's the information we need to merge, if web parts are unioned.  */\n\n  /* Number of spanned insns containing any deaths.  */\n  unsigned int spanned_deaths;\n  /* The list of bitmaps of DEF ID's with which this part conflicts.  */\n  struct tagged_conflict *sub_conflicts;\n  /* If there's any call_insn, while this part is live.  */\n  unsigned int crosses_call : 1;\n};\n\n/* Web structure used to store info about connected live ranges.\n   This represents the nodes of the interference graph, which gets\n   colored.  It can also hold subwebs, which are contained in webs\n   and represent subregs.  */\nstruct web\n{\n  /* Unique web ID.  */\n  unsigned int id;\n\n  /* Register number of the live range's variable.  */\n  unsigned int regno;\n\n  /* How many insns containing deaths do we span?  */\n  unsigned int span_deaths;\n\n  /* Spill_temp indicates if this web was part of a web spilled in the\n     last iteration, or or reasons why this shouldn't be spilled again.\n     1 spill web, can't be spilled.\n     2 big spill web (live over some deaths).  Discouraged, but not\n       impossible to spill again.\n     3 short web (spans no deaths), can't be spilled.  */\n  unsigned int spill_temp;\n\n  /* When coalescing we might change spill_temp.  If breaking aliases we\n     need to restore it.  */\n  unsigned int orig_spill_temp;\n\n  /* Cost of spilling.  */\n  unsigned HOST_WIDE_INT spill_cost;\n  unsigned HOST_WIDE_INT orig_spill_cost;\n\n  /* How many webs are aliased to us?  */\n  unsigned int num_aliased;\n\n  /* The color we got.  This is a hardreg number.  */\n  int color;\n  /* 1 + the color this web got in the last pass.  If it hadn't got a color,\n     or we are in the first pass, or this web is a new one, this is zero.  */\n  int old_color;\n\n  /* Now follow some flags characterizing the web.  */\n\n  /* Nonzero, if we should use usable_regs for this web, instead of\n     preferred_class() or alternate_class().  */\n  unsigned int use_my_regs:1;\n\n  /* Nonzero if we selected this web as possible spill candidate in\n     select_spill().  */\n  unsigned int was_spilled:1;\n\n  /* We need to distinguish also webs which are targets of coalescing\n     (all x with some y, so that x==alias(y)), but the alias field is\n     only set for sources of coalescing.  This flag is set for all webs\n     involved in coalescing in some way.  */\n  unsigned int is_coalesced:1;\n\n  /* Nonzero, if this web (or subweb) doesn't correspond with any of\n     the current functions actual use of reg rtx.  Happens e.g. with\n     conflicts to a web, of which only a part was still undefined at the\n     point of that conflict.  In this case we construct a subweb\n     representing these yet undefined bits to have a target for the\n     conflict.  Suppose e.g. this sequence:\n     (set (reg:DI x) ...)\n     (set (reg:SI y) ...)\n     (set (subreg:SI (reg:DI x) 0) ...)\n     (use (reg:DI x))\n     Here x only partly conflicts with y.  Namely only (subreg:SI (reg:DI x)\n     1) conflicts with it, but this rtx doesn't show up in the program.  For\n     such things an \"artificial\" subweb is built, and this flag is true for\n     them.  */\n  unsigned int artificial:1;\n\n  /* Nonzero if we span a call_insn.  */\n  unsigned int crosses_call:1;\n\n  /* Wether the web is involved in a move insn.  */\n  unsigned int move_related:1;\n\n  /* 1 when this web (or parts thereof) are live over an abnormal edge.  */\n  unsigned int live_over_abnormal:1;\n\n  /* Nonzero if this web is used in subregs where the mode change\n     was illegal for hardregs in CLASS_CANNOT_CHANGE_MODE.  */\n  unsigned int mode_changed:1;\n\n  /* Nonzero if some references of this web, where in subreg context,\n     but the actual subreg is already stripped (i.e. we don't know the\n     outer mode of the actual reference).  */\n  unsigned int subreg_stripped:1;\n\n  /* Nonzero, when this web stems from the last pass of the allocator,\n     and all info is still valid (i.e. it wasn't spilled).  */\n  unsigned int old_web:1;\n\n  /* Used in rewrite_program2() to remember webs, which\n     are already marked for (re)loading.  */\n  unsigned int in_load:1;\n\n  /* If in_load is != 0, then this is nonzero, if only one use was seen\n     since insertion in loadlist.  Zero if more uses currently need a\n     reload.  Used to differentiate between inserting register loads or\n     directly substituting the stackref.  */\n  unsigned int one_load:1;\n\n  /* When using rewrite_program2() this flag gets set if some insns\n     were inserted on behalf of this web.  IR spilling might ignore some\n     deaths up to the def, so no code might be emitted and we need not to\n     spill such a web again.  */\n  unsigned int changed:1;\n\n  /* With interference region spilling it's sometimes the case, that a\n     bb border is also an IR border for webs, which were targets of moves,\n     which are already removed due to coalescing.  All webs, which are\n     a destination of such a removed move, have this flag set.  */\n  unsigned int target_of_spilled_move:1;\n\n  /* For optimistic coalescing we need to be able to break aliases, which\n     includes restoring conflicts to those before coalescing.  This flag\n     is set, if we have a list of conflicts before coalescing.  It's needed\n     because that list is lazily constructed only when actually needed.  */\n  unsigned int have_orig_conflicts:1;\n\n  /* Current state of the node.  */\n  ENUM_BITFIELD(node_type) type:5;\n\n  /* A regclass, combined from preferred and alternate class, or calculated\n     from usable_regs.  Used only for debugging, and to determine\n     add_hardregs.  */\n  ENUM_BITFIELD(reg_class) regclass:10;\n\n  /* Additional consecutive hardregs needed for this web.  */\n  int add_hardregs;\n\n  /* Number of conflicts currently.  */\n  int num_conflicts;\n\n  /* Numbers of uses and defs, which belong to this web.  */\n  unsigned int num_uses;\n  unsigned int num_defs;\n\n  /* The (reg:M a) or (subreg:M1 (reg:M2 a) x) rtx which this\n     web is based on.  This is used to distinguish subreg webs\n     from it's reg parents, and to get hold of the mode.  */\n  rtx orig_x;\n\n  /* If this web is a subweb, this point to the super web.  Otherwise\n     it's NULL.  */\n  struct web *parent_web;\n\n  /* If this web is a subweb, but not the last one, this points to the\n     next subweb of the same super web.  Otherwise it's NULL.  */\n  struct web *subreg_next;\n\n  /* The set of webs (or subwebs), this web conflicts with.  */\n  struct conflict_link *conflict_list;\n\n  /* If have_orig_conflicts is set this contains a copy of conflict_list,\n     as it was right after building the interference graph.\n     It's used for incremental i-graph building and for breaking\n     coalescings again.  */\n  struct conflict_link *orig_conflict_list;\n\n  /* Bitmap of all conflicts which don't count this pass, because of\n     non-intersecting hardregs of the conflicting webs.  See also\n     record_conflict().  */\n  bitmap useless_conflicts;\n\n  /* Different sets of hard registers, for all usable registers, ...  */\n  HARD_REG_SET usable_regs;\n  /* ... the same before coalescing, ...  */\n  HARD_REG_SET orig_usable_regs;\n  /* ... colors of all already colored neighbors (used when biased coloring\n     is active), and ...  */\n  HARD_REG_SET bias_colors;\n  /* ... colors of PRECOLORED webs this web is connected to by a move.  */\n  HARD_REG_SET prefer_colors;\n\n  /* Number of usable colors in usable_regs.  */\n  int num_freedom;\n\n  /* After successful coloring the graph each web gets a new reg rtx,\n     with which the original uses and defs are replaced.  This is it.  */\n  rtx reg_rtx;\n\n  /* While spilling this is the rtx of the home of spilled webs.\n     It can be a mem ref (a stack slot), or a pseudo register.  */\n  rtx stack_slot;\n\n  /* Used in rewrite_program2() to remember the using\n     insn last seen for webs needing (re)loads.  */\n  rtx last_use_insn;\n\n  /* If this web is rematerializable, this contains the RTL pattern\n     usable as source for that.  Otherwise it's NULL.  */\n  rtx pattern;\n\n  /* All the defs and uses.  There are num_defs, resp.\n     num_uses elements.  */\n  struct ref **defs; /* \u00dd0..num_defs-1\u00a8 */\n  struct ref **uses; /* \u00dd0..num_uses-1\u00a8 */\n\n  /* The web to which this web is aliased (coalesced).  If NULL, this\n     web is not coalesced into some other (but might still be a target\n     for other webs).  */\n  struct web *alias;\n\n  /* With iterated coalescing this is a list of active moves this web\n     is involved in.  */\n  struct move_list *moves;\n\n  /* The list implementation.  */\n  struct dlist *dlink;\n\n  /* While building webs, out of web-parts, this holds a (partial)\n     list of all refs for this web seen so far.  */\n  struct df_link *temp_refs;\n};\n\n/* For implementing a single linked list.  */\nstruct web_link\n{\n  struct web_link *next;\n  struct web *web;\n};\n\n/* A subconflict is part of a conflict edge to track precisely,\n   which parts of two webs conflict, in case not all of both webs do.  */\nstruct sub_conflict\n{\n  /* The next partial conflict.  For one such list the parent-web of\n     all the S webs, resp. the parent of all the T webs are constant.  */\n  struct sub_conflict *next;\n  struct web *s;\n  struct web *t;\n};\n\n/* This represents an edge in the conflict graph.  */\nstruct conflict_link\n{\n  struct conflict_link *next;\n\n  /* The web we conflict with (the Target of the edge).  */\n  struct web *t;\n\n  /* If not the complete source web and T conflict, this points to\n     the list of parts which really conflict.  */\n  struct sub_conflict *sub;\n};\n\n/* For iterated coalescing the moves can be in these states.  */\nenum move_type\n{\n  WORKLIST, MV_COALESCED, CONSTRAINED, FROZEN, ACTIVE,\n  LAST_MOVE_TYPE\n};\n\n/* Structure of a move we are considering coalescing.  */\nstruct move\n{\n  rtx insn;\n  struct web *source_web;\n  struct web *target_web;\n  enum move_type type;\n  struct dlist *dlink;\n};\n\n/* List of moves.  */\nstruct move_list\n{\n  struct move_list *next;\n  struct move *move;\n};\n\n/* To have fast access to the defs and uses per insn, we have one such\n   structure per insn.  The difference to the normal df.c structures is,\n   that it doesn't contain any NULL refs, which df.c produces in case\n   an insn was modified and it only contains refs to pseudo regs, or to\n   hardregs which matter for allocation, i.e. those not in\n   never_use_colors.  */\nstruct ra_insn_info\n{\n  unsigned int num_defs, num_uses;\n  struct ref **defs, **uses;\n};\n\n/* The above structures are stored in this array, indexed by UID...  */\nextern struct ra_insn_info *insn_df;\n/* ... and the size of that array, as we add insn after setting it up.  */\nextern int insn_df_max_uid;\n\n/* The interference graph.  */\nextern sbitmap igraph;\n/* And how to access it.  I and J are web indices.  If the bit\n   igraph_index(I, J) is set, then they conflict.  Note, that\n   if only parts of webs conflict, then also only those parts\n   are noted in the I-graph (i.e. the parent webs not).  */\n#define igraph_index(i, j) ((i) < (j) ? ((j)*((j)-1)/2)+(i) : ((i)*((i)-1)/2)+(j))\n/* This is the bitmap of all (even partly) conflicting super webs.\n   If bit I*num_webs+J or J*num_webs+I is set, then I and J (both being\n   super web indices) conflict, maybe only partially.  Note the\n   asymmetry.  */\nextern sbitmap sup_igraph;\n\n/* After the first pass, and when interference region spilling is\n   activated, bit I is set, when the insn with UID I contains some\n   refs to pseudos which die at the insn.  */\nextern sbitmap insns_with_deaths;\n/* The size of that sbitmap.  */\nextern int death_insns_max_uid;\n\n/* All the web-parts.  There are exactly as many web-parts as there\n   are register refs in the insn stream.  */\nextern struct web_part *web_parts;\n\n/* The number of all webs, including subwebs.  */\nextern unsigned int num_webs;\n/* The number of just the subwebs.  */\nextern unsigned int num_subwebs;\n/* The number of all webs, including subwebs.  */\nextern unsigned int num_allwebs;\n\n/* For easy access when given a web ID: id2web\u00ddW->id\u00a8 == W.  */\nextern struct web **id2web;\n/* For each hardreg, the web which represents it.  */\nextern struct web *hardreg2web\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Given the ID of a df_ref, which represent a DEF, def2web\u00ddID\u00a8 is\n   the web, to which this def belongs.  */\nextern struct web **def2web;\n/* The same as def2web, just for uses.  */\nextern struct web **use2web;\n\n/* The list of all recognized and coalescable move insns.  */\nextern struct move_list *wl_moves;\n\n\n/* Some parts of the compiler which we run after colorizing\n   clean reg_renumber\u00dd\u00a8, so we need another place for the colors.\n   This is copied to reg_renumber\u00dd\u00a8 just before returning to toplev.  */\nextern short *ra_reg_renumber;\n/* The size of that array.  Some passes after coloring might have created\n   new pseudos, which will get no color.  */\nextern int ra_max_regno;\n\n/* The dataflow structure of the current function, while regalloc\n   runs.  */\nextern struct df *df;\n\n/* For each basic block B we have a bitmap of DF_REF_ID's of uses,\n   which backward reach the end of B.  */\nextern bitmap *live_at_end;\n\n/* One pass is: collecting registers refs, building I-graph, spilling.\n   And this is how often we already ran that for the current function.  */\nextern int ra_pass;\n\n/* The maximum pseudo regno, just before register allocation starts.\n   While regalloc runs all pseudos with a larger number represent\n   potentially stack slots or hardregs.  I call them stackwebs or\n   stackpseudos.  */\nextern unsigned int max_normal_pseudo;\n\n/* One of the fixed colors.  It must be < FIRST_PSEUDO_REGISTER, because\n   we sometimes want to check the color against a HARD_REG_SET.  It must\n   be >= 0, because negative values mean \"no color\".\n   This color is used for the above stackwebs, when they can't be colored.\n   I.e. normally they would be spilled, but they already represent\n   stackslots.  So they are colored with an invalid color.  It has\n   the property that even webs which conflict can have that color at the\n   same time.  I.e. a stackweb with that color really represents a\n   stackslot.  */\nextern int an_unusable_color;\n\n/* While building the I-graph, every time insn UID is looked at,\n   number_seen\u00ddUID\u00a8 is incremented.  For debugging.  */\nextern int *number_seen;\n\n/* The different lists on which a web can be (based on the type).  */\nextern struct dlist *web_lists\u00dd(int) LAST_NODE_TYPE\u00a8;\n#define WEBS(type) (web_lists\u00dd(int)(type)\u00a8)\n\n/* The largest DF_REF_ID of defs resp. uses, as it was in the\n   last pass.  In the first pass this is zero.  Used to distinguish new\n   from old references.  */\nextern unsigned int last_def_id;\nextern unsigned int last_use_id;\n\n/* Similar for UIDs and number of webs.  */\nextern int last_max_uid;\nextern unsigned int last_num_webs;\n\n/* If I is the ID of an old use, and last_check_uses\u00ddI\u00a8 is set,\n   then we must reevaluate it's flow while building the new I-graph.  */\nextern sbitmap last_check_uses;\n\n/* If nonzero, record_conflict() saves the current conflict list of\n   webs in orig_conflict_list, when not already done so, and the conflict\n   list is going to be changed.  It is set, after initially building the\n   I-graph.  I.e. new conflicts due to coalescing trigger that copying.  */\nextern unsigned int remember_conflicts;\n\n/* The maximum UID right before calling regalloc().\n   Used to detect any instructions inserted by the allocator.  */\nextern int orig_max_uid;\n\n/* A HARD_REG_SET of those color, which can't be used for coalescing.\n   Includes e.g. fixed_regs.  */\nextern HARD_REG_SET never_use_colors;\n/* For each class C this is reg_class_contents\u00ddC\u00a8 \\ never_use_colors.  */\nextern HARD_REG_SET usable_regs\u00ddN_REG_CLASSES\u00a8;\n/* For each class C the count of hardregs in usable_regs\u00ddC\u00a8.  */\nextern unsigned int num_free_regs\u00ddN_REG_CLASSES\u00a8;\n/* For each mode M the hardregs, which are MODE_OK for M, and have\n   enough space behind them to hold an M value.  Additionally\n   if reg R is OK for mode M, but it needs two hardregs, then R+1 will\n   also be set here, even if R+1 itself is not OK for M.  I.e. this\n   represent the possible resources which could be taken away be a value\n   in mode M.  */\nextern HARD_REG_SET hardregs_for_mode\u00ddNUM_MACHINE_MODES\u00a8;\n/* The set of hardregs, for which _any_ mode change is invalid.  */\nextern HARD_REG_SET invalid_mode_change_regs;\n/* For 0 <= I <= 255, the number of bits set in I.  Used to calculate\n   the number of set bits in a HARD_REG_SET.  */\nextern unsigned char byte2bitcount\u00dd256\u00a8;\n\n/* Expressive helper macros.  */\n#define ID2WEB(I) id2web\u00ddI\u00a8\n#define NUM_REGS(W) (((W)->type == PRECOLORED) ? 1 : (W)->num_freedom)\n#define SUBWEB_P(W) (GET_CODE ((W)->orig_x) == SUBREG)\n\n/* Constant usable as debug area to ra_debug_msg.  */\n#define DUMP_COSTS\t\t0x0001\n#define DUMP_WEBS\t\t0x0002\n#define DUMP_IGRAPH\t\t0x0004\n#define DUMP_PROCESS\t\t0x0008\n#define DUMP_COLORIZE\t\t0x0010\n#define DUMP_ASM\t\t0x0020\n#define DUMP_CONSTRAINTS\t0x0040\n#define DUMP_RESULTS\t\t0x0080\n#define DUMP_DF\t\t\t0x0100\n#define DUMP_RTL\t\t0x0200\n#define DUMP_FINAL_RTL\t\t0x0400\n#define DUMP_REGCLASS\t\t0x0800\n#define DUMP_SM\t\t\t0x1000\n#define DUMP_LAST_FLOW\t\t0x2000\n#define DUMP_LAST_RTL\t\t0x4000\n#define DUMP_REBUILD\t\t0x8000\n#define DUMP_IGRAPH_M\t\t0x10000\n#define DUMP_VALIDIFY\t\t0x20000\n#define DUMP_EVER\t\t((unsigned int)-1)\n#define DUMP_NEARLY_EVER\t(DUMP_EVER - DUMP_COSTS - DUMP_IGRAPH_M)\n\n/* All the wanted debug levels as ORing of the various DUMP_xxx\n   constants.  */\nextern unsigned int debug_new_regalloc;\n\n/* Nonzero means we want biased coloring.  */\nextern int flag_ra_biased;\n\n/* Nonzero if we want to use improved (and slow) spilling.  This\n   includes also interference region spilling (see below).  */\nextern int flag_ra_improved_spilling;\n\n/* Nonzero for using interference region spilling.  Zero for improved\n   Chaintin style spilling (only at deaths).  */\nextern int flag_ra_ir_spilling;\n\n/* Nonzero if we use optimistic coalescing, zero for iterated\n   coalescing.  */\nextern int flag_ra_optimistic_coalescing;\n\n/* Nonzero if we want to break aliases of spilled webs.  Forced to\n   nonzero, when flag_ra_optimistic_coalescing is.  */\nextern int flag_ra_break_aliases;\n\n/* Nonzero if we want to merge the spill costs of webs which\n   are coalesced.  */\nextern int flag_ra_merge_spill_costs;\n\n/* Nonzero if we want to spill at every use, instead of at deaths,\n   or interference region borders.  */\nextern int flag_ra_spill_every_use;\n\n/* Nonzero to output all notes in the debug dumps.  */\nextern int flag_ra_dump_notes;\n\nextern void * ra_alloc (size_t);\nextern void * ra_calloc (size_t);\nextern int hard_regs_count (HARD_REG_SET);\nextern rtx ra_emit_move_insn (rtx, rtx);\nextern void ra_debug_msg (unsigned int, const char *, ...) ATTRIBUTE_PRINTF_2;\nextern int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\nextern unsigned int rtx_to_bits (rtx);\nextern struct web * find_subweb (struct web *, rtx);\nextern struct web * find_subweb_2 (struct web *, unsigned int);\nextern struct web * find_web_for_subweb_1 (struct web *);\n\n#define find_web_for_subweb(w) (((w)->parent_web) \\\n\t\t\t\t? find_web_for_subweb_1 ((w)->parent_web) \\\n\t\t\t\t: (w))\n\nextern void ra_build_realloc (struct df *);\nextern void ra_build_free (void);\nextern void ra_build_free_all (struct df *);\nextern void ra_colorize_init (void);\nextern void ra_colorize_free_all (void);\nextern void ra_rewrite_init (void);\n\nextern void ra_print_rtx (FILE *, rtx, int);\nextern void ra_print_rtx_top (FILE *, rtx, int);\nextern void ra_debug_rtx (rtx);\nextern void ra_debug_insns (rtx, int);\nextern void ra_debug_bbi (int);\nextern void ra_print_rtl_with_bb (FILE *, rtx);\nextern void dump_igraph (struct df *);\nextern void dump_igraph_machine (void);\nextern void dump_constraints (void);\nextern void dump_cost (unsigned int);\nextern void dump_graph_cost (unsigned int, const char *);\nextern void dump_ra (struct df *);\nextern void dump_number_seen (void);\nextern void dump_static_insn_cost (FILE *, const char *, const char *);\nextern void dump_web_conflicts (struct web *);\nextern void dump_web_insns (struct web*);\nextern int web_conflicts_p (struct web *, struct web *);\nextern void debug_hard_reg_set (HARD_REG_SET);\n\nextern void remove_list (struct dlist *, struct dlist **);\nextern struct dlist * pop_list (struct dlist **);\nextern void record_conflict (struct web *, struct web *);\nextern int memref_is_stack_slot (rtx);\nextern void build_i_graph (struct df *);\nextern void put_web (struct web *, enum node_type);\nextern void remove_web_from_list (struct web *);\nextern void reset_lists (void);\nextern struct web * alias (struct web *);\nextern void merge_moves (struct web *, struct web *);\nextern void ra_colorize_graph (struct df *);\n\nextern void actual_spill (void);\nextern void emit_colors (struct df *);\nextern void delete_moves (void);\nextern void setup_renumber (int);\nextern void remove_suspicious_death_notes (void);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REAL": {"ttr": 9228, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of floating-point access for GNU compiler.\n   Copyright (C) 1989, 1991, 1994, 1996, 1997, 1998, 1999,\n   2000, 2002, 2003 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it under\n   the terms of the GNU General Public License as published by the Free\n   Software Foundation; either version 2, or (at your option) any later\n   version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n   for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#ifndef GCC_REAL_H\n#define GCC_REAL_H\n\n#include \"machmode.h\"\n\n/* An expanded form of the represented number.  */\n\n/* Enumerate the special cases of numbers that we encounter.  */\nenum real_value_class {\n  rvc_zero,\n  rvc_normal,\n  rvc_inf,\n  rvc_nan\n};\n\n#define SIGNIFICAND_BITS\t(128 + HOST_BITS_PER_LONG)\n#define EXP_BITS\t\t(32 - 5)\n#define MAX_EXP\t\t\t((1 << (EXP_BITS - 1)) - 1)\n#define SIGSZ\t\t\t(SIGNIFICAND_BITS / HOST_BITS_PER_LONG)\n#define SIG_MSB\t\t\t((unsigned long)1 << (HOST_BITS_PER_LONG - 1))\n\nstruct real_value GTY(())\n{\n  ENUM_BITFIELD (real_value_class) class : 2;\n  unsigned int sign : 1;\n  unsigned int signalling : 1;\n  unsigned int canonical : 1;\n  signed int exp : EXP_BITS;\n  unsigned long sig\u00ddSIGSZ\u00a8;\n};\n\n/* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it\n   needs to be a macro.  We do need to continue to have a structure tag\n   so that other headers can forward declare it.  */\n#define REAL_VALUE_TYPE struct real_value\n\n/* We store a REAL_VALUE_TYPE into an rtx, and we do this by putting it in\n   consecutive \"w\" slots.  Moreover, we've got to compute the number of \"w\"\n   slots at preprocessor time, which means we can't use sizeof.  Guess.  */\n\n#define REAL_VALUE_TYPE_SIZE (SIGNIFICAND_BITS + 32)\n#define REAL_WIDTH \\\n  (REAL_VALUE_TYPE_SIZE/HOST_BITS_PER_WIDE_INT \\\n   + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n\n/* Verify the guess.  */\nextern char test_real_width\n  \u00ddsizeof(REAL_VALUE_TYPE) <= REAL_WIDTH*sizeof(HOST_WIDE_INT) ? 1 : -1\u00a8;\n\n/* Calculate the format for CONST_DOUBLE.  We need as many slots as\n   are necessary to overlay a REAL_VALUE_TYPE on them.  This could be\n   as many as four (32-bit HOST_WIDE_INT, 128-bit REAL_VALUE_TYPE).\n\n   A number of places assume that there are always at least two 'w'\n   slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n\n#if REAL_WIDTH == 1\n# define CONST_DOUBLE_FORMAT\t \"ww\"\n#else\n# if REAL_WIDTH == 2\n#  define CONST_DOUBLE_FORMAT\t \"ww\"\n# else\n#  if REAL_WIDTH == 3\n#   define CONST_DOUBLE_FORMAT\t \"www\"\n#  else\n#   if REAL_WIDTH == 4\n#    define CONST_DOUBLE_FORMAT\t \"wwww\"\n#   else\n#    if REAL_WIDTH == 5\n#     define CONST_DOUBLE_FORMAT \"wwwww\"\n#    else\n#     if REAL_WIDTH == 6\n#      define CONST_DOUBLE_FORMAT \"wwwwww\"\n#     else\n       #error \"REAL_WIDTH > 6 not supported\"\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n\n\n/* Describes the properties of the specific target format in use.  */\nstruct real_format\n{\n  /* Move to and from the target bytes.  */\n  void (*encode) (const struct real_format *, long *,\n\t\t  const REAL_VALUE_TYPE *);\n  void (*decode) (const struct real_format *, REAL_VALUE_TYPE *,\n\t\t  const long *);\n\n  /* The radix of the exponent and digits of the significand.  */\n  int b;\n\n  /* log2(b).  */\n  int log2_b;\n\n  /* Size of the significand in digits of radix B.  */\n  int p;\n\n  /* Size of the significant of a NaN, in digits of radix B.  */\n  int pnan;\n\n  /* The minimum negative integer, x, such that b**(x-1) is normalized.  */\n  int emin;\n\n  /* The maximum integer, x, such that b**(x-1) is representable.  */\n  int emax;\n\n  /* The bit position of the sign bit, or -1 for a complex encoding.  */\n  int signbit;\n\n  /* Properties of the format.  */\n  bool has_nans;\n  bool has_inf;\n  bool has_denorm;\n  bool has_signed_zero;\n  bool qnan_msb_set;\n};\n\n\n/* The target format used for each floating floating point mode.\n   Indexed by MODE - QFmode.  */\nextern const struct real_format *\n  real_format_for_mode\u00ddMAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\u00a8;\n\n#define REAL_MODE_FORMAT(MODE) (real_format_for_mode\u00dd(MODE) - MIN_MODE_FLOAT\u00a8)\n\n/* Declare functions in real.c.  */\n\n/* Binary or unary arithmetic on tree_code.  */\nextern void real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,\n\t\t\t     const REAL_VALUE_TYPE *);\n\n/* Compare reals by tree_code.  */\nextern bool real_compare (int, const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n\n/* Determine whether a floating-point value X is infinite.  */\nextern bool real_isinf (const REAL_VALUE_TYPE *);\n\n/* Determine whether a floating-point value X is a NaN.  */\nextern bool real_isnan (const REAL_VALUE_TYPE *);\n\n/* Determine whether a floating-point value X is negative.  */\nextern bool real_isneg (const REAL_VALUE_TYPE *);\n\n/* Determine whether a floating-point value X is minus zero.  */\nextern bool real_isnegzero (const REAL_VALUE_TYPE *);\n\n/* Compare two floating-point objects for bitwise identity.  */\nextern bool real_identical (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n\n/* Extend or truncate to a new mode.  */\nextern void real_convert (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t\t  const REAL_VALUE_TYPE *);\n\n/* Return true if truncating to NEW is exact.  */\nextern bool exact_real_truncate (enum machine_mode, const REAL_VALUE_TYPE *);\n\n/* Render R as a decimal floating point constant.  */\nextern void real_to_decimal (char *, const REAL_VALUE_TYPE *, size_t,\n\t\t\t     size_t, int);\n\n/* Render R as a hexadecimal floating point constant.  */\nextern void real_to_hexadecimal (char *, const REAL_VALUE_TYPE *,\n\t\t\t\t size_t, size_t, int);\n\n/* Render R as an integer.  */\nextern HOST_WIDE_INT real_to_integer (const REAL_VALUE_TYPE *);\nextern void real_to_integer2 (HOST_WIDE_INT *, HOST_WIDE_INT *,\n\t\t\t      const REAL_VALUE_TYPE *);\n\n/* Initialize R from a decimal or hexadecimal string.  */\nextern void real_from_string (REAL_VALUE_TYPE *, const char *);\n\n/* Initialize R from an integer pair HIGH/LOW.  */\nextern void real_from_integer (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT, int);\n\nextern long real_to_target_fmt (long *, const REAL_VALUE_TYPE *,\n\t\t\t\tconst struct real_format *);\nextern long real_to_target (long *, const REAL_VALUE_TYPE *, enum machine_mode);\n\nextern void real_from_target_fmt (REAL_VALUE_TYPE *, const long *,\n\t\t\t\t  const struct real_format *);\nextern void real_from_target (REAL_VALUE_TYPE *, const long *,\n\t\t\t      enum machine_mode);\n\nextern void real_inf (REAL_VALUE_TYPE *);\n\nextern bool real_nan (REAL_VALUE_TYPE *, const char *, int, enum machine_mode);\n\nextern void real_maxval (REAL_VALUE_TYPE *, int, enum machine_mode);\n\nextern void real_2expN (REAL_VALUE_TYPE *, int);\n\nextern unsigned int real_hash (const REAL_VALUE_TYPE *);\n\n\n/* Target formats defined in real.c.  */\nextern const struct real_format ieee_single_format;\nextern const struct real_format mips_single_format;\nextern const struct real_format ieee_double_format;\nextern const struct real_format mips_double_format;\nextern const struct real_format ieee_extended_motorola_format;\nextern const struct real_format ieee_extended_intel_96_format;\nextern const struct real_format ieee_extended_intel_96_round_53_format;\nextern const struct real_format ieee_extended_intel_128_format;\nextern const struct real_format ibm_extended_format;\nextern const struct real_format mips_extended_format;\nextern const struct real_format ieee_quad_format;\nextern const struct real_format mips_quad_format;\nextern const struct real_format vax_f_format;\nextern const struct real_format vax_d_format;\nextern const struct real_format vax_g_format;\nextern const struct real_format i370_single_format;\nextern const struct real_format i370_double_format;\nextern const struct real_format c4x_single_format;\nextern const struct real_format c4x_extended_format;\nextern const struct real_format real_internal_format;\n\n\n/* ====================================================================== */\n/* Crap.  */\n\n#define REAL_ARITHMETIC(value, code, d1, d2) \\\n  real_arithmetic (&(value), code, &(d1), &(d2))\n\n#define REAL_VALUES_IDENTICAL(x, y)\treal_identical (&(x), &(y))\n#define REAL_VALUES_EQUAL(x, y)\t\treal_compare (EQ_EXPR, &(x), &(y))\n#define REAL_VALUES_LESS(x, y)\t\treal_compare (LT_EXPR, &(x), &(y))\n\n/* Determine whether a floating-point value X is infinite.  */\n#define REAL_VALUE_ISINF(x)\t\treal_isinf (&(x))\n\n/* Determine whether a floating-point value X is a NaN.  */\n#define REAL_VALUE_ISNAN(x)\t\treal_isnan (&(x))\n\n/* Determine whether a floating-point value X is negative.  */\n#define REAL_VALUE_NEGATIVE(x)\t\treal_isneg (&(x))\n\n/* Determine whether a floating-point value X is minus zero.  */\n#define REAL_VALUE_MINUS_ZERO(x)\treal_isnegzero (&(x))\n\n/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs.  */\n#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(IN, OUT)\t\t\t\\\n  real_to_target (OUT, &(IN),\t\t\t\t\t\t\\\n\t\t  mode_for_size (LONG_DOUBLE_TYPE_SIZE, MODE_FLOAT, 0))\n\n#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT) \\\n  real_to_target (OUT, &(IN), mode_for_size (64, MODE_FLOAT, 0))\n\n/* IN is a REAL_VALUE_TYPE.  OUT is a long.  */\n#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT) \\\n  ((OUT) = real_to_target (NULL, &(IN), mode_for_size (32, MODE_FLOAT, 0)))\n\n#define REAL_VALUE_FROM_INT(r, lo, hi, mode) \\\n  real_from_integer (&(r), mode, lo, hi, 0)\n\n#define REAL_VALUE_FROM_UNSIGNED_INT(r, lo, hi, mode) \\\n  real_from_integer (&(r), mode, lo, hi, 1)\n\nextern REAL_VALUE_TYPE real_value_truncate (enum machine_mode,\n\t\t\t\t\t    REAL_VALUE_TYPE);\n\n#define REAL_VALUE_TO_INT(plow, phigh, r) \\\n  real_to_integer2 (plow, phigh, &(r))\n\nextern REAL_VALUE_TYPE real_arithmetic2 (int, const REAL_VALUE_TYPE *,\n\t\t\t\t\t const REAL_VALUE_TYPE *);\n\n#define REAL_VALUE_NEGATE(X) \\\n  real_arithmetic2 (NEGATE_EXPR, &(X), NULL)\n\n#define REAL_VALUE_ABS(X) \\\n  real_arithmetic2 (ABS_EXPR, &(X), NULL)\n\nextern int significand_size (enum machine_mode);\n\nextern REAL_VALUE_TYPE real_from_string2 (const char *, enum machine_mode);\n\n#define REAL_VALUE_ATOF(s, m) \\\n  real_from_string2 (s, m)\n\n#define CONST_DOUBLE_ATOF(s, m) \\\n  CONST_DOUBLE_FROM_REAL_VALUE (real_from_string2 (s, m), m)\n\n#define REAL_VALUE_FIX(r) \\\n  real_to_integer (&(r))\n\n/* ??? Not quite right.  */\n#define REAL_VALUE_UNSIGNED_FIX(r) \\\n  real_to_integer (&(r))\n\n/* ??? These were added for Paranoia support.  */\n\n/* Return floor log2(R).  */\nextern int real_exponent (const REAL_VALUE_TYPE *);\n\n/* R = A * 2**EXP.  */\nextern void real_ldexp (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n\n/* **** End of software floating point emulator interface macros **** */\n\n/* Constant real values 0, 1, 2, 3, 10, -1, -2, 0.5 and 1/3.  */\n\nextern REAL_VALUE_TYPE dconst0;\nextern REAL_VALUE_TYPE dconst1;\nextern REAL_VALUE_TYPE dconst2;\nextern REAL_VALUE_TYPE dconst3;\nextern REAL_VALUE_TYPE dconst10;\nextern REAL_VALUE_TYPE dconstm1;\nextern REAL_VALUE_TYPE dconstm2;\nextern REAL_VALUE_TYPE dconsthalf;\nextern REAL_VALUE_TYPE dconstthird;\nextern REAL_VALUE_TYPE dconstpi;\nextern REAL_VALUE_TYPE dconste;\n\n/* Function to return a real value (not a tree node)\n   from a given integer constant.  */\nREAL_VALUE_TYPE real_value_from_int_cst (tree, tree);\n\n/* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n#define REAL_VALUE_FROM_CONST_DOUBLE(to, from) \\\n  memcpy (&(to), &CONST_DOUBLE_LOW ((from)), sizeof (REAL_VALUE_TYPE))\n\n/* Return a CONST_DOUBLE with value R and mode M.  */\n#define CONST_DOUBLE_FROM_REAL_VALUE(r, m) \\\n  const_double_from_real_value (r, m)\nextern rtx const_double_from_real_value (REAL_VALUE_TYPE, enum machine_mode);\n\n/* Replace R by 1/R in the given machine mode, if the result is exact.  */\nextern bool exact_real_inverse (enum machine_mode, REAL_VALUE_TYPE *);\n\n/* In tree.c: wrap up a REAL_VALUE_TYPE in a tree node.  */\nextern tree build_real (tree, REAL_VALUE_TYPE);\n\n/* Calculate R as the square root of X in the given machine mode.  */\nextern bool real_sqrt (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t       const REAL_VALUE_TYPE *);\n\n/* Calculate R as X raised to the integer exponent N in mode MODE.  */\nextern bool real_powi (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t       const REAL_VALUE_TYPE *, HOST_WIDE_INT);\n\n/* Standard round to integer value functions.  */\nextern void real_trunc (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t\tconst REAL_VALUE_TYPE *);\nextern void real_floor (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t\tconst REAL_VALUE_TYPE *);\nextern void real_ceil (REAL_VALUE_TYPE *, enum machine_mode,\n\t\t       const REAL_VALUE_TYPE *);\n\n#endif /* ! GCC_REAL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RECOG": {"ttr": 9476, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Declarations for interface to insn recognizer and insn-output.c.\n   Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Random number that should be large enough for all purposes.  */\n#define MAX_RECOG_ALTERNATIVES 30\n#define recog_memoized(I) (INSN_CODE (I) >= 0 \\\n\t\t\t   ? INSN_CODE (I) : recog_memoized_1 (I))\n\n/* Types of operands.  */\nenum op_type {\n  OP_IN,\n  OP_OUT,\n  OP_INOUT\n};\n\nstruct operand_alternative\n{\n  /* Pointer to the beginning of the constraint string for this alternative,\n     for easier access by alternative number.  */\n  const char *constraint;\n\n  /* The register class valid for this alternative (possibly NO_REGS).  */\n  enum reg_class class;\n\n  /* \"Badness\" of this alternative, computed from number of '?' and '!'\n     characters in the constraint string.  */\n  unsigned int reject;\n\n  /* -1 if no matching constraint was found, or an operand number.  */\n  int matches;\n  /* The same information, but reversed: -1 if this operand is not\n     matched by any other, or the operand number of the operand that\n     matches this one.  */\n  int matched;\n\n  /* Nonzero if '&' was found in the constraint string.  */\n  unsigned int earlyclobber:1;\n  /* Nonzero if 'm' was found in the constraint string.  */\n  unsigned int memory_ok:1;\n  /* Nonzero if 'o' was found in the constraint string.  */\n  unsigned int offmem_ok:1;\n  /* Nonzero if 'V' was found in the constraint string.  */\n  unsigned int nonoffmem_ok:1;\n  /* Nonzero if '<' was found in the constraint string.  */\n  unsigned int decmem_ok:1;\n  /* Nonzero if '>' was found in the constraint string.  */\n  unsigned int incmem_ok:1;\n  /* Nonzero if 'p' was found in the constraint string.  */\n  unsigned int is_address:1;\n  /* Nonzero if 'X' was found in the constraint string, or if the constraint\n     string for this alternative was empty.  */\n  unsigned int anything_ok:1;\n};\n\n\nextern void init_recog (void);\nextern void init_recog_no_volatile (void);\nextern int recog_memoized_1 (rtx);\nextern int check_asm_operands (rtx);\nextern int asm_operand_ok (rtx, const char *);\nextern int validate_change (rtx, rtx *, rtx, int);\nextern int insn_invalid_p (rtx);\nextern int apply_change_group (void);\nextern int num_validated_changes (void);\nextern void cancel_changes (int);\nextern int constrain_operands (int);\nextern int constrain_operands_cached (int);\nextern int memory_address_p (enum machine_mode, rtx);\nextern int strict_memory_address_p (enum machine_mode, rtx);\nextern int validate_replace_rtx_subexp (rtx, rtx, rtx, rtx *);\nextern int validate_replace_rtx (rtx, rtx, rtx);\nextern void validate_replace_rtx_group (rtx, rtx, rtx);\nextern int validate_replace_src (rtx, rtx, rtx);\nextern void validate_replace_src_group (rtx, rtx, rtx);\nextern int num_changes_pending (void);\n#ifdef HAVE_cc0\nextern int next_insn_tests_no_inequality (rtx);\n#endif\nextern int reg_fits_class_p (rtx, enum reg_class, int, enum machine_mode);\nextern rtx *find_single_use (rtx, rtx, rtx *);\n\nextern int general_operand (rtx, enum machine_mode);\nextern int address_operand (rtx, enum machine_mode);\nextern int register_operand (rtx, enum machine_mode);\nextern int pmode_register_operand (rtx, enum machine_mode);\nextern int scratch_operand (rtx, enum machine_mode);\nextern int immediate_operand (rtx, enum machine_mode);\nextern int const_int_operand (rtx, enum machine_mode);\nextern int const_double_operand (rtx, enum machine_mode);\nextern int nonimmediate_operand (rtx, enum machine_mode);\nextern int nonmemory_operand (rtx, enum machine_mode);\nextern int push_operand (rtx, enum machine_mode);\nextern int pop_operand (rtx, enum machine_mode);\nextern int memory_operand (rtx, enum machine_mode);\nextern int indirect_operand (rtx, enum machine_mode);\nextern int comparison_operator (rtx, enum machine_mode);\n\nextern int offsettable_memref_p (rtx);\nextern int offsettable_nonstrict_memref_p (rtx);\nextern int offsettable_address_p (int, enum machine_mode, rtx);\nextern int mode_dependent_address_p (rtx);\n\nextern int recog (rtx, rtx, int *);\nextern void add_clobbers (rtx, int);\nextern int added_clobbers_hard_reg_p (int);\nextern void insn_extract (rtx);\nextern void extract_insn (rtx);\nextern void extract_constrain_insn_cached (rtx);\nextern void extract_insn_cached (rtx);\nextern void preprocess_constraints (void);\nextern rtx peep2_next_insn (int);\nextern int peep2_regno_dead_p (int, int);\nextern int peep2_reg_dead_p (int, rtx);\n#ifdef CLEAR_HARD_REG_SET\nextern rtx peep2_find_free_register (int, int, const char *,\n\t\t\t\t     enum machine_mode, HARD_REG_SET *);\n#endif\nextern void peephole2_optimize (FILE *);\nextern rtx peephole2_insns (rtx, rtx, int *);\n\nextern int store_data_bypass_p (rtx, rtx);\nextern int if_test_bypass_p (rtx, rtx);\n\n/* Nonzero means volatile operands are recognized.  */\nextern int volatile_ok;\n\n/* Set by constrain_operands to the number of the alternative that\n   matched.  */\nextern int which_alternative;\n\n/* The following vectors hold the results from insn_extract.  */\n\nstruct recog_data\n{\n  /* It is very tempting to make the 5 operand related arrays into a\n     structure and index on that.  However, to be source compatible\n     with all of the existing md file insn constraints and output\n     templates, we need `operand' as a flat array.  Without that\n     member, making an array for the rest seems pointless.  */\n\n  /* Gives value of operand N.  */\n  rtx operand\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives location where operand N was found.  */\n  rtx *operand_loc\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the constraint string for operand N.  */\n  const char *constraints\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the mode of operand N.  */\n  enum machine_mode operand_mode\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives the type (in, out, inout) for operand N.  */\n  enum op_type operand_type\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n  /* Gives location where the Nth duplicate-appearance of an operand\n     was found.  This is something that matched MATCH_DUP.  */\n  rtx *dup_loc\u00ddMAX_DUP_OPERANDS\u00a8;\n\n  /* Gives the operand number that was duplicated in the Nth\n     duplicate-appearance of an operand.  */\n  char dup_num\u00ddMAX_DUP_OPERANDS\u00a8;\n\n  /* ??? Note that these are `char' instead of `unsigned char' to (try to)\n     avoid certain lossage from K&R C, wherein `unsigned char' default\n     promotes to `unsigned int' instead of `int' as in ISO C.  As of 1999,\n     the most common places to bootstrap from K&R C are SunOS and HPUX,\n     both of which have signed characters by default.  The only other\n     supported natives that have both K&R C and unsigned characters are\n     ROMP and Irix 3, and neither have been seen for a while, but do\n     continue to consider unsignedness when performing arithmetic inside\n     a comparison.  */\n\n  /* The number of operands of the insn.  */\n  char n_operands;\n\n  /* The number of MATCH_DUPs in the insn.  */\n  char n_dups;\n\n  /* The number of alternatives in the constraints for the insn.  */\n  char n_alternatives;\n\n  /* In case we are caching, hold insn data was generated for.  */\n  rtx insn;\n};\n\nextern struct recog_data recog_data;\n\n/* Contains a vector of operand_alternative structures for every operand.\n   Set up by preprocess_constraints.  */\nextern struct operand_alternative recog_op_alt\u00ddMAX_RECOG_OPERANDS\u00a8\u00ddMAX_RECOG_ALTERNATIVES\u00a8;\n\n/* A table defined in insn-output.c that give information about\n   each insn-code value.  */\n\ntypedef int (*insn_operand_predicate_fn) (rtx, enum machine_mode);\ntypedef const char * (*insn_output_fn) (rtx *, rtx);\ntypedef rtx (*insn_gen_fn) (rtx, ...);\n\nstruct insn_operand_data\n{\n  const insn_operand_predicate_fn predicate;\n\n  const char *const constraint;\n\n  ENUM_BITFIELD(machine_mode) const mode : 16;\n\n  const char strict_low;\n\n  const char eliminable;\n};\n\n/* Legal values for insn_data.output_format.  Indicate what type of data\n   is stored in insn_data.output.  */\n#define INSN_OUTPUT_FORMAT_NONE\t\t0\t/* abort */\n#define INSN_OUTPUT_FORMAT_SINGLE\t1\t/* const char * */\n#define INSN_OUTPUT_FORMAT_MULTI\t2\t/* const char * const * */\n#define INSN_OUTPUT_FORMAT_FUNCTION\t3\t/* const char * (*)(...) */\n\nstruct insn_data\n{\n  const char *const name;\n#if HAVE_DESIGNATED_INITIALIZERS\n  union {\n    const char *single;\n    const char *const *multi;\n    insn_output_fn function;\n  } output;\n#else\n  struct {\n    const char *single;\n    const char *const *multi;\n    insn_output_fn function;\n  } output;\n#endif\n  const insn_gen_fn genfun;\n  const struct insn_operand_data *const operand;\n\n  const char n_operands;\n  const char n_dups;\n  const char n_alternatives;\n  const char output_format;\n};\n\nextern const struct insn_data insn_data\u00dd\u00a8;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 9479, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Define per-register tables for data flow info and register allocation.\n   Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#include \"varray.h\"\n#include \"hard-reg-set.h\"\n#include \"basic-block.h\"\n\n#define REG_BYTES(R) mode_size\u00dd(int) GET_MODE (R)\u00a8\n\n/* When you only have the mode of a pseudo register before it has a hard\n   register chosen for it, this reports the size of each hard register\n   a pseudo in such a mode would get allocated to.  A target may\n   override this.  */\n\n#ifndef REGMODE_NATURAL_SIZE\n#define REGMODE_NATURAL_SIZE(MODE)\tUNITS_PER_WORD\n#endif\n\n#ifndef SMALL_REGISTER_CLASSES\n#define SMALL_REGISTER_CLASSES 0\n#endif\n\n/* Maximum register number used in this function, plus one.  */\n\nextern int max_regno;\n\n/* Register information indexed by register number */\ntypedef struct reg_info_def\n{\t\t\t\t/* fields set by reg_scan */\n  int first_uid;\t\t/* UID of first insn to use (REG n) */\n  int last_uid;\t\t\t/* UID of last insn to use (REG n) */\n  int last_note_uid;\t\t/* UID of last note to use (REG n) */\n\n\t\t\t\t/* fields set by reg_scan & flow_analysis */\n  int sets;\t\t\t/* # of times (REG n) is set */\n\n\t\t\t\t/* fields set by flow_analysis */\n  int refs;\t\t\t/* # of times (REG n) is used or set */\n  int freq;\t\t\t/* # estimated frequency (REG n) is used or set */\n  int deaths;\t\t\t/* # of times (REG n) dies */\n  int live_length;\t\t/* # of instructions (REG n) is live */\n  int calls_crossed;\t\t/* # of calls (REG n) is live across */\n  int throw_calls_crossed;\t/* # of calls that may throw (REG n) is live across */\n  int basic_block;\t\t/* # of basic blocks (REG n) is used in */\n  char changes_mode;\t\t/* whether (SUBREG (REG n)) exists and\n\t\t\t\t   is illegal.  */\n} reg_info;\n\nextern varray_type reg_n_info;\n\n/* Indexed by n, gives number of times (REG n) is used or set.  */\n\n#define REG_N_REFS(N) (VARRAY_REG (reg_n_info, N)->refs)\n\n/* Estimate frequency of references to register N.  */\n\n#define REG_FREQ(N) (VARRAY_REG (reg_n_info, N)->freq)\n\n/* The weights for each insn varries from 0 to REG_FREQ_BASE.\n   This constant does not need to be high, as in infrequently executed\n   regions we want to count instructions equivalently to optimize for\n   size instead of speed.  */\n#define REG_FREQ_MAX 1000\n\n/* Compute register frequency from the BB frequency.  When optimizing for size,\n   or profile driven feedback is available and the function is never executed,\n   frequency is always equivalent.  Otherwise rescale the basic block\n   frequency.  */\n#define REG_FREQ_FROM_BB(bb) (optimize_size\t\t\t\t      \\\n\t\t\t      || (flag_branch_probabilities\t\t      \\\n\t\t\t\t  && !ENTRY_BLOCK_PTR->count)\t\t      \\\n\t\t\t      ? REG_FREQ_MAX\t\t\t\t      \\\n\t\t\t      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n\t\t\t      ? ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\\\n\t\t\t      : 1)\n\n/* Indexed by n, gives number of times (REG n) is set.\n   ??? both regscan and flow allocate space for this.  We should settle\n   on just copy.  */\n\n#define REG_N_SETS(N) (VARRAY_REG (reg_n_info, N)->sets)\n\n/* Indexed by N, gives number of insns in which register N dies.\n   Note that if register N is live around loops, it can die\n   in transitions between basic blocks, and that is not counted here.\n   So this is only a reliable indicator of how many regions of life there are\n   for registers that are contained in one basic block.  */\n\n#define REG_N_DEATHS(N) (VARRAY_REG (reg_n_info, N)->deaths)\n\n/* Get the number of consecutive words required to hold pseudo-reg N.  */\n\n#define PSEUDO_REGNO_SIZE(N) \\\n  ((GET_MODE_SIZE (PSEUDO_REGNO_MODE (N)) + UNITS_PER_WORD - 1)\t\t\\\n   / UNITS_PER_WORD)\n\n/* Get the number of bytes required to hold pseudo-reg N.  */\n\n#define PSEUDO_REGNO_BYTES(N) \\\n  GET_MODE_SIZE (PSEUDO_REGNO_MODE (N))\n\n/* Get the machine mode of pseudo-reg N.  */\n\n#define PSEUDO_REGNO_MODE(N) GET_MODE (regno_reg_rtx\u00ddN\u00a8)\n\n/* Indexed by N, gives number of CALL_INSNS across which (REG n) is live.  */\n\n#define REG_N_CALLS_CROSSED(N) (VARRAY_REG (reg_n_info, N)->calls_crossed)\n\n/* Indexed by N, gives number of CALL_INSNS that may throw, across which\n   (REG n) is live.  */\n\n#define REG_N_THROWING_CALLS_CROSSED(N) \\\n  (VARRAY_REG (reg_n_info, N)->throw_calls_crossed)\n\n/* Total number of instructions at which (REG n) is live.\n   The larger this is, the less priority (REG n) gets for\n   allocation in a hard register (in global-alloc).\n   This is set in flow.c and remains valid for the rest of the compilation\n   of the function; it is used to control register allocation.\n\n   local-alloc.c may alter this number to change the priority.\n\n   Negative values are special.\n   -1 is used to mark a pseudo reg which has a constant or memory equivalent\n   and is used infrequently enough that it should not get a hard register.\n   -2 is used to mark a pseudo reg for a parameter, when a frame pointer\n   is not required.  global.c makes an allocno for this but does\n   not try to assign a hard register to it.  */\n\n#define REG_LIVE_LENGTH(N) (VARRAY_REG (reg_n_info, N)->live_length)\n\n/* Vector of substitutions of register numbers,\n   used to map pseudo regs into hardware regs.\n\n   This can't be folded into reg_n_info without changing all of the\n   machine dependent directories, since the reload functions\n   in the machine dependent files access it.  */\n\nextern short *reg_renumber;\n\n/* Vector indexed by hardware reg saying whether that reg is ever used.  */\n\nextern char regs_ever_live\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Like regs_ever_live, but saying whether reg is set by asm statements.  */\n\nextern char regs_asm_clobbered\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* For each hard register, the widest mode object that it can contain.\n   This will be a MODE_INT mode if the register can hold integers.  Otherwise\n   it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n   register.  */\n\nextern enum machine_mode reg_raw_mode\u00ddFIRST_PSEUDO_REGISTER\u00a8;\n\n/* Vector indexed by regno; gives uid of first insn using that reg.\n   This is computed by reg_scan for use by cse and loop.\n   It is sometimes adjusted for subsequent changes during loop,\n   but not adjusted by cse even if cse invalidates it.  */\n\n#define REGNO_FIRST_UID(N) (VARRAY_REG (reg_n_info, N)->first_uid)\n\n/* Vector indexed by regno; gives uid of last insn using that reg.\n   This is computed by reg_scan for use by cse and loop.\n   It is sometimes adjusted for subsequent changes during loop,\n   but not adjusted by cse even if cse invalidates it.\n   This is harmless since cse won't scan through a loop end.  */\n\n#define REGNO_LAST_UID(N) (VARRAY_REG (reg_n_info, N)->last_uid)\n\n/* Similar, but includes insns that mention the reg in their notes.  */\n\n#define REGNO_LAST_NOTE_UID(N) (VARRAY_REG (reg_n_info, N)->last_note_uid)\n\n/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers\n   that have to go in the same hard reg.  */\nextern rtx regs_may_share;\n\n/* Flag set by local-alloc or global-alloc if they decide to allocate\n   something in a call-clobbered register.  */\n\nextern int caller_save_needed;\n\n/* Predicate to decide whether to give a hard reg to a pseudo which\n   is referenced REFS times and would need to be saved and restored\n   around a call CALLS times.  */\n\n#ifndef CALLER_SAVE_PROFITABLE\n#define CALLER_SAVE_PROFITABLE(REFS, CALLS)  (4 * (CALLS) < (REFS))\n#endif\n\n/* On most machines a register class is likely to be spilled if it\n   only has one register.  */\n#ifndef CLASS_LIKELY_SPILLED_P\n#define CLASS_LIKELY_SPILLED_P(CLASS) (reg_class_size\u00dd(int) (CLASS)\u00a8 == 1)\n#endif\n\n/* Select a register mode required for caller save of hard regno REGNO.  */\n#ifndef HARD_REGNO_CALLER_SAVE_MODE\n#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n  choose_hard_reg_mode (REGNO, NREGS, false)\n#endif\n\n/* Registers that get partially clobbered by a call in a given mode.\n   These must not be call used registers.  */\n#ifndef HARD_REGNO_CALL_PART_CLOBBERED\n#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n#endif\n\n/* Allocate reg_n_info tables */\nextern void allocate_reg_info (size_t, int, int);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RELOAD": {"ttr": 9482, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Communication between reload.c and reload1.c.\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1997, 1998,\n   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* If secondary reloads are the same for inputs and outputs, define those\n   macros here.  */\n\n#ifdef SECONDARY_RELOAD_CLASS\n#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n  SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n  SECONDARY_RELOAD_CLASS (CLASS, MODE, X)\n#endif\n\n/* If either macro is defined, show that we need secondary reloads.  */\n#if defined(SECONDARY_INPUT_RELOAD_CLASS) || defined(SECONDARY_OUTPUT_RELOAD_CLASS)\n#define HAVE_SECONDARY_RELOADS\n#endif\n\n/* If MEMORY_MOVE_COST isn't defined, give it a default here.  */\n#ifndef MEMORY_MOVE_COST\n#ifdef HAVE_SECONDARY_RELOADS\n#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n  (4 + memory_move_secondary_cost ((MODE), (CLASS), (IN)))\n#else\n#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n#endif\n#endif\nextern int memory_move_secondary_cost (enum machine_mode, enum reg_class, int);\n\n/* Maximum number of reloads we can need.  */\n#define MAX_RELOADS (2 * MAX_RECOG_OPERANDS * (MAX_REGS_PER_ADDRESS + 1))\n\n/* Encode the usage of a reload.  The following codes are supported:\n\n   RELOAD_FOR_INPUT\t\treload of an input operand\n   RELOAD_FOR_OUTPUT\t\tlikewise, for output\n   RELOAD_FOR_INSN\t\ta reload that must not conflict with anything\n\t\t\t\tused in the insn, but may conflict with\n\t\t\t\tsomething used before or after the insn\n   RELOAD_FOR_INPUT_ADDRESS\treload for parts of the address of an object\n\t\t\t\tthat is an input reload\n   RELOAD_FOR_INPADDR_ADDRESS\treload needed for RELOAD_FOR_INPUT_ADDRESS\n   RELOAD_FOR_OUTPUT_ADDRESS\tlike RELOAD_FOR INPUT_ADDRESS, for output\n   RELOAD_FOR_OUTADDR_ADDRESS\treload needed for RELOAD_FOR_OUTPUT_ADDRESS\n   RELOAD_FOR_OPERAND_ADDRESS\treload for the address of a non-reloaded\n\t\t\t\toperand; these don't conflict with\n\t\t\t\tany other addresses.\n   RELOAD_FOR_OPADDR_ADDR\treload needed for RELOAD_FOR_OPERAND_ADDRESS\n                                reloads; usually secondary reloads\n   RELOAD_OTHER\t\t\tnone of the above, usually multiple uses\n   RELOAD_FOR_OTHER_ADDRESS     reload for part of the address of an input\n\t\t\t\tthat is marked RELOAD_OTHER.\n\n   This used to be \"enum reload_when_needed\" but some debuggers have trouble\n   with an enum tag and variable of the same name.  */\n\nenum reload_type\n{\n  RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN,\n  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,\n  RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,\n  RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,\n  RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n};\n\n#ifdef GCC_INSN_CODES_H\n/* Each reload is recorded with a structure like this.  */\nstruct reload\n{\n  /* The value to reload from */\n  rtx in;\n  /* Where to store reload-reg afterward if nec (often the same as\n     reload_in)  */\n  rtx out;\n\n  /* The class of registers to reload into.  */\n  enum reg_class class;\n\n  /* The mode this operand should have when reloaded, on input.  */\n  enum machine_mode inmode;\n  /* The mode this operand should have when reloaded, on output.  */\n  enum machine_mode outmode;\n\n  /* The mode of the reload register.  */\n  enum machine_mode mode;\n\n  /* the largest number of registers this reload will require.  */\n  unsigned int nregs;\n\n  /* Positive amount to increment or decrement by if\n     reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC.\n     Ignored otherwise (don't assume it is zero).  */\n  int inc;\n  /* A reg for which reload_in is the equivalent.\n     If reload_in is a symbol_ref which came from\n     reg_equiv_constant, then this is the pseudo\n     which has that symbol_ref as equivalent.  */\n  rtx in_reg;\n  rtx out_reg;\n\n  /* Used in find_reload_regs to record the allocated register.  */\n  int regno;\n  /* This is the register to reload into.  If it is zero when `find_reloads'\n     returns, you must find a suitable register in the class specified by\n     reload_reg_class, and store here an rtx for that register with mode from\n     reload_inmode or reload_outmode.  */\n  rtx reg_rtx;\n  /* The operand number being reloaded.  This is used to group related reloads\n     and need not always be equal to the actual operand number in the insn,\n     though it current will be; for in-out operands, it is one of the two\n     operand numbers.  */\n  int opnum;\n\n  /* Gives the reload number of a secondary input reload, when needed;\n     otherwise -1.  */\n  int secondary_in_reload;\n  /* Gives the reload number of a secondary output reload, when needed;\n     otherwise -1.  */\n  int secondary_out_reload;\n  /* If a secondary input reload is required, gives the INSN_CODE that uses the\n     secondary reload as a scratch register, or CODE_FOR_nothing if the\n     secondary reload register is to be an intermediate register.  */\n  enum insn_code secondary_in_icode;\n  /* Likewise, for a secondary output reload.  */\n  enum insn_code secondary_out_icode;\n\n  /* Classifies reload as needed either for addressing an input reload,\n     addressing an output, for addressing a non-reloaded mem ref, or for\n     unspecified purposes (i.e., more than one of the above).  */\n  enum reload_type when_needed;\n\n  /* Nonzero for an optional reload.  Optional reloads are ignored unless the\n     value is already sitting in a register.  */\n  unsigned int optional:1;\n  /* nonzero if this reload shouldn't be combined with another reload.  */\n  unsigned int nocombine:1;\n  /* Nonzero if this is a secondary register for one or more reloads.  */\n  unsigned int secondary_p:1;\n  /* Nonzero if this reload must use a register not already allocated to a\n     group.  */\n  unsigned int nongroup:1;\n};\n\nextern struct reload rld\u00ddMAX_RELOADS\u00a8;\nextern int n_reloads;\n#endif\n\nextern rtx *reg_equiv_constant;\nextern rtx *reg_equiv_memory_loc;\nextern rtx *reg_equiv_address;\nextern rtx *reg_equiv_mem;\n\n/* All the \"earlyclobber\" operands of the current insn\n   are recorded here.  */\nextern int n_earlyclobbers;\nextern rtx reload_earlyclobbers\u00ddMAX_RECOG_OPERANDS\u00a8;\n\n/* Save the number of operands.  */\nextern int reload_n_operands;\n\n/* First uid used by insns created by reload in this function.\n   Used in find_equiv_reg.  */\nextern int reload_first_uid;\n\n/* Nonzero if indirect addressing is supported when the innermost MEM is\n   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n   which these are valid is the same as spill_indirect_levels, above.  */\n\nextern char indirect_symref_ok;\n\n/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\nextern char double_reg_address_ok;\n\nextern int num_not_at_initial_offset;\n\nstruct needs\n{\n  /* \u00dd0\u00a8 is normal, \u00dd1\u00a8 is nongroup.  */\n  short regs\u00dd2\u00a8\u00ddN_REG_CLASSES\u00a8;\n  short groups\u00ddN_REG_CLASSES\u00a8;\n};\n\n#if defined SET_HARD_REG_BIT && defined CLEAR_REG_SET\n/* This structure describes instructions which are relevant for reload.\n   Apart from all regular insns, this also includes CODE_LABELs, since they\n   must be examined for register elimination.  */\nstruct insn_chain\n{\n  /* Links to the neighbor instructions.  */\n  struct insn_chain *next, *prev;\n\n  /* Link through a chains set up by calculate_needs_all_insns, containing\n     all insns that need reloading.  */\n  struct insn_chain *next_need_reload;\n\n  /* The basic block this insn is in.  */\n  int block;\n  /* The rtx of the insn.  */\n  rtx insn;\n  /* Register life information: record all live hard registers, and all\n     live pseudos that have a hard register.  */\n  regset_head live_throughout;\n  regset_head dead_or_set;\n\n  /* Copies of the global variables computed by find_reloads.  */\n  struct reload *rld;\n  int n_reloads;\n\n  /* Indicates which registers have already been used for spills.  */\n  HARD_REG_SET used_spill_regs;\n\n  /* Describe the needs for reload registers of this insn.  */\n  struct needs need;\n\n  /* Nonzero if find_reloads said the insn requires reloading.  */\n  unsigned int need_reload:1;\n  /* Nonzero if find_reloads needs to be run during reload_as_needed to\n     perform modifications on any operands.  */\n  unsigned int need_operand_change:1;\n  /* Nonzero if eliminate_regs_in_insn said it requires eliminations.  */\n  unsigned int need_elim:1;\n  /* Nonzero if this insn was inserted by perform_caller_saves.  */\n  unsigned int is_caller_save_insn:1;\n};\n\n/* A chain of insn_chain structures to describe all non-note insns in\n   a function.  */\nextern struct insn_chain *reload_insn_chain;\n\n/* Allocate a new insn_chain structure.  */\nextern struct insn_chain *new_insn_chain (void);\n\nextern void compute_use_by_pseudos (HARD_REG_SET *, regset);\n#endif\n\n/* Functions from reload.c:  */\n\n/* Return a memory location that will be used to copy X in mode MODE.\n   If we haven't already made a location for this mode in this insn,\n   call find_reloads_address on the location being returned.  */\nextern rtx get_secondary_mem (rtx, enum machine_mode, int, enum reload_type);\n\n/* Clear any secondary memory locations we've made.  */\nextern void clear_secondary_mem (void);\n\n/* Transfer all replacements that used to be in reload FROM to be in\n   reload TO.  */\nextern void transfer_replacements (int, int);\n\n/* IN_RTX is the value loaded by a reload that we now decided to inherit,\n   or a subpart of it.  If we have any replacements registered for IN_RTX,\n   cancel the reloads that were supposed to load them.\n   Return nonzero if we canceled any reloads.  */\nextern int remove_address_replacements (rtx in_rtx);\n\n/* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n   if they are the same hard reg, and has special hacks for\n   autoincrement and autodecrement.  */\nextern int operands_match_p (rtx, rtx);\n\n/* Return 1 if altering OP will not modify the value of CLOBBER.  */\nextern int safe_from_earlyclobber (rtx, rtx);\n\n/* Search the body of INSN for values that need reloading and record them\n   with push_reload.  REPLACE nonzero means record also where the values occur\n   so that subst_reloads can be used.  */\nextern int find_reloads (rtx, int, int, int, short *);\n\n/* Compute the sum of X and Y, making canonicalizations assumed in an\n   address, namely: sum constant integers, surround the sum of two\n   constants with a CONST, put the constant as the second operand, and\n   group the constant on the outermost sum.  */\nextern rtx form_sum (rtx, rtx);\n\n/* Substitute into the current INSN the registers into which we have reloaded\n   the things that need reloading.  */\nextern void subst_reloads (rtx);\n\n/* Make a copy of any replacements being done into X and move those copies\n   to locations in Y, a copy of X.  We only look at the highest level of\n   the RTL.  */\nextern void copy_replacements (rtx, rtx);\n\n/* Change any replacements being done to *X to be done to *Y */\nextern void move_replacements (rtx *x, rtx *y);\n\n/* If LOC was scheduled to be replaced by something, return the replacement.\n   Otherwise, return *LOC.  */\nextern rtx find_replacement (rtx *);\n\n/* Return nonzero if register in range \u00ddREGNO, ENDREGNO)\n   appears either explicitly or implicitly in X\n   other than being stored into.  */\nextern int refers_to_regno_for_reload_p (unsigned int, unsigned int,\n\t\t\t\t\t rtx, rtx *);\n\n/* Nonzero if modifying X will affect IN.  */\nextern int reg_overlap_mentioned_for_reload_p (rtx, rtx);\n\n/* Return nonzero if anything in X contains a MEM.  Look also for pseudo\n   registers.  */\nextern int refers_to_mem_for_reload_p (rtx);\n\n/* Check the insns before INSN to see if there is a suitable register\n   containing the same value as GOAL.  */\nextern rtx find_equiv_reg (rtx, rtx, enum reg_class, int, short *,\n\t\t\t   int, enum machine_mode);\n\n/* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\nextern int regno_clobbered_p (unsigned int, rtx, enum machine_mode, int);\n\n/* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\nextern int earlyclobber_operand_p (rtx);\n\n/* Record one reload that needs to be performed.  */\nextern int push_reload (rtx, rtx, rtx *, rtx *, enum reg_class,\n\t\t\tenum machine_mode, enum machine_mode,\n\t\t\tint, int, int, enum reload_type);\n\n/* Functions in postreload.c:  */\nextern void reload_cse_regs (rtx);\n\n/* Functions in reload1.c:  */\nextern int reloads_conflict (int, int);\n\n/* Initialize the reload pass once per compilation.  */\nextern void init_reload (void);\n\n/* The reload pass itself.  */\nextern int reload (rtx, int);\n\n/* Mark the slots in regs_ever_live for the hard regs\n   used by pseudo-reg number REGNO.  */\nextern void mark_home_live (int);\n\n/* Scan X and replace any eliminable registers (such as fp) with a\n   replacement (such as sp), plus an offset.  */\nextern rtx eliminate_regs (rtx, enum machine_mode, rtx);\n\n/* Emit code to perform a reload from IN (which may be a reload register) to\n   OUT (which may also be a reload register).  IN or OUT is from operand\n   OPNUM with reload type TYPE.  */\nextern rtx gen_reload (rtx, rtx, int, enum reload_type);\n\n/* Deallocate the reload register used by reload number R.  */\nextern void deallocate_reload_reg (int r);\n\n/* Functions in caller-save.c:  */\n\n/* Initialize for caller-save.  */\nextern void init_caller_save (void);\n\n/* Initialize save areas by showing that we haven't allocated any yet.  */\nextern void init_save_areas (void);\n\n/* Allocate save areas for any hard registers that might need saving.  */\nextern void setup_save_areas (void);\n\n/* Find the places where hard regs are live across calls and save them.  */\nextern void save_call_clobbered_regs (void);\n\n/* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\nextern void cleanup_subreg_operands (rtx);\n\n/* Debugging support.  */\nextern void debug_reload_to_stream (FILE *);\nextern void debug_reload (void);\n\n/* Compute the actual register we should reload to, in case we're\n   reloading to/from a register that is wider than a word.  */\nextern rtx reload_adjust_reg_for_mode (rtx, enum machine_mode);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESOURCE": {"ttr": 9486, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for computing resource usage of specific insns.\n   Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Macro to clear all resources.  */\n#define CLEAR_RESOURCE(RES)\t\\\n do { (RES)->memory = (RES)->unch_memory = (RES)->volatil = (RES)->cc = 0; \\\n      CLEAR_HARD_REG_SET ((RES)->regs); } while (0)\n\n/* The resources used by a given insn.  */\nstruct resources\n{\n  char memory;\t\t/* Insn sets or needs a memory location.  */\n  char unch_memory;\t/* Insn sets of needs a \"unchanging\" MEM.  */\n  char volatil;\t\t/* Insn sets or needs a volatile memory loc.  */\n  char cc;\t\t/* Insn sets or needs the condition codes.  */\n  HARD_REG_SET regs;\t/* Which registers are set or needed.  */\n};\n\n/* The kinds of rtl mark_*_resources will consider */\nenum mark_resource_type\n{\n  MARK_SRC_DEST = 0,\n  MARK_SRC_DEST_CALL = 1\n};\n\nextern void mark_target_live_regs (rtx, rtx, struct resources *);\nextern void mark_set_resources (rtx, struct resources *, int,\n\t\t\t\tenum mark_resource_type);\nextern void mark_referenced_resources (rtx, struct resources *, int);\nextern void clear_hashed_info_for_insn (rtx);\nextern void incr_ticks_for_insn (rtx);\nextern void mark_end_of_function_resources (rtx, int);\nextern void init_resource_info (rtx);\nextern void free_resource_info (void);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTL": {"ttr": 9729, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Register Transfer Language (RTL) definitions for GCC\n   Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_RTL_H\n#define GCC_RTL_H\n\nstruct function;\n\n#include \"machmode.h\"\n#include \"input.h\"\n\n#undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n#undef FLOAT /* Likewise.  */\n#undef ABS /* Likewise.  */\n#undef PC /* Likewise.  */\n\n/* Value used by some passes to \"recognize\" noop moves as valid\n instructions.  */\n#define NOOP_MOVE_INSN_CODE\tINT_MAX\n\n/* Register Transfer Language EXPRESSIONS CODES */\n\n#define RTX_CODE\tenum rtx_code\nenum rtx_code  {\n\n#define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   ENUM ,\n#include \"rtl.def\"\t\t/* rtl expressions are documented here */\n#undef DEF_RTL_EXPR\n\n  LAST_AND_UNUSED_RTX_CODE};\t/* A convenient way to get a value for\n\t\t\t\t   NUM_RTX_CODE.\n\t\t\t\t   Assumes default enum value assignment.  */\n\n#define NUM_RTX_CODE ((int) LAST_AND_UNUSED_RTX_CODE)\n\t\t\t\t/* The cast here, saves many elsewhere.  */\n\nextern const unsigned char rtx_length\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_LENGTH(CODE)\t\t(rtx_length\u00dd(int) (CODE)\u00a8)\n\nextern const char * const rtx_name\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_NAME(CODE)\t\t(rtx_name\u00dd(int) (CODE)\u00a8)\n\nextern const char * const rtx_format\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_FORMAT(CODE)\t\t(rtx_format\u00dd(int) (CODE)\u00a8)\n\nextern const char rtx_class\u00ddNUM_RTX_CODE\u00a8;\n#define GET_RTX_CLASS(CODE)\t\t(rtx_class\u00dd(int) (CODE)\u00a8)\n\nextern const unsigned char rtx_size\u00ddNUM_RTX_CODE\u00a8;\nextern const unsigned char rtx_next\u00ddNUM_RTX_CODE\u00a8;\n\n/* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n   relative to which the offsets are calculated, as explained in rtl.def.  */\ntypedef struct\n{\n  /* Set at the start of shorten_branches - ONLY WHEN OPTIMIZING - : */\n  unsigned min_align: 8;\n  /* Flags: */\n  unsigned base_after_vec: 1; /* BASE is after the ADDR_DIFF_VEC.  */\n  unsigned min_after_vec: 1;  /* minimum address target label is\n\t\t\t\t after the ADDR_DIFF_VEC.  */\n  unsigned max_after_vec: 1;  /* maximum address target label is\n\t\t\t\t after the ADDR_DIFF_VEC.  */\n  unsigned min_after_base: 1; /* minimum address target label is\n\t\t\t\t after BASE.  */\n  unsigned max_after_base: 1; /* maximum address target label is\n\t\t\t\t after BASE.  */\n  /* Set by the actual branch shortening process - ONLY WHEN OPTIMIZING - : */\n  unsigned offset_unsigned: 1; /* offsets have to be treated as unsigned.  */\n  unsigned : 2;\n  unsigned scale : 8;\n} addr_diff_vec_flags;\n\n/* Structure used to describe the attributes of a MEM.  These are hashed\n   so MEMs that the same attributes share a data structure.  This means\n   they cannot be modified in place.  If any element is nonzero, it means\n   the value of the corresponding attribute is unknown.  */\n/* ALIGN and SIZE are the alignment and size of the MEM itself,\n   while EXPR can describe a larger underlying object, which might have a\n   stricter alignment; OFFSET is the offset of the MEM within that object.  */\ntypedef struct mem_attrs GTY(())\n{\n  HOST_WIDE_INT alias;\t\t/* Memory alias set.  */\n  tree expr;\t\t\t/* expr corresponding to MEM.  */\n  rtx offset;\t\t\t/* Offset from start of DECL, as CONST_INT.  */\n  rtx size;\t\t\t/* Size in bytes, as a CONST_INT.  */\n  unsigned int align;\t\t/* Alignment of MEM in bits.  */\n} mem_attrs;\n\n/* Structure used to describe the attributes of a REG in similar way as\n   mem_attrs does for MEM above.  */\n\ntypedef struct reg_attrs GTY(())\n{\n  tree decl;\t\t\t/* decl corresponding to REG.  */\n  HOST_WIDE_INT offset;\t\t/* Offset from start of DECL.  */\n} reg_attrs;\n\n/* Common union for an element of an rtx.  */\n\nunion rtunion_def\n{\n  int rtint;\n  unsigned int rtuint;\n  const char *rtstr;\n  rtx rtx;\n  rtvec rtvec;\n  enum machine_mode rttype;\n  addr_diff_vec_flags rt_addr_diff_vec_flags;\n  struct cselib_val_struct *rt_cselib;\n  struct bitmap_head_def *rtbit;\n  tree rttree;\n  struct basic_block_def *bb;\n  mem_attrs *rtmem;\n  reg_attrs *rtreg;\n};\ntypedef union rtunion_def rtunion;\n\n/* RTL expression (\"rtx\").  */\n\nstruct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n\t\t    chain_prev (\"RTX_PREV (&%h)\")))\n{\n  /* The kind of expression this is.  */\n  ENUM_BITFIELD(rtx_code) code: 16;\n\n  /* The kind of value the expression has.  */\n  ENUM_BITFIELD(machine_mode) mode : 8;\n\n  /* 1 in a MEM if we should keep the alias set for this mem unchanged\n     when we access a component.\n     1 in a CALL_INSN if it is a sibling call.\n     1 in a SET that is for a return.\n     In a CODE_LABEL, part of the two-bit alternate entry field.  */\n  unsigned int jump : 1;\n  /* In a CODE_LABEL, part of the two-bit alternate entry field.\n     1 in a MEM if it cannot trap.  */\n  unsigned int call : 1;\n  /* 1 in a REG, MEM, or CONCAT if the value is set at most once, anywhere.\n     1 in a SUBREG if it references an unsigned object whose mode has been\n     from a promoted to a wider mode.\n     1 in a SYMBOL_REF if it addresses something in the per-function\n     constants pool.\n     1 in a CALL_INSN, NOTE, or EXPR_LIST for a const or pure call.\n     1 in a JUMP_INSN, CALL_INSN, or INSN of an annulling branch.  */\n  unsigned int unchanging : 1;\n  /* 1 in a MEM or ASM_OPERANDS expression if the memory reference is volatile.\n     1 in an INSN, CALL_INSN, JUMP_INSN, CODE_LABEL, BARRIER, or NOTE\n     if it has been deleted.\n     1 in a REG expression if corresponds to a variable declared by the user,\n     0 for an internally generated temporary.\n     1 in a SUBREG with a negative value.\n     1 in a LABEL_REF or in a REG_LABEL note for a non-local label.\n     In a SYMBOL_REF, this flag is used for machine-specific purposes.  */\n  unsigned int volatil : 1;\n  /* 1 in a MEM referring to a field of an aggregate.\n     0 if the MEM was a variable or the result of a * operator in C;\n     1 if it was the result of a . or -> operator (on a struct) in C.\n     1 in a REG if the register is used only in exit code a loop.\n     1 in a SUBREG expression if was generated from a variable with a\n     promoted mode.\n     1 in a CODE_LABEL if the label is used for nonlocal gotos\n     and must not be deleted even if its count is zero.\n     1 in a LABEL_REF if this is a reference to a label outside the\n     current loop.\n     1 in an INSN, JUMP_INSN or CALL_INSN if this insn must be scheduled\n     together with the preceding insn.  Valid only within sched.\n     1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n     from the target of a branch.  Valid from reorg until end of compilation;\n     cleared before used.\n     1 in an INSN, JUMP_INSN or CALL_INSN or related rtx if this insn is\n     dead code.  Valid only during dead-code elimination phase; cleared\n     before use.  */\n  unsigned int in_struct : 1;\n  /* At the end of RTL generation, 1 if this rtx is used.  This is used for\n     copying shared structure.  See `unshare_all_rtl'.\n     In a REG, this is not needed for that purpose, and used instead\n     in `leaf_renumber_regs_insn'.\n     1 in a SYMBOL_REF, means that emit_library_call\n     has used it as the function.  */\n  unsigned int used : 1;\n  /* Nonzero if this rtx came from procedure integration.\n     1 in a REG or PARALLEL means this rtx refers to the return value\n     of the current function.\n     1 in a SYMBOL_REF if the symbol is weak.  */\n  unsigned integrated : 1;\n  /* 1 in an INSN or a SET if this rtx is related to the call frame,\n     either changing how we compute the frame address or saving and\n     restoring registers in the prologue and epilogue.\n     1 in a MEM if the MEM refers to a scalar, rather than a member of\n     an aggregate.\n     1 in a REG if the register is a pointer.\n     1 in a SYMBOL_REF if it addresses something in the per-function\n     constant string pool.  */\n  unsigned frame_related : 1;\n\n  /* The first element of the operands of this rtx.\n     The number of operands and their types are controlled\n     by the `code' field, according to rtl.def.  */\n  union u {\n    rtunion fld\u00dd1\u00a8;\n    HOST_WIDE_INT hwint\u00dd1\u00a8;\n  } GTY ((special (\"rtx_def\"), desc (\"GET_CODE (&%0)\"))) u;\n};\n\n/* The size in bytes of an rtx header (code, mode and flags).  */\n#define RTX_HDR_SIZE offsetof (struct rtx_def, u)\n\n/* The size in bytes of an rtx with code CODE.  */\n#define RTX_SIZE(CODE) rtx_size\u00ddCODE\u00a8\n\n#define NULL_RTX (rtx) 0\n\n/* The \"next\" and \"previous\" RTX, relative to this one.  */\n\n#define RTX_NEXT(X) (rtx_next\u00ddGET_CODE (X)\u00a8 == 0 ? NULL\t\t\t\\\n\t\t     : *(rtx *)(((char *)X) + rtx_next\u00ddGET_CODE (X)\u00a8))\n\n/* FIXME: the \"NEXT_INSN (PREV_INSN (X)) == X\" condition shouldn't be needed.\n */\n#define RTX_PREV(X) ((GET_CODE (X) == INSN              \\\n                      || GET_CODE (X) == CALL_INSN      \\\n                      || GET_CODE (X) == JUMP_INSN      \\\n                      || GET_CODE (X) == NOTE           \\\n                      || GET_CODE (X) == BARRIER        \\\n                      || GET_CODE (X) == CODE_LABEL)    \\\n                     && PREV_INSN (X) != NULL           \\\n                     && NEXT_INSN (PREV_INSN (X)) == X  \\\n                     ? PREV_INSN (X) : NULL)\n\n/* Define macros to access the `code' field of the rtx.  */\n\n#define GET_CODE(RTX)\t    ((enum rtx_code) (RTX)->code)\n#define PUT_CODE(RTX, CODE) ((RTX)->code = (CODE))\n\n#define GET_MODE(RTX)\t    ((enum machine_mode) (RTX)->mode)\n#define PUT_MODE(RTX, MODE) ((RTX)->mode = (MODE))\n\n/* RTL vector.  These appear inside RTX's when there is a need\n   for a variable number of things.  The principle use is inside\n   PARALLEL expressions.  */\n\nstruct rtvec_def GTY(()) {\n  int num_elem;\t\t/* number of elements */\n  rtx GTY ((length (\"%h.num_elem\"))) elem\u00dd1\u00a8;\n};\n\n#define NULL_RTVEC (rtvec) 0\n\n#define GET_NUM_ELEM(RTVEC)\t\t((RTVEC)->num_elem)\n#define PUT_NUM_ELEM(RTVEC, NUM)\t((RTVEC)->num_elem = (NUM))\n\n/* Predicate yielding nonzero iff X is an rtl for a register.  */\n#define REG_P(X) (GET_CODE (X) == REG)\n\n/* Predicate yielding nonzero iff X is a label insn.  */\n#define LABEL_P(X) (GET_CODE (X) == CODE_LABEL)\n\n/* Predicate yielding nonzero iff X is a jump insn.  */\n#define JUMP_P(X) (GET_CODE (X) == JUMP_INSN)\n\n/* Predicate yielding nonzero iff X is a note insn.  */\n#define NOTE_P(X) (GET_CODE (X) == NOTE)\n\n/* Predicate yielding nonzero iff X is a barrier insn.  */\n#define BARRIER_P(X) (GET_CODE (X) == BARRIER)\n\n/* Predicate yielding nonzero iff X is a data for a jump table.  */\n#define JUMP_TABLE_DATA_P(INSN) \\\n  (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n\t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n\n/* 1 if X is a constant value that is an integer.  */\n\n#define CONSTANT_P(X)   \\\n  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n   || GET_CODE (X) == CONST || GET_CODE (X) == HIGH\t\t\t\\\n   || GET_CODE (X) == CONST_VECTOR\t                                \\\n   || GET_CODE (X) == CONSTANT_P_RTX)\n\n/* General accessor macros for accessing the fields of an rtx.  */\n\n#if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)\n/* The bit with a star outside the statement expr and an & inside is\n   so that N can be evaluated only once.  */\n#define RTL_CHECK1(RTX, N, C1) __extension__\t\t\t\t\\\n(*({ rtx const _rtx = (RTX); const int _n = (N);\t\t\t\\\n     const enum rtx_code _code = GET_CODE (_rtx);\t\t\t\\\n     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n\t\t\t\t__FUNCTION__);\t\t\t\t\\\n     if (GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C1)\t\t\t\t\\\n       rtl_check_failed_type1 (_rtx, _n, C1, __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->u.fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECK2(RTX, N, C1, C2) __extension__\t\t\t\\\n(*({ rtx const _rtx = (RTX); const int _n = (N);\t\t\t\\\n     const enum rtx_code _code = GET_CODE (_rtx);\t\t\t\\\n     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n\t\t\t\t__FUNCTION__);\t\t\t\t\\\n     if (GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C1\t\t\t\t\\\n\t && GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != C2)\t\t\t\t\\\n       rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->u.fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECKC1(RTX, N, C) __extension__\t\t\t\t\\\n(*({ rtx const _rtx = (RTX); const int _n = (N);\t\t\t\\\n     if (GET_CODE (_rtx) != (C))\t\t\t\t\t\\\n       rtl_check_failed_code1 (_rtx, (C), __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->u.fld\u00dd_n\u00a8; }))\n\n#define RTL_CHECKC2(RTX, N, C1, C2) __extension__\t\t\t\\\n(*({ rtx const _rtx = (RTX); const int _n = (N);\t\t\t\\\n     const enum rtx_code _code = GET_CODE (_rtx);\t\t\t\\\n     if (_code != (C1) && _code != (C2))\t\t\t\t\\\n       rtl_check_failed_code2 (_rtx, (C1), (C2), __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__); \\\n     &_rtx->u.fld\u00dd_n\u00a8; }))\n\n#define RTVEC_ELT(RTVEC, I) __extension__\t\t\t\t\\\n(*({ rtvec const _rtvec = (RTVEC); const int _i = (I);\t\t\t\\\n     if (_i < 0 || _i >= GET_NUM_ELEM (_rtvec))\t\t\t\t\\\n       rtvec_check_failed_bounds (_rtvec, _i, __FILE__, __LINE__,\t\\\n\t\t\t\t  __FUNCTION__);\t\t\t\\\n     &_rtvec->elem\u00dd_i\u00a8; }))\n\n#define XWINT(RTX, N) __extension__\t\t\t\t\t\\\n(*({ rtx const _rtx = (RTX); const int _n = (N);\t\t\t\\\n     const enum rtx_code _code = GET_CODE (_rtx);\t\t\t\\\n     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n\t\t\t\t__FUNCTION__);\t\t\t\t\\\n     if (GET_RTX_FORMAT(_code)\u00dd_n\u00a8 != 'w')\t\t\t\t\\\n       rtl_check_failed_type1 (_rtx, _n, 'w', __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->u.hwint\u00dd_n\u00a8; }))\n\n#define XCWINT(RTX, N, C) __extension__\t\t\t\t\t\\\n(*({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n     if (GET_CODE (_rtx) != (C))\t\t\t\t\t\\\n       rtl_check_failed_code1 (_rtx, (C), __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n     &_rtx->u.hwint\u00ddN\u00a8; }))\n\nextern void rtl_check_failed_bounds (rtx, int, const char *, int,\n\t\t\t\t     const char *)\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_type1 (rtx, int, int, const char *, int,\n\t\t\t\t    const char *)\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_type2 (rtx, int, int, int, const char *,\n\t\t\t\t    int, const char *)\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_code1 (rtx, enum rtx_code, const char *,\n\t\t\t\t    int, const char *)\n    ATTRIBUTE_NORETURN;\nextern void rtl_check_failed_code2 (rtx, enum rtx_code, enum rtx_code,\n\t\t\t\t    const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\nextern void rtvec_check_failed_bounds (rtvec, int, const char *, int,\n\t\t\t\t       const char *)\n    ATTRIBUTE_NORETURN;\n\n#else   /* not ENABLE_RTL_CHECKING */\n\n#define RTL_CHECK1(RTX, N, C1)      ((RTX)->u.fld\u00ddN\u00a8)\n#define RTL_CHECK2(RTX, N, C1, C2)  ((RTX)->u.fld\u00ddN\u00a8)\n#define RTL_CHECKC1(RTX, N, C)\t    ((RTX)->u.fld\u00ddN\u00a8)\n#define RTL_CHECKC2(RTX, N, C1, C2) ((RTX)->u.fld\u00ddN\u00a8)\n#define RTVEC_ELT(RTVEC, I)\t    ((RTVEC)->elem\u00ddI\u00a8)\n#define XWINT(RTX, N)\t\t    ((RTX)->u.hwint\u00ddN\u00a8)\n#define XCWINT(RTX, N, C)\t    ((RTX)->u.hwint\u00ddN\u00a8)\n\n#endif\n\n/* General accessor macros for accessing the flags of an rtx.  */\n\n/* Access an individual rtx flag, with no checking of any kind.  */\n#define RTX_FLAG(RTX, FLAG)\t((RTX)->FLAG)\n\n#if defined ENABLE_RTL_FLAG_CHECKING && (GCC_VERSION >= 2007)\n#define RTL_FLAG_CHECK1(NAME, RTX, C1) __extension__\t\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1)\t\t\t\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK2(NAME, RTX, C1, C2) __extension__\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2)\t\t\t\\\n     rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t      __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3) __extension__\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3)\t\t\t\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4) __extension__\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4)\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t      __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5) __extension__\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n       && GET_CODE(_rtx) != C5)\t\t\t\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6)\t\t\t\\\n     rtl_check_failed_flag  (NAME,_rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n       && GET_CODE(_rtx) != C7)\t\t\t\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\n#define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t\\\n  __extension__\t\t\t\t\t\t\t\t\\\n({ rtx const _rtx = (RTX);\t\t\t\t\t\t\\\n   if (GET_CODE(_rtx) != C1 && GET_CODE(_rtx) != C2\t\t\t\\\n       && GET_CODE(_rtx) != C3 && GET_CODE(_rtx) != C4\t\t\t\\\n       && GET_CODE(_rtx) != C5 && GET_CODE(_rtx) != C6\t\t\t\\\n       && GET_CODE(_rtx) != C7 && GET_CODE(_rtx) != C8)\t\t\t\\\n     rtl_check_failed_flag  (NAME, _rtx, __FILE__, __LINE__,\t\t\\\n\t\t\t     __FUNCTION__);\t\t\t\t\\\n   _rtx; })\n\nextern void rtl_check_failed_flag (const char *, rtx, const char *,\n\t\t\t\t   int, const char *)\n    ATTRIBUTE_NORETURN\n    ;\n\n#else\t/* not ENABLE_RTL_FLAG_CHECKING */\n\n#define RTL_FLAG_CHECK1(NAME, RTX, C1)\t\t\t\t\t(RTX)\n#define RTL_FLAG_CHECK2(NAME, RTX, C1, C2)\t\t\t\t(RTX)\n#define RTL_FLAG_CHECK3(NAME, RTX, C1, C2, C3)\t\t\t\t(RTX)\n#define RTL_FLAG_CHECK4(NAME, RTX, C1, C2, C3, C4)\t\t\t(RTX)\n#define RTL_FLAG_CHECK5(NAME, RTX, C1, C2, C3, C4, C5)\t\t(RTX)\n#define RTL_FLAG_CHECK6(NAME, RTX, C1, C2, C3, C4, C5, C6)\t\t(RTX)\n#define RTL_FLAG_CHECK7(NAME, RTX, C1, C2, C3, C4, C5, C6, C7)\t\t(RTX)\n#define RTL_FLAG_CHECK8(NAME, RTX, C1, C2, C3, C4, C5, C6, C7, C8)\t(RTX)\n#endif\n\n#define CLEAR_RTX_FLAGS(RTX)\t\\\ndo {\t\t\t\t\\\n  rtx const _rtx = (RTX);\t\\\n  _rtx->call = 0;\t\t\\\n  _rtx->frame_related = 0;\t\\\n  _rtx->in_struct = 0;\t\t\\\n  _rtx->integrated = 0;\t\t\\\n  _rtx->jump = 0;\t\t\\\n  _rtx->unchanging = 0;\t\t\\\n  _rtx->used = 0;\t\t\\\n  _rtx->volatil = 0;\t\t\\\n} while (0)\n\n#define XINT(RTX, N)\t(RTL_CHECK2 (RTX, N, 'i', 'n').rtint)\n#define XSTR(RTX, N)\t(RTL_CHECK2 (RTX, N, 's', 'S').rtstr)\n#define XEXP(RTX, N)\t(RTL_CHECK2 (RTX, N, 'e', 'u').rtx)\n#define XVEC(RTX, N)\t(RTL_CHECK2 (RTX, N, 'E', 'V').rtvec)\n#define XMODE(RTX, N)\t(RTL_CHECK1 (RTX, N, 'M').rttype)\n#define XBITMAP(RTX, N) (RTL_CHECK1 (RTX, N, 'b').rtbit)\n#define XTREE(RTX, N)   (RTL_CHECK1 (RTX, N, 't').rttree)\n#define XBBDEF(RTX, N)\t(RTL_CHECK1 (RTX, N, 'B').bb)\n#define XTMPL(RTX, N)\t(RTL_CHECK1 (RTX, N, 'T').rtstr)\n\n#define XVECEXP(RTX, N, M)\tRTVEC_ELT (XVEC (RTX, N), M)\n#define XVECLEN(RTX, N)\t\tGET_NUM_ELEM (XVEC (RTX, N))\n\n/* These are like XINT, etc. except that they expect a '0' field instead\n   of the normal type code.  */\n\n#define X0INT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtint)\n#define X0UINT(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtuint)\n#define X0STR(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtstr)\n#define X0EXP(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtx)\n#define X0VEC(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rtvec)\n#define X0MODE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttype)\n#define X0BITMAP(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rtbit)\n#define X0TREE(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').rttree)\n#define X0BBDEF(RTX, N)\t   (RTL_CHECK1 (RTX, N, '0').bb)\n#define X0ADVFLAGS(RTX, N) (RTL_CHECK1 (RTX, N, '0').rt_addr_diff_vec_flags)\n#define X0CSELIB(RTX, N)   (RTL_CHECK1 (RTX, N, '0').rt_cselib)\n#define X0MEMATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, MEM).rtmem)\n#define X0REGATTR(RTX, N)  (RTL_CHECKC1 (RTX, N, REG).rtreg)\n\n/* Access a '0' field with any type.  */\n#define X0ANY(RTX, N)\t   RTL_CHECK1 (RTX, N, '0')\n\n#define XCINT(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtint)\n#define XCUINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rtuint)\n#define XCSTR(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtstr)\n#define XCEXP(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtx)\n#define XCVEC(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rtvec)\n#define XCMODE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttype)\n#define XCBITMAP(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rtbit)\n#define XCTREE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rttree)\n#define XCBBDEF(RTX, N, C)    (RTL_CHECKC1 (RTX, N, C).bb)\n#define XCADVFLAGS(RTX, N, C) (RTL_CHECKC1 (RTX, N, C).rt_addr_diff_vec_flags)\n#define XCCSELIB(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_cselib)\n\n#define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n#define XCVECLEN(RTX, N, C)\tGET_NUM_ELEM (XCVEC (RTX, N, C))\n\n#define XC2EXP(RTX, N, C1, C2)      (RTL_CHECKC2 (RTX, N, C1, C2).rtx)\n\n/* ACCESS MACROS for particular fields of insns.  */\n\n/* Determines whether X is an insn.  */\n#define INSN_P(X)       (GET_RTX_CLASS (GET_CODE(X)) == 'i')\n\n/* Holds a unique number for each insn.\n   These are not necessarily sequentially increasing.  */\n#define INSN_UID(INSN)  XINT (INSN, 0)\n\n/* Chain insns together in sequence.  */\n#define PREV_INSN(INSN)\tXEXP (INSN, 1)\n#define NEXT_INSN(INSN)\tXEXP (INSN, 2)\n\n#define BLOCK_FOR_INSN(INSN) XBBDEF (INSN, 3)\n#define INSN_LOCATOR(INSN) XINT (INSN, 4)\n/* The body of an insn.  */\n#define PATTERN(INSN)\tXEXP (INSN, 5)\n\n/* Code number of instruction, from when it was recognized.\n   -1 means this instruction has not been recognized yet.  */\n#define INSN_CODE(INSN) XINT (INSN, 6)\n\n/* Set up in flow.c; empty before then.\n   Holds a chain of INSN_LIST rtx's whose first operands point at\n   previous insns with direct data-flow connections to this one.\n   That means that those insns set variables whose next use is in this insn.\n   They are always in the same basic block as this insn.  */\n#define LOG_LINKS(INSN)\tXEXP(INSN, 7)\n\n#define RTX_INTEGRATED_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK8(\"RTX_INTEGRATED_P\", (RTX), INSN, CALL_INSN,\t\t\\\n\t\t   JUMP_INSN, INSN_LIST, BARRIER, CODE_LABEL, CONST,\t\\\n\t\t   NOTE)->integrated)\n#define RTX_UNCHANGING_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"RTX_UNCHANGING_P\", (RTX), REG, MEM, CONCAT)->unchanging)\n#define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK5(\"RTX_FRAME_RELATED_P\", (RTX), INSN, CALL_INSN,\t\\\n\t\t   JUMP_INSN, BARRIER, SET)->frame_related)\n\n/* 1 if RTX is an insn that has been deleted.  */\n#define INSN_DELETED_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK6(\"INSN_DELETED_P\", (RTX), INSN, CALL_INSN, JUMP_INSN,\t\\\n\t\t   CODE_LABEL, BARRIER, NOTE)->volatil)\n\n/* 1 if RTX is a call to a const or pure function.  */\n#define CONST_OR_PURE_CALL_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"CONST_OR_PURE_CALL_P\", (RTX), CALL_INSN, NOTE,\t\\\n\t\t   EXPR_LIST)->unchanging)\n\n/* 1 if RTX is a call_insn for a sibling call.  */\n#define SIBLING_CALL_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SIBLING_CALL_P\", (RTX), CALL_INSN)->jump)\n\n/* 1 if RTX is a jump_insn, call_insn, or insn that is an annulling branch.  */\n#define INSN_ANNULLED_BRANCH_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"INSN_ANNULLED_BRANCH_P\", (RTX), JUMP_INSN, CALL_INSN, INSN)->unchanging)\n\n/* 1 if RTX is an insn that is dead code.  Valid only for dead-code\n   elimination phase.  */\n#define INSN_DEAD_CODE_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"INSN_DEAD_CODE_P\", (RTX), INSN, CALL_INSN, JUMP_INSN)->in_struct)\n\n/* 1 if RTX is an insn in a delay slot and is from the target of the branch.\n   If the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n   executed if the branch is taken.  For annulled branches with this bit\n   clear, the insn should be executed only if the branch is not taken.  */\n#define INSN_FROM_TARGET_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"INSN_FROM_TARGET_P\", (RTX), INSN, JUMP_INSN, CALL_INSN)->in_struct)\n\n#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n\n#define CSELIB_VAL_PTR(RTX) X0CSELIB(RTX, 0)\n\n/* Holds a list of notes on what this insn does to various REGs.\n   It is a chain of EXPR_LIST rtx's, where the second operand is the\n   chain pointer and the first operand is the REG being described.\n   The mode field of the EXPR_LIST contains not a real machine mode\n   but a value from enum reg_note.  */\n\n#define REG_NOTES(INSN)\tXEXP(INSN, 8)\n\n/* Don't forget to change reg_note_name in rtl.c.  */\nenum reg_note\n{\n  /* The value in REG dies in this insn (i.e., it is not needed past\n     this insn).  If REG is set in this insn, the REG_DEAD note may,\n     but need not, be omitted.  */\n  REG_DEAD = 1,\n\n  /* The REG is autoincremented or autodecremented.  */\n  REG_INC,\n\n  /* Describes the insn as a whole; it says that the insn sets a register\n     to a constant value or to be equivalent to a memory address.  If the\n     register is spilled to the stack then the constant value should be\n     substituted for it.  The contents of the REG_EQUIV is the constant\n     value or memory address, which may be different from the source of\n     the SET although it has the same value.  A REG_EQUIV note may also\n     appear on an insn which copies a register parameter to a pseudo-register,\n     if there is a memory address which could be used to hold that\n     pseudo-register throughout the function.  */\n  REG_EQUIV,\n\n  /* Like REG_EQUIV except that the destination is only momentarily equal\n     to the specified rtx.  Therefore, it cannot be used for substitution;\n     but it can be used for cse.  */\n  REG_EQUAL,\n\n  /* This insn copies the return-value of a library call out of the hard reg\n     for return values.  This note is actually an INSN_LIST and it points to\n     the first insn involved in setting up arguments for the call.  flow.c\n     uses this to delete the entire library call when its result is dead.  */\n  REG_RETVAL,\n\n  /* The inverse of REG_RETVAL: it goes on the first insn of the library call\n     and points at the one that has the REG_RETVAL.  This note is also an\n     INSN_LIST.  */\n  REG_LIBCALL,\n\n  /* The register is always nonnegative during the containing loop.  This is\n     used in branches so that decrement and branch instructions terminating\n     on zero can be matched.  There must be an insn pattern in the md file\n     named `decrement_and_branch_until_zero' or else this will never be added\n     to any instructions.  */\n  REG_NONNEG,\n\n  /* There is no conflict *after this insn* between the register in the note\n     and the destination of this insn.  */\n  REG_NO_CONFLICT,\n\n  /* Identifies a register set in this insn and never used.  */\n  REG_UNUSED,\n\n  /* REG_CC_SETTER and REG_CC_USER link a pair of insns that set and use CC0,\n     respectively.  Normally, these are required to be consecutive insns, but\n     we permit putting a cc0-setting insn in the delay slot of a branch as\n     long as only one copy of the insn exists.  In that case, these notes\n     point from one to the other to allow code generation to determine what\n     any require information and to properly update CC_STATUS.  These notes\n     are INSN_LISTs.  */\n  REG_CC_SETTER, REG_CC_USER,\n\n  /* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n     CODE_LABEL contained in the REG_LABEL note is used by the insn.\n     This note is an INSN_LIST.  */\n  REG_LABEL,\n\n  /* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n     write-after-read and write-after-write dependencies respectively.\n     Data dependencies, which are the only type of LOG_LINK created by\n     flow, are represented by a 0 reg note kind.  */\n  REG_DEP_ANTI, REG_DEP_OUTPUT,\n\n  /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.\n     It has an integer value.  For jumps, it is the probability that this is a\n     taken branch.  For calls, it is the probability that this call won't\n     return.  */\n  REG_BR_PROB,\n\n  /* REG_VALUE_PROFILE is attached when the profile is read in to an insn\n     before that the code to profile the value is inserted.  It contains\n     the results of profiling.  */\n  REG_VALUE_PROFILE,\n\n  /* Attached to a call insn; indicates that the call is malloc-like and\n     that the pointer returned cannot alias anything else.  */\n  REG_NOALIAS,\n\n  /* Used to optimize rtl generated by dynamic stack allocations for targets\n     where SETJMP_VIA_SAVE_AREA is true.  */\n  REG_SAVE_AREA,\n\n  /* REG_BR_PRED is attached to JUMP_INSNs and CALL_INSNSs.  It contains\n     CONCAT of two integer value.  First specifies the branch predictor\n     that added the note, second specifies the predicted hitrate of branch\n     in the same format as REG_BR_PROB note uses.  */\n  REG_BR_PRED,\n\n  /* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n     for DWARF to interpret what they imply.  The attached rtx is used\n     instead of intuition.  */\n  REG_FRAME_RELATED_EXPR,\n\n  /* Indicates that REG holds the exception context for the function.\n     This context is shared by inline functions, so the code to acquire\n     the real exception context is delayed until after inlining.  */\n  REG_EH_CONTEXT,\n\n  /* Indicates what exception region an INSN belongs in.  This is used to\n     indicate what region to which a call may throw.  REGION 0 indicates\n     that a call cannot throw at all.  REGION -1 indicates that it cannot\n     throw, nor will it execute a non-local goto.  */\n  REG_EH_REGION,\n\n  /* Used by haifa-sched to save NOTE_INSN notes across scheduling.  */\n  REG_SAVE_NOTE,\n\n  /* Indicates that this insn (which is part of the prologue) computes\n     a value which might not be used later, and if so it's OK to delete\n     the insn.  Normally, deleting any insn in the prologue is an error.\n     At present the parameter is unused and set to (const_int 0).  */\n  REG_MAYBE_DEAD,\n\n  /* Indicates that a call does not return.  */\n  REG_NORETURN,\n\n  /* Indicates that an indirect jump is a non-local goto instead of a\n     computed goto.  */\n  REG_NON_LOCAL_GOTO,\n\n  /* This kind of note is generated at each to `setjmp',\n     and similar functions that can return twice.  */\n  REG_SETJMP,\n\n  /* Indicate calls that always returns.  */\n  REG_ALWAYS_RETURN,\n\n  /* Indicate that the memory load references a vtable.  The expression\n     is of the form (plus (symbol_ref vtable_sym) (const_int offset)).  */\n  REG_VTABLE_REF\n};\n\n/* The base value for branch probability notes.  */\n#define REG_BR_PROB_BASE  10000\n\n/* Define macros to extract and insert the reg-note kind in an EXPR_LIST.  */\n#define REG_NOTE_KIND(LINK) ((enum reg_note) GET_MODE (LINK))\n#define PUT_REG_NOTE_KIND(LINK, KIND) \\\n  PUT_MODE (LINK, (enum machine_mode) (KIND))\n\n/* Names for REG_NOTE's in EXPR_LIST insn's.  */\n\nextern const char * const reg_note_name\u00dd\u00a8;\n#define GET_REG_NOTE_NAME(MODE) (reg_note_name\u00dd(int) (MODE)\u00a8)\n\n/* This field is only present on CALL_INSNs.  It holds a chain of EXPR_LIST of\n   USE and CLOBBER expressions.\n     USE expressions list the registers filled with arguments that\n   are passed to the function.\n     CLOBBER expressions document the registers explicitly clobbered\n   by this CALL_INSN.\n     Pseudo registers can not be mentioned in this list.  */\n#define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 9)\n\n/* The label-number of a code-label.  The assembler label\n   is made from `L' and the label-number printed in decimal.\n   Label numbers are unique in a compilation.  */\n#define CODE_LABEL_NUMBER(INSN)\tXINT (INSN, 6)\n\n#define LINE_NUMBER NOTE\n\n/* In a NOTE that is a line number, this is a string for the file name that the\n   line is in.  We use the same field to record block numbers temporarily in\n   NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes.  (We avoid lots of casts\n   between ints and pointers if we use a different macro for the block number.)\n   */\n\n/* Opaque data.  */\n#define NOTE_DATA(INSN)\t        RTL_CHECKC1 (INSN, 4, NOTE)\n#define NOTE_SOURCE_FILE(INSN)\tXCSTR (INSN, 4, NOTE)\n#define NOTE_BLOCK(INSN)\tXCTREE (INSN, 4, NOTE)\n#define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 4, NOTE)\n#define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 4, NOTE)\n#define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 4, NOTE)\n#define NOTE_PREDICTION(INSN)   XCINT (INSN, 4, NOTE)\n#define NOTE_PRECONDITIONED(INSN)   XCINT (INSN, 4, NOTE)\n\n/* In a NOTE that is a line number, this is the line number.\n   Other kinds of NOTEs are identified by negative numbers here.  */\n#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 5, NOTE)\n\n/* Nonzero if INSN is a note marking the beginning of a basic block.  */\n#define NOTE_INSN_BASIC_BLOCK_P(INSN)\t\t\t\\\n  (GET_CODE (INSN) == NOTE\t\t\t\t\\\n   && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n\n/* Algorithm and flags for prediction.  */\n#define NOTE_PREDICTION_ALG(INSN)   (XCINT(INSN, 4, NOTE)>>8)\n#define NOTE_PREDICTION_FLAGS(INSN) (XCINT(INSN, 4, NOTE)&0xff)\n#define NOTE_PREDICT(ALG,FLAGS)     ((ALG<<8)+(FLAGS))\n\n/* Codes that appear in the NOTE_LINE_NUMBER field\n   for kinds of notes that are not line numbers.\n\n   Notice that we do not try to use zero here for any of\n   the special note codes because sometimes the source line\n   actually can be zero!  This happens (for example) when we\n   are generating code for the per-translation-unit constructor\n   and destructor routines for some C++ translation unit.\n\n   If you should change any of the following values, or if you\n   should add a new value here, don't forget to change the\n   note_insn_name array in rtl.c.  */\n\nenum insn_note\n{\n  /* Keep all of these numbers negative.  Adjust as needed.  */\n  NOTE_INSN_BIAS = -100,\n\n  /* This note is used to get rid of an insn\n     when it isn't safe to patch the insn out of the chain.  */\n  NOTE_INSN_DELETED,\n\n  /* These are used to mark the beginning and end of a lexical block.\n     See NOTE_BLOCK, identify_blocks and reorder_blocks.  */\n  NOTE_INSN_BLOCK_BEG,\n  NOTE_INSN_BLOCK_END,\n\n  /* These mark the extremes of a loop.  */\n  NOTE_INSN_LOOP_BEG,\n  NOTE_INSN_LOOP_END,\n\n  /* Generated at the place in a loop that `continue' jumps to.  */\n  NOTE_INSN_LOOP_CONT,\n  /* Generated at the start of a duplicated exit test.  */\n  NOTE_INSN_LOOP_VTOP,\n\n  /* Generated at the end of a conditional at the top of the loop.\n     This is used to perform a lame form of loop rotation in lieu\n     of actually understanding the loop structure.  The note is\n     discarded after rotation is complete.  */\n  NOTE_INSN_LOOP_END_TOP_COND,\n\n  /* This kind of note is generated at the end of the function body,\n     just before the return insn or return label.  In an optimizing\n     compilation it is deleted by the first jump optimization, after\n     enabling that optimizer to determine whether control can fall\n     off the end of the function body without a return statement.  */\n  NOTE_INSN_FUNCTION_END,\n\n  /* This marks the point immediately after the last prologue insn.  */\n  NOTE_INSN_PROLOGUE_END,\n\n  /* This marks the point immediately prior to the first epilogue insn.  */\n  NOTE_INSN_EPILOGUE_BEG,\n\n  /* Generated in place of user-declared labels when they are deleted.  */\n  NOTE_INSN_DELETED_LABEL,\n\n  /* This note indicates the start of the real body of the function,\n     i.e. the point just after all of the parms have been moved into\n     their homes, etc.  */\n  NOTE_INSN_FUNCTION_BEG,\n\n  /* These note where exception handling regions begin and end.\n     Uses NOTE_EH_HANDLER to identify the region in question.  */\n  NOTE_INSN_EH_REGION_BEG,\n  NOTE_INSN_EH_REGION_END,\n\n  /* Generated whenever a duplicate line number note is output.  For example,\n     one is output after the end of an inline function, in order to prevent\n     the line containing the inline call from being counted twice in gcov.  */\n  NOTE_INSN_REPEATED_LINE_NUMBER,\n\n  /* Record the struct for the following basic block.  Uses NOTE_BASIC_BLOCK.  */\n  NOTE_INSN_BASIC_BLOCK,\n\n  /* Record the expected value of a register at a location.  Uses\n     NOTE_EXPECTED_VALUE; stored as (eq (reg) (const_int)).  */\n  NOTE_INSN_EXPECTED_VALUE,\n\n  /* Record a prediction.  Uses NOTE_PREDICTION.  */\n  NOTE_INSN_PREDICTION,\n\n  NOTE_INSN_MAX\n};\n\n/* Names for NOTE insn's other than line numbers.  */\n\nextern const char * const note_insn_name\u00ddNOTE_INSN_MAX - NOTE_INSN_BIAS\u00a8;\n#define GET_NOTE_INSN_NAME(NOTE_CODE) \\\n  (note_insn_name\u00dd(NOTE_CODE) - (int) NOTE_INSN_BIAS\u00a8)\n\n/* The name of a label, in case it corresponds to an explicit label\n   in the input source code.  */\n#define LABEL_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)\n\n/* In jump.c, each label contains a count of the number\n   of LABEL_REFs that point at it, so unused labels can be deleted.  */\n#define LABEL_NUSES(RTX) XCINT (RTX, 4, CODE_LABEL)\n\n/* Labels carry a two-bit field composed of the ->jump and ->call\n   bits.  This field indicates whether the label is an alternate\n   entry point, and if so, what kind.  */\nenum label_kind\n{\n  LABEL_NORMAL = 0,\t/* ordinary label */\n  LABEL_STATIC_ENTRY,\t/* alternate entry point, not exported */\n  LABEL_GLOBAL_ENTRY,\t/* alternate entry point, exported */\n  LABEL_WEAK_ENTRY\t/* alternate entry point, exported as weak symbol */\n};\n\n#if defined ENABLE_RTL_FLAG_CHECKING && (GCC_VERSION > 2007)\n\n/* Retrieve the kind of LABEL.  */\n#define LABEL_KIND(LABEL) __extension__\t\t\t\t\t\\\n({ rtx const _label = (LABEL);\t\t\t\t\t\t\\\n   if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n     rtl_check_failed_flag (\"LABEL_KIND\", _label, __FILE__, __LINE__,\t\\\n\t\t\t    __FUNCTION__);\t\t\t\t\\\n   (enum label_kind) ((_label->jump << 1) | _label->call); })\n\n/* Set the kind of LABEL.  */\n#define SET_LABEL_KIND(LABEL, KIND) do {\t\t\t\t\\\n   rtx _label = (LABEL);\t\t\t\t\t\t\\\n   unsigned int _kind = (KIND);\t\t\t\t\t\t\\\n   if (GET_CODE (_label) != CODE_LABEL)\t\t\t\t\t\\\n     rtl_check_failed_flag (\"SET_LABEL_KIND\", _label, __FILE__, __LINE__, \\\n\t\t\t    __FUNCTION__);\t\t\t\t\\\n   _label->jump = ((_kind >> 1) & 1);\t\t\t\t\t\\\n   _label->call = (_kind & 1);\t\t\t\t\t\t\\\n} while (0)\n\n#else\n\n/* Retrieve the kind of LABEL.  */\n#define LABEL_KIND(LABEL) \\\n   ((enum label_kind) (((LABEL)->jump << 1) | (LABEL)->call))\n\n/* Set the kind of LABEL.  */\n#define SET_LABEL_KIND(LABEL, KIND) do {\t\t\t\t\\\n   rtx _label = (LABEL);\t\t\t\t\t\t\\\n   unsigned int _kind = (KIND);\t\t\t\t\t\t\\\n   _label->jump = ((_kind >> 1) & 1);\t\t\t\t\t\\\n   _label->call = (_kind & 1);\t\t\t\t\t\t\\\n} while (0)\n\n#endif /* rtl flag checking */\n\n#define LABEL_ALT_ENTRY_P(LABEL) (LABEL_KIND (LABEL) != LABEL_NORMAL)\n\n/* The original regno this ADDRESSOF was built for.  */\n#define ADDRESSOF_REGNO(RTX) XCUINT (RTX, 1, ADDRESSOF)\n\n/* The variable in the register we took the address of.  */\n#define ADDRESSOF_DECL(RTX) XCTREE (RTX, 2, ADDRESSOF)\n\n/* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n   so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n   be decremented and possibly the label can be deleted.  */\n#define JUMP_LABEL(INSN)   XCEXP (INSN, 9, JUMP_INSN)\n\n/* Once basic blocks are found in flow.c,\n   each CODE_LABEL starts a chain that goes through\n   all the LABEL_REFs that jump to that label.\n   The chain eventually winds up at the CODE_LABEL: it is circular.  */\n#define LABEL_REFS(LABEL) XCEXP (LABEL, 5, CODE_LABEL)\n\n/* This is the field in the LABEL_REF through which the circular chain\n   of references to a particular label is linked.\n   This chain is set up in flow.c.  */\n\n#define LABEL_NEXTREF(REF) XCEXP (REF, 1, LABEL_REF)\n\n/* Once basic blocks are found in flow.c,\n   Each LABEL_REF points to its containing instruction with this field.  */\n\n#define CONTAINING_INSN(RTX) XCEXP (RTX, 2, LABEL_REF)\n\n/* For a REG rtx, REGNO extracts the register number.  ORIGINAL_REGNO holds\n   the number the register originally had; for a pseudo register turned into\n   a hard reg this will hold the old pseudo register number.  */\n\n#define REGNO(RTX) XCUINT (RTX, 0, REG)\n#define ORIGINAL_REGNO(RTX) X0UINT (RTX, 1)\n\n/* 1 if RTX is a reg or parallel that is the current function's return\n   value.  */\n#define REG_FUNCTION_VALUE_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK2(\"REG_FUNCTION_VALUE_P\", (RTX), REG, PARALLEL)->integrated)\n\n/* 1 if RTX is a reg that corresponds to a variable declared by the user.  */\n#define REG_USERVAR_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"REG_USERVAR_P\", (RTX), REG)->volatil)\n\n/* 1 if RTX is a reg that holds a pointer value.  */\n#define REG_POINTER(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"REG_POINTER\", (RTX), REG)->frame_related)\n\n/* 1 if the given register REG corresponds to a hard register.  */\n#define HARD_REGISTER_P(REG) (HARD_REGISTER_NUM_P (REGNO (REG)))\n\n/* 1 if the given register number REG_NO corresponds to a hard register.  */\n#define HARD_REGISTER_NUM_P(REG_NO) ((REG_NO) < FIRST_PSEUDO_REGISTER)\n\n/* For a CONST_INT rtx, INTVAL extracts the integer.  */\n\n#define INTVAL(RTX) XCWINT(RTX, 0, CONST_INT)\n\n/* For a CONST_DOUBLE:\n   For a DImode, there are two integers CONST_DOUBLE_LOW is the\n     low-order word and ..._HIGH the high-order.\n   For a float, there is a REAL_VALUE_TYPE structure, and\n     CONST_DOUBLE_REAL_VALUE(r) is a pointer to it.  */\n#define CONST_DOUBLE_LOW(r) XCWINT (r, 0, CONST_DOUBLE)\n#define CONST_DOUBLE_HIGH(r) XCWINT (r, 1, CONST_DOUBLE)\n#define CONST_DOUBLE_REAL_VALUE(r) ((struct real_value *)&CONST_DOUBLE_LOW(r))\n\n/* For a CONST_VECTOR, return element #n.  */\n#define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n\n/* For a CONST_VECTOR, return the number of elements in a vector.  */\n#define CONST_VECTOR_NUNITS(RTX) XCVECLEN (RTX, 0, CONST_VECTOR)\n\n/* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n   SUBREG_BYTE extracts the byte-number.  */\n\n#define SUBREG_REG(RTX) XCEXP (RTX, 0, SUBREG)\n#define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n\n/* in rtlanal.c */\nextern unsigned int subreg_lsb (rtx);\nextern unsigned int subreg_regno_offset\t(unsigned int, enum machine_mode,\n\t\t\t\t\t unsigned int, enum machine_mode);\nextern bool subreg_offset_representable_p (unsigned int, enum machine_mode,\n\t\t\t\t\t   unsigned int, enum machine_mode);\nextern unsigned int subreg_regno (rtx);\n\n/* 1 if RTX is a subreg containing a reg that is already known to be\n   sign- or zero-extended from the mode of the subreg to the mode of\n   the reg.  SUBREG_PROMOTED_UNSIGNED_P gives the signedness of the\n   extension.\n\n   When used as a LHS, is means that this extension must be done\n   when assigning to SUBREG_REG.  */\n\n#define SUBREG_PROMOTED_VAR_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SUBREG_PROMOTED\", (RTX), SUBREG)->in_struct)\n\n#define SUBREG_PROMOTED_UNSIGNED_SET(RTX, VAL)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  rtx const _rtx = RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_SET\", (RTX), SUBREG); \\\n  if ((VAL) < 0)\t\t\t\t\t\t\t\\\n    _rtx->volatil = 1;\t\t\t\t\t\t\t\\\n  else {\t\t\t\t\t\t\t\t\\\n    _rtx->volatil = 0;\t\t\t\t\t\t\t\\\n    _rtx->unchanging = (VAL);\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n#define SUBREG_PROMOTED_UNSIGNED_P(RTX)\t\\\n  ((RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n     ? -1 : (RTX)->unchanging)\n\n/* Access various components of an ASM_OPERANDS rtx.  */\n\n#define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)\n#define ASM_OPERANDS_OUTPUT_CONSTRAINT(RTX) XCSTR (RTX, 1, ASM_OPERANDS)\n#define ASM_OPERANDS_OUTPUT_IDX(RTX) XCINT (RTX, 2, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_VEC(RTX) XCVEC (RTX, 3, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT_VEC(RTX) XCVEC (RTX, 4, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT(RTX, N) XCVECEXP (RTX, 3, N, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_LENGTH(RTX) XCVECLEN (RTX, 3, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT_EXP(RTX, N) \\\n  XCVECEXP (RTX, 4, N, ASM_OPERANDS)\n#define ASM_OPERANDS_INPUT_CONSTRAINT(RTX, N) \\\n  XSTR (XCVECEXP (RTX, 4, N, ASM_OPERANDS), 0)\n#define ASM_OPERANDS_INPUT_MODE(RTX, N)  \\\n  GET_MODE (XCVECEXP (RTX, 4, N, ASM_OPERANDS))\n#define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR (RTX, 5, ASM_OPERANDS)\n#define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT (RTX, 6, ASM_OPERANDS)\n\n/* 1 if RTX is a mem and we should keep the alias set for this mem\n   unchanged when we access a component.  Set to 1, or example, when we\n   are already in a non-addressable component of an aggregate.  */\n#define MEM_KEEP_ALIAS_SET_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"MEM_KEEP_ALIAS_SET_P\", (RTX), MEM)->jump)\n\n/* 1 if RTX is a mem or asm_operand for a volatile reference.  */\n#define MEM_VOLATILE_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"MEM_VOLATILE_P\", (RTX), MEM, ASM_OPERANDS,\t\t\\\n\t\t   ASM_INPUT)->volatil)\n\n/* 1 if RTX is a mem that refers to an aggregate, either to the\n   aggregate itself of to a field of the aggregate.  If zero, RTX may\n   or may not be such a reference.  */\n#define MEM_IN_STRUCT_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"MEM_IN_STRUCT_P\", (RTX), MEM)->in_struct)\n\n/* 1 if RTX is a mem that refers to a scalar.  If zero, RTX may or may\n   not refer to a scalar.  */\n#define MEM_SCALAR_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"MEM_SCALAR_P\", (RTX), MEM)->frame_related)\n\n/* 1 if RTX is a mem that cannot trap.  */\n#define MEM_NOTRAP_P(RTX) \\\n  (RTL_FLAG_CHECK1(\"MEM_NOTRAP_P\", (RTX), MEM)->call)\n\n/* If VAL is nonzero, set MEM_IN_STRUCT_P and clear MEM_SCALAR_P in\n   RTX.  Otherwise, vice versa.  Use this macro only when you are\n   *sure* that you know that the MEM is in a structure, or is a\n   scalar.  VAL is evaluated only once.  */\n#define MEM_SET_IN_STRUCT_P(RTX, VAL)\t\t\\\ndo {\t\t\t\t\t\t\\\n  if (VAL)\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      MEM_IN_STRUCT_P (RTX) = 1;\t\t\\\n      MEM_SCALAR_P (RTX) = 0;\t\t\t\\\n    }\t\t\t\t\t\t\\\n  else\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      MEM_IN_STRUCT_P (RTX) = 0;\t\t\\\n      MEM_SCALAR_P (RTX) = 1;\t\t\t\\\n    }\t\t\t\t\t\t\\\n} while (0)\n\n/* The memory attribute block.  We provide access macros for each value\n   in the block and provide defaults if none specified.  */\n#define MEM_ATTRS(RTX) X0MEMATTR (RTX, 1)\n\n/* The register attribute block.  We provide access macros for each value\n   in the block and provide defaults if none specified.  */\n#define REG_ATTRS(RTX) X0REGATTR (RTX, 2)\n\n/* For a MEM rtx, the alias set.  If 0, this MEM is not in any alias\n   set, and may alias anything.  Otherwise, the MEM can only alias\n   MEMs in a conflicting alias set.  This value is set in a\n   language-dependent manner in the front-end, and should not be\n   altered in the back-end.  These set numbers are tested with\n   alias_sets_conflict_p.  */\n#define MEM_ALIAS_SET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->alias)\n\n/* For a MEM rtx, the decl it is known to refer to, if it is known to\n   refer to part of a DECL.  It may also be a COMPONENT_REF.  */\n#define MEM_EXPR(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->expr)\n\n/* For a MEM rtx, the offset from the start of MEM_EXPR, if known, as a\n   RTX that is always a CONST_INT.  */\n#define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)\n\n/* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that\n   is always a CONST_INT.  */\n#define MEM_SIZE(RTX)\t\t\t\t\t\t\t\\\n(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->size\t\t\t\t\\\n : GET_MODE (RTX) != BLKmode ? GEN_INT (GET_MODE_SIZE (GET_MODE (RTX)))\t\\\n : 0)\n\n/* For a MEM rtx, the alignment in bits.  We can use the alignment of the\n   mode as a default when STRICT_ALIGNMENT, but not if not.  */\n#define MEM_ALIGN(RTX)\t\t\t\t\t\t\t\\\n(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->align\t\t\t\t\\\n : (STRICT_ALIGNMENT && GET_MODE (RTX) != BLKmode\t\t\t\\\n    ? GET_MODE_ALIGNMENT (GET_MODE (RTX)) : BITS_PER_UNIT))\n\n/* For a REG rtx, the decl it is known to refer to, if it is known to\n   refer to part of a DECL.  */\n#define REG_EXPR(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->decl)\n\n/* For a MEM rtx, the offset from the start of MEM_DECL, if known, as a\n   RTX that is always a CONST_INT.  */\n#define REG_OFFSET(RTX) (REG_ATTRS (RTX) == 0 ? 0 : REG_ATTRS (RTX)->offset)\n\n/* Copy the attributes that apply to memory locations from RHS to LHS.  */\n#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\t\\\n  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\t\\\n   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\t\\\n   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\t\\\n   MEM_NOTRAP_P (LHS) = MEM_NOTRAP_P (RHS),\t\t\t\\\n   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\t\\\n   MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\\n   MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n\n/* 1 if RTX is a label_ref to a label outside the loop containing the\n   reference.  */\n#define LABEL_OUTSIDE_LOOP_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"LABEL_OUTSIDE_LOOP_P\", (RTX), LABEL_REF)->in_struct)\n\n/* 1 if RTX is a label_ref for a nonlocal label.  */\n/* Likewise in an expr_list for a reg_label note.  */\n#define LABEL_REF_NONLOCAL_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK2(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF,\t\t\\\n\t\t   REG_LABEL)->volatil)\n\n/* 1 if RTX is a code_label that should always be considered to be needed.  */\n#define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK2(\"LABEL_PRESERVE_P\", (RTX), CODE_LABEL, NOTE)->in_struct)\n\n/* 1 if RTX is a reg that is used only in an exit test of a loop.  */\n#define REG_LOOP_TEST_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"REG_LOOP_TEST_P\", (RTX), REG)->in_struct)\n\n/* During sched, 1 if RTX is an insn that must be scheduled together\n   with the preceding insn.  */\n#define SCHED_GROUP_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK3(\"SCHED_GROUP_P\", (RTX), INSN, JUMP_INSN, CALL_INSN\t\\\n\t\t          )->in_struct)\n\n/* For a SET rtx, SET_DEST is the place that is set\n   and SET_SRC is the value it is set to.  */\n#define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n#define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n#define SET_IS_RETURN_P(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SET_IS_RETURN_P\", (RTX), SET)->jump)\n\n/* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n#define TRAP_CONDITION(RTX) XCEXP (RTX, 0, TRAP_IF)\n#define TRAP_CODE(RTX) XCEXP (RTX, 1, TRAP_IF)\n\n/* For a COND_EXEC rtx, COND_EXEC_TEST is the condition to base\n   conditionally executing the code on, COND_EXEC_CODE is the code\n   to execute if the condition is true.  */\n#define COND_EXEC_TEST(RTX) XCEXP (RTX, 0, COND_EXEC)\n#define COND_EXEC_CODE(RTX) XCEXP (RTX, 1, COND_EXEC)\n\n/* 1 if RTX is a symbol_ref that addresses this function's rtl\n   constants pool.  */\n#define CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"CONSTANT_POOL_ADDRESS_P\", (RTX), SYMBOL_REF)->unchanging)\n\n/* 1 if RTX is a symbol_ref that addresses a value in the file's\n   tree constant pool.  This information is private to varasm.c.  */\n#define TREE_CONSTANT_POOL_ADDRESS_P(RTX)\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"TREE_CONSTANT_POOL_ADDRESS_P\",\t\t\t\\\n\t\t   (RTX), SYMBOL_REF)->frame_related)\n\n/* Used if RTX is a symbol_ref, for machine-specific purposes.  */\n#define SYMBOL_REF_FLAG(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SYMBOL_REF_FLAG\", (RTX), SYMBOL_REF)->volatil)\n\n/* 1 if RTX is a symbol_ref that has been the library function in\n   emit_library_call.  */\n#define SYMBOL_REF_USED(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SYMBOL_REF_USED\", (RTX), SYMBOL_REF)->used)\n\n/* 1 if RTX is a symbol_ref for a weak symbol.  */\n#define SYMBOL_REF_WEAK(RTX)\t\t\t\t\t\t\\\n  (RTL_FLAG_CHECK1(\"SYMBOL_REF_WEAK\", (RTX), SYMBOL_REF)->integrated)\n\n/* The tree (decl or constant) associated with the symbol, or null.  */\n#define SYMBOL_REF_DECL(RTX)\tX0TREE ((RTX), 2)\n\n/* A set of flags on a symbol_ref that are, in some respects, redundant with\n   information derivable from the tree decl associated with this symbol.\n   Except that we build a *lot* of SYMBOL_REFs that aren't associated with a\n   decl.  In some cases this is a bug.  But beyond that, it's nice to cache\n   this information to avoid recomputing it.  Finally, this allows space for\n   the target to store more than one bit of information, as with\n   SYMBOL_REF_FLAG.  */\n#define SYMBOL_REF_FLAGS(RTX)\tX0INT ((RTX), 1)\n\n/* These flags are common enough to be defined for all targets.  They\n   are computed by the default version of targetm.encode_section_info.  */\n\n/* Set if this symbol is a function.  */\n#define SYMBOL_FLAG_FUNCTION\t(1 << 0)\n#define SYMBOL_REF_FUNCTION_P(RTX) \\\n  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_FUNCTION) != 0)\n/* Set if targetm.binds_local_p is true.  */\n#define SYMBOL_FLAG_LOCAL\t(1 << 1)\n#define SYMBOL_REF_LOCAL_P(RTX) \\\n  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_LOCAL) != 0)\n/* Set if targetm.in_small_data_p is true.  */\n#define SYMBOL_FLAG_SMALL\t(1 << 2)\n#define SYMBOL_REF_SMALL_P(RTX) \\\n  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_SMALL) != 0)\n/* The three-bit field at \u00dd5:3\u00a8 is true for TLS variables; use\n   SYMBOL_REF_TLS_MODEL to extract the field as an enum tls_model.  */\n#define SYMBOL_FLAG_TLS_SHIFT\t3\n#define SYMBOL_REF_TLS_MODEL(RTX) \\\n  ((enum tls_model) ((SYMBOL_REF_FLAGS (RTX) >> SYMBOL_FLAG_TLS_SHIFT) & 7))\n/* Set if this symbol is not defined in this translation unit.  */\n#define SYMBOL_FLAG_EXTERNAL\t(1 << 6)\n#define SYMBOL_REF_EXTERNAL_P(RTX) \\\n  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)\n\n/* Subsequent bits are available for the target to use.  */\n#define SYMBOL_FLAG_MACH_DEP_SHIFT\t7\n#define SYMBOL_FLAG_MACH_DEP\t\t(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)\n\n/* Define a macro to look for REG_INC notes,\n   but save time on machines where they never exist.  */\n\n#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n#define FIND_REG_INC_NOTE(INSN, REG)\t\t\t\\\n  ((REG) != NULL_RTX && REG_P ((REG))\t\t\t\\\n   ? find_regno_note ((INSN), REG_INC, REGNO (REG))\t\\\n   : find_reg_note ((INSN), REG_INC, (REG)))\n#else\n#define FIND_REG_INC_NOTE(INSN, REG) 0\n#endif\n\n/* Indicate whether the machine has any sort of auto increment addressing.\n   If not, we can avoid checking for REG_INC notes.  */\n\n#if (defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) || defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT))\n#define AUTO_INC_DEC\n#endif\n\n#ifndef HAVE_PRE_INCREMENT\n#define HAVE_PRE_INCREMENT 0\n#endif\n\n#ifndef HAVE_PRE_DECREMENT\n#define HAVE_PRE_DECREMENT 0\n#endif\n\n#ifndef HAVE_POST_INCREMENT\n#define HAVE_POST_INCREMENT 0\n#endif\n\n#ifndef HAVE_POST_DECREMENT\n#define HAVE_POST_DECREMENT 0\n#endif\n\n#ifndef HAVE_POST_MODIFY_DISP\n#define HAVE_POST_MODIFY_DISP 0\n#endif\n\n#ifndef HAVE_POST_MODIFY_REG\n#define HAVE_POST_MODIFY_REG 0\n#endif\n\n#ifndef HAVE_PRE_MODIFY_DISP\n#define HAVE_PRE_MODIFY_DISP 0\n#endif\n\n#ifndef HAVE_PRE_MODIFY_REG\n#define HAVE_PRE_MODIFY_REG 0\n#endif\n\n\n/* Some architectures do not have complete pre/post increment/decrement\n   instruction sets, or only move some modes efficiently.  These macros\n   allow us to tune autoincrement generation.  */\n\n#ifndef USE_LOAD_POST_INCREMENT\n#define USE_LOAD_POST_INCREMENT(MODE)   HAVE_POST_INCREMENT\n#endif\n\n#ifndef USE_LOAD_POST_DECREMENT\n#define USE_LOAD_POST_DECREMENT(MODE)   HAVE_POST_DECREMENT\n#endif\n\n#ifndef USE_LOAD_PRE_INCREMENT\n#define USE_LOAD_PRE_INCREMENT(MODE)    HAVE_PRE_INCREMENT\n#endif\n\n#ifndef USE_LOAD_PRE_DECREMENT\n#define USE_LOAD_PRE_DECREMENT(MODE)    HAVE_PRE_DECREMENT\n#endif\n\n#ifndef USE_STORE_POST_INCREMENT\n#define USE_STORE_POST_INCREMENT(MODE)  HAVE_POST_INCREMENT\n#endif\n\n#ifndef USE_STORE_POST_DECREMENT\n#define USE_STORE_POST_DECREMENT(MODE)  HAVE_POST_DECREMENT\n#endif\n\n#ifndef USE_STORE_PRE_INCREMENT\n#define USE_STORE_PRE_INCREMENT(MODE)   HAVE_PRE_INCREMENT\n#endif\n\n#ifndef USE_STORE_PRE_DECREMENT\n#define USE_STORE_PRE_DECREMENT(MODE)   HAVE_PRE_DECREMENT\n#endif\n\n/* Determine if the insn is a PHI node.  */\n#define PHI_NODE_P(X)\t\t\t\t\\\n  ((X) && GET_CODE (X) == INSN\t\t\t\\\n   && GET_CODE (PATTERN (X)) == SET\t\t\\\n   && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n\n/* Nonzero if we need to distinguish between the return value of this function\n   and the return value of a function called by this function.  This helps\n   integrate.c.\n   This is 1 until after the rtl generation pass.  */\nextern int rtx_equal_function_value_matters;\n\n/* Nonzero when we are generating CONCATs.  */\nextern int generating_concat_p;\n\n/* Generally useful functions.  */\n\n/* In expmed.c */\nextern int ceil_log2 (unsigned HOST_WIDE_INT);\n\n#define plus_constant(X, C) plus_constant_wide ((X), (HOST_WIDE_INT) (C))\n\n/* In builtins.c */\nextern rtx expand_builtin_expect_jump (tree, rtx, rtx);\nextern void purge_builtin_constant_p (void);\n\n/* In explow.c */\nextern void set_stack_check_libfunc (rtx);\nextern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\nextern rtx plus_constant_wide (rtx, HOST_WIDE_INT);\nextern rtx plus_constant_for_output_wide (rtx, HOST_WIDE_INT);\nextern void optimize_save_area_alloca (rtx);\n\n/* In emit-rtl.c */\nextern rtx gen_rtx (enum rtx_code, enum machine_mode, ...);\nextern rtvec gen_rtvec (int, ...);\nextern rtx copy_insn_1 (rtx);\nextern rtx copy_insn (rtx);\nextern rtx gen_int_mode (HOST_WIDE_INT, enum machine_mode);\nextern rtx emit_copy_of_insn_after (rtx, rtx);\nextern void set_reg_attrs_from_mem (rtx, rtx);\nextern void set_mem_attrs_from_reg (rtx, rtx);\nextern void set_reg_attrs_for_parm (rtx, rtx);\nextern int mem_expr_equal_p (tree, tree);\n\n/* In rtl.c */\nextern rtx rtx_alloc (RTX_CODE);\nextern rtvec rtvec_alloc (int);\nextern rtx copy_rtx (rtx);\nextern void dump_rtx_statistics (void);\n\n/* In emit-rtl.c */\nextern rtx copy_rtx_if_shared (rtx);\n\n/* In rtl.c */\nextern rtx copy_most_rtx (rtx, rtx);\nextern rtx shallow_copy_rtx (rtx);\nextern int rtx_equal_p (rtx, rtx);\n\n/* In emit-rtl.c */\nextern rtvec gen_rtvec_v (int, rtx *);\nextern rtx gen_reg_rtx (enum machine_mode);\nextern rtx gen_rtx_REG_offset (rtx, enum machine_mode, unsigned int, int);\nextern rtx gen_label_rtx (void);\nextern int subreg_hard_regno (rtx, int);\nextern rtx gen_lowpart_common (enum machine_mode, rtx);\nextern rtx gen_lowpart (enum machine_mode, rtx);\n\n/* In cse.c */\nextern rtx gen_lowpart_if_possible (enum machine_mode, rtx);\n\n/* In emit-rtl.c */\nextern rtx gen_highpart (enum machine_mode, rtx);\nextern rtx gen_highpart_mode (enum machine_mode, enum machine_mode, rtx);\nextern rtx gen_realpart (enum machine_mode, rtx);\nextern rtx gen_imagpart (enum machine_mode, rtx);\nextern rtx operand_subword (rtx, unsigned int, int, enum machine_mode);\n\n/* In emit-rtl.c */\nextern rtx operand_subword_force (rtx, unsigned int, enum machine_mode);\nextern int subreg_lowpart_p (rtx);\nextern unsigned int subreg_lowpart_offset (enum machine_mode,\n\t\t\t\t\t   enum machine_mode);\nextern unsigned int subreg_highpart_offset (enum machine_mode,\n\t\t\t\t\t    enum machine_mode);\nextern rtx make_safe_from (rtx, rtx);\nextern rtx convert_memory_address (enum machine_mode, rtx);\nextern rtx get_insns (void);\nextern const char *get_insn_name (int);\nextern rtx get_last_insn (void);\nextern rtx get_last_insn_anywhere (void);\nextern rtx get_first_nonnote_insn (void);\nextern rtx get_last_nonnote_insn (void);\nextern void start_sequence (void);\nextern void push_to_sequence (rtx);\nextern void end_sequence (void);\nextern void push_to_full_sequence (rtx, rtx);\nextern void end_full_sequence (rtx*, rtx*);\nextern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t       enum machine_mode);\n\n/* In varasm.c  */\nextern rtx force_const_mem (enum machine_mode, rtx);\n\n/* In varasm.c  */\nextern rtx get_pool_constant (rtx);\nextern rtx get_pool_constant_mark (rtx, bool *);\nextern enum machine_mode get_pool_mode (rtx);\nextern rtx get_pool_constant_for_function (struct function *, rtx);\nextern enum machine_mode get_pool_mode_for_function (struct function *, rtx);\nextern int get_pool_offset (rtx);\nextern rtx simplify_subtraction (rtx);\n\n/* In function.c  */\nextern rtx assign_stack_local (enum machine_mode, HOST_WIDE_INT, int);\nextern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT, int);\nextern rtx assign_stack_temp_for_type (enum machine_mode,\n\t\t\t\t       HOST_WIDE_INT, int, tree);\nextern rtx assign_temp (tree, int, int, int);\n\n/* In emit-rtl.c */\nextern rtx emit_insn_before (rtx, rtx);\nextern rtx emit_insn_before_noloc (rtx, rtx);\nextern rtx emit_insn_before_setloc (rtx, rtx, int);\nextern rtx emit_jump_insn_before (rtx, rtx);\nextern rtx emit_jump_insn_before_noloc (rtx, rtx);\nextern rtx emit_jump_insn_before_setloc (rtx, rtx, int);\nextern rtx emit_call_insn_before (rtx, rtx);\nextern rtx emit_call_insn_before_noloc (rtx, rtx);\nextern rtx emit_call_insn_before_setloc (rtx, rtx, int);\nextern rtx emit_barrier_before (rtx);\nextern rtx emit_label_before (rtx, rtx);\nextern rtx emit_note_before (int, rtx);\nextern rtx emit_insn_after (rtx, rtx);\nextern rtx emit_insn_after_noloc (rtx, rtx);\nextern rtx emit_insn_after_setloc (rtx, rtx, int);\nextern rtx emit_jump_insn_after (rtx, rtx);\nextern rtx emit_jump_insn_after_noloc (rtx, rtx);\nextern rtx emit_jump_insn_after_setloc (rtx, rtx, int);\nextern rtx emit_call_insn_after (rtx, rtx);\nextern rtx emit_call_insn_after_noloc (rtx, rtx);\nextern rtx emit_call_insn_after_setloc (rtx, rtx, int);\nextern rtx emit_barrier_after (rtx);\nextern rtx emit_label_after (rtx, rtx);\nextern rtx emit_note_after (int, rtx);\nextern rtx emit_note_copy_after (rtx, rtx);\nextern rtx emit_insn (rtx);\nextern rtx emit_jump_insn (rtx);\nextern rtx emit_call_insn (rtx);\nextern rtx emit_label (rtx);\nextern rtx emit_barrier (void);\nextern rtx emit_note (int);\nextern rtx emit_note_copy (rtx);\nextern rtx emit_line_note (location_t);\nextern rtx make_insn_raw (rtx);\nextern void add_function_usage_to (rtx, rtx);\nextern rtx last_call_insn (void);\nextern rtx previous_insn (rtx);\nextern rtx next_insn (rtx);\nextern rtx prev_nonnote_insn (rtx);\nextern rtx next_nonnote_insn (rtx);\nextern rtx prev_real_insn (rtx);\nextern rtx next_real_insn (rtx);\nextern rtx prev_active_insn (rtx);\nextern rtx next_active_insn (rtx);\nextern int active_insn_p (rtx);\nextern rtx prev_label (rtx);\nextern rtx next_label (rtx);\nextern rtx next_cc0_user (rtx);\nextern rtx prev_cc0_setter (rtx);\n\n/* In cfglayout.c  */\nextern tree choose_inner_scope (tree, tree);\nextern int insn_line (rtx);\nextern const char * insn_file (rtx);\nextern int locator_line (int);\nextern const char * locator_file (int);\nextern int prologue_locator, epilogue_locator;\n\n/* In jump.c */\nextern enum rtx_code reverse_condition (enum rtx_code);\nextern enum rtx_code reverse_condition_maybe_unordered (enum rtx_code);\nextern enum rtx_code swap_condition (enum rtx_code);\nextern enum rtx_code unsigned_condition (enum rtx_code);\nextern enum rtx_code signed_condition (enum rtx_code);\nextern void mark_jump_label (rtx, rtx, int);\nextern void cleanup_barriers (void);\n\n/* In jump.c */\nextern bool squeeze_notes (rtx *, rtx *);\nextern rtx delete_related_insns (rtx);\nextern void delete_jump (rtx);\nextern void delete_barrier (rtx);\nextern rtx get_label_before (rtx);\nextern rtx get_label_after (rtx);\nextern rtx follow_jumps (rtx);\n\n/* In recog.c  */\nextern rtx *find_constant_term_loc (rtx *);\n\n/* In emit-rtl.c  */\nextern rtx try_split (rtx, rtx, int);\nextern int split_branch_probability;\n\n/* In unknown file  */\nextern rtx split_insns (rtx, rtx);\n\n/* In simplify-rtx.c  */\nextern rtx simplify_unary_operation (enum rtx_code, enum machine_mode, rtx,\n\t\t\t\t     enum machine_mode);\nextern rtx simplify_binary_operation (enum rtx_code, enum machine_mode, rtx,\n\t\t\t\t      rtx);\nextern rtx simplify_ternary_operation (enum rtx_code, enum machine_mode,\n\t\t\t\t       enum machine_mode, rtx, rtx, rtx);\nextern rtx simplify_relational_operation (enum rtx_code, enum machine_mode,\n\t\t\t\t\t  rtx, rtx);\nextern rtx simplify_gen_binary (enum rtx_code, enum machine_mode, rtx, rtx);\nextern rtx simplify_gen_unary (enum rtx_code, enum machine_mode, rtx,\n\t\t\t       enum machine_mode);\nextern rtx simplify_gen_ternary (enum rtx_code, enum machine_mode,\n\t\t\t\t enum machine_mode, rtx, rtx, rtx);\nextern rtx simplify_gen_relational (enum rtx_code, enum machine_mode,\n\t\t\t\t    enum machine_mode, rtx, rtx);\nextern rtx simplify_subreg (enum machine_mode, rtx, enum machine_mode,\n\t\t\t    unsigned int);\nextern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n\t\t\t\tunsigned int);\nextern rtx simplify_replace_rtx (rtx, rtx, rtx);\nextern rtx simplify_rtx (rtx);\nextern rtx avoid_constant_pool_reference (rtx);\nextern bool constant_pool_reference_p (rtx);\n\n/* In function.c  */\nextern rtx gen_mem_addressof (rtx, tree, int);\n\n/* In regclass.c  */\nextern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,\n\t\t\t\t\t       bool);\n\n/* In emit-rtl.c  */\nextern rtx set_unique_reg_note (rtx, enum reg_note, rtx);\n\n/* Functions in rtlanal.c */\n\n/* Single set is implemented as macro for performance reasons.  */\n#define single_set(I) (INSN_P (I) \\\n\t\t       ? (GET_CODE (PATTERN (I)) == SET \\\n\t\t\t  ? PATTERN (I) : single_set_1 (I)) \\\n\t\t       : NULL_RTX)\n#define single_set_1(I) single_set_2 (I, PATTERN (I))\n\n/* Structure used for passing data to REPLACE_LABEL.  */\ntypedef struct replace_label_data\n{\n  rtx r1;\n  rtx r2;\n  bool update_label_nuses;\n} replace_label_data;\n\nextern int rtx_addr_can_trap_p (rtx);\nextern bool nonzero_address_p (rtx);\nextern int rtx_unstable_p (rtx);\nextern int rtx_varies_p (rtx, int);\nextern int rtx_addr_varies_p (rtx, int);\nextern HOST_WIDE_INT get_integer_term (rtx);\nextern rtx get_related_value (rtx);\nextern rtx get_jump_table_offset (rtx, rtx *);\nextern int global_reg_mentioned_p (rtx);\nextern int reg_mentioned_p (rtx, rtx);\nextern int count_occurrences (rtx, rtx, int);\nextern int reg_referenced_p (rtx, rtx);\nextern int reg_used_between_p (rtx, rtx, rtx);\nextern int reg_referenced_between_p (rtx, rtx, rtx);\nextern int reg_set_between_p (rtx, rtx, rtx);\nextern int regs_set_between_p (rtx, rtx, rtx);\nextern int commutative_operand_precedence (rtx);\nextern int swap_commutative_operands_p (rtx, rtx);\nextern int modified_between_p (rtx, rtx, rtx);\nextern int no_labels_between_p (rtx, rtx);\nextern int no_jumps_between_p (rtx, rtx);\nextern int modified_in_p (rtx, rtx);\nextern int insn_dependent_p (rtx, rtx);\nextern int reg_set_p (rtx, rtx);\nextern rtx single_set_2 (rtx, rtx);\nextern int multiple_sets (rtx);\nextern int set_noop_p (rtx);\nextern int noop_move_p (rtx);\nextern rtx find_last_value (rtx, rtx *, rtx, int);\nextern int refers_to_regno_p (unsigned int, unsigned int, rtx, rtx *);\nextern int reg_overlap_mentioned_p (rtx, rtx);\nextern rtx set_of (rtx, rtx);\nextern void note_stores (rtx, void (*) (rtx, rtx, void *), void *);\nextern void note_uses (rtx *, void (*) (rtx *, void *), void *);\nextern rtx reg_set_last (rtx, rtx);\nextern int dead_or_set_p (rtx, rtx);\nextern int dead_or_set_regno_p (rtx, unsigned int);\nextern rtx find_reg_note (rtx, enum reg_note, rtx);\nextern rtx find_regno_note (rtx, enum reg_note, unsigned int);\nextern rtx find_reg_equal_equiv_note (rtx);\nextern int find_reg_fusage (rtx, enum rtx_code, rtx);\nextern int find_regno_fusage (rtx, enum rtx_code, unsigned int);\nextern int pure_call_p (rtx);\nextern void remove_note (rtx, rtx);\nextern int side_effects_p (rtx);\nextern int volatile_refs_p (rtx);\nextern int volatile_insn_p (rtx);\nextern int may_trap_p (rtx);\nextern int inequality_comparisons_p (rtx);\nextern rtx replace_rtx (rtx, rtx, rtx);\nextern rtx replace_regs (rtx, rtx *, unsigned int, int);\nextern int replace_label (rtx *, void *);\nextern int rtx_referenced_p (rtx, rtx);\nextern bool tablejump_p (rtx, rtx *, rtx *);\nextern int computed_jump_p (rtx);\ntypedef int (*rtx_function) (rtx *, void *);\nextern int for_each_rtx (rtx *, rtx_function, void *);\nextern rtx regno_use_in (unsigned int, rtx);\nextern int auto_inc_p (rtx);\nextern int in_expr_list_p (rtx, rtx);\nextern void remove_node_from_expr_list (rtx, rtx *);\nextern int insns_safe_to_move_p (rtx, rtx, rtx *);\nextern int loc_mentioned_in_p (rtx *, rtx);\nextern rtx find_first_parameter_load (rtx, rtx);\nextern bool keep_with_call_p (rtx);\nextern bool label_is_jump_target_p (rtx, rtx);\n\n/* flow.c */\n\nextern rtx find_use_as_address (rtx, rtx, HOST_WIDE_INT);\n\n/* lists.c */\n\nvoid free_EXPR_LIST_list\t\t(rtx *);\nvoid free_INSN_LIST_list\t\t(rtx *);\nvoid free_EXPR_LIST_node\t\t(rtx);\nvoid free_INSN_LIST_node\t\t(rtx);\nrtx alloc_INSN_LIST\t\t\t(rtx, rtx);\nrtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n\n/* regclass.c */\n\n/* Maximum number of parallel sets and clobbers in any insn in this fn.\n   Always at least 3, since the combiner could put that many together\n   and we want this to remain correct for all the remaining passes.  */\n\nextern int max_parallel;\n\n/* Free up register info memory.  */\nextern void free_reg_info (void);\n\n/* recog.c */\nextern int asm_noperands (rtx);\nextern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n\t\t\t\t\tenum machine_mode *);\n\nextern enum reg_class reg_preferred_class (int);\nextern enum reg_class reg_alternate_class (int);\n\nextern rtx get_first_nonparm_insn (void);\n\nextern void split_all_insns (int);\nextern void split_all_insns_noflow (void);\n\n#define MAX_SAVED_CONST_INT 64\nextern GTY(()) rtx const_int_rtx\u00ddMAX_SAVED_CONST_INT * 2 + 1\u00a8;\n\n#define const0_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT\u00a8)\n#define const1_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT+1\u00a8)\n#define const2_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT+2\u00a8)\n#define constm1_rtx\t(const_int_rtx\u00ddMAX_SAVED_CONST_INT-1\u00a8)\nextern GTY(()) rtx const_true_rtx;\n\nextern GTY(()) rtx const_tiny_rtx\u00dd3\u00a8\u00dd(int) MAX_MACHINE_MODE\u00a8;\n\n/* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the\n   same as VOIDmode.  */\n\n#define CONST0_RTX(MODE) (const_tiny_rtx\u00dd0\u00a8\u00dd(int) (MODE)\u00a8)\n\n/* Likewise, for the constants 1 and 2.  */\n\n#define CONST1_RTX(MODE) (const_tiny_rtx\u00dd1\u00a8\u00dd(int) (MODE)\u00a8)\n#define CONST2_RTX(MODE) (const_tiny_rtx\u00dd2\u00a8\u00dd(int) (MODE)\u00a8)\n\n/* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n   is used to represent the frame pointer.  This is because the\n   hard frame pointer and the automatic variables are separated by an amount\n   that cannot be determined until after register allocation.  We can assume\n   that in this case ELIMINABLE_REGS will be defined, one action of which\n   will be to eliminate FRAME_POINTER_REGNUM into HARD_FRAME_POINTER_REGNUM.  */\n#ifndef HARD_FRAME_POINTER_REGNUM\n#define HARD_FRAME_POINTER_REGNUM FRAME_POINTER_REGNUM\n#endif\n\n/* Index labels for global_rtl.  */\nenum global_rtl_index\n{\n  GR_PC,\n  GR_CC0,\n  GR_STACK_POINTER,\n  GR_FRAME_POINTER,\n/* For register elimination to work properly these hard_frame_pointer_rtx,\n   frame_pointer_rtx, and arg_pointer_rtx must be the same if they refer to\n   the same register.  */\n#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n  GR_ARG_POINTER = GR_FRAME_POINTER,\n#endif\n#if HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n  GR_HARD_FRAME_POINTER = GR_FRAME_POINTER,\n#else\n  GR_HARD_FRAME_POINTER,\n#endif\n#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n#if HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n  GR_ARG_POINTER = GR_HARD_FRAME_POINTER,\n#else\n  GR_ARG_POINTER,\n#endif\n#endif\n  GR_VIRTUAL_INCOMING_ARGS,\n  GR_VIRTUAL_STACK_ARGS,\n  GR_VIRTUAL_STACK_DYNAMIC,\n  GR_VIRTUAL_OUTGOING_ARGS,\n  GR_VIRTUAL_CFA,\n\n  GR_MAX\n};\n\n/* Pointers to standard pieces of rtx are stored here.  */\nextern GTY(()) rtx global_rtl\u00ddGR_MAX\u00a8;\n\n/* Standard pieces of rtx, to be substituted directly into things.  */\n#define pc_rtx                  (global_rtl\u00ddGR_PC\u00a8)\n#define cc0_rtx                 (global_rtl\u00ddGR_CC0\u00a8)\n\n/* All references to certain hard regs, except those created\n   by allocating pseudo regs into them (when that's possible),\n   go through these unique rtx objects.  */\n#define stack_pointer_rtx       (global_rtl\u00ddGR_STACK_POINTER\u00a8)\n#define frame_pointer_rtx       (global_rtl\u00ddGR_FRAME_POINTER\u00a8)\n#define hard_frame_pointer_rtx\t(global_rtl\u00ddGR_HARD_FRAME_POINTER\u00a8)\n#define arg_pointer_rtx\t\t(global_rtl\u00ddGR_ARG_POINTER\u00a8)\n\nextern GTY(()) rtx pic_offset_table_rtx;\nextern GTY(()) rtx static_chain_rtx;\nextern GTY(()) rtx static_chain_incoming_rtx;\nextern GTY(()) rtx return_address_pointer_rtx;\n\n/* Include the RTL generation functions.  */\n\n#ifndef NO_GENRTL_H\n#include \"genrtl.h\"\n#endif\n\n/* There are some RTL codes that require special attention; the\n   generation functions included above do the raw handling.  If you\n   add to this list, modify special_rtx in gengenrtl.c as well.  You\n   should also modify gen_rtx to use the special function.  */\n\nextern rtx gen_rtx_CONST_INT (enum machine_mode, HOST_WIDE_INT);\nextern rtx gen_rtx_CONST_VECTOR (enum machine_mode, rtvec);\nextern rtx gen_raw_REG (enum machine_mode, int);\nextern rtx gen_rtx_REG (enum machine_mode, unsigned);\nextern rtx gen_rtx_SUBREG (enum machine_mode, rtx, int);\nextern rtx gen_rtx_MEM (enum machine_mode, rtx);\n\nextern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);\n\n/* We need the cast here to ensure that we get the same result both with\n   and without prototypes.  */\n#define GEN_INT(N)  gen_rtx_CONST_INT (VOIDmode, (HOST_WIDE_INT) (N))\n\n/* Virtual registers are used during RTL generation to refer to locations into\n   the stack frame when the actual location isn't known until RTL generation\n   is complete.  The routine instantiate_virtual_regs replaces these with\n   the proper value, which is normally {frame,arg,stack}_pointer_rtx plus\n   a constant.  */\n\n#define FIRST_VIRTUAL_REGISTER\t(FIRST_PSEUDO_REGISTER)\n\n/* This points to the first word of the incoming arguments passed on the stack,\n   either by the caller or by the callee when pretending it was passed by the\n   caller.  */\n\n#define virtual_incoming_args_rtx       (global_rtl\u00ddGR_VIRTUAL_INCOMING_ARGS\u00a8)\n\n#define VIRTUAL_INCOMING_ARGS_REGNUM\t(FIRST_VIRTUAL_REGISTER)\n\n/* If FRAME_GROWS_DOWNWARD, this points to immediately above the first\n   variable on the stack.  Otherwise, it points to the first variable on\n   the stack.  */\n\n#define virtual_stack_vars_rtx\t        (global_rtl\u00ddGR_VIRTUAL_STACK_ARGS\u00a8)\n\n#define VIRTUAL_STACK_VARS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 1)\n\n/* This points to the location of dynamically-allocated memory on the stack\n   immediately after the stack pointer has been adjusted by the amount\n   desired.  */\n\n#define virtual_stack_dynamic_rtx\t(global_rtl\u00ddGR_VIRTUAL_STACK_DYNAMIC\u00a8)\n\n#define VIRTUAL_STACK_DYNAMIC_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 2)\n\n/* This points to the location in the stack at which outgoing arguments should\n   be written when the stack is pre-pushed (arguments pushed using push\n   insns always use sp).  */\n\n#define virtual_outgoing_args_rtx\t(global_rtl\u00ddGR_VIRTUAL_OUTGOING_ARGS\u00a8)\n\n#define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n\n/* This points to the Canonical Frame Address of the function.  This\n   should correspond to the CFA produced by INCOMING_FRAME_SP_OFFSET,\n   but is calculated relative to the arg pointer for simplicity; the\n   frame pointer nor stack pointer are necessarily fixed relative to\n   the CFA until after reload.  */\n\n#define virtual_cfa_rtx\t\t\t(global_rtl\u00ddGR_VIRTUAL_CFA\u00a8)\n\n#define VIRTUAL_CFA_REGNUM\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n\n#define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n\n/* Nonzero if REGNUM is a pointer into the stack frame.  */\n#define REGNO_PTR_FRAME_P(REGNUM)\t\t\\\n  ((REGNUM) == STACK_POINTER_REGNUM\t\t\\\n   || (REGNUM) == FRAME_POINTER_REGNUM\t\t\\\n   || (REGNUM) == HARD_FRAME_POINTER_REGNUM\t\\\n   || (REGNUM) == ARG_POINTER_REGNUM\t\t\\\n   || ((REGNUM) >= FIRST_VIRTUAL_REGISTER\t\\\n       && (REGNUM) <= LAST_VIRTUAL_REGISTER))\n\n/* REGNUM never really appearing in the INSN stream.  */\n#define INVALID_REGNUM\t\t\t(~(unsigned int) 0)\n\nextern rtx output_constant_def (tree, int);\nextern rtx lookup_constant_def (tree);\n\n/* Called from integrate.c when a deferred constant is inlined.  */\nextern void notice_rtl_inlining_of_deferred_constant (void);\n\n/* Nonzero after the second flow pass has completed.\n   Set to 1 or 0 by toplev.c  */\nextern int flow2_completed;\n\n/* Nonzero after end of reload pass.\n   Set to 1 or 0 by reload1.c.  */\n\nextern int reload_completed;\n\n/* Nonzero after thread_prologue_and_epilogue_insns has run.  */\nextern int epilogue_completed;\n\n/* Set to 1 while reload_as_needed is operating.\n   Required by some machines to handle any generated moves differently.  */\n\nextern int reload_in_progress;\n\n/* If this is nonzero, we do not bother generating VOLATILE\n   around volatile memory references, and we are willing to\n   output indirect addresses.  If cse is to follow, we reject\n   indirect addresses so a useful potential cse is generated;\n   if it is used only once, instruction combination will produce\n   the same indirect address eventually.  */\nextern int cse_not_expected;\n\n/* Set to nonzero before life analysis to indicate that it is unsafe to\n   generate any new pseudo registers.  */\nextern int no_new_pseudos;\n\n/* Translates rtx code to tree code, for those codes needed by\n   REAL_ARITHMETIC.  The function returns an int because the caller may not\n   know what `enum tree_code' means.  */\n\nextern int rtx_to_tree_code (enum rtx_code);\n\n/* In cse.c */\nstruct cse_basic_block_data;\n\n/* Return the right cost to give to an operation\n   to make the cost of the corresponding register-to-register instruction\n   N times that of a fast register-to-register instruction.  */\n#define COSTS_N_INSNS(N) ((N) * 4)\n\n/* Maximum cost of an rtl expression.  This value has the special meaning\n   not to use an rtx with this cost under any circumstances.  */\n#define MAX_COST INT_MAX\n\nextern int rtx_cost (rtx, enum rtx_code);\nextern int address_cost (rtx, enum machine_mode);\nextern int delete_trivially_dead_insns (rtx, int);\n#ifdef BUFSIZ\nextern int cse_main (rtx, int, int, FILE *);\n#endif\nextern void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n\t\t\t\t    int, int, int);\nextern void cse_condition_code_reg (void);\n\n/* In jump.c */\nextern int comparison_dominates_p (enum rtx_code, enum rtx_code);\nextern int condjump_p (rtx);\nextern int any_condjump_p (rtx);\nextern int any_uncondjump_p (rtx);\nextern int safe_to_remove_jump_p (rtx);\nextern rtx pc_set (rtx);\nextern rtx condjump_label (rtx);\nextern int simplejump_p (rtx);\nextern int returnjump_p (rtx);\nextern int onlyjump_p (rtx);\nextern int only_sets_cc0_p (rtx);\nextern int sets_cc0_p (rtx);\nextern int invert_jump_1 (rtx, rtx);\nextern int invert_jump (rtx, rtx, int);\nextern int rtx_renumbered_equal_p (rtx, rtx);\nextern int true_regnum (rtx);\nextern unsigned int reg_or_subregno (rtx);\nextern int redirect_jump_1 (rtx, rtx);\nextern int redirect_jump (rtx, rtx, int);\nextern void rebuild_jump_labels (rtx);\nextern enum rtx_code reversed_comparison_code (rtx, rtx);\nextern enum rtx_code reversed_comparison_code_parts (enum rtx_code,\n\t\t\t\t\t\t     rtx, rtx, rtx);\nextern void delete_for_peephole (rtx, rtx);\nextern int condjump_in_parallel_p (rtx);\nextern void never_reached_warning (rtx, rtx);\nextern void purge_line_number_notes (rtx);\nextern void copy_loop_headers (rtx);\n\n/* In emit-rtl.c.  */\nextern int max_reg_num (void);\nextern int max_label_num (void);\nextern int get_first_label_num (void);\nextern void delete_insns_since (rtx);\nextern void mark_reg_pointer (rtx, int);\nextern void mark_user_reg (rtx);\nextern void reset_used_flags (rtx);\nextern void set_used_flags (rtx);\nextern void reorder_insns (rtx, rtx, rtx);\nextern void reorder_insns_nobb (rtx, rtx, rtx);\nextern int get_max_uid (void);\nextern int in_sequence_p (void);\nextern void force_next_line_note (void);\nextern void init_emit (void);\nextern void init_emit_once (int);\nextern void push_topmost_sequence (void);\nextern void pop_topmost_sequence (void);\nextern int subreg_realpart_p (rtx);\nextern void reverse_comparison (rtx);\nextern void set_new_first_and_last_insn (rtx, rtx);\nextern void set_new_last_label_num (int);\nextern void unshare_all_rtl_again (rtx);\nextern void unshare_all_rtl_in_chain (rtx);\nextern void verify_rtl_sharing (void);\nextern void set_first_insn (rtx);\nextern void set_last_insn (rtx);\nextern void link_cc0_insns (rtx);\nextern void add_insn (rtx);\nextern void add_insn_before (rtx, rtx);\nextern void add_insn_after (rtx, rtx);\nextern void remove_insn (rtx);\nextern void reorder_insns_with_line_notes (rtx, rtx, rtx);\nextern void emit_insn_after_with_line_notes (rtx, rtx, rtx);\nextern enum rtx_code classify_insn (rtx);\nextern rtx emit (rtx);\n/* Query and clear/ restore no_line_numbers.  This is used by the\n   switch / case handling in stmt.c to give proper line numbers in\n   warnings about unreachable code.  */\nint force_line_numbers (void);\nvoid restore_line_number_status (int old_value);\nextern void renumber_insns (FILE *);\nextern void remove_unnecessary_notes (void);\nextern rtx delete_insn (rtx);\nextern void delete_insn_chain (rtx, rtx);\nextern rtx unlink_insn_chain (rtx, rtx);\nextern rtx delete_insn_and_edges (rtx);\nextern void delete_insn_chain_and_edges (rtx, rtx);\n\n/* In combine.c */\nextern int combine_instructions (rtx, unsigned int);\nextern unsigned int extended_count (rtx, enum machine_mode, int);\nextern rtx remove_death (unsigned int, rtx);\n#ifdef BUFSIZ\nextern void dump_combine_stats (FILE *);\nextern void dump_combine_total_stats (FILE *);\n#endif\n/* In web.c */\nextern void web_main (void);\n\n/* In sched.c.  */\n#ifdef BUFSIZ\nextern void schedule_insns (FILE *);\nextern void schedule_ebbs (FILE *);\n#endif\nextern void fix_sched_param (const char *, const char *);\n\n/* In print-rtl.c */\nextern const char *print_rtx_head;\nextern void debug_rtx (rtx);\nextern void debug_rtx_list (rtx, int);\nextern void debug_rtx_range (rtx, rtx);\nextern rtx debug_rtx_find (rtx, int);\n#ifdef BUFSIZ\nextern void print_mem_expr (FILE *, tree);\nextern void print_rtl (FILE *, rtx);\nextern void print_simple_rtl (FILE *, rtx);\nextern int print_rtl_single (FILE *, rtx);\nextern void print_inline_rtx (FILE *, rtx, int);\n#endif\n\n/* In loop.c */\nextern void init_loop (void);\nextern rtx libcall_other_reg (rtx, rtx);\n#ifdef BUFSIZ\nextern void loop_optimize (rtx, FILE *, int);\n#endif\nextern void branch_target_load_optimize (rtx, bool);\nextern void record_excess_regs (rtx, rtx, rtx *);\n\n/* In function.c */\nextern void reposition_prologue_and_epilogue_notes (rtx);\nextern void thread_prologue_and_epilogue_insns (rtx);\nextern int prologue_epilogue_contains (rtx);\nextern int sibcall_epilogue_contains (rtx);\nextern void preserve_rtl_expr_result (rtx);\nextern void mark_temp_addr_taken (rtx);\nextern void update_temp_slot_address (rtx, rtx);\nextern void purge_addressof (rtx);\nextern void purge_hard_subreg_sets (rtx);\n\n/* In stmt.c */\nextern void set_file_and_line_for_stmt (location_t);\nextern void expand_null_return (void);\nextern void expand_naked_return (void);\nextern void emit_jump (rtx);\nextern int preserve_subexpressions_p (void);\n\n/* In expr.c */\nextern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n\t\t\t   unsigned int, int);\n\n/* In flow.c */\nextern void recompute_reg_usage (rtx, int);\nextern int initialize_uninitialized_subregs (void);\nextern void delete_dead_jumptables (void);\n#ifdef BUFSIZ\nextern void print_rtl_with_bb (FILE *, rtx);\nextern void dump_flow_info (FILE *);\n#endif\n\n/* In expmed.c */\nextern void init_expmed (void);\nextern void expand_inc (rtx, rtx);\nextern void expand_dec (rtx, rtx);\nextern rtx expand_mult_highpart (enum machine_mode, rtx,\n\t\t\t\t unsigned HOST_WIDE_INT, rtx, int, int);\n\n/* In gcse.c */\nextern bool can_copy_p (enum machine_mode);\nextern rtx fis_get_condition (rtx);\n#ifdef BUFSIZ\nextern int gcse_main (rtx, FILE *);\nextern int bypass_jumps (FILE *);\n#endif\n\n/* In global.c */\nextern void mark_elimination (int, int);\n#ifdef BUFSIZ\nextern int global_alloc (FILE *);\nextern void dump_global_regs (FILE *);\n#endif\n#ifdef HARD_CONST\n/* Yes, this ifdef is silly, but HARD_REG_SET is not always defined.  */\nextern void retry_global_alloc (int, HARD_REG_SET);\n#endif\nextern void build_insn_chain (rtx);\n\n/* In regclass.c */\nextern int reg_classes_intersect_p (enum reg_class, enum reg_class);\nextern int reg_class_subset_p (enum reg_class, enum reg_class);\nextern void globalize_reg (int);\nextern void init_reg_modes_once (void);\nextern void init_regs (void);\nextern void init_fake_stack_mems (void);\nextern void init_reg_sets (void);\nextern void regset_release_memory (void);\nextern void regclass_init (void);\nextern void regclass (rtx, int, FILE *);\nextern void reg_scan (rtx, unsigned int, int);\nextern void reg_scan_update (rtx, rtx, unsigned int);\nextern void fix_register (const char *, int, int);\nextern void init_subregs_of_mode (void);\nextern void record_subregs_of_mode (rtx);\n#ifdef HARD_CONST\nextern void cannot_change_mode_set_regs (HARD_REG_SET *,\n\t\t\t\t\t enum machine_mode, unsigned int);\n#endif\nextern bool invalid_mode_change_p (unsigned int, enum reg_class,\n\t\t\t\t   enum machine_mode);\n\nextern int delete_null_pointer_checks (rtx);\n\n/* In regmove.c */\n#ifdef BUFSIZ\nextern void regmove_optimize (rtx, int, FILE *);\n#endif\nextern void combine_stack_adjustments (void);\n\n/* In reorg.c */\n#ifdef BUFSIZ\nextern void dbr_schedule (rtx, FILE *);\n#endif\n\n/* In local-alloc.c */\n#ifdef BUFSIZ\nextern void dump_local_alloc (FILE *);\n#endif\nextern int local_alloc (void);\nextern int function_invariant_p (rtx);\n\n/* In profile.c */\nextern void init_branch_prob (void);\nextern void branch_prob (void);\nextern void end_branch_prob (void);\n\n/* In reg-stack.c */\n#ifdef BUFSIZ\nextern bool reg_to_stack (rtx, FILE *);\n#endif\n\n/* In calls.c */\nenum libcall_type\n{\n  LCT_NORMAL = 0,\n  LCT_CONST = 1,\n  LCT_PURE = 2,\n  LCT_CONST_MAKE_BLOCK = 3,\n  LCT_PURE_MAKE_BLOCK = 4,\n  LCT_NORETURN = 5,\n  LCT_THROW = 6,\n  LCT_ALWAYS_RETURN = 7,\n  LCT_RETURNS_TWICE = 8\n};\n\nextern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,\n\t\t\t       ...);\nextern rtx emit_library_call_value (rtx, rtx, enum libcall_type,\n\t\t\t\t    enum machine_mode, int, ...);\n\n/* In unroll.c */\nextern int set_dominates_use (int, int, int, rtx, rtx);\n\n/* In varasm.c */\nextern int in_data_section (void);\nextern void init_varasm_once (void);\n\n/* In rtl.c */\nextern void init_rtl (void);\nextern void traverse_md_constants (int (*) (void **, void *), void *);\nstruct md_constant { char *name, *value; };\n\n#ifdef BUFSIZ\nextern int read_skip_spaces (FILE *);\nextern rtx read_rtx (FILE *);\n#endif\n\nextern const char *read_rtx_filename;\nextern int read_rtx_lineno;\n\n/* Redefine abort to report an internal error w/o coredump, and\n   reporting the location of the error in the source file.  This logic\n   is duplicated in rtl.h and tree.h because every file that needs the\n   special abort includes one or both.  toplev.h gets too few files,\n   system.h gets too many.  */\n\nextern void fancy_abort (const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\n#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n\n/* In alias.c */\nextern void clear_reg_alias_info (rtx);\nextern rtx canon_rtx (rtx);\nextern int true_dependence (rtx, enum machine_mode, rtx, int (*)(rtx, int));\nextern rtx get_addr (rtx);\nextern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,\n\t\t\t\t  int (*)(rtx, int));\nextern int read_dependence (rtx, rtx);\nextern int anti_dependence (rtx, rtx);\nextern int output_dependence (rtx, rtx);\nextern int unchanging_anti_dependence (rtx, rtx);\nextern void mark_constant_function (void);\nextern void init_alias_once (void);\nextern void init_alias_analysis (void);\nextern void end_alias_analysis (void);\nextern rtx addr_side_effect_eval (rtx, int, int);\nextern bool memory_modified_in_insn_p (rtx, rtx);\nextern rtx find_base_term (rtx);\nextern rtx get_reg_known_value (unsigned int);\nextern bool get_reg_known_equiv_p (unsigned int);\n\n/* In sibcall.c */\ntypedef enum {\n  sibcall_use_normal = 1,\n  sibcall_use_tail_recursion,\n  sibcall_use_sibcall\n} sibcall_use_t;\n\nextern void optimize_sibling_and_tail_recursive_calls (void);\nextern void replace_call_placeholder (rtx, sibcall_use_t);\n\n#ifdef STACK_REGS\nextern int stack_regs_mentioned (rtx insn);\n#endif\n\n/* In toplev.c */\nextern GTY(()) rtx stack_limit_rtx;\n\n/* In regrename.c */\nextern void regrename_optimize (void);\nextern void copyprop_hardreg_forward (void);\n\n/* In ifcvt.c */\nextern void if_convert (int);\n\n/* In predict.c */\nextern void invert_br_probabilities (rtx);\nextern bool expensive_function_p (int);\n/* In tracer.c */\nextern void tracer (unsigned int);\n\n#endif /* ! GCC_RTL_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RTLD": {"ttr": 10241, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   Register Transfer Expressions (rtx's) that make up the\n   Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n   Copyright (C) 1987, 88, 92, 94, 95, 97, 98, 1999, 2000\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* Expression definitions and descriptions for all targets are in this file.\n   Some will not be used for some targets.\n\n   The fields in the cpp macro call \"DEF_RTL_EXPR()\"\n   are used to create declarations in the C source of the compiler.\n\n   The fields are:\n\n   1.  The internal name of the rtx used in the C source.\n   It is a tag in the enumeration \"enum rtx_code\" defined in \"rtl.h\".\n   By convention these are in UPPER_CASE.\n\n   2.  The name of the rtx in the external ASCII format read by\n   read_rtx(), and printed by print_rtx().\n   These names are stored in rtx_name\u00dd\u00a8.\n   By convention these are the internal (field 1) names in lower_case.\n\n   3.  The print format, and type of each rtx->u.fld\u00dd\u00a8 (field) in this rtx.\n   These formats are stored in rtx_format\u00dd\u00a8.\n   The meaning of the formats is documented in front of this array in rtl.c\n\n   4.  The class of the rtx.  These are stored in rtx_class and are accessed\n   via the GET_RTX_CLASS macro.  They are defined as follows:\n\n     \"o\" an rtx code that can be used to represent an object (e.g, REG, MEM)\n     \"<\" an rtx code for a comparison (e.g, EQ, NE, LT)\n     \"1\" an rtx code for a unary arithmetic expression (e.g, NEG, NOT)\n     \"c\" an rtx code for a commutative binary operation (e.g,, PLUS, MULT)\n     \"3\" an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)\n     \"2\" an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)\n     \"b\" an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)\n     \"i\" an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n     \"m\" an rtx code for something that matches in insns (e.g, MATCH_DUP)\n     \"g\" an rtx code for grouping insns together (e.g, GROUP_PARALLEL)\n     \"a\" an rtx code for autoincrement addressing modes (e.g. POST_DEC)\n     \"x\" everything else\n\n   */\n\n/* ---------------------------------------------------------------------\n   Expressions (and \"meta\" expressions) used for structuring the\n   rtl representation of a program.\n   --------------------------------------------------------------------- */\n\n/* an expression code name unknown to the reader */\nDEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", 'x')\n\n/* (NIL) is used by rtl reader and printer to represent a null pointer.  */\n\nDEF_RTL_EXPR(NIL, \"nil\", \"*\", 'x')\n\n\n/* include a file */\n\nDEF_RTL_EXPR(INCLUDE, \"include\", \"s\", 'x')\n\n/* ---------------------------------------------------------------------\n   Expressions used in constructing lists.\n   --------------------------------------------------------------------- */\n\n/* a linked list of expressions */\nDEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", 'x')\n\n/* a linked list of instructions.\n   The insns are represented in print by their uids.  */\nDEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expression types for machine descriptions.\n   These do not appear in actual rtl code in the compiler.\n   ---------------------------------------------------------------------- */\n\n/* Appears only in machine descriptions.\n   Means use the function named by the second arg (the string)\n   as a predicate; if matched, store the structure that was matched\n   in the operand table at index specified by the first arg (the integer).\n   If the second arg is the null string, the structure is just stored.\n\n   A third string argument indicates to the register allocator restrictions\n   on where the operand can be allocated.\n\n   If the target needs no restriction on any instruction this field should\n   be the null string.\n\n   The string is prepended by:\n   '=' to indicate the operand is only written to.\n   '+' to indicate the operand is both read and written to.\n\n   Each character in the string represents an allocable class for an operand.\n   'g' indicates the operand can be any valid class.\n   'i' indicates the operand can be immediate (in the instruction) data.\n   'r' indicates the operand can be in a register.\n   'm' indicates the operand can be in memory.\n   'o' a subset of the 'm' class.  Those memory addressing modes that\n       can be offset at compile time (have a constant added to them).\n\n   Other characters indicate target dependent operand classes and\n   are described in each target's machine description.\n\n   For instructions with more than one operand, sets of classes can be\n   separated by a comma to indicate the appropriate multi-operand constraints.\n   There must be a 1 to 1 correspondence between these sets of classes in\n   all operands for an instruction.\n   */\nDEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match a SCRATCH or a register.  When used to generate rtl, a\n   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n   the desired mode and the first argument is the operand number.\n   The second argument is the constraint.  */\nDEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  */\nDEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", 'm')\n\n/* Appears only in machine descriptions.\n   Means apply a predicate, AND match recursively the operands of the rtx.\n   Operand 0 is the operand-number, as in match_operand.\n   Operand 1 is a predicate to apply (as a string, a function name).\n   Operand 2 is a vector of expressions, each of which must match\n   one subexpression of the rtx this construct is matching.  */\nDEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means to match a PARALLEL of arbitrary length.  The predicate is applied\n   to the PARALLEL and the initial expressions in the PARALLEL are matched.\n   Operand 0 is the operand-number, as in match_operand.\n   Operand 1 is a predicate to apply to the PARALLEL.\n   Operand 2 is a vector of expressions, each of which must match the\n   corresponding element in the PARALLEL.  */\nDEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  For MATCH_OPERATOR.  */\nDEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", 'm')\n\n/* Appears only in machine descriptions.\n   Means match only something equal to what is stored in the operand table\n   at the index specified by the argument.  For MATCH_PARALLEL.  */\nDEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", 'm')\n\n/* Appears only in machine descriptions.\n   Operand 0 is the operand number, as in match_operand.\n   Operand 1 is the predicate to apply to the insn.  */\nDEF_RTL_EXPR(MATCH_INSN, \"match_insn\", \"is\", 'm')\n\n/* Appears only in machine descriptions.\n   Defines the pattern for one kind of instruction.\n   Operand:\n   0: names this instruction.\n      If the name is the null string, the instruction is in the\n      machine description just to be recognized, and will never be emitted by\n      the tree to rtl expander.\n   1: is the pattern.\n   2: is a string which is a C expression\n      giving an additional condition for recognizing this pattern.\n      A null string means no extra condition.\n   3: is the action to execute if this pattern is matched.\n      If this assembler code template starts with a * then it is a fragment of\n      C code to run to decide on a template to use.  Otherwise, it is the\n      template to use.\n   4: optionally, a vector of attributes for this insn.\n     */\nDEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEsTV\", 'x')\n\n/* Definition of a peephole optimization.\n   1st operand: vector of insn patterns to match\n   2nd operand: C expression that must be true\n   3rd operand: template or C code to produce assembler output.\n   4: optionally, a vector of attributes for this insn.\n     */\nDEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EsTV\", 'x')\n\n/* Definition of a split operation.\n   1st operand: insn pattern to match\n   2nd operand: C expression that must be true\n   3rd operand: vector of insn patterns to place into a SEQUENCE\n   4th operand: optionally, some C code to execute before generating the\n\tinsns.  This might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').  */\nDEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n\n/* Definition of an insn and associated split.\n   This is the concatenation, with a few modifications, of a define_insn\n   and a define_split which share the same pattern.\n   Operand:\n   0: names this instruction.\n      If the name is the null string, the instruction is in the\n      machine description just to be recognized, and will never be emitted by\n      the tree to rtl expander.\n   1: is the pattern.\n   2: is a string which is a C expression\n      giving an additional condition for recognizing this pattern.\n      A null string means no extra condition.\n   3: is the action to execute if this pattern is matched.\n      If this assembler code template starts with a * then it is a fragment of\n      C code to run to decide on a template to use.  Otherwise, it is the\n      template to use.\n   4: C expression that must be true for split.  This may start with \"&&\"\n      in which case the split condition is the logical and of the insn\n      condition and what follows the \"&&\" of this operand.\n   5: vector of insn patterns to place into a SEQUENCE\n   6: optionally, some C code to execute before generating the\n\tinsns.  This might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').\n   7: optionally, a vector of attributes for this insn.  */\nDEF_RTL_EXPR(DEFINE_INSN_AND_SPLIT, \"define_insn_and_split\", \"sEsTsESV\", 'x')\n\n/* Definition of an RTL peephole operation.\n   Follows the same arguments as define_split.  */\nDEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", 'x')\n\n/* Definition of a combiner pattern.\n   Operands not defined yet.  */\nDEF_RTL_EXPR(DEFINE_COMBINE, \"define_combine\", \"Ess\", 'x')\n\n/* Define how to generate multiple insns for a standard insn name.\n   1st operand: the insn name.\n   2nd operand: vector of insn-patterns.\n\tUse match_operand to substitute an element of `recog_data.operand'.\n   3rd operand: C expression that must be true for this to be available.\n\tThis may not test any operands.\n   4th operand: Extra C code to execute before generating the insns.\n\tThis might, for example, create some RTX's and store them in\n\telements of `recog_data.operand' for use by the vector of\n\tinsn-patterns.\n\t(`operands' is an alias here for `recog_data.operand').  */\nDEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", 'x')\n\n/* Define a requirement for delay slots.\n   1st operand: Condition involving insn attributes that, if true,\n\t        indicates that the insn requires the number of delay slots\n\t\tshown.\n   2nd operand: Vector whose length is the three times the number of delay\n\t\tslots required.\n\t        Each entry gives three conditions, each involving attributes.\n\t\tThe first must be true for an insn to occupy that delay slot\n\t\tlocation.  The second is true for all insns that can be\n\t\tannulled if the branch is true and the third is true for all\n\t\tinsns that can be annulled if the branch is false.\n\n   Multiple DEFINE_DELAYs may be present.  They indicate differing\n   requirements for delay slots.  */\nDEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", 'x')\n\n/* Define a set of insns that requires a function unit.  This means that\n   these insns produce their result after a delay and that there may be\n   restrictions on the number of insns of this type that can be scheduled\n   simultaneously.\n\n   More than one DEFINE_FUNCTION_UNIT can be specified for a function unit.\n   Each gives a set of operations and associated delays.  The first three\n   operands must be the same for each operation for the same function unit.\n\n   All delays are specified in cycles.\n\n   1st operand: Name of function unit (mostly for documentation)\n   2nd operand: Number of identical function units in CPU\n   3rd operand: Total number of simultaneous insns that can execute on this\n\t\tfunction unit; 0 if unlimited.\n   4th operand: Condition involving insn attribute, that, if true, specifies\n\t\tthose insns that this expression applies to.\n   5th operand: Constant delay after which insn result will be\n\t\tavailable.\n   6th operand: Delay until next insn can be scheduled on the function unit\n\t\texecuting this operation.  The meaning depends on whether or\n\t\tnot the next operand is supplied.\n   7th operand: If this operand is not specified, the 6th operand gives the\n\t\tnumber of cycles after the instruction matching the 4th\n\t\toperand begins using the function unit until a subsequent\n\t\tinsn can begin.  A value of zero should be used for a\n\t\tunit with no issue constraints.  If only one operation can\n\t\tbe executed a time and the unit is busy for the entire time,\n\t\tthe 3rd operand should be specified as 1, the 6th operand\n\t\tshould be specified as 0, and the 7th operand should not\n\t\tbe specified.\n\n\t\tIf this operand is specified, it is a list of attribute\n\t\texpressions.  If an insn for which any of these expressions\n\t\tis true is currently executing on the function unit, the\n\t\tissue delay will be given by the 6th operand.  Otherwise,\n\t\tthe insn can be immediately scheduled (subject to the limit\n\t\ton the number of simultaneous operations executing on the\n\t\tunit.)  */\nDEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", 'x')\n\n/* Define attribute computation for `asm' instructions.  */\nDEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n\n/* Definition of a conditional execution meta operation.  Automatically\n   generates new instances of DEFINE_INSN, selected by having attribute\n   \"predicable\" true.  The new pattern will contain a COND_EXEC and the\n   predicate at top-level.\n\n   Operand:\n   0: The predicate pattern.  The top-level form should match a\n      relational operator.  Operands should have only one alternative.\n   1: A C expression giving an additional condition for recognizing\n      the generated pattern.\n   2: A template or C code to produce assembler output.  */\nDEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", 'x')\n\n/* SEQUENCE appears in the result of a `gen_...' function\n   for a DEFINE_EXPAND that wants to make several insns.\n   Its elements are the bodies of the insns that should be made.\n   `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\nDEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n\n/* Refers to the address of its argument.  This is only used in alias.c.  */\nDEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n\n/* ----------------------------------------------------------------------\n   Constructions for CPU pipeline description described by NDFAs.\n   These do not appear in actual rtl code in the compiler.\n   ---------------------------------------------------------------------- */\n\n/* (define_cpu_unit string \u00ddstring\u00a8) describes cpu functional\n   units (separated by comma).\n\n   1st operand: Names of cpu functional units.\n   2nd operand: Name of automaton (see comments for DEFINE_AUTOMATON).\n\n   All define_reservations, define_cpu_units, and\n   define_query_cpu_units should have unique names which may not be\n   \"nothing\".  */\nDEF_RTL_EXPR(DEFINE_CPU_UNIT, \"define_cpu_unit\", \"sS\", 'x')\n\n/* (define_query_cpu_unit string \u00ddstring\u00a8) describes cpu functional\n   units analogously to define_cpu_unit.  The reservation of such\n   units can be queried for automaton state.  */\nDEF_RTL_EXPR(DEFINE_QUERY_CPU_UNIT, \"define_query_cpu_unit\", \"sS\", 'x')\n\n/* (exclusion_set string string) means that each CPU functional unit\n   in the first string can not be reserved simultaneously with any\n   unit whose name is in the second string and vise versa.  CPU units\n   in the string are separated by commas.  For example, it is useful\n   for description CPU with fully pipelined floating point functional\n   unit which can execute simultaneously only single floating point\n   insns or only double floating point insns.  All CPU functional\n   units in a set should belong to the same automaton.  */\nDEF_RTL_EXPR(EXCLUSION_SET, \"exclusion_set\", \"ss\", 'x')\n\n/* (presence_set string string) means that each CPU functional unit in\n   the first string can not be reserved unless at least one of pattern\n   of units whose names are in the second string is reserved.  This is\n   an asymmetric relation.  CPU units or unit patterns in the strings\n   are separated by commas.  Pattern is one unit name or unit names\n   separated by white-spaces.\n\n   For example, it is useful for description that slot1 is reserved\n   after slot0 reservation for a VLIW processor.  We could describe it\n   by the following construction\n\n      (presence_set \"slot1\" \"slot0\")\n\n   Or slot1 is reserved only after slot0 and unit b0 reservation.  In\n   this case we could write\n\n      (presence_set \"slot1\" \"slot0 b0\")\n\n   All CPU functional units in a set should belong to the same\n   automaton.  */\nDEF_RTL_EXPR(PRESENCE_SET, \"presence_set\", \"ss\", 'x')\n\n/* (final_presence_set string string) is analogous to `presence_set'.\n   The difference between them is when checking is done.  When an\n   instruction is issued in given automaton state reflecting all\n   current and planned unit reservations, the automaton state is\n   changed.  The first state is a source state, the second one is a\n   result state.  Checking for `presence_set' is done on the source\n   state reservation, checking for `final_presence_set' is done on the\n   result reservation.  This construction is useful to describe a\n   reservation which is actually two subsequent reservations.  For\n   example, if we use\n\n      (presence_set \"slot1\" \"slot0\")\n\n   the following insn will be never issued (because slot1 requires\n   slot0 which is absent in the source state).\n\n      (define_reservation \"insn_and_nop\" \"slot0 + slot1\")\n\n   but it can be issued if we use analogous `final_presence_set'.  */\nDEF_RTL_EXPR(FINAL_PRESENCE_SET, \"final_presence_set\", \"ss\", 'x')\n\n/* (absence_set string string) means that each CPU functional unit in\n   the first string can be reserved only if each pattern of units\n   whose names are in the second string is not reserved.  This is an\n   asymmetric relation (actually exclusion set is analogous to this\n   one but it is symmetric).  CPU units or unit patterns in the string\n   are separated by commas.  Pattern is one unit name or unit names\n   separated by white-spaces.\n\n   For example, it is useful for description that slot0 can not be\n   reserved after slot1 or slot2 reservation for a VLIW processor.  We\n   could describe it by the following construction\n\n      (absence_set \"slot2\" \"slot0, slot1\")\n\n   Or slot2 can not be reserved if slot0 and unit b0 are reserved or\n   slot1 and unit b1 are reserved .  In this case we could write\n\n      (absence_set \"slot2\" \"slot0 b0, slot1 b1\")\n\n   All CPU functional units in a set should to belong the same\n   automaton.  */\nDEF_RTL_EXPR(ABSENCE_SET, \"absence_set\", \"ss\", 'x')\n\n/* (final_absence_set string string) is analogous to `absence_set' but\n   checking is done on the result (state) reservation.  See comments\n   for `final_presence_set'.  */\nDEF_RTL_EXPR(FINAL_ABSENCE_SET, \"final_absence_set\", \"ss\", 'x')\n\n/* (define_bypass number out_insn_names in_insn_names) names bypass\n   with given latency (the first number) from insns given by the first\n   string (see define_insn_reservation) into insns given by the second\n   string.  Insn names in the strings are separated by commas.  The\n   third operand is optional name of function which is additional\n   guard for the bypass.  The function will get the two insns as\n   parameters.  If the function returns zero the bypass will be\n   ignored for this case.  Additional guard is necessary to recognize\n   complicated bypasses, e.g. when consumer is load address.  */\nDEF_RTL_EXPR(DEFINE_BYPASS, \"define_bypass\", \"issS\", 'x')\n\n/* (define_automaton string) describes names of automata generated and\n   used for pipeline hazards recognition.  The names are separated by\n   comma.  Actually it is possibly to generate the single automaton\n   but unfortunately it can be very large.  If we use more one\n   automata, the summary size of the automata usually is less than the\n   single one.  The automaton name is used in define_cpu_unit and\n   define_query_cpu_unit.  All automata should have unique names.  */\nDEF_RTL_EXPR(DEFINE_AUTOMATON, \"define_automaton\", \"s\", 'x')\n\n/* (automata_option string) describes option for generation of\n   automata.  Currently there are the following options:\n\n   o \"no-minimization\" which makes no minimization of automata.  This\n     is only worth to do when we are debugging the description and\n     need to look more accurately at reservations of states.\n\n   o \"time\" which means printing additional time statistics about\n      generation of automata.\n\n   o \"v\" which means generation of file describing the result\n     automata.  The file has suffix `.dfa' and can be used for the\n     description verification and debugging.\n\n   o \"w\" which means generation of warning instead of error for\n     non-critical errors.\n\n   o \"ndfa\" which makes nondeterministic finite state automata.\n\n   o \"progress\" which means output of a progress bar showing how many\n     states were generated so far for automaton being processed.  */\nDEF_RTL_EXPR(AUTOMATA_OPTION, \"automata_option\", \"s\", 'x')\n\n/* (define_reservation string string) names reservation (the first\n   string) of cpu functional units (the 2nd string).  Sometimes unit\n   reservations for different insns contain common parts.  In such\n   case, you can describe common part and use its name (the 1st\n   parameter) in regular expression in define_insn_reservation.  All\n   define_reservations, define_cpu_units, and define_query_cpu_units\n   should have unique names which may not be \"nothing\".  */\nDEF_RTL_EXPR(DEFINE_RESERVATION, \"define_reservation\", \"ss\", 'x')\n\n/* (define_insn_reservation name default_latency condition regexpr)\n   describes reservation of cpu functional units (the 3nd operand) for\n   instruction which is selected by the condition (the 2nd parameter).\n   The first parameter is used for output of debugging information.\n   The reservations are described by a regular expression according\n   the following syntax:\n\n       regexp = regexp \",\" oneof\n              | oneof\n\n       oneof = oneof \"|\" allof\n             | allof\n\n       allof = allof \"+\" repeat\n             | repeat\n\n       repeat = element \"*\" number\n              | element\n\n       element = cpu_function_unit_name\n               | reservation_name\n               | result_name\n               | \"nothing\"\n               | \"(\" regexp \")\"\n\n       1. \",\" is used for describing start of the next cycle in\n       reservation.\n\n       2. \"|\" is used for describing the reservation described by the\n       first regular expression *or* the reservation described by the\n       second regular expression *or* etc.\n\n       3. \"+\" is used for describing the reservation described by the\n       first regular expression *and* the reservation described by the\n       second regular expression *and* etc.\n\n       4. \"*\" is used for convenience and simply means sequence in\n       which the regular expression are repeated NUMBER times with\n       cycle advancing (see \",\").\n\n       5. cpu functional unit name which means its reservation.\n\n       6. reservation name -- see define_reservation.\n\n       7. string \"nothing\" means no units reservation.  */\n\nDEF_RTL_EXPR(DEFINE_INSN_RESERVATION, \"define_insn_reservation\", \"sies\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expressions used for insn attributes.  These also do not appear in\n   actual rtl code in the compiler.\n   ---------------------------------------------------------------------- */\n\n/* Definition of an insn attribute.\n   1st operand: name of the attribute\n   2nd operand: comma-separated list of possible attribute values\n   3rd operand: expression for the default value of the attribute.  */\nDEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", 'x')\n\n/* Marker for the name of an attribute.  */\nDEF_RTL_EXPR(ATTR, \"attr\", \"s\", 'x')\n\n/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n   pattern.\n\n   (set_attr \"name\" \"value\") is equivalent to\n   (set (attr \"name\") (const_string \"value\"))  */\nDEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", 'x')\n\n/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n   specify that attribute values are to be assigned according to the\n   alternative matched.\n\n   The following three expressions are equivalent:\n\n   (set (attr \"att\") (cond \u00dd(eq_attrq \"alternative\" \"1\") (const_string \"a1\")\n\t\t\t    (eq_attrq \"alternative\" \"2\") (const_string \"a2\")\u00a8\n\t\t\t   (const_string \"a3\")))\n   (set_attr_alternative \"att\" \u00dd(const_string \"a1\") (const_string \"a2\")\n\t\t\t\t (const_string \"a3\")\u00a8)\n   (set_attr \"att\" \"a1,a2,a3\")\n */\nDEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", 'x')\n\n/* A conditional expression true if the value of the specified attribute of\n   the current insn equals the specified value.  The first operand is the\n   attribute name and the second is the comparison value.  */\nDEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", 'x')\n\n/* A special case of the above representing a set of alternatives.  The first\n   operand is bitmap of the set, the second one is the default value.  */\nDEF_RTL_EXPR(EQ_ATTR_ALT, \"eq_attr_alt\", \"ii\", 'x')\n\n/* A conditional expression which is true if the specified flag is\n   true for the insn being scheduled in reorg.\n\n   genattr.c defines the following flags which can be tested by\n   (attr_flag \"foo\") expressions in eligible_for_delay.\n\n   forward, backward, very_likely, likely, very_unlikely, and unlikely.  */\n\nDEF_RTL_EXPR (ATTR_FLAG, \"attr_flag\", \"s\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expression types used for things in the instruction chain.\n\n   All formats must start with \"iuu\" to handle the chain.\n   Each insn expression holds an rtl instruction and its semantics\n   during back-end processing.\n   See macros's in \"rtl.h\" for the meaning of each rtx->u.fld\u00dd\u00a8.\n\n   ---------------------------------------------------------------------- */\n\n/* An instruction that cannot jump.  */\nDEF_RTL_EXPR(INSN, \"insn\", \"iuuBieiee\", 'i')\n\n/* An instruction that can possibly jump.\n   Fields ( rtx->u.fld\u00dd\u00a8 ) have exact same meaning as INSN's.  */\nDEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuuBieiee0\", 'i')\n\n/* An instruction that can possibly call a subroutine\n   but which will not change which instruction comes next\n   in the current function.\n   Field ( rtx->u.fld\u00dd9\u00a8 ) is CALL_INSN_FUNCTION_USAGE.\n   All other fields ( rtx->u.fld\u00dd\u00a8 ) have exact same meaning as INSN's.  */\nDEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuuBieieee\", 'i')\n\n/* A marker that indicates that control will not flow through.  */\nDEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", 'x')\n\n/* Holds a label that is followed by instructions.\n   Operand:\n   4: is used in jump.c for the use-count of the label.\n   5: is used in flow.c to point to the chain of label_ref's to this label.\n   6: is a number that is unique in the entire compilation.\n   7: is the user-given name of the label, if any.  */\nDEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", 'x')\n\n/* Say where in the code a source line starts, for symbol table's sake.\n   Operand:\n   4: filename, if line number > 0, note-specific data otherwise.\n   5: line number if > 0, enum note_insn otherwise.\n   6: unique number if line number == note_insn_deleted_label.  */\nDEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", 'x')\n\n/* ----------------------------------------------------------------------\n   Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n   ---------------------------------------------------------------------- */\n\n/* Conditionally execute code.\n   Operand 0 is the condition that if true, the code is executed.\n   Operand 1 is the code to be executed (typically a SET).\n\n   Semantics are that there are no side effects if the condition\n   is false.  This pattern is created automatically by the if_convert\n   pass run after reload or by target-specific splitters.  */\nDEF_RTL_EXPR(COND_EXEC, \"cond_exec\", \"ee\", 'x')\n\n/* Several operations to be done in parallel (perhaps under COND_EXEC).  */\nDEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", 'x')\n\n/* A string that is passed through to the assembler as input.\n     One can obviously pass comments through by using the\n     assembler comment syntax.\n     These occur in an insn all by themselves as the PATTERN.\n     They also appear inside an ASM_OPERANDS\n     as a convenient way to hold a string.  */\nDEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", 'x')\n\n/* An assembler instruction with operands.\n   1st operand is the instruction template.\n   2nd operand is the constraint for the output.\n   3rd operand is the number of the output this expression refers to.\n     When an insn stores more than one value, a separate ASM_OPERANDS\n     is made for each output; this integer distinguishes them.\n   4th is a vector of values of input operands.\n   5th is a vector of modes and constraints for the input operands.\n     Each element is an ASM_INPUT containing a constraint string\n     and whose mode indicates the mode of the input operand.\n   6th is the name of the containing source file.\n   7th is the source line number.  */\nDEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n\n/* A machine-specific operation.\n   1st operand is a vector of operands being used by the operation so that\n     any needed reloads can be done.\n   2nd operand is a unique value saying which of a number of machine-specific\n     operations is to be performed.\n   (Note that the vector must be the first operand because of the way that\n   genrecog.c record positions within an insn.)\n   This can occur all by itself in a PATTERN, as a component of a PARALLEL,\n   or inside an expression.  */\nDEF_RTL_EXPR(UNSPEC, \"unspec\", \"Ei\", 'x')\n\n/* Similar, but a volatile operation and one which may trap.  */\nDEF_RTL_EXPR(UNSPEC_VOLATILE, \"unspec_volatile\", \"Ei\", 'x')\n\n/* Vector of addresses, stored as full words.  */\n/* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\nDEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n\n/* Vector of address differences X0 - BASE, X1 - BASE, ...\n   First operand is BASE; the vector contains the X's.\n   The machine mode of this rtx says how much space to leave\n   for each difference and is adjusted by branch shortening if\n   CASE_VECTOR_SHORTEN_MODE is defined.\n   The third and fourth operands store the target labels with the\n   minimum and maximum addresses respectively.\n   The fifth operand stores flags for use by branch shortening.\n  Set at the start of shorten_branches:\n   min_align: the minimum alignment for any of the target labels.\n   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.\n   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.\n   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.\n   min_after_base: true iff minimum address target label is after BASE.\n   max_after_base: true iff maximum address target label is after BASE.\n  Set by the actual branch shortening process:\n   offset_unsigned: true iff offsets have to be treated as unsigned.\n   scale: scaling that is necessary to make offsets fit into the mode.\n\n   The third, fourth and fifth operands are only valid when\n   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n   compilations.  */\n\nDEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", 'x')\n\n/* Memory prefetch, with attributes supported on some targets.\n   Operand 1 is the address of the memory to fetch.\n   Operand 2 is 1 for a write access, 0 otherwise.\n   Operand 3 is the level of temporal locality; 0 means there is no\n   temporal locality and 1, 2, and 3 are for increasing levels of temporal\n   locality.\n\n   The attributes specified by operands 2 and 3 are ignored for targets\n   whose prefetch instructions do not support them.  */\nDEF_RTL_EXPR(PREFETCH, \"prefetch\", \"eee\", 'x')\n\n/* ----------------------------------------------------------------------\n   At the top level of an instruction (perhaps under PARALLEL).\n   ---------------------------------------------------------------------- */\n\n/* Assignment.\n   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n   Operand 2 is the value stored there.\n   ALL assignment must use SET.\n   Instructions that do multiple assignments must use multiple SET,\n   under PARALLEL.  */\nDEF_RTL_EXPR(SET, \"set\", \"ee\", 'x')\n\n/* Indicate something is used in a way that we don't want to explain.\n   For example, subroutine calls will use the register\n   in which the static chain is passed.  */\nDEF_RTL_EXPR(USE, \"use\", \"e\", 'x')\n\n/* Indicate something is clobbered in a way that we don't want to explain.\n   For example, subroutine calls will clobber some physical registers\n   (the ones that are by convention not saved).  */\nDEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", 'x')\n\n/* Call a subroutine.\n   Operand 1 is the address to call.\n   Operand 2 is the number of arguments.  */\n\nDEF_RTL_EXPR(CALL, \"call\", \"ee\", 'x')\n\n/* Return from a subroutine.  */\n\nDEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n\n/* Conditional trap.\n   Operand 1 is the condition.\n   Operand 2 is the trap code.\n   For an unconditional trap, make the condition (const_int 1).  */\nDEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n\n/* Placeholder for _Unwind_Resume before we know if a function call\n   or a branch is needed.  Operand 1 is the exception region from\n   which control is flowing.  */\nDEF_RTL_EXPR(RESX, \"resx\", \"i\", 'x')\n\n/* ----------------------------------------------------------------------\n   Primitive values for use in expressions.\n   ---------------------------------------------------------------------- */\n\n/* numeric integer constant */\nDEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n\n/* numeric floating point constant.\n   Operands hold the value.  They are all 'w' and there may be from 2 to 6;\n   see real.h.  */\nDEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, 'o')\n\n/* Describes a vector constant.  */\nDEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", 'x')\n\n/* String constant.  Used only for attributes right now.  */\nDEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')\n\n/* This is used to encapsulate an expression whose value is constant\n   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n   recognized as a constant operand rather than by arithmetic instructions.  */\n\nDEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n\n/* program counter.  Ordinary jumps are represented\n   by a SET whose first operand is (PC).  */\nDEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n\n/* Used in the cselib routines to describe a value.  */\nDEF_RTL_EXPR(VALUE, \"value\", \"0\", 'o')\n\n/* A register.  The \"operand\" is the register number, accessed with\n   the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n   than a hardware register is being referred to.  The second operand\n   holds the original register number - this will be different for a\n   pseudo register that got turned into a hard register.\n   This rtx needs to have as many (or more) fields as a MEM, since we\n   can change REG rtx's into MEMs during reload.  */\nDEF_RTL_EXPR(REG, \"reg\", \"i00\", 'o')\n\n/* A scratch register.  This represents a register used only within a\n   single insn.  It will be turned into a REG during register allocation\n   or reload unless the constraint indicates that the register won't be\n   needed, in which case it can remain a SCRATCH.  This code is\n   marked as having one operand so it can be turned into a REG.  */\nDEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", 'o')\n\n/* One word of a multi-word value.\n   The first operand is the complete value; the second says which word.\n   The WORDS_BIG_ENDIAN flag controls whether word number 0\n   (as numbered in a SUBREG) is the most or least significant word.\n\n   This is also used to refer to a value in a different machine mode.\n   For example, it can be used to refer to a SImode value as if it were\n   Qimode, or vice versa.  Then the word number is always 0.  */\nDEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", 'x')\n\n/* This one-argument rtx is used for move instructions\n   that are guaranteed to alter only the low part of a destination.\n   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))\n   has an unspecified effect on the high part of REG,\n   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))\n   is guaranteed to alter only the bits of REG that are in HImode.\n\n   The actual instruction used is probably the same in both cases,\n   but the register constraints may be tighter when STRICT_LOW_PART\n   is in use.  */\n\nDEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", 'x')\n\n/* (CONCAT a b) represents the virtual concatenation of a and b\n   to make a value that has as many bits as a and b put together.\n   This is used for complex values.  Normally it appears only\n   in DECL_RTLs and during RTL generation, but not in the insn chain.  */\nDEF_RTL_EXPR(CONCAT, \"concat\", \"ee\", 'o')\n\n/* A memory location; operand is the address.  The second operand is the\n   alias set to which this MEM belongs.  We use `0' instead of `w' for this\n   field so that the field need not be specified in machine descriptions.  */\nDEF_RTL_EXPR(MEM, \"mem\", \"e0\", 'o')\n\n/* Reference to an assembler label in the code for this function.\n   The operand is a CODE_LABEL found in the insn chain.\n   The unprinted fields 1 and 2 are used in flow.c for the\n   LABEL_NEXTREF and CONTAINING_INSN.  */\nDEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", 'o')\n\n/* Reference to a named label:\n   Operand 0: label name\n   Operand 1: flags (see SYMBOL_FLAG_* in rtl.h)\n   Operand 2: tree from which this symbol is derived, or null.\n   This is either a DECL node, or some kind of constant.  */\nDEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s00\", 'o')\n\n/* The condition code register is represented, in our imagination,\n   as a register holding a value that can be compared to zero.\n   In fact, the machine has already compared them and recorded the\n   results; but instructions that look at the condition code\n   pretend to be looking at the entire value and comparing it.  */\nDEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n\n/* Reference to the address of a register.  Removed by purge_addressof after\n   CSE has elided as many as possible.\n   1st operand: the register we may need the address of.\n   2nd operand: the original pseudo regno we were generated for.\n   3rd operand: the decl for the object in the register, for\n     put_reg_in_stack.  */\n\nDEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", 'o')\n\n/* =====================================================================\n   A QUEUED expression really points to a member of the queue of instructions\n   to be output later for postincrement/postdecrement.\n   QUEUED expressions never become part of instructions.\n   When a QUEUED expression would be put into an instruction,\n   instead either the incremented variable or a copy of its previous\n   value is used.\n\n   Operands are:\n   0. the variable to be incremented (a REG rtx).\n   1. the incrementing instruction, or 0 if it hasn't been output yet.\n   2. A REG rtx for a copy of the old value of the variable, or 0 if none yet.\n   3. the body to use for the incrementing instruction\n   4. the next QUEUED expression in the queue.\n   ====================================================================== */\n\nDEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", 'x')\n\n/* ----------------------------------------------------------------------\n   Expressions for operators in an rtl pattern\n   ---------------------------------------------------------------------- */\n\n/* if_then_else.  This is used in representing ordinary\n   conditional jump instructions.\n     Operand:\n     0:  condition\n     1:  then expr\n     2:  else expr */\nDEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", '3')\n\n/* General conditional. The first operand is a vector composed of pairs of\n   expressions.  The first element of each pair is evaluated, in turn.\n   The value of the conditional is the second expression of the first pair\n   whose first expression evaluates nonzero.  If none of the expressions is\n   true, the second operand will be used as the value of the conditional.\n\n   This should be replaced with use of IF_THEN_ELSE.  */\nDEF_RTL_EXPR(COND, \"cond\", \"Ee\", 'x')\n\n/* Comparison, produces a condition code result.  */\nDEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", '2')\n\n/* plus */\nDEF_RTL_EXPR(PLUS, \"plus\", \"ee\", 'c')\n\n/* Operand 0 minus operand 1.  */\nDEF_RTL_EXPR(MINUS, \"minus\", \"ee\", '2')\n\n/* Minus operand 0.  */\nDEF_RTL_EXPR(NEG, \"neg\", \"e\", '1')\n\nDEF_RTL_EXPR(MULT, \"mult\", \"ee\", 'c')\n\n/* Operand 0 divided by operand 1.  */\nDEF_RTL_EXPR(DIV, \"div\", \"ee\", '2')\n/* Remainder of operand 0 divided by operand 1.  */\nDEF_RTL_EXPR(MOD, \"mod\", \"ee\", '2')\n\n/* Unsigned divide and remainder.  */\nDEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", '2')\nDEF_RTL_EXPR(UMOD, \"umod\", \"ee\", '2')\n\n/* Bitwise operations.  */\nDEF_RTL_EXPR(AND, \"and\", \"ee\", 'c')\n\nDEF_RTL_EXPR(IOR, \"ior\", \"ee\", 'c')\n\nDEF_RTL_EXPR(XOR, \"xor\", \"ee\", 'c')\n\nDEF_RTL_EXPR(NOT, \"not\", \"e\", '1')\n\n/* Operand:\n     0:  value to be shifted.\n     1:  number of bits.  */\nDEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", '2') /* shift left */\nDEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", '2') /* rotate left */\nDEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", '2') /* arithmetic shift right */\nDEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", '2') /* logical shift right */\nDEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", '2') /* rotate right */\n\n/* Minimum and maximum values of two operands.  We need both signed and\n   unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n   with a macro of the same name.) */\n\nDEF_RTL_EXPR(SMIN, \"smin\", \"ee\", 'c')\nDEF_RTL_EXPR(SMAX, \"smax\", \"ee\", 'c')\nDEF_RTL_EXPR(UMIN, \"umin\", \"ee\", 'c')\nDEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n\n/* These unary operations are used to represent incrementation\n   and decrementation as they occur in memory addresses.\n   The amount of increment or decrement are not represented\n   because they can be understood from the machine-mode of the\n   containing MEM.  These operations exist in only two cases:\n   1. pushes onto the stack.\n   2. created automatically by the life_analysis pass in flow.c.  */\nDEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'a')\nDEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'a')\nDEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'a')\nDEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'a')\n\n/* These binary operations are used to represent generic address\n   side-effects in memory addresses, except for simple incrementation\n   or decrementation which use the above operations.  They are\n   created automatically by the life_analysis pass in flow.c.\n   The first operand is a REG which is used as the address.\n   The second operand is an expression that is assigned to the\n   register, either before (PRE_MODIFY) or after (POST_MODIFY)\n   evaluating the address.\n   Currently, the compiler can only handle second operands of the\n   form (plus (reg) (reg)) and (plus (reg) (const_int)), where\n   the first operand of the PLUS has to be the same register as\n   the first operand of the *_MODIFY.  */\nDEF_RTL_EXPR(PRE_MODIFY, \"pre_modify\", \"ee\", 'a')\nDEF_RTL_EXPR(POST_MODIFY, \"post_modify\", \"ee\", 'a')\n\n/* Comparison operations.  The ordered comparisons exist in two\n   flavors, signed and unsigned.  */\nDEF_RTL_EXPR(NE, \"ne\", \"ee\", '<')\nDEF_RTL_EXPR(EQ, \"eq\", \"ee\", '<')\nDEF_RTL_EXPR(GE, \"ge\", \"ee\", '<')\nDEF_RTL_EXPR(GT, \"gt\", \"ee\", '<')\nDEF_RTL_EXPR(LE, \"le\", \"ee\", '<')\nDEF_RTL_EXPR(LT, \"lt\", \"ee\", '<')\nDEF_RTL_EXPR(GEU, \"geu\", \"ee\", '<')\nDEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\nDEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\nDEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n\n/* Additional floating point unordered comparison flavors.  */\nDEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\nDEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n\n/* These are equivalent to unordered or ...  */\nDEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", '<')\nDEF_RTL_EXPR(UNGE, \"unge\", \"ee\", '<')\nDEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", '<')\nDEF_RTL_EXPR(UNLE, \"unle\", \"ee\", '<')\nDEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", '<')\n\n/* This is an ordered NE, ie !UNEQ, ie false for NaN.  */\nDEF_RTL_EXPR(LTGT, \"ltgt\", \"ee\", '<')\n\n/* Represents the result of sign-extending the sole operand.\n   The machine modes of the operand and of the SIGN_EXTEND expression\n   determine how much sign-extension is going on.  */\nDEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", '1')\n\n/* Similar for zero-extension (such as unsigned short to int).  */\nDEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", '1')\n\n/* Similar but here the operand has a wider mode.  */\nDEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", '1')\n\n/* Similar for extending floating-point values (such as SFmode to DFmode).  */\nDEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", '1')\nDEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", '1')\n\n/* Conversion of fixed point operand to floating point value.  */\nDEF_RTL_EXPR(FLOAT, \"float\", \"e\", '1')\n\n/* With fixed-point machine mode:\n   Conversion of floating point operand to fixed point value.\n   Value is defined only when the operand's value is an integer.\n   With floating-point machine mode (and operand with same mode):\n   Operand is rounded toward zero to produce an integer value\n   represented in floating point.  */\nDEF_RTL_EXPR(FIX, \"fix\", \"e\", '1')\n\n/* Conversion of unsigned fixed point operand to floating point value.  */\nDEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", '1')\n\n/* With fixed-point machine mode:\n   Conversion of floating point operand to *unsigned* fixed point value.\n   Value is defined only when the operand's value is an integer.  */\nDEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", '1')\n\n/* Absolute value */\nDEF_RTL_EXPR(ABS, \"abs\", \"e\", '1')\n\n/* Square root */\nDEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", '1')\n\n/* Find first bit that is set.\n   Value is 1 + number of trailing zeros in the arg.,\n   or 0 if arg is 0.  */\nDEF_RTL_EXPR(FFS, \"ffs\", \"e\", '1')\n\n/* Count leading zeros.  */\nDEF_RTL_EXPR(CLZ, \"clz\", \"e\", '1')\n\n/* Count trailing zeros.  */\nDEF_RTL_EXPR(CTZ, \"ctz\", \"e\", '1')\n\n/* Population count (number of 1 bits).  */\nDEF_RTL_EXPR(POPCOUNT, \"popcount\", \"e\", '1')\n\n/* Population parity (number of 1 bits modulo 2).  */\nDEF_RTL_EXPR(PARITY, \"parity\", \"e\", '1')\n\n/* Reference to a signed bit-field of specified size and position.\n   Operand 0 is the memory unit (usually SImode or QImode) which\n   contains the field's first bit.  Operand 1 is the width, in bits.\n   Operand 2 is the number of bits in the memory unit before the\n   first bit of this field.\n   If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n   operand 2 counts from the msb of the memory unit.\n   Otherwise, the first bit is the lsb and operand 2 counts from\n   the lsb of the memory unit.  */\nDEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", 'b')\n\n/* Similar for unsigned bit-field.  */\nDEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", 'b')\n\n/* For RISC machines.  These save memory when splitting insns.  */\n\n/* HIGH are the high-order bits of a constant expression.  */\nDEF_RTL_EXPR(HIGH, \"high\", \"e\", 'o')\n\n/* LO_SUM is the sum of a register and the low-order bits\n   of a constant expression.  */\nDEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n\n/* Header for range information.  Operand 0 is the NOTE_INSN_RANGE_BEG insn.\n   Operand 1 is the NOTE_INSN_RANGE_END insn.  Operand 2 is a vector of all of\n   the registers that can be substituted within this range.  Operand 3 is the\n   number of calls in the range.  Operand 4 is the number of insns in the\n   range.  Operand 5 is the unique range number for this range.  Operand 6 is\n   the basic block # of the start of the live range.  Operand 7 is the basic\n   block # of the end of the live range.  Operand 8 is the loop depth.  Operand\n   9 is a bitmap of the registers live at the start of the range.  Operand 10\n   is a bitmap of the registers live at the end of the range.  Operand 11 is\n   marker number for the start of the range.  Operand 12 is the marker number\n   for the end of the range.  */\nDEF_RTL_EXPR(RANGE_INFO, \"range_info\", \"uuEiiiiiibbii\", 'x')\n\n/* Registers that can be substituted within the range.  Operand 0 is the\n   original pseudo register number.  Operand 1 will be filled in with the\n   pseudo register the value is copied for the duration of the range.  Operand\n   2 is the number of references within the range to the register.  Operand 3\n   is the number of sets or clobbers of the register in the range.  Operand 4\n   is the number of deaths the register has.  Operand 5 is the copy flags that\n   give the status of whether a copy is needed from the original register to\n   the new register at the beginning of the range, or whether a copy from the\n   new register back to the original at the end of the range.  Operand 6 is the\n   live length.  Operand 7 is the number of calls that this register is live\n   across.  Operand 8 is the symbol node of the variable if the register is a\n   user variable.  Operand 9 is the block node that the variable is declared\n   in if the register is a user variable.  */\nDEF_RTL_EXPR(RANGE_REG, \"range_reg\", \"iiiiiiiitt\", 'x')\n\n/* Information about a local variable's ranges.  Operand 0 is an EXPR_LIST of\n   the different ranges a variable is in where it is copied to a different\n   pseudo register.  Operand 1 is the block that the variable is declared in.\n   Operand 2 is the number of distinct ranges.  */\nDEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", 'x')\n\n/* Information about the registers that are live at the current point.  Operand\n   0 is the live bitmap.  Operand 1 is the original block number.  */\nDEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", 'x')\n\n/* A unary `__builtin_constant_p' expression.  These are only emitted\n   during RTL generation, and then only if optimize > 0.  They are\n   eliminated by the first CSE pass.  */\nDEF_RTL_EXPR(CONSTANT_P_RTX, \"constant_p_rtx\", \"e\", 'x')\n\n/* A placeholder for a CALL_INSN which may be turned into a normal call,\n   a sibling (tail) call or tail recursion.\n\n   Immediately after RTL generation, this placeholder will be replaced\n   by the insns to perform the call, sibcall or tail recursion.\n\n   This RTX has 4 operands.  The first three are lists of instructions to\n   perform the call as a normal call, sibling call and tail recursion\n   respectively.  The latter two lists may be NULL, the first may never\n   be NULL.\n\n   The last operand is the tail recursion CODE_LABEL, which may be NULL if no\n   potential tail recursive calls were found.\n\n   The tail recursion label is needed so that we can clear LABEL_PRESERVE_P\n   after we select a call method.\n\n   This method of tail-call elimination is intended to be replaced by\n   tree-based optimizations once front-end conversions are complete.  */\nDEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", 'x')\n\n/* Describes a merge operation between two vector values.\n   Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n   that specifies where the parts of the result are taken from.  Set bits\n   indicate operand 0, clear bits indicate operand 1.  The parts are defined\n   by the mode of the vectors.  */\nDEF_RTL_EXPR(VEC_MERGE, \"vec_merge\", \"eee\", '3')\n\n/* Describes an operation that selects parts of a vector.\n   Operands 0 is the source vector, operand 1 is a PARALLEL that contains\n   a CONST_INT for each of the subparts of the result vector, giving the\n   number of the source subpart that should be stored into it.  */\nDEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", '2')\n\n/* Describes a vector concat operation.  Operands 0 and 1 are the source\n   vectors, the result is a vector that is as long as operands 0 and 1\n   combined and is the concatenation of the two source vectors.  */\nDEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", '2')\n\n/* Describes an operation that converts a small vector into a larger one by\n   duplicating the input values.  The output vector mode must have the same\n   submodes as the input vector mode, and the number of output parts must be\n   an integer multiple of the number of input parts.  */\nDEF_RTL_EXPR(VEC_DUPLICATE, \"vec_duplicate\", \"e\", '1')\n\n/* Addition with signed saturation */\nDEF_RTL_EXPR(SS_PLUS, \"ss_plus\", \"ee\", 'c')\n\n/* Addition with unsigned saturation */\nDEF_RTL_EXPR(US_PLUS, \"us_plus\", \"ee\", 'c')\n\n/* Operand 0 minus operand 1, with signed saturation.  */\nDEF_RTL_EXPR(SS_MINUS, \"ss_minus\", \"ee\", '2')\n\n/* Operand 0 minus operand 1, with unsigned saturation.  */\nDEF_RTL_EXPR(US_MINUS, \"us_minus\", \"ee\", '2')\n\n/* Signed saturating truncate.  */\nDEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", '1')\n\n/* Unsigned saturating truncate.  */\nDEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", '1')\n\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAFE@CTY": {"ttr": 10500, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* <ctype.h> replacement macros.\n\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n   Contributed by Zack Weinberg <zackw@stanford.edu>.\n\nThis file is part of the libiberty library.\nLibiberty is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Library General Public\nLicense as published by the Free Software Foundation; either\nversion 2 of the License, or (at your option) any later version.\n\nLibiberty is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLibrary General Public License for more details.\n\nYou should have received a copy of the GNU Library General Public\nLicense along with libiberty; see the file COPYING.LIB.  If\nnot, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* This is a compatible replacement of the standard C library's <ctype.h>\n   with the following properties:\n\n   - Implements all isxxx() macros required by C99.\n   - Also implements some character classes useful when\n     parsing C-like languages.\n   - Does not change behavior depending on the current locale.\n   - Behaves properly for all values in the range of a signed or\n     unsigned char.\n\n   To avoid conflicts, this header defines the isxxx functions in upper\n   case, e.g. ISALPHA not isalpha.  */\n\n#ifndef SAFE_CTYPE_H\n#define SAFE_CTYPE_H\n\n#ifdef isalpha\n #error \"safe-ctype.h and ctype.h may not be used simultaneously\"\n#endif\n\n/* Determine host character set.  */\n#define HOST_CHARSET_UNKNOWN 0\n#define HOST_CHARSET_ASCII   1\n#define HOST_CHARSET_EBCDIC  2\n\n#if  '\\n' == 0x0A && ' ' == 0x20 && '0' == 0x30 \\\n   && 'A' == 0x41 && 'a' == 0x61 && '!' == 0x21\n#  define HOST_CHARSET HOST_CHARSET_ASCII\n#else\n# if '\\n' == 0x15 && ' ' == 0x40 && '0' == 0xF0 \\\n   && 'A' == 0xC1 && 'a' == 0x81 && '!' == 0x5A\n#  define HOST_CHARSET HOST_CHARSET_EBCDIC\n#  define _sch_istable _sch_ebcistable\n# else\n#  define HOST_CHARSET HOST_CHARSET_UNKNOWN\n# endif\n#endif\n\n/* Categories.  */\n\nenum {\n  /* In C99 */\n  _sch_isblank  = 0x0001,\t/* space \\t */\n  _sch_iscntrl  = 0x0002,\t/* nonprinting characters */\n  _sch_isdigit  = 0x0004,\t/* 0-9 */\n  _sch_islower  = 0x0008,\t/* a-z */\n  _sch_isprint  = 0x0010,\t/* any printing character including ' ' */\n  _sch_ispunct  = 0x0020,\t/* all punctuation */\n  _sch_isspace  = 0x0040,\t/* space \\t \\n \\r \\f \\v */\n  _sch_isupper  = 0x0080,\t/* A-Z */\n  _sch_isxdigit = 0x0100,\t/* 0-9A-Fa-f */\n\n  /* Extra categories useful to cpplib.  */\n  _sch_isidst\t= 0x0200,\t/* A-Za-z_ */\n  _sch_isvsp    = 0x0400,\t/* \\n \\r */\n  _sch_isnvsp   = 0x0800,\t/* space \\t \\f \\v \\0 */\n\n  /* Combinations of the above.  */\n  _sch_isalpha  = _sch_isupper|_sch_islower,\t/* A-Za-z */\n  _sch_isalnum  = _sch_isalpha|_sch_isdigit,\t/* A-Za-z0-9 */\n  _sch_isidnum  = _sch_isidst|_sch_isdigit,\t/* A-Za-z0-9_ */\n  _sch_isgraph  = _sch_isalnum|_sch_ispunct,\t/* isprint and not space */\n  _sch_iscppsp  = _sch_isvsp|_sch_isnvsp,\t/* isspace + \\0 */\n  _sch_isbasic  = _sch_isprint|_sch_iscppsp     /* basic charset of ISO C\n\t\t\t\t\t\t   (plus ` and @)  */\n};\n\n/* Character classification.  */\nextern const unsigned short _sch_istable\u00dd256\u00a8;\n\n#define _sch_test(c, bit) (_sch_istable\u00dd(c) & 0xff\u00a8 & (unsigned short)(bit))\n\n#define ISALPHA(c)  _sch_test(c, _sch_isalpha)\n#define ISALNUM(c)  _sch_test(c, _sch_isalnum)\n#define ISBLANK(c)  _sch_test(c, _sch_isblank)\n#define ISCNTRL(c)  _sch_test(c, _sch_iscntrl)\n#define ISDIGIT(c)  _sch_test(c, _sch_isdigit)\n#define ISGRAPH(c)  _sch_test(c, _sch_isgraph)\n#define ISLOWER(c)  _sch_test(c, _sch_islower)\n#define ISPRINT(c)  _sch_test(c, _sch_isprint)\n#define ISPUNCT(c)  _sch_test(c, _sch_ispunct)\n#define ISSPACE(c)  _sch_test(c, _sch_isspace)\n#define ISUPPER(c)  _sch_test(c, _sch_isupper)\n#define ISXDIGIT(c) _sch_test(c, _sch_isxdigit)\n\n#define ISIDNUM(c)\t_sch_test(c, _sch_isidnum)\n#define ISIDST(c)\t_sch_test(c, _sch_isidst)\n#define IS_ISOBASIC(c)\t_sch_test(c, _sch_isbasic)\n#define IS_VSPACE(c)\t_sch_test(c, _sch_isvsp)\n#define IS_NVSPACE(c)\t_sch_test(c, _sch_isnvsp)\n#define IS_SPACE_OR_NUL(c)\t_sch_test(c, _sch_iscppsp)\n\n/* Character transformation.  */\nextern const unsigned char  _sch_toupper\u00dd256\u00a8;\nextern const unsigned char  _sch_tolower\u00dd256\u00a8;\n#define TOUPPER(c) _sch_toupper\u00dd(c) & 0xff\u00a8\n#define TOLOWER(c) _sch_tolower\u00dd(c) & 0xff\u00a8\n\n/* Character conversion.  */\nextern const unsigned char _sch_ebcasc\u00dd256\u00a8;\nextern const unsigned char _sch_ascebc\u00dd256\u00a8;\n#define EBCTOASC(c) _sch_ebcasc\u00dd(c) & 0xff\u00a8\n#define ASCTOEBC(c) _sch_ascebc\u00dd(c) & 0xff\u00a8\n\nextern const unsigned short _sch_ebcistable\u00dd256\u00a8;\n#define _sch_ebctest(c, bit) \\\n  (_sch_ebcistable\u00dd(c) & 0xff\u00a8 & (unsigned short)(bit))\n\n#define ISEBCCNTRL(c) _sch_ebctest(c, _sch_iscntrl)\n\n#endif /* SAFE_CTYPE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SBITMAP": {"ttr": 10502, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Simple bitmaps.\n   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_SBITMAP_H\n#define GCC_SBITMAP_H\n\n/* It's not clear yet whether using bitmap.\u00ddch\u00a8 will be a win.\n   It should be straightforward to convert so for now we keep things simple\n   while more important issues are dealt with.  */\n\n#define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDE_INT)\n#define SBITMAP_ELT_TYPE unsigned HOST_WIDE_INT\n\ntypedef struct simple_bitmap_def\n{\n  unsigned int n_bits;\t\t/* Number of bits.  */\n  unsigned int size;\t\t/* Size in elements.  */\n  unsigned int bytes;\t\t/* Size in bytes.  */\n  SBITMAP_ELT_TYPE elms\u00dd1\u00a8;\t/* The elements.  */\n} *sbitmap;\n\ntypedef SBITMAP_ELT_TYPE *sbitmap_ptr;\n\n/* Return the set size needed for N elements.  */\n#define SBITMAP_SET_SIZE(N) (((N) + SBITMAP_ELT_BITS - 1) / SBITMAP_ELT_BITS)\n\n/* Set bit number bitno in the bitmap.  */\n#define SET_BIT(BITMAP, BITNO)\t\t\t\t\t\\\n  ((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8\t\t\t\\\n   |= (SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS)\n\n/* Test if bit number bitno in the bitmap is set.  */\n#define TEST_BIT(BITMAP, BITNO) \\\n((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8 >> (BITNO) % SBITMAP_ELT_BITS & 1)\n\n/* Reset bit number bitno in the bitmap.  */\n#define RESET_BIT(BITMAP, BITNO)\t\t\t\t\\\n  ((BITMAP)->elms \u00dd(BITNO) / SBITMAP_ELT_BITS\u00a8\t\t\t\\\n   &= ~((SBITMAP_ELT_TYPE) 1 << (BITNO) % SBITMAP_ELT_BITS))\n\n/* Loop over all elements of SBITSET, starting with MIN.  */\n#define EXECUTE_IF_SET_IN_SBITMAP(SBITMAP, MIN, N, CODE)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  unsigned int word_num_;\t\t\t\t\t\t\\\n  unsigned int bit_num_ = (MIN) % (unsigned int) SBITMAP_ELT_BITS;\t\\\n  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (word_num_ = (MIN) / (unsigned int) SBITMAP_ELT_BITS;\t\t\\\n       word_num_ < size_; word_num_++, bit_num_ = 0)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      SBITMAP_ELT_TYPE word_ = ptr_\u00ddword_num_\u00a8;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      if (word_ != 0)\t\t\t\t\t\t\t\\\n\tfor (; bit_num_ < SBITMAP_ELT_BITS; bit_num_++)\t\t\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    SBITMAP_ELT_TYPE _mask = (SBITMAP_ELT_TYPE) 1 << bit_num_;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    if ((word_ & _mask) != 0)\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tword_ &= ~ _mask;\t\t\t\t\t\\\n\t\t(N) = word_num_ * SBITMAP_ELT_BITS + bit_num_;\t\t\\\n\t\tCODE;\t\t\t\t\t\t\t\\\n\t\tif (word_ == 0)\t\t\t\t\t\t\\\n\t\t  break;\t\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define EXECUTE_IF_SET_IN_SBITMAP_REV(SBITMAP, N, CODE)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  unsigned int word_num_;\t\t\t\t\t\t\\\n  unsigned int bit_num_;\t\t\t\t\t\t\\\n  unsigned int size_ = (SBITMAP)->size;\t\t\t\t\t\\\n  SBITMAP_ELT_TYPE *ptr_ = (SBITMAP)->elms;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  for (word_num_ = size_; word_num_ > 0; word_num_--)\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\\\n      SBITMAP_ELT_TYPE word_ = ptr_\u00ddword_num_ - 1\u00a8;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n      if (word_ != 0)\t\t\t\t\t\t\t\\\n\tfor (bit_num_ = SBITMAP_ELT_BITS; bit_num_ > 0; bit_num_--)\t\\\n\t  {\t\t\t\t\t\t\t\t\\\n\t    SBITMAP_ELT_TYPE _mask = (SBITMAP_ELT_TYPE)1 << (bit_num_ - 1);\\\n\t\t\t\t\t\t\t\t\t\\\n\t    if ((word_ & _mask) != 0)\t\t\t\t\t\\\n\t      {\t\t\t\t\t\t\t\t\\\n\t\tword_ &= ~ _mask;\t\t\t\t\t\\\n\t\t(N) = (word_num_ - 1) * SBITMAP_ELT_BITS + bit_num_ - 1;\\\n\t\tCODE;\t\t\t\t\t\t\t\\\n\t\tif (word_ == 0)\t\t\t\t\t\t\\\n\t\t  break;\t\t\t\t\t\t\\\n\t      }\t\t\t\t\t\t\t\t\\\n\t  }\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define sbitmap_free(MAP)\t\tfree(MAP)\n#define sbitmap_vector_free(VEC)\tfree(VEC)\n\nstruct int_list;\n\nextern void dump_sbitmap (FILE *, sbitmap);\nextern void dump_sbitmap_file (FILE *, sbitmap);\nextern void dump_sbitmap_vector (FILE *, const char *, const char *, sbitmap *,\n\t\t\t\t int);\nextern sbitmap sbitmap_alloc (unsigned int);\nextern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\nextern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\nextern void sbitmap_copy (sbitmap, sbitmap);\nextern int sbitmap_equal (sbitmap, sbitmap);\nextern void sbitmap_zero (sbitmap);\nextern void sbitmap_ones (sbitmap);\nextern void sbitmap_vector_zero (sbitmap *, unsigned int);\nextern void sbitmap_vector_ones (sbitmap *, unsigned int);\n\nextern void sbitmap_union_of_diff (sbitmap, sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_union_of_diff_cg (sbitmap, sbitmap, sbitmap, sbitmap);\nextern void sbitmap_difference (sbitmap, sbitmap, sbitmap);\nextern void sbitmap_not (sbitmap, sbitmap);\nextern void sbitmap_a_or_b_and_c (sbitmap, sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_or_b_and_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);\nextern void sbitmap_a_and_b_or_c (sbitmap, sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_and_b_or_c_cg (sbitmap, sbitmap, sbitmap, sbitmap);\nextern void sbitmap_a_and_b (sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_and_b_cg (sbitmap, sbitmap, sbitmap);\nextern void sbitmap_a_or_b (sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_or_b_cg (sbitmap, sbitmap, sbitmap);\nextern void sbitmap_a_xor_b (sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_xor_b_cg (sbitmap, sbitmap, sbitmap);\nextern bool sbitmap_a_subset_b_p (sbitmap, sbitmap);\n\nextern int sbitmap_first_set_bit (sbitmap);\nextern int sbitmap_last_set_bit (sbitmap);\n\nextern void sbitmap_intersect_of_predsucc (sbitmap, sbitmap *, int,\n\t\t\t\t\t   struct int_list **);\n#define sbitmap_intersect_of_predecessors  sbitmap_intersect_of_predsucc\n#define sbitmap_intersect_of_successors    sbitmap_intersect_of_predsucc\n\nextern void sbitmap_union_of_predsucc (sbitmap, sbitmap *, int,\n\t\t\t\t       struct int_list **);\n#define sbitmap_union_of_predecessors  sbitmap_union_of_predsucc\n#define sbitmap_union_of_successors    sbitmap_union_of_predsucc\n\n/* Intersection and Union of preds/succs using the new flow graph\n   structure instead of the pred/succ arrays.  */\n\nextern void sbitmap_intersection_of_succs (sbitmap, sbitmap *, int);\nextern void sbitmap_intersection_of_preds (sbitmap, sbitmap *, int);\nextern void sbitmap_union_of_succs (sbitmap, sbitmap *, int);\nextern void sbitmap_union_of_preds (sbitmap, sbitmap *, int);\n\nextern void debug_sbitmap (sbitmap);\n#endif /* ! GCC_SBITMAP_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCAN": {"ttr": 10505, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* scan.h - Utility declarations for scan-decls and fix-header programs.\n   Copyright (C) 1993, 1998, 1999, 2003 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#include <stdio.h>\n\ntypedef struct sstring\n{\n  char *base;\n  char *ptr;\n  char *limit;\n} sstring;\n\n#define INIT_SSTRING(STR) ((STR)->base = 0, (STR)->ptr = 0, (STR)->limit = 0)\n#define FREE_SSTRING(STR) do { if ((STR)->base) free (STR)->base; } while(0)\n#define SSTRING_PUT(STR, C) do {\\\n  if ((STR)->limit <= (STR)->ptr) make_sstring_space (STR, 1); \\\n  *(STR)->ptr++ = (C); } while (0)\n#define SSTRING_LENGTH(STR) ((STR)->ptr - (STR)->base)\n#define MAKE_SSTRING_SPACE(STR, COUNT) \\\n  if ((STR)->limit - (STR)->ptr < (COUNT)) make_sstring_space (STR, COUNT);\n\nstruct partial_proto;\nstruct fn_decl\n{\n  const char *fname;\n  const char *rtype;\n  const char *params;\n  struct partial_proto *partial;\n};\n\nstruct cpp_token;\n\nextern void sstring_append (sstring *, sstring *);\nextern void make_sstring_space (sstring *, int);\nextern int skip_spaces (FILE *, int);\nextern int scan_ident (FILE *, sstring *, int);\nextern int scan_string (FILE *, sstring *, int);\nextern int read_upto (FILE *, sstring *, int);\nextern unsigned long hash (const char *);\nextern void recognized_function (const struct cpp_token *,\n\t\t\t\t unsigned int, int, int);\nextern void recognized_extern (const struct cpp_token *);\nextern unsigned int hashstr (const char *, unsigned int);\n\nextern int scan_decls (struct cpp_reader *, int, char **);\n\n/* get_token is a simple C lexer.  */\n#define IDENTIFIER_TOKEN 300\n#define CHAR_TOKEN 301\n#define STRING_TOKEN 302\n#define INT_TOKEN 303\nextern int get_token (FILE *, sstring *);\n\n/* Current file and line numer, taking #-directives into account */\nextern int source_lineno;\nextern sstring source_filename;\n/* Current physical line number */\nextern int lineno;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCHED@IN": {"ttr": 10507, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Instruction scheduling pass.  This file contains definitions used\n   internally in the scheduler.\n   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Pointer to data describing the current DFA state.  */\nextern state_t curr_state;\n\n/* Forward declaration.  */\nstruct ready_list;\n\n/* Describe state of dependencies used during sched_analyze phase.  */\nstruct deps\n{\n  /* The *_insns and *_mems are paired lists.  Each pending memory operation\n     will have a pointer to the MEM rtx on one list and a pointer to the\n     containing insn on the other list in the same place in the list.  */\n\n  /* We can't use add_dependence like the old code did, because a single insn\n     may have multiple memory accesses, and hence needs to be on the list\n     once for each memory access.  Add_dependence won't let you add an insn\n     to a list more than once.  */\n\n  /* An INSN_LIST containing all insns with pending read operations.  */\n  rtx pending_read_insns;\n\n  /* An EXPR_LIST containing all MEM rtx's which are pending reads.  */\n  rtx pending_read_mems;\n\n  /* An INSN_LIST containing all insns with pending write operations.  */\n  rtx pending_write_insns;\n\n  /* An EXPR_LIST containing all MEM rtx's which are pending writes.  */\n  rtx pending_write_mems;\n\n  /* Indicates the combined length of the two pending lists.  We must prevent\n     these lists from ever growing too large since the number of dependencies\n     produced is at least O(N*N), and execution time is at least O(4*N*N), as\n     a function of the length of these pending lists.  */\n  int pending_lists_length;\n\n  /* Length of the pending memory flush list. Large functions with no\n     calls may build up extremely large lists.  */\n  int pending_flush_length;\n\n  /* The last insn upon which all memory references must depend.\n     This is an insn which flushed the pending lists, creating a dependency\n     between it and all previously pending memory references.  This creates\n     a barrier (or a checkpoint) which no memory reference is allowed to cross.\n\n     This includes all non constant CALL_INSNs.  When we do interprocedural\n     alias analysis, this restriction can be relaxed.\n     This may also be an INSN that writes memory if the pending lists grow\n     too large.  */\n  rtx last_pending_memory_flush;\n\n  /* A list of the last function calls we have seen.  We use a list to\n     represent last function calls from multiple predecessor blocks.\n     Used to prevent register lifetimes from expanding unnecessarily.  */\n  rtx last_function_call;\n\n  /* A list of insns which use a pseudo register that does not already\n     cross a call.  We create dependencies between each of those insn\n     and the next call insn, to ensure that they won't cross a call after\n     scheduling is done.  */\n  rtx sched_before_next_call;\n\n  /* Used to keep post-call pseudo/hard reg movements together with\n     the call.  */\n  bool in_post_call_group_p;\n\n  /* Set to the tail insn of the outermost libcall block.\n\n     When nonzero, we will mark each insn processed by sched_analyze_insn\n     with SCHED_GROUP_P to ensure libcalls are scheduled as a unit.  */\n  rtx libcall_block_tail_insn;\n\n  /* The maximum register number for the following arrays.  Before reload\n     this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n  int max_reg;\n\n  /* Element N is the next insn that sets (hard or pseudo) register\n     N within the current basic block; or zero, if there is no\n     such insn.  Needed for new registers which may be introduced\n     by splitting insns.  */\n  struct deps_reg\n    {\n      rtx uses;\n      rtx sets;\n      rtx clobbers;\n      int uses_length;\n      int clobbers_length;\n    } *reg_last;\n\n  /* Element N is set for each register that has any nonzero element\n     in reg_last\u00ddN\u00a8.{uses,sets,clobbers}.  */\n  regset_head reg_last_in_use;\n\n  /* Element N is set for each register that is conditionally set.  */\n  regset_head reg_conditional_sets;\n};\n\n/* This structure holds some state of the current scheduling pass, and\n   contains some function pointers that abstract out some of the non-generic\n   functionality from functions such as schedule_block or schedule_insn.\n   There is one global variable, current_sched_info, which points to the\n   sched_info structure currently in use.  */\nstruct sched_info\n{\n  /* Add all insns that are initially ready to the ready list.  Called once\n     before scheduling a set of insns.  */\n  void (*init_ready_list) (struct ready_list *);\n  /* Called after taking an insn from the ready list.  Returns nonzero if\n     this insn can be scheduled, nonzero if we should silently discard it.  */\n  int (*can_schedule_ready_p) (rtx);\n  /* Return nonzero if there are more insns that should be scheduled.  */\n  int (*schedule_more_p) (void);\n  /* Called after an insn has all its dependencies resolved.  Return nonzero\n     if it should be moved to the ready list or the queue, or zero if we\n     should silently discard it.  */\n  int (*new_ready) (rtx);\n  /* Compare priority of two insns.  Return a positive number if the second\n     insn is to be preferred for scheduling, and a negative one if the first\n     is to be preferred.  Zero if they are equally good.  */\n  int (*rank) (rtx, rtx);\n  /* Return a string that contains the insn uid and optionally anything else\n     necessary to identify this insn in an output.  It's valid to use a\n     static buffer for this.  The ALIGNED parameter should cause the string\n     to be formatted so that multiple output lines will line up nicely.  */\n  const char *(*print_insn) (rtx, int);\n  /* Return nonzero if an insn should be included in priority\n     calculations.  */\n  int (*contributes_to_priority) (rtx, rtx);\n  /* Called when computing dependencies for a JUMP_INSN.  This function\n     should store the set of registers that must be considered as set by\n     the jump in the regset.  */\n  void (*compute_jump_reg_dependencies) (rtx, regset, regset, regset);\n\n  /* The boundaries of the set of insns to be scheduled.  */\n  rtx prev_head, next_tail;\n\n  /* Filled in after the schedule is finished; the first and last scheduled\n     insns.  */\n  rtx head, tail;\n\n  /* If nonzero, enables an additional sanity check in schedule_block.  */\n  unsigned int queue_must_finish_empty:1;\n  /* Nonzero if we should use cselib for better alias analysis.  This\n     must be 0 if the dependency information is used after sched_analyze\n     has completed, e.g. if we're using it to initialize state for successor\n     blocks in region scheduling.  */\n  unsigned int use_cselib:1;\n\n  /* Maximum priority that has been assigned to an insn.  */\n  int sched_max_insns_priority;\n};\n\nextern struct sched_info *current_sched_info;\n\n/* Indexed by INSN_UID, the collection of all data associated with\n   a single instruction.  */\n\nstruct haifa_insn_data\n{\n  /* A list of insns which depend on the instruction.  Unlike LOG_LINKS,\n     it represents forward dependencies.  */\n  rtx depend;\n\n  /* The line number note in effect for each insn.  For line number\n     notes, this indicates whether the note may be reused.  */\n  rtx line_note;\n\n  /* Logical uid gives the original ordering of the insns.  */\n  int luid;\n\n  /* A priority for each insn.  */\n  int priority;\n\n  /* The number of incoming edges in the forward dependency graph.\n     As scheduling proceeds, counts are decreased.  An insn moves to\n     the ready queue when its counter reaches zero.  */\n  int dep_count;\n\n  /* An encoding of the blockage range function.  Both unit and range\n     are coded.  This member is used only for old pipeline interface.  */\n  unsigned int blockage;\n\n  /* Number of instructions referring to this insn.  */\n  int ref_count;\n\n  /* The minimum clock tick at which the insn becomes ready.  This is\n     used to note timing constraints for the insns in the pending list.  */\n  int tick;\n\n  short cost;\n\n  /* An encoding of the function units used.  This member is used only\n     for old pipeline interface.  */\n  short units;\n\n  /* This weight is an estimation of the insn's contribution to\n     register pressure.  */\n  short reg_weight;\n\n  /* Some insns (e.g. call) are not allowed to move across blocks.  */\n  unsigned int cant_move : 1;\n\n  /* Set if there's DEF-USE dependence between some speculatively\n     moved load insn and this one.  */\n  unsigned int fed_by_spec_load : 1;\n  unsigned int is_load_insn : 1;\n\n  /* Nonzero if priority has been computed already.  */\n  unsigned int priority_known : 1;\n};\n\nextern struct haifa_insn_data *h_i_d;\n\n/* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n   sched-rgn.c.  */\n#define INSN_DEPEND(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.depend)\n#define INSN_LUID(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.luid)\n#define CANT_MOVE(insn)\t\t(h_i_d\u00ddINSN_UID (insn)\u00a8.cant_move)\n#define INSN_DEP_COUNT(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.dep_count)\n#define INSN_PRIORITY(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.priority)\n#define INSN_PRIORITY_KNOWN(INSN) (h_i_d\u00ddINSN_UID (INSN)\u00a8.priority_known)\n#define INSN_COST(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.cost)\n#define INSN_UNIT(INSN)\t\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.units)\n#define INSN_REG_WEIGHT(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.reg_weight)\n\n#define INSN_BLOCKAGE(INSN)\t(h_i_d\u00ddINSN_UID (INSN)\u00a8.blockage)\n#define UNIT_BITS\t\t5\n#define BLOCKAGE_MASK\t\t((1 << BLOCKAGE_BITS) - 1)\n#define ENCODE_BLOCKAGE(U, R)\t\t\t\\\n  (((U) << BLOCKAGE_BITS\t\t\t\\\n    | MIN_BLOCKAGE_COST (R)) << BLOCKAGE_BITS\t\\\n   | MAX_BLOCKAGE_COST (R))\n#define UNIT_BLOCKED(B)\t\t((B) >> (2 * BLOCKAGE_BITS))\n#define BLOCKAGE_RANGE(B)                                                \\\n  (((((B) >> BLOCKAGE_BITS) & BLOCKAGE_MASK) << (HOST_BITS_PER_INT / 2)) \\\n   | ((B) & BLOCKAGE_MASK))\n\n/* Encodings of the `<name>_unit_blockage_range' function.  */\n#define MIN_BLOCKAGE_COST(R) ((R) >> (HOST_BITS_PER_INT / 2))\n#define MAX_BLOCKAGE_COST(R) ((R) & ((1 << (HOST_BITS_PER_INT / 2)) - 1))\n\nextern FILE *sched_dump;\nextern int sched_verbose;\n\n/* Exception Free Loads:\n\n   We define five classes of speculative loads: IFREE, IRISKY,\n   PFREE, PRISKY, and MFREE.\n\n   IFREE loads are loads that are proved to be exception-free, just\n   by examining the load insn.  Examples for such loads are loads\n   from TOC and loads of global data.\n\n   IRISKY loads are loads that are proved to be exception-risky,\n   just by examining the load insn.  Examples for such loads are\n   volatile loads and loads from shared memory.\n\n   PFREE loads are loads for which we can prove, by examining other\n   insns, that they are exception-free.  Currently, this class consists\n   of loads for which we are able to find a \"similar load\", either in\n   the target block, or, if only one split-block exists, in that split\n   block.  Load2 is similar to load1 if both have same single base\n   register.  We identify only part of the similar loads, by finding\n   an insn upon which both load1 and load2 have a DEF-USE dependence.\n\n   PRISKY loads are loads for which we can prove, by examining other\n   insns, that they are exception-risky.  Currently we have two proofs for\n   such loads.  The first proof detects loads that are probably guarded by a\n   test on the memory address.  This proof is based on the\n   backward and forward data dependence information for the region.\n   Let load-insn be the examined load.\n   Load-insn is PRISKY iff ALL the following hold:\n\n   - insn1 is not in the same block as load-insn\n   - there is a DEF-USE dependence chain (insn1, ..., load-insn)\n   - test-insn is either a compare or a branch, not in the same block\n     as load-insn\n   - load-insn is reachable from test-insn\n   - there is a DEF-USE dependence chain (insn1, ..., test-insn)\n\n   This proof might fail when the compare and the load are fed\n   by an insn not in the region.  To solve this, we will add to this\n   group all loads that have no input DEF-USE dependence.\n\n   The second proof detects loads that are directly or indirectly\n   fed by a speculative load.  This proof is affected by the\n   scheduling process.  We will use the flag  fed_by_spec_load.\n   Initially, all insns have this flag reset.  After a speculative\n   motion of an insn, if insn is either a load, or marked as\n   fed_by_spec_load, we will also mark as fed_by_spec_load every\n   insn1 for which a DEF-USE dependence (insn, insn1) exists.  A\n   load which is fed_by_spec_load is also PRISKY.\n\n   MFREE (maybe-free) loads are all the remaining loads. They may be\n   exception-free, but we cannot prove it.\n\n   Now, all loads in IFREE and PFREE classes are considered\n   exception-free, while all loads in IRISKY and PRISKY classes are\n   considered exception-risky.  As for loads in the MFREE class,\n   these are considered either exception-free or exception-risky,\n   depending on whether we are pessimistic or optimistic.  We have\n   to take the pessimistic approach to assure the safety of\n   speculative scheduling, but we can take the optimistic approach\n   by invoking the -fsched_spec_load_dangerous option.  */\n\nenum INSN_TRAP_CLASS\n{\n  TRAP_FREE = 0, IFREE = 1, PFREE_CANDIDATE = 2,\n  PRISKY_CANDIDATE = 3, IRISKY = 4, TRAP_RISKY = 5\n};\n\n#define WORST_CLASS(class1, class2) \\\n((class1 > class2) ? class1 : class2)\n\n#ifndef __GNUC__\n#define __inline\n#endif\n\n#ifndef HAIFA_INLINE\n#define HAIFA_INLINE __inline\n#endif\n\n/* Functions in sched-vis.c.  */\nextern void init_target_units (void);\nextern void insn_print_units (rtx);\nextern void init_block_visualization (void);\nextern void print_block_visualization (const char *);\nextern void visualize_scheduled_insns (int);\nextern void visualize_no_unit (rtx);\nextern void visualize_stall_cycles (int);\nextern void visualize_alloc (void);\nextern void visualize_free (void);\n\n/* Functions in sched-deps.c.  */\nextern int add_dependence (rtx, rtx, enum reg_note);\nextern void add_insn_mem_dependence (struct deps *, rtx *, rtx *, rtx, rtx);\nextern void sched_analyze (struct deps *, rtx, rtx);\nextern void init_deps (struct deps *);\nextern void free_deps (struct deps *);\nextern void init_deps_global (void);\nextern void finish_deps_global (void);\nextern void add_forward_dependence (rtx, rtx, enum reg_note);\nextern void compute_forward_dependences (rtx, rtx);\nextern rtx find_insn_list (rtx, rtx);\nextern void init_dependency_caches (int);\nextern void free_dependency_caches (void);\n\n/* Functions in haifa-sched.c.  */\nextern int haifa_classify_insn (rtx);\nextern void get_block_head_tail (int, rtx *, rtx *);\nextern int no_real_insns_p (rtx, rtx);\n\nextern void rm_line_notes (rtx, rtx);\nextern void save_line_notes (int, rtx, rtx);\nextern void restore_line_notes (rtx, rtx);\nextern void rm_redundant_line_notes (void);\nextern void rm_other_notes (rtx, rtx);\n\nextern int insn_issue_delay (rtx);\nextern int set_priorities (rtx, rtx);\n\nextern rtx sched_emit_insn (rtx);\nextern void schedule_block (int, int);\nextern void sched_init (FILE *);\nextern void sched_finish (void);\n\nextern void ready_add (struct ready_list *, rtx);\n\n/* The following are exported for the benefit of debugging functions.  It\n   would be nicer to keep them private to haifa-sched.c.  */\nextern int insn_unit (rtx);\nextern int insn_cost (rtx, rtx, rtx);\nextern rtx get_unit_last_insn (int);\nextern int actual_hazard_this_instance (int, int, rtx, int, int);\nextern void print_insn (char *, rtx, int);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDBOUT": {"ttr": 10511, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* sdbout.h - Various declarations for functions found in sdbout.c\n   Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern void sdbout_symbol (tree, int);\nextern void sdbout_types (tree);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SORT": {"ttr": 10513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Sorting algorithms.\n   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell <mark@codesourcery.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef SORT_H\n#define SORT_H\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h> /* For size_t */\n#endif\n#ifdef __STDC__\n#include <stddef.h>\n#endif\t/* __STDC__ */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include \"ansidecl.h\"\n\n/* Sort an array of pointers.  */\n\nextern void sort_pointers PARAMS ((size_t, void **, void **));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* SORT_H */\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPECS": {"ttr": 10515, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* empty file */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPLAY@TR": {"ttr": 10753, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* A splay-tree datatype.\n   Copyright 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n   Contributed by Mark Mitchell (mark@markmitchell.com).\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* For an easily readable description of splay-trees, see:\n\n     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n     Algorithms.  Harper-Collins, Inc.  1991.\n\n   The major feature of splay trees is that all basic tree operations\n   are amortized O(log n) time for a tree with n nodes.  */\n\n#ifndef _SPLAY_TREE_H\n#define _SPLAY_TREE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#include \"ansidecl.h\"\n\n#ifndef GTY\n#define GTY(X)\n#endif\n\n/* Use typedefs for the key and data types to facilitate changing\n   these types, if necessary.  These types should be sufficiently wide\n   that any pointer or scalar can be cast to these types, and then\n   cast back, without loss of precision.  */\ntypedef unsigned long int splay_tree_key;\ntypedef unsigned long int splay_tree_value;\n\n/* Forward declaration for a node in the tree.  */\ntypedef struct splay_tree_node_s *splay_tree_node;\n\n/* The type of a function which compares two splay-tree keys.  The\n   function should return values as for qsort.  */\ntypedef int (*splay_tree_compare_fn) PARAMS((splay_tree_key, splay_tree_key));\n\n/* The type of a function used to deallocate any resources associated\n   with the key.  */\ntypedef void (*splay_tree_delete_key_fn) PARAMS((splay_tree_key));\n\n/* The type of a function used to deallocate any resources associated\n   with the value.  */\ntypedef void (*splay_tree_delete_value_fn) PARAMS((splay_tree_value));\n\n/* The type of a function used to iterate over the tree.  */\ntypedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n\n/* The type of a function used to allocate memory for tree root and\n   node structures.  The first argument is the number of bytes needed;\n   the second is a data pointer the splay tree functions pass through\n   to the allocator.  This function must never return zero.  */\ntypedef PTR (*splay_tree_allocate_fn) PARAMS((int, void *));\n\n/* The type of a function used to free memory allocated using the\n   corresponding splay_tree_allocate_fn.  The first argument is the\n   memory to be freed; the latter is a data pointer the splay tree\n   functions pass through to the freer.  */\ntypedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n\n/* The nodes in the splay tree.  */\nstruct splay_tree_node_s GTY(())\n{\n  /* The key.  */\n  splay_tree_key GTY ((use_param1 (\"\"))) key;\n\n  /* The value.  */\n  splay_tree_value GTY ((use_param2 (\"\"))) value;\n\n  /* The left and right children, respectively.  */\n  splay_tree_node GTY ((use_params (\"\"))) left;\n  splay_tree_node GTY ((use_params (\"\"))) right;\n};\n\n/* The splay tree itself.  */\nstruct splay_tree_s GTY(())\n{\n  /* The root of the tree.  */\n  splay_tree_node GTY ((use_params (\"\"))) root;\n\n  /* The comparision function.  */\n  splay_tree_compare_fn comp;\n\n  /* The deallocate-key function.  NULL if no cleanup is necessary.  */\n  splay_tree_delete_key_fn delete_key;\n\n  /* The deallocate-value function.  NULL if no cleanup is necessary.  */\n  splay_tree_delete_value_fn delete_value;\n\n  /* Allocate/free functions, and a data pointer to pass to them.  */\n  splay_tree_allocate_fn allocate;\n  splay_tree_deallocate_fn deallocate;\n  PTR GTY((skip (\"\"))) allocate_data;\n\n};\ntypedef struct splay_tree_s *splay_tree;\n\nextern splay_tree splay_tree_new        PARAMS((splay_tree_compare_fn,\n\t\t\t\t\t        splay_tree_delete_key_fn,\n\t\t\t\t\t        splay_tree_delete_value_fn));\nextern splay_tree splay_tree_new_with_allocator\n                                        PARAMS((splay_tree_compare_fn,\n\t\t\t\t\t        splay_tree_delete_key_fn,\n\t\t\t\t\t        splay_tree_delete_value_fn,\n                                                splay_tree_allocate_fn,\n                                                splay_tree_deallocate_fn,\n                                                void *));\nextern void splay_tree_delete           PARAMS((splay_tree));\nextern splay_tree_node splay_tree_insert\n\t\t                        PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_key,\n\t\t\t\t\t        splay_tree_value));\nextern void splay_tree_remove\t\tPARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_lookup\n                                        PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_key));\nextern splay_tree_node splay_tree_predecessor\n                                        PARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_successor\n                                        PARAMS((splay_tree,\n\t\t\t\t\t\tsplay_tree_key));\nextern splay_tree_node splay_tree_max\n                                        PARAMS((splay_tree));\nextern splay_tree_node splay_tree_min\n                                        PARAMS((splay_tree));\nextern int splay_tree_foreach           PARAMS((splay_tree,\n\t\t\t\t\t        splay_tree_foreach_fn,\n\t\t\t\t\t        void*));\nextern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n\t\t\t\t\t\tsplay_tree_key));\nextern int splay_tree_compare_pointers  PARAMS((splay_tree_key,\n\t\t\t\t\t\tsplay_tree_key));\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* _SPLAY_TREE_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SREAL": {"ttr": 10756, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for simple data type for positive real numbers.\n   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_SREAL_H\n#define GCC_SREAL_H\n\n/* SREAL_PART_BITS has to be an even number.  */\n#if (HOST_BITS_PER_WIDE_INT / 2) % 2 == 1\n#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2 - 1)\n#else\n#define SREAL_PART_BITS (HOST_BITS_PER_WIDE_INT / 2)\n#endif\n\n#define uhwi unsigned HOST_WIDE_INT\n#define MAX_HOST_WIDE_INT (((uhwi) 1 << (HOST_BITS_PER_WIDE_INT - 1)) - 1)\n\n#define SREAL_MIN_SIG ((uhwi) 1 << (SREAL_PART_BITS - 1))\n#define SREAL_MAX_SIG (((uhwi) 1 << SREAL_PART_BITS) - 1)\n#define SREAL_MAX_EXP (INT_MAX / 4)\n\n#if SREAL_PART_BITS < 32\n#define SREAL_BITS (SREAL_PART_BITS * 2)\n#else\n#define SREAL_BITS SREAL_PART_BITS\n#endif\n\n/* Structure for holding a simple real number.  */\ntypedef struct sreal\n{\n#if SREAL_PART_BITS < 32\n  unsigned HOST_WIDE_INT sig_lo;\t/* Significant (lower part).  */\n  unsigned HOST_WIDE_INT sig_hi;\t/* Significant (higher part).  */\n#else\n  unsigned HOST_WIDE_INT sig;\t\t/* Significant.  */\n#endif\n  signed int exp;\t\t\t/* Exponent.  */\n} sreal;\n\nextern void dump_sreal (FILE *, sreal *);\nextern sreal *sreal_init (sreal *, unsigned HOST_WIDE_INT, signed int);\nextern HOST_WIDE_INT sreal_to_int (sreal *);\nextern int sreal_compare (sreal *, sreal *);\nextern sreal *sreal_add (sreal *, sreal *, sreal *);\nextern sreal *sreal_sub (sreal *, sreal *, sreal *);\nextern sreal *sreal_mul (sreal *, sreal *, sreal *);\nextern sreal *sreal_div (sreal *, sreal *, sreal *);\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STABD": {"ttr": 10758, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Table of DBX symbol codes for the GNU system.\n   Copyright (C) 1988, 1997, 1998 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public License as\n   published by the Free Software Foundation; either version 2 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This contains contribution from Cygnus Support.  */\n\n/* Global variable.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_GSYM, 0x20, \"GSYM\")\n\n/* Function name for BSD Fortran.  Only the name is significant.\n   To find the address, look in the corresponding external symbol.  */\n__define_stab (N_FNAME, 0x22, \"FNAME\")\n\n/* Function name or text-segment variable for C.  Value is its address.\n   Desc is supposedly starting line number, but GCC doesn't set it\n   and DBX seems not to miss it.  */\n__define_stab (N_FUN, 0x24, \"FUN\")\n\n/* Data-segment variable with internal linkage.  Value is its address.\n   \"Static Sym\".  */\n__define_stab (N_STSYM, 0x26, \"STSYM\")\n\n/* BSS-segment variable with internal linkage.  Value is its address.  */\n__define_stab (N_LCSYM, 0x28, \"LCSYM\")\n\n/* Name of main routine.  Only the name is significant.\n   This is not used in C.  */\n__define_stab (N_MAIN, 0x2a, \"MAIN\")\n\n/* Global symbol in Pascal.\n   Supposedly the value is its line number; I'm skeptical.  */\n__define_stab (N_PC, 0x30, \"PC\")\n\n/* Number of symbols:  0, files,,funcs,lines according to Ultrix V4.0.  */\n__define_stab (N_NSYMS, 0x32, \"NSYMS\")\n\n/* \"No DST map for sym: name, ,0,type,ignored\"  according to Ultrix V4.0.  */\n__define_stab (N_NOMAP, 0x34, \"NOMAP\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  */\n__define_stab (N_OBJ, 0x38, \"OBJ\")\n\n/* New stab from Solaris.  I don't know what it means, but it\n   don't seem to contain useful information.  Possibly related to the\n   optimization flags used in this module.  */\n__define_stab (N_OPT, 0x3c, \"OPT\")\n\n/* Register variable.  Value is number of register.  */\n__define_stab (N_RSYM, 0x40, \"RSYM\")\n\n/* Modula-2 compilation unit.  Can someone say what info it contains?  */\n__define_stab (N_M2C, 0x42, \"M2C\")\n\n/* Line number in text segment.  Desc is the line number;\n   value is corresponding address.  */\n__define_stab (N_SLINE, 0x44, \"SLINE\")\n\n/* Similar, for data segment.  */\n__define_stab (N_DSLINE, 0x46, \"DSLINE\")\n\n/* Similar, for bss segment.  */\n__define_stab (N_BSLINE, 0x48, \"BSLINE\")\n\n/* Sun's source-code browser stabs.  ?? Don't know what the fields are.\n   Supposedly the field is \"path to associated .cb file\".  THIS VALUE\n   OVERLAPS WITH N_BSLINE!  */\n__define_stab (N_BROWS, 0x48, \"BROWS\")\n\n/* GNU Modula-2 definition module dependency.  Value is the modification time\n   of the definition file.  Other is nonzero if it is imported with the\n   GNU M2 keyword %INITIALIZE.  Perhaps N_M2C can be used if there\n   are enough empty fields? */\n__define_stab(N_DEFD, 0x4a, \"DEFD\")\n\n/* THE FOLLOWING TWO STAB VALUES CONFLICT.  Happily, one is for Modula-2\n   and one is for C++.   Still,...  */\n/* GNU C++ exception variable.  Name is variable name.  */\n__define_stab (N_EHDECL, 0x50, \"EHDECL\")\n/* Modula2 info \"for imc\":  name,,0,0,0  according to Ultrix V4.0.  */\n__define_stab (N_MOD2, 0x50, \"MOD2\")\n\n/* GNU C++ `catch' clause.  Value is its address.  Desc is nonzero if\n   this entry is immediately followed by a CAUGHT stab saying what exception\n   was caught.  Multiple CAUGHT stabs means that multiple exceptions\n   can be caught here.  If Desc is 0, it means all exceptions are caught\n   here.  */\n__define_stab (N_CATCH, 0x54, \"CATCH\")\n\n/* Structure or union element.  Value is offset in the structure.  */\n__define_stab (N_SSYM, 0x60, \"SSYM\")\n\n/* Name of main source file.\n   Value is starting text address of the compilation.  */\n__define_stab (N_SO, 0x64, \"SO\")\n\n/* Automatic variable in the stack.  Value is offset from frame pointer.\n   Also used for type descriptions.  */\n__define_stab (N_LSYM, 0x80, \"LSYM\")\n\n/* Beginning of an include file.  Only Sun uses this.\n   In an object file, only the name is significant.\n   The Sun linker puts data into some of the other fields.  */\n__define_stab (N_BINCL, 0x82, \"BINCL\")\n\n/* Name of sub-source file (#include file).\n   Value is starting text address of the compilation.  */\n__define_stab (N_SOL, 0x84, \"SOL\")\n\n/* Parameter variable.  Value is offset from argument pointer.\n   (On most machines the argument pointer is the same as the frame pointer.  */\n__define_stab (N_PSYM, 0xa0, \"PSYM\")\n\n/* End of an include file.  No name.\n   This and N_BINCL act as brackets around the file's output.\n   In an object file, there is no significant data in this entry.\n   The Sun linker puts data into some of the fields.  */\n__define_stab (N_EINCL, 0xa2, \"EINCL\")\n\n/* Alternate entry point.  Value is its address.  */\n__define_stab (N_ENTRY, 0xa4, \"ENTRY\")\n\n/* Beginning of lexical block.\n   The desc is the nesting level in lexical blocks.\n   The value is the address of the start of the text for the block.\n   The variables declared inside the block *precede* the N_LBRAC symbol.  */\n__define_stab (N_LBRAC, 0xc0, \"LBRAC\")\n\n/* Place holder for deleted include file.  Replaces a N_BINCL and everything\n   up to the corresponding N_EINCL.  The Sun linker generates these when\n   it finds multiple identical copies of the symbols from an include file.\n   This appears only in output from the Sun linker.  */\n__define_stab (N_EXCL, 0xc2, \"EXCL\")\n\n/* Modula-2 scope information.  Can someone say what info it contains?  */\n__define_stab (N_SCOPE, 0xc4, \"SCOPE\")\n\n/* End of a lexical block.  Desc matches the N_LBRAC's desc.\n   The value is the address of the end of the text for the block.  */\n__define_stab (N_RBRAC, 0xe0, \"RBRAC\")\n\n/* Begin named common block.  Only the name is significant.  */\n__define_stab (N_BCOMM, 0xe2, \"BCOMM\")\n\n/* End named common block.  Only the name is significant\n   (and it should match the N_BCOMM).  */\n__define_stab (N_ECOMM, 0xe4, \"ECOMM\")\n\n/* End common (local name): value is address.\n   I'm not sure how this is used.  */\n__define_stab (N_ECOML, 0xe8, \"ECOML\")\n\n/* These STAB's are used on Gould systems for Non-Base register symbols\n   or something like that.  FIXME.  I have assigned the values at random\n   since I don't have a Gould here.  Fixups from Gould folk welcome...  */\n__define_stab (N_NBTEXT, 0xF0, \"NBTEXT\")\n__define_stab (N_NBDATA, 0xF2, \"NBDATA\")\n__define_stab (N_NBBSS,  0xF4, \"NBBSS\")\n__define_stab (N_NBSTS,  0xF6, \"NBSTS\")\n__define_stab (N_NBLCS,  0xF8, \"NBLCS\")\n\n/* Second symbol entry containing a length-value for the preceding entry.\n   The value is the length.  */\n__define_stab (N_LENG, 0xfe, \"LENG\")\n\n/* The above information, in matrix format.\n\n\t\t\tSTAB MATRIX\n\t_________________________________________________\n\t| 00 - 1F are not dbx stab symbols\t\t|\n\t| In most cases, the low bit is the EXTernal bit|\n\n\t| 00 UNDEF  | 02 ABS\t| 04 TEXT   | 06 DATA\t|\n\t| 01  |EXT  | 03  |EXT\t| 05  |EXT  | 07  |EXT\t|\n\n\t| 08 BSS    | 0A INDR\t| 0C FN_SEQ | 0E   \t|\n\t| 09  |EXT  | 0B \t| 0D\t    | 0F\t|\n\n\t| 10 \t    | 12 COMM\t| 14 SETA   | 16 SETT\t|\n\t| 11\t    | 13\t| 15 \t    | 17\t|\n\n\t| 18 SETD   | 1A SETB\t| 1C SETV   | 1E WARNING|\n\t| 19\t    | 1B\t| 1D \t    | 1F FN\t|\n\n\t|_______________________________________________|\n\t| Debug entries with bit 01 set are unused.\t|\n\t| 20 GSYM   | 22 FNAME\t| 24 FUN    | 26 STSYM\t|\n\t| 28 LCSYM  | 2A MAIN\t| 2C\t    | 2E\t|\n\t| 30 PC\t    | 32 NSYMS\t| 34 NOMAP  | 36\t|\n\t| 38 OBJ    | 3A\t| 3C OPT    | 3E\t|\n\t| 40 RSYM   | 42 M2C\t| 44 SLINE  | 46 DSLINE |\n\t| 48 BSLINE*| 4A DEFD\t| 4C        | 4E\t|\n\t| 50 EHDECL*| 52\t| 54 CATCH  | 56        |\n\t| 58        | 5A        | 5C        | 5E\t|\n\t| 60 SSYM   | 62\t| 64 SO\t    | 66 \t|\n\t| 68 \t    | 6A\t| 6C\t    | 6E\t|\n\t| 70\t    | 72\t| 74\t    | 76\t|\n\t| 78\t    | 7A\t| 7C\t    | 7E\t|\n\t| 80 LSYM   | 82 BINCL\t| 84 SOL    | 86\t|\n\t| 88\t    | 8A\t| 8C\t    | 8E\t|\n\t| 90\t    | 92\t| 94\t    | 96\t|\n\t| 98\t    | 9A\t| 9C\t    | 9E\t|\n\t| A0 PSYM   | A2 EINCL\t| A4 ENTRY  | A6\t|\n\t| A8\t    | AA\t| AC\t    | AE\t|\n\t| B0\t    | B2\t| B4\t    | B6\t|\n\t| B8\t    | BA\t| BC\t    | BE\t|\n\t| C0 LBRAC  | C2 EXCL\t| C4 SCOPE  | C6\t|\n\t| C8\t    | CA\t| CC\t    | CE\t|\n\t| D0\t    | D2\t| D4\t    | D6\t|\n\t| D8\t    | DA\t| DC\t    | DE\t|\n\t| E0 RBRAC  | E2 BCOMM\t| E4 ECOMM  | E6\t|\n\t| E8 ECOML  | EA\t| EC\t    | EE\t|\n\t| F0\t    | F2\t| F4\t    | F6\t|\n\t| F8\t    | FA\t| FC\t    | FE LENG\t|\n\t+-----------------------------------------------+\n * 50 EHDECL is also MOD2.\n * 48 BSLINE is also BROWS.\n */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STACK": {"ttr": 10761, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* stack.h - structed access to object stacks\n   Copyright (C) 1988, 2000, 2003 Free Software Foundation, Inc.\n   Contributed by Michael Tiemann (tiemann@cygnus.com).\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* Summary: this file contains additional structures that layer\n   on top of obstacks for GNU C++.  */\n\n/* Stack of data placed on obstacks.  */\n\nstruct stack_level\n{\n  /* Pointer back to previous such level.  */\n  struct stack_level *prev;\n\n  /* Point to obstack we should return to.  */\n  struct obstack *obstack;\n\n  /* First place we start putting data.  */\n  tree *first;\n\n  /* Number of entries we can have from `first'.\n     Right now we are dumb: if we overflow, abort.  */\n  int limit;\n};\n\nstruct stack_level *push_stack_level (struct obstack *, char *, int);\nstruct stack_level *pop_stack_level (struct stack_level *);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYMCAT": {"ttr": 10763, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Symbol concatenation utilities.\n\n   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef SYM_CAT_H\n#define SYM_CAT_H\n\n#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)\n#define CONCAT2(a,b)\t a##b\n#define CONCAT3(a,b,c)\t a##b##c\n#define CONCAT4(a,b,c,d) a##b##c##d\n#define STRINGX(s) #s\n#else\n/* Note one should never pass extra whitespace to the CONCATn macros,\n   e.g. CONCAT2(foo, bar) because traditonal C will keep the space between\n   the two labels instead of concatenating them.  Instead, make sure to\n   write CONCAT2(foo,bar).  */\n#define CONCAT2(a,b)\t a/**/b\n#define CONCAT3(a,b,c)\t a/**/b/**/c\n#define CONCAT4(a,b,c,d) a/**/b/**/c/**/d\n#define STRINGX(s) \"s\"\n#endif\n\n#define XCONCAT2(a,b)     CONCAT2(a,b)\n#define XCONCAT3(a,b,c)   CONCAT3(a,b,c)\n#define XCONCAT4(a,b,c,d) CONCAT4(a,b,c,d)\n\n/* Note the layer of indirection here is typically used to allow\n   stringification of the expansion of macros.  I.e. \"#define foo\n   bar\", \"XSTRING(foo)\", to yield \"bar\".  Be aware that this only\n   works for __STDC__, not for traditional C which will still resolve\n   to \"foo\".  */\n#define XSTRING(s) STRINGX(s)\n\n#endif /* SYM_CAT_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYS@PROT": {"ttr": 10765, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "extern int                    TLappend(/* ??? */);\nextern int                    TLassign(/* ??? */);\nextern int                    TLclose(/* ??? */);\nextern int                    TLdelete(/* ??? */);\nextern int                    TLfreeentry(/* ??? */);\nextern ENTRY                  TLgetentry(/* ??? */);\nextern unsigned char *        TLgetfield(/* ??? */);\nextern int                    TLopen(/* ??? */);\nextern int                    TLread(/* ??? */);\nextern int                    TLsearch1(/* ??? */);\nextern int                    TLsubst(/* ??? */);\nextern int                    TLsync(/* ??? */);\nextern int                    TLwrite(/* ??? */);\nextern int                    __acancel(int, const long int *, int);\nextern int                    __aread(int, int, char *, uint, ecb_t *);\nextern void                   __assert(const char *, const char *, int);\nextern int                    __asyncio(int, aioop_t *, int);\nextern int                    __awrite(int, int, char *, uint, ecb_t *);\nextern int                    __evcntl(evver_t, evcntlcmds_t, long int, long int);\nextern int                    __evexit(evver_t, idtype_t, id_t, const ecb_t *);\nextern int                    __evexitset(evver_t, const procset_t *, hostid_t, const ecb_t *);\nextern int                    __evpoll(evver_t, evpollcmds_t, event_t *, int, const hrtime_t *);\nextern int                    __evpollmore(evver_t, event_t *, int);\nextern int                    __evpost(evver_t, event_t *, int, int);\nextern int                    __evqcntl(evver_t, int, evqcntlcmds_t, long int);\nextern int                    __evsig(evver_t, const sigset_t *, const ecb_t *, evsiginfo_t *, int);\nextern int                    __evtrap(evver_t, evpollcmds_t, event_t *, int, long int, void (*) (event_t *, int, long int, evcontext_t *), const evta_t *);\nextern int                    __evtrapcancel(evver_t, long int *, int);\nextern int                    __filbuf(FILE *);\nextern int                    __flsbuf(int, FILE *);\nextern major_t                __major(int, dev_t);\nextern dev_t                  __makedev(int, major_t, minor_t);\nextern minor_t                __minor(int, dev_t);\nextern long int               __priocntl(/* ??? */);\nextern long int               __priocntlset(/* ??? */);\nextern void                   _exit(int);\nextern int                    _filbuf(FILE *);\nextern int                    _flsbuf(unsigned int, FILE *);\nextern int                    _fxstat(int, int, struct stat *);\nextern u_long                 _getlong(/* ??? */);\nextern u_short                _getshort(/* ??? */);\nextern int                    _getsyx(int *, int *);\nextern int                    _longjmp(jmp_buf, int);\nextern int                    _lxstat(int, const char *, struct stat *);\nextern int                    _meta(int);\nextern struct nd_hostservlist _netdir_getbyaddr(struct netconfig *, struct netbuf *);\nextern struct nd_addrlist *   _netdir_getbyname(struct netconfig *, struct nd_hostserv *);\nextern int                    _overlay(WINDOW *, WINDOW *, int);\nextern int                    _ring(int);\nextern int                    _rpc_dtbsize(/* ??? */);\nextern int                    _rpc_endconf(/* ??? */);\nextern u_int                  _rpc_get_a_size(/* ??? */);\nextern u_int                  _rpc_get_t_size(/* ??? */);\nextern struct netconfig *     _rpc_getconf(/* ??? */);\nextern struct netconfig *     _rpc_getconfip(/* ??? */);\nextern char *                 _rpc_gethostname(/* ??? */);\nextern int                    _rpc_setconf(/* ??? */);\nextern void                   _s_aligned_copy(/* ??? */);\nextern struct _si_user *      _s_checkfd(/* ??? */);\nextern void                   _s_close(/* ??? */);\nextern int                    _s_do_ioctl(/* ??? */);\nextern int                    _s_getfamily(/* ??? */);\nextern int                    _s_getudata(/* ??? */);\nextern int                    _s_is_ok(/* ??? */);\nextern struct netconfig *     _s_match(/* ??? */);\nextern int                    _s_max(/* ??? */);\nextern int                    _s_min(/* ??? */);\nextern struct _si_user *      _s_open(/* ??? */);\nextern int                    _s_soreceive(/* ??? */);\nextern int                    _s_sosend(/* ??? */);\nextern int                    _s_uxpathlen(/* ??? */);\nextern int                    _setecho(int);\nextern int                    _setjmp(jmp_buf);\nextern int                    _setnonl(int);\nextern void                   _setqiflush(int);\nextern char *                 _taddr2uaddr(struct netconfig *, struct netbuf *);\nextern int                    _tolower(int);\nextern int                    _toupper(int);\nextern struct netbuf *        _uaddr2taddr(struct netconfig *, char *);\nextern bool                   _xdr_yprequest(/* ??? */);\nextern bool                   _xdr_ypresponse(/* ??? */);\nextern int                    _xftw(int, const char *, int (*) (const char *, const struct stat *, int), int);\nextern int                    _xmknod(int, const char *, mode_t, dev_t);\nextern int                    _xstat(int, const char *, struct stat *);\nextern int                    _yp_dobind(/* ??? */);\nextern long int               a64l(const char *);\nextern char *                 aatos(char *, struct address *, int);\nextern void                   abort(void);\nextern int                    abs(int);\nextern int                    access(const char *, int);\nextern int                    acct(const char *);\nextern double                 acos(double);\nextern float                  acosf(float);\nextern double                 acosh(double);\nextern int                    addexportent(FILE *, char *, char *);\nextern int                    addseverity(int, const char *);\nextern int                    adjtime(struct timeval *, struct timeval *);\nextern int                    advance(const char *, const char *);\nextern unsigned int           alarm(unsigned int);\nextern void *                 alloca(size_t);\nextern int                    and(void);\nextern int                    ascftime(char *, const char *, const struct tm *);\nextern char *                 asctime(const struct tm *);\nextern double                 asin(double);\nextern float                  asinf(float);\nextern double                 asinh(double);\nextern struct address *       astoa(char *, struct address *);\nextern double                 atan(double);\nextern double                 atan2(double, double);\nextern float                  atan2f(float, float);\nextern float                  atanf(float);\nextern double                 atanh(double);\nextern int                    atexit(void (*) (void));\nextern double                 atof(const char *);\nextern int                    atoi(const char *);\nextern long int               atol(const char *);\nextern char *                 atos(char *, struct netbuf *, int);\nextern void                   auth_destroy(AUTH *);\nextern AUTH *                 authdes_create(/* ??? */);\nextern void                   authdes_getcred(struct authdes_cred *, short *, short *, short *, int *);\nextern AUTH *                 authdes_seccreate(/* ??? */);\nextern AUTH *                 authnone_create(void);\nextern AUTH *                 authsys_create(char *, int, int, int, int *);\nextern AUTH *                 authsys_create_default(void);\nextern AUTH *                 authunix_create(char *, int, int, int, int *);\nextern AUTH *                 authunix_create_default(void);\nextern char *                 basename(char *);\nextern int                    baudrate(void);\nextern int                    bcmp(const void *, const void *, size_t);\nextern void                   bcopy(const void *, void *, size_t);\nextern int                    beep(void);\nextern void (*                berk_signal(int, void (*) (int, ...))) (int, ...);\nextern char *                 bgets(char *, size_t, FILE *, char *);\nextern int                    bottom_panel(PANEL *);\nextern int                    box32(WINDOW *, chtype, chtype);\nextern int                    brk(void *);\nextern void *                 bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));\nextern size_t                 bufsplit(char *, size_t, char *);\nextern void                   bzero(void *, size_t);\nextern long int               calchash(/* ??? */);\nextern void *                 calloc(size_t, size_t);\nextern void                   callrpc(char *, unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *);\nextern bool                   can_change_color(void);\nextern int                    catclose(nl_catd);\nextern char *                 catgets(nl_catd, int, int, char *);\nextern nl_catd                catopen(const char *, int);\nextern int                    cbreak(void);\nextern double                 cbrt(double);\nextern double                 ceil(double);\nextern float                  ceilf(float);\nextern speed_t                cfgetispeed(const struct termios *);\nextern speed_t                cfgetospeed(const struct termios *);\nextern void                   cfree(void *);\nextern int                    cfsetispeed(struct termios *, speed_t);\nextern int                    cfsetospeed(struct termios *, speed_t);\nextern int                    cftime(char *, char *, const time_t *);\nextern int                    chdir(const char *);\nextern int                    chmod(const char *, mode_t);\nextern int                    chown(const char *, uid_t, gid_t);\nextern int                    chroot(const char *);\nextern void                   clean_GEN_rd(/* ??? */);\nextern void                   cleanup(/* ??? */);\nextern void                   clearerr(FILE *);\nextern int                    clearok(WINDOW *, int);\nextern enum clnt_stat         clnt_broadcast(unsigned long, unsigned long, unsigned long, xdrproc_t, char *, xdrproc_t, char *, resultproc_t);\nextern enum clnt_stat         clnt_call(CLIENT *, unsigned long, xdrproc_t, char *, xdrproc_t, char *, struct timeval);\nextern bool_t                 clnt_control(CLIENT *, int, char *);\nextern CLIENT *               clnt_create(char *, unsigned long, unsigned long, char *);\nextern void                   clnt_destroy(CLIENT *);\nextern int                    clnt_freeres(CLIENT *, xdrproc_t, char *);\nextern void                   clnt_geterr(CLIENT *, struct rpc_err *);\nextern void                   clnt_pcreateerror(char *);\nextern void                   clnt_perrno(enum clnt_stat);\nextern void                   clnt_perror(CLIENT *, char *);\nextern char *                 clnt_spcreateerror(char *);\nextern char *                 clnt_sperrno(enum clnt_stat);\nextern char *                 clnt_sperror(CLIENT *, char *);\nextern CLIENT *               clnt_tli_create(/* ??? */);\nextern CLIENT *               clnt_tp_create(/* ??? */);\nextern CLIENT *               clnt_vc_create(/* ??? */);\nextern CLIENT *               clntraw_create(unsigned long, unsigned long);\nextern CLIENT *               clnttcp_create(struct sockaddr_in *, unsigned long, unsigned long, int *, unsigned int, unsigned int *);\nextern CLIENT *               clntudp_bufcreate(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *, unsigned int, unsigned int);\nextern CLIENT *               clntudp_create(struct sockaddr_in *, unsigned long, unsigned long, struct timeval, int *);\nextern clock_t                clock(void);\nextern int                    close(int);\nextern int                    closedir(DIR *);\nextern int                    color_content(int, short int *, short int *, short int *);\nextern char *                 compile(const char *, char *, char *);\nextern char *                 copylist(const char *, off_t *);\nextern double                 copysign(double, double);\nextern int                    copywin(WINDOW *, WINDOW *, int, int, int, int, int, int, int);\nextern double                 cos(double);\nextern float                  cosf(float);\nextern double                 cosh(double);\nextern float                  coshf(float);\nextern struct rd_user *       cr_rduser(/* ??? */);\nextern int                    creat(const char *, mode_t);\nextern int                    crmode(void);\nextern char *                 crypt(const char *, const char *);\nextern int                    crypt_close(int *);\nextern char *                 ctermid(char *);\nextern char *                 ctime(const time_t *);\nextern FIELD *                current_field(FORM *);\nextern ITEM *                 current_item(MENU *);\nextern int                    curs_set(int);\nextern void                   curserr(void);\nextern char *                 cuserid(char *);\nextern int                    data_ahead(FORM *);\nextern int                    data_behind(FORM *);\nextern void                   dbmclose(void);\nextern void                   dbminit(const char *);\nextern int                    def_prog_mode(void);\nextern int                    def_shell_mode(void);\nextern char *                 defread(/* ??? */);\nextern int                    del_panel(PANEL *);\nextern void                   del_rduser(/* ??? */);\nextern void                   delay(long int);\nextern int                    delay_output(int);\nextern void                   delete(datum);\nextern void                   delscreen(SCREEN *);\nextern int                    delterm(TERMINAL *);\nextern int                    delwin(WINDOW *);\nextern WINDOW *               derwin(WINDOW *, int, int, int, int);\nextern char *                 des_crypt(const char *, const char *);\nextern void                   des_encrypt(char *, int);\nextern void                   des_setkey(const char *);\nextern char *                 devattr(/* ??? */);\nextern int                    devfree(/* ??? */);\nextern char **                devreserv(/* ??? */);\nextern int                    dial(CALL);\nextern double                 difftime(time_t, time_t);\nextern char *                 dirname(char *);\nextern div_t                  div(int, int);\nextern int                    dlclose(void *);\nextern char *                 dlerror(void);\nextern void *                 dlopen(char *, int);\nextern void *                 dlsym(void *, char *);\nextern void                   dma_access(u_char, u_int, u_int, u_char, u_char);\nextern int                    doupdate(void);\nextern int                    drainio(int);\nextern double                 drand48(void);\nextern double                 drem(double, double);\nextern int                    drv_getevtoken(/* ??? */);\nextern void                   drv_relevtoken(/* ??? */);\nextern int                    dup(int);\nextern int                    dup2(int, int);\nextern FIELD *                dup_field(FIELD *, int, int);\nextern WINDOW *               dupwin(WINDOW *);\nextern int                    dynamic_field_info(FIELD *, int *, int *, int *);\nextern int                    dysize(int);\nextern int                    eaccess(const char *, int);\nextern int                    echo(void);\nextern char *                 ecvt(double, int, int *, int *);\nextern size_t                 elf32_fsize(Elf_Type, size_t, unsigned int);\nextern Elf32_Ehdr *           elf32_getehdr(Elf *);\nextern Elf32_Phdr *           elf32_getphdr(Elf *);\nextern Elf32_Shdr *           elf32_getshdr(Elf_Scn *);\nextern Elf32_Ehdr *           elf32_newehdr(Elf *);\nextern Elf32_Phdr *           elf32_newphdr(Elf *, size_t);\nextern Elf_Data *             elf32_xlatetof(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf_Data *             elf32_xlatetom(Elf_Data *, const Elf_Data *, unsigned int);\nextern Elf *                  elf_begin(int, Elf_Cmd, Elf *);\nextern int                    elf_cntl(Elf *, Elf_Cmd);\nextern int                    elf_end(Elf *);\nextern const char *           elf_errmsg(int);\nextern int                    elf_errno(void);\nextern void                   elf_fill(int);\nextern unsigned int           elf_flagdata(Elf_Data *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagehdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagelf(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagphdr(Elf *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagscn(Elf_Scn *, Elf_Cmd, unsigned int);\nextern unsigned int           elf_flagshdr(Elf_Scn *, Elf_Cmd, unsigned int);\nextern Elf_Arhdr *            elf_getarhdr(Elf *);\nextern Elf_Arsym *            elf_getarsym(Elf *, size_t *);\nextern off_t                  elf_getbase(Elf *);\nextern Elf_Data *             elf_getdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_getident(Elf *, size_t *);\nextern Elf_Scn *              elf_getscn(Elf *, size_t);\nextern long unsigned int      elf_hash(const char *);\nextern Elf_Kind               elf_kind(Elf *);\nextern size_t                 elf_ndxscn(Elf_Scn *);\nextern Elf_Data *             elf_newdata(Elf_Scn *);\nextern Elf_Scn *              elf_newscn(Elf *);\nextern Elf_Cmd                elf_next(Elf *);\nextern Elf_Scn *              elf_nextscn(Elf *, Elf_Scn *);\nextern size_t                 elf_rand(Elf *, size_t);\nextern Elf_Data *             elf_rawdata(Elf_Scn *, Elf_Data *);\nextern char *                 elf_rawfile(Elf *, size_t *);\nextern char *                 elf_strptr(Elf *, size_t, size_t);\nextern off_t                  elf_update(Elf *, Elf_Cmd);\nextern unsigned int           elf_version(unsigned int);\nextern void                   encrypt(char *, int);\nextern void                   endgrent(void);\nextern int                    endnetconfig(void *);\nextern int                    endnetpath(void *);\nextern void                   endpwent(void);\nextern void                   endrpcent(void);\nextern void                   endspent(void);\nextern void                   endutent(void);\nextern void                   endutxent(void);\nextern int                    endwin(void);\nextern double                 erand(short *);\nextern double                 erand48(short unsigned int *);\nextern char                   erasechar(void);\nextern double                 erf(double);\nextern double                 erfc(double);\nextern int                    execl(const char *, const char *, ...);\nextern int                    execle(const char *, const char *, ...);\nextern int                    execlp(const char *, const char *, ...);\nextern int                    exect(const char *,  const char **,  char **);\nextern int                    execv(const char *, char *const *);\nextern int                    execve(const char *, char *const *, char *const *);\nextern int                    execvp(const char *, char *const *);\nextern void                   exit(int);\nextern double                 exp(double);\nextern float                  expf(float);\nextern double                 fabs(double);\nextern float                  fabsf(float);\nextern int                    fattach(int, const char *);\nextern int                    fchdir(int);\nextern int                    fchmod(int, mode_t);\nextern int                    fchown(int, uid_t, gid_t);\nextern int                    fclose(FILE *);\nextern int                    fcntl(int, int, ...);\nextern char *                 fcvt(double, int, int *, int *);\nextern int                    fdetach(const char *);\nextern FILE *                 fdopen(int, const char *);\nextern int                    feof(FILE *);\nextern int                    ferror(FILE *);\nextern datum                  fetch(datum);\nextern int                    fflush(FILE *);\nextern int                    ffs(int);\nextern int                    fgetc(FILE *);\nextern struct group *         fgetgrent(FILE *);\nextern int                    fgetpos(FILE *, fpos_t *);\nextern struct passwd *        fgetpwent(FILE *);\nextern char *                 fgets(char *, int, FILE *);\nextern struct spwd *          fgetspent(FILE *);\nextern char *                 field_arg(FIELD *);\nextern chtype                 field_back(FIELD *);\nextern char *                 field_buffer(FIELD *, int);\nextern int                    field_count(FORM *);\nextern chtype                 field_fore(FIELD *);\nextern int                    field_index(FIELD *);\nextern int                    field_info(FIELD *, int *, int *, int *, int *, int *, int *);\nextern PTF_void               field_init(FORM *);\nextern int                    field_just(FIELD *);\nextern OPTIONS                field_opts(FIELD *);\nextern int                    field_opts_off(FIELD *, OPTIONS);\nextern int                    field_opts_on(FIELD *, OPTIONS);\nextern int                    field_pad(FIELD *);\nextern int                    field_status(FIELD *);\nextern PTF_void               field_term(FORM *);\nextern FIELDTYPE *            field_type(FIELD *);\nextern char *                 field_userptr(FIELD *);\nextern int                    fileno(FILE *);\nextern int                    filter(void);\nextern int                    finite(double);\nextern datum                  firsthash(/* ??? */);\nextern datum                  firstkey(void);\nextern int                    flash(void);\nextern int                    flock(int, int);\nextern double                 floor(double);\nextern float                  floorf(float);\nextern int                    flushinp(void);\nextern double                 fmod(double, double);\nextern float                  fmodf(float, float);\nextern int                    fmtmsg(long int, const char *, int, const char *, const char *, const char *);\nextern FILE *                 fopen(const char *, const char *);\nextern pid_t                  fork(void);\nextern int                    form_driver(FORM *, int);\nextern FIELD **               form_fields(FORM *);\nextern PTF_void               form_init(FORM *);\nextern OPTIONS                form_opts(FORM *);\nextern int                    form_opts_off(FORM *, OPTIONS);\nextern int                    form_opts_on(FORM *, OPTIONS);\nextern int                    form_page(FORM *);\nextern WINDOW *               form_sub(FORM *);\nextern PTF_void               form_term(FORM *);\nextern char *                 form_userptr(FORM *);\nextern WINDOW *               form_win(FORM *);\nextern long int               fpathconf(int, int);\nextern fpclass_t              fpclass(double);\nextern int                    fpgetmask(void);\nextern fp_rnd                 fpgetround(void);\nextern int                    fpgetsticky(void);\nextern int                    fprintf(FILE *, const char *, ...);\nextern int                    fpsetmask(int);\nextern fp_rnd                 fpsetround(fp_rnd);\nextern int                    fpsetsticky(int);\nextern int                    fputc(int, FILE *);\nextern int                    fputs(const char *, FILE *);\nextern size_t                 fread(void *, size_t, size_t, FILE *);\nextern void                   free(void *);\nextern int                    free_field(FIELD *);\nextern int                    free_fieldtype(FIELDTYPE *);\nextern int                    free_form(FORM *);\nextern int                    free_item(ITEM *);\nextern int                    free_menu(MENU *);\nextern void                   freenetconfigent(struct netconfig *);\nextern FILE *                 freopen(const char *, const char *, FILE *);\nextern double                 frexp(double, int *);\nextern int                    fscanf(FILE *, const char *, ...);\nextern int                    fseek(FILE *, long int, int);\nextern int                    fsetpos(FILE *, const fpos_t *);\nextern int                    fstat(int, struct stat *);\nextern int                    fstatfs(int, struct statfs *, int, int);\nextern int                    fstatvfs(int, struct statvfs *);\nextern int                    fsync(int);\nextern long int               ftell(FILE *);\nextern key_t                  ftok(const char *, int);\nextern int                    ftruncate(int, off_t);\nextern int                    ftw(const char *, int (*) (const char *, const struct stat *, int), int);\nextern size_t                 fwrite(const void *, size_t, size_t, FILE *);\nextern double                 gamma(double);\nextern char *                 gcvt(double, int, char *);\nextern int                    get_error(/* ??? */);\nextern chtype                 getattrs(WINDOW *);\nextern int                    getbegx(WINDOW *);\nextern int                    getbegy(WINDOW *);\nextern chtype                 getbkgd(WINDOW *);\nextern long unsigned int      getbmap(void);\nextern int                    getc(FILE *);\nextern char *                 getcap(/* ??? */);\nextern int                    getchar(void);\nextern int                    getcontext(ucontext_t *);\nextern int                    getcurx(WINDOW *);\nextern int                    getcury(WINDOW *);\nextern char *                 getcwd(char *, size_t);\nextern struct tm *            getdate(const char *);\nextern int                    getdents(int, struct dirent *, unsigned int);\nextern char **                getdev(/* ??? */);\nextern char **                getdgrp(/* ??? */);\nextern int                    getdomainname(char *, int);\nextern int                    getdtablesize(void);\nextern gid_t                  getegid(void);\nextern char *                 getenv(const char *);\nextern struct errhdr *        geterec(/* ??? */);\nextern struct errhdr *        geteslot(/* ??? */);\nextern uid_t                  geteuid(void);\nextern gid_t                  getgid(void);\nextern struct group *         getgrent(void);\nextern struct group *         getgrgid(gid_t);\nextern struct group *         getgrnam(const char *);\nextern int                    getgroups(int, TARGET_GETGROUPS_T \u00dd\u00a8);\nextern struct hostent *       gethostbyaddr(/* ??? */);\nextern struct hostent *       gethostbyname(/* ??? */);\nextern struct hostent *       gethostent(/* ??? */);\n#ifdef __alpha__\nextern int                    gethostid(void);\n#else\nextern long                   gethostid(void);\n#endif\nextern int                    gethostname(char *, size_t);\nextern int                    getitimer(int, struct itimerval *);\nextern char *                 getlogin(void);\nextern int                    getmaxx(WINDOW *);\nextern int                    getmaxy(WINDOW *);\nextern int                    getmntany(FILE *, struct mnttab *, struct mnttab *);\nextern int                    getmntent(/* ??? */);\nextern long unsigned int      getmouse(void);\nextern int                    getmsg(int, struct strbuf *, struct strbuf *, int *);\nextern struct netent *        getnetbyaddr(/* ??? */);\nextern struct netent *        getnetbyname(/* ??? */);\nextern struct netconfig *     getnetconfig(void *);\nextern struct netconfig *     getnetconfigent(char *);\nextern struct netent *        getnetent(/* ??? */);\nextern struct netconfig *     getnetpath(void *);\nextern int                    getopt(int, char *const *, const char *);\nextern int                    getpagesize(void);\nextern int                    getparx(WINDOW *);\nextern int                    getpary(WINDOW *);\nextern char *                 getpass(const char *);\nextern pid_t                  getpgid(pid_t);\nextern pid_t                  getpgrp(void);\nextern pid_t                  getpgrp2(pid_t);\nextern pid_t                  getpid(void);\nextern int                    getpmsg(int, struct strbuf *, struct strbuf *, int *, int *);\nextern pid_t                  getppid(void);\nextern int                    getpriority(int, int);\nextern struct protoent *      getprotobyname(/* ??? */);\nextern struct protoent *      getprotobynumber(/* ??? */);\nextern struct protoent *      getprotoent(/* ??? */);\nextern int                    getpw(int, char *);\nextern struct passwd *        getpwent(void);\nextern struct passwd *        getpwnam(const char *);\nextern struct passwd *        getpwuid(uid_t);\nextern int                    getrlimit(int, struct rlimit *);\nextern int                    getrnge(char *);\nextern struct rpcent *        getrpcbyname(const char *);\nextern struct rpcent *        getrpcbynumber(int);\nextern struct rpcent *        getrpcent(void);\nextern int                    getrusage(int, struct rusage *);\nextern char *                 gets(char *);\nextern struct servent *       getservbyname(/* ??? */);\nextern struct servent *       getservbyport(/* ??? */);\nextern struct servent *       getservent(/* ??? */);\nextern pid_t                  getsid(pid_t);\nextern struct spwd *          getspent(void);\nextern struct spwd *          getspnam(const char *);\nextern int                    getsubopt(char **, char *const *, char **);\nextern int                    gettmode(void);\nextern char *                 gettxt(const char *, const char *);\nextern uid_t                  getuid(void);\nextern struct utmp *          getutent(void);\nextern struct utmp *          getutid(const struct utmp *);\nextern struct utmp *          getutline(const struct utmp *);\nextern void                   getutmp(const struct utmpx *, struct utmp *);\nextern void                   getutmpx(const struct utmp *, struct utmpx *);\nextern struct utmpx *         getutxent(void);\nextern struct utmpx *         getutxid(const struct utmpx *);\nextern struct utmpx *         getutxline(const struct utmpx *);\nextern int                    getvfsany(FILE *, struct vfstab *, struct vfstab *);\nextern int                    getvfsent(FILE *, struct vfstab *);\nextern int                    getvfsfile(FILE *, struct vfstab *, char *);\nextern int                    getvfsspec(FILE *, struct vfstab *, char *);\nextern int                    getvol(/* ??? */);\nextern int                    getw(FILE *);\nextern char *                 getwd(char *);\nextern void                   getwidth(eucwidth_t *);\nextern WINDOW *               getwin(FILE *);\nextern int                    gmatch(const char *, const char *);\nextern struct tm *            gmtime(const time_t *);\nextern int                    gsignal(int);\nextern int                    halfdelay(int);\nextern bool                   has_colors(void);\nextern int                    has_ic(void);\nextern int                    has_il(void);\nextern long int               hashinc(/* ??? */);\nextern char *                 hasmntopt(/* ??? */);\nextern int                    hcreate(size_t);\nextern void                   hdestroy(void);\nextern int                    hide_panel(PANEL *);\nextern int                    host2netname(char *, char *, char *);\nextern int                    hrtalarm(hrtcmd_t *, int);\nextern int                    hrtcancel(const long int *, int);\nextern int                    hrtcntl(int, int, interval_t *, hrtime_t *);\nextern int                    hrtsleep(hrtcmd_t *);\nextern ENTRY *                hsearch(ENTRY, ACTION);\nextern long unsigned int      htonl(long unsigned int);\nextern short unsigned int     htons(unsigned int);\nextern double                 hypot(double, double);\nextern void                   idcok(WINDOW *, int);\nextern int                    idlok(WINDOW *, int);\nextern void                   immedok(WINDOW *, int);\nextern char *                 index(const char *, int);\nextern long unsigned int      inet_addr(/* ??? */);\nextern struct in_addr         inet_makeaddr(/* ??? */);\nextern long unsigned int      inet_network(/* ??? */);\nextern char *                 inet_ntoa(/* ??? */);\nextern int                    init_color(int, int, int, int);\nextern int                    init_pair(int, int, int);\nextern int                    initgroups(const char *, gid_t);\nextern WINDOW *               initscr(/* ??? */);\nextern WINDOW *               initscr32(void);\nextern char *                 initstate(unsigned, char *, int);\nextern void                   insque(struct qelem *, struct qelem *);\nextern int                    intrflush(WINDOW *, int);\nextern int                    ioctl(int, int, ...);\nextern int                    is_linetouched(WINDOW *, int);\nextern int                    is_wintouched(WINDOW *);\nextern int                    isalnum(int);\nextern int                    isalpha(int);\nextern int                    isascii(int);\nextern int                    isatty(int);\nextern int                    iscntrl(int);\nextern int                    isdigit(int);\nextern int                    isencrypt(const char *, size_t);\nextern int                    isendwin(void);\nextern int                    isgraph(int);\nextern int                    isinf(double);\nextern int                    islower(int);\nextern int                    isnan(double);\nextern int                    isnand(double);\nextern int                    isnanf(float);\nextern int                    isprint(int);\nextern int                    ispunct(int);\nextern int                    isspace(int);\nextern int                    isupper(int);\nextern int                    isxdigit(int);\nextern int                    item_count(MENU *);\nextern char *                 item_description(ITEM *);\nextern int                    item_index(ITEM *);\nextern PTF_void               item_init(MENU *);\nextern char *                 item_name(ITEM *);\nextern OPTIONS                item_opts(ITEM *);\nextern int                    item_opts_off(ITEM *, OPTIONS);\nextern int                    item_opts_on(ITEM *, OPTIONS);\nextern PTF_void               item_term(MENU *);\nextern char *                 item_userptr(ITEM *);\nextern int                    item_value(ITEM *);\nextern int                    item_visible(ITEM *);\nextern long int               itol(/* ??? */);\nextern double                 j0(double);\nextern double                 j1(double);\nextern double                 jn(int, double);\nextern long int               jrand48(short unsigned int *);\nextern char *                 keyname(int);\nextern int                    keypad(WINDOW *, int);\nextern int                    kill(pid_t, int);\nextern char                   killchar(void);\nextern int                    killpg(int, int);\nextern void                   l3tol(long int *, const char *, int);\nextern char *                 l64a(long int);\nextern long int               labs(long int);\nextern dl_t                   ladd(/* ??? */);\nextern int                    lchown(const char *, uid_t, gid_t);\nextern int                    lckpwdf(void);\nextern void                   lcong48(short unsigned int *);\nextern int                    ldaclose(struct ldfile *);\nextern int                    ldahread(struct ldfile *, archdr *);\nextern struct ldfile *        ldaopen(const char *, struct ldfile *);\nextern int                    ldclose(struct ldfile *);\nextern double                 ldexp(double, int);\nextern int                    ldfhread(struct ldfile *, struct filehdr *);\nextern char *                 ldgetname(struct ldfile *, const struct syment *);\nextern ldiv_t                 ldiv(long int, long int);\nextern dl_t                   ldivide(/* ??? */);\nextern int                    ldlinit(struct ldfile *, long int);\nextern int                    ldlitem(struct ldfile *, unsigned int, struct lineno *);\nextern int                    ldlread(struct ldfile *, long int, unsigned int, struct lineno *);\nextern int                    ldlseek(struct ldfile *, unsigned int);\nextern int                    ldnlseek(struct ldfile *, const char *);\nextern int                    ldnrseek(struct ldfile *, const char *);\nextern int                    ldnshread(struct ldfile *, const char *, struct scnhdr *);\nextern int                    ldnsseek(struct ldfile *, const char *);\nextern int                    ldohseek(struct ldfile *);\nextern struct ldfile *        ldopen(const char *, struct ldfile *);\nextern int                    ldrseek(struct ldfile *, unsigned int);\nextern int                    ldshread(struct ldfile *, unsigned int, struct scnhdr *);\nextern int                    ldsseek(struct ldfile *, unsigned int);\nextern long int               ldtbindex(struct ldfile *);\nextern int                    ldtbread(struct ldfile *, long int, struct syment *);\nextern int                    ldtbseek(struct ldfile *);\nextern int                    leaveok(WINDOW *, int);\nextern dl_t                   lexp10(/* ??? */);\nextern void *                 lfind(const void *, const void *, size_t *, size_t, int (*) (const void *, const void *));\nextern double                 lgamma(double);\nextern int                    link(const char *, const char *);\nextern FIELD *                link_field(FIELD *, int, int);\nextern FIELDTYPE *            link_fieldtype(FIELDTYPE *, FIELDTYPE *);\nextern char **                listdev(/* ??? */);\nextern char **                listdgrp(/* ??? */);\nextern dl_t                   llog10(/* ??? */);\nextern dl_t                   lmul(/* ??? */);\nextern struct lconv *         localeconv(void);\nextern struct tm *            localtime(const time_t *);\nextern int                    lock(int, int, long);\nextern int                    lockf(int, int, off_t);\nextern double                 log(double);\nextern double                 log10(double);\nextern float                  log10f(float);\nextern double                 logb(double);\nextern float                  logf(float);\nextern char *                 logname(void);\nextern void                   longjmp(jmp_buf, int);\nextern char *                 longname(void);\nextern long int               lrand48(void);\nextern void *                 lsearch(const void *, void *, size_t *, size_t, int (*) (const void *, const void *));\nextern off_t                  lseek(int, off_t, int);\nextern dl_t                   lshiftl(/* ??? */);\nextern int                    lstat(const char *, struct stat *);\nextern dl_t                   lsub(/* ??? */);\nextern void                   ltol3(char *, const long int *, int);\nextern int                    m_addch(int);\nextern int                    m_addstr(char *);\nextern int                    m_clear(void);\nextern int                    m_erase(void);\nextern WINDOW *               m_initscr(void);\nextern int                    m_move(int, int);\nextern SCREEN *               m_newterm(char *, FILE *, FILE *);\nextern int                    m_refresh(void);\nextern int                    maillock(char *, int);\nextern int                    mailunlock(void);\nextern major_t                major(dev_t);\nextern datum                  makdatum(/* ??? */);\nextern void                   makecontext(ucontext_t *, void (*) (/* ??? */), int, ...);\nextern dev_t                  makedev(major_t, minor_t);\nextern struct utmpx *         makeutx(const struct utmpx *);\nextern struct mallinfo        mallinfo(void);\nextern void *                 malloc(size_t);\nextern int                    mallopt(int, int);\nextern int                    map_button(long unsigned int);\nextern int                    matherr(struct exception *);\nextern int                    mbftowc(char *, wchar_t *, int (*) (/* ??? */), int *);\nextern int                    mblen(const char *, size_t);\nextern size_t                 mbstowcs(wchar_t *, const char *, size_t);\nextern int                    mbtowc(wchar_t *, const char *, size_t);\nextern void *                 memalign(size_t, size_t);\nextern void *                 memccpy(void *, const void *, int, size_t);\nextern void *                 memchr(const void *, int, size_t);\nextern int                    memcmp(const void *, const void *, size_t);\nextern void *                 memcpy(void *, const void *, size_t);\nextern int                    memlock(/* ??? */);\nextern int                    memlocked(/* ??? */);\nextern void *                 memmove(void *, const void *, size_t);\nextern void *                 memset(void *, int, size_t);\nextern int                    memunlock(/* ??? */);\nextern chtype                 menu_back(MENU *);\nextern int                    menu_driver(MENU *, int);\nextern chtype                 menu_fore(MENU *);\nextern void                   menu_format(MENU *, int *, int *);\nextern chtype                 menu_grey(MENU *);\nextern PTF_void               menu_init(MENU *);\nextern ITEM **                menu_items(MENU *);\nextern char *                 menu_mark(MENU *);\nextern OPTIONS                menu_opts(MENU *);\nextern int                    menu_opts_off(MENU *, OPTIONS);\nextern int                    menu_opts_on(MENU *, OPTIONS);\nextern int                    menu_pad(MENU *);\nextern char *                 menu_pattern(MENU *);\nextern WINDOW *               menu_sub(MENU *);\nextern PTF_void               menu_term(MENU *);\nextern char *                 menu_userptr(MENU *);\nextern WINDOW *               menu_win(MENU *);\nextern int                    meta(WINDOW *, int);\nextern void                   mfree(struct map *, size_t, u_long);\nextern int                    mincore(caddr_t, size_t, char *);\nextern minor_t                minor(dev_t);\nextern int                    mkdir(const char *, mode_t);\nextern int                    mkdirp(const char *, mode_t);\nextern int                    mkfifo(const char *, mode_t);\nextern int                    mknod(const char *, mode_t, dev_t);\nextern int                    mkstemp(char *);\nextern char *                 mktemp(char *);\nextern time_t                 mktime(struct tm *);\nextern caddr_t                mmap(/* ??? */);\nextern double                 modf(double, double *);\nextern float                  modff(float, float *);\nextern struct utmpx *         modutx(const struct utmpx *);\nextern void                   monitor(int (*) (/* ??? */), int (*) (/* ??? */), WORD *, int, int);\nextern int                    mount(const char *, const char *, int, ...);\nextern int                    mouse_off(long int);\nextern int                    mouse_on(long int);\nextern int                    mouse_set(long int);\nextern int                    move_field(FIELD *, int, int);\nextern int                    move_panel(PANEL *, int, int);\nextern int                    mprotect(/* ??? */);\nextern long int               mrand48(void);\nextern int                    msgctl(int, int, ...);\nextern int                    msgget(key_t, int);\nextern int                    msgrcv(int, void *, size_t, long int, int);\nextern int                    msgsnd(int, const void *, size_t, int);\nextern int                    munmap(/* ??? */);\nextern int                    mvcur(int, int, int, int);\nextern int                    mvderwin(WINDOW *, int, int);\nextern int                    mvprintw(int, int, ...);\nextern int                    mvscanw(int, int, ...);\nextern int                    mvwin(WINDOW *, int, int);\nextern int                    mvwprintw(WINDOW *, int, int, ...);\nextern int                    mvwscanw(WINDOW *, int, int, ...);\nextern int                    napms(int);\nextern void                   netdir_free(char *, int);\nextern int                    netdir_getbyaddr(struct netconfig *, struct nd_hostservlist **, struct netbuf *);\nextern int                    netdir_getbyname(struct netconfig *, struct nd_hostserv *, struct nd_addrlist **);\nextern int                    netdir_options(struct netconfig *, int, int, char *);\nextern void                   netdir_perror(char *);\nextern char *                 netdir_sperror(/* ??? */);\nextern FIELD *                new_field(int, int, int, int, int, int);\nextern FIELDTYPE *            new_fieldtype(PTF_int, PTF_int);\nextern FORM *                 new_form(FIELD **);\nextern ITEM *                 new_item(char *, char *);\nextern MENU *                 new_menu(ITEM **);\nextern int                    new_page(FIELD *);\nextern PANEL *                new_panel(WINDOW *);\nextern int                    newkey(char *, int, int);\nextern WINDOW *               newpad(int, int);\nextern SCREEN *               newscreen(char *, int, int, int, FILE *, FILE *);\nextern SCREEN *               newterm32(char *, FILE *, FILE *);\nextern WINDOW *               newwin(int, int, int, int);\nextern double                 nextafter(double, double);\nextern datum                  nextkey(datum);\nextern int                    nftw(const char *, int (*) (const char *, const struct stat *, int, struct FTW *), int, int);\nextern int                    nice(int);\nextern int                    nl(void);\nextern char *                 nl_langinfo(nl_item);\nextern int                    nlist(const char *, struct nlist *);\nextern int                    nocbreak(void);\nextern int                    nocrmode(void);\nextern int                    nodelay(WINDOW *, int);\nextern int                    noecho(void);\nextern int                    nonl(void);\nextern int                    noraw(void);\nextern int                    notimeout(WINDOW *, int);\nextern long int               nrand48(short unsigned int *);\nextern int                    ns_close(/* ??? */);\nextern struct nssend *        ns_rcv(/* ??? */);\nextern int                    ns_send(/* ??? */);\nextern int                    ns_setup(/* ??? */);\nextern long unsigned int      ntohl(long unsigned int);\nextern short unsigned int     ntohs(unsigned int);\nextern int                    nuname(struct utsname *);\nextern int                    open(const char *, int, ...);\nextern DIR *                  opendir(const char *);\nextern int                    openprivwait(/* ??? */);\nextern int                    openwait(/* ??? */);\nextern int                    overlay(WINDOW *, WINDOW *);\nextern int                    overwrite(WINDOW *, WINDOW *);\nextern int                    p2close(FILE **);\nextern int                    p2open(const char *, FILE **);\nextern int                    p32echochar(WINDOW *, chtype);\nextern char *                 p_cdname(/* ??? */);\nextern char *                 p_class(/* ??? */);\nextern char *                 p_rr(/* ??? */);\nextern char *                 p_type(/* ??? */);\nextern int                    pair_content(int, short int *, short int *);\nextern PANEL *                panel_above(PANEL *);\nextern PANEL *                panel_below(PANEL *);\nextern char *                 panel_userptr(PANEL *);\nextern WINDOW *               panel_window(PANEL *);\nextern long int               pathconf(const char *, int);\nextern char *                 pathfind(const char *, const char *, const char *);\nextern int                    pause(void);\nextern int                    pclose(FILE *);\nextern void                   perror(const char *);\nextern struct pfdat *         pfind(/* ??? */);\nextern int                    pglstlk(/* ??? */);\nextern int                    pglstunlk(/* ??? */);\nextern int                    pid_slot(proc_t *);\nextern int                    pipe(int *);\nextern int                    plock(int);\nextern struct pmaplist *      pmap_getmaps(/* ??? */);\nextern u_short                pmap_getport(/* ??? */);\nextern enum clnt_stat         pmap_rmtcall(/* ??? */);\nextern int                    pmap_set(/* ??? */);\nextern int                    pmap_unset(/* ??? */);\nextern int                    pnoutrefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    poll(struct pollfd *, long unsigned int, int);\nextern FILE *                 popen(const char *, const char *);\nextern int                    pos_form_cursor(FORM *);\nextern int                    pos_menu_cursor(MENU *);\nextern int                    post_form(FORM *);\nextern int                    post_menu(MENU *);\nextern double                 pow(double, double);\nextern float                  powf(float, float);\nextern int                    prefresh(WINDOW *, int, int, int, int, int, int);\nextern int                    printf(const char *, ...);\nextern int                    printw(char *, ...);\nextern void                   privsig(/* ??? */);\nextern void                   profil(short unsigned int *, size_t, int, unsigned int);\nextern void                   psiginfo(siginfo_t *, char *);\nextern void                   psignal(int, const char *);\nextern int                    ptrace(int, pid_t, int, int);\nextern int                    putc(int, FILE *);\nextern int                    putchar(int);\nextern int                    putenv(char *);\nextern int                    putmsg(int, const struct strbuf *, const struct strbuf *, int);\nextern int                    putp(char *);\nextern int                    putpmsg(int, const struct strbuf *, const struct strbuf *, int, int);\nextern int                    putpwent(const struct passwd *, FILE *);\nextern int                    puts(const char *);\nextern int                    putspent(const struct spwd *, FILE *);\nextern struct utmp *          pututline(const struct utmp *);\nextern struct utmpx *         pututxline(const struct utmpx *);\nextern int                    putw(int, FILE *);\nextern int                    putwin(WINDOW *, FILE *);\nextern void                   qsort(void *, size_t, size_t, int (*) (const void *, const void *));\nextern int                    raise(int);\nextern int                    rand(void);\nextern long                   random(void);\nextern int                    raw(void);\nextern ssize_t                read(int, void *, size_t);\nextern struct dirent *        readdir(DIR *);\nextern ssize_t                readlink(const char *, char *, size_t);\nextern void *                 realloc(void *, size_t);\nextern char *                 realpath(char *, char *);\nextern int                    redrawwin(WINDOW *);\nextern char *                 regcmp(const char *, ...);\nextern char *                 regex(const char *, const char *, ...);\nextern double                 remainder(double, double);\nextern int                    remio(/* ??? */);\nextern int                    remove(const char *);\nextern void                   remque(struct qelem *);\nextern int                    rename(const char *, const char *);\nextern int                    replace_panel(PANEL *, WINDOW *);\nextern int                    request_mouse_pos(void);\nextern struct reservdev **    reservdev(/* ??? */);\nextern int                    reset_prog_mode(void);\nextern int                    reset_shell_mode(void);\nextern int                    resetty(void);\nextern int                    restartterm(char *, int, int *);\nextern void                   rewind(FILE *);\nextern void                   rewinddir(DIR *);\nextern int                    rf_falloc(/* ??? */);\nextern char *                 rindex(const char *, int);\nextern double                 rint(double);\nextern int                    ripoffline(int, int (*) (WINDOW *, int));\nextern int                    rmdir(const char *);\nextern int                    rmdirp(char *, char *);\nextern enum clnt_stat         rpc_broadcast(/* ??? */);\nextern enum clnt_stat         rpc_call(/* ??? */);\nextern int                    rpcb_getaddr(/* ??? */);\nextern RPCBLIST *             rpcb_getmaps(/* ??? */);\nextern int                    rpcb_gettime(/* ??? */);\nextern enum clnt_stat         rpcb_rmtcall(/* ??? */);\nextern int                    rpcb_set(/* ??? */);\nextern char *                 rpcb_taddr2uaddr(/* ??? */);\nextern struct netbuf *        rpcb_uaddr2taddr(/* ??? */);\nextern int                    rpcb_unset(/* ??? */);\nextern void                   rpctest_service(/* ??? */);\nextern int                    run_crypt(long int, char *, unsigned int, int *);\nextern int                    run_setkey(int *, const char *);\nextern int                    savetty(void);\nextern void *                 sbrk(int);\nextern double                 scalb(double, double);\nextern int                    scale_form(FORM *, int *, int *);\nextern int                    scale_menu(MENU *, int *, int *);\nextern int                    scanf(const char *, ...);\nextern int                    scanw(char *, ...);\nextern int                    scr_dump(char *);\nextern int                    scr_init(char *);\nextern int                    scr_restore(char *);\nextern int                    scroll(WINDOW *);\nextern int                    scrollok(WINDOW *, int);\nextern int                    scrwidth(wchar_t);\nextern int                    sdfree(char *);\nextern char *                 sdget(char *, int, ...);\nextern short unsigned int *   seed48(short unsigned int *);\nextern void                   seekdir(DIR *, long int);\nextern int                    semctl(int, int, int, ...);\nextern int                    semget(key_t, int, int);\nextern int                    semop(int, struct sembuf *, unsigned int);\nextern int                    send(int, char *, int, int);\nextern int                    set_current_field(FORM *, FIELD *);\nextern int                    set_current_item(MENU *, ITEM *);\nextern int                    set_field_back(FIELD *, chtype);\nextern int                    set_field_buffer(FIELD *, int, char *);\nextern int                    set_field_fore(FIELD *, chtype);\nextern int                    set_field_init(FORM *, PTF_void);\nextern int                    set_field_just(FIELD *, int);\nextern int                    set_field_opts(FIELD *, OPTIONS);\nextern int                    set_field_pad(FIELD *, int);\nextern int                    set_field_status(FIELD *, int);\nextern int                    set_field_term(FORM *, PTF_void);\nextern int                    set_field_type(FIELD *, FIELDTYPE *, ...);\nextern int                    set_field_userptr(FIELD *, char *);\nextern int                    set_fieldtype_arg(FIELDTYPE *, PTF_charP, PTF_charP, PTF_void);\nextern int                    set_fieldtype_choice(FIELDTYPE *, PTF_int, PTF_int);\nextern int                    set_form_fields(FORM *, FIELD **);\nextern int                    set_form_init(FORM *, PTF_void);\nextern int                    set_form_opts(FORM *, OPTIONS);\nextern int                    set_form_page(FORM *, int);\nextern int                    set_form_sub(FORM *, WINDOW *);\nextern int                    set_form_term(FORM *, PTF_void);\nextern int                    set_form_userptr(FORM *, char *);\nextern int                    set_form_win(FORM *, WINDOW *);\nextern int                    set_item_init(MENU *, PTF_void);\nextern int                    set_item_opts(ITEM *, OPTIONS);\nextern int                    set_item_term(MENU *, PTF_void);\nextern int                    set_item_userptr(ITEM *, char *);\nextern int                    set_item_value(ITEM *, int);\nextern int                    set_max_field(FIELD *, int);\nextern int                    set_menu_back(MENU *, chtype);\nextern int                    set_menu_fore(MENU *, chtype);\nextern int                    set_menu_format(MENU *, int, int);\nextern int                    set_menu_grey(MENU *, chtype);\nextern int                    set_menu_init(MENU *, PTF_void);\nextern int                    set_menu_items(MENU *, ITEM **);\nextern int                    set_menu_mark(MENU *, char *);\nextern int                    set_menu_opts(MENU *, OPTIONS);\nextern int                    set_menu_pad(MENU *, int);\nextern int                    set_menu_pattern(MENU *, char *);\nextern int                    set_menu_sub(MENU *, WINDOW *);\nextern int                    set_menu_term(MENU *, PTF_void);\nextern int                    set_menu_userptr(MENU *, char *);\nextern int                    set_menu_win(MENU *, WINDOW *);\nextern int                    set_new_page(FIELD *, int);\nextern int                    set_panel_userptr(PANEL *, char *);\nextern int                    set_top_row(MENU *, int);\nextern void                   setbuf(FILE *, char *);\nextern int                    setcontext(ucontext_t *);\nextern SCREEN *               setcurscreen(SCREEN *);\nextern TERMINAL *             setcurterm(TERMINAL *);\nextern FILE *                 setexportent(void);\nextern int                    setgid(gid_t);\nextern void                   setgrent(void);\nextern int                    setgroups(int, const gid_t *);\nextern int                    sethostname(char *, int);\nextern int                    setitimer(int, struct itimerval *, struct itimerval *);\nextern int                    setjmp(jmp_buf);\nextern void                   setkey(const char *);\nextern char *                 setlocale(int, const char *);\nextern FILE *                 setmntent(char *, char *);\nextern void *                 setnetconfig(void);\nextern void *                 setnetpath(void);\nextern int                    setpgid(pid_t, pid_t);\nextern pid_t                  setpgrp(void);\nextern int                    setpgrp2(pid_t, pid_t);\nextern int                    setpriority(int, int, int);\nextern int                    setprivwait(/* ??? */);\nextern void                   setpwent(void);\nextern int                    setregid(gid_t, gid_t);\nextern int                    setreuid(uid_t, uid_t);\nextern int                    setrlimit(int, struct rlimit *);\nextern int                    setrpcent(int);\nextern pid_t                  setsid(void);\nextern void                   setspent(void);\nextern char *                 setstate(char *);\nextern int                    setsyx(int, int);\nextern int                    setterm(char *);\nextern int                    setuid(uid_t);\nextern int                    setupterm(char *, int, int *);\nextern void                   setutent(void);\nextern void                   setutxent(void);\nextern int                    setvbuf(FILE *, char *, int, size_t);\nextern long int               sgetl(const char *);\nextern void *                 shmat(int, void *, int);\nextern int                    shmctl(int, int, ...);\nextern int                    shmdt(void *);\nextern int                    shmget(key_t, int, int);\nextern int                    show_panel(PANEL *);\nextern int                    sigaction(int, const struct sigaction *, struct sigaction *);\nextern int                    sigaddset(sigset_t *, int);\nextern int                    sigaltstack(const stack_t *, stack_t *);\nextern int                    sigblock(int);\nextern int                    sigdelset(sigset_t *, int);\nextern int                    sigemptyset(sigset_t *);\nextern int                    sigfillset(sigset_t *);\nextern int                    sighold(int);\nextern int                    sigignore(int);\nextern int                    siginterrupt(int, int);\nextern int                    sigismember(const sigset_t *, int);\nextern void                   siglongjmp(sigjmp_buf, int);\nextern signal_ret_t (*        signal(int, signal_ret_t (*) (int))) (int);\nextern int                    sigpause(int);\nextern int                    sigpending(sigset_t *);\nextern int                    sigprocmask(int, const sigset_t *, sigset_t *);\nextern int                    sigrelse(int);\nextern int                    sigsend(idtype_t, id_t, int);\nextern int                    sigsendset(const procset_t *, int);\nextern void (*                sigset(int, void (*) (int))) (int);\nextern int                    sigsetjmp(sigjmp_buf, int);\nextern int                    sigsetmask(int);\nextern int                    sigsuspend(sigset_t *);\nextern double                 sin(double);\nextern float                  sinf(float);\nextern double                 sinh(double);\nextern float                  sinhf(float);\nextern unsigned int           sleep(unsigned int);\nextern int                    slk_attroff(chtype);\nextern int                    slk_attron(chtype);\nextern int                    slk_attrset(chtype);\nextern int                    slk_clear(void);\nextern int                    slk_init(int);\nextern char *                 slk_label(int);\nextern int                    slk_noutrefresh(void);\nextern int                    slk_refresh(void);\nextern int                    slk_restore(void);\nextern int                    slk_set(int, char *, int);\nextern int                    slk_start(int, int *);\nextern int                    slk_touch(void);\nextern int                    socket (int, int, int);\nextern void *                 sprayproc_clear_1(/* ??? */);\nextern spraycumul *           sprayproc_get_1(/* ??? */);\nextern void *                 sprayproc_spray_1(/* ??? */);\nextern int                    sprintf(char *, const char *, ...);\nextern void                   sputl(long int, char *);\nextern double                 sqrt(double);\nextern float                  sqrtf(float);\nextern void                   srand(unsigned int);\nextern void                   srand48(long int);\nextern void                   srandom(int);\nextern int                    sscanf(const char *, const char *, ...);\nextern int (*                 ssignal(int, int (*) (int))) (int);\nextern int                    start_color(void);\nextern int                    stat(const char *, struct stat *);\nextern int                    statfs(const char *, struct statfs *, int, int);\nextern int                    statvfs(const char *, struct statvfs *);\nextern int                    step(const char *, const char *);\nextern int                    stime(const time_t *);\nextern struct netbuf *        stoa(char *, struct netbuf *);\nextern void                   store(datum, datum);\nextern char *                 strcadd(char *, const char *);\nextern int                    strcasecmp(const char *, const char *);\nextern char *                 strcat(char *, const char *);\nextern char *                 strccpy(char *, const char *);\nextern char *                 strchr(const char *, int);\nextern void                   strclearctty(/* ??? */);\nextern void                   strclearpg(/* ??? */);\nextern void                   strclearsid(/* ??? */);\nextern int                    strcmp(const char *, const char *);\nextern int                    strcoll(const char *, const char *);\nextern char *                 strcpy(char *, const char *);\nextern size_t                 strcspn(const char *, const char *);\nextern char *                 strdup(const char *);\nextern char *                 streadd(char *, const char *, const char *);\nextern char *                 strecpy(char *, const char *, const char *);\nextern char *                 strerror(int);\nextern int                    strfind(const char *, const char *);\nextern size_t                 strftime(char *, size_t, const char *, const struct tm *);\nextern size_t                 strlen(const char *);\nextern int                    strncasecmp(const char *, const char *, size_t);\nextern char *                 strncat(char *, const char *, size_t);\nextern int                    strncmp(const char *, const char *, size_t);\nextern char *                 strncpy(char *, const char *, size_t);\nextern char *                 strpbrk(const char *, const char *);\nextern char *                 strrchr(const char *, int);\nextern char *                 strrspn(const char *, const char *);\nextern size_t                 strspn(const char *, const char *);\nextern char *                 strstr(const char *, const char *);\nextern double                 strtod(const char *, char **);\nextern char *                 strtok(char *, const char *);\nextern long int               strtol(const char *, char **, int);\nextern long unsigned int      strtoul(const char *, char **, int);\nextern char *                 strtrns(const char *, const char *, const char *, char *);\nextern size_t                 strxfrm(char *, const char *, size_t);\nextern WINDOW *               subpad(WINDOW *, int, int, int, int);\nextern WINDOW *               subwin(WINDOW *, int, int, int, int);\nextern int                    svc_create(/* ??? */);\nextern SVCXPRT *              svc_fd_create(/* ??? */);\nextern void                   svc_getreqset(/* ??? */);\nextern SVCXPRT *              svc_raw_create(/* ??? */);\nextern int                    svc_reg(/* ??? */);\nextern SVCXPRT *              svc_tli_create(/* ??? */);\nextern SVCXPRT *              svc_tp_create(/* ??? */);\nextern void                   svc_unreg(/* ??? */);\nextern SVCXPRT *              svc_vc_create(/* ??? */);\nextern void                   svcerr_systemerr(/* ??? */);\nextern SVCXPRT *              svcfd_create(/* ??? */);\nextern SVCXPRT *              svcraw_create(/* ??? */);\nextern SVCXPRT *              svctcp_create(/* ??? */);\nextern SVCXPRT *              svcudp_bufcreate(/* ??? */);\nextern SVCXPRT *              svcudp_create(/* ??? */);\nextern void                   swab(const char *, char *, int);\nextern int                    swapcontext(ucontext_t *, ucontext_t *);\nextern int                    symlink(const char *, const char *);\nextern void                   sync(void);\nextern int                    syncok(WINDOW *, int);\nextern int                    syscall(int, ...);\nextern long int               sysconf(int);\nextern int                    sysfs(int, ...);\nextern int                    sysinfo(int, char *, long int);\nextern int                    system(const char *);\nextern char *                 taddr2uaddr(struct netconfig *, struct netbuf *);\nextern double                 tan(double);\nextern float                  tanf(float);\nextern double                 tanh(double);\nextern float                  tanhf(float);\nextern int                    tcdrain(int);\nextern int                    tcflow(int, int);\nextern int                    tcflush(int, int);\nextern int                    tcgetattr(int, struct termios *);\nextern pid_t                  tcgetpgrp(int);\nextern pid_t                  tcgetsid(int);\nextern int                    tcsendbreak(int, int);\nextern int                    tcsetattr(int, int, const struct termios *);\nextern int                    tcsetpgrp(int, pid_t);\nextern void *                 tdelete(const void *, void **, int (*) (const void *, const void *));\nextern long int               telldir(DIR *);\nextern char *                 tempnam(const char *, const char *);\nextern chtype                 termattrs(void);\nextern void                   termerr(void);\nextern char *                 termname(void);\nextern void *                 tfind(const void *, void *const *, int (*) (const void *, const void *));\nextern int                    tgetent(char *, char *);\nextern int                    tgetflag(char *);\nextern int                    tgetnum(char *);\nextern char *                 tgetstr(char *, char **);\nextern char *                 tgoto(char *, int, int);\nextern char *                 tigetstr(char *);\nextern time_t                 time(time_t *);\nextern clock_t                times(struct tms *);\nextern char *                 timezone(int, int);\nextern void                   tinputfd(int);\nextern FILE *                 tmpfile(void);\nextern char *                 tmpnam(char *);\nextern int                    toascii(int);\nextern int                    tolower(int);\nextern int                    top_panel(PANEL *);\nextern int                    top_row(MENU *);\nextern int                    touchline(WINDOW *, int, int);\nextern int                    touchwin(WINDOW *);\nextern int                    toupper(int);\nextern char *                 tparm(/* ??? */);\nextern int                    tputs(char *, int, int (*) (char));\nextern int                    traceoff(void);\nextern int                    traceon(void);\nextern int                    truncate(const char *, off_t);\nextern void *                 tsearch(const void *, void **, int (*) (const void *, const void *));\nextern char *                 ttyname(int);\nextern int                    ttyslot(void);\nextern void                   twalk(void *, void (*) (void *, VISIT, int));\nextern int                    typeahead(int);\nextern void                   tzset(void);\nextern struct netbuf *        uaddr2taddr(struct netconfig *, char *);\nextern int                    uadmin(int, int, int);\nextern unsigned               ualarm(unsigned, unsigned);\nextern int                    ulckpwdf(void);\nextern long int               ulimit(int, ...);\nextern mode_t                 umask(mode_t);\nextern int                    umount(const char *);\nextern int                    uname(struct utsname *);\nextern char *                 unctrl(int);\nextern void                   undial(int);\nextern int                    ungetc(int, FILE *);\nextern int                    ungetch(int);\nextern int                    unlink(const char *);\nextern int                    unordered(double, double);\nextern int                    unpost_form(FORM *);\nextern int                    unpost_menu(MENU *);\nextern int                    unremio(/* ??? */);\nextern int                    untouchwin(WINDOW *);\nextern void                   update_panels(void);\nextern void                   updwtmp(const char *, struct utmp *);\nextern void                   updwtmpx(const char *, struct utmpx *);\nextern void                   use_env(int);\nextern unsigned               usleep(unsigned);\nextern int                    ustat(dev_t, struct ustat *);\nextern int                    utime(const char *, const struct utimbuf *);\nextern int                    utmpname(const char *);\nextern int                    utmpxname(const char *);\nextern void                   va_end(__gnuc_va_list);\nextern int                    vadvise(int);\nextern void *                 valloc(size_t);\nextern pid_t                  vfork(void);\nextern int                    vfprintf(FILE *, const char *, __gnuc_va_list);\nextern int                    vhangup(void);\nextern int                    vid32attr(chtype);\nextern int                    vid32puts(chtype, int (*) (char));\nextern void                   vidupdate(chtype, chtype, int (*) (char));\nextern int                    vn_close(/* ??? */);\nextern int                    vprintf(const char *, __gnuc_va_list);\nextern int                    vsprintf(char *, const char *, __gnuc_va_list);\nextern int                    vwprintw(WINDOW *, char *, void *);\nextern int                    vwscanw(WINDOW *, char *, void *);\nextern int                    w32addch(WINDOW *, chtype);\nextern int                    w32attroff(WINDOW *, chtype);\nextern int                    w32attron(WINDOW *, chtype);\nextern int                    w32attrset(WINDOW *, chtype);\nextern int                    w32echochar(WINDOW *, chtype);\nextern int                    w32insch(WINDOW *, chtype);\nextern int                    waddchnstr(WINDOW *, chtype *, int);\nextern int                    waddnstr(WINDOW *, char *, int);\nextern int                    waddstr(WINDOW *, char *);\nextern pid_t                  wait(wait_arg_t *);\nextern pid_t                  wait3(union wait *, int, struct rusage *);\nextern int                    waitid(idtype_t, id_t, siginfo_t *, int);\nextern pid_t                  waitpid(pid_t, int *, int);\nextern void *                 wallproc_wall_1(/* ??? */);\nextern int                    wbkgd(WINDOW *, chtype);\nextern void                   wbkgdset(WINDOW *, chtype);\nextern int                    wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);\nextern int                    wclear(WINDOW *);\nextern int                    wclrtobot(WINDOW *);\nextern int                    wclrtoeol(WINDOW *);\nextern size_t                 wcstombs(char *, const wchar_t *, size_t);\nextern int                    wctomb(char *, wchar_t);\nextern void                   wcursyncup(WINDOW *);\nextern int                    wdelch(WINDOW *);\nextern int                    wdeleteln(WINDOW *);\nextern int                    werase(WINDOW *);\nextern int                    wgetch(WINDOW *);\nextern int                    wgetnstr(WINDOW *, char *, int);\nextern int                    wgetstr(WINDOW *, char *);\nextern int                    whline(WINDOW *, chtype, int);\nextern chtype                 winch(WINDOW *);\nextern int                    winchnstr(WINDOW *, chtype *, int);\nextern int                    winchstr(WINDOW *, chtype *);\nextern int                    winnstr(WINDOW *, char *, int);\nextern int                    winsdelln(WINDOW *, int);\nextern int                    winsertln(WINDOW *);\nextern int                    winsnstr(WINDOW *, char *, int);\nextern int                    winstr(WINDOW *, char *);\nextern int                    wisprint(wchar_t);\nextern void                   wmouse_position(WINDOW *, int *, int *);\nextern int                    wmove(WINDOW *, int, int);\nextern int                    wnoutrefresh(WINDOW *);\nextern int                    wprintw(WINDOW *, ...);\nextern int                    wredrawln(WINDOW *, int, int);\nextern int                    wrefresh(WINDOW *);\nextern ssize_t                write(int, const void *, size_t);\nextern int                    wscanw(WINDOW *, ...);\nextern int                    wscrl(WINDOW *, int);\nextern int                    wsetscrreg(WINDOW *, int, int);\nextern int                    wstandend(WINDOW *);\nextern int                    wstandout(WINDOW *);\nextern void                   wsyncdown(WINDOW *);\nextern void                   wsyncup(WINDOW *);\nextern void                   wtimeout(WINDOW *, int);\nextern int                    wtouchln(WINDOW *, int, int, int);\nextern int                    wvline(WINDOW *, chtype, int);\nextern bool                   xdr_datum(/* ??? */);\nextern int                    xdr_double(/* ??? */);\nextern int                    xdr_exports(/* ??? */);\nextern int                    xdr_fhstatus(/* ??? */);\nextern int                    xdr_float(/* ??? */);\nextern int                    xdr_keybuf(/* ??? */);\nextern int                    xdr_mountlist(/* ??? */);\nextern int                    xdr_netbuf(/* ??? */);\nextern int                    xdr_path(/* ??? */);\nextern int                    xdr_pmap(/* ??? */);\nextern int                    xdr_pmaplist(/* ??? */);\nextern int                    xdr_pointer(/* ??? */);\nextern int                    xdr_reference(/* ??? */);\nextern int                    xdr_rmtcall_args(/* ??? */);\nextern int                    xdr_rmtcallres(/* ??? */);\nextern int                    xdr_rpcb(/* ??? */);\nextern int                    xdr_rpcb_rmtcallargs(/* ??? */);\nextern int                    xdr_rpcb_rmtcallres(/* ??? */);\nextern int                    xdr_rpcblist(/* ??? */);\nextern int                    xdr_sprayarr(/* ??? */);\nextern int                    xdr_spraycumul(/* ??? */);\nextern int                    xdr_spraytimeval(/* ??? */);\nextern int                    xdr_u_char(/* ??? */);\nextern int                    xdr_utmparr(/* ??? */);\nextern int                    xdr_utmpidlearr(/* ??? */);\nextern int                    xdr_vector(/* ??? */);\nextern int                    xdr_yp_buf(/* ??? */);\nextern bool                   xdr_yp_inaddr(/* ??? */);\nextern bool                   xdr_ypall(/* ??? */);\nextern int                    xdr_ypdelete_args(/* ??? */);\nextern bool                   xdr_ypdomain_wrap_string(/* ??? */);\nextern bool                   xdr_ypmap_parms(/* ??? */);\nextern bool                   xdr_ypmap_wrap_string(/* ??? */);\nextern bool                   xdr_ypowner_wrap_string(/* ??? */);\nextern bool                   xdr_yppushresp_xfr(/* ??? */);\nextern bool                   xdr_ypreq_key(/* ??? */);\nextern bool                   xdr_ypreq_newxfr(/* ??? */);\nextern bool                   xdr_ypreq_nokey(/* ??? */);\nextern bool                   xdr_ypreq_xfr(/* ??? */);\nextern bool                   xdr_ypresp_key_val(/* ??? */);\nextern bool                   xdr_ypresp_maplist(/* ??? */);\nextern bool                   xdr_ypresp_master(/* ??? */);\nextern bool                   xdr_ypresp_order(/* ??? */);\nextern bool                   xdr_ypresp_val(/* ??? */);\nextern int                    xdr_ypupdate_args(/* ??? */);\nextern void                   xdrrec_create(/* ??? */);\nextern int                    xdrrec_endofrecord(/* ??? */);\nextern int                    xdrrec_eof(/* ??? */);\nextern int                    xdrrec_skiprecord(/* ??? */);\nextern void                   xdrstdio_create(/* ??? */);\nextern void                   xprt_register(/* ??? */);\nextern void                   xprt_unregister(/* ??? */);\nextern double                 y0(double);\nextern double                 y1(double);\nextern double                 yn(int, double);\nextern int                    yp_all(char *, char *, struct ypall_callback *);\nextern int                    yp_bind(const char *);\nextern int                    yp_first(char *, char *, char **, int *, char **, int *);\nextern int                    yp_get_default_domain(char **);\nextern int                    yp_master(char *, char *, char **);\nextern int                    yp_match(char *, char *, char *, int, char **, int *);\nextern int                    yp_next(char *, char *, char *, int, char **, int *, char **, int *);\nextern int                    yp_order(char *, char *, int *);\nextern void                   yp_unbind(const char *);\nextern char *                 yperr_string(int);\nextern int                    ypprot_err(unsigned int);\nextern u_int *                ypu_change_1(/* ??? */);\nextern u_int *                ypu_delete_1(/* ??? */);\nextern u_int *                ypu_insert_1(/* ??? */);\nextern u_int *                ypu_store_1(/* ??? */);\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYS@TYPE": {"ttr": 11269, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "enum clnt_stat { ___fake1 };\nenum auth_stat { ___fake2 };\n\nstruct netconfig;\nstruct netbuf;\nstruct address;\nstruct tm;\nstruct ldfile;\nstruct syment;\nstruct stat;\nstruct timeval;\nstruct termios;\nstruct tms;\nstruct dma_cb;\nstruct cred;\nstruct vnode;\nstruct vattr;\nstruct uarg;\nstruct statfs;\nstruct statvfs;\nstruct dirent;\nstruct itimerval;\nstruct mnttab;\nstruct strbuf;\nstruct vfstab;\nstruct ldfile;\nstruct syment;\nstruct scnhdr;\nstruct exception;\nstruct nd_hostservlist;\nstruct nd_hostserv;\nstruct utsname;\nstruct uio;\nstruct pid;\nstruct pollfd;\nstruct nlist;\nstruct passwd;\nstruct spwd;\nstruct flock;\nstruct seg;\nstruct sembuf;\nstruct sigaction;\nstruct utimbuf;\nstruct map;\nstruct filehdr;\nstruct lineno;\nstruct nd_addrlist;\nstruct FTW;\nstruct buf;\nstruct ustat;\nstruct qelem;\nstruct prpsinfo;\nstruct user;\nstruct qelem;\nstruct execenv;\nstruct utmpx;\n\nstruct direct;\nstruct tm;\nstruct stat;\nstruct rlimit;\nstruct rusage;\nstruct sockaddr;\nstruct sockaddr_in;\nstruct timeval { int i; };\nstruct exportent;\nstruct fstab;\nstruct hostent;\nstruct in_addr { int i; };\nstruct ldfile;\nstruct mallinfo { int i; };\nstruct mint;\nstruct nmtent;\nstruct netent;\nstruct pmaplist;\nstruct protoent;\nstruct rpcent;\nstruct servent;\nstruct authdes_cred;\nstruct rpc_err;\nstruct ypall_callback;\n\nunion wait;\n\n/* Get size_t and wchar_t.  */\n#include <stddef.h>\n\n/* #include \"sys/types.h\" */\n#define ssize_t int\n\n/* The actual types used here are mostly wrong,\n   but it is not supposed to matter what types we use here.  */\n\ntypedef int dev_t;\ntypedef int pid_t;\ntypedef int gid_t;\ntypedef int off_t;\ntypedef int mode_t;\ntypedef int uid_t;\n\ntypedef int proc_t;\ntypedef int time_t;\ntypedef int addr_t;\ntypedef int caddr_t;\ntypedef int clock_t;\ntypedef int div_t;\ntypedef int ldiv_t;\ntypedef int dl_t;\ntypedef int major_t;\ntypedef int minor_t;\ntypedef int emcp_t;\ntypedef int fpclass_t;\ntypedef int index_t;\ntypedef int ecb_t;\ntypedef int aioop_t;\ntypedef int evver_t;\ntypedef int evcntlcmds_t;\ntypedef int idtype_t;\ntypedef int id_t;\ntypedef int procset_t;\ntypedef int hostid_t;\ntypedef int evpollcmds_t;\ntypedef int event_t;\ntypedef int hrtime_t;\ntypedef int evqcntlcmds_t;\ntypedef int sigset_t;\ntypedef int evsiginfo_t;\ntypedef int evcontext_t;\ntypedef int evta_t;\ntypedef int speed_t;\ntypedef int rlim_t;\ntypedef int cred_t;\ntypedef int file_t;\ntypedef int vnode_t;\ntypedef int vfs_t;\ntypedef int fpos_t;\ntypedef int exhda_t;\ntypedef int ucontext_t;\ntypedef int sess_t;\ntypedef int hrtcmd_t;\ntypedef int interval_t;\ntypedef int key_t;\ntypedef int daddr_t;\ntypedef int stack_t;\ntypedef int sigaction_t;\ntypedef int siginfo_t;\ntypedef int mblk_t;\ntypedef int paddr_t;\ntypedef int qband_t;\ntypedef int queue_t;\ntypedef int rf_resource_t;\ntypedef int sr_mount_t;\ntypedef int timer_t;\ntypedef int fpregset_t;\ntypedef int prstatus_t;\ntypedef int vfssw_t;\ntypedef int eucwidth_t;\ntypedef int page_t;\n\ntypedef int u_int;\ntypedef int u_short;\ntypedef int u_long;\ntypedef int u_char;\n\ntypedef int ushort;\ntypedef int ulong;\ntypedef int uint;\n\ntypedef int __gnuc_va_list;\n\ntypedef int archdr;\ntypedef int AUTH;\ntypedef int CLIENT;\ntypedef int DIR;\ntypedef int ENTRY;\ntypedef int Elf;\ntypedef int Elf32_Ehdr;\ntypedef int Elf32_Phdr;\ntypedef int Elf32_Shdr;\ntypedef int Elf_Arhdr;\ntypedef int Elf_Arsym;\ntypedef int Elf_Cmd;\ntypedef int Elf_Data;\ntypedef int Elf_Scn;\ntypedef int Elf_Type;\ntypedef int Elf_Kind;\ntypedef int FIELD;\ntypedef int FIELDTYPE;\ntypedef int PTF_int;\ntypedef int PTF_void;\ntypedef int PTF_charP;\ntypedef int FILE;\ntypedef int FORM;\ntypedef int ITEM;\ntypedef int MENU;\ntypedef int OPTIONS;\ntypedef int PANEL;\ntypedef int FTP_void;\ntypedef int RPCBLIST;\ntypedef int SCREEN;\ntypedef int SVCXPRT;\ntypedef int TERMINAL;\ntypedef int WINDOW;\ntypedef int bool;\ntypedef int nl_catd;\ntypedef int nl_item;\ntypedef int chtype;\ntypedef int datum;\ntypedef int fp_rnd;\ntypedef int spraycumul;\ntypedef int WORD;\ntypedef int VISIT;\ntypedef int ACTION;\n\ntypedef int *jmp_buf;\ntypedef int *sigjmp_buf;\ntypedef int xdrproc_t;\ntypedef int CALL;\ntypedef int bool_t;\ntypedef int DBM;\ntypedef int des_block;\ntypedef int resultproc_t;\n\n\n#ifdef BSD\n\n#define mode_t int\n#define uid_t int\n#define gid_t int\n#define time_t long\n#define pid_t int\n#define signal_ret_t int\n#define wait_arg_t union wait\n\n#else\n\n#define signal_ret_t void\n#define wait_arg_t int\n\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSTEM": {"ttr": 11271, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Get common system includes and various definitions and declarations based\n   on autoconf macros.\n   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#ifndef GCC_SYSTEM_H\n#define GCC_SYSTEM_H\n\n/* We must include stdarg.h before stdio.h.  */\n#include <stdarg.h>\n\n#ifndef va_copy\n# ifdef __va_copy\n#   define va_copy(d,s)  __va_copy((d),(s))\n# else\n#   define va_copy(d,s)  ((d) = (s))\n# endif\n#endif\n\n#ifdef HAVE_STDDEF_H\n# include <stddef.h>\n#endif\n\n#include <stdio.h>\n\n/* Define a generic NULL if one hasn't already been defined.  */\n#ifndef NULL\n#define NULL 0\n#endif\n\n/* The compiler is not a multi-threaded application and therefore we\n   do not have to use the locking functions.  In fact, using the locking\n   functions can cause the compiler to be significantly slower under\n   I/O bound conditions (such as -g -O0 on very large source files).\n\n   HAVE_DECL_PUTC_UNLOCKED actually indicates whether or not the stdio\n   code is multi-thread safe by default.  If it is set to 0, then do\n   not worry about using the _unlocked functions.\n\n   fputs_unlocked, fwrite_unlocked, and fprintf_unlocked are\n   extensions and need to be prototyped by hand (since we do not\n   define _GNU_SOURCE).  */\n\n#if defined HAVE_DECL_PUTC_UNLOCKED && HAVE_DECL_PUTC_UNLOCKED\n\n# ifdef HAVE_PUTC_UNLOCKED\n#  undef putc\n#  define putc(C, Stream) putc_unlocked (C, Stream)\n# endif\n# ifdef HAVE_FPUTC_UNLOCKED\n#  undef fputc\n#  define fputc(C, Stream) fputc_unlocked (C, Stream)\n# endif\n\n# ifdef HAVE_FPUTS_UNLOCKED\n#  undef fputs\n#  define fputs(String, Stream) fputs_unlocked (String, Stream)\n#  if defined (HAVE_DECL_FPUTS_UNLOCKED) && !HAVE_DECL_FPUTS_UNLOCKED\nextern int fputs_unlocked (const char *, FILE *);\n#  endif\n# endif\n# ifdef HAVE_FWRITE_UNLOCKED\n#  undef fwrite\n#  define fwrite(Ptr, Size, N, Stream) fwrite_unlocked (Ptr, Size, N, Stream)\n#  if defined (HAVE_DECL_FWRITE_UNLOCKED) && !HAVE_DECL_FWRITE_UNLOCKED\nextern int fwrite_unlocked (const void *, size_t, size_t, FILE *);\n#  endif\n# endif\n# ifdef HAVE_FPRINTF_UNLOCKED\n#  undef fprintf\n/* We can't use a function-like macro here because we don't know if\n   we have varargs macros.  */\n#  define fprintf fprintf_unlocked\n#  if defined (HAVE_DECL_FPRINTF_UNLOCKED) && !HAVE_DECL_FPRINTF_UNLOCKED\nextern int fprintf_unlocked (FILE *, const char *, ...);\n#  endif\n# endif\n\n#endif\n\n/* ??? Glibc's fwrite/fread_unlocked macros cause\n   \"warning: signed and unsigned type in conditional expression\".  */\n#undef fread_unlocked\n#undef fwrite_unlocked\n\n/* There are an extraordinary number of issues with <ctype.h>.\n   The last straw is that it varies with the locale.  Use libiberty's\n   replacement instead.  */\n#include <safe-ctype.h>\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#include <errno.h>\n\n#if !defined (errno) && defined (HAVE_DECL_ERRNO) && !HAVE_DECL_ERRNO\nextern int errno;\n#endif\n\n/* Some of glibc's string inlines cause warnings.  Plus we'd rather\n   rely on (and therefore test) GCC's string builtins.  */\n#define __NO_STRING_INLINES\n\n#ifdef STRING_WITH_STRINGS\n# include <string.h>\n# include <strings.h>\n#else\n# ifdef HAVE_STRING_H\n#  include <string.h>\n# else\n#  ifdef HAVE_STRINGS_H\n#   include <strings.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n\n/* If we don't have an overriding definition, set SUCCESS_EXIT_CODE and\n   FATAL_EXIT_CODE to EXIT_SUCCESS and EXIT_FAILURE respectively,\n   or 0 and 1 if those macros are not defined.  */\n#ifndef SUCCESS_EXIT_CODE\n# ifdef EXIT_SUCCESS\n#  define SUCCESS_EXIT_CODE EXIT_SUCCESS\n# else\n#  define SUCCESS_EXIT_CODE 0\n# endif\n#endif\n\n#ifndef FATAL_EXIT_CODE\n# ifdef EXIT_FAILURE\n#  define FATAL_EXIT_CODE EXIT_FAILURE\n# else\n#  define FATAL_EXIT_CODE 1\n# endif\n#endif\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n# include <sys/param.h>\n/* We use this identifier later and it appears in some vendor param.h's.  */\n# undef PREFETCH\n#endif\n\n#if HAVE_LIMITS_H\n# include <limits.h>\n#endif\n\n/* Get definitions of HOST_WIDE_INT and HOST_WIDEST_INT.  */\n#include \"hwint.h\"\n\n/* A macro to determine whether a VALUE lies inclusively within a\n   certain range without evaluating the VALUE more than once.  This\n   macro won't warn if the VALUE is unsigned and the LOWER bound is\n   zero, as it would e.g. with \"VALUE >= 0 && ...\".  Note the LOWER\n   bound *is* evaluated twice, and LOWER must not be greater than\n   UPPER.  However the bounds themselves can be either positive or\n   negative.  */\n#define IN_RANGE(VALUE, LOWER, UPPER) \\\n  ((unsigned HOST_WIDE_INT) ((VALUE) - (LOWER)) <= ((UPPER) - (LOWER)))\n\n/* Infrastructure for defining missing _MAX and _MIN macros.  Note that\n   macros defined with these cannot be used in #if.  */\n\n/* The extra casts work around common compiler bugs.  */\n#define INTTYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n/* The outer cast is needed to work around a bug in Cray C 5.0.3.0.\n   It is necessary at least when t == time_t.  */\n#define INTTYPE_MINIMUM(t) ((t) (INTTYPE_SIGNED (t) \\\n                             ? ~ (t) 0 << (sizeof(t) * CHAR_BIT - 1) : (t) 0))\n#define INTTYPE_MAXIMUM(t) ((t) (~ (t) 0 - INTTYPE_MINIMUM (t)))\n\n/* Use that infrastructure to provide a few constants.  */\n#ifndef UCHAR_MAX\n# define UCHAR_MAX INTTYPE_MAXIMUM (unsigned char)\n#endif\n\n#ifdef TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  ifdef HAVE_TIME_H\n#   include <time.h>\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#else\n# ifdef HAVE_SYS_FILE_H\n#  include <sys/file.h>\n# endif\n#endif\n\n#ifndef SEEK_SET\n# define SEEK_SET 0\n# define SEEK_CUR 1\n# define SEEK_END 2\n#endif\n#ifndef F_OK\n# define F_OK 0\n# define X_OK 1\n# define W_OK 2\n# define R_OK 4\n#endif\n#ifndef O_RDONLY\n# define O_RDONLY 0\n#endif\n#ifndef O_WRONLY\n# define O_WRONLY 1\n#endif\n\n/* Some systems define these in, e.g., param.h.  We undefine these names\n   here to avoid the warnings.  We prefer to use our definitions since we\n   know they are correct.  */\n\n#undef MIN\n#undef MAX\n#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))\n#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))\n\n/* Returns the least number N such that N * Y >= X.  */\n#define CEIL(x,y) (((x) + (y) - 1) / (y))\n\n#ifdef HAVE_SYS_WAIT_H\n#include <sys/wait.h>\n#endif\n\n#ifndef WIFSIGNALED\n#define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)\n#endif\n#ifndef WTERMSIG\n#define WTERMSIG(S) ((S) & 0x7f)\n#endif\n#ifndef WIFEXITED\n#define WIFEXITED(S) (((S) & 0xff) == 0)\n#endif\n#ifndef WEXITSTATUS\n#define WEXITSTATUS(S) (((S) & 0xff00) >> 8)\n#endif\n#ifndef WSTOPSIG\n#define WSTOPSIG WEXITSTATUS\n#endif\n#ifndef WCOREDUMP\n#define WCOREDUMP(S) ((S) & WCOREFLG)\n#endif\n#ifndef WCOREFLG\n#define WCOREFLG 0200\n#endif\n\n/* The HAVE_DECL_* macros are three-state, undefined, 0 or 1.  If they\n   are defined to 0 then we must provide the relevant declaration\n   here.  These checks will be in the undefined state while configure\n   is running so be careful to test \"defined (HAVE_DECL_*)\".  */\n\n#if defined (HAVE_DECL_ATOF) && !HAVE_DECL_ATOF\nextern double atof (const char *);\n#endif\n\n#if defined (HAVE_DECL_ATOL) && !HAVE_DECL_ATOL\nextern long atol (const char *);\n#endif\n\n#if defined (HAVE_DECL_FREE) && !HAVE_DECL_FREE\nextern void free (void *);\n#endif\n\n#if defined (HAVE_DECL_GETCWD) && !HAVE_DECL_GETCWD\nextern char *getcwd (char *, size_t);\n#endif\n\n#if defined (HAVE_DECL_GETENV) && !HAVE_DECL_GETENV\nextern char *getenv (const char *);\n#endif\n\n#if defined (HAVE_DECL_GETOPT) && !HAVE_DECL_GETOPT\nextern int getopt (int, char * const *, const char *);\n#endif\n\n#if defined (HAVE_DECL_GETWD) && !HAVE_DECL_GETWD\nextern char *getwd (char *);\n#endif\n\n#if defined (HAVE_DECL_SBRK) && !HAVE_DECL_SBRK\nextern void *sbrk (int);\n#endif\n\n#if defined (HAVE_DECL_STRSTR) && !HAVE_DECL_STRSTR\nextern char *strstr (const char *, const char *);\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#if defined (HAVE_DECL_MALLOC) && !HAVE_DECL_MALLOC\nextern void *malloc (size_t);\n#endif\n\n#if defined (HAVE_DECL_CALLOC) && !HAVE_DECL_CALLOC\nextern void *calloc (size_t, size_t);\n#endif\n\n#if defined (HAVE_DECL_REALLOC) && !HAVE_DECL_REALLOC\nextern void *realloc (void *, size_t);\n#endif\n\n/* If the system doesn't provide strsignal, we get it defined in\n   libiberty but no declaration is supplied.  */\n#if !defined (HAVE_STRSIGNAL) \\\n    || (defined (HAVE_DECL_STRSIGNAL) && !HAVE_DECL_STRSIGNAL)\n# ifndef strsignal\nextern const char *strsignal (int);\n# endif\n#endif\n\n#ifdef HAVE_GETRLIMIT\n# if defined (HAVE_DECL_GETRLIMIT) && !HAVE_DECL_GETRLIMIT\n#  ifndef getrlimit\nstruct rlimit;\nextern int getrlimit (int, struct rlimit *);\n#  endif\n# endif\n#endif\n\n#ifdef HAVE_SETRLIMIT\n# if defined (HAVE_DECL_SETRLIMIT) && !HAVE_DECL_SETRLIMIT\n#  ifndef setrlimit\nstruct rlimit;\nextern int setrlimit (int, const struct rlimit *);\n#  endif\n# endif\n#endif\n\n#if defined (HAVE_DECL_ABORT) && !HAVE_DECL_ABORT\nextern void abort (void);\n#endif\n\n#if defined (HAVE_DECL_SNPRINTF) && !HAVE_DECL_SNPRINTF\nextern int snprintf (char *, size_t, const char *, ...);\n#endif\n\n/* 1 if we have C99 designated initializers.  */\n#if !defined(HAVE_DESIGNATED_INITIALIZERS)\n#define HAVE_DESIGNATED_INITIALIZERS \\\n  ((GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L))\n#endif\n\n/* 1 if we have _Bool.  */\n#ifndef HAVE__BOOL\n# define HAVE__BOOL \\\n   ((GCC_VERSION >= 3000) || (__STDC_VERSION__ >= 199901L))\n#endif\n\n\n#if HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n\n/* Test if something is a normal file.  */\n#ifndef S_ISREG\n#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n#endif\n\n/* Test if something is a directory.  */\n#ifndef S_ISDIR\n#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n#endif\n\n/* Test if something is a character special file.  */\n#ifndef S_ISCHR\n#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)\n#endif\n\n/* Test if something is a block special file.  */\n#ifndef S_ISBLK\n#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)\n#endif\n\n/* Test if something is a socket.  */\n#ifndef S_ISSOCK\n# ifdef S_IFSOCK\n#   define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)\n# else\n#   define S_ISSOCK(m) 0\n# endif\n#endif\n\n/* Test if something is a FIFO.  */\n#ifndef S_ISFIFO\n# ifdef S_IFIFO\n#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)\n# else\n#  define S_ISFIFO(m) 0\n# endif\n#endif\n\n/* Approximate O_NONBLOCK.  */\n#ifndef O_NONBLOCK\n#define O_NONBLOCK O_NDELAY\n#endif\n\n/* Approximate O_NOCTTY.  */\n#ifndef O_NOCTTY\n#define O_NOCTTY 0\n#endif\n\n/* Define well known filenos if the system does not define them.  */\n#ifndef STDIN_FILENO\n# define STDIN_FILENO   0\n#endif\n#ifndef STDOUT_FILENO\n# define STDOUT_FILENO  1\n#endif\n#ifndef STDERR_FILENO\n# define STDERR_FILENO  2\n#endif\n\n/* Some systems have mkdir that takes a single argument.  */\n#ifdef MKDIR_TAKES_ONE_ARG\n# define mkdir(a,b) mkdir(a)\n#endif\n\n/* Provide a way to print an address via printf.  */\n#ifndef HOST_PTR_PRINTF\n# ifdef HAVE_PRINTF_PTR\n#  define HOST_PTR_PRINTF \"%p\"\n# elif SIZEOF_INT == SIZEOF_VOID_P\n#  define HOST_PTR_PRINTF \"%x\"\n# elif SIZEOF_LONG == SIZEOF_VOID_P\n#  define HOST_PTR_PRINTF \"%lx\"\n# else\n#  define HOST_PTR_PRINTF \"%llx\"\n# endif\n#endif /* ! HOST_PTR_PRINTF */\n\n/* By default, colon separates directories in a path.  */\n#ifndef PATH_SEPARATOR\n#define PATH_SEPARATOR ':'\n#endif\n\n/* Filename handling macros.  */\n#include \"filenames.h\"\n\n/* These should be phased out in favor of IS_DIR_SEPARATOR, where possible.  */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# ifdef HAVE_DOS_BASED_FILE_SYSTEM\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n#endif\n\n/* Get libiberty declarations.  */\n#include \"libiberty.h\"\n\n/* Provide a default for the HOST_BIT_BUCKET.\n   This suffices for POSIX-like hosts.  */\n\n#ifndef HOST_BIT_BUCKET\n#define HOST_BIT_BUCKET \"/dev/null\"\n#endif\n\n/* Be conservative and only use enum bitfields with GCC.\n   FIXME: provide a complete autoconf test for buggy enum bitfields.  */\n\n#if (GCC_VERSION > 2000)\n#define ENUM_BITFIELD(TYPE) __extension__ enum TYPE\n#else\n#define ENUM_BITFIELD(TYPE) unsigned int\n#endif\n\n/* We only use bool bitfields with gcc3.  Some supposedly C99\n   compilers don't handle them correctly.  */\n#if (GCC_VERSION >= 3000)\n#define BOOL_BITFIELD _Bool\n#else\n#define BOOL_BITFIELD unsigned int\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER)\t((size_t) &((TYPE *) 0)->MEMBER)\n#endif\n\n/* Various error reporting routines want to use __FUNCTION__.  */\n/* Also this isn't working properly in cross-compile mode */\n#if (GCC_VERSION < 2007) || defined(__MVS__) || defined(__CMS__) || \\\n    defined(__VSE__)\n#ifndef __FUNCTION__\n#define __FUNCTION__ \"?\"\n#endif /* ! __FUNCTION__ */\n#endif\n\n/* __builtin_expect(A, B) evaluates to A, but notifies the compiler that\n   the most likely value of A is B.  This feature was added at some point\n   between 2.95 and 3.0.  Let's use 3.0 as the lower bound for now.  */\n#if (GCC_VERSION < 3000)\n#define __builtin_expect(a, b) (a)\n#endif\n\n/* Provide some sort of boolean type.  We use stdbool.h if it's\n  available.  This must be after all inclusion of system headers,\n  as some of them will mess us up.  */\n#undef bool\n#undef true\n#undef false\n#undef TRUE\n#undef FALSE\n\n#ifdef HAVE_STDBOOL_H\n# include <stdbool.h>\n#else\n# if !HAVE__BOOL\ntypedef char _Bool;\n# endif\n# define bool _Bool\n# define true 1\n# define false 0\n#endif\n\n#define TRUE true\n#define FALSE false\n\n/* As the last action in this file, we poison the identifiers that\n   shouldn't be used.  Note, luckily gcc-3.0's token-based integrated\n   preprocessor won't trip on poisoned identifiers that arrive from\n   the expansion of macros.  E.g. #define strrchr rindex, won't error\n   if rindex is poisoned after this directive is issued and later on\n   strrchr is called.\n\n   Note: We define bypass macros for the few cases where we really\n   want to use the libc memory allocation routines.  Otherwise we\n   insist you use the \"x\" versions from libiberty.  */\n\n#define really_call_malloc malloc\n#define really_call_calloc calloc\n#define really_call_realloc realloc\n\n#if defined(FLEX_SCANNER) || defined(YYBISON) || defined(YYBYACC)\n/* Flex and bison use malloc and realloc.  Yuk.  Note that this means\n   really_call_* cannot be used in a .l or .y file.  */\n#define malloc xmalloc\n#define realloc xrealloc\n#endif\n\n#if (GCC_VERSION >= 3000)\n\n/* Note autoconf checks for prototype declarations and includes\n   system.h while doing so.  Only poison these tokens if actually\n   compiling gcc, so that the autoconf declaration tests for malloc\n   etc don't spuriously fail.  */\n#ifdef IN_GCC\n#undef calloc\n#undef strdup\n #pragma GCC poison calloc strdup\n\n#if !defined(FLEX_SCANNER) && !defined(YYBISON)\n#undef malloc\n#undef realloc\n #pragma GCC poison malloc realloc\n#endif\n\n/* Old target macros that have moved to the target hooks structure.  */\n #pragma GCC poison ASM_OPEN_PAREN ASM_CLOSE_PAREN\t\t\t\\\n\tFUNCTION_PROLOGUE FUNCTION_EPILOGUE\t\t\t\t\\\n\tFUNCTION_END_PROLOGUE FUNCTION_BEGIN_EPILOGUE\t\t\t\\\n\tDECL_MACHINE_ATTRIBUTES COMP_TYPE_ATTRIBUTES INSERT_ATTRIBUTES\t\\\n\tVALID_MACHINE_DECL_ATTRIBUTE VALID_MACHINE_TYPE_ATTRIBUTE\t\\\n\tSET_DEFAULT_TYPE_ATTRIBUTES SET_DEFAULT_DECL_ATTRIBUTES\t\t\\\n\tMERGE_MACHINE_TYPE_ATTRIBUTES MERGE_MACHINE_DECL_ATTRIBUTES\t\\\n\tMD_INIT_BUILTINS MD_EXPAND_BUILTIN ASM_OUTPUT_CONSTRUCTOR\t\\\n\tASM_OUTPUT_DESTRUCTOR SIGNED_CHAR_SPEC MAX_CHAR_TYPE_SIZE\t\\\n\tWCHAR_UNSIGNED UNIQUE_SECTION SELECT_SECTION SELECT_RTX_SECTION\t\\\n\tENCODE_SECTION_INFO STRIP_NAME_ENCODING ASM_GLOBALIZE_LABEL\t\\\n\tASM_OUTPUT_MI_THUNK CONST_COSTS RTX_COSTS DEFAULT_RTX_COSTS\t\\\n\tADDRESS_COST MACHINE_DEPENDENT_REORG ASM_FILE_START ASM_FILE_END \\\n\tASM_SIMPLIFY_DWARF_ADDR INIT_TARGET_OPTABS INIT_SUBTARGET_OPTABS \\\n\tINIT_GOFAST_OPTABS MULSI3_LIBCALL MULDI3_LIBCALL DIVSI3_LIBCALL \\\n\tDIVDI3_LIBCALL UDIVSI3_LIBCALL UDIVDI3_LIBCALL MODSI3_LIBCALL\t\\\n\tMODDI3_LIBCALL UMODSI3_LIBCALL UMODDI3_LIBCALL BUILD_VA_LIST_TYPE \\\n\tPRETEND_OUTGOING_VARARGS_NAMED STRUCT_VALUE_INCOMING_REGNUM\t\\\n\tSPLIT_COMPLEX_ARGS\n\n/* Other obsolete target macros, or macros that used to be in target\n   headers and were not used, and may be obsolete or may never have\n   been used.  */\n #pragma GCC poison INT_ASM_OP ASM_OUTPUT_EH_REGION_BEG CPP_PREDEFINES\t   \\\n\tASM_OUTPUT_EH_REGION_END ASM_OUTPUT_LABELREF_AS_INT SMALL_STACK    \\\n\tDOESNT_NEED_UNWINDER EH_TABLE_LOOKUP OBJC_SELECTORS_WITHOUT_LABELS \\\n\tOMIT_EH_TABLE EASY_DIV_EXPR IMPLICIT_FIX_EXPR\t\t\t   \\\n\tLONGJMP_RESTORE_FROM_STACK MAX_INT_TYPE_SIZE ASM_IDENTIFY_GCC\t   \\\n\tSTDC_VALUE TRAMPOLINE_ALIGN ASM_IDENTIFY_GCC_AFTER_SOURCE\t   \\\n\tSLOW_ZERO_EXTEND SUBREG_REGNO_OFFSET DWARF_LINE_MIN_INSTR_LENGTH   \\\n\tTRADITIONAL_RETURN_FLOAT NO_BUILTIN_SIZE_TYPE\t\t\t   \\\n\tNO_BUILTIN_PTRDIFF_TYPE NO_BUILTIN_WCHAR_TYPE NO_BUILTIN_WINT_TYPE \\\n\tBLOCK_PROFILER BLOCK_PROFILER_CODE FUNCTION_BLOCK_PROFILER\t   \\\n\tFUNCTION_BLOCK_PROFILER_EXIT MACHINE_STATE_SAVE\t\t\t   \\\n\tMACHINE_STATE_RESTORE SCCS_DIRECTIVE SECTION_ASM_OP\t\t   \\\n\tASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL ASM_OUTPUT_INTERNAL_LABEL \\\n\tOBJC_PROLOGUE ALLOCATE_TRAMPOLINE HANDLE_PRAGMA ROUND_TYPE_SIZE\t   \\\n\tROUND_TYPE_SIZE_UNIT CONST_SECTION_ASM_OP CRT_GET_RFIB_TEXT\t   \\\n\tDBX_LBRAC_FIRST DBX_OUTPUT_ENUM DBX_OUTPUT_SOURCE_FILENAME\t   \\\n\tDBX_WORKING_DIRECTORY INSN_CACHE_DEPTH INSN_CACHE_SIZE\t\t   \\\n\tINSN_CACHE_LINE_WIDTH INIT_SECTION_PREAMBLE NEED_ATEXIT ON_EXIT\t   \\\n\tEXIT_BODY OBJECT_FORMAT_ROSE MULTIBYTE_CHARS MAP_CHARACTER\t   \\\n\tLIBGCC_NEEDS_DOUBLE FINAL_PRESCAN_LABEL DEFAULT_CALLER_SAVES\t   \\\n\tLOAD_ARGS_REVERSED MAX_INTEGER_COMPUTATION_MODE\t\t\t   \\\n\tCONVERT_HARD_REGISTER_TO_SSA_P ASM_OUTPUT_MAIN_SOURCE_FILENAME\t   \\\n\tFIRST_INSN_ADDRESS TEXT_SECTION SHARED_BSS_SECTION_ASM_OP\t   \\\n\tPROMOTED_MODE EXPAND_BUILTIN_VA_END\t\t\t\t   \\\n\tLINKER_DOES_NOT_WORK_WITH_DWARF2\n\n/* Hooks that are no longer used.  */\n #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\\n\tLANG_HOOKS_MARK_TREE LANG_HOOKS_INSERT_DEFAULT_ATTRIBUTES\n\n/* Libiberty macros that are no longer used in GCC.  */\n#undef ANSI_PROTOTYPES\n#undef PTR_CONST\n#undef LONG_DOUBLE\n#undef VPARAMS\n#undef VA_OPEN\n#undef VA_FIXEDARG\n#undef VA_CLOSE\n#undef VA_START\n #pragma GCC poison ANSI_PROTOTYPES PTR_CONST LONG_DOUBLE VPARAMS VA_OPEN \\\n  VA_FIXEDARG VA_CLOSE VA_START\n#endif /* IN_GCC */\n\n/* Note: not all uses of the `index' token (e.g. variable names and\n   structure members) have been eliminated.  */\n#undef bcopy\n#undef bzero\n#undef bcmp\n#undef rindex\n #pragma GCC poison bcopy bzero bcmp rindex\n\n#endif /* GCC >= 3.0 */\n\n#endif /* ! GCC_SYSTEM_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TARGET": {"ttr": 11524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Data structure definitions for a generic GCC target.\n   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n/* This file contains a data structure that describes a GCC target.\n   At present it is incomplete, but in future it should grow to\n   contain most or all target machine and target O/S specific\n   information.\n\n   This structure has its initializer declared in target-def.h in the\n   form of large macro TARGET_INITIALIZER that expands to many smaller\n   macros.\n\n   The smaller macros each initialize one component of the structure,\n   and each has a default.  Each target should have a file that\n   includes target.h and target-def.h, and overrides any inappropriate\n   defaults by undefining the relevant macro and defining a suitable\n   replacement.  That file should then contain the definition of\n   \"targetm\" like so:\n\n   struct gcc_target targetm = TARGET_INITIALIZER;\n\n   Doing things this way allows us to bring together everything that\n   defines a GCC target.  By supplying a default that is appropriate\n   to most targets, we can easily add new items without needing to\n   edit dozens of target configuration files.  It should also allow us\n   to gradually reduce the amount of conditional compilation that is\n   scattered throughout GCC.  */\n\n#include \"tm.h\"\n\nstruct gcc_target\n{\n  /* Functions that output assembler for the target.  */\n  struct asm_out\n  {\n    /* Opening and closing parentheses for asm expression grouping.  */\n    const char *open_paren, *close_paren;\n\n    /* Assembler instructions for creating various kinds of integer object.  */\n    const char *byte_op;\n    struct asm_int_op\n    {\n      const char *hi;\n      const char *si;\n      const char *di;\n      const char *ti;\n    } aligned_op, unaligned_op;\n\n    /* Try to output the assembler code for an integer object whose\n       value is given by X.  SIZE is the size of the object in bytes and\n       ALIGNED_P indicates whether it is aligned.  Return true if\n       successful.  Only handles cases for which BYTE_OP, ALIGNED_OP\n       and UNALIGNED_OP are NULL.  */\n    bool (* integer) (rtx x, unsigned int size, int aligned_p);\n\n    /* Output code that will globalize a label.  */\n    void (* globalize_label) (FILE *, const char *);\n\n    /* Output an internal label.  */\n    void (* internal_label) (FILE *, const char *, unsigned long);\n\n    /* Emit an assembler directive to set visibility for the symbol\n       associated with the tree decl.  */\n    void (* visibility) (tree, int);\n\n    /* Output the assembler code for entry to a function.  */\n    void (* function_prologue) (FILE *, HOST_WIDE_INT);\n\n    /* Output the assembler code for end of prologue.  */\n    void (* function_end_prologue) (FILE *);\n\n    /* Output the assembler code for start of epilogue.  */\n    void (* function_begin_epilogue) (FILE *);\n\n    /* Output the assembler code for function exit.  */\n    void (* function_epilogue) (FILE *, HOST_WIDE_INT);\n\n    /* Switch to an arbitrary section NAME with attributes as\n       specified by FLAGS.  */\n    void (* named_section) (const char *, unsigned int);\n\n    /* Switch to the section that holds the exception table.  */\n    void (* exception_section) (void);\n\n    /* Switch to the section that holds the exception frames.  */\n    void (* eh_frame_section) (void);\n\n    /* Select and switch to a section for EXP.  It may be a DECL or a\n       constant.  RELOC is nonzero if runtime relocations must be applied;\n       bit 1 will be set if the runtime relocations require non-local\n       name resolution.  ALIGN is the required alignment of the data.  */\n    void (* select_section) (tree, int, unsigned HOST_WIDE_INT);\n\n    /* Select and switch to a section for X with MODE.  ALIGN is\n       the desired alignment of the data.  */\n    void (* select_rtx_section) (enum machine_mode, rtx,\n\t\t\t\t unsigned HOST_WIDE_INT);\n\n    /* Select a unique section name for DECL.  RELOC is the same as\n       for SELECT_SECTION.  */\n    void (* unique_section) (tree, int);\n\n    /* Output a constructor for a symbol with a given priority.  */\n    void (* constructor) (rtx, int);\n\n    /* Output a destructor for a symbol with a given priority.  */\n    void (* destructor) (rtx, int);\n\n    /* Output the assembler code for a thunk function.  THUNK_DECL is the\n       declaration for the thunk function itself, FUNCTION is the decl for\n       the target function.  DELTA is an immediate constant offset to be\n       added to THIS.  If VCALL_OFFSET is nonzero, the word at\n       *(*this + vcall_offset) should be added to THIS.  */\n    void (* output_mi_thunk) (FILE *file, tree thunk_decl,\n\t\t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n\t\t\t      tree function_decl);\n\n    /* Determine whether output_mi_thunk would succeed.  */\n    /* ??? Ideally, this hook would not exist, and success or failure\n       would be returned from output_mi_thunk directly.  But there's\n       too much undo-able setup involved in invoking output_mi_thunk.\n       Could be fixed by making output_mi_thunk emit rtl instead of\n       text to the output file.  */\n    bool (* can_output_mi_thunk) (tree thunk_decl, HOST_WIDE_INT delta,\n\t\t\t\t  HOST_WIDE_INT vcall_offset,\n\t\t\t\t  tree function_decl);\n\n    /* Output any boilerplate text needed at the beginning of a\n       translation unit.  */\n    void (*file_start) (void);\n\n    /* Output any boilerplate text needed at the end of a\n       translation unit.  */\n    void (*file_end) (void);\n\n    /* Output an assembler pseudo-op to declare a library function name\n       external.  */\n    void (*external_libcall) (rtx);\n  } asm_out;\n\n  /* Functions relating to instruction scheduling.  */\n  struct sched\n  {\n    /* Given the current cost, COST, of an insn, INSN, calculate and\n       return a new cost based on its relationship to DEP_INSN through\n       the dependence LINK.  The default is to make no adjustment.  */\n    int (* adjust_cost) (rtx insn, rtx link, rtx def_insn, int cost);\n\n    /* Adjust the priority of an insn as you see fit.  Returns the new\n       priority.  */\n    int (* adjust_priority) (rtx, int);\n\n    /* Function which returns the maximum number of insns that can be\n       scheduled in the same machine cycle.  This must be constant\n       over an entire compilation.  The default is 1.  */\n    int (* issue_rate) (void);\n\n    /* Calculate how much this insn affects how many more insns we\n       can emit this cycle.  Default is they all cost the same.  */\n    int (* variable_issue) (FILE *, int, rtx, int);\n\n    /* Initialize machine-dependent scheduling code.  */\n    void (* md_init) (FILE *, int, int);\n\n    /* Finalize machine-dependent scheduling code.  */\n    void (* md_finish) (FILE *, int);\n\n    /* Reorder insns in a machine-dependent fashion, in two different\n       places.  Default does nothing.  */\n    int (* reorder) (FILE *, int, rtx *, int *, int);\n    int (* reorder2) (FILE *, int, rtx *, int *, int);\n\n    /* The following member value is a pointer to a function called\n       after evaluation forward dependencies of insns in chain given\n       by two parameter values (head and tail correspondingly).  */\n    void (* dependencies_evaluation_hook) (rtx, rtx);\n\n    /* The following member value is a pointer to a function returning\n       nonzero if we should use DFA based scheduling.  The default is\n       to use the old pipeline scheduler.  */\n    int (* use_dfa_pipeline_interface) (void);\n    /* The values of all the following members are used only for the\n       DFA based scheduler: */\n    /* The values of the following four members are pointers to\n       functions used to simplify the automaton descriptions.\n       dfa_pre_cycle_insn and dfa_post_cycle_insn give functions\n       returning insns which are used to change the pipeline hazard\n       recognizer state when the new simulated processor cycle\n       correspondingly starts and finishes.  The function defined by\n       init_dfa_pre_cycle_insn and init_dfa_post_cycle_insn are used\n       to initialize the corresponding insns.  The default values of\n       the members result in not changing the automaton state when\n       the new simulated processor cycle correspondingly starts and\n       finishes.  */\n    void (* init_dfa_pre_cycle_insn) (void);\n    rtx (* dfa_pre_cycle_insn) (void);\n    void (* init_dfa_post_cycle_insn) (void);\n    rtx (* dfa_post_cycle_insn) (void);\n    /* The following member value is a pointer to a function returning value\n       which defines how many insns in queue `ready' will we try for\n       multi-pass scheduling.  if the member value is nonzero and the\n       function returns positive value, the DFA based scheduler will make\n       multi-pass scheduling for the first cycle.  In other words, we will\n       try to choose ready insn which permits to start maximum number of\n       insns on the same cycle.  */\n    int (* first_cycle_multipass_dfa_lookahead) (void);\n    /* The following member value is pointer to a function controlling\n       what insns from the ready insn queue will be considered for the\n       multipass insn scheduling.  If the hook returns zero for insn\n       passed as the parameter, the insn will be not chosen to be\n       issued.  */\n    int (* first_cycle_multipass_dfa_lookahead_guard) (rtx);\n    /* The following member value is pointer to a function called by\n       the insn scheduler before issuing insn passed as the third\n       parameter on given cycle.  If the hook returns nonzero, the\n       insn is not issued on given processors cycle.  Instead of that,\n       the processor cycle is advanced.  If the value passed through\n       the last parameter is zero, the insn ready queue is not sorted\n       on the new cycle start as usually.  The first parameter passes\n       file for debugging output.  The second one passes the scheduler\n       verbose level of the debugging output.  The forth and the fifth\n       parameter values are correspondingly processor cycle on which\n       the previous insn has been issued and the current processor\n       cycle.  */\n    int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n    /* The values of the following members are pointers to functions\n       used to improve the first cycle multipass scheduling by\n       inserting nop insns.  dfa_scheduler_bubble gives a function\n       returning a nop insn with given index.  The indexes start with\n       zero.  The function should return NULL if there are no more nop\n       insns with indexes greater than given index.  To initialize the\n       nop insn the function given by member\n       init_dfa_scheduler_bubbles is used.  The default values of the\n       members result in not inserting nop insns during the multipass\n       scheduling.  */\n    void (* init_dfa_bubbles) (void);\n    rtx (* dfa_bubble) (int);\n    /* The following member value is a pointer to a function called\n       by the insn scheduler.  It should return true if there exists a\n       dependence which is considered costly by the target, between\n       the insn passed as the first parameter, and the insn passed as\n       the second parameter.  The third parameter is the INSN_DEPEND\n       link that represents the dependence between the two insns.  The\n       fourth argument is the cost of the dependence as estimated by\n       the scheduler.  The last argument is the distance in cycles\n       between the already scheduled insn (first parameter) and the\n       the second insn (second parameter).  */\n    bool (* is_costly_dependence) (rtx, rtx, rtx, int, int);\n  } sched;\n\n  /* Given two decls, merge their attributes and return the result.  */\n  tree (* merge_decl_attributes) (tree, tree);\n\n  /* Given two types, merge their attributes and return the result.  */\n  tree (* merge_type_attributes) (tree, tree);\n\n  /* Table of machine attributes and functions to handle them.\n     Ignored if NULL.  */\n  const struct attribute_spec *attribute_table;\n\n  /* Return zero if the attributes on TYPE1 and TYPE2 are incompatible,\n     one if they are compatible and two if they are nearly compatible\n     (which causes a warning to be generated).  */\n  int (* comp_type_attributes) (tree type1, tree type2);\n\n  /* Assign default attributes to the newly defined TYPE.  */\n  void (* set_default_type_attributes) (tree type);\n\n  /* Insert attributes on the newly created DECL.  */\n  void (* insert_attributes) (tree decl, tree *attributes);\n\n  /* Return true if FNDECL (which has at least one machine attribute)\n     can be inlined despite its machine attributes, false otherwise.  */\n  bool (* function_attribute_inlinable_p) (tree fndecl);\n\n  /* Return true if bitfields in RECORD_TYPE should follow the\n     Microsoft Visual C++ bitfield layout rules.  */\n  bool (* ms_bitfield_layout_p) (tree record_type);\n\n  /* Set up target-specific built-in functions.  */\n  void (* init_builtins) (void);\n\n  /* Expand a target-specific builtin.  */\n  rtx (* expand_builtin) (tree exp, rtx target, rtx subtarget,\n\t\t\t  enum machine_mode mode, int ignore);\n\n  /* For a vendor-specific fundamental TYPE, return a pointer to\n     a statically-allocated string containing the C++ mangling for\n     TYPE.  In all other cases, return NULL.  */\n  const char * (* mangle_fundamental_type) (tree type);\n\n  /* Make any adjustments to libfunc names needed for this target.  */\n  void (* init_libfuncs) (void);\n\n  /* Given a decl, a section name, and whether the decl initializer\n     has relocs, choose attributes for the section.  */\n  /* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */\n  unsigned int (* section_type_flags) (tree, const char *, int);\n\n  /* True if new jumps cannot be created, to replace existing ones or\n     not, at the current point in the compilation.  */\n  bool (* cannot_modify_jumps_p) (void);\n\n  /* Return a register class for which branch target register\n     optimizations should be applied.  */\n  int (* branch_target_register_class) (void);\n\n  /* Return true if branch target register optimizations should include\n     callee-saved registers that are not already live during the current\n     function.  AFTER_PE_GEN is true if prologues and epilogues have\n     already been generated.  */\n  bool (* branch_target_register_callee_saved) (bool after_pe_gen);\n\n  /* True if the constant X cannot be placed in the constant pool.  */\n  bool (* cannot_force_const_mem) (rtx);\n\n  /* True if the insn X cannot be duplicated.  */\n  bool (* cannot_copy_insn_p) (rtx);\n\n  /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n  rtx (* delegitimize_address) (rtx);\n\n  /* True if it is OK to do sibling call optimization for the specified\n     call expression EXP.  DECL will be the called function, or NULL if\n     this is an indirect call.  */\n  bool (*function_ok_for_sibcall) (tree decl, tree exp);\n\n  /* True if EXP should be placed in a \"small data\" section.  */\n  bool (* in_small_data_p) (tree);\n\n  /* True if EXP names an object for which name resolution must resolve\n     to the current module.  */\n  bool (* binds_local_p) (tree);\n\n  /* Do something target-specific to record properties of the DECL into\n     the associated SYMBOL_REF.  */\n  void (* encode_section_info) (tree, rtx, int);\n\n  /* Undo the effects of encode_section_info on the symbol string.  */\n  const char * (* strip_name_encoding) (const char *);\n\n  /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n  bool (* valid_pointer_mode) (enum machine_mode mode);\n\n  /* True if a vector is opaque.  */\n  bool (* vector_opaque_p) (tree);\n\n  /* Compute a (partial) cost for rtx X.  Return true if the complete\n     cost has been computed, and false if subexpressions should be\n     scanned.  In either case, *TOTAL contains the cost result.  */\n  /* Note that CODE and OUTER_CODE ought to be RTX_CODE, but that's\n     not necessarily defined at this point.  */\n  bool (* rtx_costs) (rtx x, int code, int outer_code, int *total);\n\n  /* Compute the cost of X, used as an address.  Never called with\n     invalid addresses.  */\n  int (* address_cost) (rtx x);\n\n  /* Given a register, this hook should return a parallel of registers\n     to represent where to find the register pieces.  Define this hook\n     if the register and its mode are represented in Dwarf in\n     non-contiguous locations, or if the register should be\n     represented in more than one register in Dwarf.  Otherwise, this\n     hook should return NULL_RTX.  */\n  rtx (* dwarf_register_span) (rtx);\n\n  /* Fetch the fixed register(s) which hold condition codes, for\n     targets where it makes sense to look for duplicate assignments to\n     the condition codes.  This should return true if there is such a\n     register, false otherwise.  The arguments should be set to the\n     fixed register numbers.  Up to two condition code registers are\n     supported.  If there is only one for this target, the int pointed\n     at by the second argument should be set to -1.  */\n  bool (* fixed_condition_code_regs) (unsigned int *, unsigned int *);\n\n  /* If two condition code modes are compatible, return a condition\n     code mode which is compatible with both, such that a comparison\n     done in the returned mode will work for both of the original\n     modes.  If the condition code modes are not compatible, return\n     VOIDmode.  */\n  enum machine_mode (* cc_modes_compatible) (enum machine_mode,\n\t\t\t\t\t     enum machine_mode);\n\n  /* Do machine-dependent code transformations.  Called just before\n     delayed-branch scheduling.  */\n  void (* machine_dependent_reorg) (void);\n\n  /* Create the __builtin_va_list type.  */\n  tree (* build_builtin_va_list) (void);\n\n  /* Validity-checking routines for PCH files, target-specific.\n     get_pch_validity returns a pointer to the data to be stored,\n     and stores the size in its argument.  pch_valid_p gets the same\n     information back and returns NULL if the PCH is valid,\n     or an error message if not.\n  */\n  void * (* get_pch_validity) (size_t *);\n  const char * (* pch_valid_p) (const void *, size_t);\n\n  /* Functions relating to calls - argument passing, returns, etc.  */\n  struct calls {\n    bool (*promote_function_args) (tree fntype);\n    bool (*promote_function_return) (tree fntype);\n    bool (*promote_prototypes) (tree fntype);\n    rtx (*struct_value_rtx) (tree fndecl, int incoming);\n    bool (*return_in_memory) (tree type, tree fndecl);\n    bool (*return_in_msb) (tree type);\n    rtx (*expand_builtin_saveregs) (void);\n    /* Returns pretend_argument_size.  */\n    void (*setup_incoming_varargs) (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n\t\t\t\t    tree type, int *pretend_arg_size,\n\t\t\t\t    int second_time);\n    bool (*strict_argument_naming) (CUMULATIVE_ARGS *ca);\n    /* Returns true if we should use SETUP_INCOMING_VARARGS and/or\n       targetm.calls.strict_argument_naming().  */\n    bool (*pretend_outgoing_varargs_named) (CUMULATIVE_ARGS *ca);\n\n    /* Given a complex type T, return true if a parameter of type T\n       should be passed as two scalars.  */\n    bool (* split_complex_arg) (tree type);\n  } calls;\n\n  /* Leave the boolean fields at the end.  */\n\n  /* True if arbitrary sections are supported.  */\n  bool have_named_sections;\n\n  /* True if \"native\" constructors and destructors are supported,\n     false if we're using collect2 for the job.  */\n  bool have_ctors_dtors;\n\n  /* True if thread-local storage is supported.  */\n  bool have_tls;\n\n  /* True if a small readonly data section is supported.  */\n  bool have_srodata_section;\n\n  /* True if EH frame info sections should be zero-terminated.  */\n  bool terminate_dw2_eh_frame_info;\n\n  /* True if #NO_APP should be emitted at the beginning of\n     assembly output.  */\n  bool file_start_app_off;\n\n  /* True if output_file_directive should be called for main_input_filename\n     at the beginning of assembly output.  */\n  bool file_start_file_directive;\n\n  /* Leave the boolean fields at the end.  */\n};\n\nextern struct gcc_target targetm;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TARGET@D": {"ttr": 11276, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default initializers for a generic GCC target.\n   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis program is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by the\nFree Software Foundation; either version 2, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n In other words, you are welcome to use, share and improve this program.\n You are forbidden to forbid anyone else to use, share and improve\n what you give them.   Help stamp out software-hoarding!  */\n\n/* See target.h for a description of what this file contains and how to\n   use it.\n\n   We want to have non-NULL default definitions of all hook functions,\n   even if they do nothing.  */\n\n/* Note that if one of these macros must be defined in an OS .h file\n   rather than the .c file, then we need to wrap the default\n   definition in a #ifndef, since files include tm.h before this one.  */\n\n/* Assembler output.  */\n#define TARGET_ASM_OPEN_PAREN \"(\"\n#define TARGET_ASM_CLOSE_PAREN \")\"\n#define TARGET_ASM_BYTE_OP \"\\t.byte\\t\"\n\n#define TARGET_ASM_ALIGNED_HI_OP \"\\t.short\\t\"\n#define TARGET_ASM_ALIGNED_SI_OP \"\\t.long\\t\"\n#define TARGET_ASM_ALIGNED_DI_OP NULL\n#define TARGET_ASM_ALIGNED_TI_OP NULL\n\n/* GAS and SYSV4 assemblers accept these.  */\n#if defined (OBJECT_FORMAT_ELF)\n#define TARGET_ASM_UNALIGNED_HI_OP \"\\t.2byte\\t\"\n#define TARGET_ASM_UNALIGNED_SI_OP \"\\t.4byte\\t\"\n#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.8byte\\t\"\n#define TARGET_ASM_UNALIGNED_TI_OP NULL\n#else\n#define TARGET_ASM_UNALIGNED_HI_OP NULL\n#define TARGET_ASM_UNALIGNED_SI_OP NULL\n#define TARGET_ASM_UNALIGNED_DI_OP NULL\n#define TARGET_ASM_UNALIGNED_TI_OP NULL\n#endif /* OBJECT_FORMAT_ELF */\n\n#define TARGET_ASM_INTEGER default_assemble_integer\n\n#ifndef TARGET_ASM_GLOBALIZE_LABEL\n#define TARGET_ASM_GLOBALIZE_LABEL default_globalize_label\n#endif\n#ifndef TARGET_ASM_INTERNAL_LABEL\n#define TARGET_ASM_INTERNAL_LABEL default_internal_label\n#endif\n\n#ifndef TARGET_ASM_ASSEMBLE_VISIBILITY\n#define TARGET_ASM_ASSEMBLE_VISIBILITY default_assemble_visibility\n#endif\n\n#define TARGET_ASM_FUNCTION_PROLOGUE default_function_pro_epilogue\n#define TARGET_ASM_FUNCTION_EPILOGUE default_function_pro_epilogue\n#define TARGET_ASM_FUNCTION_END_PROLOGUE no_asm_to_stream\n#define TARGET_ASM_FUNCTION_BEGIN_EPILOGUE no_asm_to_stream\n\n#ifndef TARGET_ASM_SELECT_SECTION\n#define TARGET_ASM_SELECT_SECTION default_select_section\n#endif\n\n#ifndef TARGET_ASM_UNIQUE_SECTION\n#define TARGET_ASM_UNIQUE_SECTION default_unique_section\n#endif\n\n#ifndef TARGET_ASM_SELECT_RTX_SECTION\n#define TARGET_ASM_SELECT_RTX_SECTION default_select_rtx_section\n#endif\n\n#if !defined(TARGET_ASM_CONSTRUCTOR) && !defined(USE_COLLECT2)\n# ifdef CTORS_SECTION_ASM_OP\n#  define TARGET_ASM_CONSTRUCTOR default_ctor_section_asm_out_constructor\n# else\n#  ifdef TARGET_ASM_NAMED_SECTION\n#   define TARGET_ASM_CONSTRUCTOR default_named_section_asm_out_constructor\n#  else\n#   define TARGET_ASM_CONSTRUCTOR default_stabs_asm_out_constructor\n#  endif\n# endif\n#endif\n\n#if !defined(TARGET_ASM_DESTRUCTOR) && !defined(USE_COLLECT2)\n# ifdef DTORS_SECTION_ASM_OP\n#  define TARGET_ASM_DESTRUCTOR default_dtor_section_asm_out_destructor\n# else\n#  ifdef TARGET_ASM_NAMED_SECTION\n#   define TARGET_ASM_DESTRUCTOR default_named_section_asm_out_destructor\n#  else\n#   define TARGET_ASM_DESTRUCTOR default_stabs_asm_out_destructor\n#  endif\n# endif\n#endif\n\n#define TARGET_ASM_OUTPUT_MI_THUNK NULL\n#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_tree_hwi_hwi_tree_false\n\n#if defined(TARGET_ASM_CONSTRUCTOR) && defined(TARGET_ASM_DESTRUCTOR)\n#define TARGET_HAVE_CTORS_DTORS true\n#else\n#define TARGET_HAVE_CTORS_DTORS false\n#define TARGET_ASM_CONSTRUCTOR NULL\n#define TARGET_ASM_DESTRUCTOR NULL\n#endif\n\n#ifdef TARGET_ASM_NAMED_SECTION\n#define TARGET_HAVE_NAMED_SECTIONS true\n#else\n#define TARGET_ASM_NAMED_SECTION default_no_named_section\n#define TARGET_HAVE_NAMED_SECTIONS false\n#endif\n\n#ifndef TARGET_HAVE_TLS\n#define TARGET_HAVE_TLS false\n#endif\n\n#ifndef TARGET_HAVE_SRODATA_SECTION\n#define TARGET_HAVE_SRODATA_SECTION false\n#endif\n\n#ifndef TARGET_TERMINATE_DW2_EH_FRAME_INFO\n#ifdef EH_FRAME_SECTION_NAME\n#define TARGET_TERMINATE_DW2_EH_FRAME_INFO false\n#else\n#define TARGET_TERMINATE_DW2_EH_FRAME_INFO true\n#endif\n#endif\n\n#define TARGET_DWARF_REGISTER_SPAN hook_rtx_rtx_null\n\n#ifndef TARGET_ASM_EXCEPTION_SECTION\n#define TARGET_ASM_EXCEPTION_SECTION default_exception_section\n#endif\n\n#ifndef TARGET_ASM_EH_FRAME_SECTION\n#define TARGET_ASM_EH_FRAME_SECTION default_eh_frame_section\n#endif\n\n#ifndef TARGET_ASM_FILE_START\n#define TARGET_ASM_FILE_START default_file_start\n#endif\n\n#ifndef TARGET_ASM_FILE_END\n#define TARGET_ASM_FILE_END hook_void_void\n#endif\n\n#ifndef TARGET_ASM_FILE_START_APP_OFF\n#define TARGET_ASM_FILE_START_APP_OFF false\n#endif\n\n#ifndef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n#define TARGET_ASM_FILE_START_FILE_DIRECTIVE false\n#endif\n\n#ifndef TARGET_ASM_EXTERNAL_LIBCALL\n#define TARGET_ASM_EXTERNAL_LIBCALL default_external_libcall\n#endif\n\n#define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n\t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_SI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_DI_OP,\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_TI_OP}\n\n#define TARGET_ASM_UNALIGNED_INT_OP\t\t\t\t\\\n\t\t       {TARGET_ASM_UNALIGNED_HI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_SI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_DI_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_TI_OP}\n\n#define TARGET_ASM_OUT {TARGET_ASM_OPEN_PAREN,\t\t\t\\\n\t\t\tTARGET_ASM_CLOSE_PAREN,\t\t\t\\\n\t\t\tTARGET_ASM_BYTE_OP,\t\t\t\\\n\t\t\tTARGET_ASM_ALIGNED_INT_OP,\t\t\\\n\t\t\tTARGET_ASM_UNALIGNED_INT_OP,\t\t\\\n\t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n\t\t\tTARGET_ASM_GLOBALIZE_LABEL,\t\t\\\n\t\t\tTARGET_ASM_INTERNAL_LABEL,\t\t\\\n\t\t\tTARGET_ASM_ASSEMBLE_VISIBILITY,\t\t\\\n\t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\\n\t\t\tTARGET_ASM_FUNCTION_END_PROLOGUE,\t\\\n\t\t\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE,\t\\\n\t\t\tTARGET_ASM_FUNCTION_EPILOGUE,\t\t\\\n\t\t\tTARGET_ASM_NAMED_SECTION,\t\t\\\n\t\t\tTARGET_ASM_EXCEPTION_SECTION,\t\t\\\n\t\t\tTARGET_ASM_EH_FRAME_SECTION,\t\t\\\n\t\t\tTARGET_ASM_SELECT_SECTION,\t\t\\\n\t\t\tTARGET_ASM_SELECT_RTX_SECTION,\t\t\\\n\t\t\tTARGET_ASM_UNIQUE_SECTION,\t\t\\\n\t\t\tTARGET_ASM_CONSTRUCTOR,\t\t\t\\\n\t\t\tTARGET_ASM_DESTRUCTOR,                  \\\n                        TARGET_ASM_OUTPUT_MI_THUNK,             \\\n                        TARGET_ASM_CAN_OUTPUT_MI_THUNK,         \\\n                        TARGET_ASM_FILE_START,                  \\\n                        TARGET_ASM_FILE_END,\t\t\t\\\n\t\t\tTARGET_ASM_EXTERNAL_LIBCALL}\n\n/* Scheduler hooks.  All of these default to null pointers, which\n   haifa-sched.c looks for and handles.  */\n#define TARGET_SCHED_ADJUST_COST 0\n#define TARGET_SCHED_ADJUST_PRIORITY 0\n#define TARGET_SCHED_ISSUE_RATE 0\n#define TARGET_SCHED_VARIABLE_ISSUE 0\n#define TARGET_SCHED_INIT 0\n#define TARGET_SCHED_FINISH 0\n#define TARGET_SCHED_REORDER 0\n#define TARGET_SCHED_REORDER2 0\n#define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK 0\n#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE 0\n#define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n#define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n#define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n#define TARGET_SCHED_DFA_POST_CYCLE_INSN 0\n#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD 0\n#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD 0\n#define TARGET_SCHED_DFA_NEW_CYCLE 0\n#define TARGET_SCHED_INIT_DFA_BUBBLES 0\n#define TARGET_SCHED_DFA_BUBBLE 0\n#define TARGET_SCHED_IS_COSTLY_DEPENDENCE 0\n\n#define TARGET_SCHED\t\t\t\t\t\t\\\n  {TARGET_SCHED_ADJUST_COST,\t\t\t\t\t\\\n   TARGET_SCHED_ADJUST_PRIORITY,\t\t\t\t\\\n   TARGET_SCHED_ISSUE_RATE,\t\t\t\t\t\\\n   TARGET_SCHED_VARIABLE_ISSUE,\t\t\t\t\t\\\n   TARGET_SCHED_INIT,\t\t\t\t\t\t\\\n   TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n   TARGET_SCHED_REORDER,\t\t\t\t\t\\\n   TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n   TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK,\t\t\t\\\n   TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\t\t\t\\\n   TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n   TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n   TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\\n   TARGET_SCHED_DFA_POST_CYCLE_INSN,\t\t\t\t\\\n   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD,\t\t\\\n   TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD,\t\\\n   TARGET_SCHED_DFA_NEW_CYCLE,\t\t\t\t\t\\\n   TARGET_SCHED_INIT_DFA_BUBBLES,\t\t\t\t\\\n   TARGET_SCHED_DFA_BUBBLE,                                     \\\n   TARGET_SCHED_IS_COSTLY_DEPENDENCE}\n\n/* In tree.c.  */\n#define TARGET_MERGE_DECL_ATTRIBUTES merge_decl_attributes\n#define TARGET_MERGE_TYPE_ATTRIBUTES merge_type_attributes\n#define TARGET_ATTRIBUTE_TABLE NULL\n\n/* In cse.c.  */\n#define TARGET_ADDRESS_COST default_address_cost\n\n/* In builtins.c.  */\n#define TARGET_INIT_BUILTINS hook_void_void\n#define TARGET_EXPAND_BUILTIN default_expand_builtin\n\n/* In varasm.c.  */\n#ifndef TARGET_SECTION_TYPE_FLAGS\n#define TARGET_SECTION_TYPE_FLAGS default_section_type_flags\n#endif\n\n#ifndef TARGET_STRIP_NAME_ENCODING\n#define TARGET_STRIP_NAME_ENCODING default_strip_name_encoding\n#endif\n\n#ifndef TARGET_BINDS_LOCAL_P\n#define TARGET_BINDS_LOCAL_P default_binds_local_p\n#endif\n\n#ifndef TARGET_VALID_POINTER_MODE\n#define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n#endif\n\n#ifndef TARGET_VECTOR_OPAQUE_P\n#define TARGET_VECTOR_OPAQUE_P hook_bool_tree_false\n#endif\n\n/* In hook.c.  */\n#define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n#define TARGET_BRANCH_TARGET_REGISTER_CLASS hook_int_void_no_regs\n#define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED hook_bool_bool_false\n#define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n#define TARGET_CANNOT_COPY_INSN_P NULL\n#define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n#define TARGET_FUNCTION_OK_FOR_SIBCALL hook_bool_tree_tree_false\n#define TARGET_COMP_TYPE_ATTRIBUTES hook_int_tree_tree_1\n#define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES hook_void_tree\n#define TARGET_INSERT_ATTRIBUTES hook_void_tree_treeptr\n#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P hook_bool_tree_false\n#define TARGET_MS_BITFIELD_LAYOUT_P hook_bool_tree_false\n#define TARGET_RTX_COSTS hook_bool_rtx_int_int_intp_false\n#define TARGET_MANGLE_FUNDAMENTAL_TYPE hook_constcharptr_tree_null\n\n#ifndef TARGET_INIT_LIBFUNCS\n#define TARGET_INIT_LIBFUNCS hook_void_void\n#endif\n\n#ifndef TARGET_IN_SMALL_DATA_P\n#define TARGET_IN_SMALL_DATA_P hook_bool_tree_false\n#endif\n\n#ifndef TARGET_ENCODE_SECTION_INFO\n#define TARGET_ENCODE_SECTION_INFO default_encode_section_info\n#endif\n\n#define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false\n\n#define TARGET_CC_MODES_COMPATIBLE default_cc_modes_compatible\n\n#define TARGET_MACHINE_DEPENDENT_REORG 0\n\n#define TARGET_BUILD_BUILTIN_VA_LIST std_build_builtin_va_list\n\n#define TARGET_GET_PCH_VALIDITY default_get_pch_validity\n#define TARGET_PCH_VALID_P default_pch_valid_p\n\n#define TARGET_PROMOTE_FUNCTION_ARGS default_promote_function_args\n#define TARGET_PROMOTE_FUNCTION_RETURN default_promote_function_return\n#define TARGET_PROMOTE_PROTOTYPES default_promote_prototypes\n\n#define TARGET_STRUCT_VALUE_RTX default_struct_value_rtx\n#define TARGET_RETURN_IN_MEMORY default_return_in_memory\n#define TARGET_RETURN_IN_MSB hook_bool_tree_false\n\n#define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs\n#define TARGET_SETUP_INCOMING_VARARGS default_setup_incoming_varargs\n#define TARGET_STRICT_ARGUMENT_NAMING default_strict_argument_naming\n#define TARGET_PRETEND_OUTGOING_VARARGS_NAMED \\\n  default_pretend_outgoing_varargs_named\n#define TARGET_SPLIT_COMPLEX_ARG NULL\n\n#define TARGET_CALLS {\t\t\t\t\t\t\\\n   TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n   TARGET_PROMOTE_FUNCTION_RETURN,\t\t\t\t\\\n   TARGET_PROMOTE_PROTOTYPES,\t\t\t\t\t\\\n   TARGET_STRUCT_VALUE_RTX,\t\t\t\t\t\\\n   TARGET_RETURN_IN_MEMORY,\t\t\t\t\t\\\n   TARGET_RETURN_IN_MSB,\t\t\t\t\t\\\n   TARGET_EXPAND_BUILTIN_SAVEREGS,\t\t\t\t\\\n   TARGET_SETUP_INCOMING_VARARGS,\t\t\t\t\\\n   TARGET_STRICT_ARGUMENT_NAMING,\t\t\t\t\\\n   TARGET_PRETEND_OUTGOING_VARARGS_NAMED,\t\t\t\\\n   TARGET_SPLIT_COMPLEX_ARG,\t\t\t\t\t\\\n   }\n\n/* The whole shebang.  */\n#define TARGET_INITIALIZER\t\t\t\\\n{\t\t\t\t\t\t\\\n  TARGET_ASM_OUT,\t\t\t\t\\\n  TARGET_SCHED,\t\t\t\t\t\\\n  TARGET_MERGE_DECL_ATTRIBUTES,\t\t\t\\\n  TARGET_MERGE_TYPE_ATTRIBUTES,\t\t\t\\\n  TARGET_ATTRIBUTE_TABLE,\t\t\t\\\n  TARGET_COMP_TYPE_ATTRIBUTES,\t\t\t\\\n  TARGET_SET_DEFAULT_TYPE_ATTRIBUTES,\t\t\\\n  TARGET_INSERT_ATTRIBUTES,\t\t\t\\\n  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P,\t\\\n  TARGET_MS_BITFIELD_LAYOUT_P,\t\t\t\\\n  TARGET_INIT_BUILTINS,\t\t\t\t\\\n  TARGET_EXPAND_BUILTIN,\t\t\t\\\n  TARGET_MANGLE_FUNDAMENTAL_TYPE,\t\t\\\n  TARGET_INIT_LIBFUNCS,\t\t\t\t\\\n  TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n  TARGET_CANNOT_MODIFY_JUMPS_P,\t\t\t\\\n  TARGET_BRANCH_TARGET_REGISTER_CLASS,\t\t\\\n  TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED,\t\\\n  TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n  TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n  TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n  TARGET_FUNCTION_OK_FOR_SIBCALL,\t\t\\\n  TARGET_IN_SMALL_DATA_P,\t\t\t\\\n  TARGET_BINDS_LOCAL_P,\t\t\t\t\\\n  TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n  TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n  TARGET_VALID_POINTER_MODE,                    \\\n  TARGET_VECTOR_OPAQUE_P,\t\t\t\\\n  TARGET_RTX_COSTS,\t\t\t\t\\\n  TARGET_ADDRESS_COST,\t\t\t\t\\\n  TARGET_DWARF_REGISTER_SPAN,                   \\\n  TARGET_FIXED_CONDITION_CODE_REGS,\t\t\\\n  TARGET_CC_MODES_COMPATIBLE,\t\t\t\\\n  TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n  TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n  TARGET_GET_PCH_VALIDITY,\t\t\t\\\n  TARGET_PCH_VALID_P,\t\t\t\t\\\n  TARGET_CALLS,\t\t\t\t\t\\\n  TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n  TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n  TARGET_HAVE_TLS,\t\t\t\t\\\n  TARGET_HAVE_SRODATA_SECTION,\t\t\t\\\n  TARGET_TERMINATE_DW2_EH_FRAME_INFO,\t\t\\\n  TARGET_ASM_FILE_START_APP_OFF,\t\t\\\n  TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n}\n\n#include \"hooks.h\"\n#include \"targhooks.h\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TARGHOOK": {"ttr": 11529, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Default target hook functions.\n   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\nextern void default_external_libcall (rtx);\n\nextern enum machine_mode default_cc_modes_compatible (enum machine_mode,\n\t\t\t\t\t\t      enum machine_mode);\n\nextern bool default_promote_function_args (tree);\nextern bool default_promote_function_return (tree);\nextern bool default_promote_prototypes (tree);\n\nextern rtx default_struct_value_rtx (tree, int);\nextern bool default_return_in_memory (tree, tree);\n\nextern rtx default_expand_builtin_saveregs (void);\nextern void default_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\nextern bool default_strict_argument_naming (CUMULATIVE_ARGS *);\nextern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n\nextern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\nextern bool hook_bool_machine_mode_true (enum machine_mode);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TERNARY": {"ttr": 11531, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* ternary.h - Ternary Search Trees\n   Copyright 2001 Free Software Foundation, Inc.\n\n   Contributed by Daniel Berlin (dan@cgsoftware.com)\n\n\n   This program is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 2, or (at your option) any\n   later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n   USA.  */\n#ifndef TERNARY_H_\n#define TERNARY_H_\n/* Ternary search trees */\n\ntypedef struct ternary_node_def *ternary_tree;\n\ntypedef struct ternary_node_def\n{\n  char splitchar;\n  ternary_tree lokid;\n  ternary_tree eqkid;\n  ternary_tree hikid;\n}\nternary_node;\n\n/* Insert string S into tree P, associating it with DATA.\n   Return the data in the tree associated with the string if it's\n   already there, and replace is 0.\n   Otherwise, replaces if it it exists, inserts if it doesn't, and\n   returns the data you passed in. */\nPTR ternary_insert PARAMS ((ternary_tree *p, const char *s,\n\t\t\t    PTR data, int replace));\n\n/* Delete the ternary search tree rooted at P.\n   Does NOT delete the data you associated with the strings. */\nvoid ternary_cleanup PARAMS ((ternary_tree p));\n\n/* Search the ternary tree for string S, returning the data associated\n   with it if found. */\nPTR ternary_search PARAMS ((const ternary_node *p, const char *s));\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMEVAR": {"ttr": 11533, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Timing variables for measuring compiler performance.\n   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n   Contributed by Alex Samuel <samuel@codesourcery.com>\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#ifndef GCC_TIMEVAR_H\n#define GCC_TIMEVAR_H\n\n/* Timing variables are used to measure elapsed time in various\n   portions of the compiler.  Each measures elapsed user, system, and\n   wall-clock time, as appropriate to and supported by the host\n   system.\n\n   Timing variables are defined using the DEFTIMEVAR macro in\n   timevar.def.  Each has an enumeral identifier, used when referring\n   to the timing variable in code, and a character string name.\n\n   Timing variables can be used in two ways:\n\n     - On the timing stack, using timevar_push and timevar_pop.\n       Timing variables may be pushed onto the stack; elapsed time is\n       attributed to the topmost timing variable on the stack.  When\n       another variable is pushed on, the previous topmost variable is\n       `paused' until the pushed variable is popped back off.\n\n     - As a standalone timer, using timevar_start and timevar_stop.\n       All time elapsed between the two calls is attributed to the\n       variable.\n*/\n\n/* This structure stores the various varieties of time that can be\n   measured.  Times are stored in seconds.  The time may be an\n   absolute time or a time difference; in the former case, the time\n   base is undefined, except that the difference between two times\n   produces a valid time difference.  */\n\nstruct timevar_time_def\n{\n  /* User time in this process.  */\n  double user;\n\n  /* System time (if applicable for this host platform) in this\n     process.  */\n  double sys;\n\n  /* Wall clock time.  */\n  double wall;\n};\n\n/* An enumeration of timing variable identifiers.  Constructed from\n   the contents of timevar.def.  */\n\n#define DEFTIMEVAR(identifier__, name__) \\\n    identifier__,\ntypedef enum\n{\n#include \"timevar.def\"\n  TIMEVAR_LAST\n}\ntimevar_id_t;\n#undef DEFTIMEVAR\n\n/* Execute the sequence: timevar_pop (TV), return (E);  */\n#define POP_TIMEVAR_AND_RETURN(TV, E)  return (timevar_pop (TV), (E))\n\nextern void timevar_init (void);\nextern void timevar_push (timevar_id_t);\nextern void timevar_pop (timevar_id_t);\nextern void timevar_start (timevar_id_t);\nextern void timevar_stop (timevar_id_t);\nextern void timevar_get (timevar_id_t, struct timevar_time_def *);\nextern void timevar_print (FILE *);\n\n/* Provided for backward compatibility.  */\nextern void print_time (const char *, long);\n\n#endif /* ! GCC_TIMEVAR_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TIMEVARD": {"ttr": 11535, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions for timing variables used to\n   measure run-time performance of the compiler.\n   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n   Contributed by Alex Samuel <samuel@codesourcery.com>\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to\n   the Free Software Foundation, 59 Temple Place - Suite 330,\n   Boston, MA 02111-1307, USA.  */\n\n/* This file contains timing variable definitions, used by timevar.h\n   and timevar.c.\n\n   Syntax:\n\n     DEFTIMEVAR (id, name)\n\n   where ID is the enumeral value used to identify the timing\n   variable, and NAME is a character string describing its purpose.  */\n\n/* The total execution time.  */\nDEFTIMEVAR (TV_TOTAL                 , \"total time\")\n\n/* Time spent garbage-collecting.  */\nDEFTIMEVAR (TV_GC                    , \"garbage collection\")\n\n/* Time spent generating dump files.  */\nDEFTIMEVAR (TV_DUMP                  , \"dump files\")\n\nDEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\nDEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n/* Time spent by constructing CFG.  */\nDEFTIMEVAR (TV_CFG                   , \"cfg construction\")\n/* Time spent by cleaning up CFG.  */\nDEFTIMEVAR (TV_CLEANUP_CFG           , \"cfg cleanup\")\nDEFTIMEVAR (TV_DELETE_TRIVIALLY_DEAD , \"trivially dead code\")\n/* Time spent by life analysis.  */\nDEFTIMEVAR (TV_LIFE\t\t     , \"life analysis\")\nDEFTIMEVAR (TV_LIFE_UPDATE\t     , \"life info update\")\n\nDEFTIMEVAR (TV_ALIAS_ANALYSIS\t     , \"alias analysis\")\nDEFTIMEVAR (TV_REG_SCAN\t\t     , \"register scan\")\nDEFTIMEVAR (TV_REBUILD_JUMP\t     , \"rebuild jump labels\")\n/* Timing in various stages of the compiler.  */\nDEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\nDEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")\nDEFTIMEVAR (TV_PARSE                 , \"parser\")\nDEFTIMEVAR (TV_NAME_LOOKUP           , \"name lookup\")\nDEFTIMEVAR (TV_OVERLOAD              , \"overload resolution\")\nDEFTIMEVAR (TV_TEMPLATE_INSTANTIATION, \"template instantiation\")\nDEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")\nDEFTIMEVAR (TV_VARCONST              , \"varconst\")\nDEFTIMEVAR (TV_INTEGRATION           , \"integration\")\nDEFTIMEVAR (TV_JUMP                  , \"jump\")\nDEFTIMEVAR (TV_CSE                   , \"CSE\")\nDEFTIMEVAR (TV_GCSE                  , \"global CSE\")\nDEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\nDEFTIMEVAR (TV_BYPASS                , \"bypass jumps\")\nDEFTIMEVAR (TV_TRACER                , \"tracer\")\nDEFTIMEVAR (TV_WEB                   , \"web\")\nDEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\nDEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\nDEFTIMEVAR (TV_VPT                   , \"value profile opts\")\nDEFTIMEVAR (TV_FLOW                  , \"flow analysis\")\nDEFTIMEVAR (TV_COMBINE               , \"combiner\")\nDEFTIMEVAR (TV_IFCVT\t\t     , \"if-conversion\")\nDEFTIMEVAR (TV_REGMOVE               , \"regmove\")\nDEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\nDEFTIMEVAR (TV_SCHED                 , \"scheduling\")\nDEFTIMEVAR (TV_LOCAL_ALLOC           , \"local alloc\")\nDEFTIMEVAR (TV_GLOBAL_ALLOC          , \"global alloc\")\nDEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\nDEFTIMEVAR (TV_FLOW2                 , \"flow 2\")\nDEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\nDEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\nDEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")\nDEFTIMEVAR (TV_SCHED2                , \"scheduling 2\")\nDEFTIMEVAR (TV_MACH_DEP              , \"machine dep reorg\")\nDEFTIMEVAR (TV_DBR_SCHED             , \"delay branch sched\")\nDEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\nDEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\nDEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\nDEFTIMEVAR (TV_FINAL                 , \"final\")\nDEFTIMEVAR (TV_SYMOUT                , \"symout\")\n\n/* Everything else in rest_of_compilation not included above.  */\nDEFTIMEVAR (TV_REST_OF_COMPILATION   , \"rest of compilation\")\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TM": {"ttr": 11539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_TM_H\n#define GCC_TM_H\n#ifdef IN_GCC\n# include \"config/i370/mvspdp.h\"\n# include \"config/i370/i370.h\"\n# include \"defaults.h\"\n#endif\n#if defined IN_GCC && !defined GENERATOR_FILE && !defined USED_FOR_TARGET\n# include \"insn-constants.h\"\n# include \"insn-flags.h\"\n#endif\n#endif /* GCC_TM_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TM@P": {"ttr": 11777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_TM_P_H\n#define GCC_TM_P_H\n#ifdef IN_GCC\n# include \"config/i370/i370-protos.h\"\n# include \"tm-preds.h\"\n#endif\n#endif /* GCC_TM_P_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TM@PREDS": {"ttr": 11537, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Generated automatically by the program `genpreds'.  */\n\n#ifndef GCC_TM_PREDS_H\n#define GCC_TM_PREDS_H\n\n#ifdef RTX_CODE\n\nextern int r_or_s_operand (rtx, enum machine_mode);\nextern int s_operand (rtx, enum machine_mode);\n\n#endif /* RTX_CODE */\n\n#endif /* GCC_TM_PREDS_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TOPLEV": {"ttr": 11779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* toplev.h - Various declarations for functions found in toplev.c\n   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TOPLEV_H\n#define GCC_TOPLEV_H\n\n/* If non-NULL, return one past-the-end of the matching SUBPART of\n   the WHOLE string.  */\n#define skip_leading_substring(whole,  part) \\\n   (strncmp (whole, part, strlen (part)) ? NULL : whole + strlen (part))\n\nextern int toplev_main (unsigned int, const char **);\nextern int read_integral_parameter (const char *, const char *, const int);\nextern void strip_off_ending (char *, int);\nextern const char *trim_filename (const char *);\nextern void _fatal_insn_not_found (rtx, const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\nextern void _fatal_insn (const char *, rtx, const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n\n#define fatal_insn(msgid, insn) \\\n\t_fatal_insn (msgid, insn, __FILE__, __LINE__, __FUNCTION__)\n#define fatal_insn_not_found(insn) \\\n\t_fatal_insn_not_found (insn, __FILE__, __LINE__, __FUNCTION__)\n\n/* If we haven't already defined a frontend specific diagnostics\n   style, use the generic one.  */\n#ifndef GCC_DIAG_STYLE\n#define GCC_DIAG_STYLE __gcc_diag__\n#endif\n/* None of these functions are suitable for ATTRIBUTE_PRINTF, because\n   each language front end can extend them with its own set of format\n   specifiers.  We must use custom format checks.  */\n#if GCC_VERSION >= 3004\n#define ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m, n))) ATTRIBUTE_NONNULL(m)\n#else\n#define ATTRIBUTE_GCC_DIAG(m, n) ATTRIBUTE_NONNULL(m)\n#endif\nextern void internal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n     ATTRIBUTE_NORETURN;\nextern void warning (const char *, ...);\nextern void error (const char *, ...);\nextern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n     ATTRIBUTE_NORETURN;\nextern void pedwarn (const char *, ...);\nextern void sorry (const char *, ...);\nextern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n\nextern void rest_of_decl_compilation (tree, const char *, int, int);\nextern void rest_of_type_compilation (tree, int);\nextern void rest_of_compilation (tree);\nextern void tree_rest_of_compilation (tree, bool);\n\nextern void announce_function (tree);\n\nextern void error_for_asm (rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\nextern void warning_for_asm (rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\nextern void warn_deprecated_use (tree);\n\n#ifdef BUFSIZ\nextern void output_quoted_string\t(FILE *, const char *);\nextern void output_file_directive\t(FILE *, const char *);\n#endif\n\n#ifdef BUFSIZ\n  /* N.B. Unlike all the others, fnotice is just gettext+fprintf, and\n     therefore it can have ATTRIBUTE_PRINTF.  */\nextern void fnotice\t\t\t(FILE *, const char *, ...)\n     ATTRIBUTE_PRINTF_2;\n#endif\n\nextern int wrapup_global_declarations (tree *, int);\nextern void check_global_declarations (tree *, int);\nextern void write_global_declarations (void);\n\n/* A unique local time stamp, might be zero if none is available.  */\nextern unsigned local_tick;\n\nextern const char *progname;\nextern const char *dump_base_name;\nextern const char *aux_base_name;\nextern const char *aux_info_file_name;\nextern const char *asm_file_name;\nextern bool exit_after_options;\nextern bool version_flag;\n\nextern int target_flags_explicit;\n\n/* See toplev.c.  */\n#if !IFOX\nextern int flag_loop_optimize;\nextern int flag_crossjumping;\nextern int flag_if_conversion;\nextern int flag_if_conversion2;\nextern int flag_delete_null_pointer_checks;\n#endif\nextern int flag_keep_static_consts;\n#if !IFOX\nextern int flag_peel_loops;\n#endif\nextern int flag_rerun_cse_after_loop;\nextern int flag_thread_jumps;\nextern int flag_tracer;\n#if !IFOX\nextern int flag_unroll_loops;\nextern int flag_unroll_all_loops;\nextern int flag_unswitch_loops;\n#endif\nextern int flag_cprop_registers;\nextern int time_report;\nextern int flag_new_regalloc;\n\n/* Things to do with target switches.  */\nextern void display_target_options (void);\nextern void print_version (FILE *, const char *);\nextern void set_target_switch (const char *);\nextern void * default_get_pch_validity (size_t *);\nextern const char * default_pch_valid_p (const void *, size_t);\n\n/* The hashtable, so that the C front ends can pass it to cpplib.  */\nextern struct ht *ident_hash;\n\n/* This function can be used by targets to set the flags originally\n    implied by -ffast-math and -fno-fast-math.  */\n\nextern void set_fast_math_flags         (int);\n\n/* Handle -d switch.  */\nextern void decode_d_option\t\t(const char *);\n\n/* Return true iff flags are set as if -ffast-math.  */\nextern bool fast_math_flags_set_p\t(void);\n\n/* The following functions accept a wide integer argument.  Rather\n   than having to cast on every function call, we use a macro instead.  */\n\n#ifndef exact_log2\n#define exact_log2(N) exact_log2_wide ((unsigned HOST_WIDE_INT) (N))\n#define floor_log2(N) floor_log2_wide ((unsigned HOST_WIDE_INT) (N))\n#endif\nextern int exact_log2_wide             (unsigned HOST_WIDE_INT);\nextern int floor_log2_wide             (unsigned HOST_WIDE_INT);\n\n/* Functions used to get and set GCC's notion of in what directory\n   compilation was started.  */\n\nextern const char *get_src_pwd\t       (void);\nextern bool set_src_pwd\t\t       (const char *);\n\n#endif /* ! GCC_TOPLEV_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE": {"ttr": 11789, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Front-end tree definitions for GNU compiler.\n   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TREE_H\n#define GCC_TREE_H\n\n#include \"machmode.h\"\n#include \"version.h\"\n#include \"input.h\"\n\n/* Codes of tree nodes */\n\n#define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n\nenum tree_code {\n#include \"tree.def\"\n\n  LAST_AND_UNUSED_TREE_CODE\t/* A convenient way to get a value for\n\t\t\t\t   NUM_TREE_CODE.  */\n};\n\n#undef DEFTREECODE\n\n/* Number of language-independent tree codes.  */\n#define NUM_TREE_CODES ((int) LAST_AND_UNUSED_TREE_CODE)\n\n/* Indexed by enum tree_code, contains a character which is\n   `<' for a comparison expression, `1', for a unary arithmetic\n   expression, `2' for a binary arithmetic expression, `e' for\n   other types of expressions, `r' for a reference, `c' for a\n   constant, `d' for a decl, `t' for a type, `s' for a statement,\n   and `x' for anything else (TREE_LIST, IDENTIFIER, etc).  */\n\n#define MAX_TREE_CODES 256\nextern const char tree_code_type\u00dd\u00a8;\n#define TREE_CODE_CLASS(CODE)\ttree_code_type\u00dd(int) (CODE)\u00a8\n\n/* Returns nonzero iff CLASS is the tree-code class of an\n   expression.  */\n\n#define IS_EXPR_CODE_CLASS(CLASS) (strchr (\"<12ers\", (CLASS)) != 0)\n\n/* Returns nonzero iff NODE is an expression of some kind.  */\n\n#define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\n\n/* Number of argument-words in each kind of tree-node.  */\n\nextern const unsigned char tree_code_length\u00dd\u00a8;\n#define TREE_CODE_LENGTH(CODE)\ttree_code_length\u00dd(int) (CODE)\u00a8\n\n/* Names of tree components.  */\n\nextern const char *const tree_code_name\u00dd\u00a8;\n\n/* Classify which part of the compiler has defined a given builtin function.\n   Note that we assume below that this is no more than two bits.  */\nenum built_in_class\n{\n  NOT_BUILT_IN = 0,\n  BUILT_IN_FRONTEND,\n  BUILT_IN_MD,\n  BUILT_IN_NORMAL\n};\n\n/* Names for the above.  */\nextern const char *const built_in_class_names\u00dd4\u00a8;\n\n/* Codes that identify the various built in functions\n   so that expand_call can identify them quickly.  */\n\n#define DEF_BUILTIN(ENUM, N, C, T, LT, B, F, NA, AT, IM) ENUM,\nenum built_in_function\n{\n#include \"builtins.def\"\n\n  /* Upper bound on non-language-specific builtins.  */\n  END_BUILTINS\n};\n#undef DEF_BUILTIN\n\n/* Names for the above.  */\nextern const char *const built_in_names\u00dd(int) END_BUILTINS\u00a8;\n\n/* An array of _DECL trees for the above.  */\nextern GTY(()) tree built_in_decls\u00dd(int) END_BUILTINS\u00a8;\nextern GTY(()) tree implicit_built_in_decls\u00dd(int) END_BUILTINS\u00a8;\n\n/* The definition of tree nodes fills the next several pages.  */\n\n/* A tree node can represent a data type, a variable, an expression\n   or a statement.  Each node has a TREE_CODE which says what kind of\n   thing it represents.  Some common codes are:\n   INTEGER_TYPE -- represents a type of integers.\n   ARRAY_TYPE -- represents a type of pointer.\n   VAR_DECL -- represents a declared variable.\n   INTEGER_CST -- represents a constant integer value.\n   PLUS_EXPR -- represents a sum (an expression).\n\n   As for the contents of a tree node: there are some fields\n   that all nodes share.  Each TREE_CODE has various special-purpose\n   fields as well.  The fields of a node are never accessed directly,\n   always through accessor macros.  */\n\n/* Every kind of tree node starts with this structure,\n   so all nodes have these fields.\n\n   See the accessor macros, defined below, for documentation of the\n   fields.  */\n\nstruct tree_common GTY(())\n{\n  tree chain;\n  tree type;\n\n  ENUM_BITFIELD(tree_code) code : 8;\n\n  unsigned side_effects_flag : 1;\n  unsigned constant_flag : 1;\n  unsigned addressable_flag : 1;\n  unsigned volatile_flag : 1;\n  unsigned readonly_flag : 1;\n  unsigned unsigned_flag : 1;\n  unsigned asm_written_flag: 1;\n  unsigned unused_0 : 1;\n\n  unsigned used_flag : 1;\n  unsigned nothrow_flag : 1;\n  unsigned static_flag : 1;\n  unsigned public_flag : 1;\n  unsigned private_flag : 1;\n  unsigned protected_flag : 1;\n  unsigned deprecated_flag : 1;\n  unsigned unused_1 : 1;\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned unused_2 : 1;\n};\n\n/* The following table lists the uses of each of the above flags and\n   for which types of nodes they are defined.  Note that expressions\n   include decls.\n\n   addressable_flag:\n\n       TREE_ADDRESSABLE in\n\t   VAR_DECL, FUNCTION_DECL, FIELD_DECL, CONSTRUCTOR, LABEL_DECL,\n\t   ..._TYPE, IDENTIFIER_NODE.\n\t   In a STMT_EXPR, it means we want the result of the enclosed\n\t   expression.\n\n   static_flag:\n\n       TREE_STATIC in\n           VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n       TREE_NO_UNUSED_WARNING in\n           CONVERT_EXPR, NOP_EXPR, COMPOUND_EXPR\n       TREE_VIA_VIRTUAL in\n           TREE_LIST or TREE_VEC\n       TREE_CONSTANT_OVERFLOW in\n           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n       TREE_SYMBOL_REFERENCED in\n           IDENTIFIER_NODE\n       CLEANUP_EH_ONLY in\n           TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT,\n\t   TREE_LIST elements of a block's cleanup list.\n\n   public_flag:\n\n       TREE_OVERFLOW in\n           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n       TREE_PUBLIC in\n           VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n       EXPR_WFL_EMIT_LINE_NOTE in\n           EXPR_WITH_FILE_LOCATION\n\n   private_flag:\n\n       TREE_PRIVATE in\n           ..._DECL\n       CALL_EXPR_HAS_RETURN_SLOT_ADDR in\n           CALL_EXPR\n\n   protected_flag:\n\n       TREE_PROTECTED in\n           BLOCK\n\t   ..._DECL\n       CALL_FROM_THUNK_P in\n           CALL_EXPR\n\n   side_effects_flag:\n\n       TREE_SIDE_EFFECTS in\n           all expressions\n\n   volatile_flag:\n\n       TREE_THIS_VOLATILE in\n           all expressions\n       TYPE_VOLATILE in\n           ..._TYPE\n\n   readonly_flag:\n\n       TREE_READONLY in\n           all expressions\n       TYPE_READONLY in\n           ..._TYPE\n\n   constant_flag:\n\n       TREE_CONSTANT in\n           all expressions\n\n   unsigned_flag:\n\n       TREE_UNSIGNED in\n           INTEGER_TYPE, ENUMERAL_TYPE, FIELD_DECL\n       SAVE_EXPR_NOPLACEHOLDER in\n\t   SAVE_EXPR\n\n   asm_written_flag:\n\n       TREE_ASM_WRITTEN in\n           VAR_DECL, FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE\n\t   BLOCK\n\n   used_flag:\n\n       TREE_USED in\n           expressions, IDENTIFIER_NODE\n\n   nothrow_flag:\n\n       TREE_NOTHROW in\n           CALL_EXPR, FUNCTION_DECL\n\n       TYPE_ALIGN_OK in\n\t   ..._TYPE\n\n   deprecated_flag:\n\n\tTREE_DEPRECATED in\n\t   ..._DECL\n\n*/\n\n/* Define accessors for the fields that all tree nodes have\n   (though some fields are not used for all kinds of nodes).  */\n\n/* The tree-code says what kind of node it is.\n   Codes are defined in tree.def.  */\n#define TREE_CODE(NODE) ((enum tree_code) (NODE)->common.code)\n#define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (VALUE))\n\n/* When checking is enabled, errors will be generated if a tree node\n   is accessed incorrectly. The macros abort with a fatal error.  */\n#if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n\n#define TREE_CHECK(T, CODE) __extension__\t\t\t\t\\\n({  const tree __t = (T);\t\t\t\t\t\t\\\n    if (TREE_CODE (__t) != (CODE))\t\t\t\t\t\\\n      tree_check_failed (__t, (CODE), __FILE__, __LINE__, __FUNCTION__); \\\n    __t; })\n\n#define TREE_CLASS_CHECK(T, CLASS) __extension__\t\t\t\\\n({  const tree __t = (T);\t\t\t\t\t\t\\\n    if (TREE_CODE_CLASS (TREE_CODE(__t)) != (CLASS))\t\t\t\\\n      tree_class_check_failed (__t, (CLASS), __FILE__, __LINE__,\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n    __t; })\n\n/* These checks have to be special cased.  */\n#define EXPR_CHECK(T) __extension__\t\t\t\t\t\\\n({  const tree __t = (T);\t\t\t\t\t\t\\\n    char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\t\t\t\\\n    if (!IS_EXPR_CODE_CLASS (__c))\t\t\t\t\t\\\n      tree_class_check_failed (__t, 'e', __FILE__, __LINE__,\t\t\\\n\t\t\t       __FUNCTION__);\t\t\t\t\\\n    __t; })\n\n#define TREE_VEC_ELT_CHECK(T, I) __extension__\t\t\t\t\\\n(*({const tree __t = (T);\t\t\t\t\t\t\\\n    const int __i = (I);\t\t\t\t\t\t\\\n    if (TREE_CODE (__t) != TREE_VEC)\t\t\t\t\t\\\n      tree_check_failed (__t, TREE_VEC,\t\t\t\t\t\\\n\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\t\\\n    if (__i < 0 || __i >= __t->vec.length)\t\t\t\t\\\n      tree_vec_elt_check_failed (__i, __t->vec.length,\t\t\t\\\n\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n    &__t->vec.a\u00dd__i\u00a8; }))\n\n/* Special checks for TREE_OPERANDs.  */\n#define TREE_OPERAND_CHECK(T, I) __extension__\t\t\t\t\\\n(*({const tree __t = EXPR_CHECK (T);\t\t\t\t\t\\\n    const int __i = (I);\t\t\t\t\t\t\\\n    if (__i < 0 || __i >= TREE_CODE_LENGTH (TREE_CODE (__t)))\t\t\\\n      tree_operand_check_failed (__i, TREE_CODE (__t),\t\t\t\\\n\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n    &__t->exp.operands\u00dd__i\u00a8; }))\n\n#define TREE_OPERAND_CHECK_CODE(T, CODE, I) __extension__\t\t\\\n(*({const tree __t = (T);\t\t\t\t\t\t\\\n    const int __i = (I);\t\t\t\t\t\t\\\n    if (TREE_CODE (__t) != CODE)\t\t\t\t\t\\\n      tree_check_failed (__t, CODE, __FILE__, __LINE__, __FUNCTION__);\t\\\n    if (__i < 0 || __i >= TREE_CODE_LENGTH (CODE))\t\t\t\\\n      tree_operand_check_failed (__i, (CODE),\t\t\t\t\\\n\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n    &__t->exp.operands\u00dd__i\u00a8; }))\n\n#define TREE_RTL_OPERAND_CHECK(T, CODE, I) __extension__\t\t\\\n(*(rtx *)\t\t\t\t\t\t\t\t\\\n ({const tree __t = (T);\t\t\t\t\t\t\\\n    const int __i = (I);\t\t\t\t\t\t\\\n    if (TREE_CODE (__t) != (CODE))\t\t\t\t\t\\\n      tree_check_failed (__t, (CODE), __FILE__, __LINE__, __FUNCTION__); \\\n    if (__i < 0 || __i >= TREE_CODE_LENGTH ((CODE)))\t\t\t\\\n      tree_operand_check_failed (__i, (CODE),\t\t\t\t\\\n\t\t\t\t __FILE__, __LINE__, __FUNCTION__);\t\\\n    &__t->exp.operands\u00dd__i\u00a8; }))\n\nextern void tree_check_failed (const tree, enum tree_code,\n\t\t\t       const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\nextern void tree_class_check_failed (const tree, int,\n\t\t\t\t     const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\nextern void tree_vec_elt_check_failed (int, int, const char *,\n\t\t\t\t       int, const char *)\n    ATTRIBUTE_NORETURN;\n\nextern void tree_operand_check_failed (int, enum tree_code,\n\t\t\t\t       const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\n\n#else /* not ENABLE_TREE_CHECKING, or not gcc */\n\n#define TREE_CHECK(T, CODE)\t\t(T)\n#define TREE_CLASS_CHECK(T, CODE)\t(T)\n#define EXPR_CHECK(T)\t\t\t(T)\n#define TREE_VEC_ELT_CHECK(T, I)\t((T)->vec.a\u00ddI\u00a8)\n#define TREE_OPERAND_CHECK(T, I)\t((T)->exp.operands\u00ddI\u00a8)\n#define TREE_OPERAND_CHECK_CODE(T, CODE, I) ((T)->exp.operands\u00ddI\u00a8)\n#define TREE_RTL_OPERAND_CHECK(T, CODE, I)  (*(rtx *) &((T)->exp.operands\u00ddI\u00a8))\n\n#endif\n\n#include \"tree-check.h\"\n\n#define TYPE_CHECK(T)\t\tTREE_CLASS_CHECK (T, 't')\n#define DECL_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'd')\n#define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'c')\n#define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, 's')\n\n/* In all nodes that are expressions, this is the data type of the expression.\n   In POINTER_TYPE nodes, this is the type that the pointer points to.\n   In ARRAY_TYPE nodes, this is the type of the elements.\n   In VECTOR_TYPE nodes, this is the type of the elements.  */\n#define TREE_TYPE(NODE) ((NODE)->common.type)\n\n/* Here is how primitive or already-canonicalized types' hash codes\n   are made.  */\n#define TYPE_HASH(TYPE) ((size_t) (TYPE) & 0777777)\n\n/* Nodes are chained together for many purposes.\n   Types are chained together to record them for being output to the debugger\n   (see the function `chain_type').\n   Decls in the same scope are chained together to record the contents\n   of the scope.\n   Statement nodes for successive statements used to be chained together.\n   Often lists of things are represented by TREE_LIST nodes that\n   are chained together.  */\n\n#define TREE_CHAIN(NODE) ((NODE)->common.chain)\n\n/* Given an expression as a tree, strip any NON_LVALUE_EXPRs and NOP_EXPRs\n   that don't change the machine mode.  */\n\n#define STRIP_NOPS(EXP)\t\t\t\t\t\t\\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Like STRIP_NOPS, but don't let the signedness change either.  */\n\n#define STRIP_SIGN_NOPS(EXP) \\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TYPE_MODE (TREE_TYPE (EXP))\t\t\t\\\n\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\\\n\t && (TREE_UNSIGNED (TREE_TYPE (EXP))\t\t\t\\\n\t     == TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (EXP, 0))))) \\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Like STRIP_NOPS, but don't alter the TREE_TYPE main variant either.  */\n\n#define STRIP_MAIN_TYPE_NOPS(EXP)\t\t\t\t\t\\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\t\\\n\t && (TYPE_MAIN_VARIANT (TREE_TYPE (EXP))\t\t\t\\\n\t     == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (EXP, 0)))))\t\\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Like STRIP_NOPS, but don't alter the TREE_TYPE either.  */\n\n#define STRIP_TYPE_NOPS(EXP) \\\n  while ((TREE_CODE (EXP) == NOP_EXPR\t\t\t\t\\\n\t  || TREE_CODE (EXP) == CONVERT_EXPR\t\t\t\\\n\t  || TREE_CODE (EXP) == NON_LVALUE_EXPR)\t\t\\\n\t && TREE_OPERAND (EXP, 0) != error_mark_node\t\t\\\n\t && (TREE_TYPE (EXP)\t\t\t\t\t\\\n\t     == TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\t\\\n    (EXP) = TREE_OPERAND (EXP, 0)\n\n/* Nonzero if TYPE represents an integral type.  Note that we do not\n   include COMPLEX types here.  */\n\n#define INTEGRAL_TYPE_P(TYPE)  \\\n  (TREE_CODE (TYPE) == INTEGER_TYPE || TREE_CODE (TYPE) == ENUMERAL_TYPE  \\\n   || TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == CHAR_TYPE)\n\n/* Nonzero if TYPE represents a scalar floating-point type.  */\n\n#define SCALAR_FLOAT_TYPE_P(TYPE) (TREE_CODE (TYPE) == REAL_TYPE)\n\n/* Nonzero if TYPE represents a complex floating-point type.  */\n\n#define COMPLEX_FLOAT_TYPE_P(TYPE)\t\\\n  (TREE_CODE (TYPE) == COMPLEX_TYPE\t\\\n   && TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)\n\n/* Nonzero if TYPE represents a floating-point type, including complex\n   floating-point types.  */\n\n#define FLOAT_TYPE_P(TYPE)\t\t\\\n  (SCALAR_FLOAT_TYPE_P (TYPE) || COMPLEX_FLOAT_TYPE_P (TYPE))\n\n/* Nonzero if TYPE represents an aggregate (multi-component) type.  */\n\n#define AGGREGATE_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \\\n   || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \\\n   || TREE_CODE (TYPE) == SET_TYPE)\n\n/* Nonzero if TYPE represents a pointer or reference type.\n   (It should be renamed to INDIRECT_TYPE_P.)  */\n\n#define POINTER_TYPE_P(TYPE) \\\n  (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)\n\n/* Nonzero if this type is a complete type.  */\n#define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n\n/* Nonzero if this type is the (possibly qualified) void type.  */\n#define VOID_TYPE_P(NODE) (TREE_CODE (NODE) == VOID_TYPE)\n\n/* Nonzero if this type is complete or is cv void.  */\n#define COMPLETE_OR_VOID_TYPE_P(NODE) \\\n  (COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))\n\n/* Nonzero if this type is complete or is an array with unspecified bound.  */\n#define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n  (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))\n\n/* Nonzero if TYPE represents a type.  */\n\n#define TYPE_P(TYPE)\t(TREE_CODE_CLASS (TREE_CODE (TYPE)) == 't')\n\n/* Define many boolean fields that all tree nodes have.  */\n\n/* In VAR_DECL nodes, nonzero means address of this is needed.\n   So it cannot be in a register.\n   In a FUNCTION_DECL, nonzero means its address is needed.\n   So it must be compiled even if it is an inline function.\n   In a FIELD_DECL node, it means that the programmer is permitted to\n   construct the address of this field.  This is used for aliasing\n   purposes: see record_component_aliases.\n   In CONSTRUCTOR nodes, it means object constructed must be in memory.\n   In LABEL_DECL nodes, it means a goto for this label has been seen\n   from a place outside all binding contours that restore stack levels.\n   In ..._TYPE nodes, it means that objects of this type must\n   be fully addressable.  This means that pieces of this\n   object cannot go into register parameters, for example.\n   In IDENTIFIER_NODEs, this means that some extern decl for this name\n   had its address taken.  That matters for inline functions.  */\n#define TREE_ADDRESSABLE(NODE) ((NODE)->common.addressable_flag)\n\n/* In a VAR_DECL, nonzero means allocate static storage.\n   In a FUNCTION_DECL, nonzero if function has been defined.\n   In a CONSTRUCTOR, nonzero means allocate static storage.  */\n#define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n\n/* In a TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT, or element of a\n   block's cleanup list, means that the pertinent cleanup should only be\n   executed if an exception is thrown, not on normal exit of its scope.  */\n#define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n\n/* In a CONVERT_EXPR, NOP_EXPR or COMPOUND_EXPR, this means the node was\n   made implicitly and should not lead to an \"unused value\" warning.  */\n#define TREE_NO_UNUSED_WARNING(NODE) ((NODE)->common.static_flag)\n\n/* Nonzero for a TREE_LIST or TREE_VEC node means that the derivation\n   chain is via a `virtual' declaration.  */\n#define TREE_VIA_VIRTUAL(NODE) ((NODE)->common.static_flag)\n\n/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n   there was an overflow in folding.  This is distinct from\n   TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n   occur in constant expressions.  */\n#define TREE_CONSTANT_OVERFLOW(NODE) ((NODE)->common.static_flag)\n\n/* In an IDENTIFIER_NODE, this means that assemble_name was called with\n   this string as an argument.  */\n#define TREE_SYMBOL_REFERENCED(NODE) \\\n  (IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n\n/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n   there was an overflow in folding, and no warning has been issued\n   for this subexpression.  TREE_OVERFLOW implies\n   TREE_CONSTANT_OVERFLOW, but not vice versa.  */\n#define TREE_OVERFLOW(NODE) ((NODE)->common.public_flag)\n\n/* In a VAR_DECL or FUNCTION_DECL,\n   nonzero means name is to be accessible from outside this module.\n   In an IDENTIFIER_NODE, nonzero means an external declaration\n   accessible from outside this module was previously seen\n   for this name in an inner scope.  */\n#define TREE_PUBLIC(NODE) ((NODE)->common.public_flag)\n\n/* In any expression, nonzero means it has side effects or reevaluation\n   of the whole expression could produce a different value.\n   This is set if any subexpression is a function call, a side effect\n   or a reference to a volatile variable.\n   In a ..._DECL, this is set only if the declaration said `volatile'.  */\n#define TREE_SIDE_EFFECTS(NODE) ((NODE)->common.side_effects_flag)\n\n/* Nonzero means this expression is volatile in the C sense:\n   its address should be of type `volatile WHATEVER *'.\n   In other words, the declared item is volatile qualified.\n   This is used in _DECL nodes and _REF nodes.\n\n   In a ..._TYPE node, means this type is volatile-qualified.\n   But use TYPE_VOLATILE instead of this macro when the node is a type,\n   because eventually we may make that a different bit.\n\n   If this bit is set in an expression, so is TREE_SIDE_EFFECTS.  */\n#define TREE_THIS_VOLATILE(NODE) ((NODE)->common.volatile_flag)\n\n/* In a VAR_DECL, PARM_DECL or FIELD_DECL, or any kind of ..._REF node,\n   nonzero means it may not be the lhs of an assignment.\n   In a ..._TYPE node, means this type is const-qualified\n   (but the macro TYPE_READONLY should be used instead of this macro\n   when the node is a type).  */\n#define TREE_READONLY(NODE) ((NODE)->common.readonly_flag)\n\n/* Nonzero if NODE is a _DECL with TREE_READONLY set.  */\n#define TREE_READONLY_DECL_P(NODE) (TREE_READONLY (NODE) && DECL_P (NODE))\n\n/* Value of expression is constant.\n   Always appears in all ..._CST nodes.\n   May also appear in an arithmetic expression, an ADDR_EXPR or a CONSTRUCTOR\n   if the value is constant.  */\n#define TREE_CONSTANT(NODE) ((NODE)->common.constant_flag)\n\n/* In INTEGER_TYPE or ENUMERAL_TYPE nodes, means an unsigned type.\n   In FIELD_DECL nodes, means an unsigned bit field.  */\n#define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n\n#define TYPE_TRAP_SIGNED(NODE) \\\n  (flag_trapv && ! TREE_UNSIGNED (TYPE_CHECK (NODE)))\n\n/* Nonzero in a VAR_DECL means assembler code has been written.\n   Nonzero in a FUNCTION_DECL means that the function has been compiled.\n   This is interesting in an inline function, since it might not need\n   to be compiled separately.\n   Nonzero in a RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE or ENUMERAL_TYPE\n   if the sdb debugging info for the type has been written.\n   In a BLOCK node, nonzero if reorder_blocks has already seen this block.  */\n#define TREE_ASM_WRITTEN(NODE) ((NODE)->common.asm_written_flag)\n\n/* Nonzero in a _DECL if the name is used in its scope.\n   Nonzero in an expr node means inhibit warning if value is unused.\n   In IDENTIFIER_NODEs, this means that some extern decl for this name\n   was used.  */\n#define TREE_USED(NODE) ((NODE)->common.used_flag)\n\n/* In a FUNCTION_DECL, nonzero means a call to the function cannot throw\n   an exception.  In a CALL_EXPR, nonzero means the call cannot throw.  */\n#define TREE_NOTHROW(NODE) ((NODE)->common.nothrow_flag)\n\n/* In a CALL_EXPR, means that the address of the return slot is part of the\n   argument list.  */\n#define CALL_EXPR_HAS_RETURN_SLOT_ADDR(NODE) ((NODE)->common.private_flag)\n\n/* In a CALL_EXPR, means that the call is the jump from a thunk to the\n   thunked-to function.  */\n#define CALL_FROM_THUNK_P(NODE) ((NODE)->common.protected_flag)\n\n/* In a type, nonzero means that all objects of the type are guaranteed by the\n   language or front-end to be properly aligned, so we can indicate that a MEM\n   of this type is aligned at least to the alignment of the type, even if it\n   doesn't appear that it is.  We see this, for example, in object-oriented\n   languages where a tag field may show this is an object of a more-aligned\n   variant of the more generic type.  */\n#define TYPE_ALIGN_OK(NODE) (TYPE_CHECK (NODE)->common.nothrow_flag)\n\n/* Used in classes in C++.  */\n#define TREE_PRIVATE(NODE) ((NODE)->common.private_flag)\n/* Used in classes in C++.\n   In a BLOCK node, this is BLOCK_HANDLER_BLOCK.  */\n#define TREE_PROTECTED(NODE) ((NODE)->common.protected_flag)\n\n/* Nonzero in an IDENTIFIER_NODE if the use of the name is defined as a\n   deprecated feature by __attribute__((deprecated)).  */\n#define TREE_DEPRECATED(NODE) ((NODE)->common.deprecated_flag)\n\n/* These flags are available for each language front end to use internally.  */\n#define TREE_LANG_FLAG_0(NODE) ((NODE)->common.lang_flag_0)\n#define TREE_LANG_FLAG_1(NODE) ((NODE)->common.lang_flag_1)\n#define TREE_LANG_FLAG_2(NODE) ((NODE)->common.lang_flag_2)\n#define TREE_LANG_FLAG_3(NODE) ((NODE)->common.lang_flag_3)\n#define TREE_LANG_FLAG_4(NODE) ((NODE)->common.lang_flag_4)\n#define TREE_LANG_FLAG_5(NODE) ((NODE)->common.lang_flag_5)\n#define TREE_LANG_FLAG_6(NODE) ((NODE)->common.lang_flag_6)\n\n/* Define additional fields and accessors for nodes representing constants.  */\n\n/* In an INTEGER_CST node.  These two together make a 2-word integer.\n   If the data type is signed, the value is sign-extended to 2 words\n   even though not all of them may really be in use.\n   In an unsigned constant shorter than 2 words, the extra bits are 0.  */\n#define TREE_INT_CST(NODE) (INTEGER_CST_CHECK (NODE)->int_cst.int_cst)\n#define TREE_INT_CST_LOW(NODE) (TREE_INT_CST (NODE).low)\n#define TREE_INT_CST_HIGH(NODE) (TREE_INT_CST (NODE).high)\n\n#define INT_CST_LT(A, B)\t\t\t\t\\\n  (TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\\\n   || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\\\n       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n\n#define INT_CST_LT_UNSIGNED(A, B)\t\t\t\t\\\n  (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n    < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\t\\\n   || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\t\\\n\t== (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n\nstruct tree_int_cst GTY(())\n{\n  struct tree_common common;\n  /* A sub-struct is necessary here because the function `const_hash'\n     wants to scan both words as a unit and taking the address of the\n     sub-struct yields the properly inclusive bounded pointer.  */\n  struct tree_int_cst_lowhi {\n    unsigned HOST_WIDE_INT low;\n    HOST_WIDE_INT high;\n  } int_cst;\n};\n\n/* In a REAL_CST node.  struct real_value is an opaque entity, with\n   manipulators defined in real.h.  We don't want tree.h depending on\n   real.h and transitively on tm.h.  */\nstruct real_value;\n\n#define TREE_REAL_CST_PTR(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst_ptr)\n#define TREE_REAL_CST(NODE) (*TREE_REAL_CST_PTR (NODE))\n\nstruct tree_real_cst GTY(())\n{\n  struct tree_common common;\n  struct real_value * real_cst_ptr;\n};\n\n/* In a STRING_CST */\n#define TREE_STRING_LENGTH(NODE) (STRING_CST_CHECK (NODE)->string.length)\n#define TREE_STRING_POINTER(NODE) (STRING_CST_CHECK (NODE)->string.pointer)\n\nstruct tree_string GTY(())\n{\n  struct tree_common common;\n  int length;\n  const char *pointer;\n};\n\n/* In a COMPLEX_CST node.  */\n#define TREE_REALPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.real)\n#define TREE_IMAGPART(NODE) (COMPLEX_CST_CHECK (NODE)->complex.imag)\n\nstruct tree_complex GTY(())\n{\n  struct tree_common common;\n  tree real;\n  tree imag;\n};\n\n/* In a VECTOR_CST node.  */\n#define TREE_VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elements)\n\nstruct tree_vector GTY(())\n{\n  struct tree_common common;\n  tree elements;\n};\n\n#include \"hashtable.h\"\n\n/* Define fields and accessors for some special-purpose tree nodes.  */\n\n#define IDENTIFIER_LENGTH(NODE) \\\n  (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n#define IDENTIFIER_POINTER(NODE) \\\n  ((const char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n#define IDENTIFIER_HASH_VALUE(NODE) \\\n  (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.hash_value)\n\n/* Translate a hash table identifier pointer to a tree_identifier\n   pointer, and vice versa.  */\n\n#define HT_IDENT_TO_GCC_IDENT(NODE) \\\n  ((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n#define GCC_IDENT_TO_HT_IDENT(NODE) (&((struct tree_identifier *) (NODE))->id)\n\nstruct tree_identifier GTY(())\n{\n  struct tree_common common;\n  struct ht_identifier id;\n};\n\n/* In a TREE_LIST node.  */\n#define TREE_PURPOSE(NODE) (TREE_LIST_CHECK (NODE)->list.purpose)\n#define TREE_VALUE(NODE) (TREE_LIST_CHECK (NODE)->list.value)\n\nstruct tree_list GTY(())\n{\n  struct tree_common common;\n  tree purpose;\n  tree value;\n};\n\n/* In a TREE_VEC node.  */\n#define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->vec.length)\n#define TREE_VEC_END(NODE) \\\n  ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a\u00dd(NODE)->vec.length\u00a8))\n\n#define TREE_VEC_ELT(NODE,I) TREE_VEC_ELT_CHECK (NODE, I)\n\nstruct tree_vec GTY(())\n{\n  struct tree_common common;\n  int length;\n  tree GTY ((length (\"TREE_VEC_LENGTH ((tree)&%h)\"))) a\u00dd1\u00a8;\n};\n\n/* Define fields and accessors for some nodes that represent expressions.  */\n\n/* In a SAVE_EXPR node.  */\n#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND_CHECK_CODE (NODE, SAVE_EXPR, 1)\n#define SAVE_EXPR_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, SAVE_EXPR, 2)\n\n#define SAVE_EXPR_NOPLACEHOLDER(NODE) TREE_UNSIGNED (SAVE_EXPR_CHECK (NODE))\n/* Nonzero if the SAVE_EXPRs value should be kept, even if it occurs\n   both in normal code and in a handler.  (Normally, in a handler, all\n   SAVE_EXPRs are unsaved, meaning that their values are\n   recalculated.)  */\n#define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (SAVE_EXPR_CHECK (NODE))\n\n/* In a RTL_EXPR node.  */\n#define RTL_EXPR_SEQUENCE(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 0)\n#define RTL_EXPR_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 1)\n#define RTL_EXPR_ALT_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, RTL_EXPR, 2)\n\n/* In a WITH_CLEANUP_EXPR node.  */\n#define WITH_CLEANUP_EXPR_RTL(NODE) \\\n  TREE_RTL_OPERAND_CHECK (NODE, WITH_CLEANUP_EXPR, 2)\n\n/* In a CONSTRUCTOR node.  */\n#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND_CHECK_CODE (NODE, CONSTRUCTOR, 0)\n\n/* In ordinary expression nodes.  */\n#define TREE_OPERAND(NODE, I) TREE_OPERAND_CHECK (NODE, I)\n#define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n\n/* In a LABELED_BLOCK_EXPR node.  */\n#define LABELED_BLOCK_LABEL(NODE) \\\n  TREE_OPERAND_CHECK_CODE (NODE, LABELED_BLOCK_EXPR, 0)\n#define LABELED_BLOCK_BODY(NODE) \\\n  TREE_OPERAND_CHECK_CODE (NODE, LABELED_BLOCK_EXPR, 1)\n\n/* In an EXIT_BLOCK_EXPR node.  */\n#define EXIT_BLOCK_LABELED_BLOCK(NODE) \\\n  TREE_OPERAND_CHECK_CODE (NODE, EXIT_BLOCK_EXPR, 0)\n#define EXIT_BLOCK_RETURN(NODE) TREE_OPERAND_CHECK_CODE (NODE, EXIT_BLOCK_EXPR, 1)\n\n/* In a LOOP_EXPR node.  */\n#define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)\n\n/* In an EXPR_WITH_FILE_LOCATION node.  */\n#define EXPR_WFL_EMIT_LINE_NOTE(NODE) \\\n  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->common.public_flag)\n#define EXPR_WFL_NODE(NODE) \\\n  TREE_OPERAND_CHECK_CODE (NODE, EXPR_WITH_FILE_LOCATION, 0)\n#define EXPR_WFL_FILENAME_NODE(NODE) \\\n  TREE_OPERAND_CHECK_CODE (NODE, EXPR_WITH_FILE_LOCATION, 1)\n#define EXPR_WFL_FILENAME(NODE) \\\n  IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE (NODE))\n/* ??? Java uses this in all expressions.  */\n#define EXPR_WFL_LINECOL(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n#define EXPR_WFL_LINENO(NODE) (EXPR_WFL_LINECOL (NODE) >> 12)\n#define EXPR_WFL_COLNO(NODE) (EXPR_WFL_LINECOL (NODE) & 0xfff)\n#define EXPR_WFL_SET_LINECOL(NODE, LINE, COL) \\\n  (EXPR_WFL_LINECOL(NODE) = ((LINE) << 12) | ((COL) & 0xfff))\n\n/* In a TARGET_EXPR node.  */\n#define TARGET_EXPR_SLOT(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 0)\n#define TARGET_EXPR_INITIAL(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 1)\n#define TARGET_EXPR_CLEANUP(NODE) TREE_OPERAND_CHECK_CODE (NODE, TARGET_EXPR, 2)\n\nstruct tree_exp GTY(())\n{\n  struct tree_common common;\n  int complexity;\n  tree GTY ((special (\"tree_exp\"),\n\t     desc (\"TREE_CODE ((tree) &%0)\")))\n    operands\u00dd1\u00a8;\n};\n\n/* In a BLOCK node.  */\n#define BLOCK_VARS(NODE) (BLOCK_CHECK (NODE)->block.vars)\n#define BLOCK_SUBBLOCKS(NODE) (BLOCK_CHECK (NODE)->block.subblocks)\n#define BLOCK_SUPERCONTEXT(NODE) (BLOCK_CHECK (NODE)->block.supercontext)\n/* Note: when changing this, make sure to find the places\n   that use chainon or nreverse.  */\n#define BLOCK_CHAIN(NODE) TREE_CHAIN (BLOCK_CHECK (NODE))\n#define BLOCK_ABSTRACT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.abstract_origin)\n#define BLOCK_ABSTRACT(NODE) (BLOCK_CHECK (NODE)->block.abstract_flag)\n\n/* Nonzero means that this block is prepared to handle exceptions\n   listed in the BLOCK_VARS slot.  */\n#define BLOCK_HANDLER_BLOCK(NODE) \\\n  (BLOCK_CHECK (NODE)->block.handler_block_flag)\n\n/* An index number for this block.  These values are not guaranteed to\n   be unique across functions -- whether or not they are depends on\n   the debugging output format in use.  */\n#define BLOCK_NUMBER(NODE) (BLOCK_CHECK (NODE)->block.block_num)\n\n/* If block reordering splits a lexical block into discontiguous\n   address ranges, we'll make a copy of the original block.\n\n   Note that this is logically distinct from BLOCK_ABSTRACT_ORIGIN.\n   In that case, we have one source block that has been replicated\n   (through inlining or unrolling) into many logical blocks, and that\n   these logical blocks have different physical variables in them.\n\n   In this case, we have one logical block split into several\n   non-contiguous address ranges.  Most debug formats can't actually\n   represent this idea directly, so we fake it by creating multiple\n   logical blocks with the same variables in them.  However, for those\n   that do support non-contiguous regions, these allow the original\n   logical block to be reconstructed, along with the set of address\n   ranges.\n\n   One of the logical block fragments is arbitrarily chosen to be\n   the ORIGIN.  The other fragments will point to the origin via\n   BLOCK_FRAGMENT_ORIGIN; the origin itself will have this pointer\n   be null.  The list of fragments will be chained through\n   BLOCK_FRAGMENT_CHAIN from the origin.  */\n\n#define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_origin)\n#define BLOCK_FRAGMENT_CHAIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_chain)\n\nstruct tree_block GTY(())\n{\n  struct tree_common common;\n\n  unsigned handler_block_flag : 1;\n  unsigned abstract_flag : 1;\n  unsigned block_num : 30;\n\n  tree vars;\n  tree subblocks;\n  tree supercontext;\n  tree abstract_origin;\n  tree fragment_origin;\n  tree fragment_chain;\n};\n\n/* Define fields and accessors for nodes representing data types.  */\n\n/* See tree.def for documentation of the use of these fields.\n   Look at the documentation of the various ..._TYPE tree codes.  */\n\n#define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type.uid)\n#define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n#define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n#define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n#define TYPE_VALUES(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_DOMAIN(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_FIELDS(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_METHODS(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_VFIELD(NODE) (TYPE_CHECK (NODE)->type.minval)\n#define TYPE_ARG_TYPES(NODE) (TYPE_CHECK (NODE)->type.values)\n#define TYPE_METHOD_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_OFFSET_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type.pointer_to)\n#define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type.reference_to)\n#define TYPE_MIN_VALUE(NODE) (TYPE_CHECK (NODE)->type.minval)\n#define TYPE_MAX_VALUE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n#define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n#define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n#define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)\n#define TYPE_SYMTAB_DIE(NODE) (TYPE_CHECK (NODE)->type.symtab.die)\n#define TYPE_NAME(NODE) (TYPE_CHECK (NODE)->type.name)\n#define TYPE_NEXT_VARIANT(NODE) (TYPE_CHECK (NODE)->type.next_variant)\n#define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n#define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n#define TYPE_LANG_SPECIFIC(NODE) (TYPE_CHECK (NODE)->type.lang_specific)\n\n/* For a VECTOR_TYPE node, this describes a different type which is emitted\n   in the debugging output.  We use this to describe a vector as a\n   structure containing an array.  */\n#define TYPE_DEBUG_REPRESENTATION_TYPE(NODE) (TYPE_CHECK (NODE)->type.values)\n\n/* For aggregate types, information about this type, as a base type\n   for itself.  Used in a language-dependent way for types that are\n   neither a RECORD_TYPE, QUAL_UNION_TYPE, nor a UNION_TYPE.  */\n#define TYPE_BINFO(NODE) (TYPE_CHECK (NODE)->type.binfo)\n\n/* The (language-specific) typed-based alias set for this type.\n   Objects whose TYPE_ALIAS_SETs are different cannot alias each\n   other.  If the TYPE_ALIAS_SET is -1, no alias set has yet been\n   assigned to this type.  If the TYPE_ALIAS_SET is 0, objects of this\n   type can alias objects of any type.  */\n#define TYPE_ALIAS_SET(NODE) (TYPE_CHECK (NODE)->type.alias_set)\n\n/* Nonzero iff the typed-based alias set for this type has been\n   calculated.  */\n#define TYPE_ALIAS_SET_KNOWN_P(NODE) (TYPE_CHECK (NODE)->type.alias_set != -1)\n\n/* A TREE_LIST of IDENTIFIER nodes of the attributes that apply\n   to this type.  */\n#define TYPE_ATTRIBUTES(NODE) (TYPE_CHECK (NODE)->type.attributes)\n\n/* The alignment necessary for objects of this type.\n   The value is an int, measured in bits.  */\n#define TYPE_ALIGN(NODE) (TYPE_CHECK (NODE)->type.align)\n\n/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n   0 if it is the default for this type.  */\n#define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->type.user_align)\n\n/* The alignment for NODE, in bytes.  */\n#define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)\n\n/* If your language allows you to declare types, and you want debug info\n   for them, then you need to generate corresponding TYPE_DECL nodes.\n   These \"stub\" TYPE_DECL nodes have no name, and simply point at the\n   type node.  You then set the TYPE_STUB_DECL field of the type node\n   to point back at the TYPE_DECL node.  This allows the debug routines\n   to know that the two nodes represent the same type, so that we only\n   get one debug info record for them.  */\n#define TYPE_STUB_DECL(NODE) TREE_CHAIN (NODE)\n\n/* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type\n   has BLKmode only because it lacks the alignment requirement for\n   its size.  */\n#define TYPE_NO_FORCE_BLK(NODE) (TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* In an INTEGER_TYPE, it means the type represents a size.  We use\n   this both for validity checking and to permit optimizations that\n   are unsafe for other types.  Note that the C `size_t' type should\n   *not* have this flag set.  The `size_t' type is simply a typedef\n   for an ordinary integer type that happens to be the type of an\n   expression returned by `sizeof'; `size_t' has no special\n   properties.  Expressions whose type have TYPE_IS_SIZETYPE set are\n   always actual sizes.  */\n#define TYPE_IS_SIZETYPE(NODE) \\\n  (INTEGER_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* In a FUNCTION_TYPE, indicates that the function returns with the stack\n   pointer depressed.  */\n#define TYPE_RETURNS_STACK_DEPRESSED(NODE) \\\n  (FUNCTION_TYPE_CHECK (NODE)->type.no_force_blk_flag)\n\n/* Nonzero in a type considered volatile as a whole.  */\n#define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->common.volatile_flag)\n\n/* Means this type is const-qualified.  */\n#define TYPE_READONLY(NODE) (TYPE_CHECK (NODE)->common.readonly_flag)\n\n/* If nonzero, this type is `restrict'-qualified, in the C sense of\n   the term.  */\n#define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)\n\n/* There is a TYPE_QUAL value for each type qualifier.  They can be\n   combined by bitwise-or to form the complete set of qualifiers for a\n   type.  */\n\n#define TYPE_UNQUALIFIED   0x0\n#define TYPE_QUAL_CONST    0x1\n#define TYPE_QUAL_VOLATILE 0x2\n#define TYPE_QUAL_RESTRICT 0x4\n\n/* The set of type qualifiers for this type.  */\n#define TYPE_QUALS(NODE)\t\t\t\t\t\\\n  ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)\t\t\t\\\n   | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)\t\t\\\n   | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT))\n\n/* These flags are available for each language front end to use internally.  */\n#define TYPE_LANG_FLAG_0(NODE) (TYPE_CHECK (NODE)->type.lang_flag_0)\n#define TYPE_LANG_FLAG_1(NODE) (TYPE_CHECK (NODE)->type.lang_flag_1)\n#define TYPE_LANG_FLAG_2(NODE) (TYPE_CHECK (NODE)->type.lang_flag_2)\n#define TYPE_LANG_FLAG_3(NODE) (TYPE_CHECK (NODE)->type.lang_flag_3)\n#define TYPE_LANG_FLAG_4(NODE) (TYPE_CHECK (NODE)->type.lang_flag_4)\n#define TYPE_LANG_FLAG_5(NODE) (TYPE_CHECK (NODE)->type.lang_flag_5)\n#define TYPE_LANG_FLAG_6(NODE) (TYPE_CHECK (NODE)->type.lang_flag_6)\n\n/* If set in an ARRAY_TYPE, indicates a string type (for languages\n   that distinguish string from array of char).\n   If set in a SET_TYPE, indicates a bitstring type.  */\n#define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)\n\n/* If non-NULL, this is an upper bound of the size (in bytes) of an\n   object of the given ARRAY_TYPE.  This allows temporaries to be\n   allocated.  */\n#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n  TYPE_MAX_VALUE (ARRAY_TYPE_CHECK (ARRAY_TYPE))\n\n/* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n  GET_MODE_NUNITS (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.mode)\n\n  /* Indicates that objects of this type must be initialized by calling a\n   function when they are created.  */\n#define TYPE_NEEDS_CONSTRUCTING(NODE) \\\n  (TYPE_CHECK (NODE)->type.needs_constructing_flag)\n\n/* Indicates that objects of this type (a UNION_TYPE), should be passed\n   the same way that the first union alternative would be passed.  */\n#define TYPE_TRANSPARENT_UNION(NODE)  \\\n  (UNION_TYPE_CHECK (NODE)->type.transparent_union_flag)\n\n/* For an ARRAY_TYPE, indicates that it is not permitted to\n   take the address of a component of the type.  */\n#define TYPE_NONALIASED_COMPONENT(NODE) \\\n  (ARRAY_TYPE_CHECK (NODE)->type.transparent_union_flag)\n\n/* Indicated that objects of this type should be laid out in as\n   compact a way as possible.  */\n#define TYPE_PACKED(NODE) (TYPE_CHECK (NODE)->type.packed_flag)\n\nstruct die_struct;\n\nstruct tree_type GTY(())\n{\n  struct tree_common common;\n  tree values;\n  tree size;\n  tree size_unit;\n  tree attributes;\n  unsigned int uid;\n\n  unsigned int precision : 9;\n  ENUM_BITFIELD(machine_mode) mode : 7;\n\n  unsigned string_flag : 1;\n  unsigned no_force_blk_flag : 1;\n  unsigned needs_constructing_flag : 1;\n  unsigned transparent_union_flag : 1;\n  unsigned packed_flag : 1;\n  unsigned restrict_flag : 1;\n  unsigned spare : 2;\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned user_align : 1;\n\n  unsigned int align;\n  tree pointer_to;\n  tree reference_to;\n  union tree_type_symtab {\n    int GTY ((tag (\"0\"))) address;\n    char * GTY ((tag (\"1\"))) pointer;\n    struct die_struct * GTY ((tag (\"2\"))) die;\n  } GTY ((desc (\"debug_hooks == &sdb_debug_hooks ? 1 : debug_hooks == &dwarf2_debug_hooks ? 2 : 0\"),\n\t  descbits (\"2\"))) symtab;\n  tree name;\n  tree minval;\n  tree maxval;\n  tree next_variant;\n  tree main_variant;\n  tree binfo;\n  tree context;\n  HOST_WIDE_INT alias_set;\n  /* Points to a structure whose details depend on the language in use.  */\n  struct lang_type *lang_specific;\n};\n\n/* Define accessor macros for information about type inheritance\n   and basetypes.\n\n   A \"basetype\" means a particular usage of a data type for inheritance\n   in another type.  Each such basetype usage has its own \"binfo\"\n   object to describe it.  The binfo object is a TREE_VEC node.\n\n   Inheritance is represented by the binfo nodes allocated for a\n   given type.  For example, given types C and D, such that D is\n   inherited by C, 3 binfo nodes will be allocated: one for describing\n   the binfo properties of C, similarly one for D, and one for\n   describing the binfo properties of D as a base type for C.\n   Thus, given a pointer to class C, one can get a pointer to the binfo\n   of D acting as a basetype for C by looking at C's binfo's basetypes.  */\n\n/* The actual data type node being inherited in this basetype.  */\n#define BINFO_TYPE(NODE) TREE_TYPE (NODE)\n\n/* The offset where this basetype appears in its containing type.\n   BINFO_OFFSET slot holds the offset (in bytes)\n   from the base of the complete object to the base of the part of the\n   object that is allocated on behalf of this `type'.\n   This is always 0 except when there is multiple inheritance.  */\n\n#define BINFO_OFFSET(NODE) TREE_VEC_ELT ((NODE), 1)\n#define TYPE_BINFO_OFFSET(NODE) BINFO_OFFSET (TYPE_BINFO (NODE))\n#define BINFO_OFFSET_ZEROP(NODE) (integer_zerop (BINFO_OFFSET (NODE)))\n\n/* The virtual function table belonging to this basetype.  Virtual\n   function tables provide a mechanism for run-time method dispatching.\n   The entries of a virtual function table are language-dependent.  */\n\n#define BINFO_VTABLE(NODE) TREE_VEC_ELT ((NODE), 2)\n#define TYPE_BINFO_VTABLE(NODE) BINFO_VTABLE (TYPE_BINFO (NODE))\n\n/* The virtual functions in the virtual function table.  This is\n   a TREE_LIST that is used as an initial approximation for building\n   a virtual function table for this basetype.  */\n#define BINFO_VIRTUALS(NODE) TREE_VEC_ELT ((NODE), 3)\n#define TYPE_BINFO_VIRTUALS(NODE) BINFO_VIRTUALS (TYPE_BINFO (NODE))\n\n/* A vector of binfos for the direct basetypes inherited by this\n   basetype.\n\n   If this basetype describes type D as inherited in C, and if the\n   basetypes of D are E and F, then this vector contains binfos for\n   inheritance of E and F by C.\n\n   ??? This could probably be done by just allocating the\n   base types at the end of this TREE_VEC (instead of using\n   another TREE_VEC).  This would simplify the calculation\n   of how many basetypes a given type had.  */\n#define BINFO_BASETYPES(NODE) TREE_VEC_ELT ((NODE), 4)\n#define TYPE_BINFO_BASETYPES(NODE) TREE_VEC_ELT (TYPE_BINFO (NODE), 4)\n\n/* The number of basetypes for NODE.  */\n#define BINFO_N_BASETYPES(NODE) \\\n  (BINFO_BASETYPES (NODE) ? TREE_VEC_LENGTH (BINFO_BASETYPES (NODE)) : 0)\n\n/* Accessor macro to get to the Nth basetype of this basetype.  */\n#define BINFO_BASETYPE(NODE,N) TREE_VEC_ELT (BINFO_BASETYPES (NODE), (N))\n#define TYPE_BINFO_BASETYPE(NODE,N) \\\n  BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n\n/* For a BINFO record describing a virtual base class, i.e., one where\n   TREE_VIA_VIRTUAL is set, this field assists in locating the virtual\n   base.  The actual contents are language-dependent.  In the C++\n   front-end this field is an INTEGER_CST giving an offset into the\n   vtable where the offset to the virtual base can be found.  */\n#define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT (NODE, 5)\n\n/* Indicates the accesses this binfo has to its bases. The values are\n   access_public_node, access_protected_node or access_private_node.\n   If this array is not present, public access is implied.  */\n#define BINFO_BASEACCESSES(NODE) TREE_VEC_ELT ((NODE), 6)\n#define BINFO_BASEACCESS(NODE,N) TREE_VEC_ELT (BINFO_BASEACCESSES(NODE), (N))\n\n/* Number of language independent elements in a binfo.  Languages may\n   add additional trailing elements.  */\n\n#define BINFO_ELTS 7\n\n/* Slot used to build a chain that represents a use of inheritance.\n   For example, if X is derived from Y, and Y is derived from Z,\n   then this field can be used to link the binfo node for X to\n   the binfo node for X's Y to represent the use of inheritance\n   from X to Y.  Similarly, this slot of the binfo node for X's Y\n   can point to the Z from which Y is inherited (in X's inheritance\n   hierarchy).  In this fashion, one can represent and traverse specific\n   uses of inheritance using the binfo nodes themselves (instead of\n   consing new space pointing to binfo nodes).\n   It is up to the language-dependent front-ends to maintain\n   this information as necessary.  */\n#define BINFO_INHERITANCE_CHAIN(NODE) TREE_VEC_ELT ((NODE), 0)\n\n/* Define fields and accessors for nodes representing declared names.  */\n\n/* Nonzero if DECL represents a decl.  */\n#define DECL_P(DECL)\t(TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd')\n\n/* This is the name of the object as written by the user.\n   It is an IDENTIFIER_NODE.  */\n#define DECL_NAME(NODE) (DECL_CHECK (NODE)->decl.name)\n\n/* The name of the object as the assembler will see it (but before any\n   translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n#define DECL_ASSEMBLER_NAME(NODE) decl_assembler_name (NODE)\n\n/* Returns nonzero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,\n   the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set\n   yet.  */\n#define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n  (DECL_CHECK (NODE)->decl.assembler_name != NULL_TREE)\n\n/* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n  (DECL_CHECK (NODE)->decl.assembler_name = (NAME))\n\n/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n   semantics of using this macro, are different than saying:\n\n     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n\n   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n\n#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n  (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2,\t\t\t\t\\\n\t\t\t\t     DECL_ASSEMBLER_NAME (DECL1))\t\\\n   : (void) 0)\n\n/* Records the section name in a section attribute.  Used to pass\n   the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n#define DECL_SECTION_NAME(NODE) (DECL_CHECK (NODE)->decl.section_name)\n\n/*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or\n    QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,\n    PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes, this\n    points to either the FUNCTION_DECL for the containing function,\n    the RECORD_TYPE or UNION_TYPE for the containing type, or\n    NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has \"file\n    scope\".  */\n#define DECL_CONTEXT(NODE) (DECL_CHECK (NODE)->decl.context)\n#define DECL_FIELD_CONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.context)\n/* In a DECL this is the field where attributes are stored.  */\n#define DECL_ATTRIBUTES(NODE) (DECL_CHECK (NODE)->decl.attributes)\n/* In a FIELD_DECL, this is the field position, counting in bytes, of the\n   byte containing the bit closest to the beginning of the structure.  */\n#define DECL_FIELD_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.arguments)\n/* In a FIELD_DECL, this is the offset, in bits, of the first bit of the\n   field from DECL_FIELD_OFFSET.  */\n#define DECL_FIELD_BIT_OFFSET(NODE) (FIELD_DECL_CHECK (NODE)->decl.u2.t)\n/* In a FIELD_DECL, this indicates whether the field was a bit-field and\n   if so, the type that was originally specified for it.\n   TREE_TYPE may have been modified (in finish_struct).  */\n#define DECL_BIT_FIELD_TYPE(NODE) (FIELD_DECL_CHECK (NODE)->decl.result)\n/* In FUNCTION_DECL, a chain of ..._DECL nodes.\n   VAR_DECL and PARM_DECL reserve the arguments slot for language-specific\n   uses.  */\n#define DECL_ARGUMENTS(NODE) (DECL_CHECK (NODE)->decl.arguments)\n/* This field is used to reference anything in decl.result and is meant only\n   for use by the garbage collector.  */\n#define DECL_RESULT_FLD(NODE) (DECL_CHECK (NODE)->decl.result)\n/* In FUNCTION_DECL, holds the decl for the return value.  */\n#define DECL_RESULT(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.result)\n/* For a TYPE_DECL, holds the \"original\" type.  (TREE_TYPE has the copy.) */\n#define DECL_ORIGINAL_TYPE(NODE) (TYPE_DECL_CHECK (NODE)->decl.result)\n/* In PARM_DECL, holds the type as written (perhaps a function or array).  */\n#define DECL_ARG_TYPE_AS_WRITTEN(NODE) (PARM_DECL_CHECK (NODE)->decl.result)\n/* For a FUNCTION_DECL, holds the tree of BINDINGs.\n   For a TRANSLATION_UNIT_DECL, holds the namespace's BLOCK.\n   For a VAR_DECL, holds the initial value.\n   For a PARM_DECL, not used--default\n   values for parameters are encoded in the type of the function,\n   not in the PARM_DECL slot.  */\n#define DECL_INITIAL(NODE) (DECL_CHECK (NODE)->decl.initial)\n/* For a PARM_DECL, records the data type used to pass the argument,\n   which may be different from the type seen in the program.  */\n#define DECL_ARG_TYPE(NODE) (PARM_DECL_CHECK (NODE)->decl.initial)\n/* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n   if nonzero, indicates that the field occupies the type.  */\n#define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->decl.initial)\n/* These two fields describe where in the source code the declaration\n   was.  If the declaration appears in several places (as for a C\n   function that is declared first and then defined later), this\n   information should refer to the definition.  */\n#define DECL_SOURCE_LOCATION(NODE) (DECL_CHECK (NODE)->decl.locus)\n#define DECL_SOURCE_FILE(NODE) (DECL_SOURCE_LOCATION (NODE).file)\n#define DECL_SOURCE_LINE(NODE) (DECL_SOURCE_LOCATION (NODE).line)\n/* Holds the size of the datum, in bits, as a tree expression.\n   Need not be constant.  */\n#define DECL_SIZE(NODE) (DECL_CHECK (NODE)->decl.size)\n/* Likewise for the size in bytes.  */\n#define DECL_SIZE_UNIT(NODE) (DECL_CHECK (NODE)->decl.size_unit)\n/* Holds the alignment required for the datum, in bits.  */\n#define DECL_ALIGN(NODE) (DECL_CHECK (NODE)->decl.u1.a.align)\n/* The alignment of NODE, in bytes.  */\n#define DECL_ALIGN_UNIT(NODE) (DECL_ALIGN (NODE) / BITS_PER_UNIT)\n/* For FIELD_DECLs, off_align holds the number of low-order bits of\n   DECL_FIELD_OFFSET which are known to be always zero.\n   DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET\n   has.  */\n#define DECL_OFFSET_ALIGN(NODE) \\\n  (((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align)\n/* Specify that DECL_ALIGN(NODE) is a multiple of X.  */\n#define SET_DECL_OFFSET_ALIGN(NODE, X) \\\n  (FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align\t= exact_log2 ((X) & -(X)))\n/* 1 if the alignment for this type was requested by \"aligned\" attribute,\n   0 if it is the default for this type.  */\n#define DECL_USER_ALIGN(NODE) (DECL_CHECK (NODE)->decl.user_align)\n/* Holds the machine mode corresponding to the declaration of a variable or\n   field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a\n   FIELD_DECL.  */\n#define DECL_MODE(NODE) (DECL_CHECK (NODE)->decl.mode)\n/* Holds the RTL expression for the value of a variable or function.\n   This value can be evaluated lazily for functions, variables with\n   static storage duration, and labels.  */\n#define DECL_RTL(NODE)\t\t\t\t\t\\\n  (DECL_CHECK (NODE)->decl.rtl\t\t\t\t\\\n   ? (NODE)->decl.rtl\t\t\t\t\t\\\n   : (make_decl_rtl (NODE, NULL), (NODE)->decl.rtl))\n/* Set the DECL_RTL for NODE to RTL.  */\n#define SET_DECL_RTL(NODE, RTL) set_decl_rtl (NODE, RTL)\n/* Returns nonzero if the DECL_RTL for NODE has already been set.  */\n#define DECL_RTL_SET_P(NODE)  (DECL_CHECK (NODE)->decl.rtl != NULL)\n/* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n   NODE1, it will not be set for NODE2; this is a lazy copy.  */\n#define COPY_DECL_RTL(NODE1, NODE2) \\\n  (DECL_CHECK (NODE2)->decl.rtl = DECL_CHECK (NODE1)->decl.rtl)\n/* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n\n/* For PARM_DECL, holds an RTL for the stack slot or register\n   where the data was actually passed.  */\n#define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->decl.u2.r)\n\n/* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n#define DECL_SAVED_INSNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u2.f)\n\n/* For FUNCTION_DECL, if it is built-in,\n   this identifies which built-in operation it is.  */\n#define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.f)\n\n/* The DECL_VINDEX is used for FUNCTION_DECLS in two different ways.\n   Before the struct containing the FUNCTION_DECL is laid out,\n   DECL_VINDEX may point to a FUNCTION_DECL in a base class which\n   is the FUNCTION_DECL which this FUNCTION_DECL will replace as a virtual\n   function.  When the class is laid out, this pointer is changed\n   to an INTEGER_CST node which is suitable for use as an index\n   into the virtual function table.  */\n#define DECL_VINDEX(NODE) (DECL_CHECK (NODE)->decl.vindex)\n\n/* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n   which this FIELD_DECL is defined.  This information is needed when\n   writing debugging information about vfield and vbase decls for C++.  */\n#define DECL_FCONTEXT(NODE) (FIELD_DECL_CHECK (NODE)->decl.vindex)\n\n/* Every ..._DECL node gets a unique number.  */\n#define DECL_UID(NODE) (DECL_CHECK (NODE)->decl.uid)\n\n/* For any sort of a ..._DECL node, this points to the original (abstract)\n   decl node which this decl is an instance of, or else it is NULL indicating\n   that this decl is not an instance of some other decl.  For example,\n   in a nested declaration of an inline function, this points back to the\n   definition.  */\n#define DECL_ABSTRACT_ORIGIN(NODE) (DECL_CHECK (NODE)->decl.abstract_origin)\n\n/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract\n   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */\n#define DECL_ORIGIN(NODE) \\\n  (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : (NODE))\n\n/* Nonzero for any sort of ..._DECL node means this decl node represents an\n   inline instance of some original (abstract) decl from an inline function;\n   suppress any warnings about shadowing some other variable.  FUNCTION_DECL\n   nodes can also have their abstract origin set to themselves.  */\n#define DECL_FROM_INLINE(NODE) (DECL_ABSTRACT_ORIGIN (NODE) != NULL_TREE \\\n\t\t\t\t&& DECL_ABSTRACT_ORIGIN (NODE) != (NODE))\n\n/* Nonzero if a _DECL means that the name of this decl should be ignored\n   for symbolic debug purposes.  */\n#define DECL_IGNORED_P(NODE) (DECL_CHECK (NODE)->decl.ignored_flag)\n\n/* Nonzero for a given ..._DECL node means that this node represents an\n   \"abstract instance\" of the given declaration (e.g. in the original\n   declaration of an inline function).  When generating symbolic debugging\n   information, we mustn't try to generate any address information for nodes\n   marked as \"abstract instances\" because we don't actually generate\n   any code or allocate any data space for such instances.  */\n#define DECL_ABSTRACT(NODE) (DECL_CHECK (NODE)->decl.abstract_flag)\n\n/* Nonzero if a _DECL means that no warnings should be generated just\n   because this decl is unused.  */\n#define DECL_IN_SYSTEM_HEADER(NODE) \\\n  (DECL_CHECK (NODE)->decl.in_system_header_flag)\n\n/* Nonzero for a given ..._DECL node means that this node should be\n   put in .common, if possible.  If a DECL_INITIAL is given, and it\n   is not error_mark_node, then the decl cannot be put in .common.  */\n#define DECL_COMMON(NODE) (DECL_CHECK (NODE)->decl.common_flag)\n\n/* Language-specific decl information.  */\n#define DECL_LANG_SPECIFIC(NODE) (DECL_CHECK (NODE)->decl.lang_specific)\n\n/* In a VAR_DECL or FUNCTION_DECL,\n   nonzero means external reference:\n   do not allocate storage, and refer to a definition elsewhere.  */\n#define DECL_EXTERNAL(NODE) (DECL_CHECK (NODE)->decl.external_flag)\n\n/* In a VAR_DECL for a RECORD_TYPE, sets number for non-init_priority\n   initializations.  */\n#define DEFAULT_INIT_PRIORITY 65535\n#define MAX_INIT_PRIORITY 65535\n#define MAX_RESERVED_INIT_PRIORITY 100\n\n/* In a TYPE_DECL\n   nonzero means the detail info about this type is not dumped into stabs.\n   Instead it will generate cross reference ('x') of names.\n   This uses the same flag as DECL_EXTERNAL.  */\n#define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n  (TYPE_DECL_CHECK (NODE)->decl.external_flag)\n\n/* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n#define DECL_REGISTER(NODE) (DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In LABEL_DECL nodes, nonzero means that an error message about\n   jumping into such a binding contour has been printed for this label.  */\n#define DECL_ERROR_ISSUED(NODE) (LABEL_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In a FIELD_DECL, indicates this field should be bit-packed.  */\n#define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* In a FUNCTION_DECL with a nonzero DECL_CONTEXT, indicates that a\n   static chain is not needed.  */\n#define DECL_NO_STATIC_CHAIN(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.regdecl_flag)\n\n/* Nonzero in a ..._DECL means this variable is ref'd from a nested function.\n   For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.\n\n   For LABEL_DECL nodes, nonzero if nonlocal gotos to the label are permitted.\n\n   Also set in some languages for variables, etc., outside the normal\n   lexical scope, such as class instance variables.  */\n#define DECL_NONLOCAL(NODE) (DECL_CHECK (NODE)->decl.nonlocal_flag)\n\n/* Nonzero in a FUNCTION_DECL means this function can be substituted\n   where it is called.  */\n#define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n\n/* Nonzero in a FUNCTION_DECL means that this function was declared inline,\n   such as via the `inline' keyword in C/C++.  This flag controls the linkage\n   semantics of 'inline'; whether or not the function is inlined is\n   controlled by DECL_INLINE.  */\n#define DECL_DECLARED_INLINE_P(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.declared_inline_flag)\n\n/* Value of the decls's visibility attribute */\n#define DECL_VISIBILITY(NODE) (DECL_CHECK (NODE)->decl.visibility)\n\n/* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n#define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n\n/* In a VAR_DECL, nonzero if the data should be allocated from\n   thread-local storage.  */\n#define DECL_THREAD_LOCAL(NODE) (VAR_DECL_CHECK (NODE)->decl.thread_local_flag)\n\n/* In a FUNCTION_DECL, the saved representation of the body of the\n   entire function.  Usually a COMPOUND_STMT, but in C++ this may also\n   be a RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n#define DECL_SAVED_TREE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.saved_tree)\n\n/* List of FUNCTION_DECLs inlined into this function's body.  */\n#define DECL_INLINED_FNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inlined_fns)\n\n/* Nonzero in a FUNCTION_DECL means this function should be treated\n   as if it were a malloc, meaning it returns a pointer that is\n   not an alias.  */\n#define DECL_IS_MALLOC(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.malloc_flag)\n\n/* Nonzero in a FUNCTION_DECL means this function should be treated\n   as \"pure\" function (like const function, but may read global memory).  */\n#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.pure_flag)\n\n/* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n   specially.  */\n#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* In a LABEL_DECL, nonzero means label was defined inside a binding\n   contour that restored a stack level and which is now exited.  */\n#define DECL_TOO_LATE(NODE) (LABEL_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* Unused in FUNCTION_DECL.  */\n\n/* In a VAR_DECL that's static,\n   nonzero if the space is in the text section.  */\n#define DECL_IN_TEXT_SECTION(NODE) (VAR_DECL_CHECK (NODE)->decl.bit_field_flag)\n\n/* In a FUNCTION_DECL, nonzero means a built in function.  */\n#define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)\n\n/* For a builtin function, identify which part of the compiler defined it.  */\n#define DECL_BUILT_IN_CLASS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->decl.built_in_class)\n\n/* Used in VAR_DECLs to indicate that the variable is a vtable.\n   Used in FIELD_DECLs for vtable pointers.\n   Used in FUNCTION_DECLs to indicate that the function is virtual.  */\n#define DECL_VIRTUAL_P(NODE) (DECL_CHECK (NODE)->decl.virtual_flag)\n\n/* Used to indicate that the linkage status of this DECL is not yet known,\n   so it should not be output now.  */\n#define DECL_DEFER_OUTPUT(NODE) (DECL_CHECK (NODE)->decl.defer_output)\n\n/* Used in PARM_DECLs whose type are unions to indicate that the\n   argument should be passed in the same way that the first union\n   alternative would be passed.  */\n#define DECL_TRANSPARENT_UNION(NODE) \\\n  (PARM_DECL_CHECK (NODE)->decl.transparent_union)\n\n/* Used in FUNCTION_DECLs to indicate that they should be run automatically\n   at the beginning or end of execution.  */\n#define DECL_STATIC_CONSTRUCTOR(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.static_ctor_flag)\n\n#define DECL_STATIC_DESTRUCTOR(NODE) \\\n(FUNCTION_DECL_CHECK (NODE)->decl.static_dtor_flag)\n\n/* Used to indicate that this DECL represents a compiler-generated entity.  */\n#define DECL_ARTIFICIAL(NODE) (DECL_CHECK (NODE)->decl.artificial_flag)\n\n/* Used to indicate that this DECL has weak linkage.  */\n#define DECL_WEAK(NODE) (DECL_CHECK (NODE)->decl.weak_flag)\n\n/* Used in TREE_PUBLIC decls to indicate that copies of this DECL in\n   multiple translation units should be merged.  */\n#define DECL_ONE_ONLY(NODE) (DECL_CHECK (NODE)->decl.transparent_union)\n\n/* Used in a DECL to indicate that, even if it TREE_PUBLIC, it need\n   not be put out unless it is needed in this translation unit.\n   Entities like this are shared across translation units (like weak\n   entities), but are guaranteed to be generated by any translation\n   unit that needs them, and therefore need not be put out anywhere\n   where they are not needed.  DECL_COMDAT is just a hint to the\n   back-end; it is up to front-ends which set this flag to ensure\n   that there will never be any harm, other than bloat, in putting out\n   something which is DECL_COMDAT.  */\n#define DECL_COMDAT(NODE) (DECL_CHECK (NODE)->decl.comdat_flag)\n\n/* Used in FUNCTION_DECLs to indicate that function entry and exit should\n   be instrumented with calls to support routines.  */\n#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n\n/* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n   disabled in this function.  */\n#define DECL_NO_LIMIT_STACK(NODE) \\\n  (FUNCTION_DECL_CHECK (NODE)->decl.no_limit_stack)\n\n/* Additional flags for language-specific uses.  */\n#define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n#define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n#define DECL_LANG_FLAG_2(NODE) (DECL_CHECK (NODE)->decl.lang_flag_2)\n#define DECL_LANG_FLAG_3(NODE) (DECL_CHECK (NODE)->decl.lang_flag_3)\n#define DECL_LANG_FLAG_4(NODE) (DECL_CHECK (NODE)->decl.lang_flag_4)\n#define DECL_LANG_FLAG_5(NODE) (DECL_CHECK (NODE)->decl.lang_flag_5)\n#define DECL_LANG_FLAG_6(NODE) (DECL_CHECK (NODE)->decl.lang_flag_6)\n#define DECL_LANG_FLAG_7(NODE) (DECL_CHECK (NODE)->decl.lang_flag_7)\n\n/* Used to indicate that the pointer to this DECL cannot be treated as\n   an address constant.  */\n#define DECL_NON_ADDR_CONST_P(NODE) (DECL_CHECK (NODE)->decl.non_addr_const_p)\n\n/* Used in a FIELD_DECL to indicate that we cannot form the address of\n   this component.  */\n#define DECL_NONADDRESSABLE_P(NODE) \\\n  (FIELD_DECL_CHECK (NODE)->decl.non_addressable)\n\n/* Used to indicate an alias set for the memory pointed to by this\n   particular FIELD_DECL, PARM_DECL, or VAR_DECL, which must have\n   pointer (or reference) type.  */\n#define DECL_POINTER_ALIAS_SET(NODE) \\\n  (DECL_CHECK (NODE)->decl.pointer_alias_set)\n\n/* Nonzero if an alias set has been assigned to this declaration.  */\n#define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n  (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n\n/* Nonzero for a decl which is at file scope.  */\n#define DECL_FILE_SCOPE_P(EXP) \t\t\t\t\t\\\n  (! DECL_CONTEXT (EXP)\t\t\t\t\t\t\\\n   || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)\n\n/* Enumerate visibility settings.  */\n\nenum symbol_visibility\n{\n  VISIBILITY_DEFAULT,\n  VISIBILITY_INTERNAL,\n  VISIBILITY_HIDDEN,\n  VISIBILITY_PROTECTED\n};\n\nstruct function;\n\nstruct tree_decl GTY(())\n{\n  struct tree_common common;\n  location_t locus;\n  unsigned int uid;\n  tree size;\n  ENUM_BITFIELD(machine_mode) mode : 8;\n\n  unsigned external_flag : 1;\n  unsigned nonlocal_flag : 1;\n  unsigned regdecl_flag : 1;\n  unsigned inline_flag : 1;\n  unsigned bit_field_flag : 1;\n  unsigned virtual_flag : 1;\n  unsigned ignored_flag : 1;\n  unsigned abstract_flag : 1;\n\n  unsigned in_system_header_flag : 1;\n  unsigned common_flag : 1;\n  unsigned defer_output : 1;\n  unsigned transparent_union : 1;\n  unsigned static_ctor_flag : 1;\n  unsigned static_dtor_flag : 1;\n  unsigned artificial_flag : 1;\n  unsigned weak_flag : 1;\n\n  unsigned non_addr_const_p : 1;\n  unsigned no_instrument_function_entry_exit : 1;\n  unsigned comdat_flag : 1;\n  unsigned malloc_flag : 1;\n  unsigned no_limit_stack : 1;\n  ENUM_BITFIELD(built_in_class) built_in_class : 2;\n  unsigned pure_flag : 1;\n\n  unsigned non_addressable : 1;\n  unsigned user_align : 1;\n  unsigned uninlinable : 1;\n  unsigned thread_local_flag : 1;\n  unsigned declared_inline_flag : 1;\n  ENUM_BITFIELD(symbol_visibility) visibility : 2;\n  unsigned unused : 1;\n  /* one unused bit.  */\n\n  unsigned lang_flag_0 : 1;\n  unsigned lang_flag_1 : 1;\n  unsigned lang_flag_2 : 1;\n  unsigned lang_flag_3 : 1;\n  unsigned lang_flag_4 : 1;\n  unsigned lang_flag_5 : 1;\n  unsigned lang_flag_6 : 1;\n  unsigned lang_flag_7 : 1;\n\n  union tree_decl_u1 {\n    /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n       DECL_FUNCTION_CODE.  */\n    enum built_in_function f;\n    /* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this\n       is used by language-dependent code.  */\n    HOST_WIDE_INT i;\n    /* DECL_ALIGN and DECL_OFFSET_ALIGN.  (These are not used for\n       FUNCTION_DECLs).  */\n    struct tree_decl_u1_a {\n      unsigned int align : 24;\n      unsigned int off_align : 8;\n    } a;\n  } GTY ((skip (\"\"))) u1;\n\n  tree size_unit;\n  tree name;\n  tree context;\n  tree arguments;\t/* Also used for DECL_FIELD_OFFSET */\n  tree result;\t/* Also used for DECL_BIT_FIELD_TYPE */\n  tree initial;\t/* Also used for DECL_QUALIFIER */\n  tree abstract_origin;\n  tree assembler_name;\n  tree section_name;\n  tree attributes;\n  rtx rtl;\t/* RTL representation for object.  */\n\n  /* In FUNCTION_DECL, if it is inline, holds the saved insn chain.\n     In FIELD_DECL, is DECL_FIELD_BIT_OFFSET.\n     In PARM_DECL, holds an RTL for the stack slot\n     of register where the data was actually passed.\n     Used by Chill and Java in LABEL_DECL and by C++ and Java in VAR_DECL.  */\n  union tree_decl_u2 {\n    struct function * GTY ((tag (\"FUNCTION_DECL\"))) f;\n    rtx GTY ((tag (\"PARM_DECL\"))) r;\n    tree GTY ((tag (\"FIELD_DECL\"))) t;\n    int GTY ((tag (\"VAR_DECL\"))) i;\n  } GTY ((desc (\"TREE_CODE((tree) &(%0))\"))) u2;\n\n  /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n  tree saved_tree;\n\n  /* In a FUNCTION_DECL, these are function data which is to be kept\n     as long as FUNCTION_DECL is kept.  */\n  tree inlined_fns;\n\n  tree vindex;\n  HOST_WIDE_INT pointer_alias_set;\n  /* Points to a structure whose details depend on the language in use.  */\n  struct lang_decl *lang_specific;\n};\n\nenum tree_node_structure_enum {\n  TS_COMMON,\n  TS_INT_CST,\n  TS_REAL_CST,\n  TS_VECTOR,\n  TS_STRING,\n  TS_COMPLEX,\n  TS_IDENTIFIER,\n  TS_DECL,\n  TS_TYPE,\n  TS_LIST,\n  TS_VEC,\n  TS_EXP,\n  TS_BLOCK,\n  LAST_TS_ENUM\n};\n\n/* Define the overall contents of a tree node.\n   It may be any of the structures declared above\n   for various types of node.  */\n\nunion tree_node GTY ((ptr_alias (union lang_tree_node),\n\t\t      desc (\"tree_node_structure (&%h)\")))\n{\n  struct tree_common GTY ((tag (\"TS_COMMON\"))) common;\n  struct tree_int_cst GTY ((tag (\"TS_INT_CST\"))) int_cst;\n  struct tree_real_cst GTY ((tag (\"TS_REAL_CST\"))) real_cst;\n  struct tree_vector GTY ((tag (\"TS_VECTOR\"))) vector;\n  struct tree_string GTY ((tag (\"TS_STRING\"))) string;\n  struct tree_complex GTY ((tag (\"TS_COMPLEX\"))) complex;\n  struct tree_identifier GTY ((tag (\"TS_IDENTIFIER\"))) identifier;\n  struct tree_decl GTY ((tag (\"TS_DECL\"))) decl;\n  struct tree_type GTY ((tag (\"TS_TYPE\"))) type;\n  struct tree_list GTY ((tag (\"TS_LIST\"))) list;\n  struct tree_vec GTY ((tag (\"TS_VEC\"))) vec;\n  struct tree_exp GTY ((tag (\"TS_EXP\"))) exp;\n  struct tree_block GTY ((tag (\"TS_BLOCK\"))) block;\n };\n\n/* Standard named or nameless data types of the C compiler.  */\n\nenum tree_index\n{\n  TI_ERROR_MARK,\n  TI_INTQI_TYPE,\n  TI_INTHI_TYPE,\n  TI_INTSI_TYPE,\n  TI_INTDI_TYPE,\n  TI_INTTI_TYPE,\n\n  TI_UINTQI_TYPE,\n  TI_UINTHI_TYPE,\n  TI_UINTSI_TYPE,\n  TI_UINTDI_TYPE,\n  TI_UINTTI_TYPE,\n\n  TI_INTEGER_ZERO,\n  TI_INTEGER_ONE,\n  TI_INTEGER_MINUS_ONE,\n  TI_NULL_POINTER,\n\n  TI_SIZE_ZERO,\n  TI_SIZE_ONE,\n\n  TI_BITSIZE_ZERO,\n  TI_BITSIZE_ONE,\n  TI_BITSIZE_UNIT,\n\n  TI_PUBLIC,\n  TI_PROTECTED,\n  TI_PRIVATE,\n\n  TI_BOOLEAN_FALSE,\n  TI_BOOLEAN_TRUE,\n\n  TI_COMPLEX_INTEGER_TYPE,\n  TI_COMPLEX_FLOAT_TYPE,\n  TI_COMPLEX_DOUBLE_TYPE,\n  TI_COMPLEX_LONG_DOUBLE_TYPE,\n\n  TI_FLOAT_TYPE,\n  TI_DOUBLE_TYPE,\n  TI_LONG_DOUBLE_TYPE,\n\n  TI_FLOAT_PTR_TYPE,\n  TI_DOUBLE_PTR_TYPE,\n  TI_LONG_DOUBLE_PTR_TYPE,\n  TI_INTEGER_PTR_TYPE,\n\n  TI_VOID_TYPE,\n  TI_PTR_TYPE,\n  TI_CONST_PTR_TYPE,\n  TI_SIZE_TYPE,\n  TI_PTRDIFF_TYPE,\n  TI_VA_LIST_TYPE,\n  TI_BOOLEAN_TYPE,\n\n  TI_VOID_LIST_NODE,\n\n  TI_UV4SF_TYPE,\n  TI_UV4SI_TYPE,\n  TI_UV8HI_TYPE,\n  TI_UV8QI_TYPE,\n  TI_UV4HI_TYPE,\n  TI_UV2HI_TYPE,\n  TI_UV2SI_TYPE,\n  TI_UV2SF_TYPE,\n  TI_UV2DI_TYPE,\n  TI_UV1DI_TYPE,\n  TI_UV16QI_TYPE,\n\n  TI_V4SF_TYPE,\n  TI_V16SF_TYPE,\n  TI_V4SI_TYPE,\n  TI_V8HI_TYPE,\n  TI_V8QI_TYPE,\n  TI_V4HI_TYPE,\n  TI_V2HI_TYPE,\n  TI_V2SI_TYPE,\n  TI_V2SF_TYPE,\n  TI_V2DF_TYPE,\n  TI_V2DI_TYPE,\n  TI_V1DI_TYPE,\n  TI_V16QI_TYPE,\n  TI_V4DF_TYPE,\n\n  TI_MAIN_IDENTIFIER,\n\n  TI_MAX\n};\n\nextern GTY(()) tree global_trees\u00ddTI_MAX\u00a8;\n\n#define error_mark_node\t\t\tglobal_trees\u00ddTI_ERROR_MARK\u00a8\n\n#define intQI_type_node\t\t\tglobal_trees\u00ddTI_INTQI_TYPE\u00a8\n#define intHI_type_node\t\t\tglobal_trees\u00ddTI_INTHI_TYPE\u00a8\n#define intSI_type_node\t\t\tglobal_trees\u00ddTI_INTSI_TYPE\u00a8\n#define intDI_type_node\t\t\tglobal_trees\u00ddTI_INTDI_TYPE\u00a8\n#define intTI_type_node\t\t\tglobal_trees\u00ddTI_INTTI_TYPE\u00a8\n\n#define unsigned_intQI_type_node\tglobal_trees\u00ddTI_UINTQI_TYPE\u00a8\n#define unsigned_intHI_type_node\tglobal_trees\u00ddTI_UINTHI_TYPE\u00a8\n#define unsigned_intSI_type_node\tglobal_trees\u00ddTI_UINTSI_TYPE\u00a8\n#define unsigned_intDI_type_node\tglobal_trees\u00ddTI_UINTDI_TYPE\u00a8\n#define unsigned_intTI_type_node\tglobal_trees\u00ddTI_UINTTI_TYPE\u00a8\n\n#define integer_zero_node\t\tglobal_trees\u00ddTI_INTEGER_ZERO\u00a8\n#define integer_one_node\t\tglobal_trees\u00ddTI_INTEGER_ONE\u00a8\n#define integer_minus_one_node\t\tglobal_trees\u00ddTI_INTEGER_MINUS_ONE\u00a8\n#define size_zero_node\t\t\tglobal_trees\u00ddTI_SIZE_ZERO\u00a8\n#define size_one_node\t\t\tglobal_trees\u00ddTI_SIZE_ONE\u00a8\n#define bitsize_zero_node\t\tglobal_trees\u00ddTI_BITSIZE_ZERO\u00a8\n#define bitsize_one_node\t\tglobal_trees\u00ddTI_BITSIZE_ONE\u00a8\n#define bitsize_unit_node\t\tglobal_trees\u00ddTI_BITSIZE_UNIT\u00a8\n\n/* Base access nodes.  */\n#define access_public_node\t\tglobal_trees\u00ddTI_PUBLIC\u00a8\n#define access_protected_node\t        global_trees\u00ddTI_PROTECTED\u00a8\n#define access_private_node\t\tglobal_trees\u00ddTI_PRIVATE\u00a8\n\n#define null_pointer_node\t\tglobal_trees\u00ddTI_NULL_POINTER\u00a8\n\n#define float_type_node\t\t\tglobal_trees\u00ddTI_FLOAT_TYPE\u00a8\n#define double_type_node\t\tglobal_trees\u00ddTI_DOUBLE_TYPE\u00a8\n#define long_double_type_node\t\tglobal_trees\u00ddTI_LONG_DOUBLE_TYPE\u00a8\n\n#define float_ptr_type_node\t\tglobal_trees\u00ddTI_FLOAT_PTR_TYPE\u00a8\n#define double_ptr_type_node\t\tglobal_trees\u00ddTI_DOUBLE_PTR_TYPE\u00a8\n#define long_double_ptr_type_node\tglobal_trees\u00ddTI_LONG_DOUBLE_PTR_TYPE\u00a8\n#define integer_ptr_type_node\t\tglobal_trees\u00ddTI_INTEGER_PTR_TYPE\u00a8\n\n#define complex_integer_type_node\tglobal_trees\u00ddTI_COMPLEX_INTEGER_TYPE\u00a8\n#define complex_float_type_node\t\tglobal_trees\u00ddTI_COMPLEX_FLOAT_TYPE\u00a8\n#define complex_double_type_node\tglobal_trees\u00ddTI_COMPLEX_DOUBLE_TYPE\u00a8\n#define complex_long_double_type_node\tglobal_trees\u00ddTI_COMPLEX_LONG_DOUBLE_TYPE\u00a8\n\n#define void_type_node\t\t\tglobal_trees\u00ddTI_VOID_TYPE\u00a8\n/* The C type `void *'.  */\n#define ptr_type_node\t\t\tglobal_trees\u00ddTI_PTR_TYPE\u00a8\n/* The C type `const void *'.  */\n#define const_ptr_type_node\t\tglobal_trees\u00ddTI_CONST_PTR_TYPE\u00a8\n/* The C type `size_t'.  */\n#define size_type_node                  global_trees\u00ddTI_SIZE_TYPE\u00a8\n#define ptrdiff_type_node\t\tglobal_trees\u00ddTI_PTRDIFF_TYPE\u00a8\n#define va_list_type_node\t\tglobal_trees\u00ddTI_VA_LIST_TYPE\u00a8\n\n#define boolean_type_node\t\tglobal_trees\u00ddTI_BOOLEAN_TYPE\u00a8\n#define boolean_false_node\t\tglobal_trees\u00ddTI_BOOLEAN_FALSE\u00a8\n#define boolean_true_node\t\tglobal_trees\u00ddTI_BOOLEAN_TRUE\u00a8\n\n/* The node that should be placed at the end of a parameter list to\n   indicate that the function does not take a variable number of\n   arguments.  The TREE_VALUE will be void_type_node and there will be\n   no TREE_CHAIN.  Language-independent code should not assume\n   anything else about this node.  */\n#define void_list_node                  global_trees\u00ddTI_VOID_LIST_NODE\u00a8\n\n#define main_identifier_node\t\tglobal_trees\u00ddTI_MAIN_IDENTIFIER\u00a8\n#define MAIN_NAME_P(NODE) (IDENTIFIER_NODE_CHECK (NODE) == main_identifier_node)\n\n#define unsigned_V16QI_type_node\tglobal_trees\u00ddTI_UV16QI_TYPE\u00a8\n#define unsigned_V4SI_type_node\t\tglobal_trees\u00ddTI_UV4SI_TYPE\u00a8\n#define unsigned_V8QI_type_node\t\tglobal_trees\u00ddTI_UV8QI_TYPE\u00a8\n#define unsigned_V8HI_type_node\t\tglobal_trees\u00ddTI_UV8HI_TYPE\u00a8\n#define unsigned_V4HI_type_node\t\tglobal_trees\u00ddTI_UV4HI_TYPE\u00a8\n#define unsigned_V2HI_type_node\t\tglobal_trees\u00ddTI_UV2HI_TYPE\u00a8\n#define unsigned_V2SI_type_node\t\tglobal_trees\u00ddTI_UV2SI_TYPE\u00a8\n#define unsigned_V2DI_type_node\t\tglobal_trees\u00ddTI_UV2DI_TYPE\u00a8\n#define unsigned_V1DI_type_node\t\tglobal_trees\u00ddTI_UV1DI_TYPE\u00a8\n\n#define V16QI_type_node\t\t\tglobal_trees\u00ddTI_V16QI_TYPE\u00a8\n#define V4SF_type_node\t\t\tglobal_trees\u00ddTI_V4SF_TYPE\u00a8\n#define V4SI_type_node\t\t\tglobal_trees\u00ddTI_V4SI_TYPE\u00a8\n#define V8QI_type_node\t\t\tglobal_trees\u00ddTI_V8QI_TYPE\u00a8\n#define V8HI_type_node\t\t\tglobal_trees\u00ddTI_V8HI_TYPE\u00a8\n#define V4HI_type_node\t\t\tglobal_trees\u00ddTI_V4HI_TYPE\u00a8\n#define V2HI_type_node\t\t\tglobal_trees\u00ddTI_V2HI_TYPE\u00a8\n#define V2SI_type_node\t\t\tglobal_trees\u00ddTI_V2SI_TYPE\u00a8\n#define V2SF_type_node\t\t\tglobal_trees\u00ddTI_V2SF_TYPE\u00a8\n#define V2DI_type_node\t\t\tglobal_trees\u00ddTI_V2DI_TYPE\u00a8\n#define V2DF_type_node\t\t\tglobal_trees\u00ddTI_V2DF_TYPE\u00a8\n#define V16SF_type_node\t\t\tglobal_trees\u00ddTI_V16SF_TYPE\u00a8\n#define V1DI_type_node\t\t\tglobal_trees\u00ddTI_V1DI_TYPE\u00a8\n#define V4DF_type_node\t\t\tglobal_trees\u00ddTI_V4DF_TYPE\u00a8\n\n/* An enumeration of the standard C integer types.  These must be\n   ordered so that shorter types appear before longer ones, and so\n   that signed types appear before unsigned ones, for the correct\n   functioning of interpret_integer() in c-lex.c.  */\nenum integer_type_kind\n{\n  itk_char,\n  itk_signed_char,\n  itk_unsigned_char,\n  itk_short,\n  itk_unsigned_short,\n  itk_int,\n  itk_unsigned_int,\n  itk_long,\n  itk_unsigned_long,\n  itk_long_long,\n  itk_unsigned_long_long,\n  itk_none\n};\n\ntypedef enum integer_type_kind integer_type_kind;\n\n/* The standard C integer types.  Use integer_type_kind to index into\n   this array.  */\nextern GTY(()) tree integer_types\u00dditk_none\u00a8;\n\n#define char_type_node\t\t\tinteger_types\u00dditk_char\u00a8\n#define signed_char_type_node\t\tinteger_types\u00dditk_signed_char\u00a8\n#define unsigned_char_type_node\t\tinteger_types\u00dditk_unsigned_char\u00a8\n#define short_integer_type_node\t\tinteger_types\u00dditk_short\u00a8\n#define short_unsigned_type_node\tinteger_types\u00dditk_unsigned_short\u00a8\n#define integer_type_node\t\tinteger_types\u00dditk_int\u00a8\n#define unsigned_type_node\t\tinteger_types\u00dditk_unsigned_int\u00a8\n#define long_integer_type_node\t\tinteger_types\u00dditk_long\u00a8\n#define long_unsigned_type_node\t\tinteger_types\u00dditk_unsigned_long\u00a8\n#define long_long_integer_type_node\tinteger_types\u00dditk_long_long\u00a8\n#define long_long_unsigned_type_node\tinteger_types\u00dditk_unsigned_long_long\u00a8\n\n/* Set to the default thread-local storage (tls) model to use.  */\n\nenum tls_model {\n  TLS_MODEL_GLOBAL_DYNAMIC = 1,\n  TLS_MODEL_LOCAL_DYNAMIC,\n  TLS_MODEL_INITIAL_EXEC,\n  TLS_MODEL_LOCAL_EXEC\n};\n\nextern enum tls_model flag_tls_default;\n\n\n/* A pointer-to-function member type looks like:\n\n     struct {\n       __P __pfn;\n       ptrdiff_t __delta;\n     };\n\n   If __pfn is NULL, it is a NULL pointer-to-member-function.\n\n   (Because the vtable is always the first thing in the object, we\n   don't need its offset.)  If the function is virtual, then PFN is\n   one plus twice the index into the vtable; otherwise, it is just a\n   pointer to the function.\n\n   Unfortunately, using the lowest bit of PFN doesn't work in\n   architectures that don't impose alignment requirements on function\n   addresses, or that use the lowest bit to tell one ISA from another,\n   for example.  For such architectures, we use the lowest bit of\n   DELTA instead of the lowest bit of the PFN, and DELTA will be\n   multiplied by 2.  */\n\nenum ptrmemfunc_vbit_where_t\n{\n  ptrmemfunc_vbit_in_pfn,\n  ptrmemfunc_vbit_in_delta\n};\n\n#define NULL_TREE (tree) NULL\n\nextern tree decl_assembler_name (tree);\n\n/* Compute the number of bytes occupied by 'node'.  This routine only\n   looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n\nextern size_t tree_size (tree);\n\n/* Lowest level primitive for allocating a node.\n   The TREE_CODE is the only argument.  Contents are initialized\n   to zero except for a few of the common fields.  */\n\nextern tree make_node (enum tree_code);\n\n/* Make a copy of a node, with all the same contents.  */\n\nextern tree copy_node (tree);\n\n/* Make a copy of a chain of TREE_LIST nodes.  */\n\nextern tree copy_list (tree);\n\n/* Make a TREE_VEC.  */\n\nextern tree make_tree_vec (int);\n\n/* Return the (unique) IDENTIFIER_NODE node for a given name.\n   The name is supplied as a char *.  */\n\nextern tree get_identifier (const char *);\n\n#if GCC_VERSION >= 3000\n#define get_identifier(str) \\\n  (__builtin_constant_p (str)\t\t\t\t\\\n    ? get_identifier_with_length ((str), strlen (str))  \\\n    : get_identifier (str))\n#endif\n\n\n/* Identical to get_identifier, except that the length is assumed\n   known.  */\n\nextern tree get_identifier_with_length (const char *, size_t);\n\n/* If an identifier with the name TEXT (a null-terminated string) has\n   previously been referred to, return that node; otherwise return\n   NULL_TREE.  */\n\nextern tree maybe_get_identifier (const char *);\n\n/* Construct various types of nodes.  */\n\n#define build_int_2(LO, HI)  \\\n  build_int_2_wide ((unsigned HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n\nextern tree build (enum tree_code, tree, ...);\nextern tree build_nt (enum tree_code, ...);\n\nextern tree build_int_2_wide (unsigned HOST_WIDE_INT, HOST_WIDE_INT);\nextern tree build_vector (tree, tree);\nextern tree build_constructor (tree, tree);\nextern tree build_real_from_int_cst (tree, tree);\nextern tree build_complex (tree, tree, tree);\nextern tree build_string (int, const char *);\nextern tree build1 (enum tree_code, tree, tree);\nextern tree build_tree_list (tree, tree);\nextern tree build_decl (enum tree_code, tree, tree);\nextern tree build_block (tree, tree, tree, tree, tree);\nextern tree build_expr_wfl (tree, const char *, int, int);\n\n/* Construct various nodes representing data types.  */\n\nextern tree make_signed_type (int);\nextern tree make_unsigned_type (int);\nextern void initialize_sizetypes (void);\nextern void set_sizetype (tree);\nextern void fixup_unsigned_type (tree);\nextern tree build_pointer_type_for_mode (tree, enum machine_mode);\nextern tree build_pointer_type (tree);\nextern tree build_reference_type_for_mode (tree, enum machine_mode);\nextern tree build_reference_type (tree);\nextern tree build_type_no_quals (tree);\nextern tree build_index_type (tree);\nextern tree build_index_2_type (tree, tree);\nextern tree build_array_type (tree, tree);\nextern tree build_function_type (tree, tree);\nextern tree build_function_type_list (tree, ...);\nextern tree build_method_type_directly (tree, tree, tree);\nextern tree build_method_type (tree, tree);\nextern tree build_offset_type (tree, tree);\nextern tree build_complex_type (tree);\nextern tree array_type_nelts (tree);\n\nextern tree value_member (tree, tree);\nextern tree purpose_member (tree, tree);\nextern tree binfo_member (tree, tree);\nextern unsigned int attribute_hash_list (tree);\nextern int attribute_list_equal (tree, tree);\nextern int attribute_list_contained (tree, tree);\nextern int tree_int_cst_equal (tree, tree);\nextern int tree_int_cst_lt (tree, tree);\nextern int tree_int_cst_compare (tree, tree);\nextern int host_integerp (tree, int);\nextern HOST_WIDE_INT tree_low_cst (tree, int);\nextern int tree_int_cst_msb (tree);\nextern int tree_int_cst_sgn (tree);\nextern int tree_expr_nonnegative_p (tree);\nextern int rtl_expr_nonnegative_p (rtx);\nextern tree get_inner_array_type (tree);\n\n/* From expmed.c.  Since rtl.h is included after tree.h, we can't\n   put the prototype here.  Rtl.h does declare the prototype if\n   tree.h had been included.  */\n\nextern tree make_tree (tree, rtx);\n\n/* Return a type like TTYPE except that its TYPE_ATTRIBUTES\n   is ATTRIBUTE.\n\n   Such modified types already made are recorded so that duplicates\n   are not made.  */\n\nextern tree build_type_attribute_variant (tree, tree);\nextern tree build_decl_attribute_variant (tree, tree);\n\n/* Structure describing an attribute and a function to handle it.  */\nstruct attribute_spec\n{\n  /* The name of the attribute (without any leading or trailing __),\n     or NULL to mark the end of a table of attributes.  */\n  const char *const name;\n  /* The minimum length of the list of arguments of the attribute.  */\n  const int min_length;\n  /* The maximum length of the list of arguments of the attribute\n     (-1 for no maximum).  */\n  const int max_length;\n  /* Whether this attribute requires a DECL.  If it does, it will be passed\n     from types of DECLs, function return types and array element types to\n     the DECLs, function types and array types respectively; but when\n     applied to a type in any other circumstances, it will be ignored with\n     a warning.  (If greater control is desired for a given attribute,\n     this should be false, and the flags argument to the handler may be\n     used to gain greater control in that case.)  */\n  const bool decl_required;\n  /* Whether this attribute requires a type.  If it does, it will be passed\n     from a DECL to the type of that DECL.  */\n  const bool type_required;\n  /* Whether this attribute requires a function (or method) type.  If it does,\n     it will be passed from a function pointer type to the target type,\n     and from a function return type (which is not itself a function\n     pointer type) to the function type.  */\n  const bool function_type_required;\n  /* Function to handle this attribute.  NODE points to the node to which\n     the attribute is to be applied.  If a DECL, it should be modified in\n     place; if a TYPE, a copy should be created.  NAME is the name of the\n     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST\n     of the arguments (which may be NULL).  FLAGS gives further information\n     about the context of the attribute.  Afterwards, the attributes will\n     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,\n     unless *NO_ADD_ATTRS is set to true (which should be done on error,\n     as well as in any other cases when the attributes should not be added\n     to the DECL or TYPE).  Depending on FLAGS, any attributes to be\n     applied to another type or DECL later may be returned;\n     otherwise the return value should be NULL_TREE.  This pointer may be\n     NULL if no special handling is required beyond the checks implied\n     by the rest of this structure.  */\n  tree (*const handler) (tree *node, tree name, tree args,\n\t\t\t\t int flags, bool *no_add_attrs);\n};\n\n/* Flags that may be passed in the third argument of decl_attributes, and\n   to handler functions for attributes.  */\nenum attribute_flags\n{\n  /* The type passed in is the type of a DECL, and any attributes that\n     should be passed in again to be applied to the DECL rather than the\n     type should be returned.  */\n  ATTR_FLAG_DECL_NEXT = 1,\n  /* The type passed in is a function return type, and any attributes that\n     should be passed in again to be applied to the function type rather\n     than the return type should be returned.  */\n  ATTR_FLAG_FUNCTION_NEXT = 2,\n  /* The type passed in is an array element type, and any attributes that\n     should be passed in again to be applied to the array type rather\n     than the element type should be returned.  */\n  ATTR_FLAG_ARRAY_NEXT = 4,\n  /* The type passed in is a structure, union or enumeration type being\n     created, and should be modified in place.  */\n  ATTR_FLAG_TYPE_IN_PLACE = 8,\n  /* The attributes are being applied by default to a library function whose\n     name indicates known behavior, and should be silently ignored if they\n     are not in fact compatible with the function type.  */\n  ATTR_FLAG_BUILT_IN = 16\n};\n\n/* Default versions of target-overridable functions.  */\n\nextern tree merge_decl_attributes (tree, tree);\nextern tree merge_type_attributes (tree, tree);\nextern void default_register_cpp_builtins (struct cpp_reader *);\n\n/* Split a list of declspecs and attributes into two.  */\n\nextern void split_specs_attrs (tree, tree *, tree *);\n\n/* Strip attributes from a list of combined specs and attrs.  */\n\nextern tree strip_attrs (tree);\n\n/* Return 1 if an attribute and its arguments are valid for a decl or type.  */\n\nextern int valid_machine_attribute (tree, tree, tree, tree);\n\n/* Given a tree node and a string, return nonzero if the tree node is\n   a valid attribute name for the string.  */\n\nextern int is_attribute_p (const char *, tree);\n\n/* Given an attribute name and a list of attributes, return the list element\n   of the attribute or NULL_TREE if not found.  */\n\nextern tree lookup_attribute (const char *, tree);\n\n/* Given two attributes lists, return a list of their union.  */\n\nextern tree merge_attributes (tree, tree);\n\n#ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n/* Given two Windows decl attributes lists, possibly including\n   dllimport, return a list of their union .  */\nextern tree merge_dllimport_decl_attributes (tree, tree);\n#endif\n\n/* Return a version of the TYPE, qualified as indicated by the\n   TYPE_QUALS, if one exists.  If no qualified version exists yet,\n   return NULL_TREE.  */\n\nextern tree get_qualified_type (tree, int);\n\n/* Like get_qualified_type, but creates the type if it does not\n   exist.  This function never returns NULL_TREE.  */\n\nextern tree build_qualified_type (tree, int);\n\n/* Like build_qualified_type, but only deals with the `const' and\n   `volatile' qualifiers.  This interface is retained for backwards\n   compatibility with the various front-ends; new code should use\n   build_qualified_type instead.  */\n\n#define build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t\t\\\n  build_qualified_type ((TYPE),\t\t\t\t\t\t\\\n\t\t\t((CONST_P) ? TYPE_QUAL_CONST : 0)\t\t\\\n\t\t\t| ((VOLATILE_P) ? TYPE_QUAL_VOLATILE : 0))\n\n/* Make a copy of a type node.  */\n\nextern tree build_type_copy (tree);\n\n/* Finish up a builtin RECORD_TYPE. Give it a name and provide its\n   fields. Optionally specify an alignment, and then lsy it out.  */\n\nextern void finish_builtin_struct (tree, const char *,\n\t\t\t\t\t\t\t tree, tree);\n\n/* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n   TYPE_ALIGN and TYPE_MODE fields.  If called more than once on one\n   node, does nothing except for the first time.  */\n\nextern void layout_type (tree);\n\n/* These functions allow a front-end to perform a manual layout of a\n   RECORD_TYPE.  (For instance, if the placement of subsequent fields\n   depends on the placement of fields so far.)  Begin by calling\n   start_record_layout.  Then, call place_field for each of the\n   fields.  Then, call finish_record_layout.  See layout_type for the\n   default way in which these functions are used.  */\n\ntypedef struct record_layout_info_s\n{\n  /* The RECORD_TYPE that we are laying out.  */\n  tree t;\n  /* The offset into the record so far, in bytes, not including bits in\n     BITPOS.  */\n  tree offset;\n  /* The last known alignment of SIZE.  */\n  unsigned int offset_align;\n  /* The bit position within the last OFFSET_ALIGN bits, in bits.  */\n  tree bitpos;\n  /* The alignment of the record so far, in bits.  */\n  unsigned int record_align;\n  /* The alignment of the record so far, ignoring #pragma pack and\n     __attribute__ ((packed)), in bits.  */\n  unsigned int unpacked_align;\n  /* The previous field layed out.  */\n  tree prev_field;\n  /* The static variables (i.e., class variables, as opposed to\n     instance variables) encountered in T.  */\n  tree pending_statics;\n  /* Bits remaining in the current alignment group */\n  int remaining_in_alignment;\n  /* True if we've seen a packed field that didn't have normal\n     alignment anyway.  */\n  int packed_maybe_necessary;\n} *record_layout_info;\n\nextern void set_lang_adjust_rli (void (*) (record_layout_info));\nextern record_layout_info start_record_layout (tree);\nextern tree bit_from_pos (tree, tree);\nextern tree byte_from_pos (tree, tree);\nextern void pos_from_bit (tree *, tree *, unsigned int, tree);\nextern void normalize_offset (tree *, tree *, unsigned int);\nextern tree rli_size_unit_so_far (record_layout_info);\nextern tree rli_size_so_far (record_layout_info);\nextern void normalize_rli (record_layout_info);\nextern void place_field (record_layout_info, tree);\nextern void compute_record_mode (tree);\nextern void finish_record_layout (record_layout_info, int);\n\n/* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n   return a canonicalized ..._TYPE node, so that duplicates are not made.\n   How the hash code is computed is up to the caller, as long as any two\n   callers that could hash identical-looking type nodes agree.  */\n\nextern tree type_hash_canon (unsigned int, tree);\n\n/* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n   calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n   fields.  Call this only once for any given decl node.\n\n   Second argument is the boundary that this field can be assumed to\n   be starting at (in bits).  Zero means it can be assumed aligned\n   on any boundary that may be needed.  */\n\nextern void layout_decl (tree, unsigned);\n\n/* Return the mode for data of a given size SIZE and mode class CLASS.\n   If LIMIT is nonzero, then don't use modes bigger than MAX_FIXED_MODE_SIZE.\n   The value is BLKmode if no other mode is found.  This is like\n   mode_for_size, but is passed a tree.  */\n\nextern enum machine_mode mode_for_size_tree (tree, enum mode_class, int);\n\n/* Return an expr equal to X but certainly not valid as an lvalue.  */\n\nextern tree non_lvalue (tree);\nextern tree pedantic_non_lvalue (tree);\n\nextern tree convert (tree, tree);\nextern unsigned int expr_align (tree);\nextern tree expr_first (tree);\nextern tree expr_last (tree);\nextern int expr_length (tree);\nextern tree size_in_bytes (tree);\nextern HOST_WIDE_INT int_size_in_bytes (tree);\nextern tree bit_position (tree);\nextern HOST_WIDE_INT int_bit_position (tree);\nextern tree byte_position (tree);\nextern HOST_WIDE_INT int_byte_position (tree);\n\n/* Define data structures, macros, and functions for handling sizes\n   and the various types used to represent sizes.  */\n\nenum size_type_kind\n{\n  SIZETYPE,\t\t/* Normal representation of sizes in bytes.  */\n  SSIZETYPE,\t\t/* Signed representation of sizes in bytes.  */\n  USIZETYPE,\t\t/* Unsigned representation of sizes in bytes.  */\n  BITSIZETYPE,\t\t/* Normal representation of sizes in bits.  */\n  SBITSIZETYPE,\t\t/* Signed representation of sizes in bits.  */\n  UBITSIZETYPE,\t        /* Unsigned representation of sizes in bits.  */\n  TYPE_KIND_LAST};\n\nextern GTY(()) tree sizetype_tab\u00dd(int) TYPE_KIND_LAST\u00a8;\n\n#define sizetype sizetype_tab\u00dd(int) SIZETYPE\u00a8\n#define bitsizetype sizetype_tab\u00dd(int) BITSIZETYPE\u00a8\n#define ssizetype sizetype_tab\u00dd(int) SSIZETYPE\u00a8\n#define usizetype sizetype_tab\u00dd(int) USIZETYPE\u00a8\n#define sbitsizetype sizetype_tab\u00dd(int) SBITSIZETYPE\u00a8\n#define ubitsizetype sizetype_tab\u00dd(int) UBITSIZETYPE\u00a8\n\nextern tree size_binop (enum tree_code, tree, tree);\nextern tree size_diffop (tree, tree);\nextern tree size_int_wide (HOST_WIDE_INT, enum size_type_kind);\nextern tree size_int_type_wide (HOST_WIDE_INT, tree);\n\n#define size_int_type(L, T) size_int_type_wide ((HOST_WIDE_INT) (L), T)\n#define size_int(L) size_int_wide ((HOST_WIDE_INT) (L), SIZETYPE)\n#define ssize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SSIZETYPE)\n#define bitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), BITSIZETYPE)\n#define sbitsize_int(L) size_int_wide ((HOST_WIDE_INT) (L), SBITSIZETYPE)\n\nextern tree round_up (tree, int);\nextern tree round_down (tree, int);\nextern tree get_pending_sizes (void);\nextern int is_pending_size (tree);\nextern void put_pending_size (tree);\nextern void put_pending_sizes (tree);\n\n/* Type for sizes of data-type.  */\n\n#define BITS_PER_UNIT_LOG \\\n  ((BITS_PER_UNIT > 1) + (BITS_PER_UNIT > 2) + (BITS_PER_UNIT > 4) \\\n   + (BITS_PER_UNIT > 8) + (BITS_PER_UNIT > 16) + (BITS_PER_UNIT > 32) \\\n   + (BITS_PER_UNIT > 64) + (BITS_PER_UNIT > 128) + (BITS_PER_UNIT > 256))\n\n/* If nonzero, an upper limit on alignment of structure fields, in bits.  */\nextern unsigned int maximum_field_alignment;\n\n/* If nonzero, the alignment of a bitstring or (power-)set value, in bits.  */\nextern unsigned int set_alignment;\n\n/* Concatenate two lists (chains of TREE_LIST nodes) X and Y\n   by making the last node in X point to Y.\n   Returns X, except if X is 0 returns Y.  */\n\nextern tree chainon (tree, tree);\n\n/* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n\nextern tree tree_cons (tree, tree, tree);\n\n/* Return the last tree node in a chain.  */\n\nextern tree tree_last (tree);\n\n/* Reverse the order of elements in a chain, and return the new head.  */\n\nextern tree nreverse (tree);\n\n/* Returns the length of a chain of nodes\n   (number of chain pointers to follow before reaching a null pointer).  */\n\nextern int list_length (tree);\n\n/* Returns the number of FIELD_DECLs in a type.  */\n\nextern int fields_length (tree);\n\n/* Given an initializer INIT, return TRUE if INIT is zero or some\n   aggregate of zeros.  Otherwise return FALSE.  */\n\nextern bool initializer_zerop (tree);\n\n/* Given an initializer INIT, return TRUE if INIT is at least 3/4 zeros.\n   Otherwise return FALSE.  */\n\nextern int mostly_zeros_p (tree);\n\n/* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n\nextern int integer_zerop (tree);\n\n/* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n\nextern int integer_onep (tree);\n\n/* integer_all_onesp (tree x) is nonzero if X is an integer constant\n   all of whose significant bits are 1.  */\n\nextern int integer_all_onesp (tree);\n\n/* integer_pow2p (tree x) is nonzero is X is an integer constant with\n   exactly one bit 1.  */\n\nextern int integer_pow2p (tree);\n\n/* integer_nonzerop (tree x) is nonzero if X is an integer constant\n   with a nonzero value.  */\n\nextern int integer_nonzerop (tree);\n\n/* staticp (tree x) is nonzero if X is a reference to data allocated\n   at a fixed address in memory.  */\n\nextern int staticp (tree);\n\n/* Gets an error if argument X is not an lvalue.\n   Also returns 1 if X is an lvalue, 0 if not.  */\n\nextern int lvalue_or_else (tree, const char *);\n\n/* save_expr (EXP) returns an expression equivalent to EXP\n   but it can be used multiple times within context CTX\n   and only evaluate EXP once.  */\n\nextern tree save_expr (tree);\n\n/* Look inside EXPR and into any simple arithmetic operations.  Return\n   the innermost non-arithmetic node.  */\n\nextern tree skip_simple_arithmetic (tree);\n\n/* Return TRUE if EXPR is a SAVE_EXPR or wraps simple arithmetic around a\n   SAVE_EXPR.  Return FALSE otherwise.  */\n\nextern bool saved_expr_p (tree);\n\n/* Returns the index of the first non-tree operand for CODE, or the number\n   of operands if all are trees.  */\n\nextern int first_rtl_op (enum tree_code);\n\n/* Return which tree structure is used by T.  */\n\nenum tree_node_structure_enum tree_node_structure (tree);\n\n/* unsave_expr (EXP) returns an expression equivalent to EXP but it\n   can be used multiple times and will evaluate EXP in its entirety\n   each time.  */\n\nextern tree unsave_expr (tree);\n\n/* Reset EXP in place so that it can be expanded again.  Does not\n   recurse into subtrees.  */\n\nextern void unsave_expr_1 (tree);\n\n/* Return 0 if it is safe to evaluate EXPR multiple times,\n   return 1 if it is safe if EXPR is unsaved afterward, or\n   return 2 if it is completely unsafe.  */\nextern int unsafe_for_reeval (tree);\n\n/* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n   or offset that depends on a field within a record.\n\n   Note that we only allow such expressions within simple arithmetic\n   or a COND_EXPR.  */\n\nextern bool contains_placeholder_p (tree);\n\n/* This macro calls the above function but short-circuits the common\n   case of a constant to save time.  Also check for null.  */\n\n#define CONTAINS_PLACEHOLDER_P(EXP) \\\n  ((EXP) != 0 && ! TREE_CONSTANT (EXP) && contains_placeholder_p (EXP))\n\n/* Return 1 if any part of the computation of TYPE involves a PLACEHOLDER_EXPR.\n   This includes size, bounds, qualifiers (for QUAL_UNION_TYPE) and field\n   positions.  */\n\nextern bool type_contains_placeholder_p (tree);\n\n/* Return 1 if EXP contains any expressions that produce cleanups for an\n   outer scope to deal with.  Used by fold.  */\n\nextern int has_cleanups (tree);\n\n/* Given a tree EXP, a FIELD_DECL F, and a replacement value R,\n   return a tree with all occurrences of references to F in a\n   PLACEHOLDER_EXPR replaced by R.   Note that we assume here that EXP\n   contains only arithmetic expressions.  */\n\nextern tree substitute_in_expr (tree, tree, tree);\n\n/* variable_size (EXP) is like save_expr (EXP) except that it\n   is for the special case of something that is part of a\n   variable size for a data type.  It makes special arrangements\n   to compute the value at the right time when the data type\n   belongs to a function parameter.  */\n\nextern tree variable_size (tree);\n\n/* stabilize_reference (EXP) returns a reference equivalent to EXP\n   but it can be used multiple times\n   and only evaluate the subexpressions once.  */\n\nextern tree stabilize_reference (tree);\n\n/* Subroutine of stabilize_reference; this is called for subtrees of\n   references.  Any expression with side-effects must be put in a SAVE_EXPR\n   to ensure that it is only evaluated once.  */\n\nextern tree stabilize_reference_1 (tree);\n\n/* Return EXP, stripped of any conversions to wider types\n   in such a way that the result of converting to type FOR_TYPE\n   is the same as if EXP were converted to FOR_TYPE.\n   If FOR_TYPE is 0, it signifies EXP's type.  */\n\nextern tree get_unwidened (tree, tree);\n\n/* Return OP or a simpler expression for a narrower value\n   which can be sign-extended or zero-extended to give back OP.\n   Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n   or 0 if the value should be sign-extended.  */\n\nextern tree get_narrower (tree, int *);\n\n/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n   look for nested component-refs or array-refs at constant positions\n   and find the ultimate containing object, which is returned.  */\n\nextern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n\t\t\t\t tree *, enum machine_mode *, int *, int *);\n\n/* Return 1 if T is an expression that get_inner_reference handles.  */\n\nextern int handled_component_p (tree);\n\n/* Given a DECL or TYPE, return the scope in which it was declared, or\n   NUL_TREE if there is no containing scope.  */\n\nextern tree get_containing_scope (tree);\n\n/* Return the FUNCTION_DECL which provides this _DECL with its context,\n   or zero if none.  */\nextern tree decl_function_context (tree);\n\n/* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n   this _DECL with its context, or zero if none.  */\nextern tree decl_type_context (tree);\n\n/* Given the FUNCTION_DECL for the current function,\n   return zero if it is ok for this function to be inline.\n   Otherwise return a warning message with a single %s\n   for the function's name.  */\n\nextern const char *function_cannot_inline_p (tree);\n\n/* Return 1 if EXPR is the real constant zero.  */\nextern int real_zerop (tree);\n\n/* Declare commonly used variables for tree structure.  */\n\n/* Nonzero means lvalues are limited to those valid in pedantic ANSI C.\n   Zero means allow extended lvalues.  */\n\nextern int pedantic_lvalues;\n\n/* Nonzero means can safely call expand_expr now;\n   otherwise layout_type puts variable sizes onto `pending_sizes' instead.  */\n\nextern int immediate_size_expand;\n\n/* Points to the FUNCTION_DECL of the function whose body we are reading.  */\n\nextern GTY(()) tree current_function_decl;\n\n/* Nonzero means a FUNC_BEGIN label was emitted.  */\nextern GTY(()) tree current_function_func_begin_label;\n\n/* Nonzero means all ..._TYPE nodes should be allocated permanently.  */\n\nextern int all_types_permanent;\n\n/* Exit a binding level.  This function is provided by each language\n   frontend.  */\nextern tree poplevel (int, int, int);\n\n/* Declare a predefined function.  Return the declaration.  This function is\n   provided by each language frontend.  */\nextern tree builtin_function (const char *, tree, int, enum built_in_class,\n\t\t\t      const char *, tree);\n\n/* In tree.c */\nextern unsigned crc32_string (unsigned, const char *);\nextern void clean_symbol_name (char *);\nextern tree get_file_function_name_long (const char *);\nextern tree get_set_constructor_bits (tree, char *, int);\nextern tree get_set_constructor_bytes (tree, unsigned char *, int);\nextern tree get_callee_fndecl (tree);\nextern void change_decl_assembler_name (tree, tree);\nextern int type_num_arguments (tree);\nextern tree lhd_unsave_expr_now (tree);\n\n\n/* In stmt.c */\n\nextern void expand_fixups (rtx);\nextern tree expand_start_stmt_expr (int);\nextern tree expand_end_stmt_expr (tree);\nextern void expand_expr_stmt (tree);\nextern void expand_expr_stmt_value (tree, int, int);\nextern int warn_if_unused_value (tree);\nextern void expand_decl_init (tree);\nextern void clear_last_expr (void);\nextern void expand_label (tree);\nextern void expand_goto (tree);\nextern void expand_asm (tree, int);\nextern void expand_start_cond (tree, int);\nextern void expand_end_cond (void);\nextern void expand_start_else (void);\nextern void expand_start_elseif (tree);\nextern struct nesting *expand_start_loop (int);\nextern struct nesting *expand_start_loop_continue_elsewhere (int);\nextern struct nesting *expand_start_null_loop (void);\nextern void expand_loop_continue_here (void);\nextern void expand_end_loop (void);\nextern void expand_end_null_loop (void);\nextern int expand_continue_loop (struct nesting *);\nextern int expand_exit_loop (struct nesting *);\nextern int expand_exit_loop_if_false (struct nesting *,tree);\nextern int expand_exit_loop_top_cond (struct nesting *, tree);\nextern int expand_exit_something (void);\n\nextern void expand_return (tree);\nextern int optimize_tail_recursion (tree, rtx);\nextern void expand_start_bindings_and_block (int, tree);\n#define expand_start_bindings(flags) \\\n  expand_start_bindings_and_block(flags, NULL_TREE)\nextern void expand_end_bindings (tree, int, int);\nextern void warn_about_unused_variables (tree);\nextern void start_cleanup_deferral (void);\nextern void end_cleanup_deferral (void);\nextern int is_body_block (tree);\n\nextern int conditional_context (void);\nextern struct nesting * current_nesting_level (void);\nextern tree last_cleanup_this_contour (void);\nextern void expand_start_case (int, tree, tree, const char *);\nextern void expand_end_case_type (tree, tree);\n#define expand_end_case(cond) expand_end_case_type (cond, NULL)\nextern int add_case_node (tree, tree, tree, tree *);\nextern int pushcase (tree, tree (*) (tree, tree), tree, tree *);\nextern int pushcase_range (tree, tree, tree (*) (tree, tree), tree, tree *);\nextern void using_eh_for_cleanups (void);\n\n/* In fold-const.c */\n\n/* Fold constants as much as possible in an expression.\n   Returns the simplified expression.\n   Acts only on the top level of the expression;\n   if the argument itself cannot be simplified, its\n   subexpressions are not changed.  */\n\nextern tree fold (tree);\nextern tree fold_initializer (tree);\nextern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n\nextern int force_fit_type (tree, int);\nextern int add_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\nextern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\nextern int mul_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\nextern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t   HOST_WIDE_INT, unsigned int,\n\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\nextern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t   HOST_WIDE_INT, unsigned int,\n\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\nextern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t    HOST_WIDE_INT, unsigned int,\n\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\nextern void rrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n\t\t\t    HOST_WIDE_INT, unsigned int,\n\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n\nextern int div_and_round_double (enum tree_code, int, unsigned HOST_WIDE_INT,\n\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n\t\t\t\t HOST_WIDE_INT *);\n\nextern int operand_equal_p (tree, tree, int);\nextern tree omit_one_operand (tree, tree, tree);\nextern tree invert_truthvalue (tree);\n\n/* In builtins.c */\nextern tree fold_builtin (tree);\nextern enum built_in_function builtin_mathfn_code (tree);\nextern tree build_function_call_expr (tree, tree);\nextern tree mathfn_built_in (tree, enum built_in_function fn);\n\n/* In convert.c */\nextern tree strip_float_extensions (tree);\n\n/* In alias.c */\nextern void record_component_aliases (tree);\nextern HOST_WIDE_INT get_alias_set (tree);\nextern int alias_sets_conflict_p (HOST_WIDE_INT, HOST_WIDE_INT);\nextern int readonly_fields_p (tree);\nextern int objects_must_conflict_p (tree, tree);\n\n/* In tree.c */\nextern int really_constant_p (tree);\nextern int int_fits_type_p (tree, tree);\nextern bool variably_modified_type_p (tree);\nextern int tree_log2 (tree);\nextern int tree_floor_log2 (tree);\nextern int simple_cst_equal (tree, tree);\nextern unsigned int iterative_hash_expr (tree, unsigned int);\nextern int compare_tree_int (tree, unsigned HOST_WIDE_INT);\nextern int type_list_equal (tree, tree);\nextern int chain_member (tree, tree);\nextern tree type_hash_lookup (unsigned int, tree);\nextern void type_hash_add (unsigned int, tree);\nextern unsigned int type_hash_list (tree);\nextern int simple_cst_list_equal (tree, tree);\nextern void dump_tree_statistics (void);\nextern void expand_function_end (void);\nextern void expand_function_start (tree, int);\nextern void expand_pending_sizes (tree);\nextern tree make_vector (enum machine_mode, tree, int);\nextern tree reconstruct_complex_type (tree, tree);\n\nextern int real_onep (tree);\nextern int real_twop (tree);\nextern int real_minus_onep (tree);\nextern void init_ttree (void);\nextern void build_common_tree_nodes (int);\nextern void build_common_tree_nodes_2 (int);\nextern tree build_range_type (tree, tree, tree);\n\n/* In function.c */\nextern void setjmp_protect_args (void);\nextern void setjmp_protect (tree);\nextern void expand_main_function (void);\nextern void init_dummy_function_start (void);\nextern void expand_dummy_function_end (void);\nextern void init_function_for_compilation (void);\nextern void allocate_struct_function (tree);\nextern void init_function_start (tree);\nextern void assign_parms (tree);\nextern void put_var_into_stack (tree, int);\nextern void flush_addressof (tree);\nextern void uninitialized_vars_warning (tree);\nextern void setjmp_args_warning (void);\nextern void mark_all_temps_used (void);\nextern void init_temp_slots (void);\nextern void combine_temp_slots (void);\nextern void free_temp_slots (void);\nextern void pop_temp_slots (void);\nextern void push_temp_slots (void);\nextern void preserve_temp_slots (rtx);\nextern void preserve_rtl_expr_temps (tree);\nextern int aggregate_value_p (tree, tree);\nextern void free_temps_for_rtl_expr (tree);\nextern void instantiate_virtual_regs (tree, rtx);\nextern void unshare_all_rtl (tree, rtx);\nextern void push_function_context (void);\nextern void pop_function_context (void);\nextern void push_function_context_to (tree);\nextern void pop_function_context_from (tree);\n\n/* In print-rtl.c */\n#ifdef BUFSIZ\nextern void print_rtl (FILE *, rtx);\n#endif\n\n/* In print-tree.c */\nextern void debug_tree (tree);\n#ifdef BUFSIZ\nextern void print_node (FILE *, const char *, tree, int);\nextern void print_node_brief (FILE *, const char *, tree, int);\nextern void indent_to (FILE *, int);\n#endif\n\n/* In expr.c */\nextern int apply_args_register_offset (int);\nextern rtx expand_builtin_return_addr (enum built_in_function, int, rtx);\nextern void check_max_integer_computation_mode (tree);\n\n/* In emit-rtl.c */\nextern void start_sequence_for_rtl_expr (tree);\nextern rtx emit_line_note (location_t);\n\n/* In calls.c */\n\n/* Nonzero if this is a call to a `const' function.  */\n#define ECF_CONST\t\t1\n/* Nonzero if this is a call to a `volatile' function.  */\n#define ECF_NORETURN\t\t2\n/* Nonzero if this is a call to malloc or a related function.  */\n#define ECF_MALLOC\t\t4\n/* Nonzero if it is plausible that this is a call to alloca.  */\n#define ECF_MAY_BE_ALLOCA\t8\n/* Nonzero if this is a call to a function that won't throw an exception.  */\n#define ECF_NOTHROW\t\t16\n/* Nonzero if this is a call to setjmp or a related function.  */\n#define ECF_RETURNS_TWICE\t32\n/* Nonzero if this is a call to `longjmp'.  */\n#define ECF_LONGJMP\t\t64\n/* Nonzero if this is a syscall that makes a new process in the image of\n   the current one.  */\n#define ECF_FORK_OR_EXEC\t128\n#define ECF_SIBCALL\t\t256\n/* Nonzero if this is a call to \"pure\" function (like const function,\n   but may read memory.  */\n#define ECF_PURE\t\t512\n/* Nonzero if this is a call to a function that returns with the stack\n   pointer depressed.  */\n#define ECF_SP_DEPRESSED\t1024\n/* Nonzero if this call is known to always return.  */\n#define ECF_ALWAYS_RETURN\t2048\n/* Create libcall block around the call.  */\n#define ECF_LIBCALL_BLOCK\t4096\n\nextern int flags_from_decl_or_type (tree);\nextern int call_expr_flags (tree);\n\nextern int setjmp_call_p (tree);\nextern bool alloca_call_p (tree);\n\n/* In attribs.c.  */\n\n/* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n   which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n   it should be modified in place; if a TYPE, a copy should be created\n   unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further\n   information, in the form of a bitwise OR of flags in enum attribute_flags\n   from tree.h.  Depending on these flags, some attributes may be\n   returned to be applied at a later stage (for example, to apply\n   a decl attribute to the declaration rather than to its type).  */\nextern tree decl_attributes (tree *, tree, int);\n\n/* In integrate.c */\nextern void save_for_inline (tree);\nextern void set_decl_abstract_flags (tree, int);\nextern void output_inline_function (tree);\nextern void set_decl_origin_self (tree);\n\n/* In stor-layout.c */\nextern void set_min_and_max_values_for_integral_type (tree, int, bool);\nextern void fixup_signed_type (tree);\nextern void internal_reference_types (void);\n\n/* varasm.c */\nextern void make_decl_rtl (tree, const char *);\nextern void make_decl_one_only (tree);\nextern int supports_one_only (void);\nextern void variable_section (tree, int);\nenum tls_model decl_tls_model (tree);\nextern void resolve_unique_section (tree, int, int);\nextern void mark_referenced (tree);\nextern void notice_global_symbol (tree);\nextern void process_pending_assemble_output_defs (void);\n\n/* In stmt.c */\nextern void emit_nop (void);\nextern void expand_computed_goto (tree);\nextern bool parse_output_constraint (const char **, int, int, int,\n\t\t\t\t     bool *, bool *, bool *);\nextern bool parse_input_constraint (const char **, int, int, int, int,\n\t\t\t\t    const char * const *, bool *, bool *);\nextern void expand_asm_operands (tree, tree, tree, tree, int, location_t);\nextern tree resolve_asm_operand_names (tree, tree, tree);\nextern int any_pending_cleanups (void);\nextern void init_stmt_for_function (void);\nextern void expand_start_target_temps (void);\nextern void expand_end_target_temps (void);\nextern void expand_elseif (tree);\nextern void save_stack_pointer (void);\nextern void expand_decl (tree);\nextern int expand_decl_cleanup (tree, tree);\nextern int expand_decl_cleanup_eh (tree, tree, int);\nextern void expand_anon_union_decl (tree, tree, tree);\nextern void expand_start_case_dummy (void);\nextern HOST_WIDE_INT all_cases_count (tree, int *);\nextern void check_for_full_enumeration_handling (tree);\nextern void declare_nonlocal_label (tree);\n\n/* If KIND=='I', return a suitable global initializer (constructor) name.\n   If KIND=='D', return a suitable global clean-up (destructor) name.  */\nextern tree get_file_function_name (int);\n\n/* Interface of the DWARF2 unwind info support.  */\n\n/* Generate a new label for the CFI info to refer to.  */\n\nextern char *dwarf2out_cfi_label (void);\n\n/* Entry point to update the canonical frame address (CFA).  */\n\nextern void dwarf2out_def_cfa (const char *, unsigned, HOST_WIDE_INT);\n\n/* Add the CFI for saving a register window.  */\n\nextern void dwarf2out_window_save (const char *);\n\n/* Add a CFI to update the running total of the size of arguments pushed\n   onto the stack.  */\n\nextern void dwarf2out_args_size (const char *, HOST_WIDE_INT);\n\n/* Entry point for saving a register to the stack.  */\n\nextern void dwarf2out_reg_save (const char *, unsigned, HOST_WIDE_INT);\n\n/* Entry point for saving the return address in the stack.  */\n\nextern void dwarf2out_return_save (const char *, HOST_WIDE_INT);\n\n/* Entry point for saving the return address in a register.  */\n\nextern void dwarf2out_return_reg (const char *, unsigned);\n\n/* The type of a function that walks over tree structure.  */\n\ntypedef tree (*walk_tree_fn) (tree *, int *, void *);\n\n/* In tree-dump.c */\n\n/* Different tree dump places.  When you add new tree dump places,\n   extend the DUMP_FILES array in tree-dump.c */\nenum tree_dump_index\n{\n  TDI_all,\t\t\t/* dump the whole translation unit */\n  TDI_class,\t\t\t/* dump class hierarchy */\n  TDI_original,\t\t\t/* dump each function before optimizing it */\n  TDI_optimized,\t\t/* dump each function after optimizing it */\n  TDI_inlined,\t\t\t/* dump each function after inlining\n\t\t\t\t   within it.  */\n  TDI_end\n};\n\n/* Bit masks to control tree dumping. Not all values are applicable to\n   all tree dumps. Add new ones at the end. When you define new\n   values, extend the DUMP_OPTIONS array in tree-dump.c */\n#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n\ntypedef struct dump_info *dump_info_p;\n\nextern int dump_flag (dump_info_p, int, tree);\nextern int dump_enabled_p (enum tree_dump_index);\nextern FILE *dump_begin (enum tree_dump_index, int *);\nextern void dump_end (enum tree_dump_index, FILE *);\nextern void dump_node (tree, int, FILE *);\nextern int dump_switch_p (const char *);\nextern const char *dump_flag_name (enum tree_dump_index);\n/* Assign the RTX to declaration.  */\n\nextern void set_decl_rtl (tree, rtx);\n\n/* Redefine abort to report an internal error w/o coredump, and\n   reporting the location of the error in the source file.  This logic\n   is duplicated in rtl.h and tree.h because every file that needs the\n   special abort includes one or both.  toplev.h gets too few files,\n   system.h gets too many.  */\n\nextern void fancy_abort (const char *, int, const char *)\n    ATTRIBUTE_NORETURN;\n#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n\n/* Enum and arrays used for tree allocation stats.\n   Keep in sync with tree.c:tree_node_kind_names.  */\ntypedef enum\n{\n  d_kind,\n  t_kind,\n  b_kind,\n  s_kind,\n  r_kind,\n  e_kind,\n  c_kind,\n  id_kind,\n  perm_list_kind,\n  temp_list_kind,\n  vec_kind,\n  x_kind,\n  lang_decl,\n  lang_type,\n  all_kinds\n} tree_node_kind;\n\nextern int tree_node_counts\u00dd\u00a8;\nextern int tree_node_sizes\u00dd\u00a8;\n\n#endif  /* GCC_TREE_H  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE@CHE": {"ttr": 11782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file is generated using gencheck. Do not edit. */\n\n#ifndef GCC_TREE_CHECK_H\n#define GCC_TREE_CHECK_H\n\n#define ERROR_MARK_CHECK(t)\tTREE_CHECK (t, ERROR_MARK)\n#define IDENTIFIER_NODE_CHECK(t)\tTREE_CHECK (t, IDENTIFIER_NODE)\n#define TREE_LIST_CHECK(t)\tTREE_CHECK (t, TREE_LIST)\n#define TREE_VEC_CHECK(t)\tTREE_CHECK (t, TREE_VEC)\n#define BLOCK_CHECK(t)\tTREE_CHECK (t, BLOCK)\n#define VOID_TYPE_CHECK(t)\tTREE_CHECK (t, VOID_TYPE)\n#define INTEGER_TYPE_CHECK(t)\tTREE_CHECK (t, INTEGER_TYPE)\n#define REAL_TYPE_CHECK(t)\tTREE_CHECK (t, REAL_TYPE)\n#define COMPLEX_TYPE_CHECK(t)\tTREE_CHECK (t, COMPLEX_TYPE)\n#define VECTOR_TYPE_CHECK(t)\tTREE_CHECK (t, VECTOR_TYPE)\n#define ENUMERAL_TYPE_CHECK(t)\tTREE_CHECK (t, ENUMERAL_TYPE)\n#define BOOLEAN_TYPE_CHECK(t)\tTREE_CHECK (t, BOOLEAN_TYPE)\n#define CHAR_TYPE_CHECK(t)\tTREE_CHECK (t, CHAR_TYPE)\n#define POINTER_TYPE_CHECK(t)\tTREE_CHECK (t, POINTER_TYPE)\n#define OFFSET_TYPE_CHECK(t)\tTREE_CHECK (t, OFFSET_TYPE)\n#define REFERENCE_TYPE_CHECK(t)\tTREE_CHECK (t, REFERENCE_TYPE)\n#define METHOD_TYPE_CHECK(t)\tTREE_CHECK (t, METHOD_TYPE)\n#define FILE_TYPE_CHECK(t)\tTREE_CHECK (t, FILE_TYPE)\n#define ARRAY_TYPE_CHECK(t)\tTREE_CHECK (t, ARRAY_TYPE)\n#define SET_TYPE_CHECK(t)\tTREE_CHECK (t, SET_TYPE)\n#define RECORD_TYPE_CHECK(t)\tTREE_CHECK (t, RECORD_TYPE)\n#define UNION_TYPE_CHECK(t)\tTREE_CHECK (t, UNION_TYPE)\n#define QUAL_UNION_TYPE_CHECK(t)\tTREE_CHECK (t, QUAL_UNION_TYPE)\n#define FUNCTION_TYPE_CHECK(t)\tTREE_CHECK (t, FUNCTION_TYPE)\n#define LANG_TYPE_CHECK(t)\tTREE_CHECK (t, LANG_TYPE)\n#define INTEGER_CST_CHECK(t)\tTREE_CHECK (t, INTEGER_CST)\n#define REAL_CST_CHECK(t)\tTREE_CHECK (t, REAL_CST)\n#define COMPLEX_CST_CHECK(t)\tTREE_CHECK (t, COMPLEX_CST)\n#define VECTOR_CST_CHECK(t)\tTREE_CHECK (t, VECTOR_CST)\n#define STRING_CST_CHECK(t)\tTREE_CHECK (t, STRING_CST)\n#define FUNCTION_DECL_CHECK(t)\tTREE_CHECK (t, FUNCTION_DECL)\n#define LABEL_DECL_CHECK(t)\tTREE_CHECK (t, LABEL_DECL)\n#define CONST_DECL_CHECK(t)\tTREE_CHECK (t, CONST_DECL)\n#define TYPE_DECL_CHECK(t)\tTREE_CHECK (t, TYPE_DECL)\n#define VAR_DECL_CHECK(t)\tTREE_CHECK (t, VAR_DECL)\n#define PARM_DECL_CHECK(t)\tTREE_CHECK (t, PARM_DECL)\n#define RESULT_DECL_CHECK(t)\tTREE_CHECK (t, RESULT_DECL)\n#define FIELD_DECL_CHECK(t)\tTREE_CHECK (t, FIELD_DECL)\n#define NAMESPACE_DECL_CHECK(t)\tTREE_CHECK (t, NAMESPACE_DECL)\n#define TRANSLATION_UNIT_DECL_CHECK(t)\tTREE_CHECK (t, TRANSLATION_UNIT_DECL)\n#define COMPONENT_REF_CHECK(t)\tTREE_CHECK (t, COMPONENT_REF)\n#define BIT_FIELD_REF_CHECK(t)\tTREE_CHECK (t, BIT_FIELD_REF)\n#define INDIRECT_REF_CHECK(t)\tTREE_CHECK (t, INDIRECT_REF)\n#define BUFFER_REF_CHECK(t)\tTREE_CHECK (t, BUFFER_REF)\n#define ARRAY_REF_CHECK(t)\tTREE_CHECK (t, ARRAY_REF)\n#define ARRAY_RANGE_REF_CHECK(t)\tTREE_CHECK (t, ARRAY_RANGE_REF)\n#define VTABLE_REF_CHECK(t)\tTREE_CHECK (t, VTABLE_REF)\n#define CONSTRUCTOR_CHECK(t)\tTREE_CHECK (t, CONSTRUCTOR)\n#define COMPOUND_EXPR_CHECK(t)\tTREE_CHECK (t, COMPOUND_EXPR)\n#define MODIFY_EXPR_CHECK(t)\tTREE_CHECK (t, MODIFY_EXPR)\n#define INIT_EXPR_CHECK(t)\tTREE_CHECK (t, INIT_EXPR)\n#define TARGET_EXPR_CHECK(t)\tTREE_CHECK (t, TARGET_EXPR)\n#define COND_EXPR_CHECK(t)\tTREE_CHECK (t, COND_EXPR)\n#define BIND_EXPR_CHECK(t)\tTREE_CHECK (t, BIND_EXPR)\n#define CALL_EXPR_CHECK(t)\tTREE_CHECK (t, CALL_EXPR)\n#define WITH_CLEANUP_EXPR_CHECK(t)\tTREE_CHECK (t, WITH_CLEANUP_EXPR)\n#define CLEANUP_POINT_EXPR_CHECK(t)\tTREE_CHECK (t, CLEANUP_POINT_EXPR)\n#define PLACEHOLDER_EXPR_CHECK(t)\tTREE_CHECK (t, PLACEHOLDER_EXPR)\n#define WITH_RECORD_EXPR_CHECK(t)\tTREE_CHECK (t, WITH_RECORD_EXPR)\n#define PLUS_EXPR_CHECK(t)\tTREE_CHECK (t, PLUS_EXPR)\n#define MINUS_EXPR_CHECK(t)\tTREE_CHECK (t, MINUS_EXPR)\n#define MULT_EXPR_CHECK(t)\tTREE_CHECK (t, MULT_EXPR)\n#define TRUNC_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, TRUNC_DIV_EXPR)\n#define CEIL_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, CEIL_DIV_EXPR)\n#define FLOOR_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, FLOOR_DIV_EXPR)\n#define ROUND_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, ROUND_DIV_EXPR)\n#define TRUNC_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, TRUNC_MOD_EXPR)\n#define CEIL_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, CEIL_MOD_EXPR)\n#define FLOOR_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, FLOOR_MOD_EXPR)\n#define ROUND_MOD_EXPR_CHECK(t)\tTREE_CHECK (t, ROUND_MOD_EXPR)\n#define RDIV_EXPR_CHECK(t)\tTREE_CHECK (t, RDIV_EXPR)\n#define EXACT_DIV_EXPR_CHECK(t)\tTREE_CHECK (t, EXACT_DIV_EXPR)\n#define FIX_TRUNC_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_TRUNC_EXPR)\n#define FIX_CEIL_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_CEIL_EXPR)\n#define FIX_FLOOR_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_FLOOR_EXPR)\n#define FIX_ROUND_EXPR_CHECK(t)\tTREE_CHECK (t, FIX_ROUND_EXPR)\n#define FLOAT_EXPR_CHECK(t)\tTREE_CHECK (t, FLOAT_EXPR)\n#define NEGATE_EXPR_CHECK(t)\tTREE_CHECK (t, NEGATE_EXPR)\n#define MIN_EXPR_CHECK(t)\tTREE_CHECK (t, MIN_EXPR)\n#define MAX_EXPR_CHECK(t)\tTREE_CHECK (t, MAX_EXPR)\n#define ABS_EXPR_CHECK(t)\tTREE_CHECK (t, ABS_EXPR)\n#define LSHIFT_EXPR_CHECK(t)\tTREE_CHECK (t, LSHIFT_EXPR)\n#define RSHIFT_EXPR_CHECK(t)\tTREE_CHECK (t, RSHIFT_EXPR)\n#define LROTATE_EXPR_CHECK(t)\tTREE_CHECK (t, LROTATE_EXPR)\n#define RROTATE_EXPR_CHECK(t)\tTREE_CHECK (t, RROTATE_EXPR)\n#define BIT_IOR_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_IOR_EXPR)\n#define BIT_XOR_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_XOR_EXPR)\n#define BIT_AND_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_AND_EXPR)\n#define BIT_NOT_EXPR_CHECK(t)\tTREE_CHECK (t, BIT_NOT_EXPR)\n#define TRUTH_ANDIF_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_ANDIF_EXPR)\n#define TRUTH_ORIF_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_ORIF_EXPR)\n#define TRUTH_AND_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_AND_EXPR)\n#define TRUTH_OR_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_OR_EXPR)\n#define TRUTH_XOR_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_XOR_EXPR)\n#define TRUTH_NOT_EXPR_CHECK(t)\tTREE_CHECK (t, TRUTH_NOT_EXPR)\n#define LT_EXPR_CHECK(t)\tTREE_CHECK (t, LT_EXPR)\n#define LE_EXPR_CHECK(t)\tTREE_CHECK (t, LE_EXPR)\n#define GT_EXPR_CHECK(t)\tTREE_CHECK (t, GT_EXPR)\n#define GE_EXPR_CHECK(t)\tTREE_CHECK (t, GE_EXPR)\n#define EQ_EXPR_CHECK(t)\tTREE_CHECK (t, EQ_EXPR)\n#define NE_EXPR_CHECK(t)\tTREE_CHECK (t, NE_EXPR)\n#define UNORDERED_EXPR_CHECK(t)\tTREE_CHECK (t, UNORDERED_EXPR)\n#define ORDERED_EXPR_CHECK(t)\tTREE_CHECK (t, ORDERED_EXPR)\n#define UNLT_EXPR_CHECK(t)\tTREE_CHECK (t, UNLT_EXPR)\n#define UNLE_EXPR_CHECK(t)\tTREE_CHECK (t, UNLE_EXPR)\n#define UNGT_EXPR_CHECK(t)\tTREE_CHECK (t, UNGT_EXPR)\n#define UNGE_EXPR_CHECK(t)\tTREE_CHECK (t, UNGE_EXPR)\n#define UNEQ_EXPR_CHECK(t)\tTREE_CHECK (t, UNEQ_EXPR)\n#define IN_EXPR_CHECK(t)\tTREE_CHECK (t, IN_EXPR)\n#define SET_LE_EXPR_CHECK(t)\tTREE_CHECK (t, SET_LE_EXPR)\n#define CARD_EXPR_CHECK(t)\tTREE_CHECK (t, CARD_EXPR)\n#define RANGE_EXPR_CHECK(t)\tTREE_CHECK (t, RANGE_EXPR)\n#define CONVERT_EXPR_CHECK(t)\tTREE_CHECK (t, CONVERT_EXPR)\n#define NOP_EXPR_CHECK(t)\tTREE_CHECK (t, NOP_EXPR)\n#define NON_LVALUE_EXPR_CHECK(t)\tTREE_CHECK (t, NON_LVALUE_EXPR)\n#define VIEW_CONVERT_EXPR_CHECK(t)\tTREE_CHECK (t, VIEW_CONVERT_EXPR)\n#define SAVE_EXPR_CHECK(t)\tTREE_CHECK (t, SAVE_EXPR)\n#define UNSAVE_EXPR_CHECK(t)\tTREE_CHECK (t, UNSAVE_EXPR)\n#define RTL_EXPR_CHECK(t)\tTREE_CHECK (t, RTL_EXPR)\n#define ADDR_EXPR_CHECK(t)\tTREE_CHECK (t, ADDR_EXPR)\n#define REFERENCE_EXPR_CHECK(t)\tTREE_CHECK (t, REFERENCE_EXPR)\n#define ENTRY_VALUE_EXPR_CHECK(t)\tTREE_CHECK (t, ENTRY_VALUE_EXPR)\n#define FDESC_EXPR_CHECK(t)\tTREE_CHECK (t, FDESC_EXPR)\n#define COMPLEX_EXPR_CHECK(t)\tTREE_CHECK (t, COMPLEX_EXPR)\n#define CONJ_EXPR_CHECK(t)\tTREE_CHECK (t, CONJ_EXPR)\n#define REALPART_EXPR_CHECK(t)\tTREE_CHECK (t, REALPART_EXPR)\n#define IMAGPART_EXPR_CHECK(t)\tTREE_CHECK (t, IMAGPART_EXPR)\n#define PREDECREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, PREDECREMENT_EXPR)\n#define PREINCREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, PREINCREMENT_EXPR)\n#define POSTDECREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, POSTDECREMENT_EXPR)\n#define POSTINCREMENT_EXPR_CHECK(t)\tTREE_CHECK (t, POSTINCREMENT_EXPR)\n#define VA_ARG_EXPR_CHECK(t)\tTREE_CHECK (t, VA_ARG_EXPR)\n#define TRY_CATCH_EXPR_CHECK(t)\tTREE_CHECK (t, TRY_CATCH_EXPR)\n#define TRY_FINALLY_EXPR_CHECK(t)\tTREE_CHECK (t, TRY_FINALLY_EXPR)\n#define GOTO_SUBROUTINE_EXPR_CHECK(t)\tTREE_CHECK (t, GOTO_SUBROUTINE_EXPR)\n#define LABEL_EXPR_CHECK(t)\tTREE_CHECK (t, LABEL_EXPR)\n#define GOTO_EXPR_CHECK(t)\tTREE_CHECK (t, GOTO_EXPR)\n#define RETURN_EXPR_CHECK(t)\tTREE_CHECK (t, RETURN_EXPR)\n#define EXIT_EXPR_CHECK(t)\tTREE_CHECK (t, EXIT_EXPR)\n#define LOOP_EXPR_CHECK(t)\tTREE_CHECK (t, LOOP_EXPR)\n#define LABELED_BLOCK_EXPR_CHECK(t)\tTREE_CHECK (t, LABELED_BLOCK_EXPR)\n#define EXIT_BLOCK_EXPR_CHECK(t)\tTREE_CHECK (t, EXIT_BLOCK_EXPR)\n#define EXPR_WITH_FILE_LOCATION_CHECK(t)\tTREE_CHECK (t, EXPR_WITH_FILE_LOCATION)\n#define SWITCH_EXPR_CHECK(t)\tTREE_CHECK (t, SWITCH_EXPR)\n#define EXC_PTR_EXPR_CHECK(t)\tTREE_CHECK (t, EXC_PTR_EXPR)\n#define SIZEOF_EXPR_CHECK(t)\tTREE_CHECK (t, SIZEOF_EXPR)\n#define ARROW_EXPR_CHECK(t)\tTREE_CHECK (t, ARROW_EXPR)\n#define ALIGNOF_EXPR_CHECK(t)\tTREE_CHECK (t, ALIGNOF_EXPR)\n#define EXPR_STMT_CHECK(t)\tTREE_CHECK (t, EXPR_STMT)\n#define COMPOUND_STMT_CHECK(t)\tTREE_CHECK (t, COMPOUND_STMT)\n#define DECL_STMT_CHECK(t)\tTREE_CHECK (t, DECL_STMT)\n#define IF_STMT_CHECK(t)\tTREE_CHECK (t, IF_STMT)\n#define FOR_STMT_CHECK(t)\tTREE_CHECK (t, FOR_STMT)\n#define WHILE_STMT_CHECK(t)\tTREE_CHECK (t, WHILE_STMT)\n#define DO_STMT_CHECK(t)\tTREE_CHECK (t, DO_STMT)\n#define RETURN_STMT_CHECK(t)\tTREE_CHECK (t, RETURN_STMT)\n#define BREAK_STMT_CHECK(t)\tTREE_CHECK (t, BREAK_STMT)\n#define CONTINUE_STMT_CHECK(t)\tTREE_CHECK (t, CONTINUE_STMT)\n#define SWITCH_STMT_CHECK(t)\tTREE_CHECK (t, SWITCH_STMT)\n#define GOTO_STMT_CHECK(t)\tTREE_CHECK (t, GOTO_STMT)\n#define LABEL_STMT_CHECK(t)\tTREE_CHECK (t, LABEL_STMT)\n#define ASM_STMT_CHECK(t)\tTREE_CHECK (t, ASM_STMT)\n#define SCOPE_STMT_CHECK(t)\tTREE_CHECK (t, SCOPE_STMT)\n#define FILE_STMT_CHECK(t)\tTREE_CHECK (t, FILE_STMT)\n#define CASE_LABEL_CHECK(t)\tTREE_CHECK (t, CASE_LABEL)\n#define STMT_EXPR_CHECK(t)\tTREE_CHECK (t, STMT_EXPR)\n#define COMPOUND_LITERAL_EXPR_CHECK(t)\tTREE_CHECK (t, COMPOUND_LITERAL_EXPR)\n#define CLEANUP_STMT_CHECK(t)\tTREE_CHECK (t, CLEANUP_STMT)\n\n#endif /* GCC_TREE_CHECK_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TREE@DUM": {"ttr": 11785, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Tree-dumping functionality for intermediate representation.\n   Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n   Written by Mark Mitchell <mark@codesourcery.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_TREE_DUMP_H\n#define GCC_TREE_DUMP_H\n\n/* Flags used with queue functions.  */\n#define DUMP_NONE     0\n#define DUMP_BINFO    1\n\n/* Information about a node to be dumped.  */\n\ntypedef struct dump_node_info\n{\n  /* The index for the node.  */\n  unsigned int index;\n  /* Nonzero if the node is a binfo.  */\n  unsigned int binfo_p : 1;\n} *dump_node_info_p;\n\n/* A dump_queue is a link in the queue of things to be dumped.  */\n\ntypedef struct dump_queue\n{\n  /* The queued tree node.  */\n  splay_tree_node node;\n  /* The next node in the queue.  */\n  struct dump_queue *next;\n} *dump_queue_p;\n\n/* A dump_info gives information about how we should perform the dump\n   and about the current state of the dump.  */\n\nstruct dump_info\n{\n  /* The stream on which to dump the information.  */\n  FILE *stream;\n  /* The original node.  */\n  tree node;\n  /* User flags.  */\n  int flags;\n  /* The next unused node index.  */\n  unsigned int index;\n  /* The next column.  */\n  unsigned int column;\n  /* The first node in the queue of nodes to be written out.  */\n  dump_queue_p queue;\n  /* The last node in the queue.  */\n  dump_queue_p queue_end;\n  /* Free queue nodes.  */\n  dump_queue_p free_list;\n  /* The tree nodes which we have already written out.  The\n     keys are the addresses of the nodes; the values are the integer\n     indices we assigned them.  */\n  splay_tree nodes;\n};\n\n/* Dump the CHILD and its children.  */\n#define dump_child(field, child) \\\n  queue_and_dump_index (di, field, child, DUMP_NONE)\n\nextern void dump_pointer (dump_info_p, const char *, void *);\nextern void dump_int (dump_info_p, const char *, int);\nextern void dump_string (dump_info_p, const char *);\nextern void dump_stmt (dump_info_p, tree);\nextern void dump_next_stmt (dump_info_p, tree);\nextern void queue_and_dump_index (dump_info_p, const char *, tree, int);\nextern void queue_and_dump_type (dump_info_p, tree);\n\n#endif /* ! GCC_TREE_DUMP_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TREE@INL": {"ttr": 11787, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Tree inlining hooks and declarations.\n   Copyright 2001, 2003 Free Software Foundation, Inc.\n   Contributed by Alexandre Oliva  <aoliva@redhat.com>\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#ifndef GCC_TREE_INLINE_H\n#define GCC_TREE_INLINE_H\n\n/* Function prototypes.  */\n\nvoid optimize_inline_calls (tree);\nbool tree_inlinable_function_p (tree);\ntree walk_tree (tree*, walk_tree_fn, void*, void*);\ntree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\ntree copy_tree_r (tree*, int*, void*);\nvoid clone_body (tree, tree, void*);\nvoid remap_save_expr (tree*, void*, tree, int*);\n\n/* 0 if we should not perform inlining.\n   1 if we should expand functions calls inline at the tree level.\n   2 if we should consider *all* functions to be inline\n   candidates.  */\n\nextern int flag_inline_trees;\n\n#endif /* GCC_TREE_INLINE_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TREED": {"ttr": 12547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file contains the definitions and documentation for the\n   tree codes used in GCC.\n   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001, 2004\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n/* The third argument can be:\n   'x' for an exceptional code (fits no category).\n   't' for a type object code.\n   'b' for a lexical block.\n   'c' for codes for constants.\n   'd' for codes for declarations (also serving as variable refs).\n   'r' for codes for references to storage.\n   '<' for codes for comparison expressions.\n   '1' for codes for unary arithmetic expressions.\n   '2' for codes for binary arithmetic expressions.\n   's' for codes for \"statement\" expressions, which have side-effects,\n       but usually no interesting value.\n   'e' for codes for other kinds of expressions.  */\n\n/* For `r', `e', `<', `1', `2', and `s' nodes, which use struct\n   tree_exp, the 4th element is the number of argument slots to\n   allocate.  This determines the size of the tree node object.\n   Other nodes use different structures, and the size is determined\n   by the tree_union member structure; the 4th element should be\n   zero.  Languages that define language-specific 'x' or 'c' codes\n   must define the tree_size langhook to say how big they are.  */\n\n/* Any erroneous construct is parsed into a node of this type.\n   This type of node is accepted without complaint in all contexts\n   by later parsing activities, to avoid multiple error messages\n   for one error.\n   No fields in these nodes are used except the TREE_CODE.  */\nDEFTREECODE (ERROR_MARK, \"error_mark\", 'x', 0)\n\n/* Used to represent a name (such as, in the DECL_NAME of a decl node).\n   Internally it looks like a STRING_CST node.\n   There is only one IDENTIFIER_NODE ever made for any particular name.\n   Use `get_identifier' to get it (or create it, the first time).  */\nDEFTREECODE (IDENTIFIER_NODE, \"identifier_node\", 'x', 0)\n\n/* Has the TREE_VALUE and TREE_PURPOSE fields.  */\n/* These nodes are made into lists by chaining through the\n   TREE_CHAIN field.  The elements of the list live in the\n   TREE_VALUE fields, while TREE_PURPOSE fields are occasionally\n   used as well to get the effect of Lisp association lists.  */\nDEFTREECODE (TREE_LIST, \"tree_list\", 'x', 0)\n\n/* These nodes contain an array of tree nodes.  */\nDEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 0)\n\n/* A symbol binding block.  These are arranged in a tree,\n   where the BLOCK_SUBBLOCKS field contains a chain of subblocks\n   chained through the BLOCK_CHAIN field.\n   BLOCK_SUPERCONTEXT points to the parent block.\n     For a block which represents the outermost scope of a function, it\n     points to the FUNCTION_DECL node.\n   BLOCK_VARS points to a chain of decl nodes.\n   BLOCK_TYPE_TAGS points to a chain of types which have their own names.\n   BLOCK_CHAIN points to the next BLOCK at the same level.\n   BLOCK_ABSTRACT_ORIGIN points to the original (abstract) tree node which\n   this block is an instance of, or else is NULL to indicate that this\n   block is not an instance of anything else.  When non-NULL, the value\n   could either point to another BLOCK node or it could point to a\n   FUNCTION_DECL node (e.g. in the case of a block representing the\n   outermost scope of a particular inlining of a function).\n   BLOCK_ABSTRACT is nonzero if the block represents an abstract\n   instance of a block (i.e. one which is nested within an abstract\n   instance of an inline function).\n   TREE_ASM_WRITTEN is nonzero if the block was actually referenced\n   in the generated assembly.  */\nDEFTREECODE (BLOCK, \"block\", 'b', 0)\n\n/* Each data type is represented by a tree node whose code is one of\n   the following:  */\n/* Each node that represents a data type has a component TYPE_SIZE\n   containing a tree that is an expression for the size in bits.\n   The TYPE_MODE contains the machine mode for values of this type.\n   The TYPE_POINTER_TO field contains a type for a pointer to this type,\n     or zero if no such has been created yet.\n   The TYPE_NEXT_VARIANT field is used to chain together types\n     that are variants made by type modifiers such as \"const\" and \"volatile\".\n   The TYPE_MAIN_VARIANT field, in any member of such a chain,\n     points to the start of the chain.\n   The TYPE_NONCOPIED_PARTS field is a list specifying which parts\n     of an object of this type should *not* be copied by assignment.\n     The TREE_VALUE of each is a FIELD_DECL that should not be\n     copied.  The TREE_PURPOSE is an initial value for that field when\n     an object of this type is initialized via an INIT_EXPR.  It may\n     be NULL if no special value is required.  Even the things in this\n     list are copied if the right-hand side of an assignment is known\n     to be a complete object (rather than being, perhaps, a subobject\n     of some other object.)  The determination of what constitutes a\n     complete object is done by fixed_type_p.\n   The TYPE_NAME field contains info on the name used in the program\n     for this type (for GDB symbol table output).  It is either a\n     TYPE_DECL node, for types that are typedefs, or an IDENTIFIER_NODE\n     in the case of structs, unions or enums that are known with a tag,\n     or zero for types that have no special name.\n   The TYPE_CONTEXT for any sort of type which could have a name or\n    which could have named members (e.g. tagged types in C/C++) will\n    point to the node which represents the scope of the given type, or\n    will be NULL_TREE if the type has \"file scope\".  For most types, this\n    will point to a BLOCK node or a FUNCTION_DECL node, but it could also\n    point to a FUNCTION_TYPE node (for types whose scope is limited to the\n    formal parameter list of some function type specification) or it\n    could point to a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE node\n    (for C++ \"member\" types).\n    For non-tagged-types, TYPE_CONTEXT need not be set to anything in\n    particular, since any type which is of some type category  (e.g.\n    an array type or a function type) which cannot either have a name\n    itself or have named members doesn't really have a \"scope\" per se.\n  The TREE_CHAIN field is used as a forward-references to names for\n    ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n    see below.  */\n\nDEFTREECODE (VOID_TYPE, \"void_type\", 't', 0)\t/* The void type in C */\n\n/* Integer types in all languages, including char in C.\n   Also used for sub-ranges of other discrete types.\n   Has components TYPE_MIN_VALUE, TYPE_MAX_VALUE (expressions, inclusive)\n   and TYPE_PRECISION (number of bits used by this type).\n   In the case of a subrange type in Pascal, the TREE_TYPE\n   of this will point at the supertype (another INTEGER_TYPE,\n   or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n   Otherwise, the TREE_TYPE is zero.  */\nDEFTREECODE (INTEGER_TYPE, \"integer_type\", 't', 0)\n\n/* C's float and double.  Different floating types are distinguished\n   by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\nDEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n\n/* Complex number types.  The TREE_TYPE field is the data type\n   of the real and imaginary parts.  */\nDEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n\n/* Vector types.  The TREE_TYPE field is the data type of the vector\n   elements.  */\nDEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n\n/* C enums.  The type node looks just like an INTEGER_TYPE node.\n   The symbols for the values of the enum type are defined by\n   CONST_DECL nodes, but the type does not point to them;\n   however, the TYPE_VALUES is a list in which each element's TREE_PURPOSE\n   is a name and the TREE_VALUE is the value (an INTEGER_CST node).  */\n/* A forward reference `enum foo' when no enum named foo is defined yet\n   has zero (a null pointer) in its TYPE_SIZE.  The tag name is in\n   the TYPE_NAME field.  If the type is later defined, the normal\n   fields are filled in.\n   RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are\n   treated similarly.  */\nDEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", 't', 0)\n\n/* Pascal's boolean type (true or false are the only values);\n   no special fields needed.  */\nDEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", 't', 0)\n\n/* CHAR in Pascal; not used in C.\n   No special fields needed.  */\nDEFTREECODE (CHAR_TYPE, \"char_type\", 't', 0)\n\n/* All pointer-to-x types have code POINTER_TYPE.\n   The TREE_TYPE points to the node for the type pointed to.  */\nDEFTREECODE (POINTER_TYPE, \"pointer_type\", 't', 0)\n\n/* An offset is a pointer relative to an object.\n   The TREE_TYPE field is the type of the object at the offset.\n   The TYPE_OFFSET_BASETYPE points to the node for the type of object\n   that the offset is relative to.  */\nDEFTREECODE (OFFSET_TYPE, \"offset_type\", 't', 0)\n\n/* A reference is like a pointer except that it is coerced\n   automatically to the value it points to.  Used in C++.  */\nDEFTREECODE (REFERENCE_TYPE, \"reference_type\", 't', 0)\n\n/* METHOD_TYPE is the type of a function which takes an extra first\n   argument for \"self\", which is not present in the declared argument list.\n   The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n   is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n   includes the hidden argument for \"self\".  */\nDEFTREECODE (METHOD_TYPE, \"method_type\", 't', 0)\n\n/* Used for Pascal; details not determined right now.  */\nDEFTREECODE (FILE_TYPE, \"file_type\", 't', 0)\n\n/* Types of arrays.  Special fields:\n   TREE_TYPE\t\t  Type of an array element.\n   TYPE_DOMAIN\t\t  Type to index by.\n\t\t\t    Its range of values specifies the array length.\n The field TYPE_POINTER_TO (TREE_TYPE (array_type)) is always nonzero\n and holds the type to coerce a value of that array type to in C.\n TYPE_STRING_FLAG indicates a string (in contrast to an array of chars)\n in languages (such as Chill) that make a distinction.  */\n/* Array types in C or Pascal */\nDEFTREECODE (ARRAY_TYPE, \"array_type\", 't', 0)\n\n/* Types of sets for Pascal.  Special fields are the same as\n   in an array type.  The target type is always a boolean type.\n   Used for both bitstrings and powersets in Chill;\n   TYPE_STRING_FLAG indicates a bitstring.  */\nDEFTREECODE (SET_TYPE, \"set_type\", 't', 0)\n\n/* Struct in C, or record in Pascal.  */\n/* Special fields:\n   TYPE_FIELDS  chain of FIELD_DECLs for the fields of the struct,\n     and VAR_DECLs, TYPE_DECLs and CONST_DECLs for record-scope variables,\n     types and enumerators.\n   A few may need to be added for Pascal.  */\n/* See the comment above, before ENUMERAL_TYPE, for how\n   forward references to struct tags are handled in C.  */\nDEFTREECODE (RECORD_TYPE, \"record_type\", 't', 0)\n\n/* Union in C.  Like a struct, except that the offsets of the fields\n   will all be zero.  */\n/* See the comment above, before ENUMERAL_TYPE, for how\n   forward references to union tags are handled in C.  */\nDEFTREECODE (UNION_TYPE, \"union_type\", 't', 0)\t/* C union type */\n\n/* Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER\n   in each FIELD_DECL determine what the union contains.  The first\n   field whose DECL_QUALIFIER expression is true is deemed to occupy\n   the union.  */\nDEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", 't', 0)\n\n/* Type of functions.  Special fields:\n   TREE_TYPE\t\t    type of value returned.\n   TYPE_ARG_TYPES      list of types of arguments expected.\n\tthis list is made of TREE_LIST nodes.\n   Types of \"Procedures\" in languages where they are different from functions\n   have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\nDEFTREECODE (FUNCTION_TYPE, \"function_type\", 't', 0)\n\n/* This is a language-specific kind of type.\n   Its meaning is defined by the language front end.\n   layout_type does not know how to lay this out,\n   so the front-end must do so manually.  */\nDEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n\n/* Expressions */\n\n/* First, the constants.  */\n\n/* Contents are in TREE_INT_CST_LOW and TREE_INT_CST_HIGH fields,\n   32 bits each, giving us a 64 bit constant capability.\n   Note: constants of type char in Pascal are INTEGER_CST,\n   and so are pointer constants such as nil in Pascal or NULL in C.\n   `(int *) 1' in C also results in an INTEGER_CST.  */\nDEFTREECODE (INTEGER_CST, \"integer_cst\", 'c', 0)\n\n/* Contents are in TREE_REAL_CST field.  */\nDEFTREECODE (REAL_CST, \"real_cst\", 'c', 0)\n\n/* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n   whose contents are other constant nodes.  */\nDEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 0)\n\n/* Contents are in TREE_VECTOR_CST_ELTS field.  */\nDEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 0)\n\n/* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.  */\nDEFTREECODE (STRING_CST, \"string_cst\", 'c', 0)\n\n/* Declarations.  All references to names are represented as ..._DECL\n   nodes.  The decls in one binding context are chained through the\n   TREE_CHAIN field.  Each DECL has a DECL_NAME field which contains\n   an IDENTIFIER_NODE.  (Some decls, most often labels, may have zero\n   as the DECL_NAME).  DECL_CONTEXT points to the node representing\n   the context in which this declaration has its scope.  For\n   FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or\n   QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,\n   PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes, this\n   points to either the FUNCTION_DECL for the containing function, the\n   RECORD_TYPE or UNION_TYPE for the containing type, or NULL_TREE or\n   a TRANSLATION_UNIT_DECL if the given decl has \"file scope\".\n   DECL_ABSTRACT_ORIGIN, if non-NULL, points to the original (abstract)\n    ..._DECL node of which this decl is an (inlined or template expanded)\n    instance.\n   The TREE_TYPE field holds the data type of the object, when relevant.\n    LABEL_DECLs have no data type.  For TYPE_DECL, the TREE_TYPE field\n    contents are the type whose name is being declared.\n   The DECL_ALIGN, DECL_SIZE,\n    and DECL_MODE fields exist in decl nodes just as in type nodes.\n    They are unused in LABEL_DECL, TYPE_DECL and CONST_DECL nodes.\n\n   DECL_FIELD_BIT_OFFSET holds an integer number of bits offset for\n   the location.  DECL_VOFFSET holds an expression for a variable\n   offset; it is to be multiplied by DECL_VOFFSET_UNIT (an integer).\n   These fields are relevant only in FIELD_DECLs and PARM_DECLs.\n\n   DECL_INITIAL holds the value to initialize a variable to,\n   or the value of a constant.  For a function, it holds the body\n   (a node of type BLOCK representing the function's binding contour\n   and whose body contains the function's statements.)  For a LABEL_DECL\n   in C, it is a flag, nonzero if the label's definition has been seen.\n\n   PARM_DECLs use a special field:\n   DECL_ARG_TYPE is the type in which the argument is actually\n    passed, which may be different from its type within the function.\n\n   FUNCTION_DECLs use four special fields:\n   DECL_ARGUMENTS holds a chain of PARM_DECL nodes for the arguments.\n   DECL_RESULT holds a RESULT_DECL node for the value of a function,\n    or it is 0 for a function that returns no value.\n    (C functions returning void have zero here.)\n    The TREE_TYPE field is the type in which the result is actually\n    returned.  This is usually the same as the return type of the\n    FUNCTION_DECL, but it may be a wider integer type because of\n    promotion.\n   DECL_FUNCTION_CODE is a code number that is nonzero for\n    built-in functions.  Its value is an enum built_in_function\n    that says which built-in function it is.\n\n   DECL_SOURCE_FILE holds a filename string and DECL_SOURCE_LINE\n   holds a line number.  In some cases these can be the location of\n   a reference, if no definition has been seen.\n\n   DECL_ABSTRACT is nonzero if the decl represents an abstract instance\n   of a decl (i.e. one which is nested within an abstract instance of a\n   inline function.  */\n\nDEFTREECODE (FUNCTION_DECL, \"function_decl\", 'd', 0)\nDEFTREECODE (LABEL_DECL, \"label_decl\", 'd', 0)\nDEFTREECODE (CONST_DECL, \"const_decl\", 'd', 0)\nDEFTREECODE (TYPE_DECL, \"type_decl\", 'd', 0)\nDEFTREECODE (VAR_DECL, \"var_decl\", 'd', 0)\nDEFTREECODE (PARM_DECL, \"parm_decl\", 'd', 0)\nDEFTREECODE (RESULT_DECL, \"result_decl\", 'd', 0)\nDEFTREECODE (FIELD_DECL, \"field_decl\", 'd', 0)\n\n/* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n   _DECLs, providing a hierarchy of names.  */\nDEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", 'd', 0)\n\n/* A translation unit.  This is not technically a declaration, since it\n   can't be looked up, but it's close enough.  */\nDEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\", 'd', 0)\n\n/* References to storage.  */\n\n/* Value is structure or union component.\n   Operand 0 is the structure or union (an expression);\n   operand 1 is the field (a node of type FIELD_DECL).  */\nDEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 2)\n\n/* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n   except the position is given explicitly rather than via a FIELD_DECL.\n   Operand 0 is the structure or union expression;\n   operand 1 is a tree giving the number of bits being referenced;\n   operand 2 is a tree giving the position of the first referenced bit.\n   The field can be either a signed or unsigned field;\n   TREE_UNSIGNED says which.  */\nDEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", 'r', 3)\n\n/* C unary `*' or Pascal `\u00ac'.  One operand, an expression for a pointer.  */\nDEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n\n/* Pascal `\u00ac` on a file.  One operand, an expression for the file.  */\nDEFTREECODE (BUFFER_REF, \"buffer_ref\", 'r', 1)\n\n/* Array indexing.\n   Operand 0 is the array; operand 1 is a (single) array index.  */\nDEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n\n/* Likewise, except that the result is a range (\"slice\") of the array.  The\n   starting index of the resulting array is taken from operand 1 and the size\n   of the range is taken from the type of the expression.  */\nDEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 2)\n\n/* Vtable indexing.  Carries data useful for emitting information\n   for vtable garbage collection.\n   Operand 0: an array_ref (or equivalent expression)\n   Operand 1: the vtable base (must be a var_decl)\n   Operand 2: index into vtable (must be an integer_cst).  */\nDEFTREECODE (VTABLE_REF, \"vtable_ref\", 'r', 3)\n\n/* Constructor: return an aggregate value made from specified components.\n   In C, this is used only for structure and array initializers.\n   Also used for SET_TYPE in Chill (and potentially Pascal).\n   The operand is a list of component values made out of a chain of\n   TREE_LIST nodes.\n\n   For ARRAY_TYPE:\n   The TREE_PURPOSE of each node is the corresponding index.\n   If the TREE_PURPOSE is a RANGE_EXPR, it is a short-hand for many nodes,\n   one for each index in the range.  (If the corresponding TREE_VALUE\n   has side-effects, they are evaluated once for each element.  Wrap the\n   value in a SAVE_EXPR if you want to evaluate side effects only once.)\n\n   For RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE:\n   The TREE_PURPOSE of each node is a FIELD_DECL.\n\n   For SET_TYPE:\n   The TREE_VALUE specifies a value (index) in the set that is true.\n   If TREE_PURPOSE is non-NULL, it specifies the lower limit of a\n   range of true values.  Elements not listed are false (not in the set).  */\nDEFTREECODE (CONSTRUCTOR, \"constructor\", 'e', 1)\n\n/* The expression types are mostly straightforward, with the fourth argument\n   of DEFTREECODE saying how many operands there are.\n   Unless otherwise specified, the operands are expressions and the\n   types of all the operands and the expression must all be the same.  */\n\n/* Contains two expressions to compute, one followed by the other.\n   the first value is ignored.  The second one's value is used.  The\n   type of the first expression need not agree with the other types.  */\nDEFTREECODE (COMPOUND_EXPR, \"compound_expr\", 'e', 2)\n\n/* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\nDEFTREECODE (MODIFY_EXPR, \"modify_expr\", 'e', 2)\n\n/* Initialization expression.  Operand 0 is the variable to initialize;\n   Operand 1 is the initializer.  */\nDEFTREECODE (INIT_EXPR, \"init_expr\", 'e', 2)\n\n/* For TARGET_EXPR, operand 0 is the target of an initialization,\n   operand 1 is the initializer for the target,\n   and operand 2 is the cleanup for this node, if any.\n   and operand 3 is the saved initializer after this node has been\n   expanded once, this is so we can re-expand the tree later.  */\nDEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n\n/* Conditional expression ( ... ? ... : ...  in C).\n   Operand 0 is the condition.\n   Operand 1 is the then-value.\n   Operand 2 is the else-value.\n   Operand 0 may be of any type.\n   Operand 1 must have the same type as the entire expression, unless\n   it unconditionally throws an exception, in which case it should\n   have VOID_TYPE.  The same constraints apply to operand 2.  */\nDEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n\n/* Declare local variables, including making RTL and allocating space.\n   Operand 0 is a chain of VAR_DECL nodes for the variables.\n   Operand 1 is the body, the expression to be computed using\n   the variables.  The value of operand 1 becomes that of the BIND_EXPR.\n   Operand 2 is the BLOCK that corresponds to these bindings\n   for debugging purposes.  If this BIND_EXPR is actually expanded,\n   that sets the TREE_USED flag in the BLOCK.\n\n   The BIND_EXPR is not responsible for informing parsers\n   about these variables.  If the body is coming from the input file,\n   then the code that creates the BIND_EXPR is also responsible for\n   informing the parser of the variables.\n\n   If the BIND_EXPR is ever expanded, its TREE_USED flag is set.\n   This tells the code for debugging symbol tables not to ignore the BIND_EXPR.\n   If the BIND_EXPR should be output for debugging but will not be expanded,\n   set the TREE_USED flag by hand.\n\n   In order for the BIND_EXPR to be known at all, the code that creates it\n   must also install it as a subblock in the tree of BLOCK\n   nodes for the function.  */\nDEFTREECODE (BIND_EXPR, \"bind_expr\", 'e', 3)\n\n/* Function call.  Operand 0 is the function.\n   Operand 1 is the argument list, a list of expressions\n   made out of a chain of TREE_LIST nodes.  */\nDEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 2)\n\n/* Specify a value to compute along with its corresponding cleanup.\n   Operand 0 argument is an expression whose value needs a cleanup.\n   Operand 1 is the cleanup expression for the object.\n   Operand 2 is an RTL_EXPR which will eventually represent that value.\n     The RTL_EXPR is used in this expression, which is how the expression\n     manages to act on the proper value.\n   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n   it exists, otherwise it is the responsibility of the caller to manually\n   call expand_start_target_temps/expand_end_target_temps, as needed.\n\n   This differs from TRY_CATCH_EXPR in that operand 2 is always\n   evaluated when an exception isn't thrown when cleanups are run.  */\nDEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 3)\n\n/* Specify a cleanup point.\n   Operand 0 is an expression that may have cleanups.  If it does, those\n   cleanups are executed after the expression is expanded.\n\n   Note that if the expression is a reference to storage, it is forced out\n   of memory before the cleanups are run.  This is necessary to handle\n   cases where the cleanups modify the storage referenced; in the\n   expression 't.i', if 't' is a struct with an integer member 'i' and a\n   cleanup which modifies 'i', the value of the expression depends on\n   whether the cleanup is run before or after 't.i' is evaluated.  When\n   expand_expr is run on 't.i', it returns a MEM.  This is not good enough;\n   the value of 't.i' must be forced out of memory.\n\n   As a consequence, the operand of a CLEANUP_POINT_EXPR must not have\n   BLKmode, because it will not be forced out of memory.  */\nDEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n\n/* The following two codes are used in languages that have types where\n   some field in an object of the type contains a value that is used in\n   the computation of another field's offset or size and/or the size of\n   the type.  The positions and/or sizes of fields can vary from object\n   to object of the same type or even for one and the same object within\n   its scope.\n\n   Record types with discriminants in Ada or schema types in Pascal are\n   examples of such types.  This mechanism is also used to create \"fat\n   pointers\" for unconstrained array types in Ada; the fat pointer is a\n   structure one of whose fields is a pointer to the actual array type\n   and the other field is a pointer to a template, which is a structure\n   containing the bounds of the array.  The bounds in the type pointed\n   to by the first field in the fat pointer refer to the values in the\n   template.\n\n   When you wish to construct such a type you need \"self-references\"\n   that allow you to reference the object having this type from the\n   TYPE node, i.e. without having a variable instantiating this type.\n\n   Such a \"self-references\" is done using a PLACEHOLDER_EXPR.  This is\n   a node that will later be replaced with the object being referenced.\n   Its type is that of the object and selects which object to use from\n   a chain of references (see below).  No other slots are used in the\n   PLACEHOLDER_EXPR.\n\n   For example, if your type FOO is a RECORD_TYPE with a field BAR,\n   and you need the value of <variable>.BAR to calculate TYPE_SIZE\n   (FOO), just substitute <variable> above with a PLACEHOLDER_EXPR\n   whose TREE_TYPE is FOO.  Then construct your COMPONENT_REF with\n   the PLACEHOLDER_EXPR as the first operand (which has the correct\n   type).  Later, when the size is needed in the program, the back-end\n   will find this PLACEHOLDER_EXPR and generate code to calculate the\n   actual size at run-time.  In the following, we describe how this\n   calculation is done.\n\n   When we wish to evaluate a size or offset, we check whether it\n   contains a PLACEHOLDER_EXPR.  If it does, we construct a\n   WITH_RECORD_EXPR that contains both the expression we wish to\n   evaluate and an expression within which the object may be found.\n   The latter expression is the object itself in the simple case of an\n   Ada record with discriminant, but it can be the array in the case of\n   an unconstrained array.\n\n   In the latter case, we need the fat pointer, because the bounds of\n   the array can only be accessed from it.  However, we rely here on the\n   fact that the expression for the array contains the dereference of\n   the fat pointer that obtained the array pointer.\n\n   Accordingly, when looking for the object to substitute in place of\n   a PLACEHOLDER_EXPR, we look down the first operand of the expression\n   passed as the second operand to WITH_RECORD_EXPR until we find\n   something of the desired type or reach a constant.  */\n\n/* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n   evaluating this expression.  The type of this expression is used to\n   find the record to replace it.  */\nDEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", 'x', 0)\n\n/* Provide an expression that references a record to be used in place\n   of a PLACEHOLDER_EXPR.  The record to be used is the record within\n   operand 1 that has the same type as the PLACEHOLDER_EXPR in\n   operand 0.  */\nDEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", 'e', 2)\n\n/* Simple arithmetic.  */\nDEFTREECODE (PLUS_EXPR, \"plus_expr\", '2', 2)\nDEFTREECODE (MINUS_EXPR, \"minus_expr\", '2', 2)\nDEFTREECODE (MULT_EXPR, \"mult_expr\", '2', 2)\n\n/* Division for integer result that rounds the quotient toward zero.  */\nDEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", '2', 2)\n\n/* Division for integer result that rounds the quotient toward infinity.  */\nDEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", '2', 2)\n\n/* Division for integer result that rounds toward minus infinity.  */\nDEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", '2', 2)\n\n/* Division for integer result that rounds toward nearest integer.  */\nDEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", '2', 2)\n\n/* Four kinds of remainder that go with the four kinds of division.  */\nDEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", '2', 2)\nDEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", '2', 2)\nDEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", '2', 2)\nDEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", '2', 2)\n\n/* Division for real result.  */\nDEFTREECODE (RDIV_EXPR, \"rdiv_expr\", '2', 2)\n\n/* Division which is not supposed to need rounding.\n   Used for pointer subtraction in C.  */\nDEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", '2', 2)\n\n/* Conversion of real to fixed point: four ways to round,\n   like the four ways to divide.\n   CONVERT_EXPR can also be used to convert a real to an integer,\n   and that is what is used in languages that do not have ways of\n   specifying which of these is wanted.  Maybe these are not needed.  */\nDEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", '1', 1)\nDEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", '1', 1)\nDEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", '1', 1)\nDEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", '1', 1)\n\n/* Conversion of an integer to a real.  */\nDEFTREECODE (FLOAT_EXPR, \"float_expr\", '1', 1)\n\n/* Unary negation.  */\nDEFTREECODE (NEGATE_EXPR, \"negate_expr\", '1', 1)\n\nDEFTREECODE (MIN_EXPR, \"min_expr\", '2', 2)\nDEFTREECODE (MAX_EXPR, \"max_expr\", '2', 2)\n\n/* Represents the absolute value of the operand.\n\n   An ABS_EXPR must have either an INTEGER_TYPE or a REAL_TYPE.  The\n   operand of the ABS_EXPR must have the same type.  */\nDEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n\n/* Shift operations for shift and rotate.\n   Shift means logical shift if done on an\n   unsigned type, arithmetic shift if done on a signed type.\n   The second operand is the number of bits to\n   shift by; it need not be the same type as the first operand and result.\n   Note that the result is undefined if the second operand is larger\n   than the first operand's type size.  */\nDEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", '2', 2)\nDEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", '2', 2)\nDEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", '2', 2)\nDEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", '2', 2)\n\n/* Bitwise operations.  Operands have same mode as result.  */\nDEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", '2', 2)\nDEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", '2', 2)\nDEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", '2', 2)\nDEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", '1', 1)\n\n/* ANDIF and ORIF allow the second operand not to be computed if the\n   value of the expression is determined from the first operand.  AND,\n   OR, and XOR always compute the second operand whether its value is\n   needed or not (for side effects).  The operand may have\n   BOOLEAN_TYPE or INTEGER_TYPE.  In either case, the argument will be\n   either zero or one.  For example, a TRUTH_NOT_EXPR will never have\n   an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be\n   used to compare the VAR_DECL to zero, thereby obtaining a node with\n   value zero or one.  */\nDEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", 'e', 2)\nDEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", 'e', 2)\nDEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", 'e', 2)\nDEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", 'e', 2)\nDEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", 'e', 2)\nDEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", 'e', 1)\n\n/* Relational operators.\n   `EQ_EXPR' and `NE_EXPR' are allowed for any types.\n   The others are allowed only for integer (or pointer or enumeral)\n   or real types.\n   In all cases the operands will have the same type,\n   and the value is always the type used by the language for booleans.  */\nDEFTREECODE (LT_EXPR, \"lt_expr\", '<', 2)\nDEFTREECODE (LE_EXPR, \"le_expr\", '<', 2)\nDEFTREECODE (GT_EXPR, \"gt_expr\", '<', 2)\nDEFTREECODE (GE_EXPR, \"ge_expr\", '<', 2)\nDEFTREECODE (EQ_EXPR, \"eq_expr\", '<', 2)\nDEFTREECODE (NE_EXPR, \"ne_expr\", '<', 2)\n\n/* Additional relational operators for floating point unordered.  */\nDEFTREECODE (UNORDERED_EXPR, \"unordered_expr\", '<', 2)\nDEFTREECODE (ORDERED_EXPR, \"ordered_expr\", '<', 2)\n\n/* These are equivalent to unordered or ...  */\nDEFTREECODE (UNLT_EXPR, \"unlt_expr\", '<', 2)\nDEFTREECODE (UNLE_EXPR, \"unle_expr\", '<', 2)\nDEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\nDEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\nDEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n\n/* Operations for Pascal sets.  Not used now.  */\nDEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)\nDEFTREECODE (SET_LE_EXPR, \"set_le_expr\", '<', 2)\nDEFTREECODE (CARD_EXPR, \"card_expr\", '1', 1)\nDEFTREECODE (RANGE_EXPR, \"range_expr\", '2', 2)\n\n/* Represents a conversion of type of a value.\n   All conversions, including implicit ones, must be\n   represented by CONVERT_EXPR or NOP_EXPR nodes.  */\nDEFTREECODE (CONVERT_EXPR, \"convert_expr\", '1', 1)\n\n/* Represents a conversion expected to require no code to be generated.  */\nDEFTREECODE (NOP_EXPR, \"nop_expr\", '1', 1)\n\n/* Value is same as argument, but guaranteed not an lvalue.  */\nDEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n\n/* Represents viewing something of one type as being of a second type.\n   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n   the idiom *(type2 *)&X in C.  The only operand is the value to be\n   viewed as being of another type.  It is undefined if the type of the\n   input and of the expression have different sizes.\n\n   This code may also be used within the LHS of a MODIFY_EXPR, in which\n   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n   this case and GCC must abort if it could not do the operation without\n   generating insns.  */\nDEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n\n/* Represents something we computed once and will use multiple times.\n   First operand is that expression.  Second is the function decl\n   in which the SAVE_EXPR was created.  The third operand is the RTL,\n   nonzero only after the expression has been computed.  */\nDEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 3)\n\n/* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs,\n   CALL_EXPRs and RTL_EXPRs, that are protected\n   from being evaluated more than once should be reset so that a new\n   expand_expr call of this expr will cause those to be re-evaluated.\n   This is useful when we want to reuse a tree in different places,\n   but where we must re-expand.  */\nDEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n\n/* Represents something whose RTL has already been expanded as a\n   sequence which should be emitted when this expression is expanded.\n   The first operand is the RTL to emit.  It is the first of a chain\n   of insns.  The second is the RTL expression for the result.  The\n   third operand is the \"alternate RTL expression\" for the result, if\n   any; if the second argument is the DECL_RTL for a VAR_DECL, but\n   with an invalid memory address replaced by a valid one, then the\n   third operand will be the original DECL_RTL.  Any temporaries\n   created during the building of the RTL_EXPR can be reused once the\n   RTL_EXPR has been expanded, with the exception of the\n   RTL_EXPR_RTL.  */\nDEFTREECODE (RTL_EXPR, \"rtl_expr\", 'e', 3)\n\n/* & in C.  Value is the address at which the operand's value resides.\n   Operand may have any mode.  Result mode is Pmode.  */\nDEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n\n/* Non-lvalue reference or pointer to an object.  */\nDEFTREECODE (REFERENCE_EXPR, \"reference_expr\", 'e', 1)\n\n/* Operand is a function constant; result is a function variable value\n   of type EPmode.  Used only for languages that need static chains.  */\nDEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", 'e', 1)\n\n/* Operand0 is a function constant; result is part N of a function\n   descriptor of type ptr_mode.  */\nDEFTREECODE (FDESC_EXPR, \"fdesc_expr\", 'e', 2)\n\n/* Given two real or integer operands of the same type,\n   returns a complex value of the corresponding complex type.  */\nDEFTREECODE (COMPLEX_EXPR, \"complex_expr\", '2', 2)\n\n/* Complex conjugate of operand.  Used only on complex types.  */\nDEFTREECODE (CONJ_EXPR, \"conj_expr\", '1', 1)\n\n/* Used only on an operand of complex type, these return\n   a value of the corresponding component type.  */\nDEFTREECODE (REALPART_EXPR, \"realpart_expr\", '1', 1)\nDEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", '1', 1)\n\n/* Nodes for ++ and -- in C.\n   The second arg is how much to increment or decrement by.\n   For a pointer, it would be the size of the object pointed to.  */\nDEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", 'e', 2)\nDEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", 'e', 2)\nDEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", 'e', 2)\nDEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", 'e', 2)\n\n/* Used to implement `va_arg'.  */\nDEFTREECODE (VA_ARG_EXPR, \"va_arg_expr\", 'e', 1)\n\n/* Evaluate operand 1.  If and only if an exception is thrown during\n   the evaluation of operand 1, evaluate operand 2.\n\n   This differs from WITH_CLEANUP_EXPR, in that operand 2 is never\n   evaluated unless an exception is throw.  */\nDEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 'e', 2)\n\n/* Evaluate the first operand.\n   The second operand is a cleanup expression which is evaluated\n   on any exit (normal, exception, or jump out) from this expression.  */\nDEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 'e', 2)\n\n/* Used internally for cleanups in the implementation of TRY_FINALLY_EXPR.\n   (Specifically, it is created by expand_expr, not front-ends.)\n   Operand 0 is the rtx for the start of the subroutine we need to call.\n   Operand 1 is the rtx for a variable in which to store the address\n   of where the subroutine should return to.  */\nDEFTREECODE (GOTO_SUBROUTINE_EXPR, \"goto_subroutine\", 'e', 2)\n\n/* These types of expressions have no useful value,\n   and always have side effects.  */\n\n/* A label definition, encapsulated as a statement.\n   Operand 0 is the LABEL_DECL node for the label that appears here.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (LABEL_EXPR, \"label_expr\", 's', 1)\n\n/* GOTO.  Operand 0 is a LABEL_DECL node or an expression.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (GOTO_EXPR, \"goto_expr\", 's', 1)\n\n/* RETURN.  Evaluates operand 0, then returns from the current function.\n   Presumably that operand is an assignment that stores into the\n   RESULT_DECL that hold the value to be returned.\n   The operand may be null.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (RETURN_EXPR, \"return_expr\", 's', 1)\n\n/* Exit the inner most loop conditionally.  Operand 0 is the condition.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (EXIT_EXPR, \"exit_expr\", 's', 1)\n\n/* A loop.  Operand 0 is the body of the loop.\n   It must contain an EXIT_EXPR or is an infinite loop.\n   The type should be void and the value should be ignored.  */\nDEFTREECODE (LOOP_EXPR, \"loop_expr\", 's', 1)\n\n/* A labeled block. Operand 0 is the label that will be generated to\n   mark the end of the block.\n   Operand 1 is the labeled block body.  */\nDEFTREECODE (LABELED_BLOCK_EXPR, \"labeled_block_expr\", 'e', 2)\n\n/* Exit a labeled block, possibly returning a value.  Operand 0 is a\n   LABELED_BLOCK_EXPR to exit.  Operand 1 is the value to return. It\n   may be left null.  */\nDEFTREECODE (EXIT_BLOCK_EXPR, \"exit_block_expr\", 'e', 2)\n\n/* Annotates a tree node (usually an expression) with source location\n   information: a file name (EXPR_WFL_FILENAME);  a line number\n   (EXPR_WFL_LINENO); and column number (EXPR_WFL_COLNO).  It is\n   expanded as the contained node (EXPR_WFL_NODE);  a line note should\n   be emitted first if EXPR_WFL_EMIT_LINE_NOTE.\n   The third operand is only used in the Java front-end, and will\n   eventually be removed.  */\nDEFTREECODE (EXPR_WITH_FILE_LOCATION, \"expr_with_file_location\", 'e', 3)\n\n/* Switch expression.\n   Operand 0 is the expression used to perform the branch,\n   Operand 1 contains the case values. The way they're organized is\n   front-end implementation defined.  */\nDEFTREECODE (SWITCH_EXPR, \"switch_expr\", 'e', 2)\n\n/* The exception object from the runtime.  */\nDEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", 'e', 0)\n\n/*\nLocal variables:\nmode:c\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSYSTEM": {"ttr": 12801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Get common system includes and various definitions and declarations\n   based on target macros.\n   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* As a special exception, if you link this library with other files,\n   some of which are compiled with GCC, to produce an executable,\n   this library does not by itself cause the resulting executable\n   to be covered by the GNU General Public License.\n   This exception does not however invalidate any other reasons why\n   the executable file might be covered by the GNU General Public License.  */\n\n#ifndef GCC_TSYSTEM_H\n#define GCC_TSYSTEM_H\n\n/* System headers (e.g. stdio.h, stdlib.h, unistd.h) sometimes\n   indirectly include getopt.h.  Our -I flags will cause gcc's gnu\n   getopt.h to be included, not the platform's copy.  In the default\n   case, gnu getopt.h will provide us with a no-argument prototype\n   which will generate -Wstrict-prototypes warnings.  None of the\n   target files actually use getopt, so it is safe to tell gnu\n   getopt.h we never need this prototype.  */\n#ifndef HAVE_DECL_GETOPT\n#define HAVE_DECL_GETOPT 1\n#endif\n\n/* GCC supplies these headers.  */\n#include <stddef.h>\n#include <float.h>\n\n#ifdef inhibit_libc\n\n#ifndef malloc\nextern void *malloc (size_t);\n#endif\n\n#ifndef free\nextern void free (void *);\n#endif\n\n#ifndef atexit\nextern int atexit (void (*)(void));\n#endif\n\n#ifndef abort\nextern void abort (void) __attribute__ ((__noreturn__));\n#endif\n\n#ifndef strlen\nextern size_t strlen (const char *);\n#endif\n\n#else /* ! inhibit_libc */\n/* We disable this when inhibit_libc, so that gcc can still be built without\n   needing header files first.  */\n/* ??? This is not a good solution, since prototypes may be required in\n   some cases for correct code.  */\n\n/* GCC supplies this header.  */\n#include <stdarg.h>\n\n/* All systems have this header.  */\n#include <stdio.h>\n\n/* All systems have this header.  */\n#include <sys/types.h>\n\n/* All systems have this header.  */\n#include <errno.h>\n\n#ifndef errno\nextern int errno;\n#endif\n\n/* GCC (fixproto) guarantees these system headers exist.  */\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n/* GCC supplies this header.  */\n#include <limits.h>\n\n/* GCC (fixproto) guarantees this system headers exists.  */\n#include <time.h>\n\n#endif /* inhibit_libc */\n\n/* Define a generic NULL if one hasn't already been defined.  */\n#ifndef NULL\n#define NULL 0\n#endif\n\n#endif /* ! GCC_TSYSTEM_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TYPECLAS": {"ttr": 12803, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Values returned by __builtin_classify_type.  */\n\nenum type_class\n{\n  no_type_class = -1,\n  void_type_class, integer_type_class, char_type_class,\n  enumeral_type_class, boolean_type_class,\n  pointer_type_class, reference_type_class, offset_type_class,\n  real_type_class, complex_type_class,\n  function_type_class, method_type_class,\n  record_type_class, union_type_class,\n  array_type_class, string_type_class, set_type_class, file_type_class,\n  lang_type_class\n};\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNIXIO": {"ttr": 12805, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* written by Paul Edwards */\n/* released to the public domain */\n\n#ifndef UNIXIO_INCLUDED\n#define UNIXIO_INCLUDED\n\n#include <stddef.h>\n#include <time.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define S_IFBLK 0x3000\n#define S_IFDIR 0x4000\n#define S_IFREG 0x8000\n#define S_IFMT 0xf000\n\n#ifndef ENOENT\n#define ENOENT 2002\n#endif\n#ifndef ENOTDIR\n#define ENOTDIR 2045\n#endif\n#ifndef EINVAL\n#define EINVAL 22\n#endif\n#ifndef ENOMEM\n#define ENOMEM 12\n#endif\n#ifndef E2BIG\n#define E2BIG 7\n#endif\n\n#define O_RDONLY 1\n#define O_WRONLY 2\n#define O_RDWR 4\n#define O_EXCL 0x80\n#define O_CREAT 0x100\n#define O_TRUNC 0x200\n\ntypedef int off_t;\n\nstruct stat {\n  off_t st_size;\n  long st_mode;\n  long st_ino;\n  long st_dev;\n  long st_mtime;\n  int st_nlink;\n  int st_uid;\n  int st_gid;\n  int st_ctime;\n};\n\ntypedef struct {\n  int whatever;\n} DIR;\n\nstruct dirent {\n  int whatever;\n};\n\nstruct direct {\n  char *d_name;\n  int d_namlen;\n};\n\ntypedef int ino_t;\ntypedef int dev_t;\n\n#define wait(a) (*(a) = 0)\n#define getpid() (0)\n#define geteuid() (0)\n#define _exit(a) (exit((a)))\n\nint open(const char *fnm, int mode, ...);\nint read(int fno, void *buf, size_t bytes);\nint write(int fno, const void *buf, size_t bytes);\nint close(int fno);\nlong lseek(int fno, long int offset, int whence);\nint unlink(const char *f);\nint stat(const char *f, struct stat *buf);\nint fileno(FILE *fp);\nint access(const char *f, int n);\nint fstat(int fh, struct stat *buf);\nint pwait(int a, int *b, int c);\nchar *mktemp(char *s);\nFILE *popen(const char *s, const char *t);\nint kill(int a, int b);\nDIR *opendir(char *dirname);\nstruct dirent *readdir(DIR *dir);\nint closedir(DIR *dir);\nint execvp(char *path, char **argv);\n\n#endif\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNWIND": {"ttr": 12814, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception handling and frame unwind runtime interface routines.\n   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* As a special exception, if you include this header file into source\n   files compiled by GCC, this header file does not by itself cause\n   the resulting executable to be covered by the GNU General Public\n   License.  This exception does not however invalidate any other\n   reasons why the executable file might be covered by the GNU General\n   Public License.  */\n\n/* This is derived from the C++ ABI for IA-64.  Where we diverge\n   for cross-architecture compatibility are noted with \"@@@\".  */\n\n#ifndef _UNWIND_H\n#define _UNWIND_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Level 1: Base ABI  */\n\n/* @@@ The IA-64 ABI uses uint64 throughout.  Most places this is\n   inefficient for 32-bit and smaller machines.  */\ntypedef unsigned _Unwind_Word __attribute__((__mode__(__word__)));\ntypedef signed _Unwind_Sword __attribute__((__mode__(__word__)));\n#if defined(__ia64__) && defined(__hpux__)\ntypedef unsigned _Unwind_Ptr __attribute__((__mode__(__word__)));\n#else\ntypedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));\n#endif\ntypedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));\n\n/* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and\n   consumer of an exception.  We'll go along with this for now even on\n   32-bit machines.  We'll need to provide some other option for\n   16-bit machines and for machines with > 8 bits per byte.  */\ntypedef unsigned _Unwind_Exception_Class __attribute__((__mode__(__DI__)));\n\n/* The unwind interface uses reason codes in several contexts to\n   identify the reasons for failures or other actions.  */\ntypedef enum\n{\n  _URC_NO_REASON = 0,\n  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n  _URC_FATAL_PHASE2_ERROR = 2,\n  _URC_FATAL_PHASE1_ERROR = 3,\n  _URC_NORMAL_STOP = 4,\n  _URC_END_OF_STACK = 5,\n  _URC_HANDLER_FOUND = 6,\n  _URC_INSTALL_CONTEXT = 7,\n  _URC_CONTINUE_UNWIND = 8\n} _Unwind_Reason_Code;\n\n\n/* The unwind interface uses a pointer to an exception header object\n   as its representation of an exception being thrown. In general, the\n   full representation of an exception object is language- and\n   implementation-specific, but it will be prefixed by a header\n   understood by the unwind interface.  */\n\nstruct _Unwind_Exception;\n\ntypedef void (*_Unwind_Exception_Cleanup_Fn) (_Unwind_Reason_Code,\n\t\t\t\t\t      struct _Unwind_Exception *);\n\nstruct _Unwind_Exception\n{\n  _Unwind_Exception_Class exception_class;\n  _Unwind_Exception_Cleanup_Fn exception_cleanup;\n  _Unwind_Word private_1;\n  _Unwind_Word private_2;\n\n  /* @@@ The IA-64 ABI says that this structure must be double-word aligned.\n     Taking that literally does not make much sense generically.  Instead we\n     provide the maximum alignment required by any type for the machine.  */\n} __attribute__((__aligned__));\n\n\n/* The ACTIONS argument to the personality routine is a bitwise OR of one\n   or more of the following constants.  */\ntypedef int _Unwind_Action;\n\n#define _UA_SEARCH_PHASE\t1\n#define _UA_CLEANUP_PHASE\t2\n#define _UA_HANDLER_FRAME\t4\n#define _UA_FORCE_UNWIND\t8\n#define _UA_END_OF_STACK\t16\n\n/* This is an opaque type used to refer to a system-specific data\n   structure used by the system unwinder. This context is created and\n   destroyed by the system, and passed to the personality routine\n   during unwinding.  */\nstruct _Unwind_Context;\n\n/* Raise an exception, passing along the given exception object.  */\nextern _Unwind_Reason_Code _Unwind_RaiseException (struct _Unwind_Exception *);\n\n/* Raise an exception for forced unwinding.  */\n\ntypedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n     (int, _Unwind_Action, _Unwind_Exception_Class,\n      struct _Unwind_Exception *, struct _Unwind_Context *, void *);\n\nextern _Unwind_Reason_Code _Unwind_ForcedUnwind (struct _Unwind_Exception *,\n\t\t\t\t\t\t _Unwind_Stop_Fn,\n\t\t\t\t\t\t void *);\n\n/* Helper to invoke the exception_cleanup routine.  */\nextern void _Unwind_DeleteException (struct _Unwind_Exception *);\n\n/* Resume propagation of an existing exception.  This is used after\n   e.g. executing cleanup code, and not to implement rethrowing.  */\nextern void _Unwind_Resume (struct _Unwind_Exception *);\n\n/* @@@ Resume propagation of an FORCE_UNWIND exception, or to rethrow\n   a normal exception that was handled.  */\nextern _Unwind_Reason_Code _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *);\n\n/* @@@ Use unwind data to perform a stack backtrace.  The trace callback\n   is called for every stack frame in the call chain, but no cleanup\n   actions are performed.  */\ntypedef _Unwind_Reason_Code (*_Unwind_Trace_Fn)\n     (struct _Unwind_Context *, void *);\n\nextern _Unwind_Reason_Code _Unwind_Backtrace (_Unwind_Trace_Fn, void *);\n\n/* These functions are used for communicating information about the unwind\n   context (i.e. the unwind descriptors and the user register state) between\n   the unwind library and the personality routine and landing pad.  Only\n   selected registers maybe manipulated.  */\n\nextern _Unwind_Word _Unwind_GetGR (struct _Unwind_Context *, int);\nextern void _Unwind_SetGR (struct _Unwind_Context *, int, _Unwind_Word);\n\nextern _Unwind_Ptr _Unwind_GetIP (struct _Unwind_Context *);\nextern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);\n\n/* @@@ Retrieve the CFA of the given context.  */\nextern _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);\n\nextern void *_Unwind_GetLanguageSpecificData (struct _Unwind_Context *);\n\nextern _Unwind_Ptr _Unwind_GetRegionStart (struct _Unwind_Context *);\n\n\n/* The personality routine is the function in the C++ (or other language)\n   runtime library which serves as an interface between the system unwind\n   library and language-specific exception handling semantics.  It is\n   specific to the code fragment described by an unwind info block, and\n   it is always referenced via the pointer in the unwind info block, and\n   hence it has no ABI-specified name.\n\n   Note that this implies that two different C++ implementations can\n   use different names, and have different contents in the language\n   specific data area.  Moreover, that the language specific data\n   area contains no version info because name of the function invoked\n   provides more effective versioning by detecting at link time the\n   lack of code to handle the different data format.  */\n\ntypedef _Unwind_Reason_Code (*_Unwind_Personality_Fn)\n     (int, _Unwind_Action, _Unwind_Exception_Class,\n      struct _Unwind_Exception *, struct _Unwind_Context *);\n\n/* @@@ The following alternate entry points are for setjmp/longjmp\n   based unwinding.  */\n\nstruct SjLj_Function_Context;\nextern void _Unwind_SjLj_Register (struct SjLj_Function_Context *);\nextern void _Unwind_SjLj_Unregister (struct SjLj_Function_Context *);\n\nextern _Unwind_Reason_Code _Unwind_SjLj_RaiseException\n     (struct _Unwind_Exception *);\nextern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind\n     (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);\nextern void _Unwind_SjLj_Resume (struct _Unwind_Exception *);\nextern _Unwind_Reason_Code _Unwind_SjLj_Resume_or_Rethrow (struct _Unwind_Exception *);\n\n/* @@@ The following provide access to the base addresses for text\n   and data-relative addressing in the LDSA.  In order to stay link\n   compatible with the standard ABI for IA-64, we inline these.  */\n\n#ifdef __ia64__\n#include <stdlib.h>\n\nstatic inline _Unwind_Ptr\n_Unwind_GetDataRelBase (struct _Unwind_Context *_C)\n{\n  /* The GP is stored in R1.  */\n  return _Unwind_GetGR (_C, 1);\n}\n\nstatic inline _Unwind_Ptr\n_Unwind_GetTextRelBase (struct _Unwind_Context *_C __attribute__ ((__unused__)))\n{\n  abort ();\n  return 0;\n}\n\n/* @@@ Retrieve the Backing Store Pointer of the given context.  */\nextern _Unwind_Word _Unwind_GetBSP (struct _Unwind_Context *);\n#else\nextern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);\nextern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);\n#endif\n\n/* @@@ Given an address, return the entry point of the function that\n   contains it.  */\nextern void * _Unwind_FindEnclosingFunction (void *pc);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* unwind.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWIND@C": {"ttr": 12807, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Backward compatibility unwind routines.\n   Copyright (C) 2004\n   Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   In addition to the permissions in the GNU General Public License, the\n   Free Software Foundation gives you unlimited permission to link the\n   compiled version of this file into combinations with other programs,\n   and to distribute those combinations without any restriction coming\n   from the use of this file.  (The General Public License restrictions\n   do apply in other respects; for example, they cover modification of\n   the file, and distribution when not linked into a combined\n   executable.)\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n#define symver(name, version) \\\n  __asm__ (\".symver \" #name\",\" #name \"@\" #version)\n\n#define alias(name) \\\n  __typeof(name) __libunwind##name __attribute__ ((alias (#name)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWIND@D": {"ttr": 12809, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Subroutines needed for unwinding stack frames for exception handling.  */\n/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2004\n   Free Software Foundation, Inc.\n   Contributed by Jason Merrill <jason@cygnus.com>.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nIn addition to the permissions in the GNU General Public License, the\nFree Software Foundation gives you unlimited permission to link the\ncompiled version of this file into combinations with other programs,\nand to distribute those combinations without any restriction coming\nfrom the use of this file.  (The General Public License restrictions\ndo apply in other respects; for example, they cover modification of\nthe file, and distribution when not linked into a combine\nexecutable.)\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_UNWIND_DW2_FDE_H\n#define GCC_UNWIND_DW2_FDE_H\n\nstruct fde_vector\n{\n  const void *orig_data;\n  size_t count;\n  const struct dwarf_fde *array\u00dd\u00a8;\n};\n\nstruct object\n{\n  void *pc_begin;\n  void *tbase;\n  void *dbase;\n  union {\n    const struct dwarf_fde *single;\n    struct dwarf_fde **array;\n    struct fde_vector *sort;\n  } u;\n\n  union {\n    struct {\n      unsigned long sorted : 1;\n      unsigned long from_array : 1;\n      unsigned long mixed_encoding : 1;\n      unsigned long encoding : 8;\n      /* ??? Wish there was an easy way to detect a 64-bit host here;\n\t we've got 32 bits left to play with...  */\n      unsigned long count : 21;\n    } b;\n    size_t i;\n  } s;\n\n#ifdef DWARF2_OBJECT_END_PTR_EXTENSION\n  char *fde_end;\n#endif\n\n  struct object *next;\n};\n\n/* This is the original definition of struct object.  While the struct\n   itself was opaque to users, they did know how large it was, and\n   allocate one statically in crtbegin for each DSO.  Keep this around\n   so that we're aware of the static size limitations for the new struct.  */\nstruct old_object\n{\n  void *pc_begin;\n  void *pc_end;\n  struct dwarf_fde *fde_begin;\n  struct dwarf_fde **fde_array;\n  size_t count;\n  struct old_object *next;\n};\n\nstruct dwarf_eh_bases\n{\n  void *tbase;\n  void *dbase;\n  void *func;\n};\n\n\nextern void __register_frame_info_bases (const void *, struct object *,\n\t\t\t\t\t void *, void *);\nextern void __register_frame_info (const void *, struct object *);\nextern void __register_frame (void *);\nextern void __register_frame_info_table_bases (void *, struct object *,\n\t\t\t\t\t       void *, void *);\nextern void __register_frame_info_table (void *, struct object *);\nextern void __register_frame_table (void *);\nextern void *__deregister_frame_info (const void *);\nextern void *__deregister_frame_info_bases (const void *);\nextern void __deregister_frame (void *);\n\n\ntypedef          int  sword __attribute__ ((mode (SI)));\ntypedef unsigned int  uword __attribute__ ((mode (SI)));\ntypedef unsigned int  uaddr __attribute__ ((mode (pointer)));\ntypedef          int  saddr __attribute__ ((mode (pointer)));\ntypedef unsigned char ubyte;\n\n/* Terminology:\n   CIE - Common Information Element\n   FDE - Frame Descriptor Element\n\n   There is one per function, and it describes where the function code\n   is located, and what the register lifetimes and stack layout are\n   within the function.\n\n   The data structures are defined in the DWARF specification, although\n   not in a very readable way (see LITERATURE).\n\n   Every time an exception is thrown, the code needs to locate the FDE\n   for the current function, and starts to look for exception regions\n   from that FDE. This works in a two-level search:\n   a) in a linear search, find the shared image (i.e. DLL) containing\n      the PC\n   b) using the FDE table for that shared object, locate the FDE using\n      binary search (which requires the sorting).  */\n\n/* The first few fields of a CIE.  The CIE_id field is 0 for a CIE,\n   to distinguish it from a valid FDE.  FDEs are aligned to an addressing\n   unit boundary, but the fields within are unaligned.  */\nstruct dwarf_cie\n{\n  uword length;\n  sword CIE_id;\n  ubyte version;\n  unsigned char augmentation\u00dd\u00a8;\n} __attribute__ ((packed, aligned (__alignof__ (void *))));\n\n/* The first few fields of an FDE.  */\nstruct dwarf_fde\n{\n  uword length;\n  sword CIE_delta;\n  unsigned char pc_begin\u00dd\u00a8;\n} __attribute__ ((packed, aligned (__alignof__ (void *))));\n\ntypedef struct dwarf_fde fde;\n\n/* Locate the CIE for a given FDE.  */\n\nstatic inline const struct dwarf_cie *\nget_cie (const struct dwarf_fde *f)\n{\n  return (void *)&f->CIE_delta - f->CIE_delta;\n}\n\nstatic inline const fde *\nnext_fde (const fde *f)\n{\n  return (const fde *) ((char *) f + f->length + sizeof (f->length));\n}\n\nextern const fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);\n\nstatic inline int\nlast_fde (struct object *obj __attribute__ ((__unused__)), const fde *f)\n{\n#ifdef DWARF2_OBJECT_END_PTR_EXTENSION\n  return (char *)f == obj->fde_end || f->length == 0;\n#else\n  return f->length == 0;\n#endif\n}\n\n#endif /* unwind-dw2-fde.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNWIND@P": {"ttr": 12811, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Exception handling and frame unwind runtime interface routines.\n   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   In addition to the permissions in the GNU General Public License, the\n   Free Software Foundation gives you unlimited permission to link the\n   compiled version of this file into combinations with other programs,\n   and to distribute those combinations without any restriction coming\n   from the use of this file.  (The General Public License restrictions\n   do apply in other respects; for example, they cover modification of\n   the file, and distribution when not linked into a combined\n   executable.)\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   02111-1307, USA.  */\n\n/* @@@ Really this should be out of line, but this also causes link\n   compatibility problems with the base ABI.  This is slightly better\n   than duplicating code, however.  */\n\n#ifndef GCC_UNWIND_PE_H\n#define GCC_UNWIND_PE_H\n\n/* If using C++, references to abort have to be qualified with std::.  */\n#if __cplusplus\n#define __gxx_abort std::abort\n#else\n#define __gxx_abort abort\n#endif\n\n/* Pointer encodings, from dwarf2.h.  */\n#define DW_EH_PE_absptr         0x00\n#define DW_EH_PE_omit           0xff\n\n#define DW_EH_PE_uleb128        0x01\n#define DW_EH_PE_udata2         0x02\n#define DW_EH_PE_udata4         0x03\n#define DW_EH_PE_udata8         0x04\n#define DW_EH_PE_sleb128        0x09\n#define DW_EH_PE_sdata2         0x0A\n#define DW_EH_PE_sdata4         0x0B\n#define DW_EH_PE_sdata8         0x0C\n#define DW_EH_PE_signed         0x08\n\n#define DW_EH_PE_pcrel          0x10\n#define DW_EH_PE_textrel        0x20\n#define DW_EH_PE_datarel        0x30\n#define DW_EH_PE_funcrel        0x40\n#define DW_EH_PE_aligned        0x50\n\n#define DW_EH_PE_indirect\t0x80\n\n\n#ifndef NO_SIZE_OF_ENCODED_VALUE\n\n/* Given an encoding, return the number of bytes the format occupies.\n   This is only defined for fixed-size encodings, and so does not\n   include leb128.  */\n\nstatic unsigned int\nsize_of_encoded_value (unsigned char encoding)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding & 0x07)\n    {\n    case DW_EH_PE_absptr:\n      return sizeof (void *);\n    case DW_EH_PE_udata2:\n      return 2;\n    case DW_EH_PE_udata4:\n      return 4;\n    case DW_EH_PE_udata8:\n      return 8;\n    }\n  __gxx_abort ();\n}\n\n#endif\n\n#ifndef NO_BASE_OF_ENCODED_VALUE\n\n/* Given an encoding and an _Unwind_Context, return the base to which\n   the encoding is relative.  This base may then be passed to\n   read_encoded_value_with_base for use when the _Unwind_Context is\n   not available.  */\n\nstatic _Unwind_Ptr\nbase_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding & 0x70)\n    {\n    case DW_EH_PE_absptr:\n    case DW_EH_PE_pcrel:\n    case DW_EH_PE_aligned:\n      return 0;\n\n    case DW_EH_PE_textrel:\n      return _Unwind_GetTextRelBase (context);\n    case DW_EH_PE_datarel:\n      return _Unwind_GetDataRelBase (context);\n    case DW_EH_PE_funcrel:\n      return _Unwind_GetRegionStart (context);\n    }\n  __gxx_abort ();\n}\n\n#endif\n\n/* Read an unsigned leb128 value from P, store the value in VAL, return\n   P incremented past the value.  We assume that a word is large enough to\n   hold any value so encoded; if it is smaller than a pointer on some target,\n   pointers should not be leb128 encoded on that target.  */\n\nstatic const unsigned char *\nread_uleb128 (const unsigned char *p, _Unwind_Word *val)\n{\n  unsigned int shift = 0;\n  unsigned char byte;\n  _Unwind_Word result;\n\n  result = 0;\n  do\n    {\n      byte = *p++;\n      result |= ((_Unwind_Word)byte & 0x7f) << shift;\n      shift += 7;\n    }\n  while (byte & 0x80);\n\n  *val = result;\n  return p;\n}\n\n/* Similar, but read a signed leb128 value.  */\n\nstatic const unsigned char *\nread_sleb128 (const unsigned char *p, _Unwind_Sword *val)\n{\n  unsigned int shift = 0;\n  unsigned char byte;\n  _Unwind_Word result;\n\n  result = 0;\n  do\n    {\n      byte = *p++;\n      result |= ((_Unwind_Word)byte & 0x7f) << shift;\n      shift += 7;\n    }\n  while (byte & 0x80);\n\n  /* Sign-extend a negative value.  */\n  if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n    result |= -(((_Unwind_Word)1L) << shift);\n\n  *val = (_Unwind_Sword) result;\n  return p;\n}\n\n/* Load an encoded value from memory at P.  The value is returned in VAL;\n   The function returns P incremented past the value.  BASE is as given\n   by base_of_encoded_value for this encoding in the appropriate context.  */\n\nstatic const unsigned char *\nread_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n\t\t\t      const unsigned char *p, _Unwind_Ptr *val)\n{\n  union unaligned\n    {\n      void *ptr;\n      unsigned u2 __attribute__ ((mode (HI)));\n      unsigned u4 __attribute__ ((mode (SI)));\n      unsigned u8 __attribute__ ((mode (DI)));\n      signed s2 __attribute__ ((mode (HI)));\n      signed s4 __attribute__ ((mode (SI)));\n      signed s8 __attribute__ ((mode (DI)));\n    } __attribute__((__packed__));\n\n  const union unaligned *u = (const union unaligned *) p;\n  _Unwind_Internal_Ptr result;\n\n  if (encoding == DW_EH_PE_aligned)\n    {\n      _Unwind_Internal_Ptr a = (_Unwind_Internal_Ptr) p;\n      a = (a + sizeof (void *) - 1) & - sizeof(void *);\n      result = *(_Unwind_Internal_Ptr *) a;\n      p = (const unsigned char *) (_Unwind_Internal_Ptr) (a + sizeof (void *));\n    }\n  else\n    {\n      switch (encoding & 0x0f)\n\t{\n\tcase DW_EH_PE_absptr:\n\t  result = (_Unwind_Internal_Ptr) u->ptr;\n\t  p += sizeof (void *);\n\t  break;\n\n\tcase DW_EH_PE_uleb128:\n\t  {\n\t    _Unwind_Word tmp;\n\t    p = read_uleb128 (p, &tmp);\n\t    result = (_Unwind_Internal_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_sleb128:\n\t  {\n\t    _Unwind_Sword tmp;\n\t    p = read_sleb128 (p, &tmp);\n\t    result = (_Unwind_Internal_Ptr) tmp;\n\t  }\n\t  break;\n\n\tcase DW_EH_PE_udata2:\n\t  result = u->u2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_udata4:\n\t  result = u->u4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_udata8:\n\t  result = u->u8;\n\t  p += 8;\n\t  break;\n\n\tcase DW_EH_PE_sdata2:\n\t  result = u->s2;\n\t  p += 2;\n\t  break;\n\tcase DW_EH_PE_sdata4:\n\t  result = u->s4;\n\t  p += 4;\n\t  break;\n\tcase DW_EH_PE_sdata8:\n\t  result = u->s8;\n\t  p += 8;\n\t  break;\n\n\tdefault:\n\t  __gxx_abort ();\n\t}\n\n      if (result != 0)\n\t{\n\t  result += ((encoding & 0x70) == DW_EH_PE_pcrel\n\t\t     ? (_Unwind_Internal_Ptr) u : base);\n\t  if (encoding & DW_EH_PE_indirect)\n\t    result = *(_Unwind_Internal_Ptr *) result;\n\t}\n    }\n\n  *val = result;\n  return p;\n}\n\n#ifndef NO_BASE_OF_ENCODED_VALUE\n\n/* Like read_encoded_value_with_base, but get the base from the context\n   rather than providing it directly.  */\n\nstatic inline const unsigned char *\nread_encoded_value (struct _Unwind_Context *context, unsigned char encoding,\n\t\t    const unsigned char *p, _Unwind_Ptr *val)\n{\n  return read_encoded_value_with_base (encoding,\n\t\tbase_of_encoded_value (encoding, context),\n\t\tp, val);\n}\n\n#endif\n\n#endif /* unwind-pe.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VALUE@PR": {"ttr": 12817, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for transformations based on profile information for values.\n   Copyright (C) 2003 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n/* Supported histogram types.  */\nenum hist_type\n{\n  HIST_TYPE_INTERVAL,\t/* Measures histogram of values inside a specified\n\t\t\t   interval.  */\n  HIST_TYPE_POW2,\t/* Histogram of power of 2 values.  */\n  HIST_TYPE_SINGLE_VALUE, /* Tries to identify the value that is (almost)\n\t\t\t   always constant.  */\n  HIST_TYPE_CONST_DELTA\t/* Tries to identify the (almost) always constant\n\t\t\t   difference between two evaluations of a value.  */\n};\n\n#define COUNTER_FOR_HIST_TYPE(TYPE) ((int) (TYPE) + GCOV_FIRST_VALUE_COUNTER)\n#define HIST_TYPE_FOR_COUNTER(COUNTER) \\\n  ((enum hist_type) ((COUNTER) - GCOV_FIRST_VALUE_COUNTER))\n\n/* The value to measure.  */\nstruct histogram_value\n{\n  rtx value;\t\t/* The value to profile.  */\n  enum machine_mode mode; /* And its mode.  */\n  rtx seq;\t\t/* Insns required to count the profiled value.  */\n  rtx insn;\t\t/* Insn before that to measure.  */\n  enum hist_type type;\t/* Type of information to measure.  */\n  unsigned n_counters;\t/* Number of required counters.  */\n  union\n    {\n      struct\n\t{\n\t  int int_start;\t/* First value in interval.  */\n\t  int steps;\t\t/* Number of values in it.  */\n\t  int may_be_less;\t/* May the value be below?  */\n\t  int may_be_more;\t/* Or above.  */\n\t} intvl;\t/* Interval histogram data.  */\n      struct\n\t{\n\t  int may_be_other;\t/* If the value may be non-positive or not 2\u00ack.  */\n\t} pow2;\t\t/* Power of 2 histogram data.  */\n    } hdata;\t\t/* Profiled information specific data.  */\n};\n\nextern void find_values_to_profile (unsigned *, struct histogram_value **);\nextern void free_profiled_values (unsigned, struct histogram_value *);\nextern bool value_profile_transformations (void);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARRAY": {"ttr": 12819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Virtual array support.\n   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004\n   Free Software Foundation, Inc.\n   Contributed by Cygnus Solutions.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful, but WITHOUT\n   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n   License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with GCC; see the file COPYING.  If not, write to the Free\n   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n   MA 02111-1307, USA.  */\n\n#ifndef GCC_VARRAY_H\n#define GCC_VARRAY_H\n\n#ifndef HOST_WIDE_INT\n#include \"machmode.h\"\n#endif\n\n#ifndef GCC_SYSTEM_H\n#include \"system.h\"\n#include \"coretypes.h\"\n#include \"tm.h\"\n#endif\n\n/* Auxiliary structure used inside the varray structure, used for\n   function integration data.  */\n\nstruct const_equiv_data GTY(()) {\n  /* Map pseudo reg number in calling function to equivalent constant.  We\n     cannot in general substitute constants into parameter pseudo registers,\n     since some machine descriptions (many RISCs) won't always handle\n     the resulting insns.  So if an incoming parameter has a constant\n     equivalent, we record it here, and if the resulting insn is\n     recognizable, we go with it.\n\n     We also use this mechanism to convert references to incoming arguments\n     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n     incoming argument and virtual stacked variables registers with new\n     pseudos that contain pointers into the replacement area allocated for\n     this inline instance.  These pseudos are then marked as being equivalent\n     to the appropriate address and substituted if valid.  */\n  rtx rtx;\n\n  /* Record the valid age for each entry.  The entry is invalid if its\n     age is less than const_age.  */\n  unsigned age;\n};\n\n/* Enum indicating what the varray contains.\n   If this is changed, `element' in varray.c needs to be updated.  */\n\nenum varray_data_enum {\n  VARRAY_DATA_C,\n  VARRAY_DATA_UC,\n  VARRAY_DATA_S,\n  VARRAY_DATA_US,\n  VARRAY_DATA_I,\n  VARRAY_DATA_U,\n  VARRAY_DATA_L,\n  VARRAY_DATA_UL,\n  VARRAY_DATA_HINT,\n  VARRAY_DATA_UHINT,\n  VARRAY_DATA_GENERIC,\n  VARRAY_DATA_CPTR,\n  VARRAY_DATA_RTX,\n  VARRAY_DATA_RTVEC,\n  VARRAY_DATA_TREE,\n  VARRAY_DATA_BITMAP,\n  VARRAY_DATA_REG,\n  VARRAY_DATA_CONST_EQUIV,\n  VARRAY_DATA_BB,\n  VARRAY_DATA_TE,\n  NUM_VARRAY_DATA\n};\n\n/* Union of various array types that are used.  */\ntypedef union varray_data_tag GTY (()) {\n  char\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_C\")))\t\tc\u00dd1\u00a8;\n  unsigned char\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_UC\")))\tuc\u00dd1\u00a8;\n  short\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_S\")))\t\ts\u00dd1\u00a8;\n  unsigned short\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_US\")))\tus\u00dd1\u00a8;\n  int\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_I\")))\t\ti\u00dd1\u00a8;\n  unsigned int\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_U\")))\t\tu\u00dd1\u00a8;\n  long\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_L\")))\t\tl\u00dd1\u00a8;\n  unsigned long\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_UL\")))\tul\u00dd1\u00a8;\n  HOST_WIDE_INT\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_HINT\")))\thint\u00dd1\u00a8;\n  unsigned HOST_WIDE_INT  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_UHINT\")))\tuhint\u00dd1\u00a8;\n  PTR\t\t\t  GTY ((length (\"%0.num_elements\"), use_param (\"\"),\n\t\t\t\ttag (\"VARRAY_DATA_GENERIC\")))\tgeneric\u00dd1\u00a8;\n  char\t\t\t *GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_CPTR\")))\tcptr\u00dd1\u00a8;\n  rtx\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_RTX\")))\trtx\u00dd1\u00a8;\n  rtvec\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_RTVEC\")))\trtvec\u00dd1\u00a8;\n  tree\t\t\t  GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_TREE\")))\ttree\u00dd1\u00a8;\n  struct bitmap_head_def *GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_BITMAP\")))\tbitmap\u00dd1\u00a8;\n  struct reg_info_def\t *GTY ((length (\"%0.num_elements\"), skip (\"\"),\n\t\t\t\ttag (\"VARRAY_DATA_REG\")))\treg\u00dd1\u00a8;\n  struct const_equiv_data GTY ((length (\"%0.num_elements\"),\n\t\t\ttag (\"VARRAY_DATA_CONST_EQUIV\")))\tconst_equiv\u00dd1\u00a8;\n  struct basic_block_def *GTY ((length (\"%0.num_elements\"), skip (\"\"),\n\t\t\t\ttag (\"VARRAY_DATA_BB\")))\tbb\u00dd1\u00a8;\n  struct elt_list\t *GTY ((length (\"%0.num_elements\"),\n\t\t\t\ttag (\"VARRAY_DATA_TE\")))\tte\u00dd1\u00a8;\n} varray_data;\n\n/* Virtual array of pointers header.  */\nstruct varray_head_tag GTY(()) {\n  size_t\tnum_elements;\t/* Maximum element number allocated.  */\n  size_t        elements_used;  /* The number of elements used, if\n\t\t\t\t   using VARRAY_PUSH/VARRAY_POP.  */\n  enum varray_data_enum type;\t/* The kind of elements in the varray.  */\n  const char   *name;\t\t/* name of the varray for reporting errors */\n  varray_data\tGTY ((desc (\"%0.type\"))) data;\t/* The data elements follow,\n\t\t\t\t\t\t   must be last.  */\n};\ntypedef struct varray_head_tag *varray_type;\n\n/* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n   long, named NAME.  Array elements are zeroed.  */\nextern varray_type varray_init (size_t, enum varray_data_enum, const char *);\n\n#define VARRAY_CHAR_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_C, name)\n\n#define VARRAY_UCHAR_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_UC, name)\n\n#define VARRAY_SHORT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_S, name)\n\n#define VARRAY_USHORT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_US, name)\n\n#define VARRAY_INT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_I, name)\n\n#define VARRAY_UINT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_U, name)\n\n#define VARRAY_LONG_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_L, name)\n\n#define VARRAY_ULONG_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_UL, name)\n\n#define VARRAY_WIDE_INT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_HINT, name)\n\n#define VARRAY_UWIDE_INT_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_UHINT, name)\n\n#define VARRAY_GENERIC_PTR_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_GENERIC, name)\n\n#define VARRAY_CHAR_PTR_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_CPTR, name)\n\n#define VARRAY_RTX_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_RTX, name)\n\n#define VARRAY_RTVEC_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_RTVEC, name)\n\n#define VARRAY_TREE_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_TREE, name)\n\n#define VARRAY_BITMAP_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_BITMAP, name)\n\n#define VARRAY_REG_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_REG, name)\n\n#define VARRAY_CONST_EQUIV_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_CONST_EQUIV, name)\n\n#define VARRAY_BB_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_BB, name)\n\n#define VARRAY_ELT_LIST_INIT(va, num, name) \\\n  va = varray_init (num, VARRAY_DATA_TE, name)\n\n/* Free up memory allocated by the virtual array, but do not free any of the\n   elements involved.  */\n#define VARRAY_FREE(vp) \\\n  do { if (vp) { free (vp); vp = (varray_type) 0; } } while (0)\n\n/* Grow/shrink the virtual array VA to N elements.  */\nextern varray_type varray_grow (varray_type, size_t);\n\n#define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n\n#define VARRAY_SIZE(VA)\t((VA)->num_elements)\n\n#define VARRAY_ACTIVE_SIZE(VA)\t((VA)->elements_used)\n#define VARRAY_POP_ALL(VA)\t((VA)->elements_used = 0)\n\n#define VARRAY_CLEAR(VA) varray_clear(VA)\n\nextern void varray_clear (varray_type);\n\nextern void dump_varray_statistics (void);\n\n/* Check for VARRAY_xxx macros being in bound.  */\n#if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\nextern void varray_check_failed (varray_type, size_t, const char *, int,\n\t\t\t\t const char *) ATTRIBUTE_NORETURN;\nextern void varray_underflow (varray_type, const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n#define VARRAY_CHECK(VA, N, T) __extension__\t\t\t\\\n(*({ varray_type const _va = (VA);\t\t\t\t\\\n     const size_t _n = (N);\t\t\t\t\t\\\n     if (_n >= _va->num_elements)\t\t\t\t\\\n       varray_check_failed (_va, _n, __FILE__, __LINE__, __FUNCTION__);\t\\\n     &_va->data.T\u00dd_n\u00a8; }))\n\n#define VARRAY_POP(VA) do {\t\t\t\t\t\\\n  varray_type const _va = (VA);\t\t\t\t\t\\\n  if (_va->elements_used == 0)\t\t\t\t\t\\\n    varray_underflow (_va, __FILE__, __LINE__, __FUNCTION__);\t\\\n  else\t\t\t\t\t\t\t\t\\\n    _va->elements_used--;\t\t\t\t\t\\\n} while (0)\n\n#else\n#define VARRAY_CHECK(VA, N, T) ((VA)->data.T\u00ddN\u00a8)\n/* Pop the top element of VA.  */\n#define VARRAY_POP(VA) do { ((VA)->elements_used--); } while (0)\n#endif\n\n/* Push X onto VA.  T is the name of the field in varray_data\n   corresponding to the type of X.  */\n#define VARRAY_PUSH(VA, T, X)\t\t\t\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      if ((VA)->elements_used >= (VA)->num_elements)\t\\\n        VARRAY_GROW ((VA), 2 * (VA)->num_elements);\t\\\n      (VA)->data.T\u00dd(VA)->elements_used++\u00a8 = (X);\t\\\n    }\t\t\t\t\t\t\t\\\n  while (0)\n\n#define VARRAY_CHAR(VA, N)\t\tVARRAY_CHECK (VA, N, c)\n#define VARRAY_UCHAR(VA, N)\t\tVARRAY_CHECK (VA, N, uc)\n#define VARRAY_SHORT(VA, N)\t\tVARRAY_CHECK (VA, N, s)\n#define VARRAY_USHORT(VA, N)\t\tVARRAY_CHECK (VA, N, us)\n#define VARRAY_INT(VA, N)\t\tVARRAY_CHECK (VA, N, i)\n#define VARRAY_UINT(VA, N)\t\tVARRAY_CHECK (VA, N, u)\n#define VARRAY_LONG(VA, N)\t\tVARRAY_CHECK (VA, N, l)\n#define VARRAY_ULONG(VA, N)\t\tVARRAY_CHECK (VA, N, ul)\n#define VARRAY_WIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, hint)\n#define VARRAY_UWIDE_INT(VA, N)\t\tVARRAY_CHECK (VA, N, uhint)\n#define VARRAY_GENERIC_PTR(VA,N)\tVARRAY_CHECK (VA, N, generic)\n#define VARRAY_CHAR_PTR(VA,N)\t\tVARRAY_CHECK (VA, N, cptr)\n#define VARRAY_RTX(VA, N)\t\tVARRAY_CHECK (VA, N, rtx)\n#define VARRAY_RTVEC(VA, N)\t\tVARRAY_CHECK (VA, N, rtvec)\n#define VARRAY_TREE(VA, N)\t\tVARRAY_CHECK (VA, N, tree)\n#define VARRAY_BITMAP(VA, N)\t\tVARRAY_CHECK (VA, N, bitmap)\n#define VARRAY_REG(VA, N)\t\tVARRAY_CHECK (VA, N, reg)\n#define VARRAY_CONST_EQUIV(VA, N)\tVARRAY_CHECK (VA, N, const_equiv)\n#define VARRAY_BB(VA, N)\t\tVARRAY_CHECK (VA, N, bb)\n#define VARRAY_ELT_LIST(VA, N)\t\tVARRAY_CHECK (VA, N, te)\n\n/* Push a new element on the end of VA, extending it if necessary.  */\n#define VARRAY_PUSH_CHAR(VA, X)\t\tVARRAY_PUSH (VA, c, X)\n#define VARRAY_PUSH_UCHAR(VA, X)\tVARRAY_PUSH (VA, uc, X)\n#define VARRAY_PUSH_SHORT(VA, X)\tVARRAY_PUSH (VA, s, X)\n#define VARRAY_PUSH_USHORT(VA, X)\tVARRAY_PUSH (VA, us, X)\n#define VARRAY_PUSH_INT(VA, X)\t\tVARRAY_PUSH (VA, i, X)\n#define VARRAY_PUSH_UINT(VA, X)\t\tVARRAY_PUSH (VA, u, X)\n#define VARRAY_PUSH_LONG(VA, X)\t\tVARRAY_PUSH (VA, l, X)\n#define VARRAY_PUSH_ULONG(VA, X)\tVARRAY_PUSH (VA, ul, X)\n#define VARRAY_PUSH_WIDE_INT(VA, X)\tVARRAY_PUSH (VA, hint, X)\n#define VARRAY_PUSH_UWIDE_INT(VA, X)\tVARRAY_PUSH (VA, uhint, X)\n#define VARRAY_PUSH_GENERIC_PTR(VA, X)\tVARRAY_PUSH (VA, generic, X)\n#define VARRAY_PUSH_CHAR_PTR(VA, X)\tVARRAY_PUSH (VA, cptr, X)\n#define VARRAY_PUSH_RTX(VA, X)\t\tVARRAY_PUSH (VA, rtx, X)\n#define VARRAY_PUSH_RTVEC(VA, X)\tVARRAY_PUSH (VA, rtvec, X)\n#define VARRAY_PUSH_TREE(VA, X)\t\tVARRAY_PUSH (VA, tree, X)\n#define VARRAY_PUSH_BITMAP(VA, X)\tVARRAY_PUSH (VA, bitmap, X)\n#define VARRAY_PUSH_REG(VA, X)\t\tVARRAY_PUSH (VA, reg, X)\n#define VARRAY_PUSH_CONST_EQUIV(VA, X)\tVARRAY_PUSH (VA, const_equiv, X)\n#define VARRAY_PUSH_BB(VA, X)\t\tVARRAY_PUSH (VA, bb, X)\n\n/* Return the last element of VA.  */\n#define VARRAY_TOP(VA, T) VARRAY_CHECK(VA, (VA)->elements_used - 1, T)\n\n#define VARRAY_TOP_CHAR(VA)\t\tVARRAY_TOP (VA, c)\n#define VARRAY_TOP_UCHAR(VA)\t        VARRAY_TOP (VA, uc)\n#define VARRAY_TOP_SHORT(VA)\t        VARRAY_TOP (VA, s)\n#define VARRAY_TOP_USHORT(VA)\t        VARRAY_TOP (VA, us)\n#define VARRAY_TOP_INT(VA)\t\tVARRAY_TOP (VA, i)\n#define VARRAY_TOP_UINT(VA)\t\tVARRAY_TOP (VA, u)\n#define VARRAY_TOP_LONG(VA)\t\tVARRAY_TOP (VA, l)\n#define VARRAY_TOP_ULONG(VA)\t        VARRAY_TOP (VA, ul)\n#define VARRAY_TOP_WIDE_INT(VA)\t        VARRAY_TOP (VA, hint)\n#define VARRAY_TOP_UWIDE_INT(VA)\tVARRAY_TOP (VA, uhint)\n#define VARRAY_TOP_GENERIC_PTR(VA)\tVARRAY_TOP (VA, generic)\n#define VARRAY_TOP_CHAR_PTR(VA)\t\tVARRAY_TOP (VA, cptr)\n#define VARRAY_TOP_RTX(VA)\t\tVARRAY_TOP (VA, rtx)\n#define VARRAY_TOP_RTVEC(VA)\t        VARRAY_TOP (VA, rtvec)\n#define VARRAY_TOP_TREE(VA)\t\tVARRAY_TOP (VA, tree)\n#define VARRAY_TOP_BITMAP(VA)\t        VARRAY_TOP (VA, bitmap)\n#define VARRAY_TOP_REG(VA)\t\tVARRAY_TOP (VA, reg)\n#define VARRAY_TOP_CONST_EQUIV(VA)\tVARRAY_TOP (VA, const_equiv)\n#define VARRAY_TOP_BB(VA)\t\tVARRAY_TOP (VA, bb)\n\n#endif /* ! GCC_VARRAY_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VERSION": {"ttr": 13060, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#ifndef GCC_VERSION_H\n#define GCC_VERSION_H\nextern const char version_string\u00dd\u00a8;\nextern const char bug_report_url\u00dd\u00a8;\n#endif /* ! GCC_VERSION_H */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VMSDBG": {"ttr": 13062, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for the data structures and codes used in VMS debugging.\n   Copyright (C) 2001 Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n#ifndef GCC_VMSDBG_H\n#define GCC_VMSDBG_H 1\n\n/*  We define types and constants used in VMS Debug output.  Note that the\n    structs only approximate the output that is written.  We write the output\n    explicitly, field by field.  This output would only agree with the\n    structs in this file if no padding were done.  The sizes after each\n    struct are the size actually written, which is usually smaller than the\n    size of the struct.  */\n\n/* Header type codes.  */\ntypedef enum _DST_TYPE {DST_K_SOURCE = 155, DST_K_PROLOG = 162,\n\t\t\tDST_K_BLKBEG = 176, DST_K_BLKEND = 177,\n\t\t\tDST_K_LINE_NUM = 185, DST_K_MODBEG = 188,\n\t\t\tDST_K_MODEND = 189, DST_K_RTNBEG = 190,\n\t\t\tDST_K_RTNEND = 191} DST_DTYPE;\n\n/* Header.  */\n\ntypedef struct _DST_HEADER\n{\n  union\n    {\n      unsigned short int dst_w_length;\n      unsigned short int dst_x_length;\n    } dst__header_length;\n  union\n    {\n      ENUM_BITFIELD (_DST_TYPE) dst_w_type : 16;\n      ENUM_BITFIELD (_DST_TYPE) dst_x_type : 16;\n    } dst__header_type;\n} DST_HEADER;\n#define DST_K_DST_HEADER_SIZE sizeof 4\n\n/* Language type codes.  */\ntypedef enum _DST_LANGUAGE {DST_K_FORTRAN = 1, DST_K_C = 7, DST_K_ADA = 9,\n\t\t\t    DST_K_UNKNOWN = 10, DST_K_CXX = 15} DST_LANGUAGE;\n\n/* Module header (a module is the result of a single compilation).  */\n\ntypedef struct _DST_MODULE_BEGIN\n{\n  DST_HEADER dst_a_modbeg_header;\n  struct\n    {\n      unsigned dst_v_modbeg_hide : 1;\n      unsigned dst_v_modbeg_version : 1;\n      unsigned dst_v_modbeg_unused : 6;\n    } dst_b_modbeg_flags;\n  unsigned char dst_b_modbeg_unused;\n  DST_LANGUAGE dst_l_modbeg_language;\n  unsigned short int dst_w_version_major;\n  unsigned short int dst_w_version_minor;\n  unsigned char dst_b_modbeg_name;\n} DST_MODULE_BEGIN;\n#define DST_K_MODBEG_SIZE 15\n\n/* Module trailer.  */\n\ntypedef struct _DST_MB_TRLR\n{\n  unsigned char dst_b_compiler;\n} DST_MB_TRLR;\n\n#define DST_K_MB_TRLR_SIZE 1\n\n#define DST_K_VERSION_MAJOR 1\n#define DST_K_VERSION_MINOR 13\n\ntypedef struct _DST_MODULE_END\n{\n  DST_HEADER dst_a_modend_header;\n} DST_MODULE_END;\n#define DST_K_MODEND_SIZE sizeof 4\n\n/* Routine header.  */\n\ntypedef struct _DST_ROUTINE_BEGIN\n{\n  DST_HEADER dst_a_rtnbeg_header;\n  struct\n    {\n      unsigned dst_v_rtnbeg_unused : 4;\n      unsigned dst_v_rtnbeg_unalloc : 1;\n      unsigned dst_v_rtnbeg_prototype : 1;\n      unsigned dst_v_rtnbeg_inlined : 1;\n      unsigned dst_v_rtnbeg_no_call : 1;\n    } dst_b_rtnbeg_flags;\n  int *dst_l_rtnbeg_address;\n  int *dst_l_rtnbeg_pd_address;\n  unsigned char dst_b_rtnbeg_name;\n} DST_ROUTINE_BEGIN;\n#define DST_K_RTNBEG_SIZE 14\n\n/* Routine trailer */\n\ntypedef struct _DST_ROUTINE_END\n{\n  DST_HEADER dst_a_rtnend_header;\n  char dst_b_rtnend_unused;\n  unsigned int dst_l_rtnend_size;\n} DST_ROUTINE_END;\n#define DST_K_RTNEND_SIZE 9\n\n/* Block header.  */\n\ntypedef struct _DST_BLOCK_BEGIN\n{\n  DST_HEADER dst_a_blkbeg_header;\n  unsigned char dst_b_blkbeg_unused;\n  int *dst_l_blkbeg_address;\n  unsigned char dst_b_blkbeg_name;\n} DST_BLOCK_BEGIN;\n#define DST_K_BLKBEG_SIZE 10\n\n/* Block trailer.  */\n\ntypedef struct _DST_BLOCK_END\n{\n  DST_HEADER dst_a_blkend_header;\n  unsigned char dst_b_blkend_unused;\n  unsigned int dst_l_blkend_size;\n} DST_BLOCK_END;\n#define DST_K_BLKEND_SIZE 9\n\n/* Line number header.  */\n\ntypedef struct _DST_LINE_NUM_HEADER\n{\n  DST_HEADER dst_a_line_num_header;\n} DST_LINE_NUM_HEADER;\n#define DST_K_LINE_NUM_HEADER_SIZE 4\n\n/* PC to Line number correlation.  */\n\ntypedef struct _DST_PCLINE_COMMANDS\n{\n  char dst_b_pcline_command;\n  union\n    {\n      unsigned int dst_l_pcline_unslong;\n      unsigned short int dst_w_pcline_unsword;\n      unsigned char dst_b_pcline_unsbyte;\n    } dst_a_pcline_access_fields;\n} DST_PCLINE_COMMANDS;\n\n/* PC and Line number correlation codes.  */\n\n#define DST_K_PCLINE_COMMANDS_SIZE 5\n#define DST_K_PCLINE_COMMANDS_SIZE_MIN 2\n#define DST_K_PCLINE_COMMANDS_SIZE_MAX 5\n#define DST_K_DELTA_PC_LOW -128\n#define DST_K_DELTA_PC_HIGH 0\n#define DST_K_DELTA_PC_W 1\n#define DST_K_INCR_LINUM 2\n#define DST_K_INCR_LINUM_W 3\n#define DST_K_SET_LINUM 9\n#define DST_K_SET_ABS_PC 16\n#define DST_K_DELTA_PC_L 17\n#define DST_K_INCR_LINUM_L 18\n#define DST_K_SET_LINUM_B 19\n#define DST_K_SET_LINUM_L 20\n\n/* Source file correlation header.  */\n\ntypedef struct _DST_SOURCE_CORR\n{\n  DST_HEADER dst_a_source_corr_header;\n} DST_SOURCE_CORR;\n#define DST_K_SOURCE_CORR_HEADER_SIZE 4\n\n/* Source file correlation codes.  */\n\n#define DST_K_SRC_DECLFILE 1\n#define DST_K_SRC_SETFILE 2\n#define DST_K_SRC_SETREC_L 3\n#define DST_K_SRC_SETREC_W 4\n#define DST_K_SRC_SETLNUM_L 5\n#define DST_K_SRC_SETLNUM_W 6\n#define DST_K_SRC_INCRLNUM_B 7\n#define DST_K_SRC_DEFLINES_W 10\n#define DST_K_SRC_DEFLINES_B 11\n#define DST_K_SRC_FORMFEED 16\n#define DST_K_SRC_MIN_CMD 1\n#define DST_K_SRC_MAX_CMD 16\n\n/* Source file header.  */\n\ntypedef struct _DST_SRC_COMMAND\n{\n  unsigned char dst_b_src_command;\n  union\n    {\n      struct\n\t{\n\t  unsigned char dst_b_src_df_length;\n\t  unsigned char dst_b_src_df_flags;\n\t  unsigned short int dst_w_src_df_fileid;\n#ifdef HAVE_LONG_LONG\n\t  long long dst_q_src_df_rms_cdt;\n#else\n#ifdef HAVE___INT64\n\t  __int64 dst_q_src_df_rms_cdt;\n#endif\n#endif\n\t  unsigned int dst_l_src_df_rms_ebk;\n\t  unsigned short int dst_w_src_df_rms_ffb;\n\t  unsigned char dst_b_src_df_rms_rfo;\n\t  unsigned char dst_b_src_df_filename;\n\t} dst_a_src_decl_src;\n      unsigned int dst_l_src_unslong;\n      unsigned short int dst_w_src_unsword;\n      unsigned char dst_b_src_unsbyte;\n    } dst_a_src_cmd_fields;\n} DST_SRC_COMMAND;\n#define DST_K_SRC_COMMAND_SIZE 21\n\n/* Source file trailer.  */\n\ntypedef struct _DST_SRC_CMDTRLR\n{\n  unsigned char dst_b_src_df_libmodname;\n} DST_SRC_CMDTRLR;\n#define DST_K_SRC_CMDTRLR_SIZE 1\n\n/* Prolog header.  */\n\ntypedef struct _DST_PROLOG\n{\n  DST_HEADER dst_a_prolog_header;\n  unsigned int dst_l_prolog_bkpt_addr;\n} DST_PROLOG;\n#define DST_K_PROLOG_SIZE 8\n\n#endif /* GCC_VMSDBG_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSE": {"ttr": 13065, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions of target machine for GNU compiler.  System/370 version.\n   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for DOS/VSE by Paul Edwards.\n\nThis file is part of GNU CC.\n\nGNU CC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGNU CC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU CC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n#define TARGET_VERSION fprintf (stderr, \" (370/VSE)\");\n\n/* Specify that we're generating code for MVS.  */\n\n#define TARGET_MVS 1\n#define TARGET_HLASM 1\n#define TARGET_EBCDIC 1\n\n/* Specify that we're using the GCC macros */\n\n#define TARGET_PDPMAC 1\n#define STARTFILE_SPEC \"\"\n\n/* Specify that we're using macro prolog/epilog.  */\n\n#define TARGET_MACROS 1\n\n/* Options for the preprocessor for this target machine.  */\n\n#define CPP_SPEC \"-trigraphs\"\n\n/* Names to predefine in the preprocessor for this target machine.  */\n\n#define CPP_PREDEFINES \"-DGCC -Dgcc -DVSE -Dvse -DPDPMAC -Asystem=mvs -Acpu=i370 -Amachine=i370\"\n\n\n#ifdef PUREISO\n#include \"pureiso.h\"\n#endif\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOFF": {"ttr": 13067, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Storage classes in XCOFF object file format designed for DBX's use.\n   This info is from the `Files Reference' manual for IBM's AIX version 3\n   for the RS6000.  */\n\n#define C_GSYM\t\t0x80\n#define C_LSYM\t\t0x81\n#define C_PSYM\t\t0x82\n#define C_RSYM\t\t0x83\n#define C_RPSYM\t\t0x84\n#define C_STSYM\t\t0x85\n\n#define C_BCOMM\t\t0x87\n#define C_ECOML\t\t0x88\n#define C_ECOMM\t\t0x89\n#define C_DECL\t\t0x8c\n#define C_ENTRY\t\t0x8d\n#define C_FUN\t\t0x8e\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XCOFFOUT": {"ttr": 13069, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* XCOFF definitions.  These are needed in dbxout.c, final.c,\n   and xcoffout.h.\n   Copyright (C) 1998, 2000, 2002, 2003\n   Free Software Foundation, Inc.\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2, or (at your option) any later\nversion.\n\nGCC is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to the Free\nSoftware Foundation, 59 Temple Place - Suite 330, Boston, MA\n02111-1307, USA.  */\n\n\n#define ASM_STABS_OP \"\\t.stabx\\t\"\n\n/* Tags and typedefs are C_DECL in XCOFF, not C_LSYM.  */\n\n#define DBX_TYPE_DECL_STABS_CODE N_DECL\n\n/* Use the XCOFF predefined type numbers.  */\n\n/* ??? According to metin, typedef stabx must go in text control section,\n   but he did not make this changes everywhere where such typedef stabx\n   can be emitted, so it is really needed or not?  */\n\n#define DBX_OUTPUT_STANDARD_TYPES(SYMS)\t\t\\\n{\t\t\t\t\t\t\\\n  text_section ();\t\t\t\t\\\n  xcoff_output_standard_types (SYMS);\t\t\\\n}\n\n/* Any type with a negative type index has already been output.  */\n\n#define DBX_TYPE_DEFINED(TYPE) (TYPE_SYMTAB_ADDRESS (TYPE) < 0)\n\n/* Must use N_STSYM for static const variables (those in the text section)\n   instead of N_FUN.  */\n\n#define DBX_STATIC_CONST_VAR_CODE N_STSYM\n\n/* For static variables, output code to define the start of a static block.  */\n\n#define DBX_STATIC_BLOCK_START(ASMFILE,CODE)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if ((CODE) == N_STSYM)\t\t\t\t\t\t\\\n    fprintf ((ASMFILE), \"\\t.bs\\t%s\u00ddRW\u00a8\\n\", xcoff_private_data_section_name);\\\n  else if ((CODE) == N_LCSYM)\t\t\t\t\t\t\\\n    fprintf ((ASMFILE), \"\\t.bs\\t%s\\n\", xcoff_bss_section_name);\t\\\n}\n\n/* For static variables, output code to define the end of a static block.  */\n\n#define DBX_STATIC_BLOCK_END(ASMFILE,CODE)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n  if ((CODE) == N_STSYM || (CODE) == N_LCSYM)\t\t\t\t\\\n    fputs (\"\\t.es\\n\", (ASMFILE));\t\t\t\t\t\\\n}\n\n/* We must use N_RPYSM instead of N_RSYM for register parameters.  */\n\n#define DBX_REGPARM_STABS_CODE N_RPSYM\n\n/* We must use 'R' instead of 'P' for register parameters.  */\n\n#define DBX_REGPARM_STABS_LETTER 'R'\n\n/* Define our own finish symbol function, since xcoff stabs have their\n   own different format.  */\n\n#define DBX_FINISH_SYMBOL(SYM)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n  if (current_sym_addr && current_sym_code == N_FUN)\t\t\\\n    fprintf (asmfile, \"\\\",.\");\t\t\t\t\t\\\n  else\t\t\t\t\t\t\t\t\\\n    fprintf (asmfile, \"\\\",\");\t\t\t\t\t\\\n  /* If we are writing a function name, we must ensure that\t\\\n     there is no storage-class suffix on the name.  */\t\t\\\n  if (current_sym_addr && current_sym_code == N_FUN\t\t\\\n      && GET_CODE (current_sym_addr) == SYMBOL_REF)\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n      const char *_p = XSTR (current_sym_addr, 0);\t\t\\\n      if (*_p == '*')\t\t\t\t\t\t\\\n\tfprintf (asmfile, \"%s\", _p+1);\t\t\t\t\\\n      else\t\t\t\t\t\t\t\\\n\tfor (; *_p != '\u00dd' && *_p; _p++)\t\t\t\t\\\n\t  fprintf (asmfile, \"%c\", *_p);\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  else if (current_sym_addr)\t\t\t\t\t\\\n    output_addr_const (asmfile, current_sym_addr);\t\t\\\n  else if (current_sym_code == N_GSYM)\t\t\t\t\\\n    assemble_name (asmfile, XSTR (XEXP (DECL_RTL (sym), 0), 0)); \\\n  else\t\t\t\t\t\t\t\t\\\n    fprintf (asmfile, \"%d\", current_sym_value);\t\t\t\\\n  fprintf (asmfile, \",%d,0\\n\", stab_to_sclass (current_sym_code)); \\\n}\n\n/* These are IBM XCOFF extensions we need to reference in dbxout.c\n   and xcoffout.c.  */\n\n/* AIX XCOFF uses this for typedefs.  This can have any value, since it is\n   only used for translation into a C_DECL storage class.  */\n#ifndef N_DECL\n#define N_DECL 0x8c\n#endif\n/* AIX XCOFF uses this for parameters passed in registers.  This can have\n   any value, since it is only used for translation into a C_RPSYM storage\n   class.  */\n#ifndef N_RPSYM\n#define N_RPSYM 0x8e\n#endif\n\n/* Name of the current include file.  */\n\nextern const char *xcoff_current_include_file;\n\n/* Names of bss and data sections.  These should be unique names for each\n   compilation unit.  */\n\nextern char *xcoff_bss_section_name;\nextern char *xcoff_private_data_section_name;\nextern char *xcoff_read_only_section_name;\n\n/* Last source file name mentioned in a NOTE insn.  */\n\nextern const char *xcoff_lastfile;\n\n/* Don't write out path name for main source file.  */\n#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE,FILENAME)\n\n/* Write out main source file name using \".file\" rather than \".stabs\".\n   We don't actually do this here, because the assembler gets confused if there\n   is more than one .file directive.  rs6000_xcoff_file_start is already\n   emitting a .file directory, so we don't output one here also.\n   Initialize xcoff_lastfile.  */\n#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(FILE,FILENAME) \\\n  xcoff_lastfile = (FILENAME)\n\n/* If we are still in an include file, its end must be marked.  */\n#define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\\\n{\t\t\t\t\t\t\t\\\n  if (xcoff_current_include_file)\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      fputs (\"\\t.ei\\t\", (FILE));\t\t\t\\\n      output_quoted_string ((FILE), xcoff_current_include_file);\t\\\n      putc ('\\n', (FILE));\t\t\t\t\\\n      xcoff_current_include_file = NULL;\t\t\\\n    }\t\t\t\t\t\t\t\\\n}\n\n/* .stabx has the type in a different place.  */\n#if 0  /* Do not emit any marker for XCOFF until assembler allows XFT_CV.  */\n#define DBX_OUTPUT_GCC_MARKER(FILE) \\\n  fprintf ((FILE), \"%s\\\"%s\\\",0,%d,0\\n\", ASM_STABS_OP, STABS_GCC_MARKER, \\\n\t   stab_to_sclass (N_GSYM))\n#else\n#define DBX_OUTPUT_GCC_MARKER(FILE)\n#endif\n\n/* Do not break .stabs pseudos into continuations.  */\n#define DBX_CONTIN_LENGTH 0\n\n/* Don't try to use the `x' type-cross-reference character in DBX data.\n   Also has the consequence of putting each struct, union or enum\n   into a separate .stabs, containing only cross-refs to the others.  */\n#define DBX_NO_XREFS\n\n/* We must put stabs in the text section.  If we don't the assembler\n   won't handle them correctly; it will sometimes put stabs where gdb\n   can't find them.  */\n\n#define DEBUG_SYMS_TEXT\n\n/* Prototype functions in xcoffout.c.  */\n\nextern int stab_to_sclass (int);\n#ifdef BUFSIZ\nextern void xcoffout_begin_prologue (unsigned int, const char *);\nextern void xcoffout_begin_block (unsigned, unsigned);\nextern void xcoffout_end_epilogue (unsigned int, const char *);\nextern void xcoffout_end_function (unsigned int);\nextern void xcoffout_end_block (unsigned, unsigned);\n#endif /* BUFSIZ */\n\n#ifdef TREE_CODE\nextern void xcoff_output_standard_types (tree);\n#ifdef BUFSIZ\nextern void xcoffout_declare_function (FILE *, tree, const char *);\n#endif /* BUFSIZ */\n#endif /* TREE_CODE */\n\n#ifdef RTX_CODE\n#ifdef BUFSIZ\nextern void xcoffout_source_line (unsigned int, const char *);\n#endif /* BUFSIZ */\n#endif /* RTX_CODE */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM@MVS": {"ttr": 13072, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Configuration for GNU C-compiler for System/370.\n   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* #defines that need visibility everywhere.  */\n\n/*#define FALSE 0\n#define TRUE 1*/\n\n/* This describes the machine the compiler is hosted on.  */\n\n/*#define HOST_BITS_PER_CHAR\t8\n#define HOST_BITS_PER_SHORT\t16\n#define HOST_BITS_PER_INT\t32\n#define HOST_BITS_PER_LONG\t32 */\n#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n#define HOST_EBCDIC\t\t1\n\n#define USG\n#ifndef MVS\n#define MVS\n#endif\n\n/* Arguments to use with `exit'.  */\n\n/*#define SUCCESS_EXIT_CODE\t0\n#define FATAL_EXIT_CODE\t\t12*/\n\n#define NO_DBX_FORMAT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XM@OE": {"ttr": 13074, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Configuration for GNU C-compiler for System/370.\n   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n   Contributed by Jan Stein (jan@cd.chalmers.se).\n   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n\nThis file is part of GCC.\n\nGCC is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version.\n\nGCC is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GCC; see the file COPYING.  If not, write to\nthe Free Software Foundation, 59 Temple Place - Suite 330,\nBoston, MA 02111-1307, USA.  */\n\n/* #defines that need visibility everywhere.  */\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n#ifndef TRUE\n#define TRUE 1\n#endif\n\n#define USE_STDARGS 1\n#define USE_PROTOTYPES 1\n\n/* This describes the machine the compiler is hosted on.  */\n\n#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n#define HOST_EBCDIC\t\t1\n\n#define ONLY_INT_FIELDS\t\t1\n\n#define USG\n\n/* Arguments to use with `exit'.  */\n\n#define SUCCESS_EXIT_CODE\t0\n#define FATAL_EXIT_CODE\t\t1\n\n#define NO_DBX_FORMAT\n\n/* The mmap function on OS/390 is broken, bypass */\n\n#define MMAP_THRESHOLD 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREGEX": {"ttr": 13076, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* This file redefines all regex external names before including\n   a renamed copy of glibc's regex.h.  */\n\n#ifndef _XREGEX_H\n#define _XREGEX_H 1\n\n#  define regfree xregfree\n#  define regexec xregexec\n#  define regcomp xregcomp\n#  define regerror xregerror\n#  define re_set_registers xre_set_registers\n#  define re_match_2 xre_match_2\n#  define re_match xre_match\n#  define re_search xre_search\n#  define re_compile_pattern xre_compile_pattern\n#  define re_set_syntax xre_set_syntax\n#  define re_search_2 xre_search_2\n#  define re_compile_fastmap xre_compile_fastmap\n#  define re_syntax_options xre_syntax_options\n#  define re_max_failures xre_max_failures\n\n#  define _REGEX_RE_COMP\n#  define re_comp xre_comp\n#  define re_exec xre_exec\n\n#include \"xregex2.h\"\n\n#endif /* xregex.h */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREGEX2": {"ttr": 13078, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Definitions for data structures and routines for the regular\n   expression library, version 0.12.\n   Copyright (C) 1985,1989-1993,1995-1998, 2000 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.  Its master source is NOT part of\n   the C library, however.  The master source lives in /gd/gnu/lib.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n   02111-1307 USA.  */\n\n#ifndef _REGEX_H\n#define _REGEX_H 1\n\n/* Allow the use in C++ code.  */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* POSIX says that <sys/types.h> must be included (by the caller) before\n   <regex.h>.  */\n\n#if !defined _POSIX_C_SOURCE && !defined _POSIX_SOURCE && defined VMS\n/* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it\n   should be there.  */\n# include <stddef.h>\n#endif\n\n/* The following two types have to be signed and unsigned integer type\n   wide enough to hold a value of a pointer.  For most ANSI compilers\n   ptrdiff_t and size_t should be likely OK.  Still size of these two\n   types is 2 for Microsoft C.  Ugh... */\ntypedef long int s_reg_t;\ntypedef unsigned long int active_reg_t;\n\n/* The following bits are used to determine the regexp syntax we\n   recognize.  The set/not-set meanings are chosen so that Emacs syntax\n   remains the value 0.  The bits are given in alphabetical order, and\n   the definitions shifted by one from the previous bit; thus, when we\n   add or remove a bit, only one other definition need change.  */\ntypedef unsigned long int reg_syntax_t;\n\n/* If this bit is not set, then \\ inside a bracket expression is literal.\n   If set, then such a \\ quotes the following character.  */\n#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)\n\n/* If this bit is not set, then + and ? are operators, and \\+ and \\? are\n     literals.\n   If set, then \\+ and \\? are operators and + and ? are literals.  */\n#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)\n\n/* If this bit is set, then character classes are supported.  They are:\n     \u00dd:alpha:\u00a8, \u00dd:upper:\u00a8, \u00dd:lower:\u00a8,  \u00dd:digit:\u00a8, \u00dd:alnum:\u00a8, \u00dd:xdigit:\u00a8,\n     \u00dd:space:\u00a8, \u00dd:print:\u00a8, \u00dd:punct:\u00a8, \u00dd:graph:\u00a8, and \u00dd:cntrl:\u00a8.\n   If not set, then character classes are not supported.  */\n#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)\n\n/* If this bit is set, then \u00ac and $ are always anchors (outside bracket\n     expressions, of course).\n   If this bit is not set, then it depends:\n        \u00ac  is an anchor if it is at the beginning of a regular\n           expression or after an open-group or an alternation operator;\n        $  is an anchor if it is at the end of a regular expression, or\n           before a close-group or an alternation operator.\n\n   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because\n   POSIX draft 11.2 says that * etc. in leading positions is undefined.\n   We already implemented a previous draft which made those constructs\n   invalid, though, so we haven't changed the code back.  */\n#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)\n\n/* If this bit is set, then special characters are always special\n     regardless of where they are in the pattern.\n   If this bit is not set, then special characters are special only in\n     some contexts; otherwise they are ordinary.  Specifically,\n     * + ? and intervals are only special when not after the beginning,\n     open-group, or alternation operator.  */\n#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)\n\n/* If this bit is set, then *, +, ?, and { cannot be first in an re or\n     immediately after an alternation or begin-group operator.  */\n#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)\n\n/* If this bit is set, then . matches newline.\n   If not set, then it doesn't.  */\n#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)\n\n/* If this bit is set, then . doesn't match NUL.\n   If not set, then it does.  */\n#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)\n\n/* If this bit is set, nonmatching lists \u00dd\u00ac...\u00a8 do not match newline.\n   If not set, they do.  */\n#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)\n\n/* If this bit is set, either \\{...\\} or {...} defines an\n     interval, depending on RE_NO_BK_BRACES.\n   If not set, \\{, \\}, {, and } are literals.  */\n#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)\n\n/* If this bit is set, +, ? and | aren't recognized as operators.\n   If not set, they are.  */\n#define RE_LIMITED_OPS (RE_INTERVALS << 1)\n\n/* If this bit is set, newline is an alternation operator.\n   If not set, newline is literal.  */\n#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)\n\n/* If this bit is set, then `{...}' defines an interval, and \\{ and \\}\n     are literals.\n  If not set, then `\\{...\\}' defines an interval.  */\n#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)\n\n/* If this bit is set, (...) defines a group, and \\( and \\) are literals.\n   If not set, \\(...\\) defines a group, and ( and ) are literals.  */\n#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)\n\n/* If this bit is set, then \\<digit> matches <digit>.\n   If not set, then \\<digit> is a back-reference.  */\n#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)\n\n/* If this bit is set, then | is an alternation operator, and \\| is literal.\n   If not set, then \\| is an alternation operator, and | is literal.  */\n#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)\n\n/* If this bit is set, then an ending range point collating higher\n     than the starting range point, as in \u00ddz-a\u00a8, is invalid.\n   If not set, then when ending range point collates higher than the\n     starting range point, the range is ignored.  */\n#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)\n\n/* If this bit is set, then an unmatched ) is ordinary.\n   If not set, then an unmatched ) is invalid.  */\n#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)\n\n/* If this bit is set, succeed as soon as we match the whole pattern,\n   without further backtracking.  */\n#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)\n\n/* If this bit is set, do not process the GNU regex operators.\n   If not set, then the GNU regex operators are recognized. */\n#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)\n\n/* If this bit is set, turn on internal regex debugging.\n   If not set, and debugging was on, turn it off.\n   This only works if regex.c is compiled -DDEBUG.\n   We define this bit always, so that all that's needed to turn on\n   debugging is to recompile regex.c; the calling code can always have\n   this bit set, and it won't affect anything in the normal case. */\n#define RE_DEBUG (RE_NO_GNU_OPS << 1)\n\n/* If this bit is set, a syntactically invalid interval is treated as\n   a string of ordinary characters.  For example, the ERE 'a{1' is\n   treated as 'a\\{1'.  */\n#define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)\n\n/* This global variable defines the particular regexp syntax to use (for\n   some interfaces).  When a regexp is compiled, the syntax used is\n   stored in the pattern buffer, so changing this does not affect\n   already-compiled regexps.  */\nextern reg_syntax_t re_syntax_options;\n\n/* Define combinations of the above bits for the standard possibilities.\n   (The \u00dd\u00dd\u00dd comments delimit what gets put into the Texinfo file, so\n   don't delete them!)  */\n/* \u00dd\u00dd\u00ddbegin syntaxes\u00a8\u00a8\u00a8 */\n#define RE_SYNTAX_EMACS 0\n\n#define RE_SYNTAX_AWK\t\t\t\t\t\t\t\\\n  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL\t\t\t\\\n   | RE_NO_BK_PARENS              | RE_NO_BK_REFS\t\t\t\\\n   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES\t\t\t\\\n   | RE_DOT_NEWLINE\t\t  | RE_CONTEXT_INDEP_ANCHORS\t\t\\\n   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)\n\n#define RE_SYNTAX_GNU_AWK\t\t\t\t\t\t\\\n  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)\t\\\n   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS))\n\n#define RE_SYNTAX_POSIX_AWK \t\t\t\t\t\t\\\n  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS\t\t\\\n   | RE_INTERVALS\t    | RE_NO_GNU_OPS)\n\n#define RE_SYNTAX_GREP\t\t\t\t\t\t\t\\\n  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES\t\t\t\t\\\n   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS\t\t\t\t\\\n   | RE_NEWLINE_ALT)\n\n#define RE_SYNTAX_EGREP\t\t\t\t\t\t\t\\\n  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE\t\t\t\\\n   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS\t\t\t\t\\\n   | RE_NO_BK_VBAR)\n\n#define RE_SYNTAX_POSIX_EGREP\t\t\t\t\t\t\\\n  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES\t\t\t\\\n   | RE_INVALID_INTERVAL_ORD)\n\n/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */\n#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC\n\n#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC\n\n/* Syntax bits common to both basic and extended POSIX regex syntax.  */\n#define _RE_SYNTAX_POSIX_COMMON\t\t\t\t\t\t\\\n  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL\t\t\\\n   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)\n\n#define RE_SYNTAX_POSIX_BASIC\t\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)\n\n/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes\n   RE_LIMITED_OPS, i.e., \\? \\+ \\| are not recognized.  Actually, this\n   isn't minimal, since other operators, such as \\`, aren't disabled.  */\n#define RE_SYNTAX_POSIX_MINIMAL_BASIC\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)\n\n#define RE_SYNTAX_POSIX_EXTENDED\t\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES\t\t\t\t\\\n   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR\t\t\t\t\\\n   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)\n\n/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is\n   removed and RE_NO_BK_REFS is added.  */\n#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED\t\t\t\t\\\n  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS\t\t\t\\\n   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES\t\t\t\t\\\n   | RE_NO_BK_PARENS        | RE_NO_BK_REFS\t\t\t\t\\\n   | RE_NO_BK_VBAR\t    | RE_UNMATCHED_RIGHT_PAREN_ORD)\n/* \u00dd\u00dd\u00ddend syntaxes\u00a8\u00a8\u00a8 */\n\n/* Maximum number of duplicates an interval can allow.  Some systems\n   (erroneously) define this in other header files, but we want our\n   value, so remove any previous define.  */\n#ifdef RE_DUP_MAX\n# undef RE_DUP_MAX\n#endif\n/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */\n#define RE_DUP_MAX (0x7fff)\n\n\n/* POSIX `cflags' bits (i.e., information for `regcomp').  */\n\n/* If this bit is set, then use extended regular expression syntax.\n   If not set, then use basic regular expression syntax.  */\n#define REG_EXTENDED 1\n\n/* If this bit is set, then ignore case when matching.\n   If not set, then case is significant.  */\n#define REG_ICASE (REG_EXTENDED << 1)\n\n/* If this bit is set, then anchors do not match at newline\n     characters in the string.\n   If not set, then anchors do match at newlines.  */\n#define REG_NEWLINE (REG_ICASE << 1)\n\n/* If this bit is set, then report only success or fail in regexec.\n   If not set, then returns differ between not matching and errors.  */\n#define REG_NOSUB (REG_NEWLINE << 1)\n\n\n/* POSIX `eflags' bits (i.e., information for regexec).  */\n\n/* If this bit is set, then the beginning-of-line operator doesn't match\n     the beginning of the string (presumably because it's not the\n     beginning of a line).\n   If not set, then the beginning-of-line operator does match the\n     beginning of the string.  */\n#define REG_NOTBOL 1\n\n/* Like REG_NOTBOL, except for the end-of-line.  */\n#define REG_NOTEOL (1 << 1)\n\n\n/* If any error codes are removed, changed, or added, update the\n   `re_error_msg' table in regex.c.  */\ntypedef enum\n{\n#ifdef _XOPEN_SOURCE\n  REG_ENOSYS = -1,\t/* This will never happen for this implementation.  */\n#endif\n\n  REG_NOERROR = 0,\t/* Success.  */\n  REG_NOMATCH,\t\t/* Didn't find a match (for regexec).  */\n\n  /* POSIX regcomp return error codes.  (In the order listed in the\n     standard.)  */\n  REG_BADPAT,\t\t/* Invalid pattern.  */\n  REG_ECOLLATE,\t\t/* Not implemented.  */\n  REG_ECTYPE,\t\t/* Invalid character class name.  */\n  REG_EESCAPE,\t\t/* Trailing backslash.  */\n  REG_ESUBREG,\t\t/* Invalid back reference.  */\n  REG_EBRACK,\t\t/* Unmatched left bracket.  */\n  REG_EPAREN,\t\t/* Parenthesis imbalance.  */\n  REG_EBRACE,\t\t/* Unmatched \\{.  */\n  REG_BADBR,\t\t/* Invalid contents of \\{\\}.  */\n  REG_ERANGE,\t\t/* Invalid range end.  */\n  REG_ESPACE,\t\t/* Ran out of memory.  */\n  REG_BADRPT,\t\t/* No preceding re for repetition op.  */\n\n  /* Error codes we've added.  */\n  REG_EEND,\t\t/* Premature end.  */\n  REG_ESIZE,\t\t/* Compiled pattern bigger than 2\u00ac16 bytes.  */\n  REG_ERPAREN\t\t/* Unmatched ) or \\); not returned from regcomp.  */\n} reg_errcode_t;\n\n/* This data structure represents a compiled pattern.  Before calling\n   the pattern compiler, the fields `buffer', `allocated', `fastmap',\n   `translate', and `no_sub' can be set.  After the pattern has been\n   compiled, the `re_nsub' field is available.  All other fields are\n   private to the regex routines.  */\n\n#ifndef RE_TRANSLATE_TYPE\n# define RE_TRANSLATE_TYPE char *\n#endif\n\nstruct re_pattern_buffer\n{\n/* \u00dd\u00dd\u00ddbegin pattern_buffer\u00a8\u00a8\u00a8 */\n\t/* Space that holds the compiled pattern.  It is declared as\n          `unsigned char *' because its elements are\n           sometimes used as array indexes.  */\n  unsigned char *buffer;\n\n\t/* Number of bytes to which `buffer' points.  */\n  unsigned long int allocated;\n\n\t/* Number of bytes actually used in `buffer'.  */\n  unsigned long int used;\n\n        /* Syntax setting with which the pattern was compiled.  */\n  reg_syntax_t syntax;\n\n        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses\n           the fastmap, if there is one, to skip over impossible\n           starting points for matches.  */\n  char *fastmap;\n\n        /* Either a translate table to apply to all characters before\n           comparing them, or zero for no translation.  The translation\n           is applied to a pattern when it is compiled and to a string\n           when it is matched.  */\n  RE_TRANSLATE_TYPE translate;\n\n\t/* Number of subexpressions found by the compiler.  */\n  size_t re_nsub;\n\n        /* Zero if this pattern cannot match the empty string, one else.\n           Well, in truth it's used only in `re_search_2', to see\n           whether or not we should use the fastmap, so we don't set\n           this absolutely perfectly; see `re_compile_fastmap' (the\n           `duplicate' case).  */\n  unsigned can_be_null : 1;\n\n        /* If REGS_UNALLOCATED, allocate space in the `regs' structure\n             for `max (RE_NREGS, re_nsub + 1)' groups.\n           If REGS_REALLOCATE, reallocate space if necessary.\n           If REGS_FIXED, use what's there.  */\n#define REGS_UNALLOCATED 0\n#define REGS_REALLOCATE 1\n#define REGS_FIXED 2\n  unsigned regs_allocated : 2;\n\n        /* Set to zero when `regex_compile' compiles a pattern; set to one\n           by `re_compile_fastmap' if it updates the fastmap.  */\n  unsigned fastmap_accurate : 1;\n\n        /* If set, `re_match_2' does not return information about\n           subexpressions.  */\n  unsigned no_sub : 1;\n\n        /* If set, a beginning-of-line anchor doesn't match at the\n           beginning of the string.  */\n  unsigned not_bol : 1;\n\n        /* Similarly for an end-of-line anchor.  */\n  unsigned not_eol : 1;\n\n        /* If true, an anchor at a newline matches.  */\n  unsigned newline_anchor : 1;\n\n/* \u00dd\u00dd\u00ddend pattern_buffer\u00a8\u00a8\u00a8 */\n};\n\ntypedef struct re_pattern_buffer regex_t;\n\n/* Type for byte offsets within the string.  POSIX mandates this.  */\ntypedef int regoff_t;\n\n\n/* This is the structure we store register match data in.  See\n   regex.texinfo for a full description of what registers match.  */\nstruct re_registers\n{\n  unsigned num_regs;\n  regoff_t *start;\n  regoff_t *end;\n};\n\n\n/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,\n   `re_match_2' returns information about at least this many registers\n   the first time a `regs' structure is passed.  */\n#ifndef RE_NREGS\n# define RE_NREGS 30\n#endif\n\n\n/* POSIX specification for registers.  Aside from the different names than\n   `re_registers', POSIX uses an array of structures, instead of a\n   structure of arrays.  */\ntypedef struct\n{\n  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */\n  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */\n} regmatch_t;\n\n/* Declarations for routines.  */\n\n/* To avoid duplicating every routine declaration -- once with a\n   prototype (if we are ANSI), and once without (if we aren't) -- we\n   use the following macro to declare argument types.  This\n   unfortunately clutters up the declarations a bit, but I think it's\n   worth it.  */\n\n#if __STDC__\n\n# define _RE_ARGS(args) args\n\n#else /* not __STDC__ */\n\n# define _RE_ARGS(args) ()\n\n#endif /* not __STDC__ */\n\n/* Sets the current default syntax to SYNTAX, and return the old syntax.\n   You can also simply assign to the `re_syntax_options' variable.  */\nextern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));\n\n/* Compile the regular expression PATTERN, with length LENGTH\n   and syntax given by the global `re_syntax_options', into the buffer\n   BUFFER.  Return NULL if successful, and an error string if not.  */\nextern const char *re_compile_pattern\n  _RE_ARGS ((const char *pattern, size_t length,\n             struct re_pattern_buffer *buffer));\n\n\n/* Compile a fastmap for the compiled pattern in BUFFER; used to\n   accelerate searches.  Return 0 if successful and -2 if was an\n   internal error.  */\nextern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));\n\n\n/* Search in the string STRING (with length LENGTH) for the pattern\n   compiled into BUFFER.  Start searching at position START, for RANGE\n   characters.  Return the starting position of the match, -1 for no\n   match, or -2 for an internal error.  Also return register\n   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */\nextern int re_search\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n            int length, int start, int range, struct re_registers *regs));\n\n\n/* Like `re_search', but search in the concatenation of STRING1 and\n   STRING2.  Also, stop searching at index START + STOP.  */\nextern int re_search_2\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n             int length1, const char *string2, int length2,\n             int start, int range, struct re_registers *regs, int stop));\n\n\n/* Like `re_search', but return how many characters in STRING the regexp\n   in BUFFER matched, starting at position START.  */\nextern int re_match\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,\n             int length, int start, struct re_registers *regs));\n\n\n/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */\nextern int re_match_2\n  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,\n             int length1, const char *string2, int length2,\n             int start, struct re_registers *regs, int stop));\n\n\n/* Set REGS to hold NUM_REGS registers, storing them in STARTS and\n   ENDS.  Subsequent matches using BUFFER and REGS will use this memory\n   for recording register information.  STARTS and ENDS must be\n   allocated with malloc, and must each be at least `NUM_REGS * sizeof\n   (regoff_t)' bytes long.\n\n   If NUM_REGS == 0, then subsequent matches should allocate their own\n   register data.\n\n   Unless this function is called, the first search or match using\n   PATTERN_BUFFER will allocate its own register data, without\n   freeing the old data.  */\nextern void re_set_registers\n  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,\n             unsigned num_regs, regoff_t *starts, regoff_t *ends));\n\n#if defined _REGEX_RE_COMP || defined _LIBC\n# ifndef _CRAY\n/* 4.2 bsd compatibility.  */\nextern char *re_comp _RE_ARGS ((const char *));\nextern int re_exec _RE_ARGS ((const char *));\n# endif\n#endif\n\n/* GCC 2.95 and later have \"__restrict\"; C99 compilers have\n   \"restrict\", and \"configure\" may have defined \"restrict\".  */\n#ifndef __restrict\n# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))\n#  if defined restrict || 199901L <= __STDC_VERSION__\n#   define __restrict restrict\n#  else\n#   define __restrict\n#  endif\n# endif\n#endif\n\n#define regex_restrict_arr\n\n/* GCC 3.1 and later support declaring arrays as non-overlapping\n   using the syntax array_name\u00ddrestrict\u00a8  */\n#ifndef __restrict_arr\n# if ! (3 < __GNUC__ || (3 == __GNUC__ && 1 <= __GNUC_MINOR__)) || defined (__GNUG__)\n#  define __restrict_arr\n# else\n#  define __restrict_arr __restrict\n# endif\n#endif\n\n/* POSIX compatibility.  */\nextern int regcomp _RE_ARGS ((regex_t *__restrict __preg,\n\t\t\t      const char *__restrict __pattern,\n\t\t\t      int __cflags));\n\nextern int regexec _RE_ARGS ((const regex_t *__restrict __preg,\n\t\t\t      const char *__restrict string, size_t __nmatch,\n\t\t\t      regmatch_t __pmatch\u00ddregex_restrict_arr\u00a8,\n\t\t\t      int __eflags));\n\nextern size_t regerror _RE_ARGS ((int __errcode, const regex_t *__preg,\n\t\t\t\t  char *__errbuf, size_t __errbuf_size));\n\nextern void regfree _RE_ARGS ((regex_t *__preg));\n\n\n#ifdef __cplusplus\n}\n#endif\t/* C++ */\n\n#endif /* regex.h */\n\n/*\nLocal variables:\nmake-backup-files: t\nversion-control: t\ntrim-versions-without-asking: nil\nEnd:\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XTENSA@C": {"ttr": 13316, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* Xtensa configuration settings.\n   Copyright (C) 2001,2002,2003 Free Software Foundation, Inc.\n   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n\n#ifndef XTENSA_CONFIG_H\n#define XTENSA_CONFIG_H\n\n/* The macros defined here match those with the same names in the Xtensa\n   compile-time HAL (Hardware Abstraction Layer).  Please refer to the\n   Xtensa System Software Reference Manual for documentation of these\n   macros.  */\n\n#undef XCHAL_HAVE_BE\n#define XCHAL_HAVE_BE\t\t\t1\n\n#undef XCHAL_HAVE_DENSITY\n#define XCHAL_HAVE_DENSITY\t\t1\n\n#undef XCHAL_HAVE_CONST16\n#define XCHAL_HAVE_CONST16\t\t0\n\n#undef XCHAL_HAVE_ABS\n#define XCHAL_HAVE_ABS\t\t\t1\n\n#undef XCHAL_HAVE_ADDX\n#define XCHAL_HAVE_ADDX\t\t\t1\n\n#undef XCHAL_HAVE_L32R\n#define XCHAL_HAVE_L32R\t\t\t1\n\n#undef XCHAL_HAVE_MAC16\n#define XCHAL_HAVE_MAC16\t\t0\n\n#undef XCHAL_HAVE_MUL16\n#define XCHAL_HAVE_MUL16\t\t0\n\n#undef XCHAL_HAVE_MUL32\n#define XCHAL_HAVE_MUL32\t\t0\n\n#undef XCHAL_HAVE_DIV32\n#define XCHAL_HAVE_DIV32\t\t0\n\n#undef XCHAL_HAVE_NSA\n#define XCHAL_HAVE_NSA\t\t\t1\n\n#undef XCHAL_HAVE_MINMAX\n#define XCHAL_HAVE_MINMAX\t\t0\n\n#undef XCHAL_HAVE_SEXT\n#define XCHAL_HAVE_SEXT\t\t\t0\n\n#undef XCHAL_HAVE_LOOPS\n#define XCHAL_HAVE_LOOPS\t\t1\n\n#undef XCHAL_HAVE_BOOLEANS\n#define XCHAL_HAVE_BOOLEANS\t\t0\n\n#undef XCHAL_HAVE_FP\n#define XCHAL_HAVE_FP\t\t\t0\n\n#undef XCHAL_HAVE_FP_DIV\n#define XCHAL_HAVE_FP_DIV\t\t0\n\n#undef XCHAL_HAVE_FP_RECIP\n#define XCHAL_HAVE_FP_RECIP\t\t0\n\n#undef XCHAL_HAVE_FP_SQRT\n#define XCHAL_HAVE_FP_SQRT\t\t0\n\n#undef XCHAL_HAVE_FP_RSQRT\n#define XCHAL_HAVE_FP_RSQRT\t\t0\n\n#undef XCHAL_HAVE_WINDOWED\n#define XCHAL_HAVE_WINDOWED\t\t1\n\n\n#undef XCHAL_ICACHE_SIZE\n#define XCHAL_ICACHE_SIZE\t\t8192\n\n#undef XCHAL_DCACHE_SIZE\n#define XCHAL_DCACHE_SIZE\t\t8192\n\n#undef XCHAL_ICACHE_LINESIZE\n#define XCHAL_ICACHE_LINESIZE\t\t16\n\n#undef XCHAL_DCACHE_LINESIZE\n#define XCHAL_DCACHE_LINESIZE\t\t16\n\n#undef XCHAL_ICACHE_LINEWIDTH\n#define XCHAL_ICACHE_LINEWIDTH\t\t4\n\n#undef XCHAL_DCACHE_LINEWIDTH\n#define XCHAL_DCACHE_LINEWIDTH\t\t4\n\n#undef XCHAL_DCACHE_IS_WRITEBACK\n#define XCHAL_DCACHE_IS_WRITEBACK\t0\n\n\n#undef XCHAL_HAVE_MMU\n#define XCHAL_HAVE_MMU\t\t\t1\n\n#undef XCHAL_MMU_MIN_PTE_PAGE_SIZE\n#define XCHAL_MMU_MIN_PTE_PAGE_SIZE\t12\n\n\n#undef XCHAL_HAVE_DEBUG\n#define XCHAL_HAVE_DEBUG\t\t1\n\n#undef XCHAL_NUM_IBREAK\n#define XCHAL_NUM_IBREAK\t\t2\n\n#undef XCHAL_NUM_DBREAK\n#define XCHAL_NUM_DBREAK\t\t2\n\n#undef XCHAL_DEBUGLEVEL\n#define XCHAL_DEBUGLEVEL\t\t4\n\n\n#undef XCHAL_EXTRA_SA_SIZE\n#define XCHAL_EXTRA_SA_SIZE\t\t0\n\n#undef XCHAL_EXTRA_SA_ALIGN\n#define XCHAL_EXTRA_SA_ALIGN\t\t1\n\n#endif /* !XTENSA_CONFIG_H */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT853/CBT.V500.FILE853.PDS/GCCINC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT853/CBT.V500.FILE853.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}