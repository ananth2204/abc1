{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013022000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 128212266, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 12000, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE853.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 128212266, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 128212266, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE853.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 12000, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x07\\xfe\\x14'", "DS1TRBAL": "b'\\x14R'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xc8'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xc8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x06v\\x00\\x08\\x06\\xf8\\x00\\x07\\x07\\x9e'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x06\\xf8\\x00\\x08\\x06\\xfe\\x00\\x0e\\x00a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00Q\\x01\\x193_\\x01\\x193_\\x08\\x04\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-12-01T00:00:00", "modifydate": "2019-12-01T08:04:51", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  853\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE853\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    7280    PO\n\n   PDS117I 27 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,226,574 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/01/19    08:04:50    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00!\\x00!\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "GCC346"}, "text": "This PDS contains a stack of XMITed PDSes. They all\nneed to be restored via the RECEIVE command, by\nrunning the job XMIT6 (after reading the comments\nin it) or similar. You probably want to create two\naliases - one for GCC (the compiler proper), and one\nfor PDPCLIB (the C runtime library) before doing so.\nXMIT1 provides an example of that.\n\nAfter restoration, you may wish to run GCC.JCL(EXAMPLE)\nto compile an example C program, after the usual site\ncustomizations.\n\nFor further information, please see GCC.DOC(GCCMVS)\nafter the restoration.\n\nNote that XMIT2-5 and 7 do not need to be run, and are\nonly for reference purposes, for people who received\nthe XMIT as a zip file on the PC.\n\nYou may wish to delete the one or two XMIT files\nthat were created during this process, as they\nare only useful when trying to transport GCCMVS.\nXMIT8 is provided for that purpose.\n\nNote that the \"GCC\" module is a 31-bit version of the\ncompiler, so if you are running MVS/370 it won't work,\nand you should instead use \"GCC370\" which is a 24-bit\nmodule. The 31-bit version should work fine as-is on\nz/OS, OS/390, MVS/XA and MVS/380. Also note that\nalthough the compiler is 31-bit, by default it produces\n24-bit modules. If you wish to change this to 31-bit,\nthen after installation read GCC.DOC(GCCMVS) where\nthere are instructions for running STAGE4.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$GCC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x11\\x15\\x7f\\x01\\x11\\x15\\x7f\\x14\\x18\\x00>\\x00>\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-06T00:00:00", "modifydate": "2011-06-06T14:18:29", "lines": 62, "newlines": 62, "modlines": 0, "user": "SBGOLOB"}, "text": "*Welcome to GCCMVS (GCC for MVS, CMS and VSE) - a freely available\n31-bit mainframe compiler*\n\nGCCMVS is a standalone compiler designed to run on MVS (from z/OS all\nthe way back to MVS 3.8j, and probably beyond to PCP, but no-one has\ntested (or at least reported) back that far) or CMS (z/VM and\npredecessors) and VSE (z/VSE back to DOS/VS R34). It consists of two\ndistinct parts. Firstly, the standard GCC 3.2.3 compiler with some\nrequired code changes for MVS and CMS. Secondly, PDPCLIB, which is a C\nruntime library required for GCC to be able to run, and also for your\nown programs to be able to run. Both things are required, and both\nthings are what is dubbed \"GCCMVS\". Note that the licence for the GCC\npart is GPL while PDPCLIB is public domain (explicit PD notice). Because\nPDPCLIB is pure public domain, it means that there are no licencing\nrestrictions on executables you produce yourself. ie commercial use is\nfine, and you can even sell PDPCLIB (original or modified, including\nproprietary modifications, with or without source) if you find a market.\n\nThe source code and executables for GCCMVS can be found at sourceforge\n<http://sourceforge.net/projects/gccmvs>, in the \"downloads\" link. There\nis also an old port of GCCMVS to MUSIC/SP which is available here\n<http://webpages.mcgill.ca/staff/group3/dedwar1/web>. Unfortunately the\nauthor of the MUSIC/SP version (Dave Edwards) passed away, but the\nmainline source code does MUSIC/SP now too, but it lacks nice packaging.\nThe MVS version also works under PDOS/390.\n\nPorting the compiler to the mainframe opened up the floodgates to lots\nof C code being able to be ported. The downloads section contains some\nsuch applications. The most impressive one is probably the \"diff3\"\nutility. If you have never heard of a three-way diff, you will not\nregret learning what it can do for you.\n\nGCCMVS consumes a lot of memory when compiling large programs. More than\nthe 24-bit address space of MVS 3.8j can handle in fact. Fortunately,\neven if you want to compile large programs, there now exists free 31-bit\nmainframe operating systems - the OS/380 <http://mvs380.sourceforge.net>\nsuite. If you want, you can fire these up to do your compile and get a\n24-bit module generated that is suitable for running on an existing\n24-bit version of MVS. The GCCMVS and GCCCMS executables provided at the\nsourceforge site are 31-bit executables targetting (by default) 24-bit\nsystems, although a 24-bit executable (suitable for small programs) is\nalso provided. You are free to configure it to be 31-bit targetting\n31-bit if you wish (and even within that configuration there are more\noptions available e.g. whether to use a heap or not). The MVS\nexecutables are provided in XMIT format for the convenience of z/OS\nusers. Note that z/OS is considered to be the primary target of GCCMVS,\nalthough most testing actually occurs on the \"compatible\" MVS/380.\n\nThere are a few introductory tutorials for using GCCMVS on MVS 3.8,\nalthough at time of writing they hadn't been updated to GCCMVS 7.0.\n\n  * Installing GCCMVS <gccdocs/gccmvs.html>\n  * Using GCCMVS <gccdocs/usegcc.html>\n  * Practical GCCMVS <gccdocs/pracgcc.html>\n\nMost discussion of GCCMVS takes place here\n<http://tech.groups.yahoo.com/group/hercules-os380>, although there are\nseveral other suitable places.\n\n------------------------------------------------------------------------\nE-mail Paul Edwards here <mailto:fight.subjugation@gmail.com>.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$PDOS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00U\\x01\\x11\\x15\\x7f\\x01\\x11\\x15\\x7f\\x14'\\x008\\x008\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-06T00:00:00", "modifydate": "2011-06-06T14:27:55", "lines": 56, "newlines": 56, "modlines": 0, "user": "SBGOLOB"}, "text": "*Welcome to PDOS (Public Domain Operating System) and PDPCLIB\n(Public Domain Project C Library)*\n\nThere are two major components to the PDOS project.\n\nThe most commonly used component, thanks to GCCMVS\n<http://gccmvs.sourceforge.net> (port of GCC to IBM mainframe) is\nPDPCLIB which is a public domain C runtime library which you can\nlink your own C programs against to produce executables with no\nlicencing restrictions (even if you use a compiler, commerical or\nnon-commercial, that does have licencing restrictions). PDPCLIB\nworks on DOS, OS/2, Win32, PDOS, MVS (mainframe) and CMS. The\nlibrary conforms to the ISO/IEC 9899:1990 (aka ANSI X3.159-1989\naka C90 aka C89) standard. It has no extensions so is\nparticularly good at finding out if your code is truly portable.\n\nSecondly there is an operating system, with a user interface as\nsimple as MSDOS, but behind the scenes the story is quite\ndifferent. There are 2 completely different APIs supported (MSDOS\nand MVS). The MSDOS API is supported on both the 16-bit 8086 and\n32-bit 80386. On the 80386, it isn't really the MSDOS API, it is\na theoretical 32-bit MSDOS API (note that while the API and\napplications are pure 32-bit, it internally switches to 16-bit in\norder to be able to use the BIOS, a fact that the application and\nend user is completely unaware of). The MVS API is supported on\nthe 24-bit S/370 and 31-bit S/390 IBM mainframe hardware.  The\n31-bit S/380 from Fujitsu is also supported. The 16-bit MSDOS API\nand the 24/31-bit MVS API are both able to run a subset of\nreal-world applications that were targetted to the original\nenvironment that they are in some ways a clone of.\n\nNote that a 3rd API - Posix - is expected to be implemented at\nsome point, starting with the S/3x0 hardware. After which, a port\nof NetBSD may be possible. Note that only the S/3x0 target with\nthe MVS API is currently under active development.\n\nYou can find documentation for PDOS and PDPCLIB in text files in\nthe downloadables here <http://sourceforge.net/projects/pdos>.\n\nThere is also some miscellaneous programs with source code there,\nincluding OZPD (snippets of PD code), PDPZM (public domain\nzmodem), PDCOMM (PD communication routines for DOS, OS/2 and\nWindows), BBS-related stuff (Devil Dialer C, RSEND, Tobruk),\nRZSZPE - a port of rzsz (zmodem) to DOS and OS/2, and PDCRC - a\nset of CRC routines.\n\nMost discussion of PDPCLIB takes place here\n<http://tech.groups.yahoo.com/group/hercules-os380>, amongst\nmainframe enthusiasts. There is no real discussion group for PDOS\nalthough it does get mentioned sometimes in the\nalt.os.development newsgroup. Anyone interested in making\n(explicitly public domain) enhancements to either component is\nmost welcome.\n-----------------------------------------------------------------\nE-mail Paul Edwards here <mailto:fight.subjugation@gmail.com>.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$SYS380": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x15\\x8f\\x01\\x11\\x15\\x8f\\x19\\x12\\x04\\xf3\\x04\\xf3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-07T00:00:00", "modifydate": "2011-06-07T19:12:00", "lines": 1267, "newlines": 1267, "modlines": 0, "user": "SBGOLOB"}, "text": "System/380 Principles of Operation - Version 1.2.x\n\nThis document outlines the principles and history behind both\nMVS/380 1.0 (released in June 2009) and VM/380 1.0 (released in\nJuly 2009).\n\n\nDRIVING FORCE\n-------------\n\nThe lack of a free C compiler on z/OS meant that some people both\npast and present were unable to cost-justify the expense of a C\ncompiler and thus had to write in a non-preferred language.  The\nfree GCC compiler has had a S/370 target for approximately two\ndecades, but it was always a case of \"so close but yet so far\",\nas unfortunately the GCC compiler itself had not been written\nwith a non-Unix-based C90 environment in mind.  Even just opening\na file - open() would often be used instead of fopen(), despite\nthe fact that GCC was basically a text processing application\nthat could have been written in pure C90.  The effort to overcome\nthese problems is a story in itself (documented further down),\nbut the end result was that GCC (which inherently generates\n31-bit clean code) was ported to the (free) 24-bit MVS 3.8j\noperating system.  However, the memory constraint of\napproximately 9 MB memory, for both the 3 MB executable and its\ndata, placed severe restrictions on how large a program being\ncompiled could be before running out of memory.  GCC was for\nexample unable to recompile all of itself on MVS.  On VM/370\nwhere nearly 16 MB total is available, the situation was\ndifferent - GCC could indeed recompile itself, although not all\nmodules at full optimization (to do that required approximately\n23 MB, including 3 MB for the compiler itself).\n\nBasically, GCC needed to be executed as a 31-bit application\nrather than being constrained to 24-bits by the operating system\nand hardware.  With z/OS in mind, being 31-bit was never a\nproblem.  However, z/OS is not available for free, so hobbyists\nwere not directly able to write software targetting z/OS.  Going\nthrough hoops, it was possible to verify that z/OS worked, but\nwhat was ideally needed was a 31-bit MVS, even if it was\nsubstandard compared to z/OS.\n\nIndependently of the effort to make GCC work on an EBCDIC\nplatform, a C runtime library (PDPCLIB) was being developed\n(since 1994).  Initially written on the PC, when access to C/370\nwas suddenly made available (in 1997), the mainframe (then\nOS/390) was able to be targetted.  The design of PDPCLIB was such\nthat all OS (in this case, MVS) access was done via one assembler\nfile less than 1000 lines long.  GCC meanwhile was of the order\nof 400,000 lines of C code, which then became 700,000 lines of\nassembler.  The important thing about this generated assembler\nwas that it was \"stock standard\". No OS calls, just clean\n31-bit-capable code.  Whether the executable was 24-bit or 31-bit\ncame down to just 1000 lines of hand-written assembler.  And this\n1000 lines of code would determine the fate of EVERY C program,\nnot just the GCC compiler itself.  And some of those programs\nrequire even more memory than GCC.  This 1000 lines of assembler\ncode was eventually made AMODE 31, RMODE ANY for a good z/OS\ntarget.\n\nThe cleanliness of the generated code and the (deliberate)\nisolation of OS-dependent code had always held out the hope that\none day those 1000 lines could be replaced with something that\nwould allow the rest of the compiler to run 31-bit, free from the\nconstraints of a 24-bit operating system. Something like a\nstandalone program.  When it was time to analyze what could be\ndone, it was noted that those 1000 lines could cope with being\nexecuted in AMODE 24, even if the caller was running AMODE 31,\nusing ATL (above the 16 MB line) data, because the data that the\nassembler operated on was almost all obtained by the assembler\ncode itself in a previous call, or resided on the stack (DSA -\ndynamic save area - which was allocated in the startup code, the\nother very small bit of assembler).  A simple AMODE switch to\n24-bit should have been all that was required.  What this meant\nwas that if there was some way to get into 31-bit mode, noting\nthe possibility that interrupts may need to have been disabled to\nprevent the 24-bit operating system from interfering and getting\nconfused, the C code would be able to run freely until it hit the\nassembler, at which point it could switch mode back and reenable\ninterrupts and no-one would be any the wiser.  Sophisticated OS\nservices like SPIE would possibly not be available, multitasking\nmay have needed to be temporarily halted, but none of these\nthings were actually required in the situation in question\n(hobbyist system trying to do a large compile, and when complete,\nreturn to business as usual).\n\nMVS (24-bit) would have already loaded the 31-bit-capable code\ninto memory, so it would just be sitting there waiting for an\nappropriate machine to execute it.  ie something like this\nsequence:\n\n1. Suspend the entire traditional S/370 machine when ready to\n   enter 31-bit mode.\n2. Switch in an artificial machine (resembling S/390 to some\n   extent) that could cope with 31-bit memory addresses, all in\n   real memory, thus allowing application (GCC) logic to access\n   large data structures, but not requiring operating system\n   services.\n\n3. When the application was ready to do I/O, and thus switch back\n   to 24-bit mode ready for interaction with the operating\n   system, at the point of mode transition, switch out the\n   artificial machine and switch in the S/370 machine, which\n   would be unaware that anything had actually happened unless\n   there was some timing issue or interrupt issue.\n\nThe question was probably not if it was posible, but rather - how\nmuch work was required to construct a machine capable of\nfulfilling such a requirement.  In the end a method was found\nthat only involved about 20 lines of code changes to the S/370\nsystem provided by the Hercules emulator to produce an artificial\nS/380 system that was able to slot in very cleanly indeed.\nInterrupts did not need to be disabled.  Machine type didn't need\nto be repeatedly swapped. Real memory was not required.\n\nThe simple technique involving mapping memory was first made to\nwork in November 2007 (by Paul Edwards) and a formal release of\nthe new architecture was released in December 2007.  A new SVC\n(233) was introduced (by \"somitcw\") with MVS/380 0.2 to obtain\nand release ATL memory.  By MVS/380 0.4 (March 2008) the SVC was\nhidden inside the GETMAIN (thus allowing source code\ncompatibility with z/OS) until August 2008 (although not formally\nreleased until January 2009 with MVS/380 0.9) when Gerhard\nPostpischil developed a technique to intercept SVC 120 which\nprovided 31-bit binary compatability between MVS/380 and z/OS (at\nleast for applications that conformed to the 31-bit interface\nthat MVS/380 supported).  At the same time (January 2009), CMS\nhad also been modified (by Robert O'Hara) to allow the same\nsource and binary compatability between VM/380 0.9 and z/VM.\n\nIn March 2009, Jason Winter introduced a far more sophisticated\nflavor of S/380 - providing for memory protection, multiple\nmemory requests and even a semblance of virtual memory support.\nAt time of writing, this version requires people to roll their\nown version of Hercules, and is dependent on Jason's JCC\ncompiler.  But technically, memory protection is available for\nthose who see this as a barrier for adoption.  Either\nimplementation (or others in the pipeline), is transparent to the\nactual application (at least applications that use a heap and\nthus only make one memory request of the OS - which GCCMVS is\nable to generate, including when it generates itself).\n\nIn June 2009 MVS/380 1.0 was released, followed in July 2009 by\nVM/380 1.0, after a suitable form of distribution was found for\nboth products.\n\nIn August 2009, during some unrelated ftp work involving an SVC\nintercept, Adrian Sutherland proposed another radical change -\noffload the SVC 120 intercept, and other MVS functionality such\nas an SQL server, to the PC, using Hercules as the bridge,\nbypassing the need to port all software to MVS. The concept was\nproven for the SVC 120 intercept at least, and has opened the\ndoor for quite nice memory protection and virtual memory\nfacilities. August 2009 also saw VM/380 1.1 released with some\nbug fixes.\n\nIn January 2010, Michel Beaulieu managed to get a program to\nswitch to 31-bit mode under DOS/VS under VM/380 under\nHercules/380, and VSE/380 effectively came into existence. Also\nin January, Amrith K started working on disassemblies of MVS\ncode. Recognizing the infrastructural problems that made this\nprocess inefficient, Gerhard made extensive changes to the\ndisassembler while Paul organized rationalizing the source code\nand putting it into CVS.\n\n\n\nS/380 HARDWARE ARCHITECTURE\n---------------------------\n\nHercules was used to create the necessary \"hardware\".  The\nexisting S/370 was used as a base, and basically renamed to\nS/380, to avoid the need to create a 4th machine type.  There is\na flag to downgrade S/380 to S/370, but it is S/370 that is\nconsidered to be an \"option\".  All instructions that are common\nto both S/390 and z/Arch, with one exception involving I/O, were\nadded to S/380.  The way Hercules is constructed, this was a\nminor modification.  The S/370 I/O remains.  This is absolutely\nessential since all of MVS 3.8j uses it, and the goal is to not\nhave to rewrite MVS, where the complete source code is not even\navailable (not even PL/S-generated \"source\").\n\nAdding the S/390 instructions means that the BSM instruction is\navailable to switch into 31-bit mode.  Some small changes (e.g.\nnot using a fixed 24-bit address mask) were necessary to get\nS/380 to respect that mode change.  The biggest change was what\nto do about the ATL (above the 16 MB line) memory.  All of MVS\n3.8j is 24-bit.  Neither the operating system nor any\napplications ever reference memory above the line.  Similarly,\nthe S/370 architecture meant that there was no expectation for\nmore than 16 MB of real memory to be used.  All virtual memory\nreferences resolved to BTL (below the line) addresses.  So there\nwas nothing in existence (it was never logically possible to\ncreate such a thing) to interfere with any use of ATL memory.  As\nsuch, the change required was decidely simple - simply map any\nATL reference into the equivalent ATL address of real memory.\nThis meant that all address spaces resolve to the same address so\nyou can only run one 31-bit application at a time if you want to\nbe assured of memory protection.  Given the young state of S/380,\nand the body of current users, in practice this is a non-issue,\nas most people don't even run one 31-bit application, nevermind\nhaving a requirement to multitask multiple 31-bit applications.\nIn addition, storage keys were ignored so that the operating\nsystem didn't require modifications to set the storage key of ATL\nmemory to 8 for use by problem-state programs.  As noted earlier,\nthese tradeoffs don't exist in Jason Winter's version.\n\nIn order to run 31-bit applications under CMS, one more\nmodification was required (that was not required for MVS).  Since\nCMS runs under CP, and neither CP nor CMS are 31-bit aware, when\na CMS application does an SVC, it doesn't simply load the old PSW\nto return.  It instead constructs a new PSW, losing the old\n31-bit status in the process.  Actually, CP, running in ECMODE,\ndoes save the fact that the interrupt occurred in 31-bit mode, so\nwhen returning from hardware interrupts, there is no problem.\nThe problem only arises because CMS runs in BCMODE and thus gets\nan inherently 24-bit PSW.  But it is CMS that needs to decide\nwhat the return address will be, and obviously with zero\nknowledge of 31-bit, it can't construct the required PSW.  This\nproblem was circumvented by, during an SVC, saving the return\naddress, and when an LPSW was done, to check the address being\nreturned to, seeing if that is the same address previously noted\nand if so, restoring 31-bit mode prior to returning to the\napplication.  When CP is eventually modified to include similar\nlogic, this change can be removed from Hercules/380 (where it\ndoesn't really belong).  Note that while this change satisfies\nthe requirements for most SVCs, there are some SVCs that return\ncontrol to a different address, thus bypassing S/380's ability to\ndetect it.  If calling these SVCs, the application is required to\nswitch to 24-bit mode prior to invoking the SVC (this is not\nparticularly onerous, since the application will already have to\ndo such AMODE switches whenever calling the file i/o routines,\nwhich are done as calls, and aren't (or weren't) 31-bit clean, at\nleast in the XA days).  MVS does not have this problem, as the\nSVCs are not intercepted and the entire ECMODE (31-bit aware) PSW\ncontext is saved and restored on SVC return.\n\nMVS/380 PROGRAMMING INTERFACE\n-----------------------------\n\nMEMORY\n\nWhile there is nothing currently (ie this is subject to change\nwithout notice - and Jason Winter has a version where this does\nnot apply) physically preventing an application from directly\naccessing ATL memory, the official interface is via the normal\nz/OS GETMAIN with the LOC=ANY parameter.  The MVS 3.8j macro was\nupdated to allow this parameter, and the SVC 120 which it invokes\nis intercepted by an add-on program (SVC120I) that is usually run\nat system startup.  SVC120I also allows the operator to partition\nthe ATL memory to allow 31-bit programs that go through the\nproper interface to multitask while sharing the memory (although\nat time of writing, in the non-JW version, there is nothing\npreventing such applications from overwriting each other's\nmemory).  Programs that use the official interface are portable\nat both source and binary level to z/OS, since z/OS uses this\nexact facility to provide memory to applications.\n\nCurrently the (non-JW) GETMAIN enhancement does not allow more\nthan one simultaneous ATL memory request from the same program,\nalthough if the memory is first freed, it is then available to be\nreobtained.  Depending on your application, this may or may not\nbe a problem.  C programs usually use a heap, thus a single\nrequest for a large chunk of memory is quite sufficient, and\ngenerally preferred for performance.  This is certainly the case\nfor users of PDPCLIB, and people using this library can have this\ndone automatically for them.\n\nOne more restriction on the (non-JW) GETMAIN is that only\nrequests for a chunk of memory equal to or greater than 16 MB\nwill go to ATL memory.  The reason for this is that any such\nlarge request would otherwise fail, so there is no harm done by\nonly honoring a single request for a block such as this.\nHowever, an application that codes LOC=ANY may do that to signify\nthat it doesn't care if the memory resides above the line, even\nif it only requests a small amount of memory.  So an application\nthat requests 3 blocks of 1 MB of memory would fail on the second\nrequest if ATL memory is used, but would succeed if BTL memory is\nobtained.  So ATL memory is (currently, non-JW) reserved for use\nin a very specific GETMAIN request.  This restriction is also\nexpected to be lifted in the future to provide the same\nfacilities that Jason Winter's version has.\n\n\nASSEMBLER\n\nIFOX00 has some constraints that have been lifted, bringing it a\nlittle closer to IEV90. IEV90 has been defined as an alias to\nallow assembly JCL to be more compatible between MVS/380 and\nz/OS. It is possible to construct assembly JCL in such a way that\nthe same JCL will work on both real IFOX00 and real IEV90, and it\nis this style that is thus portable between the two systems.\nAccess to the S/390 instructions has been provided by copying\nSYS1.ZMACLIB into SYS1.MACLIB.  This implementation is subject to\nchange without notice.\n\n\nFILES\n\nA fundamental concept is how data is stored in a system. There\nare two basic forms of data - text data meant to be read by\nhumans in an editor, and binary data designed to be read by\nsoftware.\n\nText data usually contains characters like the letter 'A' and\nspaces and is divided into lines. On Unix systems a control\ncharacter, the newline, x'0a', is inserted into the data stream\nto delimit lines. There are advantages and disadvantages to this\nsystem. On MVS, a completely different approach was taken. The\nlength of the line is given upfront (as a binary value). This\nalso has advantages and disadvantages.\n\nThere are multiple ways of storing this length field, and MVS\nuses a few different ones internally. The most important one, and\nthe one that programmers should be aware of, is the RDW format,\nsince this will become visible (ie in the data stream) when\nreading text data in binary mode, depending on where the data is\ncurrently stored. Specifically if the data is stored in a RECFM=V\nor VB dataset, then the RDWs will be visible. In addition, if a\nRECFM=V dataset is transferred to the PC in binary mode via ftp\nwith the rdw option, then the RDW will appear in the data on the\nPC.\n\nOne of the advantages of the length-up-front format is that\nbinary data can also be stored and not be misinterpreted as a\nline delimiter, so a V dataset can contain either text or binary\ndata, and can be transferred to the PC intact (ie not losing the\nline (aka record) boundaries).\n\nThe RDW format is a 4-byte field. The first two bytes are the\nlength of the line, plus the length (4) of the RDW, stored in\nbig-endian format. The second two bytes are reserved, and should\nalways be set to x'00'.\n\nInternally, MVS stores multiple lines together in a block,\nprepended with a BDW which looks just like a RDW itself, but this\nshould not be made visible to the programmer for normal\napplications. Internally there's even another level, a physical\nblock size (aka sector size - but unlike on the PC, a variable\nsector size), maintained by the hardware, which similarly should\nnot normally be made visible to the programmer.\n\nUnfortunately, for historical reasons, there is quite a lot of\nsoftware written that makes use of either or both of the BDW and\nthe hardware-stored size, and thus has become intimately tied to\nhardware it resides on. Fortunately, the data that such software\nproduces can usually be converted into a more logical form (ie\nthe RDW standard) for subsequent manipulation by more generic\nprograms. And converted back again too. Using a standard utility\n- IDCAMS REPRO.\n\nSo here are the general rules.\n\nIf you wish to store text data, store it in RECFM=VB, with a\nrecommended LRECL=255,BLKSIZE=6233, which provides a good sector\nsize for most disks.\n\nIf you wish to store binary data, that by coincidence happens to\nbe a sequence of variable-length blocks of data (ie records),\nthen take advantage of the existing RDW convention and store it\nin the same RECFM=VB type dataset as above, and increase the\nLRECL from 255 to 6229 (giving a true record length of 6225) if\ndesired. Although, depending on available hardware, it is\npossible to go above 6229, if you have a need to do so, you\nshould probably treat this as arbitrary data rather than trying\nto shoehorn the data into the otherwise convenient VB format.\n\nIf you are storing load modules, use a block size of 6144, to\nprovide a multiple of 1024, which is all the linker can use.\n\nFor all other arbitrary binary data (e.g. a \"zip\" file), that\ndoesn't neatly fit into fairly short \"records\", the data should\nbe put into RECFM=U with a recommended LRECL=0,BLKSIZE=6233. With\nthis format, it is essentially the same as a PC, except the\nsector size is 6233 instead of 512 or 2048 or whatever.\n\nHowever there is one more exception. Many applications have a\nneed to write binary data in fixed length chunks (records). There\nis a convenient type of dataset to store that sort of data in as\nwell - RECFM=FB. If your data consists of e.g. 80-byte records,\nyou should store them into a file of format\nRECFM=FB,LRECL=80,BLKSIZE=6160. This is the largest number, less\nthan or equal to 6233, that is a multiple of the LRECL.\n\nFor co-existence with existing software - if the existing\nsoftware writes to RECFM=U yet expects the block boundaries to be\npreserved (ie the data should really have been put into VB), then\ntry to restrict the block size to 6225 so that it can be put into\na proper VB dataset if required by other applications that are\ncoded to expect proper RDWs.\n\nIf the existing software reads only from RECFM=F, when it\nactually contains e.g. assembler code, then use a utility like\nCOPYFILE (with the -tt option) to convert it from its natural\nRECFM=V format into the F format. COPYFILE will append spaces to\neach line to pad out to the required width (and truncate them on\nreturn).\n\nIf the existing software puts text data into RECFM=U as separate\nsectors for each line, then use IDCAMS REPRO to get it into its\nnatural VB format.\n\nIf space efficiency on a 3390 is an absolute necessary, then\n18452 will give 1/3 track blocking, while not eliminating the\nability to use a 3350. However, if you would like to store an\nIEBCOPY image of your data files in a simple (RECFM=V rather than\nVS) format, then allow a 20-byte overhead for all datasets, which\nIEBCOPY requires (12 bytes overhead plus the BDW+RDW for\nRECFM=V). This would make the recommended block size 18432, which\nhappens to be a multiple of 1024, which makes it ideally suited\nfor load modules too. But normally this is not a consideration,\nso the recommended sizes are RECFM=VB,LRECL=255,BLKSIZE=18452 for\na typical text file, RECFM=FB,LRECL=80,BLKSIZE=18400 for a\ntypical assembler file, RECFM=U,LRECL=0,BLKSIZE=18452 for a zip\nfile and RECFM=U,LRECL=0,BLKSIZE=18432 for a load module.\n\nSometimes (e.g. when using unzip) a file may be put into RECFM=U\nnot knowing whether it is binary or text. If Unix-style text data\nis stored in RECFM=U (ie with newline separators), then this can\nbe moved into its more natural RECFM=VB format using COPYFILE\n(with the -tt option).\n\nIf RDW-format data is stored in RECFM=U and you want to move it\ninto its natural format, then use COPYFILE (with -bb option) to\ndo that. Fixed length data can be moved across in exactly the\nsame way.\n\nRDW-format data can also cope with being temporarily copied into\na RECFM=F dataset and out again intact (because the mandatory\nNUL-padding at the end can be recognized by COPYFILE as the true\nend of the data, since it is an invalid RDW), but it is not\nrecommended to store RDW data in RECFM=F.\n\nHercules/380 provides a convenient interface for getting data\ndirectly from the PC into the appropriate target dataset format.\nThis is done via extensions to the TDF format.\n\nYou can use the \"TEXT\" format to present text data as:\n\nRECFM=U with no newline characters (not recommended)\nRECFM=U with newline characters\nRECFM=F with space-padding\nRECFM=V (this is the recommended option)\n\nYou can use the \"FIXED\" format to represent binary data as either\nRECFM=U or RECFM=F.\n\nYou can use the \"RDWUND\" format to present RDW data as RECFM=U.\n\nYou can use the \"RDWVAR\" format to present RDW data as RECFM=V.\n\nYou can use the \"RDWFIX\" format to present RDW data as RECFM=F\nwith space-padding.\n\nYou can use the \"RDWFIXN\" format to present RDW data as RECFM=F\nwith NUL-padding.\n\nSimilarly, if data is written to an output tape dataset, it can\nbe extracted using \"hetget\" and be put into the appropriate\nformat. Ideally, RDW data would be written as RECFM=V, where a\nbinary extraction will append the RDW automatically. A binary\ndata of RECFM=U will lose any block boundaries, although if you\nknow it is really RDW data, then there is an option to force an\nRDW to be added.  Text data is ideally written with RECFM=V, and\na text extraction will convert that to normal newline (Unix/DOS)\nformat. A text extraction of RECFM=F will strip blanks and add a\nnewline. A text extraction of RECFM=U will simply do EBCDIC to\nASCII conversion of all characters including an expected newline,\nalthough if you know the data is missing newlines, those can be\nforce-added at block boundaries.\n\nIn general, binary data either needs to be of fixed length,\nunformatted (ie the program reading the data has its own\nmechanism for recognizing data), or have RDWs, in order to be\nable to be moved to another system and still be usable. So you\nhave to be careful that you are storing your data in one of those\nformats on both MVS and the PC.\n\n\nPDPCLIB\n\nUsers of any C program linked with PDPCLIB will need to define 3\nstandard DDs - SYSIN, SYSPRINT and SYSTERM, corresponding to\nstdin, stdout and stderr.  DCB information will need to be\nprovided for new output datasets, unless the IBM default of\nRECFM=U is desired.  The startup code is designed to expect\nparameters in either TSO or BATCH style and will adjust\nautomatically.  Files opened via fopen() can have a filename of\n\"dd:xxx\" which signifies that a DDNAME of \"XXX\" exists to be\nopened.  Otherwise, the filename will be dynamically allocated to\na generated DDNAME (PDPxxx).\n\nText files (ie second parameter of fopen = \"r\" or \"w\") are\nprocessed as follows.  If file is F or FB, then trailing blanks\nwill be stripped from records on input and replaced with a single\nnewline character.  On writing, the newline is stripped and\nrecords are blank-padded.  If the line is longer than the LRECL,\nextraneous characters are silently discarded.  If file is V or\nVB, then on input the BDW and RDW are stripped, and a newline is\nadded at the end of the record.  Unless the record consists of a\nsingle space, in which case the space is stripped as well.  On\nwrite, empty lines have a space added.  This is consistent with\nhandling of Variable records on MVS (e.g. when using the ISPF\neditor), and some standard IBM utilities (e.g. IEBCOMPR) cannot\ncope with truly empty records (RDW=4).  If a line is longer than\nthe maximum LRECL, extra characters are silently dropped. If\nRECFM=U, on read the BDW is stripped and the byte stream is\npresented unchanged to the application.  Unlike IBM's C compiler,\nblock boundaries don't get newline characters inserted into the\nbyte stream. The reason for this is it prevents the ability of a\nbinary read of a text file from preserving the data, since the\nblock boundaries disappear in such a scenario. When writing to\nRECFM=U text files, data is written until a block is full.\nUnlike IBM's implementation of C, newline characters do not cause\na new block to be written. Once again, this allows a binary\ntransmit of a RECFM=U file to have the line separators preserved\nwhen the data arrives at say the PC side. No special handling of\nthe block boundaries needs to be done.\n\nBinary files (ie second parameter of fopen = \"rb\" or \"wb\") are\nprocessed as follows.  If file is F or FB, then on input, data\nwill be presented to application unchanged.  On output, data is\nalso written unchanged, except that the last record will be\npadded with NUL characters if required.  If file is V or VB, then\non input the BDW will be stripped, but the full RDW will be\npresented to the application.  This makes the byte stream\ncompatible with what a PC application would see when reading a VB\nfile transferred via ftp with the \"rdw\" option.  On write, an RDW\nneeds to be provided by the application.  Any invalid RDW causes\na file error condition, and no further data is written.  With one\nexception.  An RDW of all-NUL is a signal to discard any further\ndata written.  This allows for a binary copy of a V dataset to an\nF dataset to be copied back to V without change or error, even if\nNUL-padding was required.  (Note that this consideration doesn't\napply to text files since no RDW is provided by the application).\nIf a provided RDW is greater than the maximum LRECL then the RDW\nwill be silently adjusted and the extra data silently discarded.\n\nOpening a PDS without a member for read will cause the directory\nto be read and presented as a byte stream.  Any attempt to write\nto a PDS directory will cause an abend.\n\n\nADDRESSING MODE\n\nPrograms desiring 31-bit execution may or may not be entered in\n31-bit mode directly, and are required to detect what mode they\nwere called in and make the appropriate switch, then restore the\ncaller's AMODE on exit.\n\n\nGENERAL USABILITY\n\nIf you are considering using MVS/380 to do real work, bear in\nmind the following:\n\n  o  Although CICS is not available, there is a commercial\n     product KICKS which may do the job.\n\n  o  The version of Cobol currently available is so old that the\n     syntax is probably unsuitable. z/Cobol and Open Cobol are\n     both potential solutions to this problem, but not yet\n     implemented.\n\n  o  There is a port of SQLlite available in source form for the\n     JCC compiler. There is also a plan to offload this major\n     functionality to the PC, using Hercules as a bridge.\n\n  o  tcp/ip and ftp are not currently available in a generally\n     usable form, but are available (via bridge) in a\n     demonstration form.\n\n  o  RPF provides an ISPF-like environment, and REVIEW is an\n     ISPF-like editor.\n\n\n\nVM/380 PROGRAMMING INTERFACE\n----------------------------\n\n\nMEMORY\n\nThe interface for CMS programs is identical to MVS users.\nGETMAIN with LOC=ANY will obtain ATL storage.  There is no\npartitioning facility available in CMS, but it's not a real\nconcept for CMS.  It would be a concept for CP, but there is no\nfacility in CP for partitioning, nor any communication from CMS\nto CP.  So only one guest OS should run an ATL-using application.\nCMS applications that obtain memory via this interface can be\nported to z/VM at both the source and binary levels also.\n\n\nPARAMETERS\n\nVM/380 provides EPLIST support.  This is the same in VM/380 as in\nz/VM.  Parameters should be obtained the same way by chaining\nback via the save areas.  Once again, this is handled\nautomatically for users of PDPCLIB.\n\n\nEXEC2\n\nVM/380 provides limited EXEC2 support similar to z/VM.  As with\nz/VM, this is activated via &TRACE.  For portable scripting\n(between VM/380 and z/VM), only EXEC2 is guaranteed to have\nEPLIST available, and only the subset of EXEC2 commands that are\npresent in EXEC should be used.\n\nSo that means restricting your EXEC2 scripts to:\n\n&TRACE ALL | OFF\n&ARGS\n&BEGSTACK (no ALL)\n&ERROR\n&EXIT\n&GOTO\n&IF\n&LOOP (but no conditions on the loop)\n&READ\n&SIP\n&STACK (no HT or RT)\n&TYPE\n\nNo functions (&CONCAT, &DATATYPE, &LENGTH, &LITERAL, &SUBSTR)\n\nNo &*, &$, &DISK... &EXEC, &GLOBAL, &READFLAG, &TYPEFLAG\n\n\nASSEMBLER\n\nOn z/VM, the \"ASSEMBLE\" assembler is quite limited, and for\nprograms with a large number of symbols you need to use \"ASMAHL\"\ninstead.  VM/380 has simulated this by adding some limited\nenhancement to \"ASSEMBLE\", copying that to ASMAHL, and updating\nthe maclibs to provide macros such as BSM.  Naturally this is\nsubject to change without notice, but the programming interface\nremains the same.\n\n\nMACROS\n\nz/VM rearranged the macro libraries (e.g. replacing CMSLIB with\nDMSGPI).  To allow application portability, the macro library was\ncopied to its new name, as well as having the GETMAIN macro\nupdated (sourced from MVS) and having a BSM macro added to\ncompensate for it not being internally defined in the assembler.\n\n\nPDPCLIB\n\nUsers of any C program linked with PDPCLIB can either define the\n3 standard DDs - SYSIN, SYSPRINT and SYSTERM, corresponding to\nstdin, stdout and stderr, or these will be allocated to the\nterminal dynamically.  New files can be either defined with\nFILEDEF and opened by DDNAME by specifying a filename of \"dd:xxx\"\nwhere xxx is the DDNAME, or else they can be a full filename.  If\na full filename is specified, then on creation of an output\nbinary file, DCB attributes are set to RECFM=F, LRECL=800.  An\noutput text file is set to RECFM=V, LRECL=2000 by default.\nDynamically allocated files are given generated DDNAMEs of format\nPDPxxx where xxx is a number.  The startup code is designed to\ndetect an EPLIST otherwise get parameters from a PLIST.  However,\nif a SYSPARM filedef is in place, the parameters are obtained\nfrom the first line of that file instead.  If both a SYSPARM\n(even a dummy one) and a parameter are provided, then special\nprocessing is signalled, on the assumption that this is an EXEC\nenvironment where only a PLIST is available, and the user has\ndifficulty passing long and mixed case parameters to the\napplication.  The parameter list will be lowercased, and only\ncharacters preceded by a \"_\" will be uppercased.  Spaces will be\nstripped unless preceded by \"_\".  If the first parameter is \"_+\"\nthen the lower/upper rules are swapped.  Two underscores will\ncreate a single one.\n\nText files (ie second parameter of fopen = \"r\" or \"w\") are\nprocessed as follows.  If file is F, then trailing blanks will be\nstripped from records on input and replaced with a single newline\ncharacter.  On writing, the newline is stripped and records are\nblank-padded.  If the line is longer than the LRECL, extraneous\ncharacters are silently discarded.  If file is V, then on input\nthe BDW and RDW are stripped, and a newline is added at the end\nof the record.  Unless the record consists of a single space, in\nwhich case the space is stripped as well.  On write, empty lines\nhave a space added.  This is consistent with handling of Variable\nrecords on MVS (e.g. when using the ISPF editor).  If a line is\nlonger than the maximum LRECL, characters are silently dropped.\n\nBinary files (ie second parameter of fopen = \"rb\" or \"wb\") are\nprocessed as follows.  If file is F or FB, then on input, data\nwill be presented to application unchanged.  On output, data is\nalso written unchanged, except that the last record will be\npadded with NUL characters if required.  If file is V, then on\ninput the BDW will be stripped, but the full RDW will be\npresented to the application.  This makes the byte stream\ncompatible with what a PC application would see when reading a VB\nfile transferred via ftp with the \"rdw\" option.  On write, an RDW\nneeds to be provided by the application.  Any invalid RDW causes\na file error condition, and no further data is written.  With one\nexception.  An RDW of all-NUL is a signal to discard any further\ndata written.  This allows for a binary copy of a V dataset to an\nF dataset to be copied back to V without change or error, even if\nNUL-padding was required.\n\n\nADDRESSING MODE\n\nPrograms desiring 31-bit execution may or may not be entered in\n31-bit mode directly, and are required to detect what mode they\nwere called in and make the appropriate switch, then restore the\ncaller's AMODE on exit.\n\n\nCOMMON C CALLING CONVENTION\n---------------------------\n\nGCCMVS and GCCCMS (the C compilers bundled with MVS/380 and\nVM/380) generate a special entry point @@MAIN when a program with\nmain() defined is processed.  All function names are uppercased\nand truncated to 8 characters, and \"_\" is converted to \"@\".  As\nsuch @@MAIN is distinct from MAIN.  @@MAIN simply branches to the\nassembler startup code (@@CRT0) and control is never returned to\nit.\n\nGCC-generated code pretty much follows the standard OS linkage\nconventions, except that the list of addresses passed to the\ncalled program via R1 are not terminated with a 1 in bit 1. In C\nyou are expected to know how many arguments you'll have. In\naddition, integer parameters are not stored as addresses, but\ninstead their actual value is used.  This is expected to change\nin the future to be compatible with IBM and the Language\nEnvironment, so macros should be used in preparation for this\nchange.\n\nWhen @@CRT0 is invoked, it sets up a stack.  The first 18 words\nof the stack are a standard OS register save area.\n\n@@CRT0 calls @@START, which in turn calls MAIN (the user's\n\"main\") - which is NOT @@MAIN (the entry point to the\nexecutable).\n\nEach routine's save area comes from the GCC stack allocated in\n@@CRT0. These save areas are chained following OS conventions, ie\nsavearea+4 points to the previous save area, savearea+8 points to\nthe next one. A routine's save area includes space for its local\nvariables. This amount is calculated by the compiler, and passed\nas the FRAME= parameter of the PDPPRLG macro.\n\nSo R13 points to an area that looks like this:\n\n0 - unused by C, but PL/1 or Cobol might use it\n4 - backchain to previous save area\n8 - forward chain to next save area\n12 - R14\n16 - R15\n20 - R0\n24 - R1\n28 - R2\n32 - R3\n36 - R4\n40 - R5\n44 - R6\n48 - R7\n52 - R8\n56 - R9\n60 - R10\n64 - R11\n68 - R12\n72 - unused but could be used to store a CRAB\n76 - pointer to the top of the stack\n80 - work area for compiler-generated code (CONVLO)\n84 - work area for compiler-generated code (CONVHI)\n88 - local variables begin\n\n\nFUTURE DIRECTION\n----------------\n\nThe following projects are either underway or being considered:\n\n  o  Upgrade GCC from 3.2.3 to 3.4.6 (the last version with an\n     S/370 target - the GCC folk decided to drop the \"i370\"\n     target in GCC 4). A beta version of this was available\n     at time of writing.\n\n  o  Port PDPCLIB and GCC to DOS/VS(E) using private source\n     statement libraries (RECFM=F, LRECL=80) with Unix-style\n     data (embedded newlines), plus NUL-padding on last record.\n\n  o  Create an S/380 version of DOS/VS.\n\n  o  Port OpenCobol to MVS/380.\n\n  o  Port z/Cobol to MVS/380.\n\n  o  Port PDPCLIB to other mainframe C compilers (C/370,\n     Dignus).\n\n  o  Possible enablement of languages other than C in GCC (the\n     C++ target could perhaps use stdcxx as the C++ runtime\n     library)\n\n  o  Use BREXX or Regina to provide REXX internally to CMS as\n     per z/VM (prototype demonstrated in May 2009).\n\n  o  Provide the equivalent of mingw (or maybe LE/370) to CMS\n     applications by putting the C runtime library in shared\n     memory allowing small executables (prototype demonstrated\n     in May 2009)\n\n  o  Port 31-bit version of RPF to MVS/380 and use ATL memory\n     to allow editting of large files.\n\n  o  Modify CP so that it is responsible for remembering which\n     applications need the 31-bit restored and remove this\n     logic from Hercules/380.\n\n  o  Memory protection for different address spaces accessing\n     ATL memory (multiple solutions to this, some relatively\n     easy, some requiring extensive OS modifications, some\n     already in existence).\n\n  o  Add memmgr to the GETMAIN intercepts allowing an\n     application to do multiple GETMAINs for ATL memory (now\n     being done a different way).\n\n  o  CICS programming interface provided via KICKS.\n\n  o  Port SQLite to GCCMVS now that Jason Winter has ported it\n     to JCC.\n\n  o  Getting GCCMVS/GCCMU as a native application under\n     MUSIC/SP, completing Dave Edwards's (RIP) project.\n\n  o  Adding TCP/IP to MVS and VM (Jason Winter has a solution\n     of sorts to this, but it hasn't yet been integrated).\n\n  o  A prelinker for GCC-generated code to allow long names\n     and reentrancy.\n\n  o  Enhancements to the CMS editor.\n\n  o  Better cleanup on MVS of ATL memory for when a program\n     terminates without doing a FREEMAIN.\n\n  o  DFDSS-compatible backup (restore is already available),\n     to provide a superior method of software distribution.\n     This is currently in beta testing at time of writing.\n\n  o  Other unusual/niche EBCDIC programming environments exist,\n     although not necessarily commercially sold/used. MUSIC/SP\n     is one of those environments and has had GCC ported to\n     it already. Others include ORVYL, ACP/TPF, TSS, OS/360,\n     z/390, MTS, BS2000/OSD.\n\n  o  Getting Linux Bigfoot (i370) to be able to boot could\n     be useful.\n\n  o  Getting z/Linux or OpenSolaris running under VM/380\n     and using the HLASM from GCCMVS may be useful.\n\n  o  The following MVS usermods:\n\nJES2 spool percentage display or spool full\n\nEOV merge extents\n\nSORT using 3390s properly\n\nLinkedit to put zeroes in DS and ORG*+nnn\n\nIEBCOPY overlays not allowed ( sysgen MACRO ? )\n\nIEHMOVE repeated module load ( minor logic change )\n\nJCL accept ticks in subsys field ( CCSS ? )\n\nMPF support ( big automation improvement )\n\n\n\nGCC PORT HISTORY\n----------------\n\nThe first i370 code generator for GCC was written in 1988-1989 by\nJan Stein, targetting Amdahl's UTS.  It was distributed to others\nto use as a base.  In 1992 Dave Pitts picked that up, made\nmodifications to it, and arranged with Richard Stallman to get it\ninto the official GCC base, which happened in 1993 in GCC 2.5.\nUnfortunately, GCC itself was far from being C90-compliant which\nwould have made it easy to port to the mainframe (or any other)\nenvironment.  Considering the fact that objectively all it did\nwas read in a bunch of text files (C code) and produced another\ntext file (the assembler code) - at least with the \"-S\" option\nspecified - it should have been possible to have written it\nC90-compliant.\n\nOne of the big problems was that the GCC coders had made\nassumptions that they were running on an ASCII host.  To solve\nthis problem meant going into the internals of the compiler to\nfind out where that had been done and make the code generic.\nThis work was largely done by Dave Pitts and by 1998, GCC 2.8.1\nhad an OS/390 EBCDIC port.  Also in 1998, Linas Vepstas (with\nassistance from Dan Lepore and a machine courtesy of Melinda\nVarian) started making large scale changes to the i370 target in\nsupport of an effort to port Linux to S/370.\n\nIndependent of GCC, in mid-1994, Paul Edwards had set about\ntrying to create a C runtime library (PDPCLIB) for the PC, and\nespecially for PDOS (a replacement for MSDOS). In 1997, when\naccess to a mainframe was temporarily available, he used that\nopportunity to port PDPCLIB to MVS. Although Paul was originally\nfrom an MVS background, he had been on Unix during PDPCLIB's\nhistory.\n\nIn April 1998, Paul Edwards, shortly before he started working on\na real MVS (called OS/390 at that time) system, had dusted off\nhis 1997 MVS port of PDPCLIB, then contacted the GCC maintainers\nto ask about making modifications for MVS.  He was unaware of the\nother two activities (Linas and Dave were in communication with\neach other though), and the GCC maintainer apparently didn't know\neither, so work was done on 2.7.2 and later 2.8.1 to try to make\nit C90-compliant, with a simple compilation procedure and a\nsingle executable using Borland C++ and Watcom C++ on OS/2 (a\ndeliberately alien platform), ready to be ported to MVS.  The\nmaintainers weren't too thrilled about changes being made to make\ngcc a single executable, but some of the other changes were\naccepted.  Replacement Unix functions were written and the gcc\nexecutable was able to be compiled and linked (using AD/Cycle\nC/370) and display its usage.  However, when doing a real\ncompile, it went into a loop, that required in-depth knowledge of\nthe GCC application to resolve, so the effort was aborted at that\npoint.  In March 1999 the laptop with this work on it was stolen\nso any GCC changes that the maintainers hadn't accepted were\nlost.  However, the Unix I/O replacement functions had been\nbacked up.  In addition, the concept of converting GCC into a\nsingle, C90-compliant executable had come close to being proven.\n\nApparently encountering difficulty getting i370 mods into\nmainstream GCC, Dave had been adding his i370 mods to different\nversions of GCC since 1998 and maintaining them separately.\nLinas managed to get some, but not all, of his work into the GCC\nbaseline (these additional changes made in 1999 would end up\nbeing lost from the active development stream until 2009).  At\naround this time (1999) another development had been taking place\n- the introduction of Hercules, which allowed the S/370, 390 etc\nhardware to be emulated, thus allowing hobbyists to run old\nversions of MVS (which were public domain).  So access to a\nmainframe ceased to be problematic, especially with the\nintroduction of packaged systems like Tur(n)key from Volker\nBandke.\n\nBy late 2002, Dave was up to version 3.2 of GCC, working under\nz/OS with USS (Posix support). Paul made initial contact with\nDave in November 2002 to inquire about the technical plausibility\nof a port to non-USS MVS.  One year later, November 2003, Paul\nEdwards, working with Phil Roberts, picked up this version with a\nview to getting it working natively on MVS 3.8j.\n\nThe problems that Dave identified in any attempt to port to MVS\n3.8j were that the size of the main part of the compiler (cc1)\nwas 16 MB on OS/390, and that the way the gcc driver loaded cpp,\ncc1 etc would need to be emulated somehow, and that a scheme\nwould be needed to map Unix style file names into MVS datasets.\nNot mentioned were - the compiler had never been used to attempt\nto compile itself which would have revealed that it was riddled\nwith bugs, and the fact that it was riddled with non-C90\nfunctions, plus other non-C90 things like relying on a long\nfunction names to be unique.\n\nHowever, as you can probably guess, there were solutions to all\nthese problems.  First the 16 MB executable.  PDPCLIB is quite\nsmall, possibly because it doesn't support VSAM files, Posix and\nmany other nice-to-have features.  It did however have the\nability to process text files, which is all that was required for\nthe GCC application.  While optimization wasn't switched on until\nyears later, the entire optimized executable was eventually found\nto be just 3 MB (it was 4 MB unoptimized).  MVS 3.8j gave about 9\nMB of address space, and if abnormally stripped down, could\nprovide upwards of 10 MB.  This proved to be sufficient for most\nnormal use.  Abnormal use - such as recompiling GCC itself at\nfull optimization - was not possible though.\n\nGCC is split up into multiple components, with a small \"gcc\"\nexecutable invoking the other executables in turn.  However, this\nis fairly strange in that most of the code is in cc1 anyway, so\nthere's not a lot to be gained.  And the price is everything\nchannelled via a \"system\" call, or fork/exec calls - which are\nall inherently non-portable.  The solution here was to mask out\nall that channelling code and instead get gcc to call cc1 etc as\nnormal function calls to provide a single large gcc executable.\nThis in turn mean that the function names needed to be unique\nacross all the executables, so duplicate functions needed to be\nfound and then renamed with a #define.\n\nThe mapping of the include filenames was initially done by\nrenaming them to 8-character unique names and changing the\ncorresponding source code.  The path searching for include files\nwas nullified and replaced with DD lookups for INCLUDE and\nSYSINCL (the latter for system headers).  Later on the \"remap\"\nfacility was unearthed and all the renames in the source code\nwere able to be reversed out.\n\nThe includes for non-standard headers (fcntl.h, sys/stat.h etc)\nwere #ifdef'ed out.  These header files generally pointed to\nfunction calls which also didn't exist in C90.  The simplest\nsolution to this problem was to create a mini-Posix library where\nopen() is defined in terms of fopen().  Some functions were made\nto return a reasonable value for most common use.  Anything\nabnormal needed a code change to get rid of the call that wasn't\nneeded in the first place in a text-processing program.\n\nOne of the bugs hit early on was the fact that the compiler was\nconverting static functions into 8-character assembler\nidentifiers according to their actual name, which mean that they\nneeded to be unique within the source file.  When the dust\nsettled, there were about 3000 functions that had to be #defined\nto new names, about half of them static (C90 requires the statics\nto be unique to more than 8 characters, so it was the MVS port of\nGCC that was at fault).  To make matters worse, the code was\ninitially generating CSECTs for each function name.  The IBM\nlinker is designed to just take the largest CSECT of the same\nname and silently use that instead of reporting a name clash.\nThe code generator was changed to use unnamed CSECTs and use\nENTRY statements instead to ensure external identifiers were\nunique and clashes detected.  Years later, the static bug was\nfixed and a tool developed to search out duplicates in the\ngenerated assembler so as to only keep those names that needed to\nbe kept (ie external name clashes, which ended up being about\n1300).  Although the GNU config.h is annoying in that they don't\nprovide a C90 version by default, and instead one needs to be\nconstructed manually, it does have the advantage that all the\nremaps were able to be done in there and get picked up across the\nentire source base.\n\nWhile those other problems were time-consuming to resolve, they\nwere nonetheless straightforward.  It was the bugs that were the\nbiggest obstacle.  Without someone familiar with the compiler\ninternals, it was sometimes necessary to hack the generated\nassembler.  By 2004-01-11 ((after having started in November\n2003), the compiler was running natively on MVS. By March 2004,\nGCC 3.2 was able to recompile itself (at least on a 31-bit\nmachine) and version 1.0 was released.  The most serious problem\nwas with floating point - the native compiler was generating bad\nfloating point values and the workaround was to generate the\nvalue \"1.0\" all the time instead.  This didn't cause a problem\nfor the recompilation of GCC itself because it apparently didn't\nuse floating point for anything important.  However, it meant\nthat PDPCLIB had some defects due to this kludge that it wouldn't\nnormally have had.\n\nMeanwhile, mainstream GCC was about to release the 3.4.x series,\nthe last that would include the i370 target, as for the 4.x\nseries they had decided to unceremoniously dump it!  SVN revision\n77216 on 2004-02-04 did the dumping.  ie just as 15 years of\neffort was about to bear fruit.  The GCC maintainers aren't\nMVS/EBCDIC users themselves (the S/390 port is Linux/ASCII), so\nit is a struggle to refit the EBCDIC support for each release as\nit is either screwed with or dumped or the changes aren't\naccepted in the first place.  So it always took a long time for\nthe MVS version to come out, waiting on Dave Pitts to get the USS\nversion working on the next release first.\n\nAt this point (April 2004), Dave Wade picked up the MVS port to\ntry to get it working on VM/CMS with a view to enabling BREXX to\nbe ported.  He succeeded in doing this, plus fixing the floating\npoint bug, plus other bugs and unimplemented functionality in\nPDPCLIB and in January 2006, version 2.0 was officially released.\nAt around this time, Dave Pitts had independently moved his\nchanges up to version 3.2.3, so the GCCMVS changes were reapplied\non top of that.  So version 1.0 of 3.2.3 was released in January\n2006 also.  Version 2.0 followed a short while later (March 2006)\nmainly to enable building on Unix with later versions of GCC.\n\nVersion 3.0 was released in August 2007 and significantly\nprogressed the mainframe-ness of the compiler. The\nprologue/epilogue assembler macros were created rather than being\ndone with a separate program. Include files could be\nconcatenated.  It was fully 31-bit on z/OS (instead of being\nrestricted to RMODE 24 due to the way the RDJFCB macro had been\ncoded).  Remap was made to work. The generated files (mainly\ngenerated from the machine description) were able to be generated\non the MVS system.  Optimization (-O2) was switched on, taking\nthe executable size from 4 MB to 3 MB, although some code\nworkarounds were needed to bypass optimizer bugs.  Aliases for\nPDPCLIB modules were provided to enable automatic linking.\nAnother code generator bug fix was applied.  Also, on VM, it was\nnow possible to get GCC to recompile itself unoptimized - or to\ncreate a hybrid where most of it was optimized, but a few modules\nwere still unoptimized.  This state of affairs was probably made\npossible earlier when GCC had been modified to stop invoking\nsetjmp() all the time which consumed a lot of memory (saving the\nstack), due to an overzealous implementation that would later be\nchanged.  Regardless, this was the point at which it was now\npossible to have a purely mainframe compiler able to recompile\nitself on a freely available mainframe operating system.  Even\nthe MVS version could theoretically be generated from VM/370.\nThis was never tried as it was academic and was soon replaced by\nan alternative and superior advance.\n\nUp until this point, Paul Edwards, due to his very old and very\nflakey PC, had never dared attempt to install Hercules to see GCC\nrunning for himself.  Instead, all work had been done via email\nas he sent code to Phil Roberts and Phil sent back dumps, traces\nand on the odd occasion, the result of a successful run.  If Phil\nhadn't done this, everything would probably have been delayed by\n4 years.  By November 2007 Paul had purchased a new laptop and\nhad Hercules running TK3 (rather than TK3SU1 as that required\nHercules 3.05 which wasn't working due to another problem).  It\nwas then discovered that there wasn't enough region in TK3 out of\nthe box to compile many of the source files that had previously\nbeen set as compilable in 24-bit.  Previously an elaborate scheme\nhad been set up such that the JCL had \"dummy\" compiles where\ninstead of doing a real compile, the old assembler (from the PC)\nwas simply copied.  On a 31-bit system, those dummy compiles were\nthen globally changed to real compiles.\n\nThe problem was that there was no good figure to use for\navailable memory.  Multiple attempts were made to find a \"lowest\ncommon denominator\", but even the same machine produced different\nresults on multiple runs.  By the 17th November 2007 the region\nhad been lowered yet again, this time from 8500k to 8400k, but\nthere was no end in sight to this problem.  We were trying to get\ntoo much out of the 24-bit system and it was simply the wrong\nsolution.  This is why 31-bit systems exist and it was time to\nupgrade.  On 14th November 2007 Paul had initiated a general\nquery to find out the best way to force through essentially\nonce-off 31-bit compiles on the 24-bit MVS, with a bit of\n\"trickery\" (the phrase actually used upon success was \"Paul\nmanaged to ram a square peg in a round hole with a sledge\nhammer\").  There was a wide variety of opinions and suggestions,\nand on the 20th November 2007 an S/380 [in practice, but still\ndisplaying S/370] machine was able to enter 31-bit mode and stay\nthere with no complaint from MVS.  On the 21st November the S/380\ntest program was able to write to ATL memory, although it wasn't\nuntil the 22nd November that this was realised due to confusion\nover the so-called \"crap byte\" that BALR inserts (and BASR\ndoesn't).  By 7th December, 2007 GCC had been compiled end-to-end\n(ie reproducing itself) on the S/380 eliminating any remaining\ndoubt about whether it was technically possible or not.\n\nVersion 4.0 was released in December 2007 and a heap manager\n(memmgr) was added which provided support for the newly created\nMVS/380.  In addition, the PC and mainframe were producing\nidentical assembler thanks to the -Os option being used plus some\nother minor code changes plus another code generation problem\nbeing fixed.  This showed that there were no code generator bugs\nthat had introduced a bug into the GCC executable itself.  Later\nit was discovered (by Dave Edwards when he was doing work on\nMUSIC/SP) that -O2 causes different code (both forms valid) to be\ngenerated depending on the exact representation of floating point\nvalues.  -Os does not appear to be sensitive to that.  Ideally\ncode shouldn't be written that is sensitive to that, but no-one\nknew where that was happening.  Prior to Dave's discovery, it was\nassumed that one of the code generation bug fixes, or the\ngenerally random nature of those code changes were responsible\nfor the identical code.  -Os had been switched on for an entirely\ndifferent reason (ie an apparently incorrect claim that it\nproduced significantly faster code than -O2 on MVS).\n\nVersion 5.0 was released in March 2008 and the last major\nstandards violation - requiring statics to be unique in the first\n8 characters was lifted as it was discovered what needed to be\nchanged so that static functions could be renamed to be unique,\ngenerated names.\n\nVersion 6.0 was released in January 2009 along with version 1.00\nof PDPCLIB as (after 15 years) it became C90-compliant, at least\non the mainframe (as far as it was known) - with the exception\nthat there were still a lot of known compiler bugs which no-one\ninvolved knew how to fix.  So finally there was a free (even for\ncommercial use) C90-compliant (although given the known bugs, it\nwould be best to give this \"beta\" status) environment on the\nmainframe.  The VM build procedure was totally revamped, and\ntechniques developed to allow traditional automatic linking.\nPlus it became a totally mainframe product as BISON and SED were\nprovided on the mainframe so that nothing at all came from the\nPC.  The 31-bit GCC executables produced for both MVS/380 and\nVM/380 were made available, unchanged, for z/OS and z/VM users.\nThe z/OS deliverable was made available as an XMIT, while the\nz/VM deliverable was provided as an AWS tape. Also, output was\nswitched to move mode rather than locate mode by default which\nmade debugging-via-printf much easier after an abend.\n\nThe availability of a C compiler allowed a variety of other C\nproducts to be ported, and these were all bundled with MVS/380\n0.9 and VM/380 0.9.  They were bison, brexx, bwbasic, diffutils,\nflex, m4, patch, sed, minizip (zlib).  The changes to brexx and\nbwbasic to support MVS and CMS were incorporated into the base\nproduct.\n\nIn February 2009, Linas was contacted to see if he was interested\nin fixing some of the remaining compiler bugs (about 7 serious\nones preventing code from being compiled), and it was discovered\nthat some of his code changes were not even the current version\nof the compiler.  Paul merged in the remaining code changes,\nexcept for one, which ironically was the only change that fixed\none of the 7 bugs, but as a side-effect created an even more\nserious bug in other code! However, this change allowed\nexperimentation to find out what change was required to\ncircumvent the problem in question.\n\nIn April 2009, Paul had reached the point with Dave Pitts's\nunreleased 3.4.6 mods of being able to produce a single\nexecutable under Windows using gcc from Cygwin.  This was a\nprecursor for getting it to work on MVS with PDPCLIB.\n\nMay 2009 saw two more advances. Robert O'Hara had produced\nGCCLIB, a native CMS runtime, which could be made resident,\nenabling small applications to be developed.  Meanwhile, Linas\npassed on sufficient knowledge to Paul Edwards to enable him to\nfix GCC compiler bugs.  This allowed the 15 or thereabouts known\ncompiler bugs to be fixed at long last, producing a far more\nrobust compiler.\n\nJune 2009 saw the release of GCC 3.2.3 MVS 7.0, the first\nin-practice C90-compliant release.  This was the point where GCC\non MVS came of age, and the point at which C became a lingua\nfranca for computers, with every major (or at least, more widely\nused than DOS/VSE) platform now speaking the language for no\nadditional monetary cost.\n\nAugust 2009 saw the release of GCC 3.2.3 MVS 7.5, which saw\nextensive changes to the machine definition in order to eliminate\nthe warnings it generated. Plus some other cleanups such as\nprotecting against unsupported things like compiling two programs\nor not producing assembler output. A new PDPCLIB was released\nwhich had Linux support too.\n\nSeptember 2009 saw the port of 3.4.6, which had had multiple\nattempts made on it previously (stretching back several years),\nfinally produce a self-compiling native compiler, at least with\noptimization switched off, and not including the generated files.\n\nOctober 2009 saw a revamp of PDPCLIB for MVS by Gerhard, which\nmade things much more user-friendly by introducing default DCB\ninformation.\n\nNovember 2009 saw 3.4.6 having the 370 assembler files being\ncompletely generated via the normal (configure/make) build\nprocess.\n\nJanuary 2010 saw 3.2.3 ported to MUSIC/SP. It had been held up\ndue to an attempt to track down a paging error (MUSIC/SP was not\nconfigured with sufficient memory to prevent paging).\n\nMarch 2010 saw the release of the DOS/VS \"5 pack\", with S/380\nsupport then added to Hercules/380, effectively creating a\nVSE/380, which then saw PDPCLIB ported to some extent.\n\nApril 2010 saw GCC 3.2.3 running on VSE/380 and z/VSE, after\nbypassing various system restrictions. However, due to the\nincomplete PDPCLIB, GCC couldn't compile anything with #include\nin it.\n\nMay 2010 saw the release of GCC 3.2.3 MVS 8.0 which shipped with\nPDPCLIB 3.00 which had a major revamp of the MVS code to support\ndefault DCB information and able to run natively under TSO with\nPUTLINE.\n\nJanuary 2011 saw the release of GCC 3.2.3 MVS 8.5 which had a\nproperly working DOS/VSE port. Also VSE/380 1.0 was released.\nAlso PDOS had been developed and was a targetted system requiring\nsome MVS changes.\n\n\nPaul Edwards.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE853": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00D\\x01\\x193_\\x01\\x193_\\x08\\x04\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-12-01T00:00:00", "modifydate": "2019-12-01T08:04:44", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 853 is from Paul Edwards and contains the GCC C-Language  *   FILE 853\n//*           compiler and library, ported to MVS, z/OS, etc.       *   FILE 853\n//*           This release is GCC 3.4.6 MVS 1.0.  The GCC compilers *   FILE 853\n//*           for MVS can be found at:                              *   FILE 853\n//*                                                                 *   FILE 853\n//*           http://gccmvs.sourceforge.net    and see also:        *   FILE 853\n//*                                                                 *   FILE 853\n//*           http://pdos.sourceforge.net                           *   FILE 853\n//*                                                                 *   FILE 853\n//*           email:  mutazilah@gmail.com                           *   FILE 853\n//*                                                                 *   FILE 853\n//*         Welcome to GCCMVS (GCC for MVS, CMS and VSE)            *   FILE 853\n//*         a freely available 31-bit mainframe compiler            *   FILE 853\n//*         for C Language.                                         *   FILE 853\n//*                                                                 *   FILE 853\n//*     GCCMVS is a standalone compiler designed to run on MVS      *   FILE 853\n//*     (from z/OS all the way back to MVS 3.8j, and probably       *   FILE 853\n//*     beyond to PCP, but no-one has tested (or at least           *   FILE 853\n//*     reported) back that far) or CMS (z/VM and predecessors)     *   FILE 853\n//*     and VSE (z/VSE back to DOS/VS R34). It consists of two      *   FILE 853\n//*     distinct parts. Firstly, the standard GCC 3.4.6             *   FILE 853\n//*     compiler with some required code changes for MVS and        *   FILE 853\n//*     CMS. Secondly, PDPCLIB, which is a C runtime library        *   FILE 853\n//*     required for GCC to be able to run, and also for your       *   FILE 853\n//*     own programs to be able to run. Both things are             *   FILE 853\n//*     required, and both things are what is dubbed \"GCCMVS\".      *   FILE 853\n//*     Note that the licence for the GCC part is GPL while         *   FILE 853\n//*     PDPCLIB is public domain (explicit PD notice). Because      *   FILE 853\n//*     PDPCLIB is pure public domain, it means that there are      *   FILE 853\n//*     no licencing restrictions on executables you produce        *   FILE 853\n//*     yourself. ie commercial use is fine, and you can even       *   FILE 853\n//*     sell PDPCLIB (original or modified, including               *   FILE 853\n//*     proprietary modifications, with or without source) if       *   FILE 853\n//*     you find a market.                                          *   FILE 853\n//*                                                                 *   FILE 853\n//*     The source code and executables for GCCMVS can be found     *   FILE 853\n//*     at sourceforge                                              *   FILE 853\n//*     <http://sourceforge.net/projects/gccmvs>, in the            *   FILE 853\n//*     \"downloads\" link. There is also an old port of GCCMVS       *   FILE 853\n//*     to MUSIC/SP which is available here                         *   FILE 853\n//*     <http://webpages.mcgill.ca/staff/group3/dedwar1/web>.       *   FILE 853\n//*     Unfortunately the author of the MUSIC/SP version (Dave      *   FILE 853\n//*     Edwards) passed away, but the mainline source code does     *   FILE 853\n//*     MUSIC/SP now too, but it lacks nice packaging.  The MVS     *   FILE 853\n//*     version also works under PDOS/390.                          *   FILE 853\n//*                                                                 *   FILE 853\n//*     Porting the compiler to the mainframe opened up the         *   FILE 853\n//*     floodgates to lots of C code being able to be ported.       *   FILE 853\n//*     The downloads section contains some such applications.      *   FILE 853\n//*     The most impressive one is probably the \"diff3\"             *   FILE 853\n//*     utility. If you have never heard of a three-way diff,       *   FILE 853\n//*     you will not regret learning what it can do for you.        *   FILE 853\n//*                                                                 *   FILE 853\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GCCDOC": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x10m\\x10m\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 4205, "newlines": 4205, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCINC": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13q\\xf5q\\xf5\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 29173, "newlines": 29173, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCJCL": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x15\\xab\\x15\\xab\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 5547, "newlines": 5547, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCLINK": {"ttr": 17669, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 \\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\xff\\xff\\xff\\xff\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@\\x00\\x01yF\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCPROC": {"ttr": 58885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00~\\x00~\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCSRC": {"ttr": 59137, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 \\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\xff\\xff\\xff\\xff\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@\\x00\\x02\\xef\\xf1\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "GCCS2": {"ttr": 141062, "alias": false, "halfwords": 40, "notes": 0, "parms": "b\"\\x01\\x00 \\x00\\x01\\x115\\x9f\\x01\\x115\\x9f\\x00H\\xff\\xff\\xff\\xff\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@\\x00\\r&'\\x00\\x00\\xff\\xff\\x00\\x00\\x00\\x00\"", "ispf": {"version": "01.00", "flags": 32, "createdate": "2011-12-25T00:00:00", "modifydate": "2011-12-25T00:48:00", "lines": 65535, "newlines": 65535, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPDOC": {"ttr": 508929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x0b\\xed\\x0b\\xed\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 3053, "newlines": 3053, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPINC": {"ttr": 510209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x02Y\\x02Y\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 601, "newlines": 601, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPLINK": {"ttr": 510465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x11t\\x11t\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 4468, "newlines": 4468, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPMAC": {"ttr": 512260, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x02\\x13\\x02\\x13\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 531, "newlines": 531, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPNCAL": {"ttr": 512516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x08\\xbb\\x08\\xbb\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 2235, "newlines": 2235, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDPSRC": {"ttr": 513539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13]\\xc9]\\xc9\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 24009, "newlines": 24009, "modlines": 0, "user": "GCC346"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XMIT1": {"ttr": 523780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Define aliases for High-level qualifiers suitable\n//* for your site.\n//*\n//IDCAMS   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE ALIAS (NAME(GCC) RELATE(SYS1.UCAT.TSO)) -\n         CATALOG(SYS1.VMASTCAT/SECRET)\n  DEFINE ALIAS (NAME(PDPCLIB) RELATE(SYS1.UCAT.TSO)) -\n         CATALOG(SYS1.VMASTCAT/SECRET)\n  SET MAXCC=0\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT2": {"ttr": 523782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Allocate space for the sequential XMIT\n//* and the PDS of XMITs that it will be converted into\n//*\n//CREATE   PROC GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//* Put an explicit DSORG=PS to cater for buggy ftp programs\n//* that inspect a new dataset when they are the ones who are\n//* meant to be setting that attribute on the open-for-write\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(,CATLG),\n// DCB=(DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=3120),\n// SPACE=(3120,(30000,30000)),UNIT=SYSALLDA\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120),\n// SPACE=(3120,(30000,30000,44)),UNIT=SYSALLDA\n//         PEND\n//*\n//S1 EXEC CREATE\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT3": {"ttr": 523784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00 \\x00 \\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Note that by nature, the file from the PC is in an\n//* undefined format, since it's contents could be\n//* anything. We know it is in XMIT format though, but\n//* the generic tape setup facility doesn't know that\n//* unless you specifically tell it. This procedure\n//* assumes it is still in undefined format, and that\n//* this program (COPYFILE, rather that IEBGENER), will\n//* reform it into an FB80.\n//*\n//* Also note that the use of COPYFILE is just an example\n//* of assisted file transfer on one system. There's a\n//* very good chance that you won't even have the COPYFILE\n//* program unless you have previously installed an older\n//* version of GCC.\n//*\n//TRANSFER PROC GCCPREF='GCC',PDPPREF='PDPCLIB'\n//*\n//COPY     EXEC PGM=COPYFILE,PARM='-bb dd:in dd:out'\n//STEPLIB  DD DSN=&PDPPREF..LINKLIB,DISP=SHR\n//IN       DD DSN=HERC02.IN,DISP=OLD,\n//         UNIT=TAPE,VOL=SER=PCTOMF,LABEL=(1,NL),\n//         DCB=(RECFM=U,LRECL=0,BLKSIZE=6233)\n//OUT      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=OLD\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//         PEND\n//*\n//S1 EXEC TRANSFER\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT4": {"ttr": 523786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x19\\x00\\x19\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Receive the XMIT. Adjust the HLQs appropriately.\n//*\n//RECV1    PROC\n//*\n//RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)\n//SYSTERM  DD  SYSOUT=*\n//SYSABEND DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC RECV1\n//SYSTSIN  DD  *\nPROFILE PREFIX(GCC)\nRECEIVE INDSNAME('GCC.GCC.SEQ.XMIT')\n\nLISTC\n/*\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT5": {"ttr": 523788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x17\\x00\\x17\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Submit the job that receive the various XMITs\n//* Also the job that submits the example.\n//* And the cleanup job.\n//*\n//SUBMIT   PROC GCCPREF='GCC',MEMBER=''\n//*\n//SUBJOB   EXEC PGM=IEBGENER\n//SYSUT1   DD  DSN=&GCCPREF..GCC.PDS.XMIT(&MEMBER),DISP=SHR\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC SUBMIT,MEMBER='XMIT6'\n//*\n//S2 EXEC SUBMIT,MEMBER='XMIT7'\n//*\n//S3 EXEC SUBMIT,MEMBER='XMIT8'\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT6": {"ttr": 523790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\xae\\x00\\xae\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Preallocate all target PDSes.\n//* Then receive all the XMITs in the XMIT PDS.\n//* Adjust the HLQs appropriately.\n//*\n//CREATE   PROC PDPPREF='PDPCLIB',GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&PDPPREF..SOURCE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD3      DD DSN=&PDPPREF..DOC,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD5      DD DSN=&GCCPREF..SOURCE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD7      DD DSN=&GCCPREF..DOC,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD8      DD DSN=&GCCPREF..JCL,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD12     DD DSN=&PDPPREF..NCALIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD13     DD DSN=&PDPPREF..MACLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD14     DD DSN=&GCCPREF..S2,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//DD1      DD DSN=&PDPPREF..INCLUDE,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(23,23,44)),UNIT=SYSALLDA\n//DD2      DD DSN=&PDPPREF..SOURCE,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(350,350,44)),UNIT=SYSALLDA\n//DD3      DD DSN=&PDPPREF..DOC,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(50,50,44)),UNIT=SYSALLDA\n//DD4      DD DSN=&GCCPREF..PROCLIB,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(15,15,44)),UNIT=SYSALLDA\n//DD5      DD DSN=&GCCPREF..SOURCE,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(2860,2860,44)),UNIT=SYSALLDA\n//DD6      DD DSN=&GCCPREF..INCLUDE,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(450,450,44)),UNIT=SYSALLDA\n//DD7      DD DSN=&GCCPREF..DOC,DISP=(,CATLG),\n// DCB=(RECFM=VB,LRECL=255,BLKSIZE=6233),\n// SPACE=(6233,(100,100,44)),UNIT=SYSALLDA\n//DD8      DD DSN=&GCCPREF..JCL,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(90,90,44)),UNIT=SYSALLDA\n//DD10     DD DSN=&GCCPREF..LINKLIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(1900,1900,44),,,ROUND),UNIT=SYSALLDA\n//DD12     DD DSN=&PDPPREF..NCALIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(61,61,44)),UNIT=SYSALLDA\n//DD13     DD DSN=&PDPPREF..MACLIB,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(12,12,44)),UNIT=SYSALLDA\n//DD14     DD DSN=&GCCPREF..S2,DISP=(,CATLG),\n// DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),\n// SPACE=(6160,(12400,12400,44)),UNIT=SYSALLDA\n//DD16     DD DSN=&PDPPREF..LINKLIB,DISP=(,CATLG),\n// DCB=(RECFM=U,LRECL=0,BLKSIZE=6144),\n// SPACE=(6144,(77,77,44),,,ROUND),UNIT=SYSALLDA\n//         PEND\n//*\n//RECV2    PROC\n//*\n//RECV     EXEC PGM=IKJEFT01,DYNAMNBR=60\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=12100)\n//SYSTERM  DD  SYSOUT=*\n//SYSABEND DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//* Preallocate all datasets\n//S1 EXEC CREATE\n//*\n//* Now \"receive\" into those preallocated datasets, using\n//* the dataset substitutions below.\n//S2 EXEC RECV2\n//* Note that if you are trying to install this under your\n//* own userid, or otherwise need multiple levels of dataset\n//* name prefixes, you will need more than the profile prefix\n//* to get to the right names. You will need to manually\n//* specify the target dataset name. So on each of those\n//* blank lines you will need something like:\n//* DA('ABC.DEF.GCC.DOC').\n//* For your convenience, a second send of RECEIVE commands\n//* is included below in a DD statement that is not used.\n//* If you change that DD to SYSTSIN and rename the existing\n//* SYSTSIN to \"UNUSED\", it should work (on a z/OS system,\n//* anyway).\n//SYSTSIN  DD  *\nPROFILE PREFIX(GCC)\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCDOC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCJCL)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCLINK)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCPROC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCS2)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCSRC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(GCCINC)')\n\nPROFILE PREFIX(PDPCLIB)\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPDOC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPINC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPMAC)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPNCAL)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPLINK)')\n\nRECEIVE INDSNAME('GCC.GCC.PDS.XMIT(PDPSRC)')\n\nLISTC LEVEL(GCC)\nLISTC LEVEL(PDPCLIB)\n/*\n//*\n//* Rename this from UNUSED to SYSTSIN if this is more\n//* suitable for your use. Make sure you rename the other\n//* one from SYSTSIN to UNUSED if you do so though!\n//UNUSED   DD  *\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCDOC)')\nDA('ABC.DEF.GCC.DOC')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCJCL)')\nDA('ABC.DEF.GCC.JCL')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCLINK)')\nDA('ABC.DEF.GCC.LINKLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCPROC)')\nDA('ABC.DEF.GCC.PROCLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCS2)')\nDA('ABC.DEF.GCC.S2')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCSRC)')\nDA('ABC.DEF.GCC.SOURCE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(GCCINC)')\nDA('ABC.DEF.GCC.INCLUDE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPDOC)')\nDA('ABC.DEF.PDPCLIB.DOC')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPINC)')\nDA('ABC.DEF.PDPCLIB.INCLUDE')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPMAC)')\nDA('ABC.DEF.PDPCLIB.MACLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPNCAL)')\nDA('ABC.DEF.PDPCLIB.NCALIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPLINK)')\nDA('ABC.DEF.PDPCLIB.LINKLIB')\nRECEIVE INDSNAME('ABC.DEF.GCC.GCC.PDS.XMIT(PDPSRC)')\nDA('ABC.DEF.PDPCLIB.SOURCE')\nLISTC LEVEL(ABC.DEF.GCC)\nLISTC LEVEL(ABC.DEF.PDPCLIB)\n/*\n//*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMIT7": {"ttr": 523793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Submit the example job\n//*\n//SUBEXAMP PROC GCCPREF='GCC'\n//*\n//SUBJOB   EXEC PGM=IEBGENER\n//SYSUT1   DD  DSN=&GCCPREF..JCL(EXAMPLE),DISP=SHR\n//SYSUT2   DD  SYSOUT=(A,INTRDR)\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//         PEND\n//*\n//S1 EXEC SUBEXAMP\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XMIT8": {"ttr": 523795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x11\\x16O\\x01\\x11\\x16O\"\\x13\\x00\\x10\\x00\\x10\\x00\\x00\\xc7\\xc3\\xc3\\xf3\\xf4\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-06-13T00:00:00", "modifydate": "2011-06-13T22:13:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "GCC346"}, "text": "//GCCGEN   JOB CLASS=C,REGION=0K\n//*\n//* Delete temporary datasets\n//*\n//CLEAN    PROC GCCPREF='GCC'\n//DELETE   EXEC PGM=IEFBR14\n//DD1      DD DSN=&GCCPREF..GCC.SEQ.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//DD2      DD DSN=&GCCPREF..GCC.PDS.XMIT,DISP=(MOD,DELETE),\n//       UNIT=SYSALLDA,SPACE=(TRK,(0))\n//*\n//         PEND\n//*\n//S1 EXEC CLEAN\n//*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT853/FILE853.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT853", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}