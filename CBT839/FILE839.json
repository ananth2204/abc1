{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012924000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE839.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE839.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x06\\x11'", "DS1TRBAL": "b'U\\x88'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xd0\\x00\\x04\\x05\\xd0\\x00\\n\\x00\\x07'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x00\\x07\\x01\\x101\\x9f\\x01\\x101\\x9f\\x00\\x16\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-11-15T00:00:00", "modifydate": "2010-11-15T00:16:07", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-480"}, "text": "REGULAR CBT TAPE - VERSION 480    FILE:  839\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT480.FILE839\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 26 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,446 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/15/10    00:16:07    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COPYR": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x07\\x01\\x100O\\x01\\x101\\x8f\\x08\\x18\\x00\\x1d\\x00\\x1a\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-10-31T00:00:00", "modifydate": "2010-11-14T08:18:07", "lines": 29, "newlines": 26, "modlines": 0, "user": "CLARKE"}, "text": "*\n* COPYRIGHT Clement Clarke, CLARKE COMPUTER SOFTWARE 2010\n* ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n*\n* This program is provided free of charge, under the Apache Licence,\n* for Hercules and \"Hobbyist\" licences.\n*\n* However, you are definitely invited to contribute money if\n* you find this software useful. This will assist with the\n* development of new software and similar.\n*\n* There is no warranty - source code is provided so that the program\n* may be maintained.\n*\n* Note: You may not convert this program into a paid product, and all\n*       source code changes must be made available for everyone.\n*\n* Clement Clarke\n*\n* My email is clemclarke@gmail.com\n*          or clementclarke@ozemail.com.au\n* Tel Australia  Mobile  +61 401 056 155\n*\n*\n* These are stand alone programs.  They are inspired by Jol,\n*        the Universal Command Language for all computers.\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$READM": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00T\\x01\\x07\\x19/\\x01\\x101\\x8f\\x08!\\x00\\x19\\x00\\x13\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2007-07-11T00:00:00", "modifydate": "2010-11-14T08:21:54", "lines": 25, "newlines": 19, "modlines": 0, "user": "CLARKE"}, "text": "Please note:\n\nAll the software here is Copyright by me, Clement Victor Clarke\nor companies owned by me at one stage.\n\nMost of the software may be used free of charge for Planet Saving\nactivities.  Please, use it for Peaceful Activities.\n\nAnd companies making or saving money from any of the software might\nconsider paying me what they think it is truthfully worth to them.\n\nAnd all code changes must be made available for others.\n\nHow does it get any better than this?\n\nClement Clarke, Melbourne and Perth AUSTRALIA, Nov 14th, 2010\n\nclementclarke@ozemail.com.au or clemclarke@gmail.com.  Please put ***'s in the\nSubject Line.\n\nMany thanks,\n\nClement Clarke.\n\nTel Australia  Mobile  +61 401 056 155\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$AAAA": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x101\\x8f\\x01\\x101\\x8f\\x078\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T07:38:01", "lines": 21, "newlines": 21, "modlines": 0, "user": "CLARKE"}, "text": "Member:\n    $$CATPS     JCL: Contains a job to create some Catlogued Procedures\n    $$DOC       General Documentation\n    $ASMJOB     JCL: Job to Assemble and Link the programs\n    $PROCS      Description of sample Catalogued Procedures\n    DISPAUTH    PROGRAM: Display if a program is authorised.\n    EXECLONG    PROGRAM: Assembler code for EXECLONG\n    MAKEXMIT    JCL: Creates XMIT file containing this PDS\n    PARMCNTL    PROGRAM: Assembler code for PARMCNTL\n    SAVEPARM    PROGRAM: Assembler code for SAVEPARM\n\n    TCATDEF     Testing JCL\n    TEST01        \"\n    TEST02        \"\n    TEST99        \"\n    TFTP          \"\n    TPDSCOPY      \"\n    TPDSDELM      \"\n    TPDSREN       \"\n    TSORT         \"\n    **End**\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$CATPS": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x101\\x8f\\x01\\x101\\x8f\\x07#\\x00\\\\\\x00\\\\\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T07:23:10", "lines": 92, "newlines": 92, "modlines": 0, "user": "CLARKE"}, "text": "*************************************************\n\nNOTE:  Member $PROCS has some cataloged procedures that do the\n       following.\n\n1.     CATDEF   PROC  CAT=,NAME=,VOL=,DEVT=3380\n\n       Executes IDCAMS to create a catalog.\n\n       When Executed like this:\n\n       // EXEC CATDEF,CAT=SYS1.UCAT.MVS,NAME=GCC.ASM,VOL=JOL60,\n       //      DEVT=3380\n\n       the following control cards are created for IDCAMS.\n       We can see that the symbolic parameters copied into\n       the control file for IDCAMS, and IDCAM is run.\n\n        DEFINE CAT (SYS1.UCAT.MVS) NONVSAM -\n        ( NAME (GCC.ASM) -\n          VOL (JOL60) DEVT (3380))\n\n2.     FTP    PROC  INDSN=,OUTDSN=,PASSWORD=,HOST=,USER=\n\n       Executes FTP to transfer a file.\n\n       When Executed like this:\n\n       //  EXEC FTP,HOST=192.10.10.1,USER='userid',PASSWORD='mypassword',\n       // INDSN=NULLFILE,OUTDSN=FROM.MAINFRAME\n\n       the following control cards are created for FTP.\n       We can see that the symbolic parameters copied into\n       the control file for FTP, and FTP is run.\n\n       There is a DDCARD 'IN' created, which FTP uses.  It can be\n       a GDG, or temporary file.\n\n        192.10.10.1\n        userid\n        mypassword\n        SENDSITE\n        PUT //dd:in FROM.MAINFRAME\n        quit\n\n3.     PDSCOPYS PROC  INDSN=,OUTDSN=,SELECT=\n\n       Executes IEBCOPY to copy selected members to another\n       PDS.\n\n       When Executed like this:\n\n       //  EXEC COPYPDSS,INDSN='SYS1.PROCLIB',OUTDSN=&&TEMP,\n       //       SELECT='RDR,INIT,NONO'\n\n       the members RDR,INIT,NONO are copied to the &&TEMP\n       data set.\n\n4.     PDSRENM  PROC  INDSN=,MEM=,NEWNAME=\n\n       Executes IDCAMS to rename a member is the specified\n       INDSN PDS.  Only one member can be specified.\n\n       When Executed like this:\n\n       // EXEC PDSRENM,INDSN=CLARKE.TEST2.PDS,MEM=RDR,\n       // NEWNAME=RDR4\n\n       the member RDR is renamed to RDR4.\n\n5.     PDSDELM  PROC  INDSN=,MEM=\n\n       Executes IDCAMS to delete a selected member from the\n       INDSN PDS.  Only one member can be specified.\n\n       When Executed like this:\n\n       // EXEC PDSDELM,INDSN=CLARKE.TEST2.PDS,MEM=RDR\n\n       the member RDR is deleted from the CLARKE.TEST2.PDS\n\n6.     SORT   PROC  INDSN=,OUTDSN=,OUTDISP=NEW,FIELDS=,CYLS=5\n\n       Executes SORT to sort a file.\n\n       When Executed like this:\n\n       //  EXEC SORT,INDSN=&&TEMPSRT,OUTDSN=&&TEMP,\n       //       FIELDS='(69,2,CH,A)'\n\n       the data set &&TEMPSRT is sorted to &&TEMP,\n       using the parameters specified.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DOC": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x07\\x01\\x100O\\x01\\x101\\x8f\\x109\\x00\\\\\\x00J\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-10-31T00:00:00", "modifydate": "2010-11-14T10:39:07", "lines": 92, "newlines": 74, "modlines": 0, "user": "CLARKE"}, "text": "      Long Parameters and Symbolic Parameter replacement\n                in card image control cards.\n\nThe following programs are now available that will allow the\nabove to happen, using conventional JCL or TSO.\n\n1. EXECLONG will execute a program with up to 3,000 bytes as a\n   parameter.\n\n2. PARMCNTL creates either Fixed or Variable blocked control file\n   from a Parameter, or other control file.\n\n3. SAVEPARM saves parameters into a VB file which is used by\n   EXECLONG and/or PARMCNTL above.\n\nFurther Description:\n\n1. EXECLONG executes the program specified with the\n   PARM='PGM=program-name'.  It first reads a VB file allocated\n   with a DDNAME of $$PARM, and creates a standard parameter of\n   up to 3,000 bytes.\n\n   Standard APF facilities are used, so Authorised or\n   Non-Authorised programs may be used.\n\n2. PARMCNTL creates either FB or VB control files from either the\n   VB $$PARM file.\n\n   PARMCNTL creates a file using the $$CNTL file.  It either\n   takes it's input from the parameter field, or, if that is\n   null, it reads from the $$PARM file.\n\n   New control cards are created on finding a LF (X'25')\n   character, or <p>.\n\n   After forming up the parameter fields or the records from the\n   $$PARM DD File, the following parameters are allowed:\n\n      PGM=program-name  - Program to be executed.\n      DDN=ddname        - Instead of the $$CNTL,\n                          use ddsname instead.\n      PARM='parameter'  - Use this parameter.\n                          Quotes are not allowed.\n\n3. SAVEPARM appends it's parameter to the VB $$PARM file.\n   Symbolic parameters may be used in the PGM PARM field, and\n   hence can be used by the PARMCNTL program to create control\n   files with symbolic parameters replaced.\n\n\nExamples.\n\n1. Execute a program with a long parameter:\n\n//EXEC01    EXEC PGM=SAVEPARM,\n// PARM='Start of a long parameter.  It can have symbolics, too. '\n//$$PARM    DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//              UNIT=SYSDA,SPACE=(TRK,10),\n//              DISP=(NEW,PASS)\n//EXEC02    EXEC PGM=SAVEPARM,\n// PARM='This is the second part of the long parameter.'\n//$$PARM    DD  DSN=&&PARM, DISP=(OLD,PASS)\n//*\n//EXEC03    EXEC PGM=EXECLONG,\n// PARM='PGM=xyz'\n//$$PARM    DD  DSN=&&PARM, DISP=(OLD,DELETE)\n\nThis executes program xyz, with the parameters formed from the\n$$PARM file.\n\n2. Create Control card from parameters.\n\nNote the use of the Symbolic in the Parm Field.  And the <p> acts\nas a Line Feed when creating the control cards.\n\n//EXEC02    EXEC PGM=PARMCNTL,\n// PARM='Control Card1<p>Control Card2<p>Password=&PASS.<p>'\n//$$CNTL    DD  DSN=&&CNTL,DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//              UNIT=SYSDA,SPACE=(TRK,10),\n//              DISP=(NEW,PASS)\n//EXEC03    EXEC PGM=FTP\n//SYSIN     DD  DSN=&&CNTL, DISP=(OLD,DELETE)\n\nNote that if the control cards need more than 100 characters that\nare allowed in the conventional program parameter field, we can\nuse the SAVEPARM program repeatedly to create up to 3,000\ncharacters of text, which then can be used by the PARMCNTL\nprogram to create many Control cards.\n\nFor more information, please email me at:\n\nclemclarke@gmail.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$TODO": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x101\\x8f\\x01\\x101\\x8f\\x08\\x03\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T08:03:43", "lines": 18, "newlines": 18, "modlines": 0, "user": "CLARKE"}, "text": "There are a few items that need some comment:\n\n1. The program do not convert parameters etc to Upper Case.\n   Perhaps they should?\n\n2. Sometime in the future, I will add the Jol Automatic Symbolics\n   such as SYSUID, SYSDATE, DAY, etc (See the Jol documentation).\n\nEnjoy the programs.\n\nPlease get back to me if you would like changes.\n\nCheers,\n\nClement Clarke\n\nclementclarke@ozemail.com.au, or clemclarke@gmail.com\nBest put **** in the subject line.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ASMJOB": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x101_\\x01\\x101_\\x05C\\x00Q\\x00P\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2010-11-11T05:43:54", "lines": 81, "newlines": 80, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKE1 JOB (0000,0000),NAME,NOTIFY=CLARKE,REGION=1024K,\n// MSGCLASS=X TYPRUN=SCAN\n//ASMLINK PROC\n//*\n//* Run this JOB to install programs EXECLONG, SAVEPARM and PARMCNTL\n//*\n//* EXECLONG allows you to use parameters up to 3,000 characters.\n//* SAVEPARM allows you to save parameters to a disk file.\n//* PARMCNTL creates a SYSIN style file from the Program Parameters,\n//*  OR from the $$PARM file (if present).\n//* DISPAUTH displays a message saying if it is Authorised, or not.\n//*\n//**     N O T E\n//*\n//*    YOU MUST ALTER the Link Libraries to the the libraries for your\n//*      Installation.  See Exec's below.\n//*\n//*    EXECLONG and PARMCNTL MUST BE Authorised\n//*      if you wish to run Authorised Programs with Long Parameters.\n//*      or using (say) IEBCOPY with the PARMCNTL program.\n//*\n//*\n//**     N O T E  2\n//*\n//*    These were assembled, developed and tested using IFOX with Hercules.\n//*      You may need to change some JCL or Assembler code for\n//*      later versions of the Operating System.\n//*\n//*\n//********************************************\n//* EXECLONG Assemblies and Links\n//********************************************\n//ASM      EXEC PGM=ASMBLR,\n// PARM='LIST,RENT,OBJ,NODECK,TEST,SYSPARM(OS=MVS)'\n//STEPLIB  DD   DSN=SYS2.LINKLIB,DISP=SHR\n//         DD   DSN=SYS1.LINKLIB,DISP=SHR,VOL=SER=JOL53,UNIT=3380\n//SYSPRINT DD   SYSOUT=*\n//SYSLIB   DD   DSN=MVS38.SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=19040\n//SYSLIB   DD   DISP=SHR,DSN=SYS1.MACLIB\n//*        DD   DISP=SHR,DSN=SYS1.AMODGEN\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT2   DD   UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSUT3   DD   UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSGO    DD   DSN=&&OBJ,DISP=(,PASS),SPACE=(TRK,(5,5)),\n//         UNIT=SYSDA,DCB=BLKSIZE=400\n//************************************************\n//* LINK Program\n//************************************************\n//LKED     EXEC PGM=IEWL,PARM='LIST,MAP,RENT'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=SYSDA,SPACE=(CYL,1)\n//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)\n// PEND\n//*\n//************************************************\n//*\n//* Do Assemblies and Links\n//*\n//*\n//* You May want to change the Link Libraries, and\n//* the Assembler input Data Sets Names.\n//*\n//************************************************\n//*\n//* Note:  Authorisation is required to run Authorised Programs.\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=CLARKE.EXECSPEC.ASM(EXECLONG),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.LINKLIB(EXECLONG),DISP=SHR\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=CLARKE.EXECSPEC.ASM(PARMCNTL),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.LINKLIB(PARMCNTL),DISP=SHR\n//*\n// EXEC ASMLINK\n//ASM.SYSIN    DD  DSN=CLARKE.EXECSPEC.ASM(SAVEPARM),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.LINKLIB(SAVEPARM),DISP=SHR\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=CLARKE.EXECSPEC.ASM(DISPAUTH),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.LINKLIB(DISPAUTH),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ASMJOBZ": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\t\\x01\\x101_\\x01\\x101\\x8f\\x12X\\x00M\\x00P\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2010-11-14T12:58:09", "lines": 77, "newlines": 80, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBZ JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//ASMLINK PROC\n//*\n//* Run this JOB to install programs EXECLONG, SAVEPARM and PARMCNTL\n//*\n//* EXECLONG allows you to use parameters up to 3,000 characters.\n//* SAVEPARM allows you to save parameters to a disk file.\n//* PARMCNTL creates a SYSIN style file from the Program Parameters,\n//*  OR from the $$PARM file (if present).\n//* DISPAUTH displays a message saying if it is Authorised, or not.\n//*\n//**     N O T E\n//*\n//*    YOU MUST ALTER the Link Libraries to the the libraries for your\n//*      Installation.  See Exec's below.\n//*\n//*    EXECLONG and PARMCNTL MUST BE Authorised\n//*      if you wish to run Authorised Programs with Long Parameters.\n//*      or using (say) IEBCOPY with the PARMCNTL program.\n//*\n//*\n//**     N O T E  2\n//*\n//*    These were assembled, developed and tested using IFOX with Hercules.\n//*      You may need to change some JCL or Assembler code for\n//*      later versions of the Operating System.\n//*\n//*\n//********************************************\n//* EXECLONG Assemblies and Links\n//********************************************\n//ASM      EXEC PGM=ASMA90,\n// PARM='LIST,RENT,OBJ,NODECK,TEST'\n//SYSPRINT DD   SYSOUT=*\n//SYSLIB   DD   DISP=SHR,DSN=SYS1.MACLIB\n//         DD   DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD   UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//************************************************\n//* LINK Program\n//************************************************\n//LKED     EXEC PGM=HEWL,PARM='LIST,MAP,RENT'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=VIO,SPACE=(CYL,1)\n//SYSLIN   DD   DSN=&&TEMP,DISP=(OLD,DELETE)\n// PEND\n//*\n//************************************************\n//*\n//* Do Assemblies and Links\n//*\n//*\n//* You May want to change the Link Libraries, and\n//* the Assembler input Data Sets Names.\n//*\n//************************************************\n//*\n//* Note:  Authorisation is required to run Authorised Programs.\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=SBGOLOB.TEST.FILE839(EXECLONG),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.W$$.LINKLIB(EXECLONG),DISP=SHR\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=SBGOLOB.TEST.FILE839(PARMCNTL),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.W$$.LINKLIB(PARMCNTL),DISP=SHR\n//*\n// EXEC ASMLINK\n//ASM.SYSIN    DD  DSN=SBGOLOB.TEST.FILE839(SAVEPARM),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.W$$.LINKLIB(SAVEPARM),DISP=SHR\n//*\n// EXEC ASMLINK,PARM.LKED='LIST,MAP,RENT,AC=1'\n//ASM.SYSIN    DD  DSN=SBGOLOB.TEST.FILE839(DISPAUTH),DISP=SHR\n//LKED.SYSLMOD DD DSN=SYS1.W$$.LINKLIB(DISPAUTH),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PROCS": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00'\\x01\\x10\\x06\\x9f\\x01\\x101\\x8f\\x07T\\x00\\x9c\\x00i\\x00\\x83\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-03-10T00:00:00", "modifydate": "2010-11-14T07:54:27", "lines": 156, "newlines": 105, "modlines": 131, "user": "CLARKE"}, "text": "//MVSJOB2 JOB (0000,0000),NAME,NOTIFY=USER,REGION=1024K, <<<===========\n// MSGCLASS=X,TYPRUN=SCAN\n//CATLOAD PROC SOUT='*',                <<<======================\n//             PROCLIB='SYS2.PROCLIB'            <<<============\n//**     N O T E\n//*\n//*    YOU MUST ALTER THE INDEX PARAMETER ABOVE TO BE THE HIGH LEVEL\n//*      INDEX YOU REQUIRE.\n//*\n//*\n//***************************************************************\n//***************************************************************\n//**************                                 ****************\n//*********                                           ***********\n//*********   COPY CATALOGUED PROCEDURES TO PROCLIB   ***********\n//*********                                           ***********\n//**************                                 ****************\n//***************************************************************\n//***************************************************************\n//PROCCOPY EXEC PGM=IEBUPDTE\n//SYSPRINT DD  SYSOUT=&SOUT\n//SYSUT1   DD  DSN=&PROCLIB,DISP=SHR\n//SYSUT2   DD  DSN=&PROCLIB,DISP=SHR\n//    PEND\n//  EXEC  CATLOAD\n//PROCCOPY.SYSIN DD DATA\n./ ADD NAME=FTPTEST\n//FTPTEST PROC  INDSN=,OUTDSN=,PASSWORD=,HOST=,USER=\n//*\n//* THIS HAS NOT BEEN TESTED. I DO NOT HAVE FTP ACCESS.\n//* SEE THE MEMBER TFTP TO TEST IT.\n//*\n//* THIS PROCEDURE COPIES INFORMATION FOR AN FTP TO A VB FILE,\n//* IN THE FIRST TWO STEPS.\n//*\n//* EXECFTP EXECUTES THE FTP PROGRAM AFTER CREATING A CONTROL FILE\n//*        FORMED FROM THE VB FILE CREATED IN THE EARLIER STEPS.\n//*\n//* THANKS TO WALTER MARGUCCIO <WALTER_MARGUCCIO@YAHOO.COM>\n//* AND OTHERS IN IBMMAIN FOR THE IDEA OF THE //DD:IN\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=FTP,DDN=INPUT,PARM=''(EXIT''',\n//  ' &HOST <P> &USER <P> &PASSWORD. <P>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' SENDSITE <P> PUT //DD:IN &OUTDSN <P> QUIT '\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//*\n//EXECFTP  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* CALL PARMCNTL FROM EXECLONG. IT WILL CREATE CONTROL CARDS,\n//* AND EXECUTE THE PROGRAM (FTP) THAT WAS SPECIFIED IN THE\n//* FIRST STEP.\n//SYSUDUMP DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//IN       DD  DSN=&INDSN,DISP=(SHR,PASS)\n//* CHANGE THIS NEXT DD TO A SIMPLE WORK FILE AFTER TESTING.\n//INPUT    DD  DSN=&&CNTL,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(,PASS)\n//* NEXT STEP SIMPLY PRINTS OUT THE CREATE CONTROL FILE.\n//* AFTER TESTING, PLEASE REMOVE IT.\n//EXEC03   EXEC PGM=IEBGENER,COND=EVEN\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&CNTL,DISP=OLD VOL=REF=*.$$PARM\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n./ ADD NAME=PDSCOPYS\n//PDSCOPYS PROC  INDSN=,OUTDSN=,SELECT=\n//*\n//* THIS EXAMPLE EXECUTES IEBCOPY.    IT IS SIMILAR TO\n//* THE JOL COPY COMMAND (SEE JOL).\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IEBCOPY,DDN=SYSIN',\n//       ' C I=SYSUT1,O=SYSUT2<P> S M=&SELECT <P> ')\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   CREATED BY PROG.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&INDSN,DISP=SHR\n//SYSUT2   DD  DSN=&OUTDSN,DISP=OLD\n./ ADD NAME=PDSDELM\n//PDSDELM  PROC  INDSN=,MEM=\n//*\n//* THIS EXAMPLE EXECUTES IDCAMS.\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//       ' DELETE &INDSN(&MEM) FILE(PDS)')\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=PDSRENM\n//PDSRENM  PROC  INDSN=,MEM=,NEWNAME=\n//*\n//* THIS EXAMPLE EXECUTES IDCAMS TO RENAME A MEMBER.\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' ALTER  &INDSN(&MEM) FILE(PDS) - <P> NEWNAME(&INDSN(&NEWNAME))')\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=SORT\n//SORT   PROC  INDSN=,OUTDSN=,OUTDISP=NEW,FIELDS=,CYLS=5\n//*\n//* THIS EXAMPLE EXECUTES THE MVS SORT.  IT IS SIMILAR TO\n//* THE JOL SORT COMMAND (SEE JOL).\n//*\n//EXEC01      EXEC PGM=PARMCNTL,\n// PARM='PGM=SORT,DDN=SYSIN,PARM=''SIZE=MAX'', SORT FIELDS=&FIELDS<P>'\n//STEPLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   CREATED BY PROG.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SORTMSG  DD  SYSOUT=*\n//SORTIN   DD  DSN=&INDSN,DISP=SHR\n//SORTOUT  DD  DSN=&OUTDSN,DCB=(RECFM=VB,LRECL=2000,BLKSIZE=20000),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(&OUTDISP,CATLG)\n//SORTWK01 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK02 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK03 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK04 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n./ ADD NAME=CATDEF\n//CATDEF   PROC  CAT=,NAME=,VOL=,DEVT=3380\n//*\n//* THIS PROCEDURE COPIES INFORMATION FOR AN DEFINE TO A VB FILE,\n//* IN THE FIRST TWO STEPS.\n//*\n//* IT REQUIRES 3 STEPS BECAUSE THE PARAMETERS COULD EASILY RUN\n//*        OVER A 100 CHARACTERSE FOR A DEFINE CAT.\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' DEFINE CAT (&CAT) NONVSAM - <P>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' ( NAME (&NAME) - <P>   VOL (&VOL) DEVT (&DEVT))'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//EXECDEF  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* CALL PARMCNTL FROM EXECLONG. IT WILL CREATE CONTROL CARDS,\n//* AND EXECUTE THE PROGRAM (IDCAMS) THAT WAS SPECIFIED IN THE\n//* FIRST STEP.\n//SYSPRINT DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,DELETE)\n//* SYSIN BELOW IS WRITTEN TO BY PARMCNTL, THEN IDCAMS READS IT.\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=SORT\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$PROCSZ": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00$\\x01\\x10\\x06\\x9f\\x01\\x101\\x9f\\x00\\x08\\x00\\x9d\\x00i\\x00\\x87\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2010-03-10T00:00:00", "modifydate": "2010-11-15T00:08:24", "lines": 157, "newlines": 105, "modlines": 135, "user": "IBMUSER"}, "text": "//SBGOLOBZ JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//CATLOAD PROC SOUT='*',                <<<======================\n//             PROCLIB='SYS1.PROCLIB'            <<<============\n//**     N O T E\n//*\n//*    YOU MUST ALTER THE INDEX PARAMETER ABOVE TO BE THE HIGH LEVEL\n//*      INDEX YOU REQUIRE.\n//*\n//*\n//***************************************************************\n//***************************************************************\n//**************                                 ****************\n//*********                                           ***********\n//*********   COPY CATALOGUED PROCEDURES TO PROCLIB   ***********\n//*********                                           ***********\n//**************                                 ****************\n//***************************************************************\n//***************************************************************\n//PROCCOPY EXEC PGM=IEBUPDTE\n//SYSPRINT DD  SYSOUT=&SOUT\n//SYSUT1   DD  DSN=&PROCLIB,DISP=SHR\n//SYSUT2   DD  DSN=&PROCLIB,DISP=SHR\n//    PEND\n//  EXEC  CATLOAD\n//PROCCOPY.SYSIN DD DATA\n./ ADD NAME=FTPTEST\n//FTPTEST PROC  INDSN=,OUTDSN=,PASSWORD=,HOST=,USER=\n//*\n//* THIS HAS NOT BEEN TESTED. I DO NOT HAVE FTP ACCESS.\n//* SEE THE MEMBER TFTP TO TEST IT.\n//*\n//* THIS PROCEDURE COPIES INFORMATION FOR AN FTP TO A VB FILE,\n//* IN THE FIRST TWO STEPS.\n//*\n//* EXECFTP EXECUTES THE FTP PROGRAM AFTER CREATING A CONTROL FILE\n//*        FORMED FROM THE VB FILE CREATED IN THE EARLIER STEPS.\n//*\n//* THANKS TO WALTER MARGUCCIO <WALTER_MARGUCCIO@YAHOO.COM>\n//* AND OTHERS IN IBMMAIN FOR THE IDEA OF THE //DD:IN\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=FTP,DDN=INPUT,PARM=''(EXIT''',\n//  ' &HOST <P> &USER <P> &PASSWORD. <P>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' SENDSITE <P> PUT //DD:IN &OUTDSN <P> QUIT '\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//*\n//EXECFTP  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* CALL PARMCNTL FROM EXECLONG. IT WILL CREATE CONTROL CARDS,\n//* AND EXECUTE THE PROGRAM (FTP) THAT WAS SPECIFIED IN THE\n//* FIRST STEP.\n//SYSUDUMP DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//IN       DD  DSN=&INDSN,DISP=(SHR,PASS)\n//* CHANGE THIS NEXT DD TO A SIMPLE WORK FILE AFTER TESTING.\n//INPUT    DD  DSN=&&CNTL,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(,PASS)\n//* NEXT STEP SIMPLY PRINTS OUT THE CREATE CONTROL FILE.\n//* AFTER TESTING, PLEASE REMOVE IT.\n//EXEC03   EXEC PGM=IEBGENER,COND=EVEN\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&CNTL,DISP=OLD VOL=REF=*.$$PARM\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n./ ADD NAME=PDSCOPYS\n//PDSCOPYS PROC  INDSN=,OUTDSN=,SELECT=\n//*\n//* THIS EXAMPLE EXECUTES IEBCOPY.    IT IS SIMILAR TO\n//* THE JOL COPY COMMAND (SEE JOL).\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IEBCOPY,DDN=SYSIN',\n//       ' C I=SYSUT1,O=SYSUT2<P> S M=&SELECT <P> ')\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   CREATED BY PROG.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&INDSN,DISP=SHR\n//SYSUT2   DD  DSN=&OUTDSN,DISP=OLD\n./ ADD NAME=PDSDELM\n//PDSDELM  PROC  INDSN=,MEM=\n//*\n//* THIS EXAMPLE EXECUTES IDCAMS.\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//       ' DELETE &INDSN(&MEM) FILE(PDS)')\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=PDSRENM\n//PDSRENM  PROC  INDSN=,MEM=,NEWNAME=\n//*\n//* THIS EXAMPLE EXECUTES IDCAMS TO RENAME A MEMBER.\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' ALTER  &INDSN(&MEM) FILE(PDS) - <P> NEWNAME(&INDSN(&NEWNAME))')\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=SORT\n//SORT   PROC  INDSN=,OUTDSN=,OUTDISP=NEW,FIELDS=,CYLS=5\n//*\n//* THIS EXAMPLE EXECUTES THE MVS SORT.  IT IS SIMILAR TO\n//* THE JOL SORT COMMAND (SEE JOL).\n//*\n//EXEC01      EXEC PGM=PARMCNTL,\n// PARM='PGM=SORT,DDN=SYSIN,PARM=''SIZE=MAX'', SORT FIELDS=&FIELDS<P>'\n//STEPLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   CREATED BY PROG.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SORTMSG  DD  SYSOUT=*\n//SORTIN   DD  DSN=&INDSN,DISP=SHR\n//SORTOUT  DD  DSN=&OUTDSN,DCB=(RECFM=VB,LRECL=2000,BLKSIZE=20000),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(&OUTDISP,CATLG)\n//SORTWK01 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK02 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK03 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK04 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n./ ADD NAME=CATDEF\n//CATDEF   PROC  CAT=,NAME=,VOL=,DEVT=3380\n//*\n//* THIS PROCEDURE COPIES INFORMATION FOR AN DEFINE TO A VB FILE,\n//* IN THE FIRST TWO STEPS.\n//*\n//* IT REQUIRES 3 STEPS BECAUSE THE PARAMETERS COULD EASILY RUN\n//*        OVER 100 CHARACTERS FOR A DEFINE CAT.\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' DEFINE CAT (&CAT) NONVSAM - <P>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' ( NAME (&NAME) - <P>   VOL (&VOL) DEVT (&DEVT))'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//EXECDEF  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* CALL PARMCNTL FROM EXECLONG. IT WILL CREATE CONTROL CARDS,\n//* AND EXECUTE THE PROGRAM (IDCAMS) THAT WAS SPECIFIED IN THE\n//* FIRST STEP.\n//SYSPRINT DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,DELETE)\n//* SYSIN BELOW IS WRITTEN TO BY PARMCNTL, THEN IDCAMS READS IT.\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n./ ADD NAME=SORT\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE839": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x00B\\x01\\x101\\x9f\\x01\\x101\\x9f\\x00\\x15\\x00Q\\x00Q\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-11-15T00:00:00", "modifydate": "2010-11-15T00:15:42", "lines": 81, "newlines": 81, "modlines": 0, "user": "CBT-480"}, "text": "//***FILE 839 is from Clement Clarke and contains programs to       *   FILE 839\n//*           allow for long PARM fields and symbolic parameter     *   FILE 839\n//*           substitution in card image format control cards.      *   FILE 839\n//*                                                                 *   FILE 839\n//*       Description:                                              *   FILE 839\n//*                                                                 *   FILE 839\n//*          Long Parameters and Symbolic Parameter                 *   FILE 839\n//*          replacement in card image control cards.               *   FILE 839\n//*                                                                 *   FILE 839\n//*       The following programs are now available that will        *   FILE 839\n//*       allow the above to happen, using conventional JCL or      *   FILE 839\n//*       TSO.                                                      *   FILE 839\n//*                                                                 *   FILE 839\n//*       1. EXECLONG will execute a program with up to 3,000       *   FILE 839\n//*          bytes as a parameter.                                  *   FILE 839\n//*                                                                 *   FILE 839\n//*       2. PARMCNTL creates either Fixed or Variable blocked      *   FILE 839\n//*          control file from a Parameter, or other control        *   FILE 839\n//*          file.                                                  *   FILE 839\n//*                                                                 *   FILE 839\n//*       3. SAVEPARM saves parameters into a VB file which is      *   FILE 839\n//*          used by EXECLONG and/or PARMCNTL above.                *   FILE 839\n//*                                                                 *   FILE 839\n//*       Further Description:                                      *   FILE 839\n//*                                                                 *   FILE 839\n//*       1. EXECLONG executes the program specified with the       *   FILE 839\n//*          PARM='PGM=program-name'.  It first reads a VB file     *   FILE 839\n//*          allocated with a DDNAME of $$PARM, and creates a       *   FILE 839\n//*          standard parameter of up to 3,000 bytes.               *   FILE 839\n//*                                                                 *   FILE 839\n//*          Standard APF facilities are used, so Authorised or     *   FILE 839\n//*          Non-Authorised programs may be used.                   *   FILE 839\n//*                                                                 *   FILE 839\n//*       2. PARMCNTL creates either FB or VB control files from    *   FILE 839\n//*          either the VB $$PARM file.                             *   FILE 839\n//*                                                                 *   FILE 839\n//*          PARMCNTL creates a file using the $$CNTL file.  It     *   FILE 839\n//*          either takes it's input from the parameter field,      *   FILE 839\n//*          or, if that is null, it reads from the $$PARM file.    *   FILE 839\n//*                                                                 *   FILE 839\n//*          New control cards are created on finding a LF (X'25')  *   FILE 839\n//*          character, or <p>.                                     *   FILE 839\n//*                                                                 *   FILE 839\n//*          After forming up the parameter fields or the records   *   FILE 839\n//*          from the $$PARM DD File, the following parameters      *   FILE 839\n//*          are allowed:                                           *   FILE 839\n//*                                                                 *   FILE 839\n//*             PGM=program-name  - Program to be executed.         *   FILE 839\n//*             DDN=ddname        - Instead of the $$CNTL,          *   FILE 839\n//*                                 use ddsname instead.            *   FILE 839\n//*             PARM='parameter'  - Use this parameter.             *   FILE 839\n//*                                 Quotes are not allowed.         *   FILE 839\n//*                                                                 *   FILE 839\n//*       3. SAVEPARM appends it's parameter to the VB $$PARM       *   FILE 839\n//*          file.  Symbolic parameters may be used in the PGM      *   FILE 839\n//*          PARM field, and hence can be used by the PARMCNTL      *   FILE 839\n//*          program to create control files with symbolic          *   FILE 839\n//*          parameters replaced.                                   *   FILE 839\n//*                                                                 *   FILE 839\n//*       This program is provided free of charge, under the        *   FILE 839\n//*       Apache Licence, for Hercules and \"Hobbyist\"               *   FILE 839\n//*       licences.                                                 *   FILE 839\n//*                                                                 *   FILE 839\n//*       However, you are definitely invited to contribute         *   FILE 839\n//*       money if you find this software useful. This will         *   FILE 839\n//*       assist with the development of new software and           *   FILE 839\n//*       similar.                                                  *   FILE 839\n//*                                                                 *   FILE 839\n//*       There is no warranty - source code is provided so         *   FILE 839\n//*       that the program may be maintained.                       *   FILE 839\n//*                                                                 *   FILE 839\n//*       Note: You may not convert this program into a paid        *   FILE 839\n//*             product, and all source code changes must be        *   FILE 839\n//*             made available for everyone.                        *   FILE 839\n//*                                                                 *   FILE 839\n//*       Clement Clarke                                            *   FILE 839\n//*                                                                 *   FILE 839\n//*       My email is clemclarke@gmail.com                          *   FILE 839\n//*                or clementclarke@ozemail.com.au                  *   FILE 839\n//*       Tel Australia  Mobile  +61 401 056 155                    *   FILE 839\n//*                                                                 *   FILE 839\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPAUTH": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00Y\\x01\\x10'?\\x01\\x101\\x8f\\x08\\x08\\x00\\x11\\x01\\x0e\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2010-09-30T00:00:00", "modifydate": "2010-11-14T08:08:59", "lines": 17, "newlines": 270, "modlines": 0, "user": "CLARKE"}, "text": "DISPAUTH CSECT                                                   88036\n         USING DISPAUTH,12                                       88036\n         LR    12,15                                             88036\n         LR    2,1                                               88036\n         TESTAUTH                                                88036\n         LTR   15,15                                             88036\n         BNZ   GO                                                88036\n         WTO   'DispAuth: I am Authorised',                            *\n               ROUTCDE=(2,11)\n         MODESET MODE=SUP                                        88036\n         B     XCTL\nGO       LR    1,2                                               88036\n         WTO   'DispAuth: I am NOT Authorised',                        *\n               ROUTCDE=(2,11)\nXCTL     XCTL  EP=IEFBR14\n*        XCTL  EP=$DYNX8MN                                       88036\n         END   DISPAUTH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXECLONG": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x101_\\x01\\x101_\\x05$\\x01G\\x01G\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2010-11-11T05:24:11", "lines": 327, "newlines": 327, "modlines": 0, "user": "CLARKE"}, "text": "EXECLONG   TITLE 'Attach User Module Using Long Parameter'\n*\n* COPYRIGHT Clement Clarke, CLARKE COMPUTER SOFTWARE 2010\n* ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n*\n* This program is provided free of charge, under the Apache Licence,\n* for Hercules and \"Hobbyist\" licences.\n*\n* However, you are invited to contribute if\n* you find this software useful. And this will assist with the\n* development of new software.\n*\n* There is no warranty - source code is provided so that the program\n* may be maintained.\n*\n* Note: You may not convert this program into a paid product, and all\n*       source code changes must be made available for everyone.\n*\n* My email is clemclarke@gmail.com\n*\n*\n* This a stand alone program.  It is inspired by Jol,\n*        the Universal Command Language for all computers.\n*\n* Note: Versions of Jol exist for Z/OS, VSE, Windows, Linux, OS/2,\n*       and soon Macs.\n*\n*\n*\n*                   J             000000            L\n*                   J            0      0           L\n*                   J           0        0          L\n*                   J          0          0         L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*        J          J         0            0        L\n*         J        J           0          0         L\n*          J      J             0        0          L\n*           J    J               0      0           L\n*            JJJJ                 000000            LLLLLLLLLLL\n           SPACE 3\nEXECLONG CSECT                                                    86211\n*\n*     This program simply attaches a program after setting up\n*     a long parameter from the $$PARM DD card.\n*\n*     If the Data Set is a VB data set, then the parm is copied as is.\n*\n* APF facilities are used.                                        75311\n*\n* We jump into super-visor mode,\n* and use the special ATTACH to attach the problem                75311\n* program as a new job-step, and allow APF to work as usual.      75311\n*\n* The program currently uses a $$PARM dd card, and a parameter    10245\n*   which specifies the program to be executed, in the form       10245\n*   PARM='PGM=pgm-name'.                                          10245\n*\n* Note that other parameters will be added to the program as it   10245\n*   is developed further.                                         10245\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nEXECLON  SAVE   (14,12),,EXECLONG.COPYRIGHT.CLEM.CLARKE;COMPILED.ON.&SY+\n               SDATE.:&SYSTIME\n         USING EXECLONG,R11    ADDRESS OURSELVES\n         LR    R11,R15         AND FIX UP BASE REGISTER\n         LR    R9,R1           SAVE R1 FOR A WHILE\n         L     R0,=A(CONEND-CONSTART)  LOAD R0 WITH LENGTH OF CONSTANT\n*                                      AREA + LENGTH SAVE AREA\n         GETMAIN R,LV=(0)      GET THE REQUIRED STORAGE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         USING SAVEAREA,R13\n         LR    R13,R1          LINKAGE SET UP NOW\n         SPACE 3\n         MVC   TASKLABL,=CL8'        '\n         SPACE 3\n         ST    R9,APARM        STORE ORIGINAL R1 IN GOTTEN CORE\n         LA    R1,PARML\n         ST    R1,ATASKPRM\n         SR    R7,R7           DOUBLE ABEND INDICATOR SO IF THE\n*                              SCHEDULER ABENDS,THEN WE WON'T RELOAD\n*                              THE SCHEDULER AND LOOP FOREVER\nATTACH   DS    0H\n         XC    TASKECB,TASKECB\n         L     R15,0(R9)       POINT TO PARAMETER AREA(OS)        75128\n         USING PARMIN,R15                                         10245\n         CLC   =H'0',#PARM     IS THERE A PARAMETER?              10245\n         BNE   TPGM            Test for PGM=\n         WTO   'Execlong: No Parameter Specified',ROUTCDE=(2,11)\n         B     DISPLHLP\n*\nTPGM     CLC   =C'PGM=',PARM   Test Program Name Keyword\n         BE    TPGM2\nDISPLHLP DS    0H\n         PRINT NOGEN\n         WTO   'Execlong: Parameter Must Be PGM=program-name',         *\n               ROUTCDE=(2,11)\n         WTO   'Execlong: Parameter for the program must be in',       *\n               ROUTCDE=(2,11)\n         WTO   'Execlong: a VB Data Set with allocated with a ',       *\n               ROUTCDE=(2,11)\n         WTO   'Execlong: DDNAME of $$PARM',                           *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n         PRINT GEN\nTPGM2    DS    0H\n         MVC   TASKNAME,=CL8'        '\n* Get the Program Name from the Parameter Field\n         LH    R14,#PARM       Get Parameter Length\n         SH    R14,=AL2(4+1)   4 for PGM=, 1 for EX Instruction\n         EX    R14,MVCPARM\nMVCPARM  MVC   TASKNAME(*-*),PARM+4\n*\n* OK, Now get the long Parameter from the $$PARM DD Card\n*\n*        OPEN ($$PARM,INPUT)   Non Reentrant Open\nOPEN     DS    0H              Do a Reentrant Open\n         MVC   $$PARM($$PARMCL),$$PARMC  Copy DCB to gotten storage\n         MVC   OPENWRK(OPENINS),OPENIN  Copy Open Inirialised List\n         OPEN  ($$PARM,(INPUT)),MF=(E,OPENWRK)\n*\n         LA    R1,$$PARM       Get address of Input DCB\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN OPEN okay ?\n         BZ    OPENERR         If OPEN failed, go to ABEND\n         TM    DCBRECFM,DCBRECV VARIABLE RECORD FORMAT ?\n         BNO   MUSTBEVB        NO, Must be VB (for version 1)\n         DROP  R1\n*\n         GET   $$PARM,#FIRSTRC Get the first record directly into area\n         LH    R1,#FIRSTRC     Load the VB LRECL\n         SH    R1,=H'4'        -4\n         STH   R1,#PARML       Saved.  It is now correct for ATTACH\n* See if a 2nd record is here.\nINLOOP   GET   $$PARM,#RECIN   Try for 2nd Record\n* If we get here, a second or subsequent record was read.  We need\n* to concatenate it to the end of the current Parm.\n*\n* We need to set R14 to From Address, R0 = To Address\n* and R15 and R1 to the length to move.\n         LA   R14,RECIN        Get the address of the Data\n         LA   R0,PARML         Get TO Area Address\n         AH   R0,#PARML        Current length. We now point to END\n         LH   R15,#RECIN       Get DATA LENGTH\n         LR   R1,R15           TO SOURCE & DEST LENGTH REGS\n         MVCL 0,14             COPY THE DATA\n         LH   R15,#RECIN       Get DATA LENGTH\n         AH   R15,#PARML       Current length. We now point to END\n         SH   R15,=H'4'        -4\n         STH  R15,#PARML       Set new parameter length.\n         B    INLOOP           Try for 3rd etc record.\n*\nPARMEOD  DS    0H              Got End of File on $$PARM\n         MVC   OPENWRK(OPENINS),OPENIN  Copy Open Initialised List\n         CLOSE ($$PARM),MF=(E,OPENWRK)  Close the input control file\n*\n*\n* Now Prepare for Attach to Problem Program\n*\n         B     ATTACH2         Testing Code - Could be used\n*                              for Non-Authorised Code\n         LINK  EP=TASKNAME,PARAM=(#PARML),MF=(E,CALLAREA)\n         B     ATTACH2\nATTACH2  DS    0H                                                 75128\n         AGO   .SINGL\n* This code would be used if you were going to attach more\n* than one program.  For example, Jol will execute two or more\n* programs in one job step sometimes.\n         MODESET MODE=SUP      THIS KEEPS ME AUTHORISED\n         MODESET KEY=ZERO\n         SPACE 1\n.SINGL   ANOP\n* FIND MY JSCB\n         AGO   .SINGL2\n         L     R1,X'21C'       PSATOLD-PSA (VS2 MACRO 'IHAPSA')   75311\n         L     R6,X'B4'(R1)    POINT TO MASTER JSCB               75311\n         NI    236(R6),254     TURN OFF AUTHORISE BIT             75311\n.SINGL2  ANOP\n* NOW ATTACH PROBLEM PROGRAM.                                     75311\n*\n* Note:  We could set up the SCT so that SMF records the \"correct\"\n*        program.  Wait for user feedback.\n*\n*\n         LA    R1,#PARML       Get Address of long parameter\n         ST    R1,ATASKPRM     Store it\n         OI    ATASKPRM,X'80'  Set Hi Bit                         75311\n         LA    R1,ATASKPRM     Set R1 for Attach                  75311\n         XC    TASKECB,TASKECB CLEAR ECB                          75311\n         MVC   ATTACHL(ATTACHLN),ATTACHW INITIALISE ATTACH\n*                              BECAUSE 'E' FORM DOESN'T INITIALISE\n*                              ALL THE BITS.\n         ATTACH EPLOC=TASKNAME,ECB=TASKECB,SF=(E,ATTACHL),             *\n               RSAPF=YES,                                              *\n               JSTCB=YES,MF=(E,(1))                               76200\n         LR    R5,R1\n         WAIT  ECB=TASKECB\n         AGO   .SINGL3\n         OI    236(R6),1       TURN ON  AUTHORISE BIT\n         MODESET KEY=NZERO\n.SINGL3  ANOP\n         MVC   TASKRETN(1),X'1D'(R5) SHIFT IN ABEND CODE\n         MVC   TASKRETN+1(3),TASKECB+1 AND RETURN CODE\n* NOW I'M BACK IN CONTROL,I.E THE SUBTASK FINISHED.\n*    WHAT AM I TO DO NOW ?\n         ST    R5,CALLAREA\n         DETACH CALLAREA\nTABEND   TM    TASKRETN,128    NORMAL RETURN FOR TASK?            75003\n         BNO   TESTGOBK   YES,SO TEST GOBACK TO OS INDIC          76200\n         IC    R7,TASKRETN     SET R7 = ABEND CODE\n         L     R1,TASKRETN     LOAD TASKRETN TO REG 1\n         ABEND (1)\n*        N     R1,=X'00FFFFFF' LEAVE RETURN CODE\nTESTGOBK EQU   *\n         SPACE 3\nRETNOS   EQU   *\n         LH    R10,TASKRETN+2  LOAD 2ND 2 BYTES OF RETURN CODE\nBADRETN  EQU   *\n         L     R7,4(R13)       LOAD R7 WITH PREVIOUS SAVEAREA ADDRESS\n         LR    R1,R13          LOAD R1 WITH THE ADDRESS OF GOTTEN\n*                              STORAGE\n         FREEMAIN R,LV=CONEND-CONSTART,A=(1)\n         LR    R13,R7          SET R13=OLD SAVE\n         LR    R15,R10         SET UP RETURN CODE\n         L     R14,12(13)      AND RETURN ADDRESS\n         LM    R0,R12,20(R13)  AND OLD REGISTERS\n         BR    R14             AND BACK WE GO\n*\n*\n*\nSETRET   LA    R10,4000                                            DASD\n         B     BADRETN\nATTACHW  ATTACH EP=DUMMY,SF=L\nABNDMSG  WTO  'JOL MONITOR ABEND SXXX-YYY: JOB TERMINATED',            .\n               MF=L,ROUTCDE=(1,11)\nABNDMSGL EQU   *-ABNDMSG\n*\nOPENERR  DS    0H\n         WTO   'Execlong: Open of $$PARM File Failed',ROUTCDE=(2,11)\n         ABEND 16,DUMP\n*\nMUSTBEVB WTO   'Execlong: $$PARM File must be V or VB (Variable)',     *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n$$PARMC  DCB   DDNAME=$$PARM,DSORG=PS,MACRF=GM,EODAD=PARMEOD\n$$PARMCL EQU   *-$$PARMC\nOPENIN   OPEN  (,(INPUT)),MF=L\nOPENINS  EQU   *-OPENIN\n*\nZAPS     DC    28S(*)\n         LTORG\n*\n         LTORG\n         TITLE 'COMMUNICATION AREA FOR MONITOR AND SCHEDULER'\n*\n* This is the input Parm in the EXEC PGM=EXECLONG\n*\nPARMIN   DSECT\n#PARM    DS  H\nPARM     DS  CL100\n*\n*\n* General Work Area.  This is copied into \"gotten\" storage for\n*  renentrancy.\n*\nCONSTART DSECT\nSAVEAREA DS    18F\nATTACHL  ATTACH EP=DUMMY,SF=L\nATTACHLN EQU   *-ATTACHL\nHEXCONV  DS    XL9,0F\nMSGAREA  DS    XL256\nPARMAREA DS    0D\nTASKLABL DC    CL8' '          STEP-NAME (I.E LABEL IN JOL TERMINOLOGY)\nTASKNAME DC    CL8' '          NAME OF PROGRAM BEING EXECUTED AS A\n*                            SUBTASK\nAPARM    DS    A\nATASKPRM DS    A               ADDRESS OF GOTTEN STORAGE FOR PARAMETERS\nTASKSSI  DC    CL4' '          SSI OF THE SUB-TASK\nTASKRETN DC    F'0'            RETURN CODE FROM TASK\nTASKECB  DC    F'0'            EVENT CONTROL BLOCK FOR TASK\nTASKIND  DC    C' '            SET TO 1 AFTER SCHEDULER CALLED\n*                              THE FIRST TIME.\n*                              INSTRUCTIONS.\nDBL      DS    D               WORK AREA ONLY\nCALLAREA DS    10F             WORK AREA ONLY FOR PARAMETERS BASICALLY\n         DS    0F\nOPENLIST DS    A(*-*),A        OPEN/CLOSE parameter list\nOPENWRK  OPEN  (,),MF=L\n*\n$$PARM   DCB   DDNAME=$$PARM,DSORG=PS,MACRF=GM,EODAD=PARMEOD\n*              SYNAD=QSAMSYND\n#FIRSTRC DS    H               We read the first record in here, and\n*                              adjust the RDW and save it in #PARML.\n#PARML   DS    H               Length of Parameter in following field.\nPARML    DS    CL3004          Long Parameter Area\n#RECIN   DS    H               Length of Input Record from $$PARM DD.\n         DS    H               Necessary for VB Records\nRECIN    DS    CL3004          Long Parameter Area\nCONEND   EQU   *\n         SPACE 3\n*\n         DCBD  DSORG=PS\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEXMIT": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x10(\\x8f\\x01\\x101\\x8f\\x08\\x03\\x00\\x0c\\x00\\x0b\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-10-15T00:00:00", "modifydate": "2010-11-14T08:03:51", "lines": 12, "newlines": 11, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKET JOB (JOL),'TSO JOB',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K,\n//             MSGLEVEL=(1,1)\n//TSO    EXEC  PGM=IKJEFT01,DYNAMNBR=200\n//SYSTSPRT DD  SYSOUT=*,DCB=BLKSIZE=1380\n//SYSUDUMP DD  SYSOUT=*\n//*SYSPROC  DD  DSN=CLARKE.MCC.CLIST,DISP=SHR\n//SYSTSIN  DD  *\n DELETE 'CLARKE.EXECSPEC.ASM.XMI'\nXMIT CVC.NODE +\n DATASET('CLARKE.EXECSPEC.ASM') OUTDSN('CLARKE.EXECSPEC.ASM.XMI')\nlogoff\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARMCNTL": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00(\\x01\\x101_\\x01\\x101\\x8f\\x07$\\x02\\xac\\x02o\\x00N\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2010-11-14T07:24:28", "lines": 684, "newlines": 623, "modlines": 78, "user": "CLARKE"}, "text": "SAVEPARM   TITLE 'Save or Add the Parameter to the $$PARM File'\n*\n* COPYRIGHT Clement Clarke, CLARKE COMPUTER SOFTWARE 2010\n* ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n*\n* This program is provided free of charge, under the Apache Licence,\n* for Hercules and \"Hobbyist\" licences.\n*\n* However, you are invited to contribute if\n* you find this software useful. And this will assist with the\n* development of new software.\n*\n* There is no warranty - source code is provided so that the program\n* may be maintained.\n*\n* Note: You may not convert this program into a paid product, and all\n*       source code changes must be made available for everyone.\n*\n* My email is clemclarke@gmail.com\n*\n*\n* This a stand alone program.  It is inspired by Jol,\n*        the Universal Command Language for all computers.\n*\n* Note: Versions of Jol exist for Z/OS, VSE, Windows, Linux, OS/2,\n*       and soon Macs.\n*\n*\n*\n*\n*                   J             000000            L\n*                   J            0      0           L\n*                   J           0        0          L\n*                   J          0          0         L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*        J          J         0            0        L\n*         J        J           0          0         L\n*          J      J             0        0          L\n*           J    J               0      0           L\n*            JJJJ                 000000            LLLLLLLLLLL\n           SPACE 3\nPARMCNTL CSECT                                                    86211\n         DS    0H\n*\n*   This program simply save the parameter the program was\n*   executed with to the $$PARM DD card.\n*\n*   If the parameter has PGM=abc, has the first part of the\n*   parameter, then that program is executed.\n*\n*   If the parameter has DDN=ddn, after the PGM=abc,\n*   the the DDNAME is used instead of $$CNTL.\n*\n* NOTE:  If there is a parameter field, the $$PARM file is\n*   NOT USED.\n*\n* NOTE:  There is no provision to pass a parameter to the\n*   problem program.\n*\n*     The $$PARM file must be a VB data set.\n*     The $$CNTL file can be a Fixed or Variable file.\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSAVEPRM  SAVE   (14,12),,PARMCNTL.COPYRIGHT.CLEM.CLARKE;COMPILED.ON.&SY+\n               SDATE.:&SYSTIME\n         USING PARMCNTL,R11    ADDRESS OURSELVES\n         LR    R11,R15         AND FIX UP BASE REGISTER\n         LR    R9,R1           SAVE R1 FOR A WHILE\n         L     R0,=A(CONEND-CONSTART)  LOAD R0 WITH LENGTH OF CONSTANT\n*                                      AREA + LENGTH SAVE AREA\n         GETMAIN R,LV=(0)      GET THE REQUIRED STORAGE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         USING SAVEAREA,R13\n         LR    R13,R1          LINKAGE SET UP NOW\n         MVC   EYEBALL1,=CL16'#RECIN  #RECIN'\n         MVC   EYEBALL2,=CL16'#RECOUT #RECOUT'\n         MVC   EYEBALLP,=CL16'#PARMxxxx#PARMxxxx'\n         MVC   #PARMPP,=H'0'   Initialise Problem Program Parm to Null.\n         SPACE 3\n*\n         L     R9,0(R9)       POINT TO PARAMETER AREA(OS)         75128\n         USING PARMIN,R9\n         CLC   =H'0',#PARM     IS THERE A PARAMETER?\n         BNE   GETPARM         Yes, copy it so we can use it.\n*\n* Here, no parameters so read the file in here...\n*\n* Get the long Parameter from the $$PARM DD Card\n*\n*\n*        OPEN ($$PARM,INPUT)\nOPEN     DS    0H\n         MVC   $$PARM($$PARMCL),$$PARMC  Copy DCB to gotten storage\n         MVC   OPENWRK(OPENINS),OPENIN  Copy Open Initialised List\n         OPEN  ($$PARM,(INPUT)),MF=(E,OPENWRK)\n*\n         LA    R1,$$PARM       Get address of Input DCB\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN OPEN okay ?\n         BZ    OPENERR         If OPEN failed, go to ABEND\n         TM    DCBRECFM,DCBRECV VARIABLE RECORD FORMAT ?\n         BNO   MUSTBEVB        NO, Must be VB (for version 1)\n         DROP  R1\n*\n         GET   $$PARM,VBLRECL2 Get the first record directly into area\n         LH    R1,VBLRECL2     Load the VB LRECL\n         SH    R1,=H'4'        -4\n         STH   R1,#RECIN       Saved as a PL/I type string\n* See if a 2nd record is here.\n* We will use the RECOUT Field temporarily.\n* (I should have used Get Locate... Next version ...)\n*\nINLOOP   GET   $$PARM,VBLRECL1 Try for 2nd Record\n         LH    R1,VBLRECL1     Load the VB LRECL\n         SH    R1,=H'4'        -4\n         STH   R1,#RECOUT      Saved as a PL/I type string\n* If we get here, a second or subsequent record was read.  We need\n* to concatenate it to the end of the current Parm.\n*\n* We need to set R14 to From Address, R0 = To Address\n* and R15 and R1 to the length to move.\n         LA   R14,RECOUT       Get the address of the Data\n         LA   R0,RECIN         Get TO Area Address\n         AH   R0,#RECIN        Current length. We now point to END\n         LH   R15,#RECOUT      Get DATA LENGTH\n         LR   R1,R15           TO SOURCE & DEST LENGTH REGS\n         MVCL 0,14             COPY THE DATA\n         LH   R15,#RECOUT      Get DATA LENGTH\n         AH   R15,#RECIN       Current length. We now point to END\n         STH  R15,#RECIN       Set new parameter length.\n         B    INLOOP           Try for 3rd etc record.\n*\nPARMEOD  DS    0H              Got End of File on $$PARM\n*\n         MVC   OPENWRK(OPENINS),OPENIN  Copy Open Initialised List\n         CLOSE ($$PARM),MF=(E,OPENWRK)  Close the input control file\n         B     GOTPARM\n*\n*\nGETPARM  DS    0H\n*\n         DEVTYPE =CL8'$$PARM',CALLAREA See if $$PARM DD file as well.\n         LTR   R15,R15\n         BNZ   NOPARMDD\n         PRINT NOGEN\n         WTO   'ParmCntl: Parmeter Field used - $$PARM File Ignored.', *\n               ROUTCDE=(2,11)\n         PRINT GEN\nNOPARMDD DS    0H\n*\n* Copy the PARM field into working storage.\n*\n         LH    R14,#PARM       Get Parameter Length\n         CH    R14,=AL2(3000)  Check if Parameter too long\n         BL    PARMLOK         Parm Length OK\n         PRINT NOGEN\n         WTO   'ParmCntl: Parameter Too Long (>3000 Bytes)  ',         *\n               ROUTCDE=(2,11)\n         PRINT GEN\n         B     DISPLHLP\n*\n*\nPARMLOK  DS   0H\n*\n* We will copy the Parameter Field to a PL/I style string. Then\n* we can examine it for LF or <p> characters.\n*\n* Naturally, we had better copy more than 100 characters\n* (if necessary)!!!!\n*\n* Prepare for an MVCL.\n*\n* We need to set R14 to From Address, R0 = To Address\n* and R15 and R1 to the length to move.\n         LA   R14,PARM         Get the address of the Data\n         LA   R0,RECIN         Get TO Area Address\n         LH   R15,#PARM        Get DATA LENGTH\n         LR   R1,R15           TO SOURCE & DEST LENGTH REGS\n         MVCL 0,14             COPY THE DATA\n         LH   R15,#PARM        Get DATA LENGTH\n         STH  R15,#RECIN       Set the Data Length.\n*\nGOTPARM  DS    0H\n         MVC   TASKNAME,=CL8'        '\n         MVC   DDN,=CL8'        '\nTPGM     CLC   =C'PGM=',RECIN  Test Program Name Keyword\n         BE    FINDCOM         Find the terminating comma\n         CLC   =C'DDN=',RECIN  Test DDNAME Name Keyword\n         BE    FINDCOM         Find the terminating comma\n         CLC   =C'PARM=''',RECIN  Test Parameter Keyword\n         BNE   OPENCNTL        Go start copying to $$CNTL file.\nFINDQUOT DS    0H\n* Get the Program Name or the DDNAME from the Parameter Field\n         LA    R1,RECIN+7     Point past the PARM='\n         LH    R15,#RECIN     Get current length of the string\n         AR    R15,R1         R15 points to end of string\n         LA    R14,1          Set R14 to the Increment for the BXLE\nQUOTLUP  CLI   0(R1),C''''    Is this a ' character?\n         BE    QUOTFND        YES\n         BXLE  R1,R14,QUOTLUP ROUND LOOP\n         WTO   'ParmCntl: No Quote ('') after PARM=''',                *\n               ROUTCDE=(2,11)\n         B     DISPLHLP       Display the Help\nFINDCOM  DS    0H\n* Get the Program Name or the DDNAME from the Parameter Field\n         LA    R1,RECIN       LOAD R1 WITH ADDRESS OF STRING\n         LH    R15,#RECIN     Get current length of the string\n         AR    R15,R1         R15 points to end of string\n         LA    R14,1          Set R14 to the Increment for the BXLE\nCOMMALUP CLI   0(R1),C','     Is this a LF character?\n         BE    COMMAFND       YES\n         BXLE  R1,R14,COMMALUP ROUND LOOP\n         WTO   'ParmCntl: No Comma (,) after PGM= or DDN= Parameter',  *\n               ROUTCDE=(2,11)\n         B     DISPLHLP       Display the Help\n*\nQUOTFND  DS    0H\n         LA    R1,1(R1)       Skip over ', point to the comma after\nCOMMAFND DS    0H\n* R1 points to the ',' or the \"'\" character.\n* And R15 points to the last byte in the string.\n*\n* Copy up to the C',' to the output area, then SUBSTR the data.\n*\n* We have:\n* ____________________________________________________________\n* |     |                                                    |\n* | len | PGM=xyz,                                           |\n* |_____|____________________________________________________|\n* |     |        |                                           |\n* #Recin| Recin  R1                                         R15\n*                                                       (don't need)\n         MVC   RECOUT(12),=CL12' '\n         LR    R12,R1          Save R1 - the pointer to the ','\n         LR    R8,R1           Calc Length to Move\n         LA    R14,RECIN       Get Address of Recin\n         SR    R8,R14          Length, including the comma\n         CLC   =C'PARM=''',RECIN  Test Parameter Keyword\n         BNE   ISDDN           Must be DDN= or PGM=\n         SH    R8,=H'8'        We don't want the comma, and the EX\n         EX    R8,MVCPARM       needs 1 less byte\n         LA    R8,1(R8)\n         STH   R8,#PARMPP      Problem Program Parameter.\nMVCPARM  MVC   PARMPP(*-*),RECIN+6 Move the PARM= parameter\n         LA    R14,1(R14)      Bump past the Quote.\n         CLI   0(R14),C''''\n         BNE   SUBSTR02\n         PRINT NOGEN\n         WTO   'Parmcntl: Implementation Restriction: Double Quotes Not*\n                Allowed',                                              *\n               ROUTCDE=(2,11)\n         PRINT GEN\n         B     DISPLHLP\n*\nISDDN    SH    R8,=H'5'        We don't want the comma, and the EX\n         EX    R8,MVCFLD        needs 1 less byte\nMVCFLD   MVC   RECOUT(*-*),RECIN+4 Move the PGM= or the DDN=\n*\n* Now move the PGM or the DDN to the correct field.\n         CLC   =C'PGM=',RECIN\n         BNE   TDDN2\n         MVC   TASKNAME,RECOUT\n         B     SUBSTR02\nTDDN2    CLC   =C'DDN=',RECIN\n         BE    MOVEDDN\n* ?????\n         WTO   'ParmCntl: Catastrophic Error.  Impossible Happened ',  *\n               ROUTCDE=(2,11)\n         B     DISPLHLP       Display the Help\nMOVEDDN  MVC   DDN,RECOUT\n*\n* Now we need to copy from the OLD R1 (+ a bit) to RECIN.\n* Remember, R1 pointed to the comma,\n* and that we saved it in R12.\n*\nSUBSTR02 LR    R14,R12         Load R14 with the saved pntr.\n         LA    R14,1(R14)      Bump past the comma.\n         LA    R1,RECIN Address of start of string\n         AH    R1,#RECIN       Point to end of current string\n         LR    R15,R1\n         SR    R15,R14         New length of string\n         STH   R15,#RECIN      Stored\n         LR    R1,R15          Make lengths equal\n         LA    R0,RECIN        Get the TO address again\n         MVCL  0,14            Do the SUBSTR (copy string down)\n*\n         B     TPGM            Test if DDN=, really (could be 2 PGM=)?\n*\n*\n*\n* OK, Now open the $$CNTL DD Card, preparing to write to it.\n*\n*        OPEN ($$CNTL,OUTPUT)\nOPENCNTL DS    0H\n         MVC   $$CNTL($$CNTLCL),$$CNTLC  Copy DCB to gotten storage\n         MVC   OPENWRK(OPENOUTS),OPENOUT Copy Open Initialised List\n         LA    R10,$$CNTL      Get address of Output DCB\n         USING IHADCB,R10\n         CLC   =CL8' ',DDN     Is there an over-riding DDNAME?\n         BE    NODDN\n         MVC   DCBDDNAM,DDN    Change it from $$CNTL\nNODDN    DS    0H\n         OPEN  ($$CNTL,(OUTPUT)),MF=(E,OPENWRK)\n         TM    DCBOFLGS,DCBOFOPN OPEN okay ?\n         BZ    OPENERR         If OPEN failed, go to ABEND\n*\n* Scan down the data to be written looking for a X'25' or a < (<p>)\n* I am going to go round a loop, sort of SUBSTRINGing the data\n* when I output a record, rather than keeping pointers to where I am.\n*\nFINDLF   CLC   =H'0',#RECIN   Test if a null or empty string.\n         BE    ENDPROG        Just exit.\n         LA    R1,RECIN       LOAD R1 WITH ADDRESS OF STRING\n         LH    R15,#RECIN     Get current length of the string\n         AR    R15,R1         R15 points to end of string\n         LA    R14,1          Set R14 to the Increment for the BXLE\nBXLELOOP CLI   0(R1),X'25'    Is this a LF character?\n         BE    LFFND          YES\n         CLI   0(R1),C'<'     Is this a < character? Maybe <p>?\n         BE    OPENBRAC       YES\nBXLEREAL BXLE  R1,R14,BXLELOOP ROUND LOOP\n* Just Move record to Output Area\n         B     WRITEALL        DIDN'T FIND IT -> OUT\n*\nOPENBRAC DS    0H\n* R1 points to the < character.\n         CLC   =C'p>',1(R1)\n         BE    ENDBRAC\n         CLC   =C'P>',1(R1)\n         BE    ENDBRAC\n         B     BXLEREAL\n*\nLFFND    DS    0H\n* R1 points to the LF character.\n*\nENDBRAC  DS    0H\n* R1 points to the < character (of the <p>)\n*\n* And so R1 either points to the < or the x'25'.\n* And R15 points to the last byte in the string.\n*\n*\n* Copy up to the x'25' or <p> to the output area, then SUBSTR the data.\n*\n* We have:\n* ____________________________________________________________\n* |     |                                                    |\n* | len | PASSWORD=xyz,   <p>                                |\n* |_____|____________________________________________________|\n* |     |                 |                                  |\n* #Recin| Recin           R1                                R15\n*                                                       (don't need)\n*\n* We need to set R14 to From Address, R0 = To Address\n* and R15 and R1 to the length to move.\n         LR    R12,R1          Save R1 (We could recalc it later).\n         LA    R0,RECOUT       Get TO Area Address\n         LA    R14,RECIN       Get the start Address of the Data\n         LR    R15,R1          Calculate the DATA LENGTH\n         SR    R15,R14         Calc Amount to move\n         LR    R1,R15          TO SOURCE & DEST LENGTH REGS\n         STH   R1,#RECOUT      Set the string length, too.\n         CH    R1,=AL2(L'RECOUT) Just check it isn't too big\n         BH    RECBIG\n         MVCL  0,14            Copy from \"recin\" to \"recout\"\n*\n* Now we need to copy from the OLD R1 (+ a bit) to RECIN.\n* Remember, R1 pointed to the X'25', or the start of the <p>,\n* and that we saved it in R12.\n*\n         LR    R14,R12         Load R14 with the saved pntr.\n         CLI   0(R14),X'25'    LF Character?\n         BNE   ADD3\n         LA    R14,1(R14)      Bump past the X'25'\n         B     SUBSTR01        Shorten the string\nADD3     LA    R14,3(R14)      Bump past the <p>\nSUBSTR01 LA    R1,RECIN Address of start of string\n         AH    R1,#RECIN       Point to end of current string\n         LR    R15,R1\n         SR    R15,R14         New length of string\n         STH   R15,#RECIN      Stored\n         LR    R1,R15          Make lengths equal\n         LA    R0,RECIN        Get the TO address again\n         MVCL  0,14            Do the SUBSTR (copy string down)\n*\n         LA    R1,#RECOUT\n         BAL   R12,WRITEREC\n         B     FINDLF          Find the next LF or <p>\n*\nWRITEALL DS    0H              Here, the LF or <p> wasn't found,\n*                              so, write the entire parameter out.\n         LA    R1,#RECIN       Address the copy of the input parameter\n         BAL   R12,WRITEREC\n         B     ENDPROG         Close files, and return to OS.\n*\nWRITEREC DS    0H\n*\n* Test if VB or FB, and write the data accordingly.\n*\n         TM    DCBRECFM,DCBRECV VARIABLE RECORD FORMAT ?\n         BNO   TESTFB          Must be VB or FB\n*\n* Here it is VB.\n*\n* R1 points to the length field of the data to go out.\n* The data follows immediately after, and we have deliberately\n* allocated two bytes before the string to be used\n* as the Variable Blocked file record length, which\n* we will use.\n*\n         LH    R14,0(R1)       Get the STRING length.\n         LA    R14,4(R14)      Add 4 for VB length.\n         LR    R15,R1          Point to record length again\n         SH    R15,=H'2'       We need to store R14 there.\n         STH   R14,0(R15)      Record length stored\n         SR    R14,R14         Set next two bytes to zero.\n         STH   R14,0(R1)       Done\n         LA    R1,$$CNTL\n         LR    R2,R15\n*         DC    H'0'\n         PUT   $$CNTL,0(R15)   Put the first record directly from area\n         BR    R12             Back to caller.\n*\nTESTFB   TM    DCBRECFM,DCBRECF Fixed RECORD FORMAT ?\n         BNO   BADRECFM        Must be VB or FB - Error, Abend\n* Here it is F or FB.\n*\n* R1 points to the length field of the data to go out.\n* The data follows immediately after.\n*\n* For FB files, we need to make sure that the last record\n* is padded out with blanks.  So, the easiest thing to do\n* is to put 80 blanks on the end of the data to go out\n* (and that assumes the LRECL is 80...)\n*\n         LH    R14,0(R1)       Get the STRING length.\n         LA    R15,2(R1,R14)   Point to end of the string\n         ST    R15,AENDBYTE    Save to compare in output loop.\n         MVC   0(100,R15),=CL100' ' Copy blanks to end.\n*\n* Now loop around outputting the FB records.\n*\n         LA    R2,2(R1)        Point to record to go out\nWRITEFB  PUT   $$CNTL,0(R2)    Put the record directly from area\n         AH    R2,DCBLRECL     Add the record length\n         C     R2,AENDBYTE\n         BL    WRITEFB\n         BR    R12             Back to caller.\n*\n*\n*\nENDPROG  DS    0H              Got End of File on $$CNTL\n         MVC   OPENWRK(OPENOUTS),OPENOUT Copy Open Initialised List\n         CLOSE ($$CNTL),MF=(E,OPENWRK)  Close the input control file\n*\n* Version 2 - added PGM= and DDN=.  So, check if we XCTL to a\n* another program.  Or Link, or Attach, or something!!!!\n*\n         CLC   TASKNAME,=CL8' '\n         LA    R1,TASKNAME\n*     DC  H'0'\n         BE    NOLINK\n         B     ATTACH\n*\n***********************************************************\n*\n* We could link here.  It works for IEBCOPY.  However, for whatever\n* reason (flip of the coin?) I decided to ATTACH.\n* With ATTACH, APF is used.\n*\n         LA    R1,ATASKPRM\n         LA    R7,TASKNAME\n         LINK  EPLOC=TASKNAME,PARAM=(NULLPARM),MF=(E,CALLAREA),        *\n               SF=(E,CALLAREA+12),VL=1,DCB=0\n         LR    R10,R15   Get Return Code\n         B     BADRETN\n*\n***********************************************************\n*\n*\n*\n* NOW ATTACH PROBLEM PROGRAM.                                     75311\n*\n* Note:  We could set up the SCT so that SMF records the \"correct\"\n*        program.  Wait for user feedback.\n*\n*\nATTACH   LA    R1,#PARMPP      Get Address of User Parameters\n         LH    R15,#PARMPP     Put some banls at the end\n         LA    R15,2(R1,R15)   Point to end of string\n         MVC   0(20,R15),BLANKS\n*     DC    H'0'\n*\n         ST    R1,ATASKPRM     Store it\n         OI    ATASKPRM,X'80'  Set Hi Bit                         75311\n         LA    R1,ATASKPRM     Set R1 for Attach                  75311\n         XC    TASKECB,TASKECB CLEAR ECB                          75311\n         MVC   ATTACHL(ATTACHLN),ATTACHW INITIALISE ATTACH\n*                              BECAUSE 'E' FORM DOESN'T INITIALISE\n*                              ALL THE BITS.\n         ATTACH EPLOC=TASKNAME,ECB=TASKECB,SF=(E,ATTACHL),             *\n               RSAPF=YES,                                              *\n               JSTCB=YES,MF=(E,(1))                               76200\n         LR    R5,R1\n         WAIT  ECB=TASKECB\n         MVC   TASKRETN(1),X'1D'(R5) SHIFT IN ABEND CODE\n         MVC   TASKRETN+1(3),TASKECB+1 AND RETURN CODE\n* NOW I'M BACK IN CONTROL,I.E THE SUBTASK FINISHED.\n*    WHAT AM I TO DO NOW ?\n         ST    R5,CALLAREA\n         DETACH CALLAREA\nTABEND   TM    TASKRETN,128    NORMAL RETURN FOR TASK?            75003\n         BNO   TESTGOBK   YES,SO TEST GOBACK TO OS INDIC          76200\n         IC    R7,TASKRETN     SET R7 = ABEND CODE\n         L     R1,TASKRETN     LOAD TASKRETN TO REG 1\n         ABEND (1)\n*        N     R1,=X'00FFFFFF' LEAVE RETURN CODE\nTESTGOBK EQU   *\n           SPACE 3\nRETNOS   EQU   *\n         LH    R10,TASKRETN+2  LOAD 2ND 2 BYTES OF RETURN CODE\nBADRETN  EQU   *\n         L     R7,4(R13)       LOAD R7 WITH PREVIOUS SAVEAREA ADDRESS\n         LR    R1,R13          LOAD R1 WITH THE ADDRESS OF GOTTEN\n*                              STORAGE\n         FREEMAIN R,LV=CONEND-CONSTART,A=(1)\n         LR    R13,R7          SET R13=OLD SAVE\n         LR    R15,R10         SET UP RETURN CODE\n         L     R14,12(13)      AND RETURN ADDRESS\n         LM    R0,R12,20(R13)  AND OLD REGISTERS\n         BR    R14             AND BACK WE GO\n*\n.NOATT   ANOP\nNOLINK   L     R7,4(R13)       LOAD R7 WITH PREVIOUS SAVEAREA ADDRESS\n         LR    R1,R13          LOAD R1 WITH THE ADDRESS OF GOTTEN\n*                              STORAGE\n         FREEMAIN R,LV=CONEND-CONSTART,A=(1)\n         LR    R13,R7          SET R13=OLD SAVE\n         LR    R15,R10         SET UP RETURN CODE\n         L     R14,12(13)      AND RETURN ADDRESS\n         LM    R0,R12,20(R13)  AND OLD REGISTERS\n         SR    R15,R15\n         BR    R14             AND BACK WE GO\n*\n*\n*\n         PRINT NOGEN\n*\nDISPLHLP WTO   'ParmCntl: Parameter or data in the $$PARM File',       *\n               ROUTCDE=(2,11)\n         WTO   'ParmCntl: Is Saved to an FB or VB Control File,',      *\n               ROUTCDE=(2,11)\n         WTO   'ParmCntl: allocated with the $$CNTL DDname,    ',      *\n               ROUTCDE=(2,11)\n         WTO   'ParmCntl: unless over-ridden with the DDN=.    ',      *\n               ROUTCDE=(2,11)\n         WTO   'ParmCntl: New Lines or card images are created ',      *\n               ROUTCDE=(2,11)\n         WTO   'ParmCntl: when a LF or <p> characters are found.',     *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n*\nOPENERR  DS    0H\n         WTO   'ParmCntl: Open of $$CNTL File Failed',ROUTCDE=(2,11)\n         ABEND 16,DUMP\n*\nMUSTBEVB WTO   'ParmCntl: $$PARM File must be V or VB.',               *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n*\nBADRECFM WTO   'ParmCntl: $$CNTL File must be V, VB, F or FB    ',     *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\nRECBIG   WTO   'ParmCntl: Output Record > 255 Chars - Too Big   ',     *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n         PRINT GEN\n*\n*\n*\n$$PARMC  DCB   DDNAME=$$PARM,DSORG=PS,MACRF=GM,EODAD=PARMEOD\n$$PARMCL EQU   *-$$PARMC\n$$CNTLC  DCB   DDNAME=$$CNTL,DSORG=PS,MACRF=PM\n$$CNTLCL EQU   *-$$CNTLC\n*\nOPENIN   OPEN  (,(INPUT)),MF=L\nOPENINS  EQU   *-OPENIN\nOPENOUT  OPEN  (,(OUTPUT)),MF=L\nOPENOUTS EQU   *-OPENOUT\n*\nATTACHW  ATTACH EP=DUMMY,SF=L\n*\nNULLPARM DC    H'0'         Zero Length (Null) Parm\n*\nBLANKS   DC    CL200' '     Some blanks for us.\n*\n         LTORG\nZAPS     DC    28S(*)\n         TITLE 'COMMUNICATION AREA FOR MONITOR AND SCHEDULER'\n*\n* This is the input Parm in the EXEC PGM=ParmCntl\n*\nPARMIN   DSECT\n#PARM    DS  H\nPARM     DS  CL3000\n*\n*\n* General Work Area.  This is copied into \"gotten\" storage for\n*  re-enentrancy.\n*\nCONSTART DSECT\nSAVEAREA DS    18F\nATTACHL  ATTACH EP=DUMMY,SF=L\nATTACHLN EQU   *-ATTACHL\nOPENWRK  OPEN  (,),MF=L\nCALLAREA DS    10F             WORK AREA ONLY FOR PARAMETERS BASICALLY\n         DS    0F\nOPENLIST DS    A(*-*),A        OPEN/CLOSE parameter list\n*\nTASKNAME DS    CL8\nDDN      DS    CL8\nAPARM    DS    A\nATASKPRM DS    A               ADDRESS OF GOTTEN STORAGE FOR PARAMETERS\nTASKSSI  DC    CL4' '          SSI OF THE SUB-TASK\nTASKRETN DC    F'0'            RETURN CODE FROM TASK\nTASKECB  DC    F'0'            EVENT CONTROL BLOCK FOR TASK\nTASKIND  DC    C' '            SET TO 1 AFTER SCHEDULER CALLED\n*                              THE FIRST TIME.\nAENDBYTE DS    A               Points to last byte to be written (FB)\n*\n$$PARM   DCB   DDNAME=$$PARM,DSORG=PS,MACRF=GM,EODAD=PARMEOD\n$$CNTL   DCB   DDNAME=$$CNTL,DSORG=PS,MACRF=PM\n*\n* Here is the data area to be written to the $$CNTL file.\n*\n         DS    0D\nEYEBALL2 DC    C'#RECOUT  #RECOUT  '\nVBLRECL1 DS    H\n#RECOUT  DS    H               Length of Output Record to $$CNTL DD.\nRECOUT   DS    CL255           Record to go out.\nSPACEZZ  DS    CL100\n         DS    0D\nEYEBALLP DC    C'#PARMxxxx#PARMxxxx'\n#PARMPP  DS    H               Length of Parm from the PARM=\nPARMPP   DS    CL255           Used when PP is Attached.\n*\n* Here is the data from the Program Parameter, or from file $$PARM.\n*\n         DS    0D\nEYEBALL1 DC    C'#RECIN   #RECIN   '\nVBLRECL2 DS    H               For VB Files\n#RECIN   DS    H               Length of Input Record from $$PARM DD,\nRECIN    DS    CL3004          or Long Parameter Area\n*\nCONEND   EQU   *\n         SPACE 3\n*\n         DCBD  DSORG=PS\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVEPARM": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x101_\\x01\\x101_\\x05$\\x00\\xdf\\x00\\xdf\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-11T00:00:00", "modifydate": "2010-11-11T05:24:44", "lines": 223, "newlines": 223, "modlines": 0, "user": "CLARKE"}, "text": "SAVEPARM   TITLE 'Save or Add the Parameter to the $$PARM File'\n*\n* COPYRIGHT Clement Clarke, CLARKE COMPUTER SOFTWARE 2010\n* ALL RIGHTS RESERVED\n* ANY USE OF THIS CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE\n*\n*\n* This program is provided free of charge, under the Apache Licence,\n* for Hercules and \"Hobbyist\" licences.\n*\n* However, you are invited to contribute if\n* you find this software useful. And this will assist with the\n* development of new software.\n*\n*\n* There is no warranty - source code is provided so that the program\n* may be maintained.\n*\n* Note: You may not convert this program into a paid product, and all\n*       source code changes must be made available for everyone.\n*\n* My email is clemclarke@gmail.com\n*\n*\n* This a stand alone program.  It is inspired by Jol,\n*        the Universal Command Language for all computers.\n*\n* Note: Versions of Jol exist for Z/OS, VSE, Windows, Linux, OS/2,\n*       and soon Macs.\n*\n*\n*\n*                   J             000000            L\n*                   J            0      0           L\n*                   J           0        0          L\n*                   J          0          0         L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*                   J         0            0        L\n*        J          J         0            0        L\n*         J        J           0          0         L\n*          J      J             0        0          L\n*           J    J               0      0           L\n*            JJJJ                 000000            LLLLLLLLLLL\n           SPACE 3\n         LCLC  &SCHED\n&SCHED   SETC  '$JOLSH40'\nSAVEPARM CSECT                                                    86211\n         DS    0H\n*\n*     This program simply save the parameter the program was\n*     executed with to the $$PARM DD card.\n*\n*     The file must be a VB data set.\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nSAVEPRM  SAVE   (14,12),,SAVEPARM.COPYRIGHT.CLEM.CLARKE;COMPILED.ON.&SY+\n               SDATE.:&SYSTIME\n         USING SAVEPARM,R11    ADDRESS OURSELVES\n         LR    R11,R15         AND FIX UP BASE REGISTER\n         LR    R9,R1           SAVE R1 FOR A WHILE\n         L     R0,=A(CONEND-CONSTART)  LOAD R0 WITH LENGTH OF CONSTANT\n*                                      AREA + LENGTH SAVE AREA\n         GETMAIN R,LV=(0)      GET THE REQUIRED STORAGE\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         USING SAVEAREA,R13\n         LR    R13,R1          LINKAGE SET UP NOW\n         SPACE 3\n*\n         L     R9,0(R9)       POINT TO PARAMETER AREA(OS)         75128\n         USING PARMIN,R9                                          10245\n         CLC   =H'0',#PARM     IS THERE A PARAMETER?              10245\n         BNE   TPARM           Test for PGM=\n         WTO   'SaveParm: No Parameter Specified',ROUTCDE=(2,11)\n         B     DISPLHLP\n*\nTPARM    DS    0H\n* Get the Program Name from the Parameter Field\n         LH    R14,#PARM       Get Parameter Length\n         CH    R14,=AL2(3000)  Check if Parameter too long\n         BL    PARMLOK         Parm Length OK\n         WTO   'SaveParm: Parameter Too Long (>3000 Bytes)  ',         *\n               ROUTCDE=(2,11)\n         B     DISPLHLP\n*\n*\nPARMLOK  DS   0H\n*\n* We will copy the Parameter Field to a VB style Record, ready to\n* write out once we open the file $$PARM to Extend it.\n*\n* Naturally, we had better copy more than 100 characters\n* (if necessary)\n*\n* Prepare for an MVCL.\n*\n* We need to set R14 to From Address, R0 = To Address\n* and R15 and R1 to the length to move.\n         LA   R14,PARM         Get the address of the Data\n         LA   R0,RECOUT        Get TO Area Address\n         LH   R15,#PARM        Get DATA LENGTH\n         LR   R1,R15           TO SOURCE & DEST LENGTH REGS\n         MVCL 0,14             COPY THE DATA\n         LH   R15,#PARM        Get DATA LENGTH\n         AH   R15,=H'4'        -4\n         STH  R15,#RECOUT      Set VB Data Length.\n         SR   R14,R14\n         STH  R14,#RECOUT+2    Set next two bytes to zero for VB\n*\n* OK, Now get the long Parameter from the $$PARM DD Card\n         B     TPARM2\n         PRINT NOGEN\nDISPLHLP WTO   'SaveParm: Parameter Is Saved/Appended to a File',      *\n               ROUTCDE=(2,11)\n         WTO   'SaveParm: Program Parameter will be saved in',         *\n               ROUTCDE=(2,11)\n         WTO   'SaveParm: a VB Data Set with allocated with a ',       *\n               ROUTCDE=(2,11)\n         WTO   'SaveParm: DDNAME of $$PARM',                           *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n         PRINT GEN\nTPARM2   DS    0H\n*\n* OK, Now open the $$PARM DD Card, preparing to add to it.\n*\n*        OPEN ($$PARM,EXTEND)\nOPEN     DS    0H\n         MVC   $$PARM($$PARMCL),$$PARMC  Copy DCB to gotten storage\n         MVC   OPENWRK(OPENOUTS),OPENOUT Copy Open Inirialised List\n         OPEN  ($$PARM,(EXTEND)),MF=(E,OPENWRK)\n*\n         LA    R1,$$PARM       Get address of Input DCB\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN OPEN okay ?\n         BZ    OPENERR         If OPEN failed, go to ABEND\n         TM    DCBRECFM,DCBRECV VARIABLE RECORD FORMAT ?\n         BNO   MUSTBEVB        NO, Must be VB (for version 1)\n         DROP  R1\n*\n*\n         PUT   $$PARM,#RECOUT  Put the first record directly from area\n*\nPARMEOD  DS    0H              Got End of File on $$PARM\n         MVC   OPENWRK(OPENOUTS),OPENOUT Copy Open Initialised List\n         CLOSE ($$PARM),MF=(E,OPENWRK)  Close the input control fil\n*\n         L     R7,4(R13)       LOAD R7 WITH PREVIOUS SAVEAREA ADDRESS\n         LR    R1,R13          LOAD R1 WITH THE ADDRESS OF GOTTEN\n*                              STORAGE\n         FREEMAIN R,LV=CONEND-CONSTART,A=(1)\n         LR    R13,R7          SET R13=OLD SAVE\n         LR    R15,R10         SET UP RETURN CODE\n         L     R14,12(13)      AND RETURN ADDRESS\n         LM    R0,R12,20(R13)  AND OLD REGISTERS\n         SR    R15,R15\n         BR    R14             AND BACK WE GO\n*\n*\n*\nOPENERR  DS    0H\n         WTO   'SaveParm: Open of $$PARM File Failed',ROUTCDE=(2,11)\n         ABEND 16,DUMP\n*\nMUSTBEVB WTO   'SaveParm: $$PARM File must be V or VB (Variable)',     *\n               ROUTCDE=(2,11)\n         ABEND 16,DUMP\n$$PARMC  DCB   DDNAME=$$PARM,DSORG=PS,MACRF=PM,EODAD=PARMEOD\n$$PARMCL EQU   *-$$PARMC\n*\nOPENOUT  OPEN  (,(EXTEND)),MF=L\nOPENOUTS EQU   *-OPENOUT\n*\n         LTORG\n         TITLE 'COMMUNICATION AREA FOR MONITOR AND SCHEDULER'\n*\n* This is the input Parm in the EXEC PGM=SaveParm\n*\nPARMIN   DSECT\n#PARM    DS  H\nPARM     DS  CL3000\n*\n*\n* General Work Area.  This is copied into \"gotten\" storage for\n*  re-enentrancy.\n*\nCONSTART DSECT\nSAVEAREA DS    18F\nCALLAREA DS    10F             WORK AREA ONLY FOR PARAMETERS BASICALLY\n         DS    0F\nOPENWRK  OPEN  (,),MF=L\n*\n$$PARM   DCB   DDNAME=$$PARM,DSORG=PS,MACRF=PM,EODAD=PARMEOD\n*              SYNAD=QSAMSYND\n#RECOUT  DS    H               Length of Output Record to $$PARM DD.\n         DS    H               Necessary for VB Records\nRECOUT   DS    CL3004          Long Parameter Area\nCONEND   EQU   *\n         SPACE 3\n*\n         DCBD  DSORG=PS\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TCATDEF": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x101\\x8f\\x01\\x101\\x8f\\x069\\x00!\\x00\"\\x00\\x00\\xd1\\xd6\\xd3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T06:39:11", "lines": 33, "newlines": 34, "modlines": 0, "user": "JOL60"}, "text": "//CLARKEX JOB  (JOL),'PARMCNTL',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*\n//CATDEF   PROC  CAT=,NAME=,VOL=,DEVT=3380\n//*\n//* This procedure copies information for an DEFINE to a VB file,\n//* in the first two steps.\n//*\n//* It requires 3 steps because the parameters could easily run\n//*        over a 100 characterse for a DEFINE CAT.\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' DEFINE CAT (&CAT) NONVSAM - <p>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' ( NAME (&NAME) - <p>   VOL (&VOL) DEVT (&DEVT))'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//EXECDEF  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* Call PARMCNTL from EXECLONG. It will create control cards,\n//* and execute the program (IDCAMS) that was specified in the\n//* FIRST step.\n//SYSPRINT DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,DELETE)\n//* SYSIN below is written to by PARMCNTL, then IDCAMS reads it.\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n//       PEND\n/*\n// EXEC CATDEF,CAT=SYS1.UCAT.MVS,NAME=GCC.ASM,VOL=JOL60,\n//      DEVT=3380\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TEST01": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00I\\x01\\x100\\x9f\\x01\\x101\\x8f\\x07\\x18\\x00\"\\x00\\r\\x00\\x00\\xd1\\xd6\\xd3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2010-11-05T00:00:00", "modifydate": "2010-11-14T07:18:49", "lines": 34, "newlines": 13, "modlines": 0, "user": "JOL60"}, "text": "//CLARKEX JOB  (JOL),'LONGTEST',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*            MSGLEVEL=(1,1)\n//*\n//* This example executes a program with more than 100 bytes.\n//*\n//* EXEC01 and EXEC02 copy the parameter to VB file.          0\n//* EXEC03 executes a program with the Long Parameter        0\n//*        formed from the VB file created in the earlier\n//*        steps.\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM='Start of a long parameter.  It can have symbolics, too. '\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM='This is the second part of the long parameter.'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//*\n//EXEC03   EXEC PGM=EXECLONG,\n// PARM='PGM=PARMCNTL'\n//SYSUDUMP DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//$$CNTL   DD  DSN=&&CNTL,\n//             DCB=(RECFM=VB,LRECL=300,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(,PASS)\n//EXEC03   EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&CNTL,DISP=OLD VOL=REF=*.$$PARM\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TEST02": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x07\\x01\\x101\\x0f\\x01\\x101\\x8f\\x07\\x19\\x00\"\\x00$\\x00\\x00\\xd1\\xd6\\xd3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-11-06T00:00:00", "modifydate": "2010-11-14T07:19:07", "lines": 34, "newlines": 36, "modlines": 0, "user": "JOL60"}, "text": "//CLARKEX JOB  (JOL),'LONGTEST',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*            MSGLEVEL=(1,1)\n//*\n//* This example executes a program with more than 100 bytes.\n//*\n//* EXEC01 and EXEC02 copy the parameter to VB file.          0\n//* EXEC03 executes a program with the Long Parameter        0\n//*        formed from the VB file created in the earlier\n//*        steps.\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM='Start of a long parameter.  It can have symbolics, too. '\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM='This is the second part of the long parameter.'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//*\n//EXEC03   EXEC PGM=EXECLONG,\n// PARM='PGM=PARMCNTL'\n//SYSUDUMP DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//$$CNTL   DD  DSN=&&CNTL,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(,PASS)\n//EXEC03   EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&CNTL,DISP=OLD VOL=REF=*.$$PARM\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TEST99": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x01\\x01\\x10(\\x8f\\x01\\x101\\x8f\\x07 \\x00\\x11\\x003\\x00\\x00\\xd1\\xd6\\xd3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2010-10-15T00:00:00", "modifydate": "2010-11-14T07:20:01", "lines": 17, "newlines": 51, "modlines": 0, "user": "JOL60"}, "text": "//CLARKEX JOB  (JOL),'JOL ASSEMBLY',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K,\n//             MSGLEVEL=(1,1)\n//*\n//* Run this JOB to test the programs.\n//*\n//ASM EXEC PGM=SAVEPARM,\n//             PARM=(RENT,MCALL,NODECK,OBJ,TERM,\n//             NOALOGIC,\n//             'XREF(SHORT),FLAG(1),SYSPARM(OS=MVS)')\n//*STEPLIB   DD DSN=CLARKE.EXECSPEC.LOAD,DISP=SHR\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=100,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//ASM EXEC PGM=EXECLONG,PARM='PGM=DISPAUTH'\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TFTP": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x13\\x01\\x101\\x0f\\x01\\x101\\x7f#3\\x000\\x00$\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2010-11-06T00:00:00", "modifydate": "2010-11-13T23:33:13", "lines": 48, "newlines": 36, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKEX JOB  (JOL),'LONGTEST',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//FTP    PROC  INDSN=,OUTDSN=,PASSWORD=,HOST=,USER=\n//*\n//* This HAS NOT BEEN TESTED. I do not have FTP Access.\n//*\n//* This procedure copies information for an FTP to a VB file,\n//* in the first two steps.\n//*\n//* EXECFTP executes the FTP program after creating a control file\n//*        formed from the VB file created in the earlier steps.\n//*\n//* Thanks to Walter Marguccio <walter_marguccio@YAHOO.COM>\n//* and others in IBMMAIN for the idea of the //DD:IN\n//*\n//EXEC01      EXEC PGM=SAVEPARM,\n// PARM=('PGM=FTP,DDN=INPUT,PARM=''(EXIT''',\n//  ' &HOST <p> &USER <p> &PASSWORD. <p>')\n//$$PARM   DD  DSN=&&PARM,DCB=(RECFM=VB,LRECL=255,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//EXEC02   EXEC PGM=SAVEPARM,\n// PARM=' SENDSITE <p> PUT //dd:in &OUTDSN <p> quit '\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//*\n//EXECFTP  EXEC PGM=EXECLONG,PARM='PGM=PARMCNTL'\n//* Call PARMCNTL from EXECLONG. It will create control cards,\n//* and execute the program (FTP) that was specified in the\n//* FIRST step.\n//SYSUDUMP DD  SYSOUT=*\n//$$PARM   DD  DSN=&&PARM,DISP=(OLD,PASS)\n//IN       DD  DSN=&INDSN,DISP=(SHR,PASS)\n//* Change this next DD to a simple work file after testing.\n//INPUT    DD  DSN=&&CNTL,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(,PASS)\n//* Next step simply prints out the create control file.\n//* After testing, please remove it.\n//EXEC03   EXEC PGM=IEBGENER,COND=EVEN\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&CNTL,DISP=OLD VOL=REF=*.$$PARM\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//       PEND\n//  EXEC FTP,HOST=192.10.10.1,USER='userid',PASSWORD='mypassword',\n// INDSN=NULLFILE,OUTDSN=FROM.MAINFRAME\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TPDSCOPY": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00Y\\x01\\x101O\\x01\\x101\\x8f\\x07\\x08\\x00\\x1f\\x00U\\x00\\x00\\xd1\\xd6\\xd3\\xf6\\xf0@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2010-11-10T00:00:00", "modifydate": "2010-11-14T07:08:59", "lines": 31, "newlines": 85, "modlines": 0, "user": "JOL60"}, "text": "//CLARKEX JOB  (JOL),'PARMCNTL',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*\n//COPYPDSS PROC  INDSN=,OUTDSN=,SELECT=\n//*\n//* This JCL Executes IEBCOPY with the SELECT option.\n//* It is similar to the Jol Copy command (see Jol).\n//*\n//COPYPDS  EXEC PGM=PARMCNTL,\n// PARM=('PGM=IEBCOPY,DDN=SYSIN',\n//       ' C I=INFILE,O=OUTFILE<P> S M=&SELECT <P> ')\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   Created by Prog.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//INFILE   DD  DSN=&INDSN,DISP=SHR\n//OUTFILE  DD  DSN=&OUTDSN,DISP=OLD\n//       PEND\n//*\n//* Create Temporary PDS for Test\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//DUMMY    DD  DSN=&&TEMP,DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//             UNIT=VIO,SPACE=(TRK,(10,,3)),\n//             DISP=(NEW,PASS)\n//*\n//* Execute the program IEBCOPY after dynamically creating\n//* control cards for it.\n//*\n//  EXEC COPYPDSS,INDSN='SYS1.PROCLIB',OUTDSN=&&TEMP,\n//       SELECT='RDR,INIT,NONO'\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TPDSDELM": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x101\\x8f\\x01\\x101\\x8f\\x067\\x00 \\x00\"\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T06:37:34", "lines": 32, "newlines": 34, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKEX JOB  (JOL),'PARMCNTL',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*\n//PDSDELM  PROC  INDSN=,MEM=\n//*\n//* THIS EXAMPLE EXECUTES IDCAMS.\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//       ' DELETE &INDSN(&MEM) FILE(PDS)')\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//       PEND\n//*\n//* CREATE TEMPORARY PDS FOR TEST\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//DUMMY  DD  DSN=CLARKE.TEST2.PDS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//           UNIT=3380,SPACE=(TRK,(10,,3)),VOL=SER=JOL60,\n//           DISP=(NEW,PASS)\n//*\n//STEP1  EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//INFILE     DD DSN=SYS1.PROCLIB,DISP=SHR\n//OUTFILE    DD DSN=CLARKE.TEST2.PDS,DISP=(OLD,PASS)\n//SYSIN DD *\n    C I=INFILE,O=OUTFILE\n    S M=(RDR,INIT)\n/*\n// EXEC PDSDELM,INDSN=CLARKE.TEST2.PDS,MEM=RDR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TPDSREN": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x14\\x01\\x101\\x8f\\x01\\x101\\x8f\\x067\\x00!\\x00.\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2010-11-14T00:00:00", "modifydate": "2010-11-14T06:37:14", "lines": 33, "newlines": 46, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKEX JOB  (JOL),'PARMCNTL',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//*\n//PDSRENM  PROC  INDSN=,MEM=,NEWNAME=\n//*\n//* This example executes IEBCOPY.    It is similar to\n//* the Jol Copy command (see Jol).\n//*\n//EXEC01   EXEC PGM=PARMCNTL,\n// PARM=('PGM=IDCAMS,DDN=SYSIN',\n//  ' ALTER  &INDSN(&MEM) FILE(PDS) - <p> NEWNAME(&INDSN(&NEWNAME))')\n//SYSIN    DD  DCB=SYS1.MACLIB,UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//PDS      DD  DSN=&INDSN,DISP=SHR\n//       PEND\n//*\n//* Create Temporary PDS for Test\n//*\n//ALLOC    EXEC PGM=IEFBR14\n//DUMMY  DD  DSN=CLARKE.TEST2.PDS,DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//           UNIT=3380,SPACE=(TRK,(10,,3)),VOL=SER=JOL60,\n//           DISP=(NEW,PASS)\n//*\n//STEP1  EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//INFILE     DD DSN=SYS1.PROCLIB,DISP=SHR\n//OUTFILE    DD DSN=CLARKE.TEST2.PDS,DISP=(OLD,PASS)\n//SYSIN DD *\n    C I=INFILE,O=OUTFILE\n    S M=(RDR,INIT)\n/*\n// EXEC PDSRENM,INDSN=CLARKE.TEST2.PDS,MEM=RDR,NEWNAME=RDR4\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSORT": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00Y\\x01\\x101?\\x01\\x101\\x7f\\x07T\\x00P\\x00'\\x00\\x00\\xc3\\xd3\\xc1\\xd9\\xd2\\xc5@@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-11-09T00:00:00", "modifydate": "2010-11-13T07:54:59", "lines": 80, "newlines": 39, "modlines": 0, "user": "CLARKE"}, "text": "//CLARKEX JOB  (JOL),'LONGTEST',MSGCLASS=X,NOTIFY=CLARKE,\n//             REGION=4096K\n//SORT   PROC  INDSN=,OUTDSN=,OUTDISP=NEW,FIELDS=,CYLS=5\n//*\n//* This example executes the MVS SORT.  It is similar to\n//* the Jol Sort command (see Jol).\n//*\n//EXEC01      EXEC PGM=PARMCNTL,\n// PARM='PGM=SORT,DDN=SYSIN,PARM=''SIZE=MAX'', SORT FIELDS=&FIELDS<P>'\n//STEPLIB  DD  DSN=SYS1.SORTLIB,DISP=SHR\n//SYSIN    DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),   Created by Prog.\n//         UNIT=VIO,SPACE=(TRK,10)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SORTMSG  DD  SYSOUT=*\n//SORTIN   DD  DSN=&INDSN,DISP=SHR\n//SORTOUT  DD  DSN=&OUTDSN,DCB=(RECFM=VB,LRECL=2000,BLKSIZE=20000),\n//             UNIT=SYSDA,SPACE=(TRK,10),\n//             DISP=(&OUTDISP,CATLG)\n//SORTWK01 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK02 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK03 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//SORTWK04 DD  SPACE=(CYL,(&CYLS),,CONTIG),UNIT=SYSDA\n//       PEND\n//EXEC03   EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DSN=&&TEMPSRT,DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//             UNIT=VIO,SPACE=(TRK,10),\n//             DISP=(NEW,PASS)\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  *\n                    J             000000            L               01\n                              T   H H E                             24\n                                O    FFFFFF                         35\n                                                                    20\n                                                                    26\n                            TTTTT H H EEEE                          21\n                    J           0        0          L               03\n                    J         0            0        L               05\n                    J         0            0        L               08\n                    J         0            0        L               10\n          J        J           0          0         L               13\n         J          J         0            0        L               12\n                       JJJJ     O     Y    SSSS                     33\n                                                                    34\n                              T   HHH EEE                           23\n                              O   O  F                              40\n                              O   O  F                              41\n                               O O   F                              36\n                              O   O  F                              37\n                              O   O  F                              38\n            J    J               0      0           L               15\n                    J            0      0           L               02\n                    J         0            0        L               06\n                    J         0            0        L               09\n                    J         0            0        L               11\n           J      J             0        0          L               14\n                      J    J  O   O   Y        S                    31\n                           J   O O  Y   Y  S                        28\n                              T   H H E                             22\n                               O O   F                              42\n                                O    F                              43\n                              O   O  FFFFF                          39\n                      J    J   O O    Y        S                    32\n                           J    O   Y    Y  SSSS                    27\n                           J  O   O  Y Y   S                        29\n                              T   H H EEEE                          25\n                           J  O   O   Y     SSS                     30\n             JJJJ                 000000            LLLLLLLLLLL     16\n                    J          0          0         L               04\n                    J         0            0        L               07\n//  EXEC SORT,INDSN=&&TEMPSRT,OUTDSN=&&TEMP,\n//       FIELDS='(69,2,CH,A)'\n//SORTOUT  DD  DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//EXEC03   EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&TEMP,DISP=(OLD,DELETE)\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT839/FILE839.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT839", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}