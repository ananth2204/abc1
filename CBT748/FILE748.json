{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012719000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE748.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE748.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x08'", "DS1TRBAL": "b'\\x88f'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1a\\x00\\x05\\x05\\x1a\\x00\\t\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04I\\x00\\x00\\x01\\x061\\x0f\\x01\\x061\\x0f\\x07C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf3@@@'", "ispf": {"version": "04.73", "flags": 0, "createdate": "2006-11-06T00:00:00", "modifydate": "2006-11-06T07:43:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-473"}, "text": "REGULAR CBT TAPE - VERSION 473    FILE:  748\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT473.FILE748\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 16 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,237 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/06/06    07:43:32    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$MAIL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00S\\x01\\x061\\x0f\\x01\\x061\\x0f\\x07'\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-06T00:00:00", "modifydate": "2006-11-06T07:27:53", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": " This is a small system to control\n the transfer of programs from Development into\n Production Environment.\n The idea behind it is to give the head of section\n (whom approves the transfers) the comfort of doing\n  it from their email client inbox, without forms\n and without needing to log into the mainframe.\n\n The process starts when a REXX routine creates\n a transfer request into a file. Later, a program\n named MAILSEND is called to build an email\n and send it to the SMTP daemon server, which\n sends it to the Microsoft exchange server.\n Once the user receives the email he either\n  Approve  or  Reject  the program transfer\n and sends it back to the mainframe.\n\n The email arrives at the mainframe and is received\n by a program named MAILRECV which is started\n at every 5 minutes (via STC).\n The program issue a  receive  to read the email\n and to process a message files which comes\n as an attachment of the email (file POSTDATA.ATT).\n\n Once this message is decoded it calls another REXX program\n which updates a file with the pending transfer requests and\n also calls others processes to make the transfer.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x005\\x01\\x06)\\x0f\\x01\\x061\\x0f\\x07\\x10\\x00G\\x00N\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-10-17T00:00:00", "modifydate": "2006-11-06T07:10:35", "lines": 71, "newlines": 78, "modlines": 0, "user": "SBGOLOB"}, "text": "----------------------------------------------------------------------\nNote.  Please see member $$NOTE2 in this pds, which is a necessary\n       follow up to this member.\n----------------------------------------------------------------------\n\nSubject:     Re: Decode64 Routines (REXX and Assembler)\nFrom:        \"Lionel Dyck\" <lbdyck@gmail.com>\nDate:        Tue, 17 Oct 2006 09:42:12 -0700\nTo:          \"Jose Neto\" <joserfneto@yahoo.co.uk>\nCC:          \"Sam Golob\" <sbgolob@cbttape.org>\n\nLionel B. Dyck\nAIM: lbdyck Yahoo IM: lbdyck\nHome Page http://www.lbdsoftware.com\n\nJose - thank you for sharing - I'm copying Sam Golob (the\nmaintainer of the CBT collection) as that would be the best\nplace to share your code. I do appreciate your sharing.\n\n----------------------------------------------------------------------\n\nOn 10/17/06, Jose Neto <joserfneto@yahoo.co.uk> wrote:\n\nDear Mr. Lionel B. Dyck,\n\nI am sending some programs we have developed locally\nwhich I would like to share with the community.\n\nActually, the assembler program was made following the\nsame model which I got from the programs from you and\nMr. Leland. I mean, without your sources I wasn't\nable to code it.\n\nThe programs are two versions of a routine to perform\nBASE64 Decoding; one in assembler and another one in\nREXX. The files are like that:\n\n1. decode_asm.txt - Assembler version for the Decode\n   64 routine\n\n2. decodex1.txt, decodex4.txt, decodex9.txt - sample\n   REXX programs showing how to call the assembler\n   routine\n\n3. decode_rexx.txt - REXX version for the same routine\n   with the example on how to call the routine at the\n   beginning followed by the routine itself.\n\nI have done the first version in Assembler and it had\nworked fine for quite some time. However, another\nprogrammer alerts me for the fact the routine might\nhave a bug and I have decided to convert it to REXX\n(which solve the problem).\n\n (Note.  This problem has since been fixed!  Please disregard\n         these comments about the Assembler version, which now\n         works well--the same as the REXX version.)\n\nI thought it might be good idea to share both programs\nwith the community and maybe somebody will find an\nexplanation for it. Nevertheless, the REXX version has\nnever presented any problem.\n\nAgain, I would like to thank you very much for your\ntime and for making so many tools available to the\nMainframe community.\n\nAll the best,\n\nJose Ferreira Neto\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x061\\x0f\\x01\\x061\\x0f\\x07\\x05\\x001\\x001\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-06T00:00:00", "modifydate": "2006-11-06T07:05:02", "lines": 49, "newlines": 49, "modlines": 0, "user": "SBGOLOB"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$README": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x060\\x8f\\x01\\x060\\x9f\\x19\\x12\\x00]\\x00;\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-05T19:12:29", "lines": 93, "newlines": 59, "modlines": 0, "user": "J.NETO"}, "text": " This is a small system to control\n the transfer of programs from Development into\n Production Environment.\n The idea behind it is to give the head of section\n (whom approves the transfers) the comfort of doing\n  it from their email client inbox, without forms\n and without needing to log into the mainframe.\n\n The process starts when a REXX routine creates\n a transfer request into a file. Later, a program\n named MAILSEND is called to build an email\n and send it to the SMTP daemon server, which\n sends it to the Microsoft exchange server.\n Once the user receives the email he either\n  Approve  or  Reject  the program transfer\n and sends it back to the mainframe.\n\n The email arrives at the mainframe and is received\n by a program named MAILRECV which is started\n at every 5 minutes (via STC).\n The program issue a  receive  to read the email\n and to process a message files which comes\n as an attachment of the email (file POSTDATA.ATT).\n\n Once this message is decoded it calls another REXX program\n which updates a file with the pending transfer requests and\n also calls others processes to make the transfer.\n\n Here is a summary of the members in this library:\n\n1. CALLDECA   REXX sample program used to call DECODE64\n   (the call is external to the routine)\n   Note: DECODE64 may reside on LLA or LPA\n\n2. CALLDECR   REXX sample program used to call DECODREX\n   (the call is internal to the routine; both routines must be part\n    of the same REXX program)\n\n3. CALLSEND   REXX sample program used to call MAILSEND\n\n4. DECODE64   Assembler program for decoding the BASE64\n\n5. DECODREX   REXX program for decoding the BASE64\n\n6. MAILPARM   Parameter file pointed by SYSTSIN on the PROCMAIL\n\n7. MAILRECV   REXX program which is called to receive the email\n   at the Mainframe. At the end of the routine we will have:\n\n  Variables y.1  y.2 and y.3 have the time the email was received\n  the sender and the plain text from the DECODE64.\n  Example:\n  y.1 = Email Received at:  Sat  4 Nov 2006 21:08:27 +0300\n  y.2 = From: \"Jose Neto\" <joserfneto@yahoo.co.uk>\n  y.3 = Message Content is: group1=Approve+Order+12345\n\n  In our system we address a table where the key is the order\n  number and set the approval status.\n  Also  MAILRECV saves the log from the email in a file with a\n  DSNAME in the format: MAILCH.LOG.MISC.D041106.T210648meaning\n  it t was received at 4/11/200 at 21:06:48.\n\n  Note: the base64 text will come in a file which is attached\n  to the email with a filename=\"POSTDATA.ATT\"\n\n8. MAILSEND  REXX program which is called to send the email\n   to the Microsoft Exchange Server\n   The email is formatted using HTML tags.\n\n   You do not need to be a expert on HTML language to code it.\n   The following sites were my guideline to build it:\n\n   http://www.tizag.com/htmlT/forms.php\n   http://www.w3.org/TR/REC-html40/cover.html#minitoc\n   http://www.htmlgoodies.com/tutorials/forms/article.php/3479121\n   http://www.w3.org/TR/REC-CSS1\n\n9. PROCMAIL   The procedure used to call MAILRECV REXX Program\n\n   Note: the RACF User associated with the Procedure has to be\n   the same as the one used in the MAILSEND program. In our case\n   it was named MAILCH\n   (check strings  MAIL FROM:  and  FROM: on the MAILSEND program)\n\n10. SENDMAIL   A sample JCL which you might use to build up\n   and test your own HTML form before inserting it into the\n   MAILLSEND program.\n\n   Note: The SMTP configuration is not very difficult. You will\n   find all the information you need in the manuals:\n   IP Configuration Guide at section  Configuring the SMTP server\n   and\n   IP Configuration Reference at chapter  SMTP Server\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE748": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04I\\x00\\x00\\x01\\x061\\x0f\\x01\\x061\\x0f\\x07C\\x00Z\\x00Z\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf3@@@'", "ispf": {"version": "04.73", "flags": 0, "createdate": "2006-11-06T00:00:00", "modifydate": "2006-11-06T07:43:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "CBT-473"}, "text": "//***FILE 748 is from Jose Neto and contains a REXX program, and    *   FILE 748\n//*           also an equivalent Assembler program, to convert      *   FILE 748\n//*           BASE64 encoding back to message text.                 *   FILE 748\n//*                                                                 *   FILE 748\n//*           Also included here is an email sending system which   *   FILE 748\n//*           allows an administrator to approve system changes,    *   FILE 748\n//*           using emails.  See member $$MAIL in this pds, for     *   FILE 748\n//*           details.  See also, member $$README.                  *   FILE 748\n//*                                                                 *   FILE 748\n//*           Please see member $$NOTE2 in the pds, which           *   FILE 748\n//*           (sort of) supersedes member $$NOTE1.                  *   FILE 748\n//*                                                                 *   FILE 748\n//*           email:  joserfneto@yahoo.co.uk                        *   FILE 748\n//*                                                                 *   FILE 748\n//*     Here is a summary of the members in this library:           *   FILE 748\n//*                                                                 *   FILE 748\n//*    1. CALLDECA   REXX sample program used to call DECODE64      *   FILE 748\n//*                  (the call is external to the routine)          *   FILE 748\n//*                  Note: DECODE64 may reside on LLA or LPA        *   FILE 748\n//*                                                                 *   FILE 748\n//*    2. CALLDECR   REXX sample program used to call DECODREX      *   FILE 748\n//*                  (the call is internal to the routine; both     *   FILE 748\n//*                  routines must be part of the same REXX         *   FILE 748\n//*                  program)                                       *   FILE 748\n//*                                                                 *   FILE 748\n//*    3. CALLSEND   REXX sample program used to call MAILSEND      *   FILE 748\n//*                                                                 *   FILE 748\n//*    4. DECODE64   Assembler program for decoding the BASE64      *   FILE 748\n//*                                                                 *   FILE 748\n//*    5. DECODREX   REXX program for decoding the BASE64           *   FILE 748\n//*                                                                 *   FILE 748\n//*    6. MAILPARM   Parameter file pointed by SYSTSIN on the       *   FILE 748\n//*                  PROCMAIL                                       *   FILE 748\n//*                                                                 *   FILE 748\n//*    7. MAILRECV   REXX program which is called to receive        *   FILE 748\n//*                  the email at the Mainframe. At the end of      *   FILE 748\n//*                  the routine we will have:                      *   FILE 748\n//*                                                                 *   FILE 748\n//*      Variables y.1  y.2 and y.3 have the time the email         *   FILE 748\n//*      was received the sender and the plain text from the        *   FILE 748\n//*      DECODE64.                                                  *   FILE 748\n//*                                                                 *   FILE 748\n//*      Example:                                                   *   FILE 748\n//*      y.1 = Email Received at:  Sat  4 Nov 2006 21:08:27 +0300   *   FILE 748\n//*      y.2 = From: \"Jose Neto\" <joserfneto@yahoo.co.uk>           *   FILE 748\n//*      y.3 = Message Content is: group1=Approve+Order+12345       *   FILE 748\n//*                                                                 *   FILE 748\n//*      In our system we address a table where the key is the      *   FILE 748\n//*      order number and set the approval status.                  *   FILE 748\n//*                                                                 *   FILE 748\n//*      Also  MAILRECV saves the log from the email in a file      *   FILE 748\n//*      with a DSNAME in the format:                               *   FILE 748\n//*      MAILCH.LOG.MISC.D041106.T210648 meaning it was             *   FILE 748\n//*      received at 4/11/2006 at 21:06:48.                         *   FILE 748\n//*                                                                 *   FILE 748\n//*      Note: the base64 text will come in a file which is         *   FILE 748\n//*      attached to the email with a filename=\"POSTDATA.ATT\"       *   FILE 748\n//*                                                                 *   FILE 748\n//*    8. MAILSEND  REXX program which is called to send the        *   FILE 748\n//*       email to the Microsoft Exchange Server The email is       *   FILE 748\n//*       formatted using HTML tags.                                *   FILE 748\n//*                                                                 *   FILE 748\n//*       You do not need to be a expert on HTML language to        *   FILE 748\n//*       code it.  The following sites were my guideline to        *   FILE 748\n//*       build it:                                                 *   FILE 748\n//*                                                                 *   FILE 748\n//*  http://www.tizag.com/htmlT/forms.php                           *   FILE 748\n//*  http://www.w3.org/TR/REC-html40/cover.html#minitoc             *   FILE 748\n//*  http://www.htmlgoodies.com/tutorials/forms/article.php/3479121 *   FILE 748\n//*  http://www.w3.org/TR/REC-CSS1                                  *   FILE 748\n//*                                                                 *   FILE 748\n//*    9. PROCMAIL   The procedure used to call MAILRECV REXX       *   FILE 748\n//*                  Program                                        *   FILE 748\n//*                                                                 *   FILE 748\n//*       Note: the RACF User associated with the Procedure         *   FILE 748\n//*       has to be the same as the one used in the MAILSEND        *   FILE 748\n//*       program. In our case it was named MAILCH (check           *   FILE 748\n//*       strings  MAIL FROM:  and  FROM: on the MAILSEND           *   FILE 748\n//*       program)                                                  *   FILE 748\n//*                                                                 *   FILE 748\n//*    10. SENDMAIL   A sample JCL which you might use to           *   FILE 748\n//*       build up and test your own HTML form before               *   FILE 748\n//*       inserting it into the MAILLSEND program.                  *   FILE 748\n//*                                                                 *   FILE 748\n//*       Note: The SMTP configuration is not very difficult.       *   FILE 748\n//*       You will find all the information you need in the         *   FILE 748\n//*       manuals:  IP Configuration Guide at section               *   FILE 748\n//*       Configuring the SMTP server, and IP Configuration         *   FILE 748\n//*       Reference at chapter  SMTP Server.                        *   FILE 748\n//*                                                                 *   FILE 748\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALLDECA": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x060\\x7f\\x01\\x060\\x8f!7\\x00\\t\\x00\\t\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-03T00:00:00", "modifydate": "2006-11-04T21:37:30", "lines": 9, "newlines": 9, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\n\ntrace o\nistem = \"Z3JvdXAxPUFwcHJvdmUrT3JkZXIrMDAwMDEyMDYrUE8xNDg3KzAwMDczMTY3Kw==\"\nostem  = DECODE64( istem )\nsay 'rc  = ' dec64rc\nsay 'Message Content is:' ostem\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALLDECR": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x06)\\x0f\\x01\\x060\\x8f!9\\x00\\x08\\x00\\x08\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-10-17T00:00:00", "modifydate": "2006-11-04T21:39:59", "lines": 8, "newlines": 8, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\n\ntrace o\nistem = \"Z3JvdXAxPUFwcHJvdmUrT3JkZXIrMDAwMDEyMDYrUE8xNDg3KzAwMDczMTY3Kw==\"\ncall decodrex istem , ostem\nsay 'Message Content is:' ostem\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALLSEND": {"ttr": 535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x060\\x8f\\x01\\x060\\x8f!6\\x00\\x1a\\x00\\x13\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T21:36:35", "lines": 26, "newlines": 19, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX to call mailsend                                 */\n/*                                                       */\n/* variables :                                           */\n/* ordern: has the order number for the transfer         */\n/* user.i: 1 to n email receipients                      */\n/* prog.i: 1 to n programs name                          */\n/* nuser : number of email recipients                    */\n/* nprog : number of programs                            */\n/*                                                       */\n/*********************************************************/\ntrace o\nordern = '12345'\nuser.1 = 'user-email@mail-server.domain'\nnuser = 1\nprog.1 = 'PROGRAM1'\nprog.2 = 'PROGRAM2'\nprog.3 = 'PROGRAM3'\nnprog = 3\ndo i = 1 to nuser\n   push user.i\nend\ndo i = 1 to nprog\n   push prog.i\nend\ncall mailsend ordern nuser nprog\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECODE64": {"ttr": 537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x06)\\x0f\\x01\\x060\\x8f\\x19P\\x01o\\x01n\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-10-17T00:00:00", "modifydate": "2006-11-04T19:50:44", "lines": 367, "newlines": 366, "modlines": 0, "user": "J.NETO"}, "text": "//  Job Card\n//*\n//ASMHCL      EXEC ASMACL,\n//            PARM.C='NODECK,OBJECT,XREF(SHORT),RENT',\n//            PARM.L='MAP,LET,LIST,NCAL,RENT,REUS',\n//            COND.L=(0,NE)\n//*           PARM.C='NODECK,OBJECT,XREF(SHORT),RENT',\n//*           PARM.C='NODECK,OBJECT,XREF(SHORT)',\n//*           PARM.L='MAP,LET,LIST,NCAL',\n//C.SYSIN   DD  *\nDECODE64 CSECT ,\nDECODE64 AMODE 31\nDECODE64 RMODE ANY\n*| ====================================================================\n*| Function : Transform base64 input data into plain text (decoding)\n*|\n*| Rent     : Yes (SHOULD be placed in LPA if used frequently)\n*|\n*| Amode    : Must run in 31-bit addressing mode\n*|\n*| Rmode    : Above or below...\n*|\n*| Return   : If no errors are encountered, the return will be a text\n*|            displayable exactly as the original one which was send\n*|            as a attached file (POSTDATA.ATT) from the mail client\n*|\n*|            The Return Code will be placed in the\n*|            DEC64RC return code variable.\n*|\n*|                    0 = No errors encountered, text converted OK\n*|                    1 = No arguments specified\n*|                    2 = Input data parameter missing\n*|                    3 = Too many arguments\n*|                    4 = Failed to get larger result block\n*|                    5 = Conversion failed\n*|\n*| Descript : The routine handle BASE64 input text and decode it to\n*|            obtain the clear text in EBCDIC\n*|\n*|         First it translates to the character set used in RFC2045\n*|\n*|         Second it restores the original bit formation with 24 bits\n*|         (3 bytes).\n*|\n*|         Second it converts the character code from ASCII to EBCDIC\n*|\n*|         More information about BASE 64 can be found at:\n*|         http://www.faqs.org/rfcs/rfc2045.html\n*|\n***********************************************************************\n* ---------------------------------------------------------------------\n* Setup base registers and addressability\n* ---------------------------------------------------------------------\n         SAVE     (14,12),,*                  Save caller's registers\n         LR       R11,R15                     Get base\n         USING    DECODE64,R11                Map CSECT\n         LR       R9,R0                       Save ENVB ptr\n         LR       R10,R1                      Save EFPL ptr\n         USING    EFPL,R10                    Map EFPL\n* ---------------------------------------------------------------------\n* Grab some work area storage and map\n* ---------------------------------------------------------------------\n         STORAGE  OBTAIN,LENGTH=WORKLEN       Get storage\n         ST       R13,4(,R1)                  Save callers savearea\n         ST       R1,8(,R13)                  Store ours in callers\n         LR       R13,R1                      Establish ours\n         USING    WORKAREA,R13                Map WORK\n* ---------------------------------------------------------------------\n* Grab some REXX routine ptrs\n* ---------------------------------------------------------------------\n         ST       R9,ENVBA                    Save ENVB\n         USING    ENVBLOCK,R9                 Map ENVB\n         L        R1,ENVBLOCK_IRXEXTE         Get ptr to EXTE\n         USING    IRXEXTE,R1                  Map EXTE\n         L        R4,IRXRLT                   Get ptr to RLT\n         ST       R4,RLTA                     Save it\n         L        R4,IRXEXCOM                 Get ptr to EXCOM\n         ST       R4,EXCOMA                   Save it\n         DROP     R1                          Done with EXTE\n         DROP     R9                          Done with ENVB\n* ---------------------------------------------------------------------\n* Get addressability to EVALBLOCK\n* ---------------------------------------------------------------------\n         L        R8,EFPLEVAL                 Get ptr to eval addr\n         L        R8,0(R8)                    Get EVAL addr\n         USING    EVALBLOCK,R8                Map EVAL\n         MVC      EVALBLOCK_EVLEN,=F'0'       Pre-init to null\n* ---------------------------------------------------------------------\n* Address and map the arguments\n* ---------------------------------------------------------------------\n         L        R9,EFPLARG                  Get ptr to arguments\n         USING    ARGTABLE_ENTRY,R9           Map ARGTABLE\n* ---------------------------------------------------------------------\n* Error if there are no arguments\n* ---------------------------------------------------------------------\n         CLC      ARGTABLE_END,ARGTABLE_ENTRY Last argument?\n         BE       ERR1                        Yes, need at least 1\n* ---------------------------------------------------------------------\n* Always need input data\n* ---------------------------------------------------------------------\n         LM       R4,R5,ARGTABLE_ARGSTRING_PTR Get ptr and length\n         LTR      R5,R5                       Null or missing?\n         BZ       ERR2                        Yes, error\n         STM      R4,R5,INPPTR                Store ptr and length\n* ---------------------------------------------------------------------\n* Don't need anymore arguments\n* ---------------------------------------------------------------------\n         LA       R9,ARGTABLE_NEXT            Gen ptr to next arg\n         CLC      ARGTABLE_END,ARGTABLE_ENTRY Last argument?\n         BNE      ERR3                        No, don't need anymore\n         DROP     R9                          Done with ARGTABLE\n* ---------------------------------------------------------------------\n* Calculate output buffer size\n* ---------------------------------------------------------------------\nCALCOS   LR       R3,R5                       Get input length\n         SLL      R3,1                        Double the size\n* ---------------------------------------------------------------------\n* Current eval block have enough room?\n* ---------------------------------------------------------------------\n         L        R1,EVALBLOCK_EVSIZE         Get EVAL size\n         SLL      R1,3                        Cvt to byte size\n         S        R1,=A(EVALBLOCK_EVDATA-EVALBLOCK) Knock off CB\n         CLR      R1,R3                       Big enough?\n         BNL      LB01                        Yes, continue\n* ---------------------------------------------------------------------\n* Have to get new result block\n* ---------------------------------------------------------------------\n         ST       R3,EVALL                    Set required length\n         L        R15,RLTA                    Get IRXRLTA ptr\n         CALL     (15),(=C'GETBLOCK',EVALA,EVALL,ENVBA),VL,MF=(E,PLIST)\n         LTR      R15,R15                     Success?\n         BNZ      ERR4                        No, error\n         L        R8,EVALA                    Get ptr to EVAL\n         ST       R8,EFPLEVAL                 Store in the EFPL\nLB01     ST       R3,EVALBLOCK_EVLEN          Set length\n         LA       R2,EVALBLOCK_EVDATA         Get output ptr\n         ST       R2,OUTPTR                   Store ptr to output area\n         ST       R3,OUTLENG                  Store length of out area\n         DROP     R8                          Done with EVALBLOCK\n         DROP     R10                         Done with EFPL\n* ---------------------------------------------------------------------\n* Decode Routine\n* ---------------------------------------------------------------------\n         L        R6,INPPTR                   Point to input area\n         L        R7,INPLENG                  Size of input area\n         BCTR     R7,R0                       Subtract 1 for execute\n         EX       R7,XTR                      Translate\n         L        R8,OUTPTR                   Point to output area\n         L        R7,OUTLENG                  Size of output area\n         BCTR     R7,R0                       Subtract 2\n         BCTR     R7,R0                               for execute\n         MVI      0(R8),X'20'                 Ascii space character\n         EX       R7,MTR                      Translate\n         L        R6,INPPTR                   Point to input area\n         L        R7,INPLENG                  Size of input area\n         L        R8,OUTPTR                   Point to output area\n* ---------------------------------------------------------------------\n* Value processing loop\n* ---------------------------------------------------------------------\n* ---------------------------------------------------------------------\n* Rebuild the 3 bytes from the tuple and store in dest\n* ---------------------------------------------------------------------\nMLOOP    XR       R4,R4                       Clear quad\n         XR       R5,R5                       Clerar register\n         ICM      R5,B'1111',0(R6)            Insert four bytes\n         SLDL     R4,26                       Shift in 26 bits\n         SRL      R4,2                        Get rid of 2 bits\n         SRDL     R4,24                       Position for next 6\n         SLDL     R4,18                       Shift in 18 bits\n         SRL      R4,2                        Get rid of 2 bits\n         SRDL     R4,16                       Position for next 6\n         SLDL     R4,10                       Shift in 10 bits\n         SRL      R4,2                        Get rid of 2 bits\n         SRDL     R4,8                        Position for next 6\n         SLDL     R4,2                        Shift in 2 bits\n         STCM     R5,B'1110',0(R8)            Store 3 original bytes\n* ---------------------------------------------------------------------\n* Adjust input parameters\n* ---------------------------------------------------------------------\nML20     LA       R8,3(R8)                    Bump dest to next loc\n         LA       R6,4(R6)                    Bump to next tuple\n         SL       R7,=F'4'                    Adjust length\n         LTR      R7,R7                       Zero length?\n         BNZ      MLOOP                       Still more, back to loop\n*\nNOMORE   L        R8,OUTPTR                   Point to output area\n         L        R9,OUTLENG                  Size of output area\n         BCTR     R9,R0                       Subtract 2\n         EX       R9,TTR                      Translate\n*        LA       R15,C'0'                    Show RC zero\n*        STC      R15,RC                      Store the RC\nSETRC0   MVI      RC,C'0'                     Store the RC\n         B        SETRCVAR                    Go set DEC64RC\n*\n* ---------------------------------------------------------------------\n* Error routines\n* ---------------------------------------------------------------------\nERR5     LA       R15,C'5'                    Conversion failed\n         B        ERR\nERR4     LA       R15,C'4'                    Failed to get block\n         B        ERR\nERR3     LA       R15,C'3'                    Too many arguments\n         B        ERR\nERR2     LA       R15,C'2'                    Missing argument\n         B        ERR\nERR1     LA       R15,C'1'                    No arguments\nERR      STC      R15,RC                      Store the RC\n         B        SETRCVAR                    Go set DEC64RC\n*\n* ---------------------------------------------------------------------\n* Fill in the request block\n* ---------------------------------------------------------------------\nSETRCVAR LA       R4,VREQ                     Get request ptr\n         XC       VREQ,VREQ                   Clear request block\n         USING    SHVBLOCK,R4                 Map SHVB\n* ---------------------------------------------------------------------\n* Initialize request block\n* ---------------------------------------------------------------------\n         MVI      SHVCODE,SHVSTORE            Function code\n         LA       R6,DEC64RC                  Get name ptr\n         LA       R7,L'DEC64RC                Get name length\n         LA       R8,RC                       Get RC ptr\n         LA       R9,1                        Get RC length\n         STM      R6,R9,SHVNAMA               Store the lot\n* ---------------------------------------------------------------------\n* Store the value\n* ---------------------------------------------------------------------\n         L        R15,EXCOMA                  Get IRXEXCOM ptr\n         CALL     (15),(=C'IRXEXCOM',0,0,VREQ,ENVBA),VL,MF=(E,PLIST)\n* removed because if R15 different from 0 returns message IRX0040I\n*        LA       R15,1                       Bad RC\n         B        RETURN                      Go exit\n         DROP     R4                          Done with SHVB\n* ---------------------------------------------------------------------\n* Return to caller\n* ---------------------------------------------------------------------\nRETURN   LR       R2,R15                      Save RC\n         LR       R1,R13                      Get workarea ptr\n         L        R13,4(,R13)                 Restore callers savearea\n         STORAGE  RELEASE,LENGTH=WORKLEN,ADDR=(R1) Release workarea\n         LR       R15,R2                      Restore RC\n         L        R14,12(,R13)                Get return address\n         LM       R0,R12,20(R13)              Restore registers\n         BSM      0,R14                       Return to caller\n         DROP     R13                         Done with WORK\n* ---------------------------------------------------------------------\n* Executed instructions\n* ---------------------------------------------------------------------\nXTR      TR       0(0,R6),CSET                Executed\nTTR      TR       0(0,R8),TSET                Executed\nMTR      MVC      1(0,R8),0(R8)               Executed\n* ---------------------------------------------------------------------\n* Static data area\n* ---------------------------------------------------------------------\nDEC64RC  DC       C'DEC64RC'                  Return code variable name\n*\n         DS       0D\nCSET     DC       256XL1'00'\n         ORG      CSET+C'A'\n         DC       X'000102030405060708'\n         ORG      CSET+C'J'\n         DC       X'090A0B0C0D0E0F1011'\n         ORG      CSET+C'S'\n         DC       X'1213141516171819'\n         ORG      CSET+C'a'\n         DC       X'1A1B1C1D1E1F202122'\n         ORG      CSET+C'j'\n         DC       X'232425262728292A2B'\n         ORG      CSET+C's'\n         DC       X'2C2D2E2F30313233'\n         ORG      CSET+C'0'\n         DC       X'3435363738393A3B3C3D'\n         ORG      CSET+C'+'\n         DC       X'3E'\n         ORG      CSET+C'/'\n         DC       X'3F'\n         ORG      CSET+C'='\n         DC       X'20'\n         ORG\nTSET     DS       0D\n         DC       X'00010203372D2E2F1605250B0C0D0E0F'\n         DC       X'101112133C3D322618193F271C1D1E1F'\n         DC       X'405A7F7B4A6C507D4D5D5C4E6B604B61'\n         DC       X'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'\n         DC       X'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'\n         DC       X'D7D8D9E2E3E4E5E6E7E8E9B1E0BBBA6D'\n         DC       X'79818283848586878889919293949596'\n         DC       X'979899A2A3A4A5A6A7A8A9C04FD0BC07'\n         DC       X'68DC5142434447485253545756586367'\n         DC       X'719C9ECBCCCDDBDDDFECFC705B80BFFF'\n         DC       X'4555CEDE49699A9BABAF5FB8B7AA8A8B'\n         DC       X'2B2C092128656264B438313433B0B224'\n         DC       X'22172906202A46661A35083936303A40'\n         DC       X'8CAC7273749F757677231514046A783B'\n         DC       X'EE59EBEDCFEFA08EAEFEFBFD8DADA1BE'\n         DC       X'CA8F1BB9B6B5E19D90BDB3DAFAEA3E41'\n*\n* ---------------------------------------------------------------------\n* Literals\n* ---------------------------------------------------------------------\n         LTORG                                Literals\n         DROP     R11                         Done with BASE\n* ---------------------------------------------------------------------\n* Put argument list here to get access to constant data\n* ---------------------------------------------------------------------\n         IRXARGTB DECLARE=YES                 Argument Table\n* ---------------------------------------------------------------------\n* Workarea DSECT\n* ---------------------------------------------------------------------\nWORKAREA DSECT\nSAVEAREA DS       18F                         Must be at start\n*\nINPPTR   DS    F                   pointer to input record\nINPLENG  DS    F                   length of input record\nOUTPTR   DS    F                   pointer to output record\nOUTLENG  DS    F                   length of output record\n* ---------------------------------------------------------------------\n* Remaining work fields\n* ---------------------------------------------------------------------\nPFWD     DS       F\nEVALA    DS       A\nEVALL    DS       F\nENVBA    DS       A\nEXCOMA   DS       A\nRLTA     DS       A\nPLIST    CALL     ,(,,,,),MF=L\nVREQ     DS       XL(SHVBLEN)\nRC       DS       C\n*\nWORKLEN  EQU      *-WORKAREA\n* ---------------------------------------------------------------------\n* Register equates\n* ---------------------------------------------------------------------\n        EJECT\n*---------------------------------------------------------------------*\n*- register usage                                                    -*\n*---------------------------------------------------------------------*\nR0      EQU    0                  not used\nR1      EQU    1                  work and parm reg\nR2      EQU    2                  work reg\nR3      EQU    3                  work reg\nR4      EQU    4                  work reg\nR5      EQU    5                  work reg\nR6      EQU    6                  work reg\nR7      EQU    7                  work reg\nR8      EQU    8                  point to parameters\nR9      EQU    9                  linkage (inside the program)\nR10     EQU    10                 point to getmained area\nR11     EQU    11                 first base register\nR12     EQU    12                 second base register\nR13     EQU    13                 linkage\nR14     EQU    14                 linkage\nR15     EQU    15                 linkage\n* ---------------------------------------------------------------------\n* Rest of REXX control blocks\n* ---------------------------------------------------------------------\n         IRXEFPL                              Function Parameter List\n         IRXEVALB                             Evaluation Block\n         IRXENVB                              Environment Block\n         IRXSHVB                              Variable Request\n         IRXEXTE                              External Entry Points\n* ---------------------------------------------------------------------\n* The world is square ya know...careful you don't fall off!\n* ---------------------------------------------------------------------\n         END\n//L.SYSLMOD DD  DISP=SHR,\n//       DSN=xxx.LINKLIB(DECODE64)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DECODREX": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00P\\x01\\x06)\\x0f\\x01\\x060\\x8f!9\\x00\\xb6\\x00\\xb6\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-10-17T00:00:00", "modifydate": "2006-11-04T21:39:50", "lines": 182, "newlines": 182, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\n/* This Routine was built to decode a string which was encoded       */\n/* using the Base64 Content-Transfer-Encoding                        */\n/*                                                                   */\n/* More information about BASE 64 can be found at:                   */\n/* http://www.faqs.org/rfcs/rfc2045.html                              */\n/*                                                                   */\ntrace o\ndecodrex:\nparse arg istem ostem\nostem = ''\nllinp = Length( istem )\nicnt = llinp / 4\ntauxtem = istem\ndo idec = 1 to icnt\n   auxtem = substr(tauxtem,1,4)\n   do i1dec = 1 to 4\n      iauxtem = substr(auxtem,i1dec,1)\n      call selbit_ascii\n      obtem.i1dec = oauxtem\n   end\n   obitstem = obtem.1 || obtem.2 || obtem.3 || obtem.4\n   ibyt.1 = substr(obitstem,1,8)\n   ibyt.2 = substr(obitstem,9,8)\n   ibyt.3 = substr(obitstem,17,8)\n   do i1dec = 1 to 3\n      iauxtem = ibyt.i1dec\n      call selbyt_ascii\n      obyt.i1dec = oauxtem\n   end\n   ostem = ostem || obyt.1 || obyt.2 || obyt.3\n   tauxtem = substr(tauxtem,5)\nend\nreturn\n/*                         */\n/*  select bits from input */\n/*                         */\nselbit_ascii:\nselect\n  when iauxtem = 'A' then oauxtem = '000000'\n  when iauxtem = 'B' then oauxtem = '000001'\n  when iauxtem = 'C' then oauxtem = '000010'\n  when iauxtem = 'D' then oauxtem = '000011'\n  when iauxtem = 'E' then oauxtem = '000100'\n  when iauxtem = 'F' then oauxtem = '000101'\n  when iauxtem = 'G' then oauxtem = '000110'\n  when iauxtem = 'H' then oauxtem = '000111'\n  when iauxtem = 'I' then oauxtem = '001000'\n  when iauxtem = 'J' then oauxtem = '001001'\n  when iauxtem = 'K' then oauxtem = '001010'\n  when iauxtem = 'L' then oauxtem = '001011'\n  when iauxtem = 'M' then oauxtem = '001100'\n  when iauxtem = 'N' then oauxtem = '001101'\n  when iauxtem = 'O' then oauxtem = '001110'\n  when iauxtem = 'P' then oauxtem = '001111'\n  when iauxtem = 'Q' then oauxtem = '010000'\n  when iauxtem = 'R' then oauxtem = '010001'\n  when iauxtem = 'S' then oauxtem = '010010'\n  when iauxtem = 'T' then oauxtem = '010011'\n  when iauxtem = 'U' then oauxtem = '010100'\n  when iauxtem = 'V' then oauxtem = '010101'\n  when iauxtem = 'W' then oauxtem = '010110'\n  when iauxtem = 'X' then oauxtem = '010111'\n  when iauxtem = 'Y' then oauxtem = '011000'\n  when iauxtem = 'Z' then oauxtem = '011001'\n  when iauxtem = 'a' then oauxtem = '011010'\n  when iauxtem = 'b' then oauxtem = '011011'\n  when iauxtem = 'c' then oauxtem = '011100'\n  when iauxtem = 'd' then oauxtem = '011101'\n  when iauxtem = 'e' then oauxtem = '011110'\n  when iauxtem = 'f' then oauxtem = '011111'\n  when iauxtem = 'g' then oauxtem = '100000'\n  when iauxtem = 'h' then oauxtem = '100001'\n  when iauxtem = 'i' then oauxtem = '100010'\n  when iauxtem = 'j' then oauxtem = '100011'\n  when iauxtem = 'k' then oauxtem = '100100'\n  when iauxtem = 'l' then oauxtem = '100101'\n  when iauxtem = 'm' then oauxtem = '100110'\n  when iauxtem = 'n' then oauxtem = '100111'\n  when iauxtem = 'o' then oauxtem = '101000'\n  when iauxtem = 'p' then oauxtem = '101001'\n  when iauxtem = 'q' then oauxtem = '101010'\n  when iauxtem = 'r' then oauxtem = '101011'\n  when iauxtem = 's' then oauxtem = '101100'\n  when iauxtem = 't' then oauxtem = '101101'\n  when iauxtem = 'u' then oauxtem = '101110'\n  when iauxtem = 'v' then oauxtem = '101111'\n  when iauxtem = 'w' then oauxtem = '110000'\n  when iauxtem = 'x' then oauxtem = '110001'\n  when iauxtem = 'y' then oauxtem = '110010'\n  when iauxtem = 'z' then oauxtem = '110011'\n  when iauxtem = '0' then oauxtem = '110100'\n  when iauxtem = '1' then oauxtem = '110101'\n  when iauxtem = '2' then oauxtem = '110110'\n  when iauxtem = '3' then oauxtem = '110111'\n  when iauxtem = '4' then oauxtem = '111000'\n  when iauxtem = '5' then oauxtem = '111001'\n  when iauxtem = '6' then oauxtem = '111010'\n  when iauxtem = '7' then oauxtem = '111011'\n  when iauxtem = '8' then oauxtem = '111100'\n  when iauxtem = '9' then oauxtem = '111101'\n  when iauxtem = '+' then oauxtem = '111110'\n  when iauxtem = '/' then oauxtem = '111111'\n  when iauxtem = '=' then oauxtem = '000000'\nend\nreturn\n/*                         */\n/*  select bytes from input */\n/*                         */\nselbyt_ascii:\nselect\n  when iauxtem = '00100000' then oauxtem = ' '\n  when iauxtem = '00110000' then oauxtem = '0'\n  when iauxtem = '00110001' then oauxtem = '1'\n  when iauxtem = '00110010' then oauxtem = '2'\n  when iauxtem = '00110011' then oauxtem = '3'\n  when iauxtem = '00110100' then oauxtem = '4'\n  when iauxtem = '00110101' then oauxtem = '5'\n  when iauxtem = '00110110' then oauxtem = '6'\n  when iauxtem = '00110111' then oauxtem = '7'\n  when iauxtem = '00111000' then oauxtem = '8'\n  when iauxtem = '00111001' then oauxtem = '9'\n  when iauxtem = '00111101' then oauxtem = '='\n  when iauxtem = '01000001' then oauxtem = 'A'\n  when iauxtem = '01000010' then oauxtem = 'B'\n  when iauxtem = '01000011' then oauxtem = 'C'\n  when iauxtem = '01000100' then oauxtem = 'D'\n  when iauxtem = '01000101' then oauxtem = 'E'\n  when iauxtem = '01000110' then oauxtem = 'F'\n  when iauxtem = '01000111' then oauxtem = 'G'\n  when iauxtem = '01001000' then oauxtem = 'H'\n  when iauxtem = '01001001' then oauxtem = 'I'\n  when iauxtem = '01001010' then oauxtem = 'J'\n  when iauxtem = '01001011' then oauxtem = 'K'\n  when iauxtem = '01001100' then oauxtem = 'L'\n  when iauxtem = '01001101' then oauxtem = 'M'\n  when iauxtem = '01001110' then oauxtem = 'N'\n  when iauxtem = '01001111' then oauxtem = 'O'\n  when iauxtem = '01010000' then oauxtem = 'P'\n  when iauxtem = '01010001' then oauxtem = 'Q'\n  when iauxtem = '01010010' then oauxtem = 'R'\n  when iauxtem = '01010011' then oauxtem = 'S'\n  when iauxtem = '01010100' then oauxtem = 'T'\n  when iauxtem = '01010101' then oauxtem = 'U'\n  when iauxtem = '01010110' then oauxtem = 'V'\n  when iauxtem = '01010111' then oauxtem = 'W'\n  when iauxtem = '01011000' then oauxtem = 'X'\n  when iauxtem = '01011001' then oauxtem = 'Y'\n  when iauxtem = '01011010' then oauxtem = 'Z'\n  when iauxtem = '01100001' then oauxtem = 'a'\n  when iauxtem = '01100010' then oauxtem = 'b'\n  when iauxtem = '01100011' then oauxtem = 'c'\n  when iauxtem = '01100100' then oauxtem = 'd'\n  when iauxtem = '01100101' then oauxtem = 'e'\n  when iauxtem = '01100110' then oauxtem = 'f'\n  when iauxtem = '01100111' then oauxtem = 'g'\n  when iauxtem = '01101000' then oauxtem = 'h'\n  when iauxtem = '01101001' then oauxtem = 'i'\n  when iauxtem = '01101010' then oauxtem = 'j'\n  when iauxtem = '01101011' then oauxtem = 'k'\n  when iauxtem = '01101100' then oauxtem = 'l'\n  when iauxtem = '01101101' then oauxtem = 'm'\n  when iauxtem = '01101110' then oauxtem = 'n'\n  when iauxtem = '01101111' then oauxtem = 'o'\n  when iauxtem = '01110000' then oauxtem = 'p'\n  when iauxtem = '01110001' then oauxtem = 'q'\n  when iauxtem = '01110010' then oauxtem = 'r'\n  when iauxtem = '01110011' then oauxtem = 's'\n  when iauxtem = '01110100' then oauxtem = 't'\n  when iauxtem = '01110101' then oauxtem = 'u'\n  when iauxtem = '01110110' then oauxtem = 'v'\n  when iauxtem = '01110111' then oauxtem = 'w'\n  when iauxtem = '01111000' then oauxtem = 'x'\n  when iauxtem = '01111001' then oauxtem = 'y'\n  when iauxtem = '01111010' then oauxtem = 'z'\n  when iauxtem = '00101011' then oauxtem = '+'\n  when iauxtem = '00111101' then oauxtem = '='\n  otherwise oauxtem = ' '\nend\nreturn\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAILPARM": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x060\\x8f\\x01\\x060\\x8f R\\x00\\x04\\x00\\x06\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T20:52:54", "lines": 4, "newlines": 6, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\nprofile noprefix\nmailrecv\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAILRECV": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x060\\x8f\\x01\\x060\\x8f!\\x06\\x00I\\x00I\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T21:06:38", "lines": 73, "newlines": 73, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\n\ntrace i\nprofile noprefix\ni = 0\nreceive\nx = sysdsn('MAILCH.LOG.MISC')\nif x /= 'OK' then signal fim\n\"ALLOC FI(DDLOG) DA('MAILCH.LOG.MISC') shr\"\n\"ALLOC FI(DDMAIL) sysout(x)\"\n\n\"MAKEBUF\"\n\"EXECIO * DISKR DDLOG (FINIS\"\n\ndo until queued() = 0\n  call readfile\n  call process\nend;\ncall writefile\nsignal fecha;\n\nprocess:\nif fword = 'Date:' then\ndo\n  string = substr(line1,7)\n  i = i + 1\n  y.i = 'Email Received at: ' string\nend\nif fword = 'From:' then\ndo\n  i = i + 1\n  y.i = line1\nend\nfstr = substr(fword,2)\nif fstr = 'filename=\"POSTDATA.ATT\"' then\ndo\n  call readfile\n  call readfile\n  istem = fword\n  ostem  = DECODE64( istem )\n  i = i + 1\n  y.i = 'Message Content is:' ostem\nend\nreturn\n\nreadfile:\nparse pull line1\nfword = subword(line1,1,1)\nreturn\n\nwritefile:\n\"EXECIO \"i\" DISKW DDMAIL (STEM y.\"\nreturn\n\nfecha:\n\"EXECIO 0 DISKR DDLOG (FINIS\"\n\"EXECIO 0 DISKR DDMAIL (FINIS\"\n\"DROPBUF\"\n\"FREE FILE(DDLOG)\"\n\"FREE FILE(DDMAIL)\"\nxt = time()\nxt = 'T'||substr(xt,1,2)||substr(xt,4,2)||substr(xt,7,2)\nxd = date('E')\nxd = 'D'||substr(xd,1,2)||substr(xd,4,2)||substr(xd,7,2)\nupper xd\ndsn1 = 'MAILCH.LOG.MISC'\ndsn2 = 'MAILCH.LOG.MISC.'xd'.'xt\nrename dsn1 dsn2\nsignal fim\n\nfim:\nExit;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAILSEND": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x060\\x8f\\x01\\x060\\x8f\"\\t\\x00\\x94\\x00\\x96\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T22:09:57", "lines": 148, "newlines": 150, "modlines": 0, "user": "J.NETO"}, "text": "/* REXX                                                              */\n/*                                                                   */\n\ntrace o\nprofile noprefix\nparse upper arg chorder nuser nprog\n/* pull programs */\ndo i = nprog to 1 by -1\n   pull program.i\nend\n/* pull user */\ndo i = nuser to 1 by -1\n   pull usermail.i\nend\ndropbuf\n\n/* send mail */\n\"ALLOC F(dd2) SYSOUT(p) WRITER(SMTP)\"\n/* \"ALLOC F(dd2) SYSOUT(x)\" */\n\niy = 0\norigin = mvsvar(sysname)\ny.1 = 'HELO' origin\ny.2 = 'MAIL FROM:<MAILCH@' || origin || '.mainframe-domain>'\niy = iy + 2\ndo i = 1 to nuser\n   iy = iy + 1\n   y.iy = 'RCPT TO:<' || usermail.i || '>'\nend\n\niy = iy + 1\ny.iy = 'DATA'\niy = iy + 1\ny.iy = 'FROM:MAILCH@' || origin || '.mainframe-domain'\ndo i = 1 to nuser\n   iy = iy + 1\n   y.iy = 'TO:' || usermail.i\nend\niy = iy + 1\ny.iy = 'SUBJECT:System Name - Order Number' chorder ,\n       'Requesting your Approval'\n\niy = iy + 1\ny.iy = 'MIME-VERSION: 1.0'\niy = iy + 1\ny.iy = 'CONTENT-TYPE: MULTIPART/MIXED;'\niy = iy + 1\ny.iy = '              BOUNDARY=\"SIMPLE BOUNDARY\"'\niy = iy + 1\ny.iy = '--SIMPLE BOUNDARY'\niy = iy + 1\ny.iy = 'CONTENT-TYPE: TEXT/HTML'\niy = iy + 1\ny.iy = '                       '\niy = iy + 1\ny.iy = '<FORM METHOD=\"POST\"'\niy = iy + 1\ny.iy = 'ACTION=\"mailto:MAILCH@' || origin || '.mainframe-domain\">'\niy = iy + 1\ny.iy = '<p align=\"center\">'\niy = iy + 1\ny.iy = '<font size=\"7\" face=\"Georgia, Arial\"'\niy = iy + 1\ny.iy = 'color=\"blue\">- COMPANY -- NAME    -</font>'\niy = iy + 1\ny.iy = '</p>'\niy = iy + 1\ny.iy = '<p align=\"center\"><font size=\"7\" face=\"Georgia, Arial\"'\niy = iy + 1\ny.iy = 'color=\"maroon\">S</font>ystem'\niy = iy + 1\ny.iy = '<font size=\"7\" face=\"Georgia, Arial\"'\niy = iy + 1\ny.iy = 'color=\"maroon\">N</font>ame'\niy = iy + 1\ny.iy = '</p>'\niy = iy + 1\ny.iy = '<BR>'\niy = iy + 1\ny.iy = '<h2 align=\"center\">'\niy = iy + 1\ny.iy = ' Request For Authorization</h2>'\niy = iy + 1\ny.iy = '<h2 align=\"center\">Order No.' chorder '( ' creupd ' ) </h2>'\niy = iy + 1\ny.iy = '<BR>'\n\niy = iy + 1\ny.iy = '<p align=\"center\">'\niy = iy + 1\ny.iy = '<FONT FACE=\"COURIER\" SIZE=\"+2\"'\niy = iy + 1\ny.iy = 'COLOR=BLUE align=\"center\">'\niy = iy + 1\ny.iy = '</p>'\niy = iy + 1\ny.iy = '<BR>'\ny.iy = '<BR><BR>'\ndo i = 1 to nprog\n   iy = iy + 1\n   y.iy = program.i\n   iy = iy + 1\n   y.iy = '<BR>'\nend\niy = iy + 1\ny.iy = '<BR><BR>'\n\n/* final settings */\niy = iy + 1\ny.iy = '<FONT FACE=\"COURIER\" SIZE=\"+2\" COLOR=RED>'\niy = iy + 1\ny.iy = '<div align=\"left\"><br>'\niy = iy + 1\ny.iy = '<input type=\"radio\" name=\"group1\"'\niy = iy + 1\ny.iy = 'value=\"Approve Order' chorder'\">'\niy = iy + 1\ny.iy = 'Approve<br>'\niy = iy + 1\ny.iy = '<input type=\"radio\" name=\"group1\"'\niy = iy + 1\ny.iy = 'value=\"Reject Order' chorder '\" checked>'\niy = iy + 1\ny.iy = 'Reject<br>'\niy = iy + 1\ny.iy = '<BR><BR>'\niy = iy + 1\ny.iy = '<div align=\"center\"><br>'\niy = iy + 1\ny.iy = '<input type=\"submit\" value=\"Submit\">'\niy = iy + 1\ny.iy = '<hr>'\niy = iy + 1\ny.iy = '<BR><BR>'\niy = iy + 1\ny.iy = '</td></tr>'\niy = iy + 1\ny.iy = '</table>'\niy = iy + 1\ny.iy = '--SIMPLE BOUNDARY--'\niy = iy + 1\ny.iy = 'QUIT'\n\"EXECIO\" iy \"DISKW dd2 (STEM y.\"\n\"EXECIO 0 DISKW DD2 (FINIS\"\n\"DROPBUF\"\n\"FREE FILE(dd2)\"\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROCMAIL": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x060\\x8f\\x01\\x060\\x8f!\\x15\\x00\\x08\\x00\\x08\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T21:15:37", "lines": 8, "newlines": 8, "modlines": 0, "user": "J.NETO"}, "text": "//PROCMAIL PROC\n//*\n//CHCKTASK EXEC PGM=IKJEFT01,REGION=0M,DYNAMNBR=90\n//SYSPROC  DD  DISP=SHR,DSN=REXX-LIBRARY\n//SYSTSPRT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSTSIN  DD  DISP=SHR,DSN=PARAMETER-LIBRARY(MAILPARM)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SENDMAIL": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x060\\x8f\\x01\\x060\\x8f\"\\x12\\x00E\\x00\\x7f\\x00\\x00\\xd1K\\xd5\\xc5\\xe3\\xd6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-04T00:00:00", "modifydate": "2006-11-04T22:12:35", "lines": 69, "newlines": 127, "modlines": 0, "user": "J.NETO"}, "text": "//SMTPPTSJ JOB (B36,SSS),'SMTP PTS',REGION=8M,\n//         CLASS=B,MSGCLASS=X,MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//*\n//SENDNOTE EXEC PGM=IEBGENER\n//SYSIN    DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD SYSOUT=(P,SMTP)\n//SYSUT1   DD *\nHELO PACT\nMAIL FROM:<MAILCH@sysname.mainframe-domain>\nRCPT TO:<joserfneto@yahoo.co.uk>\nDATA\nFROM:     MAILCH@sysname.mainframe-domain\nTO:       joserfneto@yahoo.co.uk\nSUBJECT:  Order Number 12345 requesting your Approval\nMIME-VERSION: 1.0\nCONTENT-TYPE: MULTIPART/MIXED;\n              BOUNDARY=\"SIMPLE BOUNDARY\"\n--SIMPLE BOUNDARY\nCONTENT-TYPE: TEXT/HTML\n\n<FORM METHOD=\"POST\" ACTION=\"mailto:MAILCH@sysname.mainframe-domain\">\n\n\n<p align=\"center\">\n<font size=\"7\" face=\"Georgia, Arial\"\ncolor=\"blue\">-  C O M P A N Y --  N A M E    -</font>\n</p>\n<p align=\"center\"><font size=\"7\" face=\"Georgia, Arial\"\ncolor=\"maroon\">S</font>ystem\n<font size=\"7\" face=\"Georgia, Arial\"\ncolor=\"maroon\">N</font>ame\n</p>\n\n<BR>\n<h2 align=\"center\">\n Request For Authorization</h2>\n<h2 align=\"center\">Order No. 12345</h2>\n<BR>\n\n<FONT FACE=\"COURIER\" SIZE=\"+2\" COLOR=BLUE align=\"center\">\nPrograms to be transferred from Test Env. to Prod Env.\n<BR><BR>\nProgram A\n<BR>\nProgram B\n<BR>\nProgram C\n<BR>\nProgram D\n<BR><BR>\n<FONT FACE=\"COURIER\" SIZE=\"+2\" COLOR=RED>\n<div align=\"left\"><br>\n<input type=\"radio\" name=\"group1\"\nvalue=\"Approve Order 12345\">\nApprove<br>\n<input type=\"radio\" name=\"group1\"\nvalue=\"Reject Order 12345\" checked>\nReject<br>\n<BR><BR>\n<div align=\"center\"><br>\n<input type=\"submit\" value=\"Submit\">\n<hr>\n<BR><BR>\n</td></tr>\n</table>\n--SIMPLE BOUNDARY--\nQUIT\n/*EOF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT748/FILE748.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT748", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}