{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011400000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2939300, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 20, "INMDSNAM": "CBT.V500.FILE166.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2939300, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2939300, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE166.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00/\\x05'", "DS1TRBAL": "b'\\x88\\xcc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01 \\x00\\x0c\\x01#\\x00\\x0e\\x000'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$NOTE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x99\\x04?\\x00E\\x00\\x13\\x00\\x04\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1999-02-12T00:45:00", "lines": 19, "newlines": 4, "modlines": 0, "user": "NMVV1"}, "text": "\n   FOR ANY QUESTIONS, OR COMMENTS, PLEASE CALL ME AT:\n\n      (972)-401-6948 (THIS IS MY DIRECT NUMBER AT NM)\n\n(WITHOUT PROMISING....)\nWE MAY PROVIDE FIXES/MODIFICATIONS AND NEW PROGRAMS FROM TIME TO TIME.\nAGAIN, MY **NEW** (SINCE 3/1998) COMPANY ADDRESS IS AS FOLLOWS:\n\n\n          VINH VU\n          CONSULTING TECHNOLOGIST\n          NEIMAN MARCUS\n          IS DEPARTMENT\n          111 CUSTOMER WAY\n          IRVING, TX  75039-3607\n\n    email:    Vinh_Vu@neimanmarcus.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00!\\x01 \\t\\x1f\\x01 \\t\\x1f\\x11P\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-31T00:00:00", "modifydate": "2020-03-31T11:50:21", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  166\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE166\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 88 MEMBERS COUNTED; CUMULATIVE SIZE IS 27,036 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/31/20    11:50:21    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00W\\x01 \\x07\\x1f\\x01 \\t\\x0f\\x19S\\x00W\\x00A\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2020-03-11T00:00:00", "modifydate": "2020-03-30T19:53:57", "lines": 87, "newlines": 65, "modlines": 0, "user": "SBGOLOB"}, "text": "Vinh Vu - 3/11/2020\n\nJust added a couple of execs added for your entertainment:\n\n$ALIDEF\n$CATDEF\n   Edit macros to generate the DEF ALIAS/NONVSAM statements while you're\n   editing a list of data sets and/or data sets/alias names.  Look\n   inside the exec for documentation. Issuing the macro name without\n   any parm will also give you a quick help.\n\n$CPU\n   Display CPU usage in graphical format. Hitting Enter will refresh the\n   screen, and move the cursor down to the next line. Historical CPU\n   usage is kept in a rolling format (like spreadsheet rows) and it\n   wraps around.  PF3 will get you out.  I wrote this many years ago\n   when I was doing performance.  This is still usefull sometimes.\n\n$IEASYS\n   Display lots of pertinent system information along with how LOADxx\n   drives IEASYMxx which then drives IEASYSxx and other Parmlib members\n   when MVS comes up.  The thing that makes this different than others\n   is, not only it displays the member suffixes (of appropriate Parm\n   members), it also lists where they come from (based on the Parmlib\n   concatenation).  See $SYSPRM below for the extention of this feature.\n   At the bottom of the display is of course the list of system\n   symbolics.\n\n$MCOPY/$MDEL/$MREN\n   Execs used as Line Command to invoke the ISPF Member COPY/DELETE/\n   RENAME facilities. Instead of having to use the panel, you can just\n   issue this as a single line command. In addition, invoking ISPF\n   facility will ensure that the ENQ will get issued for the member\n   names, which help to avoid Directory corruption if multiply users\n   are updating the same PDS across several systems by using IEBCOPY.\n   Of course, using the ISPF Panel to do the copy will also issue the\n   ENQ as well.\n\n$MEM\n   With a list of data sets, you can find/browse/edit a specific member\n   found in that data set concatenation. Cusror sensitive help is also\n   available on the panel.  Useful to check for duplicate member and/or\n   Parmlib member so you know exactly what parmlib member is being used.\n\n$POINT\n   Grabs a data set name (plus member) and displays a data set info\n   screen which allows you to edit/browse/view, etc.. against that data\n   set. If the data set is a loadlib, it will even tell you if it's\n   APF'ed and/or Linklist'ed.  Set one of the non-frequently used PF\n   key, like PF4, and say 'TSO %$POINT' then just cursor down to\n   anywhere on screen and hit PF4.\n\n$SYMSUB\n   Edit Macro to substitue all system symbolics with their real values.\n   Relies on an ASM REXX function called $RXSYMBL which is copied into\n   VENDOR.ISPLLIB. This edit macro is also invoked by exec $SYSPRM.\n\n   Note on this: The real source of $RXSYMBL right now is in this PDS.\n   To install this somewhere, will need to assemble this program and\n   put it in a IPSLLIB/STEPLIB, etc.. where it can be found through\n   the load module search sequence.\n\n$SYSINFO\n   Colorful system information display. PF1 gives tutorial. If the LPAR\n   has several CPs, the list of SN for them will be listed at the\n   bottom, which you can also page down to see them all (up to 16).  A\n   CPU Util graph is displayed which does get refreshed when you press\n   Enter. Of course, PF3 will get you out.\n\n$SYSPRM\n   $IEASYS list the parmlib suffixes and where the parmlib members come\n   from, based on how it was coded in IEASYSxx, i.e. CMD, ALLOC, PROG,\n   OMVS, etc.. This exec will actually takes all those members, copies\n   them altogether into a temp data set, resolved all system synmbolics\n   if needed, and presents you with the data in ISPF edit mode.  Having\n   said that, it does require an argument of XXXX where XXXX is PROG,\n   OMVS, etc.. (as shown by $IEASYS). An additional character argument\n   can also be provided after this XXXX (can be anything), which brings\n   up a screen which allows you to fill in the VOLSER of the parmlibs\n   instead of using what the current parmlibs are. This is good if\n   you're working on building a new system, and having this exec go\n   after the same members on a different volume.\n\n   This exec will invoke the $SYMSUB edit macro at the end.\n\n   Example;  $SYSPRM OMVS or $SYSPRM PROG x (x=any character)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$LIST": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01 \\t\\x0f\\x01 \\t\\x0f\\t0\\x00\\x13\\x00\\x0e\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2020-03-30T00:00:00", "modifydate": "2020-03-30T09:30:02", "lines": 19, "newlines": 14, "modlines": 0, "user": "VINHVU"}, "text": "$$DOC    - What it is\n$$LIST   - What it is\n$ALIDEF  - Edit macro to generate DEF ALIAS IDCAMS statements\n$CATDEF  - Edit macro to generate DEF NVSAM IDCAMS statements\n$CPU     - Exec to display CPU Utilization\n$IEASYS  - Exec to display the IPA variables (resolved by MVS at IPL)\n$MCOPY   - To invoke ISPF COPY Member utility as a command line.\n$MDEL    - To invoke ISPF DELETE Member utility as a command line\n$MEM     - Search for a member in a list of concatenated PDSes\n$MREN    - To invoke ISPF RENAME Member utility as a command line\n$POINT   - Used to bring up a dsat summary and allows user to browse/\n           view dsat/member - Good if used in conjunction with a PF key.\n$RXSYMBL - ASM Rexx function\n$SYMSUB  - Rexx routine to invoke $RXSYMBL to resolve system symbolics\n$SYSINFO - Pretty System Info display\n$SYSPRM  - Takes a IEASYS member keyword, expands the list of concat'ed\n           members of that keyword (i.e. PROG, OMVS, etc.) and put data\n           into a temp data set so you can see the whole thing. Use this\n           in conjunction with $IEASYS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$ALIDEF": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00G\\x01\\x18&\\x9f\\x01\\x18)\\x9f\\x120\\x00v\\x009\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2018-09-26T00:00:00", "modifydate": "2018-10-26T12:30:47", "lines": 118, "newlines": 57, "modlines": 0, "user": "ITSXSB5"}, "text": "/* --------------------- Rexx ------------------------------ *\n *                                                           *\n *         $$$$   A   L      III  DDDD  EEEEE FFFFF          *\n *        $ $    A A  L       I   D   D E     F              *\n *         $$$  A   A L       I   D   D EEEE  FFFF           *\n *          $ $ AAAAA L       I   D   D E     F              *\n *        $$$$  A   A LLLLL  III  DDDD  EEEEE F              *\n *                                                           *\n * This exec macro creates the IDCAMS delete and define      *\n * alias for a list of datasets.  Parm exepected is Catalog  *\n * name, and Optional 'O' for (only DEFINE, and no DELETE    *\n * statements for the alias before re-defining it).          *\n *                                                           *\n * Edit macro reads the currently edited file, each line     *\n * contains the alias and its data set name, creates the     *\n * DELETE and re-defines the alias to point its associated   *\n * data set (unless optional parm 'O' was supplied, in which *\n * case, no DELETE statements get created).                  *\n *                                                           *\n * Example:                                                  *\n *                                                           *\n *    $ALIDEF CATALOG.MASTER.CSYS.VCATCCC                    *\n *       (Both DELETE and DEFINE statements created)         *\n *                                                           *\n *    $ALIDEF CATALOG.MASTER.CSYS.VCATCCC O                  *\n *       (Only DEFINE statements created)                    *\n *                                                           *\n * Control card format:                                      *\n *                                                           *\n *    alias_name True_dataset_name                           *\n *                                                           *\n * Chg - 09/27/2018 - VNV - Created first time               *\n *                                                           *\n * --------------------------------------------------------- */\n\nparse source . . macro_Name .\n\nif sysvar(SYSISPF) \u00ac=\"ACTIVE\" then do\n   parse source . . exec_Name .\n   say macro_Name \"can only run under ISPF.\"\n   exit\n   end\n\naddress ISPEXEC\n\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (PARMS)\"\nIf rc \u00ac=0 then do\n   zedsmsg = macro_Name \"error\"\n   zedlmsg = macro_Name \"can only be run as an ispf edit macro !!!\"\n   \"SETMSG MSG(ISRZ001)\"\n   exit 12\n   end\n\nUPPER parms\nparse var parms $cat $opt .\n\nif $cat = \"\" | $vol = \"\" then do\n   ZEDSMSG = \"\"\n   ZEDLMSG = \"Catalog_name not specified... Abort.\",\n             \"Syntax required:\" macro_Name \"Catalog_Name xxx.\",\n             \"xxx is Optional, has to be 'O' and only specified when\",\n             \"the DELETE statements do not need to be created.\"\n   'SETMSG MSG(ISRZ001)'\n   exit 12\n   end\n\n\"ISREDIT (STRTLINE) = LINENUM .ZFIRST\"\n\"ISREDIT (ENDLINE)  = LINENUM .ZLAST\"\n\"ISREDIT RESET\"\n\ninData. = \"\"\n\ndo i=strtLine to endLine\n   \"ISREDIT (TEMP) = LINE\" i\n   inData.i = STRIP(temp)\n   end\n\nCount = i-1\n\n\"ISREDIT DELETE NX ALL\"\n\nj=0\ndo i=strtLine to endLine\n   if indata.i = \"\" | SUBSTR(indata.i,1,1) = \"*\" then do\n      count = count-1\n      if SUBSTR(indata.i,1,1) = \"*\" then do\n         j=j+1;out.j  = indata.i\n         end\n      iterate\n      end\n   indata.i = TRANSLATE(indata.i)\n   parse var indata.i $alias $truDsn .\n   if $opt = \"O\" then nop    /* don't create DELETE statements     */\n   else do\n      j=j+1;out.j  = \"                                              \"\n      j=j+1;out.j  = \"  DELETE (\"||STRIP($alias)||\")   ALIAS -      \"\n      j=j+1;out.j  = \"    CATALOG(\"||STRIP($cat)||\")                \"\n      j=j+1;out.j  = \"  IF LASTCC = 8 THEN SET MAXCC = 0            \"\n      end\n   j=j+1;out.j  = \"                                              \"\n   j=j+1;out.j  = \"  DEFINE ALIAS  (NAME(\"||STRIP($alias)\") -   \"\n   j=j+1;out.j  = \"    RELATE(\"||STRIP($trudsn)\")) -            \"\n   j=j+1;out.j  = \"    CATALOG(\"||STRIP($cat)||\")               \"\n   end\n\ndo i=j to 1 by -1\n   tline = out.i\n   \"ISREDIT LINE_AFTER\" 0 \"= (TLINE)\"\n   end\n\nzedsmsg = count \"Datasets found\"\nzedlmsg = count \"Datasets were found in the control cards, and\",\n            \"the appropriate IDCAMS statements were created for\",\n            \"catalog\" $cat\".\"\n\"SETMSG MSG(ISRZ000)\"\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$BLDLIST": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x81'/\\x00\\x95\\x04\\x8f\\x10\\x02\\x000\\x00)\\x00\\x0c[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1981-09-29T00:00:00", "modifydate": "1995-02-17T10:02:00", "lines": 48, "newlines": 41, "modlines": 12, "user": "$VNV"}, "text": "         MACRO\n&LABEL   $BLDLIST &PARML,&PARM,&VL\n.*\n.*-----------------------------------------------------------------\n.*\n.*       $BLDLIST       VINH VU         09/30/81\n.*       BUILDS A PARM LIST FOR REENTRANT CODE\n.* PARMS -\n.*   &PARML - NAME OF AN AREA TO CONTAIN THE PARMLIST.\n.*            SYMBOL OR (REG).\n.*   &PARM  - NAMES OF PARMS. THEIR ADDRESSES ARE PLACED IN PARMLIST.\n.*            SYMBOL OR (REG).\n.*   &VL    - CAUSES LAST PARM ADDRESS TO BE MARKED WITH X'80'.\n.*\n.*       R14 GETS ALTERED\n.*       R1  GETS A(&PARML)\n.*\n.*       CHG - 2/17/95 - $VNV - CHANGE THE 'MVI' TO 'OI' (XA-SUPPORT)\n.*\n.*-----------------------------------------------------------------\n.*\n         LCLA  &SUB,&DISP,&LEN\n         LCLC  &CDISP,&REG\n&SUB     SETA  1\n         AIF   ('&PARML'(1,1) NE '(').NOTREG1\n&LEN     SETA  K'&PARML-2\n&REG     SETC  '&PARML'(2,&LEN)\n&LABEL   LR    1,&REG\n         AGO   .LOOP\n.NOTREG1 ANOP\n&LABEL   LA    1,&PARML\n.LOOP    ANOP\n&CDISP   SETC  '&DISP'\n         AIF   ('&PARM(&SUB)'(1,1) NE '(').NOTREG\n&LEN     SETA  K'&PARM(&SUB)-2\n&REG     SETC  '&PARM(&SUB)'(2,&LEN)\n         ST    &REG,&CDISP.(1)\n         AGO   .INCR\n.NOTREG  ANOP\n         LA    14,&PARM(&SUB)\n         ST    14,&CDISP.(1)\n.INCR    ANOP\n&SUB     SETA  &SUB+1\n&DISP    SETA  &DISP+4\n         AIF   (&SUB LE N'&PARM).LOOP\n         AIF   (T'&VL EQ 'O').CONT\n         OI    &CDISP.(1),X'80'\n.CONT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CAL": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x984\\x9f\\x00\\x99\\x00O\\tH\\x01\\xd5\\x01\\xd2\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-12-15T00:00:00", "modifydate": "1999-01-04T09:48:00", "lines": 469, "newlines": 466, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $CAL     REXX/CLIST      *********************/\n /* $CAL                                                             */\n /*                                                                  */\n /*    This REXX exec will display the whole month calendar.         */\n /*                                                                  */\n /* SYNTAX: $CAL                        (Current Date)               */\n /*         $CAL MM/YYYY                (Specific Month)             */\n /*         $CAL MM/DD/YYYY             (Specific Date)              */\n /*                                                                  */\n /*   Note:  The year is 4-digit year.  If only 2 digits are used,   */\n /*   then that year is used (1900 will not be added to it).         */\n /*                                                                  */\n /********************************************************************/\n\nDrop DISP.\nDISP.Sun = 0\nDISP.Mon = 3\nDISP.Tue = 6\nDISP.Wed = 9\nDISP.Thu = 12\nDISP.Fri = 15\nDISP.Sat = 18\n\nParse Source . . EXEC_NAME .\n\nEXTRA_SPACE = Copies(' ',2)\nCURR_DATE = DATE(S)  /* YYYYMMDD */\nUSA_DATE  = DATE(U)  /* MM/DD/YY   */\n\nParse Arg IN_DATA\nParse Var IN_DATA  P1 '/' P2 '/' P3\nIf P1 \u00ac= '' & P2 = '' & P3 = '' Then Do\n   MM = P1\n   DD = 1\n   YY = Substr(CURR_DATE,1,4)\n   End\nElse If P1 \u00ac= '' & P2 \u00ac= '' & P3 = '' Then Do\n      MM = P1\n      DD = 1\n      YY = P2\n      End\n   Else If IN_DATA  = '' Then Do\n         MM = Substr(USA_DATE,1,2)\n         DD = Substr(USA_DATE,4,2)\n         YY = Substr(CURR_DATE,1,4)\n         End\n        Else Do\n         MM = P1\n         DD = P2\n         YY = P3\n         End\n\n\nIf Datatype(DD) \u00ac= 'NUM' |,\n   Datatype(MM) \u00ac= 'NUM' |,\n   Datatype(YY) \u00ac= 'NUM' |,\n   DD < 1                |,\n   DD > 31               |,\n   MM < 1                |,\n   MM > 12               |,\n   YY < 1                |,\n   YY > 9998             Then  Do\n      ZEDLMSG = 'Invalid date as' MM||'/'||DD||'/'||YY\n      Call ERR_DISP\n      Exit\n      End\nElse Do\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(YY) Then MO.2 = 29\n   MM = Strip(MM,L,'0')\n   If DD > MO.MM Then Do\n      ZEDLMSG = 'Invalid number of days in non-leap year'\n      Call ERR_DISP\n      Exit\n      End\n   End\n\nDD = Right(DD,2,'0')\nMM = Right(MM,2,'0')\nYY = Right(YY,4,'0')\n\nMY_TODAY = DD\n\nTEXT_LINE. = ''\nHEAD1 = ''\nHEAD2 = ''\nHM1   = ''\nHM2   = ''\n\nIf MM = 1 Then Do\n   MM = 12\n   YY = Right(YY-1,4,'0')\n   End\nElse MM = Right(MM-1,2,'0')\n\nR_D =  $DATE('J2R',$DATE('G2J',MM||'/1/'||YY))\nSTRT_DAY = $DATE('R2D',R_D)\nBEG_DISP = Value(DISP.STRT_DAY)\n\nCall BUILD_IT MM,YY\nCall SPACE_OUT\n\n\nIf MM = 12 Then Do\n   MM = 01\n   YY = Right(YY+1,4,'0')\n   End\nElse MM = Right(MM+1,2,'0')\n\nR_D =  $DATE('J2R',$DATE('G2J',MM||'/1/'||YY))\nSTRT_DAY = $DATE('R2D',R_D)\nBEG_DISP = Value(DISP.STRT_DAY)\n\nMARKED_LINE = 0\nMARKED_DISP = 0\n\nMYJUL = Strip($DATE('G2J',MM||'/'||DD||'/'||YY))\nMYJUL = Substr(MYJUL,1,4)||'.'||Substr(MYJUL,5,3)\n\nCall BUILD_IT MM,YY,MY_TODAY   /* This is current month */\nCall SPACE_OUT\n\n\nIf MM = 12 Then Do\n   MM = 01\n   YY = Right(YY+1,4,'0')\n   End\nElse MM = Right(MM+1,2,'0')\n\nR_D =  $DATE('J2R',$DATE('G2J',MM||'/1/'||YY))\nSTRT_DAY = $DATE('R2D',R_D)\nBEG_DISP = Value(DISP.STRT_DAY)\n\nCall BUILD_IT MM,YY\nLINE1 = Substr(TEXT_LINE.1,1,68)\nLINE2 = Substr(TEXT_LINE.2,1,68)\nLINE3 = Substr(TEXT_LINE.3,1,68)\nLINE4 = Substr(TEXT_LINE.4,1,68)\nLINE5 = Substr(TEXT_LINE.5,1,68)\nLINE6 = Substr(TEXT_LINE.6,1,68)\nMASK1 = Copies('06'x,68)   /* Use } to hilite */\nMASK2 = Copies('06'x,68)\nMASK3 = Copies('06'x,68)\nMASK4 = Copies('06'x,68)\nMASK5 = Copies('06'x,68)\nMASK6 = Copies('06'x,68)\nHM1   = Copies('!',Length(HEAD1))\nTEMP  = \"Overlay(' }}',MASK\"||MARKED_LINE||\",\"||MARKED_DISP+1||\")\"\nTEMP  = \"MASK\"||MARKED_LINE||\" = \"||TEMP\nInterpret TEMP\nAddress ISPEXEC\n'ADDPOP COLUMN(2) ROW(1)'\n'DISPLAY PANEL($CALMON)'\nTemprc = RC\n'REMPOP'\nAddress TSO\n\nExit\n\n\n\nERR_DISP:\nZEDSMSG = EXEC_NAME 'Error - Press HELP key'\nAddress ISPEXEC 'SETMSG MSG(ISRZ001)'\nReturn\n\n\n\n\nSPACE_OUT:\nDo I=1 To 6\n   TEXT_LINE.I = TEXT_LINE.I||EXTRA_SPACE\n   End\nHEAD1 = HEAD1||EXTRA_SPACE\nHEAD2 = HEAD2||EXTRA_SPACE\nHM1   = HM1||EXTRA_SPACE\nHM2   = HM2||EXTRA_SPACE\nReturn\n\n\nBUILD_IT:\nParse Arg IN_MM,IN_YY,FLAG_TODAY\n\nMO.1  = 31\nMO.2  = 28\nMO.3  = 31\nMO.4  = 30\nMO.5  = 31\nMO.6  = 30\nMO.7  = 31\nMO.8  = 31\nMO.9  = 30\nMO.10 = 31\nMO.11 = 30\nMO.12 = 31\nIf LEAP_YEAR(IN_YY) Then MO.2 = 29\nIN_MM = Strip(IN_MM,L,'0')\nEND_DAY = MO.IN_MM\n\nTEXT_LINE.1 = TEXT_LINE.1||Copies(' ',BEG_DISP)\nLINE# = 1\n\nDo I=1 To END_DAY\n   If BEG_DISP > 18 Then Do\n      LINE# = LINE# + 1\n      BEG_DISP = 0\n      End\n   If FLAG_TODAY = I Then Do\n      MARKED_LINE = LINE#\n      MARKED_DISP = Length(TEXT_LINE.LINE#)\n      End\n   TEXT_LINE.LINE# = TEXT_LINE.LINE#||' '||Right(I,2)\n   BEG_DISP = BEG_DISP + 3\n   End\nTEXT_LINE.4 = Substr(TEXT_LINE.4,1,Length(TEXT_LINE.1))\nTEXT_LINE.5 = Substr(TEXT_LINE.5,1,Length(TEXT_LINE.1))\nTEXT_LINE.6 = Substr(TEXT_LINE.6,1,Length(TEXT_LINE.1))\nHEAD1 = HEAD1||' '||Center((MONTH_NAME(MM)||' '||YY),20)\nHEAD2 = HEAD2||' Su Mo Tu We Th Fr Sa'\nHM2   =   HM2||' {{ ## ## ## ## ## {{'\nReturn\n\n\nMONTH_NAME: Procedure\n\nMONTH.1  = 'Jan'\nMONTH.2  = 'Feb'\nMONTH.3  = 'Mar'\nMONTH.4  = 'Apr'\nMONTH.5  = 'May'\nMONTH.6  = 'Jun'\nMONTH.7  = 'Jul'\nMONTH.8  = 'Aug'\nMONTH.9  = 'Sep'\nMONTH.10 = 'Oct'\nMONTH.11 = 'Nov'\nMONTH.12 = 'Dec'\nParse Upper Arg IN_MONTH\nIN_MONTH = Strip(IN_MONTH,L,'0')\nReturn MONTH.IN_MONTH\n\n\n/*                                 REXX                             */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This REXX exec will do date conversion:                     */\n/*                                                                  */\n/*      Call Format:  DATE = $DATE(CODE,INPUT)                      */\n/*                                                                  */\n/*          CODE = 'J2G' - Julian to Gregorian date                 */\n/*          CODE = 'G2J' - Gregorian date to Julian                 */\n/*          CODE = 'J2R' - Julian to Relative date                  */\n/*          CODE = 'R2J' - Relative to Julian date                  */\n/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */\n/*                                                                  */\n/*          INPUT = either 'MM/DD/YYYY' or 'YYYYDDD' or 'nnnn'      */\n/*                                                                  */\n/*      Errors during processing will return 0 as result and        */\n/*      an error message will be displayed as well.                 */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n$DATE: Procedure\n\nParse Upper Arg FUNC,DATE\n\nIf DATE = '' Then RET_DATE = 0\nElse Select\n      When FUNC = 'J2G' Then RET_DATE = J2G_PROC(DATE)\n      When FUNC = 'G2J' Then RET_DATE = G2J_PROC(DATE)\n      When FUNC = 'J2R' Then RET_DATE = J2R_PROC(DATE)\n      When FUNC = 'R2J' Then RET_DATE = R2J_PROC(DATE)\n      When FUNC = 'R2D' Then RET_DATE = R2D_PROC(DATE)\n      Otherwise Do\n         Say 'DT999E - Invalid function code as' FUNC\n         RET_DATE = 0\n         End\n   End\n\nReturn RET_DATE\n\n\n\nJ2G_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 0 Then G_DATE = 0\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(JULIAN_YYYY) Then MO.2 = 29\n   Do I=1 to 12 While JULIAN_DDD > MO.I\n      JULIAN_DDD = JULIAN_DDD - MO.I\n      End\n   MM   = Right(I,2,'0')\n   DD   = Right(JULIAN_DDD,2,'0')\n   G_DATE = MM||'/'||DD||'/'||JULIAN_YYYY\n   End\n\nReturn G_DATE\n\n\nG2J_PROC: Procedure\n\nParse Arg GEO_DATE\nParse Var GEO_DATE MM '/' DD '/' YYYY\nJ_DATE = 0\n\nIf Datatype(MM)   \u00ac= 'NUM' | ,\n   Datatype(DD)   \u00ac= 'NUM' | ,\n   Datatype(YYYY) \u00ac= 'NUM' | ,\n   DD > 31                 | ,\n   MM < 1                  | ,\n   MM > 12                 | ,\n   YYYY > 9999          Then ,\n      Say 'DT001E - Invalid Gregorian date as' GEO_DATE\nElse Do\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(YYYY) Then MO.2 = 29\n   MM = Strip(MM,'L','0')\n   If (DD > Value(MO.MM)) Then ,\n       Say 'DT002E - Out-of-range date as' GEO_DATE\n   Else Do\n      J_ACCUM_DAY = 0\n      If MM > 1 Then Do I=1 to (MM-1)\n         J_ACCUM_DAY = J_ACCUM_DAY + MO.I\n         End\n      J_ACCUM_DAY = J_ACCUM_DAY + DD\n      J_DATE      = YYYY||Right(J_ACCUM_DAY,3,'0')\n      End\n   End\n\nReturn J_DATE\n\n\n\n\nJ2R_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 1 Then R_DATE = ((JULIAN_YYYY-1) * 365) + ,\n                            ((JULIAN_YYYY-1) % 4) - ,\n                            ((JULIAN_YYYY-1) % 100) + ,\n                            ((JULIAN_YYYY-1) % 400) + (JULIAN_DDD)\n   Else R_DATE = 0\nReturn R_DATE\n\n\n\nR2J_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_J = 0\n\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      TEMP_YYYY = (REL_DATE % 366) + 1\n      TEMP_REL = J2R_PROC(Right(TEMP_YYYY,4,'0')||'000')\n      Do While (REL_DATE - TEMP_REL) > 0\n         If LEAP_YEAR(TEMP_YYYY) Then LEFT_OVER = 366\n         Else LEFT_OVER = 365\n         If LEFT_OVER < (REL_DATE - TEMP_REL) Then Do\n            TEMP_REL  = TEMP_REL  + LEFT_OVER\n            TEMP_YYYY = TEMP_YYYY + 1\n            End\n         Else Do\n            TEMP_DDD = (REL_DATE - TEMP_REL)\n            Leave\n            End\n         End\n      RETURNED_J =  Right(TEMP_YYYY,4,'0')||Right(TEMP_DDD,3,'0')\n   End\nEnd\n\nReturn RETURNED_J\n\n\nR2D_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_DAY = 0\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      DAY_INDEX = (REL_DATE // 7)+1\n      RETURNED_DAY  = Word('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)\n   End\nEnd\n\nReturn RETURNED_DAY\n\n\n\n\n\nVALIDATE_JULIAN:\n\nVALID_DATE = 0\n\nIf Length(JUL_DATE) \u00ac=7 | Datatype(JUL_DATE) \u00ac= 'NUM' Then\n   Say 'DT003E - Date too short/long or non-numeric as' JUL_DATE\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   If (JULIAN_DDD > 366) Then ,\n      Say 'DT004E - Number of day > 366 as' JULIAN_DDD\n   Else If (LEAP_YEAR(JULIAN_YYYY) = 0) & (JULIAN_DDD = 366) Then ,\n          Say 'DT005E - Invalid days for a non-leap year as' JULIAN_YYYY\n        Else If (JULIAN_YYYY < 1) Then ,\n           Say 'DT008E - Invalid year as' JULIAN_YYYY\n           Else VALID_DATE = 1\n   End\nReturn VALID_DATE\n\n\n\nLEAP_YEAR: Procedure\nParse Arg YEAR_CHECKED\n\nIf (YEAR_CHECKED // 100) = 0 Then ,\n   If (YEAR_CHECKED // 400) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\nElse If (YEAR_CHECKED // 4) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\n\nReturn LEAP_YEAR_FLAG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CALMON": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x984\\x9f\\x00\\x984\\x9f\\x08E\\x00\"\\x00\"\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-12-15T00:00:00", "modifydate": "1998-12-15T08:45:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "NMVV1"}, "text": ")ATTR\n \\ AREA(DYNAMIC)\n { TYPE(CHAR)  CAPS(OFF)  HILITE(USCORE)  COLOR(WHITE)\n ~ TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(BLUE)\n # TYPE(CHAR)  CAPS(OFF)  HILITE(USCORE)  COLOR(GREEN)\n _ TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)\n ! TYPE(CHAR)  CAPS(OFF)                  COLOR(YELLOW)\n } TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(PINK)\n06 TYPE(CHAR)  CAPS(OFF)                  COLOR(TURQ)\n % TYPE(TEXT)  CAPS(OFF)                  COLOR(TURQ)\n + TYPE(TEXT)  CAPS(OFF)                  COLOR(WHITE)\n \u00a6 TYPE(TEXT)  CAPS(OFF)                  COLOR(GREEN)\n03 TYPE(TEXT)  CAPS(OFF)                  COLOR(BLUE)\n04 TYPE(TEXT)  CAPS(OFF)                  COLOR(GREEN)\n05 TYPE(TEXT)  CAPS(OFF)  HILITE(REVERSE) COLOR(TURQ)\n @ TYPE(OUTPUT) JUST(RIGHT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ)\n \u00ac TYPE(OUTPUT) JUST(RIGHT) INTENS(LOW) CAPS(OFF)  COLOR(GREEN)\n \" TYPE(OUTPUT) JUST(ASIS)  HILITE(REVERSE)        COLOR(GREEN)\n01 TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE)        COLOR(RED)\n02 TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE)        COLOR(BLUE)\n11 TYPE(OUTPUT) JUST(RIGHT) INTENS(LOW) CAPS(OFF)  COLOR(WHITE)\n)BODY WINDOW(70,12) EXPAND(``)\n%`-`\tPop-Up Calendar%`-`\n\u00a6` `@MYJUL   \u00a6` `\n\u00a6\\HEAD1,HM1                                                        \\\n\u00a6\\HEAD2,HM2                                                        \\\n\u00a6\n\u00a6\\LINE1,MASK1                                                      \\\n\u00a6\\LINE2,MASK2                                                      \\\n\u00a6\\LINE3,MASK3                                                      \\\n\u00a6\\LINE4,MASK4                                                      \\\n\u00a6\\LINE5,MASK5                                                      \\\n\u00a6\\LINE6,MASK6                                                      \\\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CATDEF": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00F\\x01\\x18&\\x9f\\x01\\x18)\\x9f\\x12(\\x00s\\x009\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2018-09-26T00:00:00", "modifydate": "2018-10-26T12:28:46", "lines": 115, "newlines": 57, "modlines": 0, "user": "ITSXSB5"}, "text": "/* --------------------- Rexx ------------------------------ *\n *                                                           *\n *         $$$$  CCCC   A   TTTTT DDDD  EEEEE FFFFF          *\n *        $ $   C      A A    T   D   D E     F              *\n *         $$$  C     A   A   T   D   D EEEE  FFFF           *\n *          $ $ C     AAAAA   T   D   D E     F              *\n *        $$$$   CCCC A   A   T   DDDD  EEEEE F              *\n *                                                           *\n * This exec macro creates the IDCAMS delete and define      *\n * stmts for a list of datasets.  Parm exepected is Catalog  *\n * name, volser and Optional 'O' for (only DEFINE, and no    *\n * DELETE statements).                                       *\n *                                                           *\n * Edit macro reads the currently edited file, each line     *\n * contains a Data set name, and generates the statements    *\n * to DELETE and DEFINE the data set specifying catalog name *\n * and Volume (supplied as part of the input parm). Of course*\n * if 'O' was specified, then Only 'DEFINE' statements will  *\n * get created.                                              *\n *                                                           *\n * Example:                                                  *\n *                                                           *\n *    $CATDEF CATALOG.MASTER.CSYS.VCATCCC &SYSR6             *\n *       (Both DELETE and DEFINE statements created)         *\n *                                                           *\n *    $CATDEF CATALOG.MASTER.CSYS.VCATCCC &SYSR6 O           *\n *       (Only DEFINE statements created)                    *\n *                                                           *\n * Chg - 09/26/2018 - VNV - Created first time               *\n *                                                           *\n * --------------------------------------------------------- */\n\nparse source . . macro_Name .\n\nif sysvar(SYSISPF) \u00ac=\"ACTIVE\" then do\n   parse source . . exec_Name .\n   say macro_Name \"can only run under ISPF.\"\n   exit\n   end\n\naddress ISPEXEC\n\n\"CONTROL ERRORS RETURN\"\n\"ISREDIT MACRO (PARMS)\"\nIf rc \u00ac=0 then do\n   zedsmsg = macro_Name \"error\"\n   zedlmsg = macro_Name \"can only be run as an ispf edit macro !!!\"\n   \"SETMSG MSG(ISRZ001)\"\n   exit 12\n   end\n\nUPPER parms\nparse var parms $cat $vol $opt .\n\nif $cat = \"\" | $vol = \"\" then do\n   ZEDSMSG = \"\"\n   ZEDLMSG = \"Catalog_name and/or Volume not specified... Abort.\",\n             \"Syntax required:\" macro_Name \"Catalog_Name Volume xxx.\",\n             \"xxx is Optional, has to be 'O' and only specified when\",\n             \"the DELETE statements do not need to be created.\"\n   'SETMSG MSG(ISRZ001)'\n   exit 12\n   end\n\n\"ISREDIT (STRTLINE) = LINENUM .ZFIRST\"\n\"ISREDIT (ENDLINE)  = LINENUM .ZLAST\"\n\"ISREDIT RESET\"\n\ninData. = \"\"\n\ndo i=strtLine to endLine\n   \"ISREDIT (TEMP) = LINE\" i\n   inData.i = STRIP(temp)\n   end\n\nCount = i-1\n\n\"ISREDIT DELETE NX ALL\"\n\nj=0\ndo i=strtLine to endLine\n   if indata.i = \"\" | SUBSTR(indata.i,1,1) = \"*\" then do\n      count = count-1\n      if SUBSTR(indata.i,1,1) = \"*\" then do\n         j=j+1;out.j  = indata.i\n         end\n      iterate\n      end\n   indata.i = TRANSLATE(indata.i)\n   if $opt = \"O\" then nop    /* don't create DELETE statements     */\n   else do\n      j=j+1;out.j  = \"                                              \"\n      j=j+1;out.j  = \"  DELETE (\"||LEFT(indata.i,44)||\") -          \"\n      j=j+1;out.j  = \"    NONVSAM NOSCRATCH -                       \"\n      j=j+1;out.j  = \"    CAT(\"||STRIP($cat)||\")                    \"\n      j=j+1;out.j  = \"  IF LASTCC = 8 THEN SET MAXCC = 0            \"\n      end\n   j=j+1;out.j  = \"                                              \"\n   j=j+1;out.j  = \"  DEFINE NVSAM(NAME(\"||LEFT(indata.i,44)\") -  \"\n   j=j+1;out.j  = \"    DEVT(00000000) VOL(\"||STRIP($vol)||\"))  - \"\n   j=j+1;out.j  = \"    CAT(\"||STRIP($cat)||\")                    \"\n   end\n\ndo i=j to 1 by -1\n   tline = out.i\n   \"ISREDIT LINE_AFTER\" 0 \"= (TLINE)\"\n   end\n\nzedsmsg = count \"Datasets found\"\nzedlmsg = count \"Datasets were found in the control cards, and\",\n            \"the appropriate IDCAMS statements were created for\",\n            \"catalog\" $cat \"on volume\" $vol\".\"\n\"SETMSG MSG(ISRZ000)\"\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CKOUT": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x96&\\x9f\\x00\\x97\\x04\\x1f\\x15\\x01\\x00\\x99\\x003\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1996-09-25T00:00:00", "modifydate": "1997-02-10T15:01:00", "lines": 153, "newlines": 51, "modlines": 0, "user": "$VNV"}, "text": "/*                                 REXX                             */\n\nNumeric Digits 256\n\nCVT     = Get_Stor('10'x)\nASCB    = Get_Stor(0,'224'x)\nLDA     = Get_Stor(ASCB,'30'x)\nGDA     = Get_Stor(CVT,'230'x)\n\nJN1     = Get_Stor(ASCB,'AC'x)\nJN2     = Get_Stor(ASCB,'B0'x)\n\nIf C2D(JN1) = 0 Then Do\n   If C2D(JN2) = 0 Then Do\n      JOBNAME = '**Init**'\n      End\n   Else Do\n      JOBNAME = Get_Stor(JN2,0,8)\n      End\n   End\nElse Do\n   JOBNAME = Get_Stor(JN1,0,8)\n   End\n\nTCB     = Get_Stor(0,'21C'x)\nJSCB    = Get_Stor(TCB,'B5'x,3)\nSSIB    = Get_Stor(JSCB,'13C'x)\nJOBID   = Get_Stor(SSIB,'C'x,8)\nTCT     = Get_Stor(TCB,'A4'x)\nSTEPNAME= Get_Stor(TCT,'C8'x,8)\nLCT     = Get_Stor(TCT,'98'x)\nOUCB    = Get_Stor(ASCB,'90'x)\nOUXB    = Get_Stor(ASCB,'94'x)\n\nJCT     = Get_Stor(LCT,'10'x)\nJCTX    = Get_Stor(LCT,'188'x)\nSCT     = Get_Stor(LCT,'14'x)\nCSCB    = Get_Stor(LCT,'0'x)\nJMR     = Get_Stor(LCT,'144'x)\n\nSTEPTIME= Get_Stor(LCT,'55'x,3)\n\nJOBTIME = Get_Stor(JCTX,'3C'x)\nJCLS    = Get_Stor(JCTX,'38'x)\nJCLNUM  = Get_Stor(JCTX,'34'x)\nREGSIZE = Get_Stor(JCTX,'19'x,3)\n\nREQREG  = Get_Stor(LDA,'CC'x)\n\nREGLIM  = Get_Stor(LDA,C2d('D0'x))\nREGHI   = Get_Stor(LDA,'D4'x)\nREGALIM = Get_Stor(LDA,'D8'x)\nREGAHI  = Get_Stor(LDA,'DC'x)\n\nMSGCLASS = Get_Stor(JCT,'6'x,1)\nXEQCLASS = Get_Stor(JCT,'1F'x,1)\nDPRTY    = Get_Stor(ASCB,'2B'x,1)\nPROGRAM  = Get_Stor(SCT,'6C'x,8)\nUSERID   = Get_Stor(JCT,'A0'x,7)\nORGPGN   = Get_Stor(OUCB,'B6'x,2)\nRESETPGN = Get_Stor(OUCB,'B4'x,2)\nDOMAIN   = Get_Stor(OUCB,'28'x,1)\nSYSID    = Get_Stor(CVT,'154'x,8)\nSTEPNUM  = Get_Stor(JSCB,'E4'x,1)\n\nCSASIZE  = Get_Stor(GDA,'70'x)\nCSAESIZE = Get_Stor(GDA,'80'x)\nSQASIZE  = Get_Stor(GDA,'94'x)\nSQAESIZE = Get_Stor(GDA,'9C'x)\nPRVSIZE  = Get_Stor(GDA,'A4'x)\nPRVESIZE = Get_Stor(GDA,'AC'x)\n\nSay '----- JOBSTAT FOR' Strip(JOBNAME)||'.'||Strip(STEPNAME),\n    '-' JOBID '-' Strip(SYSID) '-' Date(U)'-'Time() '-----'\nSay\nSay 'Job Name =' JOBNAME\nSay 'Job Time Limit in secs  =' C2D(JOBTIME)/100\nSay 'Job Region size =' C2D(REGSIZE)||'K'\nSay 'Job MsgClass =' MSGCLASS\nSay 'Job RunClass =' XEQCLASS\nSay 'Job USERID =' USERID\nSay 'Job Domain =' C2D(DOMAIN)\nSay 'Job Specified Performance Group =' C2D(ORGPGN)\nSay 'Job Reset Performance Group =' C2D(RESETPGN)\nSay 'Number of JCL Stmts in this job =' C2D(JCLS)\nSay\nSay 'Region requested size =' C2D(REQREG)/1024||'K'\nSay 'Region limit below 16M line =' C2D(REGLIM)/1024||'K',\n    '  (Total any combination of GETMAINs)'\nSay 'Region size below 16M line =' C2D(REGHI)/1024||'K',\n    '  (Variable-length GETMAINs)'\nSay 'Region limit above 16M line =' C2D(REGALIM)/1024||'K',\n    '  (Total any combination of GETMAINs)'\nSay 'Region size above 16M line =' C2D(REGAHI)/1024||'K',\n    '  (Variable-length GETMAINs)'\n\nSay\nSay 'Step Name =' STEPNAME\nSay 'Step Time Limit in secs =' C2D(STEPTIME)/100\nSay 'Step Program Name =' PROGRAM\nSay 'Step Number =' C2D(STEPNUM)\nSay 'Step Dispatching Priority =' C2X(DPRTY)\nSay\nSay '---  CSA Size =' Right(C2D(CSASIZE)/1024,8)||'K'\nSay '--- ECSA Size =' Right(C2D(CSAESIZE)/1024,8)||'K'\nSay '---  SQA Size =' Right(C2D(SQASIZE)/1024,8)||'K'\nSay '--- ESQA Size =' Right(C2D(SQAESIZE)/1024,8)||'K'\nSay '---  PVT Size =' Right(C2D(PRVSIZE)/1024,8)||'K'\nSay '--- EPVT Size =' Right(C2D(PRVESIZE)/1024,8)||'K'\n\n\nExit\n\n\n\n\n\n\nGet_Stor: PROCEDURE\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) Length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nParse Arg AREA,OFFSET,LENG\n\nIf Arg(2,'O') Then OFFSET=0\n\nIf Arg(3,'O') Then LENG=4\n\nIf DataType(AREA) = 'CHAR' Then Do\n   AREA =  C2D(AREA)\n   End\n\nIf DataType(OFFSET) = 'CHAR' Then Do\n   OFFSET =  C2D(OFFSET)\n   End\n\nReturn  Storage((D2X(AREA+OFFSET)),LENG)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CMDPFX": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x963\\x0f\\x00\\x963\\x1f\\x15F\\x01\\x14\\x00\\xe5\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1996-11-25T00:00:00", "modifydate": "1996-11-26T15:46:00", "lines": 276, "newlines": 229, "modlines": 0, "user": "$VNV"}, "text": "$CMDPFX  TITLE '$CMDPFX - TO ASSIGN/DELETE A SYSTEM COMMAND PREFIX'\n         PRINT NOGEN\n$CMDPFX  CSECT\n*\n*-------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*\n*        PURPOSE - TO ADD/DELETE A COMMAND PREFIX FOR A MEMBER OF\n*              THE PARALLEL SYSPLEX.\n*\n*        DATE WRITTEN - 11/25/96\n*\n*        REGISTER USAGE:\n*              R9       - RETURN CODE\n*              R11      - 2ND BASE\n*              R10      - COPY OF R1 (JCL PARM POINTER) & RC\n*              R12      - BASE\n*\n*        RETURN CODES:\n*\n*        ABEND CODES:\n*\n*        REQUIRED JCL :\n*              //         EXEC PGM=$CMDPFX,PARM='',REGION=4M\n*\n*        PROGRAM USAGE:\n*              PARM WILL BE '+PREFIX' OR '-PREFIX'. '+' IS FOR ADDING,\n*              '-' IS FOR DELETING.  IF NO PARM FOUND, THE CVTSNAME IS\n*              TO BE ADDED AS THE PREFIX.\n*\n*-------------------------------------------------------------------\n*\n*-------------------------------------------------------------------\n*\n$CMDPFX  SET   (R12,R11),DSECT=WKAREA,LV=WKLENG\n*\n         L     R10,0(R1)           SAVE PARM ADDRESS\n*\n         MVC   WKNAME,BLANK\n         MVC   WTOTEXT,BLANK\n*\n         LH    R15,0(R10)          GET LENGTH\n         LTR   R15,R15             TEST FOR ZERO\n         BZ    USECVTNM            IF ZERO THEN ASSUME ADDING CVTNAME\n         C     R15,F9              COMPARE AGAINST '9'\n         BH    BADPARM             IF HIGH THEN BADPARM\n         CLI   2(R10),C'+'         ELSE - IS IT 'ADD' ??\n         BE    GOODPARM            YES - THEN SAVE PARM\n         CLI   2(R10),C'-'         ELSE - IS IS 'DELETE' ?\n         BE    GOODPARM            YES - THEN SAVE PARM\n*\nBADPARM  EQU   *\n         MVC   WTOTEXT(L'MSG1),MSG1       SAY 'INVALID PARM'\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS12              AND THEN GET OUT\n*\nUSECVTNM EQU   *\n         L     R1,CVTPTR           OBTAIN CVT ADDRESS\n         USING CVTMAP,R1\n         MVC   WKNAME,CVTSNAME     USE SYSTEM NAME\n         DROP  R1\n         B     ADDPREF             GO TO ADD CVTSNAME AS PREFIX\n*\n*\nGOODPARM EQU   *\n         C     R15,F1              LENG=1 ? (JUST +/- AND NOTHING ELSE)\n         BE    BADPARM             YES - THEN ABORT\n*\n         BCTR  R15,0               BYPASS FIRST BYTE\n         BCTR  R15,0               MINUS 1 FOR EXECUTE INSTRUCTION\n         EX    R15,SAVEPARM        NOW SAVE PARM\n*\n*----------------------------------\n*        I'M READY TO PROCESS THE PARM\n*----------------------------------\n*\nPARMDONE EQU   *\n         CLI   2(R10),C'+'         IS IS 'ADD' ??\n         BE    ADDPREF             YES - THEN DO 'CPF DEFINE'\n*\nDELPREF  EQU   *\n         MVC   WKCPF(MCPFLENG),MCPF\n         CPF   REQUEST=DELETE,     DELETE A PREFIX                     X\n               PREFIX=WKNAME,      PREFIX IS FROM WKNAME               X\n               MF=(E,WKCPF)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    DELISOK\n         C     R15,F8              IS IT 'NOT FOUND'\n         BE    DELNOFND            YES - THEN DISPLAY APPROP MSG\n*\nDELBAD   EQU   *\n         MVC   WTOTEXT(L'MSG4),MSG4       SAY 'DELETE BAD'\n         MVC   WTOTEXT+L'MSG4(L'WKNAME),WKNAME    DISPLAY PARM AS WELL\n*\n         CVD   R15,DWORD\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   WTOTEXT+MSG4R15(4),DWORD+1\n*\n         CVD   R0,DWORD\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   WTOTEXT+MSG4R0(4),DWORD+1\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS12\n*\n*\nDELISOK  EQU   *\n         MVC   WTOTEXT(L'MSG2),MSG2       SAY 'DELETE IS OK'\n         MVC   WTOTEXT+L'MSG2(L'WKNAME),WKNAME    DISPLAY PARM AS WELL\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS0               GET OUT WITH GOOD RC\n*\nDELNOFND EQU   *\n         MVC   WTOTEXT(L'MSG3),MSG3       SAY 'DELETE ERROR'\n         MVC   WTOTEXT+L'MSG3(L'WKNAME),WKNAME    DISPLAY PARM AS WELL\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS4               USE '4' AS RC (NOT FND FOR DELETE)\n*\n*\n*\nADDPREF  EQU   *\n         MVC   WKCPF(MCPFLENG),MCPF\n         CPF   REQUEST=DEFINE,     DEFINE A PREFIX                     X\n               PREFIX=WKNAME,      PREFIX IS FROM WKNAME               X\n               OWNER=OWNER,        OWNER NAME                          X\n               FAILDISP=SYSPURGE,  KEEP UNTIL SYSTEM LEAVES PLEX       X\n               REMOVE=YES,         STRIP PFX BEFORE PROCESSING CMD     X\n               MF=(E,WKCPF)\n         LTR   R15,R15             WAS 'ADD' OK ??\n         BZ    ADDCHK              YES - THEN CHECK R0 ALSO FOR '4'\n         C     R15,F8              IS IT 'DUPLICATE'\n         BE    ADDDUP              YES - THEN DISPLAY APPROP MSG\n*\n*\nADDBAD   EQU   *\n         MVC   WTOTEXT(L'MSG5),MSG5       SAY 'ADD BAD'\n*\n         CVD   R15,DWORD\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   WTOTEXT+MSG5R15(4),DWORD+1\n*\n         CVD   R0,DWORD\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   WTOTEXT+MSG5R0(4),DWORD+1\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS12\n*\n*\nADDCHK   EQU   *\n         LTR   R0,R0               DOES R0 CONTAIN '0' ?\n         BZ    ADDISOK             YES - THEN GOOD ADD\n         MVC   WTOTEXT(L'MSG8),MSG8       SAY 'ADD IS NOT OK'\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS8               USE '8' AS RC\n*\n*\nADDISOK  EQU   *\n         MVC   WTOTEXT(L'MSG6),MSG6       SAY 'ADD IS OK'\n         MVC   WTOTEXT+L'MSG6(L'WKNAME),WKNAME    DISPLAY PARM AS WELL\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS0               GET OUT WITH GOOD RC\n*\nADDDUP   EQU   *\n         MVC   WTOTEXT(L'MSG7),MSG7       SAY 'ADD DUPLICATE'\n         MVC   WTOTEXT+L'MSG7(L'WKNAME),WKNAME    DISPLAY PARM AS WELL\n         BAL   R14,DOWTO           PUT OUT MESSAGE\n         B     RCIS4               USE '4' AS RC (NOT FND FOR DELETE)\n*\n*\n*\nDOWTO    EQU   *\n         ST    R14,#DOWTO          SAVE RETURN ADDRESS\n         MVC   WKWTO,WTOM          GET THE WTO LIST FORM TO WKAREA\n         MVC   WKWTO+4(L'WTOTEXT),WTOTEXT\n         WTO   MF=(E,WKWTO)\n         L     R14,#DOWTO          RELOAD RETURN ADDRESS\n         BR    R14                 BACK TO CALLER\n*\n*\nRCIS0    EQU   *\n         XR    R9,R9               USE 0 AS RETURN CODE\n         B     GETOUT\n*\nRCIS4    EQU   *\n         LA    R9,4\n         B     GETOUT\n*\nRCIS8    EQU   *\n         LA    R9,8\n         B     GETOUT\n*\nRCIS12   EQU   *\n         LA    R9,12\n         B     GETOUT\n*\n*\nGETOUT   EQU   *\n         EXIT  R=R9\n*\n*\nSAVEPARM MVC   WKNAME(0),3(R10)      SAVE PREFIX\n*\n*\n*\n         EJECT\n*\n         LTORG\n*\n*\n*\nMSG1     DC    C'PF0001E - PROGRAM ABORTED - INVALID PARM'\nMSG2     DC    C'PF0002I - CMD PREFIX SUCESSFULLY DELETED AS '\nMSG3     DC    C'PF0003E - DELETED PREFIX NOT FOUND AS '\nMSG4     DC    C'PF0004E - DELETE CPF ERROR - R15=XXXX - R0=XXXX'\nMSG4R15  EQU   33                  OFFSET TO R15 RC\nMSG4R0   EQU   43                  OFFSET TO R0 RC\n*\nMSG5     DC    C'PF0005E - ADD CPF ERROR - R15=XXXX - R0=XXXX'\nMSG5R15  EQU   30                  OFFSET TO R15 RC\nMSG5R0   EQU   40                  OFFSET TO R0 RC\n*\nMSG6     DC    C'PF0006I - CMD PREFIX SUCESSFULLY ADDED AS '\nMSG7     DC    C'PF0007E - DUPLICATE PREFIX BEING ADDED AS '\nMSG8     DC    C'PF0008E - ADD CPF ERROR - SYSTEM IN XCF-LOCAL MODE'\n*\nF1       DC    F'1'\nF8       DC    F'8'\nF9       DC    F'9'\n*\nMCPF     CPF   MF=(L,OWNCPF)\nMCPFLENG EQU   *-MCPF\n*\n*\nWTOM     WTO   '0123456789012345678901234567890123456789012345678901234*\n               5678901234567890123456789',ROUTCDE=2,DESC=4,MF=L\nWTOL     EQU   *-WTOM\n*\n*\n*\nOWNER    DC    CL8'$CMDPFX'\n*\n*\nBLANK    DC    CL80' '\n*\n*\n         EJECT\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\n*\nDWORD    DS    D\n#DOWTO   DS    F                   RETURN ADDRESS FOR 'DOWTO' ROUTINE\n*\n*\n         DS    0F\nWKWTO    DS    CL(WTOL)            WTO LIST FORM\n*\n*\n         CPF   MF=(L,WKCPF)\n*\n*\nWKNAME   DS    CL8                 PREFIX\n*\nWTOTEXT  DS    CL80\n*\nRETCDE   DS    F                   RET CODE\nREASCODE DS    F                   REASON CODE\n*\nWKLENG   EQU   *-WKAREA\n*\n         CVT   DSECT=YES\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CMDPFX#": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x97\\x04_\\x158\\x00\\x10\\x00\\x0c\\x00\\t[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1997-02-14T15:38:00", "lines": 16, "newlines": 12, "modlines": 9, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS($CMDPFX),DISP=SHR        <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n SETCODE AC(1)\n NAME $CMDPFX(R)                                         <== CHANGE\n/*\n//*\n//*--- NOTE: THE SYSLMOD DDNAME SHOULD POINT TO AN APF LIBRARY\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CMDPFX@": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x97\\x04\\x9f\\x10\"\\x00!\\x00\\x0c\\x00 [\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1997-02-18T10:22:00", "lines": 33, "newlines": 12, "modlines": 32, "user": "$VNV"}, "text": "//$VNV5     JOB  (7670,P4A1),VINH,MSGCLASS=Q,CLASS=9,NOTIFY=$VNV\n//*\n/*JOBPARM S=XXXX               <======= CHANGE THIS ================\n//*\n//*--------------------------------------------------------------------\n//*\n//*    PARM USAGE:\n//*        TO ADD A PREFIX, USE '+XX' WHERE XX=PREFIX.\n//*        TO DELETE A PREFIX, USE '-XX' WHERE XX=PREFIX\n//*        IF NO PARM SUPPLIED, THE PROGRAM WILL ADD A NEW PREFIX WHICH\n//*        IS THE SAME AS SYSTEM NAME (CVTSNAME).\n//*\n//*    *** IT IS IMPORTANT THAT THIS JOB IS RUN ON THE CORRECT TARGET\n//*    *** SYSTEM SINCE THE CMD PREFIX BEING ADDED WILL BE ASSOCIATED\n//*    *** WITH THE SYSTEM IT IS RUNNING ON.\n//*    ***\n//*    *** TO VERIFY THAT A COMMAND PREFIX IS ADDED TO THE SYSLEX, THE\n//*    *** FOLLOWING MVS COMMAND CAN BE USED TO DISPLAY ALL ACTIVE\n//*    *** PREFIXES:\n//*    ***\n//*    ***      'D OPDATA,PREFIX'\n//*\n//*--------------------------------------------------------------------\n//*\n//CMDPFX    PROC P=\n//STEP1     EXEC PGM=$CMDPFX,PARM='&P',REGION=4M\n//STEPLIB   DD   DSN=SYS3.TECH.LOAD,DISP=SHR <== CHANGE\n//          PEND\n//*--------------------------------------------------------------------\n//*\n//ADD1      EXEC CMDPFX,P='+ONE'     -- ADD 'ONE' AS CMD PREFIX\n//DEL1      EXEC CMDPFX,P='-ONE'     -- DELETE 'ONE' AS CMD PREFIX\n//ADDSYSID  EXEC CMDPFX              -- ADD SYSNAME AS CMD PREFIX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CPU": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x052\\x7f\\x01 \\x07\\x0f\\x161\\x02\\x00\\x02\\x00\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-23T00:00:00", "modifydate": "2020-03-10T16:31:32", "lines": 512, "newlines": 512, "modlines": 0, "user": "VINHVU"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$D": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x00\\x00\\x96\\x01\\x0f\\x01\\x005o\\x08\\x18\\x05c\\x03b\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "1996-01-10T00:00:00", "modifydate": "2000-12-21T08:18:00", "lines": 1379, "newlines": 866, "modlines": 0, "user": "NMVV1"}, "text": "/*                                 REXX                             */\n/*                                                                  */\n/*      This REXX exec will display different MVS control blocks    */\n/*                                                                  */\n/*      Note:  The HELP Text itself is part of this EXEC.           */\n/*      It begins after '/*BEGHELP ... */' and ends at              */\n/*      '/*ENDHELP ...*/'.  Any invalid parm will cause the         */\n/*      Help text to be displayed.                                  */\n/*                                                                  */\n/*                                                                  */\n/*      Vinh Vu - 5/21/92 - Origrinal codes - V1.0                  */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      6/10/92 - Vinh Vu - V1.1                                    */\n/*              - Access SYSID from CVT, not from SMF (SMFID).      */\n/*              - Pick up CPU model from CVT extenstion, not from   */\n/*                serial number.                                    */\n/*              - Also display DFP level.                           */\n/*                                                                  */\n/*     10/07/93 - Vinh Vu - V1.2                                    */\n/*              - Add display for LPA List.                         */\n/*                                                                  */\n/*     01/10/96 - Vinh Vu - V2.0                                    */\n/*              - Clean up the code                                 */\n/*              - Add display for expanded storage & more stuff     */\n/*              - Add display for Nucleus Map                       */\n/*                                                                  */\n/*     09/06/96 - Vinh Vu - V2.1                                    */\n/*              - Add display for IPL Loadparm                      */\n/*              - Check for Dynamic APF Table                       */\n/*              - Add display for chpids                            */\n/*              - Add 'ALL' to display all                          */\n/*                                                                  */\n/*     05/19/97 - Vinh Vu - V2.2                                    */\n/*              - Add display for CPU version code                  */\n/*                                                                  */\n/*     12/17/97 - Vinh Vu - V2.3                                    */\n/*              - Add *non-slot* for chpids not avail               */\n/*              - Add display for 'MOVEPAGE' & 'COMPRESSION' svc    */\n/*              - Make 'SYSTEM' default if no parm was entered      */\n/*              - Display IPL date in Gregorian dates               */\n/*              - Display System area sizes along with the addr     */\n/*                                                                  */\n/*     02/10/00 - Vinh Vu                                           */\n/*              - Change IPL date for the year 2000.                */\n/*                                                                  */\n/*     12/01/00 - Vinh Vu                                           */\n/*              - Change LLT display to pick up the current link    */\n/*                list set.                                         */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nVERSION = '2.4'\n\nParse Source . . EXEC_NAME .\nParse Version REXX_VERSION\n\nVERSION = EXEC_NAME||' '||VERSION\nVERSION = VERSION||' - '||REXX_VERSION\n\nNumeric Digits 256\n\n/*BEGHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */\n/*                                                                  */\n/*                       HELP Text                                  */\n/*                                                                  */\n/*  Syntax:   $D PARM                                               */\n/*                                                                  */\n/*     PARM will be one of the following:                           */\n/*                                                                  */\n/*      o   APF(LIST) to display the APF libraries                  */\n/*      o   CHP to display all chpids                               */\n/*      o   LINK(LIST) or LLT to display the linklist libraries     */\n/*      o   LPA(LIST) to display the LPA List libraries             */\n/*      o   PAG(ING) to display paging statistics                   */\n/*      o   NUC(MAP) to display Nucleus Map                         */\n/*      o   SS(T) to list all SubSystem names                       */\n/*      o   SVC to display the SVC table                            */\n/*      o   SYS(TEM) to display system information                  */\n/*      o   ALL to execute all above functions                      */\n/*                                                                  */\n/*ENDHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\nParse Upper Arg P1\nCVTADD  = Get_Stor('10'x)\nSMCAADD = Get_Stor(CVTADD,'C4'x)               /* SMCA pointer      */\nSMFID   = Get_Stor(SMCAADD,'10'x)              /* Get System SMF ID */\n\nSYSID   = Strip(Get_Stor(CVTADD,'154'x,8))\n\n/*                                                                  */\n/*                                                                  */\n\nSay '<'VERSION'>'\n\nSelect\n   When P1 = ''                       Then Do\n        Say\n        Say ' ***>'\n        Say \" ***>  To display EXEC syntax, type '\"EXEC_NAME\" ??' <***\"\n        Say ' ***>'\n        Call SYSDISP\n        End\n   When ABBREV('APFLIST',P1,3)        Then Do\n        Call APFDISP\n        End\n   When ABBREV('CHP',P1,3)        Then Do\n        Call CHPDISP\n        End\n   When (ABBREV('LINKLIST',P1,4)     |,\n         ABBREV('LLT',P1,3))          Then Do\n        Call LLTDISP\n        End\n   When ABBREV('LPALIST',P1,3)        Then Do\n        Call LPADISP\n        End\n   When ABBREV('NUCMAP',P1,3)         Then Do\n        Call NUCDISP\n        End\n   When ABBREV('PAGING',P1,3)        |,\n        ABBREV('PAGE',P1,3)           Then Do\n        Call PAGDISP\n        End\n   When ABBREV('SST',P1,2)            Then Do\n        Call SSTDISP\n        End\n   When ABBREV('SVC',P1,3)            Then Do\n        Call SVCDISP\n        End\n   When ABBREV('SYSTEM',P1,3)         Then Do\n        Call SYSDISP\n        End\n   When ABBREV('ALL',P1,3)            Then Do\n        Call APFDISP\n        Call CHPDISP\n        Call LLTDISP\n        Call LPADISP\n        Call NUCDISP\n        Call PAGDISP\n        Call SSTDISP\n        Call SVCDISP\n        Call SYSDISP\n        End\n   Otherwise Do\n        LASTLINE = SourceLine()\n        I = 1\n        Do Until Substr(SourceLine(I),1,9) = '/*BEGHELP'\n           I = I+1\n           End\n        I = I + 1                              /* Skip BEGHELP line */\n        If I = LASTLINE Then Exit              /* In case ......... */\n        Do Until Substr(SourceLine(I),1,9) = '/*ENDHELP'\n           Say Left(SourceLine(I),72)\n           I = I+1\n           End\n        Exit\n        End\n   End\nExit\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY APFLIST                                             */\n/*                                                                  */\n/*                                                                  */\n/*      APF = CVT+x'1E4' = Pointer to the APFList                   */\n/*      APF = '7FFFF001'x if APF format is Dynamic                  */\n/*      COUNT will be how many DSN's in APFList                     */\n/*                                                                  */\n\nAPFDISP:\nAPFADD  = Get_Stor(CVTADD,'1E4'x)\nCOUNT   = C2D(Get_Stor(APFADD,,2))\nDSNDEC  = C2D(APFADD)+2                        /* Ptr to Dsn (dec)  */\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\n\nSay\nSay '         --- APFList For' SYSID '---'\nSay\n\nIf APFADD = '7FFFF001'x Then Do\n   Say '     *-*-* APF Format is Dynamic - No data displayed *-*-* '\n   Say\n   Return\n   End\nDO I=1 to COUNT\n   DSNLENG = C2D(Get_Stor(DSNDEC,,1))-6       /* DSname leng   */\n   DSNDEC = DSNDEC+1                           /* Go past length    */\n   VOLSER = Get_Stor(DSNDEC,,6)\n   DSNDEC = DSNDEC+6                           /* Go past VOLSER    */\n   DSNAME = Get_Stor(DSNDEC,,DSNLENG)\n   DSNDEC = DSNDEC+DSNLENG                     /* Go to next entry  */\n   DSNAME = Left(DSNAME,44)\n   Say Format(I,3,0) ' ' VOLSER ' ' DSNAME\n   End\n\nReturn\n/*------------------------------------------------------------------*/\n\n\n/*                                                                  */\n/*      DISPLAY CHPIDS                                              */\n/*                                                                  */\n/*                                                                  */\n/*      CHPTAB = CVT+x'4D0' = Pointer to the chpid table            */\n/*                                                                  */\n\nCHPDISP:\nCHPTAB  = Get_Stor(CVTADD,'4D0'x)\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\n\nSay\nSay '         --- CHPList For' SYSID '---'\nSay\nUSECHP = 0\nAVAILCHP = 0\nSay ' CHP      Status'\nSay ' ---     ' Copies('-',20)\nSay\nDo I=0 to 255\n   CHPID = Get_Stor(CHPTAB,I,1)\n   If CHPID = 'E0'x Then Do\n      Say Right(D2X(I),4) '    ' 'InUse'\n      USECHP = USECHP + 1\n      End\n   Else If CHPID = '80'x Then Do\n         Say Right(D2X(I),4) '    ' Right('Avail',20)\n         AVAILCHP = AVAILCHP + 1\n         End\n        Else Do\n         Say Right(D2X(I),4) '    ' Right('*Non-slot*',15)\n         End\n   End\n\nSay\nSay 'Total Number of InUse Chpids:' USECHP\nSay 'Total Number of Avail/NotUsed Chpids:' AVAILCHP\nSay\nSay 'Total Number of Avail Chpids:' USECHP+AVAILCHP\nSay\nReturn\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY LINKLIST                                            */\n/*                                                                  */\n/*      LLT = CVT+x'4DC'(1244) = Pointer to Linklist Table          */\n/*      COUNT will be how many DSN's in Linklist                    */\n/*                                                                  */\n\nLLTDISP:\nECVT    = Get_Stor(CVTADD,'8C'x)               /* Get Extended CVT  */\nDLCB    = Get_Stor(ECVT,'88'x)                 /* Get DLCB          */\nLLTADD  = Get_Stor(DLCB,'10'x)                 /* Get Current LLT   */\nLLTSET  = Get_Stor(DLCB,'24'x,16)\n\n    /* LLTADD  = Get_Stor(CVTADD,'4DC'x)    --- This is old      */\n\nCOUNT   = C2D(Get_Stor(LLTADD,'4'x))\nLLTDEC  = C2D(LLTADD)+9                        /* Ptr to Dsn (dec)  */\nAPFDEC  = C2D(LLTADD)+8+(45*COUNT)             /* Ptr to Flag (dec) */\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nSay\nSay '        --- LinkList For' SYSID '---'\nSay\nSay '      Current Linklist Set:' LLTSET\nSay\nDO I=1 to COUNT\n   DSNAME=Get_Stor(LLTDEC,,44)\n   LLTDEC = LLTDEC + 45\n   APFFLAG=Get_Stor(APFDEC,,1)\n   If Bitand(APFFLAG,'80'x) = '80'x Then\n      APFMSG = '- APF Lib - '\n   Else\n      APFMSG = '            '\n   APFDEC = APFDEC + 1\n   Say Format(I,3,0) ' ' APFMSG DSNAME\n   End\n\nReturn\n\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY LPA Libraries List                                  */\n/*                                                                  */\n/*      CVTEXT  = CVT+x'4AC' = CVT extension                        */\n/*      LPALST  = CVTEXT+x'38' = LPA Libraries List                 */\n/*                                                                  */\n\nLPADISP:\n\nCVTEADD  = Get_Stor(CVTADD,'4AC'x)\nLPALADD  = Get_Stor(CVTEADD,'38'x)\nCOUNT    = C2D(Get_Stor(LPALADD,'4'x))\nDSNDEC   = C2D(LPALADD)+8                       /* Ptr to Dsn (dec)  */\n\n\n/*                                                                  */\n/*                                                                  */\n\nSay\nSay '         --- LPAList For' SYSID '---'\nSay\n\nDO I=1 to COUNT\n   DSNAME = Get_Stor(DSNDEC,'1'x,44)\n   DSNDEC = DSNDEC+45                          /* Go to next entry  */\n   DSNAME = Left(DSNAME,44)\n   Say Format(I,3,0) ' ' DSNAME\n   End\n\nReturn\n\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY NUCLEUS Map                                         */\n/*                                                                  */\n/*      NUCMAP  = CVT+x'4B0'                                        */\n/*                                                                  */\n\nNUCDISP:\n\nNUCADD   = C2D(Get_Stor(CVTADD,'4B0'x))\nNUCLENG  = C2D(Get_Stor(NUCADD,12))\nNUCEND   = NUCADD+NUCLENG\n\nSay\nSay ' ------- NUCLEUS Map Display for' SYSID '-------'\nSay\nSay '    MODNAME    ADDR    SIZE  CSECT RSECT'\nSay\n\nNUCADD = NUCADD+16\n\nDo While (NUCADD < NUCEND)\n   NUCNAME = Get_Stor(NUCADD,,8)\n   NUCADDR = C2X(Get_Stor(NUCADD,8))\n   NUCSIZE = C2X(Get_Stor(NUCADD,13,3))\n   NUCFLAG = Get_Stor(NUCADD,12,1)\n   If Bitand(NUCFLAG,'10'x) = '10'x Then NUCMSECT = 'CSECT'\n      Else NUCMSECT = '     '\n   If Bitand(NUCFLAG,'08'x) = '08'x Then NUCMRSEC = 'RSECT'\n      Else NUCMRSEC = '     '\n   NUCADD = NUCADD+16\n   Say '   ' NUCNAME NUCADDR NUCSIZE NUCMSECT NUCMRSEC\n   End\n\nReturn\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      DISPLAY Paging statistics                                   */\n/*                                                                  */\n/*                                                                  */\n/*      ASMVT = CVT + x'2C0'                                        */\n/*                                                                  */\n\nPAGDISP:\nASMADD  = Get_Stor(CVTADD,'2C0'x)\n\nSARTADD = Get_Stor(ASMADD,'4'x)\nPARTADD = Get_Stor(ASMADD,'8'x)\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nFIRSTADD= Get_Stor(PARTADD,52)\nLASTADD = Get_Stor(PARTADD,56)\nLPAADD  = Get_Stor(PARTADD,48)\n\nSay\nSay '             ------- Paging STAT Display for' SYSID '-------'\nSay\nSay '                               Burst         Avail Outst I/O' ,\n    ' Num  Slots'\nSay 'Type Volser Adr Devt Stat  Num Size    Size  Slots  I/O  Err' ,\n    ' Cyls PerCyl'\nSay\n\nENTADD  = LPAADD\nLPALOOP:\nCall PARTDATA\nENTADD  = Get_Stor(ENTADD)\nIf C2D(ENTADD) \u00ac= 0 Then Signal LPALOOP\n\n\nENTADD  = FIRSTADD\nPAGLOOP:\nCall PARTDATA\nIf ENTADD \u00ac= LASTADD Then Do\n   ENTADD  = Get_Stor(ENTADD)\n   Signal PAGLOOP\n   End\n\nReturn\n\nPARTDATA:\nTYPE1   = Get_Stor(ENTADD,'8'x,1)\nTYPE2   = Get_Stor(ENTADD,'9'x,1)\nPATADD  = Get_Stor(ENTADD,32)\nPCTADD  = Get_Stor(ENTADD,36)\nUCBADD  = Get_Stor(ENTADD,44)\n\nSelect\n   When Bitand(TYPE1,'80'x) = '80'x Then Do\n      DSATTYPE = 'LPLA'\n      End\n   When Bitand(TYPE1,'40'x) = '40'x Then Do\n      DSATTYPE = 'COMM'\n      End\n   When Bitand(TYPE1,'20'x) = '20'x Then Do\n      DSATTYPE = 'DUPL'\n      End\n   When Bitand(TYPE1,'10'x) = '10'x Then Do\n      DSATTYPE = 'LOCL'\n      End\n   Otherwise Do\n      DSATTYPE = '    '\n      End\n   End       /* Select */\n\nIf Bitand(TYPE2,'40'x) = '40'x Then BADDSAT = 'BAD'\n   Else BADDSAT = 'Ok '\n\nUCBNUM   = Get_Stor(UCBADD,13,3)\nUCBVOL   = Get_Stor(UCBADD,28,6)\n\nPARTNUM = Right(C2D(Get_Stor(ENTADD,10,2)),3)\nBURSTSZE= Right(C2D(Get_Stor(ENTADD,4,1)),3)\nSIZE    = Right(C2D(Get_Stor(ENTADD,16)),8)\nAVAIL   = Right(C2D(Get_Stor(ENTADD,20)),6)\nOUTSTAND= Right(C2D(Get_Stor(ENTADD,62,2)),4)\nIOERR   = Right(C2D(Get_Stor(ENTADD,24)),3)\n\nCYLNO   = Right(C2D(Get_Stor(PATADD,8,2)),5)\nCYLSIZE = Right(C2D(Get_Stor(PATADD,10,2)),5)\n\nDEVTYPE = Get_Stor(PCTADD,'4'x,6)\n\nSay DSATTYPE UCBVOL UCBNUM DEVTYPE BADDSAT PARTNUM  ,\n    BURSTSZE SIZE AVAIL OUTSTAND IOERR ,\n    CYLNO CYLSIZE\nReturn\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SubSystems                                          */\n/*                                                                  */\n/*                                                                  */\n/*      JESCT = CVT+x'128' = Pointer to the JESCT                   */\n/*      JESCT points to first SSCT which chains to next SSCT        */\n/*                                                                  */\n\nSSTDISP:\nJCTADD  = Get_Stor(CVTADD,'128'x)\nSSCTADD = Get_Stor(JCTADD,24)\n\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nI = 1\nSay\nSay '                       --- SUBSYSTEM List For' SYSID '---'\nSay\n\nSSTLOOP:\nSUBSYS  = Get_Stor(SSCTADD,'8'x)               /* SubSys Name       */\nSSVT    = Get_Stor(SSCTADD,16)                 /* SSVT Address      */\n\nIf C2D(SSVT) = 0 Then\n   SSTMSG = '(Dormant)'\nElse\n   SSTMSG = ''\n\nSay Format(I,3,0) ' ' SUBSYS '    SSCT Address = ' C2X(SSCTADD),\n    '  SSVT Address = ' C2X(SSVT)  SSTMSG\n\nSSCTADD = Get_Stor(SSCTADD,'4'x)               /* Next one in chain */\nI = I+1\nIf C2D(SSCTADD) \u00ac= 0 Then Signal SSTLOOP\nReturn\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SVC Table                                           */\n/*                                                                  */\n/*      CVT -> CVTABEND -> SCVT -> SVCTABLE                         */\n/*                                                                  */\n\nSVCDISP:\nSCVTADD  = Get_Stor(CVTADD,'C8'x)\nSVCADD   = Get_Stor(SCVTADD,'84'x)\n\n/*                                                                  */\n/*                                                                  */\n   SNUM.0   = 'EXCP/XDAP    '\n   SNUM.1 =   'WAIT/WAITR/..'\n   SNUM.2 =   'POST         '\n   SNUM.3 =   'EXIT         '\n   SNUM.4 =   'GETMAIN      '\n   SNUM.5 =   'FREEMAIN     '\n   SNUM.6 =   'LINK/LINKX   '\n   SNUM.7 =   'XCTL/XCTLX   '\n   SNUM.8 =   'LOAD         '\n   SNUM.9 =   'DELETE       '\n   SNUM.10 =  'GET/FREEM R  '\n   SNUM.11 =  'TIME         '\n   SNUM.12 =  'SYNCH/SYNCHX '\n   SNUM.13 =  'ABEND        '\n   SNUM.14 =  'SPIE         '\n   SNUM.15 =  'ERREXCP      '\n   SNUM.16 =  'PURGE        '\n   SNUM.17 =  'RESTORE      '\n   SNUM.18 =  'BLDL/FIND    '\n   SNUM.19 =  'OPEN         '\n   SNUM.20 =  'CLOSE        '\n   SNUM.21 =  'STOW         '\n   SNUM.22 =  'OPEN TYPE J  '\n   SNUM.23 =  'CLOSE TYPE T '\n   SNUM.24 =  'DEVTYPE      '\n   SNUM.25 =  'TRKBAL       '\n   SNUM.26 =  'LOCATE, ETC  '\n   SNUM.27 =  'OBTAIN       '\n   SNUM.28 =  '--Reserved-- '\n   SNUM.29 =  'SCRATCH      '\n   SNUM.30 =  'RENAME       '\n   SNUM.31 =  'FEOV         '\n   SNUM.32 =  'REALLOC      '\n   SNUM.33 =  'IOHALT       '\n   SNUM.34 =  'MGCR/QEDIT   '\n   SNUM.35 =  'WTO/WTOR     '\n   SNUM.36 =  'WTL          '\n   SNUM.37 =  'SEGLD/SEGWT  '\n   SNUM.38 =  '--Reserved-- '\n   SNUM.39 =  'LABEL        '\n   SNUM.40 =  'EXTRACT      '\n   SNUM.41 =  'IDENTIFY     '\n   SNUM.42 =  'ATTACH       '\n   SNUM.43 =  'CIRB         '\n   SNUM.44 =  'CHAP         '\n   SNUM.45 =  'OVLYBRCH     '\n   SNUM.46 =  'TTIMER       '\n   SNUM.47 =  'STIMER       '\n   SNUM.48 =  'DEQ          '\n   SNUM.49 =  '--Reserved-- '\n   SNUM.50 =  '--Reserved-- '\n   SNUM.51 =  'SNAP/SDUMP   '\n   SNUM.52 =  'RESTART      '\n   SNUM.53 =  'RELEX        '\n   SNUM.54 =  'DISABLE      '\n   SNUM.55 =  'EOV          '\n   SNUM.56 =  'ENQ/RESERVE  '\n   SNUM.57 =  'FREEDBUF     '\n   SNUM.58 =  'RELBUF/REQBUF'\n   SNUM.59 =  'OLTEP        '\n   SNUM.60 =  '(E)STAE/STAI '\n   SNUM.61 =  'IKJEGS6A     '\n   SNUM.62 =  'DETACH       '\n   SNUM.63 =  'CHKPT        '\n   SNUM.64 =  'RDJFCB       '\n   SNUM.65 =  '--Reserved-- '\n   SNUM.66 =  'BTAMTEST     '\n   SNUM.67 =  '--Reserved-- '\n   SNUM.68 =  'SYNADAF      '\n   SNUM.69 =  'BSP          '\n   SNUM.70 =  'GSERV        '\n   SNUM.71 =  'ASGNBFR, ETC '\n   SNUM.72 =  '--No MACRO-- '\n   SNUM.73 =  'SPAR         '\n   SNUM.74 =  'DAR          '\n   SNUM.75 =  'DQUEUE       '\n   SNUM.76 =  '--No MACRO-- '\n   SNUM.77 =  '--Reserved-- '\n   SNUM.78 =  'LSPACE       '\n   SNUM.79 =  'STATUS       '\n   SNUM.80 =  '--Reserved-- '\n   SNUM.81 =  'SETPRT       '\n   SNUM.82 =  '--Reserved-- '\n   SNUM.83 =  'SMFWTM       '\n   SNUM.84 =  'GRAPHICS     '\n   SNUM.85 =  'DDRSWAP      '\n   SNUM.86 =  'ATLAS        '\n   SNUM.87 =  'DOM          '\n   SNUM.88 =  '--Reserved-- '\n   SNUM.89 =  '--Reserved-- '\n   SNUM.90 =  '--Reserved-- '\n   SNUM.91 =  'VOLSTAT      '\n   SNUM.92 =  'TCBEXCP      '\n   SNUM.93 =  'TPUT/TGET    '\n   SNUM.94 =  'STCC         '\n   SNUM.95 =  'SYSEVENT     '\n   SNUM.96 =  'STAX         '\n   SNUM.97 =  'IKJEGS9G     '\n   SNUM.98 =  'PROTECT      '\n   SNUM.99 =  'DYNALLOC     '\n   SNUM.100 = 'IKJEFFIB     '\n   SNUM.101 = 'QTIP         '\n   SNUM.102 = 'AQCTL (TCAM) '\n   SNUM.103 = 'XLATE        '\n   SNUM.104 = 'TOPCTL (TCAM)'\n   SNUM.105 = 'IMGLIB       '\n   SNUM.106 = '--Reserved-- '\n   SNUM.107 = 'MODESET      '\n   SNUM.108 = '--Reserved-- '\n   SNUM.109 = 'ESR TYPE 4   '\n   SNUM.110 = '--Reserved-- '\n   SNUM.111 = '--No MACRO-- '\n   SNUM.112 = 'PGRLSE       '\n   SNUM.113 = 'PGFIX/PGFREE/'\n   SNUM.114 = 'EXCPVR       '\n   SNUM.115 = '--Reserved-- '\n   SNUM.116 = 'ESR TYPE 1   '\n   SNUM.117 = 'DEBCHK       '\n   SNUM.118 = '--Reserved-- '\n   SNUM.119 = 'TESTAUTH     '\n   SNUM.120 = 'GETMAIN/FREEM'\n   SNUM.121 = 'VSAM         '\n   SNUM.122 = 'ESR TYPE 2   '\n   SNUM.123 = 'PURGEDQ      '\n   SNUM.124 = 'TPIO         '\n   SNUM.125 = 'EVENTS       '\n   SNUM.126 = '--Reserved-- '\n   SNUM.127 = '--Reserved-- '\n   SNUM.128 = '--Reserved-- '\n   SNUM.129 = '--Reserved-- '\n   SNUM.130 = 'RACHECK      '\n   SNUM.131 = 'RACINIT      '\n   SNUM.132 = 'RACLIST      '\n   SNUM.133 = 'RACDEF       '\n   SNUM.134 = '--Reserved-- '\n   SNUM.135 = '--Reserved-- '\n   SNUM.136 = '--Reserved-- '\n   SNUM.137 = 'ESR TYPE 6   '\n   SNUM.138 = 'PGSER (XA)   '\n   SNUM.139 = 'CVAF         '\n   SNUM.140 = '             '\n   SNUM.141 = '             '\n   SNUM.142 = '             '\n   SNUM.143 = 'GENKEY/RETKEY'\n   SNUM.144 = 'PTRACE(DEBUG)'\n   SNUM.145 = '             '\n   SNUM.146 = '             '\n   SNUM.147 = '             '\n   SNUM.148 = '             '\n   SNUM.149 = '             '\n   SNUM.150 = '             '\n   SNUM.151 = '             '\n   SNUM.152 = '             '\n   SNUM.153 = '             '\n   SNUM.154 = '             '\n   SNUM.155 = '             '\n   SNUM.156 = '             '\n   SNUM.157 = '             '\n   SNUM.158 = '             '\n   SNUM.159 = '             '\n   SNUM.160 = '             '\n   SNUM.161 = '             '\n   SNUM.162 = '             '\n   SNUM.163 = '             '\n   SNUM.164 = '             '\n   SNUM.165 = '             '\n   SNUM.166 = '             '\n   SNUM.167 = '             '\n   SNUM.168 = '             '\n   SNUM.169 = '             '\n   SNUM.170 = '             '\n   SNUM.171 = '             '\n   SNUM.172 = '             '\n   SNUM.173 = '             '\n   SNUM.174 = '             '\n   SNUM.175 = '             '\n   SNUM.176 = '             '\n   SNUM.177 = '             '\n   SNUM.178 = '             '\n   SNUM.179 = '             '\n   SNUM.180 = '             '\n   SNUM.181 = '             '\n   SNUM.182 = '             '\n   SNUM.183 = '             '\n   SNUM.184 = '             '\n   SNUM.185 = '             '\n   SNUM.186 = '             '\n   SNUM.187 = '             '\n   SNUM.188 = '             '\n   SNUM.189 = '             '\n   SNUM.190 = '             '\n   SNUM.191 = '             '\n   SNUM.192 = '             '\n   SNUM.193 = '             '\n   SNUM.194 = '             '\n   SNUM.195 = '             '\n   SNUM.196 = '             '\n   SNUM.197 = '             '\n   SNUM.198 = '             '\n   SNUM.199 = '             '\n   SNUM.200 = '             '\n   SNUM.201 = '             '\n   SNUM.202 = '             '\n   SNUM.203 = '             '\n   SNUM.204 = '             '\n   SNUM.205 = '             '\n   SNUM.206 = '             '\n   SNUM.207 = '             '\n   SNUM.208 = '             '\n   SNUM.209 = '             '\n   SNUM.210 = '             '\n   SNUM.211 = '             '\n   SNUM.212 = '             '\n   SNUM.213 = '             '\n   SNUM.214 = '             '\n   SNUM.215 = 'CICS(HPSVC)  '\n   SNUM.216 = 'CICS(CSVC)   '\n   SNUM.217 = '             '\n   SNUM.218 = '             '\n   SNUM.219 = '             '\n   SNUM.220 = '             '\n   SNUM.221 = '             '\n   SNUM.222 = '             '\n   SNUM.223 = '             '\n   SNUM.224 = '             '\n   SNUM.225 = '             '\n   SNUM.226 = '             '\n   SNUM.227 = '             '\n   SNUM.228 = '             '\n   SNUM.229 = '             '\n   SNUM.230 = '             '\n   SNUM.231 = '             '\n   SNUM.232 = '             '\n   SNUM.233 = '             '\n   SNUM.234 = '             '\n   SNUM.235 = '             '\n   SNUM.236 = '             '\n   SNUM.237 = '             '\n   SNUM.238 = '             '\n   SNUM.239 = '             '\n   SNUM.240 = '             '\n   SNUM.241 = 'VSAMTUNE     '\n   SNUM.242 = 'UCC7         '\n   SNUM.243 = '             '\n   SNUM.244 = '             '\n   SNUM.245 = 'UCC11        '\n   SNUM.246 = '             '\n   SNUM.247 = 'UCC1 (X)     '\n   SNUM.248 = 'UCC1 (Y)     '\n   SNUM.249 = 'DIAGNOSE     '\n   SNUM.250 = '             '\n   SNUM.251 = '             '\n   SNUM.252 = '             '\n   SNUM.253 = '             '\n   SNUM.254 = '             '\n   SNUM.255 = '             '\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\n\nSay\nSay '         --- SVCTABLE Display For' SYSID '---'\nSay\nSay '                   ' Copies(' ',16) ,\n            '                A S P A             '\nSay '  SVC# (Hex)  Entry' Copies(' ',16) ,\n            '  Amod  Type    P E R S  Lock(s) needed '\nSay '                   ' Copies(' ',16) ,\n            '                F R E T             '\nSay\n\nDO I=0 to 255\n   ENTRYPT = Get_Stor(SVCADD)                 /*                   */\n   AMODE = Substr(ENTRYPT,1,1)\n   If Bitand(AMODE,'80'x) = '80'x Then\n      ADDR = '31'\n   Else\n      ADDR = '  '\n   SVCTYPE = Get_Stor(SVCADD,'4'x,1)\n   If Bitand(SVCTYPE,'20'x) = '20'x Then Do\n      TYPEMSG = 'T6   '\n      End\n   Else\n      If Bitand(SVCTYPE,'C0'x) = 'C0'x Then Do\n         TYPEMSG = 'T3/4 '\n         End\n      Else\n         If Bitand(SVCTYPE,'80'x) = '80'x Then Do\n            TYPEMSG = 'T2   '\n            End\n         Else\n            If Bitand(SVCTYPE,'00'x) = '00'x Then Do\n               TYPEMSG = 'T1   '\n               End\n            Else\n               TYPEMSG = '?    '\n   If Bitand(SVCTYPE,'08'x) = '08'x Then\n      APF = 'A'\n   Else\n      APF = ' '\n   If Bitand(SVCTYPE,'04'x) = '04'x Then\n      ESR = 'E'\n   Else\n      ESR = ' '\n   If Bitand(SVCTYPE,'02'x) = '02'x Then\n      PRE = 'P'\n   Else\n      PRE = ' '\n   If Bitand(SVCTYPE,'01'x) = '01'x Then\n      AST = 'S'\n   Else\n      AST = ' '\n   LOCK    = Get_Stor(SVCADD,'6'x,1)\n   LMSG = ''\n   If Bitand(LOCK,'80'x) = '80'x Then\n      LMSG = LMSG||'LOCL'\n   If Bitand(LOCK,'40'x) = '40'x Then\n      LMSG = LMSG||',CMS'\n   If Bitand(LOCK,'20'x) = '20'x Then\n      LMSG = LMSG||',OPT'\n   If Bitand(LOCK,'10'x) = '10'x Then\n      LMSG = LMSG||',SALLOC'\n   If Bitand(LOCK,'08'x) = '08'x Then\n      LMSG = LMSG||',DISP'\n   IHEX = '    '\n   IHEX = Right(D2X(I),2)\n   Say ' ' Format(I,3,0) '-' IHEX ' ' ,\n       C2X(ENTRYPT) ' ' SNUM.I ' ' ADDR ' ',\n       TYPEMSG ' ' APF ESR PRE AST ' ' LMSG\n   SVCADD  = D2C(C2D(SVCADD)+8)                /* Bump to next entry */\n   End\nSay\nReturn\n\n/*------------------------------------------------------------------*/\n\n/*                                                                  */\n/*      DISPLAY SYSTEM information                                  */\n/*                                                                  */\n/*                                                                  */\n/*      PCCAT = CVT+x'2FC' = Pointer to the PCCA Vector Table       */\n/*      PCCAVT has up to 16 PCCA pointers                           */\n/*      PCCA Has CPU Serial # plus its physical CPU Id              */\n/*                                                                  */\n/*      STRGOFF = CVT+x'358' = Online Storage (K's) at IPL          */\n/*                                                                  */\n\nSYSDISP:\n\nPVTADD  = Get_Stor(CVTADD,'2FC'x)\nRCE     = Get_Stor(CVTADD,'490'x)              /* Get RCE Pointer   */\nGDA     = Get_Stor(CVTADD,'230'x)              /* Get GDA Pointer   */\nECVT    = Get_Stor(CVTADD,'8C'x)               /* Get Extended CVT  */\nEXT2CVT = Get_Stor(CVTADD,'148'x)              /* Get CVTEXT2       */\n\nLOADPARM = Get_Stor(ECVT,'A0'x,8)\n\nIODFID  = Get_Stor(EXT2CVT,'6'x,2)\nNUCID   = Get_Stor(EXT2CVT,'4'x,1)\n\nSTRG    = Get_Stor(CVTADD,'358'x)\nEXPSTOR = C2D(Get_Stor(RCE,'A0'x))\nEXPSTOR = (EXPSTOR*4)/1024                     /* Convert To MEG    */\n\nIPLTI  = C2D(Get_Stor(SMCAADD,'150'x))%360000\nIPLTRM = C2D(Get_Stor(SMCAADD,'150'x))//360000\nIPLTD  = RIGHT(IPLTRM%6000,2,'0')             /* Find # of Minutes  */\n\nIPLT   = IPLTI||'.'||IPLTD\nIPLD   = C2X(Get_Stor(SMCAADD,'154'x))\n\nIPLYEAR  = Substr(IPLD,3,2)\nIPLDAY   = Substr(IPLD,5,3)\n\nIf Substr(IPLD,1,2) = '00' Then IPLYEAR = IPLYEAR+1900\nElse IPLYEAR = IPLYEAR+2000\n\nIPL_R   = $DATE('J2R',IPLYEAR||IPLDAY)\nTODAY_J = $DATE('G2J',,\n          Substr(DATE(S),5,2)||'/'||,\n          Substr(DATE(S),7,2)||'/'||Substr(DATE(S),1,4))\nTODAY_R = $DATE('J2R',TODAY_J)\n\nIf TODAY_R = IPL_R Then AGOS = '(Today)'\n   Else If (TODAY_R - IPL_R) = 1 Then AGOS = '(Yesterday)'\n      Else AGOS = '('||Value((TODAY_R - IPL_R))||' days ago)'\n\nUCBADD   = Get_Stor(CVTADD,'30'x)\n\nUCBNUM   = Get_Stor(UCBADD,'D'x,3)\nUCBVOL   = Get_Stor(UCBADD,'1C'x,6)\n\nCVTPRADD = D2C(C2D(CVTADD)-40)\n\nOPSYS    = Get_Stor(CVTPRADD,,8)\nFMIDS    = Get_Stor(CVTPRADD,'8'x,8)\nCPUTYPE  = C2X(Get_Stor(CVTPRADD,34,2))\nMVSREL   = Get_Stor(CVTPRADD,36)\n\nDFAADD   = Get_Stor(CVTADD,'4C0'x)\n\nDFPREL   = C2X(Get_Stor(DFAADD,'2'x,2))\nDFPREL   = Substr(DFPREL,1,3)\n\nASMADD   = Get_Stor(CVTADD,'2C0'x)\n\nIPLFLG   = Get_Stor(ASMADD,'1'x,1)\n\nCVTEADD  = Get_Stor(CVTADD,'4AC'x)\n\nMLPABEG  = C2X(Get_Stor(CVTEADD,8))\nMLPAEND  = C2X(Get_Stor(CVTEADD,12))\nMLPA_SIZE = Right(((X2D(MLPAEND)-X2D(MLPABEG)+1)%1024),8)||'K'\n\nFLPABEG  = C2X(Get_Stor(CVTEADD,16))\nFLPAEND  = C2X(Get_Stor(CVTEADD,20))\nFLPA_SIZE = Right(((X2D(FLPAEND)-X2D(FLPABEG)+1)%1024),8)||'K'\n\nPLPABEG  = C2X(Get_Stor(CVTEADD,24))\nPLPAEND  = C2X(Get_Stor(CVTEADD,28))\nPLPA_SIZE = Right(((X2D(PLPAEND)-X2D(PLPABEG)+1)%1024),8)||'K'\n\nWNUCBEG  = C2X(Get_Stor(CVTEADD,32))\nWNUCEND  = C2X(Get_Stor(CVTEADD,36))\nWNUC_SIZE = Right(((X2D(WNUCEND)-X2D(WNUCBEG)+1)%1024),8)||'K'\n\nRNUCBEG  = C2X(Get_Stor(CVTEADD,40))\nRNUCEND  = C2X(Get_Stor(CVTEADD,44))\nRNUC_SIZE = Right(((X2D(RNUCEND)-X2D(RNUCBEG)+1)%1024),8)||'K'\n\nENUCBEG  = C2X(Get_Stor(CVTEADD,48))\nENUCEND  = C2X(Get_Stor(CVTEADD,52))\nENUC_SIZE = Right(((X2D(ENUCEND)-X2D(ENUCBEG)+1)%1024),8)||'K'\n\nEPLPABEG = C2X(Get_Stor(CVTEADD,56))\nEPLPAEND = C2X(Get_Stor(CVTEADD,60))\nEPLPA_SIZE = Right(((X2D(EPLPAEND)-X2D(EPLPABEG)+1)%1024),8)||'K'\n\nEFLPABEG = C2X(Get_Stor(CVTEADD,64))\nEFLPAEND = C2X(Get_Stor(CVTEADD,68))\nEFLPA_SIZE = Right(((X2D(EFLPAEND)-X2D(EFLPABEG)+1)%1024),8)||'K'\n\nEMLPABEG = C2X(Get_Stor(CVTEADD,72))\nEMLPAEND = C2X(Get_Stor(CVTEADD,76))\nEMLPA_SIZE = Right(((X2D(EMLPAEND)-X2D(EMLPABEG)+1)%1024),8)||'K'\n\nCSASTRT  = Get_Stor(GDA,'6C'x)\nCSASIZE  = Get_Stor(GDA,'70'x)\n\nCSA_STRT = C2X(CSASTRT)\nCSA_END  = Right((D2X(C2D(CSASTRT)+C2D(CSASIZE)-1)),8,0)\n\nCSAESTRT = Get_Stor(GDA,'7C'x)\nCSAESIZE = Get_Stor(GDA,'80'x)\n\nECSA_STRT = C2X(CSAESTRT)\nECSA_END  = Right((D2X(C2D(CSAESTRT)+C2D(CSAESIZE)-1)),8,0)\n\nSQASTRT  = Get_Stor(GDA,'90'x)\nSQASIZE  = Get_Stor(GDA,'94'x)\n\nSQA_STRT = C2X(SQASTRT)\nSQA_END  = Right((D2X(C2D(SQASTRT)+C2D(SQASIZE)-1)),8,0)\n\nSQAESTRT = Get_Stor(GDA,'98'x)\nSQAESIZE = Get_Stor(GDA,'9C'x)\n\nESQA_STRT = C2X(SQAESTRT)\nESQA_END  = Right((D2X(C2D(SQAESTRT)+C2D(SQAESIZE)-1)),8,0)\n\nPRVSTRT  = Get_Stor(GDA,'A0'x)\nPRVSIZE  = Get_Stor(GDA,'A4'x)\n\nPVT_STRT = C2X(PRVSTRT)\nPVT_END  = Right((D2X(C2D(PRVSTRT)+C2D(PRVSIZE)-1)),8,0)\n\nPRVESTRT = Get_Stor(GDA,'A8'x)\nPRVESIZE = Get_Stor(GDA,'AC'x)\n\nEPVT_STRT = C2X(PRVESTRT)\nEPVT_END  = Right((D2X(C2D(PRVESTRT)+C2D(PRVESIZE)-1)),8,0)\n\nUNALLCSA   = Format((C2D(Get_Stor(GDA,'84'x))/1024),5,0)\nCSA2SQA    = Format((C2D(Get_Stor(GDA,'8C'x))/1024),5,0)\n\nCSA_ALLOC  = Format((C2D(Get_Stor(GDA,'1B0'x))/1204),9,0)\nECSA_ALLOC = Format((C2D(Get_Stor(GDA,'1B4'x))/1204),9,0)\nSQA_ALLOC  = Format((C2D(Get_Stor(GDA,'1B8'x))/1204),9,0)\nESQA_ALLOC = Format((C2D(Get_Stor(GDA,'1BC'x))/1204),9,0)\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\nD1  = Substr(DATE('J'),1,2)\nD2  = Substr(DATE('J'),3,3)\nD1N2 = D1||'.'||D2\n\nSay\nSay '         --- SYSTEM INFO Display For' SYSID '---'\nSay\nSay ' Today =' D1N2 'or' DATE('W')||',' DATE('N')\nSay ' System IPL''ed at' Format(IPLT,2,2) AGOS,\n     'on' $DATE('R2D',IPL_R)||',' IPLYEAR||'.'||IPLDAY,\n     '('||$DATE('J2G',IPLYEAR||IPLDAY)||')'\nSay Copies(' ',7) 'using volume' UCBVOL 'at address' UCBNUM\n\nIf BitAnd(IPLFLG,'08'x) = '08'x Then Do\n   QIPL = 'Non-CLPA'\n   End\nElse Do\n   QIPL = 'CLPA    '\n   End\n\nIf BitAnd(IPLFLG,'04'x) = '04'x Then Do\n   WIPL = 'Non-CVIO'\n   End\nElse Do\n   WIPL = 'CVIO    '\n   End\n\nSay ' IPL Type:  Quick Start =' QIPL  '   Warm Start =' WIPL\n\nSay ' IPL LoadParm =' LOADPARM\n\nSay ' IPL Nucleus id =' NUCID '   IPL IODF id =' IODFID\n\nSay ' Online Real Storage at IPL =' Format(C2D(STRG)/1024,5,0)||'M'\nSay ' Available Expanded Storage =' EXPSTOR'M'\nSay ' OpSys = ' OPSYS '    FMID =' FMIDS '   SMFID =' SMFID ,\n    '    Sysplex =' Get_Stor(ECVT,'8'x,8)\nSay ' MVS Rel =' MVSREL '   DFP Rel =' DFPREL ,\n    '  CPU Type ='  CPUTYPE\n\nIf Bitand(Get_Stor(CVTADD,'178'x,1),'10'x) = '10'x Then ,\n   Say ' MOVEPAGE facility is enabled for this CPU'\nElse ,\n   Say ' MOVEPAGE facility is *NOT AVAILABLE* for this CPU'\n\nIf Bitand(Get_Stor(CVTADD,'179'x,1),'80'x) = '80'x Then ,\n   Say ' MVS Compression/Expansion Service is available'\nElse ,\n   Say ' MVS Compression/Expansion Service is *NOT AVAILABLE*'\n\nIf Bitand(Get_Stor(CVTADD,'179'x,1),'40'x) = '40'x Then ,\n   Say ' Hardware Data Compression/Expansion instruction is available'\nElse ,\n   Say ' Hardware Data Compression/Expansion instruction is *NOT',\n       'AVAILABLE*'\n\nSay\n\nDo I=1 to 16\n   PCCAADD = Get_Stor(PVTADD)                  /*                   */\n   If C2D(PCCAADD) \u00ac=0 Then Do\n      VERCODE = Get_Stor(PCCAADD,'4'x,2)\n      SERIAL  = Get_Stor(PCCAADD,'6'x,6)\n      CPUTYPE = Get_Stor(PCCAADD,'C'x)\n      CPUID   = C2D(Get_Stor(PCCAADD,'10'x,2))\n      Say ' CPU =' CPUID ' Vers =' VERCODE ' Ser =' SERIAL\n      End\n   PVTADD  = D2C(C2D(PVTADD)+4)                /* Bump to next entry */\n   End\n\n  CSA_SIZE =  Right(C2D(CSASIZE)/1024,8)||'K'\n ECSA_SIZE =  Right(C2D(CSAESIZE)/1024,8)||'K'\n  SQA_SIZE =  Right(C2D(SQASIZE)/1024,8)||'K'\n ESQA_SIZE =  Right(C2D(SQAESIZE)/1024,8)||'K'\n  PVT_SIZE =  Right(C2D(PRVSIZE)/1024,8)||'K'\n EPVT_SIZE =  Right(C2D(PRVESIZE)/1024,8)||'K'\n\nSay\nSay ' Start/End Address for PVT REG ' PVT_STRT  '-'    PVT_END,\n                                                PVT_SIZE\nSay ' - - - - - - - - - - - CSA     ' CSA_STRT  '-'    CSA_END,\n                                                CSA_SIZE\nSay ' - - - - - - - - - - - MLPA    ' MLPABEG   '-'    MLPAEND,\n                                                MLPA_SIZE\nSay ' - - - - - - - - - - - FLPA    ' FLPABEG   '-'    FLPAEND,\n                                                FLPA_SIZE\nSay ' - - - - - - - - - - - PLPA    ' PLPABEG   '-'    PLPAEND,\n                                                PLPA_SIZE\nSay ' - - - - - - - - - - - SQA     ' SQA_STRT  '-'    SQA_END ,\n                                                SQA_SIZE\nSay ' - - - - - - READ/WRITE NUC    ' WNUCBEG   '-'    WNUCEND,\n                                                WNUC_SIZE\nSay ' - - - - - -  READ-ONLY NUC    ' RNUCBEG   '-'    RNUCEND,\n                                                RNUC_SIZE\nSay ' -  READ/WRITE EXTENDED NUC    ' ENUCBEG   '-'    ENUCEND,\n                                                ENUC_SIZE\nSay ' - - - - - -  EXTENDED SQA     ' ESQA_STRT '-'    ESQA_END,\n                                                ESQA_SIZE\nSay ' - - - - - -  EXTENDED PLPA    ' EPLPABEG  '-'    EPLPAEND,\n                                                EPLPA_SIZE\nSay ' - - - - - -  EXTENDED FLPA    ' EFLPABEG  '-'    EFLPAEND,\n                                                EFLPA_SIZE\nSay ' - - - - - -  EXTENDED MLPA    ' EMLPABEG  '-'    EMLPAEND,\n                                                EMLPA_SIZE\nSay ' - - - - - -  EXTENDED CSA     ' ECSA_STRT '-'    ECSA_END,\n                                                ECSA_SIZE\nSay ' - - - - - -  EXTENDED PVT REG ' EPVT_STRT '-'    EPVT_END,\n                                                EPVT_SIZE\nSay\nSay 'CSA converted to SQA = ' CSA2SQA'K'  ' Avail CSA = ' UNALLCSA'K'\nSay\nSay 'GetMained CSA =' CSA_ALLOC'K'  '  ECSA = ' ECSA_ALLOC'K'\nSay 'GetMained SQA =' SQA_ALLOC'K'  '  ESQA = ' ESQA_ALLOC'K'\nReturn\n\n/*------------------------------------------------------------------*/\n\n\nGet_Stor: PROCEDURE\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) Length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nParse Arg AREA,OFFSET,LENG\n\nIf Arg(2,'O') Then OFFSET=0\n\nIf Arg(3,'O') Then LENG=4\n\nIf DataType(AREA) = 'CHAR' Then Do\n   AREA =  C2D(AREA)\n   End\n\nIf DataType(OFFSET) = 'CHAR' Then Do\n   OFFSET =  C2D(OFFSET)\n   End\n\nReturn  Storage((D2X(AREA+OFFSET)),LENG)\n\n/*                                 REXX                             */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This REXX exec will do date conversion:                     */\n/*                                                                  */\n/*      Call Format:  DATE = $DATE(CODE,INPUT)                      */\n/*                                                                  */\n/*          CODE = 'J2G' - Julian to Gregorian date                 */\n/*          CODE = 'G2J' - Gregorian date to Julian                 */\n/*          CODE = 'J2R' - Julian to Relative date                  */\n/*          CODE = 'R2J' - Relative to Julian date                  */\n/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */\n/*                                                                  */\n/*          INPUT = either 'MM/DD/YYYY' or 'YYYYDDD' or 'nnnn'      */\n/*                                                                  */\n/*      Errors during processing will return 0 as result and        */\n/*      an error message will be displayed as well.                 */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n$DATE: Procedure\n\nParse Upper Arg FUNC,DATE\n\nIf DATE = '' Then RET_DATE = 0\nElse Select\n      When FUNC = 'J2G' Then RET_DATE = J2G_PROC(DATE)\n      When FUNC = 'G2J' Then RET_DATE = G2J_PROC(DATE)\n      When FUNC = 'J2R' Then RET_DATE = J2R_PROC(DATE)\n      When FUNC = 'R2J' Then RET_DATE = R2J_PROC(DATE)\n      When FUNC = 'R2D' Then RET_DATE = R2D_PROC(DATE)\n      Otherwise Do\n         Say 'DT999E - Invalid function code as' FUNC\n         RET_DATE = 0\n         End\n   End\n\nReturn RET_DATE\n\n\n\nJ2G_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 0 Then G_DATE = 0\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(JULIAN_YYYY) Then MO.2 = 29\n   Do I=1 to 12 While JULIAN_DDD > MO.I\n      JULIAN_DDD = JULIAN_DDD - MO.I\n      End\n   MM   = Right(I,2,'0')\n   DD   = Right(JULIAN_DDD,2,'0')\n   G_DATE = MM||'/'||DD||'/'||JULIAN_YYYY\n   End\n\nReturn G_DATE\n\n\nG2J_PROC: Procedure\n\nParse Arg GEO_DATE\nParse Var GEO_DATE MM '/' DD '/' YYYY\nJ_DATE = 0\n\nIf Datatype(MM)   \u00ac= 'NUM' | ,\n   Datatype(DD)   \u00ac= 'NUM' | ,\n   Datatype(YYYY) \u00ac= 'NUM' | ,\n   DD > 31                 | ,\n   MM < 1                  | ,\n   MM > 12                 | ,\n   YYYY > 9999          Then ,\n      Say 'DT001E - Invalid Gregorian date as' GEO_DATE\nElse Do\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(YYYY) Then MO.2 = 29\n   MM = Strip(MM,'L','0')\n   If (DD > Value(MO.MM)) Then ,\n       Say 'DT002E - Out-of-range date as' GEO_DATE\n   Else Do\n      J_ACCUM_DAY = 0\n      If MM > 1 Then Do I=1 to (MM-1)\n         J_ACCUM_DAY = J_ACCUM_DAY + MO.I\n         End\n      J_ACCUM_DAY = J_ACCUM_DAY + DD\n      J_DATE      = YYYY||Right(J_ACCUM_DAY,3,'0')\n      End\n   End\n\nReturn J_DATE\n\n\n\n\nJ2R_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 1 Then R_DATE = ((JULIAN_YYYY-1) * 365) + ,\n                            ((JULIAN_YYYY-1) % 4) - ,\n                            ((JULIAN_YYYY-1) % 100) + ,\n                            ((JULIAN_YYYY-1) % 400) + (JULIAN_DDD)\n   Else R_DATE = 0\nReturn R_DATE\n\n\n\nR2J_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_J = 0\n\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      TEMP_YYYY = (REL_DATE % 366) + 1\n      TEMP_REL = J2R_PROC(Right(TEMP_YYYY,4,'0')||'000')\n      Do While (REL_DATE - TEMP_REL) > 0\n         If LEAP_YEAR(TEMP_YYYY) Then LEFT_OVER = 366\n         Else LEFT_OVER = 365\n         If LEFT_OVER < (REL_DATE - TEMP_REL) Then Do\n            TEMP_REL  = TEMP_REL  + LEFT_OVER\n            TEMP_YYYY = TEMP_YYYY + 1\n            End\n         Else Do\n            TEMP_DDD = (REL_DATE - TEMP_REL)\n            Leave\n            End\n         End\n      RETURNED_J =  Right(TEMP_YYYY,4,'0')||Right(TEMP_DDD,3,'0')\n   End\nEnd\n\nReturn RETURNED_J\n\n\nR2D_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_DAY = 0\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      DAY_INDEX = (REL_DATE // 7)+1\n      RETURNED_DAY  = Word('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)\n   End\nEnd\n\nReturn RETURNED_DAY\n\n\n\n\n\nVALIDATE_JULIAN:\n\nVALID_DATE = 0\n\nIf Length(JUL_DATE) \u00ac=7 | Datatype(JUL_DATE) \u00ac= 'NUM' Then\n   Say 'DT003E - Date too short/long or non-numeric as' JUL_DATE\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   If (JULIAN_DDD > 366) Then ,\n      Say 'DT004E - Number of day > 366 as' JULIAN_DDD\n   Else If (LEAP_YEAR(JULIAN_YYYY) = 0) & (JULIAN_DDD = 366) Then ,\n          Say 'DT005E - Invalid days for a non-leap year as' JULIAN_YYYY\n        Else If (JULIAN_YYYY < 1) Then ,\n           Say 'DT008E - Invalid year as' JULIAN_YYYY\n           Else VALID_DATE = 1\n   End\nReturn VALID_DATE\n\n\n\nLEAP_YEAR: Procedure\nParse Arg YEAR_CHECKED\n\nIf (YEAR_CHECKED // 100) = 0 Then ,\n   If (YEAR_CHECKED // 400) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\nElse If (YEAR_CHECKED // 4) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\n\nReturn LEAP_YEAR_FLAG\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DATE": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x984\\x9f\\x00\\x984\\x9f\\x08)\\x00\\xd8\\x00\\xd8\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-12-15T00:00:00", "modifydate": "1998-12-15T08:29:00", "lines": 216, "newlines": 216, "modlines": 0, "user": "NMVV1"}, "text": "/*                                 REXX                             */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This REXX exec will do date conversion:                     */\n/*                                                                  */\n/*      Call Format:  DATE = $DATE(CODE,INPUT)                      */\n/*                                                                  */\n/*          CODE = 'J2G' - Julian to Gregorian date                 */\n/*          CODE = 'G2J' - Gregorian date to Julian                 */\n/*          CODE = 'J2R' - Julian to Relative date                  */\n/*          CODE = 'R2J' - Relative to Julian date                  */\n/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */\n/*                                                                  */\n/*          INPUT = either 'MM/DD/YYYY' or 'YYYYDDD' or 'nnnn'      */\n/*                                                                  */\n/*      Errors during processing will return 0 as result and        */\n/*      an error message will be displayed as well.                 */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n$DATE:\n\nParse Upper Arg FUNC,DATE\n\nIf DATE = '' Then RET_DATE = 0\nElse Select\n      When FUNC = 'J2G' Then RET_DATE = J2G_PROC(DATE)\n      When FUNC = 'G2J' Then RET_DATE = G2J_PROC(DATE)\n      When FUNC = 'J2R' Then RET_DATE = J2R_PROC(DATE)\n      When FUNC = 'R2J' Then RET_DATE = R2J_PROC(DATE)\n      When FUNC = 'R2D' Then RET_DATE = R2D_PROC(DATE)\n      Otherwise Do\n         Say 'DT999E - Invalid function code as' FUNC\n         RET_DATE = 0\n         End\n   End\n\nReturn RET_DATE\n\n\n\nJ2G_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 0 Then G_DATE = 0\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(JULIAN_YYYY) Then MO.2 = 29\n   Do I=1 to 12 While JULIAN_DDD > MO.I\n      JULIAN_DDD = JULIAN_DDD - MO.I\n      End\n   MM   = Right(I,2,'0')\n   DD   = Right(JULIAN_DDD,2,'0')\n   G_DATE = MM||'/'||DD||'/'||JULIAN_YYYY\n   End\n\nReturn G_DATE\n\n\nG2J_PROC: Procedure\n\nParse Arg GEO_DATE\nParse Var GEO_DATE MM '/' DD '/' YYYY\nJ_DATE = 0\n\nIf Datatype(MM)   \u00ac= 'NUM' | ,\n   Datatype(DD)   \u00ac= 'NUM' | ,\n   Datatype(YYYY) \u00ac= 'NUM' | ,\n   DD > 31                 | ,\n   MM < 1                  | ,\n   MM > 12                 | ,\n   YYYY > 9999          Then ,\n      Say 'DT001E - Invalid Gregorian date as' GEO_DATE\nElse Do\n   MO.1  = 31\n   MO.2  = 28\n   MO.3  = 31\n   MO.4  = 30\n   MO.5  = 31\n   MO.6  = 30\n   MO.7  = 31\n   MO.8  = 31\n   MO.9  = 30\n   MO.10 = 31\n   MO.11 = 30\n   MO.12 = 31\n   If LEAP_YEAR(YYYY) Then MO.2 = 29\n   MM = Strip(MM,'L','0')\n   If (DD > Value(MO.MM)) Then ,\n       Say 'DT002E - Out-of-range date as' GEO_DATE\n   Else Do\n      J_ACCUM_DAY = 0\n      If MM > 1 Then Do I=1 to (MM-1)\n         J_ACCUM_DAY = J_ACCUM_DAY + MO.I\n         End\n      J_ACCUM_DAY = J_ACCUM_DAY + DD\n      J_DATE      = YYYY||Right(J_ACCUM_DAY,3,'0')\n      End\n   End\n\nReturn J_DATE\n\n\n\n\nJ2R_PROC: Procedure\n\nParse Arg JUL_DATE\n\nCall VALIDATE_JULIAN\nIf RESULT = 1 Then R_DATE = ((JULIAN_YYYY-1) * 365) + ,\n                            ((JULIAN_YYYY-1) % 4) - ,\n                            ((JULIAN_YYYY-1) % 100) + ,\n                            ((JULIAN_YYYY-1) % 400) + (JULIAN_DDD)\n   Else R_DATE = 0\nReturn R_DATE\n\n\n\nR2J_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_J = 0\n\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      TEMP_YYYY = (REL_DATE % 366) + 1\n      TEMP_REL = J2R_PROC(Right(TEMP_YYYY,4,'0')||'000')\n      Do While (REL_DATE - TEMP_REL) > 0\n         If LEAP_YEAR(TEMP_YYYY) Then LEFT_OVER = 366\n         Else LEFT_OVER = 365\n         If LEFT_OVER < (REL_DATE - TEMP_REL) Then Do\n            TEMP_REL  = TEMP_REL  + LEFT_OVER\n            TEMP_YYYY = TEMP_YYYY + 1\n            End\n         Else Do\n            TEMP_DDD = (REL_DATE - TEMP_REL)\n            Leave\n            End\n         End\n      RETURNED_J =  Right(TEMP_YYYY,4,'0')||Right(TEMP_DDD,3,'0')\n   End\nEnd\n\nReturn RETURNED_J\n\n\nR2D_PROC: Procedure\nParse Arg REL_DATE\nRETURNED_DAY = 0\nIf Datatype(REL_DATE) \u00ac= 'NUM' Then ,\n   Say 'DT006E - Relative date non-numeric as' REL_DATE\nElse Do\n   If REL_DATE > 3652424 Then ,\n      Say 'DT007E - Relative date out-of-range as' REL_DATE\n   Else Do\n      DAY_INDEX = (REL_DATE // 7)+1\n      RETURNED_DAY  = Word('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)\n   End\nEnd\n\nReturn RETURNED_DAY\n\n\n\n\n\nVALIDATE_JULIAN:\n\nVALID_DATE = 0\n\nIf Length(JUL_DATE) \u00ac=7 | Datatype(JUL_DATE) \u00ac= 'NUM' Then\n   Say 'DT003E - Date too short/long or non-numeric as' JUL_DATE\nElse Do\n   JULIAN_YYYY = Substr(JUL_DATE,1,4)\n   JULIAN_DDD  = Substr(JUL_DATE,5,3)\n   If (JULIAN_DDD > 366) Then ,\n      Say 'DT004E - Number of day > 366 as' JULIAN_DDD\n   Else If (LEAP_YEAR(JULIAN_YYYY) = 0) & (JULIAN_DDD = 366) Then ,\n          Say 'DT005E - Invalid days for a non-leap year as' JULIAN_YYYY\n        Else If (JULIAN_YYYY < 1) Then ,\n           Say 'DT008E - Invalid year as' JULIAN_YYYY\n           Else VALID_DATE = 1\n   End\nReturn VALID_DATE\n\n\n\nLEAP_YEAR: Procedure\nParse Arg YEAR_CHECKED\n\nIf (YEAR_CHECKED // 100) = 0 Then ,\n   If (YEAR_CHECKED // 400) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\nElse If (YEAR_CHECKED // 4) = 0 Then LEAP_YEAR_FLAG = 1\n   Else LEAP_YEAR_FLAG = 0\n\nReturn LEAP_YEAR_FLAG\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DISC": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\\x14/\\x00\\x984\\x9f\\x08%\\x00\\t\\x00\\t\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-05-21T00:00:00", "modifydate": "1998-12-15T08:25:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "NMVV1"}, "text": "\n   WE, THE PROGRAMS' AUTHORS, AS WELL AS NEIMAN MARCUS, WILL NOT BE\n   HELD LIABLE FOR ANY DAMAGES CAUSED BY THE USAGE OF THE PROGRAMS\n   PROVIDED HERE.  IT IS THE USER'S SOLE RESPONSIBILITY TO EVALUATE AND\n   MAKE USE OF THESE PROGRAMS.  WE DO NOT GUARANTEE TO KEEP THE PROVIDED\n   MATERIALS UP-TO-DATE, NOR DO WE GUARANTEE TO PROVIDE CORRECTIONS AND\n   MODIFICATIONS REQUESTED BY ANY USER.\n\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DO": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x00\\x00\\x95)?\\x00\\x952O\\x16D\\x01D\\x002\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "1995-10-20T00:00:00", "modifydate": "1995-11-20T16:44:00", "lines": 324, "newlines": 50, "modlines": 0, "user": "$VNV"}, "text": "/*                              Rexx                                */\n\n/*------------------------------------------------------------------*/\n/*    This EDIT macro will verify a REXX exec for the DO/END syntax */\n/*    pairing and flags any kind of errors, i.e. hanging (unpaired) */\n/*    DO/END.                                                       */\n/*------------------------------------------------------------------*/\n/*    Author - Vinh Vu                                              */\n/*    Date written - 10/24/95                                       */\n/*------------------------------------------------------------------*/\n/*    Update - 10/27/95 - $VNV - To support multiple DO/SELECT/END  */\n/*        on the same line                                          */\n/*------------------------------------------------------------------*/\n\nAddress ISPEXEC\n\n'CONTROL ERRORS RETURN'\n'ISREDIT MACRO (NODASH)'\nIf Rc \u00ac=0 Then Do\n   ZEDSMSG = '$DO Error'\n   ZEDLMSG = '$DO can only be run as an ISPF EDIT macro !!!'\n   'SETMSG MSG(ISRZ001)'\n   Exit\n   End\n'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n'ISREDIT (ENDLINE) = LINENUM .ZLAST'\n'ISREDIT RESET'\n\nDO_STACK.  = ''                      /* Init the stack for IFs    */\nDO_LINENUM. = 0\nDO_PTR     = 0\nHIGHEST_NESTING_LEVEL = 0\nHIGHEST_NESTING_LEVEL_COUNTER = 0\nHIGHEST_NESTING_LEVEL_LINENUM = 0\nCONTINUATION_LINE = 'N'\nNUMBER_OF_DO_S = 0\n\nDo COUNTER=STRTLINE to ENDLINE\n   'ISREDIT (MYINPUT) = LINE' COUNTER\n   MYINPUT = Substr(MYINPUT,1,72)    /* Only worry about col 1-72 */\n   Call EXAMINE_THE_LINE             /* Check for IF/END */\n   End                        /* Do */\n\nIf DO_PTR > 0 Then Do\n   Call BAD_DO_FOUND\n   End\nElse Do\n   Call GOOD_COMPLETION\n   End\n\nExit\n\n\n\nEXAMINE_THE_LINE:\n\nWORK_DATA = MYINPUT                   /* Work with this temp data */\nIf NODASH = '' Then Do\n   NEW_REC = '|'||Copies('.',43)||'|'\n   End\nElse Do\n   NEW_REC = MYINPUT                     /* Save the orginal data */\n   End\n\n\nIf CONTINUATION_LINE='Y' Then Do\n   If Pos('*/',WORK_DATA) = 0 Then Do\n      Return                      /*  line (not last line)        */\n      End\n   Else Do\n      Parse Var WORK_DATA . '*/' WORK_DATA   /* Last comment line */\n      CONTINUATION_LINE='N'\n      End\n   End\n\n\nREMOVE_LITERAL_DONE = 'N'\n\nDo Until REMOVE_LITERAL_DONE ='Y'\n   If Pos(\"'\",WORK_DATA) = 0 & ,\n      Pos('\"',WORK_DATA) = 0 & ,\n      Pos('/*',WORK_DATA) = 0  Then Do\n      REMOVE_LITERAL_DONE = 'Y'\n      End\n   Else Do\n      Call REMOVING_LITERAL\n      End       /* Else Do  */\n   End          /* Do Until */\n\n\nUpper WORK_DATA\n\nWORK_DATA = Translate(WORK_DATA,'  ',',;')    /* Change ;, to blank */\n\n/*------------------------------------------------------------------*/\n/*    When we get here, WORK_DATA will not have commnents, literal  */\n/*    (text enclosed by quotes), no commas, no semi-colons, just    */\n/*    instructions.                                                 */\n/*------------------------------------------------------------------*/\n\nTOKEN_POSITION. = ''\nTOKEN_TYPE. = ''\nTOKEN_PTR = 0\n\n/*------------------------------------------------------------------*/\n/*    Find out if we have more than 1 DO/SELECT/END on the same     */\n/*    line.  If we do, then put them on a stack and start           */\n/*    processing them one by one.                                   */\n/*------------------------------------------------------------------*/\n\nCall BUILD_TOKEN_STACK 'DO'\nCall BUILD_TOKEN_STACK 'SELECT'\nCall BUILD_TOKEN_STACK 'END'\n\nIf TOKEN_PTR > 0 Then Do\n   If TOKEN_PTR = 1 Then Do\n      Call PROCESS_THE_TOKEN 1\n      End\n   Else Do\n      Call SORT_TOKEN_POSITION\n      Do I=1 To TOKEN_PTR\n         Call PROCESS_THE_TOKEN I\n         End\n      End    /* Else Do           */\n   End       /* If TOKEN_PTR > 0  */\n\nReturn\n\n\nSORT_TOKEN_POSITION:\n\nALLDONE ='N'\nDo Until ALLDONE='Y'\n   ALLDONE = 'Y'\n   Do I=1 To (TOKEN_PTR-1)\n      J=I+1\n      If TOKEN_POSITION.I > TOKEN_POSITION.J Then Do\n         TEMP             = TOKEN_POSITION.J\n         TOKEN_POSITION.J = TOKEN_POSITION.I\n         TOKEN_POSITION.I = TEMP\n         TEMP             = TOKEN_TYPE.J\n         TOKEN_TYPE.J     = TOKEN_TYPE.I\n         TOKEN_TYPE.I     = TEMP\n         ALLDONE  = 'N'\n         End                  /* If TABLEPOS */\n      End                     /* Do I=1      */\n   End                        /* Do UNTIL    */\nReturn\n\n\n\nPROCESS_THE_TOKEN:\n\nArg MY_POSITION\nMY_TYPE = TOKEN_TYPE.MY_POSITION\n\nIf MY_TYPE = 'DO' | MY_TYPE = 'SELECT' Then Do\n   NUMBER_OF_DO_S = NUMBER_OF_DO_S+1\n   DO_PTR = DO_PTR+1\n   DO_STACK.DO_PTR =  NUMBER_OF_DO_S\n   DO_LINENUM.DO_PTR = COUNTER\n   MYNOTE = Substr(NEW_REC,1,45)\n   BEG_FLAG = '('||NUMBER_OF_DO_S||')-L'||DO_PTR\n   If DO_PTR > HIGHEST_NESTING_LEVEL Then Do\n      HIGHEST_NESTING_LEVEL = DO_PTR\n      HIGHEST_NESTING_LEVEL_COUNTER = NUMBER_OF_DO_S\n      HIGHEST_NESTING_LEVEL_LINENUM = COUNTER\n      End\n   MYNOTE = MYNOTE||'     /*  Beg #'||BEG_FLAG||'  */'\n   'ISREDIT LINE_BEFORE' COUNTER '= NOTELINE (MYNOTE)'\n   End\nElse If MY_TYPE = 'END' Then Do\n   If DO_PTR = 0 Then Do\n      ZEDSMSG = '$DO - CC=8'\n      ZEDLMSG = 'Unpaired END(s) found - Check the MSGLINE'\n      'SETMSG MSG(ISRZ001)'\n      MSG1 = '>>>>>>>>>> END without a DO <<<<<<<<<<'\n      'ISREDIT LINE_AFTER' COUNTER '= MSGLINE (MSG1)'\n      MSG1  = '>>> Check for the MSGLINE on line' COUNTER 'for the',\n              'unpaired END.'\n      'ISREDIT LINE_BEFORE .ZFIRST = MSGLINE (MSG1)'\n      'ISREDIT CURSOR =' COUNTER\n      Exit\n      End\n   MYNOTE = Substr(NEW_REC,1,45)\n   MYNOTE = MYNOTE||'     /*  End #('||DO_STACK.DO_PTR||')  */'\n   'ISREDIT LINE_AFTER' COUNTER '= NOTELINE (MYNOTE)'\n   DO_PTR = DO_PTR-1\n   End\n\nReturn\n\n\nBUILD_TOKEN_STACK:\n\nArg MY_TOKEN\n\nREXX_LINE = WORK_DATA\n\nREAL_POSITION = 0\n\nDo While WordPos(MY_TOKEN,REXX_LINE) > 0\n   TOKEN_PTR = TOKEN_PTR + 1\n   TOKEN_POSITION.TOKEN_PTR = WordPos(MY_TOKEN,REXX_LINE)+REAL_POSITION\n   TOKEN_TYPE.TOKEN_PTR = MY_TOKEN\n   REXX_LINE = DelWord(REXX_LINE,WordPos(MY_TOKEN,REXX_LINE),1)\n   REAL_POSITION = REAL_POSITION + 1\n   End\n\nReturn\n\n\n\nREMOVING_LITERAL:\n\n/*------------------------------------------------------------------*/\n/*    What we do here is to remove everything in between single     */\n/*    quotes, or double quotes, or between the comments mark.       */\n/*    This is the easiest way to make sure that we're not counting  */\n/*    the DO's & END's that belong to either a comment or some kind */\n/*    of text literal.  Once the removal is done, we can then scan  */\n/*    the line for DO/SELECT and END.                               */\n/*    Steps done:  Scan for these 3 special marks on a line of Rexx */\n/*    code, sort the position (col where it is found) and then      */\n/*    remove the text in between the mark found FIRST on the line.  */\n/*    (remember that these special marks could be part of the text  */\n/*    enclosed by the other special mark - that's why we need to    */\n/*    sort the positions and do the removal on the first one found) */\n/*------------------------------------------------------------------*/\n\nTABLEPOS. = ''\nTABLETYPE. = ''\nTABLEPOS.1 = Pos(\"'\",WORK_DATA)\nTABLETYPE.1 = \"'\"\nTABLEPOS.2 = Pos('\"',WORK_DATA)\nTABLETYPE.2 = '\"'\nTABLEPOS.3 = Pos('/*',WORK_DATA)\nTABLETYPE.3 = '/*'\n\nALLDONE ='N'\nDo Until ALLDONE='Y'\n   ALLDONE = 'Y'\n   Do I=1 To 2\n      J=I+1\n      If TABLEPOS.I > TABLEPOS.J Then Do\n         TEMP             = TABLEPOS.J\n         TABLEPOS.J       = TABLEPOS.I\n         TABLEPOS.I       = TEMP\n         TEMP             = TABLETYPE.J\n         TABLETYPE.J      = TABLETYPE.I\n         TABLETYPE.I      = TEMP\n         ALLDONE  = 'N'\n         End                  /* If TABLEPOS */\n      End                     /* Do I=1      */\n   End                        /* Do UNTIL    */\n\nDo I=1 to 3\n   If TABLEPOS.I > 0 Then Do\n     Call PERFORM_REMOVAL I\n     Leave\n     End\n   End    /* Do 3 */\n\nReturn\n\n\nPERFORM_REMOVAL:\n\nArg MY_NUMBER\nLITERAL_TYPE = TABLETYPE.MY_NUMBER\n\nIf LITERAL_TYPE = \"'\" Then Do\n   Parse Var WORK_DATA WORK_DATA \"'\" . \"'\" SECOND_PART\n   WORK_DATA = WORK_DATA||SECOND_PART\n   End\nElse If LITERAL_TYPE = '\"' Then Do\n   Parse Var WORK_DATA WORK_DATA '\"' . '\"' SECOND_PART\n   WORK_DATA = WORK_DATA||SECOND_PART\n   End\nElse If LITERAL_TYPE = '/*' Then Do\n   If Pos('*/',WORK_DATA) > 0 Then Do\n      Parse Var WORK_DATA WORK_DATA '/*' . '*/' SECOND_PART\n      WORK_DATA = WORK_DATA||SECOND_PART\n      End\n   Else Do\n      Parse Var WORK_DATA WORK_DATA '/*' .\n      CONTINUATION_LINE='Y'\n      End\n   End\n\nReturn\n\n\n\nBAD_DO_FOUND:\n\nZEDSMSG = '$DO - CC=8'\nZEDLMSG = 'Un-paired DO/SELECT(s) found - Check the REXX Exec'\n'SETMSG MSG(ISRZ001)'\nMSG1  = '>>> Look for DO/SELECT #' DO_STACK.DO_PTR 'in the',\n        'text for the unpaired DO/SELECT.'\n'ISREDIT LINE_BEFORE .ZFIRST = MSGLINE (MSG1)'\n\nMSG1 = '>>>>>>>>>> Unpaired DO/SELECT <<<<<<<<<'\n'ISREDIT LINE_AFTER' DO_LINENUM.DO_PTR '= MSGLINE (MSG1)'\n'ISREDIT CURSOR =' DO_LINENUM.DO_PTR\nReturn\n\n\n\nGOOD_COMPLETION:\nZEDSMSG = '$DO - CC=0'\nZEDLMSG = 'Check the NOTE lines for the DO/END pairings'\n'SETMSG MSG(ISRZ000)'\nMSG1  = '>>> There are' NUMBER_OF_DO_S 'pairs of DO/SELECT-END. To',\n        'find the DO/SELECT-END'\nMSG2  = '>>> pairs, scroll through and look for the NOTE lines.'\nMSG3  = '>>> The highest number of nested DO/SELECT is',\n        HIGHEST_NESTING_LEVEL 'at #'HIGHEST_NESTING_LEVEL_COUNTER',',\n        'line #'HIGHEST_NESTING_LEVEL_LINENUM\n'ISREDIT LINE_BEFORE .ZFIRST = MSGLINE (MSG1)'\n'ISREDIT LINE_BEFORE .ZFIRST = MSGLINE (MSG2)'\n'ISREDIT LINE_BEFORE .ZFIRST = MSGLINE (MSG3)'\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HISTORY": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x017\\x00\\x00\\x00\\x92\\x13\\x9f\\x01\\x005o\\x08U\\x00\\xa9\\x00\\x02\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.55", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "2000-12-21T08:55:00", "lines": 169, "newlines": 2, "modlines": 0, "user": "NMVV1"}, "text": "\n\n\n  05/27/92 -  FIRST TIME PUTTING TOGETHER THE FILE.\n\n  09/30/92 -\n              CHANGED - $D (REXX EXEC) - IT CAN NOW DISPLAY MORE STUFF.\n              ADDED   - JESXIT05 - ASM - JES2 COMMAND EXIT.  SEE $INDEX\n                        FOR DOCUMENTATION.\n\n  10/20/93 -\n              CHANGED - $D (REXX EXEC) - ADD THE DISPLAY OF LPALIST AND\n                        MORE STUFF.\n              CHANGED - FIND - ASM - CHANGES TO REPLACE ALL 'TPUT' AND\n                        'TGET' WITH 'PUTLINE' AND 'GETLINE'.  'TPUT'\n                        WILL NOT WORK IF TMP IS RUN IN BATCH MODE.\n              ADDED   - SEEK - ASM - TSO COMMAND TO SEARCH FOR LOAD\n                        MODULE IN LNKLST, LPA AND/OR STEPLIB (TASKLIB).\n              ADDED   - $LLACOPY - ASM - BATCH PROGRAM TO DO A REFRESH\n                        OF A PARTICULAR MODULE.\n              ADDED   - #LLACOPY - JCL - JCL TO RUN PROGRAM $LLACOPY.\n\n  10/05/94 -\n              ADDED   - $6 (REXX EXEC) - EVERY SO OFTEN, YOU NEED TO ACCESS\n                        A LOADLIB AND EXECUTE TSO COMMANDS OUT OF IT.  RATHER\n                        THAN GETTING OUT OF SPF, ALLOCATE A NEW ISPLLIB AND THEN\n                        GET BACKIN, JUST EXECUTE THIS EXEC AND VOILA !!\n              ADDED   - $6DOC - DOC - INSTALL DOC FOR $6.\n              ADDED   - ISRTSOA - PANEL - ISPF PANEL TO BE USED WITH $D.  THIS\n                        IS THE MODIFIED ISRTSOA (IBM).\n              ADDED   - $VSAMIDX (REXX EXEC) - EXEC TO CALCULATE THE OPTIMUM\n                        NUMBER OF INDEX BUFFERS TO BE SPECIFIED FOR A VSAM KSDS.\n                        THIS WILL BE GOOD FOR ANY RANDOM ACCESS AGAINST THIS\n                        DATA SET.\n              ADDED   - $VSDOC - DOC - INSTALL DOC FOR $VSAMIDX.\n              ADDED   - $VSIDX01 - PANEL - ISPF PANEL USED BY $VSAMIDX.\n              ADDED   - JSTAT - ASM - BATCH PROGRAM TO CHECK AND SEE IF A JOB\n                        (OR STC OR TSU) IS CURRENTLY RUNNING (USING THE 'STATUS'\n                        FUNCTION OF JES2).  IF IT IS FOUND, THEN WTO'S WILL BE\n                        DONE USING CONTROL CARDS IN 'FND'.  OTHERWISE, CONTROL\n                        CARDS FROM 'NOTFND' DDNAME WILL BE USED BY WTO'S.\n                        IF 'RRFND' AND 'RRNOTFND' ARE USED, A WTOR WILL BE DONE\n                        AFTER THE WTO'S TO GIVE THE OPERATOR A CHANCE TO DO\n                        SOMETHING ELSE BEFORE THE REPLY.  OF COURSE, NONE OF\n                        THE DDNAMES HAS TO BE PRESENT, IN WHICH CASE, THE\n                        APPROPRIATE RETURN CODE WILL BE ISSUED BASED ON THE\n                        JOB STATUS.\n                        NOTE THAT SINCE THIS PROGRAM DOES NOT GO THROUGH\n                        THE ASVT, AND THEREFORE DOES WORK IN A JES2 SHARED\n                        SPOOL ENVIRONMENT.\n              ADDED   - JSTAT# - JCL USED TO ASSEMBLE MODULE JSTAT.  THIS\n                        PROGRAM REQUIRES APF AUTHORIZATION, AND THEREFORE\n                        NEEDS TO BE LINKED (OR COPIED) TO AN APF LIBRARY.\n              ADDED   - JSTAT$ - TEST JCL TO RUN JSTAT.\n\n  12/07/94 -\n              ADDED   - $JAD (REXX EXEC) - TO DISPLAY ADDRESS SPACES INFO,\n                        I.E. TCB, SRBTIME, EXCP COUNT, TOTAL PROCESSOR STORAGE,\n                        REAL, EXPANDED STORAGE, ETC ...  A PLOT OF STORAGE\n                        DISTRIBUTION BASED ON UIC CAN BE DISPLAYED FOR SELECTED\n                        ADDRESS SPACE.\n              ADDED   - $JAD... - PANELS - ISPF PANELS USED BY $JAD.\n              ADDED   - $JAD# - DOC - INSTALLATION INSTRUCTION FOR $JAD.\n\n  03/06/95 -\n              CHANGED - $JAD (REXX EXEC) - TO ADD DISPLAY OF SRM CPU BUSY PCT.\n              CHANGED - $JAD PANELS - TO SUPPORT THE ACTION BAR SELECTION ON THE\n                        MAIN DISPLAY.\n              CHANGED - $BLDLIST - MACROS - TO PROVIDE 31-BIT ADDR SUPPORT.\n              ADDED   - $JADPGM - ASM - THIS IS THE ASM VERSION OF $JAD\n                        ***** VERY FAST COMPARED TO $JAD *****\n              ADDED   - @JADPGM - JCL - USED TO ASSEMBLE $JADPGM.\n\n  08/08/95 -\n              CHANGED - JESXIT05 - ASM - TO ADD DISPLAY OF IPL TYPE ON ($Q\n                        SYSTEM) AND ALSO ADD $QDSN=XXXX.\n              CHANGED - $LLACOPY - ASM - ADD BETTER REPORTING.\n              CHANGED - #LLACOPY - JCL - TO ADD SYSIN & SYSPRINT.\n\n  02/10/97 -\n              CHANGED - $D (REXX EXEC) - CLEAN UP THE CODE.  ADD DISPLAY FOR\n                        SYSTEM STORAGE, IPL LOADPARM IN '$D SYS'.  CHECK FOR\n                        'DYNAMIC' APF IN '$D APF'.  ADD NEW FUNCTION TO DISPLAY\n                        NUCLEUS MAP AS '$D NUC', DISPLAY CHPIDS AS '$D CHP' AND\n                        '$D ALL'.\n              ADDED   - $DO - EDIT MACRO (REXX) - TO SYNTAX CHECK A REXX EXEC\n                        FOR DO/SELECT-END PAIRINGS.  ANY HANGING 'DO/SELECT' OR\n                        'END' WILL BE DETECTED AND FLAGGED.  THIS IS GOOD FOR\n                        ANYONE CODING REXX EXECS WITH A LOT OF 'DO/SELECT' AND\n                        'END'.  THIS EDIT MACRO ONLY PRODUCES INFORMATIONAL\n                        MESSAGES AND DOES NOT UPDATE THE EXEC ITSELF.\n              ADDED   - $CKOUT (REXX EXEC) - TO DISPLAY PERTINENT INFO ABOUT\n                        YOUR TSO SESSION AND/OR BATCH TMP.  I USED THIS TO\n                        VERIFY OUT SMF/JES2 EXITS WHEN WE WENT TO MVS 5.2.2.\n                        QUITE INTERESTING LITTLE EXEC.\n              CHANGED - DYNALIST - ASM - TO USE THE NEW UCBSCAN SERVICES IN\n                        MVS 5.X.X.  ALSO CHANGE ALL TPUTS & TGETS TO PUTLINES &\n                        GETLINES SO IT CAN BE RUN UNDER BATCH TMP.\n              ADDED   - $CMDPFX - ASM - TO ASSIGN A COMMAND PREFIX TO A MVS\n                        IMAGE IN A PARALLEL SYSPLEX.  RATHER THAN USING THE\n                        'ROUTE' COMMAND, YOU CAN USE THIS PREFIX FOR ROUTING\n                        A COMMAND TO THE APPROPRIATE SYSTEM.\n              ADDED   - $MPFREPL - ASM - A GENERALIZED MPF EXIT.  THE MESSAGES\n                        BEING HANDLED ARE CODED USING AN IN-LINE MACRO.\n                        PROCESSING CAN ALSO BE LIMITED TO MESSAGES PRODUCED BY\n                        CERTAIN JOBNAMES SPECIFIED BY THIS MACRO.\n              CHANGED - JESXIT05 - ASM - ADDS THE DISPLAY OF LOADPARM IN\n                        $QSYSTEM.  ALSO PUT OUT MESSAGES INDICATING DYNAMIC\n                        APF BEING ACTIVE IF THAT'S THE CASE.\n              ADDED   - $VSAMIXA (REXX EXEC) - MODIFIED VERSION OF $VSAMIDX SO\n                        IT WILL RUN WITH DFSMS 1.X.\n  12/10/98 -\n              ADDED   - $CAL - CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC\n                        DISPLAYS A QUICK POP-UP CALENDAR USING ISPF PANEL.\n                        IT ALSO DISPLAYS THE LAST AND NEXT MONTH AS WELL.\n              CHANGED - $D (REXX EXEC) - ADDED SOME MORE DISPLAYS.  ALSO INCLUDE\n                        THE DATE CONVERSION ROUTINE.\n              ADDED   - $DATE - CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS REXX\n                        FUNCTION DOES DATE CONVERSIONS, INCLUDING RELATIVE DATE\n                        USED FOR CALCULATION.\n              ADDED   - $PARM (REXX EXEC) - CLIST (EXEC) - WRITTEN IN TSO REXX.\n                        THIS EXEC TAKES IN THE PARMS AND DOES SUBSTITUTION ON\n                        THE INPUT CARDS (FROM DDNAME INPUT) TO PRODUCE OUTPUT\n                        DATA FOR SUBSEQUENT USAGE.  SEVERAL RESERVED SYMBOLS\n                        WILL BE SUBSTITUTED AS WELL, I.E. ~JOBNAME~, ~SYSID~.\n                        REXX FUNCTIONS WILL ALSO BE EVALUATED TO PRODUCE THE\n                        OUTPUT IF CODED (THIS CAN BE JUST ANOTHER EXTERNAL REXX\n                        FUNCTION LIKE $DATE)\n              ADDED   - $Q - EDIT MACRO (REXX) - THIS MACRO TAKES A PARM AS A\n                        TSO COMMAND TO BE ISSUED AND THE OUTPUT WILL BE TRAPPED\n                        AND DISPLAYED AS ISPF EDIT NOTE LINES.\n              ADDED   - $SAVE - EDIT MACRO (REXX) - THIS MACRO SAVES DATA BEING\n                        EDITED BY DOING UPDATE IN PLACE FOR A PDS MEMBER.\n                        EXTREMELY USEFUL IF SYS1.PROCLIB IS FULL, AND YOU JUST\n                        NEED TO MAKE MINIMUM CHANGES TO A PROC (UNLESS YOU WANT\n                        TO GO AHEAD AND COMPRESS IT RIGHT THEN AND THERE ...)\n              ADDED   - $WHOHAS (REXX EXEC) - CLIST (EXEC) - THIS REXX EXEC WILL\n                        LIST THE ACCESS LISTS FOR RACF DATA SET PROFILES FOUND\n                        UNDER DSN*.**.  THIS FUNCTION IS VERY MUCH SIMILAR TO\n                        'TSS WHOHAS DSN' COMMAND UNDER TOP SECRET.  IF THE EXEC\n                        IS RUN IN BATCH, THE RACF COMMANDS USED TO RE-BUILD ALL\n                        OF THE PROFILES AS DISPLAYED IN THE OUTPUT IS ALSO\n                        PRODUCED.\n              ADDED   - $X - EDIT MACRO (REXX) - THIS MACRO READS THE MEMBER\n                        BEING EDITED AND EXECUTES IT AS A CLIST/EXEC.  EXECUTION\n                        PARMS ARE ALLOWED AS WELL.  THIS DOES NOT REQUIRED THE\n                        MEMBER TO BE SAVED FIRST.  EXTREMELY USEFUL IF YOU'RE\n                        DOING A LOT OF CLIST/EXEC CODING AND DEBUGGING.\n  12/01/00 -\n              CHANGED - SEEK - ASM - TO DISPLAY THE CURRENT LINKLST SET.\n              ADDED   - ENQMON - ASM - TO DISPLAY AND LOG ENQ CONTENTIONS UNDER\n                        GRS. THIS PROGRAM TRIES TO MIMICK WHAT MIM DOES WITH\n                        THE EXCEPTION OF JOB REQUEUE FUNCTION.  SEE PROGRAM\n                        COMMENTS FOR DETAIL.\n              CHANGED - $D (REXX EXEC) - TO CORRECTLY DISPLAY THE CURRENT\n                        LINKLIST SET.\n              ADDED   - $CPU (REXX EXEC) - THIS IS A CPU MONITOR DISPLAY EXEC.\n                        THE CPU UTILIZATION IS DISPLAYED IN GRAPHICAL FORMAT\n                        USING ISPF PANELS WITH DYNAMIC COLOR.  THE DATA IS\n                        WRAPPED AROUND ON THE SCREEN FOR COMPARISON.  PRETTY\n                        COLORS !!!!\n              ADDED   - $INFO (REXX EXEC).  THIS IS A GENERAL SRM INFO DISPLAY\n                        EXEC.  THE CPU UTILIZATION PLUS ALL OTHER SRM\n                        INDICATORS ARE SHOWN. ANY EXCEPTION CONDITION WILL\n                        CHANGE EITHER SOME DISPLAY COLORS OR TEXT DISPLAY.\n                        SOME OF THE INFO INCLUDES PAGE FAULT RATE, MIGR AGE,\n                        AFQ, UIC, ETC...  THE CPU UTIL IS ALSO DISPLAYED IN A\n                        GRAPHICAL FORMAT.  AGAIN, PRETTY COLORS !!!\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IEASYS": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x07\\x01\\x171\\x7f\\x01 \\x07\\x7f\\x18(\\x03\\xdf\\x02\\xd8\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2017-11-13T00:00:00", "modifydate": "2020-03-17T18:28:07", "lines": 991, "newlines": 728, "modlines": 0, "user": "VINHVU"}, "text": "/* ------------------------ REXX ------------------------------ *\n *                                                              *\n * This exec displays IEASYSxx variables.  It also list out     *\n * the PARMLIB where these members came from.  Great for        *\n * diagnostics and chasing through what parm members got pulled *\n * based on IPL specfication.                                   *\n *                                                              *\n * Syntax - $IEASYS opt_parm (B=Browse - Default, V=View,       *\n *                            E=Edit)                           *\n *                                                              *\n * Chg - VNV - 11/10/04 -  Added the first time.                *\n *       VNV - 05/26/10 -  Added new fields for z/OS r1.11      *\n *       VNV - 09/20/12 -  Added display of IODF Dsname and     *\n *                         CPU Model.  Also check to see if     *\n *                         ISPF is run in batch, if so, then    *\n *                         displayed lines will be written to   *\n *                         SYSOUT (instead of being browse'd).  *\n *       VNV - 04/15/13 -  Added IP Addr.                       *\n *       VNV - 05/20/13 -  Added Active CSS and Current/IPL'ed  *\n *                         SSCHS (0 or 1 on GDPS LPARs)         *\n *       VNV - 03/07/14 -  Changed code to include z/OS 2.1     *\n *       VNV - 06/03/14 -  Changed Storage sizes to use comma-  *\n *                         formatted numbers                    *\n *       VNV - 10/03/14 -  Include IEASYS00 automatically for   *\n *                         \"SYS\".                               *\n *       VNV - 10/09/14 -  Add AUTOR, CATALOG, HZS, IXGCNF,     *\n *                         PAGESCM, WARNUND, GTZ, HZSPROC,      *\n *                         and fix IQP (does use member). Also  *\n *                         change ZZ to call ZAPZIP             *\n *       VNV - 07/31/15 -  Add totReal (coming from RIT)        *\n *       VNV - 08/19/15 -  Add DNSNAME to IPAddr                *\n *       VNV - 09/28/15 -  Add IODF creation date/time          *\n *       VNV - 03/23/16 -  Add SMFLIM and IEFOPZ (z/OS 2.2)     *\n *       VNV - 12/14/16 -  Changes to pull in the IPaddr for    *\n *                         ASPAC LPARs that don't use TCPIP as  *\n *                         Stc name.                            *\n *       VNV - 08/15/17 -  Add call to IWMQVS to get the        *\n *                         dynamic upgraded CEC                 *\n *       VNV - 10/26/17 -  Adding new parm for zOS 2.3, IZU,    *\n *                         RACF, FXE.                           *\n *       VNV - 09/24/18 -  Change to get the IP address as      *\n *                         resolved by Hostname (same as the    *\n *                         Hometest command).                   *\n *       VNV - 10/02/18 -  Add ICSF, ICSFPROC and OSPROTECT,    *\n *                         and SMFTBUFF).                       *\n *       VNV - 03/17/20 -  Add z14 ZR1 and z16 Hardware, plus   *\n *                         RUCSA and BOOST for z/OS 2.4         *\n * ------------------------------------------------------------ */\n\nif sysvar(SYSISPF) \u00ac='ACTIVE' then do\n   parse source . . exec_Name .\n   say exec_Name 'can only run under ISPF.'\n   exit\n   end\n\n$version = \"V06.00\"\n\ninDent   = 29                 /* indentation */\naddress ISPEXEC\n\narg viewMode .\nselect\n   when viewMode = 'B' then viewCmd = 'BROWSE'\n   when viewMode = 'V' then viewCmd = 'VIEW'\n   when viewMode = 'E' then viewCmd = 'EDIT'\n   otherwise do\n      zedsmsg = 'View mode = BROWSE'\n      zedlmsg = 'Invalid view mode - BROWSE assumed'.\n      'SETMSG MSG(ISRZ001)'\n      viewCmd = 'BROWSE'\n      end\n   end\n\nnumeric digits 256\ncvt     = Get_Stor('10'x)\necvt    = Get_Stor(cvt,'8C'x)\n\ntempDd  = '$#$'||STRIP(TIME(\"S\"))\n\nx = outtrap(\"trap.\",\"*\")\naddress TSO\n\"FREE  F(\"tempDd\")\"\n\"ALLOC F(\"tempDd\") SPACE(10 5) TRA DSORG(PS) LRECL(1330) RECF(F B)\"\n\"MAKEBUF\"\ntempRc = rc\nx= outtrap(\"off\")\naddress ISPEXEC\n\"LMINIT DATAID(MYDD) DDNAME(\"tempDd\")\"\n\nx = Get_IEASYS()\nx = Get_All_Symbols()\n\naddress TSO\n\"EXECIO 0 DISKW\" tempDd \"(FINIS\"\n\"DROPBUF\"\naddress ISPEXEC\n\nif SYSVAR(\"SYSENV\") = \"BACK\" then do\n   address TSO \"EXECIO * DISKR\" tempDd \"(FINIS STEM outLine\"\n   do i = 1 to outLine0\n      say STRIP(VALUE(\"outLine\"||i),\"T\")\n      end\n   end\nelse do\n   viewCmd \"DATAID(\"myDd\")\"\n   \"LMFREE DATAID(\"myDd\")\"\n   end\n\naddress TSO \"FREE F(\"tempDd\")\"\n\nexit\n\n\n\nGet_IEASYS:\n\n/* ------------------------------------------------------------ *\n * Get contents of IPA: IEASYS and other info used during IPL   *\n * ------------------------------------------------------------ */\n\nipa       = Get_Stor(ecvt,'188'x)\nsysid     = STRIP(Get_Stor(cvt,'154'x,8))\nucbadd    = Get_Stor(cvt,'30'x)\nucbnum    = C2X(Get_Stor(ucbadd,'4'x,2))\nucbvol    = Get_Stor(ucbadd,'1c'x,6)\ncvtpre    = D2C(C2D(cvt)-40)\ncvtixavl  = Get_Stor(cvt,'7C'x)\niociovtp  = Get_Stor(cvtixavl,'D0'x)\ncssId     = Get_Stor(cvtixavl,'113'x,1)\ncda       = Get_Stor(iociovtp,'18'x)\niodfDsn   = STRIP(Get_Stor(cda,'20'x,44))\niodfDate  = STRIP(Get_Stor(cda,156,8))\niodfTime  = STRIP(Get_Stor(cda,164,8))\niodfDesc  = STRIP(Get_Stor(cda,172,16))\n$shid     = Get_Stor(cvt,'42C'x,4)\n$cpumdl   = Get_Stor($shid,'1A'x,6)\".\"Get_Stor($shid,'20'x,3)\ngda       = Get_Stor(cvt,'230'x)\ncsd       = Get_Stor(cvt,'294'x)\nrcvt      = Get_Stor(cvt,'3E0'x)\npccavt    = Get_Stor(cvt,'2FC'x)\nSMCAADD   = Get_Stor(cvt,'C4'x)\n\ngdpsIni   = Get_Stor(iociovtp,'10B'x,1)\ngdpsAct   = C2D(Get_Stor(iociovtp,'170'x,1))\n\nif gdpsIni = '00'x then do      /* not config with alternate schset */\n   gdpsAct = \" \"\n   gdpsIni = \" \"                /* No channel set used */\n   gdpsSwp = \" \"                /* Of course no-swap   */\n   end\nelse do\n   if gdpsIni = gdpsAct then do      /* otherwise check for swap    */\n      gdpsSwp = \"N\"\n      end\n   else do\n      gdpsSwp = \"Y\"\n      end\n   end\n\nif gdpsAct > 1 then do\n   gdpsAct = \" \"     /* APAR OA32339 not applied */\n   gdpsSwp = \" \"\n   end\n\n$opsys    = MVSVAR('SYSOPSYS')\n$jeslvl   = SYSVAR('SYSJES')\n$jesnode  = SYSVAR('SYSNODE')\n\nparse var $opsys . $ovv '.' $rel '.' .\n\nif $rel > 10 | $ovv > 1 then $mvs1_11 = 1\nelse $mvs1_11 = 0\n\n$mvsrel = $ovv||$rel\n\ngetInit    = SOCKET('INITIALIZE','TCPINFO',1)\nparse var getInit INIT_RC getSubTaskid getMaxDesc getService\nif INIT_RC = 1004 then do\n   tsab    = Get_Stor(ecvt,176)\n   tsablen = C2D(Get_Stor(tsab,4,2))\n   tsebnum = (tsablen-64)/128\n   do i=1 to tsebnum\n      tseb    = D2C(C2D(tsab)+64+(i-1)*128)\n      if Get_Stor(tseb) <> \"TSEB\" then leave\n      tcpasid = Get_Stor(tseb,56,2)\n      if C2X(tcpasid) <> 0 then do\n         stcName = Get_Stor(tseb,16,8)\n         getInit = SOCKET('INITIALIZE','TCPINFO',1,stcName)\n         parse var getInit INIT_RC getSubTaskid getMaxDesc getService\n         if INIT_RC = 0 then leave\n         end\n      end\n   end\n\nif INIT_RC =  0 then do\n   getHostid = SOCKET('GETHOSTID')\n   getHostNm = SOCKET('GETHOSTNAME')\n   getDomain = SOCKET('GETDOMAINNAME')\n   parse var getHostid tcpRc tcpAddr\n   parse var getHostNm tcpRc tcpName\n   parse var getDomain tcpRc tcpDomain\n   $fullDns  = STRIP(tcpName'.'tcpDomain)\n   getNewIP  = SOCKET('GETHOSTBYNAME',$fullDns)\n   parse var getNewIP  tcpRc $pingAdd\n   if WORD($pingAdd,1) = \"EHOSTNOTFOUND\" then $pingAdd = tcpAddr\n   getTerm   = SOCKET('TERMINATE')\n   $pingAdd = $pingAdd \"-\" $fullDns \"(static:\" tcpAddr\")\"\n   end\nelse do\n   $fullDns = \"\"\n   $pingAdd = \"\"\n   end\n\n/* --- Call IWMQVS  ------------------------------------------------- */\n\nQVS_totL   = 512\nQVS_len    = D2X(QVS_totL)\nQVS_len    = RIGHT(X2C(QVS_len),4,D2C(0))\nQVS_Out    = QVS_len||COPIES('00'X,QVS_totL-4)\n\naddress linkpgm 'IWMQVS QVS_Out'\n\nIf rc = 0 then do\n   cec_type   = SUBSTR(QVS_Out,9,4)\n   cec_model  = STRIP(SUBSTR(QVS_Out,13,16))\n   select\n      when cec_type = '2064' then cec_desc = '    z Series 900'\n      when cec_type = '2066' then cec_desc = '    z Series 800'\n      when cec_type = '2084' then cec_desc = '    z Series 990'\n      when cec_type = '2086' then cec_desc = '    z Series 890'\n      when cec_type = '2094' then cec_desc = '    System z9 EC'\n      when cec_type = '2096' then cec_desc = '    System z9 BC'\n      when cec_type = '2097' then cec_desc = '   System z10 EC'\n      when cec_type = '2098' then cec_desc = '   System z10 BC'\n      when cec_type = '2817' then cec_desc = ' zEnterprise 196'\n      when cec_type = '2818' then cec_desc = ' zEnterprise 114'\n      when cec_type = '2827' then cec_desc = 'zEnterprise EC12'\n      when cec_type = '2828' then cec_desc = 'zEnterprise BC12'\n      when cec_type = '2964' then cec_desc = '    z System z13'\n      when cec_type = '2965' then cec_desc = '   z System z13s'\n      when cec_type = '3906' then cec_desc = '    z System z14'\n      when cec_type = '3907' then cec_desc = 'z System z14 ZR1'\n      when cec_type = '8561' then cec_desc = '    z System z15'\n      otherwise                   cec_desc = ' Unkwn CPU model'\n      end\n   if SUBSTR($cpumdl,8,3) <> cec_model then do\n      $cpumdl = $cpumdl\"(\"cec_model\")\"\n      end\n   $cpumdl    = $cpumdl \"-\" STRIP(cec_desc)\n   end\n\nIPLTI  = C2D(Get_Stor(SMCAADD,'150'x))%360000\nIPLTRM = C2D(Get_Stor(SMCAADD,'150'x))//360000\nIPLTD  = RIGHT(IPLTRM%6000,2,'0')             /* Find # of Minutes  */\n\nIPLT   = IPLTI||'.'||IPLTD\nIPLD   = C2X(Get_Stor(SMCAADD,'154'x))\n\nIPLYEAR  = substr(IPLD,3,2)\nIPLDAY   = substr(IPLD,5,3)\n\nif substr(IPLD,1,2) = '00' then IPLYEAR = IPLYEAR+1900\nelse IPLYEAR = IPLYEAR+2000\n\nIPL_R   = $DATE('J2R',IPLYEAR||IPLDAY)\nTODAY_J = $DATE('G2J',,\n          substr(DATE(S),5,2)||'/'||,\n          substr(DATE(S),7,2)||'/'||substr(DATE(S),1,4))\nTODAY_R = $DATE('J2R',TODAY_J)\n\nif TODAY_R = IPL_R then AGOS = '(Today)'\n   else if (TODAY_R - IPL_R) = 1 then AGOS = '(Yesterday)'\n      else AGOS = '('||Value((TODAY_R - IPL_R))||' days ago)'\n\niText =  Format(IPLT,2,2) AGOS,\n         'on' $DATE('R2D',IPL_R)||',' IPLYEAR||'.'||IPLDAY,\n         '('||$DATE('J2G',IPLYEAR||IPLDAY)||')'\n\nx=W()\nt=(\"** Listing of IPA & IEASYSxx variables on\" DATE(U)||\"-\"TIME() \"**\")\nx=W($version CENTER(t,72))\nx=W()\nt='** On' sysid 'IPLed from' ucbvol '('ucbnum') **'\nx=W(CENTER(t,80))\nt='** Opsys:' $opsys ' JES2node:' $jesnode ' JES2lvl:' $jeslvl '**'\nx=W(CENTER(t,80))\nx=W()\n\nx=W(\"** Active_CSS   =\" C2X(cssId))\nx=W(\"** ArchLevel    =\" STRIP(Get_Stor(ipa,'85F'x,1)))\nx=W(\"** CPU_Model    =\" STRIP($cpumdl))\nx=W(\"** EDT_Id       =\" STRIP(Get_Stor(ipa,'75'x,2)))\nx=W(\"** HW_Name      =\" STRIP(Get_Stor(ipa,'18'x,8)))\n\nieaSymList = STRIP(Get_Stor(ipa,'120'x,63))\nx=W(\"** IEASYM_Suff  =\" ieaSymList)\n\nx=W(\"** IEASYS_Suff  =\" STRIP(Get_Stor(ipa,'A0'x,63)))\nx=W(\"** IODF_Hlq     =\" STRIP(Get_Stor(ipa,'63'x,8)))\nx=W(\"** IODF_Suff    =\" STRIP(Get_Stor(ipa,'60'x,2)))\nx=W(\"** IODF_Dsname  =\" STRIP(iodfDsn))\nx=W(\"** IODF_Created =\" STRIP(iodfTime) \"on\" STRIP(iodfDate) \"-\" ,\n                      \"Description: '\"STRIP(iodfDesc)\"'\")\nx=W(\"** IPL_Time     =\" STRIP(iText))\nx=W(\"** Host_IP_Addr =\" STRIP($pingAdd))\nx=W(\"** LoadParm     =\" STRIP(Get_Stor(ipa,'10'x,8)))\nx=W(\"** LoadParm_DSN =\" STRIP(Get_Stor(ipa,'30'x,44)))\nx=W(\"** Lpar_Name    =\" STRIP(Get_Stor(ipa,'20'x,8)))\nx=W(\"** Mstrcat_Dsn  =\" STRIP(Get_Stor(ipa,'EA'x,44)))\nx=W(\"** Mstrcat_Vol  =\" STRIP(Get_Stor(ipa,'E0'x,6)))\nx=W(\"** Nucleus_Id   =\" STRIP(Get_Stor(ipa,'17'x,1)))\n\nonlineStor = Get_Stor(cvt,'358'x)\n\npvt     = Get_Stor(cvt,356)\nrit     = Get_Stor(pvt,4)\ntotReal = Get_Stor(rit,296,8)\n\nonlCp   = C2D(Get_Stor(csd,212,4))\n\ntotalCp = 0\nzaapCp  = 0\nziipCp  = 0\nnextCp  = D2C(C2D(pccavt)-4)\ndo until totalCp = onlCp\n   nextCp = D2C(C2D(nextCp)+4)\n   pcca   = Get_Stor(nextCp)\n   if C2D(pcca) = 0 then iterate\n   pccaSer  = Get_Stor(pcca,4,12)\n   pccaId   = Get_Stor(pcca,16,2)\n   pccaAttr = Get_Stor(pcca,376,1)\n   if BITAND(pccaAttr,'01'x) = '01'x then zaapCp = zaapCp + 1\n   if BITAND(pccaAttr,'04'x) = '04'x then ziipCp = ziipCp + 1\n   totalCp = totalCp + 1\n   end\n\nx=W(\"** Onlne_cp     =\" STRIP(onlCp))\nx=W(\"** Onlne_ZAAPcp =\" STRIP(zaapCp))\nx=W(\"** Onlne_ZIIPcp =\" STRIP(ziipCp))\n\ntempText = STRIP(FormatNumber(C2D(onlineStor)/1024)||'M')\ntotReal  = STRIP(FormatNumber(C2D(totReal)/(1024*1024))||'M')\nx=W(\"** Onlne_Stor   =\" tempText \"(\"totReal\")\")\n\nsecDsn   = Get_Stor(rcvt,56,44)\nsecType  = Get_Stor(rcvt,,4)\n\nselect\n   when secType = 'RCVT' then secSoft = 'RACF'\n   when secType = 'RTSS' then secSoft = 'TopSecret'\n   otherwise secSoft = sectype\n   end\n\nx=W(\"** SCHS_Active  =\" gdpsAct)\nx=W(\"** SCHS_Init    =\" gdpsIni)\nx=W(\"** Security     =\" secSoft)\nx=W(\"** Security_Db  =\" secDsn)\n\ncsasize  = FormatNumber((C2D(Get_Stor(gda,'70'x))%1024))||'K'\ncsaesize = FormatNumber((C2D(Get_Stor(gda,'80'x))%1024))||'K'\nsqasize  = FormatNumber((C2D(Get_Stor(gda,'94'x))%1024))||'K'\nsqaesize = FormatNumber((C2D(Get_Stor(gda,'9C'x))%1024))||'K'\nprvsize  = FormatNumber((C2D(Get_Stor(gda,'A4'x))%1024))||'K'\nprvesize = FormatNumber((C2D(Get_Stor(gda,'AC'x))%1024))||'K'\n\nx=W('** Stor_CSA     =' RIGHT(csasize,10))\nx=W('** Stor_CSA_E   =' RIGHT(csaesize,10))\nx=W('** Stor_SQA     =' RIGHT(sqasize,10))\nx=W('** Stor_SQA_E   =' RIGHT(sqaesize,10))\nx=W('** Stor_PRV     =' RIGHT(prvsize,10))\nx=W('** Stor_PRV_E   =' RIGHT(prvesize,10))\n\nx=W('** Sysplex_Name =' Get_Stor(ecvt,'8'x,8))\n\nx=W(\"** VM_Userid    =\" STRIP(Get_Stor(ipa,'28'x,8)))\nx=W(\"** Parmlibs     =\")\n\nparmNum.   = \"\"\nct         = 0\n\nparmLibNum = C2D(Get_Stor(ipa,'856'x,2))\nlibOff     = 416\ndo parmLibNum\n   if BITAND(Get_Stor(ipa,libOff+63,1),'80'x) = '80'x then do\n      x=W(COPIES(' ',17) Get_Stor(ipa,libOff,44),\n                         Get_Stor(ipa,libOff+45,6))\n      ct = ct + 1\n      parmNum.ct = \"parmDD\"||RIGHT(ct,2,0)      ,\n                 STRIP(Get_Stor(ipa,libOff,44)) ,\n                 STRIP(Get_Stor(ipa,libOff+45,6))\n      end\n   libOff  = libOff + 64\n   end\nx=W()\n\n/* ------------------------------------------------------------ *\n * Found all PARMLIB as coming off the IPL.  Now allocate them  *\n * all so they can be used later using LIMINIT ISPF service.    *\n * ------------------------------------------------------------ */\n\naddress ISPEXEC\ndo i=1 to ct\n   t_dd  = WORD(parmNum.i,1)\n   t_dsn = WORD(parmNum.i,2)\n   t_vol = WORD(parmNum.i,3)\n   \"LMINIT DATAID(\"||t_dd||\") DATASET('\"||t_dsn||\"') \"||,\n           \"VOLUME(\"||t_vol||\")\"\n   \"LMOPEN DATAID(\"VALUE(t_dd)\")\"\n   parmNum.i = VALUE(t_dd) t_dsn t_vol\n   end\naddress TSO\n\n/* ------------------------------------------------------------ *\n * Process IEASYM list first.                                   *\n * ------------------------------------------------------------ */\n\nx=W(COPIES(' ',5) '* IEASYM   * SYM      =' ieaSymList)\nif SUBSTR(ieaSymList,1,1) = '(' then do\n   parse var ieaSymList '(' ieaSymList ')' .\n   end\nieaSymList = TRANSLATE(ieaSymList,' ',',')\nif WORDS(ieaSymList) > 0 then do\n   do j=1 to WORDS(ieaSymList)\n      if LENGTH(WORD(ieaSymList,j)) = 2 then do\n         indivParmMem = \"IEASYM\"||WORD(ieaSymList,j)\n         indivLib     = Obtain_Parm(indivParmMem)\n         x=W(COPIES(' ',inDent) indivLib'('indivParmMem')')\n         end\n      end                  /* do j=1     */\n   end                     /* if WORDS   */\n\n\ncount = 1\nvarNum = 0\n\nx = Get_PDE_Data('SYS','A80'x,'IEASYS')\nx = Get_PDE_Data('ALLOC','868'x,'ALLOC')\nx = Get_PDE_Data('APF','870'x,'IEAAPF')\nx = Get_PDE_Data('APG','878'x)\nif $mvsrel > 0112 then x = Get_PDE_Data('AUTOR','B40'x,'AUTOR')\nif $mvs1_11 then  x = Get_PDE_Data('AXR','B18'x,'AXR')\nx = Get_PDE_Data('BLDL','880'x)\nx = Get_PDE_Data('BLDLF','888'x)\nif $mvsrel > 0203 then x = Get_PDE_Data('BOOST','BD8'x)\nif $mvsrel > 0112 then x = Get_PDE_Data('CATALOG','B48'x,'IGGCAT')\nif $mvs1_11 then  x = Get_PDE_Data('CEA','B08'x,'CEAPRM')\nx = Get_PDE_Data('CEE','AF0'x,'CEEPRM')\nx = Get_PDE_Data('CLOCK','890'x,'CLOCK')\nx = Get_PDE_Data('CLPA','898'x)\nx = Get_PDE_Data('CMB','8A0'x)\nx = Get_PDE_Data('CMD','8A8'x,'COMMND')\nx = Get_PDE_Data('CON','8B0'x,'CONSOL')\nx = Get_PDE_Data('CONT','8B8'x)\nx = Get_PDE_Data('COUPLE','8C0'x,'COUPLE')\nif $mvs1_11 then  x = Get_PDE_Data('CPCR','B30'x)\nx = Get_PDE_Data('CPQE','8C8'x)\nx = Get_PDE_Data('CSA','8D0'x)\nx = Get_PDE_Data('CSCBLOC','8D8'x)\nx = Get_PDE_Data('CVIO','8E0'x)\nif $mvs1_11 then  x = Get_PDE_Data('DDM','B38'x)\nx = Get_PDE_Data('DEVSUP','8E8'x,'DEVSUP')\nx = Get_PDE_Data('DIAG','8F0'x,'DIAG')\nx = Get_PDE_Data('DRMODE','AE8'x)\nx = Get_PDE_Data('DUMP','8F8'x)\nx = Get_PDE_Data('DUPLEX','900'x)\nx = Get_PDE_Data('EXIT','908'x,'EXIT')\nx = Get_PDE_Data('FIX','910'x,'IEAFIX')\nif $mvsrel > 0202 then x = Get_PDE_Data('FXE','B98'x,'FXEPRM')\nx = Get_PDE_Data('GRS','918'x)\nx = Get_PDE_Data('GRSCNF','920'x,'GRSCNF')\nx = Get_PDE_Data('GRSRNL','928'x,'GRSRNL')\nif $mvsrel > 0113 then x = Get_PDE_Data('GTZ','B70'x,'GTZPRM')\nif $mvs1_11 then  x = Get_PDE_Data('HVCOMM','B10'x)\nx = Get_PDE_Data('HVSHARE','AD8'x)\nif $mvsrel > 0113 then x = Get_PDE_Data('HZS','B68'x,'HZSPRM')\nif $mvsrel > 0113 then x = Get_PDE_Data('HZSPROC','B78'x)\nx = Get_PDE_Data('ICS','930'x,'IEAICS')\nif $mvsrel > 0201 then x = Get_PDE_Data('IEFOPZ','B88'x)\nx = Get_PDE_Data('IKJTSO','AC0'x,'IKJTSO')\nx = Get_PDE_Data('ILMLIB','AB0'x)\nx = Get_PDE_Data('ILMMODE','AB8'x)\nx = Get_PDE_Data('IOS','938'x,'IECIOS')\nx = Get_PDE_Data('IPS','940'x,'IEAIPS')\nif $mvsrel > 0202 then x = Get_PDE_Data('ICSF','BC0'x)\nif $mvsrel > 0202 then x = Get_PDE_Data('ICSFPROC','BC8'x)\nif $mvsrel > 0113 then x = Get_PDE_Data('IQP','B28'x,'IQPPRM')\nif $mvsrel > 0112 then x = Get_PDE_Data('IXGCNF','B50'x,'IXGCNF')\nif $mvsrel > 0202 then x = Get_PDE_Data('IZU','BA0'x,'IZUPRM')\nif $mvs1_11 then  x = Get_PDE_Data('LFAREA','B00'x)\nx = Get_PDE_Data('LICENSE','AC8'x)\nx = Get_PDE_Data('LNK','948'x,'LNKLST')\nx = Get_PDE_Data('LNKAUTH','950'x)\nx = Get_PDE_Data('LOGCLS','958'x)\nx = Get_PDE_Data('LOGLMT','960'x)\nx = Get_PDE_Data('LOGREC','968'x)\nx = Get_PDE_Data('LPA','970'x,'LPALST')\nx = Get_PDE_Data('MAXCAD','978'x)\nx = Get_PDE_Data('MAXUSER','980'x)\nx = Get_PDE_Data('MLPA','988'x,'IEALPA')\nx = Get_PDE_Data('MSTRJCL','990'x,'MSTJCL')\nx = Get_PDE_Data('NONVIO','998'x)\nx = Get_PDE_Data('NSYSLX','9A0'x)\nx = Get_PDE_Data('NUCMAP','9A8'x)\nx = Get_PDE_Data('OMVS','9B0'x,'BPXPRM')\nx = Get_PDE_Data('OPI','9B8'x)\nx = Get_PDE_Data('OPT','9C0'x,'IEAOPT')\nif $mvsrel > 0202 then x = Get_PDE_Data('OSPROT','BB8'x)\nx = Get_PDE_Data('PAGE','9D0'x)\nif $mvsrel > 0113 then x = Get_PDE_Data('PAGESCM','B58'x)\nx = Get_PDE_Data('PAGNUM','9D8'x)\nx = Get_PDE_Data('PAGTOTL','9E0'x)\nx = Get_PDE_Data('PAK','9E8'x,'IEAPAK')\nx = Get_PDE_Data('PLEXCFG','9F0'x)\nx = Get_PDE_Data('PRESCPU','AF8'x)\nx = Get_PDE_Data('PROD','9F8'x,'IFAPRD')\nx = Get_PDE_Data('PROG','A00'x,'PROG')\nx = Get_PDE_Data('PURGE','A08'x)\nif $mvsrel > 0202 then x = Get_PDE_Data('RACF','B90'x,'IRRPRM')\nx = Get_PDE_Data('RDE','A10'x)\nx = Get_PDE_Data('REAL','A18'x)\nx = Get_PDE_Data('RER','A20'x)\nx = Get_PDE_Data('RSU','A28'x)\nx = Get_PDE_Data('RSVNONR','A30'x)\nx = Get_PDE_Data('RSVSTRT','A38'x)\nx = Get_PDE_Data('RTLS','AA0'x,'CSVRTL')\nif $mvsrel > 0203 then x = Get_PDE_Data('RUCSA','BD0'x)\nx = Get_PDE_Data('SCH','A40'x,'SCHED')\nx = Get_PDE_Data('SMF','A48'x,'SMFPRM')\nif $mvsrel > 0202 then x = Get_PDE_Data('SMFTBUFF','BA8'x)\nif $mvsrel > 0201 then x = Get_PDE_Data('SMFLIM','B80'x)\nx = Get_PDE_Data('SMS','A50'x,'IGDSMS')\nx = Get_PDE_Data('SQA','A58'x)\nx = Get_PDE_Data('SSN','A60'x,'IEFSSN')\nx = Get_PDE_Data('SVC','A68'x,'IEASVC')\nx = Get_PDE_Data('SWAP','A70'x)\nx = Get_PDE_Data('SYSNAME','A78'x)\nx = Get_PDE_Data('UNI','AA8'x,'CUNUNI')\nx = Get_PDE_Data('VAL','A88'x,'VATLST')\nx = Get_PDE_Data('VIODSN','A90'x)\nx = Get_PDE_Data('VRREGN','A98'x)\nif $mvsrel > 0112 then x = Get_PDE_Data('WARNUND','B60'x)\nif $mvs1_11 then  x = Get_PDE_Data('ZAPZIP','B20'x)\n\n\n\nipadata.0 = count\n\naddress ISPEXEC\ndo i=1 to ct\n   t_dd  = WORD(parmNum.i,1)\n   \"LMCLOSE DATAID(\"t_dd\")\"\n   \"LMFREE  DATAID(\"t_dd\")\"\n   end\naddress TSO\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Routine to parse through the IEASYSxx parm to pick up        *\n * the specified parm.  Anything with two-chacracter long       *\n * is really a suffix that points to a member in the PARMLIB    *\n * concatenation.                                               *\n * ------------------------------------------------------------ */\n\nGet_PDE_Data:\n\nparse arg parmName,parmOff,parmMem\n\nparmName   = LEFT(parmName,8)\ncount      = count + 1\nmyPde      = Get_Stor(ipa,parmOff)\ntempOffset = C2D(parmOff)+4\npdeLeng    = C2D(Get_Stor(ipa,tempOffset,2))\nif pdeLeng > 1024 then pdeLeng = 1024\ntempOffset = C2D(parmOff)+6\norigin     = Get_Stor(ipa,tempOffset,2)\n\nselect\n   when origin = '0000'x then do\n      parmSupplied = 0\n      pdeSource = '*' '( dflt )' '*'\n      end\n   when origin = 'FFFF'x then do\n      parmSupplied = 0\n      pdeSource = '*' '( oper )' '*'\n      end\n   otherwise do\n      parmSupplied = 1\n      syspParm  = \"IEASYS\"origin\n      fromParm  =  Obtain_Parm(syspParm)\n      pdeSource = '*' 'IEASYS'origin '*'\n      end\n   end\n\nif C2D(myPde) <> 0 then do\n   pdeText = Get_Stor(myPde,,pdeLeng)\n   end\nelse do\n   pdeText = ''\n   end\n\nipaData.count = parmName \"=\" pdeText\n\nvarNum = varNum + 1\nx=W()\nx=W(RIGHT(varNum,4)'.' pdeSource ipaData.count)\nif parmSupplied then do\n   x=W(COPIES(' ',inDent) COPIES('=',54))\n   x=W(COPIES(' ',inDent) fromParm'('syspParm')    ** IEASYS **')\n   x=W(COPIES(' ',inDent) COPIES('=',54))\n   end\n\n/* ------------------------------------------------------------ *\n * For any suffix list, pick out the suffixes and try to        *\n * figure out where these members came from using the PARMLIB   *\n * concatenation.                                               *\n * ------------------------------------------------------------ */\n\nif parmMem <> \"\" then do\n   if SUBSTR(pdeText,1,1) = '(' then do\n      parse var pdeText '(' pdeText ')' .\n      end\n\n   /* ------------------------------------------------------------ *\n    * IEASYS00 is always included no matter what                   *\n    * ------------------------------------------------------------ */\n\n   if parmName = \"SYS\" then pdeText = \"00\" pdeText\n\n   pdeText = TRANSLATE(pdeText,' ',',')\n   if WORDS(pdeText) > 0 then do\n      do j=1 to WORDS(pdeText)\n         if LENGTH(WORD(pdeText,j)) = 2 then do\n            indivParmMem = parmMem||WORD(pdeText,j)\n            indivLib     = Obtain_Parm(indivParmMem)\n            if indivParmMem = \"IEASYS00\" then flg = \"      ** Dflt **\"\n            else flg = \"\"\n            x=W(COPIES(' ',inDent) indivLib'('indivParmMem')' flg)\n            end\n         end                  /* do j=1     */\n      end                     /* if WORDS   */\n   end                        /* if parmMem */\nreturn 0\n\n\n/* ------------------------------------------------------------ *\n * Collects all Static Symbols.                                 *\n * ------------------------------------------------------------ */\n\nGet_All_Symbols:\nsymTable  = Get_Stor(ecvt,'128'x)\nnumSym    = C2D(Get_Stor(symTable,2,2))\nsymAddr   = D2C(C2D(symTable)+4)\nsymBols.  = ''\n\nsymBols.0 = numSym\n\ndo i=1 to numSym\n   t = (i-1)*16\n   nextSym  = D2C(C2D(symAddr)+t)\n   s_off    = C2D(Get_Stor(nextSym,0,4))\n   s_leng   = C2D(Get_Stor(nextSym,4,4))\n   v_off    = C2D(Get_Stor(nextSym,8,4))\n   v_leng   = C2D(Get_Stor(nextSym,12,4))\n   mySym    = LEFT(STRIP(Get_Stor(symAddr,s_off,s_leng)),10)\n   if v_leng > 0 then do\n      symBols.i =  mySym \"=\" Get_Stor(symAddr,v_off,v_leng)\n      end\n   else do\n      symBols.i =  mySym \"= (blank)\"\n      end\n   end\n\nx=W()\nx=W(\"** Listing of SYMBOLICS **\")\nx=W()\n\ndo k=1 to symBols.0\n   x=W(RIGHT(k,4)'.' symBols.k)\n   end\n\nx=W()\n\nreturn 0\n\nObtain_Parm:\narg myInput\n\nfoundIt = 0\n\naddress ISPEXEC\ndo i=1 to ct\n   t_dd  = WORD(parmNum.i,1)\n   \"LMMFIND DATAID(\"t_dd\") MEMBER(\"myInput\")\"\n   select\n      when rc=0 then do\n         foundIt = 1\n         leave\n         end\n      when rc=8 then nop\n      otherwise do\n         x=W('Error doing LMMFIND on' WORD(parmNum.i,2))\n         leave\n         end\n      end\n   end\naddress TSO\nif foundIt then\n   return WORD(parmNum.i,2)\nelse\n   return '** Member not found ** '\n\nW: procedure expose tempDd\n\nparse arg outPutLine\nqueue outPutLine\naddress TSO \"EXECIO 1 DISKW\" tempDd\n\nreturn 0\n\n\n/* ------------------------------------------------------------ *\n * This procedure format a number with ','.                     *\n * ------------------------------------------------------------ */\n\nFormatNumber: procedure\n   parse value arg(1) with whole \".\" decs\n\n   formattedNumber = STRIP(REVERSE(TRANSLATE( \"abc,def,ghi,jkl,mno\",,\n                                   REVERSE(whole),,\n                                   \"abcdefghijklmno\",\",\")),\"L\",\",\")\n\n  if decs <> \"\" then\n     formattedNumber = formattedNumber || \".\" || decs\nreturn formattedNumber\n\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. cvtPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) offSet in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nGet_Stor: procedure\n\nparse arg area,offSet,leng\n\nif ARG(2,'O') then offSet=0\n\nif ARG(3,'O') then leng=4\n\nif DATATYPE(area) = 'CHAR' then do\n   area =  C2D(area)\n   End\n\nif DATATYPE(offSet) = 'CHAR' then do\n   offSet =  C2D(offSet)\n   End\n\nreturn  STORAGE((D2X(area+offSet)),leng)\n\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This REXX exec will do date conversion:                     */\n/*                                                                  */\n/*      call Format:  DATE = $DATE(CODE,INPUT)                      */\n/*                                                                  */\n/*          CODE = 'J2G' - Julian to Gregorian date                 */\n/*          CODE = 'G2J' - Gregorian date to Julian                 */\n/*          CODE = 'J2R' - Julian to Relative date                  */\n/*          CODE = 'R2J' - Relative to Julian date                  */\n/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */\n/*                                                                  */\n/*          INPUT = either 'mm/dd/YYYY' or 'YYYYDDD' or 'nnnn'      */\n/*                                                                  */\n/*      Errors during processing will return 0 as result and        */\n/*      an error message will be displayed as well.                 */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n$DATE: procedure\n\nparse Upper arg func,date\n\nif date = '' then retDate = 0\nelse select\n      when func = 'J2G' then retDate = J2G_PROC(date)\n      when func = 'G2J' then retDate = G2J_PROC(date)\n      when func = 'J2R' then retDate = J2R_PROC(date)\n      when func = 'R2J' then retDate = R2J_PROC(date)\n      when func = 'R2D' then retDate = R2D_PROC(date)\n      otherwise do\n         say 'DT999E - Invalid function code as' func\n         retDate = 0\n         end\n   end\n\nreturn retDate\n\n\n\nJ2G_PROC: procedure\n\nparse arg julDate\n\ncall VALIDATE_JULIAN\nif RESULT = 0 then gDate = 0\nelse do\n   julianYYYY  = SUBSTR(julDate,1,4)\n   julianDDD   = SUBSTR(julDate,5,3)\n   mo.1  = 31\n   mo.2  = 28\n   mo.3  = 31\n   mo.4  = 30\n   mo.5  = 31\n   mo.6  = 30\n   mo.7  = 31\n   mo.8  = 31\n   mo.9  = 30\n   mo.10 = 31\n   mo.11 = 30\n   mo.12 = 31\n   if LEAP_YEAR(julianYYYY) then mo.2 = 29\n   do I=1 to 12 while julianDDD > mo.I\n      julianDDD = julianDDD - mo.I\n      end\n   mm   = RIGHT(I,2,'0')\n   dd   = RIGHT(julianDDD,2,'0')\n   gDate = mm||'/'||dd||'/'||julianYYYY\n   end\n\nreturn gDate\n\n\nG2J_PROC: procedure\n\nparse arg gregDate\nparse var gregDate mm '/' dd '/' YYYY\nJ_DATE = 0\n\nif DATATYPE(mm)   \u00ac= 'NUM' | ,\n   DATATYPE(dd)   \u00ac= 'NUM' | ,\n   DATATYPE(YYYY) \u00ac= 'NUM' | ,\n   dd > 31                 | ,\n   mm < 1                  | ,\n   mm > 12                 | ,\n   YYYY > 9999          then ,\n      say 'DT001E - Invalid Gregorian date as' gregDate\nelse do\n   mo.1  = 31\n   mo.2  = 28\n   mo.3  = 31\n   mo.4  = 30\n   mo.5  = 31\n   mo.6  = 30\n   mo.7  = 31\n   mo.8  = 31\n   mo.9  = 30\n   mo.10 = 31\n   mo.11 = 30\n   mo.12 = 31\n   if LEAP_YEAR(YYYY) then mo.2 = 29\n   mm = STRIP(mm,'L','0')\n   if (dd > VALUE(mo.mm)) then ,\n       say 'DT002E - Out-of-range date as' gregDate\n   else do\n      jAccumDay = 0\n      if mm > 1 then do I=1 to (mm-1)\n         jAccumDay = jAccumDay + mo.I\n         end\n      jAccumDay = jAccumDay + dd\n      J_DATE      = YYYY||RIGHT(jAccumDay,3,'0')\n      end\n   end\n\nreturn J_DATE\n\n\n\n\nJ2R_PROC: procedure\n\nparse arg julDate\n\ncall VALIDATE_JULIAN\nif RESULT = 1 then relDate = ((julianYYYY-1) * 365) + ,\n                            ((julianYYYY-1) % 4) - ,\n                            ((julianYYYY-1) % 100) + ,\n                            ((julianYYYY-1) % 400) + (julianDDD)\n   else relDate = 0\nreturn relDate\n\n\n\nR2J_PROC: procedure\nparse arg REL_DATE\nRETURNED_J = 0\n\nif DATATYPE(REL_DATE) \u00ac= 'NUM' then ,\n   say 'DT006E - Relative date non-numeric as' REL_DATE\nelse do\n   if REL_DATE > 3652424 then ,\n      say 'DT007E - Relative date out-of-range as' REL_DATE\n   else do\n      temp_YYYY = (REL_DATE % 366) + 1\n      temp_REL = J2R_PROC(RIGHT(temp_YYYY,4,'0')||'000')\n      do while (REL_DATE - temp_REL) > 0\n         if LEAP_YEAR(temp_YYYY) then LEFT_OVER = 366\n         else LEFT_OVER = 365\n         if LEFT_OVER < (REL_DATE - temp_REL) then do\n            temp_REL  = temp_REL  + LEFT_OVER\n            temp_YYYY = temp_YYYY + 1\n            end\n         else do\n            temp_DDD = (REL_DATE - temp_REL)\n            leave\n            end\n         end\n      RETURNED_J =  RIGHT(temp_YYYY,4,'0')||RIGHT(temp_DDD,3,'0')\n   end\nend\n\nreturn RETURNED_J\n\n\nR2D_PROC: procedure\nparse arg REL_DATE\nRETURNED_DAY = 0\nif DATATYPE(REL_DATE) \u00ac= 'NUM' then ,\n   say 'DT006E - Relative date non-numeric as' REL_DATE\nelse do\n   if REL_DATE > 3652424 then ,\n      say 'DT007E - Relative date out-of-range as' REL_DATE\n   else do\n      DAY_INDEX = (REL_DATE // 7)+1\n      RETURNED_DAY  = WORD('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)\n   end\nend\n\nreturn RETURNED_DAY\n\n\n\n\n\nVALIDATE_JULIAN:\n\nVALID_DATE = 0\n\nif LENGTH(julDate) \u00ac=7 | DATATYPE(julDate) \u00ac= 'NUM' then\n   say 'DT003E - Date too short/long or non-numeric as' julDate\nelse do\n   julianYYYY = SUBSTR(julDate,1,4)\n   julianDDD   = SUBSTR(julDate,5,3)\n   if (julianDDD > 366) then ,\n      say 'DT004E - Number of day > 366 as' julianDDD\n   else if (LEAP_YEAR(julianYYYY) = 0) & (julianDDD = 366) then ,\n          say 'DT005E - Invalid days for a non-leap year as' julianYYYY\n        else if (julianYYYY < 1) then ,\n           say 'DT008E - Invalid year as' julianYYYY\n           else VALID_DATE = 1\n   end\nreturn VALID_DATE\n\n\n\nLEAP_YEAR: procedure\nparse arg YEAR_CHECKED\n\nif (YEAR_CHECKED // 100) = 0 then ,\n   if (YEAR_CHECKED // 400) = 0 then LEAP_YEAR_FLAG = 1\n   else LEAP_YEAR_FLAG = 0\nelse if (YEAR_CHECKED // 4) = 0 then LEAP_YEAR_FLAG = 1\n   else LEAP_YEAR_FLAG = 0\n\nreturn LEAP_YEAR_FLAG\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INDEX": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x017\\x00\\x00\\x00\\x92\\x13\\x9f\\x01\\x005o\\t\\x15\\x01G\\x00\\x02\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.55", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "2000-12-21T09:15:00", "lines": 327, "newlines": 2, "modlines": 0, "user": "NMVV1"}, "text": "\nCONTENTS OF THIS PDS:\n\n  $BLDLIST -  MACRO - TO BUILD THE PARMLIST FOR A CALLING PROGRAM\n\n  $CAL     -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC DISPLAYS A\n              QUICK POP-UP CALENDAR USING ISPF PANEL.  IT ALSO DISPLAYS\n              THE LAST AND NEXT MONTH AS WELL.\n\n  $CALMON  -  ISPF PANEL - USED IN CONJUNCTION WITH REXX EXEC $CAL.\n\n  $CKOUT   -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC DISPLAYS PERTINENT\n              INFORMATION ABOUT YOUR TSO SESSION OR BATCH JOB, I.E. JOB/STEP\n              REGION SIZES, LIMITS, JOB/STEP TIME LIMITS, MSGCLASS, ETC.. THIS\n              CAN BE USED TO VERIFY THE SETTINGS DONE BY THE LOCAL JES2 AND SMF\n              EXITS.\n\n  $CMDPFX  -  ASM - TO ASSIGN A COMMAND PREFIX TO A MVS IMAGE OF A SYSPLEX.\n              RATHER THAN USING THE 'ROUTE' COMMAND, YOU CAN USE THIS PREFIX FOR\n              ROUTING A COMMAND TO THE APPROPRIATE SYSTEM.  THE PREFIX IS\n              SPECFIED THROUGH PARM.  LOOK AT THE PROGRAM COMMENTS AND SAMPLE\n              JCL FOR MORE INFORMATION.\n\n  $CMDPFX# -  JCL - JCL USED TO ASSEMBLE MODULE $CMDPFX. THIS PROGRAM REQUIRES\n              APF AUTHORIZATION, AND THEREFORE NEEDS TO BE LINKED (OR COPIED) TO\n              AN APF LIBRARY.\n\n  $CMDPFX@ -  JCL - JCL USED TO RUN $CMDPFX.\n\n  $CPU     -  CLIST (EXEC) - THIS IS A CPU MONITOR DISPLAY EXEC.  THE CPU\n              UTILIZATION IS DISPLAYED IN GRAPHICAL FORMAT USING ISPF PANELS\n              WITH DYNAMIC COLOR.  THE DATA IS WRAPPED AROUND ON THE SCREEN\n              FOR COMPARISON.  PRETTY COLORS  !!!\n\n  $CPUPNL  -  ISPF PANEL - USED BY $CPU.\n\n  $D       -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS DISPLAYS MVS CONTROL\n              BLOCKS, I.E. LINKLIST, APFLIST, SUBSYSTEM NAMES.  THESE ARE THE\n              THINGS THAT USED TO BE DONE IN ASSEMBLER CODING.  GOOD EXAMPLE FOR\n              CHASING THROUGH MVS CONTROL BLOCKS.  THE HELP TEXT IS BUILT IN AS\n              PART OF THE SOURCE.  ANY NEW FUNCTION CAN EASILY BE ADDED.\n\n  $DATE    -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS REXX FUNCTION\n              DOES DATE CONVERSIONS, INCLUDING RELATIVE DATE USED FOR\n              CALCULATION.\n\n  $DO      -  CLIST (EXEC) - EDIT MACRO. THIS EXEC VERIFIES THE 'DO/SELECT-END'\n              PAIRINGS IN A REXX EXEC.  ANY HANGING 'DO/SELECT-END' WILL BE\n              FLAGGED AS ERROR.  IT ALSO MARKS THE BEGINNING AND END OF EACH\n              'DO/SELECT-END' PAIR.  USEFUL IF YOU DO A LOT OF REXX CODING.\n\n  $DISC    -  JUST A DISCLAIMER\n\n  $HISTORY -  QUICK HISTORY OF WHAT IS BEING ADDED TO THIS PDS.\n\n  $INDEX   -  WHAT YOU ARE READING\n\n  $INFO    -  CLIST (EXEC).  THIS IS A GENERAL SRM INFO DISPLAY EXEC.  THE\n              CPU UTILIZATION PLUS ALL OTHER SRM INDICATORS ARE SHOWN. ANY\n              EXCEPTION CONDITION WILL CHANGE EITHER SOME DISPLAY COLORS OR\n              TEXT DISPLAY.  SOME OF THE INFO INCLUDES PAGE FAULT RATE, MIGR\n              AGE, AFQ, UIC, ETC...  THE CPU UTIL IS ALSO DISPLAYED IN A\n              GRAPHICAL FORMAT.  AGAIN, PRETTY COLORS !!!\n\n  $INFOPNL -  ISPF PANEL - USED BY $INFO.\n\n  $JAD.... -  PANELS - ISPF PANELS USED BY $JAD (JOB ACTIVITY DISPLAY)\n\n  $JAD     -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC GOES THROUGH\n              THE ASCB CHAIN AND DISPLAYS JOB ACTIVITY INFO USING ISPF TABLE\n              DISPLAY FACILITY, I.E. TCBTIME, EXCPTIME, EXCP COUNT, STORAGE\n              USAGE, ETC. IF AN ADDRESS SPACE IS SELECTED, THEN ADDITIONAL INFO\n              WILL BE DISPLAYED, INCLUDING A PLOT THAT SHOWS REAL & EXPANDED\n              STORAGE, AND ANOTHER WHICH SHOWS ITS STORAGE DISTRIBUTION BASED\n              ON UIC (KINDA SHOW YOU HOW REAL MEMORY IS BEING USED AT THE TIME).\n              THE DISPLAY CAN BE SORTED AND FILTERED BY SEVERAL DIFFERENT KEYS.\n\n              THIS WAS WRITTEN ORIGINALLY TO DISPLAY THE TOTAL STORAGE USED,\n              PLUS REAL AND EXPANDED, SEPARATELY FOR THE ADDRESS SPACES. RMFWDM\n              (WORKLOAD DELAY MONITOR) ONLY GIVES YOU THE TOTAL, NOT THE OTHER\n              TWO, AND DOES NOT ALLOW SORTING.  THIS EXEC, HOWEVER, GIVES ALL\n              TOTALS AND LET YOU DO ALL KIND OF SORTING.  NOT ONLY THAT, IT\n              ALSO GIVES YOU ADDITIONAL INFO (WHILE I'M LOOKING AROUND AT THE\n              CONTROL BLOCKS...).\n\n              ****** SEE $JADPGM ******  NOTE - 3/6/95 ******\n              ****** SEE $JADPGM ******  NOTE - 3/6/95 ******\n\n  $JAD#    -  DOC - INSTALLATION INSTRUCTION FOR $JAD.\n\n  $JADPGM  -  ASM - ASSEMLER VERSION OF $JAD.  THIS WAS WRITTEN AFTER $JAD IS\n              FOUND TO BE TOO SLOW, ESPCIALLY WHEN THE CPU IS CONSTANTLY\n              RUNNING ABOVE 100% (SRM CPU BUSY PCT).  FOLLOW THE INSTRUCTION\n              FROM $JAD# TO INSTALL THE REXX VERSION ($JAD), THEN ASSEMBLE\n              THIS PROGRAM INTO A LINKLIST A TSO STEPLIB DATA SET.  IF THE\n              REXX VERSION IS NOT DESIRED, THEN DO NOT COPY $JAD TO A SYSPROC\n              OR SYSEXEC DATA SET.\n\n  $LLACOPY -  SOURCE - BATCH ASSEMBLER PROGRAM TO SELECTIVELY REFRESH A LLA\n              (VLF) MODULE.  RATHER THAN DOING A 'F LLA,REFRESH' WHICH MAY TAKE\n              A WHILE DEPENDING ON THE LIST OF DATA SETS BEING MANAGED BY LLA,\n              THIS PROGRAM WILL UPDATE JUST THE MODULE BEING REFRESHED.  THE\n              PROGRAM WILL NEED TO BE LINKED AS AC(1) TO AN APF LIBRARY OR YOU\n              CAN INVOKE YOUR OWN SVC (SEVERAL EXIST ON THE CBT TAPE) TO BECOME\n              APF AUTHORIZED.  OTHERWISE, THIS PROGRAM WILL ABEND.\n\n  $MPFREPL -  ASM - A GENERALIZED MPF EXIT.  THE MESSAGES BEING HANDLED ARE\n              CODED USING AN IN-LINE MACRO.  PROCESSING CAN ALSO BE LIMITED TO\n              MESSAGES PRODUCED BY CERTAIN JOBNAMES SPECIFIED BY THIS MACRO.\n\n  $MPFREP# -  JCL - JCL USED TO ASSEMBLE MODULE $MPFREPL. THIS PROGRAM REQUIRES\n              APF AUTHORIZATION AND HAS TO BE IN THE LINK LIST AS WELL.\n\n  $MPFREP@ -  INSTRUCTION TO INSTALL THE $MPFREPL EXIT.\n\n  $PARM    -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC TAKES IN\n              THE PARMS AND DOES SUBSTITUTION ON THE INPUT CARDS (FROM\n              DDNAME INPUT) TO PRODUCE OUTPUT DATA FOR SUBSEQUENT USAGE.\n              SEVERAL RESERVED SYMBOLS WILL BE SUBSTITUTED AS WELL, I.E.\n              ~JOBNAME~, ~SYSID~.  REXX FUNCTIONS WILL ALSO BE EVALUATED\n              TO PRODUCE THE OUTPUT IF CODED (THIS CAN BE JUST ANOTHER\n              EXTERNAL REXX FUNCTION LIKE $DATE)\n\n  $PARM#   -  JCL - SAMPLE JCL TO RUN $PARM.\n\n  $Q       -  EDIT MACRO (REXX) - THIS MACRO TAKES A PARM AS A TSO\n              COMMAND TO BE ISSUED AND THE OUTPUT WILL BE TRAPPED AND\n              DISPLAYED AS ISPF EDIT NOTE LINES.\n\n  $SAVE    -  EDIT MACRO (REXX) - THIS MACRO SAVES DATA BEING EDITED BY\n              DOING UPDATE IN PLACE FOR A PDS MEMBER.  EXTREMELY USEFUL\n              IF SYS1.PROCLIB IS FULL, AND YOU JUST NEED TO MAKE MINIMUM\n              CHANGES TO A PROC (UNLESS YOU WANT TO GO AHEAD AND\n              COMPRESS IT RIGHT THEN AND THERE ...)\n\n  $VSAMIDX -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS EXEC CALCULATES\n              THE OPTIMUM NUMBER OF INDEX BUFFERS TO BE SPECIFIED FOR A VSAM\n              KSDS USED FOR RANDOM ACCESS.  THE THEORY HERE IS: IF YOU CAN\n              KEEP ALL INDEX RECORDS IN MEMORY, THEN NO FURTHER IO'S WILL BE\n              REQUIRED ONCE THE BUFFERS ARE FILLED.  NOTE THAT, FOR SEQUENTIAL\n              ACCESS, THE NUMBER DOES NOT APPLY, SINCE ONLY THE SEQUENCE SET\n              INDEX RECORDS WILL BE USED.  IN THIS CASE, SPECIFYING A FEW\n              EXTRA DATA BUFFERS WOULD HELP.\n\n  $VSAMIXA -  CLIST (EXEC) - THE DFSMS 1.X VERSION OF $VSAMIDX.\n\n  $VSDOC   -  INSTALL DOC FOR $VSAMIDX.\n\n  $VSIDX01 -  PANEL - ISPF PANEL USED BY $VSAMIDX.\n\n  $WHOHAS  -  CLIST (EXEC) - THIS REXX EXEC WILL LIST THE ACCESS LISTS\n              FOR RACF DATA SET PROFILES FOUND UNDER DSN*.**.  THIS\n              FUNCTION IS VERY MUCH SIMILAR TO 'TSS WHOHAS DSN' COMMAND\n              UNDER TOP SECRET.  IF THE EXEC IS RUN IN BATCH, THE RACF\n              COMMANDS USED TO RE-BUILD ALL OF THE PROFILES AS DISPLAYED\n              IN THE OUTPUT IS ALSO PRODUCED.\n\n  $X       -  EDIT MACRO (REXX) - THIS MACRO READS THE MEMBER BEING\n              EDITED AND EXECUTES IT AS A CLIST/EXEC.  EXECUTION PARMS\n              ARE ALLOWED AS WELL.  THIS DOES NOT REQUIRED THE MEMBER TO\n              BE SAVED FIRST.  EXTREMELY USEFUL IF YOU'RE DOING A LOT OF\n              CLIST/EXEC CODING AND DEBUGGING.\n\n  $6       -  CLIST (EXEC) - WRITTEN IN TSO REXX.  OFTEN TIMES, YOU DO NEED\n              TO ALLOCATE A NEW LOADLIB AND EXECUTE TSO COMMANDS OUT OF IT.\n              ONE WAY TO DO IT IS: GET OUT OF ISPF, ALLOCATE IT AS ISPLLIB,\n              AND GET BACK IN.  THE OTHER WAY (WITHOUT HAVING TO GET OUT\n              OF ISPF): EXECUTE THIS EXEC, AND THERE YOU GO !!!  IF YOU WERE\n              AN ISPF BIGGOT, YOU'D HAVE THIS EXEC DONE ALREADY (PROBABLY).\n              BUT HECK, I PUT THIS IN HERE ANY WAY...\n\n  $6DOC    -  INSTALL DOC FOR $6.\n\n  #LLACOPY -  JCL - JCL USED TO RUN PROGRAM $LLACOPY.\n\n  @DYNA    -  HELP MEMBER FOR TSO COMMAND 'DYNALIST'.  NEEDS TO BE RENAMED TO\n              'DYNALIST' BEFORE MOVING IT TO 'SYS1.HELP'.\n\n  @FIND    -  HELP MEMBER FOR TSO COMMAND 'FIND'.  NEEDS TO BE RENAMED TO 'FIND'\n              BEFORE MOVING IT TO 'SYS1.HELP'.\n\n  @JADPGM  -  JCL USED TO ASSEMBLE $JADPGM.\n\n  @TSOINIT -  HELP MEMBER FOR TSO COMMAND 'TSOINIT'.  NEEDS TO BE RENAMED TO\n              'TSOINIT' BEFORE MOVING IT TO 'SYS1.HELP'.\n\n  ASSEM    -  GENERAL JCL USED TO ASSEMBLE THE PROGRAMS/COMMANDS:  DALLOC,\n              DYNALIST, FIND, TSOINIT.\n\n  DALLOC   -  SOURCE - TSO CMD TO DISPLAY DYNAMIC ALLOCATIONS.  I'VE GOT THE\n              ORIGINAL SOURCE FROM ONE OF THE VERY OLD CBT TAPE.  THIS STOPPED\n              WORKING WHEN OUR JES2 PGMR DECIDED TO MOVE SWA ABOVE THE LINE.  I\n              THEN DECIDED TO FIX THIS PROGRAM USING MACRO 'SWAREQ' WHICH IS THE\n              STANDARD WAY TO ACCESS THE JFCB FROM TIOT PTR.\n\n  DATE     -  THIS IS JES2 EXIT 1 (PAGE SEPARATOR), BUT REALLY IT IS CSECT\n              RBDDATE WHICH IMPLEMENTS TABLELESS DATE CONVERSION\n\n  DYNALIST -  SOURCE - TSO COMMAND TO DISPLAY ALL UNIT NAMES ON THE SYSTEM AND\n              THE UCBS' (PLUS VOLSERS) ASSOCIATED WITH THOSE UCBS.  DYNALIST IS\n              AN OLD PROGRAM COMING OFF THE CBT TAPE.  I MODIFIED IT SINCE WE\n              WENT TO MVS 3.1.0E.  NOW THAT WE ARE AT MVS 4.2, IT STOPS WORKING\n              AGAIN.  DUE TO THE CHANGES TO THE IOCP PROCESS (ONLINE HCDS), I\n              DECIDED TO RE-WRITE THIS PROGRAM USING MORE STANDARD MVS\n              INTERFACES THAN THE OLD MODULE.  ALONG THE WAY, I ALSO ADDED SOME\n              NEW BELLS AND WHISTLES.  AS FAR AS I AM CONCERNED, THIS SHOULD\n              ALSO WORK WITH MVS 3.1.0E.\n\n  ENQMON   -  SOURCE - ASM PROGRAM USED AS A STC TO MONITOR AND DISPLAY GRS\n              ENQ CONTENTION. THIS PROGRAM DOES GQSCAN EVERY MINUTE, DISPLAYS\n              THE HOLDERS/WAITERS ON THE CONSOLE.  IF THE HOLDER IS A TSU USER,\n              A MESSAGE WILL BE SENT TO NOTIFY THE USER.  EVERY MINUTE, THE\n              CONSOLE DISPLAYED MESSAGE WILL BE UN-HILIGHTED, THE MINUTE COUNT\n              INCREMENTS, AND A NEW MESSAGE IS DISPLAYED.  THE WAITING JOB WILL\n              ALSO RECEIVE MESSAGES AS PART OF THE JOBLOG.  THIS PROGRAM TRIES\n              TO MIMICK MIM AS MUCH AS POSSIBLE WITH THE EXCEPTION OF THE JOB\n              REQUEUE FUNCTION.\n\n  ENQMON#  -  JCL - JCL USED TO ASSEMBLE MODULE ENQMON. THIS PROGRAM REQUIRES\n              APF AUTHORIZATION.\n\n  ENQMON$  -  JCL - JCL USED TO RUN ENQMON AS A STARTED TASK.\n\n  EXIT     -  MACRO - TO EXIT A PROGRAM\n\n  FIND     -  SOURCE - TSO CMD TO DO QUICK SEARCH FOR ANY CHARACTER STRING IN A\n              PDS.  HAS A FEW NICE OPTIONS.  LOOK AT @FIND FOR HELP.\n\n  IEFUTL   -  MULTI FUNCTION, SEMI-SMART, TABLE DRIVEN TIMEOUT PROCESSOR\n\n  IEFUTLTB -  THE TABLE IT USES\n\n  ISRTSOA  -  PANEL - THE 'MODIFIED OPTION 6' PANEL USED BY $6.\n\n  JESXIT05 -  JES2 COMMAND EXIT TO DO THE FOLLOWING:\n\n              $Q'XXX    -  DISPLAYS ALL JOBS PREFIXED BY XXX\n              $QAPF     -  DISPLAYS APF LIST\n              $QLLT     -  DISPLAYS LINKLIST TABLE\n              $QDSN=XXX -  CATALOG SEARCH DSNAME XXX.  IF FOUND, THE CATALOGED\n                           VOLUME IS ALSO SEARCHED TO MAKE SURE DATA SET DOES\n                           RESIDE THERE.\n              $QVOL=YYY -  DISPLAYS UCB ADDR OF VOL=YYY.  IT'S NOT EASY TO FIND\n                           THIS OUT USING NATIVE MVS COMMANDS.\n              $QSYSTEM  -  DISPLAYS ALL KIND OF INFO ABOUT SYSTEM.  GOOD FOR US\n                           SYSTEMS PROGRAMMERS.\n              $Q        -  DISPLAYS AVAILABLE PARMS (AS ABOVE)\n\n              THIS CODE WAS WRITTEN FOR JES2 4.2 (MVS/ESA 4.2), FOR ANY EARLIER\n              VERSION OF JES2, YOU MAY HAVE TO CHANGE MACRO 'CONVCON' TO GO\n              CHECK THE CONSOLE YOURSELF.  ALSO, '$CFJMSG' WAS USED TO PRODUCE\n              THE EXACT DISPLAY THAT '$D' DOES (THIS IS NOT A DOCUMENTED MACRO\n              IN JES2 MANUAL).  THE WAY THIS PROGRAM IS WRITTEN, YOU CAN EASILY\n              ADD A NEW PARM AND WRITE A NEW SECTION OF CODE TO PROCESS THAT\n              PARM.  PLANNED MODIFICATIONS FOR FUTURE:\n\n                 *   FIX UP THE MACRO USED TO SET UP THE PARAMETER TABLE.  RIGHT\n                     NOW, THE HELP TEXT HAS TO BE LESS THAN 60 CHAR SINCE THE\n                     BUFFER AREA USED FOR DISPLAY IS 60 CHAR LONG (MAY CAUSE\n                     SOME OVERLAY IF IT IS LONGER).\n\n              JES2 PARMS NEEDED:\n\n              *   LOADMOD(JESXIT05)\n              *   EXIT(005) ROUTINE=EXIT5,STATUS=ENABLED,TRACE=NO\n\n  JESX006  -  JES2 INTERNAL TEXT SCAN, TABLE DRIVEN, IMPLEMENTS CONTROLS ON\n              NUMBER OF TAPE DRIVES PER STEP.\n\n  JSTAT    -  SOURCE - BATCH PROGRAM TO CHECK AND SEE IF A JOB (OR STC OR TSU)\n              IS CURRENTLY RUNNING (USING THE 'STATUS' FUNCTION OF JES2).  IF IT\n              IS FOUND, THEN WTO'S WILL BE DONE USING CONTROL CARDS IN 'FND'.\n              OTHERWISE, CONTROL CARDS FROM 'NOTFND' DDNAME WILL BE USED BY\n              WTO'S.  IF 'RRFND' AND 'RRNOTFND' ARE USED, A WTOR WILL BE DONE\n              AFTER THE WTO'S TO GIVE THE OPERATOR A CHANCE TO DO SOMETHING ELSE\n              BEFORE THE REPLY.  OF COURSE, NONE OF THE DDNAMES HAS TO BE\n              PRESENT, IN WHICH CASE, THE APPROPRIATE RETURN CODE WILL BE ISSUED\n              BASED ON THE JOB STATUS.  NOTE THAT SINCE THIS PROGRAM DOES NOT GO\n              THROUGH THE ASVT, AND THEREFORE DOES WORK IN A JES2 SHARED SPOOL\n              ENVIRONMENT.\n\n  JSTAT#   -  JCL - JCL USED TO ASSEMBLE MODULE JSTAT.  THIS PROGRAM REQUIRES\n              APF AUTHORIZATION, AND THEREFORE NEEDS TO BE LINKED (OR COPIED) TO\n              AN APF LIBRARY.\n\n  JSTAT$   -  JCL - JCL USED TO RUN JSTAT.\n\n  LOCKTERM -  TSO COMMAND TO LOCK A SCREEN WITH A PASSWORD\n\n  MFORM    -  MACRO USED IN LOCKTERM\n\n  MSIXBIT  -  MACRO USED IN LOCKTERM\n\n  M3270    -  MACRO USED IN LOCKTERM\n\n  SEEK     -  SOURCE - TSO CMD TO DO QUICK SEARCH FOR ANY MODULE THAT RESIDES IN\n              LPA (MLPT/FLPA/PLPA), LINKLIST, AND/OR STEPLIB.  MODULE\n              INFORMATION WILL BE DISPLAYED ACCORDINGLY IF FOUND.\n\n  SET      -  MACRO - TO SET UP SAVE AREA AT BEGINNING OF PROGRAM\n\n  TSOINIT  -  SOURCE - TSO CMD TO CHECK FOR A FEW ISPF DATA SETS AND ALLOCATE\n              THEM AS 'NEW' IF THEY ARE NOT FOUND IN THE CATALOGS.  THESE DATA\n              SET NAMES ARE RECORDED IN A TABLE OF THIS PROGRAM.  THE FIRST DATA\n              SET QUALIFIER WILL BE THE SAME WITH THE EXECUTING TSO ID.  I GUESS\n              YOU CAN DO ALL THIS USING 'ALLOC' COMMAND WITH RETURN CODE\n              CHECKING, BUT, THIS IS PROBABLY A LOT MORE EFFICIENT ....  ALSO, I\n              AM TOO LAZY TO WRITE A MACRO TO CREATE A NAME ENTRY IN THE DATA\n              SET NAME TABLE.  MAYBE SOMEONE WILL DO THAT FOR ME ....\n\n-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\n\n  WE DO NOT PROMISE TO MAKE ANY CORRECTIONS AND/OR MODIFICATIONS TO ANY OF THE\n  PROGRAMS.  HOWEVER, WE DO ENCOURAGE ANY COMMENTS/IDEAS AND WILL ATTEMPT TO\n  PROVIDE ANY FIXES AND/OR MODIFICATIONS AS TIME PERMITS.  ALL\n  QUESTIONS/COMMENTS CAN BE DIRECTED TO:\n\n          VINH VU\n          CONSULTING TECHNOLOGIST\n          NEIMAN MARCUS\n          IS DEPARTMENT\n          111 CUSTOMER WAY\n          IRVING, TX  75039-3607\n          (972)-401-6948\n\n-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INFO": {"ttr": 2818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x005o\\x01\\x005o\\x084\\x01\\x12\\x01\\x12\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-21T00:00:00", "modifydate": "2000-12-21T08:34:00", "lines": 274, "newlines": 274, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $INFO    REXX/CLIST      *********************/\n /* $INFO                                                            */\n /*   This exec displays the indicators which SRM uses to determine  */\n /*   whether system MPL needs to be adjusted.  These indcators      */\n /*   include CPU util, UIC, Page fault rate, Fixed store below 16M  */\n /*   and below & above 16m pct.  The CPU Util % will also be        */\n /*   displayed as a bar chart, whereas the color will change        */\n /*   accordingly.  All indicator thresholds are displayed along     */\n /*   with the current measurement whose color will also change.     */\n /*   The final decision for MPL adjustment is shown at the bottom   */\n /*   with the appropriate color as well.                            */\n /*                                                                  */\n /* SYNTAX: $INFO                                                    */\n /*                                                                  */\n /********************************************************************/\n\nIf Sysvar(SYSISPF) \u00ac='ACTIVE' Then Do\n   Parse Source . . EXEC_NAME .\n   Say '***' EXEC_NAME 'can only run under ISPF...'\n   Exit\n   End\n\nNumeric Digits 256\n\nYELLOW  = 'YELLOW'\nWHITE   = 'WHITE'\nRED     = 'RED'\nGREEN   = 'GREEN'\nTURQ    = 'TURQ'\nPINK    = 'PINK'\nFLENG   = 6\n\nCVT     = Get_Stor('10'x)\nRCE     = Get_Stor(CVT,'490'x)\nRMCT    = Get_Stor(CVT,'25C'x)\nRCT     = Get_Stor(RMCT,'E4'x)\nCCT     = Get_Stor(RMCT,4)\nMCT     = Get_Stor(RMCT,'C'x)\nCSD     = Get_Stor(CVT,'294'x)\nRCE     = Get_Stor(CVT,'490'x)\nSMCAADD = Get_Stor(CVT,'C4'x)\nSMF     = Get_Stor(SMCAADD,'10'x)\nPVTADD  = Get_Stor(CVT,'2FC'x)\n\nMACH    = C2X(Get_Stor(CVT,-6,2))\nNUM_CPU = C2D(Get_Stor(CSD,'A'x,2))\nCP      = NUM_CPU\nSU      = C2D(Get_Stor(RMCT,64))\nSUSEC   = Strip(Format((16000000/SU),8,2))\nRSTORE  = (C2D(Get_Stor(CVT,'358'x))/1024)||'M'\nESTORE  = (C2D(Get_Stor(RCE,'A0'x))*4)/1024||'M'\n\nLATENT_DEMAND = 7*NUM_CPU\nTOO_MUCH_STRESS = LATENT_DEMAND + (7*2)\nSETUP:\n\nCOUNTER = 0                 /* Used to maintain MPL adjustment flag  */\n\nLOUIC   = C2D(Get_Stor(RCT,4,2))                  /*   UIC   */\nHIUIC   = C2D(Get_Stor(RCT,6,2))\nUIC     = C2D(Get_Stor(RCT,'36'x,2))\nOUIC    = Center(UIC,FLENG)\n\nLOCPU   = C2D(Get_Stor(RCT,8,2))/16               /*  CPU Util  */\nHICPU   = C2D(Get_Stor(RCT,10,2))/16\nAVGCPU  = Format(C2D(Get_Stor(RCT,'38'x,2))/16,3,0)\nREALCPU = C2D(Get_Stor(CCT,102,2))\nCPU     = REALCPU||'%'\nOCPU    = Center(AVGCPU,FLENG)\n\nLOPRTE  = C2D(Get_Stor(RCT,'C'x,2))        /* Page fault rate */\nHIPRTE  = C2D(Get_Stor(RCT,'E'x,2))\nPRTE = C2D(Get_Stor(RCT,'40'x,2))\nOPRTE   = Center(PRTE,FLENG)\n\nLOFIX   = C2D(Get_Stor(RCT,'78'x,2))      /* Fixed storage (all) */\nHIFIX   = C2D(Get_Stor(RCT,'7A'x,2))\nAVGFIX  = C2D(Get_Stor(RCT,'80'x,2))\nOFIX    = Center(AVGFIX,FLENG)\n\nLOBELOW = C2D(Get_Stor(RCT,'7C'x,2))      /* Fixed storage < 16M */\nHIBELOW = C2D(Get_Stor(RCT,'7E'x,2))\nAVGBELOW= C2D(Get_Stor(RCT,'82'x,2))\nOBELOW  = Center(AVGBELOW,FLENG)\n\nXDD     = Date('U')\nXTIME   = Time()\n\nSelect\n   When UIC < LOUIC Then Do\n      COUNTER = COUNTER-5\n      UICCLR = RED\n      End\n   When UIC > HIUIC Then Do\n      UICCLR = GREEN\n      COUNTER = COUNTER+1\n      End\n   Otherwise Do\n      UICCLR = WHITE\n      End\n   End\n\nSelect\n   When AVGCPU < LOCPU Then Do\n      CPUCLR = GREEN\n      COUNTER = COUNTER+1\n      End\n   When AVGCPU > HICPU Then Do\n      CPUCLR = RED\n      COUNTER = COUNTER-5\n      End\n   Otherwise Do\n      CPUCLR = WHITE\n      End\n   End\n\n\nSelect\n   When PRTE < LOPRTE Then Do\n      PRTCLR = GREEN\n      COUNTER = COUNTER+1\n      End\n   When PRTE > HIPRTE Then Do\n      PRTCLR = RED\n      COUNTER = COUNTER-5\n      End\n   Otherwise Do\n      PRTCLR = WHITE\n      End\n   End\n\n\nSelect\n   When AVGBELOW < LOBELOW Then Do\n      BELCLR = GREEN\n      COUNTER = COUNTER+1\n      End\n   When AVGBELOW > HIBELOW Then Do\n      BELCLR = RED\n      COUNTER = COUNTER-5\n      End\n   Otherwise Do\n      BELCLR = WHITE\n      End\n   End\n\nSelect\n   When AVGFIX < LOFIX Then Do\n      FIXCLR = GREEN\n      COUNTER = COUNTER+1\n      End\n   When AVGFIX > HIFIX Then Do\n      FIXCLR = RED\n      COUNTER = COUNTER-5\n      End\n   Otherwise Do\n      FIXCLR = WHITE\n      End\n   End\n\nSelect\n   When COUNTER < 0 Then Do\n      MPLCLR = RED\n      MFLG = Center('Decr',FLENG)\n      End\n   When COUNTER = 5 Then Do\n      MPLCLR = GREEN\n      MFLG = Center('Incr',FLENG)\n      End\n   Otherwise  Do\n      MPLCLR = WHITE\n      MFLG = Center('None',FLENG)\n      End\n   End\n\nTL = REALCPU%2\nCPUBAR = Center(CPU,TL,'-')\nIf REALCPU < 91  Then Do\n   CPUBAR = Left(CPUBAR,TL)||Copies('o',50-TL)\n   CPUMASK = Copies('#',TL)||Copies('}',50-TL)\n   End\nElse If REALCPU < 100 Then Do\n   CPUBAR = Left(CPUBAR,TL)||Copies('o',50-TL)\n   CPUMASK = Copies('_',TL)||Copies('}',50-TL)\n   End\nElse Do\n   TL = (REALCPU-100)%2\n   CPUMASK = Copies('~',50)||Copies('{',TL)\n   CPUBAR = Left(CPUBAR,50)||Copies('x',TL)\n   End\n\nMIGR    = C2D(Get_Stor(MCT,'14C'x))\nAFQA    = C2D(Get_Stor(RCT,'3C'x,2))\nDLY     = Format(C2D(Get_Stor(RCT,'16'x,2))/16,3,0)\nBADCPU  = ''\nBADFL   = 'BLINK'\nIf DLY = 0 Then Do\n   DLY = ''\n   DLFLAG = 'USCORE'\n   WAITFL = TURQ\n   End\nElse Do\n   DLFLAG = 'REVERSE'\n   BADCLR = TURQ\n   If DLY > LATENT_DEMAND Then Do\n      BADCPU = Center('<< CPU Under Stress >>',26)\n      BADFL  = 'REVERSE'\n      If DLY > TOO_MUCH_STRESS Then Do\n         BADCLR = RED\n         WAITFL = RED\n         End\n      Else Do\n         BADCLR = YELLOW\n         WAITFL = YELLOW\n         End\n      End\n   Else WAITFL = TURQ\n   End\n/*  Look for other kind of SRM info as well                    */\n\nSWPRT   = C2D(Get_Stor(RCT,'42'x,2))\nTPAGE   = C2D(Get_Stor(RCT,'44'x,2))\nTLPGIN  = C2D(Get_Stor(RCE,'44'x))\nTLPGOUT = C2D(Get_Stor(RCE,'58'x))\nTLFIXED = C2D(Get_Stor(RCE,'78'x))\nTLEUSE  = C2D(Get_Stor(RCE,'A4'x))\nTLESYS  = C2D(Get_Stor(RCE,'A0'x))\nTLEPCT  = Format(((TLEUSE*100)/TLESYS),3,2)||'%'\nTLRSYS  = C2D(Get_Stor(RCE,'4'x))\n\n\nAddress ISPEXEC 'ADDPOP COLUMN(5)'\nAddress ISPEXEC 'DISPLAY PANEL($INFOPNL)'\nTRC = Rc\nAddress ISPEXEC 'REMPOP'\nIf TRC < 8 Then Signal SETUP\n\nExit\n\nGet_Stor: PROCEDURE\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) Length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nParse Arg AREA,OFFSET,LENG\n\nIf Arg(2,'O') Then OFFSET=0\n\nIf Arg(3,'O') Then LENG=4\n\nIf DataType(AREA) = 'CHAR' Then Do\n   AREA =  C2D(AREA)\n   End\n\nIf DataType(OFFSET) = 'CHAR' Then Do\n   OFFSET =  C2D(OFFSET)\n   End\n\nReturn  Storage((D2X(AREA+OFFSET)),LENG)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INFOPNL": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x00\\x83\\x13\\x9f\\x01\\x00\\x05o\\x11\\x13\\x002\\x00\\x13\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "2000-02-25T11:13:00", "lines": 50, "newlines": 19, "modlines": 0, "user": "NMVV1"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$JAD": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x00\\x942/\\x00\\x95\\x06_\\x13$\\x02\\xa1\\x00\\xb8\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1994-11-18T00:00:00", "modifydate": "1995-03-06T13:24:00", "lines": 673, "newlines": 184, "modlines": 0, "user": "$VNV"}, "text": "/*                                 REXX                             */\n/*                                                                  */\n/********************************************************************/\n/*                                                                  */\n/*   This exec will display Address Spaces Information, mainly      */\n/*   storage usage sorted by total frames (Central & Expanded).     */\n/*   This information can be obtained though RMFWDM, however, the   */\n/*   total is not broken down by Central & Expanded.  By the same   */\n/*   token, OMEGAMON let you view by Central or Expanded, not by    */\n/*   total of the two.                                              */\n/*                                                                  */\n/********************************************************************/\n/*                                                                  */\n/*   Changes:                                                       */\n/*                                                                  */\n/*   11/18/94 - V1.00 - $VNV - Added the fist time                  */\n/*   03/01/95 - V1.01 - $VNV                                        */\n/*                    - Added the CPU Pct Busy (SRM CPU Busy)       */\n/*                    - Stop using HIGHEST_STOR for plotting        */\n/*                    - Use Real EXCPCNT (not /100) on detail displ */\n/*                                                                  */\n/********************************************************************/\n/*                                                                  */\n                                               /*                    */\nIf SYSVAR(SYSISPF) = 'NOT ACTIVE' Then Do\n   Say 'ISPF is required to run this EXEC'\n   Exit\n   End\n                                               /*                    */\nSWAPFLG.1  = 'TO'\nSWAPFLG.2  = 'TI'\nSWAPFLG.3  = 'LW'\nSWAPFLG.4  = 'XS'\nSWAPFLG.5  = 'RS'\nSWAPFLG.6  = 'DW'\nSWAPFLG.7  = 'RQ'\nSWAPFLG.8  = 'NQ'\nSWAPFLG.9  = 'EX'\nSWAPFLG.10 = 'US'\nSWAPFLG.11 = 'TS'\nSWAPFLG.12 = 'IC'\nSWAPFLG.13 = 'IP'\nSWAPFLG.14 = 'MR'\nSWAPFLG.15 = 'AW'\nSWAPFLG.16 = 'OI'\nSWAPFLG.17 = 'OO'\n                                               /*                    */\nSWAPTXT.1  = 'Terminal Output Wait'\nSWAPTXT.2  = 'Terminal Input Wait'\nSWAPTXT.3  = 'Long Wait'\nSWAPTXT.4  = 'Aux Storage Shortage'\nSWAPTXT.5  = 'Central Storage Shortage'\nSWAPTXT.6  = 'Detected Wait'\nSWAPTXT.7  = 'Requested Swap'\nSWAPTXT.8  = 'Enqueue Exchange'\nSWAPTXT.9  = 'Exchange/Rec value'\nSWAPTXT.10 = 'Unilateral'\nSWAPTXT.11 = 'Transition Swap'\nSWAPTXT.12 = 'Improve Central Storage'\nSWAPTXT.13 = 'Improve System Paging'\nSWAPTXT.14 = 'Make Room Swapped Users'\nSWAPTXT.15 = 'APPC Wait'\nSWAPTXT.16 = 'Input Wait'\nSWAPTXT.17 = 'Output Wait'\n                                               /*                    */\nHIGHSWAP = 17                                  /*                    */\nTABLENM  = '$JADTAB'\nTABPANEL = '$JADTBL1'\nJOBPANEL = '$JADJOB'\nSORTPNL  = '$JADSORT'\nMSGPNL   = '$JADMSG'\nVIEWPNL  = '$JADVIEW'\n                                               /*                    */\nPLOT_X_AXIS = 50                               /* 50 units on X-axis */\nMSG_X_AXIS  = 16                               /* 16 units on X-axis */\nHOW_MANY_TIMES_CHECKED = 5                     /* Check to display   */\n                                               /* 'In-Progess' panel */\nNUMERIC DIGITS 30                              /*                    */\nSORTXEQ  = ''                                  /*                    */\nVIEWXEQ  = ''                                  /*                    */\n\nCVT      = C2X(Storage(10,4))\nDCVT     = X2D(CVT)\n                                               /*                    */\nSYSID    = Storage((D2X(DCVT+340)),4)\n\nSRMT     = C2X(Storage((D2X(DCVT+604)),4))\nDSRMT    = X2D(SRMT)\nCCT      = C2X(Storage((D2X(DSRMT+4)),4))\nDCCT     = X2D(CCT)\n\nASVT     = C2X(Storage((D2X(DCVT+556)),4))\nDASVT    = X2D(ASVT)\n\nRCEP     = C2X(Storage((D2X(DCVT+1168)),4))\nDRCEP    = X2D(RCEP)\n                                               /*                    */\nTOTREAL  = (C2D(Storage((D2X(DCVT+856)),4)))/4\nTOTEXP   = C2D(Storage((D2X(DRCEP+160)),4))\nTOTSTOR  = TOTREAL+TOTEXP                      /* In frames          */\n                                               /*                    */\nTOTREAL  = (TOTREAL*4)/1024                    /* Convert To MEG     */\nTOTEXP   = (TOTEXP*4)/1024                     /* Convert To MEG     */\nTOTSTOR  = (TOTSTOR*4)/1024                    /* Convert To MEG     */\n                                               /*                    */\nTOTREAL  = Format(TOTREAL,4)                   /*                    */\nTOTEXP   = Format(TOTEXP,4)                    /*                    */\nTOTSTOR  = Format(TOTSTOR,5)                   /*                    */\n\nMAXNUM   = C2D(Storage(D2X(DASVT+516),4))      /* Max # of Addrspc   */\nCHECKPT  = MAXNUM%HOW_MANY_TIMES_CHECKED       /*                    */\n\n\nLOOP_THRU_ALL_ASCBS:\n                                               /*                    */\nREFRESH_IS_REQUIRED = 'N'                      /* Set flag           */\n                                               /*                    */\nASCB_OFFSET = 524-4                            /* First ASCB offset  */\nCOUNT    = 0                                   /*                    */\nPROG_SW  = 1                                   /* To keep track of   */\n                                               /* when to display    */\n                                               /* \"In-Progress' msg  */\n                                               /*                    */\nAddress ISPEXEC\n'TBCREATE' TABLENM 'NAMES(',\n  'JOBN TYPE ASID DPRTY INWSS TARWSS FIXBELOW ESTOR RSTOR STORAGE',\n  'UIC1  UIC2  UIC3  UIC4 SRBTIME TCBTIME RDYTCBS SWAPCNT COUNT',\n  'SWAPSTAT SWAPCODE EVENTCDE EXCPCNT DOMAIN WSMRV INTPGIN INTPGOUT',\n  'ECNT)  REPLACE NOWRITE'\nAddress TSO                                    /*                    */\n                                               /*                    */\nDo I=1 To MAXNUM\n   If I%CHECKPT > PROG_SW Then Do              /*                    */\n      PROG_SW = I%CHECKPT                      /*                    */\n      Call DISPL_IN_PROGRESS_MESSAGE I         /*                    */\n      End                                      /*                    */\n   ASCB_OFFSET = ASCB_OFFSET + 4               /*                    */\n   ASCB  =  C2X(Storage((D2X(DASVT+ASCB_OFFSET)),4)) /*              */\n   Call PROCESS_AN_ASCB                        /*                    */\n   End                                         /* Do I=1             */\n\n\nSYSUIC1  = C2D(Storage(D2X(DRCEP+284),2))      /*                    */\nSYSUIC2  = C2D(Storage(D2X(DRCEP+286),2))      /*                    */\nSYSUIC3  = C2D(Storage(D2X(DRCEP+288),2))      /*                    */\nSYSUIC4  = C2D(Storage(D2X(DRCEP+290),2))      /*                    */\n\nCPUP     = C2D(Storage(D2X(DCCT+102),2))       /*                    */\nCPUP     = Format(CPUP,3)||'%'\n\nSORT_THE_TABLE:                                /*                    */\nIf SORTXEQ \u00ac= '' Then Do                       /*                    */\n   Address ISPEXEC\n   SORTXEQ\n   Address TSO\n   End                                         /*                    */\n                                               /*                    */\n                                               /*                    */\n                                               /*                    */\nDISPL_TABLE_AFTER_SORT:                        /*                    */\nMYCMD = ''                                     /*                    */\nMYSEL = ''                                     /*                    */\nAddress ISPEXEC                                /*                    */\n'TBTOP' TABLENM                                /*                    */\nAddress TSO                                    /*                    */\n                                               /*                    */\n                                               /*                    */\n                                               /*                    */\nDISPL_TABLE_AGAIN:                             /*                    */\nAddress ISPEXEC                                /*                    */\n'TBDISPL' TABLENM  'PANEL('TABPANEL')'         /*                    */\nTemprc = Rc                                    /*                    */\nAddress TSO                                    /*                    */\n                                               /*                    */\nIf Temprc = 8 Then Signal IAMDONE\n  Else If Temprc = 0 | Temprc = 4 Then Signal CHECK_INPUT\n       Else Do\n          Say 'Err TBDISPL as' Temprc          /*                    */\n          Signal IAMDONE                       /*                    */\n          End                                  /*                    */\n\n\n\nCHECK_INPUT:                                   /*                    */\nParse Var MYCMD CMD1 .                         /*                    */\nSelect                                         /*                    */\n   When CMD1  = '' Then Do\n      If MYSEL \u00ac='_' Then Signal DISPLAY_A_SPECIFIC_JOB\n      Else Signal LOOP_THRU_ALL_ASCBS\n      End                                      /*                    */\n   When CMD1  = 'SORT' Then Do\n      Call PROCESS_SORT_OPTION\n      Signal SORT_THE_TABLE\n      End\n   When CMD1  = 'VIEW' Then Do\n      Call PROCESS_VIEW_OPTION\n      If RESULT = 0 Then Do\n         Signal LOOP_THRU_ALL_ASCBS            /*                    */\n         End                                   /*                    */\n      Else Signal DISPL_TABLE_AGAIN            /*  If PF3 was hit    */\n      End\n   Otherwise Signal DISPL_TABLE_AFTER_SORT\nEnd    /* Select  */                           /*                    */\n                                               /*                    */\nIf MYSEL = '_' Then Signal DISPL_TABLE_AFTER_SORT /*                 */\n\n\n\nDISPLAY_A_SPECIFIC_JOB:\n                                               /*                    */\nJOBN = Center(Strip(JOBN,B),8)                 /*                    */\nLARGEST_STOR_SIZE = (STORAGE*4)/1024           /* Convert to Meg     */\nBASESTOR = (((LARGEST_STOR_SIZE%50)*50)*2)+50  /* Figure out how     */\n                                               /* many Meg to plot   */\n\nDOMAIN   = Format(DOMAIN,4)                    /*                    */\nWSMRV    = Format(WSMRV,6)                     /*                    */\n                                               /*                    */\nSelect                                         /*                    */\n   When Bitand(EVENTCDE,'80'x)= '80'x Then Do  /*                    */\n      EVENT = 'LongW'                          /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'40'x)= '40'x Then Do  /*                    */\n      EVENT = 'TermW'                          /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'20'x)= '20'x Then Do  /*                    */\n      EVENT = 'OutTrmW'                        /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'10'x)= '10'x Then Do  /*                    */\n      EVENT = 'CompInp'                        /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'08'x)= '08'x Then Do  /*                    */\n      EVENT = 'EnqHold'                        /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'04'x)= '04'x Then Do  /*                    */\n      EVENT = 'QSCEST'                         /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'02'x)= '02'x Then Do  /*                    */\n      EVENT = 'QSCECMP'                        /*                    */\n      End                                      /*                    */\n   When Bitand(EVENTCDE,'01'x)= '01'x Then Do  /*                    */\n      EVENT = 'MSODetW'                        /*                    */\n      End                                      /*                    */\n   Otherwise EVENT = ''                        /*                    */\nEnd                                            /* Select             */\n                                               /*                    */\nRSTOR    = (RSTOR*4)/1024                      /* Convert To MEG     */\nESTOR    = (ESTOR*4)/1024                      /* Convert To MEG     */\nSTORAGE  = (STORAGE*4)/1024                    /*                    */\n\nEXCPCNT  = ECNT\nEXCPCNT  = Format(EXCPCNT,12)\n\nESTOR    = Format(ESTOR,4,2)                   /*                    */\nRSTOR    = Format(RSTOR,4,2)                   /*                    */\n                                               /*                    */\nTARWSS   = Format(TARWSS,6)                    /*                    */\n                                               /*                    */\n$RSTOR   = Format(((RSTOR*100)/TOTREAL),2,2)   /*                    */\n$ESTOR   = Format(((ESTOR*100)/TOTEXP),2,2)    /*                    */\n\n$RSTOR   = $RSTOR||'%'                         /*                    */\n$ESTOR   = $ESTOR||'%'                         /*                    */\n                                               /*                    */\nRPCT     = (RSTOR*PLOT_X_AXIS)%BASESTOR        /*                    */\nEPCT     = (ESTOR*PLOT_X_AXIS)%BASESTOR        /*                    */\nIf (RPCT + EPCT) < PLOT_X_AXIS Then DOTS = PLOT_X_AXIS - (RPCT + EPCT)\n   Else DOTS = 0                               /*                    */\nM1       = Copies('{',RPCT)                    /*                    */\nM2       = Copies('~',EPCT)                    /*                    */\nM3       = Copies('}',DOTS)                    /*                    */\nMARKS    = M1||M2||M3                          /*                    */\nM1       = Copies('r',RPCT)                    /*                    */\nM2       = Copies('e',EPCT)                    /*                    */\nM3       = Copies('.',DOTS)                    /*                    */\nJOBPCT   = M1||M2||M3                          /*                    */\n                                               /*                    */\nRSTORM   = RSTOR||' M'                         /*                    */\nESTORM   = ESTOR||' M'                         /*                    */\n                                               /*                    */\n$TOTREAL = Format(TOTREAL,4,0)||' Meg'\n$TOTEXP  = Format(TOTEXP,4,0)||' Meg'\n                                               /*                    */\n                                               /*                    */\n   UIC1  = Format(UIC1,6)                      /*                    */\n   UIC2  = Format(UIC2,6)                      /*                    */\n   UIC3  = Format(UIC3,6)                      /*                    */\n   UIC4  = Format(UIC4,6)                      /*                    */\n                                               /*                    */\nTOTUIC   = UIC1+UIC2+UIC3+UIC4                 /*                    */\n                                               /*                    */\nIf TOTUIC = 0 Then Do                          /*                    */\n   UICDIST = Copies('.',PLOT_X_AXIS)           /*                    */\n   UICMSKS = Copies('}',PLOT_X_AXIS)           /*                    */\n   Signal ALL_UIC_ARE_ZEROS                    /*                    */\n   End                                         /*                    */\n                                               /*                    */\nTEMP1    = (UIC1*PLOT_X_AXIS)%TOTUIC           /*                    */\nTEMP2    = (UIC2*PLOT_X_AXIS)%TOTUIC           /*                    */\nTEMP3    = (UIC3*PLOT_X_AXIS)%TOTUIC           /*                    */\nTEMP4    = (UIC4*PLOT_X_AXIS)%TOTUIC           /*                    */\n                                               /*                    */\nM1       = Copies('~',TEMP1)                   /*   UIC < 256        */\nM2       = Copies('#',TEMP2)                   /*       < 40         */\nM3       = Copies('_',TEMP3)                   /*       < 20         */\nM4       = Copies('{',TEMP4)                   /*       < 4          */\n                                               /*                    */\n$M1      = Copies('$',TEMP1)                   /*   UIC < 256        */\n$M2      = Copies('*',TEMP2)                   /*       < 40         */\n$M3      = Copies('-',TEMP3)                   /*       < 20         */\n$M4      = Copies('x',TEMP4)                   /*       < 4          */\n                                               /*                    */\nUICDIST  = $M1||$M2||$M3||$M4                  /*                    */\nUICMSKS  = M1||M2||M3||M4                      /*                    */\n                                               /*                    */\n                                               /*                    */\n                                               /*                    */\nALL_UIC_ARE_ZEROS:                             /*                    */\n                                               /*                    */\nRDYTCBS = Format(RDYTCBS,10)                   /*                    */\nSWAPCNT = Format(SWAPCNT,10)                   /*                    */\nINWSS   = Format(INWSS,6)                      /*                    */\nFIXBELOW= Format(FIXBELOW,6)                   /*                    */\n                                               /*                    */\nINTPGIN = Format(INTPGIN,8)                    /*                    */\nINTPGOUT= Format(INTPGOUT,8)                   /*                    */\n                                               /*                    */\nIf SWAPCODE \u00ac= '' Then Do                      /*                    */\n   TEMP = X2D(SWAPCODE)                        /*                    */\n   If TEMP > HIGHSWAP Then SWAPTEXT = '?????'  /*                    */\n      Else Do                                  /*                    */\n         SWAPTEXT = SWAPTXT.TEMP               /*                    */\n         If Substr(SWAPSTAT,1,2)='L*' Then Do  /*                    */\n            SWAPTEXT = '**Logswap**  '||SWAPTEXT\n            End                                /* If Substr          */\n      End                                      /* Else Do            */\n   End                                         /* If SWAPCODE=       */\nElse SWAPTEXT = ''                             /*                    */\n                                               /*                    */\nAddress ISPEXEC                                /*                    */\n'ADDPOP COLUMN(13)'                            /*                    */\n'DISPLAY PANEL('JOBPANEL')'                    /*                    */\nTemprc = Rc                                    /*                    */\n'REMPOP'                                       /*                    */\nAddress TSO                                    /*                    */\n                                               /*                    */\nIf Temprc = 8 Then Signal NO_UPDATE_THIS_TIME  /*                    */\n                                               /*                    */\n                                               /*                    */\n/********************************************************************/\n/*  I've got here because user hits Enter at the JOB DISPLAY screen */\n/*  (a job being selected).  What I need to do is to loop thru      */\n/*  all ASCBs again, update info for this ASCB, and display it      */\n/*  on the same screen.  However, I will need refresh the table     */\n/*  display since it has the old info about this ASCB.              */\n/********************************************************************/\n                                               /*                    */\nCHECK_THIS_JOB = JOBN                          /*                    */\nCHECK_THIS_ASID = ASID                         /*                    */\nASCB_OFFSET = 524-4                            /* First ASCB offset  */\n                                               /*                    */\nREFRESH_IS_REQUIRED = 'Y'\n\nDo I=1 To MAXNUM\n   ASCB_OFFSET = ASCB_OFFSET + 4               /*                    */\n   ASCB  =  C2X(Storage((D2X(DASVT+ASCB_OFFSET)),4)) /*              */\n   Call PROCESS_AN_ASCB   CHECK_THIS_JOB   CHECK_THIS_ASID\n   If GOOD_ASCB_FOUND = 'Y' Then Do            /*                    */\n      SYSUIC1  = C2D(Storage(D2X(DRCEP+284),2))\n      SYSUIC2  = C2D(Storage(D2X(DRCEP+286),2))\n      SYSUIC3  = C2D(Storage(D2X(DRCEP+288),2))\n      SYSUIC4  = C2D(Storage(D2X(DRCEP+290),2))\n      Leave                                    /*                    */\n      End                                      /* If GOOD_ASCB_      */\n   End                                         /* Do I=1             */\n\nIf GOOD_ASCB_FOUND = 'Y' Then                  /*                    */\n   Signal DISPLAY_A_SPECIFIC_JOB               /*                    */\nElse Do                                        /*                    */\n   ZEDSMSG = 'Job Not Found'\n   ZEDLMSG = 'Job No Longer Avail for UPDATE Request'\n   PROCPCT  = Substr(('-Job Not Found-'),1,16)\n   MASKS    = Copies('{',MSG_X_AXIS)\n   Address ISPEXEC\n   /*   'SETMSG MSG(ISRZ001)'  */\n   'ADDPOP COLUMN(28) ROW(-1)'\n   'DISPLAY PANEL('MSGPNL')'\n   'REMPOP'\n   Address TSO\n   End                                         /*                    */\n                                               /*                    */\nNO_UPDATE_THIS_TIME:                           /*                    */\n                                               /*                    */\nIf REFRESH_IS_REQUIRED = 'Y' Then              /*                    */\n   Signal LOOP_THRU_ALL_ASCBS                  /*                    */\nElse                                           /*                    */\n   Signal DISPL_TABLE_AGAIN                    /*                    */\n\n\n\nIAMDONE:                                       /*                    */\nAddress ISPEXEC                                /*                    */\n'TBCLOSE' TABLENM                              /*                    */\nAddress TSO                                    /*                    */\n                                               /*                    */\nExit\n\n\n\nPROCESS_AN_ASCB:\n\n/*                                                                  */\n/********************************************************************/\n/*  All ASCB (and OUCB, etc ..) info will be interrogated and saved */\n/*  for all Asid's in this routine.                                 */\n/********************************************************************/\n/*  This routine can by called with parms.  This is done when       */\n/*  a job is selected and user Press Enter key to update ADRSPC     */\n/*  info without having to exit back to the Table Display.          */\n/********************************************************************/\n\nGOOD_ASCB_FOUND = 'N'                          /*                    */\n                                               /*                    */\nIf Bitand(Substr(X2C(ASCB),1,1),'80'X) = '80'X Then\n   Return                                      /*                    */\nIf X2D(ASCB) = 0 Then Return                   /*                    */\nIf Storage(ASCB,4) \u00ac= 'ASCB' Then              /*                    */\n   Return                                      /*                    */\n                                               /*                    */\nCOUNT = COUNT + 1                              /*                    */\n                                               /*                    */\nArg SELECTED_JOB SELECTED_ASID                 /*                    */\n                                               /*                    */\n                                               /*                    */\nDASCB    = X2D(ASCB)\n\nTSB      = C2X(Storage(D2X(DASCB+60),4))       /* LOAD TSB  ADDRESS  */\nDTSB     = X2D(TSB)                            /*                    */\n\nJOBNI    = C2X(Storage(D2X(DASCB+172),4))      /*                    */\nJOBNS    = C2X(Storage(D2X(DASCB+176),4))      /*                    */\n                                               /*                    */\nIf X2D(JOBNS) = 0 AND X2D(JOBNI) = 0 Then Do   /*                    */\n   JOBN = 'Starting'                           /*                    */\n   TYPE = '*'                                  /*                    */\n   End                                         /*                    */\n                                               /*                    */\nIf X2D(JOBNI) = 0 Then Do                      /*                    */\n   If X2D(JOBNS) \u00ac=0 Then JOBN  = Storage(JOBNS,8)\n      Else JOBN = '**Init**'\n   If DTSB = 0 Then TYPE = 'S'                 /*                    */\n      Else TYPE = 'T'                          /*                    */\n   End                                         /*                    */\nElse Do                                        /*                    */\n   JOBN  = Storage(JOBNI,8)\n   TYPE  = 'B'                                 /*                    */\n   End                                         /*                    */\n                                               /*                    */\nIf SELECTED_JOB \u00ac= '' Then Do                  /*                    */\n   If SELECTED_JOB \u00ac= JOBN Then Return         /*                    */\n   End                                         /*                    */\n                                               /*                    */\nIf VIEWXEQ \u00ac= '' Then Do\n   VIEWXEQ = VIEWXEQ||' Then Return'           /*                    */\n   Interpret VIEWXEQ                           /*                    */\n   End                                         /*                    */\n                                               /*                    */\nOUCB     = C2X(Storage(D2X(DASCB+144),4))      /* LOAD OUCB ADDRESS  */\nDOUCB    = X2D(OUCB)                           /*                    */\n                                               /*                    */\nIf DOUCB = 0 Then Return                       /* OUCB is invalid    */\n                                               /*                    */\nOUXB     = C2X(Storage(D2X(DASCB+148),4))      /* LOAD OUXB ADDRESS  */\nDOUXB    = X2D(OUXB)                           /*                    */\n                                               /*                    */\nRSME     = C2X(Storage(D2X(DASCB+364),4))      /* LOAD RSME ADDRESS  */\nDRSME    = X2D(RSME)                           /*                    */\n\n\nASID     = C2X(Storage(D2X(DASCB+36),2))       /* LOAD ASID          */\n   ASID  = Substr(ASID,2,3)\n                                               /*                    */\nIf SELECTED_JOB \u00ac= '' Then Do                  /*                    */\n   If SELECTED_ASID \u00ac= ASID Then Return        /*                    */\n   End                                         /*                    */\n                                               /*                    */\nDPRTY    = C2X(Storage(D2X(DASCB+43),1))       /* LOAD PRTY          */\n  DPRTY  = Substr(DPRTY,1,2)                   /*                    */\n                                               /*                    */\nTCBTIME  = Storage(D2X(DASCB+64),8)            /* TCB CPU Time       */\nTCBTIME  = (C2D(TCBTIME)/4096)/1000000\n TCBTIME = Substr((Format(TCBTIME,14,2)),5,13)\nSRBTIME  = Storage(D2X(DASCB+200),8)           /* SRB CPU Time       */\nSRBTIME  = (C2D(SRBTIME)/4096)/1000000\n SRBTIME = Substr((Format(SRBTIME,14,2)),5,13)\nRDYTCBS  = C2X(Storage(D2X(DASCB+216),4))      /* Ready TCBS         */\n\n\nINWSS    = C2D(Storage(D2X(DOUCB+276),4))      /* Swap-in WSS        */\nDOMAIN   = C2D(Storage(D2X(DOUCB+40),1))       /* Domain             */\nWSMRV    = C2D(Storage(D2X(DOUCB+100),2))      /* WSM RV             */\n                                               /*                    */\nCall FIGURE_OUT_SWAP_STATUS                    /*                    */\n                                               /*                    */\nSWAPCNT  = C2D(Storage(D2X(DOUCB+42),2))       /* Swap-count         */\n                                               /*                    */\nTARWSS   = C2D(Storage(D2X(DOUCB+280),4))      /* Target WSS         */\n                                               /*                    */\n                                               /*                    */\nECNT     = C2D(Storage(D2X(DOUXB+152),4))      /* EXCP Count         */\nEXCPCNT  = (C2D(Storage(D2X(DOUXB+152),4)))/100    /* EXCP Count/100 */\nEXCPCNT  = Substr((Format(EXCPCNT,14)),7,8)\n                                               /*                    */\nINTPGIN  = C2D(Storage(D2X(DOUXB+16),4))\nINTPGOUT = C2D(Storage(D2X(DOUXB+20),4))\n                                               /*                    */\n                                               /*                    */\nESTOR    = C2D(Storage(D2X(DRSME+8),4))        /*                    */\n   ESTOR = Format(ESTOR,6)                     /*                    */\n                                               /*                    */\nRSTOR    = C2D(Storage(D2X(DRSME+44),4))       /*                    */\n   RSTOR = Format(RSTOR,6)                     /*                    */\n                                               /*                    */\nSTORAGE  = ESTOR + RSTOR                       /*                    */\n STORAGE = Format(STORAGE,7)                   /*                    */\n                                               /*                    */\nFIXBELOW = C2D(Storage(D2X(DRSME+48),2))       /*                    */\n                                               /*                    */\nUIC1     = C2D(Storage(D2X(DRSME+60),4))       /*                    */\nUIC2     = C2D(Storage(D2X(DRSME+64),4))       /*                    */\nUIC3     = C2D(Storage(D2X(DRSME+68),4))       /*                    */\nUIC4     = C2D(Storage(D2X(DRSME+72),4))       /*                    */\n                                               /*                    */\nGOOD_ASCB_FOUND = 'Y'                          /*                    */\n                                               /*                    */\nIf SELECTED_JOB = '' Then Do                   /* Only add to table  */\n   Call ADD_ROW_TO_TABLE                       /* during the process */\n   End                                         /* of table building  */\n                                               /* (not when called   */\n                                               /* by Selected-Job    */\nReturn                                         /* display).          */\n\n\nADD_ROW_TO_TABLE:                              /*                    */\nAddress ISPEXEC                                /*                    */\n'TBADD' TABLENM                                /*                    */\nAddress TSO                                    /*                    */\n                                               /*                    */\nReturn                                         /*                    */\n\n\n\nFIGURE_OUT_SWAP_STATUS:                        /*                    */\n                                               /*                    */\nSWAPCODE = C2X(Storage(D2X(DOUCB+41),1))       /* Swap Code          */\n                                               /*                    */\nTEMP = X2D(SWAPCODE)                           /*                    */\nIf TEMP > HIGHSWAP Then SWAPREAS = '??'        /*                    */\n   Else SWAPREAS = SWAPFLG.TEMP                /*                    */\n                                               /*                    */\nOUCBQFL  = Storage(D2X(DOUCB+16),1)            /*                    */\nOUCBSFL  = Storage(D2X(DOUCB+17),1)            /*                    */\nEVENTCDE = Storage(D2X(DOUCB+21),1)            /*                    */\n\nSelect                                         /*                    */\n   When Bitand(OUCBSFL,'80'x) = '80'x Then Do\n      SWAPSTAT = 'N/S'\n      SWAPCODE = ''                            /*                    */\n      End\n   When Bitand(OUCBQFL,'80'x) = '80'x |,\n        Bitand(OUCBQFL,'40'x) = '40'x |,\n        Bitand(OUCBQFL,'20'x) = '20'x Then Do\n      SWAPSTAT = 'Tran'\n      SWAPCODE = ''                            /*                    */\n      End                                      /*                    */\n   When Bitand(OUCBQFL,'04'x) = '04'x Then Do\n      SWAPSTAT = SWAPREAS\n      If Bitand(OUCBQFL,'02'x) = '02'x Then Do /*   This is Logical  */\n         SWAPSTAT ='L*'||SWAPSTAT              /*       Swap         */\n         End                                   /*                    */\n      End                                      /*                    */\n   OtherWise Do                                /*                    */\n      SWAPSTAT = 'In'\n      SWAPCODE = ''                            /*                    */\n      End                                      /*                    */\nEnd                                            /*                    */\nReturn                                         /*                    */\n\n\n\nPROCESS_SORT_OPTION:                           /*                    */\n\nOPTSTMT  = ''                                  /*                    */\nSORTSEQ  = ''                                  /*                    */\n                                               /*                    */\nAddress ISPEXEC                                /*                    */\n'ADDPOP COLUMN(10)'                            /*                    */\n'DISPLAY PANEL('SORTPNL')'                     /*                    */\nTemprc = Rc                                    /*                    */\n'REMPOP'                                       /*                    */\nAddress TSO                                    /*                    */\nIf Temprc = 8 Then Return                      /*                    */\n Else                                          /*                    */\n   If OPTSTMT \u00ac= '' Then Do                    /*                    */\n      SORTXEQ = 'TBSORT '||TABLENM||' FIELDS('||,\n            OPTSTMT||',C,'||SORTSEQ||')'\n      End          /* Then Do */\n   Else Do\n      SORTXEQ = ''\n      Address ISPEXEC                          /*                    */\n      'TBSORT' TABLENM 'FIELDS(COUNT,N,A)'\n      Address TSO                              /*                    */\n      End\n\nReturn                                         /*                    */\n\n\n\nPROCESS_VIEW_OPTION:                           /*                    */\n\nMYRC     = 0                                   /*                    */\nJOBFLTR  = ''                                  /*                    */\nJOBSEL   = ''                                  /*                    */\n                                               /*                    */\nAddress ISPEXEC                                /*                    */\n'ADDPOP COLUMN(10)'                            /*                    */\n'DISPLAY PANEL('VIEWPNL')'                     /*                    */\nTemprc = Rc                                    /*                    */\n'REMPOP'                                       /*                    */\nAddress TSO                                    /*                    */\nIf Temprc = 8 Then Do                          /*                    */\n   MYRC = 8                                    /*                    */\n   Signal PROCESS_VIEW_DONE                    /*                    */\n   End                                         /*                    */\n                                               /*                    */\nSelect                                         /*                    */\n   When JOBFLTR = '' Then VIEWXEQ = ''         /*                    */\n   When JOBFLTR = 'STC' Then Do                /*                    */\n      VIEWXEQ = 'If TYPE\u00ac=\"S\"'                 /*                    */\n      End                                      /*                    */\n   When JOBFLTR = 'TSU' Then Do                /*                    */\n      VIEWXEQ = 'If TYPE\u00ac=\"T\"'                 /*                    */\n      End                                      /*                    */\n   When JOBFLTR = 'BAT' Then Do                /*                    */\n      VIEWXEQ = 'If TYPE\u00ac=\"B\"'                 /*                    */\n      End                                      /*                    */\n   Otherwise Do                                /*                    */\n      JOBSEL = Strip(JOBSEL,T,'_')             /*                    */\n      JOBSEL = Strip(JOBSEL)                   /*                    */\n      JOBLENG = LENGTH(JOBSEL)                 /*                    */\n      VIEWXEQ = 'If ABBREV(JOBN,JOBSEL,JOBLENG) = 0'\n      End                                      /*                    */\n   End                                         /*    Select          */\n                                               /*                    */\nPROCESS_VIEW_DONE:                             /*                    */\nReturn MYRC                                    /*                    */\n                                               /*                    */\n                                               /*                    */\nDISPL_IN_PROGRESS_MESSAGE:                     /*                    */\n                                               /*                    */\nArg MYCOUNT                                    /*                    */\n                                               /*                    */\nTMP1     = (MYCOUNT*MSG_X_AXIS)%MAXNUM\nTMP2     = MSG_X_AXIS-TMP1                     /*                    */\nPROCPCT  = Copies(' ',TMP1)||Copies('.',TMP2)  /*                    */\nMASKS    = Copies('#',TMP1)||Copies('}',TMP2)  /*                    */\nAddress ISPEXEC                                /*                    */\n'CONTROL DISPLAY LOCK'                         /*                    */\n'ADDPOP COLUMN(62) ROW(-1)'                    /*                    */\n'DISPLAY PANEL('MSGPNL')'                      /*                    */\n'REMPOP'                                       /*                    */\nAddress TSO                                    /*                    */\nReturn                                         /*                    */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JAD#": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x94'\\x8f\\x00\\x944\\x1f\\x168\\x00\\x0b\\x00\\t\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-12-07T16:38:00", "lines": 11, "newlines": 9, "modlines": 0, "user": "$VNV"}, "text": "To install the $JAD exec, do the following:\n\n   o   Copy $JADJOB, $JADMSG, $JADSORT, $JADTBL1 and $JADVIEW to a\n       system ISPPLIB (ISPF Panel) data set of your choice.\n   o   Copy $JAD to the system SYSPROC (CLIST) or SYSEXEC (EXEC) data\n       set of your choice.\n\nSyntax for $JAD:\n\n       $JAD\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$JADJOB": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01_\\x00\\x00\\x00\\x83\\x13\\x9f\\x00\\x95\\x06\\x1f\\x13B\\x002\\x00\\x13\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.95", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "1995-03-02T13:42:00", "lines": 50, "newlines": 19, "modlines": 0, "user": "$VNV"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$JADMSG": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01[\\x00\\x00\\x00\\x83\\x13\\x9f\\x00\\x943\\x9f\\x16C\\x00\\x11\\x00\\x13\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.91", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "1994-12-05T16:43:00", "lines": 17, "newlines": 19, "modlines": 0, "user": "$VNV"}, "text": ")ATTR\n \\ AREA(DYNAMIC)\n { TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(RED)\n ~ TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(BLUE)\n # TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(GREEN)\n _ TYPE(CHAR)  CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)\n } TYPE(CHAR)  CAPS(OFF)                  COLOR(YELLOW)\n % TYPE(TEXT)  CAPS(OFF)\n + TYPE(TEXT)  INTENS(LOW)   CAPS(OFF)  COLOR(WHITE)\n \u00a6 TYPE(TEXT)  CAPS(OFF)  COLOR(GREEN)\n ! TYPE(TEXT)  CAPS(OFF)  COLOR(YELLOW)\n @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ) JUST(RIGHT)\n \u00ac TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(GREEN) JUST(RIGHT)\n \" TYPE(OUTPUT) JUST(ASIS) HILITE(REVERSE) COLOR(GREEN)\n)BODY WINDOW(16,1)\n\u00a6\\PROCPCT,MASKS\\\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JADPGM": {"ttr": 3086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01 \\x08\\x9f\\x01 \\x08\\x9f\\x19\"\\x06L\\x06L\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-29T00:00:00", "modifydate": "2020-03-29T19:22:09", "lines": 1612, "newlines": 1612, "modlines": 0, "user": "$VNV"}, "text": "$JADPGM  TITLE '-- JOB ACTIVITY DISPLAY - &SYSDATE - &SYSTIME --'\n$JADPGM  AMODE 31\n$JADPGM  RMODE ANY\n         PRINT NOGEN\n*\n*---------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*        DATE WRITTEN - 01/13/95\n*\n*        REGISTER USAGE\n*\n*              R0  - WORK\n*              R1  - WORK\n*              R2  - USED AS BASE FOR CVT, ASVT ...\n*              R3  - USED AS COUNT IN LOOPING THROUGH ASCB\n*              R4  - USED AS BASE FOR OUCB, OUXB ..\n*              R5  -\n*              R6  -\n*              R7  -\n*              R8  -\n*              R9  - USED AS SUBROUTINE RC\n*              R10 -\n*              R11 - BASE REG\n*              R12 - BASE REG\n*              R13 -\n*              R14 - TEMP - RETURN ADDRESS TO CALLER\n*              R15 - TEMP - ADCON/ENTRY ADDRESS\n*\n*        PURPOSE -\n*              THIS PGM WILL GO THROUGH THE ASCB CHAIN AND DISPLAY\n*              INFORMATION ABOUT EACH ADDRESS SPACE.  ISPF TABLE\n*              FACILITY IS USED, WHICH ALLOWS SORTING ON ANY OF\n*              THE FIELDS.  SOME OF THE INFORMATION DISPLAYED INCLUDE:\n*              TCB, SRB, EXCP, TOT STOR, CENTRAL, EXPANDED, SWAP STAT.\n*              SINCE SORTING IS ALLOWED, THIS PGM WILL GIVE DIFFERENT\n*              VIEWS OF THE SYSTEM.\n*\n*        SYNTAX -\n*              $JADPGM (NO OPERANDS REQUIRED)\n*\n*---------------------------------------------------------------------\n*\n$JADPGM  CSECT\n         SET   (R12,R11),LV=WKLENG,DSECT=WKAREA\n*\n         MVC   WLINKQRY,LINKQRY    MOVE TO WK AREA\n         LINK  SF=(E,WLINKQRY)     CALL 'ISPQRY'\n         LTR   R15,R15             TEST FOR RET CODE\n         BNZ   END$JAD             IF NON-ZERO THEN EXIT\n*\n         XC    LINKADD,LINKADD     CLEAR OUT THE SAVED ADDRESS\n         LOAD  EP=ISPLINK\n         ST    R0,LINKADD          NOW SAVE THE ENTRY ADDRESS\n*\n         XC    SWITCH,SWITCH       CLEAR OUT THE SWITCH\n         OI    SWITCH,$REFRESH     TURN ON 'REFRESH REQUIRED' SWITCH\n*\n*------- DO 'ISPEXEC CONTROL ERRORS RETURN'\n*\n         $BLDLIST WKPARM,(CONTROL,      ** FUNCTION **                 X\n               ERRRET),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n*\n*------- DEFINE ALL ISPF VARIABLES\n*\n         $BLDLIST WKPARM,(VDEFINE,      ** FUNCTION **                 X\n               DEFVAR,                  ** VAR NAMES **                X\n               WVARS,                   ** MY STORAGE FOR VAR **       X\n               VARFORM,                 ** VAR FORMAT ARRAY **         X\n               VARLENG,                 ** VAR LENGTH ARRAY **         X\n               LIST),VL\n*\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         LTR   R15,R15             IS RETURN CODE GOOD\n         BZ    GETINFO             YEAH - THEN GO THRU\n         ABEND 999\n*\n*\nGETINFO  EQU   *\n         L     R2,CVTPTR           GET ADDRESS OF CVT\n         USING CVT,R2              ESTABLISH ADDRESSABILITY\n         MVC   SYSID,CVTSNAME      SAVE THE SYSID\n         L     R14,CVTRLSTG        GET REAL STORAGE\n         SRL   R14,10              K'S -> MEG (DIVIDE BY 1024)\n         ST    R14,TOTREAL         SAVE THIS\n         L     R15,CVTRCEP         GET ADDRESS OF RCEP\n         USING RCE,R15             ESTAB ADDRESSABILITY\n         L     R14,RCEESPL         GET TOTAL EXP STORAGE IN K'S\n         SRL   R14,8               FRAME -> MEG (DIVIDE BY 256)\n         ST    R14,TOTEXP          STORE IT AWAY\n         A     R14,TOTREAL         TOTREAL + TOTEXP\n         ST    R14,TOTSTOR         STORE AWAY TOTAL (REAL  + EXP)\n*\n         LH    R14,RCEFRV1         GET SYSUIC1\n         ST    R14,SYSUIC1         SAVE IT\n*\n         LH    R14,RCEFRV2         GET SYSUIC2\n         ST    R14,SYSUIC2         SAVE IT\n*\n         LH    R14,RCEFRV3         GET SYSUIC3\n         ST    R14,SYSUIC3         SAVE IT\n*\n         LH    R14,RCEFRV4         GET SYSUIC4\n         ST    R14,SYSUIC4         SAVE IT\n*\n         DROP  R15                 DROP RCE ADDRESSABILITY\n*\n*---------------------------------------------------------------------*\n*        EVERY TIME WE GO THROUGH THE ASCB, THE ISPF TABLE NEEDS TO   *\n*        BE REBUILT.                                                  *\n*---------------------------------------------------------------------*\n*\n*------- BUILD THE ISPF TABLE\n*\nBUILDTBL EQU   *\n         TM    SWITCH,$REFRESH     DO I NEED TO CREATE THE NEW TABLE ?\n         BZ    DISPTBL             NOOP - THEN GO AROUND\n*\nOKTOBLD  EQU   *\n         NI    SWITCH,X'FF'-($JOBSLTD+$REFRESH)\n*\n         $BLDLIST WKPARM,(TBCREATE,     ** FUNCTION **                 X\n               TABLENM,                 ** TABLE NAME **               X\n               BLANK,                     NO KYWD LIST                 X\n               TABVAR,                  ** VAR NAMES **                X\n               NOWRITE,                 ** NOWRITE MODE **             X\n               REPLACE),VL              ** REPLACE OLD TABLE **\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         C     R15,=F'4'           IS RETURN CODE > 4\n         BNH   RDYLOOP             NOOP - THEN GO ON\n         MVC   ZEDSMSG,ERR1S\n         MVC   ZEDLMSG,ERR1L\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     END$JAD             AND THEN EXIT\n*\nRDYLOOP  EQU   *\n         OI    SWITCH,$TBCREAT     INDICATE THAT TABLE WAS CREATED\n         L     R2,CVTPTR           GET ADDRESS OF CVT\n         USING CVT,R2              ESTABLISH ADDRESSABILITY\n*\n         L     R14,CVTOPCTP        GET SRM TABLE ADDRESS\n         L     R14,4(,R14)         GET CCT ADDRESS\n         LH    R14,102(,R14)       LOAD CPU % BUSY (FROM SRM)\n         CVD   R14,DWORD           CONVERT THIS TO DEC FOR DISPLAY\n         MVC   WKPARM(L'CPUPCT),CPUPCT\n         ED    WKPARM(L'CPUPCT),DWORD+6\n         MVC   CPUP(L'CPUP-1),WKPARM+1\n         MVI   CPUP+L'CPUP-1,C'%'\n*\n         L     R2,CVTASVT          LOAD ADDRESS OF THE ASVT\n*\n         DROP  R2\n         USING ASVT,R2\n         L     R3,ASVTMAXU         GET NUMBER OF A.S.\n         LA    R2,ASVTFRST         GET THE FIRST ASCB ENTRY ADDRESS\n         ST    R2,NEXTASCB         SAVE THIS AWAY\n         XC    COUNT,COUNT\n         DROP  R2\n*\nLOOPASCB EQU   *\n*\n*------- NEXTASCB POINTS TO NEXT ASCB ADDRESS, R3=HOW MANY A.S.\n*\n         L     R2,NEXTASCB         GET ADDRESS OF NEXT ASVT ENTRY\n         TM    0(R2),ASVTAVAI      IS ASCB AVAILABLE ?\n         BO    ASCBNEXT            YEAH - THEN GO TO NEXT\n*\n         L     R2,0(,R2)           LOAD ADDRESS OF ASCB\n         ST    R2,CURRASCB         SAVE ASCB ADDRESS FIRST\n         BAL   R14,DO#1ASCB        NOW - GO PROCESS THIS ONE ASCB\n*\n         TM    SWITCH,$FNDASCB     IS THIS ASCB GOOD ???\n         BZ    ASCBNEXT            NOOP - THEN GO GET THE NEXT ONE\n*\n         $BLDLIST WKPARM,(TBADD,TABLENM),VL     ** FUNCTION **\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    ASCBNEXT            IF ZERO - THEN RESET TO TOP OF TBL\n         MVC   ZEDSMSG,ERR2S       ELSE - PUT\n         MVC   ZEDLMSG,ERR2L              OUT ERROR MESSAGE\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     END$JAD             AND THEN EXIT\n*\nASCBNEXT EQU   *\n         L     R2,NEXTASCB         LOAD ASCB ENTRY ADDRESS INTO R2\n         LA    R2,4(,R2)           POINT TO NEXT ASCB\n         ST    R2,NEXTASCB         SAVE IT AWAY\n         BCT   R3,LOOPASCB\n*\n         TM    SWITCH,$JOBSORT     IS SORT REQUIRED ?\n         BZ    TOPIT               NOOP - THEN GO AROUND\n*\nSORTTBL  EQU   *\n         TM    SWITCH,$JOBSORT     IS SORT REQUIRED ?\n         BZ    TOPIT               NOOP - THEN GO RIGHT BYE\n         $BLDLIST WKPARM,(TBSORT,TABLENM,WSORT),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n*\nTOPIT    EQU   *\n         $BLDLIST WKPARM,(TBTOP,TABLENM),VL     ** FUNCTION **\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    DISPTBL             NOW GOTO DISPLAY IT\n         MVC   ZEDSMSG,ERR3S       ELSE - PUT\n         MVC   ZEDLMSG,ERR3L              OUT ERROR MESSAGE\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     END$JAD             AND THEN EXIT\n*\nDISPTBL  EQU   *\n         MVC   MYCMD,BLANK\n         MVC   MYSEL,BLANK\n         $BLDLIST WKPARM,(TBDISPL,TABLENM,TABPANEL),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         C     R15,=F'8'           IS IT 'END' OR 'RETURN' ?\n         BE    END$JAD             YES - THEN I AM DONE\n         C     R15,=F'4'           IS IT '4' OR LESS ??\n         BNH   CKINPUT             YES - THEN CHECK THE INPUT\n*\n         MVC   ZEDSMSG,ERR4S       ELSE - PUT\n         MVC   ZEDLMSG,ERR4L              OUT ERROR MESSAGE\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     END$JAD\n*\n*\n*---------------------------------------------------------------------*\n*        THE INPUT COMMAND IS CHECKED HERE. CURRENTLY, ONLY 'SORT'    *\n*        AND 'VIEW' ARE ALLOWED.                                      *\n*---------------------------------------------------------------------*\n*\nCKINPUT  EQU   *\n         CLC   MYCMD,BLANK         IS CMD BLANK ??\n         BNE   CKSORT              NOOP - CHECK FOR 'SORT'\n         CLI   MYSEL,C'_'          IS ANYTHING SELECTED ??\n         BE    OKTOBLD             NOOP - THEN RE-BUILD TABLE\n         B     JOBDISP             ELSE - GO DISPLAY A JOB\n*\nCKSORT   EQU   *\n         CLC   MYCMD(4),=CL4'SORT' IS IT 'SORT' ??\n         BNE   CKVIEW              NOOP - THEN CHECK FOR VIEW\n         BAL   R14,SORTOPTS        ELSE - PROCESS SORT OPTIONS\n         B     SORTTBL             AND NOW - BACK TO DISPLAY\n*\nCKVIEW   EQU   *\n         CLC   MYCMD(4),=CL4'VIEW' IS IT 'VIEW' ??\n         BNE   TOPIT               NOOP - THEN RE-DISPLAY TABLE\n         BAL   R14,VIEWOPTS        ELSE - PROCESS VIEW OPTIONS\n         LTR   R15,R15             CHECK RETURN CODE\n         BZ    OKTOBLD             -- IF 'ENTER' WAS HIT ..\n         B     DISPTBL             -- IF 'END' KEY WAS HIT ..\n*\n*\n*---------------------------------------------------------------------*\n*        THIS IS WHEN AN ADDRESS SPACE IS SELECTED FOR DISPLAY.       *\n*        ALL PERTINENT INFO ABOUT THE A.S. IS DISPLAYED.  THE USER    *\n*        CAN PRESS ENTER OR PF3 TO GET OUT.  IF USER PRESSES ENTER,   *\n*        WE NEED TO GO THROUGH THE ASCB, PICK OUT THE SELECTED        *\n*        ASCB (USING JOBNAME & ASID), AND THEN CONTINUE TO DISPLAY    *\n*        THE SAME INFORMATION ON THE JOB DISPLAY SCREEN.  ALSO, A     *\n*        FLAG IS TURNED ON SO THAT WHEN PF3 IS HIT, A NEW TABLE WILL  *\n*        BE REBUILT (REFRESHED). HOWEVER, IF PF3 WAS HIT IMMEDIATELY  *\n*        AFTER THE DISPLAY, THEN THE TABLE IS LEFT INTACT, AND        *\n*        IT WILL BE RE-DISPLAYED WITH THE SELECTED A.S. POSITIONED    *\n*        AT THE TOP OF SCREEN.                                        *\n*---------------------------------------------------------------------*\n*\n*\nJOBDISP  EQU   *\n         MVC   POPCOL,=F'13'\n         XC    POPROW,POPROW\n         BAL   R14,DOADDPOP        POSITION THE POP-UP WINDOW\n*\n#JOBCKIT EQU   *\n         L     R14,STORAGE         GET MY TOTAL STORAGE SO FAR\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         SRDA  R14,32              GET READY FOR DIVIDE\n         D     R14,=F'50'          NOW - DIVIDE BY 50\n         MH    R15,=H'100'         MULTIPLY IT BACK TO 50*2\n         A     R15,=F'50'          AND THEN ADD 50 ON TOP\n         ST    R15,BASESTOR        SAVE THIS NEW TOTAL FOR DISPLAY\n*\n         MVC   EXCPCNT,$EXCPCNT    GET ORIGINAL EXCP COUNT BACK (X100)\n*\n         MVC   EVENT,BLANK\n         TM    EVENTCDE,OUCBLWT    IS IS LONG WAIT\n         BO    #JOBLWT             YEAH\n         TM    EVENTCDE,OUCBTRM    IS IS TERM WAIT\n         BO    #JOBTRM             YEAH\n         TM    EVENTCDE,OUCBOWT    IS IS OUPUT WAIT\n         BO    #JOBOWT             YEAH\n         TM    EVENTCDE,OUCBCIM    IS IS INPUT WAIT\n         BO    #JOBCIM             YEAH\n         TM    EVENTCDE,OUCBNQF    IS IS ENQ WAIT\n         BO    #JOBNQF             YEAH\n         TM    EVENTCDE,OUCBQSS    IS IS QSCEST WAIT\n         BO    #JOBQSS             YEAH\n         TM    EVENTCDE,OUCBQSC    IS IS QSCECMP WAIT\n         BO    #JOBQSC             YEAH\n         TM    EVENTCDE,OUCBMWT    IS IS MSO WAIT\n         BO    #JOBMWT             YEAH\n         B     #JOBFLOK\n*\n#JOBLWT  EQU   *\n         MVC   EVENT,#MSGLWT\n         B     #JOBFLOK\n*\n#JOBTRM  EQU   *\n         MVC   EVENT,#MSGTRM\n         B     #JOBFLOK\n*\n#JOBOWT  EQU   *\n         MVC   EVENT,#MSGOWT\n         B     #JOBFLOK\n*\n#JOBCIM  EQU   *\n         MVC   EVENT,#MSGCIM\n         B     #JOBFLOK\n*\n#JOBNQF  EQU   *\n         MVC   EVENT,#MSGNQF\n         B     #JOBFLOK\n*\n#JOBQSS  EQU   *\n         MVC   EVENT,#MSGQSS\n         B     #JOBFLOK\n*\n#JOBQSC  EQU   *\n         MVC   EVENT,#MSGQSC\n         B     #JOBFLOK\n*\n#JOBMWT  EQU   *\n         MVC   EVENT,#MSGMWT\n         B     #JOBFLOK\n*\n#JOBFLOK EQU   *\n         L     R14,RSTOR\n         MH    R14,=H'100'\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         CVD   R14,DWORD           CONVERT RSTOR (XX.XX) TO DEC\n         MVC   WKPARM(L'MEGPAT),MEGPAT\n         ED    WKPARM(L'MEGPAT),DWORD+5\n         MVC   RSTORM(6),WKPARM+1       RSTORM = RSTOR(XXX.XX)\n         MVI   RSTORM+7,C'M'            RSTORM = RSTOR(XXX.XX M)\n*\n         L     R14,ESTOR\n         MH    R14,=H'100'\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         CVD   R14,DWORD           CONVERT RSTOR (XX.XX) TO DEC\n         MVC   WKPARM(L'MEGPAT),MEGPAT\n         ED    WKPARM(L'MEGPAT),DWORD+5\n         MVC   ESTORM(6),WKPARM+1       ESTORM = ESTOR(XXX.XX)\n         MVI   ESTORM+7,C'M'            ESTORM = ESTOR(XXX.XX M)\n*\n         L     R14,RSTOR\n         MH    R14,=H'10000'\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         SRDA  R14,32              FIGURE OUT RSTOR AS PCT\n         D     R14,TOTREAL\n         CVD   R15,DWORD\n         MVC   WKPARM(L'MEGPAT),MEGPAT\n         ED    WKPARM(L'MEGPAT),DWORD+5\n         MVC   $RSTOR(5),WKPARM+2       $RSTOR = RSTOR(XX.XX%)\n         MVI   $RSTOR+5,C'%'            $RSTOR = RSTOR(XX.XX%)\n*\n         L     R14,ESTOR\n         MH    R14,=H'10000'\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         SRDA  R14,32              FIGURE OUT ESTOR AS PCT\n         D     R14,TOTEXP\n         CVD   R15,DWORD\n         MVC   WKPARM(L'MEGPAT),MEGPAT\n         ED    WKPARM(L'MEGPAT),DWORD+5\n         MVC   $ESTOR(5),WKPARM+2       $ESTOR = ESTOR(XX.XX%)\n         MVI   $ESTOR+5,C'%'            $ESTOR = ESTOR(XX.XX%)\n*\n         L     R14,TOTREAL\n         CVD   R14,DWORD\n         MVC   WKPARM(L'TOTPAT),TOTPAT\n         ED    WKPARM(L'TOTPAT),DWORD+5\n         MVC   $TOTREAL(4),WKPARM+2     $TOTREAL = TOTREAL\n         MVC   $TOTREAL+4(4),=CL4' Meg' $TOTREAL = TOTREAL+' Meg'\n*\n         L     R14,TOTEXP\n         CVD   R14,DWORD\n         MVC   WKPARM(L'TOTPAT),TOTPAT\n         ED    WKPARM(L'TOTPAT),DWORD+5\n         MVC   $TOTEXP(4),WKPARM+2      $TOTEXP = TOTEXP\n         MVC   $TOTEXP+4(4),=CL4' Meg'  $TOTEXP = TOTEXP+' Meg'\n*\n         MVC   SWAPTEXT,BLANK\n         CLI   SWAPCODE,X'00'      IS IT '00' (I SET IT TO '00') ?\n         BE    #JNOSWAP            YEAH - THEN FORGET THIS\n*\n         XR    R1,R1\n         IC    R1,SWAPCODE         GET SWAP CODE\n         BCTR  R1,0                SWAPCODE - 1\n         MH    R1,=AL2(SWAPLENG)   GET OFFSET INTO SWAP TABLE\n         LA    R14,SWAPTAB         GET ADDRESS OF THE SWAP CODE TABLE\n         LA    R14,2(R1,R14)       ADD THE OFFSET\n         CLC   SWAPSTAT(2),=C'L*'  LOGICAL SWAP ??\n         BE    #JLOGSW             YEAH ...\n         MVC   SWAPTEXT,0(R14)\n         B     #JNOSWAP\n*\n#JLOGSW  EQU   *\n         MVC   SWAPTEXT(13),=CL13'**LogSwap**  '\n         MVC   SWAPTEXT+13(L'SWAPTEXT-13),0(R14)\n*\n#JNOSWAP EQU   *\n         L     R14,RSTOR\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT THE RSTOR ON THE PLOT\n         D     R14,BASESTOR\n         ST    R15,RPCT\n*\n         L     R14,ESTOR\n         SRL   R14,8               DIVIDE BY 256 (FRAME -> MEG)\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT THE ESTOR ON THE PLOT\n         D     R14,BASESTOR\n         ST    R15,EPCT\n*\n         A     R15,RPCT            TOTAL OF RPCT&EPCT\n         LH    R14,PLOTAXIS\n         SR    R14,R15             NUMBER OF DOTS LEFT TO PLOT\n         ST    R14,DOTS\n*\n         MVC   MARKS,BLANK\n         MVC   JOBPCT,BLANK\n*\n         LA    R14,MARKS\n         LA    R15,JOBPCT\n*\n         ICM   R1,B'1111',RPCT     GET NUMBER OF DOTS FOR RSTOR\n         BZ    #J#EPCT\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'{'\n         MVI   0(R15),C'r'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JNORPCT          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n#JNORPCT EQU   *\n         LA    R14,2(R1,R14)       MOVE TO NEXT POSITION\n         LA    R15,2(R1,R15)            \"\"\"\"\"\"\"\"\"\n*\n#J#EPCT  EQU   *\n         ICM   R1,B'1111',EPCT     GET NUMBER OF DOTS FOR ESTOR\n         BZ    #J#DOTS\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'~'\n         MVI   0(R15),C'e'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JNOEPCT          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n#JNOEPCT EQU   *\n         LA    R14,2(R1,R14)       MOVE TO NEXT POSITION\n         LA    R15,2(R1,R15)            \"\"\"\"\"\"\"\"\"\n*\n#J#DOTS  EQU   *\n         L     R1,DOTS             GET NUMBER OF DOTS LEFT OVER\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'}'\n         MVI   0(R15),C'.'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JDOUIC           YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n         B     #JDOUIC\n*\nMOVEMRKS MVC   1(0,R14),0(R14)\nMOVEPCT  MVC   1(0,R15),0(R15)\n*\n#JDOUIC  EQU   *\n         L     R14,UIC1\n         A     R14,UIC2\n         A     R14,UIC3\n         A     R14,UIC4\n         ST    R14,TOTUIC          FIGURE OUT TOTAL OF ALL UIC\n         LTR   R14,R14             TEST FOR ZEROS (TOTAL UIC)\n         BZ    #JZERO              IF YES - THEN PUT OUT DOTS ONLY\n*\n*------- DO UIC1\n*\n         L     R14,UIC1\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT UIC PORTION THE PLOT\n         D     R14,TOTUIC\n         ST    R15,TEMP1\n*\n*------- DO UIC2\n*\n         L     R14,UIC2\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT UIC PORTION THE PLOT\n         D     R14,TOTUIC\n         ST    R15,TEMP2\n*\n*------- DO UIC3\n*\n         L     R14,UIC3\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT UIC PORTION THE PLOT\n         D     R14,TOTUIC\n         ST    R15,TEMP3\n*\n*------- DO UIC4\n*\n         L     R14,UIC4\n         MH    R14,PLOTAXIS\n         SRDA  R14,32              FIGURE OUT UIC PORTION THE PLOT\n         D     R14,TOTUIC\n         ST    R15,TEMP4\n*\n         MVC   UICDIST,BLANK\n         MVC   UICMSKS,BLANK\n*\n         LA    R14,UICMSKS\n         LA    R15,UICDIST\n*\n*\n*\n         ICM   R1,B'1111',TEMP1    GET NUMBER OF DOTS FOR UIC1\n         BZ    #J#UIC2\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'~'\n         MVI   0(R15),C'$'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JNOUIC1          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n#JNOUIC1 EQU   *\n         LA    R14,2(R1,R14)       MOVE TO NEXT POSITION\n         LA    R15,2(R1,R15)            \"\"\"\"\"\"\"\"\"\n*\n#J#UIC2  EQU   *\n*\n         ICM   R1,B'1111',TEMP2    GET NUMBER OF DOTS FOR UIC2\n         BZ    #J#UIC3\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'#'\n         MVI   0(R15),C'*'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JNOUIC2          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n#JNOUIC2 EQU   *\n         LA    R14,2(R1,R14)       MOVE TO NEXT POSITION\n         LA    R15,2(R1,R15)            \"\"\"\"\"\"\"\"\"\n*\n*\n#J#UIC3  EQU   *\n*\n         ICM   R1,B'1111',TEMP3    GET NUMBER OF DOTS FOR UIC3\n         BZ    #J#UIC4\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'_'\n         MVI   0(R15),C'-'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JNOUIC3          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n#JNOUIC3 EQU   *\n         LA    R14,2(R1,R14)       MOVE TO NEXT POSITION\n         LA    R15,2(R1,R15)            \"\"\"\"\"\"\"\"\"\n*\n*\n#J#UIC4  EQU   *\n*\n         ICM   R1,B'1111',TEMP4    GET NUMBER OF DOTS FOR UIC4\n         BZ    #JOBDISP\n         BCTR  R1,0                MINUS 1 FOR EX\n         MVI   0(R14),C'{'\n         MVI   0(R15),C'x'\n         BCTR  R1,0                AND ANOTHER (REPEATED MOVE)\n         LTR   R1,R1               IS NUMBER NEGATIVE\n         BC    4,#JOBDISP          YEH - THEN DON'T BOTHER TO MOVE\n         EX    R1,MOVEMRKS         NOW - MOVE COLOR\n         EX    R1,MOVEPCT          NOW - MOVE LETTER\n*\n         B     #JOBDISP\n*\n#JZERO   EQU   *\n         MVI   UICDIST,C'.'\n         MVC   UICDIST+1(L'UICDIST-1),UICDIST\n         MVI   UICMSKS,C'}'\n         MVC   UICMSKS+1(L'UICMSKS-1),UICMSKS\n*\n#JOBDISP EQU   *\n         MVC   WPANEL,JOBPANEL\n         BAL   R14,DODISPL         DISPLAY THE JOB PANEL\n         C     R15,=F'8'           IS IT 'END' OR 'RETURN' ?\n         BE    #JOBEXIT            YEAH - THEN BACK TO DISPLAY\n         BNH   #JOBENTR            ELSE - PREPARE DATA FOR DISPLAY\n         MVC   ZEDSMSG,ERR5S\n         MVC   ZEDLMSG,ERR5L\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     #JOBEXIT            AND BACK TO DO THE DISPLAY\n*\n#JOBENTR EQU   *\n         OI    SWITCH,$REFRESH+$JOBSLTD INDICATE TABLE NEEDS RE-BUILT\n*                                       AND 'JOB DISPLAY' IS ON\n         MVC   SAVEJOBN,JOBN       SAVE DATA\n         MVC   SAVEASID,ASID\n*\n         L     R2,CVTPTR           GET ADDRESS OF CVT\n         USING CVT,R2              ESTABLISH ADDRESSABILITY\n         L     R2,CVTASVT          LOAD ADDRESS OF THE ASVT\n         DROP  R2\n         USING ASVT,R2\n         L     R3,ASVTMAXU         GET NUMBER OF A.S.\n         LA    R2,ASVTFRST         GET THE FIRST ASCB ENTRY ADDRESS\n         ST    R2,NEXTASCB         SAVE THIS AWAY\n         XC    COUNT,COUNT\n         DROP  R2\n*\n#JLOOP   EQU   *\n*\n*------- NEXTASCB POINTS TO NEXT ASCB ADDRESS, R3=HOW MANY A.S.\n*\n         L     R2,NEXTASCB         GET ADDRESS OF NEXT ASVT ENTRY\n         TM    0(R2),ASVTAVAI      IS ASCB AVAILABLE ?\n         BO    #JNEXT              YEAH - THEN GO TO NEXT\n*\n         L     R2,0(,R2)           LOAD ADDRESS OF ASCB\n         ST    R2,CURRASCB         SAVE ASCB ADDRESS FIRST\n         BAL   R14,DO#1ASCB        NOW - GO PROCESS THIS ONE ASCB\n*\n         TM    SWITCH,$FNDASCB     IS THIS ASCB GOOD ???\n         BO    #JOBCKIT            THEN - I FOUND THE ONE\n*\n*\n#JNEXT   EQU   *\n         L     R2,NEXTASCB         LOAD ASCB ENTRY ADDRESS INTO R2\n         LA    R2,4(,R2)           POINT TO NEXT ASCB\n         ST    R2,NEXTASCB         SAVE IT AWAY\n         BCT   R3,#JLOOP\n*\n         BAL   R14,DOREMPOP\n*\n         MVC   PROCPCT,JOBNOTFN    MOVE 'JOBNOTFOUND' MSG TO DISPLAY\n         MVI   MASKS,C'{'\n         MVC   MASKS+1(L'MASKS-1),MASKS\n         MVC   POPROW,=F'-1'\n         MVC   POPCOL,=F'28'\n         BAL   R14,DOADDPOP        POSITION THE POP-UP WINDOW\n         MVC   WPANEL,MSGPNL\n         BAL   R14,DODISPL         DISPLAY THE JOB PANEL\n*\n#JOBEXIT EQU   *\n         BAL   R14,DOREMPOP\n         B     BUILDTBL\n         EJECT\n*\n*\n*------- TO PROCESS THE 'SORT' OPTIONS AND PREPARE THE APPROPRIATE\n*------- STATEMENTS USED IN 'TBSORT'\n*\nSORTOPTS EQU   *\n         ST    R14,##SORT          SAVE R14\n         MVC   POPCOL,=F'8'\n         XC    POPROW,POPROW\n         BAL   R14,DOADDPOP        POSITION THE POP-UP WINDOW\n*\n         MVC   WPANEL,SORTPNL\n         BAL   R14,DODISPL         DISPLAY THE SORT PANEL\n         C     R15,=F'8'           IS IT 'END' OR 'RETURN' ?\n         BE    #SRTEND             YEAH - THEN BACK TO DISPLAY\n         BNH   SORTCKIT            ELSE - CHECK FOR SORT OPTIONS\n         MVC   ZEDSMSG,ERR5S       ELSE - PUT\n         MVC   ZEDLMSG,ERR5L              OUT ERROR MESSAGE\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     #SRTEND             AND BACK TO DO THE DISPLAY\n*\nSORTCKIT EQU   *\n         MVC   WSORT,$SORT         MOVE THE 'SORT' MODEL STMT TO WKAREA\n*\n         CLC   OPTSTMT,BLANK       IS IT BLANK ?\n         BE    #SNONE              YEAH - THEN SORT BY 'COUNT'\n*\n         OI    SWITCH,$JOBSORT     TURN ON 'SORT-REQUIRED' SWITCH\n*\n         CLC   =C'JOBN',OPTSTMT    IS IT 'JOBN' ?\n         BE    #SJOBN              YEAH ...\n         CLC   =C'TCBTIME',OPTSTMT    IS IT 'TCB' ?\n         BE    #STCB               YEAH ...\n         CLC   =C'SRBTIME',OPTSTMT    IS IT 'SRB' ?\n         BE    #SSRB               YEAH ...\n         CLC   =C'STORAGE',OPTSTMT    IS IT 'STORAGE' ?\n         BE    #SSTG               YEAH ...\n         CLC   =C'RSTOR',OPTSTMT      IS IT 'RSTOR' ?\n         BE    #SRSTOR             YEAH ...\n         CLC   =C'ESTOR',OPTSTMT      IS IT 'ESTOR' ?\n         BE    #SESTOR             YEAH ...\n         CLC   =C'EXCPCNT',OPTSTMT    IS IT 'EXCP' ?\n         BE    #SEXCP              YEAH ...\n         B     #SRTEND             ELSE - NOTHING\n*\n#SJOBN   EQU   *\n         MVC   WKPARM(8),=CL8'JOBN'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'C'        'CHARACTER' SORT\n         B     #SSETUP\n*\n#STCB    EQU   *\n         MVC   WKPARM(8),=CL8'TCBTIME'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'NUMERIC' SORT\n         B     #SSETUP\n*\n#SSRB    EQU   *\n         MVC   WKPARM(8),=CL8'SRBTIME'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'NUMERIC' SORT\n         B     #SSETUP\n*\n#SSTG    EQU   *\n         MVC   WKPARM(8),=CL8'STORAGE'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'BINARY' SORT\n         B     #SSETUP\n*\n#SRSTOR  EQU   *\n         MVC   WKPARM(8),=CL8'RSTOR'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'BINARY' SORT\n         B     #SSETUP\n*\n#SESTOR  EQU   *\n         MVC   WKPARM(8),=CL8'ESTOR'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'BINARY' SORT\n         B     #SSETUP\n*\n#SEXCP   EQU   *\n         MVC   WKPARM(8),=CL8'EXCPCNT'\n         MVC   DWORD(1),SORTSEQ\n         MVI   DWORD+1,C'N'        'BINARY' SORT\n         B     #SSETUP\n*\n*\n#SSETUP  EQU   *\n         MVC   WSORT+$SORTFLD(8),WKPARM\n         MVC   WSORT+$SORTSEQ(1),DWORD\n         MVC   WSORT+$SORTYPE(1),DWORD+1\n         B     #SRTEND\n*\n#SNONE   EQU   *\n         NI    SWITCH,X'FF'-$JOBSORT    TURN ON 'SORT' SWITCH\n         $BLDLIST WKPARM,(TBSORT,TABLENM,WSORT),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n*\n#SRTEND  EQU   *\n         BAL   R14,DOREMPOP\n         L     R14,##SORT          RELOAD RETURN ADDRESS\n         BR    R14                 BACK TO CALLER\n         EJECT\n*\n*\n*------- TO SETUP 'JOB' FILTER, I.E. STC ONLY, TSU ONLY ...\n*\nVIEWOPTS EQU   *\n         ST    R14,##VIEW          SAVED REG 14\n*\n         MVC   POPCOL,=F'10'\n         XC    POPROW,POPROW\n         BAL   R14,DOADDPOP        POSITION THE POP-UP WINDOW\n*\n         MVC   WPANEL,VIEWPNL\n*\n         XR    R9,R9               CLEAR RETURN CODE FOR THIS ROUTINE\n*\n         BAL   R14,DODISPL         DISPLAY THE SORT PANEL\n         C     R15,=F'8'           IS IT 'END' OR 'RETURN' ?\n         BE    #VIEWNOP            YEAH - THEN BACK TO DISPLAY\n         BNH   #VIEWCK             IF LESS THAN 4 ...\n         MVC   ZEDSMSG,ERR5S\n         MVC   ZEDLMSG,ERR5L\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n         B     #VIEWNOP            AND BACK TO DO THE DISPLAY\n*\n#VIEWCK  EQU   *\n         MVI   SAVETYPE,C' '       BLANK OUT 'SAVED' TYPE\n*\n         CLC   JOBFLTR,BLANK       IS 'VIEW FILTER' REQUIRED ?\n         BE    #VNONE\n*\n         OI    SWITCH,$JOBVIEW     TURN ON 'VIEW FILTER' SWITCH\n*\n         CLC   =C'STC',JOBFLTR     IS IT 'STC' ONLY ??\n         BE    #VSTC\n         CLC   =C'TSU',JOBFLTR     IS IT 'TSU' ONLY ??\n         BE    #VTSU\n         CLC   =C'BAT',JOBFLTR     IS IT 'BAT' ONLY ??\n         BE    #VBAT\n         CLC   =C'JOB',JOBFLTR     IS IT 'JOB' ONLY ??\n         BE    #VJOB\n         B     #VNONE              ELSE - ASSUME LIKE NOTHIN' HAPPENED\n*\n#VSTC    EQU   *\n         MVI   SAVETYPE,C'S'       SAVED 'S' FOR COMPARISON LATER\n         B     #VIEWEND            THEN GO BACK TO CALLER\n*\n#VTSU    EQU   *\n         MVI   SAVETYPE,C'T'       SAVED 'T' FOR COMPARISON LATER\n         B     #VIEWEND            THEN GO BACK TO CALLER\n*\n#VBAT    EQU   *\n         MVI   SAVETYPE,C'B'       SAVED 'B' FOR COMPARISON LATER\n         B     #VIEWEND            THEN GO BACK TO CALLER\n*\n#VJOB    EQU   *\n         MVC   SAVEJLNG,=F'7'      ASSUME LENG OF 8 INITIALLY\n         TRT   JOBSEL,JOBPFIX      TEST FOR BLANK OR '_'\n         BC    8,#V8BYTES          IF ALL ZEROS, THEN JOBSEL = 8 CHARS\n         LA    R14,JOBSEL\n         SR    R1,R14              GET LENG OF JOB PREFIX\n         BCTR  R1,0                SUB 1 FOR EXECUTE INSTRUCTION LATER\n         ST    R1,SAVEJLNG         SAVE THIS LENG\n*\n#V8BYTES EQU   *\n         MVC   SAVEJCMP,JOBSEL     AND JOB NAME FOR LATER COMPARISON\n         B     #VIEWEND            NOW - BACK TO CALLER\n*\n#VNONE   EQU   *\n         NI    SWITCH,X'FF'-$JOBVIEW    TURN OFF THE 'JOB FLTER' REQ SW\n         B     #VIEWEND            AND THEN RETURN TO CALLER\n*\n#VIEWNOP EQU   *\n         LA    R9,4                SET UP RETURN CODE\n*\n#VIEWEND EQU   *\n         BAL   R14,DOREMPOP\n         L     R14,##VIEW          GET REG 14 BACK\n         LR    R15,R9              AND SETUP RETURN CODE\n         BR    R14                 BACK TO CALLER\n*\n         EJECT\n*\n*\n*---------------------------------------------------------------------*\n*        THIS IS WHERE EACH ASCB IS EXAMINED AND APPROPRIATE DATA     *\n*        IS SAVED INTO THE ISPF TABLE.                                *\n*---------------------------------------------------------------------*\n*\n*------- R2 - ASCB, R3 - CONTAINS THE NUMBER OF ASVT ENTRIES LEFT\n*------- R4 - OUCB, OUXB, RSME\n*\nDO#1ASCB EQU   *\n         ST    R14,##DO#1          SAVE RETURN REGISTER\n         NI    SWITCH,X'FF'-$FNDASCB   TURN OFF THE 'ASCB-GOOD' SWITCH\n         ICM   R2,B'1111',CURRASCB LOAD ADDRESS OF CURRENT ASCB\n         BZ    DO#1END             IF ZERO - THEN END THIS\n         USING ASCB,R2             NOW - ESTABLISH ADDRESSABILITY\n*\n         CLC   ASCBASCB,=CL4'ASCB' IS THE ASCB GOOD ??\n         BNE   DO#1END             NOOP - THEN GET OUT\n*\n         CLC   ASCBOUCB,=F'0'      IS OUCB PTR INVALID ?\n         BE    DO#1END             YEAH - THEN GET OUT\n*\n         L     R1,COUNT            INCREMENT THE COUNT\n         LA    R1,1(,R1)\n         ST    R1,COUNT\n*\n         MVC   JOBN,=CL8'Starting'      START OUT WITH 'STARTING'\n*\n         ICM   R14,B'1111',ASCBJBNI     GET ADDRESS OF BATCH JOBN\n         BZ    #1CKSTC             IF ZERO - THEN CHECK AS STC\n         MVI   TYPE,C'B'           ELSE - THIS IS BATCH\n         MVC   JOBN,0(R14)         SAVE JOBNAME\n         B     #1CKAJOB\n*\n#1CKSTC  EQU   *\n         MVC   JOBN,=CL8'**Init**'      START OUT WITH '**INIT**'\n         ICM   R14,B'1111',ASCBJBNS     GET ADDRESS OF STC/TSO JOBN\n         BZ    #1CKTSO             IF ZERO THEN GO AROUND\n         MVC   JOBN,0(R14)         SAVE JOBNAME\n*\n#1CKTSO  EQU   *\n         MVI   TYPE,C'S'           ASSUME THIS AS 'STC' FIRST\n         ICM   R14,B'1111',ASCBTSB      IS THIS TSO ??\n         BZ    #1CKAJOB                 NOOP - THEN BRANCH AROUND\n         MVI   TYPE,C'T'                ELSE - MAKE IT TYPE 'T'\n*\n*\n#1CKAJOB EQU   *\n         LH    R1,ASCBASID         GET ASID\n         STH   R1,WKPARM           STORE THIS\n         UNPK  DWORD(5),WKPARM(3)\n         TR    DWORD(4),NUMTRT-240\n         MVC   ASID,DWORD+1        MOVE ASID\n*\n         TM    SWITCH,$JOBSLTD     IS 'JOB DISPLAY' ON\n         BZ    #1CKVIEW            NOOP - THEN GO CHECK FOR 'VIEW'\n*\n         CLC   SAVEJOBN,JOBN       IS JOB NAME MATCHING ?\n         BNE   DO#1END             NO - THEN I AM DONE HERE\n         CLC   SAVEASID,ASID       IS JOB ASID MATCHING ?\n         BNE   DO#1END             NO - THEN I AM DONE HERE\n         B     #1OUCB              I FOUND THE 'ON DISPLAY' JOB\n*\n#1CKVIEW EQU   *\n         TM    SWITCH,$JOBVIEW     IS 'VIEW FILTER' FLAG ON\n         BZ    #1OUCB              NOOP - THEN GO ON\n*\n         CLI   SAVETYPE,C' '       IS IS BY 'JOB PREFIX' ??\n         BNE   #1NOPFX             NOOP - THEN GO CHECK FOR JOBTYPE\n*\n         L     R1,SAVEJLNG         GET JOB LENG TO COMPARE\n         EX    R1,CMPJOB           AND ACTUALLY DO THE COMPARE\n         BNE   DO#1END             IF NOT THE SAME - THEN I'M GONE\n         B     #1OUCB              ELSE - CONTINUE ON\n*\nCMPJOB   CLC   SAVEJCMP(0),JOBN\n*\n#1NOPFX  EQU   *\n         CLC   TYPE,SAVETYPE       IS THE 'TYPE' MATCHING ??\n         BNE   DO#1END             NO - THEN I GETOUTA HERE\n*\n*\n*\n#1OUCB   EQU   *\n         MVC   WKPARM(1),ASCBDP    GET DISP PRIORITY\n         UNPK  DWORD(3),WKPARM(2)\n         TR    DWORD(2),NUMTRT-240\n         MVC   DPRTY,DWORD\n*\n         LM    R14,R15,ASCBEJST    GET TCB TIME\n         SRDL  R14,12              DIVIDE BY 4096\n         D     R14,=F'10000'\n         CVD   R15,DWORD\n         MVC   TCBTIME(L'PAT),PAT     MOVE PATTERN OVER\n         ED    TCBTIME(L'PAT),DWORD+3 EDIT THIS\n*\n         LM    R14,R15,ASCBSRBT    GET SRB TIME\n         SRDL  R14,12              DIVIDE BY 4096\n         D     R14,=F'10000'\n         CVD   R15,DWORD\n         MVC   SRBTIME(L'PAT),PAT     MOVE PATTERN OVER\n         ED    SRBTIME(L'PAT),DWORD+3 EDIT THIS\n*\n         MVC   RDYTCBS,ASCBTCBS    SAVE 'READY TCBS'\n*\n         ICM   R4,B'1111',ASCBOUCB LOAD ADDRESS OF OUCB\n         USING OUCB,R4             ESTAB ADDRESSABILITY\n*\n         MVC   INWSS,OUCBWSS       SAVE IN-WSS\n         MVC   TARWSS,OUCBTWSS     SAVE TARGET-WSS\n*\n         XR    R1,R1               CLEAR REGISTER\n         IC    R1,OUCBDMN          GET DOMAIN NUMBER\n         ST    R1,DOMAIN           SAVE IT\n*\n         LH    R1,OUCBVAL          GET WSM RV\n         ST    R1,WSMRV            SAVE IT\n*\n         LH    R1,OUCBSWC          GET SWAP COUNT\n         ST    R1,SWAPCNT          SAVE IT\n*\n         MVC   SWAPCODE,OUCBSRC    SAVE SWAP-OUT CODE\n*\n         MVC   SWAPSTAT,BLANK      BLANK OUT SWAPSTAT FIRST\n*\n         XR    R1,R1               CLEAR REG1\n         IC    R1,OUCBSRC          LOAD SWAP-OUT CODE\n         C     R1,NUMSWAP          IS IT > THEN WHAT I HAVE ?\n         BNH   #1SWAPOK            NOOP - THEN GO AROUND\n         MVC   SWAPSTAT,=CL4'  ??' ELSE - INIT THIS WITH ??\n         B     #1SWAPCK            NOW GO CHECK THE REAL STATUS\n*\n#1SWAPOK EQU   *\n         BCTR  R1,0                SWAPCODE - 1\n         MH    R1,=AL2(SWAPLENG)   GET OFFSET INTO SWAP TABLE\n         LA    R14,SWAPTAB         GET ADDRESS OF THE SWAP CODE TABLE\n         LA    R14,0(R1,R14)       ADD THE OFFSET\n         MVC   SWAPSTAT+2(2),0(R14)     GET THE CORRECT CODE\n*\n#1SWAPCK EQU   *\n         MVC   EVENTCDE,OUCBEFL    SAVE THE 'EVENT' CODE\n*\n         TM    OUCBSFL,OUCBNSW     NON-SWAP ??\n         BO    #1NONSW             YEAH ..\n         TM    OUCBQFL,OUCBGOO+OUCBGOI+OUCBGOB      TRANSITION ?\n         BNZ   #1TRANS             YEAH ..\n         TM    OUCBQFL,OUCBOUT     IS IT OUT (SWAP) ?\n         BO    #1LOGSW             YEAH ..\n         MVC   SWAPSTAT,=CL4'In'\n         MVI   SWAPCODE,X'00'\n         B     #1FLAGOK\n*\n#1NONSW  EQU   *\n         MVC   SWAPSTAT,=CL4'N/S'\n         MVI   SWAPCODE,X'00'\n         B     #1FLAGOK\n*\n#1TRANS  EQU   *\n         MVC   SWAPSTAT,=CL4'Tran'\n         MVI   SWAPCODE,X'00'\n         B     #1FLAGOK\n*\n#1LOGSW  EQU   *\n         TM    OUCBQFL,OUCBLSW     REALLY LOGICAL SWAP ???\n         BZ    #1FLAGOK\n         MVC   SWAPSTAT(2),=CL2'L*'\n         B     #1FLAGOK\n*\n#1FLAGOK EQU   *\n         DROP  R4\n*\n         L     R4,ASCBOUXB         LOAD ADDRESS OF OUXB\n         USING OUXB,R4\n         MVC   $EXCPCNT,OUXBIOSM   SAVE EXCP COUNT\n         L     R14,OUXBIOSM        LOAD THIS INTO R1\n         SRDA  R14,32              SHIFT FOR DIVISION\n         D     R14,=F'100'         DIVIDE BY '100'\n         ST    R15,EXCPCNT         AND SAVE IT\n         MVC   INTPGIN,OUXBPIN     SAVE PAGE-IN CNT\n         MVC   INTPGOUT,OUXBPOUT   SAVE PAGE-OUT CNT\n         DROP  R4\n*\n         L     R4,ASCBRSME         GET RSM ADDRESS\n         USING RAX,R4\n*\n         MVC   ESTOR,RAXESCT       GET EXP STORAGE FRAMES\n         MVC   RSTOR,RAXFMCT       GET CENTRAL STORAGE FRAMES\n*\n         L     R1,RAXESCT          LOAD EXP STOR FRAMES\n         A     R1,RAXFMCT          ADD CENTRAL STORAGE\n*\n         ST    R1,STORAGE          STORE TOTAL STORAGE AWAY\n*\n         LH    R1,RAXBELFX         GET BELOW-FIXED STORAGE\n         ST    R1,FIXBELOW         STORE THIS AWAY\n*\n         MVC   UIC1,RAXFBV1        SAVE UIC1\n         MVC   UIC2,RAXFBV2        SAVE UIC2\n         MVC   UIC3,RAXFBV3        SAVE UIC3\n         MVC   UIC4,RAXFBV4        SAVE UIC4\n*\n         OI    SWITCH,$FNDASCB     TURN ON 'GOOD-ASCB' SWITCH\n*\nDO#1END  EQU   *\n         L     R14,##DO#1          RELOAD RETURN REGISTER\n         BR    R14                 AND THEN BRANCH BACK\n         DROP  R2\n*\n*------- GENERAL ROUTINE TO DISPLAY AN ISPF PANEL\n*\nDODISPL  EQU   *\n         ST    R14,##DISPL         SAVE REG 14\n         $BLDLIST WKPARM,(DISPLAY,WPANEL),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         L     R14,##DISPL         RELOAD REG 14\n         BR    R14\n*\n*------- GENERAL ROUTINE TO ISSUE 'ADDPOP'\n*\nDOADDPOP EQU   *\n         ST    R14,##ADDPOP        SAVE REG 14\n         $BLDLIST WKPARM,(ADDPOP,BLANK,POPROW,  ** FUNCTION **         X\n               POPCOL),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         L     R14,##ADDPOP        RELOAD REG 14\n         BR    R14\n*\n*------- GENERAL ROUTINE TO ISSUE 'REMPOP'\n*\nDOREMPOP EQU   *\n         ST    R14,##REMPOP        SAVE REG 14\n         $BLDLIST WKPARM,(REMPOP),VL\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         L     R14,##REMPOP        RELOAD REG 14\n         BR    R14\n*\n*\n*------- THIS IS THE COMMON ROUTINE TO SET THE MSG TO BE DISPLAYED\n*\nSETMYMSG EQU   *\n         ST    R14,##MSG           SAVE REG 14\n         $BLDLIST WKPARM,(SETMSG,       ** FUNCTION **                 X\n               ISRZ001),VL              ** TABLE NAME **\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n         L     R14,##MSG           GET THE RETURN ADDRESS BACK\n         BR    R14                 NOW RETURN TO CALLER\n*\n*\n*\n*\nEND$JAD  EQU   *\n         TM    SWITCH,$TBCREAT     HAS TABLE BEEN CREATED ?\n         BZ    END#TAB             NOOP - THEN DO NO CLOSING\n*\n         $BLDLIST WKPARM,(TBCLOSE,TABLENM),VL     ** FUNCTION **\n         L     R15,LINKADD         GET LOAD ADDRESS\n         BALR  R14,R15             DO THE CALL\n*\n         MVC   ZEDSMSG,ENDSMSG\n         MVC   ZEDLMSG,ENDLMSG\n         BAL   R14,SETMYMSG        NOW SET UP MSG TO BE DISPLAYED\n*\nEND#TAB  EQU   *\n         ICM   R15,B'1111',LINKADD CHECK AND SEE IF 'ISPLINK' LOADED\n         BZ    EXIT$JAD            IF NOT - THEN JUST ENDIT\n         DELETE EP=ISPLINK         ELSE - DELETE THE MODULE\n*\nEXIT$JAD EQU   *\n         EXIT                      EXIT\n*\n         LTORG\n         EJECT\n*\n         DS    0F\nPLOTAXIS DC    AL2(L'JOBPCT)\n*\nNUMTRT   DC    C'0123456789ABCDEF'\n*\n#MSGLWT  DC    CL(L'EVENT)'Long_Wait'\n#MSGTRM  DC    CL(L'EVENT)'Term_Wait'\n#MSGOWT  DC    CL(L'EVENT)'Out_Term_Wait'\n#MSGCIM  DC    CL(L'EVENT)'Comp_Inp'\n#MSGNQF  DC    CL(L'EVENT)'Enq_Hold'\n#MSGQSS  DC    CL(L'EVENT)'QSCEST'\n#MSGQSC  DC    CL(L'EVENT)'QSCECMP'\n#MSGMWT  DC    CL(L'EVENT)'MSO_Det_Wait'\n*\nJOBNOTFN DC    CL(L'PROCPCT)'-Job Not Found-'\n*\nSWAPTAB  DS    0C\n         DC    CL2'TO',CL(L'SWAPTEXT)'Terminal Output Wait'\nSWAPLENG EQU   *-SWAPTAB           LENG OF EACH ENTRY\n         DC    CL2'TI',CL(L'SWAPTEXT)'Terminal Input Wait'\n         DC    CL2'LW',CL(L'SWAPTEXT)'Long Wait'\n         DC    CL2'XS',CL(L'SWAPTEXT)'Aux Storage Shortage'\n         DC    CL2'RS',CL(L'SWAPTEXT)'Central Storage Shortage'\n         DC    CL2'DW',CL(L'SWAPTEXT)'Detected Wait'\n         DC    CL2'RQ',CL(L'SWAPTEXT)'Requested Swap'\n         DC    CL2'NQ',CL(L'SWAPTEXT)'Enqueue Exchange'\n         DC    CL2'EX',CL(L'SWAPTEXT)'Exchange/Rec value'\n         DC    CL2'US',CL(L'SWAPTEXT)'Unilateral'\n         DC    CL2'TS',CL(L'SWAPTEXT)'Transition Swap'\n         DC    CL2'IC',CL(L'SWAPTEXT)'Improve Central Storage'\n         DC    CL2'IP',CL(L'SWAPTEXT)'Improve System Paging'\n         DC    CL2'MR',CL(L'SWAPTEXT)'Make Room Swapped Users'\n         DC    CL2'AW',CL(L'SWAPTEXT)'APPC Wait'\n         DC    CL2'OI',CL(L'SWAPTEXT)'Input Wait'\n         DC    CL2'OO',CL(L'SWAPTEXT)'Output Wait'\nSWAPEND  EQU   *\n         DS    0F\nNUMSWAP  DC    AL4((SWAPEND-SWAPTAB)/SWAPLENG)\n*\nSETMSG   DC    CL8'SETMSG'\nVDEFINE  DC    CL8'VDEFINE'        DEFINE VAR FUNCTION\nTBCREATE DC    CL8'TBCREATE'       CREATE TABLE\nTBSORT   DC    CL8'TBSORT'         TABLE SORT\nTBCLOSE  DC    CL8'TBCLOSE'        CLOSE TABLE\nTBADD    DC    CL8'TBADD'          ADD ROW TO TABLE\nTBTOP    DC    CL8'TBTOP'          GET TO TOP OF TABLE\nTBDISPL  DC    CL8'TBDISPL'        TABLE DISPLAY\nREPLACE  DC    CL8'REPLACE'\nDISPLAY  DC    CL8'DISPLAY'\nADDPOP   DC    CL8'ADDPOP'\nREMPOP   DC    CL8'REMPOP'\nNOWRITE  DC    CL8'NOWRITE'\nCONTROL  DC    CL8'CONTROL'\nLIST     DC    CL8'(LIST)'\n*\nERRRET   DS    0CL16\n         DC    CL8'ERRORS'\n         DC    CL8'RETURN'\n*\n*\nISRZ001  DC    CL8'ISRZ001'\n*\nBLANK    DC    CL80' '\n*\nPAT      DC    XL11'40202020202020214B2020'\nMEGPAT   DC    XL7'402020214B2020'\nTOTPAT   DC    XL6'402020202021'\nCPUPCT   DC    XL4'40202021'\n*\nTABVAR   DC    C'(JOBN TYPE ASID DPRTY INWSS TARWSS FIXBELOW ESTOR     X\n               RSTOR STORAGE UIC1 UIC2 UIC3 UIC4 SRBTIME TCBTIME       X\n               RDYTCBS SWAPCNT COUNT SWAPSTAT SWAPCODE EVENTCDE        X\n               EXCPCNT DOMAIN WSMRV INTPGIN INTPGOUT $EXCPCNT)'\n*\nDEFVAR   DC    C'('\n         DC    CL9'$EXCPCNT '\n         DC    CL9'BASESTOR '\n         DC    CL9'COUNT    '\n         DC    CL9'DOMAIN   '\n         DC    CL9'ESTOR    '\n         DC    CL9'EXCPCNT  '\n         DC    CL9'FIXBELOW '\n         DC    CL9'INTPGIN  '\n         DC    CL9'INTPGOUT '\n         DC    CL9'INWSS    '\n         DC    CL9'RDYTCBS  '\n         DC    CL9'RSTOR    '\n         DC    CL9'STORAGE  '\n         DC    CL9'SWAPCNT  '\n         DC    CL9'SYSUIC1  '\n         DC    CL9'SYSUIC2  '\n         DC    CL9'SYSUIC3  '\n         DC    CL9'SYSUIC4  '\n         DC    CL9'TARWSS   '\n         DC    CL9'TOTEXP   '\n         DC    CL9'TOTREAL  '\n         DC    CL9'TOTSTOR  '\n         DC    CL9'UIC1     '\n         DC    CL9'UIC2     '\n         DC    CL9'UIC3     '\n         DC    CL9'UIC4     '\n         DC    CL9'WSMRV    '\n         DC    CL9'$ESTOR   '\n         DC    CL9'$RSTOR   '\n         DC    CL9'$TOTEXP  '\n         DC    CL9'$TOTREAL '\n         DC    CL9'ASID     '\n         DC    CL9'CPUP     '\n         DC    CL9'DPRTY    '\n         DC    CL9'ESTORM   '\n         DC    CL9'EVENT    '\n         DC    CL9'EVENTCDE '\n         DC    CL9'JOBFLTR  '\n         DC    CL9'JOBN     '\n         DC    CL9'JOBPCT   '\n         DC    CL9'JOBSEL   '\n         DC    CL9'MARKS    '\n         DC    CL9'MASKS    '\n         DC    CL9'MYCMD    '\n         DC    CL9'MYSEL    '\n         DC    CL9'OPT      '\n         DC    CL9'OPTSTMT  '\n         DC    CL9'PROCPCT  '\n         DC    CL9'RSTORM   '\n         DC    CL9'SORTSEQ  '\n         DC    CL9'SRBTIME  '\n         DC    CL9'SWAPCODE '\n         DC    CL9'SWAPSTAT '\n         DC    CL9'SWAPTEXT '\n         DC    CL9'SYSID    '\n         DC    CL9'TCBTIME  '\n         DC    CL9'TYPE     '\n         DC    CL9'UICDIST  '\n         DC    CL9'UICMSKS  '\n         DC    CL9'ZEDLMSG  '\n         DC    CL9'ZEDSMSG  '\n*\n         DC    C')'            END OF VAR LIST\n*\n*\n*\nTABLENM  DC    CL8'$JADTAB'\nTABPANEL DC    CL8'$JADTBL1'\nJOBPANEL DC    CL8'$JADJOB'\nSORTPNL  DC    CL8'$JADSORT'\nVIEWPNL  DC    CL8'$JADVIEW'\nMSGPNL   DC    CL8'$JADMSG'\n*\nLINKQRY  LINK  EP=ISPQRY,SF=L\nLINKQRYL EQU   *-LINKQRY\n*\nJOBPFIX  DC    256XL1'00'\n         ORG   JOBPFIX+C' '\n         DC    C' '\n         ORG   JOBPFIX+C'_'\n         DC    C'_'\n         ORG\n*\n*------- THE FOLLOWING FIELDS NEED TO STAY TOGETHER (ISPFVAR)\n*\nVARLENG  DS    0F\n         DC    AL4(L'$EXCPCNT)\n         DC    AL4(L'BASESTOR)\n         DC    AL4(L'COUNT)\n         DC    AL4(L'DOMAIN)\n         DC    AL4(L'ESTOR)\n         DC    AL4(L'EXCPCNT)\n         DC    AL4(L'FIXBELOW)\n         DC    AL4(L'INTPGIN)\n         DC    AL4(L'INTPGOUT)\n         DC    AL4(L'INWSS)\n         DC    AL4(L'RDYTCBS)\n         DC    AL4(L'RSTOR)\n         DC    AL4(L'STORAGE)\n         DC    AL4(L'SWAPCNT)\n         DC    AL4(L'SYSUIC1)\n         DC    AL4(L'SYSUIC2)\n         DC    AL4(L'SYSUIC3)\n         DC    AL4(L'SYSUIC4)\n         DC    AL4(L'TARWSS)\n         DC    AL4(L'TOTEXP)\n         DC    AL4(L'TOTREAL)\n         DC    AL4(L'TOTSTOR)\n         DC    AL4(L'UIC1)\n         DC    AL4(L'UIC2)\n         DC    AL4(L'UIC3)\n         DC    AL4(L'UIC4)\n         DC    AL4(L'WSMRV)\n*\n         DC    AL4(L'$ESTOR)\n         DC    AL4(L'$RSTOR)\n         DC    AL4(L'$TOTEXP)\n         DC    AL4(L'$TOTREAL)\n         DC    AL4(L'ASID)\n         DC    AL4(L'CPUP)\n         DC    AL4(L'DPRTY)\n         DC    AL4(L'ESTORM)\n         DC    AL4(L'EVENT)\n         DC    AL4(L'EVENTCDE)\n         DC    AL4(L'JOBFLTR)\n         DC    AL4(L'JOBN)\n         DC    AL4(L'JOBPCT)\n         DC    AL4(L'JOBSEL)\n         DC    AL4(L'MARKS)\n         DC    AL4(L'MASKS)\n         DC    AL4(L'MYCMD)\n         DC    AL4(L'MYSEL)\n         DC    AL4(L'OPT)\n         DC    AL4(L'OPTSTMT)\n         DC    AL4(L'PROCPCT)\n         DC    AL4(L'RSTORM)\n         DC    AL4(L'SORTSEQ)\n         DC    AL4(L'SRBTIME)\n         DC    AL4(L'SWAPCODE)\n         DC    AL4(L'SWAPSTAT)\n         DC    AL4(L'SWAPTEXT)\n         DC    AL4(L'SYSID)\n         DC    AL4(L'TCBTIME)\n         DC    AL4(L'TYPE)\n         DC    AL4(L'UICDIST)\n         DC    AL4(L'UICMSKS)\n         DC    AL4(L'ZEDLMSG)\n         DC    AL4(L'ZEDSMSG)\n*\n*------- END (ISPF VARIABLES)\n*\n*\n*------- THE FOLLOWING FIELDS NEED TO STAY TOGETHER (ISPFVAR)\n*\n*\nVARFORM  DS    0F\n@$EXCPC  DC    CL8'FIXED'\n@BASEST  DC    CL8'FIXED'\n@COUNT   DC    CL8'FIXED'\n@DOMAIN  DC    CL8'FIXED'\n@ESTOR   DC    CL8'FIXED'\n@EXCPCNT DC    CL8'FIXED'\n@FIXBEL  DC    CL8'FIXED'\n@INTPIN  DC    CL8'FIXED'\n@INTPOUT DC    CL8'FIXED'\n@INWSS   DC    CL8'FIXED'\n@RDYTCBS DC    CL8'FIXED'\n@RSTOR   DC    CL8'FIXED'\n@STORAGE DC    CL8'FIXED'\n@SWAPCNT DC    CL8'FIXED'\n@SYSUIC1 DC    CL8'FIXED'\n@SYSUIC2 DC    CL8'FIXED'\n@SYSUIC3 DC    CL8'FIXED'\n@SYSUIC4 DC    CL8'FIXED'\n@TARWSS  DC    CL8'FIXED'\n@TOTEXP  DC    CL8'FIXED'\n@TOTREAL DC    CL8'FIXED'\n@TOTSTOR DC    CL8'FIXED'\n@UIC1    DC    CL8'FIXED'\n@UIC2    DC    CL8'FIXED'\n@UIC3    DC    CL8'FIXED'\n@UIC4    DC    CL8'FIXED'\n@WSMRV   DC    CL8'FIXED'\n*\n@$ESTOR  DC    CL8'CHAR'\n@$RSTOR  DC    CL8'CHAR'\n@$TTEXP  DC    CL8'CHAR'\n@$TTREAL DC    CL8'CHAR'\n@ASID    DC    CL8'CHAR'\n@CPUP    DC    CL8'CHAR'\n@DPRTY   DC    CL8'CHAR'\n@ESTORM  DC    CL8'CHAR'\n@EVENT   DC    CL8'CHAR'\n@EVNTCDE DC    CL8'CHAR'\n@JOBFLTR DC    CL8'CHAR'\n@JOBN    DC    CL8'CHAR'\n@JOBPCT  DC    CL8'CHAR'\n@JOBSEL  DC    CL8'CHAR'\n@MARKS   DC    CL8'CHAR'\n@MASKS   DC    CL8'CHAR'\n@MYCMD   DC    CL8'CHAR'\n@MYSEL   DC    CL8'CHAR'\n@OPT     DC    CL8'CHAR'\n@OPTSTMT DC    CL8'CHAR'\n@PROCPCT DC    CL8'CHAR'\n@RSTORM  DC    CL8'CHAR'\n@SORTSEQ DC    CL8'CHAR'\n@SRBTIME DC    CL8'CHAR'\n@SWPCODE DC    CL8'CHAR'\n@SWPSTAT DC    CL8'CHAR'\n@SWPTEXT DC    CL8'CHAR'\n@SYSID   DC    CL8'CHAR'\n@TCBTIME DC    CL8'CHAR'\n@TYPE    DC    CL8'CHAR'\n@UICDIST DC    CL8'CHAR'\n@UICMSKS DC    CL8'CHAR'\n@ZEDLMSG DC    CL8'CHAR'\n@ZEDSMSG DC    CL8'CHAR'\n*\n*------- END (ISPF VARIABLES)\n*\n*\n$SORT    DS    0C\n         DC    C'('\n$SORTFLD EQU   *-$SORT             OFFSET TO SORT FIELD NAME\n         DC    CL8'COUNT'\n         DC    C','\n$SORTYPE EQU   *-$SORT\n         DC    C'N'\n         DC    C','\n$SORTSEQ EQU   *-$SORT             OFFSET TO SORT SEQUENCE\n         DC    C'A'\n         DC    C')'\n$SORTLNG EQU   *-$SORT\n*\n*\nERR1S    DC    CL(L'ZEDSMSG)'TBCREATE Error'\nERR1L    DC    CL(L'ZEDLMSG)'Servere error doing TBCREATE on $JADTAB'\n*\nERR2S    DC    CL(L'ZEDSMSG)'TBADD Error'\nERR2L    DC    CL(L'ZEDLMSG)'Servere error doing TBADD on $JADTAB'\n*\nERR3S    DC    CL(L'ZEDSMSG)'TBTOP Error'\nERR3L    DC    CL(L'ZEDLMSG)'Servere error doing TBTOP on $JADTAB'\n*\nERR4S    DC    CL(L'ZEDSMSG)'TBTDISPL Error'\nERR4L    DC    CL(L'ZEDLMSG)'Servere error displaying $JADTAB'\n*\nERR5S    DC    CL(L'ZEDSMSG)'DISPLAY Error'\nERR5L    DC    CL(L'ZEDLMSG)'Servere error displaying ISPF panel'\n*\n*\nENDSMSG DC  CL(L'ZEDSMSG)'$JAD Ended - RC=0'\nENDLMSG DC  CL(L'ZEDLMSG)'$JAD Module Date/Time - &SYSDATE-&SYSTIME'\n*\n         EJECT\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\nWKPARM   DS    40F                 PARM LIST\n*\nDWORD    DS    D                   WORK DOUBLE WORD\n*\nLINKADD  DS    F                   LOAD ADDRESS OF 'ISPLINK'\n*\n##MSG    DS    F                   SAVED REG 14\n##DO#1   DS    F                   SAVED REG 14\n##SORT   DS    F                   SAVED REG 14\n##VIEW   DS    F                   SAVED REG 14\n##DISPL  DS    F                   SAVED REG 14\n##ADDPOP DS    F                   SAVED REG 14\n##REMPOP DS    F                   SAVED REG 14\n*\n*\n*\nNEXTASCB DS    F                   ASVT POINTER ANCHOR\nCURRASCB DS    F                   CURR ASCB ADDRESS\n*\nSWITCH   DS    CL1                 SWITCH\n$REFRESH EQU   X'80'               NEED TO REFRESH THE TABLE\n$FNDASCB EQU   X'40'               THIS ASCB IS GOOD !!!\n$JOBVIEW EQU   X'20'               'VIEW' FILTER IS ON\n$JOBSORT EQU   X'10'               'SORT' REQUIRED\n$JOBSLTD EQU   X'08'               'A JOB' IS SELECTED FOR DISPLAY\n*\n$TBCREAT EQU   X'01'               TABLE WAS CREATED\n*\nWLINKQRY DS    CL(LINKQRYL)\nWSORT    DS    CL($SORTLNG)        'SORT'\n*\nSAVEJOBN DS    CL(L'JOBN)\nSAVEASID DS    CL(L'ASID)\n*\n*\nSAVETYPE DS    CL(L'TYPE)          USED BY 'JOB FILTER'\nSAVEJCMP DS    CL(L'JOBN)              (BY PREFIX)\nSAVEJLNG DS    F\n*\nRPCT     DS    F\nEPCT     DS    F\nDOTS     DS    F\nTOTUIC   DS    F\n*\nTEMP1    DS    F\nTEMP2    DS    F\nTEMP3    DS    F\nTEMP4    DS    F\n*\nPOPCOL   DS    XL4\nPOPROW   DS    XL4\nWPANEL   DS    CL8                 PANEL TO BE DISPLAYED\n*\n*------- THE FOLLOWING FIELDS NEED TO STAY TOGETHER (ISPFVAR)\n*\nWVARS    DS    0F\n$EXCPCNT DS    XL4\nBASESTOR DS    XL4\nCOUNT    DS    XL4\nDOMAIN   DS    XL4\nESTOR    DS    XL4\nEXCPCNT  DS    XL4\nFIXBELOW DS    XL4\nINTPGIN  DS    XL4\nINTPGOUT DS    XL4\nINWSS    DS    XL4\nRDYTCBS  DS    XL4\nRSTOR    DS    XL4\nSTORAGE  DS    XL4\nSWAPCNT  DS    XL4\nSYSUIC1  DS    XL4\nSYSUIC2  DS    XL4\nSYSUIC3  DS    XL4\nSYSUIC4  DS    XL4\nTARWSS   DS    XL4\nTOTEXP   DS    XL4\nTOTREAL  DS    XL4\nTOTSTOR  DS    XL4\nUIC1     DS    XL4\nUIC2     DS    XL4\nUIC3     DS    XL4\nUIC4     DS    XL4\nWSMRV    DS    XL4\n*\n$ESTOR   DS    CL6\n$RSTOR   DS    CL6\n$TOTEXP  DS    CL8\n$TOTREAL DS    CL8\nASID     DS    CL3                 ASID\nCPUP     DS    CL4\nDPRTY    DS    CL2                 DISPATCHING PRIORITY\nESTORM   DS    CL8\nEVENT    DS    CL20\nEVENTCDE DS    XL1\nJOBFLTR  DS    CL8\nJOBN     DS    CL8                 JOBNAME\nJOBPCT   DS    CL50\nJOBSEL   DS    CL8\nMARKS    DS    CL(L'JOBPCT)\nMASKS    DS    CL16\nMYCMD    DS    CL80\nMYSEL    DS    CL1\nOPT      DS    CL1\nOPTSTMT  DS    CL80\nPROCPCT  DS    CL16\nRSTORM   DS    CL8\nSORTSEQ  DS    CL1\nSRBTIME  DS    CL11\nSWAPCODE DS    XL1\nSWAPSTAT DS    CL4\nSWAPTEXT DS    CL40\nSYSID    DS    CL4\nTCBTIME  DS    CL11\nTYPE     DS    CL1                 JOBTYPE\nUICDIST  DS    CL(L'JOBPCT)\nUICMSKS  DS    CL(L'JOBPCT)\nZEDLMSG  DS    CL70\nZEDSMSG  DS    CL30\n*\n*------- END (ISPF VARIABLES)\n*\nWKLENG   EQU   *-WKAREA\n         EJECT\n         PRINT GEN\n         CVT   DSECT=YES,LIST=YES\n         EJECT\n         IHAASVT LIST=YES\n         EJECT\n         IHAASCB LIST=YES\n         EJECT\n         IHAASXB LIST=YES\n         EJECT\n         IARRCE\n         EJECT\n         IARRAX\n         EJECT\n         IRAOUCB\n         EJECT\n         IHAOUXB\n         END\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JADSORT": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01K\\x00\\x00\\x00\\x83\\x13\\x9f\\x00\\x95\\x02\\x7f\\x14I\\x006\\x00\\x13\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.75", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "1995-01-27T14:49:00", "lines": 54, "newlines": 19, "modlines": 0, "user": "$VNV"}, "text": ")ATTR\n % TYPE(TEXT)  CAPS(OFF)\n + TYPE(TEXT)  INTENS(LOW)   CAPS(OFF)  COLOR(WHITE) SKIP(ON)\n \u00a6 TYPE(TEXT)  CAPS(OFF)  COLOR(GREEN)\n ! TYPE(TEXT)  CAPS(OFF)  COLOR(YELLOW)\n @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ) JUST(RIGHT)\n \" TYPE(OUTPUT) JUST(ASIS) HILITE(REVERSE) COLOR(GREEN)\n \u00cf TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE) COLOR(RED)\n \u00cc TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE) COLOR(BLUE)\n # TYPE(INPUT)            COLOR(YELLOW)\n \u00a2 TYPE(TEXT)  JUST(ASIS) HILITE(REVERSE) COLOR(YELLOW)\n)BODY WINDOW(40,16) EXPAND(``)\n%`-`\u00a2SORT Option Panel%`-`\n+\n+ Opt ....... #Z+ (0 Through 6)\n!\n!    0. \u00a6No Sorting\n!    1. \u00a6Sort By Job Name\n!    2. \u00a6Sort By TCBTIME\n!    3. \u00a6Sort By SRBTIME\n!    4. \u00a6Sort By Total Storage\n!    5. \u00a6Sort By Real Storage\n!    6. \u00a6Sort By Expanded Storage\n!    7. \u00a6Sort By EXCPCOUNT\n!\n+ Sort Seq .. #Z+ (A or D)\n!\n\u00a6 PF3-Cancel\n)INIT\n .ZVARS = '(OPT SORTSEQ)'\n .CURSOR = OPT\n &OPT = ''\n &SORTSEQ = 'D'\n &OPTSTMT = ''\n)PROC\n   VER (&OPT,NB,LIST,0,1,2,3,4,5,6,7)\n   VER (&SORTSEQ,NB,LIST,A,D)\n   IF (&OPT = 0)\n      &OPTSTMT = ' '\n   IF (&OPT = 1)\n      &OPTSTMT = JOBN\n   IF (&OPT = 2)\n      &OPTSTMT = TCBTIME\n   IF (&OPT = 3)\n      &OPTSTMT = SRBTIME\n   IF (&OPT = 4)\n      &OPTSTMT = STORAGE\n   IF (&OPT = 5)\n      &OPTSTMT = RSTOR\n   IF (&OPT = 6)\n      &OPTSTMT = ESTOR\n   IF (&OPT = 7)\n      &OPTSTMT = EXCPCNT\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JADTBL1": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01I\\x00\\x00\\x00\\x83\\x13\\x9f\\x00\\x95\\x06\\x1f\\t&\\x00/\\x00\\x13\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.73", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "1995-03-02T09:26:00", "lines": 47, "newlines": 19, "modlines": 0, "user": "$VNV"}, "text": ")ATTR\n % TYPE(TEXT)   CAPS(OFF)\n | TYPE(INPUT)  CAPS(OFF)  COLOR(RED)\n + TYPE(TEXT)   INTENS(LOW)   CAPS(OFF)  COLOR(WHITE)\n \u00a6 TYPE(OUTPUT) CAPS(OFF)  COLOR(WHITE)\n ! TYPE(TEXT)   CAPS(OFF)  COLOR(YELLOW)\n @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ) JUST(RIGHT)\n \u00ac TYPE(OUTPUT) CAPS(OFF)  HILITE(REVERSE) COLOR(BLUE)\n \" TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)\n ~ TYPE(OUTPUT) CAPS(OFF)                  COLOR(GREEN) JUST(RIGHT)\n { TYPE(OUTPUT) CAPS(OFF)                  COLOR(RED)   JUST(RIGHT)\n \\ TYPE(AB)\n < TYPE(ABSL)\n)ABC Desc(View)\n  PDC DESC('Set up VIEW selection') ACTION RUN(VIEW)\n)ABCINIT\n  .ZVARS='VIEWX'\n  .RESP = ENTER\n)ABC Desc(Sort)\n  PDC DESC('Set up SORT filter') ACTION RUN(SORT)\n)ABCINIT\n  .ZVARS='SORTX'\n  .RESP = ENTER\n)ABC Desc(Exit)\n  PDC DESC('Exit') ACTION RUN(END)\n)ABCINIT\n  .ZVARS='ENDX'\n  .RESP = ENTER\n)BODY EXPAND(``)\n!\\ View  \\ Sort  \\ Exit +\n\u00acZ   %-`-` \"JOB Activity Display% `-`!CPU%-\u00acCPUP\n+Command input%===> _ZCMD                                     +Scroll%===>_AMT +\n! (SORT, VIEW)\n!             Swap  AS PR         TCB         SRB     Tot   Real    Exp  EXCPCNT\n!  Jobname  T Stat  ID TY        Time        Time    Stor   Stor   Stor   (100s)\n%-`-`\n)MODEL\n|Z\u00a6JOBN    @Z~Z   @Z  @Z ~TCBTIME    ~SRBTIME    {Z      @RSTOR @ESTOR @Z\n)INIT\n   .ZVARS = '(SYSID $SEL TYPE SWAPSTAT ASID DPRTY STORAGE EXCPCNT)'\n   &$SEL = '_'\n   &AMT = PAGE\n   &ZCMD = ''\n)PROC\n   &MYCMD = &ZCMD\n   &MYSEL = &$SEL\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JADVIEW": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01P\\x00\\x00\\x00\\x83\\x13\\x9f\\x00\\x95\\x02\\x7f\\x14P\\x00-\\x00\\x13\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.80", "flags": 0, "createdate": "1983-05-19T00:00:00", "modifydate": "1995-01-27T14:50:00", "lines": 45, "newlines": 19, "modlines": 0, "user": "$VNV"}, "text": ")ATTR\n % TYPE(TEXT)  CAPS(OFF)\n + TYPE(TEXT)  INTENS(LOW)   CAPS(OFF)  COLOR(WHITE) SKIP(ON)\n \u00a6 TYPE(TEXT)  CAPS(OFF)  COLOR(GREEN)\n ! TYPE(TEXT)  CAPS(OFF)  COLOR(YELLOW)\n @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ) JUST(RIGHT)\n \" TYPE(OUTPUT) JUST(ASIS) HILITE(REVERSE) COLOR(GREEN)\n \u00cf TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE) COLOR(RED)\n \u00cc TYPE(OUTPUT) JUST(RIGHT) HILITE(REVERSE) COLOR(BLUE)\n # TYPE(INPUT)            COLOR(YELLOW)\n \u00a2 TYPE(TEXT)  JUST(ASIS) HILITE(REVERSE) COLOR(YELLOW)\n)BODY WINDOW(35,12) EXPAND(``)\n%`-`\u00a2VIEW Option Panel%`-`\n+\n+ Opt ....... #Z+\n!\n!  0. \u00a6No Filter\n!  1. \u00a6STC only\n!  2. \u00a6TSU only\n!  3. \u00a6BATCH only\n!  4. \u00a6Job prefix+==> #JOBSEL  +\n!\n\u00a6 PF3-Cancel\n)INIT\n .ZVARS = '(OPT)'\n .CURSOR = OPT\n &OPT = ''\n &JOBSEL = '________'\n)PROC\n   VER (&OPT,NB,LIST,0,1,2,3,4)\n   IF (&JOBSEL = '________')\n      &JOBSEL = ''\n   IF (&OPT = 4)\n      VER (&JOBSEL,NB)\n   IF (&OPT = 0)\n      &JOBFLTR = ''\n   IF (&OPT = 1)\n      &JOBFLTR = 'STC'\n   IF (&OPT = 2)\n      &JOBFLTR = 'TSU'\n   IF (&OPT = 3)\n      &JOBFLTR = 'BAT'\n   IF (&OPT = 4)\n      &JOBFLTR = 'JOB'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LLACOPY": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x10?\\x00\\x95\\x10?\\tI\\x01\\xd4\\x01\\xd4\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-04-13T00:00:00", "modifydate": "1995-04-13T09:49:00", "lines": 468, "newlines": 468, "modlines": 0, "user": "$VNV"}, "text": "$LLACOPY TITLE '$LLACOPY-- TO REFRESH A LLA MEMBER (VLF)'\n         PRINT NOGEN\n$LLACOPY CSECT\n*\n*-------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*\n*        PURPOSE - TO SELECTIVELY REQUEST LLA TO REFRESH A SPECIFIC\n*              PDS MEMBER.  THIS IS USED IN CONJUNCTION WITH DDC9MOVE.\n*\n*        DATE WRITTEN - 05/27/92\n*\n*        REGISTER USAGE:\n*              R10      - COPY OF R1 (JCL PARM POINTER) & RC\n*              R12      - BASE\n*              R11      - 2ND BASE\n*\n*        RETURN CODES:\n*\n*        ABEND CODES:\n*              999  -  PGM RUN UNDER TSO\n*              888  -  RC > WHAT ERRTABLE HAS (POSSIBLY NEW RC\n*                      SINCE THIS PROG WAS WRITTEN)\n*\n*        REQUIRED JCL :\n*              //         EXEC PGM=$LLACOPY,PARM='MODULE',REGION=4M\n*              //LLAPDS   DD DSN=SYS4.LINKLIB,DISP=SHR  (COPY FROM)\n*              //SYSPRINT DD SYSOUT=*\n*              //SYSIN    DD ......\n*              //SYSUDUMP DD SYSOUT=*       (OPTIONAL FOR DEBUGGING)\n*\n*        PROGRAM USAGE:\n*              MODULE NAMES TO BE REFRESHED CAN COME FROM EITHER PARM\n*              OR 'SYSIN', OR BOTH.\n*\n*-------------------------------------------------------------------\n*\n*        CHANGE - 4/87/95 - $VNV\n*              CHANGE TO TAKE INPUT FROM 'SYSIN' DDNAME AND ALSO\n*              PROVIDE OUTPUT TO 'SYSPRINT' INSTEAD OF WTO'S.\n*              PROGRAM RC WILL BE HIGHEST RETURN CODE OF ALL MODULES\n*              BEING PROCESSED.\n*\n*-------------------------------------------------------------------\n*\n$LLACOPY SET   (R12,R11)\n*\n         XR    R9,R9               CLEAR RETURN CODE\n         L     R10,0(R1)           SAVE PARM ADDRESS\n*\n         XC    HIGHRC,HIGHRC       CLEAR OUT HIGHEST RETURN CODE\n*\n*------  DISALLOW PROG FROM BEING RUN UNDER TSO\n*\n         EXTRACT MYANS,'S',FIELDS=(TSO)\n         L     R15,MYANS           GET TSO BYTE ADDRESS\n         TM    0(R15),X'80'        IS THIS TSO ??\n         BZ    OPENPDS             NO - THEN GO ON\n         WTO   'LLA001E - PGM EXECUTION UNDER TSO NOT ALLOWED',        X\n               ROUTCDE=11\n         ABEND 999\n*\n*\n*------  NOW OPEN THE INPUT PDS AND SYSPRINT\n*\nOPENPDS  EQU   *\n*\n*------  RETRIEVE INFO FROM JFCB FIRST (FROM LLAPDS)\n*\n         RDJFCB (LLAPDS)\n         LTR   R15,R15\n         BNZ   PDSOKAY\n         LA    R15,##JFCB          ADDRESSING THE JFCB AREA\n         USING JFCB,R15\n         MVC   H1DSN,JFCBDSNM      OUTPUT DSAT NAME\n         MVC   H2VOL,JFCBVOLS      OUTPUT VOLSER\n         DROP  R15\n*\nPDSOKAY  EQU   *\n         OPEN  (LLAPDS)\n         TM    DCBOFLGS-IHADCB+LLAPDS,DCBOFOPN    OPEN GOOD ??\n         BC    7,GETINFO           YEAH - THEN GO OBTAIN DSN INFO\n         WTO   'LLA002E - DDNAME=LLAPDS IS MISSING',                   X\n               ROUTCDE=11\n         B     ERRRET\n*\nGETINFO  EQU     *\n*\n*------  GET TIME\n*\n         TIME  DEC,TIMEDATE,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         UNPK  DWORD(7),TIMEDATE(4)   GET TIME\n         MVC   H1TIME(2),DWORD        HH\n         MVC   H1TIME+3(2),DWORD+2    MM\n         MVC   H1TIME+6(2),DWORD+4    MM\n*\n         MVC   DWORD(4),TIMEDATE+8\n         UNPK  TIMEDATE(9),DWORD(5)     GET DATE\n         MVC   H1DATE(2),TIMEDATE       MM\n         MVC   H1DATE+3(2),TIMEDATE+2   DD\n         MVC   H1DATE+6(4),TIMEDATE+4   YYYY\n*\n         L     R1,CVTPTR           GET ADDRESS OF CVT\n         USING CVT,R1\n         MVC   H2SYSTEM,CVTSNAME\n         DROP  R1\n*\nOPENPRNT EQU   *\n         OPEN  (SYSPRINT,OUTPUT)\n         TM    DCBOFLGS-IHADCB+SYSPRINT,DCBOFOPN    OPEN GOOD ??\n         BC    7,GETPARM           YEAH - THEN GO CHECK JCL PARM\n         WTO   'LLA003E - DDNAME=SYSPRINT IS MISSING',                 X\n               ROUTCDE=11\n         B     ERRRET\n*\n*\n*\n*------  HERE, WE NEED TO PROCESS PARM FROM JCL.\n*\nGETPARM  EQU   *\n         LH    R15,0(R10)          GET LENGTH\n         LTR   R15,R15             TEST FOR ZERO\n         BZ    CKSYSIN             IF ZERO THEN GO CHECK SYSIN\n         C     R15,F8              COMPARE AGAINST '8'\n         BNH   GOODPARM            IF NOT HIGH THEN GO THRU\n         L     R15,F8              ELSE USE 8 BYTES ONLY\n*\nGOODPARM EQU   *\n         BCTR  R15,R0              MINUS 1 FOR EXECUTE INSTRUCTION\n         EX    R15,SAVEPARM        NOW SAVE PARM\n         BAL   R14,LLAUPDT         CALL ROUTINE TO UPDATE LLA\n*\n*\n*------  PROCESS 'SYSIN' CONTROL CARDS\n*\n*\nCKSYSIN  EQU   *\n         DEVTYPE SYSINDD,SIXF\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ENDIT               IF NOT 0 - THEN GET OUT\n*\n*\n*------  OPENING 'SYSIN' DATA SET\n*\nOPENINP  EQU   *\n         OPEN  (SYSIN)\n         TM    DCBOFLGS-IHADCB+SYSIN,DCBOFOPN    OPEN GOOD ??\n         BC    8,ENDIT             NO - THEN GET OUT\n*\n*\n*\n*------  LOOP TO PROCESS ALL RECORDS FROM 'SYSIN'\n*\nREADCARD EQU   *\n         GET   SYSIN,CARD          READ IN EVERY RECORD FROM 'SYSIN'\n         MVC   WKNAME,CARD         ASSUME FIRST 8 BYTES BEING MODNAME\n         BAL   R14,LLAUPDT         CALL LLA-UPDATE ROUTINE\n         B     READCARD            AND THEN PROCESS NEXT RECORD\n*\n*\n         EJECT\n*\n*------  THIS ROUTINE WILL DO THE ACTUAL LLA UPDATE USING MODULE\n*------  NAME SUPPLIED IN 'WKNAME'\n*\nLLAUPDT  EQU   *\n         ST    R14,#LLAUPDT        SAVE R14 AS RETURN ADDRESS\n*        $AUTH ON\n         MODESET KEY=ZERO,MODE=SUP\n*        $AUTH OFF\n*\n         LLACOPY DCB=LLAPDS,BLDLLIST=WKLIST,RETCODE=RETCDE,            X\n               RSNCODE=REASCODE\n*\n*        $AUTH ON\n         MODESET KEY=NZERO,MODE=PROB\n*        $AUTH OFF\n*\n         MVC   MODULE,WKNAME       MOVE MOD NAME TO OUTPUT\n*\n         L     R15,RETCDE          GET RETURN CODE BACK\n         CVD   R15,DWORD           CONVERT RC TO DECIMAL\n         MVC   RC,PATTERN          MOVE EDIT PATTERN TO OUTPUT\n         ED    RC,DWORD+6\n*\n         C     R15,HIGHRC          SAVE HIGHEST RETURN CODE\n         BNH   RCISOKAY\n         ST    R15,HIGHRC\n*\nRCISOKAY EQU   *\n         SRL   R15,2               DIVIDE RC BY 4\n         CH    R15,NUMENTRY        IS IT > THEN WHAT MY TABLE SAYS ??\n         BNH   TABOKAY             NOP - THEN CONTINUE ON\n         WTO   'LLA004E - RC > HIGHEST RC IN PROGRAM TABLE - CHECK NEW X\n               RETURN CODES AVAIL WITH LLACOPY MACRO',                 X\n               ROUTCDE=11\n         ABEND 888,DUMP            AND - REALLY ABEND\n*\nTABOKAY  EQU   *\n         MH    R15,ENTLENG         GET OFFSET INTO MESSAGE TABLE\n         LA    R14,ERRTABLE\n         LA    R14,0(R15,R14)\n         MVC   MSG,4(R14)          MOVE CORRECT MESSAGE TO OUTPUT\n*                                  (BYPASS THE ADCON FIELD)\n*\n         ICM   R15,B'1111',0(R14)  LOAD ADCON\n         BZ    LLADONE             IF NO ADDTL PROCESS REQ'ED ...\n*\n         BALR  R14,R15             ELSE - CALL THE ROUTINE\n*\nLLADONE  EQU   *\n         BAL   R14,DOPRINT         CALL ROUTINE TO DO THE PRINTING\n         L     R14,#LLAUPDT        RELOAD RETURN ADDRESS FOR CALLER\n         BR    R14                 AND THEN BRANCH BACK\n         EJECT\n*\n*\n*\nPRINTTTR EQU   *\n         ST    R14,#PTTR           SAVE RETURN ADDRESS\n*\n         UNPK  DWORD(7),WKTTR(4)\n         MVC   TTR,DWORD\n         TR    TTR,NUMTRT-240      MAKE EVERYTHING PRINTABLE\n*\n         UNPK  DWORD(3),WKK(2)\n         MVC   K,DWORD\n         TR    K,NUMTRT-240        MAKE EVERYTHING PRINTABLE\n*\n         UNPK  DWORD(3),WKZ(2)\n         MVC   Z,DWORD\n         TR    Z,NUMTRT-240        MAKE EVERYTHING PRINTABLE\n*\n         UNPK  DWORD(3),WKC(2)\n         MVC   C,DWORD\n         TR    C,NUMTRT-240        MAKE EVERYTHING PRINTABLE\n*\n         L     R14,#PTTR           LOAD RETURN ADDRESS\n         BR    R14                 AND BRANCH BACK\n*\n*\n*\n*\nCHECKR0  EQU   *\n         ST    R14,#CHECKR0        SAVE RETURN ADDRESS\n         L     R15,REASCODE        OBTAIN REASON CODE\n         CVD   R15,DWORD           CONVERT RC TO DECIMAL\n         MVC   MSG+M8OFFSET(L'PATTERN),PATTERN\n         ED    MSG+M8OFFSET(L'PATTERN),DWORD+6\n         L     R14,#CHECKR0        LOAD RETURN ADDRESS\n         BR    R14                 AND BRANCH BACK\n*\n*\n*\nDOPRINT  EQU   *\n         ST    R14,#DOPRINT        SAVE RETURN ADDRESS\n         L     R14,LINECNT         GET LINE COUNT\n         LA    R14,1(,R14)         ADD 1 TO IT\n         ST    R14,LINECNT         SAVE IT FIRST\n         C     R14,F55             IS IT TOO HIGH ??\n         BL    NOHEAD              NO - THEN DO NOT PRINT HEADING\n         PUT   SYSPRINT,HEAD1      ELSE - PRINT HEADING\n         PUT   SYSPRINT,HEAD2\n         PUT   SYSPRINT,HEAD3\n         LA    R14,1               AND THEN INIT LINE COUNT\n         ST    R14,LINECNT\n         MVI   CC,C'0'             DOUBLE SPACING\n*\nNOHEAD   EQU   *\n         PUT   SYSPRINT,PRINT      PRINT DATA LINE\n         MVC   PRINT,BLANK         BLANK OUT PRINT LINE\n         L     R14,#DOPRINT        RELOAD RETURN ADDDRESS\n         BR    R14                 AND THEN BRANCH BACK TO CALLER\n*\n*\n*\n*\n*\nERRRET   EQU   *\n         MVC   HIGHRC,F16          SET RETURN CODE AS 16\n         B     GETOUT              THEN EXIT\n*\n*\nCLOSINPT EQU   *\n         CLOSE (SYSIN,FREE)\n*\nENDIT    EQU   *\n         CLOSE (LLAPDS,,SYSPRINT)\n*\n*\nGETOUT   EQU   *\n         L     R10,HIGHRC          GET THE HIGHEST RETURN CODE\n         EXIT  R=R10\n*\n*\nSAVEPARM MVC   WKNAME(0),2(R10)      SAVE MODULE NAME\n*\n*\n         EJECT\n*\n         LTORG\n*\n*\n*------  THE FOLLOWING TABLE IS USED FOR OUTPUT MESSAGES.  THE FIRST\n*------  MSG IS FOR RC=0, THEN 4, 8, ETC ...\n*------  EACH ENTRY WILL HAVE AN ACON WHICH POINTS TO THE ROUTINE\n*------  TO DO ADDITIONAL PROCESS FOR THIS PARTICULAR RC, AND THE MSG\n*------  ASSOCIATED WITH IT.\n*\nERRTABLE EQU   *\n         DC    AL4(PRINTTTR)\n         DC    CL(L'MSG)'LLACOPY SUCESSFULLY COMPLETED'\nONEENTRY EQU   *-ERRTABLE          ENTRY LENG\n*\n         DC    AL4(0)\n         DC    CL(L'MSG)'MODULE NOT FOUND/DELETED OUT OF LLA'\n*\n         DC    AL4(CHECKR0)\n         DC    CL(L'MSG)'LLACOPY FAILED - R0 =XXXX'\nM8OFFSET EQU   21                  OFFSET TO 'R0 =XXXX'\n*\nENDTABLE EQU   *\n*\nNUMENTRY DC    AL2(((ENDTABLE-ERRTABLE)/ONEENTRY)-1)\nENTLENG  DC    AL2(ONEENTRY)\n*\n*\n*\n*\nLLAPDS   DCB   DSORG=PO,DDNAME=LLAPDS,MACRF=R,EXLST=##LIST\n*\nSYSPRINT DCB   DSORG=PS,MACRF=PM,RECFM=FBA,DDNAME=SYSPRINT,LRECL=133\n*\nSYSIN    DCB   DSORG=PS,RECFM=FB,MACRF=GM,DDNAME=SYSIN,LRECL=80,       *\n               EODAD=CLOSINPT\n*\n*\nNUMTRT   DC    C'0123456789ABCDEF'\n*\n*\nDWORD    DS    D\n*\n*\nRETCDE   DS    F                   RET CODE\nREASCODE DS    F                   REASON CODE\n*\nMYANS    DS    F\nHIGHRC   DS    F\n*\n#LLAUPDT DS    F\n#DOPRINT DS    F\n#CHECKR0 DS    F\n#PTTR    DS    F\n*\nSIXF     DC    6F'0'               USED BY 'DEVTYPE'\nF8       DC    F'8'\nF16      DC    F'16'\nF55      DC    F'55'\nLINECNT  DC    F'99'               START OUT LINECOUNT WITH '99'\n*\n*\nPATTERN  DC    X'40202120'\n*\n*\nSYSINDD  DC    CL8'SYSIN'\n*\n*\nTIMEDATE DS    CL16                DATE/TIME RETURNED FROM 'TIME DEC'\n*\n*\nWKLIST   DS    0F\nWKFF     DC    AL2(1)\nWKLL     DC    AL2(WKENTL)\n*\nWKNAME   DC    CL8' '\nWKTTR    DC    AL3(0)\nWKK      DC    AL1(0)\nWKZ      DC    AL1(0)\nWKC      DC    AL1(0)\nWKDATA   DC    CL62' '             USER DATA\n*\nWKENTL   EQU   *-WKNAME            LENG OF THIS ENTRY\n*\nBLANK    DC    CL133' '\n*\nCARD     DC    CL80' '             INPUT RECORDS\nPRINT    DC    CL133' '            OUTPUT SYSOUT\n*\n         ORG   PRINT\nCC       DS    CL1\n         DS    CL2\nMODULE   DS    CL8\n         DS    CL2\nTTR      DS    CL6\n         DS    CL1\nK        DS    CL2\n         DS    CL1\nZ        DS    CL2\n         DS    CL1\nC        DS    CL2\n         DS    CL2\nRC       DS    CL4\n         DS    CL2\nMSG      DS    CL50\n         ORG\n*\n*\nHEAD1    DC    CL133' '\n         ORG   HEAD1\n         DC    CL1'1'\n         DC    CL2' '\n         DC    CL16'RUN DATE/TIME: '\nH1DATE   DC    CL10'MM/DD/YYYY'\n         DC    CL1'-'\nH1TIME   DC    CL8'HH.MM.SS'\n         DC    CL15' '\n         DC    CL13'LLAPDS DSN: '\nH1DSN    DC    CL44' '\n         ORG\n*\n*\nHEAD2    DC    CL133' '\n         ORG   HEAD2\n         DC    CL6' '\n         DC    CL13'RUN SYSTEM: '\nH2SYSTEM DC    CL4' '\n         DC    CL37' '\n         DC    CL6'VOL: '\nH2VOL    DC    CL6' '\n         ORG\n*\nHEAD3    DC    CL133' '\n         ORG   HEAD3\n         DC    CL1'0'\n         DC    CL2' '\n         DC    CL8'MODULE'\n         DC    CL2' '\n         DC    CL6'   TTR'\n         DC    CL1' '\n         DC    CL2' K'\n         DC    CL1' '\n         DC    CL2' Z'\n         DC    CL1' '\n         DC    CL2' C'\n         DC    CL2' '\n         DC    CL4'  RC'\n         DC    CL2' '\n         DC    CL50'----------------- M E S S A G E ------------------'\n         ORG\n*\n##JFCB   DS    0F,CL(JFCBLENG)\n         DS    0F\n##LIST   DC    X'87',AL3(##JFCB)\n*\n         EJECT\n*\n         DCBD  DSORG=PS\n         EJECT\n*\nJFCB     DSECT\n         IEFJFCBN\nJFCBLENG EQU   *-JFCB\n         EJECT\n*\n         CVT   DSECT=YES\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MCOPY": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x02\\x01\\x16\\x06\\x9f\\x01\\x16\\x13/\\x16A\\x01\\xb9\\x01U\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2016-03-09T00:00:00", "modifydate": "2016-05-11T16:41:02", "lines": 441, "newlines": 341, "modlines": 0, "user": "ITSXSB5"}, "text": "/* -------------------------- REXX ------------------------------ *\n *                                                                *\n *               $$$$ M   M  CCCC  OOO  PPPP  Y   Y               *\n *              $ $   MM MM C     O   O P   P  Y Y                *\n *               $$$  M M M C     O   O PPPP    Y                 *\n *                $ $ M   M C     O   O P       Y                 *\n *              $$$$  M   M  CCCC  OOO  P       Y                 *\n *                                                                *\n * This exec copies member(s) from one PDS to another PDS using   *\n * ISPF services and therefore maintains the ENQ across. The exec *\n * provides same function under Batch ISPF as option 3.3 under    *\n * on-line ISPF.                                                  *\n *                                                                *\n * Syntax - $MCOPY PDSname(mem) outPutPDS                         *\n *               FROM(vol111)  TO(vol222)                         *\n *               REPLACE                                          *\n *          PDSname - Input PDS - Required                        *\n *          mem - Members to be copied - Required                 *\n *             Mask can be used for xxx, i.e. A*, AA%%B, etc.     *\n *          outPutPDS - Output PDS - Required                     *\n *          FROM(vol111) - Optional - Volser of Input PDS         *\n *          TO(vol222) - Optional - Volser of Output PDS          *\n *          REPLACE - Optional - Use COPY with Replace Option     *\n *                                                                *\n * Note that ALL KEYWORDS can be abbreviated, i.e. F(ROM), T(O),  *\n * as long as they are distinguishable.  MEMLIST can have masks,  *\n * i.e. M%1, A*, etc...                                           *\n *                                                                *\n * 02/16/15 - VNV - First added.                                  *\n *                                                                *\n * -------------------------------------------------------------- */\n\ninDsn    = \"\"\noutDsn   = \"\"\nfromVol  = \"\"\ntoVol    = \"\"\nreplOpt  = \"\"                                /* Blank or REPLACE */\nmemList  = \"\"\npfxhead  = \" =>\"\npfx      = \"  >\"\npfxblk   = \"   \"\npfxprt   = \" ..\"\n\nparse source . . exec_Name .\n\nif SYSVAR(\"SYSENV\") = \"BACK\" then do\n   batIspf = 1\n   end\nelse do\n   if sysvar(SYSISPF) <> \"ACTIVE\" then do       /* under READY mode */\n      parse UPPER arg allParms\n      queue \"ISPSTART CMD(\"exec_Name allParms\") NEWAPPL(ISR)\"\n      exit\n      end\n   batIspf = 0\n   ispfDd  = '$#$'||STRIP(TIME(\"S\"))\n   x = outtrap(\"trap.\",\"*\")\n   address TSO \"FREE  F(\"ispfDD\")\"\n   address TSO \"ALLOC F(\"ispfDD\") SPACE(5 2) CYL DSORG(PS)\"  ,\n               \"LRECL(1024) RECF(F B)\"\n   address TSO \"MAKEBUF\"\n   tempRc = rc\n   x = outtrap(\"off\")\n   end\n\nsaveEnv = ADDRESS()\naddress ISPEXEC\n\n$sysid  = STRIP(MVSVAR('SYSNAME'))\n\nX=W(,,0)\nX=W(\"COPY processing starts on\" ,\n     $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\n\nparse UPPER arg allParms\n\nX=W(\"Cmd Input =>\" exec_Name allParms,,0)\nX=W(,,0)\n\nif allParms = \"\" then do\n   x=Syntax_Err()\n   end\n\nx = Get_Parms(allParms)\nif inDsn = \"\" | outDsn  = \"\" | memList = \"\" then do\n   X=Syntax_Err()\n   end\n\n/* --------------------------------------------------------- *\n * To obtain the fully qualified Data set name in case the   *\n * PDSNAME supplied from parm did not have single quotes     *\n * around the name.                                          *\n * --------------------------------------------------------- */\n\ninDsn    = Ck_Dsn(inDsn,fromVol)\nmyInVol  = SYSVOLUME\nx=Print_Dsn()\noutDsn   = Ck_Dsn(outDsn,toVol)\nmyOutVol = SYSVOLUME\nx=Print_Dsn()\n\nx=W(,,0)\n\nif (inDsn = outDsn) & (myInVol = myOutVol) then do\n   X=W(\"Input and Output DSNs are the same - RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\nif fromVol <> \"\" then do\n   inXt = \"VOLUME(\"fromVol\")\"\n   inMsg = \" on\" fromVol\n   end\nelse do\n   inXt = \"\"\n   inMsg = \"\"\n   end\n\nif toVol <> \"\" then do\n   outXt = \"VOLUME(\"toVol\")\"\n   outMsg = \" on\" toVol\n   end\nelse do\n   outXt = \"\"\n   outMsg = \"\"\n   end\n\nif INDEX(memList,'*') > 0 | ,\n   INDEX(memList,'%') > 0 then do\n   massCopy = 1\n   end\nelse do\n   massCopy = 0\n   end\n\n/* ------------------------------------------------------------ *\n * Everything looks fine here.  Continue to process the PDSes   *\n * ------------------------------------------------------------ */\n\"CONTROL ERRORS RETURN\"\n\n\"LMINIT DATAID(inId) DATASET('\"inDsn\"') ENQ(SHR)\" inXt\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"INIT error for dataset\" inDsn||inMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\n/* ------------------------------------------------------------ *\n * If member mask is used, then list all members with matching  *\n * names first (just for documentation purpose).                *\n * ------------------------------------------------------------ */\n\nif massCopy = 1 then do\n\n   x=W(\"Checking names that match\" memList\":\")\n   X=W(,,0)\n\n   \"LMOPEN DATAID(\"inId\") OPTION(INPUT)\"\n   if rc > 0 then do\n      X=W(\"Err:\" STRIP(zerrlm))\n      X=W(\"OPEN error for dataset\" inDsn||inMsg \"- RC=12.\",12,0)\n      \"LMFREE DATAID(\"inId\")\"\n      x=View_Data()\n      exit 12\n      end\n\n   varList = \"\"\n   listRc = 0\n   do until listRc > 0\n      \"LMMLIST DATAID(\"inId\") MEMBER(VARLIST) PATTERN(\"memList\")\"\n      listRc = rc\n      select\n         when listRc = 0 then do\n            x=W(\"... Matching member name:\" varList,,0)\n            end\n         when listRc = 4 then do\n            x=W(\"No matching member found for\" memList \"- RC=8.\",8,0)\n            \"LMCLOSE DATAID(\"inId\")\"\n            \"LMFREE DATAID(\"inId\")\"\n            x=View_Data()\n            exit 8\n            end\n         when listRc = 8 then do\n            \"LMMLIST DATAID(\"dataid\") MEMBER(VARLIST)\" ,\n              \"OPTION(FREE)\"\n            end\n         otherwise do\n            X=W(\"Err:\" STRIP(zerrlm))\n            X=W(\"LIST error for dataset\" inDsn||inMsg ,\n                   \"- RC=12.\",12,0)\n            \"LMCLOSE DATAID(\"inId\")\"\n            \"LMFREE DATAID(\"inId\")\"\n            x=View_Data()\n            exit 12\n            end\n         end                               /* select        */\n      end                                  /* Do until      */\n   end                                     /* if massCopy   */\n\n\"LMINIT DATAID(outId) DATASET('\"outDsn\"') ENQ(SHRW)\" outXt\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"INIT error for dataset\" outDsn||outMsg \"- RC=12.\",12,0)\n   \"LMFREE DATAID(\"inId\")\"\n   x=View_Data()\n   exit 12\n   end\n\n\"LMCOPY FROMID(\"inId\") TODATAID(\"outid\") FROMMEM(\"memList\")\" replOpt\ntempRc = rc\n\n/* ------------------------------------------------------------ *\n * Issued the COPY. Now check return codes.                     *\n * ------------------------------------------------------------ */\n\nif massCopy = 1 then x=W(,,0)\n\nexitCc = 0\n\nselect\n   when tempRc = 0 then do\n      X=W(memList \"successfully copied from\" inDsn||inMsg \"to\" ,\n             outDsn||outMsg \"- RC=0.\",0,0)\n      end\n   when tempRc = 4 then do\n      X=W(\"Err:\" STRIP(zerrlm))\n      X=W(memList \"not available - RC=8.\",8,0)\n      exitCC = 8\n      end\n   when tempRc = 8 then do\n      X=W(memList \"not found in\" inDsn||inMsg \"- RC=8\",8,0)\n      exitCC = 8\n      end\n   otherwise do\n      X=W(\"Err:\" STRIP(zerrlm))\n      X=W(\"COPY error from\" inDsn||inMsg \"to\" ,\n             outDsn||outMsg \"- RC=12.\",12,0)\n      exitCC = 12\n      end\n   end                                    /* select */\n\nx=View_Data()\n\n\"LMFREE DATAID(\"inId\")\"\n\"LMFREE DATAID(\"OutId\")\"\n\naddress saveENV\n\nexit exitCC\n\n\nPrint_Dsn:\nx=W(STRIP(SYSDSNAME)                ,\n    \"V(\"STRIP(SYSVOLUME)\")\"         ,\n    \"RECF(\"STRIP(SYSRECFM)\")\"        ,\n    \"LRECL(\"STRIP(SYSLRECL)\")\"       ,\n    \"BLKS(\"STRIP(SYSBLKSIZE)\")\"      ,\n     LEFT(STRIP(SYSUNITS),3)         ,\n    \"SP(\"STRIP(SYSPRIMARY) STRIP(SYSSECONDS)\")\",,pfxPrt)\nreturn 0\n\n\nView_Data:\n\nX=W(,,0)\nX=W(\"Processing ends on\",\n    $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\nX=W(,,0)\n\nif batISPF = 1 then nop\nelse do\n   address TSO \"EXECIO 0 DISKW\" ispfDD \"(FINIS\"\n   \"LMINIT DATAID(VIEWDD) DDNAME(\"ispfDD\")\"\n   \"BROWSE DATAID(\"viewDd\")\"\n   \"LMFREE DATAID(\"viewDd\")\"\n   address TSO \"FREE  F(\"ispfDD\")\"\n   end\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Loop through and pick up all possible Parms. Each parm       *\n * will then be examined later to have appropriate values       *\n * parsed out and stored into different var (in another         *\n * routine: Obtain_Kw)                                          *\n * ------------------------------------------------------------ */\n\nGet_Parms:\n\narg inParms\n\nparse value inParms with myDsn inParms\nparse value myDsn with inDsn '(' memList ')' endQuote\n\ninDsn    = STRIP(inDsn)||STRIP(endQuote)\nmemList  = STRIP(memList)\n\nposParm  = 0\nif WORDS(inParms) > 0 then do\n   do i=1 to WORDS(inParms)             /* process all parms left */\n      parse value WORD(inParms,i) with inOption .\n      if INDEX(inOption,'(') > 0 then do\n         call Obtain_Kw\n         iterate\n         end\n      else do                           /* parms w/o '(' and ')'  */\n         posParm = posParm + 1\n         select\n            when posParm = 1 then do    /* 1st parm = outDSN      */\n               outDsn = STRIP(inOption)\n               iterate\n               end\n            when posParm = 2 then do    /* 2nd parm has to be REP */\n               if ABBREV('REPLACE',inOption,1) = 1 then do\n                  replOpt  = \"REPLACE\"\n                  iterate\n                  end\n               else do                  /* unknown parm ??        */\n                  X=W(\"Unknown parm as:\" inOption \"- RC=12.\",12,0)\n                  x=View_Data()\n                  exit 12\n                  end\n               end\n            otherwise do                /* too many parms w/o     */\n               X=W(\"Too many parms - RC=12.\",12,0)\n               x=View_Data()\n               exit 12\n               end\n            end                         /* select                 */\n         end                            /* parms w/o '(' and ')'  */\n      end                               /* do i=1                 */\n   end                                  /* if WORDS(..            */\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Parse input to pick up appropriate parms                     *\n * ------------------------------------------------------------ */\n\nObtain_Kw:\nparse value inOption with keyWord \"(\" contents \")\"\ncontents = STRIP(contents)\nselect\n   when ABBREV('FROM',keyWord,1) = 1 then do\n      fromVol = contents\n      end\n   when ABBREV('TO',keyWord,1) = 1 then do\n      toVol = contents\n      end\n   otherwise do\n      X=Syntax_Err()\n      end\n   end\nreturn 0\n\n\nSyntax_Err:\nX=W(\"Valid syntax is:\" exec_Name ,\n    \"inPDS(mem) outPDS - optional FROM(v1) TO(v2)\",\n    \"REPLACE\")\nX=W(\"Member name can have masking characters (% or *).\",12,0)\nx=View_Data()\nexit 12\nreturn 0\n\n\n/* ------------------------------------------------------------ *\n * This is to issue error message.  At the same time, set the   *\n * ISPF return code to whatever being passed (ready to exit).   *\n * This is the only way for ISPSTART to end with a non-zero RC. *\n * 3rd parm = line-prefix, if 0, then blank, if not there, use  *\n * normal prefix, any other values will use that as prefix.     *\n * ------------------------------------------------------------ */\n\nW:\nparse arg errMsg,errCode,inputPfx\n\nselect\n   when inputPfx = \"0\" then myPfx = pfxblk\n   when inputPfx = \"\" then myPfx = pfx\n   otherwise myPfx = inputPfx\n   end\n\nif batISPF = 1 then do\n   say myPfx errMsg\n   end\nelse do\n   queue myPfx errMsg\n   address TSO \"EXECIO 1 DISKW\" ispfDD\n   end\nif errCode <> \"\" then do\n   zispfrc = errCode\n   address ISPEXEC \"VPUT (ZISPFRC) SHARED\"\n   end\nreturn 0\n\n\nCk_Dsn:\nparse arg myDsn,myVol\n\nif myVol <> \"\" then do\n   xTra    = \"VOLUME(\"myVol\")\"\n   xTraMsg = \" on\" inVol\n   end\nelse do\n   xTra    = \"\"\n   xTraMsg = \"\"\n   end\n\ntemp = myDsn \"DIRECTORY NORECALL\" xTra\ntempRc = LISTDSI(temp)\nif tempRc = 16 then do\n   if SYSREASON = 9 then do\n      X=W(\"Data set\" myDsn \"has been migrated - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   If SYSREASON = 5 then do\n      X=W(\"Data set\" myDsn \"not cataloged - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   else do\n      X=W(SYSMSGLVL2)\n      X=W(\"LISTDSI error for\" myDsn ,\n             \"- SYSREASON=\" SYSREASON \"- RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   end\n\nmyDsn = sysdsname\n\nif SUBSTR(sysdsorg,1,2) <> \"PO\" then do\n   X=W(\"Data set is not a PDS:\" myDsn||xTraMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\nreturn myDsn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MDEL": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x10\\x01\\x16\\x05O\\x01\\x16\\x13/\\x16B\\x01o\\x00\\xdb\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2016-02-23T00:00:00", "modifydate": "2016-05-11T16:42:10", "lines": 367, "newlines": 219, "modlines": 0, "user": "ITSXSB5"}, "text": "/* -------------------------- REXX ------------------------------ *\n *                                                                *\n *                $$$$ M   M DDDD  EEEEE L                        *\n *               $ $   MM MM D   D E     L                        *\n *                $$$  M M M D   D EEEE  L                        *\n *                 $ $ M   M D   D E     L                        *\n *               $$$$  M   M DDDD  EEEEE LLLLL                    *\n *                                                                *\n * This exec does a delete of a PDS member using ISPF dialog      *\n * services and therefore maintains the ENQ across. The exec does *\n * provide the same function under batch (running ISPF) as in     *\n * option 3.1 for online ISPF.                                    *\n *                                                                *\n * Syntax - $MDEL pds(xxx) VOL(zzzzzz) MASK(YES)                  *\n *          pds - Name of PDS.                                    *\n *          xxx = name of member to be deleted.                   *\n *            Mask can be used, i.e. $*, %%A%1.                   *\n *            For a MASK to be used, MARK(YES) has to be included *\n *            as extra caution measure.                           *\n *          VOLUME(zzzzzz) - zzzzzz = VOLSER of PDS (optional)    *\n * Note that ALL KEYWORDS can be abbreviated, i.e. MA(YES),       *\n * V(OLUME), as long as they are distinguishable.                 *\n *                                                                *\n *                                                                *\n * 02/16/15 - VNV - First added.                                  *\n *                                                                *\n * -------------------------------------------------------------- */\n\ninDsn    = \"\"\ninVol    = \"\"\ndelM     = \"\"\nnewM     = \"\"\nmassDel  = 0\nmassOpt  = 0\npfxhead  = \" =>\"\npfx      = \"  >\"\npfxblk   = \"   \"\npfxprt   = \" ..\"\n\n\nparse source . . exec_Name .\n\nif SYSVAR(\"SYSENV\") = \"BACK\" then do\n   batIspf = 1\n   end\nelse do\n   if sysvar(SYSISPF) <> \"ACTIVE\" then do       /* under READY mode */\n      parse UPPER arg allParms\n      queue \"ISPSTART CMD(\"exec_Name allParms\") NEWAPPL(ISR)\"\n      exit\n      end\n   batIspf = 0\n   ispfDd  = '$#$'||STRIP(TIME(\"S\"))\n   x = outtrap(\"trap.\",\"*\")\n   address TSO \"FREE  F(\"ispfDD\")\"\n   address TSO \"ALLOC F(\"ispfDD\") SPACE(5 2) CYL DSORG(PS)\"  ,\n               \"LRECL(1024) RECF(F B)\"\n   address TSO \"MAKEBUF\"\n   tempRc = rc\n   x = outtrap(\"off\")\n   end\n\nsaveEnv = ADDRESS()\naddress ISPEXEC\n\n$sysid  = STRIP(MVSVAR('SYSNAME'))\n\nX=W(,,0)\nX=W(\"DELETE processing starts on\" ,\n     $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\n\nparse UPPER arg allParms\n\nX=W(\"Cmd Input =>\" exec_Name allParms,,0)\nX=W(,,0)\n\nif allParms = \"\" then do\n   x=Syntax_Err()\n   end\n\nx = Get_Parms(allParms)\n\nif inDsn = \"\" | delM = \"\" then do\n   x=Syntax_Err()\n   end\n\nif INDEX(delM,'*') > 0  | ,\n   INDEX(delM,'%') > 0  then do\n   massDel = 1                     /* turn on 'mass delete' flag */\n   if massOpt = 0 then do\n      X=W(\"MASK(YES) is required for a mass delete operation. \" ,\n             \"Exec aborted - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   end\n\nif inVol <> \"\" then do\n   xTra = \"VOLUME(\"inVol\")\"\n   xTraMsg = \" on\" inVol\n   end\nelse do\n   xTra = \"\"\n   xTraMsg = \"\"\n   end\n\n/* --------------------------------------------------------- *\n * To obtain the fully qualified Data set name in case the   *\n * PDSNAME supplied from parm did not have single quotes     *\n * around the name.                                          *\n * --------------------------------------------------------- */\n\ntemp = inDsn \"DIRECTORY NORECALL\" xTra\ntempRc = LISTDSI(temp)\nif tempRc = 16 then do\n   if SYSREASON = 9 then do\n      X=W(\"Data set\" inDsn \"has been migrated - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   If SYSREASON = 5 then do\n      X=W(\"Data set\" inDsn \"not cataloged - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   else do\n      X=W(SYSMSGLVL2)\n      X=W(\"LISTDSI error for\" inDsn ,\n             \"- SYSREASON=\" SYSREASON \"- RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   end\n\ninDsn = sysdsname\nx=Print_Dsn()\nx=W(,,0)\n\nif SUBSTR(sysdsorg,1,2) <> \"PO\" then do\n   X=W(\"Data set is non-PDS:\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\n/* ------------------------------------------------------------ *\n * Everything looks fine here.  Continue to process the PDS.    *\n * ------------------------------------------------------------ */\n\"CONTROL ERRORS RETURN\"\n\n\"LMINIT DATAID(dataid) DATASET('\"inDsn\"') ENQ(SHRW)\" xTra\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"INIT error for dataset\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\n\"LMOPEN DATAID(\"dataid\") OPTION(OUTPUT)\"\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"OPEN error for dataset\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   call Free_file\n   x=View_Data()\n   exit 12\n   end\n\nif massDel = 1 then do\n\n   x=W(\"Checking names that match\" delM\":\")\n   X=W(,,0)\n\n   varList = \"\"\n   listRc = 0\n   do until listRc > 0\n      \"LMMLIST DATAID(\"dataid\") MEMBER(VARLIST) PATTERN(\"delM\")\"\n      listRc = rc\n      select\n         when listRc = 0 then do\n            x=W(\"... Matching member name:\" varList,,0)\n            end\n         when listRc = 4 then do\n            x=W(\"No matching member found for\" delM \"- RC=8.\",8,0)\n            call Close_file\n            call Free_file\n            x=View_Data()\n            exit 8\n            end\n         when listRc = 8 then do\n            \"LMMLIST DATAID(\"dataid\") MEMBER(VARLIST)\" ,\n              \"OPTION(FREE)\"\n            end\n         otherwise do\n            X=W(\"Err:\" STRIP(zerrlm))\n            X=W(\"LIST error for dataset\" inDsn||xTraMsg ,\n                   \"- RC=12.\",12,0)\n            call Close_file\n            call Free_file\n            x=View_Data()\n            exit 12\n            end\n         end                               /* select */\n      end\n   end\n\n\"LMMDEL DATAID(\"dataid\") MEMBER(\"delM\")\"\ntempRc = rc\n\n/* ------------------------------------------------------------ *\n * Issued the DELETE. Now check return codes.                   *\n * ------------------------------------------------------------ */\n\nif massDel = 1 then X=W(,,0)\n\nexitCc = 0\n\nselect\n   when tempRc = 0 then do\n      X=W(delM \"successfully deleted in\" inDsn||xTraMsg \"- RC=0.\",0,0)\n      end\n   when tempRc = 8 then do\n      X=W(delM \"not found in\" inDsn||xTraMsg \"- RC=8.\",8,0)\n      exitCC = 8\n      end\n   otherwise do\n      X=W(\"Err:\" STRIP(zerrlm))\n      X=W(\"DEL error for\" inDsn \"- RC=12.\",12,0)\n      exitCC = 12\n      end\n   end                                    /* select */\n\ncall Close_file\ncall Free_file\nx=View_Data()\n\naddress saveENV\n\nexit exitCC\n\n\nclose_file:\n\"LMCLOSE DATAID(\"dataid\")\"\nreturn 0\n\nFree_file:\n\"LMFREE DATAID(\"dataid\")\"\nreturn 0\n\n\nPrint_Dsn:\nx=W(STRIP(SYSDSNAME)                ,\n    \"V(\"STRIP(SYSVOLUME)\")\"         ,\n    \"RECF(\"STRIP(SYSRECFM)\")\"        ,\n    \"LRECL(\"STRIP(SYSLRECL)\")\"       ,\n    \"BLKS(\"STRIP(SYSBLKSIZE)\")\"      ,\n     LEFT(STRIP(SYSUNITS),3)         ,\n    \"SP(\"STRIP(SYSPRIMARY) STRIP(SYSSECONDS)\")\",,pfxPrt)\nreturn 0\n\n\nView_Data:\n\nX=W(,,0)\nX=W(\"Processing ends on\",\n    $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\nX=W(,,0)\n\nif batISPF = 1 then nop\nelse do\n   address TSO \"EXECIO 0 DISKW\" ispfDD \"(FINIS\"\n   \"LMINIT DATAID(VIEWDD) DDNAME(\"ispfDD\")\"\n   \"BROWSE DATAID(\"viewDd\")\"\n   \"LMFREE DATAID(\"viewDd\")\"\n   address TSO \"FREE  F(\"ispfDD\")\"\n   end\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Loop through and pick up all possible Parms. Each parm       *\n * will then be examined later to have appropriate values       *\n * parsed out and stored into different var (in another         *\n * routine: Obtain_Kw)                                          *\n * ------------------------------------------------------------ */\n\nGet_Parms:\n\narg inParms\n\nparse value inParms with myDsn inParms\nparse value myDsn with inDsn '(' delM ')' endQuote\ninDsn = STRIP(inDsn)||STRIP(endQuote)\ndelM  = STRIP(delM)\n\nif WORDS(inParms) > 0 then do\n   do i=1 to WORDS(inParms)\n      parse value WORD(inParms,i) with inOption .\n      if INDEX(inOption,'(') > 0 then do\n         call Obtain_Kw\n         end\n      else do\n         X=Syntax_Err()\n         end\n      end\n   end\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Parse input to pick up appropriate parms                     *\n * ------------------------------------------------------------ */\n\nObtain_Kw:\nparse value inOption with keyWord \"(\" contents \")\"\ncontents = STRIP(contents)\nselect\n   when ABBREV('VOLUME',keyWord,1) = 1 then do\n      inVol = contents\n      end\n   when ABBREV('MASK',keyword,2) = 1 then do\n      if contents = \"YES\" then massOpt = 1\n      end\n   otherwise do\n      X=Syntax_Err()\n      end\n   end\nreturn 0\n\n\nSyntax_Err:\nX=W(\"Valid syntax is:\" exec_Name ,\n    \"PDSname(mem) - optional VOLUME(zzzzzz)\",\n    \"MASK(YES)\")\nX=W(\"If member name contains masking character (% or *),\",\n    \"MASK(YES) is required.\",12,0)\nx=View_Data()\nexit 12\nreturn 0\n\n/* ------------------------------------------------------------ *\n * This is to issue error message.  At the same time, set the   *\n * ISPF return code to whatever being passed (ready to exit).   *\n * This is the only way for ISPSTART to end with a non-zero RC. *\n * 3rd parm = line-prefix, if 0, then blank, if not there, use  *\n * normal prefix, any other values will use that as prefix.     *\n * ------------------------------------------------------------ */\n\nW:\nparse arg errMsg,errCode,inputPfx\n\nselect\n   when inputPfx = \"0\" then myPfx = pfxblk\n   when inputPfx = \"\" then myPfx = pfx\n   otherwise myPfx = inputPfx\n   end\n\nif batISPF = 1 then do\n   say myPfx errMsg\n   end\nelse do\n   queue myPfx errMsg\n   address TSO \"EXECIO 1 DISKW\" ispfDD\n   end\nif errCode <> \"\" then do\n   zispfrc = errCode\n   address ISPEXEC \"VPUT (ZISPFRC) SHARED\"\n   end\nreturn 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MEM": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x008\\x01\\x134?\\x01 \\x07\\x0f\\x161\\x03!\\x02\\xb9\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2013-12-09T00:00:00", "modifydate": "2020-03-10T16:31:38", "lines": 801, "newlines": 697, "modlines": 0, "user": "VINHVU"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$MPFREP#": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x97\\x04_\\x159\\x00\\x0e\\x00\\x0c\\x00\\t[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1997-02-14T15:39:00", "lines": 14, "newlines": 12, "modlines": 9, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL,PARM.LKED=RENT\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS($MPFREPL),DISP=SHR       <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n SETCODE AC(1)\n NAME $MPFREPL(R)                                        <== CHANGE\n//*\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MPFREP@": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97\\x04_\\x00\\x97\\x04\\x9f\\x10\\x13\\x00\\n\\x00\\x08\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-02-14T00:00:00", "modifydate": "1997-02-18T10:13:00", "lines": 10, "newlines": 8, "modlines": 0, "user": "$VNV"}, "text": "To install pgm $MPFREPL, do the following:\n\n   o   Copy $MPFREPL to a APF Linklist data set.\n   o   Update MPFLSTxx, i.e.\n\n       ICK003D,SUP(YES),USEREXIT($MPFREPL)\n\n   o   Either wait for next IPL or do 'SET MPF=xx' (refresh the\n       Linklist module before doing the SET command.  Look at program\n       $LLACOPY for ways to refresh just a single module in LLA).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MPFREPL": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x96\"\\x0f\\x00\\x965\\x1f\\x13&\\x00\\xda\\x00e\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1996-08-07T00:00:00", "modifydate": "1996-12-16T13:26:00", "lines": 218, "newlines": 101, "modlines": 0, "user": "$VNV"}, "text": "$MPFREPL TITLE '$MPFREPL -- WTOR EXIT TO REPLY TO VARIOUS MESSAGES'\n*\n*\n         MACRO\n&LABEL   $MSGTAB &JOBNAME,&TEXT,&REPLY,&TYPE=BODY\n*\n         AIF   ('&TYPE' EQ 'START').START\n         AIF   ('&TYPE' EQ 'BODY').BODY\n         AIF   ('&TYPE' EQ 'STOP').STOP\n         AGO   .BODY\n.START   ANOP\n         MNOTE *,'*-----------------------------------------------*'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THIS MACRO WILL SET UP THE MESSAGE TABLE:   *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      JOBNAME = JOBNAME THAT GENERATES THE     *'\n         MNOTE *,'*          WTORS (OR *)                         *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      TEXT =  THE MESSAGE TEXT PART OF THE     *'\n         MNOTE *,'*          WTOR.                                *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      REPLY = THE REPLY USED FOR THIS WTOR     *'\n         MNOTE *,'*          (ASSUMING THE JOBNAME AND THE WTOR   *'\n         MNOTE *,'*          TEXT MATCH).                         *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      TYPE = BEGIN, BODY OR END.  USED TO      *'\n         MNOTE *,'*      INDICATE THE TABLE ENTRY TYPE.           *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THE RESULTING TABLE ENTRY WILL BE:          *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      DC  AL1(LENG OF JOBNAME)                 *'\n         MNOTE *,'*      DC  C\"JOBNAME\"                           *'\n         MNOTE *,'*      DC  AL1(LENG OF WTOR TEXT)               *'\n         MNOTE *,'*      DC  C\"WTOR TEXT\"                         *'\n         MNOTE *,'*      DC  AL1(LENG OF REPLY)                   *'\n         MNOTE *,'*      DC  C\"REPLY\"                             *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*-----------------------------------------------*'\n&LABEL   DS    0F\n         MEXIT\n*\n.BODY    ANOP\n         LCLA &LENG\n&LENG    SETA K'&JOBNAME\n         AIF  (&LENG LE 8).CKTEXT\n         MNOTE 12,'****** JOBNAME IS > 8 CHARACTERS'\n         MEXIT\n.CKTEXT  ANOP\n&LENG    SETA K'&TEXT\n         AIF  (&LENG LE 50).CKREPLY\n         MNOTE 12,'****** WTOR TEXT IS > 50 CHARACTERS'\n         MEXIT\n.CKREPLY ANOP\n&LENG    SETA K'&REPLY\n         AIF  (&LENG LE 52).ITISOK\n         MNOTE 12,'****** WTOR REPLY IS > 50 CHARACTERS'\n         MEXIT\n.ITISOK  ANOP\n             DC    AL1(L'$$J&SYSNDX.@)       LENG OF JOBNAME\n$$J&SYSNDX.@ DC    C'&JOBNAME'               JOBNAME\n             DC    AL1(L'$$T&SYSNDX.@)       LENG OF WTOR TEXT\n$$T&SYSNDX.@ DC    C&TEXT                    WTOR TEXT\n             DC    AL1(L'$$R&SYSNDX.@)       LENG OF REPLY\n$$R&SYSNDX.@ DC    C&REPLY                   REPLY\n         MEXIT\n*\n.STOP    ANOP\n         DC     X'00'              END OF TABLE\n*\n         MEND\n         EJECT\n*\n*\n*\n*\n         PRINT NOGEN\n*\n$MPFREPL CSECT\n$MPFREPL AMODE 31\n$MPFREPL RMODE ANY\n*\n         USING *,R12\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         B     BEGINPGM\n         DC    C'$MPFREPL'\n         DC    C'&SYSDATE',C' &SYSTIME'\n*\nBEGINPGM EQU   *\n         L     R11,0(R1)           PICK UP ADDRESS OF CTXT\n         USING CTXT,R11\n         L     R10,CTXTTXPJ        LOAD POINTER TO THE MSG ATTR\n         USING CTXTATTR,R10\n         TM    CTXTTFB1,CTXTTFWR   WTOR?\n         BNO   RETURN              NO, FORGET IT\n         LA    R14,MSGTABLE\n*\nVERIFY   EQU   *\n         CLI   0(R14),X'00'        IS THIS END-OF-TABLE ??\n         BE    RETURN              YES - THEN FORGET THIS ...\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R14)          GET LENG OF JOBNAME FOR COMPARE\n         BCTR  R15,0               MINUS 1 FOR EXECUTE\n*\n         CLI   1(R14),C'*'         ARE ANY JOBNAMES ALLOWED ??\n         BE    JOBOKAY             YES - THEN GO ON FOR MORE CHECKIN'\n         EX    R15,CLCJOBNM        CHECK FOR MATCHING JOBNAME\n         BE    JOBOKAY             IF EQUAL THEN GO ON\n         LA    R14,2(R15,R14)      GO PAST JOBNAME\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R14)          GET LENG OF WTOR TEXT\n         LA    R14,1(R15,R14)      GO PAST WTOR TEXT\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R14)          GET LENG OF REPLY TEXT\n         LA    R14,1(R15,R14)      GO PAST REPLY TEXT\n         B     VERIFY              BACK TO VERIFY EVERYTHING\n*\nCLCJOBNM CLC   CTXTJBNM(0),1(R14)  COMPARE JOBNAMES\nCLCTEXT  CLC   CTXTTMSG(0),1(R14)  COMPARE WTOR TEXT\nMVCREPLY MVC   3(0,R14),1(R9)      MOVE REPLY TO COMMAND AREA\n*\nJOBOKAY  EQU   *\n         LA    R14,2(R15,R14)      GO PAST JOBNAME\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R14)          GET LENG OF WTOR TEXT\n         BCTR  R15,0               MINUS 1 FOR EXECUTE\n         EX    R15,CLCTEXT         CHECK FOR MATCHING TEXT\n         BE    TEXTOKAY            IF EQUAL THEN GO ON\n         LA    R14,2(R15,R14)      GO PAST WTOR TEXT\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R14)          GET LENG OF REPLY TEXT\n         LA    R14,1(R15,R14)      GO PAST REPLY TEXT\n         B     VERIFY              BACK TO VERIFY EVERYTHING\n*\nTEXTOKAY EQU   *\n         LA    R9,2(R15,R14)       GO PAST WTOR TEXT (SAVE ADDR=R9)\n*\n         GETMAIN RU,LV=WORKEND,SP=230,LOC=(BELOW,ANY)\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         USING WORKAREA,R13\n         XC    MGCRPL(MGCRSIZ),MGCRPL CLEAR THE MGCR AREA\n         MVC   MGCRTEXT(L'REPLYD),REPLYD   MOVE REPLY TO MACRO AREA\n         MVC   MGCRTEXT+REPLYFIX(L'CTXTRPYI),CTXTRPYI\n         LA    R14,MGCRTEXT+REPLYFIX+L'CTXTRPYI GO TO END OF REPLYID\n*\nFINDNONB EQU   *\n         BCTR  R14,0               SUB 1\n         CLI   0(R14),C' '         IS THIS BLANK STILL ??\n         BE    FINDNONB            YES - THEN BACK AGAIN\n*\n         MVI   1(R14),C','\n         MVI   2(R14),C''''        MOVE SINGLE QUOTE THERE\n         SR    R15,R15             CLEAR R15 FIRST\n         IC    R15,0(R9)           GET LENG OF WTOR REPLY\n         BCTR  R15,0               MINUS 1 FOR EXECUTE\n         EX    R15,MVCREPLY        MOVE REPLY TO CMD AREA\n         LA    R14,4(R15,R14)      GO PAST THE END OF REPLY\n         MVI   0(R14),C''''        MOVE SINGLE QUOTE (ENDING)\n*\n         LA    R3,(MGCRTEXT-MGCRPL)+L'REPLYD\n         STC   R3,MGCRLGTH         SET THE LENGTH OF THE REPLY\n         SR    R0,R0\n         MGCR  MGCRPL\n         L     R10,4(R13)          RETURN TO MPF\n         FREEMAIN RU,LV=WORKEND,A=(R13),SP=230\n         LR    R13,R10\nRETURN   EQU   *\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n*\n*\n*\nREPLYD   DC    CL80'REPLY '\nREPLYFIX EQU   6\n*\n*\nMSGTABLE $MSGTAB TYPE=START\n         $MSGTAB DASDMNT,'ICK003D REPLY U TO ALTER VOLUME 0E','U'\n         $MSGTAB DASDMNT,'ICK003D REPLY U TO ALTER VOLUME 0F','U'\n         $MSGTAB *,'TESTING','U'\n         $MSGTAB $VNV1,'FLIDC000I ENTER FLCACHE','QUIT'\n         $MSGTAB $VNV1,'FLIDC000I STARTING DASD','NO'\n         $MSGTAB VNV1,'FLIDC000I STARTING DASD','YES'\n         $MSGTAB TYPE=STOP\n*\n         LTORG\n         PRINT   GEN\n*\nWORKAREA DSECT\n         DS    18F            SAVE AREA\n         IEZMGCR DSECT=NO\n         ORG\nWORKEND  EQU   *-WORKAREA\n*\n         IEZVX100\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         END   $MPFREPL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MREN": {"ttr": 4877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00@\\x01\\x16\\x04/\\x01\\x16\\x13/\\x16A\\x01>\\x00\\n\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2016-02-11T00:00:00", "modifydate": "2016-05-11T16:41:40", "lines": 318, "newlines": 10, "modlines": 0, "user": "ITSXSB5"}, "text": "/* -------------------------- REXX ------------------------------ *\n *                                                                *\n *                 $$$$ M   M RRRR  EEEEE N   N                   *\n *                $ $   MM MM R   R E     NN  N                   *\n *                 $$$  M M M RRRR  EEEE  N N N                   *\n *                  $ $ M   M R  R  E     N  NN                   *\n *                $$$$  M   M R   R EEEEE N   N                   *\n *                                                                *\n * This exec does a rename of a PDS member using ISPF dialog      *\n * services and therefore maintains the ENQ across.  The exec     *\n * provides same function under batch ISPF as option 3.1 under    *\n * online ISPF.                                                   *\n *                                                                *\n * Syntax - $MREN PDSname(oldmem) newMem VOLUME(zzzzzz)           *\n *          PDSname - Name of PDS.                                *\n *          oldMem = name of member to be renamed                 *\n *          newMemMem = new member name (renamed to)              *\n *          VOLUME(zzzzzz) - zzzzzz = VOLSER of PDS (optional)    *\n *                                                                *\n * Note that ALL KEYWORDS can be abbreviated, i.e. V(VOLUME),     *\n * as long as they are distinguishable.                           *\n *                                                                *\n * 02/12/15 - VNV - First added.                                  *\n *                                                                *\n * -------------------------------------------------------------- */\n\ninDsn    = \"\"\ninVol    = \"\"\noldM     = \"\"\nnewM     = \"\"\npfxhead  = \" =>\"\npfx      = \"  >\"\npfxblk   = \"   \"\npfxprt   = \" ..\"\n\nparse source . . exec_Name .\n\nif SYSVAR(\"SYSENV\") = \"BACK\" then do\n   batIspf = 1\n   end\nelse do\n   if sysvar(SYSISPF) <> \"ACTIVE\" then do       /* under READY mode */\n      parse UPPER arg allParms\n      queue \"ISPSTART CMD(\"exec_Name allParms\") NEWAPPL(ISR)\"\n      exit\n      end\n   batIspf = 0\n   ispfDd  = '$#$'||STRIP(TIME(\"S\"))\n   x = outtrap(\"trap.\",\"*\")\n   address TSO \"FREE  F(\"ispfDD\")\"\n   address TSO \"ALLOC F(\"ispfDD\") SPACE(5 2) CYL DSORG(PS)\"  ,\n               \"LRECL(1024) RECF(F B)\"\n   address TSO \"MAKEBUF\"\n   tempRc = rc\n   x = outtrap(\"off\")\n   end\n\n\nsaveEnv = ADDRESS()\naddress ISPEXEC\n\n$sysid  = STRIP(MVSVAR('SYSNAME'))\n\nX=W(,,0)\nX=W(\"RENAME processing starts on\" ,\n     $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\n\nparse UPPER arg allParms\n\nX=W(\"Cmd Input =>\" exec_Name allParms,,0)\nX=W(,,0)\n\nif allParms = \"\" then do\n   x=Syntax_Err()\n   end\n\nx = Get_Parms(allParms)\nif inDsn = \"\" | oldM = \"\" | newM = \"\" then do\n   x=Syntax_Err()\n   end\n\nif inVol <> \"\" then do\n   xTra = \"VOLUME(\"inVol\")\"\n   xTraMsg = \" on\" inVol\n   end\nelse do\n   xTra = \"\"\n   xTraMsg = \"\"\n   end\n\n/* --------------------------------------------------------- *\n * To obtain the fully qualified Data set name in case the   *\n * PDSNAME supplied from parm did not have single quotes     *\n * around the name.                                          *\n * --------------------------------------------------------- */\n\ntemp = inDsn \"DIRECTORY NORECALL\" xTra\ntempRc = LISTDSI(temp)\nif tempRc = 16 then do\n   if SYSREASON = 9 then do\n      X=W(\"Data set\" inDsn \"has been migrated - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   If SYSREASON = 5 then do\n      X=W(\"Data set\" inDsn \"not cataloged - RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   else do\n      X=W(SYSMSGLVL2)\n      X=W(\"LISTDSI error for\" inDsn ,\n             \"- SYSREASON=\" SYSREASON \"- RC=12.\",12,0)\n      x=View_Data()\n      exit 12\n      end\n   end\n\ninDsn = sysdsname\nx=Print_Dsn()\nx=W(,,0)\n\nif SUBSTR(sysdsorg,1,2) <> \"PO\" then do\n   X=W(\"Data set is a non-PDS:\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\n/* ------------------------------------------------------------ *\n * Everything looks fine here.  Continue to process the PDS.    *\n * ------------------------------------------------------------ */\n\n\"CONTROL ERRORS RETURN\"\n\n\"LMINIT DATAID(dataid) DATASET('\"inDsn\"') ENQ(SHRW)\" xTra\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"INIT error for dataset\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   x=View_Data()\n   exit 12\n   end\n\n\"LMOPEN DATAID(\"dataid\") OPTION(OUTPUT)\"\nif rc > 0 then do\n   X=W(\"Err:\" STRIP(zerrlm))\n   X=W(\"OPEN error for dataset\" inDsn||xTraMsg \"- RC=12.\",12,0)\n   call Free_file\n   x=View_Data()\n   exit 12\n   end\n\n\"LMMREN DATAID(\"dataid\") MEMBER(\"oldM\") NEWNAME(\"newM\")\"\ntempRc = rc\n\n/* ------------------------------------------------------------ *\n * Issued the RENAME. Now check return codes.                   *\n * ------------------------------------------------------------ */\n\nexitCc = 0\n\nselect\n   when tempRc = 0 then do\n      X=W(oldM \"successfully renamed to\" newM \"in\" inDsn||xTraMsg ,\n            \"- RC=0.\",0,0)\n      end\n   when tempRc = 4 then do\n      X=W(newM \"already exists in\" inDsn||xTraMsg,\n             \"- RC=8.\",8,0)\n      exitCC = 8\n      end\n   when tempRc = 8 then do\n      X=W(oldM \"not found in\" inDsn||xTraMsg \"- RC=8.\",8,0)\n      exitCC = 8\n      end\n   otherwise do\n      X=W(\"Err:\" STRIP(zerrlm))\n      X=W(\"REN error for\" inDsn \"- RC=12.\",12,0)\n      exitCC = 12\n      end\n   end                                    /* select */\n\ncall Close_file\ncall Free_file\nx=View_Data()\n\naddress saveENV\n\nexit exitCC\n\n\nclose_file:\n\"LMCLOSE DATAID(\"dataid\")\"\nreturn 0\n\nFree_file:\n\"LMFREE DATAID(\"dataid\")\"\nreturn 0\n\nPrint_Dsn:\nx=W(STRIP(SYSDSNAME)                ,\n    \"V(\"STRIP(SYSVOLUME)\")\"         ,\n    \"RECF(\"STRIP(SYSRECFM)\")\"        ,\n    \"LRECL(\"STRIP(SYSLRECL)\")\"       ,\n    \"BLKS(\"STRIP(SYSBLKSIZE)\")\"      ,\n     LEFT(STRIP(SYSUNITS),3)         ,\n    \"SP(\"STRIP(SYSPRIMARY) STRIP(SYSSECONDS)\")\",,pfxPrt)\nreturn 0\n\n\nView_Data:\n\nX=W(,,0)\nX=W(\"Processing ends on\",\n    $sysid \"at\" TIME() \"on\" DATE('U')\".\",,pfxhead)\nX=W(,,0)\n\nif batISPF = 1 then nop\nelse do\n   address TSO \"EXECIO 0 DISKW\" ispfDD \"(FINIS\"\n   \"LMINIT DATAID(VIEWDD) DDNAME(\"ispfDD\")\"\n   \"BROWSE DATAID(\"viewDd\")\"\n   \"LMFREE DATAID(\"viewDd\")\"\n   address TSO \"FREE  F(\"ispfDD\")\"\n   end\n\nreturn 0\n\n\n/* ------------------------------------------------------------ *\n * Loop through and pick up all possible Parms. Each parm       *\n * will then be examined later to have appropriate values       *\n * parsed out and stored into different var (in another         *\n * routine: Obtain_Kw)                                          *\n * ------------------------------------------------------------ */\n\nGet_Parms:\n\narg inParms\n\nparse value inParms with myDsn inParms\nparse value myDsn with inDsn '(' oldM ')' endQuote\n\ninDsn = STRIP(inDsn)||STRIP(endQuote)\noldM  = STRIP(oldM)\n\nif WORDS(inParms) > 0 then do\n   do i=1 to WORDS(inParms)\n      parse value WORD(inParms,i) with inOption .\n      if INDEX(inOption,'(') > 0 then do   /* has to be VOL(xxx) */\n         call Obtain_Kw\n         end\n      else do                              /* has to be newname  */\n         if newM = \"\" then newM = STRIP(inOption)\n         else do\n            X=Syntax_Err()\n            end\n         end\n      end\n   end\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * Parse input to pick up appropriate parms                     *\n * ------------------------------------------------------------ */\n\nObtain_Kw:\nparse value inOption with keyWord \"(\" contents \")\"\ncontents = STRIP(contents)\nselect\n   when ABBREV('VOLUME',keyWord,1) = 1 then do\n      inVol = contents\n      end\n   otherwise do\n      X=Syntax_Err()\n      end\n   end\nreturn 0\n\n\nSyntax_Err:\nX=W(\"Valid syntax is:\" exec_Name ,\n    \"PDSname(oldMem) newMem - optional VOLUME(zzzzzz)\",12)\nx=View_Data()\nexit 12\nreturn 0\n\n/* ------------------------------------------------------------ *\n * This is to issue error message.  At the same time, set the   *\n * ISPF return code to whatever being passed (ready to exit).   *\n * This is the only way for ISPSTART to end with a non-zero RC. *\n * 3rd parm = line-prefix, if 0, then blank, if not there, use  *\n * normal prefix, any other values will use that as prefix.     *\n * ------------------------------------------------------------ */\n\n\nW:\nparse arg errMsg,errCode,inputPfx\n\nselect\n   when inputPfx = \"0\" then myPfx = pfxblk\n   when inputPfx = \"\" then myPfx = pfx\n   otherwise myPfx = inputPfx\n   end\n\nif batISPF = 1 then do\n   say myPfx errMsg\n   end\nelse do\n   queue myPfx errMsg\n   address TSO \"EXECIO 1 DISKW\" ispfDD\n   end\nif errCode <> \"\" then do\n   zispfrc = errCode\n   address ISPEXEC \"VPUT (ZISPFRC) SHARED\"\n   end\nreturn 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PARM": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x00O\\x00\\x99\\x00O\\x11\\x15\\x00\\xb5\\x00\\xb3\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-01-04T00:00:00", "modifydate": "1999-01-04T11:15:00", "lines": 181, "newlines": 179, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $PARM    REXX/CLIST      *********************/\n /* $PARM                                                            */\n /*                                                                  */\n /*    This exec takes in the parms and substitutes the input (from  */\n /*    DDNAME INPUT) as follows:  &1& with the 1st parm, &2& with    */\n /*    the 2nd parm, and so on.  Several reserved symbols will be    */\n /*    substituted as well.  They are ~xxxx~ whereas xxxx will be    */\n /*    JOBNAME, SYSID, etc ... (look in the code for these reserved  */\n /*    names). If { and } are used, whatever is inside the brackets  */\n /*    will be evaluated as a REXX function.  Of course, this does   */\n /*    include external REXX function as well.                       */\n /*                                                                  */\n /* SYNTAX: $PARM PARM1 PARM2                                        */\n /*    PARMn will be substituted for &n& in the INPUT data and       */\n /*    written out to DDNAME OUTPUT.                                 */\n /*                                                                  */\n /* Some examples for Input Data:                                    */\n /*    LINE1 &1&  &2&                                                */\n /*    LINE2 ~GDATE~~JDATE~ ~TIME~ ~SYSID~ ~WEEKDAY~ ~JOBNAME~       */\n /*    TODAY IS {DATE()} AND TIME IS {TIME()}                        */\n /*    {$DATE('J2G',$DATE('R2J',$DATE('J2R','19'||DATE('J'))+3))}    */\n /*       ---- Calc the dates for 3 days from now ----               */\n /*                                                                  */\n /********************************************************************/\n\nSYSDATA. = ''\nCall GET_SYSINFO\n\nPFX = ' '\nINDATA.  = ''\nARRAY.   = ''\n\nParse Arg PARMS\nPARMS = Strip(PARMS)\n\nNUM_PARM = Words(PARMS)\n\nSay PFX Time() Copies('-',80)\nSay PFX Time() '- Run starts on' Date(W)||', '||Date(U)\nSay PFX Time() Copies('-',80)\n\nDo I=1 To NUM_PARM\n   ARRAY.I = Strip(WORD(PARMS,I))\n   Say PFX Time() '- Parm' I':' ARRAY.I\n   End\nSay PFX Time() Copies('-',80)\n\nREAD_USERS:\n\n'EXECIO * DISKR INPUT   (STEM INDATA. FINIS'\n\nDo I=1 to INDATA.0\n   CNT = 0\n   Do J=1 To NUM_PARM\n      PATTERN = '&'||Strip(Format(J,3,0))||'&'\n      Do While Pos(PATTERN,INDATA.I) > 0             /* Go against */\n         Parse Var INDATA.I PART1 (PATTERN) PART2    /* parm table */\n         INDATA.I = PART1||ARRAY.J||PART2            /* and subst  */\n         CNT = CNT + 1                               /* all data   */\n         End                                         /*Do While Pos*/\n      End                                            /* Do J=1     */\n\n   Do While Pos('~',INDATA.I) > 0                    /* Go against */\n      Parse Var INDATA.I PART1 '~' TOKEN '~' PART2   /* SYSINFO tbl*/\n      TOKEN = Strip(Word(TOKEN,1))\n      INDATA.I = PART1||SYSDATA.TOKEN||PART2         /* and subst  */\n      CNT = CNT + 1                                  /* all data   */\n      End                                            /*Do While Pos*/\n\n   Do While Pos('{',INDATA.I) > 0                    /* Execute REXX  */\n      Parse Var INDATA.I PART1 '{' RFUNC '}' PART2   /* function      */\n      END_RESULT = 'NEWDATA='\n      Interpret END_RESULT RFUNC\n      INDATA.I = PART1||NEWDATA||PART2\n      CNT = CNT + 1\n      End\n\n   If CNT > 0 Then Do\n      Say PFX Time() '- Data substituted for record #',\n          Format(I,4,0)||':' INDATA.I\n      End\n   End                                               /* Do I=1     */\n\n\nEND_ALLUSERS:\n'EXECIO * DISKW OUTPUT  (STEM INDATA. FINIS'\n\nSay PFX Time() Copies('-',80)\nSay PFX Time() '- Run stops on' Date(W)||', '||Date(U)\n\nExit\n\n\nGET_SYSINFO:\n\nNumeric Digits 256\n\nCVT             = Get_Stor('10'x)\nASCB            = Get_Stor(0,'224'x)\nASXB            = Get_Stor(ASCB,'6C'x)\nLDA             = Get_Stor(ASCB,'30'x)\nACEE            = Get_Stor(ASXB,'C8'x)\nGDA             = Get_Stor(CVT,'230'x)\n\nTCB             = Get_Stor(0,'21C'x)\nTIOT            = Get_Stor(TCB,'C'x)\nJSCB            = Get_Stor(TCB,'B5'x,3)\nSSIB            = Get_Stor(JSCB,'13C'x)\nTCT             = Get_Stor(TCB,'A4'x)\nLCT             = Get_Stor(TCT,'98'x)\nOUCB            = Get_Stor(ASCB,'90'x)\nOUXB            = Get_Stor(ASCB,'94'x)\n\nJCT             = Get_Stor(LCT,'10'x)\nJCTX            = Get_Stor(LCT,'188'x)\nSCT             = Get_Stor(LCT,'14'x)\nCSCB            = Get_Stor(LCT,'0'x)\nJMR             = Get_Stor(LCT,'144'x)\n\n\nRACNAME@        = Get_Stor(ACEE,'64'x)\nRACNAME#        = C2D(Get_Stor(RACNAME@,0,1))\n\nRACINST@        = Get_Stor(ACEE,'10'x)\nRACINST#        = C2D(Get_Stor(RACINST@,0,1))\n\nSYSDATA.GDATE   = Strip(Date(S))\nSYSDATA.JDATE   = Strip(Date(J))\nSYSDATA.JOBID   = Strip(Get_Stor(SSIB,'C'x,8))\nSYSDATA.JOBNAME = Strip(Get_Stor(TIOT,0,8))\nSYSDATA.MSGCLASS= Get_Stor(JCT,'6'x,1)\nSYSDATA.RACGROUP= Strip(Get_Stor(ACEE,'1E'x,8))\nSYSDATA.RACINST = Strip(Get_Stor(RACINST@,1,(RACINST#-1)))\nSYSDATA.RACNAME = Strip(Get_Stor(RACNAME@,1,(RACNAME#-1)))\nSYSDATA.RACUSER = Strip(Get_Stor(ACEE,'15'x,8))\nSYSDATA.STEPNAME= Strip(Get_Stor(TCT,'C8'x,8))\nSYSDATA.SYSID   = Strip(Get_Stor(CVT,'154'x,8))\nSYSDATA.TIME    = Strip(Time())\nSYSDATA.USERID  = Strip(Get_Stor(JCT,'A0'x,7))\nSYSDATA.WEEKDAY = Strip(Date(W))\nSYSDATA.XEQCLASS= Get_Stor(JCT,'1F'x,1)\n\nReturn\n\n\n\nGet_Stor: PROCEDURE\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) Length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nParse Arg AREA,OFFSET,LENG\n\nIf Arg(2,'O') Then OFFSET=0\n\nIf Arg(3,'O') Then LENG=4\n\nIf DataType(AREA) = 'CHAR' Then Do\n   AREA =  C2D(AREA)\n   End\n\nIf DataType(OFFSET) = 'CHAR' Then Do\n   OFFSET =  C2D(OFFSET)\n   End\n\nReturn  Storage((D2X(AREA+OFFSET)),LENG)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PARM#": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00O\\x00\\x99\\x00O\\x11\\x12\\x006\\x00$\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-04T00:00:00", "modifydate": "1999-01-04T11:12:00", "lines": 54, "newlines": 36, "modlines": 0, "user": "NMVV1"}, "text": "//NMVV1C    JOB  (6948,TECH),'VINH.VU',MSGCLASS=X,\n//          CLASS=Z,NOTIFY=&SYSUID\n//*\n//OUTDFLT OUTPUT BUILDING='NM/LAS COLINAS',DEFAULT=YES,DEPT=ITS,\n//          ADDRESS=('TECHNICAL SUPPORT','1ST FLOOR'),\n//          NAME='VINH VU',ROOM='FLOOR1',JESDS=ALL,\n//          TITLE='CONSULTING TECHNOLOGIST' ,\n//*\n//*\n//*\n//BUILDCTL  EXEC PGM=IRXJCL,REGION=6M,\n//          PARM='$PARM INPUTPARM1 INPUTPARM2 INPUTPARM3'\n//SYSEXEC   DD   DSN=SYS3.TECH.SYSEXEC,DISP=SHR\n//SYSTSPRT  DD   SYSOUT=*\n//SYSTSIN   DD   DUMMY\n//INPUT     DD   *\n\n{CENTER('/*'||COPIES(' ',40)||'*/',72)}\n{CENTER('/* RUNS ON ~WEEKDAY~, ~GDATE~ AT ~TIME~ */',72)}\n{CENTER('/* BY ~JOBNAME~-~JOBID~ ON ~SYSID~ IN CLASS ~XEQCLASS~ */',72)}\n{CENTER('/* JOB   RACFUSER = ~RACUSER~ */',72)}\n\nPARM1 IS &1&\nPARM2 IS &2&\nPARM3 IS &3&\n\nFOLLOWING IS A LIST OF RESERVED SYMBOLS:\n\n'GDATE      '=  ~GDATE    ~\n'JDATE      '=  ~JDATE    ~\n'JOBID      '=  ~JOBID    ~\n'JOBNAME    '=  ~JOBNAME  ~\n'MSGCLASS   '=  ~MSGCLASS ~\n'RACGROUP   '=  ~RACGROUP ~\n'RACINST    '=  ~RACINST  ~\n'RACNAME    '=  ~RACNAME  ~\n'RACUSER    '=  ~RACUSER  ~\n'STEPNAME   '=  ~STEPNAME ~\n'SYSID      '=  ~SYSID    ~\n'TIME       '=  ~TIME     ~\n'USERID     '=  ~USERID   ~\n'WEEKDAY    '=  ~WEEKDAY  ~\n'XEQCLASS   '=  ~XEQCLASS ~\n\n{CENTER('/*'||COPIES(' ',40)||'*/',72)}\n{'/*   '||COPIES(' ',60)||'  */'}\n{'/*   '||COPIES(' ',60)||'  */'}\n{'/*   '||LEFT('JOB ~JOBNAME~(~JOBID~) ON ~SYSID~',60)||'  */'}\n{'/*   '||LEFT('RUNS ON ~WEEKDAY~, ~GDATE~ AT ~TIME~',60)||'  */'}\n{'/*   '||LEFT('IN CLASS ~XEQCLASS~ USING RACFID ~RACUSER~',60)||'  */'}\n{'/*   '||COPIES(' ',60)||'  */'}\n{'/*   '||COPIES(' ',60)||'  */'}\n\n//OUTPUT    DD   SYSOUT=*    --- OUTPUT ---\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$POINT": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01A\\x00\\x03\\x01\\x03&\\x8f\\x01 \\x07\\x0f\\x163\\x02\\x81\\x02\\x00\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.65", "flags": 0, "createdate": "2003-09-25T00:00:00", "modifydate": "2020-03-10T16:33:03", "lines": 641, "newlines": 512, "modlines": 0, "user": "VINHVU"}, "text": "/*                           Rexx                                */\n/* ------------------------------------------------------------- *\n *                                                               *\n * To grab the data set name at where the cursor is and brings   *\n * up a panel showing data set characteristics and also allows   *\n * it to be edited, browsed, etc... For the data set types that  *\n * ISPF cannot handle, i.e. VSAM, Loadlib, FileAid will be       *\n * invoked instead.                                              *\n *                                                               *\n * It is best used by setting up a PF key to say 'TSO %$POINT'   *\n * and then cursor down to a data set name any where on the      *\n * screen and hit that PF key.  Also note that because most      *\n * of the ISPF applications now use their own PFKEY settings,    *\n * this may have to be done in several places, i.e. SDSF, EDIT,  *\n * TSO Command Option 6, etc.. Just type in KEYS where the       *\n * command line is, and then change one of the PF key to say     *\n * 'TSO %$POINT' (without the single quotes). The best key to    *\n * use would normally be PF4.                                    *\n *                                                               *\n * Author - Vinh Vu                                              *\n * Date-written - 3/6/2003                                       *\n *                                                               *\n * External Rexx execs used in conjunction with this:            *\n *    $PDS - Used for PDSAA command (CBT Tape - file 182).       *\n *    $LIBR - To invoke Librarian function                       *\n *                                                               *\n * ------------------------------------------------------------- */\n\nif sysvar(SYSISPF) \u00ac='ACTIVE' then do\n   parse source . . exec_Name .\n   say exec_Name 'can only run under ISPF.'\n   exit\n   end\n\nmain_Panel = '$$PT01##'\n\ncvtadd  = Get_Stor('10'x)\nsysid   = LEFT(STRIP(Get_Stor(cvtadd,'154'x,8)),8)\nmyId    = LEFT(STRIP(USERID()),7)\n\naddress ISPEXEC\n\n'VGET (ZSCREEN,ZSCREENI,ZSCREENC,ZENVIR,ZSCREENW,ZSCREEND)'\n\n/* --------------------------------------------------------- *\n * Figuring out the data set name                            *\n * --------------------------------------------------------- */\n\nvalid_Data  = XRANGE('A','I')||XRANGE('J','R')||XRANGE('S','Z')||,\n              XRANGE('0','9')||'.()$#@-'\n\nmyWord = ''\n\nstartOfLine = (zscreenc%zscreenw)*zscreenw\nzscreenc  = zscreenc + 1\nendOfLine =  startOfLine+zscreenw\n/*  Debug\nt = SUBSTR(zscreeni,1,(endOfLine-startOfLine)*24)\n   say t\n    Debug */\ndo i=zscreenc by -1 to startOfLine+1\n   letter = SUBSTR(zscreeni,i,1)\n   if INDEX(valid_Data,TRANSLATE(letter)) = 0 then leave\n   myWord = myWord||letter\n   end\n\nmyWord = REVERSE(myWord)\n\nif myWord <> '' then do\n   do i=zscreenc+1 by 1 to endOfLine\n      letter = SUBSTR(zscreeni,i,1)\n      if INDEX(valid_Data,TRANSLATE(letter)) = 0 then leave\n      myWord = myWord||letter\n      end\n   end\nelse do\n   zedsmsg = ''\n   zedlmsg = 'Data set name cannot be blank.'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\nif SUBSTR(myWord,1,1) = '('   &,\n   SUBSTR(myWord,LENGTH(myWord),1) = ')' then do\n   parse var myWord '(' myWord ')'\n   end\n\nx = Validate_Dataset_Name(myWord)   /* Error msgs will be returned */\n                                    /* if there are any.           */\n\nif x <> '' then do\n   zedsmsg = ''\n   zedlmsg = x\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\nplain_Dsn = $dsn\n$dsn      = \"'\"$dsn\"'\"\n\nHFSdsat   = 0\n\n/* --------------------------------------------------------- *\n * Collect information about the data set to be displayed    *\n * on the panel.                                             *\n * --------------------------------------------------------- */\n\nmsg_Status = MSG(\"OFF\")\nx = LISTDSI($dsn 'DIRECTORY NORECALL')\ntemp = MSG(msg_Status)                 /* resets message value */\n\nzedlmsg = \"\"\n\nif x=16 then do\n   select\n      when sysreason = 9 then do\n         zedlmsg = $dsn 'has been migrated.'\n         gotReply = 0\n         do until gotReply\n            say $dsn 'is a migrated data set.'\n            say 'Do you want to recall the data set, Y or N ?'\n            pull ans\n            select\n               when ans = 'Y' then do\n                  address TSO 'HRECALL' $dsn\n                  say $dsn 'has been recalled.  Come back later.'\n                  gotReply = 1\n                  end\n               when ans = 'N' then do\n                  say 'HRECALL was not requested for' $dsn'.'\n                  gotReply = 1\n                  end\n               otherwise nop\n               end\n            end\n         end\n      when sysreason = 3 then do\n         HFSdsat = 1\n         end\n      when sysreason = 5 then do\n         zedlmsg = TRANSLATE($dsn) 'is not cataloged.'\n         end\n      otherwise do\n         zedlmsg = 'LISTDSI RC16 - Sysreason=' sysreason'.' ,\n                   sysmsglvl2 ' ==>>  Dsn='TRANSLATE($dsn)\n         end\n      end                                  /* select   */\n   end                                     /* if x=16  */\n\nif zedlmsg <> '' then do\n   zedsmsg = \"\"\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\n\"DSINFO DATASET(\"$dsn\")\"\n\n$apfFlag = zdsapf\n$lltFlag = zdslnk\n\n$action = ''\n\nif HFSdsat then do\n   $vol    = zdsvol\n   $dsorg  = zdsdsnt\n   $alctyp = STRIP(zdsspc)\n   $xtents = STRIP(zdsexta)\n   $alcpri = STRIP(zds1ex)\n   $alcsec = STRIP(zds2ex)\n   $cdate  = SUBSTR(zdscdate,6,5)||\"/\"||SUBSTR(zdscdate,3,2)\n   $rdate  = SUBSTR(zdsrdate,6,5)||\"/\"||SUBSTR(zdsrdate,3,2)\n   $alloc  = STRIP(zdstota)\n   $used   = STRIP(zdstotu)\n   $recfm  = STRIP(zdsrf)\n   $lrecl  = STRIP(zdslrec)\n   $blksz  = STRIP(zdsblk)\n   $diralc = STRIP(zdsdira)\n   $diruse = STRIP(zdsdiru)\n   $memnum = STRIP(zds#mem)\n   end\nelse do\n   $vol    = sysvolume\n   $dsorg  = sysdsorg\n   $alctyp = sysunits\n   $xtents = sysextents\n   $alcpri = sysprimary\n   $alcsec = sysseconds\n   $cdate  = SUBSTR(zdscdate,6,5)||\"/\"||SUBSTR(zdscdate,3,2)\n   $rdate  = SUBSTR(zdsrdate,6,5)||\"/\"||SUBSTR(zdsrdate,3,2)\n   $alloc  = sysalloc\n   $used   = sysused\n   $recfm  = sysrecfm\n   $lrecl  = syslrecl\n   $blksz  = sysblksize\n   $diralc = sysadirblk\n   $diruse = sysudirblk\n   $memnum = sysmembers\n   end\n\n\nddname  = '$'||STRIP(TIME('S'))||RANDOM(10,99)\n\naddress TSO 'ALLOC F('DDNAME') REUSE NEW DEL DSO(PO) DIR(1) SP(1)' ,\n            'TRACK RECFM(F B) LRECL(80)'\n'LMINIT DATAID(DID)  DDNAME('ddname') ENQ(EXCLU)'\n'LMOPEN DATAID(&DID) OPTION(OUTPUT)'\n\n/* --------------------------------------------------------- *\n * Build ISPF panels on the fly.                             *\n * --------------------------------------------------------- */\n\ncall W \")ATTR                                                          \"\ncall W \" { TYPE(TEXT)  CAPS(OFF)                  COLOR(TURQ)          \"\ncall W \" ~ TYPE(TEXT) CAPS(OFF) HILITE(REVERSE) COLOR(YELLOW)          \"\ncall W \" | TYPE(INPUT) HILITE(USCORE)             COLOR(TURQ)          \"\ncall W \" # TYPE(TEXT)  CAPS(OFF)  HILITE(REVERSE) COLOR(GREEN)         \"\ncall W \" % TYPE(TEXT)  CAPS(OFF)                                       \"\ncall W \" + TYPE(TEXT)  CAPS(OFF)                  COLOR(WHITE)         \"\ncall W \" \u00a6 TYPE(TEXT)  CAPS(OFF)  HILITE(USCORE)  COLOR(YELLOW)        \"\ncall W \" ! TYPE(TEXT)  CAPS(OFF)                  COLOR(YELLOW)        \"\ncall W \" @ TYPE(OUTPUT) JUST(ASIS) COLOR(GREEN)                        \"\ncall W \" } TYPE(OUTPUT) JUST(ASIS) COLOR(PINK)                         \"\ncall W \" \u00ac TYPE(OUTPUT) JUST(ASIS)  HILITE(REVERSE) COLOR(RED)         \"\ncall W \" _ TYPE(OUTPUT) JUST(ASIS)                  COLOR(WHITE)       \"\ncall W \")BODY WINDOW(65,18) EXPAND(``)                                 \"\ncall W \"@ZDATESTD   {`-`~Data Set Summary{`-`@ZTIMEL     +             \"\ncall W \"+Command%===>|ZCMD                                             \"\ncall W \"+                                                              \"\ncall W \"+Action   !==>|Z+   \u00a6B+={Browse \u00a6E+={Edit \u00a6F+={FileAid Edit    \"\ncall W \"+                   \u00a6L+={LIBRIAN\u00a6V+={View \u00a6W+={WorkPlace       \"\ncall W \"+                   \u00a6\\+={DSList \u00a6/+={Other Action Command      \"\ncall W \"+DSN      !==>@$DSN                                           +\"\ncall W \"+Member   !==>|$MEM    +                                       \"\ncall W \"+                    CrDate!==>@$CDATE  + Refdate!==>@$RDATE  +\"\ncall W \"+Vol  !==>@$VOL  +    DSORG!==>@$DSORG+   Extents!==>@$XTENTS +\"\ncall W \"+AlcTp!==>}$ALCTYP +  Alloc!==>}$ALLOC  +    Used!==>}$USED +  \"\ncall W \"+                   Primary!==>}$ALCPRI + Secndry!==>}$ALCSEC +\"\ncall W \"+Recfm!==>@$RECFM+    Lrecl!==>@$LRECL+   Blksize!==>@$BLKSZ+  \"\ncall W \"{  APF!==>}$APFFLAG{ LnkLst!==>}$LLTFLAG+                      \"\ncall W \"{`-` << PDS Dir Information Only >>{`-`                        \"\ncall W \"+Alloc!==>@$DIRALC+    Used!==>@$DIRUSE+   MemNum!==>@$MEMNUM+ \"\ncall W \"{`-`                                                           \"\ncall W \"}sysid` `#Enter+To Proceed or#END+to Cancel+` `}myId   +\"\ncall W \")INIT                                                          \"\ncall W \"   .ZVARS = '($ACTION)'                                        \"\ncall W \"   &ZCMD = ' '                                                 \"\ncall W \")PROC                                                          \"\ncall W \"   VER (&$ACTION,NB,LIST,B,E,F,L,P,V,W,/,\\)                    \"\ncall W \")END                                                           \"\n\n'LMMADD DATAID(&DID) MEMBER('main_Panel')'\n\n'LMFREE DATAID(&DID)'\n'LIBDEF ISPPLIB LIBRARY ID('ddname') STACK'\n\n'ADDPOP COLUMN(5)'\n'DISPLAY PANEL('main_Panel')'\ntemprc = rc\n'REMPOP'\n'CONTROL ERRORS RETURN'\n\nif temprc = 8 then do\n   call Clean_Up\n   exit\n   end\n\n/* --------------------------------------------------------- *\n * Clean up member name if DSORG is neither 'PO' nor 'POU'.  *\n * Otherwise, for 'View' and 'Browse', give error rc if      *\n * member does not exist.                                    *\n * --------------------------------------------------------- */\n\nlibr_mem = $mem                          /* Librarian member name  */\n\nif FIND('PO POU',$dsorg) = 0 then $mem = ''\nelse do\n   if $mem <> '' then do\n      $dsn = \"'\"plain_dsn\"(\"$mem\")'\"\n      if $action = 'B' | $action = 'V' then do\n         msg_Status = MSG(\"OFF\")\n         x = SYSDSN($dsn)\n         temp = MSG(msg_Status)          /* resets message value */\n         if x <> \"OK\" then do\n            zedsmsg = ''\n            zedlmsg = x'.'\n            'SETMSG MSG(ISRZ001)'\n            call Clean_Up\n            exit\n            end    /* if x <> \"OK\"  */\n         end       /* if $action    */\n      end          /* if $mem       */\n   end             /* else do       */\n\n/* --------------------------------------------------------- *\n * When I get here, we'll take action based on input command.*\n * For anything that ISPF cannot handle, FileAid (Compuware) *\n * will be invoked instead.                                  *\n * --------------------------------------------------------- */\n\nnonIspf = 'DA DAU IS ISU VS'     /* ISPF cannot handle these dsats */\n\nselect\n\n/* --------------------------------------------------------- *\n * This is 'Browse' function.  FileAid used if necessary.    *\n * --------------------------------------------------------- */\n\n   when $action = 'B' then do               /*  Browse data set  */\n      if FIND(nonIspf,$dsorg) > 0 | $recfm = 'VBS' then do\n         zedsmsg = '*** FileAid Browse ***'\n         zedlmsg = 'ISPF Browse cannot handle this data set.',\n                   'FileAid is now invoked.'\n         'SETMSG MSG(ISRZ000)'\n         'SELECT CMD(%FADYNALC 1 DSN('$dsn') QUOTE) NEWAPPL(FAXX)'\n         end\n      else do\n         'BROWSE DATASET('$dsn')'\n         x = Check_ReturnCode(rc,'B')\n         end\n      end\n\n/* --------------------------------------------------------- *\n * This is 'View' function.  FileAid used if necessary.      *\n * --------------------------------------------------------- */\n\n   when $action = 'V' then do               /*  View data set    */\n      if FIND(nonIspf,$dsorg) > 0 | $recfm = 'VBS' then do\n         zedsmsg = '*** FileAid Browse ***'\n         zedlmsg = 'ISPF View cannot handle this data set.',\n                   'FileAid is now invoked.'\n         'SETMSG MSG(ISRZ000)'\n         'SELECT CMD(%FADYNALC 1 DSN('$dsn') QUOTE) NEWAPPL(FAXX)'\n         end\n      else do\n         'VIEW DATASET('$dsn')'\n         x = Check_ReturnCode(rc,'V')\n         end\n      end\n\n/* --------------------------------------------------------- *\n * This is 'Edit' function.  FileAid used if necessary.      *\n * --------------------------------------------------------- */\n\n   when $action = 'E' then do               /*  Edit data set    */\n      if FIND(nonIspf,$dsorg) > 0 | $recfm = 'VBS' |,\n                                    $recfm = 'U' then do\n         zedsmsg = '*** FileAid Edit ***'\n         zedlmsg = 'ISPF Edit cannot handle this',\n                   'data set. FileAid is now invoked.'\n         'SETMSG MSG(ISRZ000)'\n         'SELECT CMD(%FADYNALC 2 DSN('$dsn') QUOTE) NEWAPPL(FAXX)'\n         end\n      else do\n         'EDIT DATASET('$dsn')'\n         x = Check_ReturnCode(rc,'E')\n         end\n      end\n\n/* --------------------------------------------------------- *\n * This is 'FileAid' function as requested by user.          *\n * --------------------------------------------------------- */\n\n   when $action = 'F' then do               /*  FileAid Edit     */\n      'SELECT CMD(%FADYNALC 2 DSN('$dsn') QUOTE) NEWAPPL(FAXX)'\n      end\n\n/* --------------------------------------------------------- *\n * This is 'Librarian' function (at Citigroup). Verification *\n * is done to ensure that DSORG is either 'DA' or 'DAU'.     *\n * --------------------------------------------------------- */\n\n   when $action = 'L' then do               /*  Librarian        */\n      if FIND('DA DAU',$dsorg) = 0 then do\n         zedsmsg = '** Invalid DSORG **'\n         zedlmsg = 'Non-Librarian DSORG for:' $dsn'.'\n         'SETMSG MSG(ISRZ001)'\n         end\n      else do\n         if libr_mem <> '' then do\n            $dsn = \"'\"plain_dsn\"(\"libr_mem\")'\"\n            end\n         queue '$LIBR' $dsn\n         end\n      end\n\n/* --------------------------------------------------------- *\n * This is 'PDS' function (the old PDSAA command from the    *\n * CBT tape - file 182).  However, if a PDSE is found, then  *\n * go to ISPF 3.4 instead.                                   *\n * --------------------------------------------------------- */\n\n   when $action = 'P' then do               /*  PDSAA command    */\n      if FIND('PO POU',$dsorg) = 0 |,\n         $diralc = 'NO_LIM'        then do  /*  PDSE             */\n         zedsmsg = '** Invalid DSORG **'\n         zedlmsg = 'PDSAA cmd can only handle Partitioned Data Set.'\n         'SETMSG MSG(ISRZ001)'\n         dsn_list = \"'\"||plain_Dsn||\"'\"     /*  Invoke DSLIST    */\n         'SELECT PGM(ISRDSLST) PARM(DSL' dsn_list') SUSPEND'\n         end\n      else do\n         queue '$PDS' \"'\"||plain_Dsn||\"'\"\n         end\n      end\n\n/* --------------------------------------------------------- *\n * This '/' action will present another panel with the data  *\n * set name filled in already.  Commands can be entered      *\n * in front of DSN for further action, i.e. 'DELETE', etc.   *\n * --------------------------------------------------------- */\n\n   when $action = '/' then do\n      x = Flag_Notices()\n      zcmd = '*       ' $dsn\n      'VPUT (ZCMD)'\n      'SELECT PGM(ISRRCL) PARM(C1) SUSPEND SCRNAME($POINT)'\n      zcmd = ''\n      'VPUT (ZCMD)'\n      end\n\n/* --------------------------------------------------------- *\n * This is 'DSLIST' function (ISPF 3.4).                     *\n * --------------------------------------------------------- */\n\n   when $action = '\\' then do               /*  DSLIST command   */\n\n   /* --------------------------------------------------------- *\n    *  The following will just bring up the 3.4 screen only     *\n    *  with just the DSNAME filled in.                          *\n    * --------------------------------------------------------- */\n\n   /* zdldsnlv = plain_Dsn\n      'VPUT (zdldsnlv) PROFILE'\n      'SELECT PGM(ISRUDL) PARM(ISRUDLP)'    */\n\n   /* --------------------------------------------------------- *\n    *  The following will take you straight to the data set.    *\n    * --------------------------------------------------------- */\n\n      dsn_list = \"'\"||plain_Dsn||\"'\"\n      'SELECT PGM(ISRDSLST) PARM(DSL' dsn_list') SUSPEND'\n      end\n\n/* --------------------------------------------------------- *\n * This is 'WorkPlace' function under ISPF.                  *\n * --------------------------------------------------------- */\n\n   when $action = 'W' then do               /*  WorkPlace        */\n      zwrkdsn = \"'\"plain_Dsn\"'\"\n      zwrkvol = ''\n      zreftype = 'D'\n      'VPUT (zwrkdsn zwrkvol zreftype) PROFILE'\n      'SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)'\n      end\n\n   otherwise nop\n\n   end\n\ncall Clean_Up\n\nexit\n\nClean_Up:\n\n'LIBDEF ISPPLIB'\naddress TSO 'FREE F('ddname')'\n\nreturn 0\n\nFlag_Notices: procedure\nzedsmsg = ''\nzedlmsg = 'Change * to any valid command and hit Enter to',\n          'execute or PF3 to cancel.  Once the command has',\n          'been executed, hit PF3 to return to your original',\n          'ISPF screen.'\n'SETMSG MSG(ISRZ001)'\nreturn 0\n\nCheck_ReturnCode: procedure\n\n/* --------------------------------------------------------- *\n * This function checks ISPF return code for 'Edit', 'View'  *\n * and 'Browse' function.  Some of the common errors would   *\n * be Browsing non-existing members, Editing a data set      *\n * allocated as 'OLD' by other users, etc.                   *\n * --------------------------------------------------------- */\n\narg returnCode,function .\nif returnCode = 0 then return 0\n\nzedsmsg = ''\n\nselect\n\n   when function = 'V' then do\n      select\n         when returnCode = 12 then,\n            zedlmsg = 'VIEW has been disabled through the',\n                      'ISPF configuration table.'\n         when returnCode = 14 then,\n            zedlmsg = 'Member or sequential data set is in use.'\n         when returnCode = 16 then,\n            zedlmsg = 'No matching members found in data set.'\n         otherwise ,\n            zedlmsg = 'Severe error - RC:'returnCode'.',\n                      'Unable to continue.'\n         end\n      end\n\n   when function = 'B' then do\n      select\n         when returnCode = 12 then,\n            zedlmsg = 'Zero-length data; empty sequential or',\n                      'zero-length member of a partitioned data set.'\n         when returnCode = 14 then,\n            zedlmsg = 'Specified member not found.'\n         when returnCode = 16 then,\n            zedlmsg = 'No matching members found in data set.'\n         otherwise ,\n            zedlmsg = 'Severe error - RC:'returnCode'.',\n                      'Unable to continue.'\n         end\n      end\n\n   when function = 'E' then do\n      select\n         when returnCode = 4 then,\n            zedlmsg = ''\n         when returnCode = 14 then,\n            zedlmsg = 'Member or sequential data set is in use.'\n         when returnCode = 16 then,\n            zedlmsg = 'No matching members found in data set.'\n         otherwise ,\n            zedlmsg = 'Severe error - RC:'returnCode'.',\n                      'Unable to continue.'\n         end\n      end\n\n   otherwise nop\n\n   end\n\n'SETMSG MSG(ISRZ000)'\n\nreturn 0\n\n\n/* --------------------------------------------------------- *\n * Verifies the data set name and make sure that it is legit *\n * Check also made to ensure that if a member name is used,  *\n * it does conform to MVS standard.  Also, GDG names will be *\n * detected and rejected as well (we just can't handle it    *\n * for now).                                                 *\n * --------------------------------------------------------- */\n\nValidate_Dataset_Name: procedure expose $dsn $mem\n\ninvalid_Mem = '.('\n\nparse arg myWord\n\n$dsn   = ''\n$mem   = ''\nretMsg = ''\n\nif INDEX(myWord,'(') > 0 then do\n   parse var myWord $dsn '(' $mem ')' residual\n   $mem = STRIP($mem)\n\n   select\n\n      when $mem = '0' then do\n         retMsg = 'Relative GDG is not currently supported.'\n         end\n\n      when $dsn = ''                      | ,\n           residual <> ''                 | ,\n           $mem = ''                      | ,\n           DATATYPE($mem) = 'NUM'         | ,\n           LENGTH($mem) > 8               | ,\n           INDEX(invalid_Mem,$mem) > 0    | ,\n           DATATYPE(SUBSTR($mem,1,1)) = 'NUM' then do\n           retMsg = 'Data set name not valid as:' myWord'.'\n         end\n\n      otherwise nop\n\n      end\n   end\nelse do\n   if DATATYPE(SUBSTR(myWord,1,1)) = 'NUM' then do\n      retMsg = 'A relative GDG and/or invalid data set name detected.'\n      end\n   else $dsn = myWord\n   end\n\nreturn retMsg\n\nW:\nparse arg p1\n\"LMPUT DATAID(&DID) MODE(INVAR) DATALOC(P1) DATALEN(80)\"\nreturn\n\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nGet_Stor: procedure\n\nparse arg area,offset,leng\n\nif ARG(2,'O') then offset=0\n\nif ARG(3,'O') then leng=4\n\nif DATATYPE(area) = 'CHAR' then do\n   area =  C2D(area)\n   End\n\nif DATATYPE(offset) = 'CHAR' then do\n   offset =  C2D(offset)\n   End\n\nreturn  STORAGE((D2X(area+offset)),leng)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$Q": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00O\\x00\\x99\\x00O\\t1\\x00:\\x00:\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-04T00:00:00", "modifydate": "1999-01-04T09:31:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $Q       REXX/CLIST      *********************/\n /* $Q                                                               */\n /*                                                                  */\n /*   This REXX exec takes the parm and issues that as a TSO command */\n /*   and then displays the output in the forms of ISPF EDIT NOTE    */\n /*   lines.  This only works if the TSO command does PUTLINE (not   */\n /*   TPUTs).                                                        */\n /*                                                                  */\n /* SYNTAX: $Q                                                       */\n /*                                                                  */\n /********************************************************************/\n\n\nAddress ISPEXEC\n\nParse Source . . EDIT_MACRO_NAME .\n\n'CONTROL ERRORS RETURN'\n'ISREDIT MACRO (CMD)'\nIf Rc \u00ac=0 Then Do\n   ZEDSMSG = EDIT_MACRO_NAME||' Error'\n   ZEDLMSG = EDIT_MACRO_NAME||' can only run as an ISPF EDIT macro !!!'\n   'SETMSG MSG(ISRZ001)'\n   Exit\n   End\nIf CMD = '' Then Exit\n\n'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n'ISREDIT (ENDLINE) = LINENUM .ZLAST'\n'ISREDIT (CURRTOP,CURRBOT) = DISPLAY_LINES'\n\nX = OUTTRAP('O.')\nAddress TSO CMD\nIf O.0 = 0 Then Do\n   ZEDSMSG = 'No trapped output'\n   ZEDLMSG = 'TSO Command does not generate any output to be trapped'\n   'SETMSG MSG(ISRZ000)'\n   End\nElse Do\n   BLANKLNE = ''\n   DASHLINE = Copies('=',72)\n   DATELINE = Date(W)||', '||,\n              Date(U)||' at '||Time()\n   FOOTAGE =  \"Output from command '\"||,\n              Translate(CMD)\"'\"\n   DATELINE = Center(DATELINE,72)\n   FOOTAGE  = Center(FOOTAGE,72)\n   'ISREDIT LINE_BEFORE' CURRTOP '= MSGLINE  (DATELINE)'\n   'ISREDIT LINE_BEFORE' CURRTOP '= MSGLINE  (FOOTAGE)'\n   Do I=1 To O.0            /*  Display trapped output from TSO cmd */\n      MYNOTE = O.I\n      'ISREDIT LINE_BEFORE' CURRTOP '= NOTELINE (MYNOTE)'\n      End\n   'ISREDIT LINE_BEFORE' CURRTOP '= INFOLINE (DASHLINE)'\n   End\nX = OUTTRAP('OFF')\n'ISREDIT UP' O.0+3\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RXSYMBL": {"ttr": 5387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00(\\x00\\x98\\x08\\x9f\\x01\\x052/\\x08\\x10\\x01M\\x00k\\x00\\x00\\xc9\\xe3\\xe2\\xe7\\xe2\\xc2\\xf5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1998-03-30T00:00:00", "modifydate": "2005-11-18T08:10:28", "lines": 333, "newlines": 107, "modlines": 0, "user": "ITSXSB5"}, "text": "$RXSYMBL CSECT\n$RXSYMBL RMODE ANY\n$RXSYMBL AMODE 31\n*\n* ------------------------------------------------------------ *\n*        AUTHOR - VINH VU                                      *\n*        DATE WRITTEN - 11/14/05                               *\n*                                                              *\n*        REGISTER USAGE                                        *\n*                                                              *\n*              R0  - WORK                                      *\n*              R1  - WORK                                      *\n*              R2  - WORK                                      *\n*              R3  - ADDRESS OF ARG                            *\n*              R4  - LENG OF ARG                               *\n*              R5  - ARGTABLE_ENTRY                            *\n*              R6  -                                           *\n*              R7  -                                           *\n*              R8  -                                           *\n*              R9  - USED AS RC                                *\n*              R10 -                                           *\n*              R11 - EVALBLOCK                                 *\n*              R12 - BASE REG                                  *\n*              R13 -                                           *\n*              R14 - TEMP                                      *\n*              R15 - TEMP                                      *\n*                                                              *\n*        PURPOSE - TO INVOKE THE ASASYMBP TO RESOLVE AND SUBS  *\n*                 ALL SYSTEM SYMBOLICS IN THE INPUT STRING     *\n*                 AND RETURN THE OUTPUT.                       *\n*                                                              *\n*        THIS IS A REXX ROUTINE THAT WILL RESOLVE/SUBSTITUTE   *\n*        THE SYMBOLICS FROM THE INPUT CHARACTER STRING, E.G.   *\n*                                                              *\n*        NEW_STRING = $RXSYMBL('&SYSPLEX..&B1..TESTNAME')      *\n*                                                              *\n*        NEW_STRING -> PLEX41.G0.TESTNAME                      *\n*                                                              *\n* ------------------------------------------------------------ *\n*\n* ------ IN-LINE MACROS BEGINNING ---------------------------- *\n*                                                              *\n         MACRO\n         SET   &BASE,&LV=,&DSECT=,&REG=\n.*\n.*--------------------------------------------------------------------\n.*\n.*       MACRO = SET\n.*\n.*       AUTHOR = VINH VU\n.*\n.*       DATE-WRITTEN = 08/31/81\n.*\n.*       PURPOSE = TO SET UP BASE REGS FOR A SOURCE MODULE.\n.*             IF LV IS OMITTED, PROGRAM IS ASSUMED NOT TO BE\n.*             RE-ENTRANT. USE EXIT MACRO IN CONJUNCTION WITH THIS\n.*             MACRO.\n.*             FOR RE-ENTRANT MODULE, 18F AS SAVE AREA WILL\n.*             BE ASSUMED TO BE FIRST. PAY ATTENTION TO THIS\n.*             WHEN YOU SET UP THE DSECT.\n.*\n.*       EXAMPLES =\n.*\n.*         *   SET (R12,R11),LV=WKLENG,DSECT=WKAREA\n.*\n.*             R12 AND R11 WILL BE BASE REGISTERS.\n.*             LV WILL ASSUME A RE-ENTRANT MODULE AND THIS IS THE\n.*                LENGTH OF THE GETMAIN AREA BEING OBTAINED (WHICH\n.*                ALSO INCLUDES THE SAVE AREA OF 18F THAT WILL BE\n.*                AT THE BEGINNING OF THE GETMAINED AREA.)\n.*                THE GETMAINED DSECT SHOULD LOOK LIKE :\n.*                           WKAREA    DSECT\n.*                                     DS    18F\n.*                           USER1     DS    CL256\n.*                                     ETC   ........\n.*\n.*         *   SET LV=WKLENG\n.*\n.*             THIS ASSUMES R12 AS BASE REGISTER, A RE-ENTRANT\n.*                MODULE, BUT YOU WILL HAVE TO CODE THE USING\n.*                STATEMENT FOR THE GETMAIN AREA DSECT\n.*\n.*         *   SET\n.*\n.*             THIS ASSUMES A NON-RE-ENTRANT MODULE, R12 WILL BE\n.*                BASE REGISTER.\n.*\n.*--------------------------------------------------------------------\n.*\n         LCLA  &C,&TEST,&ORG,&CSLENG\n         LCLC  &B,&SAVE\n         GBLC  &SETEXIT\n&SETEXIT SETC  ''\n&ORG     SETA  0\n&TEST    SETA  1\n         AIF   (T'&BASE EQ 'O').DEF\n&C       SETA  N'&BASE\n&B       SETC  '&BASE(&TEST)'\n         AGO   .EQU\n.DEF     ANOP\n&C       SETA  1\n&B       SETC  'R12'\n.EQU     ANOP\n         AIF   (T'&REG EQ 'O').SETREG\n         AGO   .REGDONE\n.SETREG  ANOP\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n.REGDONE ANOP\n         B     28(R15)             BRANCH AROUND\n&CSLENG  SETA  K'&SYSECT\n         DC    AL2(&CSLENG)        LENG OF CSECT NAME\n         DC    CL8'&SYSECT'        CSECT NAME\n         DC    CL8'&SYSDATE'       THIS IS DATE\n         DC    CL6'&SYSTIME'       THIS IS TIME\n         CNOP  0,4                 GET ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE PREVIOUS REGS\n         LR    &B,R15              GET BASE REG SETUP\n         USING &SYSECT,&B          ESTABLISH ADDRESABILITY\n.LOOP    ANOP\n         AIF   (&TEST EQ &C).THRU\n&SAVE    SETC  '&BASE(&TEST)'\n&ORG     SETA  &ORG+4096\n&TEST    SETA  &TEST+1\n&B       SETC  '&BASE(&TEST)'\n         USING &SYSECT+&ORG,&B\n         LA    &B,4095(,&SAVE)\n         LA    &B,1(,&B)\n         AGO   .LOOP\n.THRU    ANOP\n         AIF   (T'&LV EQ 'O').NORENT\n&SETEXIT SETC  '&LV'\n         GETMAIN R,LV=&LV\n         ST    R13,4(,R1)          SAVE REG13 FROM PREVIOUS\n         L     R15,24(,R13)        SAVE REG 1\n         ST    R1,8(,R13)          SAVE MY REG13 IN PREV SAVE AREA\n         LR    R13,R1              GET MY REG 13 READY\n         LR    R1,R15              GET REG1 BACK\n         AIF   (T'&DSECT EQ 'O').FINAL\n         USING &DSECT,R13          ESTABLISH ADDRESSABILITY\n.FINAL   ANOP\n         MEXIT\n.NORENT  ANOP\n         CNOP  0,4                 GET ALIGNMENT\n         BAL   R1,*+76             BRANCH AROUND\n         DS    18F                 THIS IS MY SAVE AREA\n         ST    R13,4(,R1)          SAVE REG13 FROM PREVIOUS\n         L     R15,24(,R13)        SAVE REG 1\n         ST    R1,8(,R13)          SAVE MY REG13 IN PREV SAVE AREA\n         LR    R13,R1              GET MY REG 13 READY\n         LR    R1,R15              GET REG1 BACK\n         MEND\n*\n* ------------------------------------------------------------ *\n*\n         MACRO\n         EXIT  &RC=,&R=\n.*\n.*--------------------------------------------------------------------\n.*\n.*       MACRO = EXIT\n.*\n.*       AUTHOR = VINH VU\n.*\n.*       DATE-WRITTEN = 09/02/81\n.*\n.*       PURPOSE = TO EXIT FROM A MODULE\n.*             THIS HAS TO BE USED IN CONJUNCTION WITH MACRO\n.*             SET WHICH IS THE INITIALIZATION MACRO.\n.*\n.*       EXAMPLES :\n.*\n.*         *   EXIT RC=10\n.*\n.*             THIS WILL GENERATE A RETURN CODE OF 10. NO FREEMAIN\n.*                WILL BE DONE\n.*\n.*         *   EXIT R=R9\n.*\n.*             THIS WILL GENERATE RETURN CODE FROM CONTENTS OF REG 9.\n.*                A FREEMAIN WILL BE DONE ALSO ASSUMING ADDRESS OF\n.*                GETMAINED AREA IS IN REG13 (DONE IN MACRO SET).\n.*\n.*--------------------------------------------------------------------\n.*\n         GBLC  &SETEXIT\n         AIF   ('&SETEXIT' EQ '').NOFREE\n         LR    R1,R13              GET ADDR OF GMAREA INTO R1\n         L     R13,4(,R13)         GET PREVIOUS SAVE AREA\n         FREEMAIN R,LV=&SETEXIT,A=(R1)\n         AGO   .FREEIT\n.NOFREE  ANOP\n         L     R13,4(,R13)         GET PREVIOUS SAVE AREA\n.FREEIT  ANOP\n         AIF   (T'&RC EQ 'O').CKR\n         LA    R15,&RC             GET RETURN CODE\n         AGO   .THRU\n.CKR     ANOP\n         AIF   (T'&R EQ 'O').NONE\n         LR    R15,&R              GET RETURN CODE\n         AGO   .THRU\n.NONE    ANOP\n         SR    R15,R15             RETURN CODE IS ZERO\n.THRU    ANOP\n         L     R14,12(0,R13)       GET R14\n         LM    R0,R12,20(R13)      GET REG 0 - 12\n         BR    R14                 RETURN TO CALLER\n         MEND\n*\n* ------ IN-LINE MACROS END ---------------------------------- *\n*\n* ------------------------------------------------------------ *\n*        REAL CODES BEGIN                                      *\n* ------------------------------------------------------------ *\n*\n         SET   (R12),LV=WKLENG,DSECT=WKAREA   SAVE CALLER'S REGS\n*\nPARMLST  EQU   *                              LABEL PARMLST\n         SR    R9,R9                          CLEAR OUT RC\n         USING EFPL,R1                        MAP EVAL PARM LIST\n         L     R2,EFPLEVAL                    LOAD EVAL POINTER\n         L     R11,0(R2)                      ADRESS OF EVAL BLOCK\n         USING EVALBLOCK,R11                  MAP EVAL BLOCK\n         L     R5,EFPLARG                     LOAD ARG LST PNTR\n         USING ARGTABLE_ENTRY,R5              MAP THE ENTRY\n*\n* ------------------------------------------------------------ *\n*        GET/PROCESS PARM                                      *\n* ------------------------------------------------------------ *\n*\n         LM    R3,R4,ARGTABLE_ARGSTRING_PTR   LOAD ARG ADDR/LNGTH\n*\n* ------------------------------------------------------------ *\n*        R3 = PARM LENGTH, R4 = ADDRESS TO PARM                *\n* ------------------------------------------------------------ *\n*\n         LTR   R4,R4                          HAS TO BE > 0\n         BC    13,BAD_CALL\n         LTR   R3,R3                          CHECK PARM ADDRESS\n         BC    13,BAD_CALL\n         C     R4,F250                        CHECK FOR TXT > 250\n         BH    BAD_CALL                       YES - THEN BAD CALL\n*\n         MVI   INDATA,C' '\n         MVC   INDATA+1(L'INDATA-1),INDATA\n         XC    WKSYMBP,WKSYMBP                CLEAR OUT WKAREA\n         LA    R14,WKSYMBP\n         USING SYMBP,R14                      SET UP WKAREA\n*\n         LA    R1,INDATA\n         ST    R1,SYMBPPATTERN@\n         ST    R4,SYMBPPATTERNLENGTH          GET INPUT LENGTH\n*\n         BCTR  R4,0\n         EX    R4,GETINPUT\n         EX    R4,TRTIT                    CHECK FOR '&'\n         BC    8,NOXLATE                   IF NOT FND, DON'T DO NOTHING\n*\n         LA    R1,EVALBLOCK_EVDATA         GET ADDRESS OF OUTPUT AREA\n         ST    R1,SYMBPTARGET@             STORE IT IN SMBP\n         MVC   EVALBLOCK_EVLEN,F250        SET MAX LENGTH\n         LA    R1,EVALBLOCK_EVLEN          GET ADDRESS OF OUTPUT LENGT\n         ST    R1,SYMBPTARGETLENGTH@       STORE IT IN SMBP\n*\n         LA    R1,RCODE                    GET ADDRESS OF RC\n         ST    R1,SYMBPRETURNCODE@         STORE IT IN SMBP\n         LINK  EP=ASASYMBM,MF=(E,SYMBP)    CALL SYMBOL SERVICE\n*\n         LA    R5,ARGTABLE_NEXT-ARGTABLE_ENTRY(R5)     NO NEXT PARM\n         CLC   ARGTABLE_ARGSTRING_PTR(8),=8X'FF'\n         BNE   BAD_CALL                             ELSE GOTO BAD_CALL\n*\nGETOUT   EQU   *                              LABEL RETURN\n         EXIT  R=R9                           USE R9 AS RC\n*\nNOXLATE  EQU   *\n         LA    R4,1(,R4)                      GET BACK THE ORIG LENTH\n         STCM  R4,B'1111',EVALBLOCK_EVLEN     SAVE IT BACK\n         MVC   EVALBLOCK_EVDATA(L'INDATA),INDATA    GET INPUT DATA BACK\n         B     GETOUT                         READY TO RETURN\n*\n*\nGETINPUT MVC   INDATA(0),0(R3)                SAVE INPUT DATA\n*\nTRTIT    TRT   INDATA(0),TRTABLE              CHECK FOR C'&'\n*\nBAD_CALL EQU   *                              LABEL BAD_CALL\n         MVC   EVALBLOCK_EVLEN,F1             RETURN VAL LNGTH\n         MVI   EVALBLOCK_EVDATA,C'N'          RETURN 'N'\n         LA    R9,4                           RC=4\n         B     GETOUT\n*\nMAXLENG  EQU   250\n*\nF1       DC    F'1'\nF250     DC    AL4(MAXLENG)\n*\nTRTABLE  DC    256X'00'\n         ORG   TRTABLE+C'&&'                  STOP AT '&'\n         DC    X'FF'\n         ORG\n*\nWKAREA   DSECT\n         DS    18F\nWKSYMBP  DS    CL(SYMBP_LEN)\n*\nRCODE    DS    F\n*\nINDATA   DS    CL(MAXLENG)\n*\nWKLENG   EQU   *-WKAREA\n         EJECT\n*\n         ASASYMBP\n         IRXEFPL\n         IRXEVALB\n         IRXARGTB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SAVE": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x984\\x9f\\x00\\x984\\x9f\\x088\\x00\\x9e\\x00\\x9e\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-12-15T00:00:00", "modifydate": "1998-12-15T08:38:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $SAVE    REXX/CLIST      *********************/\n /* $SAVE                                                            */\n /*    This exec will do update in place using data from the data    */\n /*    being edited.  This keeps a PDS from filling up due to        */\n /*    wasted space.  The restriction here is that the input and     */\n /*    output need to have the SAME NUMBER OF RECORDS.               */\n /*                                                                  */\n /*    Since this is update in place, the exec does require that     */\n /*    the number of lines (records) not being changed.  Obviously,  */\n /*    adding more lines is impossible.  Keeping the same number of  */\n /*    lines now will make it easier if further updates are needed   */\n /*    at a later time.                                              */\n /*                                                                  */\n /* SYNTAX: $SAVE                                                    */\n /*                                                                  */\n /* Author: Vinh Vu                                                  */\n /*    Chg -  11/6/97 - Newly written                                */\n /*                                                                  */\n /********************************************************************/\n\n\nParse Source . . MACRO_NAME .\n\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\n'ISREDIT MACRO'\nIf Rc \u00ac=0 Then Do\n   ZEDSMSG = ''\n   ZEDLMSG = MACRO_NAME||' can only run as an ISPF EDIT macro !!!'\n   'SETMSG MSG(ISRZ001)'\n   Exit\n   End\n\n'ISREDIT (MYDSN) = DATASET'\n\nIf DSN_NOGOOD(MYDSN) Then Exit\n\n'ISREDIT (MYMEM) = MEMBER'\n'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n'ISREDIT (ENDLINE) = LINENUM .ZLAST'\n'ISREDIT RECOVERY ON'\n'ISREDIT RESET'\n\nNUM_LINES = (ENDLINE-STRTLINE)+1\nDATANAME = \"'\"||MYDSN||\"(\"||MYMEM||\")'\"\nFILENAME = '##'||Random(1000,9999)||Random(10,99)\n\nAddress TSO \"ALLOC DA(\"||DATANAME||\") FILE(\"||FILENAME||\") SHR\"\nOLDLINE. = ''\n'NEWSTACK'\n\nAddress TSO 'EXECIO * DISKR' FILENAME '(STEM OLDLINE. FINIS'\n'DELSTACK'\nIf OLDLINE.0 \u00ac= NUM_LINES Then Do\n   ZEDSMSG = ''\n   ZEDLMSG = 'Number of records being written out is different than',\n             'what is out there.  Update-in-place IS NOT ALLOWED.',\n             'Number of old records='||OLDLINE.0||'. Number of new',\n             'records='||NUM_LINES||'.'\n   'SETMSG MSG(ISRZ001)'\n   Address TSO 'FREE FILE('FILENAME')'\n   Exit\n   End\n\nNEWLINE. = ''\nCNT = 0\nDo I=STRTLINE to ENDLINE\n   'ISREDIT (MYINPUT) = LINE' I\n   CNT = CNT + 1\n   NEWLINE.CNT = MYINPUT\n   End\n\nCNT = 0\n'NEWSTACK'\nNOT_THE_END = 1\nDo While NOT_THE_END\n   Address TSO 'EXECIO 1 DISKRU' FILENAME\n   TEMPRC = RC\n   If TEMPRC=2 Then NOT_THE_END = 0\n   Else Do\n      If TEMPRC \u00ac= 0 Then Do\n         ZEDSMSG = ''\n         ZEDLMSG = 'EXECIO Retcode='||TEMPRC||'.',\n                   'Partial data was written out ... process aborted.'\n         'SETMSG MSG(ISRZ001)'\n         Call CLOSE_FILE\n         Exit\n         End\n      Else Do\n         Pull\n         CNT = CNT + 1\n         Queue NEWLINE.CNT\n         Address TSO 'EXECIO 1 DISKW' FILENAME\n         End\n      End\n   End\n'DELSTACK'\n\nCall CLOSE_FILE\n\nZEDSMSG = ''\nZEDLMSG = MYMEM||\" has been successfully saved in \"||MYDSN||\". \",\n   \"Data being edited was updated in place.  However, the\",\n   \"the ISPF stat (i.e. LAST MODIFIED, ID, etc..) did not change and\",\n   \"therefore is no longer correct.\"\n\n'SETMSG MSG(ISRZ001)'\n'ISREDIT CANCEL'\n\nExit\n\n\nCLOSE_FILE:\nAddress TSO 'EXECIO 0 DISKW' FILENAME '(FINIS'\nAddress TSO 'FREE FILE('FILENAME')'\nReturn\n\n\nDSN_NOGOOD:\nArg CHECK_DSN\nCHECK_DSN =\"'\"||Strip(CHECK_DSN)||\"'\"\nX = LISTDSI(CHECK_DSN 'NODIRECTORY NORECALL')\nIf X=16 Then Do\n   If SYSREASON = 9 Then Do\n      ZEDSMSG = 'Data set migrated'\n      ZEDLMSG = ''\n      'SETMSG MSG(ISRZ001)'\n      Return 1\n      End\n   If SYSREASON = 5 Then Do\n      ZEDSMSG = 'Dataset not cataloged'\n      ZEDLMSG = ''\n      'SETMSG MSG(ISRZ001)'\n      Return 1\n      End\n   Else Do\n      ZEDSMSG = 'LISTDSI RC=16'\n      ZEDLMSG = 'LISTDSI error RC=16 - SYSREASON=' SYSREASON\n      'SETMSG MSG(ISRZ001)'\n      Return 1\n      End\n   End\nIf SYSRECFM = 'F' | SYSRECFM = 'FB' Then Nop\nElse Do\n   ZEDSMSG = ''\n   ZEDLMSG = 'Invalid RECFM as '||SYSRECFM||'.',\n             MACRO_NAME 'can only be used to process either F or FB.'\n   'SETMSG MSG(ISRZ001)'\n   Return 1\n   End\nIf SYSDSORG = 'PO' Then Return 0\nElse Do\n   ZEDSMSG = ''\n   ZEDLMSG = 'Invalid DSORG as '||SYSDSORG||'.',\n             MACRO_NAME 'can only be used to update a PDS member.'\n   'SETMSG MSG(ISRZ001)'\n   Return 1\n   End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SYMSUB": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00\\x10\\x01\\x052\\x0f\\x01 \\x07\\x1f\\x00'\\x00E\\x00+\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2005-11-16T00:00:00", "modifydate": "2020-03-11T00:27:10", "lines": 69, "newlines": 43, "modlines": 0, "user": "VINHVU"}, "text": "/* ----------------------- rexx ------------------------------- *\n * This Edit macro will take the data being edited and replace  *\n * the system symbolics with what's their values found in the   *\n * system.  External Rexx routine $RXSYMBL is called to         *\n * resolve/substitute the symbolics.                            *\n *                                                              *\n * Chg - VNV - 11/10/04 -  Added the first time.                *\n *       VNV - 01/24/01 -  Change to not update the member      *\n *                         unless UP(DATE) is used as parm when *\n *                         edit macro invoked.  Otherwise, new  *\n *                         data will appear as part of the      *\n *                         NOTELINE only (no update occurred).  *\n *                                                              *\n * ------------------------------------------------------------ */\n\nparse source . . macro_Name .\n\nif sysvar(SYSISPF) \u00ac='ACTIVE' then do\n   parse source . . exec_Name .\n   say macro_Name 'can only run under ISPF.'\n   exit\n   end\n\naddress ISPEXEC\n\n'CONTROL ERRORS RETURN'\n'ISREDIT MACRO (UPDATE)'\nIf rc \u00ac=0 then do\n   zedsmsg = macro_Name 'error'\n   zedlmsg = macro_Name 'can only be run as an ispf edit macro !!!'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\nupper update\n\nif ABBREV(update,'UP') > 0 then updateIt = 1\nelse updateIt = 0\n\n'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n'ISREDIT (ENDLINE) = LINENUM .ZLAST'\n'ISREDIT RESET'\n\nct = 0\n\ndo i=strtLine to endLine\n   'ISREDIT (TEMP) = LINE' i\n   newData = $RXSYMBL(LEFT(temp,72))\n   if newData \u00ac== LEFT(temp,72) then do\n      ct = ct + 1\n      if updateIt then do\n         'ISREDIT LINE' i '= (NEWDATA)'\n         'ISREDIT LINE_BEFORE' i '= NOTELINE (TEMP)'\n         end\n      else do\n         'ISREDIT LINE_AFTER' i '= NOTELINE (newData)'\n         end\n      end\n   end\n\nzedsmsg = ct 'of' endLine-strtLine 'lines changed.'\nzedlmsg = 'Total number of lines edited:' endLine-strtLine'.',\n          'Number of lines changed due to symbolic substitution:' ct,\n          '(if UPD was specified, otherwise, the data is unchanged). ',\n          'There is an NOTELINE above each line that was changed. To',\n          'find these lines, user LOC SPECIAL and/or LOC SPECIAL NEXT.'\n'SETMSG MSG(ISRZ000)'\n\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$SYSINFO": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00%\\x01\\x17\\x04\\x7f\\x01 \\x07/#(\\x04\\xcd\\x03\\xb6\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "2017-02-16T00:00:00", "modifydate": "2020-03-12T23:28:25", "lines": 1229, "newlines": 950, "modlines": 0, "user": "VINHVU"}, "text": "/*                                 REXX                             */\n/********************************************************************/\n/*                                                                  */\n/*         $$$$  SSSS Y   Y  SSSS  III  N   N FFFFF  OOO            */\n/*        $ $   S      Y Y  S       I   NN  N F     O   O           */\n/*         $$$   SSS    Y    SSS    I   N N N FFFF  O   O           */\n/*          $ $     S   Y       S   I   N  NN F     O   O           */\n/*        $$$$  SSSS    Y   SSSS   III  N   N F      OOO            */\n/*                                                                  */\n/********************************************************************/\n/*   Display System Information using ISPF panel.                   */\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*   Changes:                                                       */\n/*      02/16/17 - V1.00 - VNV - Added the first time.              */\n/*      07/12/17 - V2.00 - VNV - Added the DVOL (Bernie's version)  */\n/*                         to collect the Res volumes (M1-6) for    */\n/*                         display.                                 */\n/*      07/13/17 - V2.01 - VNV - Change to not display MAxxxx-MZxxxx*/\n/*                         vols (they were sorted and become the 1st*/\n/*                         volumes in the list).                    */\n/*      08/15/17 - V2.02 - VNV - Add call to IWMQVS to get the      */\n/*                         dynamic upgraded model number            */\n/*      08/22/17 - V2.03 - VNV - Add the Help screen (tutorial).    */\n/*      05/17/18 - V2.04 - VNV - Change to fix the Scroll amount.   */\n/*                         It never did work before.                */\n/*      08/08/18 - V2.05 - VNV - Change to swap display positions   */\n/*                         of Sysplex/Sysname.                      */\n/*      09/27/18 - V2.06 - VNV - Change to get the Host+Domain and  */\n/*                         then obtain the Hostid from there.       */\n/********************************************************************/\n/*                                                                  */\n\n$vers                  = \"v3.0\"      /* Version number                */\n\nparse source . . execName .\n\nif SYSVAR(\"SYSENV\") = \"BACK\" then do\n   say exec_Name 'can only run online.'\n   exit\n   end\nelse do\n   if SYSVAR(SYSISPF) <> \"ACTIVE\" then do       /* under READY mode */\n      parse UPPER arg allParms\n      queue \"ISPSTART CMD(\"execName allParms\") NEWAPPL(ISR)\"\n      exit\n      end\n   end\n\nnumeric digits 256\n\naddress ISPEXEC\nmainPanel              = \"$$CPUID$\"\nload_info = loadispf()\n\ncall Get_System_Data      /* goes thru MVS control blocks and\n                            collects data                    */\n\ndispRc = 0\ndo while dispRc = 0\n   call Get_Dynamic_Data         /* update dynamic data      */\n   \"DISPLAY PANEL(\"mainPanel\")\"\n   dispRc = rc\n   end\n\ndo until length(load_info) = 0\n   parse value load_info with dd libd load_info\n   if LEFT(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                          else lib = \"EXEC\"\n      address TSO,\n        \"ALTLIB DEACT APPLICATION(\"lib\")\"\n      end\n   else \"libdef\" libd\n   address TSO \"FREE F(\"dd\")\"\n   end\n\nexit\n\n/* ------------------------------------------------------------ *\n * Obtain z/OS data using either Control Block access or        *\n * MVSVAR function.  Also obtain values for all Static Symbols  *\n * i.e., &SYSRES, etc..  All values will be recorded in a       *\n * stem var.  For example, 'valueFor.SYSRES' will contain       *\n * the value for &SYSRES.  Other example: 'valueFor.SYSCLONE'   *\n * has the value for &SYSCLONE.  The & and ending '.' has been  *\n * removed so that theses variable names can be readily         *\n * available for use in Rexx.                                   *\n * ------------------------------------------------------------ */\n\n/* ------------------------------------------------------------ *\n * The following variables are available for Var substitution.  *\n * Remember that the JCL itself will not have variables         *\n * subtituted automatically.  The substitution is only done     *\n * on the 'Included' member (read the doc on how to use this).  *\n *                                                              *\n *     $csaSize - CSA size (in 'K')                             *\n *     $csaEsze - Extended CSA size (in 'K')                    *\n *     $ipladr  - IPL'ed Address                                *\n *     $ipladr$ - IPL'ed Address (after it has been TDMF'ed)    *\n *     $ipldt   - IPL'ed Date & Time                            *\n *     $iplvol  - IPL'ed Volser                                 *\n *     $jeslvl  - JES2 Level                                    *\n *     $jesnode - JES2 Nodename                                 *\n *     $load    - IPL Loadparm                                  *\n *     $load$   - IPL Loadparm (after it has been TDMF'ed)      *\n *     $lpar    - LPAR hardware name                            *\n *     $opsys   - Operating System Level                        *\n *     $ssmf    - SSMF version                                  *\n *     $sysid   - System Name                                   *\n *     $plex    - SYSPLEX name                                  *\n *     $pvtSize - Private Reg size (in 'K')                     *\n *     $pvtEsze - Extended Private Reg size (in 'K')            *\n *     $sqaSize - SQA size (in 'K')                             *\n *     $sqaEsze - Extended SQA size (in 'K')                    *\n *     smfid    - SMF id                                        *\n *                                                              *\n *     plus all static Symbolics, i.e. &SYSR0, &S1, &B1, etc.   *\n *                                                              *\n * ------------------------------------------------------------ */\n\nGet_System_Data:\n$opsys   = MVSVAR('SYSOPSYS')\n$sysid   = MVSVAR('SYSNAME')\nsmfid    = MVSVAR('SYSSMFID')\n$jeslvl  = SYSVAR('SYSJES')\n$jesnode = SYSVAR('SYSNODE')\n\ncvt      = Get_Stor('10'x)\necvt     = Get_Stor(cvt,'8C'x)\nasvt     = Get_Stor(cvt,'22C'x)\nmaxUser  = C2D(Get_Stor(asvt,'204'x))\nipa      = Get_Stor(ecvt,'188'x)\nsmca     = Get_Stor(cvt,'C4'x)\nucbadd   = Get_Stor(cvt,'30'x)\n$iplvol  = Get_Stor(ucbadd,'1C'x,6)\n$ipladr  = C2X(Get_Stor(ucbadd,4,2))\n$iplprm  = Get_Stor(ecvt,'A0'x,8)\n$cecnam  = Get_Stor(ecvt,'150'x,8)\n$lparnam = Get_Stor(ecvt,'158'x,8)\ncvtpre   = D2C(C2D(cvt)-40)\nfmids    = Get_Stor(cvtpre,'8'x,8)\n$ssmf    = Get_Stor(cvtpre,16,16)\n$ssmfLvl = SUBSTR($ssmf,5,LENGTH($ssmf)-4)\n$plex    = Get_Stor(ecvt,'8'x,8)\n$load    = Get_Stor(ecvt,'A0'x,8)\n$lpar    = Get_Stor(ecvt,344,8)\ncvtixavl = Get_Stor(cvt,'7C'x)\niociovtp = Get_Stor(cvtixavl,'D0'x)\ncssId    = C2X(Get_Stor(cvtixavl,'113'x,1))\ncda      = Get_Stor(iociovtp,'18'x)\n$shid    = Get_Stor(cvt,'42C'x,4)\n$cpumdl  = Get_Stor($shid,'1A'x,6)\".\"Get_Stor($shid,'20'x,3)\n\n/* --- Call IWMQVS  ------------------------------------------------- */\n\nQVS_totL   = 512\nQVS_len    = D2X(QVS_totL)\nQVS_len    = RIGHT(X2C(QVS_len),4,D2C(0))\nQVS_Out    = QVS_len||COPIES('00'X,QVS_totL-4)\n\naddress linkpgm 'IWMQVS QVS_Out'\n\nIf rc = 0 then do\n   cec_type   = SUBSTR(QVS_Out,9,4)\n   cec_model  = STRIP(SUBSTR(QVS_Out,13,16))\n   select\n      when cec_type = '2064' then cec_desc = '    z Series 900'\n      when cec_type = '2066' then cec_desc = '    z Series 800'\n      when cec_type = '2084' then cec_desc = '    z Series 990'\n      when cec_type = '2086' then cec_desc = '    z Series 890'\n      when cec_type = '2094' then cec_desc = '    System z9 EC'\n      when cec_type = '2096' then cec_desc = '    System z9 BC'\n      when cec_type = '2097' then cec_desc = '   System z10 EC'\n      when cec_type = '2098' then cec_desc = '   System z10 BC'\n      when cec_type = '2817' then cec_desc = ' zEnterprise 196'\n      when cec_type = '2818' then cec_desc = ' zEnterprise 114'\n      when cec_type = '2827' then cec_desc = 'zEnterprise EC12'\n      when cec_type = '2828' then cec_desc = 'zEnterprise BC12'\n      when cec_type = '2964' then cec_desc = '    z System z13'\n      when cec_type = '2965' then cec_desc = '   z System z13s'\n      when cec_type = '3906' then cec_desc = '    z System z14'\n      otherwise                   cec_desc = ' Unkwn CPU model'\n      end\n   if SUBSTR($cpumdl,8,3) <> cec_model then do\n      $cpumdl = $cpumdl\"(\"cec_model\")\"\n      end\n   end\n\n$cecDesc = CENTER(\" (\"STRIP(cec_desc)\") \",56,'.')\n$hwname  = STRIP(Get_Stor(ipa,'18'x,8))\niodfDsn  = STRIP(Get_Stor(cda,'20'x,44))\niodfDate = STRIP(Get_Stor(cda,156,8))\niodfTime = STRIP(Get_Stor(cda,164,8))\ncatDsn   = STRIP(Get_Stor(ipa,'EA'x,44))\ncatVol   = STRIP(Get_Stor(ipa,'E0'x,6))\n\nrmct     = Get_Stor(cvt,604)\niralcct  = Get_Stor(rmct,620)\ncct      = Get_Stor(rmct,4)\nrct      = Get_Stor(rmct,'E4'x)\n\nsvcUnt   = C2D(Get_Stor(rmct,64))\nsuSec    = STRIP(FORMAT((16000000/svcUnt),8,2))\n\niplti    = C2D(Get_Stor(smca,'150'x))%360000\nipltrm   = C2D(Get_Stor(smca,'150'x))//360000\nipltd    = RIGHT(ipltrm%6000,2,'0')               /* # of minutes */\n\niplt     = iplti||'.'||ipltd\nipld     = C2X(Get_Stor(smca,'154'x))\n\niplyear  = \"20\"||SUBSTR(ipld,3,2)||SUBSTR(ipld,5,3)\n$dayago  = $DATE(\"J2R\",\"20\"||date('J'))-$DATE(\"J2R\",iplyear)\n$saveAgo = $dayago\n$i       = $DATE(\"J2G\",iplyear)\n\nselect\n   when $dayago = 0 then $dayago = \"(IPLed today)\"\n   when $dayago = 1 then $dayago = \"(Yesterday)\"\n   otherwise             $dayago = \"(\"$dayago\" days ago)\"\n   end\n\n$ipldt   = SUBSTR($i,1,6)||SUBSTR($i,9,2) \"-\" iplt\ndrop iplti ipltrm ipltd iplt ipld iplyear $i\n\ncsd      = Get_Stor(cvt,'294'x)\nrcvt     = Get_Stor(cvt,'3E0'x)\npccavt   = Get_Stor(cvt,'2FC'x)\n\ngda      = Get_Stor(cvt,'230'x)\ngdpsIni  = Get_Stor(iociovtp,'10B'x,1)\ngdpsAct  = C2D(Get_Stor(iociovtp,'170'x,1))\n\nif gdpsIni = '00'x then do      /* not config with alternate schset */\n   gdpsAct = \" \"\n   gdpsIni = \" \"                /* No channel set used */\n   end\n\nif gdpsAct > 1 then do\n   gdpsAct = \" \"     /* APAR OA32339 not applied */\n   end\n\ngetInit    = SOCKET('INITIALIZE','TCPINFO',1)\nparse var getInit INIT_RC getSubTaskid getMaxDesc getService\nif INIT_RC = 1004 then do\n   tsab    = Get_Stor(ecvt,176)\n   tsablen = C2D(Get_Stor(tsab,4,2))\n   tsebnum = (tsablen-64)/128\n   do i=1 to tsebnum\n      tseb    = D2C(C2D(tsab)+64+(i-1)*128)\n      if Get_Stor(tseb) <> \"TSEB\" then leave\n      tcpasid = Get_Stor(tseb,56,2)\n      if C2X(tcpasid) <> 0 then do\n         stcName = Get_Stor(tseb,16,8)\n         getInit = SOCKET('INITIALIZE','TCPINFO',1,stcName)\n         parse var getInit INIT_RC getSubTaskid getMaxDesc getService\n         if INIT_RC = 0 then leave\n         end\n      end\n   end\n\nif INIT_RC =  0 then do\n   getHostid = SOCKET('GETHOSTID')\n   getHostNm = SOCKET('GETHOSTNAME')\n   getDomain = SOCKET('GETDOMAINNAME')\n   parse var getHostid tcpRc tcpAddr    /* this is the main IP */\n   parse var getHostNm tcpRc tcpName\n   parse var getDomain tcpRc tcpDomain\n   $fullDns  = STRIP(tcpName'.'tcpDomain)\n   getNewIP  = SOCKET('GETHOSTBYNAME',$fullDns)\n   parse var getNewIP  tcpRc $pingAdd\n   if WORD($pingAdd,1) = \"EHOSTNOTFOUND\" then $pingAdd = tcpAddr\n   getTerm   = SOCKET('TERMINATE')\n   end\nelse do\n   $fullDns = \"\"\n   $pingAdd = \"\"\n   end\n\n\nOnLinstg = STRIP(FormatNumber(C2D(Get_Stor(cvt,'358'x))/1024)||'M')\n\nsecDsn   = Get_Stor(rcvt,56,44)\nsecType  = Get_Stor(rcvt,,4)\n\nselect\n   when secType = 'RCVT' then secSoft = 'RACF'\n   when secType = 'RTSS' then secSoft = 'TopSecret'\n   otherwise secSoft = sectype\n   end\n\nonlCp   = C2D(Get_Stor(csd,212,4))\n\ntotalCp = 0\nzaapCp  = 0\nziipCp  = 0\nnextCp  = D2C(C2D(pccavt)-4)\n\ndo i=1 to 16\n   t = \"$sn\"||RIGHT(i,2,'0')\n   t = t \"= ''\"\n   interpret t\n   end\n\nactCnt = 1\n\ndo until totalcp = onlCp\n   nextCp = D2C(C2D(nextCp)+4)\n   pcca   = Get_Stor(nextCp)\n   if C2D(pcca) = 0 then iterate\n   pccaSer  = Get_Stor(pcca,4,12)\n   pccaVer  = Get_Stor(pcca,4,2)\n   pccaId   = RIGHT(C2D(Get_Stor(pcca,16,2)),2,'0')\n   pccaType = C2X(Get_Stor(pcca,'C'x))\n   pccaAttr = Get_Stor(pcca,376,1)\n   sn = pccaId\"-\"SUBSTR(pccaSer,3,6)\n   if BITAND(pccaAttr,'01'x) = '01'x then do\n      zaapCp = zaapCp + 1\n      sn = sn||\"_zAAp\"\n      end\n   if BITAND(pccaAttr,'04'x) = '04'x then do\n      ziipCp = ziipCp + 1\n      sn = sn||\"_zIIp\"\n      end\n   tempCnt = RIGHT(actCnt,2,'0')\n   t = \"$sn\"||tempCnt\n   t = t \"=\" \"'\"sn\"'\"\n   interpret t\n   actCnt  = actCnt  + 1\n   totalCp = totalCp + 1\n   end\n\nsymTable  = Get_Stor(ecvt,'128'x)\nnumSym    = C2D(Get_Stor(symTable,2,2))\nsymAddr   = D2C(C2D(symTable)+4)\nvalueFor. = ''\ndo i=1 to numSym\n   t = (i-1)*16\n   nextSym  = D2C(C2D(symAddr)+t)\n   s_off    = C2D(Get_Stor(nextSym,0,4))\n   s_leng   = C2D(Get_Stor(nextSym,4,4))\n   v_off    = C2D(Get_Stor(nextSym,8,4))\n   v_leng   = C2D(Get_Stor(nextSym,12,4))\n   mySym    = STRIP(Get_Stor(symAddr,s_off,s_leng))\n   mySym    = STRIP(STRIP(mySym,'L','&'),'T','.')\n   if v_leng > 0 then do\n      valueFor.mySym = Get_Stor(symAddr,v_off,v_leng)\n      end\n   else do\n      valueFor.mySym = ''\n      end\n   t = mySym||\"='\"valueFor.mySym\"'\"\n   interpret t\n   if mySym \u00ac= \"\" then do\n      address ISPEXEC \"VPUT (\"mySym\") SHARED\"\n      end\n   end\n\n/* ------------------------------------------------------------ *\n * Check the LOAD addr and LOADPARM to see if these UCBs have   *\n * been TDMF'ed.  If so, the new UCB will be reflected in the   *\n * two new vars: $ipladr$ and $load$ (the original vars were    *\n * $ipladr and $load, respectively).                            *\n * ------------------------------------------------------------ */\n\n$ipladr$ = $ipladr               /*  First set the $vars$ to be */\n$load$   = $load                 /*  the same as the original   */\n\n/* ------------------------------------------------------------ *\n * First check the $iplvol (it was derived from the recorded    *\n * IPL'ed UCB.  If it is not same as SYSR1, then the IPL vol    *\n * has been TDMF'ed.  Need to get the new UCB, and also set     *\n * $iplvol to SYSR1.                                            *\n * ------------------------------------------------------------ */\n\nif $iplvol \u00ac= sysr1 then do      /*  $iplvol came from ucb addr */\n   $iplvol  = sysr1              /*  and it is different - TDMF */\n   x = outtrap(\"trap.\",\"*\")\n   address TSO \"DVOL\" $iplvol\n   x = outtrap(\"off\")\n   do m=1 to trap.0\n      parse var trap.m p_var1 p_var2 .\n      if p_var1 = $iplvol then $ipladr$ = STRIP(p_var2)\n      end\n   end\n\n/* ------------------------------------------------------------ *\n * Now check the IODF dsname.  Get the UCB for its volume and   *\n * if the first 4 char of loadparm is not the same, i.e. the    *\n * IODF volume has been TDMF'ed, then fix the loadparm to       *\n * reflect the new UCB (again new value stored in $load$).      *\n * ------------------------------------------------------------ */\n\nt_iodfDsn = \"'\"iodfDsn\"'\"\nx = LISTDSI(t_iodfDsn 'DIRECTORY NORECALL')\nif x=0 | x=4  then do\n   x = outtrap(\"trap.\",\"*\")\n   address TSO \"DVOL\" sysvolume\n   x = outtrap(\"off\")\n   do m=1 to trap.0\n      parse var trap.m p_var1 p_var2 .\n      if p_var1 = sysvolume then do\n         $load$ = STRIP(RIGHT(p_var2,4,'0')||SUBSTR($load,5,4))\n         end\n      end\n   end\n\n/* ------------------------------------------------------------ *\n * This section of code just does a DVOL for M%xxxx to collect  *\n * the UCBs for all Mx volumes for the active res.  If DVOL     *\n * command is not available then the whole line is just set     *\n * to blank                                                     *\n * ------------------------------------------------------------ */\n\ntrap.0 = \"\"\n\nx = Call_Dvol(\"VIMVS\")\n\nvolCount = trap.0\n\n/* -------------------------------------------------- *\n * Now sort VOL data                                  *\n * -------------------------------------------------- */\n\n\nif trap.2 = trap.2 then trap.2 = \"\"\nif trap.3 = trap.3 then trap.3 = \"\"\nif trap.4 = trap.4 then trap.4 = \"\"\nif trap.5 = trap.5 then trap.5 = \"\"\nif trap.6 = trap.6 then trap.6 = \"\"\n\nallDone = 0\ndo until allDone = 1\n   allDone = 1\n   do i=1 to volCount-1\n      j=i+1\n      if trap.i > trap.j then do\n\n         tempData   = trap.J\n         trap.J     = trap.I\n         trap.I     = tempData\n\n         allDone  = 0\n         end                  /* if trap.i     */\n      end                     /* do i=1      */\n   end                        /* do until    */\n/* ------------------------------------------------------ *\n * SORT ends                                              *\n * ------------------------------------------------------ */\n\nj = 0\n\ndo i=1 to volCount\n  fndVol    = LEFT(WORD(trap.i,1),6)\n  fndAddr   = LEFT(WORD(trap.i,2),4)\n  j = j + 1\n  trap.j    = fndVol||\"-\"||fndAddr\n  end\n\nallVols = trap.1 \"\" trap.2 \"\" trap.3 \"\" trap.4 \"\" trap.5 \"\" trap.6\n\nreturn 0\n\n\n/* ------------------------------------------------------------ *\n * Issue DVOL command and trap output                           *\n * ------------------------------------------------------------ */\n\nCall_Dvol:\narg Cvol .\naddress ispexec\nx = outtrap(\"trap.\",\"*\")\n\"SELECT CMD(DVOL\" Cvol\" NOHEAD) NEWAPPL(ISR) PASSLIB NEST\"\nx = outtrap(\"off\")\nreturn 0\n\n\nGet_Dynamic_Data:\n\n\ncsaSize  = Get_Stor(gda,'70'x)\ncsaEsze  = Get_Stor(gda,'80'x)\nsqaSize  = Get_Stor(gda,'94'x)\nsqaEsze  = Get_Stor(gda,'9C'x)\nprvSize  = Get_Stor(gda,'A4'x)\nprvEsze  = Get_Stor(gda,'AC'x)\n\n$csaSize = FormatNumber(C2D(csaSize)/1024)\n$csaEsze = FormatNumber(C2D(csaEsze)/1024)\n$sqaSize = FormatNumber(C2D(sqaSize)/1024)\n$sqaEsze = FormatNumber(C2D(sqaEsze)/1024)\n$pvtSize = FormatNumber(C2D(prvSize)/1024)\n$pvtEsze = FormatNumber(C2D(prvEsze)/1024)\n\nrealCpu  = C2D(Get_Stor(cct,102,2))\ncputil   = realCpu||'%'\n\ndots#    = 26                  /* length of the CPU Bar field */\ntmpLeng  = realCpu%(100/26)    /* represent BUSY dots         */\ncpubar   = CENTER(cputil,tmpLeng,'-')\n\nif realCpu < 85  then do\n   cpubar  = LEFT(cpubar,tmpLeng)||COPIES('-',dots#-tmpLeng)\n   cpumask = COPIES('56'x,tmpLeng)||COPIES('55'x,dots#-tmpLeng)\n   end\nelse if realCpu < 98  then do\n   cpubar  = LEFT(cpubar,tmpLeng)||COPIES('-',dots#-tmpLeng)\n   cpumask = COPIES('57'x,tmpLeng)||COPIES('55'x,dots#-tmpLeng)\n   end\nelse do\n   tmpLeng = (realCpu-100)%3.33\n   cpubar  = LEFT(cpubar,dots#)||COPIES('-',tmpLeng)\n   cpumask = COPIES('58'x,dots#)||COPIES('55'x,tmpLeng)\n   end\n\navgCpu   = FORMAT(C2D(Get_Stor(rct,'38'x,2))/16,3,0)||\"%\"\n\ntsoCnt   = 0\nstcCnt   = 0\nbatCnt   = 0\n\nasvt     = Get_Stor(cvt,'22C'x)\nmaxUser  = C2D(Get_Stor(asvt,'204'x))\noffSet   = 0+C2D('20C'x)            /* first ASCB entry  */\n\ndo maxUser\n   ascb    = Get_Stor(asvt,offSet)\n   offSet  = offSet+4\n   if BITAND(SUBSTR(ASCB,1,1),'80'x) = '80'x then iterate\n   if C2D(ascb) = 0 then iterate\n   if Get_Stor(ascb,0,4) \u00ac= \"ASCB\" then iterate\n\n   jobni = Get_Stor(ASCB,172)\n   jobns = Get_Stor(ASCB,176)\n\n/*say Get_Stor(jobns,,8) Get_Stor(jobni,,8)  C2D(Get_Stor(ascb,'3C'x))*/\n\n   if C2D(jobni) = 0 & C2D(jobns) = 0 then iterate\n\n   if C2D(jobni) <> 0 then do\n      batCnt = batCnt + 1\n      end\n   else do\n      if C2D(Get_Stor(ascb,'3C'x)) = 0 then do\n         if Get_Stor(jobns,,8) = \"INIT\" then nop\n         else do\n            stcCnt = stcCnt + 1\n            end\n         end\n      else do\n         tsoCnt = tsoCnt + 1\n         end\n      end\n   end\n\nreturn 0\n\n/* ------------------------------------------------------------ *\n * This procedure format a number with ','.                     *\n * ------------------------------------------------------------ */\n\nFormatNumber: procedure\n   parse value arg(1) with whole \".\" decs\n\n   formattedNumber = STRIP(REVERSE(TRANSLATE( \"abc,def,ghi,jkl,mno\",,\n                                   REVERSE(whole),,\n                                   \"abcdefghijklmno\",\",\")),\"L\",\",\")\n\n  if decs <> \"\" then\n     formattedNumber = formattedNumber || \".\" || decs\nreturn formattedNumber\n\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nGet_Stor: procedure\n\nparse arg area,offset,leng\n\nif ARG(2,'O') then offset=0\n\nif ARG(3,'O') then leng=4\n\nif DATATYPE(area) = 'CHAR' then do\n   area =  C2D(area)\n   End\n\nif DATATYPE(offset) = 'CHAR' then do\n   offset =  C2D(offset)\n   End\n\nreturn  STORAGE((D2X(area+offset)),leng)\n\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This REXX exec will do date conversion:                     */\n/*                                                                  */\n/*      call Format:  DATE = $DATE(CODE,INPUT)                      */\n/*                                                                  */\n/*          CODE = 'J2G' - Julian to Gregorian date                 */\n/*          CODE = 'G2J' - Gregorian date to Julian                 */\n/*          CODE = 'J2R' - Julian to Relative date                  */\n/*          CODE = 'R2J' - Relative to Julian date                  */\n/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */\n/*                                                                  */\n/*          INPUT = either 'mm/dd/YYYY' or 'YYYYDDD' or 'nnnn'      */\n/*                                                                  */\n/*      Errors during processing will return 0 as result and        */\n/*      an error message will be displayed as well.                 */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n$DATE: procedure\n\nparse Upper arg func,date\n\nif date = '' then retDate = 0\nelse select\n      when func = 'J2G' then retDate = J2G_PROC(date)\n      when func = 'G2J' then retDate = G2J_PROC(date)\n      when func = 'J2R' then retDate = J2R_PROC(date)\n      when func = 'R2J' then retDate = R2J_PROC(date)\n      when func = 'R2D' then retDate = R2D_PROC(date)\n      otherwise do\n         say 'DT999E - Invalid function code as' func\n         retDate = 0\n         end\n   end\n\nreturn retDate\n\n\n\nJ2G_PROC: procedure\n\nparse arg julDate\n\ncall VALIDATE_JULIAN\nif RESULT = 0 then gDate = 0\nelse do\n   julianYYYY  = SUBSTR(julDate,1,4)\n   julianDDD   = SUBSTR(julDate,5,3)\n   mo.1  = 31\n   mo.2  = 28\n   mo.3  = 31\n   mo.4  = 30\n   mo.5  = 31\n   mo.6  = 30\n   mo.7  = 31\n   mo.8  = 31\n   mo.9  = 30\n   mo.10 = 31\n   mo.11 = 30\n   mo.12 = 31\n   if LEAP_YEAR(julianYYYY) then mo.2 = 29\n   do I=1 to 12 while julianDDD > mo.I\n      julianDDD = julianDDD - mo.I\n      end\n   mm   = RIGHT(I,2,'0')\n   dd   = RIGHT(julianDDD,2,'0')\n   gDate = mm||'/'||dd||'/'||julianYYYY\n   end\n\nreturn gDate\n\n\nG2J_PROC: procedure\n\nparse arg gregDate\nparse var gregDate mm '/' dd '/' YYYY\nJ_DATE = 0\n\nif DATATYPE(mm)   \u00ac= 'NUM' | ,\n   DATATYPE(dd)   \u00ac= 'NUM' | ,\n   DATATYPE(YYYY) \u00ac= 'NUM' | ,\n   dd > 31                 | ,\n   mm < 1                  | ,\n   mm > 12                 | ,\n   YYYY > 9999          then ,\n      say 'DT001E - Invalid Gregorian date as' gregDate\nelse do\n   mo.1  = 31\n   mo.2  = 28\n   mo.3  = 31\n   mo.4  = 30\n   mo.5  = 31\n   mo.6  = 30\n   mo.7  = 31\n   mo.8  = 31\n   mo.9  = 30\n   mo.10 = 31\n   mo.11 = 30\n   mo.12 = 31\n   if LEAP_YEAR(YYYY) then mo.2 = 29\n   mm = STRIP(mm,'L','0')\n   if (dd > VALUE(mo.mm)) then ,\n       say 'DT002E - Out-of-range date as' gregDate\n   else do\n      jAccumDay = 0\n      if mm > 1 then do I=1 to (mm-1)\n         jAccumDay = jAccumDay + mo.I\n         end\n      jAccumDay = jAccumDay + dd\n      J_DATE      = YYYY||RIGHT(jAccumDay,3,'0')\n      end\n   end\n\nreturn J_DATE\n\n\n\n\nJ2R_PROC: procedure\n\nparse arg julDate\n\ncall VALIDATE_JULIAN\nif RESULT = 1 then relDate = ((julianYYYY-1) * 365) + ,\n                            ((julianYYYY-1) % 4) - ,\n                            ((julianYYYY-1) % 100) + ,\n                            ((julianYYYY-1) % 400) + (julianDDD)\n   else relDate = 0\nreturn relDate\n\n\n\nR2J_PROC: procedure\nparse arg REL_DATE\nRETURNED_J = 0\n\nif DATATYPE(REL_DATE) \u00ac= 'NUM' then ,\n   say 'DT006E - Relative date non-numeric as' REL_DATE\nelse do\n   if REL_DATE > 3652424 then ,\n      say 'DT007E - Relative date out-of-range as' REL_DATE\n   else do\n      temp_YYYY = (REL_DATE % 366) + 1\n      temp_REL = J2R_PROC(RIGHT(temp_YYYY,4,'0')||'000')\n      do while (REL_DATE - temp_REL) > 0\n         if LEAP_YEAR(temp_YYYY) then LEFT_OVER = 366\n         else LEFT_OVER = 365\n         if LEFT_OVER < (REL_DATE - temp_REL) then do\n            temp_REL  = temp_REL  + LEFT_OVER\n            temp_YYYY = temp_YYYY + 1\n            end\n         else do\n            temp_DDD = (REL_DATE - temp_REL)\n            leave\n            end\n         end\n      RETURNED_J =  RIGHT(temp_YYYY,4,'0')||RIGHT(temp_DDD,3,'0')\n   end\nend\n\nreturn RETURNED_J\n\n\nR2D_PROC: procedure\nparse arg REL_DATE\nRETURNED_DAY = 0\nif DATATYPE(REL_DATE) \u00ac= 'NUM' then ,\n   say 'DT006E - Relative date non-numeric as' REL_DATE\nelse do\n   if REL_DATE > 3652424 then ,\n      say 'DT007E - Relative date out-of-range as' REL_DATE\n   else do\n      DAY_INDEX = (REL_DATE // 7)+1\n      RETURNED_DAY  = WORD('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)\n   end\nend\n\nreturn RETURNED_DAY\n\n\n\n\n\nVALIDATE_JULIAN:\n\nVALID_DATE = 0\n\nif LENGTH(julDate) \u00ac=7 | DATATYPE(julDate) \u00ac= 'NUM' then\n   say 'DT003E - Date too short/long or non-numeric as' julDate\nelse do\n   julianYYYY = SUBSTR(julDate,1,4)\n   julianDDD   = SUBSTR(julDate,5,3)\n   if (julianDDD > 366) then ,\n      say 'DT004E - Number of day > 366 as' julianDDD\n   else if (LEAP_YEAR(julianYYYY) = 0) & (julianDDD = 366) then ,\n          say 'DT005E - Invalid days for a non-leap year as' julianYYYY\n        else if (julianYYYY < 1) then ,\n           say 'DT008E - Invalid year as' julianYYYY\n           else VALID_DATE = 1\n   end\nreturn VALID_DATE\n\n\n\nLEAP_YEAR: procedure\nparse arg YEAR_CHECKED\n\nif (YEAR_CHECKED // 100) = 0 then ,\n   if (YEAR_CHECKED // 400) = 0 then LEAP_YEAR_FLAG = 1\n   else LEAP_YEAR_FLAG = 0\nelse if (YEAR_CHECKED // 4) = 0 then LEAP_YEAR_FLAG = 1\n   else LEAP_YEAR_FLAG = 0\n\nreturn LEAP_YEAR_FLAG\n\n\n\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n * ---------------------------------------------------------- */\n LoadISPF: procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * /*>START - start of inline data                         *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END*/   - end of all inline data (optional if last)    *\n * ------------------------------------------------------- */\n last_line = SOURCELINE()\n do i = last_line to 1 by -1\n    line = SOURCELINE(i)\n    if TRANSLATE(LEFT(line,9)) = \"/*>START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = SOURCELINE(j)\n    if TRANSLATE(LEFT(line,7)) = \">END*/ \" then leave\n    if TRANSLATE(LEFT(line,7)) = \">CLIST \" then kclist = 1\n    if TRANSLATE(LEFT(line,6)) = \">EXEC \"  then kexec  = 1\n    if TRANSLATE(LEFT(line,5)) = \">MSG \"   then kmsg   = 1\n    if TRANSLATE(LEFT(line,7)) = \">PANEL \" then kpanel = 1\n    if TRANSLATE(LEFT(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n address ISPEXEC\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\"$##\"\n execDD  = \"le\"random(999)\"$##\"\n msgDD   = \"lm\"random(999)\"$##\"\n panelDD = \"lp\"random(999)\"$##\"\n skelDD  = \"ls\"random(999)\"$##\"\n\n/* ---------------------------------------- *\n *  LMINIT and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call Alloc_DD clistDD\n    \"LMINIT DATAID(CLIST) DDNAME(\"clistDD\")\"\n    \"LMOPEN DATAID(\"clist\") OPTION(OUTPUT)\"\n    returns = STRIP(returns clistDD ALTLIBC)\n    end\n if kexec <> null then do\n    call Alloc_DD execDD\n    \"LMINIT DATAID(EXEC) DDNAME(\"execDD\")\"\n    \"LMOPEN DATAID(\"exec\") OPTION(OUTPUT)\"\n    returns = STRIP(returns execDD ALTLIBE)\n    end\n if kmsg <> null then do\n    call Alloc_DD msgDD\n    \"LMINIT DATAID(MSG) DDNAME(\"msgDD\")\"\n    \"LMOPEN DATAID(\"msg\") OPTION(OUTPUT)\"\n    returns = STRIP(returns msgDD ISPMLIB)\n    end\n if kpanel <> null then do\n    call Alloc_DD panelDD\n    \"LMINIT DATAID(PANEL) DDNAME(\"panelDD\")\"\n    \"LMOPEN DATAID(\"panel\") OPTION(OUTPUT)\"\n    returns = STRIP(returns panelDD ISPPLIB)\n    end\n if kskel <> null then do\n    call Alloc_DD skelDD\n    \"LMINIT DATAID(SKEL) DDNAME(\"skelDD\")\"\n    \"LMOPEN DATAID(\"skel\") OPTION(OUTPUT)\"\n    returns = STRIP(returns skelDD ISPSLIB)\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = TRANSLATE(record)\n    if LEFT(recordu,5) = \">END \" then leave\n    if LEFT(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if LEFT(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if LEFT(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if LEFT(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if LEFT(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LMPUT DATAID(\"clist\") MODE(INVAR)\" ,\n                 \"DATALOC(RECORD) DATALEN(80)\"\n      When type = \"Exec\" then\n           \"LMPUT DATAID(\"exec\") MODE(INVAR)\" ,\n                 \"DATALOC(RECORD) DATALEN(80)\"\n      When type = \"Msg\" then\n           \"LMPUT DATAID(\"msg\") MODE(INVAR)\" ,\n                 \"DATALOC(RECORD) DATALEN(80)\"\n      When type = \"Panel\" then\n           \"LMPUT DATAID(\"panel\") MODE(INVAR)\" ,\n                 \"DATALOC(RECORD) DATALEN(80)\"\n      When type = \"Skel\" then\n           \"LMPUT DATAID(\"skel\") MODE(INVAR)\" ,\n                 \"DATALOC(RECORD) DATALEN(80)\"\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"ALTLIB ACT APPLICATION(CLIST) FILE(\"clistDD\")\"\n    \"LMFREE DATAID(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"ALTLIB ACT APPLICATION(EXEC) FILE(\"execDD\")\"\n    \"LMFREE DATAID(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LMFREE DATAID(\"msg\")\"\n    \"LIBDEF ISPMLIB LIBRARY ID(\"msgDD\") STACK\"\n    end\n if kpanel <> null then do\n    \"LIBDEF ISPPLIB LIBRARY ID(\"panelDD\") STACK\"\n    \"LMFREE DATAID(\"panel\")\"\n    end\n if kskel <> null then do\n    \"LIBDEF ISPSLIB LIBRARY ID(\"skelDD\") STACK\"\n    \"LMFREE DATAID(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n if type = \"Clist\" then\n    \"LMMADD DATAID(\"clist\") MEMBER(\"name\")\"\n if type = \"Exec\" then\n    \"LMMADD DATAID(\"exec\") MEMBER(\"name\")\"\n if type = \"Msg\" then\n    \"LMMADD DATAID(\"msg\") MEMBER(\"name\")\"\n if type = \"Panel\" then\n    \"LMMADD DATAID(\"panel\") MEMBER(\"name\")\"\n if type = \"Skel\" then\n    \"LMMADD DATAID(\"skel\") MEMBER(\"name\")\"\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n address TSO\n if pos(LEFT(dd,2),\"lc le\") > 0 then\n \"ALLOC F(\"dd\") UNIT(SYSALLDA) SPA(5,5) CYL DIR(10)\",\n    \"RECFM(F B) LRECL(80) BLKSIZE(6160)\"\n else\n \"ALLOC F(\"dd\") UNIT(SYSALLDA) SPA(5,5) CYL DIR(10)\",\n    \"RECFM(F B) LRECL(80) BLKSIZE(23440)\"\n return\n\n/* -------------------------------------------------------------------- *\n * Beginning of ISPF members to be built dynamically                    *\n * -------------------------------------------------------------------- */\n\n/*>START\n>Panel $$CPUID$\n)ATTR\n [ AREA(DYNAMIC)\n \\ AREA(SCRL) EXTEND(OFF)\n % TYPE(TEXT)   CAPS(OFF)\n # TYPE(OUTPUT) CAPS(ON)   COLOR(RED)\n | TYPE(INPUT)  CAPS(OFF)   COLOR(RED) HILITE(USCORE)\n + TYPE(TEXT)   INTENS(LOW)   CAPS(OFF)  COLOR(WHITE) SKIP(ON)\n ~ TYPE(TEXT)   CAPS(OFF)  COLOR(BLUE) SKIP(ON)\n ] TYPE(OUTPUT)             CAPS(OFF)  COLOR(TURQ) HILITE(REVERSE)\n \u00a6 TYPE(OUTPUT) CAPS(OFF)  COLOR(BLUE) HILITE(REVERSE) JUST(RIGHT)\n ! TYPE(TEXT)   CAPS(OFF)  COLOR(YELLOW)\n @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  COLOR(TURQ)\n } TYPE(TEXT)   JUST(LEFT)  CAPS(OFF)  COLOR(TURQ)\n \u00a2 TYPE(OUTPUT) JUST(RIGHT) CAPS(OFF)  COLOR(TURQ)\n ^ TYPE(OUTPUT) JUST(LEFT)  CAPS(OFF)  COLOR(RED)\n \u00ac TYPE(TEXT)   CAPS(OFF)  COLOR(GREEN)\n \" TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)\n { TYPE(OUTPUT) CAPS(OFF) JUST(RIGHT) COLOR(YELLOW)\n55 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(WHITE)  HILITE(REVERSE)\n56 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(GREEN)  HILITE(REVERSE)\n57 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(YELLOW) HILITE(REVERSE)\n58 TYPE(CHAR)   JUST(ASIS)  CAPS(OFF)  COLOR(RED)    HILITE(REVERSE)\n)BODY EXPAND(``)\n@ZDATESTD   %-`-`\"SYSTEM Information%`-`@ZTIMEL     +\n+Cmd input%===> |ZCMD                                     +Scroll%===>_ZSCROLLD+\n\\DSAREA                                                                        \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n\\                                                                              \\\n+` `}Press\"ENTER}to refresh CPU Util or\"END}to exit+` `\n)AREA DSAREA DEPTH(20)\n+\u00acSysname: ]z   +           \u00acSysplex: @$PLEX     \u00acIPLvol: @Z     }/@Z       +\n\u00acEyecatch: @$SSMF           \u00acJESnode: @$JESNODE\u00acLoadParm: @$LOAD         +\n+  \u00acOPsys: @$OPSYS                              \u00acIPLtime: @$IPLDT              +\n{$CECDESC                                                \u00ac@$dayago             +\n+\u00acCECname: ^$cecnam   \u00acLPARname: ^$lparnam\u00ac       SMF Id: ^smfid               +\n+\u00acTotalCP: ^totalCp    \u00acZip/Zap: ^z \u00ac/+^z +   \u00acCPU model: ^$cpumdl             +\n+\u00ac   IODF: ^iodfDsn                             \u00acHost IP: ^$pingadd            +\n\u00acIODFDate: ^iodfDate\u00ac-^iodfTime +                                              +\n+\u00acSecType: @secSoft        \u00ac Sec DSN: @secDsn                                  +\n+\u00acMstrCat: @catdsn                            \u00acCatlg Vol: @catvol+             +\n\u00ac ^allVols                                                                     +\n~`.`+Online Storage:{OnLinstg  ~`.`\n+\u00acPrivate: {$pvtSize   +(K)\u00ac  Priv/E: {$pvtEsze   +(K)    \u00acActive CSS: @cssId  +\n+\u00ac    CSA: {$csaSize   +(K)\u00ac   CSA/E: {$csaEsze   +(K)    \u00ac    Schset: @gdpsAct+\n+\u00ac    SQA: {$sqaSize   +(K)\u00ac   SQA/E: {$sqaEsze   +(K)\n+ Sym:\u00acJESSSN  \u00ac:^JESSSN  \u00ac SVTSC   :^SVTSC   \u00acUNIXVER :^UNIXVER \u00ac         +\n+     \u00acVENDOR  \u00ac:^VENDOR  \u00ac VTAMLST :^VTAMLST \u00ac     ---- CPU Utilization~-----\n~.....+Su/Sec {susec   ~.......+SRM Avg CPU \u00a6Z   ~  [CPUBAR,CPUMASK            [\n\u00ac CPU S/N: @$sn01           @$sn02          +     \u00acBat:^Z   \u00acTso:^Z   \u00acStc:^Z  +\n+          @$sn03           @$sn04          +                                  +\n+          @$sn05           @$sn06          +                                  +\n+          @$sn07           @$sn08          +                                  +\n+          @$sn09           @$sn10          +                                  +\n+          @$sn11           @$sn12          +                                  +\n+          @$sn13           @$sn14          +                                  +\n+          @$sn15           @$sn16          +                                  +\n}\n+`.`{$VERS\n)INIT\n   .ZVARS = '($SYSID $IPLVOL $IPLADR$ ZIIPCP ZAAPCP +\n              AVGCPU BATCNT TSOCNT STCCNT)'\n   .HELP  = $INF$H01\n   &$DEL1ST = N\n   IF  (&ZSCROLLD = '')\n        &ZSCROLLD = 'CURSOR'\n)REINIT\n   &$SEL = ''\n)PROC\n   &SCRAMT = TRUNC (&ZSCROLLD,1)\n   IF  (&SCRAMT   = C)\n        &ZSCROLLD = 'CURSOR'\n   IF  (&SCRAMT   = P)\n        &ZSCROLLD = 'PAGE'\n   IF  (&SCRAMT   = H)\n        &ZSCROLLD = 'HALF'\n)END\n>Panel $INF$H01\n)ATTR DEFAULT(%+!)\n   ! TYPE(NEF) PAD(USER) CAPS(ON)\n   \" TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(YELLOW)\n   + TYPE(NT)\n   { TYPE(TEXT)   CAPS(OFF)                  COLOR(TURQ)\n   } TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(TURQ)\n   \u00a2 TYPE(OUTPUT) CAPS(OFF)                  COLOR(RED)\n   \u00ac TYPE(TEXT)   CAPS(OFF)                  COLOR(WHITE)\n   | TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(WHITE)\n   \\ TYPE(TEXT)   CAPS(OFF)  HILITE(REVERSE) COLOR(RED)\n   _ TYPE(TEXT)   CAPS(OFF)                  COLOR(YELLOW)\n   # AREA(SCRL) EXTEND(ON)\n)BODY\n%Tutorial -----------------\"SYSTEM Information Display%---------------- Tutorial\n%Command ===>!ZCMD                                                             +\n+\n+       }NOTE - use PF10 and PF11 to page up and down (ISPF tutorial)+\n+\n#SAREA                                                                         #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n#                                                                              #\n+\n)AREA SAREA\n+   This is a general system information display. In addition to the static\n information, some data will get refreshed as you press Enter.  That includes\n CPU utilization as RMF sees it, along with the total number of Bat/TSU/STC\n address spaces at the time. CPU utilization is presented as ISPF dynamic data,\n using different color based on the percentage, of which,\\RED+color denotes\\98+\n percent-plus utilization, while\"YELLOW+means\"85+percent-plus, etc..\n\n    The{SRM Avg CPU+is what RMF used internally, which, in the past, was used to\n influence the\u00ac'old'+SRM algorithm in making\u00ac'swapping'+decision. Even with WLM,\n I do believe that some of this data is still used as part of the internal\n adjustment for workloads.\n\n    Some other interesting information includes: CPU model. Most of the time,\n a machine was dynamically upgraded after the initial Power-on Reset. The Base\n CPU model will become a different number, in which case, the model will be\n listed inside the parentheses. This model normally shows up as part of the\n\u00acD M=CPU+command under\u00acCPC SI+information.  The Machine type is listed on a\n seperate line, i.e. z13 vs z14 or EC12, etc..\n\n    The total number of CP includes all zIIP/zAAp engines, and the next field\n will display how many of these zIIp/zAAp engines were there. The serial\n numbers displayed in a scrollable area below will indicate which engine(s)\n being the special one(s).\n\n    In addition, there is a line showing the Volser/UCBs for the active volumes\n res volumes (up to 6).\n\n    A list of the most frequently referrenced symbolics is also listed.\n\n    Everything else should be self-explanatory.\n\n\u00ac------------------------------- End Of Tutorial ------------------------------+\n\n)END\n>END*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SYSPRM": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x01\\x171\\x7f\\x01 \\x07\\x1f\\x00&\\x04\\x80\\x04i\\x00\\x00\\xe5\\xc9\\xd5\\xc8\\xe5\\xe4@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-11-13T00:00:00", "modifydate": "2020-03-11T00:26:52", "lines": 1152, "newlines": 1129, "modlines": 0, "user": "VINHVU"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$VSAMIDX": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x94&?\\x00\\x94&O\\x10\\x10\\x00\\x90\\x006\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1994-09-20T00:00:00", "modifydate": "1994-09-21T10:10:00", "lines": 144, "newlines": 54, "modlines": 0, "user": "$VNV"}, "text": "/**************************** REXX ********************************/\n/*                                                                */\n/*   REXX exec to calculate the index buffer spefication for      */\n/*   a VSAM data set to make sure that all index records for      */\n/*   that VSAM data set will be in memory all the time (random    */\n/*   access).  For sequential access, specifying a lot of index   */\n/*   buffers will not help.                                       */\n/*                                                                */\n/**************************** REXX ********************************/\n\nIf SYSVAR(SYSISPF) = 'NOT ACTIVE' Then Do\n   Say 'ISPF is required to run this EXEC'\n   Exit\n   End\n\nArg DSN\nIf DSN = '' Then Do Until DSN \u00ac= ''\n   Say 'DSName missing - Enter DSNAME !!'\n   Pull DSN\n   End\nUpper DSN\n\nMESSAGE = SYSDSN(DSN)\nIf MESSAGE \u00ac= 'OK' Then Do\n   Say MESSAGE\n   Exit\n   End\n\nRECFM = LISTDSI(DSN)\n\nSelect\n   When SYSREASON = 12 | SYSREASON = 0 Then NOP      /* VSAM  */\n   When SYSREASON = 5 Then Do\n      Say DSN 'is not cataloged'\n      Exit\n      End\n   Otherwise Do\n      Say 'Error obtaining DSNAME information. LISTDSI Rc =' SYSREASON\n      Exit\n      End\n   End                      /* Select */\n\n\nIf SYSDSORG \u00ac= 'VS' Then Do\n   Say DSN 'is not VSAM'\n   Exit\n   End\n\n/******************************************************************/\n/*  Now collect VSAM information using 'LISTC ENT(DSN) ALL'       */\n/******************************************************************/\n\nX = OUTTRAP('O.')\n'LISTC ENT('DSN') ALL'\nX = OUTTRAP('OFF')\n\nSelect\n   When Pos('NONVSAM --',O.1) \u00ac= 0 Then Do\n      Say DSN 'Is not VSAM'\n      Exit\n      End\n   When Pos('CLUSTER -',O.1) = 0   Then Do\n      Say DSN 'Is not a VSAM Cluster'\n      Exit\n      End\n   Otherwise Nop\n   End                      /* Select */\n\n\n\nIf Pos('INDEX---',O.9) = 0 Then Do\n   Say DSN 'does not contain an INDEX'\n   Exit\n   End\n\n/******************************************************************/\n/*     Look for DATA CISIZE, CI/CA data (DATA section)            */\n/******************************************************************/\n\nDo I=8 to O.0\n   If Pos('DATA -',O.I) = 4 Then Do              /* Found DATA */\n      I = I+9\n      Call VERIFY 'CISIZE' Substr(O.I,95,6)\n      DCISIZE = Strip(Substr(O.I,114,5),,'-')\n      I = I+1\n      Call VERIFY 'CI/CA' Substr(O.I,95,5)\n      CIPERCA = Strip(Substr(O.I,114,5),,'-')\n      Leave\n      End\n   End                      /* Do */\n\n/******************************************************************/\n/*     Look for Data HI-USED-RBA (DATA section)                   */\n/******************************************************************/\n\nDo I=I to O.0\n   If Pos('ALLOCATION',O.I) = 6 Then Do\n      I = I+2\n      Call VERIFY 'HI-USED-RBA' Substr(O.I,37,11)\n      HIURBA = Strip(Substr(O.I,48,13),,'-')\n      Leave\n      End\n   End                      /* Do */\n\n\n/******************************************************************/\n/*     Look for index CISIZE and TOTAL REC                        */\n/******************************************************************/\n\nDo I=I to O.0\n   If Pos('INDEX -',O.I) = 4 Then Do\n      I = I+9\n      Call VERIFY 'CISIZE' Substr(O.I,95,6)\n      ICISIZE = Strip(Substr(O.I,114,5),,'-')\n      Leave\n      End\n   End                      /* Do */\n\nDo I=I to O.0\n   If Pos('STATISTICS',O.I) = 6 Then Do\n      I = I+1\n      Call VERIFY 'REC-TOTAL' Substr(O.I,8,9)\n      TREC   = Strip(Substr(O.I,17,15),,'-')\n      Leave\n      End\n   End                      /* Do */\n\nCASIZE = DCISIZE*CIPERCA\nIDXSET = TREC - (HIURBA%CASIZE)\nSTRNO =  10\nIBUFNO = STRNO + IDXSET\nBATCH  = 1 + IDXSET\n\nAddress ISPEXEC 'DISPLAY PANEL($VSIDX01)'\nExit\n\nVERIFY:\nArg CONSTANT VERDATA\nIf VERDATA \u00ac= CONSTANT Then Do\n   Say 'Data verification fails for' CONSTANT\n   Exit\n   End\nReturn\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$VSAMIXA": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x94&?\\x00\\x97\\x04O\\x10E\\x00\\x90\\x006\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1994-09-20T00:00:00", "modifydate": "1997-02-13T10:45:00", "lines": 144, "newlines": 54, "modlines": 0, "user": "$VNV"}, "text": "/**************************** REXX ********************************/\n/*                                                                */\n/*   REXX exec to calculate the index buffer spefication for      */\n/*   a VSAM data set to make sure that all index records for      */\n/*   that VSAM data set will be in memory all the time (random    */\n/*   access).  For sequential access, specifying a lot of index   */\n/*   buffers will not help.                                       */\n/*                                                                */\n/**************************** REXX ********************************/\n\nIf SYSVAR(SYSISPF) = 'NOT ACTIVE' Then Do\n   Say 'ISPF is required to run this EXEC'\n   Exit\n   End\n\nArg DSN\nIf DSN = '' Then Do Until DSN \u00ac= ''\n   Say 'DSName missing - Enter DSNAME !!'\n   Pull DSN\n   End\nUpper DSN\n\nMESSAGE = SYSDSN(DSN)\nIf MESSAGE \u00ac= 'OK' Then Do\n   Say MESSAGE\n   Exit\n   End\n\nRECFM = LISTDSI(DSN)\n\nSelect\n   When SYSREASON = 12 | SYSREASON = 0 Then NOP      /* VSAM  */\n   When SYSREASON = 5 Then Do\n      Say DSN 'is not cataloged'\n      Exit\n      End\n   Otherwise Do\n      Say 'Error obtaining DSNAME information. LISTDSI Rc =' SYSREASON\n      Exit\n      End\n   End                      /* Select */\n\n\nIf SYSDSORG \u00ac= 'VS' Then Do\n   Say DSN 'is not VSAM'\n   Exit\n   End\n\n/******************************************************************/\n/*  Now collect VSAM information using 'LISTC ENT(DSN) ALL'       */\n/******************************************************************/\n\nX = OUTTRAP('O.')\n'LISTC ENT('DSN') ALL'\nX = OUTTRAP('OFF')\n\nSelect\n   When Pos('NONVSAM --',O.1) \u00ac= 0 Then Do\n      Say DSN 'Is not VSAM'\n      Exit\n      End\n   When Pos('CLUSTER -',O.1) = 0   Then Do\n      Say DSN 'Is not a VSAM Cluster'\n      Exit\n      End\n   Otherwise Nop\n   End                      /* Select */\n\n\n\nIf Pos('INDEX---',O.11) = 0 Then Do\n   Say DSN 'does not contain an INDEX'\n   Exit\n   End\n\n/******************************************************************/\n/*     Look for DATA CISIZE, CI/CA data (DATA section)            */\n/******************************************************************/\n\nDo I=8 to O.0\n   If Pos('DATA -',O.I) = 4 Then Do              /* Found DATA */\n      I = I+10\n      Call VERIFY 'CISIZE' Substr(O.I,95,6)\n      DCISIZE = Strip(Substr(O.I,113,6),,'-')\n      I = I+1\n      Call VERIFY 'CI/CA' Substr(O.I,95,5)\n      CIPERCA = Strip(Substr(O.I,113,6),,'-')\n      Leave\n      End\n   End                      /* Do */\n\n/******************************************************************/\n/*     Look for Data HI-USED-RBA (DATA section)                   */\n/******************************************************************/\n\nDo I=I to O.0\n   If Pos('ALLOCATION',O.I) = 6 Then Do\n      I = I+2\n      Call VERIFY 'HI-U-RBA' Substr(O.I,37,8)\n      HIURBA = Strip(Substr(O.I,45,16),,'-')\n      Leave\n      End\n   End                      /* Do */\n\n\n/******************************************************************/\n/*     Look for index CISIZE and TOTAL REC                        */\n/******************************************************************/\n\nDo I=I to O.0\n   If Pos('INDEX -',O.I) = 4 Then Do\n      I = I+9\n      Call VERIFY 'CISIZE' Substr(O.I,95,6)\n      ICISIZE = Strip(Substr(O.I,113,6),,'-')\n      Leave\n      End\n   End                      /* Do */\n\nDo I=I to O.0\n   If Pos('STATISTICS',O.I) = 6 Then Do\n      I = I+1\n      Call VERIFY 'REC-TOTAL' Substr(O.I,8,9)\n      TREC   = Strip(Substr(O.I,17,15),,'-')\n      Leave\n      End\n   End                      /* Do */\n\nCASIZE = DCISIZE*CIPERCA\nIDXSET = TREC - (HIURBA%CASIZE)\nSTRNO =  10\nIBUFNO = STRNO + IDXSET\nBATCH  = 1 + IDXSET\n\nAddress ISPEXEC 'DISPLAY PANEL($VSIDX01)'\nExit\n\nVERIFY:\nArg CONSTANT VERDATA\nIf VERDATA \u00ac= CONSTANT Then Do\n   Say 'Data verification fails for' CONSTANT\n   Exit\n   End\nReturn\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$VSDOC": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x15P\\x00\\t\\x00\\t\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T15:50:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "$VNV"}, "text": "To install the $VSAMIDX exec, do the following:\n\n   o   Copy $VSIDX01 to the system ISPF panel data set.\n   o   Copy $VSAMIDX to the system CLIST data set.\n\nSyntax for $VSAMIDX:\n\n       $VSAMIDX VSAMdsname\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$VSIDX01": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00\\x00\\x00\\x901\\x8f\\x00\\x97\\x04\\x1f\\x16\\x18\\x00'\\x00\\x1a\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "1990-11-14T00:00:00", "modifydate": "1997-02-10T16:18:00", "lines": 39, "newlines": 26, "modlines": 0, "user": "$VNV"}, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT) INTENS(HIGH) COLOR(GREEN) SKIP(ON)\n  \u00a2 TYPE(TEXT) INTENS(LOW) JUST(RIGHT) CAPS(OFF) COLOR(YELLOW)\n    + TYPE(TEXT) INTENS(LOW)  COLOR(TURQ) SKIP(ON)\n    ~ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW) SKIP(ON) HILITE(REVERSE)\n  ! TYPE(TEXT) INTENS(HIGH)  COLOR(BLUE) SKIP(ON) HILITE(USCORE)\n  } TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) CAPS(OFF)  COLOR(YELLOW)\n  { TYPE(OUTPUT) INTENS(HIGH) JUST(LEFT) CAPS(OFF)  COLOR(YELLOW)\n  ? TYPE(TEXT) INTENS(HIGH) COLOR(GREEN) HILITE(REVERSE)\n  @ TYPE(OUTPUT) INTENS(LOW) JUST(RIGHT) CAPS(OFF) COLOR(YELLOW)\n    \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n  \" TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) COLOR(PINK) HILITE(REVERSE)\n)BODY EXPAND(\\\\)\n+-\\-\\-~VSAM Index Buffer Analysis+-\\-\\-\n\u00acCOMMAND ===>_ZCMD                                                             +\n+\n\u00acData Set Name: {DSN                                        +\n+\n+!Data CISIZ+    !Idx CISIZ+  !Data HI-Used-RBA+  !Data CI/CA+   !Idx TOTREC+\n+   }DCISIZE+      }ICISIZE+     }HIURBA       +     }CIPERCA+         }TREC+\n+                                                                             +\n+    Normally, for a KSDS VSAM data set, specifying a good number of index    +\n+buffers used for random access would certainly provide tremendous performance+\n+improvement due to IO avoidance.  Based on the above information, the number +\n+of\u00acExtra Index Buffers+for this data set was calculated as\"IDXSET+\n+                                                                             +\n+    Therfore, the recommended number of index buffers specified will be:+\n+                                                                              +\n+           ?BUFNI+=?Extra Index Buffer+plus?Number Of String+\n+                                                                              +\n+    For Batch, BUFNI =  {BATCH+    +number of strings for batch = 1          +\n+    For CICS, BUFNI  =  {IBUFNO+   +assuming number of strings ={STRNO       +\n+\n+  %For an accurate calculation, the data set IDCAMS statistic needs to be+\n+  %correct, i.e. the VSAM file has to be re-org'ed before you run this.+\n)INIT\n  &ZCMD = &Z\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WHOHAS": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x00O\\x00\\x99\\x00O\\tE\\x00\\xc2\\x00\\xc0\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-01-04T00:00:00", "modifydate": "1999-01-04T09:45:00", "lines": 194, "newlines": 192, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $WHOHAS REXX/CLIST       *********************/\n /* $WHOHAS                                                          */\n /*                                                                  */\n /*   This exec will list access lists for all data set profiles     */\n /*   found under DSN*.**.  This function is very much similar to    */\n /*   'TSS WHOHAS DSN' command under Top Secret.  If the exec is     */\n /*   run in Batch, the RACF commands used to re-build all of the    */\n /*   profiles as displayed in the output is also produced.          */\n /*                                                                  */\n /* UPDATE                                                           */\n /*   9/25/97 - New exec - Vinh Vu                                   */\n /*                                                                  */\n /* SYNTAX: $WHOHAS Dsn    ---- Do not use quotes ----               */\n /*                                                                  */\n /*     Sample JCL to run this under Batch:                          */\n /*                                                                  */\n /*     //TMP       EXEC PGM=IKJEFT01,TIME=1200,REGION=4096K,        */\n /*     //          PARM='$WHOHAS SYS4'                              */\n /*     //SYSEXEC   DD   DSN=$VNV.CLIST,DISP=SHR                     */\n /*     //SYSTSPRT  DD   SYSOUT=*                                    */\n /*     //SYSTSIN   DD   DUMMY                                       */\n /*     //CMDS      DD   SYSOUT=*                                    */\n /*                                                                  */\n /********************************************************************/\n\nArg IN_DSN\nIf IN_DSN = '' Then Do\n   Say '$BDSN01E - DSN PATTERN REQUIRED .. ABORT ..'\n   Exit\n   End\n\nIN_DSN = Strip(IN_DSN)\nIf Substr(IN_DSN,Length(IN_DSN),1) = '*' Then Do\n   Say '$BDSN02E - * IS FOUND AS LAST CHARACTER IN THE DSN .. ABORT ..'\n   Exit\n   End\n\nIf Index(IN_DSN,\"'\") > 0 Then Do\n   Say '$BDSN03E - DO NOT USE QUOTES AS PART OF THE DSN PREFIX'\n   Exit\n   End\n\nParse Value Reverse(IN_DSN) with LLQ '.' .\nIf Length(Strip(LLQ)) > 7 Then IN_DSN = IN_DSN||'.**'\n   Else If Substr(IN_DSN,Length(IN_DSN),1) = '.' Then,\n      IN_DSN = IN_DSN||'**'\n      Else IN_DSN = IN_DSN||'*.**'\n\nFIRST_LINE        = 'INFORMATION FOR DATASET'\nACC_HEADLINE      = '   ID     ACCESS       '\nCOND_ACC_HEADLINE = '   ID    ACCESS   CLASS'\nBLANK_PFX         = Copies(' ',1)\nLINE_PFX          = Copies(' ',1)\nIf SYSVAR(SYSENV) = 'BACK' Then BATCH = 1\n   Else BATCH = 0\nIf SYSVAR(SYSISPF) = 'ACTIVE' Then UNDER_ISPF = 1\n   Else UNDER_ISPF = 0\n\n'MAKEBUF'\nX = OUTTRAP('CMD.')\nAddress TSO \"SR CLASS(DATASET) FILTER(\"IN_DSN\")\"\nTEMPRC = RC\n'DROPBUF'\n\nIf TEMPRC > 0 Then Do\n   Do I=1 To CMD.0\n      Say CMD.I\n      End\n   Exit\n   End\n\nIf Index(CMD.1,'NO ENTRIES MEET SEARCH CRITERIA') > 1 Then Do\n   Say '$BDSN02E - NO ENTRIES FOUND FOR' IN_DSN\n   Exit\n   End\n\nSay BLANK_PFX 'DATA SET   = ' IN_DSN\n\nDo I=1 to CMD.0\n   Call PROCESS_ENT CMD.I\n   End\n\nIf BATCH Then Do\n   \"EXECIO 0 DISKW CMDS (FINIS\"\n   End\n\nExit\n\n\n\nPROCESS_ENT: Procedure Expose BLANK_PFX LINE_PFX,\n                              FIRST_LINE,\n                              ACC_HEADLINE,\n                              COND_ACC_HEADLINE  BATCH UNDER_ISPF\nParse Upper Arg INPARM\nParse Var INPARM DSN .\n\n'MAKEBUF'\nX = OUTTRAP('CMD.')\nAddress TSO \"LD DATA('\"||DSN||\"') AU GEN\"\n'DROPBUF'\n\nIf Substr(CMD.1,1,23) \u00ac= FIRST_LINE Then Do\n   Say BLANK_PFX ' PROFILE   = ' Left(Strip(DSN),44)\n   Say LINE_PFX  '*** Data set profile not avail ***'\n   Return\n   End\n\nParse Var CMD.1 . . . FOUND_DSN .\nFOUND_DSN = Strip(FOUND_DSN)\nParse Var CMD.5 . . UACC .\nFOUND_ACC_LIST = 0\nDo I=10 to CMD.0 Until FOUND_ACC_LIST\n   If Substr(CMD.I,1,23) = ACC_HEADLINE Then Do\n      FOUND_ACC_LIST = 1\n      End\n   End               /*  Found the access list */\nSTRT_CNT = I+2\nACC_ID.   = ''\nACC_AUTH. = ''\nJ=0\nDo I=STRT_CNT to CMD.0 While Words(CMD.I) = 2  /* Loop till end  */\n   J=J+1                                       /* of access list */\n   Parse Var CMD.I ACC_ID.J ACC_AUTH.J .\n   ACC_ID.J    = Left(Strip(ACC_ID.J),8)\n   ACC_AUTH.J  = Left(Strip(ACC_AUTH.J),8)\n   End\nACC_CNT = J                    /* Number of ids in access list   */\n\nSTRT_CNT = I\nFOUND_COND_ACC_LIST = 0        /* Now look for COND access list  */\nDo I=STRT_CNT to CMD.0 Until FOUND_COND_ACC_LIST\n   If Substr(CMD.I,1,23) = COND_ACC_HEADLINE  Then Do\n      FOUND_COND_ACC_LIST = 1\n      End\n   End\nSTRT_CNT = I+2\nCOND_ID.     = ''\nCOND_AUTH.   = ''\nCOND_CLASS.  = ''\nCOND_ENTITY. = ''\nJ=0\nDo I=STRT_CNT to CMD.0 While Words(CMD.I) = 4    /* COND acc ent */\n   J=J+1\n   Parse Var CMD.I COND_ID.J COND_AUTH.J COND_CLASS.J COND_ENTITY.J\n   COND_ID.J      = Left(Strip(COND_ID.J),8)\n   COND_AUTH.J    = Left(Strip(COND_AUTH.J),8)\n   COND_CLASS.J   = Left(Strip(COND_CLASS.J),8)\n   COND_ENTITY.J  = Left(Strip(COND_ENTITY.J),8)\n   End\nCOND_CNT = J                   /* Number of COND accesses        */\n\n\n'MAKEBUF'\nIf DSN = Substr(FOUND_DSN,1,Length(DSN)) Then Do\n   Say BLANK_PFX ' PROFILE   = ' Left(Strip(DSN),44)||' UACC='||UACC\n   If BATCH Then Do\n      Parse Var DSN HLQ '.' .\n      Queue \" ADDSD '\"DSN\"' UACC(\"UACC\") OWNER(\"HLQ\") GEN\"\n      Queue \" PE '\"DSN\"' GEN RESET\"\n      End\n   If ACC_CNT > 0 Then Do\n      Do I=1 To ACC_CNT\n         Say LINE_PFX '    ACCESS = ' Left(ACC_AUTH.I,20),\n                      'ID =' ACC_ID.I\n         If BATCH Then Do\n            Queue \" PE '\"DSN\"' GEN\",\n                  \"ID(\"ACC_ID.I\") ACC(\"ACC_AUTH.I\")\"\n            End\n         End\n      End\n   If COND_CNT > 0 Then Do\n      Do I=1 to COND_CNT\n         Say LINE_PFX '    ACCESS = ' Left(COND_AUTH.I,20),\n                      'ID =' COND_ID.I\n         Say LINE_PFX Copies(' ',39) 'WHEN   ',\n                      COND_CLASS.I '=',\n                      COND_ENTITY.I\n         If BATCH Then Do\n            Queue \" PE '\"DSN\"' GEN\",\n                  \"ID(\"COND_ID.I\") ACC(\"COND_AUTH.I\")   - \"\n            Queue \"          WHEN(\"COND_CLASS.I\"(\"COND_ENTITY.I\"))\"\n            End\n         End\n      End\n   End\n\nIf BATCH Then Do\n   \"EXECIO\" Queued() \"DISKW CMDS\"\n   End\n'DROPBUF'\nReturn\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$X": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x984\\x9f\\x00\\x984\\x9f\\x085\\x00_\\x00_\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-12-15T00:00:00", "modifydate": "1998-12-15T08:35:00", "lines": 95, "newlines": 95, "modlines": 0, "user": "NMVV1"}, "text": " /********************* $X       REXX/CLIST      *********************/\n /* $X                                                               */\n /*                                                                  */\n /*    This is an edit macro.  It reads the member being edited and  */\n /*    executes it as a clist.  Parms can be entered on the command  */\n /*    line as if you're really running this under Option 6 (TSO).   */\n /*    You DO NOT have to save the edited member before running      */\n /*    this macro (that's why it was written in the first place).    */\n /*                                                                  */\n /* Author: Vinh Vu                                                  */\n /* Date written: 8/1997                                             */\n /*                                                                  */\n /* SYNTAX: $X Parms (Optional)                                      */\n /*                                                                  */\n /********************************************************************/\n\nParse Source . . MACRO_NAME .\n\nAddress ISPEXEC\n'CONTROL ERRORS RETURN'\n'ISREDIT MACRO (PARMS)'\nIf Rc \u00ac=0 Then Do\n   ZEDSMSG = MACRO_NAME||' error'\n   ZEDLMSG = MACRO_NAME||' can only run as an ISPF EDIT macro !!!'\n   'SETMSG MSG(ISRZ001)'\n   Exit\n   End\n\n'ISREDIT (OWNNAME) = MEMBER'\nIf MACRO_NAME = OWNNAME Then Do\n   ZEDSMSG = 'Recursive call error'\n   ZEDLMSG = MACRO_NAME||' is being called recursively ... abort'\n   'SETMSG MSG(ISRZ001)'\n   Exit\n   End\n\nAddress ISPEXEC \"VGET (ZTEMPF)\"\n\nDATANAME = \"'\"||ZTEMPF||\"'\"\nFILENAME = '$$'||Random(1000,9999)||'$$'\n\nAddress TSO \"ALLOC DA(\"||DATANAME||\") FILE(\"||FILENAME||\") SHR\"\n\n'ISREDIT (STRTLINE) = LINENUM .ZFIRST'\n'ISREDIT (ENDLINE) = LINENUM .ZLAST'\n'ISREDIT RECOVERY ON'\n'ISREDIT RESET'\n\nNUM_LINES = (ENDLINE-STRTLINE)+1\n\nDATA. = ''\nDo I=STRTLINE to ENDLINE\n   'ISREDIT (MYINPUT) = LINE' I\n   DATA.I = MYINPUT\n   End\nDATA.0 = NUM_LINES\n\nAddress TSO\n\"EXECIO * DISKW\" FILENAME \"(STEM DATA. FINIS\"\nAddress ISPEXEC\n\nX = OUTTRAP('O.')\nAddress TSO \"FREE F(\"FILENAME\")\"\nX = OUTTRAP('OFF')\n\nQUOTES = \"'\"\n\"MAKEBUF\"\n\nIf Index(PARMS,QUOTES) > 0 Then Do\n   PARM_PART. = ''\n   I = 0\n   Do Until Index(PARMS,QUOTES) = 0\n      I=I+1\n      PARM_PART.I = Substr(PARMS,1,Index(PARMS,QUOTES)-1)\n      PARMS = Substr(PARMS,Index(PARMS,QUOTES)+1)\n      I=I+1\n      PARM_PART.I = QUOTES||QUOTES\n      End\n   If PARMS \u00ac = '' Then Do    /* if there is data left after last ' */\n      I=I+1\n      PARM_PART.I = PARMS\n      End\n   PARMS = ''                 /* Re-construct the parms             */\n   Do J=1 To I\n      PARMS = PARMS||PARM_PART.J\n      End\n\n   End\n\nIf PARMS = '' Then  Address TSO \"EX\" DATANAME\nElse Address TSO \"EX\" DATANAME \"'\"PARMS\"'\"\n\n\"DROPBUF\"\n\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$6": {"ttr": 6928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00\\x00\\x00\\x94'\\x1f\\x00\\x94'\\x8f\\x10F\\x00'\\x00\\n\\x00 [\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "1994-09-28T00:00:00", "modifydate": "1994-10-05T10:46:00", "lines": 39, "newlines": 10, "modlines": 32, "user": "$VNV"}, "text": "/*                    REXX                                 */\n\nArg MYLOAD\n\nIf MYLOAD = \"\" Then Do\n   Say \"DATA SET NAME REQUIRED\"\n   Exit\n   End\n\nMSG = SYSDSN(MYLOAD)\n\nIf SYSDSN(MYLOAD) \u00ac= \"OK\" Then Do\n   Say MSG\n   Exit\n   End\n\nTEMP = LISTDSI(MYLOAD)\n\nIf SYSDSORG  \u00ac= \"PO\" & SYSDSORG \u00ac= \"POU\" Then Do\n   Say \"INVALID DSORG FOR LOADLIB AS\" SYSDSORG\n   Exit\n   End\n\nIf SYSRECFM \u00ac= \"U\" Then Do\n   Say \"INVALID RECFM FOR LOADLIB AS\" SYSRECFM\n   Exit\n   End\n\n\"ISPEXEC VPUT (MYLOAD)\"\n\"ISPEXEC LIBDEF ISPPLIB\"\n\"ISPEXEC LIBDEF ISPLLIB\"\n\n\"ISPEXEC LIBDEF ISPLLIB DATASET ID(\"MYLOAD\")\"\n\"ISPEXEC LIBDEF ISPPLIB DATASET ID('$VNV.CBT.PDS')\"   /** Change **/\n\n\"ISPEXEC SELECT PGM(ISRPTC)\"\n\n\"ISPEXEC LIBDEF ISPPLIB\"\n\"ISPEXEC LIBDEF ISPLLIB\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$6DOC": {"ttr": 6930, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x15X\\x00\\x15\\x00\\t\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T15:58:00", "lines": 21, "newlines": 9, "modlines": 0, "user": "$VNV"}, "text": "To install the $6 exec, do the following:\n\n   o   Copy ISRTSOA to a data set (FB, LRECL=80).  This panel is a\n       modified copy of the IBM ISRTSOA.  The only difference is that\n       the Loadlib data set name will be displayed so that you know\n       this is not the native ISPF Option 6.\n\n       NOTE ****** DO NOT COPY THIS TO A SYSTEM ISPF PANEL DATA SET, OR\n       IT WILL BE DISPLAYED BY ANYONE USING ISPF OPTION 6.\n\n       Make a note of the data set name where you copied this member to.\n\n   o   Copy $6 to the system CLIST data set.\n\n   o   Modify the $6 Exec and change $VNV.CBT.PDS to the new dsname.\n\n\nSyntax for $6:\n\n       $6 LoadlibDsname\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#LLACOPY": {"ttr": 6932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x92\\x14\\x8f\\x00\\x95\"\\x0f\\x15\\x10\\x00\\x08\\x00\\x06\\x00\\x07[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-05-27T00:00:00", "modifydate": "1995-08-08T15:10:00", "lines": 8, "newlines": 6, "modlines": 7, "user": "$VNV"}, "text": "//$VNV3    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n/*JOBPARM S=RED1\n//STEP0    EXEC PGM=$LLACOPY,PARM='ASREXIT'   <=== PARM=\"MODULE NAME\"\n//STEPLIB  DD DSN=$VNV.LOAD,DISP=SHR          <=== YOUR APF LOADLIB\n//LLAPDS   DD DSN=SYS1.LINKLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=SYSRED\n//SYSUDUMP DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY   /* OR DD * FOR ADDITIONAL MODULE NAMES */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DYNA": {"ttr": 7170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x85\\x13_\\x00\\x92\\x14\\x1f\\x12\\x12\\x00\\x13\\x009\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1985-05-15T00:00:00", "modifydate": "1992-05-20T12:12:00", "lines": 19, "newlines": 57, "modlines": 0, "user": "$VNV"}, "text": ")F FUNCTION -\n\n     The DYNALIST TSO command displays all unit names and UCBs\n associated with those names.  The unit names will be displayed by\n device class, i.e. TAPE, COMM, etc ... or by alaphabetically sorted\n sequence.  Once the unit names are displayed, you can then display\n the UCBs associated with a specific name (esoteric).\n\n     For non-Tape/DASD device, only the Online/Offline status is shown.\n For DASD, VOLSER, Mount status, SHARED/Non-SHARED DASD status is\n displayed.  For Tape, VOLSER, Device Capacity, Density and Type\n is displayed.\n\n\n)X SYNTAX -\n\n          DYNALIST\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE166": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x15\\x01 \\t\\x1f\\x01 \\t\\x1f\\x11P\\x01]\\x01]\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-31T00:00:00", "modifydate": "2020-03-31T11:50:15", "lines": 349, "newlines": 349, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 166 is from VINH VU and contains a nice collection        *   FILE 166\n//*           of utilities, exits, and REXX execs.  This file       *   FILE 166\n//*           is worth a very good look.                            *   FILE 166\n//*                                                                 *   FILE 166\n//*       email:  Vinh Vu <vinhnvu@gmail.com>                       *   FILE 166\n//*                                                                 *   FILE 166\n//*    CONTENTS OF THIS PDS:                                        *   FILE 166\n//*                                                                 *   FILE 166\n//*      $ALIDEF  -  THIS EXEC MACRO CREATES THE IDCAMS DELETE AND  *   FILE 166\n//*                  DEFINE ALIAS FOR A LIST OF DATASETS.  PARM     *   FILE 166\n//*                  EXEPECTED IS CATALOG NAME, AND OPTIONAL 'O'    *   FILE 166\n//*                  FOR (ONLY DEFINE, AND NO DELETE STATEMENTS     *   FILE 166\n//*                  FOR THE ALIAS BEFORE RE-DEFINING IT).          *   FILE 166\n//*                                                                 *   FILE 166\n//*      $CAL     -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  EXEC DISPLAYS A QUICK POP-UP CALENDAR USING    *   FILE 166\n//*                  ISPF PANEL.  CHECK IT OUT.                     *   FILE 166\n//*                                                                 *   FILE 166\n//*      $CATDEF  -  THIS EXEC MACRO CREATES THE IDCAMS DELETE AND  *   FILE 166\n//*                  DEFINE STMTS FOR A LIST OF DATASETS.  PARM     *   FILE 166\n//*                  EXEPECTED IS CATALOG NAME, VOLSER AND OPTIONAL *   FILE 166\n//*                  'O' FOR (ONLY DEFINE, AND NO DELETE            *   FILE 166\n//*                  STATEMENTS).                                   *   FILE 166\n//*                                                                 *   FILE 166\n//*      $CKOUT   -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  EXEC DISPLAYS PERTINENT INFORMATION ABOUT      *   FILE 166\n//*                  YOUR TSO SESSION OR BATCH JOB, I.E. JOB/STEP   *   FILE 166\n//*                  REGION SIZES, LIMITS, JOB/STEP TIME LIMITS,    *   FILE 166\n//*                  MSGCLASS, ETC.. THIS CAN BE USED TO VERIFY     *   FILE 166\n//*                  THE SETTINGS DONE BY THE LOCAL JES2 AND SMF    *   FILE 166\n//*                  EXITS.                                         *   FILE 166\n//*                                                                 *   FILE 166\n//*      $CMDPFX  -  ASM - TO ASSIGN A COMMAND PREFIX TO A MVS      *   FILE 166\n//*                  IMAGE OF A SYSPLEX.  RATHER THAN USING THE     *   FILE 166\n//*                  'ROUTE' COMMAND, YOU CAN USE THIS PREFIX FOR   *   FILE 166\n//*                  ROUTING A COMMAND TO THE APPROPRIATE SYSTEM.   *   FILE 166\n//*                  THE PREFIX IS SPECFIED THROUGH PARM.           *   FILE 166\n//*                                                                 *   FILE 166\n//*      $CPU     -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS IS   *   FILE 166\n//*                  A CPU MONITOR DISPLAY.  THE CPU UTILIZATION    *   FILE 166\n//*                  IS DISPLAYED IN GRAPHICAL FORMAT USING ISPF    *   FILE 166\n//*                  PANELS WITH DYNAMIC COLOR.  THE DATA IS WRAPPED*   FILE 166\n//*                  AROUND ON THE SCREEN FOR COMPARISON.  PRETTY   *   FILE 166\n//*                  COLORS !!!!                                    *   FILE 166\n//*                                                                 *   FILE 166\n//*      $D       -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  DISPLAYS MVS CONTROL BLOCKS, I.E.              *   FILE 166\n//*                  LINKLIST, APFLIST, SUBSYSTEM NAMES.            *   FILE 166\n//*                                                                 *   FILE 166\n//*      $DATE    -  CLIST (EXEC) - WRITTEN IN TSO REXX.            *   FILE 166\n//*                  THIS REXX FUNCTION DOES DATE                   *   FILE 166\n//*                  CONVERSIONS, INCLUDING RELATIVE DATE           *   FILE 166\n//*                  USED FOR CALCULATION.                          *   FILE 166\n//*                                                                 *   FILE 166\n//*      $DO      -  CLIST (EXEC) - EDIT MACRO. THIS EXEC           *   FILE 166\n//*                  VERIFIES THE 'DO/SELECT-END' PAIRINGS IN A     *   FILE 166\n//*                  REXX EXEC.  ANY HANGING 'DO/SELECT-END' WILL   *   FILE 166\n//*                  BE FLAGGED AS ERROR.  IT ALSO MARKS THE        *   FILE 166\n//*                  BEGINNING AND END OF EACH 'DO/SELECT-END'      *   FILE 166\n//*                  PAIR.  USEFUL IF YOU DO A LOT OF REXX          *   FILE 166\n//*                  CODING.                                        *   FILE 166\n//*                                                                 *   FILE 166\n//*      $IEASYS  -  THIS EXEC DISPLAYS IEASYSXX VARIABLES.  IT     *   FILE 166\n//*                  ALSO LISTS OUT THE PARMLIB WHERE THESE MEMBERS *   FILE 166\n//*                  CAME FROM.  GREAT FOR DIAGNOSTICS AND CHASING  *   FILE 166\n//*                  THROUGH WHAT PARM MEMBERS GOT PULLED BASED ON  *   FILE 166\n//*                  IPL SPECFICATION.                              *   FILE 166\n//*                                                                 *   FILE 166\n//*      $INFO    -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS IS A *   FILE 166\n//*                  GENERAL SRM INFO DISPLAY.  THE CPU UTILIZATION *   FILE 166\n//*                  PLUS ALL OTHER SRM INDICATORS ARE SHOWN. ANY   *   FILE 166\n//*                  EXCEPTION CONDITION WILL CHANGE EITHER SOME    *   FILE 166\n//*                  DISPLAY COLORS OR TEXT DISPLAY.  SOME OF THE   *   FILE 166\n//*                  INFO INCLUDES PAGE FAULT RATE, MIGR AGE, AFQ,  *   FILE 166\n//*                  UIC, ETC...  THE CPU UTIL IS ALSO DISPLAYED IN *   FILE 166\n//*                  A GRAPHICAL FORMAT.  AGAIN, PRETTY COLORS !!!  *   FILE 166\n//*                                                                 *   FILE 166\n//*      $JAD     -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  EXEC GOES THROUGH THE ASCB CHAIN AND           *   FILE 166\n//*                  DISPLAYS JOB ACTIVITY INFO USING ISPF TABLE    *   FILE 166\n//*                  DISPLAY FACILITY, I.E. TCBTIME, EXCPTIME,      *   FILE 166\n//*                  EXCP COUNT, STORAGE USAGE, ETC. IF AN          *   FILE 166\n//*                  ADDRESS SPACE IS SELECTED, THEN ADDITIONAL     *   FILE 166\n//*                  INFO WILL BE DISPLAYED, INCLUDING A PLOT       *   FILE 166\n//*                  THAT SHOWS REAL & EXPANDED STORAGE, AND        *   FILE 166\n//*                  ANOTHER WHICH SHOWS ITS STORAGE                *   FILE 166\n//*                  DISTRIBUTION BASED ON UIC (KINDA SHOW YOU      *   FILE 166\n//*                  HOW REAL MEMORY IS BEING USED AT THE TIME).    *   FILE 166\n//*                  THE DISPLAY CAN BE SORTED AND FILTERED BY      *   FILE 166\n//*                  SEVERAL DIFFERENT KEYS.                        *   FILE 166\n//*                                                                 *   FILE 166\n//*                  THIS WAS WRITTEN ORIGINALLY TO DISPLAY THE     *   FILE 166\n//*                  TOTAL STORAGE USED, PLUS REAL AND EXPANDED,    *   FILE 166\n//*                  SEPARATELY FOR THE ADDRESS SPACES. RMFWDM      *   FILE 166\n//*                  (WORKLOAD DELAY MONITOR) ONLY GIVES YOU THE    *   FILE 166\n//*                  TOTAL, NOT THE OTHER TWO, AND DOES NOT         *   FILE 166\n//*                  ALLOW SORTING.  THIS EXEC, HOWEVER, GIVES      *   FILE 166\n//*                  ALL TOTALS AND LET YOU DO ALL KIND OF          *   FILE 166\n//*                  SORTING.  NOT ONLY THAT, IT ALSO GIVES YOU     *   FILE 166\n//*                  ADDITIONAL INFO (WHILE I'M LOOKING AROUND      *   FILE 166\n//*                  AT THE CONTROL BLOCKS...).                     *   FILE 166\n//*                                                                 *   FILE 166\n//*               ****** SEE $JADPGM ******  NOTE - 3/6/95 ******   *   FILE 166\n//*               ****** SEE $JADPGM ******  NOTE - 3/6/95 ******   *   FILE 166\n//*                                                                 *   FILE 166\n//*      $JADPGM  -  ASM - ASSEMLER VERSION OF $JAD.  THIS WAS      *   FILE 166\n//*                  WRITTEN AFTER $JAD IS FOUND TO BE TOO          *   FILE 166\n//*                  SLOW, ESPCIALLY WHEN THE CPU IS CONSTANTLY     *   FILE 166\n//*                  RUNNING ABOVE 100% (SRM CPU BUSY PCT).         *   FILE 166\n//*                                                                 *   FILE 166\n//*      $LLACOPY -  SOURCE - BATCH ASSEMBLER PROGRAM TO            *   FILE 166\n//*                  SELECTIVELY REFRESH A LLA (VLF) MODULE.        *   FILE 166\n//*                  RATHER THAN DOING A 'F LLA,REFRESH' WHICH      *   FILE 166\n//*                  MAY TAKE A WHILE DEPENDING ON THE LIST OF      *   FILE 166\n//*                  DATA SETS BEING MANAGED BY LLA, THIS           *   FILE 166\n//*                  PROGRAM WILL UPDATE JUST THE MODULE(S) BEING   *   FILE 166\n//*                  REFRESHED.                                     *   FILE 166\n//*                                                                 *   FILE 166\n//*      $MCOPY   -  THIS EXEC COPIES MEMBER(S) FROM ONE PDS TO     *   FILE 166\n//*                  ANOTHER PDS USING ISPF SERVICES AND THEREFORE  *   FILE 166\n//*                  MAINTAINS THE ENQ ACROSS. THE EXEC PROVIDES    *   FILE 166\n//*                  SAME FUNCTION UNDER BATCH ISPF AS OPTION 3.3   *   FILE 166\n//*                  UNDER ON-LINE ISPF.                            *   FILE 166\n//*                                                                 *   FILE 166\n//*      $MDEL    -  THIS EXEC DOES A DELETE OF A PDS MEMBER USING  *   FILE 166\n//*                  ISPF DIALOG SERVICES AND THEREFORE MAINTAINS   *   FILE 166\n//*                  THE ENQ ACROSS. THE EXEC DOES PROVIDE THE      *   FILE 166\n//*                  SAME FUNCTION UNDER BATCH (RUNNING ISPF) AS    *   FILE 166\n//*                  IN OPTION 3.1 FOR ONLINE ISPF.                 *   FILE 166\n//*                                                                 *   FILE 166\n//*      $MREN    -  THIS EXEC DOES A RENAME OF A PDS MEMBER USING  *   FILE 166\n//*                  ISPF DIALOG SERVICES AND THEREFORE MAINTAINS   *   FILE 166\n//*                  THE ENQ ACROSS.  THE EXEC PROVIDES SAME        *   FILE 166\n//*                  FUNCTION UNDER BATCH ISPF AS OPTION 3.1 UNDER  *   FILE 166\n//*                  ONLINE ISPF.                                   *   FILE 166\n//*                                                                 *   FILE 166\n//*      $MEM     -  THIS EXEC ALLOWS A MEMBER TO BE SEARCHED FROM  *   FILE 166\n//*                  CONCATENATION OF SEVERAL PDS'S.  THESE PDS'S   *   FILE 166\n//*                  CAN HAVE SPECIFIC VOLSER CODED.  ONLY THE      *   FILE 166\n//*                  FIRST FOUND MEMBER IN THE CONCATENATION WILL   *   FILE 166\n//*                  BE DISPLAYED (VIEW, BROWSE OR EDIT).  THIS IS  *   FILE 166\n//*                  GOOD FOR LOOKING AT SYS1.XXX.PARMLIB MEMBERS.  *   FILE 166\n//*                                                                 *   FILE 166\n//*      $MPFREPL -  ASM - A GENERALIZED MPF EXIT.  THE MESSAGES    *   FILE 166\n//*                  BEING HANDLED ARE CODED USING AN IN-LINE       *   FILE 166\n//*                  MACRO.  PROCESSING CAN ALSO BE LIMITED TO      *   FILE 166\n//*                  MESSAGES PRODUCED BY CERTAIN JOBNAMES          *   FILE 166\n//*                  SPECIFIED BY THIS MACRO.                       *   FILE 166\n//*                                                                 *   FILE 166\n//*      $PARM    -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  EXEC TAKES IN THE PARMS AND DOES SUBSTITUTION  *   FILE 166\n//*                  ON THE INPUT CARDS (FROM DDNAME INPUT) TO      *   FILE 166\n//*                  PRODUCE OUTPUT DATA FOR SUBSEQUENT USAGE.      *   FILE 166\n//*                  SEVERAL RESERVED SYMBOLS WILL BE SUBSTITUTED   *   FILE 166\n//*                  AS WELL, I.E. ~JOBNAME~, ~SYSID~.  REXX        *   FILE 166\n//*                  FUNCTIONS WILL ALSO BE EVALUATED TO PRODUCE    *   FILE 166\n//*                  THE OUTPUT IF CODED (THIS CAN BE JUST ANOTHER  *   FILE 166\n//*                  EXTERNAL REXX FUNCTION LIKE $DATE)             *   FILE 166\n//*                                                                 *   FILE 166\n//*      $POINT   -  TO GRAB THE DATA SET NAME AT WHERE THE CURSOR  *   FILE 166\n//*                  IS AND BRINGS UP A PANEL SHOWING DATA SET      *   FILE 166\n//*                  CHARACTERISTICS AND ALSO ALLOWS IT TO BE       *   FILE 166\n//*                  EDITED, BROWSED, ETC... FOR THE DATA SET TYPES *   FILE 166\n//*                  THAT ISPF CANNOT HANDLE, I.E. VSAM, LOADLIB,   *   FILE 166\n//*                  FILEAID WILL BE INVOKED INSTEAD.               *   FILE 166\n//*                                                                 *   FILE 166\n//*      $Q       -  EDIT MACRO (REXX) - THIS MACRO TAKES A PARM    *   FILE 166\n//*                  AS A TSO COMMAND TO BE ISSUED AND THE OUTPUT   *   FILE 166\n//*                  WILL BE TRAPPED AND DISPLAYED AS ISPF EDIT     *   FILE 166\n//*                  NOTE LINES.                                    *   FILE 166\n//*                                                                 *   FILE 166\n//*      $RXSYMBL -  AN ASSEMBLER PROGRAM TO USE THE ASASYMBP       *   FILE 166\n//*                  MACRO TO RESOLVE AND SUBSTITUTE ALL SYSTEM     *   FILE 166\n//*                  SYMBOLIC REFERENCES.  CALLED BY THE $SYMSUB    *   FILE 166\n//*                  EXEC.                                          *   FILE 166\n//*                                                                 *   FILE 166\n//*      $SAVE    -  EDIT MACRO (REXX) - THIS MACRO SAVES DATA      *   FILE 166\n//*                  BEING EDITED BY DOING UPDATE IN PLACE FOR A    *   FILE 166\n//*                  PDS MEMBER.  EXTREMELY USEFUL IF               *   FILE 166\n//*                  SYS1.PROCLIB IS FULL, AND YOU JUST NEED TO     *   FILE 166\n//*                  MAKE MINIMUM CHANGES TO A PROC (UNLESS YOU     *   FILE 166\n//*                  WANT TO GO AHEAD AND COMPRESS IT RIGHT THEN    *   FILE 166\n//*                  AND THERE ...)                                 *   FILE 166\n//*                                                                 *   FILE 166\n//*      $SYMSUB  -  EDIT MACRO TO REPLACE SYSTEM SYMBOLICS WITH    *   FILE 166\n//*                  THEIR ACTUAL VALUE.  NEEDS EXTERNAL REXX       *   FILE 166\n//*                  $RXSYMBL TO ACTUALLY RESOLVE THE SYMBOLICS.    *   FILE 166\n//*                                                                 *   FILE 166\n//*      $SYSINFO -  DISPLAY SYSTEM INFORMATION USING A GRAPHIC     *   FILE 166\n//*                  ISPF PANEL.                                    *   FILE 166\n//*                                                                 *   FILE 166\n//*      $SYSPRM  -  THIS EXEC WILL BRING BRING IN THE              *   FILE 166\n//*                  CONCATENATION OF PARMLIB MEMBERS INTO A        *   FILE 166\n//*                  TEMPORARY DATA SET, THEN INVOKE ISPF EDIT      *   FILE 166\n//*                  WITH MACRO $SYMSUB TO REPLACE SYSTEM           *   FILE 166\n//*                  SYMBOLICS WITH THE REAL VALUES.  THIS IS A     *   FILE 166\n//*                  GOOD WAY TO SEE WHAT EACH PARM MEMBER          *   FILE 166\n//*                  SPECIFICATION EXPANDS TO UNDER THE CURRENT     *   FILE 166\n//*                  SYSTEM.                                        *   FILE 166\n//*                                                                 *   FILE 166\n//*      $VSAMIDX -  CLIST (EXEC) - WRITTEN IN TSO REXX.  THIS      *   FILE 166\n//*                  EXEC CALCULATES THE OPTIMUM NUMBER OF          *   FILE 166\n//*                  INDEX BUFFERS TO BE SPECIFIED FOR A VSAM       *   FILE 166\n//*                  KSDS USED FOR RANDOM ACCESS.                   *   FILE 166\n//*                                                                 *   FILE 166\n//*      $VSAMIXA -  CLIST (EXEC) - THE DFSMS 1.X VERSION OF        *   FILE 166\n//*                  $VSAMIDX.                                      *   FILE 166\n//*                                                                 *   FILE 166\n//*      $WHOHAS  -  CLIST (EXEC) - THIS REXX EXEC WILL LIST THE    *   FILE 166\n//*                  ACCESS LISTS FOR RACF DATA SET PROFILES FOUND  *   FILE 166\n//*                  UNDER DSN*.**.  THIS FUNCTION IS VERY MUCH     *   FILE 166\n//*                  SIMILAR TO 'TSS WHOHAS DSN' COMMAND UNDER TOP  *   FILE 166\n//*                  SECRET.  IF THE EXEC IS RUN IN BATCH, THE RACF *   FILE 166\n//*                  COMMANDS USED TO RE-BUILD ALL OF THE PROFILES  *   FILE 166\n//*                  AS DISPLAYED IN THE OUTPUT IS ALSO PRODUCED.   *   FILE 166\n//*                                                                 *   FILE 166\n//*      $X       -  EDIT MACRO (REXX) - THIS MACRO READS THE       *   FILE 166\n//*                  MEMBER BEING EDITED AND EXECUTES IT AS A       *   FILE 166\n//*                  CLIST/EXEC.  EXECUTION PARMS ARE ALLOWED AS    *   FILE 166\n//*                  WELL.  THIS DOES NOT REQUIRED THE MEMBER TO    *   FILE 166\n//*                  BE SAVED FIRST.  EXTREMELY USEFUL IF YOU'RE    *   FILE 166\n//*                  DOING A LOT OF CLIST/EXEC CODING AND           *   FILE 166\n//*                  DEBUGGING.                                     *   FILE 166\n//*                                                                 *   FILE 166\n//*      $6       -  CLIST (EXEC) - WRITTEN IN TSO REXX.  OFTEN     *   FILE 166\n//*                  TIMES, YOU DO NEED TO ALLOCATE A NEW           *   FILE 166\n//*                  LOADLIB AND EXECUTE TSO COMMANDS OUT OF        *   FILE 166\n//*                  IT.  ONE WAY TO DO IT IS: GET OUT OF ISPF,     *   FILE 166\n//*                  ALLOCATE IT AS ISPLLIB, AND GET BACK IN.       *   FILE 166\n//*                  THE OTHER WAY (WITHOUT HAVING TO GET OUT       *   FILE 166\n//*                  OF ISPF): EXECUTE THIS EXEC, AND THERE YOU     *   FILE 166\n//*                  GO !!!                                         *   FILE 166\n//*                                                                 *   FILE 166\n//*      DALLOC   -  SOURCE - TSO CMD TO DISPLAY DYNAMIC            *   FILE 166\n//*                  ALLOCATIONS.  I'VE GOT THE ORIGINAL SOURCE     *   FILE 166\n//*                  FROM ONE OF THE VERY OLD CBT TAPE.  THIS       *   FILE 166\n//*                  STOPPED WORKING WHEN OUR JES2 PGMR DECIDED     *   FILE 166\n//*                  TO MOVE SWA ABOVE THE LINE.  I THEN            *   FILE 166\n//*                  DECIDED TO FIX THIS PROGRAM USING MACRO        *   FILE 166\n//*                  'SWAREQ' WHICH IS THE STANDARD WAY TO          *   FILE 166\n//*                  ACCESS THE JFCB FROM TIOT PTR.                 *   FILE 166\n//*                                                                 *   FILE 166\n//*      DATE     -  THIS IS JES2 EXIT 1 (PAGE SEPARATOR),          *   FILE 166\n//*                  BUT REALLY IT IS CSECT RBDDATE WHICH           *   FILE 166\n//*                  IMPLEMENTS TABLELESS DATE CONVERSION           *   FILE 166\n//*                                                                 *   FILE 166\n//*      DYNALIST -  SOURCE - TSO COMMAND TO DISPLAY ALL UNIT       *   FILE 166\n//*                  NAMES ON THE SYSTEM AND THE UCBS' (PLUS        *   FILE 166\n//*                  VOLSERS) ASSOCIATED WITH THOSE UCBS.           *   FILE 166\n//*                  DYNALIST IS AN OLD PROGRAM COMING OFF THE      *   FILE 166\n//*                  CBT TAPE AND MODIFIED TO WORK WITH MVS 4.2     *   FILE 166\n//*                  AND ABOVE.                                     *   FILE 166\n//*                                                                 *   FILE 166\n//*      ENQMON   -  SOURCE - ASM PROGRAM USED AS A STC TO          *   FILE 166\n//*                  MONITOR AND DISPLAY GRS ENQ CONTENTION. THIS   *   FILE 166\n//*                  PROGRAM DOES GQSCAN EVERY MINUTE, DISPLAYS     *   FILE 166\n//*                  THE HOLDERS/WAITERS ON THE CONSOLE.  IF THE    *   FILE 166\n//*                  HOLDER IS A TSO USER, A MESSAGE WILL BE SENT   *   FILE 166\n//*                  TO NOTIFY THE USER.  EVERY MINUTE, THE         *   FILE 166\n//*                  CONSOLE DISPLAYED MESSAGE WILL BE              *   FILE 166\n//*                  UN-HILIGHTED, THE MINUTE INCREMENTS, AND A     *   FILE 166\n//*                  NEW MESSAGE IS DISPLAYED.  THE WAITING JOB     *   FILE 166\n//*                  WILL ALSO RECEIVE MESSAGES AS PART OF THE      *   FILE 166\n//*                  JOBLOG.  THIS PROGRAM TRIES TO MIMICK MIM AS   *   FILE 166\n//*                  MUCH AS POSSIBLE WITH THE EXCEPTION OF THE     *   FILE 166\n//*                  JOB REQUEUE FUNCTION.                          *   FILE 166\n//*                                                                 *   FILE 166\n//*      FIND     -  SOURCE - TSO CMD TO DO QUICK SEARCH FOR        *   FILE 166\n//*                  ANY CHARACTER STRING IN A PDS.  HAS A FEW      *   FILE 166\n//*                  NICE OPTIONS.                                  *   FILE 166\n//*                                                                 *   FILE 166\n//*      IEFUTL   -  MULTI FUNCTION, SEMI-SMART, TABLE DRIVEN       *   FILE 166\n//*                  TIMEOUT PROCESSOR                              *   FILE 166\n//*                                                                 *   FILE 166\n//*      IEFUTLTB -  THE TABLE IT USES                              *   FILE 166\n//*                                                                 *   FILE 166\n//*      JESXIT05 -  JES2 COMMAND EXIT TO DO THE FOLLOWING:         *   FILE 166\n//*                                                                 *   FILE 166\n//*                  $Q'XXX    -  DISPLAYS ALL JOBS PREFIXED        *   FILE 166\n//*                               BY XXX                            *   FILE 166\n//*                  $QAPF     -  DISPLAYS APF LIST                 *   FILE 166\n//*                  $QLLT     -  DISPLAYS LINKLIST TABLE           *   FILE 166\n//*                  $QDSN=XXX -  CATALOG SEARCH DSNAME XXX. THE    *   FILE 166\n//*                               CATALOGED VOLUME IS ALSO SEARCHED *   FILE 166\n//*                               TO MAKE SURE DATA SET DOES EXIST  *   FILE 166\n//*                               THERE.                            *   FILE 166\n//*                  $QVOL=YYY -  DISPLAYS UCB ADDR OF VOL=YYY.     *   FILE 166\n//*                               IT'S NOT EASY TO FIND THIS OUT    *   FILE 166\n//*                               USING NATIVE MVS COMMANDS.        *   FILE 166\n//*                  $QSYSTEM  -  DISPLAYS ALL KIND OF INFO ABOUT   *   FILE 166\n//*                               SYSTEM.  GOOD FOR US SYSTEMS      *   FILE 166\n//*                               PROGRAMMERS.                      *   FILE 166\n//*                  $Q        -  DISPLAYS AVAILABLE PARMS (AS      *   FILE 166\n//*                               ABOVE)                            *   FILE 166\n//*                                                                 *   FILE 166\n//*          JES2 PARMS NEEDED:                                     *   FILE 166\n//*                                                                 *   FILE 166\n//*          *   LOADMOD(JESXIT05)                                  *   FILE 166\n//*          *   EXIT(005) ROUTINE=EXIT5,STATUS=ENABLED,TRACE=NO    *   FILE 166\n//*                                                                 *   FILE 166\n//*      JESX006  -  JES2 INTERNAL TEXT SCAN, TABLE DRIVEN,         *   FILE 166\n//*                  IMPLEMENTS CONTROLS ON NUMBER OF TAPE          *   FILE 166\n//*                  DRIVES PER STEP.                               *   FILE 166\n//*                                                                 *   FILE 166\n//*      JSTAT    -  SOURCE - BATCH PROGRAM TO CHECK AND SEE IF     *   FILE 166\n//*                  A JOB (OR STC OR TSU) IS CURRENTLY RUNNING     *   FILE 166\n//*                  (USING THE 'STATUS' FUNCTION OF JES2).  IF     *   FILE 166\n//*                  IT IS FOUND, THEN WTO'S WILL BE DONE USING     *   FILE 166\n//*                  CONTROL CARDS IN 'FND'.  OTHERWISE,            *   FILE 166\n//*                  CONTROL CARDS FROM 'NOTFND' DDNAME WILL BE     *   FILE 166\n//*                  USED BY WTO'S.  IF 'RRFND' AND 'RRNOTFND'      *   FILE 166\n//*                  ARE USED, A WTOR WILL BE DONE AFTER THE        *   FILE 166\n//*                  WTO'S TO GIVE THE OPERATOR A CHANCE TO DO      *   FILE 166\n//*                  SOMETHING ELSE BEFORE THE REPLY.  OF           *   FILE 166\n//*                  COURSE, NONE OF THE DDNAMES HAS TO BE          *   FILE 166\n//*                  PRESENT, IN WHICH CASE, THE APPROPRIATE        *   FILE 166\n//*                  RETURN CODE WILL BE ISSUED BASED ON THE        *   FILE 166\n//*                  JOB STATUS.  NOTE THAT SINCE THIS PROGRAM      *   FILE 166\n//*                  DOES NOT GO THROUGH THE ASVT, AND              *   FILE 166\n//*                  THEREFORE DOES WORK IN A JES2 SHARED SPOOL     *   FILE 166\n//*                  ENVIRONMENT.                                   *   FILE 166\n//*                                                                 *   FILE 166\n//*      LOCKTERM -  TSO COMMAND TO LOCK A SCREEN WITH A            *   FILE 166\n//*                  PASSWORD                                       *   FILE 166\n//*                                                                 *   FILE 166\n//*      SEEK     -  SOURCE - TSO CMD TO DO QUICK SEARCH FOR        *   FILE 166\n//*                  ANY MODULE THAT RESIDES IN LPA                 *   FILE 166\n//*                  (MLPT/FLPA/PLPA), LINKLIST, AND/OR             *   FILE 166\n//*                  STEPLIB.  MODULE INFORMATION WILL BE           *   FILE 166\n//*                  DISPLAYED ACCORDINGLY IF FOUND.                *   FILE 166\n//*                                                                 *   FILE 166\n//*      TSOINIT  -  SOURCE - TSO CMD TO CHECK FOR A FEW ISPF       *   FILE 166\n//*                  DATA SETS AND ALLOCATE THEM AS 'NEW' IF        *   FILE 166\n//*                  THEY ARE NOT FOUND IN THE CATALOGS.  THESE     *   FILE 166\n//*                  DATA SET NAMES ARE RECORDED IN A TABLE OF      *   FILE 166\n//*                  THIS PROGRAM.  THE FIRST DATA SET              *   FILE 166\n//*                  QUALIFIER WILL BE THE SAME WITH THE            *   FILE 166\n//*                  EXECUTING TSO ID.                              *   FILE 166\n//*                                                                 *   FILE 166\n//*   -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- *   FILE 166\n//*                                                                 *   FILE 166\n//*     WE DO NOT PROMISE TO MAKE ANY CORRECTIONS AND/OR            *   FILE 166\n//*     MODIFICATIONS TO ANY OF THE PROGRAMS.  HOWEVER, WE DO       *   FILE 166\n//*     ENCOURAGE ANY COMMENTS/IDEAS AND WILL ATTEMPT TO PROVIDE    *   FILE 166\n//*     ANY FIXES AND/OR MODIFICATIONS AS TIME PERMITS.  ALL        *   FILE 166\n//*     QUESTIONS/COMMENTS CAN BE DIRECTED TO:                      *   FILE 166\n//*                                                                 *   FILE 166\n//*          email:  Vinh Vu <vinhnvu@gmail.com>                    *   FILE 166\n//*                                                                 *   FILE 166\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FIND": {"ttr": 7178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x85\\x13_\\x00\\x92\\x13\\x9f\\x14S\\x009\\x009\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1985-05-15T00:00:00", "modifydate": "1992-05-18T14:53:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "$VNV"}, "text": ")F FUNCTION -\n\n     The FIND TSO Command searches for a character string in a PDS\n (Partitioned Data Set) and displays the number of occurrences found\n in each member.\n\n     This command can be executed under native TSO mode or SPF/Option 6.\n The command will prompt for Data Set Name and search argument.  The\n total for occurrences and members will also be displayed at the end of\n execution.\n\n\n)X SYNTAX -\n\n          FIND 'DSNAME' S('CHARACTER STRING')\n                        GROUP(XX)\n                        LOWER\n                        QUICK\n\n\n  REQUIRED - 'DSNAME'  S('Character string')\n  DEFAULTS -  None\n\n)O OPERAND -\n\n  'DSNAME'    - Name of the partitioned Data Set to be\n                searched.  Omit the single quotes and the first\n                data set qualifier if it is your own data set.\n\n))S('Character string')\n\n              - The string of characters to be searched for.  Could be a\n                program name, data set name, or text data, etc..\n\n))GROUP(XX)\n\n              - Optional Keyword.  Used to limit the search on only\n                members having name beginning with XX.\n\n\n                E.g.  FIND  '$VNV.JCL.CNTL'  S('PGM=IDCAMS') GROUP($)\n\n\n))LOWER\n\n              - Optional Keyword.  Used to search for lowercase TEXT\n                character string.  If this keyword is not used, the\n                character string will be converted into uppercase before\n                the search is being performed.\n\n))QUICK\n\n              - Optional Keyword.  Used to stop command from reading\n                the entire member after the first occurrence found.\n                Process continues to the next member.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@JADPGM": {"ttr": 7180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x95\\x06_\\x102\\x00\\x0c\\x00\\x0c\\x00\\x05[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1995-03-06T10:32:00", "lines": 12, "newlines": 12, "modlines": 5, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL,PARM.LKED='XREF,LET,LIST,NCAL,RENT'\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS($JADPGM),DISP=SHR        <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n NAME $JADPGM(R)                                         <== CHANGE\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@TSOINIT": {"ttr": 7182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x85\\x13_\\x00\\x92\\x14\\x1f\\x12I\\x00\\x17\\x009\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1985-05-15T00:00:00", "modifydate": "1992-05-20T12:49:00", "lines": 23, "newlines": 57, "modlines": 0, "user": "$VNV"}, "text": ")F FUNCTION -\n\n     The TSOINIT TSO command checks for several ISPF data sets and\n allocate them as 'NEW' if they are not found in the catalog.  This\n can be set up to be executed at logon time.  That way, you will not\n have to worry about new TSO id being used the first time.\n\n\n)X SYNTAX -\n\n          TSOINIT  MESSAGE\n\n  REQUIRED -  None\n  DEFAULTS -  None\n\n)O OPERAND -\n\n))MESSAGE\n\n              - Optional Keyword.  Used to display the new data sets\n                being allocated/cataloged.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSEM": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x92\\x14\\x1f\\x12'\\x00\\x0c\\x00\\x0c\\x00\\x04[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1992-05-20T12:27:00", "lines": 12, "newlines": 12, "modlines": 4, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS(DALLOC),DISP=SHR         <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n NAME DALLOC(R)                                          <== CHANGE\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMMAND": {"ttr": 7186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\"\\x0f\\x00\\x96\"\\x0f\\t$\\x02\\xf3\\x02\\xf3\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-08-07T00:00:00", "modifydate": "1996-08-07T09:24:00", "lines": 755, "newlines": 755, "modlines": 0, "user": "$VNV"}, "text": "COMMAND  TITLE 'PROGRAM TO ISSUE O/S COMMANDS FROM A DATASET'\n***********************************************************************\n*                                                                     *\n*                          C O M M A N D                              *\n*                                                                     *\n*        THIS PROGRAM WILL USE THE SVC 34 INTERFACE TO ISSUE O/S OR   *\n*        JES2 COMMANDS.                                               *\n*                                                                     *\n*        WHAT MAKES THIS PROGRAM DIFFERENT FROM MOST PROGRAMS         *\n*        WHAT ISSUE COMMANDS IS TWO SPECIAL COMMANDS:                 *\n*                                                                     *\n*        1)  DELAY=NNN - THIS COMMAND MAKES THE PROGRAM DELAY         *\n*            NNN SECONDS PRIOR TO ISSUING THE NEXT COMMAND IN         *\n*            THE LIST.                                                *\n*                                                                     *\n*        2)  REPLY JOBNAME MESSAGEID REPLYTEXT - THIS GIVES           *\n*            THE ABILITY TO REPLY TO OUTSTANDING REPLIES FOR          *\n*            SPECIFIED JOBS WITHOUT HAVING TO KNOW THE REPLY          *\n*            ID.                                                      *\n*                                                                     *\n*        THE COMMANDS CAN COME FROM TWO INPUT SOURCES.  THE FIRST     *\n*        IS THE PARM VALUE ON THE EXECUTE CARD FOR THE STEP.  THE     *\n*        OTHER IS FROM THE INPUT DATA SET IEFRDER.  IF THE SOURCE     *\n*        IS THE PARM FIELD, MULTIPLE COMMANDS CAN BE ENTERED BY       *\n*        SEPARATING EACH COMMAND WITH A \";\".  IF THE SOURCE IS THE    *\n*        INPUT DATA SET, EACH RECORD WILL CONTAIN A SINGLE COMMAND    *\n*        STARTING IN COLUMN 1 THROUGH COLUMN 72 OF EACH RECORD.       *\n*        IF BOTH THE PARM AND INPUT DATASET ARE USED, THE COMMANDS    *\n*        IN THE PARM ARE EXECUTED FIRST.                              *\n*                                                                     *\n*        ONLY THE FIRST 72 CHARACTERS OF EACH COMMAND WILL BE USED    *\n*        WHEN ACTUALLY ISSUING THE COMMAND.                           *\n*                                                                     *\n*        IF THE COMMAND IS \"DELAY=NNN\", THE PROGRAM WILL ENTER A      *\n*        WAIT FOR THE NUMBER OF SECONDS SPECIFIED BY \"NNN\".  IF       *\n*        MORE THAN A THREE DIGIT DELAY TIME IS SPECIFIED, ONLY        *\n*        THE FIRST THREE DIGITS WILL BE USED.                         *\n*                                                                     *\n*        IF THE COMMAND IS \"REPLY JOBNAME MESSAGEID REPLYTEXT\"        *\n*        THE PROGRAM WILL SEARCH FOR OUTSTANDING REPLIES FOR          *\n*        THE SPECIFIED JOBNAME AND CONTAINING THE OPTIONAL            *\n*        MESSAGE TEXT.                                                *\n*                                                                     *\n*        THE FULL JOBNAME MUST BE SPECIFIED.  THE USE IF THE          *\n*        MESSAGEID FIELD IS OPTIONAL.  IF MULTIPLE REPLIES MAY        *\n*        BE OUTSTANDING FOR THE JOB, THIS PARAMETER CAN BE USED       *\n*        TO SPECIFY A MESSAGEID OR CHARACER STRING CONTAINED IN       *\n*        THE MESSAGE.  IF NO MESSAGEID IS TO BE SPECIFIED, A          *\n*        '*' MUST BE SPECIFIED.  SINGLE QUOTES MAY BE USED IF         *\n*        THE STRING CONTAINS IMBEDDED BLANKS.                         *\n*                                                                     *\n*        THE REPLY TEXT MUST BE SPECIFIED.  SINGLE QUOTES MAY         *\n*        BE USED IF THE STRING CONTAINS IMBEDDED BLANKS.              *\n*                                                                     *\n*        BECAUSE THIS PROGRAM ISSUES THE MODESET MACRO AND USES       *\n*        CROSS MEMORY SERVICES, IT MUST BE APF AUTHORIZED TO DO       *\n*        SO.                                                          *\n*                                                                     *\n*        ESA VERSION 4 ALLOWS A REPLYID TO BE UP TO 4 CHARACTERS      *\n*        LONG.  THIS PROGRAM DOES NOT SUPPORT THIS.  IF THAT          *\n*        SUPPORT IS REQUIRED, THE REPLYID CAN BE EXTRACTED FROM       *\n*        THE BINARY REPLY ID IN FIELD WQERPYIB USING THE              *\n*        VERSION OF THE IHAWQE MACRO AND THE LENGTH OF THE            *\n*        REPLY IN THE COMMAND BUFFER CAN BE CHANGED.  SOME            *\n*        OTHER CHANGES WOULD LIKELY BE NEEDED FOR SYSPLEX AS          *\n*        WELL.   THIS CHANGE WAS NOT MADE TO KEEP COMPATIBILITY       *\n*        WITH ESA VERSION 3.                                          *\n*                                                                     *\n*                                                                     *\n*        WRITTEN BY:                                                  *\n*                   JOHN V. HOOPER                                    *\n*                   FOOD LION, INC.                                   *\n*                   2110 EXECUTIVE DRIVE                              *\n*                   SALISBURY, N.C.  28145-1330                       *\n*                                                                     *\n*                                                                     *\n*                           DISCLAIMER                                *\n*                                                                     *\n*      THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,                 *\n*      DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR             *\n*      WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT            *\n*      LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR          *\n*      IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,       *\n*      ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,             *\n*      DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR            *\n*      FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED             *\n*      MATERIALS; THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY          *\n*      KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,                 *\n*      DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR        *\n*      APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING       *\n*      THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,             *\n*      WARRANTY, OR KNOWLEDGE; NOR DO THE AUTHORS ASSUME ANY          *\n*      LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM          *\n*      THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,       *\n*      DOCUMENTATION, OR RELATED MATERIALS.                           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*      CHG - 8/5/96 - VINH VU                                         *\n*                                                                     *\n*        CHANGE TO USE THE BINARY REPLY ID (TO ALLOW FOR 4-CHAR       *\n*        REPID) AND ALSO REPLY TO LOCAL WTOR'S ONLY IN A SYSPLEX      *\n*        ENVIRONMENT.                                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*                        SAMPLE JCL                                   *\n*                                                                     *\n*       //JOBNAME ...                                                 *\n*       //COMMAND  EXEC PGM=COMMAND,REGION=4M                         *\n*       //SYSPRINT DD  SYSOUT=*                                       *\n*       //IEFRDER  DD  *                                              *\n*       D R,R                                                         *\n*       DELAY=10                                                      *\n*       REPLY TESTJOB 'WAITING FOR' 'STOP'                            *\n*       DELAY 10                                                      *\n*       REPLY TESTJOB * YES                                           *\n*       DELAY 10                                                      *\n*       D R,R                                                         *\n*                                                                     *\n*       IN THE ABOVE EXAMPLE, THE DELAY COMMAND IS USED TO            *\n*       PAUSE THE PROGRAM FOR 10 SECONDS BETWEEN COMMANDS TO          *\n*       ALLOW TIME FOR THE PREVIOUS COMMAND TO BE EXECUTED.           *\n*                                                                     *\n*       THE FIRST REPLY COMMAND WILL REPLY 'STOP' TO THE FIRST        *\n*       OUTSTANDING REPLY FOR JOB TESTJOB WHICH CONTAINS              *\n*       THE CHARACTERS 'WAITING FOR'.                                 *\n*                                                                     *\n*       THE SECOND REPLY COMMAND WILL REPLY 'YES' TO THE              *\n*       FIRST OUTSTANDING REPLY FOR JOB TESTJOB NO                    *\n*       MATTER WHAT REPLY MESSAGE IS OUTSTANDING.                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*            M A C R O S   U S E D   I N   C O M M A N D              *\n*                                                                     *\n*        01)  ABEND        SYS1.MACLIB                                *\n*        02)  AXSET        SYS1.MACLIB                                *\n*        03)  CALL         SYS1.MACLIB                                *\n*        04)  CLOSE        SYS1.MACLIB                                *\n*        05)  CVT          SYS1.MODGEN                                *\n*        06)  DCB          SYS1.MACLIB                                *\n*        07)  FREEMAIN     SYS1.MACLIB                                *\n*        08)  GET          SYS1.MACLIB                                *\n*        09)  GEMAIN       SYS1.MACLIB                                *\n*        10)  IEECUCM      SYS1.MODGEN                                *\n*        11)  IHAASCB      SYS1.MODGEN                                *\n*        12)  IHAASVT      SYS1.MODGEN                                *\n*        13)  IHAORE       SYS1.MODGEN                                *\n*        14)  IHAPSA       SYS1.MACLIB                                *\n*        15)  IHAWQE       SYS1.MODGEN                                *\n*        16)  MGCR         SYS1.MODGEN                                *\n*        17)  MODESET      SYS1.MACLIB                                *\n*        18)  OPEN         SYS1.MACLIB                                *\n*        19)  RETURN       SYS1.MACLIB                                *\n*        20)  SAVE         SYS1.MACLIB                                *\n*        21)  SETLOCK      SYS1.MACLIB                                *\n*        22)  STIMER       SYS1.MACLIB                                *\n*        23)  WTO          SYS1.MACLIB                                *\n*                                                                     *\n*                                                                     *\n*               L I N K A G E    E D I T O R    I N F O               *\n*                                                                     *\n*        SIZE:       2K                                               *\n*        ATTRIBUTES: AUTHORIZED NORENT NOREUS NOREFR                  *\n*                    AMODE24    RMODE24                               *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*                                                                     *\n*        START OF PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nCOMMAND  CSECT\nCOMMAND  AMODE 24\nCOMMAND  RMODE 24\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         USING COMMAND,R12         SET ADDRESSABILITY\n         LA    R15,SAVEAREA        LOAD ADDRESS OF NEW SAVE\n         ST    R15,8(R13)          STORE NEW SAVE ADDR IN OLD\n         ST    R13,4(R15)          STORE OLD SAVE ADDR IN NEW\n         LR    R13,R15             SET NEW SAVE ADDRESS\n         LR    R2,R1               SAVE INPUT PARM ADDRESS\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        GET STORAGE FOR AN OUTSTANDING REPLY TABLE                   *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=13801        GET STORAGE FOR TABLE\n         ST    R1,GETADDR          SAVE TABLE ADDRESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SEE IF A PARM HAS BEEN ENTERED.  IF SO, PROCESS EACH         *\n*        COMMAND WITHIN THE PARM.                                     *\n*                                                                     *\n***********************************************************************\nCKPARM   LR    R1,R2               RESTORE INPUT PARM ADDRESS\n         LTR   R1,R1               SEE IF INPUT PARM\n         BZ    OPEN                NONE, GO OPEN FILE\n         L     R9,0(R1)            LOAD PARM ADDRESS\n         LTR   R9,R9               TEST PARM ADDRESS\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LH    R8,0(R9)            LOAD PARM LENGTH\n         LTR   R8,R8               TEST PARM LENGTH\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LA    R9,2(R9)            POINT TO ACTUAL PARM\nCKPARM1  LR    R1,R9               SAVE START ADDRESS OF PARM\n         SLR   R15,R15             SET LENGTH OF COMMAND\nCKPARM2  CLI   0(R1),C';'          SEE IF END OF COMMAND\n         BE    CKPARM3             YES, BRANCH\n         LA    R15,1(R15)          ADD 1 TO LENGTH\n         LA    R1,1(R1)            INCREMENT TO NEXT CHAR OF PARM\n         BCT   R8,CKPARM2          LOOP FOR NEXT CHAR OF PARM\nCKPARM3  LTR   R15,R15             TEST FOR ZERO LENGTH\n         BZ    CKPARM5             ZERO, NULL COMMAND, BRANCH\n         CH    R15,=H'72'          SEE IF EXCEEDS MAX LENGTH\n         BNH   CKPARM4             NO, BRANCH\n         LA    R15,72              SET TO MAX LENGTH\nCKPARM4  MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,PARMCMD         MOVE PARM COMMAND TO BUFFER\n         LR    R9,R1               SET NEW START OF CMD POINTER\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\nCKPARM5  CLI   0(R9),C';'          IS THERE ANOTHER COMMAND\n         BNE   OPEN                NO, GET OUT\n         LA    R9,1(R9)            INCREMENT PAST SEMICOLON\n         BCTR  R8,0                REDUCE REMAINING PARM LENGTH BY 1\n         LTR   R8,R8               TEST REMAINING PARM LENGTH\n         BZ    OPEN                ZERO, FINISHED\n         B     CKPARM1             GO PROCESS THIS COMMAND\nPARMCMD  MVC   COMDATA+4(0),0(R9)  **** EXECUTE ONLY ****\n         EJECT\n***********************************************************************\n*                                                                     *\n*        OPEN THE IEFRDER DATA SET (IF SPECIFIED).                    *\n*                                                                     *\n***********************************************************************\nOPEN     SLR   R15,R15        CLEAR REGISTER FOR ICM\n         L     R14,16         POINT TO CVT\n         L     R14,0(,R14)    POINT TO TCB POINTERS\n         L     R14,4(,R14)    POINT TO CURRENT TCB\n         L     R14,12(,R14)   POINT TO TIOT\n         LA    R14,24(,R14)   POINT TO TIOT DD ENTRIES\nOPEN1    ICM   R15,1,0(R14)   LOAD ENTRY LENGTH\n         BZ    RETURN         END OF TIOT, END OF PROCESSING\n         CLC   4(8,R14),=CL8'IEFRDER' SEE IF DD STATEMENT SPECIFIED\n         BE    OPEN2          YES, GET OUT\n         LA    R14,0(R15,R14) INCREMENT TO NEXT ENTRY\n         B     OPEN1          LOOP\n***********************************************************************\n*                                                                     *\n*        READ INPUT FILE.  PASS THE FIRST 72 CHARACTERS OF EACH       *\n*        RECORD TO O/S AS A COMMAND.                                  *\n*                                                                     *\n***********************************************************************\nOPEN2    OPEN  (IEFRDER,(INPUT))   OPEN INPUT FILE\nREAD     GET   IEFRDER             READ INPUT FILE\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVC   COMDATA+4(72),0(R1) MOVE IN JES OR O/S COMMAND\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\n         B     READ\n         EJECT\n***********************************************************************\n*                                                                     *\n*        END OF THE PROGRAM                                           *\n*                                                                     *\n***********************************************************************\nEOF      CLOSE (IEFRDER)           CLOSE INPUT FILE\nRETURN   L     R1,GETADDR          LOAD ADDRESS OF GETMAINED TABLE\n         FREEMAIN R,LV=13801,A=(1) FREE STORAGE USED BY THE TABLE\n         L     R13,4(,R13)         LOAD ADDRESS OF OLD SAVE AREA\n         RETURN (14,12),RC=0       RETURN TO O/S\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EITHER ISSUE THE COMMAND WHICH HAS BEEN STORED AT            *\n*        COMDATA+4 OR IF IT IS A DELAY COMMAND, WAIT THE SPECIFIED    *\n*        INTERVAL OF TIME BEFORE CONTINUING WITH OTHER COMMANDS.      *\n*                                                                     *\n*        INPUT:  COMMAND AT COMDATA+4                                 *\n*                R10 - RETURN ADDRESS                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*        SEE IF THE COMMAND IS A DELAY COMMAND TO THE PROGRAM TO      *\n*        WAIT A SPECIFIED INTERVAL OF TIME BEFORE CONTINUING WITH     *\n*        OTHER INPUT COMMANDS.                                        *\n***********************************************************************\nDOCMD    CLC   COMDATA+4(6),=CL6'DELAY=' SEE IF A DELAY COMMAND\n         BNE   DOCMD4              NO, GO ISSUE THE COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         LA    R2,COMDATA+10       POINT TO START OF \"DELAY=\" VALUE\n         LA    R3,8                SET MAXIMUM LENGTH OF DELAY VALUE\n         SLR   R4,R4               SET LENGTH COUNTER\nDOCMD1   CLI   0(R2),C' '          END OF DELAY VALUE\n         BE    DOCMD2              YES, BRANCH\n         LA    R4,1(,R4)           ADD 1 TO LENGTH COUNTER\n         CLI   0(R2),C'0'          SEE IF LT 0\n         BL    DOCMD3              YES, NOT NUMERIC\n         CLI   0(R2),C'9'          SEE IF GT 9\n         BH    DOCMD3              YES, NOT NUMERIC\n         LA    R2,1(,R2)           INCREMENT TO NEXT INPUT CHARACTER\n         BCT   R3,DOCMD1           LOOP UP TO 8 TIMES\n         CLI   0(R2),C' '          END OF DELAY VALUE\n         BNE   DOCMD3              NO, TOO LONG\nDOCMD2   LTR   R4,R4               TEST LENGTH\n         BZ    DOCMD3              ZERO, BLANK\n         BCTR  R4,0                MAKE MACHINE LENGTH\n         EX    R4,PACKTIME         PACK THE DELAY VALUE\n         CVB   R5,DOUBLE           CONVERT DELAY TO BINARY\n         LTR   R5,R5               CHECK VALUE\n         BZ    DOCMD3              ZERO, INVALID\n         CH    R5,=H'999'          SEE IF EXCEEDS MAXIMUM VALUE\n         BH    DOCMD3              YES, ERROR\n         MH    R5,=H'100'          MULTIPLY BY 100\n         ST    R5,WAITIME          SAVE WAIT TIME IN HUNDRETHS OF A SEC\n         STIMER WAIT,BINTVL=WAITIME WAIT THE SPECIFIED TIME\n         B     DOCMD6              GO GET ANOTHER COMMAND\nDOCMD3   WTO   'CMD001E ILLEGAL VALUE SPECIFIED ON THE DELAY CONTROL STX\n               ATEMENT - JOB ABORTED',ROUTCDE=(2,11)\n         ABEND 0001,DUMP           ABEND THE STEP\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\nDOCMD4   CLC   COMDATA+4(6),=CL6'REPLY ' SEE IF A REPLY COMMAND\n         BNE   DOCMD5              NO, GO ISSUE THE COMMAND\n***********************************************************************\n*                                                                     *\n*        PARSE THE REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE REPLY COMMAND\n         LA    R1,REPLYWK+5        POINT TO START OF REPLY DATA\n         LA    R14,72-5            LOAD LENGTH OF REPLY DATA\n         MVI   DELIM,C' '          SET DELIMETER TO BLANK\n         LA    R2,PARMS            POINT TO PARM TABLE\n         SLR   R15,R15             SET PARM COUNT TO ZERO\nDOCMD4A  CLC   0(1,R1),DELIM       SEE IF START OF PARM\n         BNE   DOCMD4B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD4A         LOOP\n         B     DOCMD4F             END OF PARM, BRANCH\nDOCMD4B  CH    R15,=H'3'           SEE IF ALREADY FOUND MAX PARMS\n         BNL   DOCMD4F             YES, IGNORE ANY OTHERS\n         LA    R15,1(,R15)         ADD 1 TO PARM COUNTER\n         CLI   0(R1),C''''         SEE IF QUOTED STRING\n         BNE   DOCMD4C             NO, BRANCH\n         MVC   DELIM,0(R1)         SET DELIMETER\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD4F             DONE, GET OUT\nDOCMD4C  ST    R1,0(R2)            SAVE START ADDRESS OF PARM\nDOCMD4D  CLC   0(1,R1),DELIM       SEE IF END OF PARM\n         BE    DOCMD4E             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD4D         LOOP\nDOCMD4E  S     R1,0(R2)            SUBTRACT START ADDR FROM ENDING\n         ST    R1,4(R2)            SAVE PARM LENGTH\n         A     R1,0(R2)            RESTORE END ADDRESS\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD4F             DONE, GET OUT\n         MVI   DELIM,C' '          SET DEFAULT DELIMETER\n         LA    R2,8(,R2)           INCREMENT TO NEXT PARM POINTER\n         B     DOCMD4A             GO PROCESS NEXT PARM\nDOCMD4F  CH    R15,=H'3'           SEE IF THREE PARMS\n         BE    DOCMD4G             YES, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR01' SET ERROR FLAG\n         B     DOCMD4P             GO ECHO THE COMMAND\nDOCMD4G  CLC   JOBNL,=F'0'         TEST LENGTH OF THE JOBNAME\n         BNZ   DOCMD4H             NOT ZERO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR02' SET ERROR FLAG\n         B     DOCMD4P             GO ECHO THE COMMAND\nDOCMD4H  CLC   JOBNL,=F'8'         TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD4I             NOT GREATER THAN 8, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR03' SET ERROR FLAG\n         B     DOCMD4P             GO ECHO THE COMMAND\n***********************************************************************\n*                                                                     *\n*        GO GET A LIST OF OUTSTANDING REPLIES                         *\n*                                                                     *\n***********************************************************************\nDOCMD4I  L     R1,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         CALL  REPLY               CALL THE SUBROUTINE\n***********************************************************************\n*                                                                     *\n*        FIND AN OUTSTANDING REPLY FOR THE SPECIFIED JOBNAME          *\n*                                                                     *\n***********************************************************************\nDOCMD4J  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         L     R14,JOBN            LOAD ADDRESS OF JOBNAME\n         L     R15,JOBNL           LOAD LENGTH OF JOBNAME\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETNAME         SET THE FULL JOB NAME\n         L     R3,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         USING MSGENT,R3           SET ADDRESSABILITY TO REPLY TABLE\nDOCMD4K  CLI   0(R3),X'FF'         END OF TABLE, BRANCH\n         BNE   DOCMD4L             NO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR04' SET ERROR FLAG\n         B     DOCMD4P             GO ECHO THE COMMAND\nDOCMD4L  CLC   JNAME,JOBNAME       SEE IF MATCH ON JOB NAME\n         BE    DOCMD4N             YES, BRANCH\nDOCMD4M  LA    R3,L'MSGENT(,R3)    INCREMENT TO NEXT REPLY TABLE ENTRY\n         B     DOCMD4K             LOOP\n***********************************************************************\n*                                                                     *\n*        SEE IF THIS REPLY CONTAINS THE SPECIFIED TEXT (IF ANY)       *\n*                                                                     *\n***********************************************************************\nDOCMD4N  LA    R14,MSG             POINT TO MESSAGE TEST\n         LA    R15,128             LOAD MESSAGE LENGTH\n         S     R15,MATCHL          CALCULATE LOOP COUNTER\n         L     R1,MATCHL           LOAD LENGTH OF MATCH TEXT\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         L     R2,MATCH            LOAD ADDRESS OF MATCH TEXT\n         CLC   MATCHL,=F'0'        SEE IF LENGTH OF TEXT = 0\n         BE    DOCMD4P             YES, USE THIS OUTSTANDING REPLY\n         CLC   MATCHL,=F'1'        SEE IF LENGTH OF TEXT = 1\n         BH    DOCMD4O             NO, BRANCH\n         CLI   0(R2),C'*'          SEE IF NULL MATCH TEXT\n         BE    DOCMD4P             YES, USE THIS OUTSTANDING REPLY\nDOCMD4O  EX    R1,COMPTEXT         SEE IF MATCH MESSAGE TEXT\n         BE    DOCMD4P             YES, BRANCH\n         LA    R14,1(,R14)         POINT TO NEXT CHARACTER OF TEXT\n         BCT   R15,DOCMD4O         LOOP\n         B     DOCMD4M             NO MATCH FOR TEXT, FIND ANOTHER MSG\nDOCMD4P  WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         CLC   COMDATA+4+72(8),=CL8' ' SEE IF ERROR HAS OCCURRED\n         BNE   DOCMD6              YES, DROP THIS REPLY COMMAND\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVI   COMDATA+4,C'R'      SET REPLY CHARACTER\n         LH    R1,RID              GET REPLYID (IN BINARY)\n         CVD   R1,DOUBLE           CONVERT TO DECIMAL\n         UNPK  DOUBLE(5),DOUBLE+5(3) UNPACK THIS\n         OI    DOUBLE+4,X'F0'      MAKE LAST BYTE PRINTABLE\n         MVC   COMDATA+4+2(4),DOUBLE+1 SET REPLY ID\n         MVI   COMDATA+4+6,C','    SET THE END OF THE REPLY ID\n         L     R1,REPLYTX          LOAD ADDRESS OF THE REPLY TEXT\n         ICM   R15,B'1111',REPLYTXL LOAD LENGTH OF REPLY TEXT\n         BZ    DOCMD5              ZERO, GO ISSUE THE NULL REPLY\n         MVI   COMDATA+4+7,C''''   SET START QUOTE FOR REPLY\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETREPLY        SET THE REPLY TEXT\n         LA    R15,COMDATA+4+8+1(R15) POINT PAST REPLY\n         MVI   0(R15),C''''        SET ENDING QUOTE FOR REPLY\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         B     DOCMD5              GO ISSUE THE REPLY\nSETNAME  MVC   JOBNAME(0),0(R14)   **** EXECUTE ONLY ****\nCOMPTEXT CLC   0(0,R14),0(R2)      **** EXECUTE ONLY ****\nSETREPLY MVC   COMDATA+4+8(0),0(R1) *** EXECUTE ONLY ****\n         DROP  R3                  DROP ADDRESSABILITY TO REPLY TABLE\n         SPACE 1\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE COMMAND                                            *\n*                                                                     *\n***********************************************************************\nDOCMD5   SLR   R0,R0               CLEAR REG ZERO\n         MODESET KEY=ZERO          GET INTO KEY ZERO\n         MGCR  COMDATA             ISSUE THE COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         MODESET KEY=NZERO         GET OUT OF KEY ZERO\nDOCMD6   BR    R10                 GO GET ANOTHER COMMAND\n         SPACE 1\nPACKTIME PACK  DOUBLE,COMDATA+10(0)  *** EXECUTE ONLY ***\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTANTS AND WORK AREAS.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         LTORG\n         SPACE 3\nSAVEAREA DS    18F                 REGISTER SAVE AREA\nGETADDR  DS    F                   ADDRESS OF OUTSTANDING REPLY TABLE\nREPLYWK  DC    CL80' '             REPLY COMMAND WORK AREA\nPARMS    DS    0F                  REPLY PARM PARSE LIST\nJOBN     DS    F                   ADDRESS OF JOB NAME\nJOBNL    DS    F                   LENGTH OF JOB NAME\nMATCH    DS    F                   ADDRESS OF REPLY TEXT TO MATCH\nMATCHL   DS    F                   LENGTH OF REPLY TEXT TO MATCH\nREPLYTX  DS    F                   ADDRESS OF ACTUAL REPLY TEXT\nREPLYTXL DS    F                   LENGTH OF ACTUAL REPLY TEXT\nDELIM    DC    C' '                TEXT SCAN DELIMETER\nJOBNAME  DS    CL8                 JOBNAME FOR REPLY SEARCH\nCOMDATA  DS    0F\n         DC    X'00'\n         DC    AL1(84)\n         DC    X'0000'\n         DC    C'123456789 123456789 123456789 123456789 123456789 1234X\n               56789 123456789 12        '\nDOUBLE   DS    D                   DOUBLE WORK WORK AREA\nWAITIME  DS    F                   DELAY TIME IN 1/100 SECONDS\n         PRINT NOGEN\nIEFRDER  DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GL,EODAD=EOF\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           R E P L Y                                 *\n*                                                                     *\n*        RETURN A LIST OF THE OUTSTANDING REPLIES IN A TABLE          *\n*        POINTED TO BY REGISTER 1 ON ENTRY.  THERE IS ROOM FOR        *\n*        100 OUTSTANDING REPLIES IN THE TABLE.  AN ENTRY WHICH        *\n*        STARTS WITH X'FF' WILL FLAG THE END OF THE REPLIES.          *\n*                                                                     *\n*        BECAUSE SOME OF THE STORAGE AREAS ARE ABOVE THE 16           *\n*        MEG LINE, THE ROUTINE WILL SWITCH TO AMODE31 IN THE          *\n*        BEGINNING AND SWITCH BACK TO AMODE 24 WHEN FINISHED.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           R1  - ADDRESS OF THE REPLY TABLE                          *\n*           R13 - ADDRESS OF A SAVE AREA                              *\n*           R15 - ENTRY POINT ADDRESS                                 *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           SAME AS ON ENTRY                                          *\n*                                                                     *\n***********************************************************************\nREPLY    CSECT\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             INITIALIZE FIRST BASE REGISTER\n         USING REPLY,R12           SET PROGRAM ADDRESSABILITY\n         LR    R15,R13             SAVE CALLING'S SAVE AREA ADDR\n         LA    R13,REPSAVE         LOAD ADDR OF NEW SAVE AREA\n         ST    R13,8(R15)          STORE NEW SAVE ADDR IN OLD\n         ST    R15,4(R13)          STORE OLD SAVE ADDR IN NEW\n         LA    R15,*+10            SET BRANCH ADDRESS\n         O     R15,=X'80000000'    SET AMODE31 BIT ON\n         BASSM R14,R15             GO TO AMODE 31\n***********************************************************************\n*                                                                     *\n*        FLAG END OF REPLY TABLE                                      *\n*                                                                     *\n***********************************************************************\n         MVI   0(R1),X'FF'         SET END OF TABLE INDICATOR\n         ST    R1,TBLADDR          SAVE REPLY TABLE ADDRESS\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE ASID NUMBER OF THE CONSOLE ADDRESS SPACE       *\n*                                                                     *\n***********************************************************************\nREPLY01  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R4,ASVTMAXU         LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R2,1                SET ADDRESS SPACE NUMBER TO ONE\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\nREPLY02  ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   REPLY03             ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF JOBNAME FIELD.\n         BZ    REPLY03             ZERO, BYPASS THIS ONE\n         CLC   0(8,R15),=C'CONSOLE ' IS THIS THE CONSOLE ADDRESS SPACE?\n         BE    REPLY04             YES, EXIT FROM LOOP.\nREPLY03  LA    R2,1(R2)            ADD 1 TO THE ASID\n         LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R4,REPLY02          LOOP\n         B     REPLY13             ERROR, GET OUT\nREPLY04  ST    R2,CONSASID         SAVE ASID OF CONSOLE ADDRESS SPACE.\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SET UP CROSS MEMORY SERVICES                                 *\n*                                                                     *\n***********************************************************************\nREPLY05  L     R10,TBLADDR         GET START OF REPLY TABLE\n         USING MSGDSECT,R10        SET ADDRESSABILITY TO REPLY ENTRY\n         SLR   R7,R7               SET MESSAGE COUNT TO ZERO\n         MODESET MODE=SUP,KEY=ZERO AUTHORIZE OURSELVES\n         ESAR  R9                  GET SECONDARY ASID\n         ST    R9,SASID            AND SAVE IT\n         AXSET AX=ONE              SET AX TO ALLOW SSAR\n         L     R9,CONSASID         GET 'CONSOLE' ASID\n         SSAR  R9                  SET 'CONSOLE' AS SECONDARY ASID\n***********************************************************************\n*                                                                     *\n*        GET THE CMS LOCK SO THAT THE OUTSTANDING REPLY               *\n*        ELEMENT (ORE) CHAIN WILL NOT BE ALTERED DURING               *\n*        OUR PROCESSING.                                              *\n*                                                                     *\n***********************************************************************\nREPLY06  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE\n         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*          GET THE ADDRESS OF THE FIRST OUTSTANDING REPLY             *\n*          ELEMENT (ORE)                                              *\n*                                                                     *\n***********************************************************************\nREPLY07  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R4,CVTCUCB          R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         USING UCM,R4              SET ADDRESSABILITY TO UCM BASE\n         L     R2,UCMRPYQ          LOAD ADDRESS OF FIRST ORE\n         LTR   R2,R2               TEST ORE ADDRESS\n         BZ    REPLY12             ZERO, NO OUTSTANDING REPLIES\n         DROP  R4                  DROP ADDRESSABILITY TO UCM BASE\n         USING OREF,R2             SET ADDRESSABILITY TO ORE\n***********************************************************************\n*                                                                     *\n*          COPY THE WTO QUEUE ELEMENT (WQE) FROM THE CONSOLE          *\n*          ADDRESS SPACE FOR THE CURRENT ORE                          *\n*                                                                     *\n***********************************************************************\nREPLY08  L     R8,ORERWQE          R8 = ADDR OF WQE\n         LA    R4,WQECOPY          R4 = ADDR OF COPY OF WQE\n         LA    R5,WQESIZE          R5 = SET LENGTH OF WQE\n         SLR   R15,R15             SET 'FROM' KEY TO ZERO\nREPLY09  MVCP  0(R5,R4),0(R8),R15  MOVE UP TO 256 BYTES\n         BZ    REPLY10             CC=0 - DONE\n         LA    R4,256(,R4)         INCREMENT 'TO' ADDRESS\n         LA    R8,256(,R8)         INCREMENT 'FROM' ADDRESS\n         SH    R5,=H'256'          SUBTRACT LENGTH OF LAST MOVE\n         B     REPLY09             GO GET REST OF AREA\nREPLY10  LA    R4,WQECOPY          RESTORE ADDRESS OF COPY OF WQE\n         USING WQE,R4              SET ADDRESSABILITY TO WQE\n***********************************************************************\n*                                                                     *\n*          SAVE THE REPLY JOBNAME, MSGID, AND ACTUAL MESSAGE          *\n*          FROM THE WQE                                               *\n*                                                                     *\n***********************************************************************\nREPLY11  EQU   *\n         TM    WQEFLG2,WQEFORN     IS THIS WTOR FROM ANOTHER SYSTEM\n         BO    REPLYBAD            YEAH - THEN JUST JUMP AROUND\n         MVI   MSGENT,C' '         BLANK THE ENTIRE\n         MVC   MSGENT+1(L'MSGENT-1),MSGENT   MESSAGE AREA\n         MVC   JNAME,WQEOJBNM      SAVE JOB NAME\n         MVC   RID,WQERPYIB+2      SAVE REPLY ID (LAST 2 BYTES)\n         MVC   MSG,WQETXT          SAVE MESSAGE TEXT\n*\n         LA    R7,1(,R7)           ADD 1 TO MESSAGE COUNT\n         LA    R10,L'MSGENT(,R10)  INCREMENT TO NEXT MESSAGE AREA\n*\nREPLYBAD EQU   *\n         MVI   0(R10),X'FF'        SET END OF TABLE INDICATOR\n         CH    R7,=H'100'          SEE IF REACHED MAXIMUM\n         BNL   REPLY12             YES, GET OUT\n         L     R2,ORELKP           LOAD ADDRESS OF NEXT ORE\n         LTR   R2,R2               SEE IF ANY MORE ORE'S\n         BNZ   REPLY08             YES, LOOP\n         DROP  R2                  DROP ADDRESSABILITY TO ORE\n         DROP  R4                  DROP ADDRESSABILITY TO WQE\n         DROP  R10                 DROP ADDRESSABILITY TO REPLY TABLE\n***********************************************************************\n*                                                                     *\n*        FREE THE CMS LOCK SO THAT NORMAL CONSOLE MESSAGE             *\n*        PROCESSING CAN CONTINUE                                      *\n*                                                                     *\n***********************************************************************\nREPLY12  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK RELEASE,TYPE=CMS,REGS=SAVE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*        GET OUT OF CROSS MEMORY MODE                                 *\n*                                                                     *\n***********************************************************************\n         L     R9,SASID            RESTORE PREVIOUS SECONDARY ASID\n         SSAR  R9                  SHOULD BE SAME AS PRIMARY\n         AXSET AX=ZERO             SET AUTHORIZATION INDEX BACK TO ZERO\n         MODESET MODE=PROB,KEY=NZERO UNAUTHORIZE OURSELVES\n***********************************************************************\n*                                                                     *\n*        RETURN TO THE CALLER                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nREPLY13  LA    R15,*+6             SET BRANCH ADDRESS\n         BASSM R14,R15             GO TO AMODE 24\n         L     R13,4(R13)          RESTORE ORIG SAVE AREA ADDRESS\n         RETURN (14,12)            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n         LTORG\nREPSAVE  DS    18F                 PROGRAM SAVE AREA\nCONSASID DC    F'0'                ASID OF CONSOLE ADDRESS SPACE\nTBLADDR  DS    F                   ADDRESS OF REPLY TABLE\nSASID    DS    F                   SAVE PREVIOUS SECONDARY ASID\nONE      DC    H'1'                TO SET AX 1\nZERO     DC    H'0'                TO SET AX 0\n         DS    0F\nWQECOPY  DS    CL512               LOCAL COPY OF WQE\n         EJECT\nMSGDSECT DSECT\nMSGENT   DS    0CL138\nJNAME    DS    CL8\nRID      DS    CL2\nMSG      DS    CL128\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IEECUCM DSECT=YES,FORMAT=NEW,LIST=YES\n         EJECT\n         IHAASVT DSECT=YES\n         EJECT\n         IHAASCB DSECT=YES\n         EJECT\n         IHAORE DSECT=YES\n         EJECT\n         IHAWQE DSECT=YES,FORMAT=OLD\n         EJECT\n         IHAPSA DSECT=YES,LIST=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DALLOC": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x90\\x07_\\x00\\x92\\x13\\x9f\\x11%\\x01=\\x00\\xbc\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1990-03-16T00:00:00", "modifydate": "1992-05-18T11:25:00", "lines": 317, "newlines": 188, "modlines": 0, "user": "$VNV"}, "text": "*\n         TITLE 'DALLOC - LIST DYNAMIC DATASET ALLOCATIONS'\n**********************************************************************\n*                                                                    *\n*   NAME      -   DALLOC                                             *\n*                                                                    *\n*   AUTHOR    -   C. LYONS                                           *\n*                                                                    *\n*   FUNCTION  -   LIST DYNAMICALLY ALLOCATED DATASETS                *\n*                                                                    *\n*   OUTPUT    -   DSNAME   DDNAME   DISP   VOLSER   CUU              *\n*                                                                    *\n*   ATTRIB    -   RENT                                               *\n*                                                                    *\n*   SYSTEM    -   MVS 3.8 AND MVS/SE2                                *\n*                                                                    *\n*   DATE      -   12/09/80                                           *\n*                                                                    *\n*   MACROS    -   FULLSAVE,GETMAIN,FREEMAIN,TPUT,FULLRTRN            *\n*                                                                    *\n*   DSECTS    -   WORK,IHAPSA,IKJTCB,IEZJSCB,IHADSAB,QDB,TIOT        *\n*                 IEFJFCBN,IEFUCBOB                                  *\n*                                                                    *\n*   REGISTERS -   R12=BASE; R13->SAVE AREA; R3->DSAB; R4->TIOT;      *\n*                 R5->UCB; R6->JFCB                                  *\n*                                                                    *\n*   LANGUAGE  -   VS ASSEMBLER                                       *\n*                                                                    *\n*   PRIVILEGE -   PROBLEM PROGRAM                                    *\n*                                                                    *\n*   LOGIC     -   1. ENTRANCE CONVENTIONS                            *\n*                 2. FIND DSAB CHAIN                                 *\n*                 3. SCAN DSAB CHAIN, EXTRACTING INFORMATION:        *\n*                                                                    *\n*                         DSNAME  FROM  JFCB                         *\n*                         DDNAME  FROM  TIOT                         *\n*                         DISP    FROM  JFCB                         *\n*                         VOLSER  FROM  UCB                          *\n*                         CUU     FROM  UCB                          *\n*                                                                    *\n*                 4. EXIT CONVENTIONS                                *\n*                                                                    *\n*  INSTALL    -   ASSEMBLE DALLOC                                    *\n*                 LINK DALLOC RENT REUS REFR                         *\n*                 PLACE DALLOC IN LINKLIST LIBRARY OR PLPA           *\n*                                                                    *\n**********************************************************************\n*                                                                    *\n*   CHG - 5/12/92 - VINH VU - CHANGES TO ALLOW FOR SWA TO BE ABOVE   *\n*        THE LINE (SWA=ABOVE IN JES2 PARMS).                         *\n*        ALSO ADD THE DISPLAY OF THE DSORG FOR EACH DATA SET.        *\n*                                                                    *\n**********************************************************************\n         TITLE 'DALLOC - INITIALIZATION'\nDALLOC   CSECT\n         SET   DSECT=WKAREA,LV=WKLENG\n         MVI   ALLOCMSG,C' '           CLEAR ALLOCATION MESSAGE\n         MVC   ALLOCMSG+1(L'ALLOCMSG-1),ALLOCMSG\n         MVI   HEADING,X'0'            CLEAR PRINT HEADING INDICATOR\n         TITLE 'DALLOC - FIND DSAB CHAIN'\n*\n*   PSA->TCB->JSCB->QDB->DSAB->JFCB->TIOT->UCB\n*\n         USING PSA,R0\n         L     R1,PSATOLD              TCB\n         USING TCB,R1\n         L     R1,TCBJSCB              JSCB\n         USING IEZJSCB,R1\n         L     R1,JSCDSABQ             QDB\n         USING QDB,R1\n         L     R2,QDBNELMS             ARE THERE ANY ALLOC DATASETS?\n         LTR   R2,R2\n         BNZ   GETDSAB\n         TPUT  NOALLOC,40              NO, TELL USER AND EXIT\n         B     EXIT\n*\nGETDSAB  EQU   *\n         L     R3,QDBFELMP             DSAB\n         DROP  R1\n         TITLE 'DALLOC - SCAN DSAB CHAIN'\n         USING DSAB,R3\n*\nDSABLOOP EQU   *\n         TM    DSABFLG1,DSABDALC       DYNAMICALLY ALLOCATED?\n         BZ    NEXTDSAB\n         CLI   HEADING,PRTHEAD         HAS THE HEADING BEEN PRINTED?\n         MVI   HEADING,HEADPRT         SAY IT HAS NOW\n         BNE   GETTIOT                 AND PRINT IT IF NECESSARY\n         LA    R0,L'TITLEMSG\n         LA    R1,TITLEMSG\n         TPUT  (1),(0),R\n         LA    R0,L'TITLEMSG\n         LA    R1,UNDERLNE\n         TPUT  (1),(0),R\n*\nGETTIOT  EQU   *\n         L     R4,DSABTIOT             TIOT\n         USING TIOELNGH,R4\n         ICM   R5,7,TIOEFSRT           UCB\n         USING UCBCMSEG,R5\n*\n*\n         USING INFMJFCB,R6\n*\n         ICM   R15,B'1111',AMOVEIT     GET ADDR OF THE 31BIT ROUTINE\n         BASSM R14,R15                 GET & MOVE JFCB TO BELOW 16M\n         B     GOODJFCB\n*\n*\n*\nMOVE31   EQU   *\n         ST    R14,RETURN24        SAVE R14 FOR RETURNING ADDRESS\n         LA    R15,EPAEXT          GET ADDR OF EPA\n         ST    R15,SWEPAPTR        STORE IT AWAY\n         USING SWAEPAX,R15         ESTAB ADDR\n         XC    SWAEPAX,SWAEPAX     CLEAR THE AREA AT FIRST\n         MVC   SWVA,TIOEJFCB       MOVE TOKEN TO WORK AREA\n         DROP  R15\n         SWAREQ FCODE=RL,UNAUTH=YES,EPA=SWEPAPTR,MF=(E,SWLIST)\n         LTR   R15,R15\n         BZ    SWAGOOD\n         ABEND 999,DUMP\n*\nSWAGOOD  EQU   *\n         LA    R15,EPAEXT          GET ADDR OF EPA\n         USING SWAEPAX,R15         ESTAB ADDR\n         L     R6,SWBLKPTR         GET JFCB ADDRESS IN R6\n         DROP  R15\n         MVC   WKJFCB,0(R6)    MOVE JFCB TO BELOW 16M\n         LA    R6,WKJFCB       POINT R6 TO THE NEW WK JFCB AREA\n         L     R14,RETURN24    RESTORE RETURN ADDRESS\n         BSM   0,R14           BACK TO CALLING ROUTINE\n*\n*\nGOODJFCB EQU   *\n         MVC   DSNAME,JFCBDSNM         SAVE DSNAME\n         MVC   DDNAME,TIOEDDNM         SAVE DDNAME\n*\n         MVC   DSORG,=CL2' '\n*\n         TM    JFCDSRG1,JFCORGIS       ISAM ??\n         BZ    CKPS\n         MVC   DSORG,=CL2'IS'\n         B     DSORGOK\n*\nCKPS     EQU   *\n         TM    JFCDSRG1,JFCORGPS       PHYSICAL SEQUENTIAL ?\n         BZ    CKDA\n         MVC   DSORG,=CL2'PS'\n         B     DSORGOK\n*\nCKDA     EQU   *\n         TM    JFCDSRG1,JFCORGDA       DA ?\n         BZ    CKPO\n         MVC   DSORG,=CL2'DA'\n         B     DSORGOK\n*\nCKPO     EQU   *\n         TM    JFCDSRG1,JFCORGPO       PARTITIONED ?\n         BZ    CKVS\n         MVC   DSORG,=CL2'PO'\n         B     DSORGOK\n*\nCKVS     EQU   *\n         TM    JFCDSRG2,JFCORGAM       VSAM ?\n         BZ    DSORGOK\n         MVC   DSORG,=CL2'VS'\n         B     DSORGOK\n*\nDSORGOK  EQU   *\n         CLC   DSNAME(9),NULLFILE      DUMMY DATASET?\n         BE    BLANKOUT\n*\nSYSOUT   EQU   *\n         TM    JFCBTSDM,JFCSDS         SYSOUT/SYSIN DATASET?\n         BZ    REGDSN\n*\nBLANKOUT EQU   *\n         MVC   VOLSER,HYPHENS\n         MVC   CUU,HYPHENS\n         B     SETDISP\n*\nREGDSN   EQU   *\n         CLI   JFCBELNM,C' '           MEMBER NAME PRESENT?\n         BE    NOMEMBER\n         TRT   DSNAME(35),BLANK        YES, SAVE IT\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCBELNM        DSN(MEMBER)\n         TRT   2(8,R1),BLANK\n         MVI   0(R1),C')'\n*\nNOMEMBER EQU   *\n         MVC   VOLSER,UCBVOLI          SAVE VOLSER\n         MVC   CUU,UCBNAME             SAVE UNITNAME\n*\nSETDISP  EQU   *\n         TM    JFCBIND2,JFCSHARE       DISP=SHR?\n         BZ    TRYNEW\n         MVC   DISP,SHRDSN             YES, SAY DISP=SHR\n         B     TERMOUT\n*\nTRYNEW   EQU   *\n         TM    JFCBIND2,JFCNEW         DISP=NEW?\n         BNO   TRYMOD\n         MVC   DISP,NEWDSN             YES, SAY DISP=NEW\n         B     TERMOUT\n*\nTRYMOD   EQU   *\n         TM    JFCBIND2,JFCMOD         DISP=MOD?\n         BZ    TRYOLD\n         MVC   DISP,MODDSN             YES, SAY DISP=MOD\n         B     TERMOUT\n*\n*\nTRYOLD   EQU   *\n         TM    JFCBIND2,JFCOLD         DISP=OLD?\n         BZ    TERMOUT\n         MVC   DISP,OLDDSN             YES, SAY DISP=OLD\n*\nTERMOUT  EQU   *\n         LA    R1,ALLOCMSG\n         LA    R0,L'ALLOCMSG\n         TPUT  (1),(0),R               OUT TERMINAL MESSAGE\n*\nNEXTDSAB EQU   *\n         L     R3,DSABFCHN             FORWARD DSAB CHAIN\n         LTR   R3,R3\n         BNZ   DSABLOOP                LOOP THROUGH DSABS\n         TITLE 'DALLOC - EXIT'\n*\nEXIT     EQU   *\n         EXIT\n*\n*\n*\n         TITLE 'DALLOC CONSTANTS'\n*\nAMOVEIT  DC    X'80',AL3(MOVE31)\n*\nHYPHENS  DC    C'--------'\nNULLFILE DC    CL9'NULLFILE '\nBLANK    DC    (C' ')X'0',C' ',(255-C' ')X'0'\nNEWDSN   DC    CL4'NEW'\nOLDDSN   DC    CL4'OLD'\nSHRDSN   DC    CL4'SHR'\nMODDSN   DC    CL4'MOD'\nNOALLOC  DC    CL40'NO DYNAMICALLY ALLOCATED DATASETS'\nTITLEMSG DS    0CL78\n         DC    C' '\n         DC    CL6'DSNAME'\n         DC    CL40' '\n         DC    CL8'DDNAME'\n         DC    CL2' '\n         DC    CL2'DS'\n         DC    CL2' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL6'VOLSER'\n         DC    CL2' '\n         DC    CL3'CUU'\nUNDERLNE DC    C' ',6C'-',CL40' ',6C'-',CL4' ',2C'-',CL2' ',4C'-'\n         DC    CL2' ',6C'-',CL2' ',3C'-'\n         TITLE 'DALLOC - DSECTS'\nWKAREA   DSECT\n         DS    18F\n*\nSWLIST   SWAREQ MF=L\n*\nEPAEXT   DS   CL28\nSWEPAPTR DS   F\nRETURN24 DS   F\nWKJFCB   DS   CL(JFCBLGTH)\n*\n*\nALLOCMSG DS   0CL78\nOPFLAG   DS   CL1\nDSNAME   DS   CL44\n         DS   CL2\nDDNAME   DS   CL8\n         DS   CL2\nDSORG    DS   CL2\n         DS   CL2\nDISP     DS   CL4\n         DS   CL2\nVOLSER   DS   CL6\n         DS   CL2\nCUU      DS   CL3\nHEADING  DS   X\nPRTHEAD  EQU  X'00'\nHEADPRT  EQU  X'FF'\nWKLENG   EQU  *-WKAREA\n         EJECT\n         PRINT NOGEN\n         IHAPSA\n         IKJTCB\n         IEZJSCB\n         PRINT GEN\n         IHADSAB\n         EJECT\n         IEFJFCBN LIST=YES\n         EJECT\n         IEFUCBOB\n         EJECT\n         IEFZB505 LOCEPAX=YES\n         PRINT NOGEN\n         IEFJESCT\n         CVT  DSECT=YES\n*\nTIOT     DSECT\n         IEFTIOT1\nQDB      DSECT\nQDBQDB   DS    CL4\nQDBATTR  DS    XL2\nQDBRV001 DS    XL2\nQDBNELMS DS    F\nQDBFELMP DS    A\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATE": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x14\\x0f\\x00\\x92\\x14\\x0f\\x17\\x04\\x01\\xc3\\x01\\xc3\\x00\\x00[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-19T00:00:00", "modifydate": "1992-05-19T17:04:00", "lines": 451, "newlines": 451, "modlines": 0, "user": "$WKS"}, "text": "//PTEC2201  JOB (8351,RTSP),CLASS=I,MSGCLASS=X,NOTIFY=PTEC220\n/*JOBPARM   R=403\n//ASM1      EXEC PGM=IEUASM,PARM='LOAD,NODECK,RENT'\n//SYSPRINT    DD SYSOUT=*\n//SYSLIB      DD DSN=SYS1.SMPMTS,DISP=SHR,UNIT=SYSDA,VOL=SER=SYSRSA\n//            DD DSN=SYS1.SMPSTS,DISP=SHR,UNIT=SYSDA,VOL=SER=SYSRSA\n//            DD DSN=SYS1.HASPSRC,DISP=SHR\n//            DD DSN=SYS1.MACLIB,DISP=SHR\n//            DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT2      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT3      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSIN       DD *\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              EXIT1                                    *\n*                                                                     *\n*  MODULE TYPE:              JES2 MAIN TASK SEP PAGE EXIT             *\n*                                                                     *\n*  LOAD MODULE NAME:         EXIT1                                    *\n*                                                                     *\n*  LOAD LIBRARY:             SYS2.LINKLIB                             *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     RENT                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          RENT                                     *\n*                                                                     *\n*  MODULE AUTHORIZATION:     JES2                                     *\n*                                                                     *\n*  MACROS:                   REF: JES2 MODS AND MACS                  *\n*                                                                     *\n*  MACRO LIBRARIES:          SYS1.HASPSRC, SYS1.MACLIB                *\n*                                                                     *\n*  ABENDS:                   NONE                                     *\n*                                                                     *\n*  FUNCTION:                 FORMAT AND PRINT A SEP PAGE FOR PRINT    *\n*                                                                     *\n*  PARAMETERS:               REF: JES2 MODS AND MACS                  *\n*                                                                     *\n*  INTERNAL TABLES:          NONE                                     *\n*                                                                     *\n*  CALLED MODULES:           RBDATE: FORMAT DATE/TIME ROUTINE         *\n*                                                                     *\n*  CALLING MODULES:          REF: JES2 MODS AND MACS                  *\n*                                                                     *\n*  PROGRAM FLOW:                                                      *\n*                                                                     *\n*                                                                     *\n*  PARAMETER LAYOUTS:        REF: JES2 MODS AND MACS                  *\n*                                                                     *\n*                                                                     *\n*  COPYRIGHT:                REPUBLIC BANK DALLAS                     *\n*                            JUNE 15, 1985                            *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN, INFORMATION SERVICES       *\n*                            (214)-653-7794                           *\n*                            REPUBLIC BANK DALLAS                     *\n*                            P.O. BOX 225961                          *\n*                            DALLAS ,  TEXAS   75265                  *\n*                                                                     *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 06-15-85 KIRK STICKEN        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         COPY  $HASPGBL                .  COPY THOSE HASP GLOBALS\nSAMPUEX  $MODULE SYSP=(NOGEN,GEN,NODATA,NOGEN,NOGEN),                  X\n               TITLE='JES2 PRINT SEPARATOR PAGE',                      X\n               ENVIRON=JES2,                                           X\n               PSA,                    .                               X\n               CVT,                    .                               X\n               SMCA,                   .                               X\n               $BUFFER,                .                               X\n               $CAT,                   .                               X\n               $DCT,                   .                               X\n               $HASPEQU,               .                               X\n               $HCT,                   .                               X\n               $JCT,                   .                               X\n               $JOE,                   .                               X\n               $JQE,                   .                               X\n               $MIT,                   .                               X\n               $PCE,                   .                               X\n               $PDDB,                  .                               X\n               $PPPWORK                .\nRBDEXIT  $ENTRY BASE=R12,CSECT=YES     .  ENTER A JES2 USER EXIT\n         $SAVE                         .  STD SAVE PROTOCOL\n         LR    R12,R15                 .  SET ADDRESS OF THE EXIT\n         LR    R8,R1                   . GET THE DCT POINTER\n         USING DCTDSECT,R8             .    AND ADDRESS THE DCT ALSO\n         SLR   R15,R15                 .  PRESET VALID RETURN CODE\n         TM    PCEID,PCEPUSID          .  IS THIS A PUNCH DEVICE?\n         BO    RETURN                  .      YOU GOT IT SHERLOCK\n         TM    DCTPPSW,DCTPPSWS        . ARE SEP PAGES REQUESTED\n         BO    RETURN                  .    NO, GO HOME\n         TM    DCTPPSW9,DCT9700        . IS THIS THE 9700\n         BO    RETURN                  .    YES, DO NOT REPEAT PAGE\nBEGIN    DS    0H                      .\n         LR    R5,R0                   . SAVE ENTRY CODE\n         L     R3,PCEUSER0             . GET PCEUSER SPECIAL SAVE FLD\n         C     R3,$ZEROS               . WERE WE INTERRUPTED?\n         BNE   OK                      .    YES WE WERE, CONTINUE\n         $GETBUF TYPE=HASP,FIX=YES,WAIT=YES . GET A HASP WORK BUFFER\n         LR    R3,R1                   . COPY ADDRESS OF BUFFER\n         USING BUFDSECT,R3             .      SO WE CAN USE IT HERE\n         ST    R3,PCEUSER0             . SAVE FIXED BUFFER PTR\nOK       LA    R4,BUFSTART             . REFERENCE OUR WORK AREA\n         USING WORK3,R4                . ADDRESS WORKING STORAGE\n         TM    MDCTFEAT,DCTPSHDR       . IS THIS SNA TERM ?\n         BNO   NOSNA                   .    NO, SKIP PDIR COMMAND\n         $SEPPDIR (R3)                 . SEND PDIR IN CASE SNA RMT\nNOSNA    DS    0H                      . SO WE FINALLY GOT HERE!!\n         LA    R0,JCTJNAME             . GET JOBNAME FROM JCT\n         $PBLOCK BUFFER=(R3),DATA=(R0),SLANT=YES,CENTER=YES . BLOCK IT\n         MVI   MSG,C' '                . PRINT ONE SPACE\n         LA    R1,MSG                  . GET ADDRESS FOR LINE PRINT\n         LA    R0,1                    .     AND BUFFER LENGTH\n         $PRPUT DATA=(R1),LEN=(R0),COUNT=03,WAIT=YES . CLEAR 3 LINES\n         MVC   DCTUSER0(8),=CL8'BIN#'  . CLEAR EIGHT BYTES IN WORK AREA\n         MVC   DCTUSER1(4),JCTROOMN    .    AND MOVE IN BIN NUMBER\n         LA    R0,DCTUSER0             . PERPARE TO BLOCK BIN NUMBER\n         $PBLOCK BUFFER=(R3),DATA=(R0),SLANT=YES,CENTER=YES . BLOCK IT\n         MVI   MSG,C' '                . PRINT ONE SPACE\n         LA    R1,MSG                  . GET ADDRESS FOR LINE PRINT\n         LA    R0,1                    .     AND BUFFER LENGTH\n         $PRPUT DATA=(R1),LEN=(R0),COUNT=02,WAIT=YES . CLEAR 2 LINES\n         L     R7,PWKJOE               .  ADDRESS THE CURRENT JOE\n         USING JOEDSECT,R7             .     AND ADDRESS IT\n         MVC   MSG,TEMPLATE            . INIT BUFFER AREA\n         MVC   MSG+TJOB-TEMPLATE(L'TJOB),JCTJNAME  . MOVE JOBNAME\n         MVC   MSG+TCLASS1-TEMPLATE(L'TCLASS1),JOECURCL  . MOVE CLASS\n         MVC   MSG+TCLASS2-TEMPLATE(L'TCLASS2),JOECURCL  . MOVE CLASS\n         SLA   R5,1                    . MULT ENTRY CODE BY 2\n         LA    R5,TYPES(R5)            . INDEX TO TYPE CODE\n         MVC   MSG+TYPE-TEMPLATE(L'TYPE),0(R5)  AND MOVE IT IN\n         MVC   MSG+TYPE2-TEMPLATE(L'TYPE),0(R5) AND MOVE IT IN\n         MVC   MSG+TJID1-TEMPLATE(L'TJID1),JCTJOBID . MOVE IN JOBID\n         MVC   MSG+TJID2-TEMPLATE(L'TJID2),JCTJOBID . MOVE IN JOBID\n         MVC   MSG+TNAME-TEMPLATE(L'TNAME),JCTPNAME . MOVE IN PROG NAME\n         MVC   MSG+TROOM-TEMPLATE(L'TROOM),JCTROOMN . MOVE IN BIN #\n         LA    R15,MSG+TTIME-TEMPLATE  . GET ADDRESS OF TIME\n         ST    R15,PLIST               .       PUT IT IN PLIST\n         LA    R15,MSG+TDATE-TEMPLATE  . GET ADDRESS OF DATE\n         ST    R15,PLIST+4             .       PUT IT IN PLIST\n         LA    R15,USERWORK            . GET USER STORAGE AREA\n         O     R15,=X'80000000'        .       SAY LAST PARM\n         ST    R15,PLIST+8             .           AND PUT IN PLIST\n         LA    R1,PLIST                .  STD REG PARMS\n         L     R15,=V(RBDATE)          .      AND CALL DATE ROUTINE\n         BALR  R14,R15                 .           NOW\n         MVC   MSG+TPRID-TEMPLATE(L'TPRID),DCTDEVN . MOVE IN PRINTER NM\n         L     R1,16                   . GET CVT IN R1\n         L     R1,CVTSMCA-CVT(R1)      . GET SMCA\n         MVC   MSG+TSYS-TEMPLATE(L'TSYS),SMCASID-SMCA(R1) . MOVE SYSTEM\nDOPUT    DS    0H                      .\n         SLR   R9,R9                   .\n         IC    R9,$PRIDCT              . GET LOCAL LINES PER SEP PAGE\n         TM    DCTDEVTP,DCTPRT         . IS LOCAL PRINTER\n         BO    LOCAL                   .\n         IC    R9,$TPIDCT              . GET REMOTE LINE COUNT INSTEAD\nLOCAL    S     R9,=F'30'               .   MINUS PRINTED LINES +1\n         C     R9,$ZEROS               . IS PERHAPS NEGATIVE?\n         BH    OKAGAIN                 .    NO, IS OK\n         L     R9,$F8                  .   YES, MAKE 8 THE DEFAULT\nOKAGAIN  DS    0H                      .\n         BALR  R2,R0                   .\nLOOP     LA    R0,L'MSG                .\n         LA    R1,MSG                  .\n         $PRPUT DATA=(R1),LEN=(R0),COUNT=1,WAIT=NO  PRINT A LINE\n         BCTR  R9,R2                   . LOOP UNTIL DONE\n         LA    R0,L'MSG                .\n         LA    R1,MSG                  .\n         $PRPUT DATA=(R1),LEN=(R0),COUNT=1,WAIT=YES PRINT LAST LINE\n         $FREEBUF (R3)                 . FREE HASP BFR AND WORK AREA\n         SLR   R15,R15                 . CLEAR REGISTER\n         ST    R15,PCEUSER0            . RESET OUR WORK POINTER\n         DROP  R3,R4                   .\n         LA    R15,8                   . DO NOT PRINT JES2 SEPARATOR\nRETURN   EQU   *\n         $RETURN RC=(R15)              .  GO BACK TO JES WITH RC\nTYPES    DC    CL8'START'              .  ENTRY CODE = 0\n         DC    CL8'CONT'               .  ENTRY CODE = 4\n         DC    CL8'END'                .  ENTRY CODE = 8\nTEMPLATE DC    CL132' '                .  INITIAL TEMPLATE DATA\n         ORG   TEMPLATE                .\n         DC    CL4'****'               .  FIRST BOUNDARY\nTCLASS1  DS    CL1                     .  OUTPUT CLASS\n         DC    CL2' '                  .\nTYPE     DS    CL5                     .  SEPARATOR TYPE(START,END)\n         DC    CL2' '                  .\nTJID1    DS    CL8                     .  JOB ID\n         DC    CL2' '                  .\nTJOB     DS    CL8                     .  JOB NAME\n         DC    CL2' '                  .\nTNAME    DS    CL20                    .  PROGRAMMER NAME\n         DC    CL2' '                  .\n         DC    CL4'BIN#'               .\nTROOM    DS    CL4                     .  ROOM NUMBER\n         DC    CL2' '                  .\nTTIME    DS    CL12                    .  PRINTER TIME\nTDATE    DS    CL10                    .  DATE (DD MMM YY)\n         DC    CL2' '                  .\nTPRID    DS    CL8                     . PRINTER ID\n         DC    CL2' '                  .\n         DC    CL4'SYS '               .\nTSYS     DS    CL4                     . JES2 SYSTEM CPU ID\n         DC    CL2' '                  .\nTJID2    DS    CL8                     . JOB ID 2\n         DC    CL2' '                  .\nTYPE2    DS    CL5                     .\n         DC    CL2' '                  .\nTCLASS2  DS    CL1                     . SECOND OCCURRENCE OF JOB CLASS\n         DC    CL4'****'               .\nTPLEN    EQU   *-TEMPLATE              .\n         ORG   ,                       .\n         LTORG                         .\nWORK3    DSECT                         .\nMSG      DS    CL(TPLEN)               .\nPLIST    DS    5F                      .\n         DS    0D                      .\nUSERWORK DS    CL256                   .\nWORKLEN  EQU   *-MSG                   .\n         PUSH  USING                   .\nRBDATE   CSECT\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              RBDATE                                   *\n*                                                                     *\n*  MODULE TYPE:              JES2 EXIT SUBROUTINE                     *\n*                                                                     *\n*  LOAD MODULE NAME:         RBDATE                                   *\n*                                                                     *\n*  LOAD LIBRARY:             SYS1.LINKLIB                             *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     RENT                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          RENT                                     *\n*                                                                     *\n*  MODULE AUTHORIZATION:     JES2                                     *\n*                                                                     *\n*  MACROS:                   NONE                                     *\n*                                                                     *\n*  MACRO LIBRARIES:          NONE                                     *\n*                                                                     *\n*  ABENDS:                   NONE                                     *\n*                                                                     *\n*  FUNCTION:                 FORMAT DATE AND TIME                     *\n*                                                                     *\n*  PARAMETERS:               TIME,DATE,WORKAREA                       *\n*                                                                     *\n*  INTERNAL TABLES:          MONTAB: TABLE OF MONTH NAMES             *\n*                                                                     *\n*  CALLED MODULES:           NONE                                     *\n*                                                                     *\n*  CALLING MODULES:          HASPXIT1                                 *\n*                                                                     *\n*  PROGRAM FLOW:             FORMAT TIME                              *\n*                            CONVERT JULIAN TO GREGORIAN DATE         *\n*                                                                     *\n*  PARAMETER LAYOUTS:        NONE                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN, INFORMATION SERVICES       *\n*                            (214)-653-7794                           *\n*                            REPUBLIC BANK DALLAS                     *\n*                            P.O. BOX 225961                          *\n*                            DALLAS ,  TEXAS   75265                  *\n*                                                                     *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 05-06-85 KIRK STICKEN        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         B     START1-RBDATE(R15)      .  BRANCH AROUND CONSTANT\n         DC    AL1(L'@ID)              .  DEFINE ID LENGTH\n@ID      DC    C'RBDATE'               .  DEFINE PROGRAM ID\n         DC    C'_&SYSDATE._&SYSTIME._REPUBLIC_BANK_DALLAS'\n*   THE JULIAN DATE CONVERSION ALGORITHM COMES FROM THE CACM.\n*   ALGORITHM 398: TABLELESS DATE CONVERSION\n*\n*   PROCEDURE CALENDAR(Y,N,M,D);\n*     VALUE Y,N:  INTEGER Y, N, M, D, T;\n*     COMMENT Y IS YEAR, N IS DAY OF YEAR. M IS MONTH, D IS DAY OF\n*             MONTH. M AND D ARE CALCULATED FOR YOU;\n*     BEGIN\n*       T:= IF(Y/4)*4=Y THEN 1 ELSE 0;\n*       T:=IF(Y/400)*400=Y OR (Y/100)*100 NOT=Y THEN T ELSE 0;\n*       D:=N+(IF N>(59+T) THEN 2-T ELSE 0);\n*       M:=((D+91*100)/3055;\n*       D:=(D+91) - (M*3055)/100;\n*       M:=M-2;\n*     END CALENDAR;\n*\n*\nSTART1   DS    0H                      .\n         STM   R14,R12,12(R13)         .  SAVE MASTERS REGISTERS\n         LR    R12,R15                 .  SET UP BASE ADDRESS\n         USING RBDATE,R12              .  AND USE TO RUN WITH\n         USING PARM1,R5                .\n         USING PARM2,R6                .\n         USING PARM3,R7                .\n         LM    R5,R7,0(R1)             .  LOAD 3 PARMS\n         LA    R8,SAVE2                .  GET OUR SAVE AREA\n         ST    R8,8(R13)               .  STORE OURS THERE\n         ST    R13,4(R8)               .  STORE THEIRS HERE\n         LR    R13,R8                  .  STANDARD REGISTER CONVENTIONS\n         MVI   WTIME,C' '              .\n         MVC   WTIME+1(L'WTIME-1),WTIME . BLANK OUT FIELD\n         MVI   WDATE,C' '              .\n         MVC   WDATE+1(L'WDATE-1),WDATE . BLANK OUT FIELD\nTIME1    TIME  DEC                     .  GET SYSTEM DATE AND TIME\n         ST    R1,DATE1                .    AND SAVE THE DATE\n         O     R0,=F'15'               .  SET PACKED SIGN\n         ST    R0,TIME2                .    AND SAVE TIME\n         MVC   TYPE1,=C'AM'            .  INIT TYPE TO MORNING\n         CP    TIME2,=P'1200000'       .  IS IT IN AFTERNOON\n         BL    AMOK                    .      NO, AM IS OK\n         MVC   TYPE1,=C'PM'            .    YES, RESET TYPE\n         SP    TIME2,=P'1200000'       .  ADJUST FOR AFTERNOON\nAMOK     MVC   EWORK,=X'4021204B20204B2020' . INIT EDIT WORK\n         ED    EWORK,TIME2             .  EDIT THE TIME\n         MVC   WTIME(L'EWORK),EWORK    .\n         MVC   WTIME+L'EWORK+1(L'TYPE1),TYPE1\n* R1=T,  R2=D,  R3=Y,  R4=M            .\nLINE0    MVC   DWORK1+4(4),DATE1       .\n         XC    DWORK1(4),DWORK1        .\n         CVB   R2,DWORK1               .\n         SRDA  R2,32                   .\n         D     R2,=F'1000'             .\nLINE1    SR    R1,R1                   .\n         LR    R14,R3                  .\n         SRDA  R14,32                  .\n         D     R14,=F'4'               .\n         LR    R14,R15                 .\n         SRDA  R14,32                  .\n         M     R14,=F'4'               .\n         CR    R3,R15                  .\n         BNE   OKT1                    .\n         LA    R1,1                    .\nOKT1     DS    0H                      .\nLINE2    LR    R14,R3                  .\n         SRDA  R14,32                  .\n         D     R14,=F'400'             .\n         LTR   R14,R14                 .\n         BZ    NOMORT                  .\n         LR    R14,R3                  .\n         SRDA  R14,32                  .\n         D     R14,=F'100'             .\n         LTR   R14,R14                 .\n         BNZ   NOMORT                  .\n         SR    R1,R1                   .\nNOMORT   DS    0H                      .\nLINE3    LA    R15,59(R1)              .\n         CR    R2,R15                  .\n         BNH   NOMOR3                  .\n         LA    R15,2                   .\n         SR    R15,R1                  .\n         AR    R2,R15                  .\nNOMOR3   DS    0H                      .\nLINE4    LA    R14,91(R2)              .\n         SRDA  R14,32                  .\n         M     R14,=F'100'             .\n         D     R14,=F'3055'            .\n         LR    R4,R15                  .\nLINE5    LA    R2,91(R2)               .\n         LR    R14,R4                  .\n         SRDA  R14,32                  .\n         M     R14,=F'3055'            .\n         D     R14,=F'100'             .\n         SR    R2,R15                  .\nLINE6    BCTR  R4,R0                   .\n         BCTR  R4,R0                   .\n*LINE7    LTR   R1,R1                   .\n*         BZ    NOMOR7                  .\n*         C     R4,=F'2'                .\n*         BNE   NOMOR7                  .\n*         C     R2,=F'27'               .\n*         BNH   NOMOR7                  .\n*         BCTR  R2,R0                   .\n*NOMOR7   DS    0H                      .\n         CVD   R2,DWORK1               .\n         MVC   EWORKD,=X'40202021'     .\n         ED    EWORKD,DWORK1+6         .\n         CVD   R3,DWORK1               .\n         MVC   EWORKY,=X'40202021'     .\n         ED    EWORKY,DWORK1+6         .\n         LR    R14,R4                  .\n         BCTR  R14,R0                  .\n         SRDA  R14,32                  .\n         M     R14,=F'3'               .\n         LA    R15,MONTAB(R15)         .\n         MVC   WDATE+4(3),0(R15)       .\n         MVC   WDATE(3),EWORKD+1       .\n         MVC   WDATE+7(3),EWORKY+1     .\nRETURN1  EQU   *\n         SR    R15,R15                 .  GET MODULE RETURN CODE\n         L     R13,4(R13)              .  GET THEIR SAVE AREA ADDRESS\n         L     R14,12(R13)             .  GET RETURN ADDRESS\n         LM    R0,R12,20(R13)          .  RESTORE ALL BUT R15\n         BR    R14                     .  RETURN TO CALLER\nMONTAB   DC    CL3'JAN'                .\n         DC    CL3'FEB'                .\n         DC    CL3'MAR'                .\n         DC    CL3'APR'                .\n         DC    CL3'MAY'                .\n         DC    CL3'JUN'                .\n         DC    CL3'JUL'                .\n         DC    CL3'AUG'                .\n         DC    CL3'SEP'                .\n         DC    CL3'OCT'                .\n         DC    CL3'NOV'                .\n         DC    CL3'DEC'                .\n         LTORG ,                       .\nPARM1    DSECT                         .\nWTIME    DS    CL12                    .\nPARM2    DSECT                         .\nWDATE    DS    CL10                    .\nPARM3    DSECT                         .\nSAVE2    DS    18F\nDWORK1   DS    D                       .\nTIME2    DS    F                       .\nDATE1    DS    F                       .\nTYPE1    DS    CL2                     .\nEWORK    DS    CL9                     .\nEWORKD   DS    CL4                     .\nEWORKY   DS    CL4                     .\n         POP   USING                   .\nRBDEXIT  CSECT                         .\n         LTORG\n         $MODEND                       .  SOME JES2 HOUSKEEPING\n         END\n//SYSGO       DD DSN=&&A,SPACE=(TRK,(10,10)),DCB=(LRECL=80,\n//             BLKSIZE=800,RECFM=FB),DISP=(,PASS,DELETE),UNIT=SYSDA\n//LKED      EXEC PGM=IEWL,REGION=256K,COND=(4,LT,ASM1),\n//             PARM=('LIST,LET,MAP,RENT')\n//SYSLIB      DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN      DD DSN=&&A,DISP=(OLD,DELETE)\n//            DD DDNAME=SYSIN          .\n//SYSLMOD     DD DISP=SHR,DSN=PTEC220.TEST.LOAD\n//SYSPRINT    DD SYSOUT=*,DCB=(BLKSIZE=121,BUFNO=1)\n//SYSUT1      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSIN       DD *                     .\n  NAME EXIT1N(R)                       .\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DYNALIST": {"ttr": 7942, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97\\x00?\\x00\\x97\\x00?\\t\\x11\\x031\\x031\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-01-03T00:00:00", "modifydate": "1997-01-03T09:11:00", "lines": 817, "newlines": 817, "modlines": 0, "user": "$VNV"}, "text": "DYNALIST TITLE 'DYNALIST-- TO LIST UNIT NAMES'\n         PRINT NOGEN\nDYNALIST CSECT\n*\n*-------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*\n*        PURPOSE - TO DISPLAY UNIT NAMES AND UCB ADDRESSES PLUS\n*              VOLSERS ASSOCIATED WITH THEM.\n*\n*        DATE WRITTEN - 05/01/92\n*\n*        REGISTER USAGE :\n*\n*              R4       - USED TO ANCHOR MY ADDRESS TABLE\n*              R8       - USED TO ANCHOR MY UNIT TABLE\n*              R9       - ANCHOR POINT FOR ADDRESSABILITY TO DCQ\n*              R10      - USED TO ANCHOR CPPL\n*              R12      - BASE\n*              R11      - BASE\n*\n*        RETURN CODES :\n*\n*-------------------------------------------------------------------\n*\n*        MODIFIED - VINH VU - 01/02/97 - CHANGE 'TPUT' TO 'PUTLINE'\n*        AND 'TGET' TO 'GETLINE'.  ALSO, CHANGE THE WAY UCBINFO IS\n*        ACCESSED BY USING EDTINFO & UCBSCAN MACRO SINCE THE IBM\n*        ROUTINE (IEFEB4UV) STOPPED WORKING WHEN WE WENT TO MVS 5.2.2.\n*\n*-------------------------------------------------------------------\n*\nDYNALIST SET   (R12,R11),DSECT=WKAREA,LV=WKLENG\n*\n         LR    R10,R1              GET CPPL ADDR\n         USING CPPL,R10            ESTAB ADDR\n*\n         USING ADDRTAB,R4          USE R4 AS ANCHOR POINT\n         XR    R4,R4               CLEAR OUT POINTER TO DEVN TABLE\n*\n         LA    R14,MSG+70          SAVE THE ENDING ADDR OF THE MSGLINE\n         ST    R14,ENDPOS\n*\nGETCLASS EQU   *\n         L     R9,CVTPTR           GET CVT ADDRESS\n         USING CVTMAP,R9           ESTAB ADDR\n         L     R9,CVTDCQA          GET DCQ ADDRESS\n         DROP  R9                  DROP ADDRESSABILITY\n*\n         USING DCQ,R9              USE DCQ ADDRESSABILITY NOW\n         L     R9,DCQFIRST         GET FIRST DCQ ADDRESS\n         DROP  R9                  DROP ADDRESSABILITY\n*\n         USING DCQELMNT,R9         ESTAB ADDRESSABILITY FOR DCQ ELMNT\n*\n         LA    R8,UNITTABL         GET ADDRESS OF MY UNIT TABLE\n         L     R1,TABLNGTH         GET LENGTH OF TABLE\n         AR    R1,R8               GO TO THE END ADDRESS\n         ST    R1,ENDADDR          SAVE THIS FOR COMPARISON LATER\n*\nFILLTAB  EQU   *\n*\n         EDTINFO RTNNAMD,SUBPOOL=127,                                  X\n               NAMELIST=UNITPTR,DEVCLASS=DCQDEVCL,MF=(E,EDTLIST)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ERRUNITS            IF NON-ZERO CODE THEN GO DISPLAY\n*\n         L     R1,UNITPTR\n*\n         LA    R7,0(0,R1)          GET TO THE RETURNED UNITNAME LIST\n         ICM   R6,B'1111',4(R1)    GET THE # OF UNIT NAMES\n         BZ    NOMORE              IF NONE FOUND THEN GO TO NEXT CLASS\n*\n         LA    R1,BLANK            GET ADDR OF PUTLINE AREA\n         LA    R15,L'BLANK         GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   MSG,BLANK           CLEAR MSG AREA\n         MVC   MSG(L'MSG1),MSG1    GET FIRST TITLE THERE\n         MVC   MSG+15(L'DCQDEVNM),DCQDEVNM    GET DEVICE NAME\n         LH    R15,DCQUCBCT        GET # OF UCB'S IN THIS CLASS\n         CVD   R15,DWORD           CONVERT TO PACKED DECIMAL\n         MVC   MSG+L'MSG1(L'PATTERN),PATTERN\n         ED    MSG+L'MSG1(L'PATTERN),DWORD+5\n*\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         LA    R1,BLANK            GET ADDR OF PUTLINE AREA\n         LA    R15,L'BLANK         GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         LA    R7,8(,R7)           GO TO FIRST UNIT NAME\n*\n         LA    R1,MSG+5            GET BEGINNING ADDR OF THE LINE\n         ST    R1,CURRPOS          SAVE IT AS CURR POS (MSG LINE)\n         MVC   MSG,BLANK           CLEAR OUT MSG AREA\n*\nMOVEUNIT EQU   *\n         C     R8,ENDADDR          COMPARE WITH ENDING ADDR (UNITTBL)\n         BNL   BADTAB              IF HIGH - THEN TABLE TOO SMALL\n         MVC   0(8,R8),0(R7)       SAVE UNIT NAMES IN MY TABLE\n         BAL   R14,FILLDATA        NOW FILL UP MSG LINE\n*\n         LA    R7,8(,R7)           GO TO NEXT UNIT NAMES (RETURNED)\n         LA    R8,8(,R8)           GO TO NEXT UNIT NAMES (MY TABL)\n         BCT   R6,MOVEUNIT         CHECK AGAINST # OF UNIT NAMES\n*\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\nNOMORE   EQU   *\n         FREEMAIN R,SP=127\n         ICM   R9,B'1111',DCQCHAIN NEXT DCQ ELEMENT\n         BZ    FULLTABL            IF ZERO THEN I AM DONE FOR NOW\n         B     FILLTAB             ELSE - BACK TO NEXT DCQ ELEMENT\n         DROP  R9                  DROP ADDRESSABILITY\n*\n*\nFULLTABL EQU   *\n         MVC   0(8,R8),=8X'FF'     FILL OUT 'EOT' ENTRY\n         ST    R8,LASTUNIT         SAVE LAST UNIT ENTRY ADDRESS (SORT)\n*\nFULLMSG  EQU   *\n         LA    R1,BLANK            GET ADDR OF PUTLINE AREA\n         LA    R15,L'BLANK         GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG4),MSG4    GET REAL MESSAGE OUT\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   BUFFER,BLANK        BLANK OUT THE INPUT AREA FIRST\n         LA    R1,BUFFER           GET ADDR OF PUTLINE AREA\n         LA    R15,L'BUFFER        GET LENG OF MESSAGE\n         BAL   R14,GETBUF          ISSUE THE GETLINE\n*\n         OC    BUFFER,BLANK        TURN TO UPPER CASE\n         TRT   BUFFER,NOBLANK      CHECK FOR FIRST NON-BLANK CHAR\n         BC    8,FULLMSG           IF ALL BLANK, THEN BACK TO ASK\n*\n         CLC   =C'= ',0(R1)        IS IT '=' ??\n         BE    GETCLASS            YEAH - THEN DO THIS AGAIN\n         CLC   =C'END ',0(R1)      IS IT 'END' ??\n         BE    ALLDONE             YEAH - THEN IT'S OVER\n         CLC   =C'* ',0(R1)        IS IT TO SORT AND DISPLAY ??\n         BE    SORTIT              YEAH - THEN GO DO THE SORT\n*\n         MVC   WORKUNIT,0(R1)      ELSE - MOVE IT IN AS UNITNAME\n         BAL   R14,VERIFY          CHECK AND SEE IF UNITNAME GOOD\n         LTR   R15,R15             TEST RC FROM THIS CHECK\n         BZ    GETUCB              IF 0 THEN GO ON\n*\nBADUNIT  EQU   *\n         LA    R1,BLANK            GET ADDR OF PUTLINE AREA\n         LA    R15,L'BLANK         GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG5),MSG5    GET REAL MESSAGE OUT\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     FULLMSG             BACK TO ASK AGAIN\n         EJECT\n*\n*\n*--------\n*        I'VE GOT HERE 'CAUSE SOMEONE ASKS ME TO DISPLAY A UNITNAME\n*--------\n*\nGETUCB   EQU   *\n         LTR   R4,R4               DID I DO GETMAIN ALREADY ?\n         BNZ   GOTSTOR             YES - THEN JUMP RIGHT THROUGH\n         GETMAIN  R,SP=126,LV=ATABLENG\n         LR    R4,R1               USE R4 AS BASE\n*\nGOTSTOR  EQU   *\n         L     R1,=AL4(ATABLENG)   GET SIZE OF THE WHOLE TABLE\n         ST    R1,ATABSIZE         PASS THIS TO THE EDTINFO MACRO\n         ST    R4,UNITPTR          USE UNITPTR AGAIN AS TEMP PARM ADDR\n*\n         EDTINFO RTNDEVN,UNITNAME=WORKUNIT,                            X\n               DEVNLIST=UNITPTR,DYNAMIC=YES,LOC=ANY,RANGE=ALL,         X\n               MF=(E,EDTLIST)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ERRDEVN             IF NON-ZERO CODE THEN GO DISPLAY\n*\n         LA    R7,ATABELM          GET TO THE RETURNED UCB DEVN\n         ICM   R6,B'1111',ATABNUM  GET THE # OF DEVN RETURNED\n         BZ    NOUCB               IF NONE FOUND THEN GO DO FREEMAIN\n*\n         USING UCBOB,R5            ESTAB ADDRESSABILITY\n*\n*--------------\n*        R5 WILL POINT TO EACH UCB\n*--------------\n*\nPROCUCB  EQU   *\n         MVC   DWORD+3(4),0(R7)\n         TR    DWORD+3(4),PACKTABL   CONVER 'AB..' TO X'FAFB..'\n         PACK  DWORD(3),DWORD+3(5)\n         MVC   DEVNUM,DWORD\n         XC    UCBWORK,UCBWORK     CLEAR OUT THE SCAN AREA\n         LA    R5,UCBDATA\n         UCBSCAN COPY,WORKAREA=UCBWORK,UCBAREA=(R5),                   X\n               DEVN=DEVNUM,DYNAMIC=YES,RANGE=ALL\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   SCANERR             IF ERROR FOUND ...\n*\n         MVC   MSG,BLANK           BLANK OUT MSG AREA\n*\n         MVC   MSG+9(4),0(R7)      MOVE NAME TO PRINT\n         MVI   MSG+15,C'-'         MOVE '-' FOR READABILITY\n         CLC   DEVNUM,UCBCHAN      DID I FIND THE RIGHT DEV ??\n         BE    GOODDEV             YEAH - THEN CONTINUE ON\n         MVC   MSG+17(7),=CL7'UnAvail'     SAY THIS IS NOT AVAIL\n         B     PRTUCB              AND THEN GO DO THE DISPLAY\n*\nGOODDEV  EQU   *\n         MVC   MSG+17(7),=CL7'Offline'     MAKE OFFLINE DEFAULT\n         TM    UCBSTAT,UCBONLI     IS IT ONLINE ???\n         BZ    DASDTAPE            NOOP - THEN CK FOR DASD OR TAPE\n         MVC   MSG+17(7),=CL7'Online'\n*\nDASDTAPE EQU   *\n         TM    UCBTBYT3,UCB3TAPE   TAPE ??\n         BO    GETVOLS             YEAH - GO THRU\n         TM    UCBTBYT3,UCB3DACC   DASD ??\n         BO    GETVOLS             YEAH - GO THRU\n*\n*\n*\n*--------------\n*        WHEN I'M READY TO DISPLAY ....\n*--------------\n*\nPRTUCB   EQU   *\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         LA    R7,4(,R7)           GET TO NEXT UCB POINTER\n         BCT   R6,PROCUCB          GO TO PROCESS THE UCB\n         B     NOUCB               NOW GO CLEANUP\n*\n*\n*--------------\n*        I'VE GOT HERE ONLY FOR TAPE AND DASD UCBS\n*--------------\n*\nGETVOLS  EQU   *\n         MVI   MSG+26,C'-'\n         MVC   MSG+29(6),UCBVOLI   GET VOLSER THERE\n         TM    UCBTBYT3,UCB3TAPE   TAPE ??\n         BO    TAPEUCB             YEAH - GO TO PROCESS TAPE UCB\n*\n*--------------\n*        DASD PROCESSING ONLY\n*--------------\n*\n         MVI   MSG+36,C'-'\n         TM    UCBSTAB,UCBBPRV     'PRIVATE' ??\n         BO    MPRIV               YEAH\n         TM    UCBSTAB,UCBBPUB     'PUBLIC' ??\n         BO    MPUB                YEAH\n         TM    UCBSTAB,UCBBSTR     'STORAGE' ??\n         BO    MSTR                YEAH\n         B     CKSHARED            NOW - CHECK FOR SHARED DASD\n*\nMPRIV    EQU   *\n         MVC   MSG+39(7),=CL7'Private'\n         B     CKSHARED            NOW - CHECK FOR SHARED DASD\n*\nMPUB     EQU   *\n         MVC   MSG+39(7),=CL7'Public'\n         B     CKSHARED            NOW - CHECK FOR SHARED DASD\n*\nMSTR     EQU   *\n         MVC   MSG+39(7),=CL7'Storage'\n         B     CKSHARED            NOW - CHECK FOR SHARED DASD\n*\n*\nCKSHARED EQU   *\n         TM    UCBTBYT2,UCBRR      IS THIS SHAREABLE BETWEEN CPU ??\n         BZ    PRTUCB              NOOP - THEN GO DISPLAY\n         MVI   MSG+49,C'-'\n         MVC   MSG+52(8),=CL8'Shared'     SHARED DASD\n         B     PRTUCB              NOW - GO DISPLAY\n*\n*\n*\n*--------------\n*        TAPE PROCESSING ONLY\n*--------------\n*\nTAPEUCB  EQU   *\n         MVI   MSG+36,C'-'\n         TM    UCBTBYT1,UCBD1600   1600 BPI ??\n         BZ    TAPE6250            NOOP - CHECK FOR 6250\n         MVC   MSG+39(8),=CL8'1600 BPI'\n         B     TAPEOPT             NOW CHECK TAPE OPTIONS\n*\nTAPE6250 EQU   *\n         TM    UCBTBYT1,UCBD6250   6250 BPI ??\n         BZ    TAPEOPT             NOOP - GO CHECK FOR TAPE OPTIONS\n         MVC   MSG+39(8),=CL8'6250 BPI'\n*\n*\n*\nTAPEOPT  EQU   *\n         MVI   MSG+49,C'-'\n         TM    UCBTBYT2,UCBDUDN1   DUAL 800/1600 BPI ??\n         BZ    TAPEDUAL            NOOP - CHECK FOR 1600/6250\n         MVC   MSG+52(14),=CL14' 800/1600 Dual'\n         B     TAPETYPE            NOW GO CHECK FOR TAPE TYPE\n*\nTAPEDUAL EQU   *\n         TM    UCBTBYT2,UCBDUDN2   DUAL 1600/6250 BPI ??\n         BZ    TAPETYPE            NOOP - CHECK FOR TAPE TYPE\n         MVC   MSG+52(14),=CL14'1600/6250 Dual'\n*\n*\nTAPETYPE EQU   *\n         MVI   MSG+68,C'-'\n         CLI   UCBTBYT4,UCB3400    3400 ?\n         BNE   TAPE3423            NOOP - CHECK FOR 3423 ??\n         MVC   MSG+71(4),=CL4'3400'\n         B     PRTUCB              NOW - GO DISPLAY\n*\nTAPE3423 EQU   *\n         CLI   UCBTBYT4,UCB3423    3423 ?\n         BNE   TAPE3480            NOOP - CHECK FOR 3480 ??\n         MVC   MSG+71(4),=CL4'3423'\n         B     PRTUCB              NOW - GO DISPLAY\n*\nTAPE3480 EQU   *\n         CLI   UCBTBYT4,UCB3480    3480 ?\n         BNE   TAPE3490            NOOP - CHECK FOR 3490 ??\n         MVC   MSG+71(4),=CL4'3480'\n         B     PRTUCB              NOW - GO DISPLAY\n*\n*\nTAPE3490 EQU   *\n         CLI   UCBTBYT4,UCB3490    3490 ?\n         BNE   PRTUCB              NOOP - GO DISPLAY\n         MVC   MSG+71(4),=CL4'3490'\n         B     PRTUCB              NOW - GO DISPLAY\n*\n*\n*--------------\n*        EITHER I PROCESSED THEM ALL OR THERE IS NO UCB IN 1ST PLACE\n*--------------\n*\nNOUCB    EQU   *\n         B     FULLMSG             THEN BACK TO PROMPT AGAIN\n*\n*\nVERIFY   EQU   *\n         ST    R14,SAVE14          SAVE REG 14\n         LA    R1,UNITTABL         GET SAVED UNITTABL ADDR\n         SR    R15,R15             CLEAR RETURN CODE FIRST\n*\nVFYLOOP  EQU   *\n         CLC   0(8,R1),=8X'FF'     IS IT 'EOT' ??\n         BE    VFYBAD              YEAH - THEN NAME NOT FOUND\n         CLC   WORKUNIT,0(R1)      IS UNIT IN TABLE ??\n         BE    VFYDONE             YEAH - THEN GET OUT WITH GOOD RC\n         LA    R1,8(,R1)           ELSE - GO TO NEXT ENTRY\n         B     VFYLOOP             NOW - BACK TO CHECK AGAIN\n*\nVFYBAD   EQU   *\n         LA    R15,4               BAD RC IN R15\n*\nVFYDONE  EQU   *\n         L     R14,SAVE14          LOAD R14 BACK\n         BR    R14                 AND RETURN\n*\n*\n*\n*\nFILLDATA EQU   *\n         ST    R14,SAVE14          SAVE REG 14\n         L     R1,CURRPOS          GET CURR POSITION\n         C     R1,ENDPOS           DOES IT GO PAST THE END POSITION ?\n         BL    FILLITUP            NOOP - THEN KEEP ON FILLING UP\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   MSG,BLANK           BLANK OUT THE OUTPUT AREA\n*\n         LA    R1,MSG+5            GET BEGINNING ADDR OF THE LINE\n         ST    R1,CURRPOS          SAVE IT AS CURR POSITION\n*\n*--------\n*        WHEN WE GOT HERE, R1 POINTS TO THE POSITION IN THE MSG LINE\n*        WHERE THE UNIT NAME WILL BE MOVED TO. R7 POINTS TO UNIT NAME.\n*--------\n*\nFILLITUP EQU   *\n         MVC   0(8,R1),0(R7)       MOVE UNITNAME TO BUFFER\n         LA    R1,10(,R1)          BUMP TO 10 BYTES PAST WHERE WE ARE\n         ST    R1,CURRPOS          SAVE THIS NEXT POSITION\n*\n         L     R14,SAVE14          LOAD R14 BACK\n         BR    R14                 AND RETURN\n         EJECT\n*\n*\nSORTIT   EQU   *\n         MVI   SWAPSW,X'00'        NO SWAP TAKES PLACE\n         LA    R15,UNITTABL        GET MY UNIT TABLE ADDRESS\n         LA    R14,UNITTABL+8      GET THE N+1 ITEM\n*\nSORTLOOP EQU   *\n         CLC   0(8,R14),0(R15)     COMPARE ITEMS\n         BNL   SORTBUMP            IF HIGH - THEN NEED TO SWAP\n         XC    0(8,R14),0(R15)     SWAP THESE\n         XC    0(8,R15),0(R14)          TWO\n         XC    0(8,R14),0(R15)              FIELDS\n*\n         MVI   SWAPSW,X'FF'        TURN ON SWAP SWITCH\n*\nSORTBUMP EQU   *\n         LA    R14,8(,R14)         BUMP TO NEXT GUY\n         LA    R15,8(,R15)         BUMP TO NEXT GUY\n         C     R14,LASTUNIT        AM I AT THE END ??\n         BE    SORTCHK             YEAH - THEN ONE PASS IS DONE\n         B     SORTLOOP            ELSE - BACK TO CHECK/SWAP AGAIN\n*\nSORTCHK  EQU   *\n         CLI   SWAPSW,X'FF'        DID SWAP TAKE PLACE ??\n         BE    SORTIT              YEAH - THEN BACK FOR ONE MORE PASS\n*\n*--------------\n*        I AM DONE WITH THE SORTING - NOW DISPLAY THE TABLE\n*--------------\n*\n         LA    R8,UNITTABL         GET ADDR OF UNIT TABLE\n         MVC   MSG,BLANK           BLANK OUT OUTPUT LINE\n         LA    R1,MSG+5            GET BEG ADDR OF OUTPUT LINE\n         ST    R1,CURRPOS          SAVE THIS\n*\nSORTPRT  EQU   *\n         CLC   0(8,R8),=8X'FF'     AM I AT EOT ??\n         BE    SORTDONE            YEAH - THEN I AM FINISHED\n         L     R1,CURRPOS          ELSE - WHERE AM I (ON THE MSGLINE)?\n         C     R1,ENDPOS           CHECK AGAINST MY LINE ENDING ADDR\n         BL    SORTSHRT            IF I STILL GOT ROOM THEN ....\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         MVC   MSG,BLANK           BLANK OUT THE MESSAGE LINE\n         LA    R1,MSG+5            GET BEG ADDR OF OUTPUT LINE\n         ST    R1,CURRPOS          SAVE THIS\n*\nSORTSHRT EQU   *\n         MVC   0(8,R1),0(R8)       MOVE UNIT NAME TO MSGLINE\n         LA    R8,8(,R8)           GO TO NEXT UNIT IN TABLE\n         LA    R1,10(,R1)          BUMP TO NEXT SPOT ON MSGLINE\n         ST    R1,CURRPOS          SAVE THIS ADDRESS\n         B     SORTPRT             NOW - BACK TO PROCESS NEXT ENTRY\n*\nSORTDONE EQU   *\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     FULLMSG             BACK TO ASK\n*\n         EJECT\n*\nBADTAB   EQU   *\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG3),MSG3    GET REAL MESSAGE OUT\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     ALLDONE             THEN GET OUT\n*\n*\nERRUNITS EQU   *\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG7),MSG7    GET REAL MESSAGE OUT\n*\n         CVD   R15,DWORD           SAVE R15\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+26(4),DWORD+1\n*\n         CVD   R0,DWORD            SAVE R0\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+36(4),DWORD+1\n*\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     ALLDONE             THEN GET OUT\n*\n*\nERRDEVN  EQU   *\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG8),MSG8    GET REAL MESSAGE OUT\n*\n         CVD   R15,DWORD           SAVE R15\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+26(4),DWORD+1\n*\n         CVD   R0,DWORD            SAVE R0\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+36(4),DWORD+1\n*\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     ALLDONE             THEN GET OUT\n*\n*\nSCANERR  EQU   *\n         MVC   MSG,BLANK           BLANK OUT MESSAGE\n         MVC   MSG(L'MSG9),MSG9    GET REAL MESSAGE OUT\n*\n         CVD   R15,DWORD           SAVE R15\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+26(4),DWORD+1\n*\n         CVD   R0,DWORD            SAVE R0\n         UNPK  DWORD(5),DWORD+5(3)\n         OI    DWORD+4,X'F0'       MAKE EVERYTHING PRINTABLE\n         MVC   MSG+36(4),DWORD+1\n*\n         LA    R1,MSG              GET ADDR OF PUTLINE AREA\n         LA    R15,L'MSG           GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n         B     ALLDONE             THEN GET OUT\n*\n*\n*\n*---------------\n*        AT ENTRY TO WLINE, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  THIS IS THE MSG BUFFER TO BE DISPLAYED.\n*---------------\n*\nWLINE    EQU   *\n         ST    R14,WLINERE         SAVE RETURN ADDRESS\n         STM   R3,R4,WLINER34\n         MVC   WMSGLENG,H84        MOVE LENG TO PUTLINE WKAREA\n         XC    WMSGRES,WMSGRES     CLEAR OUT THE RESERVED AREA\n         MVI   WMSG,X'40'          CLEAR OUT MESSAGE AREA\n         MVC   WMSG+1(L'WMSG-1),WMSG\n         CH    R15,=AL2(L'WMSG)    IS MESSAGE GOING TO FIT ??\n         BNH   WLINERDY            YEAH - THEN GO ON\n         LH    R15,=AL2(L'WMSG)    ELSE - USE MAX LENG\n*\nWLINERDY EQU   *\n         BCTR  R15,0               SUBTRACT 1 FOR 'EX' INSTRUCTION\n         EX    R15,WMOVEMSG        NOW MOVE MSG TO WKAREA\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WPUTBLOK,PUTBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         PUTLINE PARM=WPUTBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               OUTPUT=(WMSGLENG,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    WLINEOK             IF ZERO THEN GET READY TO TERMINATE\n         ABEND 888\n*\nWLINEOK  EQU   *\n         LM    R3,R4,WLINER34      LOAD OLD REG\n         L     R14,WLINERE         LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nWMOVEMSG MVC   WMSG(0),0(R1)       MOVE MESSAGE TO PUTLINE WKAREA\n*\n         EJECT\n*\n*\n*\n*---------------\n*        AT ENTRY TO GETBUF, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  IF THE GETLINE WORKS, THE INPUT BUFFER (DATA\n*        RETURNED BY GETLINE) WILL BE COPIED TO THIS AREA.\n*---------------\n*\n*\nGETBUF   EQU   *\n         ST    R14,GETBRE          SAVE RETURN ADDRESS\n         STM   R3,R4,GETBR34\n         ST    R1,OUTPTR           SAVE THE BUFFER POINTER\n         ST    R15,OUTLENG         SAVE THE BUFFER LENGTH\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WGETBLOK,GETBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         GETLINE PARM=WGETBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               INPUT=(TERM,PHYSICAL),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    GETBUFOK            IF ZERO THEN GET READY TO TERMINATE\n         MVC   BUFFER,BLANK        BLANK OUT MSG BUFFER\n         MVC   BUFFER(L'MSG2),MSG2      GET ERROR MSG TO BUFFER\n         ST    R15,DWORD           SAVE RC\n         UNPK  DWORD+5(3),DWORD+3(2) UNPACK RC\n         MVC   BUFFER+3(2),DWORD+5      MOVE TO MESSAGE\n         TR    BUFFER+3(2),NUMTRT-240   MAKE SURE IT'S TRANSLATED RIGHT\n*\n         LA    R1,BUFFER\n         LA    R15,L'BUFFER\n         BAL   R14,WLINE           PUT OUT MESSAGE\n         ABEND 999\n*\nGETBUFOK EQU   *\n         L     R1,WGETBLOK+GTPBIBUF-GTPB      GET RET BUF ADDR\n         LH    R14,0(R1)           GET LENG RETURN\n*\n         ST    R14,FREELENG        SAVE LENG TO BE FREEMAIN'ED\n         ST    R1,FREEAREA         SAVE ADDRESS TO DO FREEMAIN\n*\n         C     R14,OUTLENG         COMPARE WITH MY ALLOWED MAX\n         BNH   GETMOVE             IF OK THEN MOVE TO MY BUFFER\n         L     R14,OUTLENG         ELSE - USE MY MAX\n*\nGETMOVE  EQU   *\n         L     R15,OUTPTR          GET ADDR OF MY BUFFER\n         S     R14,F4              SUBTRACT THE HEADER\n         LTR   R14,R14             IS IT ZERO LENG ??\n         BZ    GETFREE             YES - THEN JUST FORGET THE MOVE\n         BCTR  R14,0               SUBTRACT 1 FOR 'EXE' INSTRUCTION\n         EX    R14,MOVEBUF         THEN MOVE DATA TO MY BUFFER\n*\nGETFREE  EQU   *\n         L     R3,FREEAREA\n         L     R4,FREELENG\n         FREEMAIN R,A=(R3),LV=(R4),SP=1\n*\n         LM    R3,R4,GETBR34\n         L     R14,GETBRE          LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nMOVEBUF  MVC   0(0,R15),4(R1)\n*\n*\n*\nALLDONE  EQU   *\n*\n         LTR   R4,R4               DID I GETMAIN FOR DEVTAB STOR ?\n         BZ    ALLOUT              NOP - THEN JUMP RIGHT THROUGH\n         FREEMAIN R,SP=126\n*\nALLOUT   EQU   *\n         EXIT\n         EJECT\n*\nF4       DC    F'4'\nH84      DC    H'84'\n*\nPUTBLOK  PUTLINE MF=L\nPUTBLOKL EQU   *-PUTBLOK           LENG OF THE PUTLINE LIST FORM\n*\n*\nGETBLOK  GETLINE MF=L\nGETBLOKL EQU   *-GETBLOK           LENG OF THE GETLINE LIST FORM\n*\n*\nMSG1     DC    C'Device Class = XXXXXXXX <==>    # UCBs = '\nMSG2     DC    C'RC=XX - GETLINE Error'\nMSG3     DC    C'Too many unit names (> 500)'\nMSG4     DC    C'Enter ''='' (List), ''*'' (Sorted list), ''END'' (QuitX\n               ), or UNITNAME'\nMSG5     DC    C'Unit Name not found'\nMSG7     DC    C'Dec RC from EDTINFO - R15=0000 - R0=0000 (RTNNAMD)'\nMSG8     DC    C'Dec RC from EDTINFO - R15=0000 - R0=0000 (RTNDEVN)'\nMSG9     DC    C'Dec RC from UCBSCAN - R15=0000 - R0=0000'\n*\nPATTERN  DC    X'402020202021'\n*\n         DS    0F\nTABLNGTH DC    AL4(TABLEND)        LENG OF UNITTABLE\n*\nBLANK    DC    CL80' '\n*\n         PRINT GEN\n*\n*\nNUMTRT   DC    C'0123456789ABCDEF'\n*\nNOBLANK  DC    256X'FF'\n         ORG   NOBLANK+X'40'\n         DC    X'00'\n         ORG\n*\nPACKTABL DC    256AL1(*-PACKTABL)\n         ORG   PACKTABL+C'A'\n         DC    X'FAFBFCFDFEFF'\n         ORG\n*\n         LTORG\n*\n         EJECT\nWKAREA   DSECT\n         DS    18F\n*\nDWORD    DS    D                   WORK AREA\n*\nSAVE14   DS    F\nWLINERE  DS    F\nWLINER34 DS    2F\nGETBRE   DS    F\nGETBR34  DS    2F\n*\nLASTUNIT DS    F                   ADDR OF LAST UNIT IN TABLE\n*                                  (USED FOR SORTING ONLY)\n*\nUNITPTR  DS    F                   POINTER TO RETURNED UNITNAME LIST\n*\nFREELENG DS    F\nFREEAREA DS    F\n*\nENDADDR  DS    F                   SAVE TABLE END ADDRESS\nCURRPOS  DS    F                   SAVED ADDRESS\nENDPOS   DS    F                   SAVED ADDRESS\n*\nECBADS   DS    F                   ECB USED BY PUTLINE\nIOPLADS  DS    4F                  IOPL USED BY PUTLINE\n*\nOUTPTR   DS    F\nOUTLENG  DS    F\n*\nDEVNUM   DS    H\n*\n         DS    0F\nWPUTBLOK DS    CL(PUTBLOKL)        PUTLINE LIST FORM\n*\n         DS    0F\nWGETBLOK DS    CL(GETBLOKL)        GETLINE LIST FORM\n*\n*\n*\nWORKUNIT DS    CL8                 UNIT NAME\n*\n*\nUCBWORK  DS    CL100               WORKAREA USED BY UCBSCAN\nUCBDATA  DS    CL48                A COPY OF THE UCB BEING RETURNED\n*\nBUFFER   DS    CL80                USED FOR TGET\nMSG      DS    CL80                USED FOR TPUT\n*\nSWAPSW   DS    CL1                 USED FOR SORT SWITCH\n*\n*\n         PRINT GEN\n         EDTINFO MF=(L,EDTLIST)    EDTINFO (LIST FORM)\n*\nWMSGLENG DS    H         ********  THESE 3 FIELDS HAVE TO BE  *****\nWMSGRES  DS    H         ********  TOGETHER LIKE THIS  *******\nWMSG     DS    CL80      ********  USED FOR GET/PUTLINE  *******\n*\nUNITTABL DS    500CL8              ALLOW 500 UNIT NAMES (TOTAL)\nTABLEND  EQU   *-UNITTABL          GET LENG\n         DS    CL8                 --  RESERVED FOR EOF ENTRY --\n*\nWKLENG   EQU   *-WKAREA\n*\n         EJECT\n*\n*\nADDRTAB  DSECT\nATABSIZE DS    F                   SIZE OF TABLE\nATABNUM  DS    F                   NUMBER OF TABLE ENTRIES (RETURNED)\nATABELM  DS    50000CL4            ALLOW 50000 ADDRESSES\nATABLENG EQU   *-ADDRTAB           LENG OF TABLE\n*\n         EJECT\nDCQ      DSECT\nDCQNAME  DS    CL4\nDCQLNGTH DS    XL2\nDCQCOUNT DS    XL2\nDCQFIRST DS    XL4\nDCQDSTCT DS    XL4\nDCQUCBNO DS    XL4\n*\nDCQELMNT DSECT\nDCQCHAIN DS    XL4                 NEXT DCQ\nDCQDEVCL DS    XL1                 DEVICE CLASS\nDCQFLG1  DS    XL1                 RESERVED\nDCQUCBCT DS    XL2                 # OF UCBS\nDCQUCBAD DS    XL4                 FIRST UCB\nDCQDEVNM DS    CL8                 CLASS NAME\n         DS    CL8                 RESERVED\n*\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJPPL\nPPLLENG  EQU   *-PPL               LENG OF PPL\n         EJECT\n         IKJUPT\n         EJECT\n         IKJECT\n         EJECT\n         IKJGTPB\n         EJECT\n         IEFUCBOB\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENQMON": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01V\\x00\\x00\\x00\\x98%\\x8f\\x00\\x99%\\x9f\\x15\\x07\\x04\\x1d\\x01\\x04\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.86", "flags": 0, "createdate": "1998-09-15T00:00:00", "modifydate": "1999-09-16T15:07:00", "lines": 1053, "newlines": 260, "modlines": 0, "user": "NMVV1"}, "text": "ENQM     TITLE 'STARTED TASK ENQ CONTENTION MONITOR'\n         PRINT NOGEN\n*---------------------------------------------------------------------*\n*---     NAME: ENQMON                                              ---*\n*---                                                               ---*\n*---     PURPOSE: DISPLAY AND LOG DATASET CONTENTION PROBLEMS.     ---*\n*---                                                               ---*\n*---     METHOD: EACH MINUTE, USE GQSCAN TO LOCATE ANY DATASET     ---*\n*---           CONTENTION SITUATIONS.  USE THE INFORMATION RETURNED---*\n*---           BY GRS TO DISPLAY, ON CONSOLES AND SYSLOG, THE      ---*\n*---           DSNAME INVOLVED, THE HOLDERS, AND REQUESTORS.       ---*\n*---           IF THE HOLDER(S) ARE TSU USER(S), THEN THIS TASK    ---*\n*---           DOES TPUT TO ASK THE TSO USER TO FREE THE DATA SET  ---*\n*---           IN CONTENTION.  THE CONSOLE MESSAGES WILL BE        ---*\n*---           REPEATED EVERY MINUTE (AFTER THE PREVIOUS ONES      ---*\n*---           HAVE BEEN DELETED - (DOM'ED)).  THESE MESSAGES DO   ---*\n*---           INDICATE HOW LONG THE WAIT HAS BEEN.                ---*\n*---                                                               ---*\n*---           ALSO, THE JOB WAITING FOR THE DATA SET WILL RECEIVE ---*\n*---           MESSAGES (IN THE JOB LOG) INDICATING THE WAIT.      ---*\n*---           THESE MESSAGES HAVE THE EXACT SAME CONTENT AS THE   ---*\n*---           CONSOLE MESSAGES.                                   ---*\n*---                                                               ---*\n*---     PARAMETERS: NONE                                          ---*\n*---                                                               ---*\n*---     DD STATEMENTS REQUIRED: NONE                              ---*\n*---                                                               ---*\n*---     TERMINATION: THIS PROGRAM WILL ACCEPT A MVS STOP COMMAND  ---*\n*---           AS A SIGNAL TO SHUTDOWN.  ACTUAL SHUTDOWN MAY TAKE  ---*\n*---           UP TO ONE MINUTE.                                   ---*\n*---                                                               ---*\n*---     PROGRAM ATTRIBUTES: AMODE-31, RMODE-24, NOT-RENT, APF AUTH---*\n*---           APF AUTH IS REQUIRED TO ISSUE THE IEFSSREQ MACRO    ---*\n*---           TO OBTAIN THE JOBID OF A JOB, AND ALSO TO MAKE A    ---*\n*---           'WTO' A TRUE HILITE.  THE COMMAND USED TO LOG       ---*\n*---           A MESSAGE IN THE BATCH JOB ('$DM') ALSO REQUIRES    ---*\n*---           APF AUTHORIZATION.                                  ---*\n*---                                                               ---*\n*---     AUTHOR - VINH VU - 06/01/99                               ---*\n*---           I TOOK THE A PROGRAM FROM THE CBT TAPE AND MADE     ---*\n*---           'HEAVY' MODIFICATIONS TO IT TO DO EVERYTHING        ---*\n*---           I SAID IT WOULD DO ABOVE.  THE ORGINAL PROGRAM      ---*\n*---           DOES THE GSCAN AND PUT OUT JUST THE WTOS DISPLAYING ---*\n*---           ENQ HOLDERS/WAITERS (NON-HILITE) EVERY MINUTE.      ---*\n*---                                                               ---*\n*---     REGISTER USAGE:                                           ---*\n*---                                                               ---*\n*---           R2  - WORK                                          ---*\n*---           R3  - RIBE BASE                                     ---*\n*---           R4  - WORK - USED AS COUNTER                        ---*\n*---           R5  - BASE FOR THE OWNER'S LIST                     ---*\n*---           R6  - BASE FOR THE WAITER'S LIST                    ---*\n*---           R7  - WORK (AVAIL)                                  ---*\n*---           R8  - OWNERS COUNT                                  ---*\n*---           R9  - WAITERS COUNT                                 ---*\n*---           R10 - RIB BASE                                      ---*\n*---           R11 - 2ND CODE BASE                                 ---*\n*---           R12 - 1ST CODE BASE                                 ---*\n*---           R13 - STORAGE BASE (GETMAIN'ED)                     ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n*\nOWN_LST  EQU   5                   REG 5\nWAIT_LST EQU   6                   REG 6\n*\nENQMON   CSECT\nENQMON   AMODE 31\nENQMON   RMODE 24\n*\n         SET   (R12,R11),LV=WKLENG,DSECT=WKAREA\n*---------------------------------------------------------------------*\n*---     1. SET UP CIB INTERFACE FOR STOP COMMAND.                 ---*\n*---------------------------------------------------------------------*\n         LA    R2,COMMPTR          POINT TO RETURN AREA\n         EXTRACT (2),FIELDS=COMM\n         L     R2,COMMPTR          LOAD THE COMMAREA POINTER\n         USING COM,R2              AND BASE THE DSECT\n         ICM   R3,15,COMCIBPT      LOAD CIB POINTER\n         BZ    NOCIB               NONE TO FREE ---\n         LA    R4,COMCIBPT         POINT TO CIB START ADDRESS\n         QEDIT ORIGIN=(4),BLOCK=(3)    RELEASE 'START' CIB\n*\nNOCIB    EQU   *\n         QEDIT ORIGIN=(4),CIBCTR=1\n         DROP  R2\n*---------------------------------------------------------------------*\n*---     2. GRAB STORAGE FOR GQSCAN RETURN AREA AND BASE ITS       ---*\n*---        DSECT(S)                                               ---*\n*---------------------------------------------------------------------*\n         L     R2,GQSCSIZE         LOAD SIZE\n         GETMAIN RC,LV=(2),SP=POOL6,BNDRY=PAGE,LOC=ANY\n         LR    R4,R1               COPY STORAGE ADDRESS\n         ST    R1,GQAREA           AND SAVE FOR LATER\n         LR    R5,R2               COPY AREA SIZE\n         LA    R6,0                SOURCE ADDRESS OF ZERO\n         LA    R7,0                AND LENGTH OF ZERO\n         MVCL  R4,R6               CLEAR IT OUT...\n*\n         GETMAIN RU,SP=POOL10,LV=OWN_GM,LOC=ANY     BUILD OWNERS LIST\n         ST    R1,@OWNERS          SAVE ADDRESS TO THE OWNERS LIST\n*\n         GETMAIN RU,SP=POOL11,LV=WAIT_GM,LOC=ANY    BUILD WAITERS LIST\n         ST    R1,@WAITERS         SAVE ADDRESS TO THE WAITERS LIST\n*\n         GETMAIN RU,SP=POOL12,LV=STAT_GM,LOC=ANY    BUILD SSCS STORAGE\n         ST    R1,SSCSPTR          SAVE ADDRESS TO THE SSCS POINTER\n*\n         L     R14,CVTPTR          FIND THE CVT\n         MVC   OWNSYS,CVTSNAME-CVTMAP(R14)    SAVE MY OWN SYS-ID\n*\n         XC    ANCHOR,ANCHOR       CLEAR OUT THE 1ST LL IN THE CHAIN\n         XC    TOKEN,TOKEN         START THE TOKEN (WTO) WITH ZEROS\n*\nINIT_IT  EQU   *\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG0),MSG0       I AM READY\n         MVC   WTOLENG,=AL2(L'MSG0)\n         XR    R0,R0\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2),TOKEN=BEGTOKEN\n*\n*---------------------------------------------------------------------*\n*---     5. ISSUE GQSCAN FOR SYSDSN CONTENTION                     ---*\n*---------------------------------------------------------------------*\n*\nRESCAN   EQU   *\n         BAL   R14,CLEARLL         RESET ALL FLAGS FOR THE LINKLIST\n         BAL   R14,DOMLL           DELETE ALL OLD HILITED WTO'S\n         L     R9,GQAREA           GET THE AREA POINTER BACK\n         L     R3,GQSCSIZE         LOAD AREA SIZE\n         GQSCAN AREA=((R9),(R3)),SCOPE=ALL,REQLIM=MAX,                 X\n               WAITCNT=1,XSYS=NO,RESNAME=QNAME\n         ST    R1,RIBSLEFT         SAVE RIB COUNT\n         CH    R15,=H'4'           ANY CONTENTION ??\n         BE    NOWAIT              NOPE; RELEASE CHAINS\n         BL    PARSEIT             SOMEONE IS WAITING; CHECK IT OUT\n*\nBADSCAN  EQU   *\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG901),MSG901   I AM TERMINATING\n         MVC   WTOLENG,=AL2(L'MSG901)\n         XR    R0,R0\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2)\n         ABEND 999,DUMP\n*\nBAD_JES2 EQU   *\n*\n         DOM   TOKEN=BEGTOKEN      UN-HILITE THE 'READY' MESSAGE 1ST\n*\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG900),MSG900   I AM SUSPENDING FOR 5 MINUTES\n         MVC   WTOLENG,=AL2(L'MSG900)\n         XR    R0,R0\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2),TOKEN=BEGTOKEN\n*\n         STIMER WAIT,BINTVL=FIVEMIN\n         BAL   R14,INCR_TME        INCREASE ALL WAIT TIME (+5 MIN)\n*\n         DOM   TOKEN=BEGTOKEN      UN-HILITE THE 'SUSPEND' MSG\n*\n         B     INIT_IT             AND BACK AGAIN ---\n*\n*\n*---------------------------------------------------------------------*\n*---     NOBODY WAITING FOR DATASETS. RELEASE ANY CHAINS WE HAVE   ---*\n*---           AND GO WAIT FOR ANOTHER MINUTE.                     ---*\n*---------------------------------------------------------------------*\n*\nNOWAIT   EQU   *\n         BAL   R14,FREELL          DO FREEMAIN ON UNUSED LL\n*                                  BEFORE GOING BACK TO WAIT AND\n*                                  DO MORE SCAN\n         L     R2,COMMPTR          LOAD COMM AREA POINTER\n         USING COM,R2\n         ICM   R3,15,COMCIBPT      IS THERE A CIB ??\n         BZ    WAITMORE            NOPE ---\n         USING CIB,R3              YES; MAP IT\n         CLI   CIBVERB,CIBSTOP     STOP COMMAND ??\n         BE    ENDITALL\n         LA    R4,COMCIBPT         POINT TO ORIGIN\n         QEDIT ORIGIN=(R4),BLOCK=(R3)\n         DROP  R2,R3               DISCARD MAPS\n*\nWAITMORE EQU   *\n         STIMER WAIT,BINTVL=MINUTE\n         B     RESCAN              AND SCAN AGAIN ---\n*\nMINUTE   DC    A(60*100)           ONE MINUTE WAIT INTERVAL\nFIVEMIN  DC    A(60*100*5)         FIVE MINUTE WAIT INTERVAL\n*\n*---------------------------------------------------------------------*\n*---     A STOP COMMAND WAS ISSUED.  I JUST NEED TO CLEAN UP AND   ---*\n*---     GO AWAY.                                                  ---*\n*---------------------------------------------------------------------*\n*\nENDITALL EQU   *\n*\n         BAL   R14,DOMLL           DELETE ALL OLD HILITED WTO'S\n         DOM   TOKEN=BEGTOKEN\n*\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG999),MSG999   I AM TERMINATING\n         MVC   WTOLENG,=AL2(L'MSG999)\n         XR    R0,R0\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2)\n*\n         FREEMAIN RC,SP=POOL6\n         FREEMAIN RC,SP=POOL7\n         FREEMAIN RC,SP=POOL10\n         FREEMAIN RC,SP=POOL11\n         FREEMAIN RC,SP=POOL12\n         EXIT\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     PARSE THE RIB RETURNED BY GQSCAN                          ---*\n*---                                                               ---*\n*---     R3  - BASE FOR THE RIBE                                   ---*\n*---     R10 - BASE FOR THE RIB                                    ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n*\nPARSEIT  EQU   *\n         L     R10,GQAREA          COPY AREA POINTER FOR LATER\n         USING RIB,R10             AND BASE ITS DSECT\n*\nNEWRIB   EQU   *\n         ST    R1,RIBSLEFT         SAVE UPDATED RIB COUNT\n         LA    R3,RIBEND           POINT TO START OF RIBVAR\n         AH    R3,RIBVLEN          ADD VARIABLE AREA LENGTH\n         USING RIBE,R3             AND BASE ANOTHER DSECT\n         L     R4,RIBNRIBE         LOAD RIBE COUNT\n*\n         L     OWN_LST,@OWNERS     POINT TO OWNERS' LIST\n         L     WAIT_LST,@WAITERS   POINT TO WAITERS' LIST\n*\n         XC    OWN_CNT,OWN_CNT     NO OWNERS YET\n         XC    WAIT_CNT,WAIT_CNT   NO WAITERS YET\n*\nLOOPRIBE EQU   *\n*---------------------------------------------------------------------*\n*---     FIND THE OWNERS AND WAITERS FIRST                         ---*\n*---                                                               ---*\n*---           R4 - COUNTERS USED TO PROCESS # OF RIBE'S           ---*\n*---           R5 (OWN_LST) POINTS TO LIST OF OWNERS               ---*\n*---           R6 (WAIT_LST) POINTS TO LIST OF WAITERS             ---*\n*---                                                               ---*\n*---     HERE, WE JUST FILL OUT THE TWO TABLES (OWNERS AND         ---*\n*---     WAITERS) FROM THE RIBE'S.  WE'RE STILL PROCESSING THIS    ---*\n*---     ONE RIB (FOR A DATASET IN CONTENTION).                    ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         TM    RIBESFLG,RIBESTAT   WAITING FOR RESOURCE ??\n         BZ    RES_WAIT            YES ---\n         MVC   0(16,OWN_LST),RIBEJBNM    COPY JOB/SYSTEM NAMES\n         MVC   16(1,OWN_LST),RIBERFLG    COPY REQUEST FLAGS\n         MVC   17(2,OWN_LST),RIBEASID    SAVE THE OWNER ASID\n         LA    OWN_LST,OWN_LNG(,OWN_LST)      POINT TO NEXT SLOT\n         L     R15,OWN_CNT         GET 'OWNERS' COUNT BACK\n         LA    R15,1(,R15)         INCREMENT COUNTER BY ONE\n         ST    R15,OWN_CNT          AND SAVE IT BACK\n         C     R15,=AL4(MAXLIMIT)  IS THERE TOO MUCH  ????\n         BH    ALLRIBES            YEAH - THEN DON'T PROCESS MORE\n         B     NEXTRIBE            AND CONTINUE TO NEXT RIBE\n*\nRES_WAIT EQU   *\n         MVC   0(16,WAIT_LST),RIBEJBNM    COPY JOB/SYSTEM NAMES\n         MVC   16(1,WAIT_LST),RIBERFLG    COPY REQUEST FLAGS\n         MVC   17(2,WAIT_LST),RIBEASID    SAVE THE WAITER ASID\n         MVC   JOBID,RIBEJBNM      SAVE JOB NAME\n*\n         BAL   R14,JOB_SRC         NOW - FIND THE JOBID TO DO $DM LATER\n         CLC   JOBID,=8C'?'        IS JES2 RUNNING OK ??\n         BE    BAD_JES2            NOPE - THEN I NEED TO WAIT 5 MINUTES\n*\n         MVC   19(8,WAIT_LST),JOBID       SAVE THE FOUND JES2_JOBID\n*\n         LA    WAIT_LST,WAIT_LNG(,WAIT_LST)     POINT TO NEXT SLOT\n         L     R15,WAIT_CNT        GET 'WAITERS' COUNT BACK\n         LA    R15,1(,R15)         INCREMENT COUNTER BY ONE\n         ST    R15,WAIT_CNT           AND SAVE IT BACK\n         C     R15,=AL4(MAXLIMIT)  IS THERE TOO MUCH  ????\n         BH    ALLRIBES            YEAH - THEN DON'T PROCESS MORE\n*\nNEXTRIBE EQU   *\n         LA    R3,RIBEEND          POINT TO NEXT RIBE\n         BCT   R4,LOOPRIBE         AND CONTINUE ---\n*\nALLRIBES EQU   *\n         ICM   R15,15,OWN_CNT      ANY OWNERS ??\n         BZ    NOMORE              NOP - (SHOULDN'T BE) - BUT HECK\n         ICM   R15,15,WAIT_CNT     ANY WAITERS ??\n         BZ    NOMORE              NOP - (SHOULDN'T BE) - BUT HECK\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     HERE, I'VE GOT ALL 'OWNERS' AND 'WAITERS' FOR ONE         ---*\n*---     DATA SET LOADED IN TWO DIFFERENT TABLES.  NOW, GO         ---*\n*---     PROCESS THEM.                                             ---*\n*---                                                               ---*\n*---     START BUILDING/SPITING MESSAGES                           ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n*\n         LA    R15,RIBEND          POINT TO RIB VARIABLE AREA\n         USING RIBVAR,R15\n         XR    R1,R1               CLEAR OUT CONTENTS FOR IC LATER\n         IC    R1,RIBRNMLN         LOAD LENGTH OF THE RNAME\n         ST    R1,DSNLENG          SAVE THIS LENG FOR LATER USAGE\n         BCTR  R1,R0\n         MVI   DSNAME,C' '\n         MVC   DSNAME+1(L'DSNAME-1),DSNAME\n         EX    R1,RIBM             MOVE DSNAME TO MESSAGE\n         B     GOTDSN\n*\nRIBM     MVC   DSNAME(1),RIBRNAME COPY THE DSNAME\n         DROP  R15\n*\nGOTDSN   EQU   *\n         BAL   R14,DO_TPUT         SEND TSO MESSAGES WHEN APPROPRIATE\n         BAL   R14,DO_WTOS         NOW GO THROUGH AND ISSUE\n*                                  WTO'S AS NEEDED\n*\n*---------------------------------------------------------------------*\n*---     I'VE PROCESSED ALL ENTRIES BELONGING TO ONE ENQ'ED DSN    ---*\n*---     READY TO GO BACK FOR ANOTHER DATASET IN CONTENTION        ---*\n*---------------------------------------------------------------------*\nNOMORE   EQU   *\n         LR    R10,R3              START A NEW RIBE\n         L     R1,RIBSLEFT         GET NUMBER OF RIBS LEFT\n         BCT   R1,NEWRIB           PROCESS NEXT RIB, IF ANY\n*\n         B     NOWAIT              AND LOOP ---\n*\n         EJECT\n*---------------------------------------------------------------------*\n*---     GO THROUGH ALL 'OWNERS' ENTRIES AND ISSUE TPUT'S WHEN     ---*\n*---     APPROPRIATE.                                              ---*\n*---                                                               ---*\n*---           R5 (OWN_LST) POINTS TO LIST OF OWNERS               ---*\n*---           R6 (WAIT_LST) POINTS TO LIST OF WAITERS             ---*\n*---                                                               ---*\n*---           R8 - OWNERS COUNT                                   ---*\n*---           R9 - WAITERS COUNT                                  ---*\n*---                                                               ---*\n*---     HERE, I'M JUST LOOKING AT ONE DSN IN CONTENTION.          ---*\n*---     WE'RE JUST TRYING TO DO TPUT TO ALL HOLDERS OF THIS       ---*\n*---     DATA SET.                                                 ---*\n*---------------------------------------------------------------------*\n*\nDO_TPUT  EQU   *\n         ST    R14,TP_R14          SAVE RETURNED ADDRESS\n         L     OWN_LST,@OWNERS     GET ADDRESS OF THE 'OWNERS' TAB\n         L     WAIT_LST,@WAITERS   GET ADDRESS OF THE 'WAITERS' TAB\n         L     R8,OWN_CNT          RELOAD THE 'OWNERS' COUNT\n*\nTP_BYOWN EQU   *\n         CLC   OWNSYS,8(OWN_LST)   IS THE OWNER LOCAL ??\n         BNE   TP_NXOWN            NOPE - GO TO NEXT  'OWNER'\n*\n         MVC   JOBASID,17(OWN_LST)\n         LOCASCB ASID=JOBASID      GET ASCB OF OWNER\n         LTR   R15,R15             ASCB WAS FOUND ?\n         BNZ   TP_NXOWN            NOP - THEN GO TO NEXT 'OWNER'\n*\n         L     R1,ASCBOUCB-ASCB(,R1)      YES, GET OUCB OF OWNER\n         TM    OUCBYFL-OUCB(R1),OUCBLOG   LOGON CREATED USER?\n         BZ    TP_NXOWN            NO, THEN GO TO NEXT 'OWNER'\n*\n         L     R9,WAIT_CNT         RELOAD THE 'WAITERS' COUNT\n*\nTP_1WAIT EQU   *\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG100),MSG100\n         MVC   BUFFER+22(8),0(WAIT_LST)      GET JOBNAME\n         MVC   BUFFER+L'MSG100(8),8(WAIT_LST) GET SYSID\n         MVC   BUFFER+37(4),=CL4'EXCL'       START OUT WITH 'EXCL'\n         TM    16(WAIT_LST),X'80'  TEST FOR 'EXCL'\n         BNO   TP_1STLN            IF SO - THEN GO TPUT\n         MVC   BUFFER+37(4),=CL4'SHR '       ELSE - MAKE IT 'SHR '\n*\nTP_1STLN EQU   *\n*\n         LA    R1,BUFFER\n         LA    R0,L'BUFFER\n         TPUT  (R1),L'BUFFER,ASIDLOC=JOBASID\n*\nTP_BYPAS EQU   *\n         LA    WAIT_LST,WAIT_LNG(,WAIT_LST)     POINT TO NEXT SLOT\n         BCT   R9,TP_1WAIT         CHECK FOR EVERY 'WAITER'\n*\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG101),MSG101\n         MVC   BUFFER+L'MSG101(44),DSNAME\n         MVC   BUFFER+15(4),=CL4'EXCL'       START OUT WITH 'EXCL'\n         TM    16(OWN_LST),X'80'   TEST FOR 'EXCL'\n         BNO   TP_OWNLN            IF SO - THEN GO TPUT\n         MVC   BUFFER+15(4),=CL4'SHR '       ELSE - MAKE IT 'SHR '\n*\nTP_OWNLN EQU   *\n         LA    R1,BUFFER\n         LA    R0,L'BUFFER\n         TPUT  (R1),L'BUFFER,ASIDLOC=JOBASID\n*\nTP_NXOWN EQU   *\n         LA    OWN_LST,OWN_LNG(,OWN_LST)     POINT TO NEXT SLOT\n         BCT   R8,TP_BYOWN         PROCESS ALL OWNERS\n*\nTPUT_ALL EQU   *\n         L     R14,TP_R14          RELOAD RETURNED ADDRESS\n         BR    R14                 AND BACK TO THE CALLER\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     GO THROUGH THE LINKLIST AND RESET ALL ENTRIES             ---*\n*---------------------------------------------------------------------*\nCLEARLL  EQU   *\n         LA    R4,ANCHOR           GET THE HEAD OF THE CHAIN\n         USING LNKLST,R4\n         B     CLLSKIP             GO RIGHT BY THE FIRST (DUMMY) LL\n*\nCLLLOOP  EQU   *\n         OI    LLFLAG,LLCLEAR      TURN ON 'START-OF-CYCLE' FLAG\n*\nCLLSKIP  EQU   *\n         ICM   R4,15,LLNEXT        AND GO TO NEXT ENTRY\n         BNZ   CLLLOOP\n*\nCLLEXIT  EQU   *\n         DROP  R4\n         BR    R14                 BACK TO CALLER\n*\n*\n*---------------------------------------------------------------------*\n*---     GO THROUGH THE LINKLIST AND FREE UNUSED LL ENTRIES        ---*\n*---------------------------------------------------------------------*\nFREELL   EQU   *\n         ST    R14,FLLR14          SAVE RETURNED ADDRESS\n         USING LNKLST,R4\n         LA    R4,ANCHOR           GET THE HEAD OF THE CHAIN\n         B     FRLBYPAS            GO RIGHT BY THE FIRST (DUMMY) LL\n*\nFRLLOOP  EQU   *\n         TM    LLFLAG,LLCLEAR      DO I NEED TO FREE THIS LL ??\n         BZ    FRLBYPAS            NOP - THEN GO AROUND\n         MVC   SAVENEXT,LLNEXT     SAVE THE NEXT LL POINTER\n*\nFRLNORM  EQU   *\n         FREEMAIN RU,SP=POOL7,LV=LLLENG,A=(R4)\n         ICM   R4,15,LASTLL        USE THE LASTLL AGAIN\n         MVC   LLNEXT,SAVENEXT     RESET THE NEXT LL POINTER\n*\nFRLBYPAS EQU   *\n         ST    R4,LASTLL           SAVE THE LAST LL PROCESSED\n         ICM   R4,15,LLNEXT        GET NEXT ENTRY\n         BNZ   FRLLOOP\n*\nFRLEXIT  EQU   *\n         DROP  R4\n         L     R14,FLLR14          RELOAD RETURNED ADDRESS\n         BR    R14                 BACK TO CALLER\n*\n*---------------------------------------------------------------------*\n*---     GO THROUGH THE LINKLIST AND 'DOM' ALL PREVIOUS 'WTOS'     ---*\n*---------------------------------------------------------------------*\nDOMLL    EQU   *\n         ST    R14,DOMR14          SAVE RETURNED ADDRESS\n         LA    R4,ANCHOR           GET THE HEAD OF THE CHAIN\n         USING LNKLST,R4\n         B     DOMSKIP             GO RIGHT BY THE FIRST DUMMY LL\n*\nDOMLOOP  EQU   *\n         CLC   OWNSYS,LLSYSID      IS THIS A LOCAL JOB ??\n         BNE   DOMSKIP             NOPE - THEN NO NEED TO 'DOM'\n         DOM   TOKEN=LLTOKEN\n*\nDOMSKIP  EQU   *\n         ICM   R4,15,LLNEXT        AND GO TO NEXT ENTRY\n         BNZ   DOMLOOP\n*\nDOMEXIT  EQU   *\n         DROP  R4\n         L     R14,DOMR14          RELOAD RETURNED ADDRESS\n         BR    R14                 BACK TO CALLER\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     GO THROUGH THE LINKLIST AND INCREASE ALL WAIT TIME BY     ---*\n*---     5.  I JUST WENT THROUGH A 5 MIN SUSPENSION DUE TO JES2    ---*\n*---     PROBLEM.                                                  ---*\n*---------------------------------------------------------------------*\n*\nINCR_TME EQU   *\n         LA    R4,ANCHOR           GET THE HEAD OF THE CHAIN\n         USING LNKLST,R4\n         B     INC_SKIP            GO RIGHT BY THE FIRST (DUMMY) LL\n*\nINC_LOOP EQU   *\n         L     R1,LLWAIT           GET THE 'WAIT' TIME IN MINUTE\n         LA    R1,5(,R1)           ADD '5 MORE MIN' TO IT\n         ST    R1,LLWAIT           AND STORE IT RIGHT BACK\n*\nINC_SKIP EQU   *\n         ICM   R4,15,LLNEXT        AND GO TO NEXT ENTRY\n         BNZ   INC_LOOP\n*\nINC_EXIT EQU   *\n         DROP  R4\n         BR    R14                 BACK TO CALLER\n         EJECT\n*\n*\n*---------------------------------------------------------------------*\n*---           R5 (OWN_LST) POINTS TO LIST OF OWNERS               ---*\n*---           R6 (WAIT_LST) POINTS TO LIST OF WAITERS             ---*\n*---           R8 - OWNERS COUNT                                   ---*\n*---           R9 - WAITERS COUNT                                  ---*\n*---------------------------------------------------------------------*\n*\nDO_WTOS  EQU   *\n         ST    R14,WTOR14          SAVE RETURNED ADDRESS\n*\n         L     WAIT_LST,@WAITERS   POINT TO LIST OF WAITERS\n         L     R9,WAIT_CNT\n*\nDO_1WAIT EQU   *\n         CLC   19(8,WAIT_LST),=8C'_'     IS THIS A 'GONE GONE' JOB ?\n         BE    DO_NOWTO            YEAH - THEN DON'T DO 'WTO' OR '$DM'\n         BAL   R14,PROCWAIT        PROCESS THIS WAITER\n*\nDO_NOWTO EQU   *\n         LA    WAIT_LST,WAIT_LNG(,WAIT_LST)     POINT TO NEXT SLOT\n         BCT   R9,DO_1WAIT         AND CONTINUE ---\n*\n         L     OWN_LST,@OWNERS     POINT TO LIST OF OWNERS\n         L     R8,OWN_CNT\n*\nDO_1OWN  EQU   *\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   WTOLENG,=AL2(L'BUFFER)\n         MVC   BUFFER(L'MSG201),MSG201\n         MVC   BUFFER+10(8),0(OWN_LST)      GET HOLDING JOBNAME\n         MVC   BUFFER+22(8),8(OWN_LST)      GET HOLDING SYSID\n         MVC   BUFFER+L'MSG201(44),DSNAME   GET DSNAME IN CONTENTION\n         MVC   BUFFER+37(4),=CL4'EXCL'      START OUT WITH 'EXCL'\n         TM    16(OWN_LST),X'80'   TEST FOR 'EXCL'\n         BNO   DO_NXOWN            IF SO - THEN GO WTO\n         MVC   BUFFER+37(4),=CL4'SHR '       ELSE - MAKE IT 'SHR '\n*\nDO_NXOWN EQU   *\n         XR    R0,R0\n         WTO   TEXT=WTOLENG\n         LA    OWN_LST,OWN_LNG(,OWN_LST)     POINT TO NEXT SLOT\n         BCT   R8,DO_1OWN          AND CONTINUE ---\n*\nWTOEXIT  EQU   *\n         L     R14,WTOR14          RELOAD RETURNED ADDRESS\n         BR    R14                 BACK TO CALLER\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     WAIT_LST POINTS TO THE 'WAITERS' TABLE ENTRY              ---*\n*---                                                               ---*\n*---     HERE, I NEED TO GO THROUGH AND SEARCH THE LINKLIST FOR    ---*\n*---     MATCHING ONWER,DSNAME,ASID AND SYSID.  IF FOUND, THEN     ---*\n*---     INCREASE WAITING TIME (IN MIN), RESET FLAG SO THE ENTRY   ---*\n*---     STORAGE WON'T BE FREE'ED AND THEN DO 'WTO' WITH TOKEN     ---*\n*---     (SAVED IN THE LINKLIST ENTRY SO 'DOM' CAN BE DONE LATER). ---*\n*---                                                               ---*\n*---     IF NOT FOUND, GO ACQUIRE STORAGE, UPDATE LINKLIST CHAIN   ---*\n*---     AND DO THE SAME WTO (WITHOUT SHOWING THE WAITING TIME).   ---*\n*---                                                               ---*\n*---     ALSO, HERE IS WHERE I ISSUE A $DM TO LOG A MESSAGE TO     ---*\n*---     THE WAITING JOB SAYING THAT IT CANNOT RUN DUE TO DATA     ---*\n*---     SET CONTENTION.                                           ---*\n*---                                                               ---*\n*---     THE WTO AND $DM WILL ONLY BE DONE IF JOBNUM IS NOT '___'. ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n*\nPROCWAIT EQU   *\n         ST    R14,PROCR14         SAVE RETURNED ADDRESS\n         USING LNKLST,R4\n         LA    R4,ANCHOR           GET THE HEAD OF THE CHAIN\n         B     PRCBYPAS            GO RIGHT BY THE FIRST (DUMMY) LL\n*\nPRCLOOP  EQU   *\n         CLC   LLJOB,0(WAIT_LST)   IS IT THE SAME JOB ?\n         BNE   PRCBYPAS            NOPE - THEN GO TO NEXT ENTRY\n         CLC   LLSYSID,8(WAIT_LST) IS IT ON THE SAME SYSTEM ??\n         BNE   PRCBYPAS            NOPE - THEN GO TO NEXT ENTRY\n         CLC   LLASID,17(WAIT_LST) IS IT THE SAME ASID ??\n         BNE   PRCBYPAS            NOPE - THEN GO TO NEXT ENTRY\n         CLC   LLJOBNUM,19(WAIT_LST)   IS IT THE SAME JOBNUM\n         BNE   PRCBYPAS            NOPE - THEN GO TO NEXT ENTRY\n         CLC   LLDSN,DSNAME        IS IT THE SAME DATASET ??\n         BNE   PRCBYPAS            NOPE - THEN GO TO NEXT ENTRY\n         B     PRCGOTIT            ELSE - I NEED TO WTO THIS GUY\n*\nPRCBYPAS EQU   *\n         ST    R4,LASTLL           SAVE THIS AS THE LASTLL PROCESSED\n         ICM   R4,15,LLNEXT        AND GO TO NEXT ENTRY\n         BNZ   PRCLOOP\n*\n*---------------------------------------------------------------------*\n*---     IF I GOT HERE, THAT MEANS I COUND NOT FIND A MATCHING     ---*\n*---     LNKLST ENTRY (SAME JOBNAME, SYSID, ETC).                  ---*\n*---------------------------------------------------------------------*\n*\n         GETMAIN RU,SP=POOL7,LV=LLLENG,LOC=ANY\n         L     R14,LASTLL          GET THE LASTLL I PROCESSED\n         ST    R1,LLNEXT-LNKLST(R14) MAKE ME THE LAST GUY IN THE CHAIN\n         LR    R4,R1               AND START USING THE NEW STORAGE\n         XC    LNKLST(LLLENG),LNKLST   ZERO OUT THE STORAGE THOUGH\n         MVC   LLJOB,0(WAIT_LST)   SAVE THIS JOBNAME\n         MVC   LLSYSID,8(WAIT_LST) SAVE THE SYSID\n         MVC   LLASID,17(WAIT_LST) SAVE THE ASID\n         MVC   LLJOBNUM,19(WAIT_LST)    SAVE JES2 JOBNUM\n         MVC   LLDSN,DSNAME        SAVE THE DSNAME\n         B     PRCDOWTO            NOW - GO DO THE WTO\n*\nPRCGOTIT EQU   *\n         XC    LLFLAG,LLFLAG       TURN OFF 'DO CLEAR' FLAG\n         L     R1,LLWAIT           GET WAITING TIME (MINUTE)\n         LA    R1,1(,R1)           INCREMENT BY 1\n         ST    R1,LLWAIT           STORE THE NEW WAITING TIME BACK\n*\nPRCDOWTO EQU   *\n         L     R1,TOKEN            GET THE TOKEN (COUNTER)\n         LA    R1,1(,R1)           INCREASE THIS TOKEN (COUNTER)\n         ST    R1,TOKEN            AND SAVE THIS ONE FOR EACH WTO\n         MVC   LLTOKEN,TOKEN       ALSO SAVE TO 'DOM' LATER\n*\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   WTOLENG,=AL2(L'BUFFER)\n         MVC   BUFFER(L'MSG200),MSG200\n         MVC   BUFFER+10(8),LLJOB            GET HOLDING JOBNAME\n         MVC   BUFFER+22(8),LLSYSID          GET HOLDING SYSID\n         MVC   BUFFER+39(4),=CL4'EXCL'       START OUT WITH 'EXCL'\n         TM    16(WAIT_LST),X'80'  TEST FOR 'EXCL'\n         BNO   PRCFILL             IF SO - THEN GO FILL IN OTHER DATA\n         MVC   BUFFER+39(4),=CL4'SHR '       ELSE - MAKE IT 'SHR '\n*\nPRCFILL  EQU   *\n         LA    R14,BUFFER+L'MSG200\n         MVC   0(44,R14),DSNAME    MOVE DSNAME TO WTO BUFFER\n         ICM   R15,15,LLWAIT       HAVE I BEEN WAITING ??\n         BZ    PRCNOWAT            NOP - THEN DON'T SAY THAT\n*\n         L     R1,DSNLENG          GET LENG OF DSNAME\n         LA    R14,1(R1,R14)       BUMP PAST THE END OF DSNAME\n         MVC   0(L'MSG200A,R14),MSG200A   GET THE 2ND PART OF MSG\n         LA    R14,L'MSG200A(,R14)        GO PAST THE 2ND PART OF MSG\n         CVD   R15,DWORD\n         MVC   MSG200B(L'$PAT5),$PAT5      EDIT AND\n         ED    MSG200B(L'$PAT5),DWORD+5    PRINT OUT MINUTES\n*\n         TRT   MSG200B,BLANKTB     TRY TO CATCH THE 1ST NON-BLANK CHAR\n*\n         LA    R15,MSG200B+L'MSG200B\n         SR    R15,R1              GET LENG OF DATA TO BE MOVED\n         BCTR  R15,0               MINUS 1 FOR EXECUTE INSTRUCTION\n         EX    R15,MOVEMSG         NOW MOVE LAST PART OF MSG TO BUFFER\n         B     PRCBUILD\n*\n*---------------------------------------------------------------------*\n*---     BUILDING THE '$DM' COMMAND                                ---*\n*---------------------------------------------------------------------*\n*\nPRCNOWAT EQU   *\n         L     R15,DSNLENG\n         BCTR  R15,R0\n*\nPRCBUILD EQU   *\n         LA    R14,1(R15,R14)      NOW I'M LOOKING AT THE END OF BUFFER\n         LA    R15,BUFFER+10       PAST THE 'QM200 JOB '\n         SR    R14,R15\n         MVI   CMDTEXT,C' '\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT\n         BCTR  R14,R0\n         EX    R14,BLDCMD\n         LA    R15,CMDTEXT\n         LA    R15,1(R14,R15)\n         MVI   0(R15),X'7D'        PUT THE QUOTE AT THE END OF CMD\n         MVC   CMDJOB,LLJOBNUM\n         LA    R14,15(,R14)        ADD '$DMJOBXXX,\"   \"' TO IT\n         STH   R14,CMDLEN          AND THERE IS THE CMD LENGTH\n*\nPRCRDY   EQU   *\n*\n         XR    R0,R0\n*\n         CLC   OWNSYS,LLSYSID      IS THIS JOB A LOCAL JOB ??\n         BE    PROC_HIL            YEAH - THEN HIGHLIGHT THE WTO\n*\n         WTO   TEXT=WTOLENG        ELSE - DON'T HIGHLIGHT THE WTO\n         B     PROCEXIT            AND DON'T DO '$DM'\n*\nPROC_HIL EQU   *\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2),TOKEN=LLTOKEN\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R2,CMDAREA          USE CONSID AS 0\n         MGCRE MF=(E,COMMANDS),TEXT=(R2),CONSID=MYCONS\n         MODESET KEY=NZERO,MODE=PROB\n*\n*---------------------------------------------------------------------*\n*---     NOW, DO WTOS INDICATING THE HOLDING JOB(S).  ONLY THE     ---*\n*---     FIRST 4 JOBS ARE LISTED (THEY'LL ALL FIT ON ONE LINE).    ---*\n*---     THERE IS NO REASON TO LIST MORE THAN 4 AT THIS POINT.     ---*\n*---------------------------------------------------------------------*\n*\n         MVI   CMDTEXT,C' '\n         MVC   CMDTEXT+1(L'CMDTEXT-1),CMDTEXT\n         MVC   CMDTEXT(L'MSG202),MSG202\n         LA    R15,CMDTEXT+L'MSG202\n         L     R1,@OWNERS          GET ADDR OF 'OWNERS' TABLE\n         L     R14,OWN_CNT\n         C     R14,=F'4'           IS IT > 4 ??\n         BNH   PRC_HOLD            NOPE - THEN USE IT\n         LA    R14,4               ELSE - USE 4\n*\nPRC_HOLD EQU   *\n         MVC   0(8,R15),0(R1)      GET JOBNAME FOR THE OWNER\n         MVC   9(6,R15),=CL6'(EXCL)'\n         TM    16(R1),X'80'        TEST FOR 'SHR'\n         BNO   PRC_GOT\n         MVC   9(6,R15),=CL6'(SHR)'\n*\nPRC_GOT  EQU   *\n         LA    R15,16(,R15)        BUMP TO NEXT ADDRESS\n         LA    R1,OWN_LNG(,R1)     BUMP TO NEXT OWNER\n*\n         BCT   R14,PRC_HOLD        DO THIS FOR ALL OWNERS\n         MVI   0(R15),X'7D'        MOVE THE ENDING QUOTE THERE\n         LA    R14,CMD-2           FIGURE OUT THE CMD LENG\n         SR    R15,R14\n         STH   R15,CMDLEN          AND SAVE IT\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R2,CMDAREA          USE CONSID AS 0\n         MGCRE MF=(E,COMMANDS),TEXT=(R2),CONSID=MYCONS\n         MODESET KEY=NZERO,MODE=PROB\n*\nPROCEXIT EQU   *\n         DROP  R4\n         L     R14,PROCR14         RELOAD RETURNED ADDRESS\n         BR    R14                 BACK TO CALLER\n*\nMOVEMSG  MVC   0(0,R14),0(R1)\nBLDCMD   MVC   CMDTEXT(0),BUFFER+10\n         EJECT\n*\n*\n*---------------------------------------------------------------------*\n*---     HERE, WE NEED TO FIND THE JOBID FOR THE WAITING JOB SO    ---*\n*---     THAT WE CAN LOG A MESSAGE TO IT LATER (USING $DM) TO      ---*\n*---     INDICATE THAT IT IS WAITING FOR A DATA SET.               ---*\n*---                                                               ---*\n*---     AT ENTRY, JOBID WILL HAVE THE JOBNAME.  AFTER EVERYTHING  ---*\n*---     SAID AND DONE, JOBID WILL ACTUALLY CONTAIN THE JES2       ---*\n*---     JOBID OF THAT JOB.  IF FOR SOME REASONS, THE JOB IS NO    ---*\n*---     LONGER IN THE SYSTEM AT THE TIME, JOBID WILL BE '_____'.  ---*\n*---     IF FOR SOME REASONS, JES2 IS NOT AVAILABLE, I WILL RETURN ---*\n*---     JOBID AS '??????'.                                        ---*\n*---                                                               ---*\n*---     THIS JOB SEARCH IS DONE AFTER THE GQSCAN HAS BEEN DONE.   ---*\n*---     THERE IS A SLIGHT CHANCE THAT THE JOB IS NO LONGER IN     ---*\n*---     THE SYSTEM DUE TO THE TIMING.  IF NOT, THERE IS ALSO      ---*\n*---     A CASE WHERE THE JOB STILL RUNS, BUT WHILE I'M DOING      ---*\n*---     OTHER THINGS, THE JOB FINALLY GAINS CONTROL OF THE DATA   ---*\n*---     SET, RUNS, AND FINISHES IN A HURRY, BEFORE MY NEXT SCAN.  ---*\n*---     IN THIS CASE, I WILL NOT DO EITHER A 'WTO' OR A '$DM'.    ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n*\nJOB_SRC  EQU   *\n         ST    R14,JOBSR14         SAVE THE RETURNED ADDRESS\n*\n         XC    MYSSOB,MYSSOB       CLEAR MY AREA\n         MVC   MYSSOB+SSOBID-SSOB(4),=CL4'SSOB'\n         MVC   MYSSOB+SSOBLEN-SSOB(2),=AL2(SSOBHSIZ)   SET UP LENGTH\n         MVC   MYSSOB+SSOBFUNC-SSOB(2),=AL2(SSOBSTAT)  DO 'STATUS'\n         L     R14,SSCSPTR                     GET ADDR OF MY SSCS\n         ST    R14,MYSSOB+SSOBINDV-SSOB         STORE IT\n*\n         USING STATSTOR,R14\n         XC    MYSSCS(SSCSIZE),MYSSCS          CLEAR THE AREA\n         MVC   MYSSCS+SSCSLEN-SSCSBGN(2),=AL2(SSCSIZE)\n         MVC   MYSSCS+SSCSJOBN-SSCSBGN(8),JOBID       GET JOBNAME\n         MVC   MYSSCS+SSCSJOBI-SSCSBGN(8),=CL8' '     BLANK JOB ID\n         MVC   JOBID,=8C'_'        JUST IN CASE I CAN'T FIND THE JOB\n         MVC   MYSSCS+SSCSDIMP-SSCSBGN(2),=AL2(STATLENG)\n         DROP  R14\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R1,MYSSOB\n         ST    R1,MYADDR\n         OI    MYADDR,X'80'        TURN ON THE HI-ODER BIT\n         LA    R1,MYADDR           GET THE ADDR INTO R1\n         IEFSSREQ\n         LR    R2,R15              SAVE RETURN CODE\n         MODESET KEY=NZERO,MODE=PROB\n*\n         LTR   R2,R2               TEST RETURN CODE\n         BZ    JOB_CK              IF OKAY THEN GO ON AND CHECK MORE\n         C     R2,=AL4(16)         IS SUBSYSTEM AVAILABLE ??\n         BH    JOB_BAD             YES - THEN SOME OTHER ERRORS\n*\n         MVC   JOBID,=8C'?'        ELSE - FLAG THIS AS 'REAL TROUBLE'\n         B     JOB_EXIT            AND GET OUT\n*\nJOB_CK   EQU   *\n         ICM   R2,B'1111',MYSSOB+SSOBRETN-SSOB   GET RETURN CODE\n         BZ    JOB_FND             IF ZERO - THEN FOUND\n         C     R2,=AL4(4)          R15 = '4' ??\n         BE    JOB_EXIT            YEAH - NOT FOUND\n*\nJOB_BAD  EQU   *\n         MVI   BUFFER,C' '\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         MVC   BUFFER(L'MSG902),MSG902   I AM TERMINATING\n         MVC   WTOLENG,=AL2(L'MSG902)\n         XR    R0,R0\n         WTO   TEXT=WTOLENG,ROUTCDE=(11),DESC=(2)\n         ABEND 999,DUMP\n*\n*\nJOB_FND  EQU   *\n         L     R14,SSCSPTR         GET ADDRESS TO THE SSCS ARRAYS\n         USING STATSTOR,R14\n         LH    R1,MYSSCS+SSCSDIMR-SSCSBGN      GET ARRAYS USED\n         LA    R15,MYSSCS+SSCSARAY-SSCSBGN     GET MYSSCS ARRAY ADDR\n         AR    R1,R15              GET TO THE END OF DATA\n         ST    R1,SAVEEND          SAVE THIS\n         USING SSCSARAY,R15        ESTAB ADDRESSABILITY\n*\nJOB_LOOP EQU   *\n         C     R15,SAVEEND         COMPARE AGST ENDING ADDR\n         BNL   JOB_EXIT            IF NOT LOW - NOT FOUND\n         TM    SSCSFLG1,SSCSJACT   IS IT ACTIVE ??\n         BO    JOB_ACTV            YEAH - THEN GO THRU\n         LA    R15,SSCSELSZ(,R15)  BUMP TO NEXT ADDR\n         B     JOB_LOOP            BACK TO LOOP\n*\nJOB_ACTV EQU   *\n         MVC   JOBID,SSCSARID      SAVE THE JOBID FOUND\n*\nJOB_EXIT EQU   *\n         DROP  R14\n         L     R14,JOBSR14         RELOAD THE RETURNED ADDRESS\n         BR    R14                 AND BACK TO THE CALLER\n*\n         EJECT\n*\n*\n         DS    0F\nBEGTOKEN DC    XL4'FFFFFFFF'       USED FOR THE 'INITIALIZATION' WTO\nGQSCSIZE DC    AL4(1024*1024*8)    8 MEGABYTES\nPOOL6    EQU   6                   SUBPOOL FOR GQSCAN RETURN AREA\nPOOL7    EQU   7                   LINK LIST USED FOR WTO'S\nPOOL10   EQU   10                  OWNERS LIST\nPOOL11   EQU   11                  WAITERS LIST\nPOOL12   EQU   12                  STORAGE USED FOR 'IEFSSREQ'\n*\nQNAME    DC    CL8'SYSDSN'\n*\nDSNAME   DC    CL44' '\n*\n*\n$PAT5    DC    X'402020202120'\n*\nMSG0     DC    C'QM001 ENQMON IS READY. DATA SET ENQ MONITORING IS NOW *\n               ACTIVE.'\n*\nMSG100   DC    C'QM100 CONTENTION WITH XXXXXXXX NEEDS XXXX ON '\nMSG101   DC    C'QM101 YOU HOLD XXXX ON '\n*\nMSG200   DC    C'QM200 JOB XXXXXXXX OF XXXXXXXX WAITING XXXX ON '\nMSG200A  DC    C'FOR '\nMSG200B  DC    C'XXXXXX MIN'\n*\nMSG201   DC    C'QM201 JOB XXXXXXXX ON XXXXXXXX HOLDS XXXX ON '\n*\nMSG202   DC    C'HOLDING JOB(S):  '\n*\nMSG900   DC    C'QM900 ERROR COMMUNICATING TO JES2. ENQMON IS TEMPORARI*\n               LY SUSPENDED FOR FIVE MINUTES.'\n*\nMSG901   DC    C'QM901 QSCAN SEVERE ERRORS HAVE OCCURRED. ENQMON IS TER*\n               MINATED. PLEASE NOTIFY TECH SERVICES.'\n*\nMSG902   DC    C'QM902 INVALID RETURN CODE FROM IEFSSREQ. ENQMON IS TER*\n               MINATED. PLEASE NOTIFY TECH SERVICES.'\n*\nMSG999   DC    C'QM999 ENQMON HAS TERMINATED. DATA SET ENQ MONITORING I*\n               S NO LONGER ACTIVE.'\n*\n*\nMYCONS   DC    F'0'                MY CONSID\n*\n$DMLENG  EQU   110\n*\nCMDAREA  DS    0CL(CMDEND+L'CMDLEN)\nCMDLEN   DC    AL2(CMDEND)\n*\nCMD      DC    C'$DM'\nCMDJOB   DC    CL8' '\n         DC    C','''\nCMDTEXT  DS    CL($DMLENG)\n         DC    C' '\nCMDEND   EQU   *-CMD\n*\nCOMMANDS MGCRE MF=L\n*\nBLANKTB  DC    256X'FF'\n         ORG   BLANKTB+X'40'\n         DC    X'00'\n         ORG\n         LTORG\n         EJECT\n*\n*\nWKAREA   DSECT\nSA       DS    18F\n*\nDWORD    DS    D\n*\nGQAREA   DS    F\nRIBSLEFT DS    F\nCOMMPTR  DS    F\nWAIT_CNT DS    F                   COUNT OF ALL 'WAITERS'\nOWN_CNT  DS    F                   COUNT OF ALL 'OWNERS'\nTOKEN    DS    F                   TOKEN USED BY 'WTO' AND 'DOM'\nDSNLENG  DS    F\n*\n@OWNERS  DS    F                   ADDRESS OF OWNERS LIST\n@WAITERS DS    F                   ADDRESS OF WAITERS LIST\n*\nLASTLL   DS    F\nSAVENEXT DS    F\n*\nSAVEEND  DS    F                   ENDING ADDRESS FOR SSCS ARRAYS\n*\nTP_R14   DS    F                   SAVED RETURNED ADDRESS\nFLLR14   DS    F                   SAVED RETURNED ADDRESS\nDOMR14   DS    F                   SAVED RETURNED ADDRESS\nWTOR14   DS    F                   SAVED RETURNED ADDRESS\nPROCR14  DS    F                   SAVED RETURNED ADDRESS\nJOBSR14  DS    F                   SAVED RETURNED ADDRESS\n*\nMYADDR   DS    F                   POINTS TO MYSSOB\nSSCSPTR  DS    F                   ADDRESS TO THE SSOB EXTENSION\n*\n         DS    0F\nMYSSOB   DS    CL(SSOBHSIZ)\n*\nJOBASID  DS    H\n*\nWTOLENG  DS    H                   *** DO NOT SEPERATE THESE  ***\nBUFFER   DS    CL133               *** TWO FIELDS             ***\n*\n*\nOWNSYS   DS    CL8                 MY OWN SYSTEM-ID\nJOBID    DS    CL8\n*\nANCHOR   DS    CL(LLLENG)          HEAD OF THE LL CHAIN (DUMMY)\n*\n*\nWKLENG   EQU   *-WKAREA\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     THIS IS THE INFO RELATED TO THE 'OWNERS' & 'WAITERS'      ---*\n*---     TABLES.                                                   ---*\n*---------------------------------------------------------------------*\n*\nMAXLIMIT EQU   1000                MAX # ENTRIES I CAN DEAL WITH\nWAIT_GM  EQU   MAXLIMIT*WAIT_LNG   'MAXLIMIT' OWNERS ALLOWED\nWAIT_LNG EQU   8+8+1+2+8           JOB+SYSID+FLAG+ASID+JES2_JOB_ID\n*\nOWN_GM   EQU   MAXLIMIT*OWN_LNG    'MAXLIMIT' WAITERS ALLOWED\nOWN_LNG  EQU   8+8+1+2             JOB+SYSID+FLAG+ASID\n         EJECT\n*\n*---------------------------------------------------------------------*\n*---     LNKLST IS A LINKED-LIST CHAIN, STARTING OUT WITH A DUMMY  ---*\n*---     LL (ANCHOR).  EACH LL WILL HAVE A POINTER TO ADDRESS      ---*\n*---     THE NEXT LL IN THE CONTROL BLOCK CHAIN.  THESE LL'S WILL  ---*\n*---     BE GETMAIN'ED AS THEY ARE NEEDED.  EACH LL WILL CONTAIN   ---*\n*---     DATA FOR A JOB WAITING ON A SPECIFIC DSNAME, I.E. TOKEN   ---*\n*---     TO BE USED IN 'WTO' AND 'DOM', NUMBER OF MINUTES WAITING. ---*\n*---     AT THE BEGINNING OF EACH SCAN CYCLE, ALL LL'S WILL BE     ---*\n*---     MARKED.  IF AFTER ALL DATA HAS BEEN PROCESSED, AND THE    ---*\n*---     FLAG STAYS THE SAME, THEN THE LL WILL BE FREE'ED (THE     ---*\n*---     CONTENTION FOR THAT SPECIFIC JOB NO LONGER EXISTS).       ---*\n*---------------------------------------------------------------------*\n*\nLNKLST   DSECT\nLLNEXT   DS    F                   NEXT LL ENTRY (X'00000000'=LAST)     E)\nLLWAIT   DS    F                   WAITS IN MINUTES                     E)\nLLTOKEN  DS    F                   TOKEN USED BY 'DOM'                  E)\nLLASID   DS    H                   ASID OF WAITING JOB\nLLFLAG   DS    X\nLLCLEAR  EQU   X'80'               START OF A NEW CYCLE\nLLJOB    DS    CL8                 JOB WAITING ON DSN\nLLJOBNUM DS    CL8                 JES2 JOBID FOR THIS JOB\nLLSYSID  DS    CL8                 SYSID OF WAITING JOB\nLLDSN    DS    CL44                DATA SET IN CONTENTION\nLLLENG   EQU   *-LNKLST            LENG OF LL ENTRY\n         EJECT\n*---------------------------------------------------------------------*\n*---     STORAGE USED FOR 'IEFSSREQ' (LIKE A TSO STATUS COMMAND    ---*\n*---     TO CHECK/OBTAIN THE JOBID FOR A JOB).                     ---*\n*---------------------------------------------------------------------*\nSTATSTOR DSECT\nSTATMAX  EQU   300                 ALLOW 1000 RETURNED ENTRIES\nSTATLENG EQU   STATMAX*SSCSELSZ\nMYSSCS   DS    CL(STATLENG)\n         DS    ((14+62)*(STATMAX+100))C\nSTAT_GM  EQU   *-STATSTOR\n         EJECT\n         PRINT GEN\n         ISGRIB\n         EJECT\n*\nCOM      DSECT\n         IEZCOM\n         EJECT\n*\nCIB      DSECT\n         IEZCIB\n         EJECT\n         PRINT NOGEN\n*\n         CVT   DSECT=YES\n         EJECT\n         IHAASCB DSECT=YES,LIST=YES\n         EJECT\n         IRAOUCB DSECT=YES\n         EJECT\n*\n         IEFJESCT\n         EJECT\n         PRINT GEN\n         IEFJSSOB (CS),CONTIG=NO\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQMON$": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x005_\\x01\\x005_\\x135\\x00\\x03\\x00\\x03\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-20T00:00:00", "modifydate": "2000-12-20T13:35:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "NMVV1"}, "text": "//ENQMON    EXEC PGM=ENQMON,TIME=1440,REGION=8M\n//STEPLIB   DD   DSN=SYS3.TECH.LOAD,DISP=SHR       <----- CHANGE\n//SYSUDUMP  DD   SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENQMON#": {"ttr": 8713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x92\\x13\\x9f\\x01\\x005_\\x134\\x00\\x10\\x00\\x0c\\x00\\t\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "2000-12-20T13:34:00", "lines": 16, "newlines": 12, "modlines": 9, "user": "NMVV1"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS(ENQMON),DISP=SHR         <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n SETCODE AC(1)\n NAME ENQMON(R)                                          <== CHANGE\n/*\n//*\n//*--- NOTE: THE SYSLMOD DDNAME SHOULD POINT TO AN APF LIBRARY\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIT": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x81$_\\x00\\x81)?\\tE\\x005\\x00\\x18\\x00\\x1f[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1981-09-02T00:00:00", "modifydate": "1981-10-20T09:45:00", "lines": 53, "newlines": 24, "modlines": 31, "user": "$VNV"}, "text": "         MACRO\n         EXIT  &RC=,&R=\n.*\n.*--------------------------------------------------------------------\n.*\n.*       MACRO = EXIT\n.*\n.*       AUTHOR = VINH VU\n.*\n.*       DATE-WRITTEN = 09/02/81\n.*\n.*       PURPOSE = TO EXIT FROM A MODULE\n.*             THIS HAS TO BE USED IN CONJUNCTION WITH MACRO\n.*             SET WHICH IS THE INITIALIZATION MACRO.\n.*\n.*       EXAMPLES :\n.*\n.*         *   EXIT RC=10\n.*\n.*             THIS WILL GENERATE A RETURN CODE OF 10. NO FREEMAIN\n.*                WILL BE DONE\n.*\n.*         *   EXIT R=R9\n.*\n.*             THIS WILL GENERATE RETURN CODE FROM CONTENTS OF REG 9.\n.*                A FREEMAIN WILL BE DONE ALSO ASSUMING ADDRESS OF\n.*                GETMAINED AREA IS IN REG13 (DONE IN MACRO SET).\n.*\n.*--------------------------------------------------------------------\n.*\n         GBLC  &SETEXIT\n         AIF   ('&SETEXIT' EQ '').NOFREE\n         LR    R1,R13              GET ADDR OF GMAREA INTO R1\n         L     R13,4(,R13)         GET PREVIOUS SAVE AREA\n         FREEMAIN R,LV=&SETEXIT,A=(R1)\n         AGO   .FREEIT\n.NOFREE  ANOP\n         L     R13,4(,R13)         GET PREVIOUS SAVE AREA\n.FREEIT  ANOP\n         AIF   (T'&RC EQ 'O').CKR\n         LA    R15,&RC             GET RETURN CODE\n         AGO   .THRU\n.CKR     ANOP\n         AIF   (T'&R EQ 'O').NONE\n         LR    R15,&R              GET RETURN CODE\n         AGO   .THRU\n.NONE    ANOP\n         SR    R15,R15             RETURN CODE IS ZERO\n.THRU    ANOP\n         L     R14,12(0,R13)       GET R14\n         LM    R0,R12,20(R13)      GET REG 0 - 12\n         BR    R14                 RETURN TO CALLER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIND": {"ttr": 8717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x84'\\x8f\\x00\\x930\\x0f\\x11\\x07\\x03\\xa6\\x03\\x1c\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1984-10-04T00:00:00", "modifydate": "1993-10-27T11:07:00", "lines": 934, "newlines": 796, "modlines": 0, "user": "$VNV"}, "text": "FIND     TITLE 'FIND     --- TO SEARCH FOR AN ARGUMENT IN A PDS'\n*\n*-------------------------------------------------------------------\n*        PROGRAM - FIND\n*        PURPOSE - TO SEARCH ARGUMENT IN A PDS.\n*        AUTHOR - VINH VU\n*        DATE-WRITTEN - 02/82\n*        MACROS USED -\n*              SET,EXIT,READ,NOTE,POINT,PUTLINE,GETLINE,GETMAIN,\n*              FREEMAIN,OPEN,CLOSE,DCB,DCBD\n*        NOTE -\n*              THIS IS A COMMAND PROCESSOR. ALL MISSING POSITIONAL\n*              PARAMETERS WILL BE PROMPTED AT TERMINAL.\n*\n*        COMMAND FORMAT :\n*              FIND    'XXXXX' S('YYY') LOWER GROUP('TTT') QUICK\n*        WHERE :\n*          *   'XXXX' = PDS TO BE SEARCHED\n*          *   S - STANDS FOR STRING, 'YYY' = ARGUMENT STRING. THIS\n*              IS OPTIONAL. IF NOT ENTERED, YOU WILL BE PROMPTED FOR.\n*          *   LOWER = OPTIONAL KEYWORD. TO USE SEARCH ARGUMENT AS\n*              ENTERED (DO NOT TURN TO UPPERCASE). THE DEFAULT IS\n*              'NOT LOWER'.\n*          *   GROUP = OPTIONAL KEYWORD. TO START SEARCHING ON\n*              MEMBERS WITH NAME PREFIXED BY THIS.\n*          *   QUICK = OPTIONAL KEYWORD. STOP THE SEARCH IN A MEMBER\n*              ONCE THE CHARACTER STRING IS FOUND.  WILL PROCEED TO\n*              NEXT MEMBER.\n*\n*        CHG - 3/9/93 -  VINH VU\n*              CHANGE ALL 'TPUT' TO 'PUTLINE'.  SAME THING, 'TGET' TO\n*              'GETLINE'.\n*-------------------------------------------------------------------\n*\nFIND     CSECT\n         SET   DSECT=WKAREA,LV=WKLENG\n         LR    R11,R1              GET CPPL ADDR\n         USING CPPL,R11            ESTAB ADDR\n         XC    WKPPL,WKPPL         CLEAR OUT PPL\n         LA    R4,WKPPL            GET ADDR OF PPL\n         USING PPL,R4              ESTAB ADDR\n         MVC   PPLUPT,CPPLUPT      GET UPT\n         MVC   PPLECT,CPPLECT      GET ECT\n         XC    MYECB,MYECB         CLEAR MY ECB\n         LA    R1,MYECB            GET A(ECB)\n         ST    R1,PPLECB           GET ECB\n         MVC   PPLPCL,APCL         GET PPLPCL\n         LA    R1,ANS\n         ST    R1,PPLANS           GET ANS\n         MVC   PPLCBUF,CPPLCBUF    GET CBUF\n         CALLTSSR EP=IKJPARS,MF=(E,WKPPL)\n         LTR   R15,R15\n         BNZ   ABEND020\n         L     R7,ANS              GET ANS\n         LA    R1,0(0,R7)          CLEAR OUT TRASH\n         LTR   R1,R1               CHECK IF ANS IS THERE\n         BZ    ABEND020            NOP - THEN ABEND\n         USING IKJPARMD,R7         ESTAB ADDR\n*\n         XC    QKSW,QKSW           TURN OFF 'QK' SW\n         CLI   FQUICK+1,0          IS 'QK' ENTERED ??\n         BE    CKLOWER             NOP - THEN GO THRU\n         MVI   QKSW,X'FF'          ELSE - TURN ON SWITCH\n*\nCKLOWER  EQU   *\n*\n         MVI   UPPER,X'FF'         TURN ON SWITCH\n         CLI   FLOWER+1,0          IS 'LOWER' ENTERED ?\n         BE    NOLOWER             NOP - THEN GO THRU\n         MVI   UPPER,X'00'         ELSE - TURN OFF SWITCH\n*\nNOLOWER  EQU   *\n         MVC   WKDSTEST,BLANK\n         LA    R1,44               GET LENG OF DSNAME\n         STH   R1,WKDST            STORE IT\n         TM    FPDS+6,X'80'        SOURCE NAME THERE ?\n         BZ    ABEND020            NOP - THEN ABEND\n         TM    FPDS+6,X'40'        SOURCE NAME HAS QUOTES ?\n         BZ    PREFIXTS            NOP - THEN PREFIX IT WITH USER-ID\n         L     R1,FPDS             GET POINTER TO SOURCE NAME\n         LH    R2,FPDS+4           GET LENG OF SOURCE NAME\n         BCTR  R2,R0               MINUS 1 FOR EX\n         EX    R2,MVCFPDS          MOVE DSN\n         B     CHECK               GOTO ALLOCIT\n*\nPREFIXTS EQU   *\n         L     R1,CPPLPSCB         GET ADDR OF PSCB\n         USING PSCB,R1             ESTABLISH ADDRESSABILITY\n         MVC   WKDSTEST(L'PSCBUSER),PSCBUSER\n         XR    R15,R15             CLEAR REG 15\n         LA    R14,WKDSTEST        GET ADDR OF WKSOURCE\n         IC    R15,PSCBUSRL        GET LENG OF USER-ID\n         LA    R14,0(R14,R15)      GET TO END OF IT\n         MVI   0(R14),C'.'         MOVE '.' IN THERE\n         DROP  R1                  DROP ADDR\n         L     R1,FPDS             GET POINTER TO SOURCE NAME\n         LH    R2,FPDS+4           GET LENG OF SOURCE NAME\n         BCTR  R2,R0               MINUS 1 FOR EX\n         EX    R2,MVCPFR           MOVE DSN\n         B     CHECK               GO TO ALLOCIT\n*\nMVCFPDS  MVC   WKDSTEST(0),0(R1)\nMVCPFR   MVC   1(0,R14),0(R1)\n*\n*\nCHECK    EQU   *\n         CLI   FKEYWD+1,0          KEY WORD ENTERED ?\n         BE    ALLOCIT             NOP - THEN DO THE GETLINE\n         L     R10,STRING          ELSE - GET POINTER INTO R10\n         LH    R2,STRING+4         GET LENG\n         ST    R2,ARGLENG          STORE LENG\n         BCTR  R2,R0               MINUS 1 FOR EX\n         MVC   ARG,BLANK           BLANK OUT THIS AREA FIRST\n         EX    R2,SAVEARG          SAVE THE ARGUMENT\n         B     THRU                THEN GO THRU\n*\nALLOCIT  EQU   *\n         LA    R1,MSG1             GET MSG\n         LA    R15,L'MSG1          GET LENG\n         BAL   R14,WLINE           NOW WRITE IT\n*\nLOOPGET  EQU   *\n         MVC   BUFFER,BLANK        BLANK THE BUFFER\n         LA    R1,BUFFER           GET ADDR OF BUFFER\n         LA    R15,L'BUFFER        GET LENG OF BUFFER\n         BAL   R14,GETBUF          NOW GET INPUT\n         CLC   BUFFER,BLANK        IS IT STILL BLANK ?\n         BE    ALLOCIT             YEAH - THEN GOBACK TO LOOP\n         TRT   BUFFER,QUOTE        CHECK FOR 1ST QUOTE\n         BC    8,PROMPT            IF NOT FND , GO TO PROMPT\n         LA    R15,BUFFER+L'BUFFER GET TO THE END\n         LA    R1,1(0,R1)          GET PAST THE QUOTE\n         LR    R10,R1              SAVE BEGINNING ADDRESSS\n         SR    R15,R1              GET LENG\n         BZ    PROMPT              IF ZERO THEN GOTO PROMPT\n         BCTR  R15,R0              MINUS 1 FOR EX\n         EX    R15,TRTQUOTE        DO THE SEARCH AGAIN\n         BC    8,PROMPT            IF NOT FND , GO TO PROMPT\n         SR    R1,R10              GET LENG OF ARGUMENT\n         ST    R1,ARGLENG          SAVE ARGUMENT LENG\n         BCTR  R1,R0               MINUS 1 FOR EX\n         MVC   ARG,BLANK           BLANK OUT THIS AREA FIRST\n         EX    R1,SAVEARG          SAVE THE ARGUMENT\n         B     THRU                THEN GO THRU\n*\nTRTQUOTE TRT   0(0,R10),QUOTE      DO THE TRT\nSAVEARG  MVC   ARG(0),0(R10)\n*\nPROMPT   EQU   *\n         LA    R1,MSG2             GET MSG\n         LA    R15,L'MSG2          GET LENG\n         BAL   R14,WLINE           DO PUTLINE\n         B     LOOPGET             GOBACK TO GET\n*\nTHRU     EQU   *\n         CLI   UPPER,X'FF'         SHOULD TURN ON TO UPPERCASE ?\n         BNE   THRU01              NOP - THEN GO THRU\n         TR    ARG,TRTABLE         ELSE - TURN ON TO UPPERCASE\n*\nTHRU01   EQU   *\n*--------------\n         B     THRU02              BYPASS EVERYBODY FOR NOW\n*--------------\n         L     R15,CPPLPSCB        GET PSCB POINTER\n         TM    PSCBATR1-PSCB(R15),PSCBCTRL     OPER ON ?\n         BO    THRU02              YEAH - THEN GO THRU\n         MVC   TESTUSER,BLANK      TO BLANK IT FIRST\n         MVC   TESTUSER(7),PSCBUSER-PSCB(R15)    ELSE - SAVE USER-ID\n         XR    R14,R14             CLEAR REG 14\n         IC    R14,PSCBUSRL-PSCB(R15)   GET LENG OF USER\n         LA    R1,TESTUSER         GET ADDR INTO R1\n         LA    R1,0(R14,R1)\n         MVI   0(R1),C'.'          PUT IN PERIOD\n         EX    R14,TESTDSN         THEN DO THE TEST\n         BE    THRU02              IF EQ THEN LET THRU\n         LA    R1,ERR3             GET MSG\n         LA    R15,L'ERR3          GET LENG\n         BAL   R14,WLINE           THEN PUT OUT MSG\n         B     ENDIT\n*\nTESTDSN  CLC   TESTUSER(0),WKDSTEST\nMOVE     MVC   KGROUP(0),0(R1)\nCOMPARE  CLC   SAVEMEM(0),KGROUP\n*\nTHRU02   EQU   *\n*\n         XC    GROUPSW,GROUPSW     CLEAR GROUPSW\n         TM    PGROUP+6,X'80'      IS GROUP THERE ???\n         BZ    THRU03              NOP - THEN FORGET IT\n         MVI   GROUPSW,X'FF'       TURN ON SWITCH\n         L     R1,PGROUP           ELSE - GET ITS ADDRESS\n         LH    R9,PGROUP+4         GET LENG\n         BCTR  R9,R0               MINUS 1 FOR EXECUTE\n         ST    R9,LGROUP           SAVE LENG FOR LATER COMPARE\n         EX    R9,MOVE             NOW DO THE MOVE\n*\nTHRU03   EQU   *\n         XC    ETAB,ETAB           CLEAR TABLE\n         XR    R9,R9               CLEAR REG 9\n         IC    R9,ARG              GET FIRST BYTE INTO TABLE\n         LA    R9,ETAB(R9)         GET TO THE POINT\n         MVI   0(R9),X'FF'         TURN ON STOP INDICATOR\n         XC    WKDAP08,WKDAP08     CLEAR AREA\n         LA    R9,WKDAP08          GET ADDR INTO R9\n         USING DAPB08,R9           ESTAB ADDR\n         MVC   DA08CD,=XL2'0008'\n         LA    R1,WKDST            GET ADDR OF DSNAME BUFF (TEST)\n         ST    R1,DA08PDSN\n         MVC   DA08DDN,BLANK       BLANK OUT DDNAME\n         MVC   DA08UNIT,=CL8'SYSDA'\n         MVC   DA08SER,BLANK       BLANK SER NO\n         MVC   DA08PSWD,BLANK      BLANK OUT PSWD\n         MVC   DA08MNM,BLANK       BLANK OUT MEMBER NAME\n         OI    DA08DSP1,DA08SHR    SHR\n         DROP  R9\n         XC    WKDAPL,WKDAPL       CLEAR AREA\n         LA    R9,WKDAPL           GET ADDR INTO R9\n         USING DAPL,R9             ESTAB ADDTR\n         MVC   DAPLUPT,CPPLUPT     GET UPT\n         MVC   DAPLECT,CPPLECT     GET ECT\n         XC    MYECB,MYECB         CLEAR MYECB\n         LA    R1,MYECB            GET ITS ADDR\n         ST    R1,DAPLECB          GET IT INTO LIST\n         MVC   DAPLPSCB,CPPLPSCB   GET PSCB\n         LA    R1,WKDAP08          GET ADDR OF DAIR\n         ST    R1,DAPLDAPB         GET IT INTO LIST\n         LA    R1,WKDAPL           GET ADDR OF PARM LIST\n         CALLTSSR EP=IKJDAIR,MF=(E,WKDAPL)\n         LTR   R15,R15             TEST RET CODE\n         BNZ   DAIRERR             BAD - GOTO DAIR ERR\n         LA    R9,WKDAP08          GET ADDR INTO R9\n         USING DAPB08,R9           ESTAB ADDR\n         MVC   SAVEDDTS,DA08DDN    SAVE DD NAME FOR TEST MASTER\n         TM    DA08DSO,X'02'       PDS ???\n         BZ    NOTPDS              NOP - THEN ERROR\n         ZAP   COUNTER,=P'0'\n         ZAP   TOT,=P'0'           ZERO OUT FINAL COUNTER\n         ZAP   MEMTOT,=P'0'        ZERO OUT THE MEMBER TOTAL\n         DROP  R9\n*\n         MVC   WMASTER,MASTER      GET DCB INTO WK AREA\n         MVC   WOPENM,OPENM        MOVE OPEN LIST TO WK AREA\n         LA    R1,WMASTER          GET DCB\n         USING IHADCB,R1           ESTAB ADDR\n         MVC   DCBDDNAM,SAVEDDTS   GET DDNAME\n         DROP  R1                  DROP ADDR\n         OPEN  (WMASTER),MF=(E,WOPENM)\n         LA    R1,WMASTER          GET DCB\n         USING IHADCB,R1           ESTAB ADDR\n         TM    DCBOFLGS,DCBOFOPN   IS OPEN GOOD ?\n         BC    8,BADOPEN           NO - GOTO BAD OPEN\n         MVC   SAVESIZE,DCBBLKSI   SAVE REAL BLK SIZE\n         MVC   SAVERECL,DCBLRECL   SAVE REAL LRECL\n         MVC   DCBBLKSI,H256       BLKSIZE IS 256\n         DROP  R1                  DROP ADDR\n         LA    R5,DIR              GET ADD OF DIR AREA\n         BAL   R9,READNXT          DO THE READ\n         BAL   R9,CHECKIT          DO THE CHECK\n         NOTE  WMASTER             GET CURR TTR\n         LA    R1,1(0,R1)          BUMP IT BY 1\n         ST    R1,TTR              SAVE IT\n         LA    R1,WMASTER          GET DCB ADDR\n         USING IHADCB,R1           ESTAB ADDR\n         LA    R2,LOOPPROC         GET ADDRT OF EODAD\n         STCM  R2,B'0111',DCBEODA  STORE INTO DCB\n         DROP  R1                  DROP ADDR\n         B     LOOPCK              GOTO LOOP\n*\nREADIR   EQU   *\n*\n*--------------\n*        THIS IS A LOOP TO READ DIR\n*--------------\n*\n         LA    R1,WMASTER          GET DCB ADDR\n         USING IHADCB,R1           ESTAB ADDR\n         MVC   DCBBLKSI,H256       BLKSIZE IS 256\n         MVC   SAVEODAD,DCBEODA    SAVE EODAD\n         LA    R2,ENDRPT           GET NEW EODAD\n         STCM  R2,B'0111',DCBEODA\n         DROP  R1                  DROP ADDR\n         POINT WMASTER,TTR         GET TO NEW POS\n         LA    R5,DIR              GET RECORD AREA\n         BAL   R9,READNXT          THEN READ\n         BAL   R9,CHECKIT          AND CHECK THE READ\n         LA    R1,WMASTER          GET DCB ADDR\n         USING IHADCB,R1           ESTAB ADDR\n         MVC   DCBEODA(3),SAVEODAD GET OLD EODAD BACK\n         DROP  R1                  DROP R1\n         NOTE  WMASTER\n         LA    R1,1(0,R1)          BUMP IT BY 1\n         ST    R1,TTR              SAVE THE TTR FOR NEXT TIME\n*\nLOOPCK   EQU   *\n         LA    R1,DIR              GET DIR ADDR\n         LH    R2,DIR              GET THE BYTES USED\n         AR    R1,R2               GET ENDING ADDR\n         ST    R1,SAVEEND          SAVE IT\n         LA    R5,2                GET R5 AS 1ST BASE TO MEM NAME\n         ST    R5,SAVECURR         SAVE CURR POS\n*\nLOOPPROC EQU   *\n*\n*--------------\n*        THIS IS A LOOP TO CHECK DIR ENTRY FOR EACH MEMBER\n*--------------\n*\n         CP    COUNTER,=P'0'       IS COUNTER GREATER THAN 0\n         BE    LOOPPR1             ZERO ? THEN GO THRU\n         AP    TOT,COUNTER         ADD COUNTER TO FINAL TOTAL\n         AP    MEMTOT,=P'1'        ADD 1 TO MEMBER TOTAL\n         MVC   BUFFER,BLANK        CLEAR BUFFER\n         MVC   BUFFER(L'MSG4),MSG4 GET MSG\n         MVC   BUFFER+44(L'SAVEMEM),SAVEMEM\n         MVC   BUFFER+55(L'PAT),PAT\n         ED    BUFFER+55(L'PAT),COUNTER+2\n         LA    R1,BUFFER           GET MSG\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           DO TPUT\n*\nLOOPPR1  EQU   *\n         ZAP   COUNTER,=P'0'       ZERO OUT COUNTER\n         LA    R1,DIR              GET DIR ADDTR\n         L     R5,SAVECURR         GET CURR DISP\n         AR    R1,R5               GET TO CURR POS\n         C     R1,SAVEEND          CHECK AGST ENDING ADDR\n         BNL   READIR              IF END - READ ANOTHER DIR BLK\n         CLC   0(8,R1),=8XL1'FF'   IS THIS LAST MEM\n         BE    ENDRPT              YES - GOTO ENDIT\n         XR    R2,R2               CLEAR REG 2\n         IC    R2,11(R1)           GET NUM\n         N     R2,=F'31'           CLEAN OUT TRASH\n         AR    R2,R2               DOUBLE LENGTH\n         LA    R2,12(0,R2)         PLUS MEM NAME AND MISC\n         A     R2,SAVECURR         ADD TO CURR DISP\n         ST    R2,SAVECURR         SAVE THIS CURR DISP\n*\nGOON     EQU   *\n         LR    R2,R1               R2 HAS GOOD ADDR\n         MVC   SAVEMEM,0(R2)       SAVE MOD NAME\n*\n         CLI   GROUPSW,X'FF'       GROUP SW ON ???\n         BNE   GOON1               NOP - THEN NO CHECK\n         L     R15,LGROUP          GET LENG FOR COMPARE\n         EX    R15,COMPARE         DO THE COMPARE\n         BL    LOOPPR1             LOW - THEN GO BACK\n         BH    ENDRPT              HIGH - THEN TERMINATE\n*\nGOON1    EQU   *\n         XR    R1,R1               CLEAR REG1\n         ICM   R1,B'1110',8(R2)    GET TTR\n         ST    R1,WKTTR            SAVE MEM TTR\n         LA    R1,WMASTER          GET DCB ADDR\n         USING IHADCB,R1           ESTAB ADDR\n         MVC   DCBBLKSI,SAVESIZE   GET REAL BLKSIZE\n         MVC   DCBLRECL,SAVERECL   GET REAL LRECL\n         DROP  R1                  DROP ADDR\n         POINT WMASTER,WKTTR\n         LA    R5,RECORD           GET REC ADDR INTO R5\n         XC    SW,SW               CLEAR BLK SWITCH\n         ZAP   COUNTER,=P'0'       MOVE 0 TO COUNTER\n*\nFIND0010 EQU   *\n         BAL   R9,READNXT          DO THE READ\n         BAL   R9,CHECKIT          DO THE CHECK\n         LA    R8,RECORD           GET ADDR OF RECORD\n         L     R1,WREADM+16        GET IOB ADDR\n         LH    R15,SAVESIZE        GET SAVED SIZE\n         SH    R15,14(R1)          GET RECORD SIZE HERE\n         STH   R15,SAVECNT         SAVE IT\n         LA    R14,RECORD(R15)     GET ENDING ADDR\n         ST    R14,SAVEREC         SAVE IT\n         TM    SW,NEXTBLK          SHOULD CHECK THIS BLK COMPARE ?\n         BZ    FIND0020            NOP - THEN KEEP ON\n         NI    SW,X'FF'-NEXTBLK    TURN OFF SW\n         LH    R14,SAVECOMP        GET SAVE COMP\n         LA    R7,ARG(R14)         GET ADDR OF THE REST OF CONSTANT\n         XR    R1,R1               CLEAR REG 1\n         L     R1,ARGLENG          GET LENG OF CONSTANT\n         SR    R1,R14              R1 HAS RESIDUAL LENG\n         CR    R15,R1              CHECK SAVECNT\n         BL    FIND0020            IS LESS THEN KEEP ON\n         BCTR  R1,R0               MINUS 1 FOR EX\n         EX    R1,CKREST           DO THE COMPARE\n         BNE   FIND0015            IF NOT EQ THEN GO THRU\n         AP    COUNTER,=P'1'       ADD 1 TO COUNTER\n         CLI   QKSW,X'FF'          IS 'QK' SW ON ??\n         BE    LOOPPROC            YEAH - THEN BYE BYE\n*\nFIND0015 EQU   *\n         LA    R8,1(0,R8)          ELSE - RESET R8\n         BCTR  R15,R0              SUBTRACT SAVECNT BY 1\n         STH   R15,SAVECNT         AND RESAVE IT\n*\nFIND0020 EQU   *\n         XR    R15,R15             CLEAR R15\n         ICM   R15,B'0011',SAVECNT GET SAVED COUNT\n         BZ    FIND0010            IF ZERO THEN GOBACK TO READ\n         CH    R15,H256            IS IT GREATER THAN 256\n         BNH   FIND0030            NOP - THEN GO THRU\n         SH    R15,H256            ELSE - SUBTRACT IT BY 256\n         STH   R15,SAVECNT         THEN SAVE IT FOR NEXT TIME\n         LH    R15,H256            LOAD 256 FOR TRT\n         B     FIND0040            THEN GOTO DO TRT\n*\nFIND0030 EQU   *\n         XC    SAVECNT,SAVECNT     ZERO OUT SAVE CNT\n*\nFIND0040 EQU   *\n         BCTR  R15,R0              MINUS 1 FOR EX\n         EX    R15,TRTEE           CHECK FOR X'EE'\n         BC    8,FIND0070          NOT FND - THEN BUMP ADDR\n         L     R14,SAVEREC         GET ENDING ADDR\n         SR    R14,R1              SUBTRACT FOR LENG\n         L     R15,ARGLENG         GET ARG LENG\n         CR    R14,R15             CHECK AGSNT ARG LNG\n         BNL   FIND0060            IF HIGH THEN SKIP THIS\n         STH   R14,SAVECOMP        SAVE THIS LENG\n         BCTR  R14,R0              MINUS 1 FOR EX\n         EX    R14,CLCEE           DO THE COMPARE\n         BNE   FIND0050            IS NOT EQ THEN GO ON\n         OI    SW,NEXTBLK          TURN ON SW FOR NEXT BLK COMPARE\n         B     FIND0010            GOBACK TO READ\n*\nFIND0050 EQU   *\n         LA    R8,1(0,R1)          ELSE - RESET R8\n         L     R15,SAVEREC         GET ENDING ADDR\n         SR    R15,R8              GET RESIDUAL LENG\n         STH   R15,SAVECNT         SAVE IT\n         B     FIND0020            GOBACK TO LOOP\n*\nFIND0060 EQU   *\n         L     R3,ARGLENG          GET ARG LENG\n         BCTR  R3,R0               MINUS 1 FOR EX\n         EX    R3,CLCEE            DO THE COMPARE\n         BNE   FIND0065            IF NOT MATCH - THEN GO THU\n         AP    COUNTER,=P'1'       ADD 1 TO COUNTER\n         CLI   QKSW,X'FF'          IS 'QK' SW ON ??\n         BE    LOOPPROC            YEAH - THEN BYE BYE\n*\nFIND0065 EQU   *\n         LA    R8,1(0,R1)          ELSE - RESET R8\n         L     R15,SAVEREC         GET ENDING ADDR\n         SR    R15,R8              GET RESIDUAL LENG\n         STH   R15,SAVECNT         SAVE IT\n         B     FIND0020            GOBACK TO LOOP\n*\nFIND0070 EQU   *\n         LA    R8,1(R15,R8)        GET TO NEXT ADDR\n         B     FIND0020            GOBACK TO LOOP\n*\nTRTEE    TRT   0(0,R8),ETAB\nCLCEE    CLC   0(0,R1),ARG\nCKREST   CLC   0(0,R8),0(R7)\n*\n*\nREADNXT  EQU   *\n*\n*--------------\n*        AT ENTRY TO THIS ROUTINE, R5 WILL POINT TO THE AREA\n*        FOR THE RECORD TO BE READ INTO\n*--------------\n*\n         MVC   WREADM,READM        MOVE READ LIST TO WK AREA\n         READ  WREADM,SF,WMASTER,(R5),'S',MF=E\n         BR    R9\n         SPACE 3\n*\nCHECKIT  EQU   *\n*\n*--------------\n*        THIS IS TO CHECK AFTER ANY BSAM I/O\n*        WREADM WILL BE THE DECB TO BE CHECKED ON\n*--------------\n*\n         CHECK WREADM\n         BR    R9\n         EJECT\n*\nDAIRERR  EQU   *\n         ST    R15,DAIRRET         SAVE R15\n         LA    R1,ERR2             GET MSG\n         LA    R15,L'ERR2          GET LENG\n         BAL   R14,WLINE           NOW PUT OUT MSG\n         LA    R9,WKDERR           GET ADDR OF DAIRFAIL PARM\n         USING DFDSECTD,R9         ESTAB ADDR\n         LA    R15,WKDAPL\n         ST    R15,DFDAPLP\n         LA    R15,DAIRRET\n         ST    R15,DFRCP\n         LA    R15,HEXZEROS\n         ST    R15,DFJEFF02\n         LA    R15,DAIRBYTE\n         ST    R15,DFIDP\n         LR    R1,R9               GET R1 SET UP\n         MVC   WLINKIT,LINKIT      GET LINK LIST FORM\n         LINK  SF=(E,WLINKIT)\n         LTR   R15,R15             RETN CODE GOOD ?\n         BZ    ENDIT               YEAH - THEN THRU\n         ABEND 30                  ELSE ABEND 30\n*\nABEND020 EQU   *\n         LA    R1,ERR1             GET BUFFER ADDR\n         LA    R15,L'ERR1          GET LENG\n         BAL   R14,WLINE           PUT OUT MSG\n         ABEND 20\n*\nNOTPDS   EQU   *\n         LA    R1,ERR4             GET BUFFER ADDR\n         LA    R15,L'ERR4          GET LENG\n         BAL   R14,WLINE           PUT OUT MSG\n         B     ENDIT               GO TO EXIT\n*\nBADOPEN  EQU   *\n         MVC   BUFFER,MSG3         GET MSG\n         LA    R1,BUFFER           GET BUFFER ADDR\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           PRINT OUT MSG\n         B     ENDIT               GOTO EXIT\n         EJECT\n*\n*\n*\nENDRPT   EQU   *\n         CP    COUNTER,=P'0'       IS COUNTER GREATER THAN 0\n         BE    ENDRPT1             ZERO ? THEN GO THRU\n         MVC   BUFFER,BLANK        CLEAR BUFFER\n         MVC   BUFFER(L'MSG4),MSG4 GET MSG\n         MVC   BUFFER+44(L'SAVEMEM),SAVEMEM\n         MVC   BUFFER+55(L'PAT),PAT\n         ED    BUFFER+55(L'PAT),COUNTER+2\n         LA    R1,BUFFER           GET MSG\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           PRINT OUT MSG\n*\nENDRPT1  EQU   *\n         MVC   BUFFER,BLANK        CLEAR BUFFER\n         LA    R1,BUFFER           GET MSG\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           PRINT OUT MSG\n         MVC   BUFFER,BLANK        CLEAR BUFFER\n         MVC   BUFFER(L'MSG5),MSG5 GET MSG\n         MVC   BUFFER+7(L'PAT1),PAT1\n         ED    BUFFER+7(L'PAT1),MEMTOT+3\n         MVC   BUFFER+55(L'PAT),PAT\n         ED    BUFFER+55(L'PAT),TOT+2\n         LA    R1,BUFFER           GET MSG\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           PRINT OUT MSG\n         CLI   QKSW,X'FF'          'QK' SWITCH ON ??\n         BNE   NONOTES             NO - THEN NO NOTES DISPLAYED\n         MVC   BUFFER,BLANK        CLEAR BUFFER\n         MVC   BUFFER(L'MSG5A),MSG5A GET MSG\n         LA    R1,BUFFER           GET MSG\n         LA    R15,L'BUFFER        GET LENG\n         BAL   R14,WLINE           PRINT OUT MSG\n*\nNONOTES  EQU   *\n         MVC   WCLOSEM,CLOSEM      MOVE CLOSE LIST TO WK AREA\n         CLOSE (WMASTER),MF=(E,WCLOSEM)\n         B     ENDIT\n*\n*\n*\n*---------------\n*        AT ENTRY TO WLINE, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  THIS IS THE MSG BUFFER TO BE DISPLAYED.\n*---------------\n*\nWLINE    EQU   *\n         ST    R14,SAVE14          SAVE RETURN ADDRESS\n         MVC   WMSGLENG,H84        MOVE LENG TO PUTLINE WKAREA\n         XC    WMSGRES,WMSGRES     CLEAR OUT THE RESERVED AREA\n         MVI   WMSG,X'40'          CLEAR OUT MESSAGE AREA\n         MVC   WMSG+1(L'WMSG-1),WMSG\n         CH    R15,=AL2(L'WMSG)    IS MESSAGE GOING TO FIT ??\n         BNH   WLINERDY            YEAH - THEN GO ON\n         LH    R15,=AL2(L'WMSG)    ELSE - USE MAX LENG\n*\nWLINERDY EQU   *\n         BCTR  R15,R0              SUBTRACT 1 FOR 'EX' INSTRUCTION\n         EX    R15,WMOVEMSG        NOW MOVE MSG TO WKAREA\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WPUTBLOK,PUTBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         PUTLINE PARM=WPUTBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               OUTPUT=(WMSGLENG,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    WLINEOK             IF ZERO THEN GET READY TO TERMINATE\n         ABEND 10\n*\nWLINEOK  EQU   *\n         L     R14,SAVE14          LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nWMOVEMSG MVC   WMSG(0),0(R1)       MOVE MESSAGE TO PUTLINE WKAREA\n*\n*\n         EJECT\n*\n*---------------\n*        AT ENTRY TO GETBUF, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  IF THE GETLINE WORKS, THE INPUT BUFFER (DATA\n*        RETURNED BY GETLINE) WILL BE COPIED TO THIS AREA.\n*---------------\n*\n*\nGETBUF   EQU   *\n         ST    R14,SAVE14          SAVE RETURN ADDRESS\n         ST    R1,OUTPTR           SAVE THE BUFFER POINTER\n         ST    R15,OUTLENG         SAVE THE BUFFER LENGTH\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WGETBLOK,GETBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         GETLINE PARM=WGETBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               INPUT=(ISTACK,PHYSICAL),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    GETBUFOK            IF ZERO THEN GET READY TO TERMINATE\n         MVC   BUFFER,BLANK        BLANK OUT MSG BUFFER\n         MVC   BUFFER(L'ERR5),ERR5      GET ERROR MSG TO BUFFER\n         ST    R15,WDWORD          SAVE RC\n         UNPK  WDWORD+5(3),WDWORD+3(2)  UNPACK RC\n         MVC   BUFFER+3(2),WDWORD+5     MOVE TO MESSAGE\n         TR    BUFFER+3(2),NUMTRT-240   MAKE SURE IT'S TRANSLATED RIGHT\n*\n*--------------\n*        NORMALLY, WE CAN CALL WLINE IN HERE, SINCE WLINE SAVE R14\n*        INTO SAVE14 (WHICH WILL OVERLAY OUR SAVE14).  HOWEVER, AFTER\n*        WE CALL WLINE, THE 'ABEND' WILL BE ISSUED AND WE DO NOT NEED\n*        TO RETURN TO OUR CALLER (WHOEVER ISSUED GETBUF).\n*--------------\n*\n         LA    R1,BUFFER\n         LA    R15,L'BUFFER\n         BAL   R14,WLINE           PUT OUT MESSAGE\n         ABEND 999\n*\nGETBUFOK EQU   *\n         L     R1,WGETBLOK+GTPBIBUF-GTPB      GET RET BUF ADDR\n         LH    R14,0(R1)           GET LENG RETURN\n*\n         ST    R14,FREELENG        SAVE LENG TO BE FREEMAIN'ED\n         ST    R1,FREEAREA         SAVE ADDRESS TO DO FREEMAIN\n*\n         C     R14,OUTLENG         COMPARE WITH MY ALLOWED MAX\n         BNH   GETMOVE             IF OK THEN MOVE TO MY BUFFER\n         L     R14,OUTLENG         ELSE - USE MY MAX\n*\nGETMOVE  EQU   *\n         L     R15,OUTPTR          GET ADDR OF MY BUFFER\n         BCTR  R14,R0              SUBTRACT 1 FOR 'EXE' INSTRUCTION\n         EX    R14,MOVEBUF         THEN MOVE DATA TO MY BUFFER\n*\n         L     R3,FREEAREA\n         L     R4,FREELENG\n         FREEMAIN R,A=(R3),LV=(R4),SP=1\n*\n         L     R14,SAVE14          LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nMOVEBUF  MVC   0(0,R15),4(R1)\n*\n*\nENDIT    EQU   *\n         EXIT\n         EJECT\n*\nEIGHTY   EQU   80\nMSG1     DC    C'Enter search argument in quotes'\nMSG2     DC    C'Missing quotes - Re-Enter'\nMSG3     DC    C'Open on ''MASTER'' file has failed'\nMSG4     DC    C'Total Number of Occurrences found in Member XXXXXXXX iX\n               s XXXXXXX'\nMSG5     DC    C'   From XXXXX Members, the Final Total is   ==========X\n               > XXXXXXX'\nMSG5A    DC    C'   Note - QUICK option invoked. Number of occurrences X\n               is always 1 if found'\n*\nERR1     DC    C'IKJPARS ERROR - COMMAND TERMINATED'\nERR2     DC    C'IKJDAIR ERROR - COMMAND TERMINATED'\nERR3     DC    C'Command is restricted to search your own Data Sets OnlX\n               y'\nERR4     DC    C'Data set is not Partitioned. Command Terminated'\nERR5     DC    C'RC=XX - GETLINE error. Command Terminated'\n*\nH4       DC    H'4'\nH84      DC    H'84'\nH256     DC    H'256'\nPAT      DC    X'4020202020202120'\nPAT1     DC    X'402020202120'\n*\n*\n*\n         EJECT\n         DS    0F\nLINKIT   LINK  EP=IKJEFF18,SF=L\nLINKITL  EQU   *-LINKIT\n*\n*\n*\n*\nMASTER   DCB   DSORG=PS,MACRF=(RP),EODAD=ENDRPT,RECFM=U,DDNAME=MASTER\nMASTERL  EQU   *-MASTER            LENG OF THE INPUT DCB\n*\n*\n*\n*\n         DS    0F                  ALIGN ON FWD BOUNDARY\nOPENM    OPEN  (MASTER),MF=L\nOPENML   EQU   *-OPENM\n*\n*\n*\n*\n         DS    0F                  ALIGN ON FWD BOUNDARY\nCLOSEM   CLOSE (MASTER,FREE),MF=L\nCLOSEML  EQU   *-CLOSEM\n*\n*\n*\n*\n         DS    0F\nREADM    READ  HDECB,SF,MASTER,,'S',MF=L\nREADML   EQU   *-READM\n*\n*\n*\nAPCL     DC    A(PCL)\nHEXZEROS DC    F'0'\nDAIRBYTE DC    XL2'0001'\n*\n*\nBLANK    DC    CL80' '\n*\n*\nPUTBLOK  PUTLINE MF=L\nPUTBLOKL EQU   *-PUTBLOK           LENG OF THE PUTLINE LIST FORM\n*\n*\nGETBLOK  GETLINE MF=L\nGETBLOKL EQU   *-GETBLOK           LENG OF THE GETLINE LIST FORM\n*\n*\nNUMTRT   DC    C'0123456789ABCDEF'\n*\n*\n         EJECT\n         SPACE 3\nQUOTE    DS    0CL256\n         DC    256X'00'\n         ORG   QUOTE+C''''         STOP AT QUOTE\n         DC    X'FF'\n         ORG\n         SPACE 3\n*\nTRTABLE  DC    256AL1(*-TRTABLE)\n*\n         ORG   TRTABLE+X'81'       THIS IS LOWER CASE 'A'\n         DC    C'ABCDEFGHI'\n         ORG   TRTABLE+X'91'       THIS IS LOWER CASE 'J'\n         DC    C'JKLMNOPQR'\n         ORG   TRTABLE+X'A2'       THIS IS LOWER CASE 'S'\n         DC    C'STUVWXYZ'\n         ORG\n*\n         EJECT\n*\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\nWKPARM   DS    20F                 THIS IS USED FOR CALL\n*\n         DS    0F\nWLINKIT  DS    CL(LINKITL)\n*\n*\n         DS    0F\nWPUTBLOK DS    CL(PUTBLOKL)        PUTLINE LIST FORM\n*\n*\n         DS    0F\nWGETBLOK DS    CL(GETBLOKL)        GETLINE LIST FORM\n*\n*\n         DS    0F\nWKPPL    DS    CL(PPLLENG)\n         DS    0F\nWKDAPL   DS    CL(DAPLLENG)\n         DS    0F\nWKDAP08  DS    CL(DAP08LEN)\n         DS    0F\nWKDERR   DS    CL(DFLEN)\n*\n*\nECBADS   DS    F                   ECB USED BY PUTLINE\nIOPLADS  DS    4F                  IOPL USED BY PUTLINE\n*\nOUTPTR   DS    F\nOUTLENG  DS    F\n*\n*\nFREELENG DS    F\nFREEAREA DS    F\n*\nTTR      DS    F                   THIS IS SAVED TTR\nWKTTR    DS    F                   THIS IS SAVED TTR\nSAVEEND  DS    F\nSAVECURR DS    F\nSAVESIZE DS    H\nSAVERECL DS    H\nSAVE15   DS    F\nSAVE14   DS    F\nSAVECOMP DS    H\nSAVECNT  DS    H\nSAVEREC  DS    F\nANS      DS    F\nMYECB    DS    F\nDAIRRET  DS    F\nARGLENG  DS    F                   ARGUMENT LENG\nWDWORD   DS    D                   WORK DOUBLE WORD\nSAVEODAD DS    CL3\n         DS    0H\nWKDST    DS    0CL46\n         DS    CL2                 LENG\nWKDSTEST DS    CL44                NAME\n         DS    0H\n*\nSAVEDDTS DS    CL8                 SAVED DDNAME FOR TEST MASTER\nSAVEMEM  DS    CL8                 SAVED MEMBER NAME\n*\n*\nBUFFER   DS    CL80\nARG      DS    CL80                SAVED ARGUMENT\nSW       DS    X\nNEXTBLK  EQU   X'80'\n*\nUPPER    DS    X                   SWITCH USED FOR UPPERCASE\nQKSW     DS    X                   SWITCH USED FOR 'QUICK' OPTION\nCOUNTER  DS    PL6\nTOT      DS    PL6                 THIS IS FINAL TOTAL\nMEMTOT   DS    PL6                 THIS IS TOTAL OF MEMBERS\nTESTUSER DS    CL8\nKGROUP   DS    CL7                 SAVED GROUP PREFIX\nLGROUP   DS    F                   LENG USED TO COMPARE\nGROUPSW  DS    X                   SWITCH\n*\n*\n         DS    0F                  ALIGN ON FWD BOUNDARY\nWMASTER  DS    CL(MASTERL)         WK DCB\n*\n         DS    0F                  ALIGN ON FWD BOUNDARY\nWOPENM   DS    CL(OPENML)\n*\n         DS    0F\nWCLOSEM  DS    CL(CLOSEML)\n*\n         DS    0F\nWREADM   DS    CL(READML)\n*\n*\nWMSGLENG DS    H\nWMSGRES  DS    H\nWMSG     DS    CL80                MSG WORK AREA\n*\nETAB     DS    CL256\n*\n         DS    0F\nDIR      DS    CL256\nRECORD   DS    CL32767             THIS IS A LARGEST BLK\n*\nWKLENG   EQU   *-WKAREA            THIS IS LENG OF GETMAINED AREA\n*\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJPPL\nPPLLENG  EQU   *-PPL               LENG OF PPL\n         EJECT\n         IKJDAPL\nDAPLLENG EQU   *-DAPL              LENG OF DAPL\n         EJECT\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08            LENG\n         EJECT\n         IKJEFFDF DFDSECT=YES\n         EJECT\n         IKJPSCB\n         EJECT\n         DCBD  DSORG=PS\n         EJECT\n         IKJUPT\n         EJECT\n         IKJECT\n         EJECT\n         IKJGTPB\n         EJECT\nFIND     CSECT\n         PRINT NOGEN\nPCL      IKJPARM\nFPDS     IKJPOSIT DSNAME,PROMPT='DSNAME OF PDS',                       X\n               HELP=('DSNAME OF PDS TO BE SEARCHED')\n*\nFKEYWD   IKJKEYWD\n         IKJNAME 'STRING',SUBFLD=FSTRING\n*\nFLOWER   IKJKEYWD\n         IKJNAME 'LOWER'\n*\nFQUICK   IKJKEYWD\n         IKJNAME 'QUICK'\n*\nGROUP    IKJKEYWD\n         IKJNAME 'GROUP',SUBFLD=@GROUP\n*\n*\nFSTRING  IKJSUBF\nSTRING   IKJIDENT 'ARGUMENT STRING',MAXLNTH=80,CHAR,ASIS,              X\n               PROMPT='STRING OF ARGUMENT TO BE SEARCHED'\n*\n@GROUP   IKJSUBF\nPGROUP   IKJIDENT 'MEMBER NAME PREFIX',MAXLNTH=7,                      X\n               FIRST=ALPHA,OTHER=ALPHANUM,                             X\n               PROMPT='MEMBER NAME PREFIX USED FOR SEARCH'\n*\n         IKJENDP\n*\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFUTL": {"ttr": 9220, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x92\\x14\\x0f\\x00\\x92\\x14\\x0f\\x17\\x10\\x02\\xf7\\x02.\\x02\\xf7[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1992-05-19T00:00:00", "modifydate": "1992-05-19T17:10:00", "lines": 759, "newlines": 558, "modlines": 759, "user": "$WKS"}, "text": "//ASM       EXEC PGM=IEUASM,REGION=300K,PARM=('LOAD,NODECK,RENT')\n//SYSGO       DD DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(5,1),RLSE),DCB=(LRECL=80,BLKSIZE=400,\n//             RECFM=FB)\n//SYSUT1      DD UNIT=VIO,SPACE=(CYL,05)\n//SYSUT2      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT3      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSPRINT    DD SYSOUT=*,DCB=(BLKSIZE=121,BUFNO=1)\n//SYSPUNCH    DD SYSOUT=B,DCB=(BLKSIZE=080,BUFNO=1)\n//SYSLIB      DD DSN=SYS1.SMPMTS,DISP=SHR,DCB=BLKSIZE=19040\n//            DD DSN=SYS1.SMPSTS,DISP=SHR\n//            DD DSN=SYS1.HASPSRC,DISP=SHR\n//            DD DSN=SYS1.MACLIB,DISP=SHR\n//            DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSIN       DD *\nIEFUTL CSECT\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              IEFUTL                                   *\n*                                                                     *\n*  MODULE TYPE:              SMF PROCESSING SUBROUTINE                *\n*                                                                     *\n*  LOAD MODULE NAME:         IEFUTL                                   *\n*                                                                     *\n*  LOAD LIBRARY:             SYS1.LPALIB                              *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     RENT                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          RENT,REUS,REFR                           *\n*                                                                     *\n*  MODULE AUTHORIZATION:     KEY 0,PROBLEM STATE                      *\n*                                                                     *\n*  MACROS:                                                            *\n*                                                                     *\n*  MACRO LIBRARIES:          SYS1.MACLIB SYS1.AMODGEN                 *\n*                                                                     *\n*  ABENDS:                   NONE                                     *\n*                                                                     *\n*  FUNCTION:                 THIS MODULE WILL PROCESS TIME            *\n*                            EXCESSIONS. IT WILL AUTO EXTEND,AUTO     *\n*                            CANCEL, REQUEST OPERATOR DECISION. IT    *\n*                            WILL DO ALL OF THE ABOVE A SPECIFIC      *\n*                            NUMBER OF TIMES AND THEN SWITCH TO       *\n*                            ANOTHER MODE.  ALL OF THIS IS CONTROLLED *\n*                            BY A SEPARATLY COMPILED OPTIONS TABLE.   *\n*                                                                     *\n*  PARAMETERS:               R1 :COMMON EXIT PARAMETER LIST           *\n*                                     SEE SMFCET BELOW                *\n*                            R0 :      0     JOB CPU TIME EXCEEDED    *\n*                                      4     STEP CPU TIME EXCEEDED   *\n*                                      8     JOB WAIT TIME EXCEEDED   *\n*                                                                     *\n*                                                                     *\n*  RETURN CODES:             R15:      0     CANCEL JOB               *\n*                                      4     TIME EXTENSION IN TU     *\n*                                      8     TIME EXTENSION IN SEC    *\n*                                                                     *\n*                                                                     *\n*  INTERNAL TABLES:          SEPARATLY COMPILED OPTIONS TABLE         *\n*                                   =V(OTABLE) . SEE MEMBER IEFUTLTB. *\n*                                                                     *\n*                            USER COMMUNICATION AREA IN SMFCET IS     *\n*                               USED TO KEEP COUNT OF EXTENSIONS.     *\n*                                                                     *\n*  CALLED MODULES:           JESJCT                                   *\n*                                                                     *\n*  CALLING MODULES:          SMF EXIT EFFECTOR                        *\n*                                                                     *\n*  PROGRAM FLOW:             GETMAIN STORAGE IN SP 253                *\n*                                                                     *\n*                            DETERMINE CPU ADJUSTMENT FACTOR FOR CPU  *\n*                                TIME EXCESSION                       *\n*                                                                     *\n*                            CALCULATE ACTUAL TCB CPU TIME USED       *\n*                                                                     *\n*                            SEARCH OTABLE FOR CORRECT LINE USING     *\n*                                 JOBCLASS,JOBNAME,TERMINAL,SYSTEM    *\n*                                                                     *\n*                            BRANCH TO CORRECT CODE GROUP FOR         *\n*                                EXCESSION TYPE:                      *\n*                                                                     *\n*                               JWAIT ---  SET REGISTER TO POINT      *\n*                                          TO WAIT TABLE ELEMENT IN   *\n*                                          OTABLE LINE                *\n*                                          BRANCH TO TABLE PROCESS    *\n*                               SCPU  ---  SET REGISTER TO POINT      *\n*                                          TO STEP CPU TABLE ELEMENT  *\n*                                          IN OTABLE LINE             *\n*                                          BRANCH TO TABLE PROCESS    *\n*                               JCPU  ---  SET REGISTER TO POINT      *\n*                                          TO JOB  CPU TABLE ELEMENT  *\n*                                          IN OTABLE LINE             *\n*                                          BRANCH TO TABLE PROCESS    *\n*                                                                     *\n*                            PROCESS TABLE OPTIONS, PERFORM AS        *\n*                                SPECIFIED.                           *\n*                                                                     *\n*                            ISSUE ANY DELAYED MESSAGES               *\n*                                                                     *\n*                            FREEMAIN STORAGE                         *\n*                                                                     *\n*                            RETURN                                   *\n*                                                                     *\n*                                                                     *\n*  PARAMETER LAYOUTS:        SMFCET --- SEE SMFCET BELOW              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN, INFORMATION SERVICES       *\n*                            (214)-334-2031                           *\n*                            FRITO LAY, DALLAS TX                     *\n*                                                                     *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 12-14-83 KIRK STICKEN        *\n*                            12/20/83 USE COMPOSITE CPU TIME FROM     *\n*                                  ASCB AND ACTJTIME IN ACT           *\n*                            04/17/85 ADD JOBNAME,TERMINAL,SYSTEM     *\n*                                  SUPPORT                            *\n*                            11/27/85 CHANGE WTO TO HRDCPY ONLY       *\n*                            01/15/86 ADD JESJCT ROUTINE TO GET       *\n*                                     JOB CARD TIME SAVED IN JES2 XIT6*\n*                                                                     *\n***********************************************************************\nR0       EQU   0                       .\nR1       EQU   1                       .\nR2       EQU   2                       .\nR3       EQU   3                       .\nR4       EQU   4                       .\nR5       EQU   5                       .\nR6       EQU   6                       .\nR7       EQU   7                       .\nR8       EQU   8                       .\nR9       EQU   9                       .\nR10      EQU   10                      .\nR11      EQU   11                      .\nR12      EQU   12                      .\nR13      EQU   13                      .\nR14      EQU   14                      .\nR15      EQU   15                      .\nSUBPOOL  EQU   253                     .  GETMAIN SUBPOOL\n         B     START1-IEFUTL(R15)      .  BRANCH AROUND BLURB\n         DC    AL1(L'@ID)              .  DEFINE ID LENGTH\n@ID      DC    C'IEFUTL'               .  DEFINE PROGRAM ID\n         DC    C'_&SYSDATE._&SYSTIME._REPUBLIC_BANK_DALLAS'\nSTART1   DS    0H                      .\n         STM   R14,R12,12(R13)         .  SAVE MASTERS REGISTERS\n         LR    R9,R13                  .  SAVE R13 ADDRESS\n         LR    R8,R0                   .  SAVE R0 PARM REGISTER\n         BALR  R12,R0                  .  SET UP BASE ADDRESS\n         USING *,R12                   .  AND USE TO RUN WITH\n         LR    R5,R1                   .  SAVE PARM REGISTER\n         L     R2,GETSIZE              .  USE THE GETMAIN SIZE\n         GETMAIN R,LV=(2)              .  GET WORKING STORAGE\n         LR    R0,R1                   .  R0=START OF WORK\n         LR    R4,R1                   .  R4=START OF WORK\n         LA    R1,WORKSIZE             .  R1=LEN OF WORK\n         LR    R2,R0                   .  R2=START OF WORK\n         SR    R3,R3                   .  R3=0\n         MVCL  R0,R2                   .  CLEAR WORKING STORAGE\n         ST    R4,8(R13)               .  STORE OURS THERE\n         ST    R13,4(R4)               .  STORE THEIRS HERE\n         LR    R13,R4                  .  STANDARD REGISTER CONVENTIONS\n         USING WORKX,R13               .  ADDRESS WORKING STORAGE\n         LR    R1,R5                   .  RESTORE PARM REGISTER\n         LR    R0,R8                   .  RESTORE R0 PARM REGISTER\n         LR    R3,R9                   .  RESTORE R13 PARM REGISTER\nBEGIN    DS    0H                      .  BEGIN PROJECT\n         L     R15,=V(JESJCT)          .  GET JOB CARD TIME FROM\n         BALR  R14,R15                 .     JCTUSERF AND PUT IN\n         ST    R15,UTIME               .         UTIME FOR LATER\n         L     R1,0(R1)                .  GET THAT OLD PARM\n         ST    R1,PARMSAVE             .\n         LR    R14,R1                  .\n         USING SMFCET,R14              .\n         MVC   WTOMSG(WTOSL),WTOSHELL  .  INIT WTO AREAS\n         MVC   WTOE(WTORSL),WTORSHEL   .  INIT WTO AREAS\n         MVC   RETCODE,=H'8'           .  DEFAULT IS SECONDS\n         MVC   24(4,R3),=F'1'          .  DEFAULT IS 1 SECOND\n         MVC   FACTOR+2(2),=H'10'      .  DEFAULT CPU FACTOR IS 1.0\n         SR    R9,R9                   .  ADDRESS THE PSA\n         L     R7,PSATOLD-PSA(R9)      .  LOAD THE TCB OLD ADDRESS\n         L     R7,TCBTCT-TCB(R7)       .  GO TO THE TCT\n         L     R7,TCTLCTAD-SMFTCT(R7)  .  GO TO THE LCT\n         ICM   R7,B'0111',LCTJCTAD-LCT+1(R7) . GET THE JCT\n         ICM   R7,B'1000',=F'0'        . CLEAR HIGH BYTE\n         ICM   R7,B'0111',JCTACTAD-INJMJCT(R7) . GET THE ACT\n         A     R7,=F'16'               .  ADDRESS TO ACTUAL ACT\n         XC    WORK,WORK               .\n         MVC   WORK+1(3),ACTJTIME-IEFAACTB(R7) .  MOVE IN OTHER TCB TM\n         L     R9,PSAAOLD-PSA(R9)      .  LOAD THE ASCB OLD ADDRESS\n         CLC   =CL4'ASCB',0(R9)        .  IS IT REALLY ASCB?\n         BE    OKASCB                  .     YUP\n         MVC   MSG,BLANKS              .\n         MVC   MSG(MSG7L),MSG7         .  MOVE IN INTERNAL LOGIC ERR\n         MVC   MJOB,SMFJOB             .  GET JOBNAME\n         WTO   MF=(E,WTOMSG)           .  WRITE OUT MESSAGE\n         B     RETURN                  .\nOKASCB   DS    0H                      .\n         C     R0,=F'8'                .  IS THIS WAIT TIME?\n         BE    DOWAIT1                 .  YES GO FORMAT WAIT TIME\n         LM    R14,R15,ASCBEJST-ASCB(R9)   TCTEJST  JOB TIME\n         SRDA  R14,12                  .  SHIFT UNUSED BITS\n         D     R14,=F'10000'           .  R15=SSSSSS.TH\n         A     R15,WORK                .  ADD IN PRIOR STEPS CPU TIME\n         LR    R14,R15                 .  GO AND DROP OFF THE \"H\"\n         SRDA  R14,32                  .  SHIFT FOR DIVIDE\n         D     R14,=F'10'              .  R15=SSSSSS.T\n         ST    R15,CPUTIME             .  STORE CPU TIME\n         B     CPUDONE                 .  GO CONTINUE\nDOWAIT1  DS    0H                      .\n         L     R14,ASCBSWTL-ASCB(R9)   .  SET WAIT TIME LIMIT SSSS\n         SRDA  R14,32                  .\n         M     R14,=F'10'              .  CPUTIME BECOMES WAIT TIME\n         ST    R15,CPUTIME             .       SSSS.T\n         SLR   R15,R15                 . DO NOT USE JOB CARD TIME\n         ST    R15,UTIME               .   FOR WAIT REASON TIMEOUTS\nCPUDONE  DS    0H                      .\n         L     R14,PARMSAVE            .\n         L     R15,=V(OTABLE)          . GET OPTIONS TABLE\n         L     R9,4(R15)               . OFFSET TO CPU TABLE\n         LR    R11,R9                  .\n         SRA   R11,24                  . HIGH BYTE CONTAINS CPU COUNT\n         ICM   R9,B'1000',=F'0'        . RESET HIGH BYTE\n         LA    R10,6                   . 6 IS CPU TABLE ENTRY LENGTH\n         BALR  R8,R0                   .\nCPULOOP  DS    0H                      .\n         CLC   SMFCPU,0(R9)            .  IS CPU ID HERE\n         BE    CPUFOUND                .  YES, GO SAVE FACTOR\n         LA    R9,0(R10,R9)            .  NO GET NEXT ENTRY\n         BCTR  R11,R8                  .  AND LOOP\nCPUFOUND DS    0H                      .\n         MVC   FACTOR+2(2),4(R9)       .  SAVE CPU FACTOR (IE: 2.5=25)\n         L     R9,0(R15)               .  ADDRESS THE OPTIONS TABLE\n         ICM   R9,B'1000',=F'0'        .  RESET HIGH BYTE\n         USING OTABLE,R9               .  USE IT\n         LA    R8,OENTL                .  GET LENGTH OF EACH LINE\n         LA    R10,OLOOP               .  SET LOOP ADDRESS\nOLOOP    DS    0H                      .\n         BAL   R1,BUILDKEY             .  GO BUILD THE SEARCH KEY\n         CLC   SMFKEY,TABKEY           .  IS THERE A MATCH ON SRCH KEY\n         BE    CLASSFND                .  YES, GO CONTINUE\n         CLC   CLASS,OEND              .  IS IT LAST ENTRY IN TABLE\n         BE    CLASSFND                .  YES, THIS IS DEFAULT\n         LA    R9,0(R8,R9)             .  GET NEXT LINE ENTRY\n         BR    R10                     .  LOOP\nCLASSFND DS    0H                      .\n         ST    R9,LINE                 .  SAVE LINE ADDRESS\n         LR    R9,R0                   .  COPY ENTRY TYPE INTO WORK\n         SRA   R9,2                    .  DIVIDE BY 4\n         ST    R9,X                    .  SAVE INDEX ADDRESS\n         LR    R9,R0                   .  COPY ENTRY TYPE AGAIN\n         L     R10,LINE                .  GET OPTION TABLE LINE\n         B     *+4(R9)                 .  PERFORM BRANCH TABLE\n         B     JCPU                    .    PROCESS JOB CPU\n         B     SCPU                    .            STEP CPU\n         B     JWAIT                   .            JOB WAIT TIME\nJCPU     DS    0H                      .\n         LA    R10,JTYPE-CLASS(R10)    .  ADDRESS JOB CPU ENTRY\n         B     TABLE1                  .\nSCPU     DS    0H                      .\n         LA    R10,STYPE-CLASS(R10)    .  ADDRESS STEP CPU ENTRY\n         B     TABLE1                  .\nJWAIT    DS    0H                      .\n         LA    R10,WTYPE-CLASS(R10)    .  ADDRESS JOB WAIT ENTRY\nTABLE1   DS    0H                      .\n         USING TABLE,R10               .\n         MVC   MSG,BLANKS              .\n         MVC   H2,TIMES                .  MOVE TIMES FIELD TO HWORD\n         MVC   H3,AMT                  .  MOVE AMOUNT FIELD TO HWORD\n         CLC   TYPE,CANCEL             .  IS TYPE=CANCEL\n         BNE   NOCAN                   .  NO, CHECK ANOTHER\nDOCANCEL DS    0H                      .\n         MVC   MSG,BLANKS              .  BLANK OUT AREA FIRST\n         MVC   MSG(MSG1L),MSG1         .  MOVE IN CANCEL MESSAGE\n         L     R9,CPUTIME              .\n         CVD   R9,DWORK                .\n         MVC   XTIME,=X'4020202020202020214B20' .\n         ED    XTIME,DWORK+3           . MOVE IN CPUTIME\n         OI    XTIME+L'XTIME-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MTIME,XTIME+1           . MOVE JOB INTO MESSAGE\n         MVC   MJOB,SMFJOB             . MOVE JOB INTO MESSAGE\n         MVC   RETCODE,=H'0'           . CANCEL JOB\n         OI    FLAGS,DIDCAN            . REMEMBER DID NORMAL CANCEL\n         B     RETURN                  .\nNOCAN    DS    0H                      .\n         CLC   TYPE,AUTO               . IS IT AUTO EXTEND\n         BNE   NOAUT1                  . IT IS NOT THIS KIND OF AUTO\nDOAUTO   L     R7,X                    . GET COUNT INDEX\n         SR    R6,R6                   .\n         IC    R6,SMFUSER(R7)          . INDEX TO COUNT BYTE IN USER\n         A     R6,=F'1'                . ADD 1 TO IT\n         LH    R4,H3                   . GET AMOUNT TO EXTEND FROM\n         SRDA  R4,32                   .     TABLE (IN SECONDS)\n         M     R4,=F'38400'            . MULTIPLY BY TU PER SECOND\n         ST    R5,24(R3)               . SAVE IN R1 SAVE AREA\n         CH    R6,H2                   . HAVE WE EXCEEDED EXTEND COUNT\n         BH    EXCEEDOP                . YES GO DO EXCEED OPTION\n         STC   R6,SMFUSER(R7)          . SAVE EXCEED COUNT\n         MVC   RETCODE,=H'4'           . EXTEND JOB IN TU\n         MVC   MSG(MSG2L),MSG2         . MOVE IN AUTO EXTEND MESSAGE\n         L     R9,CPUTIME              .\n         CVD   R9,DWORK                .\n         MVC   XTIME,=X'4020202020202020214B20' .\n         ED    XTIME,DWORK+3           . MOVE IN CPUTIME\n         OI    XTIME+L'XTIME-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MTIME,XTIME+1           . MAKE SIGN PRINTABLE\n         LH    R9,H3                   . GET EXTEND AMOUNT\n         CVD   R9,DWORK                .\n         MVC   MEXTD,=X'402020202021'  . MOVE IN EDIT PATTERN\n         ED    MEXTD,DWORK+5           . MOVE IN EXTEND AMOUNT\n         OI    MEXTD+L'MEXTD-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MJOB,SMFJOB             . MOVE JOB INTO MESSAGE\n         OI    FLAGS,DIDAUT            . REMEMBER DID NORMAL AUTO\n         B     RETURN                  .\nNOAUT1   DS    0H                      .\n         CLC   TYPE,CLASSAUT           . IS IT CLASSAUTO\n         BNE   NOAUT2                  . NOT THIS KIND OF AUTO EITHER\nDOCLAUTO DS    0H                      .\n         L     R9,X                    . GET COUNT INDEX\n         SR    R6,R6                   .\n         IC    R6,SMFUSER(R9)          . INDEX TO COUNT FIELD\n         A     R6,=F'1'                . ADD 1 TO IT\n         MVC   RETCODE,=H'4'           . EXTEND TIME IN TU\n         LH    R4,H3                   . GET CLASS MAX AMT FROM TABLE\n         SRDA  R4,32                   .\n         M     R4,FACTOR               . R5=CPU ADJUSTED CPU MAX TIME\n         L     R15,UTIME               .\n         C     R15,=F'0'               .\n         BNH   NOUTIME                 .\n         CR    R5,R15                  . IS R5 <= USER JOB CARD TIME\n         BL    NOUTIME                 .   YES, SKIP TIME OVERRIDE\n         L     R5,UTIME                .\nNOUTIME  DS    0H                      .\n         S     R5,CPUTIME              . R5=DIFF TO ALLOT SSSS.T\n         LR    R4,R5                   .\n         SRDA  R4,32                   .\n         D     R4,=F'10'               . R5=DIFF IN SECONDS\n         CH    R6,H2                   . EXCEEDED EXTEND COUNT?\n         BH    EXCEEDOP                . YES, GO DO EXCEED OPTION\n         C     R5,=F'1'                . IS AMOUNT TO EXTEND < 1 SEC\n         BL    EXCEEDOP                . YES, GO DO EXCEED OPTION\n         STC   R6,SMFUSER(R9)          . PUT EXCEED COUNT BACK\n         MVC   RETCODE,=H'4'           . EXTEND JOB IN TU\n         LR    R4,R5                   . SHIFT\n         SRDA  R4,32                   .  FOR BIG\n         ST    R5,WORK                 .\n         M     R4,=F'38400'            .    MULTPLICATION\n         ST    R5,24(R3)               . SAVE IN R1 SAVE AREA\n         MVC   MSG(MSG2L),MSG2         . MOVE IN AUTO EXTEND MESSAGE\n         L     R9,CPUTIME              .\n         CVD   R9,DWORK                .\n         MVC   XTIME,=X'4020202020202020214B20' .\n         ED    XTIME,DWORK+3           . MOVE IN CPUTIME\n         OI    XTIME+L'XTIME-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MTIME,XTIME+1           . MAKE SIGN PRINTABLE\n         L     R9,WORK                 . GET EXTEND AMOUNT\n         CVD   R9,DWORK                .\n         MVC   MEXTD,=X'402020202021'  . MOVE IN EDIT PATTERN\n         ED    MEXTD,DWORK+5           . MOVE IN EXTEND AMOUNT\n         OI    MEXTD+L'MEXTD-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MJOB,SMFJOB             . MOVE JOB INTO MESSAGE\n         OI    FLAGS,DIDCLAUT          . REMEMBER DID CLASS AUTO\n         B     RETURN                  .\nNOAUT2   DS    0H                      .\n         CLC   TYPE,OPER               .  IS OPER INVOLVED\n         BNE   NOOPER                  .\nDOOPER   DS    0H                      .\n         L     R9,X                    .\n         SR    R6,R6                   .\n         IC    R6,SMFUSER(R9)          .  GET EXTEND COUNT\n         A     R6,=F'1'                .  ADD 1 TO IT\n         CH    R6,H2                   .  EXCEEDED EXTEND COUNT?\n         BH    EXCEEDOP                .  YES, GO DO EXCEED OPTION\n         STC   R6,SMFUSER(R9)          .  PUT IF BACK FOR LATER\nDOOPERL  DS    0H                      .\n         MVC   MSG,BLANKS              .\n         MVC   MSG(MSG3L),MSG3         .  MOVE IN EXCEEDED MESSAGE\n         MVC   MJOB,SMFJOB             .  MOVE IN JOBNAME\n         L     R5,X                    .  SET\n         SLA   R5,3                    .    UP\n         LA    R5,TYPEM(R5)            .     EXCESSION TYPE\n         MVC   MTYPE,0(R5)             .  MOVE IN MESSAGE TYPE\n         MVC   MSGE,BLANKS             .\n         MVC   MSGE(MSG3L),MSG         .  MOVE MSG INTO REPLY WTO\n         XC    ECB,ECB                 .  CLEAR ECB\n         WTOR  ,REPLY,2,ECB,MF=(E,WTOE) . ASK OPER ABOUT IT\n         L     R14,PARMSAVE            .  RESTORE SMFCET ADDRESS\n         WAIT  ECB=ECB,LONG=YES        .  AWAIT REPLY\n         TRT   REPLY,REPLYTAB          .  VERIFY NUMERICS\n         BZ    OKREPLY                 .  ZERO IF NUMERIC\n         MVC   MSG,BLANKS              .  SET UP\n         MVC   MSG(MSG4L),MSG4         .    INVALID REPLY\n         WTO   MF=(E,WTOMSG)           .      MESSAGE\n         B     DOOPERL                 .      AND LOOP\nOKREPLY  DS    0H                      .\n         PACK  DWORK,REPLY             .  PACK REPLY\n         CVB   R8,DWORK                .  AND MAKE IT BINARY\n         C     R8,=F'1'                .  IS IT 00 (IE: CANCEL)\n         BL    DOCANCEL                .  YES, GO CANCEL FOOL\n         SRDA  R8,32                   .  WE MUST CONVERT TO\n         M     R8,=F'60'               .   SECONDS SO MULT BY 60*38400\n         ST    R9,WORK                 .\n         M     R8,=F'38400'            .   SECONDS SO MULT BY 60*38400\n         ST    R9,24(R3)               .  SAVE IN R1 SAVE AREA\n         MVC   RETCODE,=H'4'           .  EXTEND TIME IN TU\n         MVC   MSG(MSG2L),MSG2         . MOVE IN AUTO EXTEND MESSAGE\n         L     R9,CPUTIME              .\n         CVD   R9,DWORK                .\n         MVC   XTIME,=X'4020202020202020214B20' .\n         ED    XTIME,DWORK+3           . MOVE IN CPUTIME\n         OI    XTIME+L'XTIME-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MTIME,XTIME+1           . MAKE SIGN PRINTABLE\n         L     R9,WORK                 . GET EXTEND AMOUNT\n         CVD   R9,DWORK                .\n         MVC   MEXTD,=X'402020202021'  . MOVE IN EDIT PATTERN\n         ED    MEXTD,DWORK+5           . MOVE IN EXTEND AMOUNT\n         OI    MEXTD+L'MEXTD-1,X'F0'   . MAKE SIGN PRINTABLE\n         MVC   MJOB,SMFJOB             . MOVE JOB INTO MESSAGE\n         OI    FLAGS,DIDOPER           . REMEMBER WE ASKED OPER BOUTIT\n         B     RETURN                  .\nEXCEEDOP DS    0H                      .\n         CLC   EOPT,CANCEL             . IS EXCEED OPTION = CANCEL\n         BE    DOCANCEL                . YES GO DO CANCEL\n         CLC   EOPT,OPER               . IS EXCEED OPTION = OPER\n         BE    DOOPERL                 . YES, GO DO OPERATOR STUFF\n         MVC   MSG,BLANKS              . INVALID EXCEED OPTION\n         MVC   MSG(MSG5L),MSG5         . MOVE IN \"WHAT THE H*LL\" MSG\n         MVC   MJOB,SMFJOB             .\n         WTO   MF=(E,WTOMSG)           . SEND OUT INVALID EXCEED OPT\n         MVC   REPLY,=C'05'            . EXTEND 5 MINUTES DEFAULT\n         B     OKREPLY                 .\nNOOPER   DS    0H                      . INVALID EXCEED TYPE\n*                                      .   (DONT KNOW WHAT TO DO)\n         MVC   MSG,BLANKS              .\n         MVC   MSG(MSG6L),MSG6         . MOVE IN \"WHAT THE SH*T\" MSG\n         MVC   MJOB,SMFJOB             .\n         WTO   MF=(E,WTOMSG)           .\n         MVC   REPLY,=C'05'            . EXTEND 5 MINUTES DEFAULT\n         B     OKREPLY                 .\nRETURN   DS    0H                      .  BUZZ THIS JOINT\n         L     R5,X                    .\n         SLA   R5,3                    .\n         LA    R5,TYPEM(R5)            .\n         MVC   MTYPE,0(R5)             .  MOVE IN MESSAGE TYPE\n         TM    FLAGS,DIDOPER           .  DID WE ASK OPERATOR?\n         BO    PUTITOUT                .     YES, WRITE WTO MSG\n         TM    FLAGS,DIDCAN            .  DID WE DO A CANCEL\n         BO    PUTITOUT                .\n         B     NOPUTOUT                .  DONT PUT OUT TODAY\nPUTITOUT DS    0H                      .\n         WTO   MF=(E,WTOMSG)           .  WRITE THIS MESSAGE\nNOPUTOUT DS    0H                      .\n         LH    R3,RETCODE              .  GET MODULE RETURN CODE\n         L     R1,GETSIZE              .  USE GETMAIN SIZE\n         LR    R2,R13                  .  SAVE WORK ADDRESS\n         L     R13,4(R13)              .  GET THEIR SAVE AREA ADDRESS\n         L     R14,12(R13)             .  GET RETURN ADDRESS\n         FREEMAIN R,LV=(1),A=(2)       .  FREE WORKING STORAGE\n         LR    R15,R3                  .  RESTORE RETURN CODE\n         LM    R0,R12,20(R13)          .  RESTORE ALL BUT R15\n         BR    R14                     .  RETURN TO CALLER\nBUILDKEY DS    0H                      .\n         STM   R0,R15,SAVE1            .  SAVE IT ALL FOR LATER\n         MVC   TABKEY,0(R9)            .  MOVE IN TABLE KEY DATA\n         MVC   SMFKEY(L'SMFJC),SMFJC   .  MOVE IN JOBCLASS\n         TM    SMFSMFO,X'01'           .  IS THIS FOREGROUND\n         BNO   BSKIP1                  .  SKIP NEXT INSTR\n         MVC   SMFKEY(L'OTSU),OTSU     .  MAKE CLASS TSU IN KEY\nBSKIP1   DS    0H                      .\n         MVC   SMFKEY+L'SMFJC(L'SMFJOB),SMFJOB  . MOVE IN JOBNAME\n         MVC   SMFKEY+L'SMFJC+L'SMFJOB+L'ACEETRID(L'SMFCPU),SMFCPU\n         SR    R15,R15                 .  ADDRESS THE PSA\n         L     R15,PSAAOLD-PSA(R15)    .  GET OLD ASCB\n         L     R15,ASCBASXB-ASCB(R15)  .  GET THE ASXB\n         L     R15,ASXBSENV-ASXB(R15)  .  GET THE ACEE\n         MVC   SMFKEY+L'SMFJC+L'SMFJOB(L'ACEETRID),ACEETRID-ACEE(R15)\n         LA    R1,SMFKEY               .  GET FIRST CHAR OF SMFKEY POS\n         LA    R2,TABKEY               .  GET FIRST CHAR POS OF TABKEY\n         LA    R3,L'TABKEY             .  LIMIT THE LOOPING THIS WAY\n         LA    R4,BLOOP                .  AND MAKE FOR A FASTER LOOP\nBLOOP    CLC   0(1,R2),=C'*'           .  DOES TABKEY(I)='*'\n         BNE   BCONT                   .     NO, GET NEXT CHAR\n         MVC   0(1,R1),=C'*'           .     YES, MAKE SMFKEY(I)='*'\nBCONT    LA    R1,1(R1)                .  GET NEXT CHAR IN SMFKEY\n         LA    R2,1(R2)                .      AND TABKEY\n         BCTR  R3,R4                   .  LOOP UNTIL TABKEY CHARS PROCD\n         LM    R0,R15,SAVE1            .  REMEMBER THIS STUFF???\n         BR    R1                      .  RETURN AGAIN\nGETSIZE  DS    0F                      .  WORKING STORAGE LENGTH\n         DC    AL1(SUBPOOL)            .  AND SUBPOOL\n         DC    AL3(WORKSIZE)           .\nTYPEM    DC    C'JOB CPU '             .\n         DC    C'STEP CPU'             .\n         DC    C'JOB WAIT'             .\nBLANKS   DC    121CL1' '               .\nMSG1     DC    C'IEFUTL1 JOB=12345678 12345678 EXCEEDED,TIME=123456789'\n         DC    C'A JOB CANCELED'        .\nMSG1L    EQU   *-MSG1                  .\nMSG2     DC    C'IEFUTL2 JOB=12345678 12345678 EXCEEDED,TIME=123456789'\n         DC    C'A AUTO EXTEND=123456 SECONDS'\nMSG2L    EQU   *-MSG2                  .\nMSG3     DC    C'IEFUTL3 JOB=12345678 12345678 EXCEEDED,ENTER MINUTES '\n         DC    C'\"MM\" TO EXTEND,OR \"00\"'\nMSG3L    EQU   *-MSG3                  .\nMSG4     DC    C'IEFUTL4 INVALID REPLY FOR TIME EXTENSION'\nMSG4L    EQU   *-MSG4                  .\nMSG5     DC    C'IEFUTL5 JOB=12345678 INVALID EXCESSION OPTION, TIME E'\n         DC    C'XTENDED BY 5 MINUTES'\nMSG5L    EQU   *-MSG5                  .\nMSG6     DC    C'IEFUTL6 JOB=12345678 INVALID OPTIONS TABLE (OPTION TY'\n         DC    C'PE). TIME EXTENDED BY 5 MINUTES'\nMSG6L    EQU   *-MSG6                  .\nMSG7     DC    C'IEFUTL7 JOB=12345678 INTERNAL LOGIC ERROR. TIME EXTEN'\n         DC    C'DED BY 1 SECOND.'\nMSG7L    EQU   *-MSG7                  .\nWTOSHELL WTO   '                                                       X\n                                                                       X\n                         ',ROUTCDE=(11),DESC=(7),MF=L\nWTOSL    EQU   *-WTOSHELL              .\nWTORSHEL WTOR  '                                                       X\n                                                                       X\n                         ',ROUTCDE=(11),DESC=(7),MF=L\nWTORSL   EQU   *-WTORSHEL              .\nCANCEL   DC    XL1'04'                 .\nAUTO     DC    XL1'01'                 .\nCLASSAUT DC    XL1'02'                 .\nOPER     DC    XL1'03'                 .\nREPLYTAB DS    0C                      .\n         DC    256XL1'04'              .\n         ORG   REPLYTAB+C'0'           .\n         DC    10XL1'00'               .\n         ORG   ,                       .\nOEND     DC    XL1'FF'                 .\nOTSU     DC    XL1'00'                 .\nSMFCET   DSECT                         .\nSMFJOB   DS    CL8                     .  JOB NAME\nSMFTS    DS    BL4                     .  TIME STAMP\nSMFDS    DS    PL4                     .  DATE STAMP\nSMFCPU   DS    CL4                     .  SYSTEM ID\nSMFUID   DS    CL8                     .  USERID\nSMFSTEP  DS    XL1                     .  STEPNUMBER\nSMFSMFO  DS    XL1                     .  SMF OPT\nSMFRSTO  DS    XL1                     .  RESTART IND\nSMFJC    DS    CL1                     .  JOB CLASS\nSMFUSER  DS    CL4                     .  USER COMMUNICATION\nOTABLE   DSECT                         .\nCLASS    DS    CL1                     .  JOB CLASS\nOJOB     DS    CL8                     .     JOB NAME\nOTERM    DS    CL8                     .       TERMINAL\nOSYS     DS    CL4                     .         SYSTEM\nKEYLEN   EQU   *-CLASS                 .\nWTYPE    DS    CL1                     .  JOB WAIT ELEMENTS\nWAMT     DS    H                       .\nWTIMES   DS    H                       .\nWEOPT    DS    CL1                     .\nSTYPE    DS    CL1                     .  STEP CPU ELEMENTS\nSAMT     DS    H                       .\nSTIMES   DS    H                       .\nSEOPT    DS    CL1                     .\nJTYPE    DS    CL1                     .  JOB CPU ELEMENTS\nJAMT     DS    H                       .\nJTIMES   DS    H                       .\nJEOPT    DS    CL1                     .\nJFILL01  DS    CL1                     .\nOENTL    EQU   *-CLASS                 .\nTABLE    DSECT                         .\nTYPE     DS    CL1                     .\nAMT      DS    CL2                     .\nTIMES    DS    CL2                     .\nEOPT     DS    CL1                     .\nWORKX    DSECT                         .\nSAVE     DS    18F                     .  SAVE AREA LOCATION\nSAVE1    DS    18F                     .  SAVE AREA LOCATION\nSMFKEY   DS    CL(KEYLEN)              .  SEARCH KEY\nTABKEY   DS    CL(KEYLEN)              .  SEARCH KEY\nRETCODE  DS    H                       .  MODULE RETURN CODE\n         DS    D                       .\nWTOMSG   WTO   '                                                       X\n                                                                       X\n                         ',MF=L\n         ORG  WTOMSG+4                 .\nMSG      DS    CL121                   .\n         ORG   MSG+12                  .\nMJOB     DS    CL8                     .\n         DS    CL1                     .\nMTYPE    DS    CL8                     .\n         ORG   MSG+44                  .\nMTIME    DS    CL10                    .\n         ORG   MSG+67                  .\nMEXTD    DS    CL6                     .\n         ORG   ,                       .\n         DS    D                       .\nWTOE     WTOR  '                                                       X\n                                                                       X\n                         ',MF=L\n         ORG   WTOE+12                 .\nMSGE     DS    CL121                   .\n         ORG   ,                       .\n         DS    D                       .\nDWORK    DS    D                       .\nWORK     DS    F                       .\nFACTOR   DS    F                       .\nCPUTIME  DS    F                       .\nLINE     DS    F                       .\nX        DS    F                       .\nXTIME    DS    CL11                    .\nECB      DS    F                       .\nREPLY    DS    CL2                     .\nPARMSAVE DS    F                       .\nH2       DS    H                       .\nH3       DS    H                       .\nFLAGS    DS    CL1                     .\nDIDCLAUT EQU   B'10000000'             .\nDIDAUT   EQU   B'01000000'             .\nDIDOPER  EQU   B'00100000'             .\nDIDCAN   EQU   B'00010000'             .\nF05      EQU   B'00001000'             .\nF06      EQU   B'00000100'             .\nF07      EQU   B'00000010'             .\nF08      EQU   B'00000001'             .\nUTIME    DS    F                       .\nWORKSIZE EQU   *-WORKX                 .\n         PRINT NOGEN                   .\n         IKJTCB ,                      .  TCB STRUCTURE\n         DSECT                         .\n         IHAPSA ,                      .  PREFIX SAVE AREA\n         DSECT                         .\n         IHAASCB ,                     .  ADDRESS SPACE CTL BLOCK\n         DSECT                         .\n         IHAASXB ,                     .  ADDRESS SPACE XTENSION BLOCK\n         DSECT                         .\n         IHAACEE ,                     .  ACCESS CONTROL ENV ELEMENT\n         DSECT                         .\n         IEFAJCTB ,                    .  JCT STRUCTURE\nLCT      DSECT                         .\n         IEFALLCT ,                    .  LCT STRUCTURE\n         DSECT                         .\n         IEFTCT ,                      .  TCT STRUCTURE\n         END   IEFUTL\n//ASM2      EXEC PGM=IEUASM,REGION=300K,PARM=('LOAD,NODECK,RENT,TEST')\n//SYSGO       DD DSN=&&LOADSET,DISP=(MOD,PASS),\n//             DCB=(LRECL=80,BLKSIZE=400,\n//             RECFM=FB)\n//SYSUT1      DD UNIT=VIO,SPACE=(CYL,05)\n//SYSUT2      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT3      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSPRINT    DD SYSOUT=*,DCB=(BLKSIZE=121,BUFNO=1)\n//SYSPUNCH    DD SYSOUT=B,DCB=(BLKSIZE=080,BUFNO=1)\n//SYSLIB      DD DSN=SYS1.SMPMTS,DISP=SHR,DCB=BLKSIZE=19040\n//            DD DSN=SYS1.SMPSTS,DISP=SHR\n//            DD DSN=SYS1.HASPSRC,DISP=SHR\n//            DD DSN=SYS1.MACLIB,DISP=SHR\n//            DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSIN       DD *\nJESJCT  CSECT                          .\n        PUSH  PRINT                    .\n        PRINT NOGEN                    .\n         CVT  DSECT=YES,LIST=NO        .\n         IHAPSA                        .\n         IKJTCB                        .\n         IEFJESCT                      .\n         IEFJSSIB                      .\n         IEZJSCB                       .\n         IEFJSCVT                      .\n         COPY $HASPGBL                 .\n        $HASPEQU                       .\n        $PCE                           .\n        $JQE                           .\n        $MIT                           .\n        $BUFFER                        .\n        $JCT                           .\n        DROP   R10                     .   JCT DOESNT USE R10\n        $SJB                           .\n        $CAT                           .\n        $HCT                           .\n        $SCAT                          .\n        $XECB                          .\n        $SVT                           .\nSMFCET   DSECT                         .\nSMFJOB   DS    CL8                     .  JOB NAME\nSMFTS    DS    BL4                     .  TIME STAMP\nSMFDS    DS    PL4                     .  DATE STAMP\nSMFCPU   DS    CL4                     .  SYSTEM ID\nSMFUID   DS    CL8                     .  USERID\nSMFSTEP  DS    XL1                     .  STEPNUMBER\nSMFSMFO  DS    XL1                     .  SMF OPT\nSMFRSTO  DS    XL1                     .  RESTART IND\nSMFJC    DS    CL1                     .  JOB CLASS\nSMFUSER  DS    CL4                     .  USER COMMUNICATION\n         POP   PRINT                   .\nJESJCT   CSECT\n         STM   R14,R12,12(R13)         .  SAVE ALL REGISTERS\n         LR    R12,R15                 .  SET UP BASE ADDR FOR MOI\n         USING JESJCT,R12              .  AND USE MYSELF BY NAME\n         L     R3,0(R1)                .  GET SMFCET POINTER\n         USING SMFCET,R3               .\n         SLR   R2,R2                   .  RESULT WILL SHOW UP IN R2\n         L     R15,PSATOLD-PSA(R2)     .  PULL UP TCB\n         L     R15,TCBJSCB-TCB(R15)    .  POINT TO JSCB\n         L     R15,JSCBACT-IEZJSCB(R15) . POINT TO ACTIVE JSCB\n         L     R9,JSCBSSIB-IEZJSCB(R15) . POINT TO SSIB\n         USING SSIB,R9                 .\n         L     R15,16                  .  GET CVT AGAIN\n         L     R15,CVTJESCT-CVT(R15)   .  GET JES CONTROL TAB\n         L     R15,JESSSCT-JESCT(R15)  .  GET FIRST SSCT\n         USING SSCT,R15                .\nRECHECK  DS    0H                      .\n         CLC   SSCTSNAM,SSIBSSNM       .  CHECK SUBSYSTEM MATCH\n         BE    CONT01                  .\n         L     R15,SSCTSCTA            .  GET NEXT SUBSYS PTR\n         CL    R15,=F'0'               .    IS IT SET?\n         BE    NOTIME                  .      NO, GET OUT\n         B     RECHECK                 .\nCONT01   DS    0H                      .\n         DROP  R15                     .\n         L     R8,SSCTSSVT-SSCT(R15)   .  GET SSVT\n         USING $SVDSECT,R8             .  USE BY NAME\n         L     R15,$SVJXCLS            .  GET BATCH QUEUE\n         TM    SMFSMFO,X'01'           .  IS THIS TSO?\n         BNO   NOJCTSU                 .  NOT TSO\n         L     R15,$SVJXNUM            .  GET TSO QUEUE\nNOJCTSU  DS    0H                      .\n         USING SJBDSECT,R15            .  USE BY NAME\nRECHECK1 DS    0H                      .\n         CL    R15,=F'0'               .  NO MORE SJBS\n         BE    NOTIME                  .\n         CLC   SMFJOB,SJBJOBNM         .  IS IT A MATCH ON JOB NAME\n         BE    FOUND                   .\n         L     R15,SJBXQCHN            .  POINT TO NEXT SJB\n         B     RECHECK1                .\nFOUND    DS    0H                      .\n         L     R7,SJBJCT               .  GET USERS JCT\n         USING JCTDSECT,R7             .\n         CLI   JCTUSERF,X'7F'          .  IS JOB CARD TIME SET?\n         BNE   NOTIME                  .   NO, SKIP SAVE\n         SLR   R14,R14                 .\n         ICM   R14,B'0111',JCTUSERF+1  .\n         SRDA  R14,32                  .\n         M     R14,=F'10'              .  JOB CARD TIME*10 IN R15\n         LR    R2,R15                  .\nNOTIME   DS    0H                      .\n         LR    R15,R2                  .  GET JOB CARD TIME IN R15\n         LM    R0,R12,20(R13)          .\n         L     R14,12(R13)             .  GET RETURN ADDR\n         BR    R14                     .  RETURN PASSING JOB TIME\n         END\n//LKED     EXEC PGM=IEWL,REGION=256K,COND=(4,LT),\n//            PARM=('LIST,LET,MAP,RENT,REUS,REFR')\n//SYSLIB    DD DSN=SYS1.LPALIB,DISP=SHR,UNIT=SYSDA,VOL=SER=DMVSB1\n//SYSLIN    DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//          DD DDNAME=SYSIN\n//SYSLMOD   DD DISP=SHR,DSN=SYS1.LPALIB,UNIT=SYSDA,VOL=SER=DMVSB1\n//SYSPRINT  DD SYSOUT=*,DCB=BLKSIZE=121\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n  INCLUDE SYSLIB(IEFUTL)\n  ORDER IEFUTL,OTABLE\n  ENTRY IEFUTL\n  NAME IEFUTL(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFUTLTB": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x14\\x0f\\x00\\x92\\x14\\x0f\\x17\\x02\\x01\\x8b\\x01\\x8b\\x00\\x00[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-19T00:00:00", "modifydate": "1992-05-19T17:02:00", "lines": 395, "newlines": 395, "modlines": 0, "user": "$WKS"}, "text": "//ASM       EXEC PGM=IEUASM,REGION=300K,PARM=('LOAD,NODECK,RENT')\n//SYSGO       DD DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=VIO,SPACE=(CYL,10)\n//SYSUT1      DD UNIT=VIO,SPACE=(CYL,05)\n//SYSUT2      DD UNIT=SYSDA,SPACE=(CYL,05)\n//SYSUT3      DD UNIT=SYSDA,SPACE=(CYL,05)\n//SYSPRINT    DD SYSOUT=*,DCB=(BLKSIZE=121,BUFNO=1)\n//SYSPUNCH    DD SYSOUT=B,DCB=(BLKSIZE=080,BUFNO=1)\n//SYSLIB      DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSIN       DD *\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              OTABLE                                   *\n*                                                                     *\n*  MODULE TYPE:              OPTIONS TABLE                            *\n*                                                                     *\n*  LOAD MODULE NAME:         NONE, COMPOSIT WITH IEFUTL               *\n*                                                                     *\n*  LOAD LIBRARY:             SYS1.LPALIB                              *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     RENT                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          RENT                                     *\n*                                                                     *\n*  MODULE AUTHORIZATION:     NO EXEC CODE                             *\n*                                                                     *\n*  MACROS:                   SELF DEFINED \"CLASS\" MACRO               *\n*                                                                     *\n*  MACRO LIBRARIES:          NONE                                     *\n*                                                                     *\n*  ABENDS:                   NONE                                     *\n*                                                                     *\n*  FUNCTION:                 TO DEFINE IEFUTL PROCESSING OPTIONS      *\n*                                                                     *\n*  PARAMETERS:               NONE                                     *\n*                                                                     *\n*  INTERNAL TABLES:          CPU ADJUSTMENT TABLE, CLASS DEF TABLE    *\n*                                                                     *\n*  CALLED MODULES:           NONE                                     *\n*                                                                     *\n*  CALLING MODULES:          USED BY IEFUTL                           *\n*                                                                     *\n*  PROGRAM FLOW:             NONE                                     *\n*                                                                     *\n*                                                                     *\n*  PARAMETER LAYOUTS:        NONE                                     *\n*                                                                     *\n*                                                                     *\n*  COPYRIGHT:                REPUBLIC BANK DALLAS                     *\n*                            JUNE 20, 1985                            *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN, INFORMATION SERVICES       *\n*                            (214)-653-7794                           *\n*                            REPUBLIC BANK DALLAS                     *\n*                            P.O. BOX 225961                          *\n*                            DALLAS ,  TEXAS   75265                  *\n*                                                                     *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 06-20-85 KIRK STICKEN        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    CLASS &CLASS,&JOBNAME,&TERMINL,&SYSTEM,                     XXX\n               &WAIT=(CANCEL,30,256,CANCEL),                         XXX\n               &SCPU=(CANCEL,30,256,CANCEL),                        XXXX\n               &JCPU=(CANCEL,30,256,CANCEL)\n         GBLB &FIRST\n         GBLA &CLCNT\n         LCLC &W1,&W2,&W3,&W4,&S1,&S2,&S3,&S4,&J1,&J2,&J3,&J4\n         LCLC &CLASSI,&CLASSJ,&JOB1,&TERM1,&SYS1,&JOBI,&TERMI,&SYSI\n&W1      SETC  '&WAIT(1)'\n&W2      SETC  '&WAIT(2)'\n&W3      SETC  '&WAIT(3)'\n&W4      SETC  '&WAIT(4)'\n&S1      SETC  '&SCPU(1)'\n&S2      SETC  '&SCPU(2)'\n&S3      SETC  '&SCPU(3)'\n&S4      SETC  '&SCPU(4)'\n&J1      SETC  '&JCPU(1)'\n&J2      SETC  '&JCPU(2)'\n&J3      SETC  '&JCPU(3)'\n&J4      SETC  '&JCPU(4)'\n&JOB1    SETC  '&JOBNAME'\n&TERM1   SETC  '&TERMINL'\n&SYS1    SETC  '&SYSTEM'\n         AIF    ('&JOB1' NE '').JJ1\n&JOB1    SETC   '********'\n.JJ1     ANOP\n         AIF    ('&TERM1' NE '').JJ2\n&TERM1   SETC   '********'\n.JJ2     ANOP\n         AIF    ('&SYS1' NE '').JJ3\n&SYS1    SETC   '********'\n.JJ3     ANOP\n         AIF    ('&W1' NE '').A1\n&W1      SETC  'CANCEL'\n.A1      ANOP\n         AIF   ('&W2' NE '').A2\n&W2      SETC  '30'\n.A2      ANOP\n         AIF   ('&W3' NE '').A3\n&W3      SETC  '256'\n.A3      ANOP\n         AIF   ('&W4' NE '').A4\n&W4      SETC  'CANCEL'\n.A4      ANOP\n         AIF   ('&S1' NE '').A5\n&S1      SETC  'CANCEL'\n.A5      ANOP\n         AIF   ('&S2' NE '').A6\n&S2      SETC  '30'\n.A6      ANOP\n         AIF   ('&S3' NE '').A7\n&S3      SETC  '256'\n.A7      ANOP\n         AIF   ('&S4' NE '').A8\n&S4      SETC  'CANCEL'\n.A8      ANOP\n         AIF   ('&J1' NE '').A9\n&J1      SETC  'CANCEL'\n.A9      ANOP\n         AIF   ('&J2' NE '').A10\n&J2      SETC  '30'\n.A10     ANOP\n         AIF   ('&J3' NE '').A11\n&J3      SETC  '256'\n.A11     ANOP\n         AIF   ('&J4' NE '').A12\n&J4      SETC  'CANCEL'\n.A12     ANOP\n         AIF   ('&CLASS' NE '').B1\n         MNOTE 8,'NULL CLASS IS INVALID'\n         MEXIT\n.B1      ANOP\n         AIF   ('&CLASS' EQ 'OTHER').O1\n         AIF   ('&CLASS' EQ 'TSU').O2\n&CLASSI  SETC  'CL1''&CLASS'''\n         AGO   .O3\n.O1      ANOP\n&CLASSI  SETC  'XL1''FF'''\n         AGO   .O3\n.O2      ANOP\n&CLASSI  SETC  'XL1''00'''\n.O3      ANOP\n         AIF   ('&S1' NE 'CLASSAUTO').SK2\n&S1      SETC  'CLAUTO'\n.SK2     ANOP\n         AIF   ('&J1' NE 'CLASSAUTO').SK3\n&J1      SETC  'CLAUTO'\n.SK3     ANOP\n         AIF   (&FIRST EQ 1).SK1\n&FIRST   SETB  1\n&CLCNT   SETA  0\nCANCEL   EQU   X'04'\nAUTO     EQU   X'01'\nCLAUTO   EQU   X'02'\nOPER     EQU   X'03'\n         DS    0D\n.SK1     ANOP\n&JOBI    SETC  'CL8''&JOB1'''\n&TERMI   SETC  'CL8''&TERM1'''\n&SYSI    SETC  'CL4''&SYS1'''\n&CLCNT   SETA  &CLCNT+1\n&NAME    DC    &CLASSI            CLASS DEFINITION\n         DC    &JOBI              JOBNAME DEF\n         DC    &TERMI             TERMINAL DEF\n         DC    &SYSI              SYSTEM DEF\n         DC    AL1(&W1)               WAIT TYPE\n         DC    H'&W2'                 WAIT AMOUNT\n         DC    H'&W3'                 WAIT EXTEND COUNT\n         DC    AL1(&W4)               WAIT EXTEND OPTION\n         DC    AL1(&S1)               STEP CPU TYPE\n         DC    H'&S2'                 STEP CPU  AMOUNT\n         DC    H'&S3'                 STEP CPU  EXTEND COUNT\n         DC    AL1(&S4)               STEP CPU  EXTEND OPTION\n         DC    AL1(&J1)               JOB  CPU TYPE\n         DC    H'&J2'                 JOB  CPU  AMOUNT\n         DC    H'&J3'                 JOB  CPU  EXTEND COUNT\n         DC    AL1(&J4)               JOB  CPU  EXTEND OPTION\n         DC    XL1'00'                FILLER\n         AIF   ('&CLASS' EQ 'OTHER').L1\n         MEXIT\n.L1      ANOP\nCLCNT    EQU   &CLCNT             CLASS COUNT\n         MEND\n*******************************************************************\n*****                                                         *****\n*****           TABLE BEGIN                                   *****\n*****                                                         *****\n*******************************************************************\nOTABLE   CSECT\nCLASSORI DC    AL1(CLCNT),AL3(TSU)     .\nCPUORI   DC    AL1(CPCNT),AL3(CPU)     .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\n         DC    A(0)                    .\nCPU      DS    0H                      .\n         DC    C'CPU1',H'10'     10 13 .    CPU1=3033=1.01 FACTOR\n         DC    C'CPU2',H'10'     08 10 .    CPU2=V8  =1.00 FACTOR\n         DC    C'CPU3',H'05'     04 05 .    CPU3=580 =0.49 FACTOR\n         DC    C'CPU4',H'16'     15 19 .    CPU4=V7B =1.57 FACTOR\n         DC    C'CPU5',H'05'     04 05 .    CPU5=580 =0.49 FACTOR\nCPCNT    EQU   (*-CPU)/6               .\n         DC    C'ERRR',H'10'           .    DEFAULT FACTOR\n*\n*\n*       FORMAT OF THE CLASS MACRO IS\n*           ID,JOB,LTERM,SYSTEM,\n*              WAIT=(TYPE,AMOUNT,NUMBER OF TIMES,EXCEED OPTION),\n*              SCPU=(     \"        \"\"     \"\"      \"\"       \"\" ),\n*              JCPU=(     \"        \"\"     \"\"      \"\"       \"\" ),\n*\n*     ID:        JOB CLASS ID  (IE: 0, 8, I...)\n*                TWO SPECIAL JOB CLASSES: TSU, OTHER\n*                OTHER MUST BE LAST ENTRY (IT TERMINATES THE SEARCH)\n*                TSU IS FOR TIME SHARING USERS\n*\n*     JOB:       FULL, OR PARTIALLY QUALIFIED, JOBNAME\n*                EXAMPLES: RFIM2020,RFIM****,R***1010,*LOB****\n*                AN ASTERICK IN ANY POSITION ACTS AS A WILD CARD.\n*\n*     LTERM:     FULL, OR PARTIALLY QUALIFIED, TERMINAL NAME\n*                EXAMPLES: TTSP0150,TTSP****,TISS****,*DA*****\n*                AN ASTERICK IN ANY POSITION ACTS AS A WILD CARD.\n*\n*     SYSTEM:    FULL, OR PARTIALLY QUALIFIED, CPU ID\n*                EXAMPLES: CPU1,CPU2,***3,CPU*\n*                AN ASTERICK IN ANY POSITION ACTS AS A WILD CARD.\n*\n*\n*     TYPES:\n*\n*             AUTO  -  CONDITIONAL AUTO EXTENSION BY \"AMOUNT\"\n*        CLASSAUTO  -  CONDITIONAL AUTO EXTENSION BY CPU DEPENDENT\n*                      DIFFERENCE BETWEEN USED CPU AMOUNT AND \"AMOUNT\"\n*           CANCEL  -  UNCONDITIONAL CANCEL FOR ANY EXCESSION\n*             OPER  -  OPERATOR DECIDES HOW LONG JOB IS EXTENDED\n*\n*     AMOUNT:    ANY TIME AMOUNT IN SECONDS 0 THRU 32767\n*\n*     NUMBER OF TIMES:    A COUNT OF HOW MANY AUTO EXTENSIONS WILL\n*                         BE ALLOWED BEFORE EXCEED OPTION IS PERFORMED\n*\n*     EXCEED OPTIONS:\n*\n*             OPER  -  THE OPERATOR WILL BEGIN DECIDING HOW LONG THE\n*                      JOB IS EXTENDED\n*\n*           CANCEL  -  THE JOB IS UNCONDITIONALLY CANCELLED\n*\n*    DEFAULTS:\n*\n*          NUMBER OF TIMES:  DEFAULT IS 256\n*                   AMOUNT:  DEFAULT IS 30\n*                     TYPE:  DEFAULT IS CANCEL\n*            EXCEED OPTION:  DEFAULT IS CANCEL\n*\n*\n*    EXAMPLE 1:   CLASS 0,WAIT=(CANCEL),SCPU=(CLASSAUTO,10,1,CANCEL),\n*                                       JCPU=(CLASSAUTO,10,1,CANCEL)\n*\n*        JOB XXYYZZ01 HAS USED 10 CPU TCB SECONDS ON CPU2 (B168)\n*            AND TIMES OUT.  IEFUTL WILL AUTO EXTEND THE JOB BY 15 SEC.\n*            (10 SEC CLASS MAX * 2.5 168 EQUIVALENT=25-10 USED=15)\n*\n*        JOB XXYYZZ01 AGAIN TIMES OUT AFTER USING 25 CPU SECONDS ON\n*            CPUB.  IEFUTL WILL CANCEL THE JOB SINCE IT HAS USED ITS\n*            CLASS MAXIMUM.\n*\n*        JOB XXYYZZ01 HAS USED 10 CPU TCB SECONDS ON CPU1 (A3033)\n*            AND TIMES OUT.  IEFUTL WILL CANCEL THE JOB SINCE IT HAS\n*            USED ITS CLASS MAXIMUM (10 SEC * 1.0 3033 EQUIV - 10=0)\n*\n*\n         DS    0D\nTSU      DS    0C\n         CLASS TSU,DP25894,                                          XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DP00220,                                          XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T675,,                                     XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T62027,,                                   XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,UDA6050A,,                                 XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,UDA6050B,,                                 XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,UDA6050C,,                                 XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,UDA6050D,,                                 XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T677,,                                      X\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,CTRL,,                                      X\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,CTRL2,,                                    XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T60129,,                                   XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T60329,,                                   XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T60439,,                                   XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,T60441,,                                   XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,NCCTERM1,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,TTSP0160,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,OMEGCICS,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,TTSP0162,,                                 XX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,TTSP0163,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DS*****,TTSP0164,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DP*****,UDA0620*,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\n         CLASS TSU,DP*****,UDA0603*,,                                XXX\n               WAIT=(AUTO,1439,256,OPER),                             XX\n               SCPU=(AUTO,10),JCPU=(AUTO,10)\nTSUDFLT  CLASS TSU,WAIT=(CANCEL),SCPU=(AUTO,10),JCPU=(AUTO,10)\nC0       CLASS 0,WAIT=(CANCEL),SCPU=(CLASSAUTO,20),JCPU=(CLASSAUTO,20)\nC1       CLASS 1,WAIT=(CANCEL),                                       XX\n               SCPU=(CLASSAUTO,60),                                    X\n               JCPU=(CLASSAUTO,60)\nC2       CLASS 2,WAIT=(CANCEL),                                       XX\n               SCPU=(CLASSAUTO,150),                                   X\n               JCPU=(CLASSAUTO,150)\nC3       CLASS 3,WAIT=(CANCEL),SCPU=(CLASSAUTO,3000,,OPER),            X\n               JCPU=(CLASSAUTO,3000,,OPER)\nC4       CLASS 4,WAIT=(OPER),SCPU=(CLASSAUTO,60),JCPU=(CLASSAUTO,60)\nC5       CLASS 5,WAIT=(OPER),                                         XX\n               SCPU=(CLASSAUTO,150),                                   X\n               JCPU=(CLASSAUTO,150)\nC6       CLASS 6,WAIT=(OPER),SCPU=(CLASSAUTO,3000,,OPER),              X\n               JCPU=(CLASSAUTO,3000,,OPER)\nC7       CLASS 7,WAIT=(CANCEL),SCPU=(CLASSAUTO,30),JCPU=(CLASSAUTO,30)\nC8       CLASS 8,WAIT=(OPER),SCPU=(CLASSAUTO,1000,,OPER),              X\n               JCPU=(CLASSAUTO,1000,,OPER)\nCI       CLASS I,WAIT=(OPER),                                          X\n               SCPU=(AUTO,60,3,OPER),JCPU=(AUTO,60,3,OPER)\nOTHER    CLASS OTHER,WAIT=(OPER),SCPU=(OPER),JCPU=(OPER)\n*\n         DC    C'&SYSDATE._&SYSTIME._REPUBLIC_BANK_DALLAS'\n         END\n//LKED     EXEC PGM=IEWL,REGION=256K,COND=(0,LT,ASM),\n//            PARM=('LIST,LET,MAP,RENT,REUS,REFR')\n//SYSLIB     DD DSN=DP25894.TEST.LOAD,DISP=SHR\n//SYSLIN     DD DSN=&&LOADSET,DISP=(OLD,DELETE)\n//           DD DDNAME=SYSIN\n//SYSLMOD    DD DISP=SHR,DSN=DP25894.TEST.LOAD\n//SYSPRINT   DD SYSOUT=*,DCB=BLKSIZE=121\n//SYSUT1     DD UNIT=SYSDA,SPACE=(TRK,(02,02))\n  INCLUDE SYSLIB(IEFUTL)\n  ORDER IEFUTL,OTABLE\n  ENTRY IEFUTL\n  NAME IEFUTL(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISRTSOA": {"ttr": 9731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x94'\\x8f\\x00\\x94'\\x8f\\x15\\x17\\x00;\\x00;\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-05T00:00:00", "modifydate": "1994-10-05T15:17:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "$VNV"}, "text": ")ATTR\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n  ! TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(TEXT) INTENS(HIGH)\n  $ TYPE(INPUT) INTENS(HIGH)\n  ~ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW) HILITE(REVERSE)\n  \\ TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK)\n)BODY CMD(ZSPFCMD)\n%------------------------- ~TSO Command Processor% -----------------------------\n%ISPF Command ===>_ZSPFCMD\n%\n%Temporary Load Library ===>\\MYLOAD                                            +\n%\n%Enter TSO Command, Clist, or REXX Exec below:\n%\n%===>_ZCMD\n\n\n%                                                                              %\n+\n+\n!ENTER SESSION MANAGER MODE\u00a2===>$ZSM !  (YES or NO)\n)INIT\n  &ZCMD = &PTCBTEXT\n  .HELP = ISR60010\n  VGET (ZSESS) PROFILE\n  IF (&ZSESS = 'Y')\n    &ZSM = TRANS(&ZSMMODE Y,YES *,NO)\n  IF (&ZSESS = 'N')\n    .ATTRCHAR(!) = 'INTENS(NON)'\n    .ATTRCHAR($) = 'TYPE(OUTPUT),INTENS(NON)'\n    .ATTRCHAR(\u00a2) = 'INTENS(NON)'\n    &ZSM = NO\n)PROC\n  &PTCBTEXT = &ZCMD\n  &PTCLOG = 'Y'          /* Y = YES, LOG COMMANDS. N = NO LOGGING */\n  &Z6MODE = '          ' /* \"MODE(LINE)\" to have command run in   */\n                         /* line mode, \"MODE(FSCR)\" to have the   */\n                         /* command run in full screen mode       */\n  &ZSM = TRUNC(&ZSM,1)\n  VER (&ZSM,NB,LIST,Y,N)\n  &ZSMMODE = TRANS(&ZSM Y,Y N,N)\n  VPUT (ZSMMODE) PROFILE\n  IF (.RESP = END)\n    &ZSM = NO\n)END\n/* $SEG(ISRTSOA )  COMP(COMMAND )    PROD(MVS):                      */\n/* CHANGE ACTIVITY:                                                  */\n/*                                                                   */\n/* OY14414 - 88/05/25 - TSO COMMAND TYPED INTO COMMAND FIELD OF      */\n/*           PANEL ISRTSO (OPTION 6) IS ERASED WHEN SCREENS ARE      */\n/*           SWAPPED.  ISPF CMD FIELD ADDED.  GT4045-SFG             */\n/*                                                                   */\n/* OY16968 - 88/09/15 - SMPE ERRORS IN PTFS UY25769, UY25770 AND     */\n/*           UY25771 PLACED PANEL ISRTSOA IN DISTLIB AISRPKLB.       */\n/*           GT4045-SFG.                                             */\n/*                                                                   */\n/*  $H1= QUALITY   M310     881216   764700 : PTM #211              */\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JESXIT05": {"ttr": 9733, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x95 \\x7f\\x00\\x96%O\\x11\\x17\\x08\\xae\\x08\\x8b\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1995-07-26T00:00:00", "modifydate": "1996-09-10T11:17:00", "lines": 2222, "newlines": 2187, "modlines": 0, "user": "$VNV"}, "text": "JESXIT05 TITLE 'JES2 EXIT5 - INLINE MACROS'\n*\n         PRINT NOGEN\n         MACRO\n&LABEL   $$CMDTAB &CMD,&ADDR,&TYPE=BODY\n*\n         AIF   ('&TYPE' EQ 'START').START\n         AIF   ('&TYPE' EQ 'BODY').BODY\n         AIF   ('&TYPE' EQ 'STOP').STOP\n.START   ANOP\n         MNOTE *,'*-----------------------------------------------*'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THIS MACRO WILL SET UP THE COMMAND TABLE:   *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      CMD = COMMAND IN THE FORM OF \"DC\" IN     *'\n         MNOTE *,'*          ASSEMBLER.                           *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      ADDR =  ADDRESS OF THE TABLE USED TO     *'\n         MNOTE *,'*          HOLD THE SUB-PARAMETERS FOR THIS     *'\n         MNOTE *,'*          COMMAND, I.E. $QTAB.                 *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      TYPE = BEGIN, BODY OR END.  USED TO      *'\n         MNOTE *,'*      INDICATE THE TABLE ENTRY TYPE.           *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THE RESULTING TABLE ENTRY WILL BE:          *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      DC  AL1(LENG OF COMMAND)                 *'\n         MNOTE *,'*      DC  C\"COMMAND ITSELF\"                    *'\n         MNOTE *,'*      DC  AL4(ADDR OF SUBCMD TABLE)            *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*-----------------------------------------------*'\n&LABEL   DS    0F\n         MEXIT\n*\n.BODY    ANOP\n             DC    AL1(L'$$C&SYSNDX.C)       LENG OF COMMAND\n$$C&SYSNDX.C DC    C&CMD                     COMMAND\n             DC    AL4(&ADDR)                TABLE ADDRESS\n         MEXIT\n*\n.STOP    ANOP\n         DC     X'00'              END OF TABLE\n*\n         MEND\n         EJECT\n*\n         MACRO\n&SUBLABL $$SUBTAB &SUBCMD,&ADCON,&HELPTXT,&ENTTYPE=BODY\n*\n         AIF   ('&ENTTYPE' EQ 'START').SUBSTRT\n         AIF   ('&ENTTYPE' EQ 'BODY').SUBBODY\n         AIF   ('&ENTTYPE' EQ 'STOP').SUBSTOP\n.SUBSTRT ANOP\n         MNOTE *,'*-----------------------------------------------*'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THIS MACRO WILL SET UP THE SUB-CMD TABLE:   *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      SUBCMD = CMD PARM IN THE FORM OF \"DC\"    *'\n         MNOTE *,'*          IN ASSEMBLER.                        *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      ADCON =  ADDRESS OF THE ROUTINE TO BE    *'\n         MNOTE *,'*          CALLED FOR THIS SUB PARM.  THE       *'\n         MNOTE *,'*          CALL WILL BE DONE VIA \"$CALL\"        *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      HELPTXT = HELP TEXT TO BE DISPLAYED      *'\n         MNOTE *,'*          FOR THIS SUB CMD (COMMAND PARM).     *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      TYPE = BEGIN, BODY OR END.  USED TO      *'\n         MNOTE *,'*      INDICATE THE TABLE ENTRY TYPE.           *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   THE RESULTING TABLE ENTRY WILL BE:          *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*      DC  AL1(LENG OF PARM)                    *'\n         MNOTE *,'*      DC  C\"COMMAND PARAMETER\"                 *'\n         MNOTE *,'*      DC  AL4(ADDR OF ROUTINE USED TO PROCESS  *'\n         MNOTE *,'*              THIS PARAMETER)                  *'\n         MNOTE *,'*      DC  AL1(LENG OF HELP TEXT)               *'\n         MNOTE *,'*      DC  C\"HELP TEXT\"                         *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*   A NOTE ON THE HELP TEXT:  FOR EACH SUB-     *'\n         MNOTE *,'*   COMMAND, THERE WILL BE \"HELP TEXTS\"         *'\n         MNOTE *,'*   ASSOCIATED WITH IT.  THIS COULD BE HANDY    *'\n         MNOTE *,'*   IN CASE YOU WANT TO DISPLAY THE USAGE FOR   *'\n         MNOTE *,'*   ALL SUB-COMMANDS (PARAMETERS) AVAILABLE     *'\n         MNOTE *,'*   FOR A PARTICULAR USER COMMAND.              *'\n         MNOTE *,'*                                               *'\n         MNOTE *,'*-----------------------------------------------*'\n&SUBLABL DS    0F\n         MEXIT\n*\n.SUBBODY  ANOP\n             DC    AL1(L'$$S&SYSNDX.C)       LENG OF SUB-CMD\n$$S&SYSNDX.C DC    C&SUBCMD                  SUB-COMMAND\n             DC    AL4(&ADCON)               ROUTINE ADDRESS\n             DC    AL1(L'$$S&SYSNDX.H)       LENG OF HELP TEXT\n$$S&SYSNDX.H DC    C&HELPTXT                 LENG OF HELP TEXT\n         MEXIT\n*\n.SUBSTOP ANOP\n             DC    X'00'              END OF TABLE\n*\n         MEND\n         EJECT\n*\n*\n*\n         TITLE 'JES2 EXIT5 - PROLOG (MODULE COMMENT BLOCK)'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n* MODULE NAME = JESXIT05 CSECT                                        *\n*                                                                     *\n* DESCRIPTIVE NAME = JES2 COMMAND PREPROCESSOR                        *\n*                                                                     *\n* FUNCTION = TO ALLOW FOR FRITO LAY USER COMMANDS:                    *\n*                                                                     *\n*            $Q                                                       *\n*                                                                     *\n* ATTRIBUTES = NON-REENTRANT, SUPERVISOR STATE, PROTECT KEY OF        *\n*                 HASP'S (1), RMODE 24, AMODE 24/31                   *\n*                                                                     *\n* ENTRY POINT = EXIT5                                                 *\n*                                                                     *\n*    PURPOSE = SEE FUNCTION                                           *\n*                                                                     *\n*    LINKAGE = STANDARD MVS LINKAGE                                   *\n*                                                                     *\n* EXIT-NORMAL = RETURN TO CALLER (HASPCOMM)                           *\n*                                                                     *\n* EXIT-ERROR = NONE                                                   *\n*                                                                     *\n* EXTERNAL REFERENCES = SEE BELOW                                     *\n*                                                                     *\n*    ROUTINES = MISCELLANEOUS JES2 SERVICE ROUTINES                   *\n*                                                                     *\n*    DATA AREAS = SEE $MODULE MACRO EXPANSION                         *\n*                                                                     *\n*    CONTROL BLOCKS = SEE $MODULE MACRO EXPANSION                     *\n*                                                                     *\n* TABLES = SEE $MODULE MACRO DEFINITION (BELOW)                       *\n*                                                                     *\n* MACROS = JES2 - $CALL, $CFCVE, $CWTO, $ENTRY, $ESTAE, $MODEND,      *\n*                 $MODULE, $MSG, $RETURN, $SAVE, $SETRP, $WTO         *\n*                                                                     *\n* MACROS = MVS  - MODESET                                             *\n*                                                                     *\n* CHANGE ACTIVITY:                                                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         TITLE 'JES2 EXIT5 - PROLOG ($HASPGBL)'\n         COPY  $HASPGBL            COPY HASP GLOBALS\n*\n         TITLE 'JES2 EXIT5 - PROLOG ($MODULE)'\nJESXIT05 $MODULE ENVIRON=JES2,                                         C\n               SYSP=(NOGEN,NOGEN,NODATA,NOGEN,NOGEN),                  C\n               TITLE='JES2 EXIT5 - PROLOG ($MODULE)',                  C\n               $BUFFER,            GENERATE HASP BUFFER DSECT          C\n               $CADDR,             GENERATE HASP CADDR DSECT           C\n               $CMB,               GENERATE HASP CMB DSECT             C\n               $COMWORK,           GENERATE HASP COMWORK DSECT         C\n               CONV,               GENERATE MVS CONV DSECT             C\n               $CWA,               GENERATE HASP CWA DSECT             C\n               $DAS,               GENERATE HASP DAS DSECT             C\n               $DCT,               GENERATE HASP DCT DSECT             C\n               $ERA,               GENERATE HASP ERA DCT               C\n               $HASPEQU,           GENERATE HASP EQUATES               C\n               $HCT,               GENERATE HASP HCT DSECT             C\n               $JQE,               GENERATE HASP JQE DSECT             C\n               $JOE,               GENERATE HASP JOE DSECT             C\n               $LMT,               GENERATE HASP LMT DSECT             C\n               $MIT,               GENERATE HASP MIT DSECT             C\n               MLTE,               GENERATE MVS MLTE DSECT             C\n               OHLD,               GENERATE MVS OHLD DSECT             C\n               $PADDR,             GENERATE HASP PADDR DSECT           C\n               $PARMLST,           GENERATE HASP PARMLST DSECT         C\n               $PCE,               GENERATE HASP PCE DSECT             C\n               PDS,                GENERATE MVS PDS DSECT              C\n               PPL,                GENERATE MVS PPL DSECT              C\n               $PRE,               GENERATE HASP PRE DSECT             C\n               $PSV,               GENERATE HASP PSV DSECT             C\n               $QSE,               GENERATE HASP QSE DSECT             C\n               RESPA,              GENERATE MVS IATRESPA DSECT         C\n               SDWA,               GENERATE MVS SDWA DSECT             C\n               TOKEN,              GENERATE MVS TOKEN DSECT            C\n               $TQE,               GENERATE HASP TQE DSECT             C\n               UCB,                GENERATE MVS UCB DSECT              C\n               $USERCBS,           GENERATE HASP USERCBS DSECT         C\n               WPL,                GENERATE MVS WPL DSECT              C\n               $XECB,              GENERATE HASP XECB DSECT            C\n               $XIT                GENERATE HASP XIT DSECT\n         TITLE 'JES2 EXIT5 - COMMAND PREPROCESSOR EXIT ENTRY POINT'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        EXIT5 - INSTALLATION EXIT 5 ROUTINE                          *\n*                                                                     *\n* OVERVIEW:                                                           *\n*                                                                     *\n*        THIS EXIT IS TAKEN FROM HASPCOMM AFTER COMMAND EDITING       *\n*        (HASPCOME). HASPCOME TAKES AS INPUT THE COMMAND THAT HAS     *\n*        BEEN PASSED IN THE CMB AND EDITS IT BY REMOVING COMMENTS     *\n*        AND BLANKS AND PLACES THE REST OF THE INPUT INTO THE         *\n*        COMMAND WORK AREA.  IT ALSO BUILDS THE OPERAND POINTER       *\n*        TABLE AND THEN GIVES CONTROL TO EXIT 5.  THIS EXIT IS        *\n*        TAKEN ONCE FOR EACH COMMAND VERB IN A MULTIPLE COMMAND.      *\n*        THE COMMAND IS LOCATED IN THE 'COMMAND' AREA OF THE PCE.     *\n*                                                                     *\n*        UPON ENTRY, EXIT5 WILL:                                      *\n*                                                                     *\n*          1. ESTABLISH $ESTAE ENVIRONMENT                            *\n*          2. TEST FOR USER COMMAND, RETURN IF NOT                    *\n*          3. CHECK CONSOLE AUTHORITY                                 *\n*          4. PERFORM L=CCA PROCESSING                                *\n*          5. EXECUTE USER COMMAND                                    *\n*          6. RETURN TO HASPCOMM                                      *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        BRANCH ENTERED FROM THE JES2 EXIT EFFECTOR                   *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        NONE                                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n*        REG          ENTRY VALUE              EXIT VALUE             *\n*                                                                     *\n*        R0           N/A                      UNCHANGED OR           *\n*                                              MESSAGE LENGTH         *\n*        R1-R4        N/A                      UNCHANGED              *\n*        R5           POINTER TO ADDRESS OF    UNCHANGED              *\n*                         CURRENT OPERAND                             *\n*        R6           INCREMENT VALUE OF 4     UNCHANGED              *\n*        R7           POINTER TO ADDRESS OF    UNCHANGED              *\n*                         LAST OPERAND                                *\n*        R8-R10       N/A                      UNCHANGED              *\n*        R11          HCT ADDRESS              UNCHANGED              *\n*        R12          N/A                      UNCHANGED              *\n*        R13          PCE ADDRESS              UNCHANGED              *\n*        R14          RETURN ADDRESS           UNCHANGED              *\n*        R15          ENTRY ADDRESS            RETURN CODE            *\n*                                                                     *\n*        NOTE -  THIS EXIT WILL NOT BE TAKEN IF THE                   *\n*                CURRENT COMMAND BEING PROCESSED IS THE               *\n*                SPECIAL START INITIATORS COMMAND.                    *\n*                                                                     *\n*        VALID RETURN CODES FOR EXIT ROUTINES --                      *\n*                                                                     *\n*        +0  --  CONTINUE WITH NORMAL COMMAND PROCESSING              *\n*        +4  --  CONTINUE WITH NORMAL COMMAND PROCESSING              *\n*        +8  --  PERFORM $CRET NORMAL RETURN -- (DELETES COMMAND)     *\n*        +12 --  ISSUE $CRET OK MESSAGE                               *\n*        +16 --  ISSUE $CRET MESSAGE  --  TEXT IN 'COMMAND' AREA      *\n*                                         MESSAGE LENGTH IN R0        *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING HCT,R11             HCT ADDRESSABILITY\n         USING PCE,R13             PCE ADDRESSABILITY\n         USING WKAREA,R9           MY WORK AREA\n*\nEXIT5   $ENTRY BASE=R12            PROVIDE PROCESSOR ENTRY\n        $SAVE                      SAVE CALLER'S REGISTERS\n         LR    R12,R15             LOAD BASE REGISTER\n*\n         EJECT\n*\n        $GETBUF TYPE=HASP,WAIT=YES\n         LR    R9,R1               GET ADDRESS OF MY WORK AREA\n*\n         MVC   WCOMMAND,COMMAND    SAVE ORIGINAL COMMAND\n        $CALL  X5TSTU,             SCREEN COMMAND AND SEE IF IT'S OURS C\n               ERRET=X5BADCMD         NOT OURS, LET HASPCOMM PROCESS\n*\n*\n*---------------------------------------------------------------------*\n*        ESTABLISH ESTAE ENVIRONMENT                                  *\n*---------------------------------------------------------------------*\n*\n         L     R14,=A(X5RECOVR)    R14 => EXIT5 RECOVERY EP\n        $ESTAE RECADDR=(R14)       CREATE ESTAE ENVIRONMENT\n*\n*---------------------------------------------------------------------*\n*        MOVE PORTION OF THE COMMAND CURRENTLY BEING PROCESSED        *\n*        INTO THE PRE (PRETRACK) FOR THE PROCESSOR RECOVERY           *\n*        ROUTINE (X5RECOVR)                                           *\n*---------------------------------------------------------------------*\n*\n*\n         L     R14,PCEPRE          GET ADDRESS OF PRE\n         USING PRE,R14             ADDRESSABILITY\n*\n         MVC   PRETRACK(CCMDLN),WCOMMAND    MOVE COMMAND INTO PRE\n         MVI   PRELOGLN,CCMDLN     SET LENGTH OF DATA IN PRETRACK\n*                                    TO BE RECORDED IN LOGREC\n*\n         DROP  R14                 KILL ADDRESSABILITY\n         TITLE 'JES2 EXIT5 - COMMAND PREPROCESSOR EXIT MAIN ROUTINE'\n*\n*---------------------------------------------------------------------*\n*        EXIT5 MAIN CALLING ROUTINE                                   *\n*---------------------------------------------------------------------*\n*\n*\n        $CALL  X5AUTH,             CHECK CONSOLE AUTHORIZATION         C\n               ERRET=X5RC08           AUTH IS BAD, RETURN WITH RC=8\n*\n*\n        $CALL  X5LCCA,             PERFORM L=CCA PROCESSING            C\n               ERRET=X5RC08           CCA IS BAD, RETURN WITH RC=8\n*\n*--------------\n*        NOTE THAT 'X5LCCA' ALREADY DID X'80' AND X'20' FOR MLWTO\n*        IF COMUCMA NE 0.  THEREFORE, IN 'X5UCMD', ONLY HAVE TO MOVE\n*        X'10' FOR THE LAST LINE (MLWTO ONLY).  LOOK AT THE JES2\n*        CUSTOMIZATION BOOK ON EXIT 5 ABOUT SETTING THESE FLAGS.\n*--------------\n*\n        $CALL  X5UCMD              PROCESS USER COMMAND\n*\n*\n         B     X5RC12              ALL DONE, RETURN TO HASPCOMM\n*\n         TITLE 'JES2 EXIT5 - COMMAND PREPROCESSOR COMMON RETURN'\n*\n*---------------------------------------------------------------------*\n*        JESXIT05 COMMON RETURN ROUTINES                              *\n*---------------------------------------------------------------------*\n*\n*--------------\n*        +0  --  CONTINUE WITH NORMAL COMMAND PROCESSING\n*--------------\n*\nX5RC00   DS      0H\n         XR    R2,R2               SET RC=0\n         B     X5ECAN              BRANCH TO COMMON RETURN\n*\n*--------------\n*        +4  --  CONTINUE WITH NORMAL COMMAND PROCESSING\n*--------------\n*\nX5RC04   DS      0H\n         LA    R2,4                SET RC=4\n         B     X5ECAN              BRANCH TO COMMON RETURN\n*\n*--------------\n*        +8  --  PERFORM $CRET NORMAL RETURN -- (DELETES COMMAND)\n*--------------\n*\nX5RC08   DS      0H\n         LA    R2,8                SET RC=8\n         B     X5ECAN              BRANCH TO COMMON RETURN\n*\n*--------------\n*        +12 --  ISSUE $CRET OK MESSAGE\n*--------------\n*\nX5RC12   DS      0H\n         LA    R2,12               SET RC=12\n         B     X5ECAN              BRANCH TO COMMON RETURN\n*\n*--------------\n*        +16 --  ISSUE $CRET MESSAGE  --  TEXT IN 'COMMAND' AREA\n*                                         MESSAGE LENGTH IN R0\n*--------------\n*\nX5RC16   DS      0H\n         LA    R2,16               SET RC=16\n         B     X5ECAN              BRANCH TO COMMON RETURN\n*\n*\n*--------------\n*        +0  --  CONTINUE WITH NORMAL COMMAND PROCESSING\n*        THIS SPECIAL ROUTINE IS EXECUTED SINCE A TEST IS DONE\n*        AS SOON AS THIS PGM START EXECUTING.  IF A NON-USER COMMAND\n*        IS DETECTED (X5TSTU), THEN IMMEDIATELY RETURN TO JES2.\n*        HOWEVER, THE $ESTAE ENVIRONMENT HAS NOT EVEN BEEN SET UP YET.\n*        THEREFORE, THIS ROUTINE IS TO BYPASS THE $ESTAE CANCEL.\n*--------------\n*\nX5BADCMD DS    0H\n         XR    R2,R2               SET RC=0\n         B     X5ENDIT             GO RIGHT BACK TO JES2\n*\n*\nX5ECAN   DS      0H                CANCEL XJ2COMM ESTAE ENVIRON\n        $ESTAE CANCEL              CANCEL ESTAE ENVIRONMENT\n*\nX5ENDIT $FREEBUF (R9)              NOW FREE THE BUFFER ACQUIRED\n        $RETURN RC=(R2)            RETURN TO MAINLINE HASPCOMM\n*\n*\n*\n         TITLE 'JES2 EXIT5 - XCREEN   - CHECK FOR USER COMMANDS'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        XSCREEN - CHECK THE COMMAND VERB                             *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*        CHECK FOR USER COMMANDS.  IF THE COMMAND BELONGS TO JES2,    *\n*        RETURN TO MAIN CALLING ROUTINE WITH RC=4.  IF THIS IS A      *\n*        USER COMMAND, RETURN TO MAIN CALLING ROUTINE WITH RC=0.      *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        CONTROL GIVEN BY $CALL FROM MAIN CALLING ROUTINE             *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        $ESTAE ESTABLISH UPON ENTRY.  THE RECOVERY ROUTINE IS        *\n*        PROVIDED IN X5RECOVR.                                        *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT):                                        *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0-R4     N/A                        UNCHANGED                   *\n*    R5        POINTER TO ADDRESS OF                                  *\n*               CURRENT OPERAND           UNCHANGED                   *\n*    R6        INCREMENT VALUE OF 4       UNCHANGED                   *\n*    R7        POINTER TO ADDRESS OF                                  *\n*               LAST OPERAND              UNCHANGED                   *\n*    R8-R10    N/A                        UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R12       ADDRESS OF HASPCOMM PCE    UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* PARAMETER LIST:                                                     *\n*                                                                     *\n*        ALL NECESSARY INFORMATION LOCATED IN THE DTE, AS PASSED      *\n*        BY THE ATTACHING PROCESSOR.                                  *\n*                                                                     *\n* REGISTER USAGE (INTERNAL):                                          *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0-R10    WORK REGISTERS                                         *\n*    R11       HCT BASE ADDRESS                                       *\n*    R12       LOCAL BASE ADDRESS                                     *\n*    R13       PCE BASE ADDRESS                                       *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        00 = USER COMMAND                                            *\n*        04 = JES2 COMMAND                                            *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        N/A                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5TSTU,R12          ESTABLISH X5TSTU ADDRESSABILITY\n*\nX5TSTU  $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15             ESTABLISH BASE\n*\n         L     R14,=AL4(UCOMTAB)   GET ADDR OF COMMAND TABLE\n         XR    R15,R15             CLEAR REG15\n*\nX5TLOOP  EQU   *\n         CLI   0(R14),X'00'        IS IT EOT ?\n         BE    X5TBADC             YEAH - THEN BACK TO JES2\n*\n         IC    R15,0(R14)          GET LENG OF SUB COMMAND\n         BCTR  R15,0               MINUS 1 FOR EX INSTRUCTION\n         EX    R15,X5TCKCMD        NOW - COMPARE WITH MY CMDS\n         BE    X5TMYCMD            IF EQ - THEN I AM OUTA HERE\n         LA    R14,6(R15,R14)      NOW - BUMP TO NEXT ENTRY\n         B     X5TLOOP             AND THEN BACK TO LOOP\n*\nX5TCKCMD CLC   WCOMMAND(0),1(R14)  CHECK AGAINST MY COMMAND IN TABLE\n*\nX5TBADC  LA    R15,4               BACK TO JES2\n         B     X5TSRET\n*\nX5TMYCMD L     R4,2(R15,R14)       PICK UP MY SUB-CMD TABLE ADDRESS\n         LA    R3,WCOMMAND         GET ADDRESS OF THE COMMAND BUFFER\n         LA    R3,1(R15,R3)         ....  AND ITS PARM\n*\n         ST    R3,CMDPTR\n         ST    R4,SUBADDR\n*\n         XR    R15,R15             CLEAR REG 15\n         B     X5TSRET\n*\n*--------------\n*        IF COMMAND IS FOUND, BEFORE RETURNING TO THE MAIN ROUTINE,\n*        R4 IS LOADED WITH THE SUBCMD TABLE ADDR, R3 IS LOADED WITH\n*        THE ADDRESS OF ITS SUBCMD (IN THE COMMAND BUFFER), AND THEN\n*        BOTH REGS WILL BE SAVED INTO WORK AREA TO BE USED LATER.\n*--------------\n*\nX5TSRET $RETURN RC=(R15)           RETURN TO MAIN CALLING ROUTINE\n*\n         DROP  R12\n         TITLE 'JES2 EXIT5 - X5AUTH   - CHECK CONSOLE AUTHORITY'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        X5AUTH - CHECK CONSOLE AUTHORITY                             *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*        THIS IS HERE IN CASE WE WANT TO CHECLK FOR CONSOLE           *\n*        AUTHORIY LATER.                                              *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        CONTROL GIVEN BY $CALL FROM MAIN CALLING ROUTINE             *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        $ESTAE ESTABLISH UPON ENTRY.  THE RECOVERY ROUTINE IS        *\n*        PROVIDED IN X5RECOVR.                                        *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT):                                        *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0-R4     N/A                        UNCHANGED                   *\n*    R5        POINTER TO ADDRESS OF                                  *\n*               CURRENT OPERAND           UNCHANGED                   *\n*    R6        INCREMENT VALUE OF 4       UNCHANGED                   *\n*    R7        POINTER TO ADDRESS OF                                  *\n*               LAST OPERAND              UNCHANGED                   *\n*    R8-R10    N/A                        UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R12       ADDRESS OF HASPCOMM PCE    UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* PARAMETER LIST:                                                     *\n*                                                                     *\n*        ALL NECESSARY INFORMATION LOCATED IN THE DTE, AS PASSED      *\n*        BY THE ATTACHING PROCESSOR.                                  *\n*                                                                     *\n* REGISTER USAGE (INTERNAL):                                          *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0-R10    WORK REGISTERS                                         *\n*    R11       HCT BASE ADDRESS                                       *\n*    R12       LOCAL BASE ADDRESS                                     *\n*    R13       PCE BASE ADDRESS                                       *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        00 = USER COMMAND                                            *\n*        04 = JES2 COMMAND                                            *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        N/A                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5AUTH,R12          ESTABLISH X5AUTH ADDRESSABILITY\n*\nX5AUTH  $SAVE                      SAVE CALLERS REGISTERS\n*\n         LR    R12,R15             ESTABLISH BASE\n*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*        PUT THE AUTHORIZATION CHECK HERE.  FOR NOW, WE JUST BRANCH   *\n*        AROUND AND ALLOW ALL AUTHORITY.  BRANCH TO X5AUBAD           *\n*        FOR UNAUTHORIZED CONSOLES.                                   *\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*---------------------------------------------------------------------*\n*\n         XR    R15,R15             ZERO RETURN CODE, AUTH OK\n         B     X5AURET             AND RETURN TO MAIN CALLING ROUTINE\n*\n*---------------------------------------------------------------------*\n*   ISSUE $HASP936 IF COMMAND ISSUED FROM UNAUTHORIZED CONSOLE        *\n*---------------------------------------------------------------------*\n*\nX5AUBAD  TM    COMFLAG,CMBFLAGU    IS THIS UCM\n         BZ    X5AUBAD1            DISPLAY ERROR IF NOT\n*\n        $CALL  X5CVCCA,            VERIFY CCA                          C\n               ERRET=X5AUBAD2      BAD RETURN FROM CCA, SKIP MSG936\n*\n         CLI   COMUCMA,0           MLWTO\n         BZ    X5AUBAD1              SKIP CONTROL LINE IF NO\n         MVI   COMLINET,X'80'      SET CONTROL LINE\n*\n        $CWTO  COMMAND,L=L'COMMAND,MSGID=936   DISPLAY COMMAND ON...\n*                                                CONTROL LINE\n*\n         MVI   COMLINET,X'20'      SET DATA LINE\n*\nX5AUBAD1 DS    0H              BAD L=A, ISSUE MESSAGE $HASP937\n        $CWTO MSG=MSG937,L=L'MSG937,MSGID=937  ISSUE ERROR MESSAGE\n*\n         CLI   COMUCMA,0           MLWTO\n         BZ    X5AUBAD2             NO, SKIP EOL CONTROL\n         MVI   COMLINET,X'10'  OTHERWISE, SET END OF LINE\n*\n        $CWTO  MSG=MSG937,L=L'MSG937,MSGID=937  EOL CONTROL\n*\nX5AUBAD2 LA    R15,4                    SET NON-ZERO RETURN CODE\n*\nX5AURET $RETURN RC=(R15)                RETURN TO MAIN CALLING ROUTINE\n*\n         LTORG ,                   EXPAND LITERAL POOL HERE\nMSG937   DC    CL40' ERROR MESSAGE FROM EXIT 5     '\n         DROP  R12\n         TITLE 'JES2 EXIT5 - X5LCCA   - L=CCA PROCESSING'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        X5LCCA - L=CCA PROCESSING                                    *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*        CHECK FOR L=CCA.  IF NOT LOCAL CONSOLE, RETURN WITH RC=0.    *\n*        $CALL X5CVCCA TO VALIDATE THE CONSOLE/AREA. IF AREA          *\n*        SPECIFIED; SET CONTOL LINE; ISSUE THE $CWTO, AND THEN        *\n*        SET THE DATA LINE BEFORE RETURNING WITH RC=0.                *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        CONTROL GIVEN BY $CALL FROM MAIN CALLING ROUTINE             *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        $ESTAE ESTABLISH UPON ENTRY.  THE RECOVERY ROUTINE IS        *\n*        PROVIDED IN X5RECOVR.                                        *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT):                                        *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0-R4     N/A                        UNCHANGED                   *\n*    R5        POINTER TO ADDRESS OF                                  *\n*               CURRENT OPERAND           UNCHANGED                   *\n*    R6        INCREMENT VALUE OF 4       UNCHANGED                   *\n*    R7        POINTER TO ADDRESS OF                                  *\n*               LAST OPERAND              UNCHANGED                   *\n*    R8-R10    N/A                        UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R12       ADDRESS OF HASPCOMM PCE    UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* PARAMETER LIST:                                                     *\n*                                                                     *\n*        ALL NECESSARY INFORMATION LOCATED IN THE DTE, AS PASSED      *\n*        BY THE ATTACHING PROCESSOR.                                  *\n*                                                                     *\n* REGISTER USAGE (INTERNAL):                                          *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0-R10    WORK REGISTERS                                         *\n*    R11       HCT BASE ADDRESS                                       *\n*    R12       LOCAL BASE ADDRESS                                     *\n*    R13       PCE BASE ADDRESS                                       *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        00 = USER COMMAND                                            *\n*        04 = JES2 COMMAND                                            *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        N/A                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5LCCA,R12          ESTABLISH X5LCCA ADDRESSABILITY\n*\nX5LCCA  $SAVE                      SAVE CALLERS REGISTERS\n*\n         LR    R12,R15             ESTABLISH BASE\n         TM    COMFLAG,CMBFLAGU    IS THIS UCM...\n         BZ    X5CGOOD             IF NOT, RETURN WITH RC=0\n*\nX5CRPT  $CALL  X5CVCCA,            VERIFY CCA                          C\n               ERRET=X5CBAD1       BAD RETURN FROM CCA, SKIP MSG936\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5CGOOD              IF NOT, SKIP\n         MVI   COMLINET,X'80'      SET CONTROL LINE\n*\n        $CWTO  MSG=COMMAND,L=60,MSGID=936   LIST COMMAND ON...\n*                                                    CONTROL LINE\n*\n         MVI   COMLINET,X'20'      SET DATA LINE...\n         B     X5CGOOD               AND RETURN\n*\n*--------------\n*        NOTE THAT X'20' IS USED HERE SO THAT WHEN WE GET TO THE\n*        COMMAND PROCESSING ROUTINE, WE ARE READY TO DO $CWTO\n*        WITHOUT CHECKING ANYTHING.  ONLY WHEN WE ARE DONE WITH\n*        EVERYTHING, THEN WE NEED TO DO A X'10' FOR MLWTO.\n*--------------\n*\nX5CBAD1  LA    R15,4               SET BAD RETURN CODE\n         B     X5CCARE             AND RETURN\n*\nX5CGOOD  XR    R15,R15             SET ZERO RETURN CODE\n*\nX5CCARE $RETURN RC=(R15)           RETURN TO MAIN CALLING ROUTINE\n*\n         DROP  R12\n         TITLE 'JES2 EXIT5 - X5UCMD   - USER COMMAND PROCESSING'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        X5UCMD - USER COMMAND PROCESSING                             *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*        LOOPS THROUGH THE COMMAND TABLE (UCOMTAB) TO PICK UP         *\n*        THE ROUTINE ADDRESS ASSOCIATED WITH THE COMMAND AND THEN     *\n*        GO THERE VIA $CALL.                                          *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        CONTROL GIVEN BY $CALL FROM MAIN CALLING ROUTINE             *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        $ESTAE ESTABLISH UPON ENTRY.  THE RECOVERY ROUTINE IS        *\n*        PROVIDED IN X5RECOVR.                                        *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT):                                        *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0-R4     N/A                        UNCHANGED                   *\n*    R5        POINTER TO ADDRESS OF                                  *\n*               CURRENT OPERAND           UNCHANGED                   *\n*    R6        INCREMENT VALUE OF 4       UNCHANGED                   *\n*    R7        POINTER TO ADDRESS OF                                  *\n*               LAST OPERAND              UNCHANGED                   *\n*    R8-R10    N/A                        UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R12       ADDRESS OF HASPCOMM PCE    UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* PARAMETER LIST:                                                     *\n*                                                                     *\n*        ALL NECESSARY INFORMATION LOCATED IN THE DTE, AS PASSED      *\n*        BY THE ATTACHING PROCESSOR.                                  *\n*                                                                     *\n* REGISTER USAGE (INTERNAL):                                          *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0-R2     WORK REGISTERS                                         *\n*    R3     ***  ADDRESS OF THE SUBCMD IN COMMAND BUFFER              *\n*    R4     ***  ADDRESS OF THE SUBCMD TABLE                          *\n*           ***  R3 & R4 -- CAME FROM X5TSTU ROUTINE                  *\n*    R5-R10    WORK REGISTERS                                         *\n*    R11       HCT BASE ADDRESS                                       *\n*    R12       LOCAL BASE ADDRESS                                     *\n*    R13       PCE BASE ADDRESS                                       *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        00 = USER COMMAND                                            *\n*        04 = JES2 COMMAND                                            *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        N/A                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5UCMD,R12          ESTABLISH X5UCMD ADDRESSABILITY\n*\nX5UCMD  $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15             GET BASE REGISTER\n         L     R3,CMDPTR           RELOAD REG 3 (FROM X5TSTU)\n         L     R4,SUBADDR          RELOAD REG 4 (FROM X5TSTU)\n*\n*\n*\n*-------------\n*        R3 NOW POINTS PAST THE COMMAND (ITS PARAMETER)\n*-------------\n*\n*\nX5USUBCK EQU   *\n         CLI   0(R4),X'00'         IS IT THE EOT ??\n         BE    X5UERR              YEAH - DISPLAY HELP MESSAGES\n*\n         XR    R15,R15             CLEAR REG15 FIRST\n         IC    R15,0(R4)           GET LENG OF PARAMETER\n         BCTR  R15,0               MINUS 1 FOR EX INSTRUCTION\n         EX    R15,X5UPARM         NOW - COMPARE WITH ALLOWED PARM\n         BE    X5UGOTIT            IF EQ - THEN CONTINUE ON ....\n         LA    R4,6(R15,R4)        NOW - BUMP TO HELPTEXT DATA\n         IC    R15,0(R4)           PICK UP THE LENGTH\n         LA    R4,1(R15,R4)        AND GO PAST THAT\n         B     X5USUBCK            THEN BACK TO LOOP\n*\n*\nX5UPARM  CLC   0(0,R3),1(R4)       CHECK AGAINST MY PARAMETER TAB\n*\n*\nX5UGOTIT EQU   *\n         LA    R3,1(R15,R3)        NOW - R3 POINTS TO DATA\n         ST    R3,CMDPTR           SAVE THIS INTO MY WORK AREA\n*\n*--------------\n*        BEFORE CALLING ANY ROUTINES, R3 WILL BE SET TO POINT TO\n*        NEXT POSITION IN THE COMMAND AREA (AFTER THE SUBCMD).\n*--------------\n*\n         L     R4,2(R15,R4)        PICK UP ROUTINE ADDRESS\n         $CALL (R4)                EXECUTE THE ROUTINE\n         B     X5UDONE             BRANCH FOR NOW\n*\nX5UERR   EQU   *\n         MVC   BUFFER,X5UMSG1\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         L     R4,SUBADDR          RELOAD REG 4 (FROM X5TSTU)\n*\nX5ULIST  EQU   *\n         CLI   0(R4),X'00'         IS IT THE EOT ??\n         BE    X5UENDL             YEAH - THEN STOP\n*\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         LA    R1,BUFFER+4         KEEP TRACK OF WHERE I AM\n*\n         XR    R15,R15             CLEAR REG15 FIRST\n         IC    R15,0(R4)           GET LENG OF PARAMETER\n         BCTR  R15,0               MINUS 1 FOR EX\n         EX    R15,X5UMOVE         MOVE SUBCMD\n         LA    R1,1(R15,R1)        GO PAST COMMAND ON DISPLAY LINE\n         LA    R4,6(R15,R4)        NOW - BUMP TO HELPTEXT DATA\n         IC    R15,0(R4)           PICK UP THE LENGTH\n         BCTR  R15,R0              MINUS 1 FOR EX\n         EX    R15,X5UMOVE         MOVE HELP TXT FOR DISPLAY\n         LA    R4,2(R15,R4)        AND GO PAST THAT\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         B     X5ULIST             THEN BACK TO LOOP\n*\n*\nX5UMOVE  MVC   0(0,R1),1(R4)       MOVE SUBCMD/HELPTXT\n*\nX5UENDL  EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5UFINIS             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5UFINIS EQU   *\n*\n*---------------------------------------------------------------------*\n*        RETURN TO MAIN CALLING ROUTINE                               *\n*---------------------------------------------------------------------*\n*\n         XR    R15,R15             SET ZERO RETURN CODE\n*\nX5UDONE $RETURN RC=(R15)           RETURN TO MAIN CALLING ROUTINE\n*\n*\nX5UMSG1  DC    CL(BUFFERL)' ALLOWED PARM(S):'\n         LTORG ,                   EXPAND LITERAL POOL HERE\n         DROP  R12\n*\n*\n*\n*\n         TITLE 'JES2 EXIT5 - X5CDJOB - DISPLAY JOBS'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*        R4 - JQE                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5DJOB,R12          ESTABLISH X5UCMD ADDRESSABILITY\n*\nX5DJOB  $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n*\n         MVI   WKDATAL,8           USE 8 AS DEFAULT LENGTH\n         TRT   0(8,R3),TRTABLE     TEST FOR SPACE OR QUOTES\n         BC    8,X5DGOTIT          IF CC=0, THEN 8 CHARACTER LONG\n         SR    R1,R3               ELSE - GET LENG OF PARM\n         BC    8,X5DWTO            IF 0 (BLANK) THEN RETURN\n         STC   R1,WKDATAL          ELSE - STORE THIS\n*\nX5DGOTIT EQU   *\n         LA    R15,0               SET INDEX FOR START OF QUEUE\n         MVI   FOUNDSW,X'00'       TURN OFF 'FOUND' SW\n         USING JQE,R4              ESTAB ADDR\n*\nX5DQJSC  STH   R15,COMJQHDS        SAVE JOB QUEUE HEADER INDEX\n         LA    R4,$JQHEADS-(JQENEXT-JQE)(R15)    NEXT JOB Q\n*\nX5DWKJQE L     R4,JQENEXT          OFFSET OF NEXT JQE\n         N     R4,$ZEROFFF         BR IF END OF Q\n         BZ    X5JNEXTQ\n         AL    R4,$JOBQPTR         GET JQE ADDRESS\n         B     X5DCKNM             GO CHECK FOR MATCHING NAME\n*\nX5JNEXTQ LH    R15,COMJQHDS        GET CURR JOB Q HDR INDEX\n         LA    R15,4(,R15)         INDEX TO NEXT Q\n         LA    R4,$JQTYPES*$JQHEADL     GET LENG OF Q HEADS\n         CLR   R15,R4              END OF QUEUES ??\n         BL    X5DQJSC             NOOP - THEN BACK TO CHECK\n         B     X5DENDJQ            ELSE - I AM DONE\n*\nX5DCOMPJ CLC   JQEJNAME(0),0(R3)   COMPARE\n*\nX5DCKNM  EQU   *\n         XR    R1,R1               CLEAR REG1\n         IC    R1,WKDATAL          GET JOB LENG BACK\n         BCTR  R1,0                SUB 1 FOR EXE\n         EX    R1,X5DCOMPJ         CHECK AGAINST NAME\n         BNE   X5DWKJQE            IF NOT EQ - GO TO NEXT\n*\n         OI    FOUNDSW,$FOUND      KEEP TRACK OF THIS\n*\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n*\n         LR    R1,R4\n         MVI   COMMAND,X'40'\n         MVC   COMMAND+1(255),COMMAND\n        $CFJMSG JOBQE=(R1)\n         B     X5DWKJQE            NOW - LOOK FOR MORE\n*\nX5DENDJQ EQU   *\n         TM    FOUNDSW,$FOUND      ANY JOB(S) FOUND ??\n         BO    X5DWTO              YEAH - THEN GET OUT\n         MVC   BUFFER,X5DJOBM1     GET MESSAGE THERE\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n*\nX5DWTO   EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5DJOBX              IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5DJOBX $RETURN                    RETURN TO MAIN CALLING ROUTINE\n*\nX5DJOBM1 DC    CL(BUFFERL)' NO JOB(S) FOUND'\n*\nTRTABLE  DC    256X'00'\n         ORG   TRTABLE+X'40'       STOP AT X'40'\n         DC    X'FF'\n         ORG   TRTABLE+C''''       STOP AT QUOTES\n         DC    X'FF'\n         ORG   TRTABLE+C','        STOP AT ,\n         DC    X'FF'\n         ORG\n*\n         DROP  R4\n         DROP  R12\n*\n         LTORG\n*\n*\n*\n         TITLE 'JES2 EXIT5 - X5LLT - DISPLAY LINKLIST LIBRARIES'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*---------------------------------------------------------------------*\n*\n         USING X5LLT,R12           ESTABLISH ADDRESSABILITY\n*\nX5LLT   $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n         XC    COUNT,COUNT         CLEAR COUNTER\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BNZ   X5LPROC              IF YES, JUST BYPASS THIS\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5LPROC  EQU   *\n         L     R1,CVTPTR           GET CVT POINTER\n         USING CVTMAP,R1           ESTAB ADDRESSABILITY\n         L     R4,CVTLLTA          GET LINKLIST TABLE ADDRESS\n         DROP  R1\n*\n         USING LLT,R4              ESTAB ADDRESSABILITY\n         ICM   R5,B'1111',LLTCOUNT GET NUMBER OF ENTRIES\n         BZ    X5LLTWTO            IF NONE - THEN GET OUT\n         LR    R15,R5              GET NUMBER OF ENTRIES\n         MH    R15,=AL2(L'LLTENTRY)\n         LA    R15,LLTENTRY-LLT(R15,R4)    GO TO THE APF SECTION\n         ST    R15,LLTAPFAD        SAVE THIS AS APF ADDRESS\n*\n*--------------\n*        R4 POINTS TO NEXT ENTRY\n*        R5 HAS NUMBER OF ENTRIES LEFT TO BE PROCESSED\n*--------------\n*\nX5LLTCK  EQU   *\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         LA    R14,BUFFER\n         USING OLLT,R14            USE R14 TO ADDRESS OUTPUT LINE\n         L     R1,COUNT            GET COUNT\n         LA    R1,1(,R1)           ADD 1 TO IT\n         ST    R1,COUNT            STORE IT BACK\n         CVD   R1,DWORD            CONVERT THIS TO DECIMAL\n         MVC   OLLTCT,LLTCPAT      GET EDIT PATTERN THERE\n         ED    OLLTCT,DWORD+6      NOW UNPACK THIS\n         MVC   OLLTDSN,LLTDSN      MOVE DSN TO OUTPUT\n         L     R15,LLTAPFAD        GET APF POINTER BACK\n         TM    0(R15),LLTAPFIN     CHECK FOR APF\n         BZ    X5LLTOK             IF NO - THEN CONTINUE\n         MVC   OLLTAPF,APFMSG\n*\nX5LLTOK  EQU   *\n         LA    R15,1(R15)          BUMP ADDR BY 1\n         ST    R15,LLTAPFAD        STORE THIS BACK\n*\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n*\n         LA    R4,L'LLTENTRY(,R4)  BUMP TO NEXT ENTRY\n         BCT   R5,X5LLTCK          BACK TO NEXT ENTRY\n*\nX5LLTWTO EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5LLTXIT             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5LLTXIT $RETURN                   RETURN TO MAIN CALLING ROUTINE\n*\n*\nLLTCPAT  DC    X'40202021'         PATTERN USED FOR PRINTING COUNTER\n*\nOLLTAPFL EQU   L'OLLTAPF\nAPFMSG   DC    CL(OLLTAPFL)'- APF -'\n         LTORG\n*\n         DROP  R4\n         DROP  R12\n         DROP  R14\n*\n*\n         TITLE 'JES2 EXIT5 - X5APF - DISPLAY APF LIBRARIES'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*---------------------------------------------------------------------*\n*\n         USING X5APF,R12           ESTABLISH ADDRESSABILITY\n*\nX5APF   $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n         XC    COUNT,COUNT         CLEAR COUNTER\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BNZ   X5ASTART             IF YES, JUST BYPASS THIS\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5ASTART EQU   *\n         L     R1,CVTPTR           GET CVT POINTER\n         USING CVTMAP,R1           ESTAB ADDRESSABILITY\n         L     R4,CVTAUTHL         GET APF TABLE ADDRESS\n         DROP  R1\n         C     R4,DYNAMADR         IS DYNAMIC APF IN EFFECT ?\n         BE    X5DYNAPF            YES ,THEN END IT ALL\n         LH    R5,0(R4)            PICK UP # OF ENTRIES\n         LTR   R5,R5               TEST FOR ZERO\n         BZ    X5APFWTO            IF 0 - THEN I AM DONE\n         LA    R4,2(,R4)           GO TO NEXT GUY\n*\n*--------------\n*        R4 POINTS TO NEXT ENTRY\n*        R5 HAS NUMBER OF ENTRIES LEFT TO BE PROCESSED\n*--------------\n*\nX5APFCK  EQU   *\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n         LA    R14,BUFFER\n         USING OAPF,R14\n*\n         L     R1,COUNT            GET COUNT\n         LA    R1,1(,R1)           ADD 1 TO IT\n         ST    R1,COUNT            STORE IT BACK\n         CVD   R1,DWORD            CONVERT THIS TO DECIMAL\n         MVC   OAPFCT,APFCPAT      GET EDIT PATTERN THERE\n         ED    OAPFCT,DWORD+6      NOW UNPACK THIS\n         MVC   OAPFVOL,1(R4)       GET VOLSER THERE\n         XR    R15,R15             CLEAR REG 15\n         IC    R15,0(R4)           GET LENG OF ENTRY\n         SH    R15,=H'6'           MINUS VOLSER\n         BC    13,X5APFWTO            IF ZERO OR NEG - SOMETHING WRONG\n         BCTR  R15,0               SUBTRACT 1 FOR EXECUTE\n         EX    R15,X5APFMVE            NOW MOVE IT\n         LA    R4,8(R15,R4)        GO TO NEXT ENTRY\n*\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n*\n         BCT   R5,X5APFCK          BACK TO NEXT ENTRY\n*\nX5APFWTO EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5APFXIT             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5APFXIT $RETURN                   RETURN TO MAIN CALLING ROUTINE\n*\n*\nX5DYNAPF EQU   *\n         MVC   BUFFER,APFISDYN     MOVE MSG TO BUFFER FOR DISPLAYING\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         B     X5APFWTO            I'M DONE FOR NOW\n*\nX5APFMVE MVC   OAPFDSN(0),7(R4)    MOVE DSN TO OUTPUT\n*\n         DS    0F\nAPFCPAT  DC    X'40202021'         PATTERN USED FOR PRINTING COUNTER\nDYNAMADR DC    X'7FFFF001'         DYNAMIC APF IN EFFECT\nAPFISDYN DC    CL(BUFFERL)' DYNAMIC APF ACTIVE - USE: D PROG,APF'\n*\n         LTORG\n*\n         DROP  R12\n         DROP  R14\n*\n*\n         TITLE 'JES2 EXIT5 - X5VOL - DISPLAY VOLSER'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*---------------------------------------------------------------------*\n*\n         USING X5VOL,R12           ESTABLISH ADDRESSABILITY\n*\nX5VOL   $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BNZ   X5VBEGIN             IF YES, JUST BYPASS THIS\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5VBEGIN EQU   *\n*\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n*\n         LA    R15,6               USE 6 AS DEFAULT LENGTH\n         L     R14,=AL4(PARMTABL)  GET ADDRESS OF THE TRT TABLE\n         TRT   0(6,R3),0(R14)      TEST FOR SPACE OR ','\n         BC    8,X5VVOLOK          IF CC=0, THEN 6 CHARACTER LONG\n         SR    R1,R3               ELSE - GET LENG OF PARM\n         BC    8,X5VOLWTO          IF 0 (BLANK) THEN RETURN\n         LR    R15,R1              ELSE - STORE THIS\n*\nX5VVOLOK EQU   *\n         MVI   WVOL,X'40'\n         MVC   WVOL+1(L'WVOL-1),WVOL    BLANK VOL\n         BCTR  R15,0               MINUS 1 FOR EXECUTE\n         EX    R15,X5VGETIT        AND THEN SAVE THE VOLSER\n         MVI   UCBWORK,X'00'\n         MVC   UCBWORK+1(L'UCBWORK-1),UCBWORK\n*\n         UCBLOOK VOLSER=WVOL,                                          X\n               UCBPTR=UCBADDR,                                         X\n               NOPIN,                                                  X\n               DEVCLASS=DASD,                                          X\n               DYNAMIC=YES,                                            X\n               RANGE=ALL,                                              X\n               IOCTOKEN=UCBWORK,                                       X\n               RETCODE=UCBRET,RSNCODE=UCBRSN,                          X\n               MF=(E,WUCBLIST)\n*\n         ICM   R15,B'1111',UCBRET  GET RETURN CODE\n         BC    8,X5VFOUND          IF ZERO THEN I FOUND IT\n         CH    R15,=H'4'           IS IT '4' ??\n         BE    X5VNFND             YEAH - THEN NOT FOUND\n*\n         MVC   BUFFER,X5VVOLM1\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         MVC   BUFFER,X5VVOLM2\n         L     R1,=AL4(UNPACK-240) LOAD ADDR OF 'TR' TABLE\n         UNPK  UCBWORK(9),UCBRET(5)\n         TR    UCBWORK(8),0(R1)    DO THE DIRTY WORK\n         MVC   BUFFER+RETOFF(8),UCBWORK\n         UNPK  UCBWORK(9),UCBRSN(5)\n         TR    UCBWORK(8),0(R1)    DO THE DIRTY WORK\n         MVC   BUFFER+RSNOFF(8),UCBWORK\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         B     X5VOLWTO            AND THEN EXIT\n*\nX5VFOUND EQU   *\n         LA    R15,BUFFER\n         USING OUCB,R15\n*\n         MVC   OUCBVOL,OBVOLM\n         MVC   OUCBADDR,OBADDRM\n         MVC   OUCBSTAT,OBSTATM\n         MVC   OUCBMT,OBMTM\n         MVC   OUCBSHR,OBSHRM\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n*\n         LA    R15,BUFFER\n         L     R14,UCBADDR         LOAD ADDRESS OF UCB\n         USING UCBOB,R14           ESTAB ADDR\n*\n         MVC   OUCBVOL,WVOL        VOLSER\n         MVC   OUCBADDR,UCBNAME    ITS ADDR\n*\n         TM    UCBSTAB,UCBBPRV     'PRIVATE' ??\n         BO    X5VMPRIV               YEAH\n         TM    UCBSTAB,UCBBPUB     'PUBLIC' ??\n         BO    X5VMPUB                YEAH\n         TM    UCBSTAB,UCBBSTR     'STORAGE' ??\n         BO    X5VMSTR                YEAH\n         B     X5VCKMT             NOW - CHECK FOR MOUNT STAT\n*\nX5VMPRIV EQU   *\n         MVC   OUCBSTAT,OBPRIV\n         B     X5VCKMT             NOW - CHECK MOUNT STAT\n*\nX5VMPUB  EQU   *\n         MVC   OUCBSTAT,OBPUB\n         B     X5VCKMT             NOW - CHECK MOUNT STAT\n*\nX5VMSTR  EQU   *\n         MVC   OUCBSTAT,OBSTOR\n         B     X5VCKMT             NOW - CHECK MOUNT STAT\n*\n*\nX5VCKMT  EQU   *\n         TM    UCBSTAT,UCBRESV     'RESERVED' ?\n         BZ    X5VCKPRE            NOP - GO CHECK 'RESIDENT'\n         MVC   OUCBMT,OBMTRES      MOVE MESSAGE 'RESERVD'\n         B     X5VCKSHR            NOW - CHECK FOR SHARED DASD\n*\nX5VCKPRE EQU   *\n         TM    UCBSTAT,UCBPRES     'RESDNT' ?\n         BZ    X5VCKSHR            NOP - GO CHECK FOR SHARED DASD\n         MVC   OUCBMT,OBMTPRES     MOVE MESSAGE 'RESDNT'\n*\n*\nX5VCKSHR EQU   *\n         TM    UCBTBYT2,UCBRR      IS THIS SHAREABLE BETWEEN CPU ??\n         BZ    X5VDISPL            NOOP - THEN GO DISPLAY\n         MVC   OUCBSHR,OBSHARED    SHARED DASD\n*\nX5VDISPL EQU   *\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         B     X5VOLWTO            AND THEN EXIT\n*\nX5VNFND  EQU   *\n         MVC   BUFFER,X5VVOLM3\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=900\n         B     X5VOLWTO            AND THEN EXIT\n*\nX5VOLWTO EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5VOLXIT             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=900\n*\nX5VOLXIT $RETURN                   RETURN TO MAIN CALLING ROUTINE\n*\nX5VGETIT MVC   WVOL(0),0(R3)       SAVE VOL\n*\n*\n*\nX5VVOLM1 DC    CL(BUFFERL)' ERROR ISSUING THE UCBLOOK MACRO'\nX5VVOLM2 DC    CL(BUFFERL)' RET=XXXXXXXX RSN=XXXXXXXX'\nRETOFF   EQU   5\nRSNOFF   EQU   18\nX5VVOLM3 DC    CL(BUFFERL)' VOLSER NOT FOUND'\n*\n*\nOBVOLL   EQU   L'OUCBVOL\nOBVOLM   DC    CL(OBVOLL)'VOL'\n*\nOBADDRL  EQU   L'OUCBADDR\nOBADDRM  DC    CL(OBADDRL)'ADR'\n*\nOBSTATL  EQU   L'OUCBSTAT\nOBSTATM  DC    CL(OBSTATL)'STAT'\nOBPRIV   DC    CL(OBSTATL)'PRIVATE'\nOBPUB    DC    CL(OBSTATL)'PUBLIC'\nOBSTOR   DC    CL(OBSTATL)'STORAGE'\n*\nOBMTL    EQU   L'OUCBMT\nOBMTM    DC    CL(OBMTL)'MNTSTAT'\nOBMTRES  DC    CL(OBMTL)'RESERVD'\nOBMTPRES DC    CL(OBMTL)'RESDNT'\n*\nOBSHRL   EQU   L'OUCBSHR\nOBSHRM   DC    CL(OBSHRL)'SHRDASD'\nOBSHARED DC    CL(OBSHRL)'SHARED'\n*\n         LTORG\n*\n         DROP  R12\n         DROP  R14\n         DROP  R15\n*\n*\n*\n         TITLE 'JES2 EXIT5 - X5DSN - LOCATE DATA SET'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*---------------------------------------------------------------------*\n*\n         USING X5DSN,R12           ESTABLISH ADDRESSABILITY\n*\nX5DSN   $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BNZ   X5DSNBEG             IF YES, JUST BYPASS THIS\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=905\n*\nX5DSNBEG EQU   *\n*\n         MVI   BUFFER,X'40'\n         MVC   BUFFER+1(L'BUFFER-1),BUFFER\n*\n         LA    R15,44              USE 44 AS DEFAULT LENGTH\n         L     R14,=AL4(PARMTABL)  GET ADDRESS OF THE TRT TABLE\n         TRT   0(44,R3),0(R14)     TEST FOR SPACE OR ','\n         BC    8,X5DSNOK           IF CC=0, THEN 44 CHARACTERS LONG\n         SR    R1,R3               ELSE - GET LENG OF PARM\n         BC    8,X5DSNWTO          IF 0 (BLANK) THEN RETURN\n         LR    R15,R1              ELSE - STORE THIS\n*\nX5DSNOK  EQU   *\n         MVI   DSN,X'40'\n         MVC   DSN+1(L'DSN-1),DSN  BLANK DSNAME\n         BCTR  R15,0               MINUS 1 FOR EXECUTE\n         EX    R15,X5DSNMVC        AND THEN SAVE THE DSNAME\n*\n         MVC   WCAMLST,CAMLSTN     MAKE CALMST THE RE-ENTRANT FORM\n         LA    R1,DSN              SET UP THE PARAMETER LIST\n         ST    R1,WCAMLST+4             FOR THE CAMLST MACRO\n         LA    R1,LOCAREA\n         ST    R1,WCAMLST+12\n*\n         LOCATE WCAMLST            NOW CATALOG SEARCH THIS DSN\n         STC   R15,DWORD           TEMPORARILY STORE RC TO CHECK\n         TM    DWORD,X'03'         IS THIS DIVISIBLE BY 4 ?\n         BNZ   X5DLCHI             NOPE - THEN RC IS BAD\n*\n         C     R15,=AL4((X5DLCHI-X5DLCR0)-4)   IS RC TOO BIG ??\n         BH    X5DLCHI             YES, THEN SOMETHING WRONG ...\n*\n         B     X5DLCR0(R15)\n*\nX5DLCR0  B     X5DLCCAT            DSN IS CATALOGED\nX5DLCR4  B     X5DLCHI\nX5DLCR8  B     X5DLCNFN\nX5DLCR12 B     X5DLCNFN\nX5DLCR16 B     X5DLCNFN\nX5DLCR20 B     X5DLCNFN\nX5DLCR24 B     X5DLCHI\nX5DLCR28 B     X5DLCNFN\nX5DLCR32 B     X5DLCNFN\nX5DLCR36 B     X5DLCNFN\nX5DLCHI  EQU   *\n         ST    R15,OBTWORK\n         UNPK  DWORD(5),OBTWORK+2(3)\n         L     R1,=AL4(UNPACK-240) LOAD ADDR OF 'TR' TABLE\n         TR    DWORD(4),0(R1)      DO THE TRANSLATION FOR BAD CHAR\n         MVC   BUFFER,X5DSNM1\n         MVC   BUFFER+LCRCOFF(4),DWORD\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=905\n         B     X5DSNWTO\n*\nX5DLCNFN EQU   *\n         ST    R15,OBTWORK\n         UNPK  DWORD(5),OBTWORK+2(3)\n         L     R1,=AL4(UNPACK-240) LOAD ADDR OF 'TR' TABLE\n         TR    DWORD(4),0(R1)      DO THE TRANSLATION FOR BAD CHAR\n         MVC   BUFFER,X5DSNM2\n         MVC   BUFFER+NFNDOFF(4),DWORD\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=905\n         B     X5DSNWTO\n*\n*\nX5DLCCAT EQU   *\n*\n*------- I'VE GOT A GOOD RETURN CODE FROM 'LOCATE'.  NOW MY 'LOCAREA'\n*------- HAS THE LIST OF VOLUMES THIS DATA SET IS ON.\n*\n         LH    R5,LOCAREA          OBTAIN # OF VOLUMES\n*\n*\n*------- R5 - NUMBER OF VOLUMES TO BE PROCESSED\n*------- R6 - VOLUME ENTRY ADDRESS (FROM THE WORKAREA RETURNED)\n*\n*\n         LA    R6,LOCAREA+2        ADDR OF A VOLUME ENTRY\n         MVC   BUFFER,X5DSNM3\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=905\n         MVC   BUFFER,X5DSNM3A\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=905\n*\nX5DLOOP  EQU   *\n         MVC   BUFFER,X5DSNM4\n         MVC   BUFFER+CVOLUME(6),4(R6)  MOVE VOLSER TO OUTPUT LINE\n*\n         TM    2(R6),X'20'         IS THIS DASD ??\n         BO    X5DASDOK            YES - THEN GO PROCESS MORE\n         TM    2(R6),X'80'         IS IT TAPE ??\n         BZ    X5DDISP             NOPE - THEN GO DO THE DISPLAY\n*\n         MVC   BUFFER+CMESSAGE(L'@TAPE),@TAPE\n         B     X5DDISP             PUT OUT '(TAPE)' AS MESSAGE\n*\nX5DASDOK EQU   *\n         MVC   WCAMLST,CAMLSTS     MAKE CALMST THE RE-ENTRANT FORM\n         LA    R1,DSN              SET UP THE PARAMETER LIST\n         ST    R1,WCAMLST+4             FOR THE CAMLST MACRO\n         LA    R1,4(,R6)           ADDRESS TO VOLSER\n         ST    R1,WCAMLST+8\n         LA    R1,OBTWORK\n         ST    R1,WCAMLST+12\n*\n*\n         OBTAIN WCAMLST            NOW OBTAIN DSCB ON THIS VOLUME\n         STC   R15,DWORD           TEMPORARILY STORE RC TO CHECK\n         TM    DWORD,X'03'         IS THIS DIVISIBLE BY 4 ?\n         BNZ   X5DOBTHI            NOPE - THEN RC IS BAD\n*\n         C     R15,=AL4((X5DOBTHI-X5DOBT0)-4)   IS RC TOO BIG ??\n         BH    X5DOBTHI            YES, THEN SOMETHING WRONG ...\n*\n         B     X5DOBT0(R15)\n*\nX5DOBT0  B     X5DEXIST            DSN EXISTS ON VOLUME\nX5DOBT4  B     X5DONOTM            VOLUME NOT MOUNTED\nX5DOBT8  B     X5DNOVOL            NOT ON VOLUME\nX5DOBT12 B     X5DOBTHI            ERROR\nX5DOBT16 B     X5DOBTHI            ERROR\nX5DOBTHI EQU   *\n         ST    R15,OBTWORK\n         UNPK  DWORD(5),OBTWORK+2(3)\n         L     R1,=AL4(UNPACK-240) LOAD ADDR OF 'TR' TABLE\n         TR    DWORD(4),0(R1)      DO THE TRANSLATION FOR BAD CHAR\n         MVC   BUFFER+CMESSAGE(L'@OBTRC),@OBTRC\n         MVC   BUFFER+CMESSAGE+L'@OBTRC-4(4),DWORD     MOVE RC\n         B     X5DDISP\n*\n*\nX5DEXIST EQU   *\n         MVC   BUFFER+CMESSAGE(L'@EXIST),@EXIST\n         B     X5DDISP\n*\nX5DONOTM EQU   *\n         MVC   BUFFER+CMESSAGE(L'@NOTMNT),@NOTMNT\n         B     X5DDISP\n*\nX5DNOVOL EQU   *\n         MVC   BUFFER+CMESSAGE(L'@NOTHERE),@NOTHERE\n         B     X5DDISP\n*\n*\nX5DDISP  EQU   *\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=905\n         LA    R6,12(,R6)          GO TO NEXT VOLUME ENTRY\n         BCT   R5,X5DLOOP          LOOP BACK TO PROCESS ALL VOLUMES\n*\nX5DSNWTO EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5DSNXIT             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=905\n*\nX5DSNXIT $RETURN                   RETURN TO MAIN CALLING ROUTINE\n*\n*\nX5DSNMVC MVC   DSN(0),0(R3)        SAVE DSNAME\n*\n*\n*\nX5DSNM1  DC    CL(BUFFERL)' LOCATE ERROR - RC=XXXX'\nLCRCOFF  EQU   19\n*\nX5DSNM2  DC    CL(BUFFERL)' DATA SET NOT FOUND - RC=XXXX'\nNFNDOFF  EQU   25\n*\nX5DSNM3  DC    CL(BUFFERL)' CATALG   MESSAGE'\nX5DSNM3A DC    CL(BUFFERL)' ------   --------------------------------'\nX5DSNM4  DC    CL(BUFFERL)' XXXXXX   X'\nCVOLUME  EQU   1\nCMESSAGE EQU   10\n*\n*\n@TAPE    DC    C'(TAPE)'\n@OBTRC   DC    C'+++ OBTAIN ERROR - RC=XXXX'\n@EXIST   DC    C'DATA SET ON VOLUME AS CATALOGED'\n@NOTHERE DC    C'+++ DATA SET NOT ON VOLUME'\n@NOTMNT  DC    C'+++ VOLUME NOT MOUNTED'\n*\n*\nCAMLSTN  CAMLST NAME,*,,*\nCAMLSTL  EQU   *-CAMLSTN\n*\nCAMLSTS  CAMLST SEARCH,*,*,*\n*\n*\n         LTORG\n*\n         DROP  R12\n*\n*\n         TITLE 'JES2 EXIT5 - X5SYS - DISPLAY SYSTEM INFORMATION'\n*\n*---------------------------------------------------------------------*\n*        R3 - POINTS TO CURRENT POSITION IN THE CMD BUFFER            *\n*---------------------------------------------------------------------*\n*\n         USING X5SYS,R12           ESTABLISH ADDRESSABILITY\n*\nX5SYS   $SAVE                      SAVE CALLERS REGISTERS\n         LR    R12,R15\n         L     R3,CMDPTR           RE-LOAD CMD POINTER POSITION\n*\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BNZ   X5SYSBEG             IF YES, JUST BYPASS THIS\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=910\n*\nX5SYSBEG EQU   *\n         L     R1,CVTPTR           GET CVT POINTER\n         SH    R1,=AL2(CVTMAP-CVTFIX)   BACK TO CVT PREFIX\n         USING CVTFIX,R1\n*\n         MVC   IPLOPSYS,CVTPRODN   GET MVS OPSYS\n         MVC   IPLFMID,CVTPRODI    GET MVS FMID\n         MVC   IPLMVSRL,CVTRELNO   GET MVS REL #\n         UNPK  DWORD(5),CVTMDL(3)  GET CPU MODEL\n         MVC   IPLCPTYP,DWORD      MOVE THIS\n         TR    IPLCPTYP,UNPACK-240   ... AND MAKE THIS PRINTABLE\n*\n         ICM   R14,B'1111',CVTASMVT      GET ASM POINTER\n         MVC   IPLCLPA,X5NCLPA\n         TM    1(R14),X'08'        IS CLPA DONE ?\n         BO    X5SYSIPL            NOPE - THEN CONTINUE ON\n         MVC   IPLCLPA,X5CLPA\n*\nX5SYSIPL EQU   *\n         MVC   IPLSYSID,CVTSNAME   GET SYSID\n         ICM   R14,B'1111',CVTRLSTG      GET ONLINE STORAGE\n         SRA   R14,10              DIVIDE BY 1024\n         CVD   R14,DWORD           CONVERT TO DECIMAL\n         MVC   UCBWORK(L'X5SPAT1),X5SPAT1\n         ED    UCBWORK(L'X5SPAT1),DWORD+5\n         MVC   IPLSTOR,UCBWORK+1   MOVE THIS TO PRINT\n*\n         ICM   R14,B'1111',CVTRCEP GET POINTER TO RCE\n         USING RCE,R14\n         L     R14,RCEESPL         GET EXPANDED STORAGE (IN FRAMES)\n         DROP  R14\n         SRL   R14,8               CONVERT TO MEG (DIVIDE BY 256)\n         CVD   R14,DWORD           CONVERT TO DECIMAL\n         MVC   UCBWORK(L'X5SPAT1),X5SPAT1\n         ED    UCBWORK(L'X5SPAT1),DWORD+5\n         MVC   IPLESTOR,UCBWORK+1      MOVE THIS TO PRINT\n*\n         L     R14,CVTDFA          GET DFA ADDRESS\n         USING DFA,R14\n         UNPK  DWORD(5),DFAREL(3)\n         MVC   IPLDFPRL,DWORD\n         TR    IPLDFPRL,UNPACK-240     MAKE THIS PRINTABLE\n         DROP  R14\n*\n         L     R14,CVTECVT         GET EXTENDED CVT ADDRESS\n         USING ECVT,R14\n         MVC   IPLLOADP,ECVTLOAD   OBTAIN IPL'ED LOADPARM\n         DROP  R14\n*\n         L     R14,CVTSYSAD        GET SYSRES UCB ADDRESS\n         USING UCBOB,R14\n         MVC   IPLVOL,UCBVOLI      GET VOLSER\n         MVC   IPLADDR,UCBNAME     GET UCB ADDRESS\n         DROP  R14\n*\n         L     R14,CVTSMCA         GET SMCA ADDRESS\n         USING SMCABASE,R14\n         MVC   IPLSMFID,SMCASID    GET SMF ID\n         UNPK  DWORD(5),SMCAIDTE+1(3)\n         MVC   IPLDATE(2),DWORD    MOVE YEAR\n         MVI   IPLDATE+2,C'.'       AND SEPARATER\n         MVC   IPLDATE+3(3),DWORD+2   AND DAY\n         L     R4,SMCAITME         GET TIME\n         SRDA  R4,32(0)            SHIFT BEFORE DIVISION\n         D     R4,=F'360000'       GET THE HOUR\n         CVD   R5,DWORD            CONVERT RESULT TO DECIMAL\n         MVC   UCBWORK(L'X5SPAT2),X5SPAT2\n         ED    UCBWORK(L'X5SPAT2),DWORD+6\n         MVC   IPLTIME(2),UCBWORK+2\n         MVI   IPLTIME+2,C'.'      ADD SEPERATOR\n         SRDA  R4,32(0)            SHIFT BEFORE DIVISION\n         D     R4,=F'6000'         GET THE MINUTES\n         CVD   R5,DWORD            CONVERT RESULT TO DECIMAL\n         MVC   UCBWORK(L'X5SPAT3),X5SPAT3\n         ED    UCBWORK(L'X5SPAT3),DWORD+6\n         MVC   IPLTIME+3(2),UCBWORK+2\n         DROP  R14\n*\n         MVC   BUFFER,X5SM0\n         MVC   BUFFER+M0SYSID(L'IPLSYSID),IPLSYSID\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM1\n         MVC   BUFFER+M1DATE(L'IPLDATE),IPLDATE\n         MVC   BUFFER+M1TIME(L'IPLTIME),IPLTIME\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM1A\n         MVC   BUFFER+M1AITYPE(L'IPLCLPA),IPLCLPA\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM1B\n         MVC   BUFFER+M1BLOADP(L'IPLLOADP),IPLLOADP\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM2\n         MVC   BUFFER+M2ADDR(L'IPLADDR),IPLADDR\n         MVC   BUFFER+M2VOL(L'IPLVOL),IPLVOL\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM3\n         MVC   BUFFER+M3STOR(L'IPLSTOR),IPLSTOR\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM3A\n         MVC   BUFFER+M3AESTR(L'IPLESTOR),IPLESTOR\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM4\n         MVC   BUFFER+M4OPSYS(L'IPLOPSYS),IPLOPSYS\n         MVC   BUFFER+M4FMID(L'IPLFMID),IPLFMID\n         MVC   BUFFER+M4SMFID(L'IPLSMFID),IPLSMFID\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         MVC   BUFFER,X5SM5\n         MVC   BUFFER+M5MVSREL(L'IPLMVSRL),IPLMVSRL\n         MVC   BUFFER+M5DFPREL(L'IPLDFPRL),IPLDFPRL\n         MVC   BUFFER+M5CPUTYP(L'IPLCPTYP),IPLCPTYP\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\n         L     R4,CVTPCCAT         GET PCCAVT ADDRESS\n         LA    R5,16               ASSUME 16 CP'S\n         DROP  R1\n         USING PCCA,R1\n*\nX5SPCCA  EQU   *\n         ICM   R1,B'1111',0(R4)    GET PCCA ADDRESS\n         BZ    X5SNEXT             IS ZERO - THEN GO TO NEXT\n         MVC   BUFFER,X5SM6\n         MVC   BUFFER+M6SERIAL(6),PCCACPID+2\n         UNPK  DWORD(5),PCCACPUA(3)\n         TR    DWORD(4),UNPACK-240\n         MVC   BUFFER+M6CPUNUM(2),DWORD+2    GET CPU ADDRESS\n        $CWTO  MSG=BUFFER,L=L'BUFFER,MSGID=910\n*\nX5SNEXT  EQU   *\n         LA    R4,4(,R4)           BUMP TO NEXT PCCA POINTER\n         BCT   R5,X5SPCCA          CHECK FOR 16 ENTRIES\n*\n         DROP  R1\nX5SYSWTO EQU   *\n         CLI   COMUCMA,0           TEST FOR MLWTO\n         BZ    X5SYSXIT             IF NOT, I AM DONE\n         MVI   COMLINET,X'10'      SET CONTROL LINE\n        $CWTO  MSG=WCOMMAND,L=L'BUFFER,MSGID=910\n*\nX5SYSXIT $RETURN                   RETURN TO MAIN CALLING ROUTINE\n*\nX5SPAT1  DC    X'402020202021'\nX5SPAT2  DC    X'40202120'\nX5SPAT3  DC    X'40212020'\n*\nCLPALENG EQU   L'IPLCLPA\nX5NCLPA  DC    CL(CLPALENG)'NON-CLPA'\nX5CLPA   DC    CL(CLPALENG)'CLPA'\n*\nX5SM0    DC    CL(BUFFERL)' SYSINFO DISPLAY FOR XXXXXXXX'\nM0SYSID  EQU   21\n*\nX5SM1    DC    CL(BUFFERL)' IPL TIME=DD.YYY - HH.MM'\nM1DATE   EQU   10\nM1TIME   EQU   19\n*\nX5SM1A   DC    CL(BUFFERL)' IPL TYPE=XXXXXXXX'\nM1AITYPE EQU   10\n*\nX5SM1B   DC    CL(BUFFERL)' IPL LOADPARM=XXXXXXXX'\nM1BLOADP EQU   14\n*\nX5SM2    DC    CL(BUFFERL)' SYSRES ADDR=XXX  VOLSER=XXXXXX'\nM2ADDR   EQU   13\nM2VOL    EQU   25\n*\nX5SM3    DC    CL(BUFFERL)' ONLINE STORAGE AT IPL TIME=XXXXXM'\nM3STOR   EQU   28\n*\nX5SM3A   DC    CL(BUFFERL)' EXPANDED STORAGE=XXXXXM'\nM3AESTR  EQU   18\n*\nX5SM4    DC    CL(BUFFERL)' OPSYS=XXXXXXXX  FMID=XXXXXXXX  SMFID=XXXX'\nM4OPSYS  EQU   7\nM4FMID   EQU   22\nM4SMFID  EQU   38\n*\nX5SM5    DC    CL(BUFFERL)' MVSREL=XXXX  DFPREL=XXX  CPUTYPE=XXXX'\nM5MVSREL EQU   8\nM5DFPREL EQU   21\nM5CPUTYP EQU   34\n*\nX5SM6    DC    CL(BUFFERL)' CPU=XX  SERIAL=XXXXXX'\nM6CPUNUM EQU   5\nM6SERIAL EQU   16\n*\n         LTORG\n*\n         DROP  R12\n*\n*\n*\n         TITLE 'JES2 EXIT5 - X5CVCCA  - CHECK VALID CONSOLE AREA'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        X5CVCCA - VERIFY CONSOLE/AREA                                *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*        X5CVCCA VERIFIES CONSOLE AREA.  IF NO SERIOS ERROR,          *\n*        RETURN TO CALLER (R15=0).  IF ERROR, ERROR MESSAGE           *\n*        HASP936/7 IS ISSUED, RETURN TO CALLER (R15=4).               *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        CONTROL GIVEN BY $CALL FROM MAIN CALLING ROUTINE             *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        $ESTAE ESTABLISH UPON ENTRY.  THE RECOVERY ROUTINE IS        *\n*        PROVIDED IN X5RECOVR.                                        *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT):                                        *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0-R4     N/A                        UNCHANGED                   *\n*    R5        POINTER TO ADDRESS OF                                  *\n*               CURRENT OPERAND           UNCHANGED                   *\n*    R6        INCREMENT VALUE OF 4       UNCHANGED                   *\n*    R7        POINTER TO ADDRESS OF                                  *\n*               LAST OPERAND              UNCHANGED                   *\n*    R8-R10    N/A                        UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R12       ADDRESS OF HASPCOMM PCE    UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* PARAMETER LIST:                                                     *\n*                                                                     *\n*        ALL NECESSARY INFORMATION LOCATED IN THE DTE, AS PASSED      *\n*        BY THE ATTACHING PROCESSOR.                                  *\n*                                                                     *\n* REGISTER USAGE (INTERNAL):                                          *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0-R10    WORK REGISTERS                                         *\n*    R11       HCT BASE ADDRESS                                       *\n*    R12       LOCAL BASE ADDRESS                                     *\n*    R13       PCE BASE ADDRESS                                       *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        00 = USER COMMAND                                            *\n*        04 = JES2 COMMAND                                            *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        N/A                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\n         USING X5CVCCA,R12         ESTABLISH X5CVCCA ADDRESSABILITY\n*\nX5CVCCA $SAVE                      SAVE CALLERS REGISTERS\n*\n         LR    R12,R15             ESTABLISH BASE\n*\n         TM    MBLFLG,MBLFLGR      REMOTE SYSTEM UCM\n         BO    X5GOODRC              NO, ZERO RC...\n*\nX5CNRUCM L     R2,$COMEXTN         POINT TO EXTENDED AREA\n         USING CONV,R2             ESTABLISH COM ADDRESSABILITY\n*\n         L     R2,CWAVG200-CWA(R2) POINT TO CONV PARM LIST\n         XC    CONV(CONVPLEN),CONV REFRESH CONV PARM LIST\n         MVC   CONVACRO,=C'CONV'  SET PARMLIST EYE CATCHER\n         MVI   CONVVRSN,CONVRID   SET SYSTEM/VERSION LEVEL\n         MVI   CONVFLGS,CONVPID   INDICATE PROCESS CONSOLE ID\n         MVC   CONVID,COMUCMID    SET CONSOLE ID\n         CLI   COMUCMA,X'0'       IS AREA SPECIFIED ?\n         BNE   X5CNAREA           YES - GO SET AREA\n         MVI   CONVAREA,C'Z'      NO  - FORCE DEFAULT AREA\n         B     X5CNCONV           CALL CONVCON SERVICE\n*\nX5CNAREA MVC   CONVAREA,COMUCMA   SET AREA TO BE VERIFIED\n*\nX5CNCONV CONVCON (R2)             GO VERIFY CONSOLE + AREA\n*\n         LTR   R15,R15            IS CONSOLE AVAILABLE ?\n         BNZ   X5CVERR            NO  - GO HANDLE IT\n         CLI   CONVRSN,$AIDOK     IS AREA OK ?\n         BE    X5CVRET            YES - RETURN TO CALLER\n         CLI   CONVRSN,$AIDUSED   IS AREA OK, BUT IN USE ?\n         BE    X5CVRET            YES - RETURN TO CALLER\n*\nX5CVERR  SLR   R3,R3              ZERO WORK\n         ICM   R3,B'0101',COMUCMID+(COMUCMA-COMUCMA)\n*                                 PICK UP UCM ID AND AREA\n         MVI   COMUCMA,0          FORCE NO MLWTO (NO PREVIOUS LINE\n         MVC   COMUCMID,COMINCON  SET INPUT CONSOLE ID\n*\n        $CWTO  L=L'COMMAND,MSGID=936      WRITE TO OPERATOR\n*\n         MVC   COMMAND(MBVINVL),MBVINV MOVE DIAGNOSTIC TEXT\n         STC   R3,MBVINVA         SET AREA\n         SRL   R3,8               ALIGN CONSOLE ID\n*\n         $CFCVE VALUE=(R3)        CONVERT TO EBCDIC\n*\n         MVC   MBVINVC,COMDWORK+3 SET INTO TEXT\n         MVC   COMMAND+MBVINVL(8),COMACEID MOVE IDENTIFIER\n         MVC   COMMAND(MBVINVL),MBVINV\n         LA    R1,COMMAND\n        $CWTO  L=MBVINVL,MSGID=937      WRITE TO OPERATOR\n         LA    R15,4                    SET NON-ZERO RETURN CODE\n         B     X5CVRET                  NOW - GET OUT\n*\nX5GOODRC XR    R15,R15                  CLEAR RETURN CODE\nX5CVRET $RETURN RC=(R15)                RETURN TO CALLER (X5AUTH)\n*                                         OR (X5LCCA)\n*\n         DROP  R2\n         DROP  R12\n         TITLE 'JES2 EXIT5 - X5RECOVR - PROCESSOR RECOVERY ROUTINE'\n*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        JESXIT05 - EXIT 5 RECOVERY ROUTINE                           *\n*                                                                     *\n*        THIS ROUTINE WILL RECOVER FROM PROGRAM                       *\n*        CHECKS BY DISCARDING THE COMMAND CURRENTLY                   *\n*        BEING PROCESSED AND THEN RETURN TO 'X5RC08'                  *\n*        WHERE IT WILL RETURN TO JES2 WITH A CODE 8                   *\n*        WHICH WILL CAUSE JES2 TO IGNORE THE COMMAND                  *\n*                                                                     *\n*        REGISTERS UPON ENTRY -                                       *\n*                                                                     *\n*            R0 - SAME AS AT ABEND                                    *\n*            R1 - POINTER TO ERA                                      *\n*      R2 - R10 - SAME AS AT ABEND                                    *\n*           R11 - POINTER TO HCT                                      *\n*           R13 - POINTER TO PCE                                      *\n*           R14 - RETURN ADDRESS                                      *\n*           R15 - ENTRY ADDRESS                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n*\nX5RECOVR $SAVE                     SAVE CALLERS REGISTERS\n*\n         LR    R8,R15              GET ADDRESS OF RECOVERY RTN\n         USING X5RECOVR,R8         SET ADDRESSABILITY FOR RTN\n*\n         LR    R5,R1               GET ADDRESS OF ERA IN R5\n         USING ERA,R5              SET ADDRESSABILITY FOR ERA\n*\n         CLC   ERAESRG0,=F'12'     IS THERE A SDWA....\n         BE    CPERC               BRANCH IF NO\n*\n         L     R3,ERASDWA          GET ADDRESS OF SDWA\n         USING SDWA,R3             SET ADDRESSABILITY FOR SDWA\n*\n         L     R4,ERAPRE           GET ADDRESS OF PRE\n         USING PRE,R4              SET ADDRESSABILITY FOR PRE\n*\n*---------------------------------------------------------------------*\n*        TEST FOR PROGRAM CHECK  (SDWAPCHK)                           *\n*---------------------------------------------------------------------*\n*\n         TM    SDWAERRA,SDWAPCHK   TEST FOR PROGRAM CHECK\n         BZ    CPERC               BRANCH IF NOT A PROGRAM CHECK\n*\n         DROP  R3                  KILL ADDRESSABILITY FOR SDWA\n*\n*---------------------------------------------------------------------*\n*        END ANY MULTIPLE LINE WTO IN PROGRESS                        *\n*---------------------------------------------------------------------*\n*\n         TM    COMFLAG,CMBFLAGU    TEST FOR UCMID .(OWN OR OTHER)\n         BZ    CSETMSG             BRANCH IF OTHER\n*\n         CLI   COMUCMA,0           IS THIS A MLWTO...\n         BZ    CSETMSG             BRANCH IF NO\n*\n         OI    COMLINET,X'10'      SET END LINE\n*\n         SLR   R0,R0               SET NULL MESSAGE LENGTH\n         BCTR  R0,0              SET LENGTH TO -1 TO TRUNC MLWTO\n*\n        $CWTO  L=(R0)              END ANY MLWTO IN PROGRESS\n*\n         MVI   COMUCMA,X'00'       CLEAR UCM AREA TO INSURE CMD        C\n                                     TERMINATED MSG IS NOT MLWTO\n*\n*---------------------------------------------------------------------*\n*        INFORM OPERATOR OF COMMAND THAT WILL BE DISCARDED.           *\n*        'NETWORK COMMAND' WILL BE USED FOR SSI FORMATTED             *\n*        COMMANDS.                                                    *\n*---------------------------------------------------------------------*\n*\nCSETMSG  MVC   COMMAND(L'CMSGTXT),CMSGTXT   MOVE IN MESSAGE TEXT\n*\n         TM    COMINCON,X'80'     TEST FOR SSI FORMATTED COMMAND\n         BZ    CPREMSG            BRANCH IF NOT SSI FORMATTED CMD\n*\n         MVC   COMMAND+L'CMSGTXT(CCMDLN),CNETCMD MOVE IN FORMATTED     C\n                                                     COMMAND TEXT\n         B     CMSGTOOP            GO SEND MESSAGE TO OPERATOR\n*\nCPREMSG  MVC   COMMAND+L'CMSGTXT(CCMDLN),PRETRACK MOVE IN PORTION      C\n                                                      OF COMMAND\n*\n         DROP  R4                  KILL ADDRESSABILITY FOR PRE\n*\n*---------------------------------------------------------------------*\n*        SEND COMMAND TERMINATED MESSAGE TO CONSOLE WHERE THE         *\n*        COMMAND ORIGINATED AND ALSO TO THE MAIN CONSOLE              *\n*---------------------------------------------------------------------*\n*\nCMSGTOOP $CWTO L=CMLENGTH,MSGID=925   SEND MESSAGE TO WHERE            C\n                                         COMMAND ORIGINATED\n*\n        $WTO   COMMID,CMLENGTH+L'COMMID,JOB=NO,       SEND MSG TO      C\n               ROUTE=$MAIN+$ERR,CLASS=$ALWAYS,PRI=$HI MASTER CON\n*\n*---------------------------------------------------------------------*\n*      $SETRP                                                         *\n*        SET UP OPTIONS (RESUME OR PERCOLATE)                         *\n*        AND RETURN TO CALLER.                                        *\n*---------------------------------------------------------------------*\n*\n         MVC   ERAREG12,=A(EXIT5) RESTORE MAINLINE ROUTINE'S           C\n                                     BASE REGISTER             @410P232\n         L     R14,=A(X5RC08)      R14 => DELETE COMMAND RETURN\n*\n        $SETRP RESUME=(R14)        SET RESUMPTION ADDRESS\n*\n         B     CRETURN             GO TO RETURN\n*\nCPERC   $SETRP PERCOLATE           SET PERCOLATE OPTION\n*\nCRETURN $RETURN                    RETURN TO CALLER\n*\n         DROP  R5                  KILL ADDRESSABILITY FOR ERA\n*\n*---------------------------------------------------------------------*\n*        CONSTANTS FOR X5RECOVR PROCESSOR RECOVERY ROUTINE            *\n*---------------------------------------------------------------------*\n*\nCMSGTXT  DC    C'COMMAND TERMINATED - '   CMD TERMINATED MSG TEXT\n*\nCNETCMD  DC    C'NETWORK COMMAND' FOR FORMATTED COMMANDS THIS TEXT     C\n                                      WILL BE USED INSTEAD OF THE      C\n                                          ACTUAL COMMAND\n*\nCCMDLN   EQU   L'CNETCMD           LENGTH OF THIS MESSAGE\n*\nCMLENGTH EQU   L'CMSGTXT+CCMDLN    TOTAL MESSAGE LENGTH\n*\n         EJECT\n         DROP  R8\n         TITLE 'JES2 EXIT5 - COMMAND EDIT CONSTANTS'\n*\n*---------------------------------------------------------------------*\n*        EXIT 5  CONSTANTS                                            *\n*---------------------------------------------------------------------*\n*\nMBVINVMB DC    C'$HASP994 COMMAND IS INVALID FROM THIS CONSOLE'\nMBVINVLB EQU   *-MBVINVMB\n*\nMBVINV   DC    C'RESPONSE LOCATION L=CCA UNAVAILABLE '\nMBVINVL  EQU   *-MBVINV\nMBVINVC  EQU   COMMAND+MBVINVL-16,2\nMBVINVA  EQU   MBVINVC+2,1\n*\n*\nMBLFLG   EQU   COMEWORK+2          FLAG BYTE\nMBLFLGR  EQU   1                   UCM COMMAND FROM REMOTE SYSTEM\nMBLFLGC  EQU   2                   CONSOLE HAS BEEN SPECIFIED\nMBLFLGA  EQU   4                   AREA HAS BEEN SPECIFIED\n*\nUNPACK   DC    C'0123456789ABCDEF'\n*\n*--------\n*        MY COMMAND TABLE\n*--------\n*\nUCOMTAB  $$CMDTAB TYPE=START\n*\n         $$CMDTAB '$Q',USUBTAB\n*\n         $$CMDTAB TYPE=STOP\n*\n*\n*--------\n*        SUB-COMMAND TABLE FOR $Q\n*--------\n*\n*\nUSUBTAB  $$SUBTAB ENTTYPE=START\n*\n         $$SUBTAB '''',X5DJOB,'XX = TO DISPLAY JOB(S) PREFIXED BY XX'\n         $$SUBTAB 'APF ',X5APF,'= TO DISPLAY APF LIBRARIES'\n         $$SUBTAB 'DSN=',X5DSN,'XX = TO LOCATE A DATA SET'\n         $$SUBTAB 'LLT ',X5LLT,'= TO DISPLAY LINKLIST LIBRARIES'\n         $$SUBTAB 'VOL=',X5VOL,'XX = TO DISPLAY UCB ADDR FOR VOLSER XX'\n         $$SUBTAB 'SYSTEM ',X5SYS,'= TO DISPLAY SYSTEM INFORMATION'\n*\n         $$SUBTAB ENTTYPE=STOP\n*\nPARMTABL DC    256X'00'            STOP AT ' ' OR ','\n         ORG   PARMTABL+C','\n         DC    X'FF'\n         ORG   PARMTABL+C' '\n         DC    X'FF'\n         ORG\n*\n         LTORG ,                   EXPAND LITERAL POOL HERE\n*\n*\n         EJECT\n*\n         $MODEND ,\n*\n*\nWKAREA   DSECT\n         DS    CL(BUFSTART-BFPDSECT)    RESERVED BY JES2\nDWORD    DS    D\nWKDATAL  DS    CL1                 DATA LENG (TO COMPARE)\n*\nFOUNDSW  DS    CL1\n$FOUND   EQU   X'80'               JOB IS FOUND\n*\nCOUNT    DS    F                   USED AS COUNTER\nSUBADDR  DS    F                   ADDRESS OF SUBCMD TABLE\nCMDPTR   DS    F                   POINTER TO COMMAND PARM\nUCBADDR  DS    F                   UCB ADDRESS RETURNED BY UCBLOOK\nUCBRET   DS    F                   UCBLOOK RET CODE\nUCBRSN   DS    F                   UCBLOOK REASON CODE\nLLTAPFAD DS    F                   POINTER TO APF SECTION IN LLT\n*\n*\nWCAMLST  DS    CL(CAMLSTL)         CAMLST WORK AREA\nDSN      DS    CL44                WORK DSN\nLOCAREA  DS    0D\n         DS    265C                CAMLST WORK AREA\n*\n         DS    0F\nOBTWORK  DS    140C\n*\n*\nIPLTIME  DS    CL5                 IPL TIME\nIPLDATE  DS    CL6                 IPL DATE\nIPLVOL   DS    CL6                 IPL VOLSER\nIPLADDR  DS    CL3                 IPL ADDRESS\nIPLCLPA  DS    CL8                 IPL TYPE (CLPA OR NON-CLPA)\nIPLSTOR  DS    CL5                 IPL'ED ONLINE STORAGE\nIPLESTOR DS    CL5                 IPL'ED EXPANDED STORAGE\nIPLSYSID DS    CL(L'CVTSNAME)      SYSTEM ID\nIPLSMFID DS    CL(L'SMCASID)       SMF ID\nIPLOPSYS DS    CL(L'CVTPRODN)      MVS LEVEL\nIPLFMID  DS    CL(L'CVTPRODI)      MVS FMID\nIPLCPTYP DS    CL4                 CPU TYPE\nIPLMVSRL DS    CL(L'CVTRELNO)      MVS RELEASE NUMBER\nIPLDFPRL DS    CL3                 DFP RELEASE NUMBER\nIPLLOADP DS    CL8                 IPL'ED LOADPARM\n*\n         DS    0D                  ALIGNMENT\n         UCBLOOK MF=(L,WUCBLIST)\nWVOL     DS    CL6\n*\nUCBWORK  DS    CL48                WKAREA USED BY UCBLOOK\n*\nBUFFER   DS    CL60\nBUFFERL  EQU   L'BUFFER\n*\nWCOMMAND DS    CL256               SAVED COMMAND AREA\nWKLENG   EQU   *-WKAREA\n*\n         EJECT\n*\nOLLT     DSECT\n         DS    CL1\nOLLTCT   DS    CL4\n         DS    CL2\nOLLTAPF  DS    CL7\n         DS    CL1\nOLLTDSN  DS    CL44\n*\n*\nOAPF     DSECT\n         DS    CL1\nOAPFCT   DS    CL4\n         DS    CL2\nOAPFVOL  DS    CL6\n         DS    CL2\nOAPFDSN  DS    CL44\n*\n*\nOUCB     DSECT\n         DS    CL1\nOUCBVOL  DS    CL6\n         DS    CL2\nOUCBADDR DS    CL3\n         DS    CL2\nOUCBSTAT DS    CL7\n         DS    CL2\nOUCBMT   DS    CL7\n         DS    CL2\nOUCBSHR  DS    CL7\n*\n*\nLLT      DSECT\nLLTHEAD  DS    0CL8\nLLTID    DS    CL4\nLLTCOUNT DS    CL4\n*\nLLTENTRY DS    0CL45\nLLTDSLTH DS    CL1                 LENG OF DSAT\nLLTDSN   DS    CL44                DSNAME\n*\nLLTAPFIN EQU   X'80'               LIBRARY IS APF\n*\n         EJECT\n        PRINT GEN\n         CVT   DSECT=YES,LIST=YES,PREFIX=YES\n         EJECT\n         IHAECVT LIST=YES\n         EJECT\n        PRINT NOGEN\n         IARRCE\n         EJECT\n         IHADFA\n         EJECT\n         IEESMCA\n         EJECT\n         IHAPCCAT\n         EJECT\n         IHAPCCA\n         END   ,                   END OF JESXIT05\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JESX006": {"ttr": 10505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x92\\x14\\x0f\\x00\\x92\\x14\\x0f\\x17\\x11\\x05\\xdc\\x01\\x9b\\x05\\xdc[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1992-05-19T00:00:00", "modifydate": "1992-05-19T17:11:00", "lines": 1500, "newlines": 411, "modlines": 1500, "user": "$WKS"}, "text": "//ASM1      EXEC PGM=IEUASM,PARM='LOAD,NODECK,RENT,TEST'\n//SYSPRINT    DD SYSOUT=*,DCB=BUFNO=1\n//SYSGO       DD DSN=&&A,SPACE=(TRK,(10,10)),DCB=(LRECL=80,\n//             BLKSIZE=800,RECFM=FB),DISP=(,PASS,DELETE),UNIT=SYSDA\n//SYSLIB      DD DSN=SYS1.SMPMTS,DISP=SHR,UNIT=SYSDA,VOL=SER=DIPOSP,\n//             DCB=BLKSIZE=19040\n//            DD DSN=SYS1.SMPSTS,DISP=SHR,UNIT=SYSDA,VOL=SER=DIPOSP\n//            DD DSN=SYS1.HASPSRC,DISP=SHR,UNIT=SYSDA,VOL=SER=DLIB02\n//            DD DSN=SYS1.MACLIB,DISP=SHR\n//            DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1      DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSUT3      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSIN       DD *\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              JESX006                                  *\n*                                                                     *\n*  MODULE TYPE:              JES2 USER EXIT 6                         *\n*                                                                     *\n*  LOAD MODULE NAME:         JESX006                                  *\n*                                                                     *\n*  LOAD LIBRARY:             SYS2.LINKLIB                             *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     RENT                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          RENT,REUS                                *\n*                                                                     *\n*  MODULE AUTHORIZATION:     NONE                                     *\n*                                                                     *\n*  MACROS:                  $SYSMSG, $ENTRY, $MODULE, GETMAIN         *\n*                           FREEMAIN, WTO, $$WTO, LOCATE, $MODEND     *\n*                                                                     *\n*  MACRO LIBRARIES:         SYS1.HASPSRC, SYS1.MACLIB, SYS1.AMODGEN   *\n*                           SYS1.SMPMTS SYS1.SMPSTS                   *\n*                                                                     *\n*  ABENDS:                  NONE                                      *\n*                                                                     *\n*  FUNCTION:                TO PROVIDE JCL STANDARDS ENFORCEMENT      *\n*                                                                     *\n*  PARAMETERS:              REFER: JES2 MODULES AND MACROS            *\n*                                                                     *\n*  INTERNAL TABLES:         A TABLE OF CLASS DEFINITIONS              *\n*                                                                     *\n*  CALLED MODULES:          NONE                                      *\n*                                                                     *\n*  CALLING MODULES:         JES2 HASPCNVT                             *\n*                                                                     *\n*  PROGRAM FLOW:                                                      *\n*                                                                     *\n*                                                                     *\n*  PARAMETER LAYOUTS:       REFER: JES2 MODULES AND MACROES           *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN, INFORMATION SERVICES       *\n*                            (214)-334-2031                           *\n*                            FRITO LAY                                *\n*                            DALLAS, TX                               *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 11/27/85 KIRK STICKEN        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         MACRO                         .\n&LAB     $SYSMSG &M                    .\n         LCLC &MSG                     .\n         GBLB &TIMES                   .\n&MSG     SETC '&M'                     .\n         AIF  (&TIMES).MSG1            .\n&TIMES   SETB 1                        .\n         PUSH PRINT                    .  REMEMBER OUR PRINT STATUS\n         PRINT GEN                     .    AND PRINT THIS FOR HISTORY\n         B    Q&SYSNDX                 .  SKIP PROCESS SUBROUTINE\nPUTMSG   DS   0H                       .  ROUTINE ENTERED TO PUT     XXX\n                                       .  MESSAGE ON JES2 SYSMSGS    XXX\n                                       .  DATASET\n         ST   R14,R14SAVE              .  SAVE HOME BASE\n         LH   R15,0(R1)                .  GET MESSAGE LENGTH\n         A    R15,=F'10'               .  MAKE IT LONGER\n         N    R15,=F'127'              .  BUT NOT TOO LONG\n         ST   R15,MYRPL+RPLRLEN-IFGRPL .  PUT IN RPL\n         BCTR R15,R0                   .  DEC FOR MOVE\n         EX   R15,PUTMVC               .  MOVE MESSAGE INTO AREA\n         MVC  MSG+10(1),$CCOMCHR-HCTDSECT(R11) MOVE IN COMMAND CHAR\n         MVC  MSG(10),=CL10'           ' . CLEAR FIRST TEN SPACES\n         LA   R1,MYRPL                 .  POINT TO RPL\n         PUT  RPL=(1)                  .  AND OUTPUT THE RPL\n         L    R14,R14SAVE              .  SO GO HOME NOW\n         BR   R14                      .  SEE HOW GOOD IT IS\nPUTMVC   MVC  MSG+10(0),2(R1)          .  MOVE IN MSG\n         POP  PRINT                    .  RESTORE PRINT STATUS\nQ&SYSNDX DS   0H                       .  BRANCH POINT FROM PUTMSG\n.MSG1    ANOP                          .\n&LAB     LA    R1,Z&SYSNDX             .  POINT TO MESSAGE LENGTH\n         BAL   R14,PUTMSG              .  BRANCH TO MSG ROUTINE\n         B     N&SYSNDX                .  SKIP OVER MESSAGE\nZ&SYSNDX DC    AL2(L'M&SYSNDX)         .  THE MESSAGE LENGTH\nM&SYSNDX DC    C&MSG                   .   AND THE MESSAGE ITSELF\nN&SYSNDX DS    0H                      .  THE SKIP-AROUND-POINT\n         MEND                          .\n         COPY  $HASPGBL                .  COPY THOSE HASP GLOBALS\nJESX006A $MODULE SYSP=(NOGEN,NOGEN,NODATA,NOGEN,NOGEN),                X\n               TITLE='INFERNAL TEXT PROCESSOR -- REPUBLICBANK DALLAS', X\n               ENVIRON=SUBTASK,                                        X\n               $BUFFER,                .                               X\n               $PCE,                   .  R8                           X\n               $DCT,                   .                               X\n               $PDDB,                  .                               X\n               $HASPEQU,               .                               X\n               $HCT,                   .  R11                          X\n               KEYS,                   .                               X\n               TEXT,                   .                               X\n               $JCT,                   .  R10                          X\n               $JQE,                   .                               X\n               $MIT,                   .                               X\n               $CNVWORK,               .                               X\n               UCB,                    .                               X\n               CVT,                    .                               X\n               DEB,                    .                               X\n               $CAT,                   .                               X\n               WPL,                    .                               X\n               NEL,                    .                               X\n               RPL                     .\nSUBPOOL  EQU   00                      .  GETMAIN SUBPOOL\nEX000    EQU   B'10000000'             .  EXIT BITS FOR JCTXMASK\nEX001    EQU   B'01000000'             .    THESE CAN TURN\nEX002    EQU   B'00100000'             .      ON OR OFF\nEX003    EQU   B'00010000'             .        A PARTICULAR EXITS\nEX004    EQU   B'00001000'             .         INVOCATION\nEX005    EQU   B'00000100'             .          STATUS\nEX006    EQU   B'00000010'             .\nEX007    EQU   B'00000001'             .\n         DROP  R13                     .  DO NOT USE R13 FOR PCE\n         USING PCEDSECT,R8             .  HERE WE USE R8 FOR PCE\nJESX006  $ENTRY CSECT=YES,BASE=(R9,R12) . BEGIN EXIT ROUTINE\n         STM   R14,R12,12(R13)         .  SAVE ENTRY REGISTERS\n         LR    R9,R15                  .  APPLY BASE FOR PROGRAM\n         LA    R12,4095(R9)            .    AND THE\n         LA    R12,1(R12)              .      OVERFLOW BASE TOO\n         TM    JCTJOBFL,JCTBATCH       .  IS THIS BATCH?\n         BNO   RNOMEM4                 .    NO, NEVER COME BACK HERE\n         USING TEXT,R7                 .  APPLY BASE FOR TEXT AREA\n         L     R7,4(R1)                .  GET PASSED PARMS\n         L     R6,PCEUSER0             .  IS PTR TO WORK AREA SET?\n         LTR   R6,R6                   .       WELL, IS IT?\n         BNZ   BEGIN                   .     YES, GO WORK ON IT\nUINIT    DS    0H                      .     NO , INIT WORK AREAS\n         LR    R3,R0                   .  SAVE R0\n         LR    R4,R1                   .   AND R1\n         L     R2,GETSIZE              .  PREPARE FOR GETMAIN\n         GETMAIN RC,LV=(2)             .  GET WORKING STORAGE\n         LTR   R15,R15                 .  CHECK GETMAIN\n         BNZ   RNOMEM1                 .  ERROR NO MEMORY AVAILABLE !\n         LR    R6,R1                   .  SAVE GETMAIN ADDRESS\n         LR    R14,R1                  .  CLEAR\n         L     R15,GETSIZE             .    WORKING\n         LR    R0,R14                  .       STORAGE\n         SR    R1,R1                   .          AREA\n         MVCL  R14,R0                  .            NOW\n         ST    R6,PCEUSER0             .  SAVE MEMORY POINTER\n         OI    FLAGS-SAVE(R6),MGOT     .  SET MEMORY GOTTEN FLAG\n         MVC   WORKINST-SAVE(L'INSTSHEL,R6),INSTSHEL . INIT SHEL INSTR\n         LA    R14,68                  .  INIT\n         SLL   R14,24                  .    THE\n         ST    R14,CAMLOC-WORK(R6)     .     LOCATE\n         LA    R14,DSN-WORK(R6)        .       DATA\n         ST    R14,CAMLOC-WORK+4(R6)   .         AREA\n         LA    R14,CAMRET-WORK(R6)     .             |\n         ST    R14,CAMLOC-WORK+12(R6)  .             |\n         SLR   R14,R14                 .             |\n         ST    R14,CAMLOC-WORK+8(R6)   .             |\n         PUSH  USING                   .\n         USING WORK,R6                 .  TEMPORARY BASE FOR WORK\n         LA    R2,JPCEMSG              .  GET PCE SYSMSG ACB\n         LA    R15,MSG                 .  GET PCE SYSMSG ACB\n         MVI   MYRPL-IFGRPL+RPLREQ,RPLPUT . THIS IS A PUT\n         ST    R2,MYRPL-IFGRPL+RPLDACB .  SAVE ACB INTO RPL HERE\n         ST    R15,MYRPL-IFGRPL+RPLAREA . SAVE MSG ADDRESS IN RPL HERE\n         MVI   MYRPL-IFGRPL+RPLOPT1,RPLSEQ . THIS IS SEQUENTIAL PUT\n         LA    R15,L'MSG               .\n         ST    R15,MYRPL-IFGRPL+RPLRLEN . SAVE MSG LENGTH IN RPL HERE\n         POP   USING                   .\n         LR    R0,R3                   .  RESET\n         LR    R1,R4                   .    PARM REGISTERS\nBEGIN    DS    0H                      .\n         USING WORK,R13                .  ADDRESS GETMAINED AREA\n         ST    R6,8(R13)               .  STORE OURS THERE\n         ST    R13,4(R6)               .  STORE THEIRS HERE\n         LR    R13,R6                  .  RESET SAVE AREA POINTER\n         LR    R15,R0                  .  GET ENTRY CODE FOR INDEX FUNC\n         N     R15,=F'15'              .  USE ONLY LAST 4 BITS OF CODE\n         B     FUNCTION(R15)           .  INDEX TO FUNCTION CODE\nINSTSHEL LA    R15,0(R0,R9)            .  SHELL INSTRUCTION\nFUNCTION B     DOTEXT                  .  PROCESS TEXT RECORD\n         B     DOLAST                  .  PROCESS LAST CALL\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*   DOTEXT DETERMINES THE TYPE OF TEXT RECORD PASSED, AND GOES TO    *\n*   PROCESSING ROUTINES TO HANDLE THE TEXT RECORD                    *\n*                                                                    *\n**********************************************************************\nDOTEXT   DS    0H                      .  ANOTHER IMPASS, YES?\n         LA    R5,JOBTABLE             .  GET THE TAB OF \"S\" TYPE ADDRS\n         SLR   R15,R15                 .  CLEAR FOR NEXT IC\n         IC    R15,STRINDCS            .  GET RECORD TYPE\n         N     R15,=F'15'              .    USE LAST 4 BITS\n         SLA   R15,2                   .      TIMES 4\n         B     TXTTYPE(R15)            .         INDEX TO TXT TYPE\nTXTTYPE  B     RETURN                  .  00 - TYPE 0 - UNUSED\n         B     DOJOB                   .  04 - TYPE 1 - JOB STATEMENT\n         B     DOEXEC                  .  08 - TYPE 2 - EXEC STMT\n         B     RETURN                  .  12 - TYPE 3 - UNUSED\n         B     DODD                    .  16 - TYPE 4 - DD STMT\n         B     RETURN                  .  20 - TYPE 5 - UNUSED\n         B     RETURN                  .  24 - TYPE 6 - UNUSED\n         B     RETURN                  .  28 - TYPE 7 - UNUSED\n         B     DOPROC                  .  32 - TYPE 8 - PROC STMT\n         B     RETURN                  .  36 - TYPE 9 - UNUSED\n         B     RETURN                  .  40 - TYPE A - UNUSED\n         B     RETURN                  .  44 - TYPE B - UNUSED\n         B     RETURN                  .  48 - TYPE C - UNUSED\n         B     RETURN                  .  52 - TYPE D - UNUSED\n         B     RETURN                  .  56 - TYPE E - UNUSED\n         B     RETURN                  .  60 - TYPE F - UNUSED\n         B     RETURN                  .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  DOLAST IS THE FINAL STEP IN THE JOBS JCL.  ALL JCL IS CONVERTED   *\n*  AND JES CALLS US WITH THE LAST CALL INDICATOR SET.                *\n*                                                                    *\n*  AT THIS POINT WE LOOK AT THE BIT SETTINGS LEFT BY SCANNING THE    *\n*  JCL FOR THE JOB. IF ANY ARE SET THAT WE DONT LIKE (IE:TIME=1440)  *\n*  WE CAN SET THE ERROR FLAG ON AND CANCEL THE JOB WITH A MESSAGE.   *\n*                                                                    *\n**********************************************************************\nDOLAST   DS    0H                      .  NOW WE CAN DECIDE TO KILL 'EM\n         OI    FLAGS,LASTCALL          .  SET LAST CALL FLAG\n         L     R15,JTAPE               .  GET JOB TAPE COUNT\n         A     R15,STAPE               .     ADD STEP TAPE COUNT\n         ST    R15,JTAPE               .         AND SAVE\n         L     R15,STAPEM              .  CHECK STEP TAPE MAX\n         C     R15,STAPE               .    AGAINST CURRENT STEP TAPES\n         BNL   OKSTAPEM                .       IF NOT HIGHEST JUST SKIP\n         L     R15,STAPE               .          OTHERWISE SAVE FOR\n         ST    R15,STAPEM              .             LATER DECISIONS\nOKSTAPEM DS    0H                      .  OH BOY\n         PUSH  USING                   .\n         USING CLASSD,R3               .  LOCATE CLASS DEFINITIONS\n         L     R3,CLASSPTR             .    IF NOT FOUND JUST GO\n         LTR   R3,R3                   .       AND BYPASS THIS HOOEY\n         BZ    OKTIME2                 .\n         TM    FLAGS1,TESTBTCH         .  IS THIS TEST BATCH\n         BNO   NOTSTB1                 .     NOT TEST BATCH\n         TM    FLAGS2,JCARD            .  DID USER HARD CODE CLASS?\n         BO    NOTSTB1                 .    YES, SKIP FINAL OVERRIDE\nCLOOP1   DS    0H                      .\n         CLC   MAXTIME,CJOBTIME        .  IS TIME OK FOR CLASS\n         BNH   CKTP1                   .    YES, GO CHECK STEP TAPES\n         CLI   CID,C'*'                .  IS THIS SILLY? CL NOT FOUND\n         BE    SILLY1                  .    YES, VERY. JUST IGNORE ME\n         LA    R3,CENTL(R3)            .  SKIP TO NEXT TABLE ENTRY\n         B     CLOOP1                  .      AND LOOP YOUR BUNS OFF\nCKTP1    CLC   STAPEM,CSTEPTP          .  IS STEP TAPE MAX OK FOR CLASS\n         BNH   CKTP2                   .     YES, CHECK JOB TAPE MAX\n         CLI   CID,C'*'                .  IS THIS SILLY AGAIN?\n         BE    SILLY1                  .     WHAT A BOONDOGGLE,GET HOME\n         LA    R3,CENTL(R3)            .  SKIP TO NEXT TABLE ENTRY\n         B     CLOOP1                  .      AND TRY IT FROM THE TOP\nCKTP2    CLC   JTAPE,CJOBTP            .  IS JOB  TAPE MAX OK FOR CLASS\n         BNH   RECATC                  .    YES, RECATALOG THIS CLASS\n         CLI   CID,C'*'                .  IS THIS SILLY TOO MUCH??\n         BE    SILLY1                  .    WHY DO I LIKE THIS SO MUCH?\n         LA    R3,CENTL(R3)            .  ONCE AGAIN INTO THE BREACH\n         B     CLOOP1                  .   DEER FIENDS\nRECATC   DS    0H                      .  CLASS NEEDS TO BE SET AGAIN\n         CLI   CID,C'*'                .  IS THIS SILLY? CL NOT FOUND\n         BE    SILLY1                  .    YES, VERY. JUST IGNORE ME\n         CLC   CDTIME,=F'0'            .  IS THIS CLASS DEFAULTABLE\n         BNE   RECATC1                 .     NO, BUT WHO CARES ANYWAY\n         LA    R3,CENTL(R3)            .\n         B     CLOOP1                  .\nRECATC1  DS    0H                      .\n         CLC   CID,CLASS               .    BUT DID IT REALLY CHANGE?\n         BE    NOTSTB1                 .       OF COURSE NOT, FOOL\n         ST    R3,CLASSPTR             .  REMEMBER THE NEW JOB CLASS\n         MVC   CLASS,CID               .    AND PUT THE NEW CLASS\n         MVC   JCTJCLAS,CLASS          .      INTO THE JES2 CONTROL\n         MVC   JCTCLASS,CLASS          .        BLOCKS THAT HE\n         L     R14,PCEJQE              .           WANTS THEM\n         MVC   JQEJCLAS-JQEDSECT(1,R14),CLASS         IN\n         B     NOTSTB1                 .  BYPASS ALL SILLINESS\nSILLY1   DS    0H                      .  OH BOY\n         OI    FLAGS1,ERROR            .  JOB NOT FIT CLASS STRUCTURE\n        $SYSMSG '$HASP920 (E6) TEST BATCH JOB DOES NOT FIT CLASS STRUCTU\n               URE'                    .\n         L     R3,CLASSPTR             .  RESET THE CLASS DEFF POINTER\nNOTSTB1  DS    0H                      .  OH BOY\n         CLC   CJOBTIME,MAXTIME        .  DID USER WANT TOO MUCH TIME\n         BNL   CKTAPE                  .  NO, GO CHECK TAPE SITU.\n         OI    FLAGS1,ERROR            .  WEE GWANG KILLEM NOW!\n        $SYSMSG '$HASP920 (E6) JOB MAXIMUM CPU TIME INVALID FOR CLASS'\nCKTAPE   DS    0H                      .  OH BOY\n         CLC   CSTEPTP,STAPEM          .  WHAT IS STEP TAPE MAX\n         BNL   OKSTAPE                 .    STEP MAX OK FOR CLASS\n         TM    FLAGS2,STAPEE           .  DID USER SEE THIS MSG YET?\n         BO    OKSTAPE                 .     WHY YES, DONT MAKE IT MAD\n         OI    FLAGS2,STAPEE           .     WHY NO, SET BIT TO REMEMBR\n         OI    FLAGS1,ERROR            .  I LOVE A GOOD ERROR.\n        $SYSMSG '$HASP920 (E6) STEP TAPE LIMIT EXCEEDED'\nOKSTAPE  DS    0H                      .  OH BOY\n         CLC   CJOBTP,JTAPE            .  IS JOB TAPE LIMIT OK\n         BNL   OKJTAPE                 .    WHY CANT I EVER BE HAPPY\n         TM    FLAGS2,JTAPEE           .  HAS USER SEEN THIS ALREADY?\n         BO    OKJTAPE                 .     SHUCKY DARNS\n         OI    FLAGS2,JTAPEE           .     OH GOODY\n         OI    FLAGS1,ERROR            .  BYTE THIS ONE!\n        $SYSMSG '$HASP920 (E6) JOB TAPE LIMIT EXCEEDED'\nOKJTAPE  DS    0H                      .\nOKTIME2  DS    0H                      .  NOW PUT OUT A MESSAGE\n*                                      .     SAYING WHAT A NICE BOY\n*                                      .     THE USER IS AND HOW WE\n*                                      .     LIKE HIM AND ALL OF HIS\n*                                      .     RELATIVES. ALSO TELL HIM\n*                                      .     WHY WE ARE CANCELLING HIM\n*                                      .     AND  TELL HIM WHAT THE\n*                                      .     EXIT THINKS HE IS USING.\n         MVC   MSGX+2(L'STATMSG),STATMSG . INIT FOR STATS MESSAGE\n         MVC   MSGX+2+STATC-STATMSG(L'STATC),CLASS . INIT CLASS\n         L     R14,MAXTIME             .\n         CVD   R14,DWORK               .\n         UNPK  MSGX+2+STATT-STATMSG(L'STATT),DWORK . INIT TIME\n         OI    MSGX+2+STATT-STATMSG+L'STATT-1,X'F0'  CLEAR SIGN\n         L     R14,STAPEM              .\n         CVD   R14,DWORK               .\n         UNPK  MSGX+2+STATS-STATMSG(L'STATS),DWORK . INIT STAPES\n         OI    MSGX+2+STATS-STATMSG+L'STATS-1,X'F0'  CLEAR SIGN\n         L     R14,JTAPE               .\n         CVD   R14,DWORK               .\n         UNPK  MSGX+2+STATJ-STATMSG(L'STATJ),DWORK . INIT JTAPES\n         OI    MSGX+2+STATJ-STATMSG+L'STATJ-1,X'F0'  CLEAR SIGN\n         L     R14,REGIONJ             .\n         CVD   R14,DWORK               .\n         UNPK  MSGX+2+STATR-STATMSG(L'STATR),DWORK . INIT JREGION\n         OI    MSGX+2+STATR-STATMSG+L'STATR-1,X'F0'  CLEAR SIGN\n         LA    R14,L'STATMSG           .  GET MESSAGE LENGTH FOR PUT\n         STCM  R14,B'0011',MSGX        .     PUT  IN CORRECT PLACE\n         LA    R1,MSGX                 .  GET THE MESSAGE\n         BAL   R14,PUTMSG              .    AND GO PUT THE MESSAGE OUT\n         TM    FLAGS1,ERROR            .  HAS AN ERROR BEEN ENCOUNTERED\n         BNO   RETURN                  .\n************\n************\n************     BYPASS CANCEL FOR TESTING PURPOSES\n************\n************\n************\n*       $SYSMSG '$HASP920 (E6) BATCH JOB WILL BE CANCELLED WHEN USER EXI\n               IT TRIAL PERIOD EXPIRES'\n        $SYSMSG '$HASP920 (E6) BATCH JOB HAS BEEN CANCELLED BY JES2 USEC\n               R EXIT 6'\n         MVC   RC,=H'8'                .  GIVE THE JOB A JCL ERROR\n         LA    R1,MSG                  .    AND PUT A MESSAGE ON\n         MVC   MSG(MSG1L),MSG1         .      THE JES2 LOG FOR ALL\n       $$WTO   (R1)                    .        TO SEE.\n         B     RETURN                  .\n         POP   USING                   .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n* DOJOB, DOEXEC, DODD, AND DOPROC ARE THE MAJOR ENTRYS FOR SCANNING  *\n* THE JOBS JCL TEXT. A BIT IS SET TO REMEMBER THE TEXT TYPE, SOME    *\n* INITIALIZATION IS DONE, AND DOKEY IS ENTERED TO LOCATE THE         *\n* TEXT KEY PROCESSOR ROUTINE.                                        *\n*                                                                    *\n**********************************************************************\n         USING JUMPTAB,R5              .  ADDRESS BRANCH TABLE\n         USING USERTEXT,R4             .  ADDRESS TEXT KEY PTRS\nDOJOB    DS    0H                      .\n         LA    R4,STRJKEY              .  REFERENCE FIRST JOB KEY\n         ST    R4,CURPTR               .  SAVE CURRENT KEY POINTER\n         OI    FLAGS,JOBU              .  REMEMBER THIS IS JOB TEXT\n         OI    FLAGS1,JOBCARD          .  AND REMEMBER JOB CARD FOUND\n         B     DOKEY                   .  GO PROCESS ALL KEYS\nDOEXEC   DS    0H                      .\n         LA    R4,STREKEY              .  REFERENCE FIRST EXEC KEY\n         ST    R4,CURPTR               .  SAVE CURRENT KEY POINTER\n         OI    FLAGS,EXECU             .  REMEMBER THIS IS EXEC TEXT\n         L     R15,JTAPE               .  ADD STEP TAPES\n         A     R15,STAPE               .    TO JOB TAPES TO GET A\n         ST    R15,JTAPE               .      RUNNING JOB TAPE TOTAL.\n         L     R15,STAPEM              .  FIND STEP TAPE\n         C     R15,STAPE               .    MAX AS AN ONGOING\n         BNL   OKSTM1                  .      PROCESS\n         L     R15,STAPE               .  SAVE STEP TAPE MAX\n         ST    R15,STAPEM              .    FOR LATER CHECKING\nOKSTM1   DS    0H                      .\n         SLR   R15,R15                 .  CLEAR FOR COUNTING\n         ST    R15,STAPE               .     STEP TAPES.\n         B     DOKEY                   .  GO PROCESS ALL EXEC KEYS\nDODD     DS    0H                      .\n         TM    STRDINDC,DTXSYSIN+DTXSYOUT+DTXSUBSK                   XXX\n                                       .  IS THIS DD CARD A SYSOUT     X\n                                       .  OR A SUBSYSTEM REQUEST?\n         BM    RETURN                  .     YES, DO NOT PROCESS\n         XC    UNITSW,UNITSW           .  CLEAR UNIT BIT SETTINGS\n         XC    CAMDEVB3,CAMDEVB3       .  CLEAR CATALOG BITS FOR TAPE\n         NI    FLAGS3,255-DSNS2        .  CLEAR DSN BITS\n         MVI   DSN,C' '                .  CLEAR OUT THE ENTIRE\n         MVC   DSN+1(L'DSN-1),DSN      .     DATASET NAME AREA\n         LA    R4,STRDKEY              .  REFERENCE FIRST DD KEY\n         ST    R4,CURPTR               .  SAVE CURRENT KEY POINTER\n         OI    FLAGS,DDU               .  REMEMBER THIS IS DD CARD\n         B     DOKEY                   .  GO PROCESS ALL DD KEYS\nDOPROC   DS    0H                      .\n         LA    R4,STREKEY              .  REFERENCE FIRST PROC KEY\n         ST    R4,CURPTR               .  SAVE CURRENT KEY POINTER\n         OI    FLAGS,PROCU             .  REMEMBER THIS IS A PROC\nDOKEY    DS    0H                      .  ****** OH BOY ********\n         L     R4,CURPTR               .  MAKE SURE POINT TO TEXT\n         SLR   R15,R15                 .  CLEAR FOR INDEX LOAD\n         IC    R15,USERKEY             .  GET KEY TO INDEX WITH\n         SLA   R15,1                   .  TIMES 2 = INDEX TO TABLE\n         LA    R15,JUMP(R15)           .  PULL IN JUMP TABLE ENTRY\n         MVC   WORKINST+2(2),0(R15)    .  BUILD VALID \"LA\" INSTRUCTION\n         SLR   R14,R14                 .  SET LENGTH TO 0 FOR EXECUTE\n         EX    R14,WORKINST            .  LA R15,XXX(9) GET ADDRESS\n         BALR  R14,R15                 .  CALL FUNCTION\n         B     SKIPKEY                 .  SKIP KEY JUST PROCESSED\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  LASTKEY IS INVOKED WHEN THE \"END-OF-TEXT\" TEXT KEY FOR A SINGLE   *\n*  JCL RECORD IS ENCOUNTERED. (IE: END OF JCL RECORD).               *\n*  BRANCH TO CLEANUP ROUTINES BASED ON TEXT UNIT TYPE.               *\n*                                                                    *\n**********************************************************************\nLASTKEY  DS    0H                      .\n         TM    FLAGS,DDU               .  DITTO FOR THIS DD CARD?\n         BO    CHECKDD                 .    YESUM, GETUM CLEANED\n         TM    FLAGS,EXECU             .  IS THIS EXEC CARD DONE NOW\n         BO    CHECKEX                 .    YES, GO CLEAN UP WHATEVER\n         TM    FLAGS,PROCU             .  AND HOW ABOUT PROCS TODAY?\n         BO    CHECKPR                 .    TSK TSK...DIRTY PROCS!\n         TM    FLAGS,JOBU              .  IS THIS JOB CARD DONE NOW\n         BO    CHECKJOB                .    YES, CHECK THE JOB PARMS\n         B     RETURN                  .  TEXT RCD DONE, GET SOME MORE\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n* JOB CARD JCL WAS JUST PROCESSED.                                   *\n*                                                                    *\n* IF JOB CLASS WAS NOT SPECIFIED DEFAULT CLASS BASED ON JOB TIME.    *\n* IF CLASS AND TIME ARE NOT SPECIFIED USED DEFAULT CLASS FROM        *\n*     READER.                                                        *\n* IF TIME IS NOT SPECIFIED, DEFAULT THE TIME BASED ON JOB CLASS.     *\n*                                                                    *\n* CHECK JOB FLAGS SET DURING SCAN TO SEE IF USER TRYED TO USE        *\n*    JCL KEYWORDS WE DONT WANT THEM TO USE IN RBD                    *\n*       THINGS LIKE ADRSP=REAL ETC ARE FROWNED UPON.                 *\n*                                                                    *\n**********************************************************************\n         PUSH  USING                   .\nCHECKJOB DS    0H                      .  REMEMBER JOBCARD ENCOUNTERED\n         LA    R3,CLASSTAB             .  GET CLASS TABLE\n         USING CLASSD,R3               .    REFERENCE BY NAME\n         CLI   CLASS,C'A'              .  IS CLASS SET\n         BL    N1                      .     NO, GO CHECK TIME\n         CLC   MAXTIME,=F'0'           .  IS TIME AND CLASS SET\n         BE    DEFTIME                 .     NO, GO DEFAULT TIME\nVALTIME  DS    0H                      .  VALIDATE TIME FOR CLASS\n         BALR  R15,R0                  .  SET LOOP BACK ADDRESS\n         CLI   CID,C'*'                .  IS END OF TABLE?\n         BE    NOCLASS                 .     YES, INVALID CLASS ON JOB\n         CLC   CID,CLASS               .  IS CLASS FOUND?\n         BE    CFND1                   .     YES, USE FOR CHECK\n         LA    R3,CENTL(R3)            .  GET NEXT CLASS ENTRY\n         BR    R15                     .  LOOP BACK\nCFND1    DS    0H                      .  CLASS AND TIME EXIST\n         CLC   CJOBTIME,MAXTIME        .  DOES CLASS TIME FIT JOB TIME\n         BNL   OKTIME1                 .  TIME IS OK\n         OI    FLAGS1,ERROR            .  AGAIN TO CANCEL OR NOT?\n        $SYSMSG '$HASP920 (E6) TIME IS INCORRECT FOR JOB CLASS'\n         B     OKTIME1                 .\nDEFTIME  DS    0H                      .  DEFAULT TIME TO CLASS MAX\n         BALR  R15,R0                  .  SET LOOP BACK ADDRESS\n         CLI   CID,C'*'                .  IS END OF TABLE?\n         BE    NOCLASS                 .     YES, INVALID CLASS ON JOB\n         CLC   CID,CLASS               .  IS CLASS FOUND?\n         BE    CFND2                   .     YES, USE FOR CHECK\n         LA    R3,CENTL(R3)            .  GET NEXT CLASS ENTRY\n         BR    R15                     .  LOOP BACK\nNOCLASS  DS    0H                      .\n*        OI    FLAGS1,ERROR            .\n*       $SYSMSG '$HASP920 (E6) JOB IS USING INVALID CLASS'\n         B     OKTIME1                 .\nCFND2    DS    0H                      .  CLASS WAS FOUND IN TABLE\n         CLC   CDTIME,=F'0'            .  IS DEFAULT TIME THERE\n         BE    OKTIME1                 .   NO, CANNOT DEFAULT TIME\n         OI    FLAGS3,TIMEDEF          .  REMEMBER TIME DEFAULTED\n         MVC   MAXTIME,CDTIME          .  REMEMBER DEFAULT TIME\n         MVC   DF1(3),=AL1(TIMEJK,2,4) .  SET UP TEXT KEYS FOR TIME\n         MVI   DF2,2                   .     DEFAULT\n         MVI   DF3,ENDK                .  MOVE IN END OF TEXT KEY\n         L     R14,MAXTIME             .  GET TIME TO DEFAULT\n         SRDA  R14,32                  .  SHIFT FOR DIVIDE\n         D     R14,=F'60'              .  14=SEC, 15=MIN\n         CVD   R14,DWORK               .  MAKE SECONDS BCD NUMERIC\n         UNPK  DSEC,DWORK              .    AND PUT\n         OI    DSEC+L'DSEC-1,X'F0'     .       INTO DEFAULT KEY AREA\n         CVD   R15,DWORK               .  MAKE MINUTES BCD NUMERIC\n         UNPK  DMIN,DWORK              .    AND PUT\n         OI    DMIN+L'DMIN-1,X'F0'     .       INTO DEFAULT KEY AREA\n         MVC   USERKEY(L'DF),DF        .  MOVE ENTIRE DEFAULT TIME TO\n         LH    R15,STRLTH              .    TEXT KEY AREA AND UPDATE\n         LA    R15,L'DF-1(R15)         .      THE LENGTH FIELDS\n         STH   R15,STRLTH              .         SO JES2 IS HAPPY\n         B     OKTIME1                 .\nN1       DS    0H                      .  CLASS WAS NOT SET,\n         CLC   MAXTIME,=F'0'           .    BUT IS TIME?\n         BE    N1N2                    .      NO CLASS AND TIME NOT SET\nDEFCLASS DS    0H                      .  PICK CLASS BASED ON TIME\n         BALR  R15,R0                  .  SET LOOP BACK ADDRESS\n         CLI   CID,C'*'                .  IS END OF TABLE?\n         BE    CFND3                   .     YES, USE LAST AS DEFAULT\n         CLC   CDTIME,=F'0'            .  IS CLASS DEFAULTABLE?\n         BE    SKIPD2                  .     NO, SKIP IT\n         CLC   CJOBTIME,MAXTIME        .  IS TIME A MATCH\n         BNL   CFND3                   .     YES, USE FOR CHECK\nSKIPD2   LA    R3,CENTL(R3)            .  GET NEXT CLASS ENTRY\n         BR    R15                     .  LOOP BACK\nCFND3    DS    0H                      .  TIME FOUND IN CLASS TABLE\n         MVC   CLASS,CID               .  MOVE IN CLASS ID\n         CLI   CLASS,C'*'              .  IS THIS  A VALID CLASS\n         BNE   TRULAST                 .     YES, DO NOT RESET TO 0\n         MVI   CLASS,C'0'              .  NOT VALID CLASS, RESET TO 0\nTRULAST  DS    0H                      .\n         MVC   JCTJCLAS,CLASS          .  MOVE CLASS TO JES2\n         MVC   JCTCLASS,CLASS          .     PLACES THAT ARE FUN\n         L     R14,PCEJQE              .       PLACES TO LIVE\n         MVC   JQEJCLAS-JQEDSECT(L'JQEJCLAS,R14),CLASS  ALSO INTO JQE\n         MVI   USERKEY,CLASSJK         .  BUILD CLASS= KEYS IN TEXT\n         MVI   USER#,1                 .    AREA AND\n         MVI   USERL1,1                .       MOVE IN ALL DATA\n         MVC   USERTXT(L'CLASS),CLASS  .         SO THAT JES KNOWS\n         MVI   USERTXT+L'CLASS,ENDK    .            THAT I WROTE THIS\n         LH    R15,STRLTH              .  UPDATE TEXT RCD LENGTH\n         LA    R15,L'CLASS+3(R15)      .    WITH LENGTH OF JOB CLASS=\n         STH   R15,STRLTH              .      TEXT KEYS\n         B     OKTIME1                 .  GO CHECK OTHER STUFF.\nN1N2     DS    0H                      .  CLASS AND TIME NOT SET, DEFLT\n         MVC   CLASS,JCTJCLAS          .  GET CLASS FROM JES2 DFLTS\n         CLI   CLASS,C'A'              .  IS IT VALID CLASS\n         BNL   CHECKJOB                .    YES, GO CHECK AGAIN\n         MVI   CLASS,C'0'              .  NOT VALID SOMEHOW, SET TO 0\n         B     CHECKJOB                .     AND CHECK AGAIN\nOKTIME1  DS    0H                      .\n         ST    R3,CLASSPTR             .  SAVE CLASS TABLE POINTER\n         CLC   =C'DP',USER             .  IS USER SPECIAL?\n         BE    SPECUS1                 .  COULD BE\n         CLC   =C'DS',USER             .  OR IS IT PC\n         BE    SPECUS1                 .  MIGHT BE\n         CLC   =C'RDPP ',USER          .  OR IS IT GOD\n         BE    SPECUSER                .  YES INDEED\n         B     NOTSPEC                 .  USER IS NOT SPECIAL\nSPECUS1  DS    0H                      .\n         TRT   USER+3(1),TRTNUM        .  IS THIRD POS NUMBER (DP0...)\n         BZ    NOTSPEC                 .  USER IS NOT SPECIAL\nSPECUSER DS    0H                      .\n         OI    FLAGS2,SPUSER           .  USER IS SPECIAL\nNOTSPEC  DS    0H                      .\n         CLI   CBATCH,C'C'             .  IS CLASS PRIVILEDGED?\n         BNE   OKCLASSX                .     NO, CHECK NEXT GIZMO\n         TM    FLAGS2,SPUSER           .  IS USER SPECIAL?\n         BO    OKCLASSX                .  USER IS ALLOWED TO USE CLASS\n*        OI    FLAGS1,ERROR            .  AAAHHHHH!!! WHAT A JOY!!\n*       $SYSMSG '$HASP920 (E6) USER CANNOT USE PRIVLEDGED JOB CLASS'\nOKCLASSX DS    0H                      .\n         CLI   CLASS,C'0'              .  IS THIS TEST BATCH?\n         BL    RETURN                  .     NO, SKIP TESTS\n         OI    FLAGS1,TESTBTCH         .  REMEMBER THIS IS TEST BATCH\nOKRGN1   DS    0H                      .\n         TM    FLAGS1,REALMEM          .  IS IT TEST ADDRSP=REAL?\n         BNO   NOREAL                  .     NO, CONTINUE\n         OI    FLAGS1,ERROR            .    YES, CANCEL JOB\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE ADDRSP=REAL'\nNOREAL   DS    0H                      .  IS IT TEST REGION=XXXK\n         L     R14,REGIONJ             .  GET REGION FROM JOB\n         C     R14,=F'500'             .  CHECK AGAINST CONVTR PARMS\n         BNH   NORGN                   .     NO, REGION OK\n         OI    FLAGS1,ERROR            .    YES, CANCEL JOB\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE REGION= ON JOB CARC\n               D'                      .\nNORGN    TM    FLAGS1,JOBHOLD          .  IS IT TEST TYPRUN=HOLD\n         BNO   NOHOLD                  .     NO, CONTINUE\n         OI    FLAGS1,ERROR            .    YES, SET CANCEL JOB FLAG\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE TYPRUN=HOLD ON JOBC\n               CARD'\nNOHOLD   L     R15,MAXTIME             .  GET JOB TIME REQUESTED\n         C     R15,=F'86400'           .  IS IT TIME=1440 ON JOB CARD?\n         BL    NOTIME                  .     NO, TIME OK SO FAR\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE TIME=1440 ON JOB  C\n               CARD'                   .\n         OI    FLAGS1,ERROR            .    YES, TIME IS INVALID\nNOTIME   DS    0H                      .\n         TM    FLAGS3,PERFJ            .  IS PERFORM= ON JOB CARD\n         BNO   NOPERFJ                 .     NO, PERFORM IS NOT THERE\n*        OI    FLAGS1,ERROR            .    YES, NOW SHOWEM WHO IS BOSS\n*       $SYSMSG '$HASP920 (E6) JOB CANNOT USE PERFORM ON JOB CARD'\nNOPERFJ  DS    0H                      .\n*        LH    R15,USERLEN             .  DOES JOB NAME START WITH\n*        N     R15,=F'15'              .    USER ID.?\n*        BCTR  R15,R0                  .\n*        EX    R15,USERCLC             .  THIS WILL TELL ME NOW\n*        BE    OKTIMEQ                 .    USER IS OK, CONTINUE\n*       $SYSMSG '$HASP920 (E6) JOB MUST CONTAIN USERID IN JOBNAME'\n*        OI    FLAGS1,ERROR            .    USER IS AFU, TELL HIM SO\nOKTIMEQ  DS    0H                      .\n         TM    FLAGS3,TIMEDEF          .  HAS TIME ALREADY DEFAULTED\n         BO    RETURN                  .     YES, DO NOT DEFAULT AGAIN\n         BAL   R14,OVERTIME            .  OVERRIDE JOB CARD TIME\n        $SYSMSG '$HASP920 (E6) JOB TIME LIMIT SET TO \"TIME=(,1)\"'\n         B     RETURN                  .  ALL DONE WITH JOB CARD\n*USERCLC CLC   USER(0),JOB             .\n         POP   USING                   .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  A DD CARD WAS JUST PROCESSED.                                     *\n*                                                                    *\n*  CHECK TO SEE IF CATALOG NEEDS TO BE READ TO COUNT TAPES.          *\n*  IF SO, GO READ CATALOG AND COUNT TAPES.                           *\n*                                                                    *\n*  DSN=XX.YY(ZZ) WHERE ZZ CAN BE ANYTHING CAUSES ONLY 1 CAT READ.    *\n*  DSN=XX.YY     CAUSES UP TO 2 CATALOG READS, ONCE FOR XX.YY        *\n*                AND ONCE FOR XX.YY(0) IF XX.YY NOT CATALOGED.       *\n*                                                                    *\n*                                                                    *\n**********************************************************************\nCHECKDD  DS    0H\n         TM    FLAGS1,TESTBTCH         .  IS THIS JOB TEST BATCH\n         BNO   RETURN                  .    NO, DO NOT DO FOR PROD\n         TM    UNITSW,UNITAFF+VOLREF   .  DID USER HAVE A UNIT=AFF\n         BM    RETURN                  .    YES, NOT A TAPE\n         CLC   =C'NULLFILE ',DSN       .  IS THIS A DUMMY DSN\n         BE    RETURN                  .    YES, DO NOT READ THE CAT\n**********************************************************************\n*                                                                    *\n*                      CHECK THE UNIT AND VOLSER SPECS.              *\n*                      DECIDE WHETHER TO READ CATALOG OR NOT.        *\n*                                                                    *\n**********************************************************************\n         TM    UNITSW,VOLSPEC+VOLTAPE  .  DID USER PUT VOL=SER=XXX IN? X\n                                       .     WITH A VOLSER THAT IS TAPE\n         BO    KEEPTAPE                .  YES, GO COUNT A TAPE HAHA..\n         TM    UNITSW,VOLSPEC          .  DID USER SAY VOL=SER=XXX     X\n                                       .    AND NOT SAY TAPE VOLSER\n         BO    RETURN                  .\n         TM    UNITSW,TAPEUNIT+DISPNEW .  IS IT A NEW TAPE?\n         BO    KEEPTAPE                .    YES, GO COUNT A TAPE\n         TM    UNITSW,UNITXIST+DISPNEW .  IS IT A NEW ANYTHING\n         BO    RETURN                  .    YES, NOT A TAPE, GET OUT\n**********************************************************************\n*                                                                    *\n*                      I CANT DECIDE IF TAPE OR NOT FROM JCL,        *\n*                      I MIGHT WANT TO READ THE CATALOG IF THE       *\n*                      DSN IS NOT A TEMP.                            *\n*                                                                    *\n**********************************************************************\nLOCATEIT DS    0H                      .\n         CLI   DSN,C'&&'               .  IS THIS A TEMP\n         BE    CK4TAPE1                .    TEMPS DO NOT MATTER\n         CLC   =C'A',DSN               .  IS THIS A VALID DSN\n         BH    CK4TAPE1                .    SHOOT, MUST BE A TEMP\n         CLC   $SID,=CL4'CPU4'         .  IS THIS CPU4?\n         BE    RETURN                  .   YES, SKIP CATALOG READ     XX\n                                       .   DUE TO CPU4 NOT DEFINED     X\n                                       .   ON ALL PATHS\n         TM    FLAGS3,DSNS2            .  SEE IF DSN=XX.YY(ZZ) THERE\n         BO    CHECKAGN                .    IF SO, READ XX.YY(0)\n         LOCATE CAMLOC                 .  LOCATE THE DSNAME\n         C     R15,=F'0'               .  WHAT ABOUT RETURN CODES?\n         BNE   CHECKAGN                .     MVS IS A FART IN THE WIND\n         CLI   CAMSER,X'00'            .  IS VOLSER SET MEANINGFUL\n         BE    RETURN                  .     MVS IS A BIG FART IN THE  X\n                                       .     WIND\n         TM    CAMDEVB3,UCB3TAPE       .  DOES THE CATALOG SAY \"TAPE\"\n         BNO   RETURN                  .    NOT A TAPE, GET OUT\n         B     KEEPTAPE                .    IS A TAPE, REMEMBER IT\nCK4TAPE1 DS    0H                      .\n         TM    UNITSW,TAPEUNIT         .  IS IT TEMP TAPE?\n         BO    KEEPTAPE                .     YES, GO COUNT IT FOR ME\n         B     RETURN                  .      NO, JUST GO HOME\nCHECKAGN DS    0H                      .  FIRST READ FAILED, CHECK     X\n                                       .    AS IF IT WERE GEN (0)\n         TRT   DSN,TRTDSN              .  FIND FIRST BLANK\n         BZ    RETURN                  .     OOPS, THERE ISNT ONE\n         MVC   0(3,R1),=C'(0)'         .  PRETEND IT IS GEN\n         LOCATE CAMLOC                 .  READ MY CATALOG AGAIN\n         C     R15,=F'0'               .  DID MVS SAY \"KIRK IS A FOOL\"\n         BNE   RETURN                  .     YES, I HATE A SMARTALECK\n         TM    CAMDEVB3,UCB3TAPE       .  DID THE CATALOG SAY \"TAPE\"\n         BNO   RETURN                  .     NO, I CANNOT COUNT AIR\nKEEPTAPE DS    0H                      .  A TAPE HAS BEEN FOUND\n         L     R15,STAPE               .   SO COUNT\n         A     R15,=F'1'               .     INTO THE STEP TAPE\n         ST    R15,STAPE               .        BUCKET\n         B     RETURN                  .  GO TRY AGAIN\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  EITHER AN EXEC OR A PROC STATEMENT WAS JUST PROCESSED. VERY       *\n*  SIMILAR PROCESSING OCCURS FOR BOTH.                               *\n*                                                                    *\n*  VALIDATE THAT INVALID EXEC AND PROC KEYWORDS ARE NOT USABLE       *\n*  BY THE GENERAL POPULATION.                                        *\n*                                                                    *\n**********************************************************************\nCHECKEX  DS    0H                      .  READ NEXT LINE\nCHECKPR  DS    0H                      .  READ PREVIOUS LINE\n         TM    FLAGS1,TESTBTCH         .  IF THIS IS TEST, CONTINUE\n         BNO   RETURN                  .    NOT TEST, WE DONT CARE\n         TM    FLAGS2,EPERF            .  DID TEST WANT PERFORM\n         BNO   NOEPERF                 .     NO PERFORM NEEDED\n*        OI    FLAGS1,ERROR            .  AGAIN I CAN KILL EM\n*       $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE PERFORM= ON EXEC CB\n               ARD'\n*        NI    FLAGS2,255-EPERF        .  TURN OFF INDICATOR BIT\nNOEPERF  TM    FLAGS2,EADRS            .  DID TEST WANT ADDRSPC=REAL\n         BNO   NOEADRS                 .     NO, NOT TOO BRIGHT IS HE\n         OI    FLAGS1,ERROR            .    YES, SO CANCEL HIM\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE ADDRSPC= ON EXEC CA\n               ARD'                    .\n         NI    FLAGS2,255-EADRS        .  RESET THE BIT\nNOEADRS  TM    FLAGS2,EDPRT            .  DID TEST WANT DPRTY=(NN,NN)\n         BNO   NOEDPRT                 .     NO, AGAIN WHAT A DUMMY\n         OI    FLAGS1,ERROR            .    YES, CANCEL HIS REAR\n        $SYSMSG '$HASP920 (E6) TEST BATCH CANNOT USE DPRTY= ON EXEC CARC\n               D'\n         NI    FLAGS2,255-EDPRT        .  RESET THE BIT\nNOEDPRT  DS    0H                      .\n         B     RETURN                  .  WEE DUN NOW.\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  RANDOMLY ENTERED KEYWORD PROCESSING ROUTINES FOR JOB CARDS        *\n*  FOLLOW HERE.                                                      *\n*                                                                    *\n**********************************************************************\nJADRSP   DS    0H                      .  PROCESS ADRSP     JOB\n         CLC   =C'REAL',USERTXT        .    IS IT ADRSP=REAL?\n         BNE   SKIPKEY                 .      NO, CONTINUE\n         OI    FLAGS1,REALMEM          .     YES, REMEMBER THIS\n         B     SKIPKEY                 .\nJTIME    DS    0H                      .  PROCESS TIME      JOB\n         OI    FLAGS3,TIMEJJ           .  REMEMBER TIME WAS HERE\n         SLR   R14,R14                 .  CLEAR 14 FOR IC\n         SLR   R15,R15                 .  CLEAR 15 TIME ACCUMULATOR\n         IC    R14,USER#               .  GET OPERAND COUNT FIELD\n         C     R14,=F'2'               .  ANY OPERANDS?\n         BE    DOTIME2                 .    YES, 2 OF THEM\n         C     R14,=F'1'               .\n         BE    DOTIME1                 .    YES, 1 OPERAND\n         B     SKIPKEY                 .     NO, 0 OPERANDS\nDOTIME1  IC    R14,USERL1              .  GET FIRST OPERAND LENGTH\n         C     R14,=F'0'               .  DOES IT HAVE ANY LENGTH\n         BE    SKIPKEY                 .  DOES ME NO GOOD\n         BCTR  R14,R0                  .  GET LENGTH RELATIVE 0\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK               .  PACK TIME OPERAND\n         CVB   R14,DWORK               .  PUT TIME IN MINUTES IN R14\n         SRDA  R14,32                  .\n         M     R14,=F'60'              .  TIMES 60 TO GET SECONDS\n         B     TCOMPARE                .\nDOTIME2  IC    R14,USERL1              .  GET OPERAND LENGTH 1\n         C     R14,=F'0'               .  IS IT 0?\n         BE    DOTIME2A                .     YES, GET SECOND OPERAND\n         BCTR  R14,R0                  .      NO, DECREMENT RELATIVE 0\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK               .  PACK MINUTES\n         CVB   R14,DWORK               .\n         SRDA  R14,32                  .  CONVERT TO\n         M     R14,=F'60'              .      SECONDS  IN R15\n         SLR   R14,R14                 .\n         IC    R14,USERL1              .  GET LENGTH AGAIN\nDOTIME2A LA    R1,3(R14,R4)            .  INDEX TO USERL2 LENGTH FLD\n         IC    R14,0(R1)               .    AND PULL IT IN\n         C     R14,=F'0'               .  IS LENGTH 2 =0\n         BE    TCOMPARE                .\n         BCTR  R14,R0                  .  CONVERT\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK1              .     TIME\n         CVB   R14,DWORK               .         TO BINARY\n         AR    R15,R14                 .  GET TOTAL TIME REQUESTED\nTCOMPARE C     R15,MAXTIME             .  IS THIS ONE BIGGER THAN MAX\n         BNH   TEXIT                   .    YES, JUST FLOW HOME\n         ST    R15,MAXTIME             .     NO, SAVE FOR LATER\nTEXIT    DS    0H                      .  PREPARE TO LEAVE FOR HOME\n         L     R15,MAXTIME             .  GET THE USER SPECIFIED TIME\n         ICM   R15,B'1000',=X'7F'      .   SET FLAG ID TO IEFUTL\n         ST    R15,JCTUSERF            .    AND SAVE IN JCT FOR IEFUTL\n         B     SKIPKEY                 .  SKIP THIS TIME KEY\nTPACK    PACK  DWORK,USERTXT(0)        .\nTPACK1   PACK  DWORK,1(0,R1)           .\nJCLASS   DS    0H                      .  PROCESS CLASS     JOB\n         MVC   CLASS,USERTXT           .\n         OI    FLAGS2,JCARD            .  REMEMBER JOB CARD\n         B     SKIPKEY                 .\nJREGION  DS    0H                      .  PROCESS REGION    JOB\n         SLR   R14,R14                 .  GET NUMBER OF DIGITS\n         IC    R14,USERL1              .    IN REGION REQUEST\n         C     R14,=F'15'              .  DID USER GO OVERBOARD\n         BH    SKIPKEY                 .     LOOKS THAT WAY\n         C     R14,=F'0'               .  DID USER ACT STUPID\n         BE    SKIPKEY                 .     LOOKS THAT WAY\n         BCTR  R14,R0                  .  SUBTRACT 2 FOR\n         BCTR  R14,R0                  .     EXECUTE OF PACK\n         EX    R14,TPACK               .  PACK THE REGION VALUE\n         CVB   R14,DWORK               .     AND MAKE IT BINARY\n         ST    R14,REGIONJ             .  REGION= SAVED FOR LATER\n         B     SKIPKEY                 .\nJPRTY    DS    0H                      .  PROCESS PRTY      JOB\n         OI    FLAGS1,JOBPRTY          .  PRTY=XX ON JOB CARD\n         B     SKIPKEY                 .\nJTYPRUN  DS    0H                      .  PROCESS TYPRUN    JOB\n         CLC   =C'HOLD',USERTXT        .    IS IT TYPRUN=HOLD?\n         BNE   SKIPKEY                 .      NO, CONTINUE\n         OI    FLAGS1,JOBHOLD          .     YES, REMEMBER THIS\n         B     SKIPKEY                 .\nJJOBN    DS    0H                      .  PROCESS JOBNAME   JOB\n         SLR   R15,R15                 .  CLEAR FOR EXEC INSTR\n         IC    R15,USERL1              .  GET JOBNAME LENGTH\n         MVC   JOB,=CL8'        '      .  PRE CLEAR JOBNAME FIELD\n         N     R15,=F'15'              .  LIMIT JOB NAME LEN\n         BCTR  R15,R0                  .  RELATIVE 0 FOR EX\n         EX    R15,JOBMVC              .  MOVE IN JOBNAME\n         B     SKIPKEY                 .\nJOBMVC   MVC   JOB(0),USERTXT          .  EXECUTED JOBNAME MOVE\nJPERF    DS    0H                      .\n         OI    FLAGS3,PERFJ            .  USER SAID PERFORM=\n         B     SKIPKEY                 .\nJOBUSER  DS    0H                      .  PROCESS JOBNAME   JOB\n         SLR   R15,R15                 .  CLEAR FOR EXEC INSTR\n         IC    R15,USERL1              .  GET USER    LENGTH\n         N     R15,=F'15'              .  LIMIT USER LENGTH\n         STH   R15,USERLEN             .  SAVE USER LENGTH\n         MVC   USER,=CL8'        '     .  PRE CLEAR USER    FIELD\n         BCTR  R15,R0                  .  RELATIVE 0 FOR EX\n         EX    R15,USERMVC             .  MOVE IN USER\n         B     SKIPKEY                 .\nUSERMVC  MVC   USER(0),USERTXT         .  EXECUTED USER    MOVE\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*   RANDOMLY ENTERED EXEC AND PROC KEYWORD PROCESSOR ROUTINES        *\n*   FOLLOW HERE.                                                     *\n*                                                                    *\n**********************************************************************\nEXPRFMD  DS    0H                      .  PROCESS PERFORM.XXX=    EXEC\n         OI    FLAGS2,EPERF            .\n         B     SKIPKEY                 .\nEXPRFM   DS    0H                      .  PROCESS PERFORM=        EXEC\n         OI    FLAGS2,EPERF            .\n         B     SKIPKEY                 .\nEXADRSD  DS    0H                      .  PROCESS ADRSP.XXX=      EXEC\n         OI    FLAGS2,EADRS            .\n         B     SKIPKEY                 .\nEXADRS   DS    0H                      .  PROCESS ADRSP=          EXEC\n         OI    FLAGS2,EADRS            .\n         B     SKIPKEY                 .\nEXDPRTD  DS    0H                      .  PROCESS DPRTY.XXX=      EXEC\n         OI    FLAGS2,EDPRT            .\n         B     SKIPKEY                 .\nEXDPRT   DS    0H                      .  PROCESS DPRTY=          EXEC\n         OI    FLAGS2,EDPRT            .\n         B     SKIPKEY                 .\nEXTIMED  DS    0H                      .  PROCESS TIME.XX=        EXEC\n         OI    FLAGS2,ETIME            .\n         SLR   R14,R14                 .  CLEAR 14 FOR IC\n         SLR   R15,R15                 .  CLEAR 15 TIME ACCUMULATOR\n         IC    R14,USER#               .  GET OPERAND COUNT FIELD\n         C     R14,=F'3'               .  ANY OPERANDS?\n         BE    DFTIME3                 .    YES, 3 OF THEM\n         C     R14,=F'2'               .  ANY OPERANDS?\n         BE    DFTIME2                 .    YES, 2 OF THEM\n         B     SKIPKEY                 .     NO, 0 OPERANDS\nDFTIME2  IC    R14,USERL1              .  GET FIRST OPERAND LENGTH\n         LA    R1,3(R14,R4)            .  INDEX TO SECOND OPERAND LEN\n         IC    R14,0(R1)               .  GET THAT LENGTH\n         C     R14,=F'0'               .\n         BE    SKIPKEY                 .\n         BCTR  R14,R0                  .\n         EX    R14,TPACK5              .  PACK MINUTES\n         CVB   R14,DWORK               .\n         SRDA  R14,32                  .\n         M     R14,=F'60'              .\n         B     FCOMPARE                .\nDFTIME3  DS    0H                      .  GET OPERAND LENGTH 1\n         IC    R14,USERL1              .\n         LA    R1,3(R14,R4)            .  POINT TO MINUTES LEN\n         IC    R14,0(R1)               .  GET THE LENGTH\n         C     R14,=F'0'               .\n         BE    DFTIME3A                .  NO MINUTES, GET SECONDS\n         BCTR  R14,R0                  .\n         EX    R14,TPACK5              .\n         CVB   R14,DWORK               .\n         SRDA  R14,32                  .\n         M     R14,=F'60'              .\nDFTIME3A DS    0H                      .\n         SLR   R14,R14                 .\n         IC    R14,0(R1)               .  GET LENGTH AGAIN\n         LA    R1,1(R14,R1)            .  POINT TO LAST FIELD\n         IC    R14,0(R1)               .  GET THE LENGTH\n         C     R14,=F'0'               .\n         BE    FCOMPARE                .  NO SECONDS, COMPARE\n         BCTR  R14,R0                  .\n         EX    R14,TPACK5              .\n         CVB   R14,DWORK               .\n         AR    R15,R14                 .  ADD SECONDS AND MINUTES\nFCOMPARE C     R15,MAXTIME             .  IS THIS ONE BIGGER THAN MAX\n         BNH   FEXIT                   .    YES, JUST FLOW HOME\n         ST    R15,MAXTIME             .     NO, SAVE FOR LATER\nFEXIT    B     SKIPKEY                 .  SKIP THIS TIME KEY\nTPACK5   PACK  DWORK,1(0,R1)           .\nEXTIME   DS    0H                      .  PROCESS TIME=           EXEC\n         OI    FLAGS2,ETIME            .\n         SLR   R14,R14                 .  CLEAR 14 FOR IC\n         SLR   R15,R15                 .  CLEAR 15 TIME ACCUMULATOR\n         IC    R14,USER#               .  GET OPERAND COUNT FIELD\n         C     R14,=F'2'               .  ANY OPERANDS?\n         BE    DETIME2                 .    YES, 2 OF THEM\n         C     R14,=F'1'               .\n         BE    DETIME1                 .    YES, 1 OPERAND\n         B     SKIPKEY                 .     NO, 0 OPERANDS\nDETIME1  IC    R14,USERL1              .  GET FIRST OPERAND LENGTH\n         C     R14,=F'0'               .  DOES IT HAVE ANY LENGTH\n         BE    SKIPKEY                 .  DOES ME NO GOOD\n         BCTR  R14,R0                  .  GET LENGTH RELATIVE 0\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK2              .  PACK TIME OPERAND\n         CVB   R14,DWORK               .  PUT TIME IN MINUTES IN R14\n         SRDA  R14,32                  .\n         M     R14,=F'60'              .  TIMES 60 TO GET SECONDS\n         B     ECOMPARE                .\nDETIME2  IC    R14,USERL1              .  GET OPERAND LENGTH 1\n         C     R14,=F'0'               .  IS IT 0?\n         BE    DETIME2A                .     YES, GET SECOND OPERAND\n         BCTR  R14,R0                  .      NO, DECREMENT RELATIVE 0\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK2              .  PACK MINUTES\n         CVB   R14,DWORK               .\n         SRDA  R14,32                  .  CONVERT TO\n         M     R14,=F'60'              .      SECONDS  IN R15\n         SLR   R14,R14                 .\n         IC    R14,USERL1              .  GET LENGTH AGAIN\nDETIME2A LA    R1,3(R14,R4)            .  INDEX TO USERL2 LENGTH FLD\n         IC    R14,0(R1)               .    AND PULL IT IN\n         C     R14,=F'0'               .  IS LENGTH 2 =0\n         BE    ECOMPARE                .\n         BCTR  R14,R0                  .  CONVERT\n         XC    DWORK,DWORK             .\n         EX    R14,TPACK3              .     TIME\n         CVB   R14,DWORK               .         TO BINARY\n         AR    R15,R14                 .  GET TOTAL TIME REQUESTED\nECOMPARE C     R15,MAXTIME             .  IS THIS ONE BIGGER THAN MAX\n         BNH   EEXIT                   .    YES, JUST FLOW HOME\n         ST    R15,MAXTIME             .     NO, SAVE FOR LATER\nEEXIT    B     SKIPKEY                 .  SKIP THIS TIME KEY\nTPACK2   PACK  DWORK,USERTXT(0)        .\nTPACK3   PACK  DWORK,1(0,R1)           .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  RANDOMLY ENTERED DD TEXT KEY PROCESSORS FOLLOW HERE.              *\n*                                                                    *\n**********************************************************************\nDDDISP   DS    0H                      .  DD CARD DISPOSITION\n         CLC   =C'NEW',USERTXT         .  IS IT DISP=(NEW,,,,,,,)\n         BE    ISNEW                   .    YES, GO SET BIT\n         SLR   R14,R14                 .  CLEAR FOR NEXT IC\n         IC    R14,USERL1              .  GET THE FIRST DISP LENGTH\n         C     R14,=F'0'               .  IS IT DISP=(,,,,,) IE:NEW\n         BNE   SKIPKEY                 .    NO, JUST GET OUT\nISNEW    DS    0H                      .\n         OI    UNITSW,DISPNEW          .\n         B     SKIPKEY                 .\nDUNITK   DS    0H                      .\n         OI    UNITSW,UNITXIST         .  UNIT KEYWORD FOUND\n         CLC   =C'TAPE',USERTXT        .  IS IT UNIT=TAPE\n         BE    ISTAPE                  .\n         CLC   =C'3400',USERTXT        .  IS IT UNIT=3400\n         BE    ISTAPE                  .\n         B     SKIPKEY                 .\nISTAPE   DS    0H                      .\n         OI    UNITSW,TAPEUNIT         .  REMEMBER TAPE DSN\n         B     SKIPKEY                 .\nDDAFF    DS    0H                      .  UNIT=AFF=\n         OI    UNITSW,UNITAFF          .    TURN ON BIT SETTING\n         B     SKIPKEY                 .       AND GET NEXT BIG ONE\nDDVOLS   DS    0H                      .  VOL=SER=\n         TM    FLAGS1,TESTBTCH         .  IS IT TEST BATCH\n         BNO   SKIPKEY                 .\n         SLR   R14,R14                 .  CLEAR FOR GODLIKE INSERT\n         IC    R14,USERL1              .     GET SERIAL LIST COUNT\n         C     R14,=F'0'               .  DID USER HAVE A SER LIST?\n         BE    SKIPKEY                 .    NO, TRY TO FAKE ME OUT MAN.\n         OI    UNITSW,VOLSPEC          .    YES, TURN ON BIT SETTING\n         SLR   R15,R15                 .\n         L     R14,16                  .  POINT TO CVT\n         L     R14,CVTILK2-CVT(R14)    .  GET UCB LOOKUP TABLE\n         OI    UNITSW,VOLTAPE          .  MAKE THE DEFAULT TO TAPE VOL\n         PUSH  USING                   .\nUCBLOOP1 DS    0H                      .\n         ICM   R15,B'0011',0(R14)      .  POINT TO A UCB\n         LA    R14,2(R14)              .    AND POINT TO NEXT LOOKUP\n         USING UCBOB,R15               .  ADDRESS UCB BY NAME\n         CL    R15,=X'0000FFFF'        .  IS THIS THE END OF UCB TAB?\n         BE    SKIPKEY                 .\n         CLC   UCBVOLI,USERTXT         .  IS VOLSER A MATCH\n         BE    UCBCK1                  .     YES, CHECK IF TAPE UCB\n         B     UCBLOOP1                .      NO, LOOP UNTIL DONE\nUCBCK1   DS    0H                      .\n         TM    UCBTBYT3,UCB3TAPE       .\n         BO    SKIPKEY                 .\n         NI    UNITSW,FF-VOLTAPE       .\n         B     SKIPKEY                 .       AND GET NEXT KEYWORD\n         POP   USING                   .\nDDREFS   DS    0H                      .  VOL=REF=\n         OI    UNITSW,VOLREF           .  AND REMEMBER IT FOR LATER\n         B     SKIPKEY                 .       AND GET NEXT KEYWORD\nDDSNK    DS    0H                      .  DSNAME KEY FOUND\n         CLI   DSN,C' '                .  IS DSN ALREADY SPECIFIED\n         BNE   SKIPKEY                 .  SKIP THIS NONSENSE\n         SLR   R14,R14                 .\n         IC    R14,USERL1              .  GET LENGTH OF DSNAME\n         C     R14,=F'0'               .  IS DSNAME THERE\n         BE    SKIPKEY                 .   NO, JUST GET OUT\n         C     R14,=F'127'             .  IS HIGH BIT SET\n         BH    TWODSNS                 .\n         BCTR  R14,R0                  .\n         EX    R14,DSNMVC              .  MOVE DSNAME TO WORK\n         B     SKIPKEY                 .\nDSNMVC   MVC   DSN(0),USERTXT          .\nTWODSNS  DS    0H                      .\n         OI    FLAGS3,DSNS2            .\n         IC    R14,USERTXT             .  GET LENGTH OF FIRST DSN\n         C     R14,=F'44'              .  IS IT VALID\n         BH    SKIPKEY                 .    NO, GET OUT\n         C     R14,=F'0'               .  IS IT REALLY VALID\n         BE    SKIPKEY                 .    NO, GET OUT\n         BCTR  R14,R0                  .\n         EX    R14,DSN2MVC             .  MOVE IN FIRST DSN\n         B     SKIPKEY                 .\nDSN2MVC  MVC   DSN(0),USERTXT+1        .\nDDUMMK   DS    0H                      .  DUMMY DSNAME FOUND\n         MVC   DSN(09),=C'NULLFILE '   .\n         B     SKIPKEY                 .\nDDDK     DS    0H                      .\n         MVI   DD,C' '                 .  CLEAR DDNAME\n         MVC   DD+1(L'DD-1),DD         .\n         SLR   R14,R14                 .\n         IC    R14,USER#               .  GET COUNT OF OPERANDS\n         C     R14,=F'0'               .\n         BE    SKIPKEY                 .  NO DDNAME ENTERED\n         IC    R14,USERL1              .  GET DDNAME LENGTH\n         C     R14,=F'0'               .\n         BE    SKIPKEY                 .  NO DDNAME LENGTH\n         BCTR  R14,R0                  .\n         EX    R14,DDMVC               .\n         B     SKIPKEY                 .\nDDMVC    MVC   DD(0),USERTXT           .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n* SKIPKEY IS A ROUTINE TO SKIP OVER THE CURRENT TEXT KEYWORD.        *\n* IT SKIPS OVER ALL THE CURRENT MAJOR TEXT KEYWORD AND ALL           *\n* PARENTHESIZED SUBFIELDS FOR THE MAJOR KEYWORD.                     *\n*                                                                    *\n* IT RETURNS DIRECTLY TO \"DOKEY\"                                     *\n*                                                                    *\n**********************************************************************\nSKIPKEY  DS    0H                      .\n         L     R1,CURPTR               .  R1=KEY\n         SLR   R2,R2                   .  CLEAR FOR\n         SLR   R3,R3                   .    FURTHER PROCESSING\n         LA    R1,1(R1)                .  POINT PAST TEXT KEY\n         IC    R2,0(R1)                .  GET COUNT FIELD\n         LA    R1,1(R1)                .  POINT TO LENG OR COUNT\n         C     R2,=F'0'                .  IS COUNT 0\n         BE    EXIT1                   .\nLOOP1    TM    0(R1),X'80'             .  IS THIS COUNT FIELD\n         BO    MORE#                   .  GO PROCESS COUNT FIELD\n         IC    R3,0(R1)                .  GET LENGTH\n         LA    R1,1(R3,R1)             .    INDEX PAST THIS KEY\n         BCT   R2,LOOP1                .\n         B     EXIT1                   .\nMORE#    IC    R3,0(R1)                .  GET COUNT FIELD\n         N     R3,=F'127'              .  STRIP OFF HIGH BIT\n         LA    R2,0(R3,R2)             .  ADD NEW COUNT TO OLD\n         LA    R1,1(R1)                .  POINT TO NEW COUNT OR LEN\n         BCT   R2,LOOP1                .\nEXIT1    ST    R1,CURPTR               .  KEY HAS BEEN SKIPPED,SAVE PTR\n         B     DOKEY                   .  RETURN TO NEXT PROCESS\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n* SKIPKEY6 IS A ROUTINE TO SKIP OVER THE CURRENT TEXT KEYWORD.       *\n* IT SKIPS OVER ALL THE CURRENT MAJOR TEXT KEYWORD AND ALL           *\n* PARENTHESIZED SUBFIELDS FOR THE MAJOR KEYWORD.                     *\n*                                                                    *\n* IT RETURNS INDIRECTLY THRU R14.                                    *\n*                                                                    *\n**********************************************************************\nSKIPKEY6 DS    0H                      .\n         L     R1,CURPTR               .  R1=KEY\n         SLR   R2,R2                   .  CLEAR FOR\n         SLR   R3,R3                   .    FURTHER PROCESSING\n         LA    R1,1(R1)                .  POINT PAST TEXT KEY\n         IC    R2,0(R1)                .  GET COUNT FIELD\n         LA    R1,1(R1)                .  POINT TO LENG OR COUNT\n         C     R2,=F'0'                .  IS COUNT 0\n         BE    EXIT6                   .\nLOOP6    TM    0(R1),X'80'             .  IS THIS COUNT FIELD\n         BO    MORE#6                  .  GO PROCESS COUNT FIELD\n         IC    R3,0(R1)                .  GET LENGTH\n         LA    R1,1(R3,R1)             .    INDEX PAST THIS KEY\n         BCT   R2,LOOP6                .\n         B     EXIT6                   .\nMORE#6   IC    R3,0(R1)                .  GET COUNT FIELD\n         N     R3,=F'127'              .  STRIP OFF HIGH BIT\n         LA    R2,0(R3,R2)             .  ADD NEW COUNT TO OLD\n         LA    R1,1(R1)                .  POINT TO NEW COUNT OR LEN\n         BCT   R2,LOOP6                .\nEXIT6    ST    R1,CURPTR               .  KEY HAS BEEN SKIPPED,SAVE PTR\n         BR    R14                     .  RETURN TO NEXT PROCESS\n         EJECT                         .\n***********************************************************************\n*                                                                     *\n*  OVERTIME SCANS FOR THE TIME KEYWORD ON THE JOB CARD AND            *\n*  DELETES IT FROM THE TEXT RECORD. THEN IT ATTACHES A DEFAULT        *\n*  JOB TIME FACTOR OF TIME=(,1)                                       *\n*                                                                     *\n***********************************************************************\nOVERTIME DS    0H                      .\n         ST    R14,R14SAVE             .  REMEMBER WHERE HOME IS\n         TM    FLAGS3,TIMEJJ           .  DID USER EVEN USE TIME\n         BNO   OVDEFTM                 .   NO, JUST DEFAULT TIME\n         LA    R4,STRJKEY              .  GET FIRST JOB KEY\n         ST    R4,CURPTR               .  SAVE FOR SCANNER\nOVLOOP1  DS    0H                      .\n         CLI   USERKEY,ENDK            .  IS THIS KEY THE END ?\n         BE    OVDEFTM                 .   YES, DO DEFAULTS\n         CLI   USERKEY,TIMEJK          .  IS THIS KEY JOB TIME?\n         BE    OVFND1                  .   YES, FIND NEXT KEY\n         BAL   R14,SKIPKEY6            .  SKIP  CURRENT KEY\n         L     R4,CURPTR               .\n         B     OVLOOP1                 .\nOVFND1   DS    0H                      .  TIME KEY FOUND\n         L     R4,CURPTR               .\n         ST    R4,TIMEPTR              .  SAVE IT\n         BAL   R14,SKIPKEY6            .  SKIP TO NEXT KEY\n         L     R4,CURPTR               .\n         ST    R4,OTHPTR               .  SAVE NEXT KEY PTR\n         S     R4,TIMEPTR              .  GET LENGTH OF TIME KEY\n         ST    R4,TIMELEN              .  WE GETIN CLOSE NOW\n         LH    R4,STRLTH               .  GET LENGTH OF ALL\n         LA    R4,0(R4,R7)             .  POINT TO PAST LAST KEY\n         S     R4,OTHPTR               .  LEN OF OTHER KEY\n         ST    R4,OTHLEN               .  SAVE LEN OTHER KEY\n         LM    R14,R1,TIMEPTR          .  SET FOR MVCL\n         AR    R15,R1                  .  MAKE IT A BIG ONE\n         MVCL  R14,R0                  .  TIME KEY IS SQUOZE OUT\n         LH    R14,STRLTH              .\n         S     R14,TIMELEN             .  TIME IS GONE NOW\n         STH   R14,STRLTH              .  FOR GOOD PERHAPS\nOVDEFTM  DS    0H                      .  NOW DEFAULT THE TIME\n         LH    R14,STRLTH              .\n         LA    R14,0(R14,R7)           .  POINT TO PAST LAST KEY\n         S     R14,=F'1'               .  POINT TO ENDK\n         MVC   0(03,R14),=AL1(TIMEJK,2,0)\n         MVC   3(02,R14),=X'01F1'      .\n         MVI   5(R14),ENDK             .  TIME=(,1)\n         LH    R14,STRLTH              .\n         LA    R14,5(R14)              .\n         STH   R14,STRLTH              .\n         L     R14,R14SAVE             .\n         BR    R14                     .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  THE MANY FACES OF RETURN.                                         *\n*                                                                    *\n*  \"RETURN\" IS THE NORMAL EXIT POINT FOR THIS ROUTINE.               *\n*                                                                    *\n*   RNOMEM1 IS FOR  RETURNING WHEN MEMORY HAS NOT BEEN GOTTEN.       *\n*                                                                    *\n*   RNOMEM4 IS FOR  RETURNING WHEN MEMORY HAS NOT BEEN GOTTEN,       *\n*      AND I NEVER WANT TO BE CALLED AGAIN.                          *\n*                                                                    *\n*                                                                    *\n**********************************************************************\nRETURN   DS    0H                      .\n         NI    FLAGS,255-JOBU-DDU-EXECU-PROCU . RESET TXT TYPE FLAGS\n         TM    FLAGS,LASTCALL          .  IS THIS LAST CALL\n         BNO   NOTLAST                 .\n         SLR   R15,R15                 .\n         ST    R15,PCEUSER0            .  CLEAR POINTER\n         LH    R3,RC                   .  GET THE RETURN CODE\n         L     R4,4(R13)               .  SAVE USERS SAVE AREA\n         L     R1,GETSIZE              .  GET FREEMAIN SIZE\n         L     R14,12(R4)              .  GET RETURN AREA POINTER\n         LR    R2,R13                  .\n         FREEMAIN R,LV=(1),A=(2)       .  FREE GETMAIN AREA\n         LR    R15,R3                  .  PUT RC INTO R15\n         LR    R13,R4                  .  PUT SAVE ARE BACK IN 13\n         LM    R0,R12,20(R13)          .\n         BR    R14                     .  GO BACK TO MASTER\nNOTLAST  DS    0H                      .  GET THE RETURN CODE\n         LH    R15,RC                  .  GET THE RETURN CODE\n         L     R13,4(R13)              .  RESET SAVE AREA POINTER\n         L     R14,12(R13)             .\n         LM    R0,R12,20(R13)          .\n         BR    R14                     .  GOBACK\nRNOMEM1  DS    0H                      .  ERROR RETURN, NOMEMORY AVAIL\n         LM    R14,R12,12(R13)         .  RESTORE USERS REGISTERS\n         SLR   R15,R15                 .  SET RETURN CODE 0\n         BR    R14                     .  RETURN TO CALLER\nRNOMEM4  DS    0H                      .  ERROR RETURN, NOMEMORY AVAIL\n         NI    JCTXMASK,FF-EX006       .  DO NOT CALL AGAIN\n         LM    R14,R12,12(R13)         .  RESTORE USERS REGISTERS\n         SLR   R15,R15                 .  SET RETURN CODE 0\n         BR    R14                     .  RETURN TO CALLER\n         EJECT                         .\nGETSIZE  DC    0F'0',AL1(SUBPOOL),AL3(WORKLEN)\n**********************************************************************\n*                                                                    *\n*  FOLLOWS IS A TABLE OF \"BASE/DISPLACEMENT\" ADDRESSES FOR USE IN    *\n*  BRANCHING TO TEXT KEY PROCESSOR ROUTINES.                         *\n*                                                                    *\n**********************************************************************\nJOBTABLE DC    256S(SKIPKEY)           . DEFAULT IS IGNORE TEXT RECORD\n         ORG   JOBTABLE+2*ADRSPJK      .\n         DC    S(JADRSP)               . PROCESS JOB ADRSP=REAL\n         ORG   JOBTABLE+2*TIMEJK       .\n         DC    S(JTIME)                . PROCESS JOB TIME=\n         ORG   JOBTABLE+2*CLASSJK      .\n         DC    S(JCLASS)               . PROCESS JOB CLASS=\n         ORG   JOBTABLE+2*REGINJK      .\n         DC    S(JREGION)              . PROCESS JOB REGION=\n         ORG   JOBTABLE+2*PRFMJK       .\n         DC    S(JPERF)                . PROCESS JOB PERFORM=\n         ORG   JOBTABLE+2*PRTYJK       .\n         DC    S(JPRTY)                . PROCESS JOB PRTY=\n         ORG   JOBTABLE+2*TYPRUNJK     .\n         DC    S(JTYPRUN)              . PROCESS JOB TYPRUN=\n         ORG   JOBTABLE+2*JOBK         .\n         DC    S(JJOBN)                . PROCESS JOB NAME=\n         ORG   JOBTABLE+2*USERK        .\n         DC    S(JOBUSER)              . PROCESS JOB USER=\n         ORG   JOBTABLE+2*ENDK         .\n         DC    S(LASTKEY)              . PROCESS LAST KEY FOR JOB\n         ORG   JOBTABLE+2*PRFMPEK      .\n         DC    S(EXPRFMD)              . PROCESS EXEC PERFORM.XXX=\n         ORG   JOBTABLE+2*PRFMEEK      .\n         DC    S(EXPRFM)               . PROCESS EXEC PERFORM=\n         ORG   JOBTABLE+2*ADRSPPEK     .\n         DC    S(EXADRSD)              . PROCESS EXEC ADRSP.XXX=\n         ORG   JOBTABLE+2*ADRSPEEK     .\n         DC    S(EXADRS)               . PROCESS EXEC ADRSP=\n         ORG   JOBTABLE+2*SDPPEK       .\n         DC    S(EXDPRTD)              . PROCESS EXEC DPRTY.XX=\n         ORG   JOBTABLE+2*SDPEEK       .\n         DC    S(EXDPRT)               . PROCESS EXEC DPRTY=\n         ORG   JOBTABLE+2*TIMEPEK      .\n         DC    S(EXTIMED)              . PROCESS EXEC TIME.XXX=\n         ORG   JOBTABLE+2*TIMEEEK      .\n         DC    S(EXTIME)               . PROCESS EXEC TIME=\n         ORG   JOBTABLE+2*UNITK        . PROCESS DD UNIT=\n         DC    S(DUNITK)               .\n         ORG   JOBTABLE+2*DSNAMEK      . PROCESS DD DSNAME=\n         DC    S(DDSNK)               .\n         ORG   JOBTABLE+2*DUMMK        . PROCESS DD DUMMY\n         DC    S(DDUMMK)              .\n         ORG   JOBTABLE+2*DDK          . PROCESS DD NAME=\n         DC    S(DDDK)                .\n         ORG   JOBTABLE+2*AFFMK        . PROCESS DD UNIT=AFF=\n         DC    S(DDAFF)               .\n         ORG   JOBTABLE+2*SERMK        . PROCESS DD VOL=SER=XXXX\n         DC    S(DDVOLS)              .\n         ORG   JOBTABLE+2*REFMK        . PROCESS DD VOL=REF=XXXX\n         DC    S(DDREFS)              .\n         ORG   JOBTABLE+2*DISPK        . PROCESS DD DISP=\n         DC    S(DDDISP)               .\n         ORG   ,                       .\nMSG1     WTO   '$HASP920 (E6) -- JOB FAILED REPUBLICBANK JCL EXIT. REVIC\n               EW SYSTEM MESSAGES FOR EXACT CAUSES',MF=L,              C\n               ROUTCDE=(2),DESC=(6)   .\nMSG1L    EQU   *-MSG1                  .\nSTATSMSX DC    127CL1' '               .\n         ORG   STATSMSX                .\n         DC    C'$HASP920 (E6) CLASS='  .\nSTATC    DC    CL1' '                  .\n         DC    C', TIME='              .\nSTATT    DS    CL5                     .\n         DC    C', JTAPES='            .\nSTATJ    DS    CL5                     .\n         DC    C', STAPES='            .\nSTATS    DS    CL5                     .\n         DC    C', JREGION='           .\nSTATR    DS    CL4                     .\nSTATLEN  EQU   *-STATSMSX              .\n         ORG   STATSMSX                .\nSTATMSG  DS    CL(STATLEN)             .\n         ORG   ,                       .\n         EJECT                         .\n**********************************************************************\n*                                                                    *\n*  FOLLOWS IS A TABLE OF LIMITS FOR EACH AVAILABLE JOB CLASS.        *\n*  STEPTAP IS MAX STEP TAPES ALLOWED                                 *\n*  JOBTAPE IS MAX JOB TAPES ALLOWED                                  *\n*  JOBCPU IS MAX CPU TIME FOR THE JOB CLASS                          *\n*  DFLT TIME IS WHAT TO USE WHEN CLASS OR TIME IS DEFAULTED          *\n*                                                                    *\n**********************************************************************\nCLASSTAB DS    0F                      .\n*              STEPTAP |JOBTAPE |JOBCPU  | CLASS |DFLT TIME\nCB       DC    F'32768',F'32768',F'86399',C'BP  ',F'000'\nCI       DC    F'32768',F'32768',F'86399',C'IC  ',F'000'\nCK       DC    F'32768',F'32768',F'86399',C'KP  ',F'000'\nCO       DC    F'32768',F'32768',F'86400',C'OP  ',F'000'    CPCS\nCP       DC    F'32768',F'32768',F'86400',C'PP  ',F'000'    IMS\nCQ       DC    F'32768',F'32768',F'86400',C'QP  ',F'000'    CICS\nCR       DC    F'32768',F'32768',F'86399',C'RP  ',F'000'\nCU       DC    F'32768',F'32768',F'86399',C'UP  ',F'000'\nCV       DC    F'32768',F'32768',F'86399',C'VP  ',F'000'\nCX       DC    F'32768',F'32768',F'86399',C'XC  ',F'000'\nCY       DC    F'32768',F'32768',F'86400',C'YP  ',F'000'    IMS TEST\nC0       DC    F'00000',F'00000',F'00020',C'0T  ',F'001'\nC1       DC    F'00000',F'00000',F'00060',C'1T  ',F'001'\nC2       DC    F'00000',F'00000',F'00150',C'2T  ',F'001'\nC3       DC    F'00000',F'00000',F'03000',C'3T  ',F'001'\nC4       DC    F'00001',F'32768',F'00060',C'4T  ',F'001'\nC5       DC    F'00002',F'32768',F'00150',C'5T  ',F'001'\nC6       DC    F'32768',F'32768',F'03000',C'6T  ',F'001'\nC7       DC    F'00000',F'00000',F'00030',C'7S  ',F'001'\nC8       DC    F'00003',F'32768',F'01000',C'8S  ',F'001'\nC9       DC    F'32768',F'32768',F'86399',C'9R  ',F'000'\n         DC    F'32768',F'32768',F'86399',C'*   ',F'000'  TABLE END\nTRTDSN   DC    256XL1'00'              .  TRT TABLE TO FIND FIRST\n         ORG   TRTDSN+X'40'            .    BLANK IN DSN\n         DC    XL1'04'                 .\n         ORG   ,                       .\nTRTNUM   DC    256XL1'00'              .  TRT TABLE TO FIND\n         ORG   TRTNUM+C'0'             .    NUMERIC BYTE IN FIELD\n         DC    10XL1'04'               .\n         ORG   ,                       .\n         LTORG                         .\n         EJECT                         .\nCLASSD   DSECT                         .\nCSTEPTP  DS    F                       .\nCJOBTP   DS    F                       .\nCJOBTIME DS    F                       .\nCID      DS    C                       .\nCBATCH   DS    CL1                     . BATCH FLAGS\nCTEST    EQU   C'T'                    .  TEST\nCSPEC    EQU   C'S'                    . SPECIAL\nCRECOV   EQU   C'R'                    . RECOVERY\nCPROD    EQU   C'P'                    . PRODUCTION\nCCNTRL   EQU   C'C'                    . LIMITED TO TECH AND PC\nFILLER   DS    CL2                     .\nCDTIME   DS    F                       .\nCENTL    EQU   *-CSTEPTP               .\n         EJECT                         .\nWORK     DSECT                         .\nSAVE     DS    18F                     .\nDWORK    DS    D                       .  AREA FOR DATA CONVERSION\nR14SAVE  DS    F                       .  SAVE AREA FOR R14\nCURPTR   DS    F                       .  CURRENT TEXT KEY POINTER\nTIME     DS    F                       .  TIME= AREA\nSTAPE    DS    F                       .  STEP TAPES\nSTAPEM   DS    F                       .  STEP TAPE MAX\nJTAPE    DS    F                       .  JOB TAPES\nREGIONJ  DS    F                       .  JOB REGION\nMAXTIME  DS    F                       .  MAX CPU TIME REQUESTED\nTIMEPTR  DS    F                       .  FLDS USED\nTIMELEN  DS    F                       .    WHEN SQUEEZING OUT\nOTHPTR   DS    F                       .       THE TIME\nOTHLEN   DS    F                       .          KEYWORD\nRC       DS    H                       .  RETURN CODE\nUSERLEN  DS    H                       .  USERID LENGTH\nWORKINST DS    CL6                     .  AREA FOR DYNAMIC INSTRUCTION\nUSER     DS    CL08                    .\nJOB      DS    CL08                    .\nDSN      DS    CL44                    .\nDD       DS    CL08                    .\nUNITSW   DS    CL01                    .  UNIT SWITCH SETTINGS\nTAPEUNIT EQU   B'10000000'             .\nUNITXIST EQU   B'01000000'             .\nUNITAFF  EQU   B'00100000'             .\nVOLSPEC  EQU   B'00010000'             .\nVOLREF   EQU   B'00001000'             .\nVOLTAPE  EQU   B'00000100'             .\nDISPNEW  EQU   B'00000010'             .\nU08      EQU   B'00000001'             .\nCLASSPTR DS    F                       .  POINTER TO CLASS DEF\nCLASS    DS    C                       .  THE CLASS USER SAID\nFLAGS    DS    C                       .  SOME FLAGS\nMGOT     EQU   B'10000000'             .  MEMORY GOTTEN FLAG\nLASTCALL EQU   B'01000000'             .  LAST JES2 INVOCATION FLAG\nJOBU     EQU   B'00100000'             .  PROCESSING JOB CARD\nPROCU    EQU   B'00010000'             .             PROC\nDDU      EQU   B'00001000'             .             DD\nEXECU    EQU   B'00000100'             .             EXEC\nUNUSED6  EQU   B'00000010'             .\nUNUSED7  EQU   B'00000001'             .\nFLAGS1   DS    C                       .      JOB FLAGS\nREALMEM  EQU   B'10000000'             .  JOB ADRSP=REAL\nF102     EQU   B'01000000'             .\nJOBRGN   EQU   B'00100000'             .  JOB REGION=\nJOBPRTY  EQU   B'00010000'             .  JOB PRTY=\nJOBHOLD  EQU   B'00001000'             .  JOB TYPRUN=HOLD\nTESTBTCH EQU   B'00000100'             .  JOB IS TESTBATCH\nERROR    EQU   B'00000010'             .  JOB SHOULD BE FAILED\nJOBCARD  EQU   B'00000001'             .  JOB CARD ENCOUNTERED\nFLAGS2   DS    C                       .      EXEC FLAGS\nEPERF    EQU   B'10000000'             .\nEADRS    EQU   B'01000000'             .\nEDPRT    EQU   B'00100000'             .\nETIME    EQU   B'00010000'             .\nSPUSER   EQU   B'00001000'             .  SPECIAL USER DP,DS,RDPP\nJCARD    EQU   B'00000100'             .\nSTAPEE   EQU   B'00000010'             .\nJTAPEE   EQU   B'00000001'             .\nFLAGS3   DS    C                       .  MORE FLAGS\nTIMEJJ   EQU   B'10000000'             .\nTIMEDEF  EQU   B'01000000'             .\nDSNS2    EQU   B'00100000'             .\nPERFJ    EQU   B'00010000'             .\nE305     EQU   B'00001000'             .\nE306     EQU   B'00000100'             .\nE307     EQU   B'00000010'             .\nE308     EQU   B'00000001'             .\n         DS    0D\nCAMRET   DS    CL280                   .\n         ORG   CAMRET                  .\nCAMCNT   DS    H                       .\nCAMDEVB1 DS    CL1                     .\nCAMDEVB2 DS    CL1                     .\nCAMDEVB3 DS    CL1                     .\nCAMDEVB4 DS    CL1                     .\nCAMSER   DS    CL6                     .\nCAMSEQ   DS    CL2                     .\nCAMELEN  EQU   *-CAMDEVB1              .\n         ORG   CAMRET+20               .\nMSG      DS    CL255                   .\n         ORG   MSG+20                  .\nMSGX     DS    CL255                   .\n         ORG   ,                       .\nDF1      DS    CL3                     .\nDMIN     DS    CL4                     .\nDF2      DS    C                       .\nDSEC     DS    CL2                     .\nDF3      DS    C                       .\nDLEN     EQU   *-DF1                   .\n         ORG   DF1                     .\nDF       DS    CL(DLEN)                .\n         ORG   ,                       .\n         DS    0F                      .\nCAMLOC   CAMLST NAME,DSN,,CAMRET       . LOCATE FUNCTIONS\nMYRPL    RPL   ACB=JPCEMSG,AM=VSAM     .\nMYRPLL   EQU   *-MYRPL                 .\nWORKLEN  EQU   *-SAVE                  .\n         EJECT                         .\nJUMPTAB  DSECT                         .\nJUMP     DS    256F                    .\nUSERTEXT DSECT                         .\nUSERKEY  DS    C                       .\nUSER#    DS    C                       .\nUSERL1   DS    C                       .\nUSERTXT  DS    CL255                   .\nJESX006  CSECT                         .\n         $MODEND                       .\n         END\n//LKED      EXEC PGM=IEWL,REGION=256K,COND=(0,LT,ASM1),\n//             PARM=('LIST,LET,MAP,RENT')\n//SYSLIB      DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLIN      DD DSN=&&A,DISP=(OLD,DELETE)\n//            DD DDNAME=SYSIN          .\n//SYSLMOD     DD DISP=SHR,DSN=SYS2.LINKLIB\n//SYSPRINT    DD SYSOUT=*,DCB=(BLKSIZE=121,BUFNO=1)\n//SYSUT1      DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//SYSIN       DD *\n  NAME JESX006N(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JSTAT": {"ttr": 11268, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x009\\x01 \\x08\\x9f\\x01 \\x08\\x9f\\x19'\\x00\\xea\\x00\\xea\\x00\\x00[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-29T00:00:00", "modifydate": "2020-03-29T19:27:39", "lines": 234, "newlines": 234, "modlines": 0, "user": "$VNV"}, "text": "JSTAT    TITLE 'JSTAT-- TO LOCATE A JOB'\n         PRINT NOGEN\nJSTAT    CSECT\n*\n*-------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*\n*        PURPOSE - TO LOCATE JOB AND ISSUE WTO DEPENDING ON THE\n*              JOB STATUS. IF JOB IS RUNNING, WTO IS DONE FROM\n*              DDNAME 'FND', OTHERWISE, FROM 'NOTFND'.  IF 'RRFND' OR\n*              'RRNOTFND' IS FOUND THEN A 'WTOR' IS DONE AFTER THE\n*              WTO'S.\n*\n*        DATE WRITTEN - 06/04/84\n*              * CHG - VINH VU - 05/01/87 - TO FIX THE S0C4.\n*\n*        REGISTER USAGE :\n*\n*              R9       - RETURN CODE\n*              R12      - BASE\n*\n*        RETURN CODES :\n*\n*              0  --->  NO PARM SUPPLIED\n*              4  --->  JOB NAME AS SUPPLIED BY PARM IS FOUND TO BE\n*                       EXECUTING.  IF THE DDNAME 'FND' EXISTS THEN\n*                       ITS CONTENTS WILL BE WTO'ED.\n*              8  --->  JOB NAME AS SUPPLIED BY PARM IS NOT EXECUTING\n*                       IF THE DDNAME 'NOTFND' EXISTS THEN ITS\n*                       CONTENTS WILL BE WTO'ED.\n*\n*        REQUIRED JCL :\n*\n*              //         EXEC PGM=STAT,PARM='JOBNAME'\n*              //FND      DD DSN=           (OPTIONAL - FOR WTO)\n*              //NOTFND   DD DSN=           (OPTIONAL - FOR WTO)\n*              //RRFND    DD DSN=           (OPTIONAL - FOR WTO + WTOR)\n*              //RRNOTFND DD DSN=           (OPTIONAL - FOR WTO + WTOR)\n*              //SYSUDUMP DD SYSOUT=*       (OPTIONAL FOR DEBUGGING)\n*\n*        NOTE : IF BOTH 'RRFND' AND 'FND' ARE FOUND, 'RRFND' WILL TAKE\n*              PRECEDENCE.  I.E. ALL WTO WILL BE DONE USING TEXT FROM\n*              'RRFND' AND THEN A FINAL WTOR IS ALSO DONE AT THE END.\n*              SAME RULE APPLIES TO 'NOTFND' AND 'RRNOTFND'.\n*\n*-------------------------------------------------------------------\n*\nJSTAT    SET   (R12)\n*\n         SR    R9,R9               CLEAR RETURN CODE\n         L     R10,0(R1)           GET ADDR TO PARM\n         LH    R15,0(R10)          GET LENGTH\n         LTR   R15,R15             TEST FOR ZERO\n         BZ    ENDIT               IF ZERO THEN ENDIT\n         CH    R15,H8              COMPARE AGAINST '8'\n         BNH   GOODPARM            IF NOT HIGH THEN GO THRU\n         LA    R15,8               ELSE USE 8\n*\nGOODPARM EQU   *\n         BCTR  R15,R0              MINUS 1 FOR EXECUTE INSTRUCTION\n         EX    R15,SAVPARM         NOW SAVE PARM\n*\n*\n         XC    MYSSOB,MYSSOB       CLEAR MY AREA\n         MVC   MYSSOB+SSOBID-SSOB(4),=CL4'SSOB'\n         LA    R1,SSOBHSIZ         GET SIZE OF SSOB\n         STH   R1,MYSSOB+SSOBLEN-SSOB          STORE IT\n         LA    R1,SSOBSTAT         GET FUNCTION\n         STH   R1,MYSSOB+SSOBFUNC-SSOB         STORE IT\n         LA    R1,MYSSCS                       GET ADDR OF MY SSCS\n         ST    R1,MYSSOB+SSOBINDV-SSOB         STORE IT\n*\n         XC    MYSSCS(SSCSIZE),MYSSCS          CLEAR THE AREA\n         LA    R1,SSCSIZE          GET SSCS SIZE\n         STH   R1,MYSSCS+SSCSLEN-SSCSBGN       STORE IT\n         MVC   MYSSCS+SSCSJOBN-SSCSBGN(8),MYJOB      GET JOBNAME\n         MVC   MYSSCS+SSCSJOBI-SSCSBGN(8),BLANK      BLANK JOB ID\n         L     R1,=AL4(LENG)       GET MY SSCS SIZE\n         STH   R1,MYSSCS+SSCSDIMP-SSCSBGN      STORE IT\n*\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R1,MYADDR           GET THE ADDR INTO R1\n         IEFSSREQ\n         LR    R10,R15             SAVE RETURN CODE\n         MODESET KEY=NZERO,MODE=PROB\n*\n         LTR   R10,R10             TEST RETURN CODE\n         BNZ   BADREQ              IF BAD THEN ABEND\n         ICM   R10,B'1111',MYSSOB+SSOBRETN-SSOB   GET RETURN CODE\n         BZ    #FND                IF ZERO - THEN FOUND\n         CH    R10,H4              R15 = '4' ??\n         BE    #NOTFND             YEAH - NOT FOUND\n         WTO   'JSTAT002E - INVALID ''STATUS'' RETURN CODE',           *\n               ROUTCDE=(1,11),DESC=2\n         ABEND 888,DUMP            AND DUMP\n*\n#FND     EQU   *\n         LH    R1,MYSSCS+SSCSDIMR-SSCSBGN      GET ARRAYS USED\n         LA    R15,MYSSCS+SSCSARAY-SSCSBGN     GET MYSSCS ARRAY ADDR\n         AR    R1,R15              GET TO THE END OF DATA\n         ST    R1,SAVEEND          SAVE THIS\n         USING SSCSARAY,R15        ESTAB ADDRESSABILITY\n*\n#FNDLOOP EQU   *\n         C     R15,SAVEEND         COMPARE AGST ENDING ADDR\n         BNL   #NOTFND             IF NOT LOW - NOT FOUND\n         TM    SSCSFLG1,SSCSJACT   IS IT ACTIVE ??\n         BO    YEAH                YEAH - THEN GO THRU\n         TM    SSCSFLG1,SSCSEXCQ   IS IT WAITING ??\n         BO    YEAH                YEAH - THEN GO THRU\n         LA    R15,SSCSELSZ(,R15)  BUMP TO NEXT ADDR\n         B     #FNDLOOP            BACK TO LOOP\n*\nYEAH     EQU   *\n         LA    R9,4                RETURN AS 4\n*\n         MVC   MYDD,=CL8'RRFND'    CHECK FOR 'RRFND' (WTO + WTOR)\n         DEVTYPE MYDD,SIXF\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    OPENIT              IF 0 - THEN OPEN DATA SET\n         MVC   MYDD,=CL8'FND'      CHECK FOR 'FND' (WTO ONLY)\n         DEVTYPE MYDD,SIXF\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ENDIT               IF NOT 0 - THEN END THE WHOLE THING\n         B     OPENIT              ELSE - GO TO OPENIT\n*\n#NOTFND  EQU   *\n         LA    R9,8                RETURN AS 8\n*\n         MVC   MYDD,=CL8'RRNOTFND' CHECK FOR 'RRNOTFND' (WTO + WTOR)\n         DEVTYPE MYDD,SIXF\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    OPENIT              IF 0 - THEN OPEN DATA SET\n         MVC   MYDD,=CL8'NOTFND'   CHECK FOR 'NOTFND' (WTO ONLY)\n         DEVTYPE MYDD,SIXF\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   ENDIT               IF NOT 0 - THEN END THE WHOLE THING\n         B     OPENIT              ELSE - GO TO OPENIT\n*\nOPENIT   EQU   *\n         MVC   SYSIN+DCBDDNAM-IHADCB(8),MYDD     GET CORRECT DDNAME\n*\nREOPEN   EQU   *\n         OPEN  (SYSIN)\n         TM    DCBOFLGS-IHADCB+SYSIN,DCBOFOPN   OPEN GOOD ??\n         BC    7,DOWTO             YEAH - THEN DO WTO\n         B     ENDIT               ELSE - GOTO ENDFILE\n*\nDOWTO    EQU   *\n         GET   SYSIN,INREC         READ RECORD\n         MVC   @@WTO+8(80),INREC   MOVE TO WTO\n@@WTO    WTO   '                                                       *\n                                        ',ROUTCDE=(1,11),DESC=2\n         B     DOWTO               BACK TO READ\n*\n*\nENDFILE  EQU   *\n         CLOSE (SYSIN)\n         FREEPOOL SYSIN\n         CLC   SYSIN+DCBDDNAM-IHADCB(2),=CL2'RR'         WTOR REQ'ED ??\n         BNE   ENDIT               NOP - THEN THIS IS THE END\n*\nREWTOR   EQU   *\n         MVI   MYANS,C' '          CLEAR OUT REPLY AREA\n         XC    MYECB,MYECB         CLEAR OUT THE ECB\n         WTOR  'REPLY ''U'' TO PROCEED OR ''R'' TO RE-DISPLAY MESSAGES'*\n               ,MYANS,1,MYECB,ROUTCDE=(1,11)\n         WAIT  ECB=MYECB\n         OC    MYANS,BLANK         TURN IT TO UPPERCASE\n         CLI   MYANS,C'U'          IS IT 'U' ??\n         BE    ENDIT               YEAH - THEN END IT ALL\n         CLI   MYANS,C'R'          IS IT 'R' ??\n         B     REOPEN              YEAH - THEN RE-OPEN IT\n         B     REWTOR              ELSE - BACK TO RE-WTOR\n*\nENDIT    EQU   *\n         EXIT  R=R9\n*\n*\nBADREQ   EQU   *\n         WTO   'JSTAT001E - BAD RETURN CODE FROM IEFSSREQ',            *\n               ROUTCDE=(1,11),DESC=2\n         ABEND 999,DUMP            NOW DUMP\n*\n*\nSAVPARM  MVC   MYJOB(0),2(R10)     SAVE JOBNAME\n*\n*\nSYSIN    DCB   DSORG=PS,LRECL=80,RECFM=FB,MACRF=GM,DDNAME=SYSIN,       *\n               EODAD=ENDFILE\n         EJECT\n         LTORG\n*\nH8       DC    H'8'\nH4       DC    H'4'\n*\nBLANK    DC    CL8' '\n*\nMYANS    DC    C' '                WTOR REPLY\nMYECB    DC    F'0'                ECB USED FOR WTOR\n*\n         DS    0D\nMYDD     DC    CL8' '\nSIXF     DC    6F'0'\nSAVEEND  DC    F'0'\n*\nMYJOB    DC    CL8' '\nINREC    DC    CL80' '\n*\n         DS    0F\nMYSSOB   DS    CL(SSOBHSIZ)\n*\n         DS    0F\nMYADDR   DC    AL1(128),AL3(MYSSOB)    THE ONLY PARM PASSED TO IEFSSREQ\n*\n*\nLENG     EQU   300*SSCSELSZ            ALLOW 300 ARRAY ELEMENTS\nMYSSCS   DS    CL(LENG)\n         DS    ((14+62)*400)C          ALLOW FOR 2ND LEVEL MESSAGES\nTOTLENG  EQU   *-MYSSCS                JUST FOR ASSEM LISTING\n*\n*\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IEFJESCT\n         EJECT\n         IEFJSSOB (CS),CONTIG=NO\n         EJECT\n         DCBD  DSORG=PS\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JSTAT$": {"ttr": 11273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x94'\\x9f\\tD\\x00\\x17\\x00\\x0c\\x00\\x15[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1994-10-06T09:44:00", "lines": 23, "newlines": 12, "modlines": 21, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*\n//*--------------------------------------------------------------------\n//STAT     PROC JOB=\n//STEP1    EXEC PGM=JSTAT,PARM=&JOB,REGION=4M\n//STEPLIB  DD DSN=SYS3.TECH.LOAD,DISP=SHR              <== CHANGE\n//         PEND\n//*--------------------------------------------------------------------\n//*\n//$1       EXEC STAT,JOB=IMSPROD\n//$2       EXEC STAT,JOB=CICX\n//*********************************************************************\n//$3       EXEC STAT,JOB=IMSPROD\n//FND      DD *\nTEST JOB FOUND!\n//*********************************************************************\n//$4       EXEC STAT,JOB=CICX\n//FND      DD *\nTEST JOB FOUND!\n/*\n//NOTFND      DD *\nTEST JOB NOT FOUND!\n//*********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JSTAT#": {"ttr": 11275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x92\\x13\\x9f\\x00\\x94'\\x8f\\x177\\x00\\x0e\\x00\\x0c\\x00\\x07[\\xe5\\xd5\\xe5@@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-05-18T00:00:00", "modifydate": "1994-10-05T17:37:00", "lines": 14, "newlines": 12, "modlines": 7, "user": "$VNV"}, "text": "//$VNV5    JOB (7670,P4A1),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=$VNV\n//*--------------------------------------------------------------------\n//STEP1    EXEC ASMHCL\n//ASM.SYSLIB DD DSN=$VNV.CBT.PDS,DISP=SHR                <== CHANGE\n//         DD DSN=SYS1.HASPSRC,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//ASM.SYSIN DD DSN=$VNV.CBT.PDS(JSTAT),DISP=SHR          <== CHANGE\n//LKED.SYSLMOD DD DSN=$VNV.UTIL.SPFLOAD,DISP=SHR         <== CHANGE\n//LKED.SYSIN DD *\n SETCODE AC(1)\n NAME JSTAT(R)                                           <== CHANGE\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOCKTERM": {"ttr": 11277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x14\\x9f\\x00\\x92\\x14\\x9f\\x111\\x00\\x9a\\x00\\x9a\\x00\\x00[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-28T00:00:00", "modifydate": "1992-05-28T11:31:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "$WKS"}, "text": "LOCKTERM CSECT\n***********************************************************************\n*                                                                     *\n*  MODULE NAME:              LOCKTERM                                 *\n*                                                                     *\n*  MODULE TYPE:              TSO COMMAND                              *\n*                                                                     *\n*  LOAD MODULE NAME:         LOCKTERM                                 *\n*                                                                     *\n*  LOAD LIBRARY:             SYS2.LINKLIB                             *\n*                                                                     *\n*  ASSEMBLER ATTRIBUTES:     NONE                                     *\n*                                                                     *\n*  LKED ATTRIBUTES:          NONE                                     *\n*                                                                     *\n*  MODULE AUTHORIZATION:     NONE                                     *\n*                                                                     *\n*  MACROS:                   LOTS                                     *\n*                                                                     *\n*  MACRO LIBRARIES:          SYS1.MACLIB PTEC220.S.ASM                *\n*                                                                     *\n*  ABENDS:                   NONE                                     *\n*                                                                     *\n*  FUNCTION:                 TO LOCK UP A TERMINAL UNTIL THE          *\n*                            CORRECT PASSWORD IS ENTERED              *\n*                                                                     *\n*  PARAMETERS:               NONE                                     *\n*                                                                     *\n*  INTERNAL TABLES:          NONE                                     *\n*                                                                     *\n*  CALLED MODULES:           NONE                                     *\n*                                                                     *\n*  CALLING MODULES:          TMP                                      *\n*                                                                     *\n*  PROGRAM FLOW:             PROMPT FOR INITIAL PASSWORD              *\n*                                                                     *\n*                            LOOP UNTIL PASSWORD IS TYPED IN AGAIN    *\n*                                                                     *\n*  PARAMETER LAYOUTS:        NONE                                     *\n*                                                                     *\n*                                                                     *\n*  COPYRIGHT:                KIRK STICKEN                             *\n*                            APRIL 25, 1985                           *\n*                                                                     *\n*  AUTHOR:                   KIRK STICKEN                             *\n*                                                                     *\n*                                                                     *\n*  MODIFICATION RECORD:      NEW PROGRAM 04-25-85 KIRK STICKEN        *\n*                            MODIFY FOR X-A  5/1/86 KIRK STICKEN      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nLOCKTERM RMODE 24\nLOCKTERM AMODE 31\n         SPLEVEL SET=2\nBLANK    EQU   X'40'\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING LOCKTERM,R12\n         LA    R6,SAVE\n         ST    R6,8(R13)\n         ST    R13,4(R6)\n         LR    R13,R6\n         STFSMODE ON,INITIAL=YES       . START FULL SCREEN PROGRAM\nTPUT1    TPUT  KLEAR,KLEARL,FULLSCR    . CLEAR AND ISSUE WRITE ERASE\n         ESTAE EXIT1                   . PREPARE FOR THE WURST\n         STTMPMD OFF,KEYS=ALL          . I INTERCEPT ALL FKEYS NOW\nINITL    BAL   R9,PUTGET1              . PUT SCREEN AND GET RESPONSE\n         CLI   DATA1,X'00'             . DID USER ENTER ANYTHING\n         BE    INITL                   .    NOT HE.\n         MVC   PWD,DATA1               . SAVE PASSWORD\n         BALR  R10,0                   . SET LOOPBACK\nLOOP     BAL   R9,PUTGET               . GET USERS DATA\n         CLC   PWD,DATA1               . IS IT THE PASSWORD\n         BNER  R10                     . NO, LOOP FOREVER\n         B     FINAL                   . USER ENTER PWD, GET OUT\nEXIT1    DS    0H                      .\n         STM   R14,R12,12(R13)         .\n         BALR  R11,R0                  .\n         USING *,R11                   .\n         ESTAE 0                       .\n         STTMPMD ON,KEYS=NO            .\n         SETRP RC=0                    .\n         LM    R14,R12,12(R13)         .\n         BR    R14                     .\n         DROP  R11                     .\nPUTGET   NOPR  R1\nRESHOW1  TPUT  WORK,WORKL,FULLSCR\n         XC    DATA1(L'PWD),DATA1      . CLEAR PASSWORD AREA\n         TGET  PFK,L'PFK,ASIS\n         CLI   PFK,RESHOW              .\n         BE    RESHOW1                 .\n         BR    R9\nPUTGET1  NOPR  R1\nRESHOW2  TPUT  WORK1,WORK1L,FULLSCR\n         XC    DATA1(L'PWD),DATA1      . CLEAR PASSWORD AREA\n         TGET  PFK,L'PFK,ASIS\n         CLI   PFK,RESHOW              .\n         BE    RESHOW2                 .\n         BR    R9\nFINAL    DS    0H                      .\nRETURN   EQU   *\n         STTMPMD ON,KEYS=NO            . RESET TMP SCREEN MANAGMENT\n         ESTAE 0                       .\nTPUT2    TPUT  KLEAR,KLEARL,FULLSCR    . RESET TMP SCREEN MANAGMENT\n         STFSMODE OFF                  . RESET TMP SCREEN MANAGMENT\n         LH    R15,RETCODE      SET A VALID RETURN CODE\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\nSAVE     DS    18F\nRETCODE  DC    H'0'\nKLEAR    MFORM ESC,WRE,(1,1),IC,(1,2),(24,79,RA),NULL\nWORK     MFORM WCCA,(2,00032),A'P','TERMINAL LOCKUP',            XXXXXXX\n               (3,00025),(3,29,RA),NULL,                              XX\n               (3,00029),'Enter Your',                                XX\n               A'HP','Password:',A'O',IC,(3,00050),(3,065,RA),NULL,    X\n               (3,00058),A'P'\nWORK1    MFORM WCCA,(2,00032),A'P','TERMINAL LOCKUP',              XXXXX\n               (3,00025),'Enter Your',                                XX\n               A'HP','Initial Password:',A'O',IC,                      X\n               (3,00054),(3,00062,RA),NULL,A'P'\nPWD      DS    CL8                     .\nPFK      DS    CL1920\n         ORG   PFK                     .\nKEY1     DS    CL1                     .\nCURADDR  DS    CL2                     .\nSBA1     DS    CL1                     .\nDATA1DDR DS    CL2                     .\nDATA1    DS    CL(L'PFK-(*-KEY1))      .\n         ORG ,                         .\n         M3270\n         DSECT\n         IHASDWA ,                     .\n         END   LOCKTERM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MFORM": {"ttr": 11521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x81\\x08o\\x00\\x81\\x08o\\x14R\\x00P\\x00O\\x00\\x07\\xe7\\xc4\\xf1\\xf7\\xf0\\xf3\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1981-03-27T00:00:00", "modifydate": "1981-03-27T14:52:00", "lines": 80, "newlines": 79, "modlines": 7, "user": "XD17035"}, "text": "         MACRO\n&NAME    MFORM   &X\n         GBLC    &NAMEX\n         LCLA    &I,&J,&K\n         LCLC    &C\n         AIF     ('&NAME' EQ '').GO\n&NAME    DS    0C               START OF SCREEN\n&NAMEX   SETC    '&NAME'\n.GO      AIF     (&I EQ N'&SYSLIST).END\n&I       SETA    &I+1\n         AIF     (N'&SYSLIST(&I) EQ 2).ADD\n         AIF     (N'&SYSLIST(&I) EQ 3).ADD\n         AIF     ('&SYSLIST(&I)'(1,2) EQ 'A''').WCC\n         AIF     ('&SYSLIST(&I)'(1,2) EQ 'W''').WCC\n         AIF     ('&SYSLIST(&I)'(1,1) EQ '''').CON\n         AIF     ('&SYSLIST(&I)' EQ 'NEND').MEXIT\n         DC    AL1(&SYSLIST(&I))\n         AGO     .GO\n.CON     DC    C&SYSLIST(&I)\n         AGO     .GO\n.WCC     ANOP    ,\n&J       SETA    1\n&K       SETA    0\n.SC      AIF     (&J EQ K'&SYSLIST(&I)).GEN\n&J       SETA    &J+1\n&C       SETC    '&SYSLIST(&I)'(&J,1)\n         AIF     ('&C' EQ '''').SC\n         AIF     ('&C' EQ ' ').SC\n         AIF     ('&C' NE 'R').NOR\n&K       SETA    &K+1\n         AGO     .SC\n.NOR     AIF     ('&C' NE 'K').NOK\n&K       SETA    &K+2\n         AGO     .SC\n.NOK     AIF     ('&C' NE 'A').NOA\n&K       SETA    &K+4\n         AGO     .SC\n.NOA     AIF     ('&C' NE 'P').NOP\n&K       SETA    &K+32\n         AGO     .SC\n.NOP     AIF     ('&C' NE 'S').NOS\n&K       SETA    &K+48\n         AGO     .SC\n.NOS     AIF     ('&C' NE 'N').NON\n&K       SETA    &K+16\n         AGO     .SC\n.NON     AIF     ('&C' NE 'H').NOH\n&K       SETA    &K+8\n         AGO     .SC\n.NOH     AIF     ('&C' NE 'O').NOO\n&K       SETA    &K+12\n         AGO     .SC\n.NOO     AIF     ('&C' NE 'M').NOM\n&K       SETA    &K+1\n         AGO     .SC\n.NOM     MNOTE   8,'INVALID CODE ''&C'''\n         AGO     .SC\n.GEN     AIF     ('&SYSLIST(&I)' EQ 'W').GWCC\n         MSIXBIT &K,,SF\n         AGO     .GO\n.GWCC    MSIXBIT &K\n         AGO     .GO\n.ADD     AIF     (&SYSLIST(&I,1) GT 24).AERR1\n         AIF     (&SYSLIST(&I,2) GT 80).AERR2\n&J       SETA    (&SYSLIST(&I,1)-1)*80+&SYSLIST(&I,2)-1\n&K       SETA    &J/64\n&J       SETA    &J-&K*64\n         AIF     (N'&SYSLIST(&I) EQ 3).SPE\n         MSIXBIT &K,&J,SBA\n         AGO     .GO\n.AERR1   MNOTE   8,'INVALID SCREEN ADDRES ''&SYSLIST(&I,1)'''\n         AGO     .GO\n.AERR2   MNOTE   8,'INVALID SCREEN ADDRESS ''&SYSLIST(&I,2)'''\n         AGO     .GO\n.SPE     MSIXBIT &K,&J,&SYSLIST(&I,3)\n         AGO     .GO\n.END     AIF     ('&NAMEX' EQ '').MEXIT\n&NAMEX.L EQU     *-&NAMEX\n&NAMEX   SETC    ''\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSIXBIT": {"ttr": 11524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x81\\x08o\\x00\\x86\\x12\\x1f\\t\\x08\\x00(\\x00\\x03\\x00&[\\xe6\\xd2\\xe2@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1981-03-27T00:00:00", "modifydate": "1986-05-01T09:08:00", "lines": 40, "newlines": 3, "modlines": 38, "user": "$WKS"}, "text": "         MACRO\n         MSIXBIT &X,&Y,&Z\n         LCLA    &I,&J\n         LCLC    &A(8),&OUT1,&OUT2\n&A(1)    SETC    ' ABCDEFG'\n&A(2)    SETC    'HI\u00a2.<(+|'\n&A(3)    SETC    ' JKLMNOP'\n&A(4)    SETC    'QR!$*);\u00ac'\n&A(5)    SETC    '-/STUVWX'\n&A(6)    SETC    'YZ \u00a6,%_>?'\n&A(7)    SETC    '01234567'\n&A(8)    SETC    '89:#@ =\"'\n         AIF     (&X EQ 16).AMP1\n         AIF     (&X EQ 61).QUO1\n&J       SETA    &X/8+1\n&I       SETA    &X+1-(&J-1)*8\n&OUT1    SETC    '&A(&J)'(&I,1)\n         AGO     .NOQ1\n.QUO1    ANOP    ,\n&OUT1    SETC    ''''''\n         AGO     .NOQ1\n.AMP1    ANOP    ,\n&OUT1    SETC    '&&'\n.NOQ1    AIF     ('&Y' EQ '').NOY\n         AIF     (&Y EQ 16).AMP2\n         AIF     (&Y EQ 61).QUO2\n&J       SETA    &Y/8+1\n&I       SETA    &Y+1-(&J-1)*8\n&OUT2    SETC    '&A(&J)'(&I,1)\n         AGO     .NOY\n.QUO2    ANOP    ,\n&OUT2    SETC    ''''''\n         AGO     .NOY\n.AMP2    ANOP    ,\n&OUT2    SETC    '&&'\n.NOY     AIF     ('&Z' EQ '').NOZ\n         DC    AL1(&Z),C'&OUT1&OUT2'\n         MEXIT\n.NOZ     DC    C'&OUT1&OUT2'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "M3270": {"ttr": 11526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x81\\x08o\\x00\\x85\\x01o\\x071\\x004\\x00\\x12\\x00$\\xd7\\xe3\\xc5\\xc3\\xf2\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1981-03-27T00:00:00", "modifydate": "1985-01-16T07:31:00", "lines": 52, "newlines": 18, "modlines": 36, "user": "PTEC220"}, "text": "         MACRO\n         M3270\nDUP      EQU   X'1C'         DUPLICATE\nEUA      EQU   X'12'         ERASE UNPROTECTED TO ADDRESS\nFM       EQU   X'1E'         FIELD MARK\nNL       EQU   X'15'         NEW LINE\nIC       EQU   X'13'         INSERT CURSOR\nNULL     EQU   X'00'         EASY TO PUT A PLACE HOLDER IN SCREEN\nPT       EQU   X'05'         PROGRAM TAB\nRA       EQU   X'3C'         REPEAT TOADDRESS\nSBA      EQU   X'11'         SET BUFFER ADDRESS\nSF       EQU   X'1D'         START FIELD(ATTRIBUTE CHARS)\nESC      EQU   X'27'         ESCAPE CHAR TO PRECEDE COMMAND CODE\nWR       EQU   X'F1'         WRITE\nWRE      EQU   X'F5'         WRITE ERASE\nWREA     EQU   X'7E'         WRITE ERASE ALTERNATE\nRDB      EQU   X'F2'         READ BUFFER\nRDM      EQU   X'F6'         READ MODIFIED\nEAUC     EQU   X'6F'         ERASE ALL UNPROTECTED\nWCCA     EQU   X'C1'         WRITE FOR CLEAR\nPF1      EQU   C'1'\nPF2      EQU   C'2'\nPF3      EQU   C'3'\nPF4      EQU   C'4'\nPF5      EQU   C'5'\nPF6      EQU   C'6'\nPF7      EQU   C'7'\nPF8      EQU   C'8'\nPF9      EQU   C'9'\nPF10     EQU   X'7A'\nPF11     EQU   X'7B'\nPF12     EQU   X'7C'\nPF13     EQU   C'A'\nPF14     EQU   C'B'\nPF15     EQU   C'C'\nPF16     EQU   C'D'\nPF17     EQU   C'E'\nPF18     EQU   C'F'\nPF19     EQU   C'G'\nPF20     EQU   C'H'\nPF21     EQU   C'I'\nPF22     EQU   X'4A'\nPF23     EQU   X'4B'\nPF24     EQU   X'4C'\nENTER    EQU   X'7D'\nLITPEN   EQU   X'7E'\nPA1      EQU   X'6C'\nCLEAR    EQU   X'6D'\nPA2      EQU   X'6E'\nRESHOW   EQU   X'6E'\nPA3      EQU   X'6B'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SEEK": {"ttr": 11528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x93\\x07\\x7f\\x01\\x005_\\x08'\\x02\\xe1\\x02\\xbe\\x00\\x00\\xd5\\xd4\\xe5\\xe5\\xf1@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-03-18T00:00:00", "modifydate": "2000-12-20T08:27:00", "lines": 737, "newlines": 702, "modlines": 0, "user": "NMVV1"}, "text": "SEEK     TITLE 'SEEK -- TO LOCATE A MODULE'\n         PRINT NOGEN\nSEEK     CSECT\nSEEK     AMODE 31\nSEEK     RMODE ANY\n*-------------------------------------------------------------------\n*\n*        AUTHOR - VINH VU\n*        PURPOSE - TO LOCATE A MODULE IN EITHER STEPLIB, JOBLIB\n*              OR LINKLIST.\n*        DATE WRITTEN - 11/04/81\n*        MACROS USED - SET, EXIT, BLDL, TPUT, DCB, IKJPARM,\n*              IKJPOSIT, IKJENDP, CVT, IKJCPPL, IKJPPL, IHALPDE.\n*\n*-------------------------------------------------------------------\n*\n*        USAGE OF REGS -\n*\n*              R0  - WORK\n*              R1  - WORK\n*              R2  - WORK\n*              R3  - WORK\n*              R4  - WORK\n*              R5  - WORK\n*              R6  - WORK\n*              R7  - USED AS PDL BASE\n*              R8  - USED AS PPL BASE\n*              R9  - USED AS RETURN ADDR FOR SUB ROUTINE\n*              R10 - CPPL ADDR\n*              R11 - WORK\n*              R12 - BASE FOR PROG\n*              R13 - BASE FOR SAVE & GETMAINED AREA\n*              R14 - USED AS RETURN ADDR FOR SUB ROUTINE\n*              R15 - WORK\n*\n*        ABENDS -\n*\n*              10  - TPUT ERROR\n*              20  - IKJPARS ERROR\n*\n*-------------------------------------------------------------------\n*\n*        MODIFIED - VINH VU - 03/16/93 - CHANGE ALL 'TPUT' TO 'PUTLINE'\n*        ALSO ADDED THE SEARCH FOR MLPA/FLPA QUEUE.  THE LINKLIST\n*        DATA SET NAME IS NOW ALSO DISPLAYED (ACCESS 'LLT').\n*        MORE INFORMATION (MODULE ATTRIBUTES) WILL BE DISPLAYED IF\n*        FOUND IN ANY LPA QUEUE.\n*\n*        CHANGED - VINH VU - 10/27/00 - CHANGE TO ACCESS THE 'CURRENT'\n*        DYNAMIC LINKLIST SET.\n*\n*-------------------------------------------------------------------\n*\n         SET   DSECT=WKAREA,LV=WKLENG\n         MVI   FNDSW,X'00'         INIT FOUND SW\n         MVC   WKNAME,BLANK        BLANK OUT THE NAME\n         LR    R10,R1              GET CPPL ADDR\n         USING CPPL,R10            ESTAB ADDR\n         XC    WKPPL,WKPPL         CLEAR OUT PPL\n         LA    R8,WKPPL            GET ADDR OF PPL\n         USING PPL,R8              ESTAB ADDR\n         MVC   PPLUPT,CPPLUPT      GET UPT\n         MVC   PPLECT,CPPLECT      GET ECT\n         XC    MYECB,MYECB         CLEAR MY ECB\n         LA    R1,MYECB            GET A(ECB)\n         ST    R1,PPLECB           GET ECB\n         MVC   PPLPCL,APCL         GET PPLPCL\n         LA    R1,ANS\n         ST    R1,PPLANS           GET ANS\n         MVC   PPLCBUF,CPPLCBUF    GET CBUF\n         CALLTSSR EP=IKJPARS,MF=(E,WKPPL)\n         LTR   R15,R15\n         BNZ   ABEND020\n         L     R7,ANS              GET ANS\n         LA    R1,0(0,R7)          CLEAR OUT TRASH\n         LTR   R1,R1               CHECK IF ANS IS THERE\n         BZ    ABEND020            NOP - THEN ABEND\n         USING IKJPARMD,R7         ESTAB ADDR\n         TM    MODNAME+6,X'80'     MODULE NAME THERE ?\n         BZ    ABEND020            NO - THEN ABEND\n         L     R1,MODNAME          GET PTR TO MODNAME\n         LH    R2,MODNAME+4        GET LENG\n         STC   R2,SAVELENG         SAVE THE LENG\n         BCTR  R2,R0               MINUS 1 FOR MVC\n         EX    R2,MVCIT            MOVE MODNAME\n         MVC   WKFF,H1\n         LA    R1,WKENTL           GET ENTRY LENG\n         STCM  R1,B'0011',WKLL     STORE LENG INTO LIST\n         BLDL  0,WKLIST\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   CKMFLPA             IS NON ZERO THEN CHECK LPA\n         B     ANALYZE             GOTO ANALYZE IT\n*\n*\nMVCIT    MVC   WKNAME(0),0(R1)\n*\n*--------------\n*        MODULE IS FOUND IN EITHER LINKLIST OR JOBPACK AREA.\n*--------------\n*\nANALYZE  EQU   *\n         OI    FNDSW,$FNDSTEP      TURN ON FND SW\n         MVC   WKPRINT,MSG01       GET FIRST LINE\n         MVC   WKPRINT+11(L'WKNAME),WKNAME\n         LA    R1,WKPRINT+11       GET BEGIN ADDR OF MODNAME\n         XR    R15,R15             CLEAR REG 15\n         IC    R15,SAVELENG        GET LENG OF MODNAME\n         LA    R1,0(R15,R1)        GET TO THE END OF MODNAME\n         MVC   0(L'MSG01A,R1),MSG01A\n*\n         UNPK  WKDWORD(7),WKTTR(4)      GET TTR\n         TR    WKDWORD(6),NUMTRT-240    MAKE THIS PRINTABLE\n         MVC   18(6,R1),WKDWORD    MOVE THIS TO MESSAGE LINE\n*\n         LA    R1,WKPRINT          GET ADDR OF PUTLINE AREA\n         LA    R15,L'WKPRINT       GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         SR    R1,R1               CLEAR REG 1\n         IC    R1,WKK              GET THE CONCAT NUMBER\n         CVD   R1,WKDWORD          CONVERT TO PACK NUMBER\n         UNPK  SAVENUM,WKDWORD+6(2)\n         OI    SAVENUM+2,X'F0'     MAKE IT PRINTABLE\n*\n         SR    R11,R11             CLEAR REG 11\n         IC    R11,WKZ             GET THE Z\n*\n*\n*-------------------------------------------------------------------\n*        THIS ROUTINE IS TO CHECK IF MODULE CAME FROM A PRIVATE\n*        LIBRARY.\n*-------------------------------------------------------------------\n*\nCHECK0   EQU   *\n         C     R11,F0              IS IT PRIVATE LIBRARY ?\n         BH    CHECK1              NOP - THEN CHECK FOR 1\n         MVC   WKPRINT,MSG02            - GET MSG\n         B     STEPLBPR            THEN GOTO PRINT IT\n*\n*\n*-------------------------------------------------------------------\n*        THIS ROUTINE IS TO CHECK IF MODULE CAME FROM A LINKLIST\n*        LIBRARY.  IF IT IS, WILL DISPLAY MESSAGE AND THEN GO ON\n*        TO CHECK IN LPA.\n*-------------------------------------------------------------------\n*\nCHECK1   EQU   *\n         C     R11,F1              IS IT LINK LIBRARY ?\n         BH    CHECK2              NOP - THEN CHECK FOR 2\n*\n         MVC   WKPRINT,MSG03            GET MSG\n         MVC   WKPRINT+36(3),SAVENUM    GET CONCAT NUMBER\n*\n         LA    R1,WKPRINT          GET ADDR OF PUTLINE AREA\n         LA    R15,L'WKPRINT       GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         SR    R15,R15             CLEAR REG15\n         IC    R15,WKK             GET CONCAT # FOR LNKLST DSAT\n         MH    R15,H45             MULT BY LLT ENTRY LENG\n*\n         L     R1,PSAAOLD-PSA      GET ASCB ADDRESS\n         L     R1,ASCBASSB-ASCB(R1)    GET ASSB ADDRESS\n         L     R1,ASSBDLCB-ASSB(R1)    GET DLCB ADDRESS\n         MVC   LNKLSTNM,DLCBLNKLSTSETNAME-DLCB(R1)    SAVE LNKLSTSETNM\n         L     R1,DLCBLLT@-DLCB(R1)    GET LLT ADDRESS\n*\n*        L     R1,CVTPTR           GET CVT POINTER\n*        USING CVTMAP,R1\n*        L     R1,CVTLLTA          GET LLT ADDRESS\n*        DROP  R1\n*\n         LA    R1,8(R15,R1)        GO TO THE LLT ENTRY\n         MVC   WKPRINT,MSG03A      GET MSG\n         MVC   WKPRINT+18(44),1(R1)     GET DSN\n         SR    R15,R15             CLEAR REG15\n         IC    R15,0(R1)           GET LENG OF DSN\n         LA    R1,WKPRINT+18(R15)  GO TO THE END OF DSN\n         MVI   0(R1),C''''         PUT IN ENDING QUOTES\n         MVI   1(R1),C')'\n*\n         LA    R1,WKPRINT          GET ADDR OF PUTLINE AREA\n         LA    R15,L'WKPRINT       GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         MVC   WKPRINT,MSG03B           GET MSG\n         MVC   WKPRINT+26(L'LNKLSTNM),LNKLSTNM\n         LA    R1,WKPRINT          GET ADDR OF PUTLINE AREA\n         LA    R15,L'WKPRINT       GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         B     CKMFLPA             NOW GO CHECK LPA\n*\n*\n*-------------------------------------------------------------------\n*        THIS ROUTINE IS TO CHECK IF MODULE CAME FROM A STEP OR JOB\n*        OR TASK LIBRARY.\n*-------------------------------------------------------------------\n*\nCHECK2   EQU   *\n         C     R11,F2              IS IT JOB, TASK OR STEP LIBRARY ?\n         BH    CHECK3              NOP - THEN IT BELONGS TO PARENT TASK\n         MVC   WKPRINT,MSG04       ELSE - GET MSG\n         B     STEPLBPR            THEN GOTO PRINT IT\n*\nCHECK3   EQU   *\n         LA    R1,MSG05            MOD FORM PARENT TASK LIBRARY\n         LA    R15,L'MSG05\n         BAL   R14,WLINE\n*\n         MVC   WKPRINT,MSG05A      GET MSG\n         B     STEPLBPR            THEN GOTO PRINT IT\n*\n*\n*\n*\n*--------------\n*        THIS ROUTINE WILL PRINT OUT MESSAGE FOR A MODULE FOUND\n*        IN STEPLIB (OR JOBPACK AREA), NOT FROM LINKLIST.\n*        IF A MODULE IS FOUND IN LINKLIST, IT WILL BE PRINTED IN\n*        'CHECK1' ROUTINE.\n*--------------\n*\nSTEPLBPR EQU   *\n         MVC   WKPRINT+46(3),SAVENUM    GET CONCAT NUMBER\n*\n         LA    R1,WKPRINT          GET ADDR OF PUTLINE AREA\n         LA    R15,L'WKPRINT       GET LENG OF MESSAGE\n         BAL   R14,WLINE           ISSUE THE PUTLINE\n*\n         B     CKMFLPA             GOTO CHECK LPA\n         EJECT\n*\n*\n*\n*-------------------------------------------------------------------\n*        THIS ROUTINE IS TO CHECK IF MODULE CAME FROM FLPA/MLPA\n*-------------------------------------------------------------------\n*\nCKMFLPA  EQU   *\n         L     R1,CVTPTR           GET CVT POINTER\n         USING CVTMAP,R1           ESTAB ADDR\n         L     R11,CVTQLPAQ        GET MLPA DIR ENTRIES\n         USING CDENTRY,R11         ESTAB ADDR\n         DROP  R1\n*\nMFLOOP   EQU   *\n         CLC   CDCHAIN,F0          END OF TABLE\n         BE    CKLPA               YEAH - THEN CHECK PLPA\n         CLC   CDNAME,WKNAME       NAME MATCH ?\n         BE    FNDMFLPA            YEAH - THEN FOUND IT\n         L     R11,CDCHAIN         ELSE - BUMP TO NEXT ENTRY\n         B     MFLOOP              AND GOBACK TO LOOP\n*\nFNDMFLPA EQU   *\n         OI    FNDSW,$FNDMF        TURN ON FND SW\n*\n         MVC   WKPRINT,MSG01       GET FIRST LINE\n         MVC   WKPRINT+11(L'WKNAME),WKNAME\n         LA    R1,WKPRINT+11       GET BEGIN ADDR OF MODNAME\n         SR    R15,R15             CLEAR REG 15\n         IC    R15,SAVELENG        GET LENG OF MODNAME\n         LA    R1,0(R15,R1)        GET TO THE END OF MODNAME\n         MVC   0(L'MSG01B,R1),MSG01B\n*\n         TM    FNDSW,$FNDSTEP      MOD FOUND ALREADY IN STEPLIB ?\n         BZ    FNDMFONL            NOOP - ONLY FOUND HERE\n         MVC   L'MSG01B(L'MSG01G,R1),MSG01G\n         LA    R1,BLANK            PRINT OUT ONE BLANK LINE\n         LA    R15,L'BLANK\n         BAL   R14,WLINE\n*\nFNDMFONL EQU   *\n         LA    R1,WKPRINT          GET ADDR OF MSG\n         LA    R15,L'WKPRINT       GET LENG OF MSG\n         BAL   R14,WLINE           AND DISPLAY\n*\n         MVC   WKDWORD(4),CDENTPT  MOVE ADDR TO A TEMP AREA\n         NI    WKDWORD,X'FF'-CDEMODE    TURN OFF THE 31-BIT MODE FLAG\n         UNPK  WKPRINT(9),WKDWORD(5)\n         TR    WKPRINT(8),NUMTRT-240    SAVE ENTRY POINT\n         MVC   MENTPT,WKPRINT\n*\n         MVC   M31BIT,$31BIT       DEFAULT - YES\n         TM    CDENTPT,CDEMODE     IS IT REALLY ?\n         BO    MFCOUNT             YES - GO GET USE COUNT\n         MVC   M31BIT,#31BIT       ELSE - SAY NO\n*\nMFCOUNT  EQU   *\n         LH    R1,CDUSE            GET USE COUNT\n         CVD   R1,WKDWORD          CONVERT TO PACKED DECIMAL\n         UNPK  MUSECNT,WKDWORD     UNPACK\n         OI    MUSECNT+L'MUSECNT-1,X'F0'\n*\n         MVC   MRENT,$RENT         ASSUME DEFAULT AS 'RENT'\n         TM    CDATTR,CDREN        IS IT REALLY ?\n         BO    MFCKRES             YEAH - GO CHECK FOR 'REUSE'\n         MVC   MRENT,#RENT         ELSE - SAY NO\n*\nMFCKRES  EQU   *\n         MVC   MREUSE,$REUSE       ASSUME DEFAULT AS 'REUSE'\n         TM    CDATTR,CDSER        IS IT REALLY ?\n         BO    MFCKAC              YEAH - GO CHECK FOR 'AC=X'\n         MVC   MREUSE,#REUSE       ELSE - SAY NO\n*\nMFCKAC   EQU   *\n         MVC   MAUTH,$AUTH         ASSUME DEFAULT AS 'AUTH'\n         TM    CDATTR2,CDAUTH      IS IT REALLY ?\n         BO    MFCKLIB             YEAH - GO PRINT\n         MVC   MAUTH,#AUTH         ELSE - SAY NO\n*\nMFCKLIB  EQU   *\n         MVC   MAPF,$APF           ASSUME DEFAULT AS 'APF-LIB'\n         TM    CDATTR2,CDSYSLIB    IS IT REALLY ?\n         BO    LPAPRINT            YEAH - GO PRINT\n         MVC   MAPF,#APF           ELSE - SAY NO\n*\n         B     LPAPRINT            NOW DO THE PRINT\n         DROP  R11\n*\n*\n*\n*-------------------------------------------------------------------\n*        THIS ROUTINE IS TO CHECK IF MODULE CAME FROM PLPA\n*-------------------------------------------------------------------\n*\nCKLPA    EQU   *\n         L     R1,CVTPTR           GET CVT POINTER\n         USING CVTMAP,R1           ESTAB ADDR\n         SR    R11,R11             CLEAR REG 11\n         ICM   R11,B'0111',CVTLPDIR     GET LPA DIR ENTRIES\n         USING LPDE,R11            ESTAB ADDR\n         DROP  R1\n*\nLOOP     EQU   *\n         CLC   LPDENAME,=8X'FF'    END OF TABLE\n         BE    ENDIT               YEAH - THEN NOT FOUND\n         CLC   LPDENAME,WKNAME     NAME MATCH ?\n         BE    FNDIT               YEAH - THEN FOUND IT\n         LA    R11,LPDELENG(0,R11) ELSE - BUMP TO NEXT ENTRY\n         B     LOOP                AND GOBACK TO LOOP\n*\nFNDIT    EQU   *\n         OI    FNDSW,$FNDPLPA      TURN ON FND SW\n*\n         MVC   WKPRINT,MSG01       GET FIRST LINE\n         MVC   WKPRINT+11(L'WKNAME),WKNAME\n         LA    R1,WKPRINT+11       GET BEGIN ADDR OF MODNAME\n         SR    R15,R15             CLEAR REG 15\n         IC    R15,SAVELENG        GET LENG OF MODNAME\n         LA    R1,0(R15,R1)        GET TO THE END OF MODNAME\n         MVC   0(L'MSG01C,R1),MSG01C\n*\n         TM    FNDSW,$FNDSTEP      MOD FOUND ALREADY IN STEPLIB ?\n         BZ    FNDITONL            NOOP - ONLY FOUND HERE\n         MVC   L'MSG01C(L'MSG01G,R1),MSG01G\n         LA    R1,BLANK            PRINT OUT ONE BLANK LINE\n         LA    R15,L'BLANK\n         BAL   R14,WLINE\n*\nFNDITONL EQU   *\n         LA    R1,WKPRINT          GET ADDR OF MSG\n         LA    R15,L'WKPRINT       GET LENG OF MSG\n         BAL   R14,WLINE           AND DISPLAY\n*\n         MVC   WKDWORD(4),LPDENTP  MOVE ADDR TO A TEMP AREA\n         NI    WKDWORD,X'FF'-LPDEMODE   TURN OFF 31-BIT MODE FLAG\n         UNPK  WKPRINT(9),WKDWORD(5)\n         TR    WKPRINT(8),NUMTRT-240    SAVE ENTRY POINT\n         MVC   MENTPT,WKPRINT\n*\n         MVC   M31BIT,$31BIT       DEFAULT - YES\n         TM    LPDENTP,LPDEMODE    IS IT REALLY ?\n         BO    DOCOUNT             YES - GO GET USE COUNT\n         MVC   M31BIT,#31BIT       ELSE - SAY NO\n*\nDOCOUNT  EQU   *\n         LH    R1,LPDEUSE          GET USE COUNT\n         CVD   R1,WKDWORD          CONVERT TO PACKED DECIMAL\n         UNPK  MUSECNT,WKDWORD     UNPACK\n         OI    MUSECNT+L'MUSECNT-1,X'F0'\n*\n         MVC   MRENT,$RENT         ASSUME DEFAULT AS 'RENT'\n         TM    LPDEATTR,LPDEREN    IS IT REALLY ?\n         BO    CKRES               YEAH - GO CHECK FOR 'REUSE'\n         MVC   MRENT,#RENT         ELSE - SAY NO\n*\nCKRES    EQU   *\n         MVC   MREUSE,$REUSE       ASSUME DEFAULT AS 'REUSE'\n         TM    LPDEATTR,LPDESER    IS IT REALLY ?\n         BO    CKAC                YEAH - GO CHECK FOR 'AC=X'\n         MVC   MREUSE,#REUSE       ELSE - SAY NO\n*\nCKAC     EQU   *\n         MVC   MAUTH,$AUTH         ASSUME DEFAULT AS 'AC=1'\n         TM    LPDEATT2,LPDEAUTH   IS IT REALLY ?\n         BO    CKLIB               YEAH - GO CHECK FOR 'APF-LIB'\n         MVC   MAUTH,#AUTH         ELSE - SAY NO\n*\nCKLIB    EQU   *\n         MVC   MAPF,$APF           ASSUME DEFAULT AS 'APF-LIB'\n         TM    LPDEATT2,LPDESYSL   IS IT REALLY ?\n         BO    LPAPRINT            YEAH - GO PRINT\n         MVC   MAPF,#APF           ELSE - SAY NO\n*\n         B     LPAPRINT\n         DROP  R11\n*\n*\nLPAPRINT EQU   *\n         LA    R1,MSG01D           GET ADDR OF MSG\n         LA    R15,L'MSG01D        GET LENG OF MSG\n         BAL   R14,WLINE           AND DISPLAY\n*\n         MVC   WKPRINT,BLANK\n         MVC   WKPRINT(L'MSG01E),MSG01E\n         MVC   WKPRINT+12(L'MENTPT),MENTPT\n         MVC   WKPRINT+24(L'M31BIT),M31BIT\n         MVC   WKPRINT+30(L'MUSECNT),MUSECNT\n         MVC   WKPRINT+38(L'MRENT),MRENT\n         MVC   WKPRINT+45(L'MREUSE),MREUSE\n         MVC   WKPRINT+53(L'MAUTH),MAUTH\n         MVC   WKPRINT+58(L'MAPF),MAPF\n         LA    R1,WKPRINT          GET ADDR OF MSG\n         LA    R15,L'WKPRINT       GET LENG OF MSG\n         BAL   R14,WLINE           AND DISPLAY\n         B     EXITIT\n*\n*\nENDIT    EQU   *\n         TM    FNDSW,$FNDONE       FOUND ANY ?\n         BNZ   EXITIT              YEAH - THEN END IT\n         MVC   WKPRINT,MSG01       GET MSG\n         MVC   WKPRINT+11(L'WKNAME),WKNAME\n         LA    R1,WKPRINT+11       GET BEGINNING ADDR OF MODNAME\n         XR    R15,R15             CLEAR REG 15\n         IC    R15,SAVELENG        GET LENG OF MODNAME\n         LA    R1,0(R15,R1)        GET TO END OF MODNAME\n         MVC   0(L'MSG01F,R1),MSG01F\n         LA    R1,WKPRINT\n         LA    R15,L'WKPRINT\n         BAL   R14,WLINE\n*\nEXITIT   EQU   *\n         EXIT\n         EJECT\n*\n*\n*---------------\n*        AT ENTRY TO WLINE, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  THIS IS THE MSG BUFFER TO BE DISPLAYED.\n*---------------\n*\nWLINE    EQU   *\n         ST    R14,SAVE14          SAVE RETURN ADDRESS\n         MVC   WMSGLENG,H84        MOVE LENG TO PUTLINE WKAREA\n         XC    WMSGRES,WMSGRES     CLEAR OUT THE RESERVED AREA\n         MVI   WMSG,X'40'          CLEAR OUT MESSAGE AREA\n         MVC   WMSG+1(L'WMSG-1),WMSG\n         CH    R15,=AL2(L'WMSG)    IS MESSAGE GOING TO FIT ??\n         BNH   WLINERDY            YEAH - THEN GO ON\n         LH    R15,=AL2(L'WMSG)    ELSE - USE MAX LENG\n*\nWLINERDY EQU   *\n         BCTR  R15,R0              SUBTRACT 1 FOR 'EX' INSTRUCTION\n         EX    R15,WMOVEMSG        NOW MOVE MSG TO WKAREA\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WPUTBLOK,PUTBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         PUTLINE PARM=WPUTBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               OUTPUT=(WMSGLENG,TERM,SINGLE,DATA),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    WLINEOK             IF ZERO THEN GET READY TO TERMINATE\n         ABEND 10\n*\nWLINEOK  EQU   *\n         L     R14,SAVE14          LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nWMOVEMSG MVC   WMSG(0),0(R1)       MOVE MESSAGE TO PUTLINE WKAREA\n*\n*\n         EJECT\n*\n*---------------\n*        AT ENTRY TO GETBUF, R1 POINTS TO OUTPUT BUFFER, R15 POINTS TO\n*        ITS LENGTH.  IF THE GETLINE WORKS, THE INPUT BUFFER (DATA\n*        RETURNED BY GETLINE) WILL BE COPIED TO THIS AREA.\n*---------------\n*\n*\nGETBUF   EQU   *\n         ST    R14,SAVE14          SAVE RETURN ADDRESS\n         ST    R1,OUTPTR           SAVE THE BUFFER POINTER\n         ST    R15,OUTLENG         SAVE THE BUFFER LENGTH\n         XC    ECBADS,ECBADS       CLEAR OUT THE ECB\n         XC    IOPLADS,IOPLADS     CLEAR OUT THE IOPL\n         MVC   WGETBLOK,GETBLOK    MOVE PUTLINE LISTFORM TO WKAREA\n         L     R3,CPPLUPT          GET UPT\n         L     R4,CPPLECT          GET ECT\n         GETLINE PARM=WGETBLOK,UPT=(R3),ECT=(R4),ECB=ECBADS,           X\n               INPUT=(ISTACK,PHYSICAL),MF=(E,IOPLADS)\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    GETBUFOK            IF ZERO THEN GET READY TO TERMINATE\n         MVC   BUFFER,BLANK        BLANK OUT MSG BUFFER\n         MVC   BUFFER(L'ERR1),ERR1      GET ERROR MSG TO BUFFER\n         ST    R15,WKDWORD         SAVE RC\n         UNPK  WKDWORD+5(3),WKDWORD+3(2) UNPACK RC\n         MVC   BUFFER+3(2),WKDWORD+5    MOVE TO MESSAGE\n         TR    BUFFER+3(2),NUMTRT-240   MAKE SURE IT'S TRANSLATED RIGHT\n*\n*--------------\n*        NORMALLY, WE CAN'T CALL WLINE IN HERE, SINCE WLINE SAVE R14\n*        INTO SAVE14 (WHICH WILL OVERLAY OUR SAVE14).  HOWEVER, AFTER\n*        WE CALL WLINE, THE 'ABEND' WILL BE ISSUED AND WE DO NOT NEED\n*        TO RETURN TO OUR CALLER (WHOEVER ISSUED GETBUF).\n*--------------\n*\n         LA    R1,BUFFER\n         LA    R15,L'BUFFER\n         BAL   R14,WLINE           PUT OUT MESSAGE\n         ABEND 999\n*\nGETBUFOK EQU   *\n         L     R1,WGETBLOK+GTPBIBUF-GTPB      GET RET BUF ADDR\n         LH    R14,0(R1)           GET LENG RETURN\n*\n         ST    R14,FREELENG        SAVE LENG TO BE FREEMAIN'ED\n         ST    R1,FREEAREA         SAVE ADDRESS TO DO FREEMAIN\n*\n         C     R14,OUTLENG         COMPARE WITH MY ALLOWED MAX\n         BNH   GETMOVE             IF OK THEN MOVE TO MY BUFFER\n         L     R14,OUTLENG         ELSE - USE MY MAX\n*\nGETMOVE  EQU   *\n         L     R15,OUTPTR          GET ADDR OF MY BUFFER\n         BCTR  R14,R0              SUBTRACT 1 FOR 'EXE' INSTRUCTION\n         EX    R14,MOVEBUF         THEN MOVE DATA TO MY BUFFER\n*\n         L     R3,FREEAREA\n         L     R4,FREELENG\n         FREEMAIN R,A=(R3),LV=(R4),SP=1\n*\n         L     R14,SAVE14          LOAD RETURN ADDRESS\n         BR    R14                 AND NOW RETURN\n*\n*\nMOVEBUF  MVC   0(0,R15),4(R1)\n*\n*---------------\n*        IF IKJPARS FAILED\n*---------------\n*\nABEND020 EQU   *\n         ABEND 20\n         EJECT\n*\n*\n*\n*\nH1       DC    H'1'\nH45      DC    H'45'\nH84      DC    H'84'\nF0       DC    F'0'\nF1       DC    F'1'\nF2       DC    F'2'\nAPCL     DC    A(PCL)\n*\n*\nPUTBLOK  PUTLINE MF=L\nPUTBLOKL EQU   *-PUTBLOK           LENG OF THE PUTLINE LIST FORM\n*\n*\nGETBLOK  GETLINE MF=L\nGETBLOKL EQU   *-GETBLOK           LENG OF THE GETLINE LIST FORM\n*\n*\nNUMTRT   DC    C'0123456789ABCDEF'\n*\nBLANK    DC    CL80' '\n*\nMSG01    DC    CL80'==> MODULE XXXXXXXX'\nMSG01A   DC    C' WAS FOUND AT TTR=XXXXXX IN'\nMSG01B   DC    C' WAS FOUND IN MLPA/FLPA OR ACTIVE PLPA QUEUE'\nMSG01C   DC    C' WAS FOUND IN PLPA'\nMSG01D   DC    C'               ENTRY  31BIT   COUNT   ------ ATTRIBUTE*\n               S -------'\nMSG01E   DC    C'            XXXXXXXX    YES   XXXXX   NORENT NOREUSE A*\n               C=0 NOAPF'\nMSG01F   DC    C' WAS NOT FOUND IN EITHER LINKLIST, STEPLIB, TASKLIB OR*\n                LPA'\nMSG01G   DC    C' (ALSO)'\nMSG02    DC    CL80'         PRIVATE LIBRARY          ==>  NUMBER XXX'\nMSG03    DC    CL80'      LINKLIST LIBRARY  ==>  NUMBER XXX'\nMSG03A   DC    CL80'          (DSN = '''\nMSG03B   DC    CL80'      LINKLIST SET NAME = '\nMSG04    DC    CL80'      JOB, TASK OR STEP LIBRARY   ==>  NUMBER XXX'\nMSG05    DC    CL80'      JOB, TASK OR STEP LIBRARY'\nMSG05A   DC    CL80'          OF PARENT TASK          ==>  NUMBER XXX'\n*\n*\nERR1     DC    C'RC=XX - GETLINE ERROR'\n*\n$31BIT   DC    CL3'YES'\n#31BIT   DC    CL3' NO'\n$RENT    DC    CL6' RENT '\n#RENT    DC    CL6'NORENT'\n$REUSE   DC    CL7' REUSE '\n#REUSE   DC    CL7'NOREUSE'\n$AUTH    DC    CL4'AC=1'\n#AUTH    DC    CL4'AC=0'\n$APF     DC    CL5' APF '\n#APF     DC    CL5'NOAPF'\n*\n         EJECT\n*\nWKAREA   DSECT\n         DS    18F                 SAVE AREA\n*\nWKDWORD  DS    D\n*\n*\nSAVE14   DS    F\n*\nECBADS   DS    F                   ECB USED BY PUTLINE\nIOPLADS  DS    4F                  IOPL USED BY PUTLINE\n*\nOUTPTR   DS    F\nOUTLENG  DS    F\n*\n*\nFREELENG DS    F\nFREEAREA DS    F\n*\n*\nANS      DS    F\nMYECB    DS    F\n*\n*\n         DS    0F\nWPUTBLOK DS    CL(PUTBLOKL)        PUTLINE LIST FORM\n*\n         DS    0F\nWGETBLOK DS    CL(GETBLOKL)        GETLINE LIST FORM\n*\n*\n*\n*-------------------------------------------------------------------\n*        DO NOT INSERT ANYTHING FROM HERE TO WKENTL\n*-------------------------------------------------------------------\n*\n*\nWKLIST   DS    0F\nWKFF     DS    XL2\nWKLL     DS    XL2\nWKNAME   DS    CL8\nWKTTR    DS    XL3\nWKK      DS    XL1\nWKZ      DS    XL1\nWKC      DS    XL1\nWKUSER   DS    CL62\nWKENTL   EQU   *-WKNAME            LENG FOR THIS ENTRY\n*\n*\nBUFFER   DS    CL80\n*\nWMSGLENG DS    H\nWMSGRES  DS    H\nWMSG     DS    CL80\n*\n*\nMENTPT   DS    CL8\nM31BIT   DS    CL3\nMUSECNT  DS    CL5\nMRENT    DS    CL6\nMREUSE   DS    CL7\nMAUTH    DS    CL4\nMAPF     DS    CL5\n*\nWKPRINT  DS    CL80\nSAVENUM  DS    CL3\n*\nLNKLSTNM DS    CL16                LINK LIST SET NAME\n*\nFNDSW    DS    CL1\n$FNDSTEP EQU   X'80'               FOUND IN JOB/STEP LIB\n$FNDMF   EQU   X'40'               FOUND IN MLPA/FLPA\n$FNDPLPA EQU   X'20'               FOUND IN PLPA\n$FNDONE  EQU   $FNDSTEP+$FNDMF+$FNDPLPA\n*\nWKPPL    DS    CL(PPLLENG)\nSAVELENG DS    CL1\n*\nWKLENG   EQU   *-WKAREA\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IHAPSA\n         EJECT\n         IHAASCB\n         EJECT\n         IHAASSB\n         EJECT\n         CSVDLCB\n         EJECT\n         IHALPDE\nLPDELENG EQU   *-LPDE\n         EJECT\n         IHACDE\nCDELENG  EQU   *-CDENTRY\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJPPL\nPPLLENG  EQU   *-PPL               LENG OF PPL\n         EJECT\n         IKJPSCB\n         EJECT\n         IKJUPT\n         EJECT\n         IKJECT\n         EJECT\n         IKJGTPB\n         EJECT\n*\nSEEK     CSECT\n         PRINT NOGEN\nPCL      IKJPARM\nMODNAME  IKJIDENT 'MODULE NAME',                                       X\n               MAXLNTH=8,FIRST=ALPHANUM,OTHER=ALPHANUM,                X\n               PROMPT='MODULE NAME',                                   X\n               HELP=('NAME OF MODULE','NAME OF MODULE TO BE LOCATED')\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SET": {"ttr": 11783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x81%\\x7f\\x00\\x86$\\x7f\\x16)\\x00}\\x00D\\x00M[\\xe5\\xd5\\xe5@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1981-09-14T00:00:00", "modifydate": "1986-09-04T16:29:00", "lines": 125, "newlines": 68, "modlines": 77, "user": "$VNV"}, "text": "         MACRO\n         SET   &BASE,&LV=,&DSECT=,&REG=\n.*\n.*--------------------------------------------------------------------\n.*\n.*       MACRO = SET\n.*\n.*       AUTHOR = VINH VU\n.*\n.*       DATE-WRITTEN = 08/31/81\n.*\n.*       PURPOSE = TO SET UP BASE REGS FOR A SOURCE MODULE.\n.*             IF LV IS OMITTED, PROGRAM IS ASSUMED NOT TO BE\n.*             RE-ENTRANT. USE EXIT MACRO IN CONJUNCTION WITH THIS\n.*             MACRO.\n.*             FOR RE-ENTRANT MODULE, 18F AS SAVE AREA WILL\n.*             BE ASSUMED TO BE FIRST. PAY ATTENTION TO THIS\n.*             WHEN YOU SET UP THE DSECT.\n.*\n.*       EXAMPLES =\n.*\n.*         *   SET (R12,R11),LV=WKLENG,DSECT=WKAREA\n.*\n.*             R12 AND R11 WILL BE BASE REGISTERS.\n.*             LV WILL ASSUME A RE-ENTRANT MODULE AND THIS IS THE\n.*                LENGTH OF THE GETMAIN AREA BEING OBTAINED (WHICH\n.*                ALSO INCLUDES THE SAVE AREA OF 18F THAT WILL BE\n.*                AT THE BEGINNING OF THE GETMAINED AREA.)\n.*                THE GETMAINED DSECT SHOULD LOOK LIKE :\n.*                           WKAREA    DSECT\n.*                                     DS    18F\n.*                           USER1     DS    CL256\n.*                                     ETC   ........\n.*\n.*         *   SET LV=WKLENG\n.*\n.*             THIS ASSUMES R12 AS BASE REGISTER, A RE-ENTRANT\n.*                MODULE, BUT YOU WILL HAVE TO CODE THE USING\n.*                STATEMENT FOR THE GETMAIN AREA DSECT\n.*\n.*         *   SET\n.*\n.*             THIS ASSUMES A NON-RE-ENTRANT MODULE, R12 WILL BE\n.*                BASE REGISTER.\n.*\n.*--------------------------------------------------------------------\n.*\n         LCLA  &C,&TEST,&ORG,&CSLENG\n         LCLC  &B,&SAVE\n         GBLC  &SETEXIT\n&SETEXIT SETC  ''\n&ORG     SETA  0\n&TEST    SETA  1\n         AIF   (T'&BASE EQ 'O').DEF\n&C       SETA  N'&BASE\n&B       SETC  '&BASE(&TEST)'\n         AGO   .EQU\n.DEF     ANOP\n&C       SETA  1\n&B       SETC  'R12'\n.EQU     ANOP\n         AIF   (T'&REG EQ 'O').SETREG\n         AGO   .REGDONE\n.SETREG  ANOP\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n.REGDONE ANOP\n         B     28(R15)             BRANCH AROUND\n&CSLENG  SETA  K'&SYSECT\n         DC    AL2(&CSLENG)        LENG OF CSECT NAME\n         DC    CL8'&SYSECT'        CSECT NAME\n         DC    CL8'&SYSDATE'       THIS IS DATE\n         DC    CL6'&SYSTIME'       THIS IS TIME\n         CNOP  0,4                 GET ALIGNMENT\n         STM   R14,R12,12(R13)     SAVE PREVIOUS REGS\n         LR    &B,R15              GET BASE REG SETUP\n         USING &SYSECT,&B          ESTABLISH ADDRESABILITY\n.LOOP    ANOP\n         AIF   (&TEST EQ &C).THRU\n&SAVE    SETC  '&BASE(&TEST)'\n&ORG     SETA  &ORG+4096\n&TEST    SETA  &TEST+1\n&B       SETC  '&BASE(&TEST)'\n         USING &SYSECT+&ORG,&B\n         LA    &B,4095(,&SAVE)\n         LA    &B,1(,&B)\n         AGO   .LOOP\n.THRU    ANOP\n         AIF   (T'&LV EQ 'O').NORENT\n&SETEXIT SETC  '&LV'\n         GETMAIN R,LV=&LV\n         ST    R13,4(,R1)          SAVE REG13 FROM PREVIOUS\n         L     R15,24(,R13)        SAVE REG 1\n         ST    R1,8(,R13)          SAVE MY REG13 IN PREV SAVE AREA\n         LR    R13,R1              GET MY REG 13 READY\n         LR    R1,R15              GET REG1 BACK\n         AIF   (T'&DSECT EQ 'O').FINAL\n         USING &DSECT,R13          ESTABLISH ADDRESSABILITY\n.FINAL   ANOP\n         MEXIT\n.NORENT  ANOP\n         CNOP  0,4                 GET ALIGNMENT\n         BAL   R1,*+76             BRANCH AROUND\n         DS    18F                 THIS IS MY SAVE AREA\n         ST    R13,4(,R1)          SAVE REG13 FROM PREVIOUS\n         L     R15,24(,R13)        SAVE REG 1\n         ST    R1,8(,R13)          SAVE MY REG13 IN PREV SAVE AREA\n         LR    R13,R1              GET MY REG 13 READY\n         LR    R1,R15              GET REG1 BACK\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETMODE": {"ttr": 11786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01 \\x08\\x9f\\x01 \\x08\\x9f\\x190\\x00\\x13\\x00\\x13\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-29T00:00:00", "modifydate": "2020-03-29T19:30:12", "lines": 19, "newlines": 19, "modlines": 0, "user": "-------"}, "text": "         MACRO\n&NAME    SETMODE &P1,&R=R15\n         AIF   ('&P1' EQ '24').OK24\n         AIF   ('&P1' EQ '31').OK31\n         MNOTE 8,'NOT CORRECT MODE'\n         MEXIT\n.OK24    ANOP\n         L     &R,=A(A&SYSNDX)     .   GET NEXT SEQUENTIAL ADDR\n         N     &R,=X'7FFFFFFF'     .   DO NOT USE AMODE31\n         BSM   0,&R                .   TURN OFF AMODE31\nA&SYSNDX DS    0H\n         MEXIT\n.OK31    ANOP\n         L     &R,=A(A&SYSNDX)     .   GET NEXT SEQUENTIAL ADDR\n         O     &R,=X'80000000'     .   MAKE IT USE AMODE31\n         BSM   0,&R                .   TURN ON AMODE31\nA&SYSNDX DS    0H\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSOINIT": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01 \\x08\\x9f\\x01 \\x08\\x9f\\x190\\x01\\x84\\x01\\x84\\x00\\x00```````@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-03-29T00:00:00", "modifydate": "2020-03-29T19:30:12", "lines": 388, "newlines": 388, "modlines": 0, "user": "-------"}, "text": "TSOINIT  TITLE 'TSOINIT ---- TO PRE-ALLOCATE ISPF DATA SETS'\n*\n*-------------------------------------------------------------------\n*        PROGRAM - TSOINIT\n*        PURPOSE -\n*              LOCATE IS DONE TO FIND OUT IF A USER HAS THE ISPF DATA\n*              SETS CATALOGED.  IF NOT THEN THIS COMMAND WILL ALLOCATE\n*              THOSE ISPF DATA SETS AS NEW.\n*        DATE-WRITTEN - 02/23/88\n*        MACROS USED -\n*              SET,EXIT,READ,NOTE,POINT,TPUT,TGET,GETMAIN,\n*              FREEMAIN,OPEN,CLOSE,DCB,DCBD\n*        NOTE -\n*              THIS IS A COMMAND PROCESSOR.\n*\n*        COMMAND FORMAT :\n*\n*              TSOINIT MESSAGE (OPTIONAL KEYWORD)\n*\n*                    IF KEYWORD 'MESSAGE' IS ENTERED, THEN A MESSAGE\n*                    LINE WILL BE DISPLAYED FOR EVERY ALLOCATION OF A\n*                    NEW DATA SET.\n*\n*        REGISTER USAGE :\n*\n*              R12 - BASE\n*              R11 - 2ND BASE\n*              R10 - CPPL BASE - CANNOT BE ALTERED\n*              R8  - POINTS TO THE DSNAMES TABLE\n*-------------------------------------------------------------------\n*\n*\nTSOINIT  CSECT\n         SET   (R12,R11)\n         TM    0(R1),X'80'         IS IT CALLED AS A PROGRAM ??\n         BO    NOTCP               YEAH - THEN END IT RIGHT HERE\n         LR    R10,R1              GET CPPL ADDR\n         USING CPPL,R10            ESTAB ADDR\n         LA    R8,DSNTABLE         GET ADDRESS OF THE DSNAME TABLE\n         USING DSNDSECT,R8         ESTABLISH ADDRESSABILITY\n*\n*--- NOW DO THE TSO PARSE\n*\n         XC    WKPPL,WKPPL         CLEAR OUT PPL\n         LA    R4,WKPPL            GET ADDR OF PPL\n         USING PPL,R4              ESTAB ADDR\n         MVC   PPLUPT,CPPLUPT      GET UPT\n         MVC   PPLECT,CPPLECT      GET ECT\n         XC    MYECB,MYECB         CLEAR MY ECB\n         LA    R1,MYECB            GET A(ECB)\n         ST    R1,PPLECB           GET ECB\n         MVC   PPLPCL,APCL         GET PPLPCL\n         LA    R1,ANS\n         ST    R1,PPLANS           GET ANS\n         MVC   PPLCBUF,CPPLCBUF    GET CBUF\n         CALLTSSR EP=IKJPARS,MF=(E,WKPPL)\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   BADPARSE            IF NOT GOOD THEN ABEND\n*\n         XC    MSGSW,MSGSW         TURN OFF MSGSW\n*\n         L     R7,ANS              GET ANS\n         LA    R1,0(0,R7)          CLEAR OUT TRASH\n         LTR   R1,R1               CHECK IF ANS IS THERE\n         BZ    PROCNAME            NOP - THEN NO COMMAND SUPPLIED\n*\n         USING IKJPARMD,R7         ESTAB ADDR\n         XR    R1,R1               CLEAR REG 1\n         ICM   R1,B'0011',MSG      CHECK TO SEE IF KW ENTERED\n         BZ    PROCNAME            IF NOT - THEN GO AROUND\n         OI    MSGSW,X'01'         ELSE - TURN ON SWITCH\n         DROP  R7\n*\n*--- PROCESS EACH NAME FOUND IN THE DSN TABLE\n*\nPROCNAME EQU   *\n         CLI   0(R8),X'FF'         IS IT THE END ??\n         BE    ENDIT               YEAH - THEN I AM DONE\n*\n*--- FIND OUT WHAT HIS DSN SHOULD BE\n*\n         MVC   DSN,BLANK           BLANK OUT DSNAME\n         L     R1,CPPLPSCB         GET ADDR OF PSCB\n         USING PSCB,R1             ESTABLISH ADDRESSABILITY\n         MVC   DSN(L'PSCBUSER),PSCBUSER\n         XR    R15,R15             CLEAR REG 15\n         LA    R14,DSN             GET ADDR OF WKSOURCE\n         IC    R15,PSCBUSRL        GET LENG OF USER-ID\n         LA    R14,0(R14,R15)      GET TO END OF IT\n         MVI   0(R14),C'.'         MOVE '.' IN THERE\n         MVC   1(L'DNAME,R14),DNAME      MOVE DSNAME THERE\n         DROP  R1                  DROP ADDR\n*\n*--- NOW LOCATE THE DATA SET\n*\n         LOCATE LOCLIST\n         LTR   R15,R15             TEST RETURN CODE ..\n         BZ    NEXTNAME            IF FOUND - THEN GO TO NEXT NAME\n*\n*---  FREE ATTR LIST NAME\n*\n         XC    WKDAP34,WKDAP34     CLEAR AREA\n         LA    R9,WKDAP34          GET ADDR INTO R9\n         USING DAPB34,R9           ESTAB ADDR\n         MVC   DA34CD,=X'0034'\n         OI    DA34CTRL,DA34UNCH   DELETE SPECIFIED ATTR\n         MVC   DA34NAME,DATTR      USE ATTR NAME FROM TABLE\n         DROP  R9\n*\n         XC    WKDAPL,WKDAPL       CLEAR AREA\n         LA    R9,WKDAPL           GET ADDR INTO R9\n         USING DAPL,R9             ESTAB ADDTR\n         MVC   DAPLUPT,CPPLUPT     GET UPT\n         MVC   DAPLECT,CPPLECT     GET ECT\n         XC    MYECB,MYECB         CLEAR MYECB\n         LA    R1,MYECB            GET ITS ADDR\n         ST    R1,DAPLECB          GET IT INTO LIST\n         MVC   DAPLPSCB,CPPLPSCB   GET PSCB\n         LA    R1,WKDAP34          GET ADDR OF DAIR\n         ST    R1,DAPLDAPB         GET IT INTO LIST\n         LA    R1,WKDAPL           GET ADDR OF PARM LIST\n         CALLTSSR EP=IKJDAIR,MF=(E,WKDAPL)\n*\n*---  ALLOCATE ATTR LIST NAME\n*\n         XC    WKDACB,WKDACB       CLEAR AREA\n         LA    R9,WKDACB           GET ADDR INTO R9\n         USING DAIRACB,R9          ESTAB ADDR\n         OC    DAIRECFM,DRECFM     RECFM\n         MVC   DAIBLKSI,DBLKSIZE   BLKSIZE\n         MVC   DAILRECL,DLRECL     LRECL\n         DROP  R9\n         XC    WKDAP34,WKDAP34     CLEAR AREA\n         LA    R9,WKDAP34          GET ADDR INTO R9\n         USING DAPB34,R9           ESTAB ADDR\n         MVC   DA34CD,=X'0034'\n         OI    DA34CTRL,DA34CHN    BUILD SPECIFIED ATTR\n         MVC   DA34NAME,DATTR      USE ATTR NAME FROM TABLE\n         MVC   DA34ADDR,=AL4(WKDACB)    GET ADDR OF ATTR LIST\n         DROP  R9\n*\n         XC    WKDAPL,WKDAPL       CLEAR AREA\n         LA    R9,WKDAPL           GET ADDR INTO R9\n         USING DAPL,R9             ESTAB ADDTR\n         MVC   DAPLUPT,CPPLUPT     GET UPT\n         MVC   DAPLECT,CPPLECT     GET ECT\n         XC    MYECB,MYECB         CLEAR MYECB\n         LA    R1,MYECB            GET ITS ADDR\n         ST    R1,DAPLECB          GET IT INTO LIST\n         MVC   DAPLPSCB,CPPLPSCB   GET PSCB\n         LA    R1,WKDAP34          GET ADDR OF DAIR\n         ST    R1,DAPLDAPB         GET IT INTO LIST\n         LA    R1,WKDAPL           GET ADDR OF PARM LIST\n         CALLTSSR EP=IKJDAIR,MF=(E,WKDAPL)\n         LTR   R15,R15             TEST RET CODE\n         BZ    ALLOCNEW            IF GOOD - THEN GO ALLOCATE\n         ST    R15,DAIRRET         SAVE R15\n         MVC   MSG01+42(8),DATTR   GET ATTR NAME\n         TPUT  MSG01,L'MSG01       DO THE TPUT\n         B     DAIRERR             AND BRANCH AROUND\n*\n*---  ALLOCATE NEW DATA SET\n*\nALLOCNEW EQU   *\n         XC    WKDAP08,WKDAP08     CLEAR AREA\n         LA    R9,WKDAP08          GET ADDR INTO R9\n         USING DAPB08,R9           ESTAB ADDR\n         MVC   DA08CD,=XL2'0008'\n         LA    R1,DSNAME           GET ADDR OF DSNAME BUFF\n         ST    R1,DA08PDSN\n         MVC   DA08DDN,BLANK       DDNAME IS BLANK\n         MVC   DA08UNIT,BLANK\n         MVC   DA08SER,BLANK       BLANK SER NO\n         MVC   DA08PSWD,BLANK      BLANK OUT PSWD\n         MVC   DA08MNM,BLANK       BLANK OUT MEMBER NAME\n         OI    DA08DSP1,DA08NEW    NEW\n         OI    DA08DPS2,DA08CAT    CATLG\n         OI    DA08DPS3,DA08DELE   DELETE\n         MVC   DA08PQTY,DPRIM      PRIMARY\n         MVC   DA08SQTY,DSEC       SECONDARY\n         MVC   DA08DQTY,DDIR       DIR\n         OI    DA08CTL,DA08TRKS+DA08ATRL  ATTR & TRKS\n         MVC   DA08ALN,DATTR       ATTR LIST FROM TABLE\n         DROP  R9\n         XC    WKDAPL,WKDAPL       CLEAR AREA\n         LA    R9,WKDAPL           GET ADDR INTO R9\n         USING DAPL,R9             ESTAB ADDTR\n         MVC   DAPLUPT,CPPLUPT     GET UPT\n         MVC   DAPLECT,CPPLECT     GET ECT\n         XC    MYECB,MYECB         CLEAR MYECB\n         LA    R1,MYECB            GET ITS ADDR\n         ST    R1,DAPLECB          GET IT INTO LIST\n         MVC   DAPLPSCB,CPPLPSCB   GET PSCB\n         LA    R1,WKDAP08          GET ADDR OF DAIR\n         ST    R1,DAPLDAPB         GET IT INTO LIST\n         LA    R1,WKDAPL           GET ADDR OF PARM LIST\n         CALLTSSR EP=IKJDAIR,MF=(E,WKDAPL)\n         LTR   R15,R15             TEST RET CODE\n         BZ    CKMSG               GOOD - THEN PROCESS NEXT NAME\n         ST    R15,DAIRRET         ELSE - SAVE R15\n         TPUT  MSG02,L'MSG02       PUT OUT MESSAGE\n         MVC   MSG02TXT,DSN\n         TPUT  MSG02A,MSG02AL\n         B     DAIRERR             AND THEN BRANCH AROUND\n*\nCKMSG    EQU   *\n         TM    MSGSW,X'01'         DO I NEED TO PUT OUT MSG\n         BZ    NEXTNAME            NOP - THEN JUST GO AROUND\n         MVC   MSG05TXT,DSN        ELSE - GET DSN INTO MSG\n         TPUT  MSG05,MSG05L        AND PUT OUT MESSAGE\n*\nNEXTNAME EQU   *\n         LA    R8,DLENG(,R8)       BUMP TO NEXT ENTRY\n         B     PROCNAME            AND GO BACK TO PROCESS\n*\nDAIRERR  EQU   *\n         LA    R9,WKDERR           GET ADDR OF DAIRFAIL PARM\n         USING DFDSECTD,R9         ESTAB ADDR\n         LA    R15,WKDAPL\n         ST    R15,DFDAPLP\n         LA    R15,DAIRRET\n         ST    R15,DFRCP\n         LA    R15,HEXZEROS\n         ST    R15,DFJEFF02\n         LA    R15,DAIRBYTE\n         ST    R15,DFIDP\n         LR    R1,R9               GET R1 SET UP\n         LINK  EP=IKJEFF18\n         LTR   R15,R15             RETN CODE GOOD ?\n         BZ    ENDIT               YEAH - THEN THRU\n         ABEND 30                  ELSE ABEND 30\n*\nBADPARSE EQU   *\n         TPUT  MSG04,L'MSG04       PUT OUT ERR MESSAGE\n         B     ENDIT               AND THEN GO AROUND\n*\nNOTCP    EQU   *\n         TPUT  MSG03,L'MSG03       PUT OUT ERR MESSAGE\n*\nENDIT    EQU   *\n         EXIT\n         EJECT\n*\n*\n         DS    0F\nWKPPL    DS    CL(PPLLENG)\n         DS    0F\nWKDAPL   DS    CL(DAPLLENG)\n         DS    0F\nWKDAP08  DS    CL(DAP08LEN)\n         DS    0F\nWKDAP34  DS    CL(DAP34LEN)\n         DS    0F\nWKDACB   DS    CL(DACBLEN)\n         DS    0F\nWKDERR   DS    CL(DFLEN)\n         DS    0F\n*\n*\nHEXZEROS DC    F'0'\nDAIRBYTE DC    XL2'0001'\n*\n*\nDAIRRET  DS    F\n*\nBLANK    DC    CL80' '\n*\n         DS    0F\nDSNAME   DS    0CL46\n         DC    AL2(L'DSN)\nDSN      DC    CL44' '\n*\nMYECB    DS    F\nANS      DS    F\nAPCL     DC    A(PCL)\n*\n*\nMSGSW    DS    X                   SWITCH\n*\n*\nLOCLIST  CAMLST NAME,DSN,,WKAREA\nWKAREA   DS    265C                WKAREA FOR LOCATE\n*\n*\nDSNTABLE DS    0C\n*\n         DC    CL35'CLIST    '     DSNAME\n         DC    CL8'$DMYATTR '      ATTR NAME\n         DC    AL2(3120)           BLKSIZE\n         DC    AL2(80)             LRECL\n         DC    XL1'90'             FB\n         DC    AL4(1)              PRIMARY\n         DC    AL4(1)              SECONDARY\n         DC    AL4(15)             DIRECTORY\n*\n         DC    CL35'ISPPLIB'       DSNAME\n         DC    CL8'$DMYATTR'       ATTR NAME\n         DC    AL2(3120)           BLKSIZE\n         DC    AL2(80)             LRECL\n         DC    XL1'90'             FB\n         DC    AL4(1)              PRIMARY\n         DC    AL4(1)              SECONDARY\n         DC    AL4(15)             DIRECTORY\n*\n         DC    CL35'ISPSLIB'       DSNAME\n         DC    CL8'$DMYATTR'       ATTR NAME\n         DC    AL2(3120)           BLKSIZE\n         DC    AL2(80)             LRECL\n         DC    XL1'90'             FB\n         DC    AL4(1)              PRIMARY\n         DC    AL4(1)              SECONDARY\n         DC    AL4(15)             DIRECTORY\n*\n         DC    CL35'ISPMLIB'       DSNAME\n         DC    CL8'$DMYATTR'       ATTR NAME\n         DC    AL2(3120)           BLKSIZE\n         DC    AL2(80)             LRECL\n         DC    XL1'90'             FB\n         DC    AL4(1)              PRIMARY\n         DC    AL4(1)              SECONDARY\n         DC    AL4(15)             DIRECTORY\n*\n         DC    X'FF'               END-OF-TABLE\n*\n*\n*\n*\n*\nMSG01    DC    C'TSOINIT-001E - ERR IN ALLOCATION FOR ATTR 12345678'\n*\nMSG02    DC    C'TSOINIT-002E - DSNAME ALLOCATION ERR'\nMSG02A   DC    C'               DSNAME = '\nMSG02TXT DC    CL44' '\nMSG02AL  EQU   *-MSG02A            LENG OF MESSAGE (2ND PART)\n*\nMSG03    DC    C'TSOINIT-003E - NEEDS TO XEQ PROG AS A TSO COMMAND'\n*\nMSG04    DC    C'TSOINIT-004E - BAD RETURN CODE FROM IKJPARS'\n*\nMSG05    DC    C'TSOINIT-005I - ALLOCATING DATA SET : '\nMSG05TXT DC    CL44' '\nMSG05L   EQU   *-MSG05             LENG OF MESSAGE\n*\n*\nDSNDSECT DSECT\nDNAME    DS    CL35                DS NAME\nDATTR    DS    CL8                 ATTRIBUTE NAME\nDBLKSIZE DS    XL2                 BLOCK SIZE\nDLRECL   DS    XL2                 LRECL\nDRECFM   DS    XL1                 RECFM\nDPRIM    DS    XL4                 PRIMARY ALLOCATION\nDSEC     DS    XL4                 SECONDARY ALLOCATION\nDDIR     DS    XL4                 DIRECTORY\nDLENG    EQU   *-DNAME             LENG OF EACH ENTRY\n*\n*\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IKJCPPL\n         EJECT\n         IKJPPL\nPPLLENG  EQU   *-PPL               LENG OF PPL\n         EJECT\n         IKJDAPL\nDAPLLENG EQU   *-DAPL              LENG OF DAPL (DAIR PARM LIST)\n         EJECT\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08            LENG\n         EJECT\n         IKJDAP34\nDAP34LEN EQU   *-DAPB34\n         EJECT\n         IKJDACB\nDACBLEN  EQU   *-DAIRACB\n         EJECT\n         IKJEFFDF DFDSECT=YES\n         EJECT\n         IKJPSCB\n*\nTSOINIT  CSECT\n         PRINT NOGEN\n*\nPCL      IKJPARM\nMSG      IKJKEYWD\n         IKJNAME 'MESSAGE'\n         IKJENDP\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT166/FILE166.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT166", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}