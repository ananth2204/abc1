{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013321000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE891.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE891.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\n'", "DS1TRBAL": "b'\\tn'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\x7f\\x00\\n\\x08\\x7f\\x00\\r\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00W\\x01\\x13\\x17\\x8f\\x01\\x13\\x17\\x8f\\x084\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-06-27T00:00:00", "modifydate": "2013-06-27T08:34:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-487"}, "text": "REGULAR CBT TAPE - VERSION 487    FILE:  891\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE891\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,116 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/27/13    08:34:57    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x13\\x15?\\x01\\x13\\x15?!(\\x00$\\x00$\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-06-02T00:00:00", "modifydate": "2013-06-02T21:28:01", "lines": 36, "newlines": 36, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  MINE Tool - to generate a visual structure chart\nFrom:     Quasar Chunawala <quasar.chunawalla@gmail.com>\nDate:     6/2/2013 12:36 PM\nTo:       sbgolob@cbttape.org\n\nHi Sam,\n\nI would like to contribute my tool to CBT Tape. The tool is\ncalled MINE.\n\nMINE is a powerful REXX utility developed to build the structure\nchart of a COBOL source. Just press <PF1> under any paragraph. A\nvisual diagram that shows all calling paragraphs and called\nparagraphs is displayed on the screen.\n\nPressing <PF2> on any PERFORM <para> statement, allows you to\njump directly to the called paragraph. Press <PF4> within the\ncalled paragraph, takes you back the last PERFORM statement. You\ncan traverse upto any number levels and back up.\n\nThis script implements several data-structures in Rexx. MINE was\nwritten keeping in mind, a structured top-down programming\nmethodology. It is therefore, divided into several smaller\nroutines. MINE also uses two panels DYNAREA and MINEMSG.\n\nYou may invoke MINE on the ISPF Editor. The syntax is MINE\n<function>, where <function> parameter could be IN, OUT or GRAPH.\nI have set my PFKeys as <PF1> - MINE GRAPH, <PF2> - MINE IN and\n<PF4> - MINE OUT.\n\nAttached herewith, please find MINE.XMI in the binary format.\nPlease let me know, if the file's fine.\n\nThank you very much,\nQuasar\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x13\\x17\\x8f\\x01\\x13\\x17\\x8f\\x083\\x00-\\x00-\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-06-27T00:00:00", "modifydate": "2013-06-27T08:33:06", "lines": 45, "newlines": 45, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Small (very!) suggestion for FILE891\nFrom:     \"Michael R. Mayne\" <michael.mayne@hhsys.org>\nDate:     6/26/2013 2:45 PM\nTo:       QUASAR.CHUNAWALA@BNYMELLON.COM\nCC:       Sam Golob <sbgolob@cbttape.org>\n\nQuasar, the MINE exec looks very interesting!  I do have one\nchange I would like to recommend, however.  Instead of setting up\nPF keys, I was doing some basic testing on the exec by typing in\nthe commands on the command line of the edit (or view) session.\nI couldn't get it to do anything, it would just take the command\nand return to the session as if I had just pressed enter!\nNeedless to say, this was not a desirable result.  However, the\nproblem (and the fix) is very simple - the exec doesn't like\nparameters in lower case!  If you add this one line, there is no\nmore problem with this issue:\n\n...\n/* KEY-PRESS IS INTERCEPTED AND THE PARA_STACK VARIABLE IS CLEARED. */\n/*__________________________________________________________________*/\n\n  CALL INITIALIZATION\n\n  PARM = TRANSLATE(PARM)  <-- add this line\n\n  IF PARM = 'IN' THEN DO\n...\n\nThe default behavior of the TRANSLATE function is simply to\nreturn the provided argument translated to upper case.  Lower\ncase input is no longer a problem...\n\nBest regards,\n-Mike\n\n--\nMichael R. Mayne\nSystems Programmer III\nHuntsville Hospital System\n101 Sivley Rd. SW\nHuntsville, AL 35801-4421\n\nEmail: michael.mayne@hhsys.org\nTel: (256) 265-9012\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE891": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00Q\\x01\\x13\\x17\\x8f\\x01\\x13\\x17\\x8f\\x084\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-06-27T00:00:00", "modifydate": "2013-06-27T08:34:51", "lines": 29, "newlines": 29, "modlines": 0, "user": "CBT-487"}, "text": "//***FILE 891 is from Quasar Chunawala and contains a REXX program  *   FILE 891\n//*           to flow-chart a COBOL program automatically, given    *   FILE 891\n//*           its source code.  This program is called MINE.        *   FILE 891\n//*                                                                 *   FILE 891\n//*           email:  quasar.chunawalla@gmail.com                   *   FILE 891\n//*                                                                 *   FILE 891\n//*     MINE is a powerful REXX utility developed to build the      *   FILE 891\n//*     structure chart of a COBOL source. Just press <PF1>         *   FILE 891\n//*     under any paragraph. A visual diagram that shows all        *   FILE 891\n//*     calling paragraphs and called paragraphs is displayed on    *   FILE 891\n//*     the screen.                                                 *   FILE 891\n//*                                                                 *   FILE 891\n//*     Pressing <PF2> on any PERFORM <para> statement, allows      *   FILE 891\n//*     you to jump directly to the called paragraph. Press         *   FILE 891\n//*     <PF4> within the called paragraph, takes you back the       *   FILE 891\n//*     last PERFORM statement. You can traverse upto any number    *   FILE 891\n//*     levels and back up.                                         *   FILE 891\n//*                                                                 *   FILE 891\n//*     This script implements several data-structures in Rexx.     *   FILE 891\n//*     MINE was written keeping in mind, a structured top-down     *   FILE 891\n//*     programming methodology. It is therefore, divided into      *   FILE 891\n//*     several smaller routines. MINE also uses two panels         *   FILE 891\n//*     DYNPANE and MINEMESG, which it generates.                   *   FILE 891\n//*                                                                 *   FILE 891\n//*     You may invoke MINE on the ISPF Editor. The syntax is       *   FILE 891\n//*     MINE <function>, where <function> parameter could be IN,    *   FILE 891\n//*     OUT or GRAPH.  I have set my PFKeys as <PF1> - MINE         *   FILE 891\n//*     GRAPH, <PF2> - MINE IN and <PF4> - MINE OUT.                *   FILE 891\n//*                                                                 *   FILE 891\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x13\\x15O\\x01\\x13\\x15O\\x01$\\x00(\\x00\\x00\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-06-03T00:00:00", "modifydate": "2013-06-03T01:24:00", "lines": 40, "newlines": 0, "modlines": 0, "user": "SYSADM"}, "text": "1.1 Introduction\n    ------------\n    MINE is a powerful Rexx utility developed to build a structure\n    chart of a COBOL source. Just press <PF1> under any paragraph.\n    A visual diagram that shows all the calling paragraphs and\n    called paragraphs is displayed on the screen.\n\n    Pressing <PF2> on any PERFORM <para> statement, allows you to\n    jump directly to the called paragraph. Press <PF4> within the\n    called paragraph, takes you back to the last PERFORM statement.\n    You can traverse upto any number of levels.\n\n1.2 How to use\n    ----------\n    You may invoked MINE on the ISPF Editor.\n\n    Syntax\n    ======\n    MINE {parameter}\n\n    The parameter passed to the MINE EXEC determines the function\n    to be performed. The parameter could be one of these values\n    IN, OUT or GRAPH.\n\n1.3 Installation\n    ------------\n    Copy the MINE EXEC in this PDS to any library under your\n    //SYSPROC or //SYSEXEC concatenations. It is recommended to change\n    your ISPF Editor Keylist settings as follows; assign the command\n    MINE IN to <PF2>, MINE OUT to <PF4> and MINE GRAPH <PF1>.\n\n1.4 Author\n    ------\n    MINE is written entirely in REXX by Quasar Chunawala.\n    He can be reached at quasar.chunawalla@gmail.com.\n\n    Thank you for trying MINE!\n    - Quasar Chunawala,\n      Pune, Maharashtra, India\n      quasar.chunawalla@gmail.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MINE": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x13\\x15O\\x01\\x13\\x17\\x8f\\x08#\\x03\\xba\\x03\\xb8\\x00\\x00\\xe2\\xe8\\xe2\\xc1\\xc4\\xd4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-06-03T00:00:00", "modifydate": "2013-06-27T08:23:51", "lines": 954, "newlines": 952, "modlines": 0, "user": "SYSADM"}, "text": "/* REXX - MINE TOOL(FOR COBOL PROGRAMS)                             */\n/*__________________________________________________________________*/\n/* AUTHOR : C QUASAR. QUASAR.CHUNAWALA@BNYMELLON.COM                */\n/*                                                                  */\n/* DESCRIPTION :                                                    */\n/* -----------                                                      */\n/* MINE REFERS TO SOFTWARE MINING AND IS FOR ANALYSIS OF            */\n/* COBOL PROGRAMS.                                                  */\n/*                                                                  */\n/* IT RUNS AS AN EDIT-MACRO. THE <PF2> KEY IS USED TO TRAVERSE      */\n/* DOWN FROM THE CALLING TO THE CALLED ROUTINE. THE <PF4> KEY       */\n/* IS USED BACK UP. <PF1> KEY HELPS TO GENERATE A STRCUTURE CHART.  */\n/*                                                                  */\n/*__________________________________________________________________*/\n\n\n/* START OF MACRO */\nADDRESS ISREDIT\n\"MACRO (PARM) NOPROCESS\"\n\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*__________________________________________________________________*/\n  MAIN:\n/*-----                                                             */\n/* THE MAIN ROUTINE FIRST INITIALIZES THE VARIABLES TO THE DEFAULT  */\n/* VALUES. NEXT, IT READS THE LONG VARIABLE PARA_STACK TO DETERMINE */\n/* HOW DEEP WE ARE IN THE CALL-TREE. DEPENDING UPON THE PARAMETER   */\n/* PASSED, 'IN' OR 'OUT' IT WILL PROCESSING IS PERFORMED. A <PF3>   */\n/* KEY-PRESS IS INTERCEPTED AND THE PARA_STACK VARIABLE IS CLEARED. */\n/*__________________________________________________________________*/\n\n  CALL INITIALIZATION\n\n  PARM = TRANSLATE(PARM)\n\n  IF PARM = 'IN' THEN DO\n     CALL MINE_IN\n  END\n\n  IF PARM = 'OUT' THEN DO\n     CALL MINE_OUT\n  END\n\n  IF PARM = 'GRAPH' THEN DO\n     CALL GEN_FLOW_GRAPH\n  END\n\n  EXIT\n\n/*__________________________________________________________________*/\n  INITIALIZATION:\n/*--------------                                                    */\n/* THE INITIALIZATION ROUTINE ASSIGNS TO DEFAULT VALUES TO VARIABLES*/\n/* THAT ARE USED, EACH TIME THIS EXEC IS INVOKED.                   */\n/*__________________________________________________________________*/\n\n  LINENUM = 0\n  LINEDATA = ''\n  SCREEN_NO = 00\n  RACFID = ''\n  EDIT_DATASET = ''\n  PARAGRAPH = ''\n  LINE_NUMBER = 00\n  PARA_NAME = ''\n  MATCH_FOUND = 0\n  ITEM_FOUND = ''\n  SEARCH_KEY = ''\n  MAX_SIZE = 0\n  ITEM_LENGTH = 102\n  SEARCH_KEY_LENGTH = 93\n  STEP_SIZE = -102\n  EXTRACTED_STR = ''\n  I = 0\n  J = 0\n  PRECEDING_STR  = ''\n  SUCCEEDING_STR = ''\n  PARA_LIST.0 = 0\n  PARA_LIST. = ''\n  PARA_IDX = 0\n  N = 0\n  GRAPH. = 0\n  GRAPH_PARA = ''\n  CALLER_LIST.0 = 0\n  CALLER_LIST.  = ''\n  CALLED_LIST.0 = 0\n  CALLED_LIST.  = ''\n  SHAD_CALLER_LIST.0 = 0\n  SHAD_CALLER_LIST.  = ''\n  SHAD_CALLED_LIST.0 = 0\n  SHAD_CALLED_LIST.  = ''\n  CALLER_CONNECTOR.0 = 0\n  CALLER_CONNECTOR.  =''\n  CALLED_CONNECTOR.0 = 0\n  CALLED_CONNECTOR.  =''\n\n  Respect_cmd = 'Yes'\n  Caller_list_has_more_items = 'Yes'\n  Called_list_has_more_items = 'Yes'\n  Caller_List_Size = 0\n  Called_List_Size = 0\n  Caller_List_Max_Pos = 0\n  Called_List_Max_Pos = 0\n  DYN_CALLER_LIST.0 = 0\n  DYN_CALLER_LIST.  = ''\n  DYN_CALLED_LIST.0 = 0\n  DYN_CALLED_LIST.  = ''\n\n/* List of Function Pool Variables\n  Curr_marker_pos = 0\n  Main_Para = ''\n*/\n\n  RETURN\n\n/*__________________________________________________________________*/\n  VGET_CALL_STACK:\n/*--------------                                                    */\n/* THIS ROUTINE VGETS THE CALLSTK VARIABLE FROM THE ISPF SHARED     */\n/* POOL.                                                            */\n/*__________________________________________________________________*/\n\n  ADDRESS ISPEXEC \"VGET (CALLSTK) SHARED\"\n\n  RETURN\n\n/*__________________________________________________________________*/\n  VPUT_CALL_STACK:\n/*--------------                                                    */\n/* THIS ROUTINE VPUTS THE CALLSTK VARIABLE TO   THE ISPF SHARED     */\n/* POOL.                                                            */\n/*__________________________________________________________________*/\n\n  ADDRESS ISPEXEC\n  \"VPUT CALLSTK SHARED\";\n\n  RETURN\n\n/*__________________________________________________________________*/\n  MINE_IN:\n/*-------                                                           */\n/* THIS ROUTINE JUMPS FROM THE CALLING <PARA> TO THE CALLED <PARA>. */\n/* IT FIRST ACQUIRES THE LINE-NO, THE PERFORM PARA-NAME, THE RACFID */\n/* AND THE CURRENT DATASET NAME AND APPENDS THEM TO THE CALLSTK     */\n/* VARIABLE IN THE BASE ISR SHARED POOL.                            */\n/* NEXT, IT EXECUTES THE FIND ALL <PARA-NAME> 08 COMMAND TO JUMP    */\n/* TO THE CALLED PARAGRAPH.                                         */\n/*__________________________________________________________________*/\n\n\n/* GET THE CURRENT LINE NUMBER, WHERE THE CURSOR IS POSITIONED      */\n  ADDRESS ISREDIT\n  \"(LINENUM) = LINENUM .ZCSR\"\n\n/* GET THE CURRENT LINE DATA                                        */\n  ADDRESS ISREDIT\n  \"(LINEDATA) = LINE .ZCSR\"\n\n/* PARSE THE CURRENT LINE-OF-CODE, TO SEE IF THIS IS A PERFORM      */\n  PARSE VAR LINEDATA TAG 8,\n                     AREA_A 12,\n                     AREA_B 72,\n                     COMMENT\n\n\n/* IF AREA-B STATEMENT CONTAINS THE COBOL KEYWORD PERFORM           */\n  IF INDEX(AREA_B,'PERFORM') > 0\n  THEN DO\n\n/* THE TSO-USER RACF-ID - 8 BYTES                                   */\n     RACF_ID = USERID()\n     RACF_ID = RACF_ID || COPIES(' ',08 - LENGTH(RACF_ID))\n\n/* THE STATEMENT NUMBER OF PERFORM <PARA> - 08 BYTES                */\n     LINE_NUMBER = LINENUM\n\n/* THE COBOL PARAGRAPH NAME - 30 BYTES                              */\n     PARSE VAR AREA_B VERB PARAGRAPH .\n\n     IF VERB = 'PERFORM' THEN DO\n        IF PARAGRAPH = 'VARYING' | PARAGRAPH = 'UNTIL',\n        | PARAGRAPH = 'TEST' THEN DO\n           WARNMSG = '  THIS IS AN INLINE PERFORM STATEMENT. POSITION',\n                     'THE CURSOR ON PERFORM <PARA>'\n           Call Prepare_popup\n           ADDRESS ISPEXEC \"ADDPOP ROW(19) COLUMN(01)\"\n           ADDRESS ISPEXEC \"DISPLAY PANEL(MINEMESG)\"\n           ADDRESS ISPEXEC \"REMPOP\"\n           Call Free_popup\n        END\n        ELSE DO\n          PARAGRAPH = PARAGRAPH || COPIES(' ',30 - LENGTH(PARAGRAPH))\n\n/* THE CURRENT DATASET OPEN IN EDIT MODE - 54 BYTES                 */\n          ADDRESS ISREDIT \"(CURDSN) = DATASET\"\n          ADDRESS ISREDIT \"(MEMBER) = MEMBER\"\n          CURDSN = CURDSN || '(' || MEMBER || ')'\n          CURDSN = CURDSN || COPIES(' ',54 - LENGTH(CURDSN))\n\n/* THE CURRENT LOGICAL SCREEN                                       */\n          ADDRESS ISPEXEC \"VGET ZSCREEN SHARED\"\n          SCREEN_NO = ZSCREEN\n\n/* EXECUTE THE FIND ALL <PARA-NAME> 08 COMMAND                      */\n          ADDRESS ISREDIT \"FIND ALL \"PARAGRAPH\" 08 \"\n\n/* IF THE FIND <PARA-NAME> COMMAND COMPLETES SUCCESSFULLY           */\n          IF RC = 0 THEN DO\n\n/* APPEND THE DATA TO END OF THE CALLSTK                            */\n             CALL VGET_CALL_STACK\n\n/* IF YOU'RE MINE'ING FOR THE VERY FIRST TIME IN THE TSO SESSION,   */\n/* THE VGET FAILS WITH A RETURN-CODE 08. HENCE INITIALISE THE       */\n/* CALLSTK VARIABLE TO SPACES.                                      */\n             IF RC > 0  THEN DO\n                CALLSTK = ''\n             END\n\n             CALLSTK = CALLSTK || RACF_ID || PARAGRAPH || CURDSN,\n                       || SCREEN_NO || LINE_NUMBER || '|'\n\n             CALL VPUT_CALL_STACK\n\n          END\n          ELSE DO\n             WARNMSG = '   THE <PARA-NAME> ON THE PERFORM STATEMENT COULD',\n                       'NOT BE FOUND'\n             Call prepare_popup\n             ADDRESS ISPEXEC \"ADDPOP ROW(19) COLUMN(01)\"\n             ADDRESS ISPEXEC \"DISPLAY PANEL(MINEMESG)\"\n             ADDRESS ISPEXEC \"REMPOP\"\n             Call free_popup\n          END\n        END\n     END\n     ELSE DO\n       WARNMSG = '   THIS IS NOT A PERFORM STATEMENT. POSITION THE',\n                 'CURSOR ON PERFORM <PARA>'\n       Call prepare_popup\n       ADDRESS ISPEXEC \"ADDPOP ROW(19) COLUMN(01)\"\n       ADDRESS ISPEXEC \"DISPLAY PANEL(MINEMESG)\"\n       ADDRESS ISPEXEC \"REMPOP\"\n       Call free_popup\n     END\n  END\n  ELSE DO\n     WARNMSG = '   THIS IS NOT A PERFORM STATEMENT. POSITION THE',\n               'CURSOR ON PERFORM <PARA>'\n     Call prepare_popup\n     ADDRESS ISPEXEC \"ADDPOP ROW(19) COLUMN(01)\"\n     ADDRESS ISPEXEC \"DISPLAY PANEL(MINEMESG)\"\n     ADDRESS ISPEXEC \"REMPOP\"\n     Call free_popup\n  END\n\n  RETURN\n\n/*__________________________________________________________________*/\n  MINE_OUT:\n/*-------                                                           */\n/* THIS ROUTINE JUMPS BACK FROM THE CALLED <PARA> TO THE CALLING    */\n/* <PARA>.                                                          */\n/*__________________________________________________________________*/\n\n/* FIND THE CURRENT PARAGRAPH IN WHICH <Pf4> KEY WAS PRESSED        */\n   ADDRESS ISREDIT \"FIND PREV P' #' 07\"\n   ADDRESS ISREDIT \"(LINEDATA) = LINE .ZCSR\"\n\n/* GET THE CURRENT PARAGRAPH NAME                                   */\n   PARSE VAR LINEDATA TAG 08 PARAGRAPH '.' .\n   PARAGRAPH = PARAGRAPH || COPIES(' ',30 - LENGTH(PARAGRAPH))\n\n/* GET THE RACFID OF THE USER                                       */\n   RACF_ID = USERID()\n   RACF_ID = RACF_ID || COPIES(' ',08 - LENGTH(RACF_ID))\n\n/* WHAT'S THE CURRENT DATASET NAME                                  */\n   ADDRESS ISREDIT \"(CURDSN) = DATASET\"\n   ADDRESS ISREDIT \"(MEMBER) = MEMBER\"\n   CURDSN = CURDSN || '(' || MEMBER || ')'\n   CURDSN = CURDSN || COPIES(' ',54 - LENGTH(CURDSN))\n\n/* THE CURRENT LOGICAL SCREEN                                       */\n   ADDRESS ISPEXEC \"VGET ZSCREEN SHARED\"\n   SCREEN_NO = ZSCREEN\n\n/* FORM THE SEARCH KEY                                              */\n/* 93    BYTES  <---08----|----30-----|---54----|----01---->         */\n   SEARCH_KEY =  RACF_ID || PARAGRAPH || CURDSN || SCREEN_NO\n\n/* VGET THE CALL STACK FROM THE APPLICATION SHARED POOL             */\n   CALL VGET_CALL_STACK\n\n\n/* GET THE TOTAL LENGTH OF THE CALLSTK STRING                       */\n   MAX_SIZE = LENGTH(CALLSTK)\n\n/* SEARCH THE CALLSTK STRING BACKWARDS                              */\n/* ITEM_LENGTH = 102 BYTES STEP_SIZE=102 BYTES                      */\n   DO I = (MAX_SIZE - ITEM_LENGTH + 1) TO 1 BY STEP_SIZE\n      EXTRACTED_STR = SUBSTR(CALLSTK,I,SEARCH_KEY_LENGTH)\n      J = J + ITEM_LENGTH\n      IF SEARCH_KEY = EXTRACTED_STR THEN DO\n         MATCH_FOUND = 1\n         LEAVE\n      END\n   END\n\n   IF MATCH_FOUND = 1 THEN DO\n\n      ITEM_FOUND = SUBSTR(CALLSTK,I,ITEM_LENGTH - 1)\n      LINE_NUMBER = SUBSTR(ITEM_FOUND,94,08)\n      ADDRESS ISREDIT \"UP MAX\"\n      ADDRESS ISREDIT \"CURSOR = \"LINE_NUMBER\"\"\n      ADDRESS ISREDIT \"FIND \"PARAGRAPH\"\"\n\n      PRECEDING_STR = SUBSTR(CALLSTK,1,I - 1)\n      SUCCEEDING_STR = SUBSTR(CALLSTK,I + ITEM_LENGTH,J)\n\n      CALLSTK = PRECEDING_STR || SUCCEEDING_STR\n\n      CALL VPUT_CALL_STACK\n\n   END\n\n   IF MATCH_FOUND = 0 THEN DO\n      WARNMSG = '             THERE ARE NO MORE LEVELS TO MINE BA',\n                || 'CK UP.                  '\n      Call prepare_popup\n      ADDRESS ISPEXEC \"ADDPOP ROW(19) COLUMN(01)\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(MINEMESG)\"\n      ADDRESS ISPEXEC \"REMPOP\"\n      Call free_popup\n   END\n\n   RETURN\n\n/*__________________________________________________________________*/\n   Gen_Flow_Graph:\n/* --------------                                                   */\n/* This paragraph is used to prepare first finds the para, for which*/\n/* the user requested the graph and then invoked Build_Graph and    */\n/* and Build_Dyn_Area routines.                                     */\n/*__________________________________________________________________*/\n\n   Curr_marker_pos = 0\n\n   Call Get_Para\n\n   Display_rc = 0\n\n   Do Until Display_rc = 08\n\n      Call Initialization\n\n      Graph_Para = Main_Para\n\n      Call Build_Graph\n      Call Build_Dyn_Area\n      Call Display_Dyn_Panel\n\n/*    Say 'zcmd : ' zcmd                                            */\n\n      If zcmd = 'NEXT' then do\n         Curr_marker_pos = Curr_marker_pos + 5\n/*       Say' curr_marker_pos = ' curr_marker_pos                   */\n      End\n\n      If zcmd = 'PREV' then do\n         Curr_marker_pos = Curr_marker_pos - 5\n         If Curr_marker_pos < 0 then do\n            Curr_marker_pos = 0\n         End\n/*       Say' curr_marker_pos = ' curr_marker_pos                   */\n      End\n   End\n\n   Address isredit \"LOCATE \"CURRPOS\"\"\n\n   RETURN\n\n/*__________________________________________________________________*/\n   Get_Para:\n/* --------------                                                   */\n/* UNDER WHICH PARAGRAPH WAS THE PF1 KEY PRESSED                    */\n/*__________________________________________________________________*/\n  ADDRESS ISREDIT \"(CURRPOS) = LINENUM .ZCSR\"\n  ADDRESS ISREDIT \"FIND PREV P' #' 07\"\n  ADDRESS ISREDIT \"(LINEDATA) = LINE .ZCSR\"\n  PARSE VAR LINEDATA TAG 08 MAIN_PARA  '.' .\n  Say 'CURRPOS = ' currpos\n\n  RETURN\n\n/*__________________________________________________________________*/\n   BUILD_GRAPH:\n/* --------------                                                   */\n/* THIS PARAGRAPH IS USED TO PREPARE AN MATRIX OF N X N, REPRESENTIN*/\n/* ALL THE CALLING PARAGRAPHS AND THE CALLED PARAGRAPHS.            */\n/* IT THEN DRAWS THE STRUCTURE CHART ON A DYNAMIC AREA.             */\n/*__________________________________________________________________*/\n\n/* COLLECT THE LIST OF ALL THE PARAGRAPHS IN AN ARRAY.              */\n  LBL = 'PD'\n  ADDRESS ISREDIT \"X ALL 07 '*'\"\n  ADDRESS ISREDIT \"F ALL 'PROCEDURE' 08\"\n  ADDRESS ISREDIT \"X ALL .ZF .ZCSR\"\n  ADDRESS ISREDIT \"UP MAX\"\n  DO FOREVER\n     ADDRESS ISREDIT \"F 08 P'\u00ac' NX\"\n     IF RC > 0 THEN DO\n        PARA_LIST.0 = PARA_IDX\n        ADDRESS ISREDIT \"RESET\"\n        LEAVE\n     END\n     ELSE DO\n/* GET THE CURRENT LINE DATA                                        */\n       ADDRESS ISREDIT\n       \"(LINEDATA) = LINE .ZCSR\"\n/* PARSE THE CURRENT LINE-OF-CODE, TO SEE IF THIS IS A PERFORM      */\n       PARSE VAR LINEDATA TAG 8,\n                          AREA_A '.'\n       IF INDEX(AREA_A,'EXIT') = 0\n       THEN DO\n          PARA_IDX = PARA_IDX + 1\n          PARA_LIST.PARA_IDX = AREA_A\n       END\n     END\n  END\n\n\n  N = PARA_IDX\n\n/* DISPLAY THE LIST OF PARAGRAPHS */\n\n/*DO I = 1 TO N\n   SAY PARA_LIST.I\nEND */\n\n/* BUILD THE FLOW GRAPH - IT WILL BE A N X N MATRIX                 */\n/* FIRST WE SHALL INITIALIZE THE MATRIX                             */\n  DO X = 1 TO N\n     DO Y = 1 TO N\n        GRAPH.X.Y = 0\n     END\n  END\n\n  DO PARA_IDX = 1 TO N\n/* POSITION THE CURSOR AT THE PARA                                  */\n     ADDRESS ISREDIT \"F ALL \"PARA_LIST.PARA_IDX\" 08\"\n     ADDRESS ISREDIT \"(LINENUM) = LINENUM .ZCSR\"\n     ADDRESS ISREDIT \"(LASTLIN) = LINENUM .ZLAST\"\n/*   SAY 'PARA:' PARA_LIST.PARA_IDX                              */\n/* READ ALL THE LINES IN THIS PARAGRAPH TILL THE END-OF-PARA        */\n     DO FOREVER\n/* QUERY THE LINE-NUMBER                                            */\n        LINENUM = LINENUM + 1\n        ADDRESS ISREDIT  \"(LINEDATA) = LINE \"LINENUM\"\"\n\n/*      SAY 'LINEDATA : ' LINEDATA                                  */\n\n        PARSE VAR LINEDATA TAG 8,\n                           AREA_A 12,\n                           AREA_B 72,\n                           COMMENT\n\n/* FIX TO IGNORE COMMENT LINES                                      */\n        IF SUBSTR(TAG,7,1) = '*' THEN DO\n           ITERATE\n        END\n\n        IF (AREA_A  > '' & (SUBSTR(TAG,7,1) <> '*')),\n           | (LINENUM > LASTLIN) THEN DO\n/*         SAY PARA_LIST.PARA_IDX ' ENDED AT ' LINENUM            */\n           LEAVE\n        END\n/* IF A PERFORM STATEMENT IS FOUND ON THIS LINE                     */\n        IF INDEX(AREA_B,'PERFORM') > 0   DO\n        THEN DO\n           PARSE VAR AREA_B VERB PARAGRAPH .\n           IF PARAGRAPH = 'VARYING' | PARAGRAPH = 'UNTIL' THEN DO\n              ITERATE\n           END\n\n           ELSE DO\n              X = PARA_IDX\n/* SEARCH THIS PARAGRAPH NAME IN THE PARA_LIST                      */\n              DO Y = 1 TO N\n                 IF PARA_LIST.Y = PARAGRAPH THEN DO\n/* THERE SHOULD BE AN EDGE FROM X TO Y                              */\n                    GRAPH.X.Y = 1\n                 END\n              END\n           END\n        END\n     END\n  END\n\n/*DO X = 1 TO N\n     DO Y = 1 TO N\n        SAY 'GRAPH(' X ',' Y ')' GRAPH.X.Y\n     END\n  END */\n\n/* FIND OUT ALL EDGES LEADING INTO THE GRAPH_PARA - CALLER_LIST     */\n\n  DO Y = 1 TO N\n     IF PARA_LIST.Y = GRAPH_PARA THEN DO\n        LEAVE\n     END\n  END\n  I = 0\n  DO X = 1 TO N\n     IF GRAPH.X.Y = 1 THEN DO\n        I = I + 1\n        CALLER_LIST.I = PARA_LIST.X\n/*      SAY 'CALLER_LIST.' I ' = ' CALLER_LIST.I                    */\n     END\n  END\n\n  X = Y\n/* FIND OUT ALL EDGES GOING OUT OF THE GRAPH_PARA - CALLED_LIST     */\n  I = 0\n  DO Y = 1 TO N\n     IF GRAPH.X.Y = 1 THEN DO\n        I = I + 1\n        CALLED_LIST.I = PARA_LIST.Y\n/*      SAY 'CALLED_LIST.' I ' = ' CALLED_LIST.I                    */\n     END\n  END\n\n  RETURN\n\n/*__________________________________________________________________*/\n   BUILD_DYN_AREA:\n/* --------------                                                   */\n/* This paragraph is used to prepare an matrix of n x n, representin*/\n/* all the calling paragraphs and the called paragraphs.            */\n/* It then draws the structure chart on a dynamic area.             */\n/*__________________________________________________________________*/\n\n/*\nLayout of the Dynamic Area\n__________________________\n\n----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n   $0000-MAIN          \u00a2-----$2000-MAINLINE-PROCE\u00a2-----$2500-DISPLAY-DATA  \u00a2\n    <<----- 19 ------>>       <<------ 19 ----->>     <<------ 19 ----->>\n\n\nHow PF7 and PF8 Scrolling works ?\n_______________________________\nThe curr_marker_pos keeps track of the current position. Each time\na scroll up, subtracts 5 to curr_marker_pos, a scroll down adds 5 to\ncurr_marker_pos.\n\nWe check if either the Caller_list or Called_list have no. of elements\ngreater than the value of curr_marker_pos. If so, we must display the\nremaining flow on the screen.\n\n*/\n\n/* PF7 and PF8 Logic                                               */\n   Curr_marker_pos = Curr_marker_pos + 1\n\n   If Caller_list.curr_marker_pos > '' then do\n      Respect_cmd = 'Yes'\n      Caller_list_has_more_items = 'Yes'\n   End\n   Else do\n      Respect_cmd = 'No'\n      Caller_list_has_more_items = 'No'\n   End\n\n   If Called_list.curr_marker_pos > '' then do\n      Respect_cmd = 'Yes'\n      Called_list_has_more_items = 'Yes'\n   End\n   Else do\n      Respect_cmd = 'No'\n      Called_list_has_more_items = 'No'\n   End\n\n/* Say 'Caller_List_has_more_items = ' Caller_List_has_more_items  */\n/* Say 'Called_List_has_more_items = ' Called_List_has_more_items  */\n   Curr_marker_pos = Curr_marker_pos - 1\n\n/* Find out the Caller_List_Size and Called_List_Size              */\n\n   I = 1\n   Do Forever\n      If Caller_List.I = '' then do\n         Caller_List_Size = I - 1\n         Leave\n      End\n      Else do\n         I = I + 1\n      End\n   End\n\n   I = 1\n   Do Forever\n      If Called_List.I = '' then do\n         Called_List_Size = I - 1\n         Leave\n      End\n      Else do\n         I = I + 1\n      End\n   End\n\n/* Find Caller_List_Max_Pos and Called_List_Max_Pos                */\n   Caller_List_Max_Pos = Caller_List_Size - (Caller_List_Size // 5)\n   Called_List_Max_Pos = Called_List_Size - (Called_List_Size // 5)\n\n/* Say 'Caller_List_Size    : ' Caller_List_Size\n   Say 'Called_List_Size    : ' Called_List_Size\n   Say 'Caller_List_Max_Pos : ' Caller_List_Max_Pos\n   Say 'Called_List_Max_Pos : ' Called_List_Max_Pos                */\n\n/* Build the Dynamic Area                                          */\n\n   DO I = 1 TO 05\n      If Caller_list_has_more_items = 'Yes' then do\n         INDX = curr_marker_pos + I\n/*       Say 'Copying CALLER_LIST.' INDX ' TO DYN_CALLER_LIST.' I   */\n         DYN_CALLER_LIST.I = SUBSTR(CALLER_LIST.INDX,1,19)\n      End\n      Else do\n         INDX = Caller_List_Max_Pos + I\n/*       Say 'Copying CALLER_LIST.' INDX ' TO DYN_CALLER_LIST.' I   */\n         DYN_CALLER_LIST.I = SUBSTR(CALLER_LIST.INDX,1,19)\n      End\n\n      If Called_list_has_more_items = 'Yes' then do\n         INDX = curr_marker_pos + I\n/*       Say 'Copying CALLED_LIST.' INDX ' TO DYN_CALLED_LIST.' I   */\n         DYN_CALLED_LIST.I = SUBSTR(CALLED_LIST.INDX,1,19)\n      End\n      Else do\n         INDX = Called_List_Max_Pos + I\n/*       Say 'Copying CALLED_LIST.' INDX ' TO DYN_CALLED_LIST.' I   */\n         DYN_CALLED_LIST.I = SUBSTR(CALLED_LIST.INDX,1,19)\n      End\n\n      IF DYN_CALLER_LIST.I > '' THEN DO\n         DYN_CALLER_LIST.I = '$' || LEFT(DYN_CALLER_LIST.I,19) || '\u00a2'\n         SHAD_CALLER_LIST.I = ' ' || COPIES('Y',19) || ' '\n/*       SAY 'CALLER_LIST(' I ') = ' DYN_CALLER_LIST.I              */\n      END\n      ELSE DO\n         DYN_CALLER_LIST.I = COPIES(' ',21)\n         SHAD_CALLER_LIST.I = COPIES(' ',21)\n      END\n      IF DYN_CALLED_LIST.I > '' THEN DO\n         DYN_CALLED_LIST.I = '$' || LEFT(DYN_CALLED_LIST.I,19) || '\u00a2'\n         SHAD_CALLED_LIST.I = ' ' || COPIES('Y',19) || ' '\n      END\n      ELSE DO\n         DYN_CALLED_LIST.I = COPIES(' ',21)\n         SHAD_CALLED_LIST.I = COPIES(' ',21)\n      END\n   END\n\n   CALL Build_connector_array\n\n   GRAPH_PARA = SUBSTR(GRAPH_PARA,1,19)\n   GRAPH_PARA = '$' || LEFT(GRAPH_PARA,19) || '\u00a2'\n\n   DYNVAR = ''\n   SHADVAR = ''\n\n   DYNVAR = DYNVAR ||,\n           DYN_CALLER_LIST.1 || CALLER_CONNECTOR.1 || GRAPH_PARA        ||,\n                                CALLED_CONNECTOR.1 || DYN_CALLED_LIST.1 ||,\n                                COPIES(' ',02)     ||,\n           COPIES(' ',21)    || CALLER_CONNECTOR.2 || COPIES(' ',21)    ||,\n           CALLED_CONNECTOR.2|| COPIES(' ',23),\n      ||   DYN_CALLER_LIST.2 || CALLER_CONNECTOR.3 || COPIES(' ',21)    ||,\n                                CALLED_CONNECTOR.3 || DYN_CALLED_LIST.2 ||,\n                                COPIES(' ',02)     || ,\n           COPIES(' ',21)    || CALLER_CONNECTOR.4 || COPIES(' ',21)    ||,\n           CALLED_CONNECTOR.4|| COPIES(' ',23),\n      ||   DYN_CALLER_LIST.3 || CALLER_CONNECTOR.5 || COPIES(' ',21)    ||,\n                                CALLED_CONNECTOR.5 || DYN_CALLED_LIST.3 ||,\n                                COPIES(' ',02)     || ,\n           COPIES(' ',21)    || CALLER_CONNECTOR.6 || COPIES(' ',21)    ||,\n           CALLED_CONNECTOR.6|| COPIES(' ',23),\n      ||   DYN_CALLER_LIST.4 || CALLER_CONNECTOR.7 || COPIES(' ',21)    ||,\n                                CALLED_CONNECTOR.7 || DYN_CALLED_LIST.4 ||,\n                                COPIES(' ',02)     || ,\n           COPIES(' ',21)    || CALLER_CONNECTOR.8 || COPIES(' ',21)    ||,\n           CALLED_CONNECTOR.8|| COPIES(' ',23),\n      ||   DYN_CALLER_LIST.5 || CALLER_CONNECTOR.9 || COPIES(' ',21)    ||,\n                                CALLED_CONNECTOR.9 || DYN_CALLED_LIST.5 ||,\n                                COPIES(' ',02)\n\n   SHADVAR = SHADVAR,\n          ||SHAD_CALLER_LIST.1  || COPIES(' ',06) || COPIES('Y',19),\n                                || COPIES(' ',06) || SHAD_CALLED_LIST.1,\n                                || COPIES(' ',02) || COPIES(' ',75),\n          ||SHAD_CALLER_LIST.2  || COPIES(' ',05) || COPIES(' ',21),\n                                || COPIES(' ',05) || SHAD_CALLED_LIST.2,\n                                || COPIES(' ',02) || COPIES(' ',75),\n          ||SHAD_CALLER_LIST.3  || COPIES(' ',05) || COPIES(' ',21),\n                                || COPIES(' ',05) || SHAD_CALLED_LIST.3,\n                                || COPIES(' ',02) || COPIES(' ',75),\n          ||SHAD_CALLER_LIST.4  || COPIES(' ',05) || COPIES(' ',21),\n                                || COPIES(' ',05) || SHAD_CALLED_LIST.4,\n                                || COPIES(' ',02) || COPIES(' ',75),\n          ||SHAD_CALLER_LIST.5  || COPIES(' ',05) || COPIES(' ',21),\n                                || COPIES(' ',05) || SHAD_CALLED_LIST.5,\n                                || COPIES(' ',02)\n\n   RETURN\n\n/*__________________________________________________________________*/\n   Display_Dyn_Panel:\n/* -----------------                                                */\n/* This routine builds an ISPF Panel on the fly and displays it.    */\n/*__________________________________________________________________*/\n   ZPF07 = 'PREV'\n   ZPF08 = 'NEXT'\n   ZCMD  = ''\n   ROW   = 0\n   COL   = 0\n\n   Call load_dynlib\n   Call put_object\n\n   Address ispexec \"libdef ispplib library id(\"dynlib\") stack\"\n/* SAY 'LIBDEF RC = ' RC                                            */\n\n   Address Ispexec \"VPUT (ZPF07,ZPF08) PROFILE\"\n/* Say 'VPUT RC: ' RC                                               */\n   Address Ispexec \"ADDPOP ROW(05) COLUMN(01)\"\n   IF RC > 0 THEN DO\n      Say 'ADDPOP RC = ' RC\n      EXIT\n   end\n\n   Address Ispexec \"DISPLAY PANEL(DYNPANE)\"\n   Display_rc = rc\n\n   Address ISPEXEC \"REMPOP\"\n   Address Ispexec \"libdef ispplib\"\n   Address tso \"free f(\"dynlib\")\"\n   TrapON=OutTrap('ON')\n   Address tso \"delete '\"tempds\"'\"\n/* SAY 'DISPLAY_RC : ' DISPLAY_RC                                   */\n   RETURN\n\n/*__________________________________________________________________*/\n   load_dynlib:\n/* -----------------                                                */\n/* This routine queues the panel body, and then stores it in a mem. */\n/*__________________________________________________________________*/\n   dynlib = 'dyn'||random(99999)\n   tempds = USERID()|| '.ISPPLIB.TMP' ||random(9999)\n   alloc_fi = \"ALLOC FI (\"dynlib\") da('\"tempds\"')\" ||,\n           \" lrecl(80) blksize(800)\" ||,\n           \" new reu\" ||,\n           \" space(5,5) dir(10) \"\n\n   ADDRESS TSO \"\"alloc_fi\"\"\n\n\n   if rc = 0 then do\n      ispdyn = tempds\n   end\n   else do\n      ispdyn = 'NOT FOUND'\n      Say 'Failed to allocated Dynamic Library'\n      Say '//' || dynlib || ' DD DSN=' || tempds\n      Say rc\n      exit\n   end\n\n   Address tso\n   \"newstack\"\n\n   member = 'DYNPANE'\n   queue ')ATTR'\n   queue '@ AREA(DYNAMIC) SCROLL(OFF)'\n   queue 'Y TYPE(CHAR) COLOR(TURQUOISE) HILITE(REVERSE)'\n   queue '~ TYPE(CHAR) COLOR(GREEN)'\n   queue '$ TYPE(DATAIN) COLOR(TURQUOISE) HILITE(REVERSE)'\n   queue '_ TYPE(NEF) PADC(_)'\n   queue '| TYPE(TEXT) COLOR(YELLOW)'\n   queue '\u00a2 TYPE(DATAOUT) COLOR(BLUE)'\n   queue '? TYPE(NT)'\n   queue ')BODY WINDOW(76,12) CMD(ZCMD)'\n   queue '|                        MINE - Structure Chart Generator' ||,\n         '                  +'\n   queue '?Command ==> _ZCMD                                       ' ||,\n         '                  +'\n   queue '?                                                        ' ||,\n         '                  +'\n   queue '+@DYNVAR,SHADVAR                                         ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue '+@                                                       ' ||,\n         '                  @'\n   queue ')PROC'\n   queue '&PFKEY=.PFKEY'\n   queue ')END'\n\n   RETURN\n\n/*__________________________________________________________________*/\n   put_object:\n/* ----------                                                       */\n/* This routine stores the member into the Temporary ISPF Library   */\n/* allocated previously.                                            */\n/*__________________________________________________________________*/\n   tfil = 'tfil' || random(9999)\n   Address tso\n   \"alloc f(\"tfill\") da('\"ispdyn\"(\"member\")') shr reu\"\n   if rc > 0 then do\n      say 'Failed to allocate member, RC = ' rc\n   end\n   Address tso\n   \"execio\" queued() \"diskw \"tfill\" (finis\"\n   \"free f(\"tfill\")\"\n   \"delstack\"\n\n   RETURN\n\n   Build_connector_array:\n\n/* BUILD THE CONNECTOR ARRAY                                        */\n  IF Dyn_CALLER_LIST.1 > '' THEN DO\n     CALLER_CONNECTOR.1 = '-----'\n  END\n  ELSE DO\n     CALLER_CONNECTOR.1 = COPIES(' ',05)\n  END\n  J = 1\n  DO J = 02 TO 05\n     I = (J - 1)*2\n     IF Dyn_CALLER_LIST.J > '' THEN DO\n        CALLER_CONNECTOR.I = '  |  '\n        I = I + 1\n        CALLER_CONNECTOR.I = '--+  '\n     END\n     ELSE DO\n        CALLER_CONNECTOR.I = '     '\n        I = I + 1\n        CALLER_CONNECTOR.I = '     '\n     END\n  END\n\n  IF Dyn_CALLED_LIST.1 > '' THEN DO\n     CALLED_CONNECTOR.1 = '-----'\n  END\n  ELSE DO\n     CALLED_CONNECTOR.1 = COPIES(' ',05)\n  END\n  J = 1\n  DO J = 02 TO 05\n     I = (J - 1)*2\n     IF Dyn_CALLED_LIST.J > '' THEN DO\n        CALLED_CONNECTOR.I = '  |  '\n        I = I + 1\n        CALLED_CONNECTOR.I = '  +--'\n     END\n     ELSE DO\n        CALLED_CONNECTOR.I = COPIES(' ',05)\n        I = I + 1\n        CALLED_CONNECTOR.I = COPIES(' ',05)\n     END\n  END\n\n  Return\n\n/*__________________________________________________________________*/\n   Prepare_popup:\n/* -------------                                                    */\n/* This routine builds the popup screen on-the-fly, does necessary  */\n/* allocations and LIBDEF's it to the ISPPLIB.                      */\n/*__________________________________________________________________*/\n   dynlib = 'dyn'||random(99999)\n   tempds = USERID()|| '.ISPPLIB.TMP' ||random(9999)\n   alloc_fi = \"ALLOC FI (\"dynlib\") da('\"tempds\"')\" ||,\n           \" lrecl(80) blksize(800)\" ||,\n           \" new reu\" ||,\n           \" space(5,5) dir(10) \"\n\n   ADDRESS TSO \"\"alloc_fi\"\"\n\n\n   if rc = 0 then do\n      ispdyn = tempds\n   end\n   else do\n      ispdyn = 'NOT FOUND'\n      Say 'Failed to allocated Dynamic Library'\n      Say '//' || dynlib || ' DD DSN=' || tempds\n      Say rc\n      exit\n   end\n\n   Address tso\n   \"newstack\"\n\n   member = 'MINEMESG'\n   queue   ')ATTR'\n   queue   '  $ TYPE(CT)'\n   queue   '  @ TYPE(PT)'\n   queue   '  + TYPE(NT)'\n   queue   '  # TYPE(OUTPUT) CAPS(ON) COLOR(YELLOW)'\n   queue   ')BODY WINDOW(76,03)'\n   queue   '@                               MINE ERROR'\n   queue   '#WARNMSG'\n   queue   ')END'\n\n   tfil = 'tfil' || random(9999)\n   Address tso\n   \"alloc f(\"tfill\") da('\"ispdyn\"(\"member\")') shr reu\"\n   if rc > 0 then do\n      say 'Failed to allocate member, RC = ' rc\n   end\n   Address tso\n   \"execio\" queued() \"diskw \"tfill\" (finis\"\n   \"free f(\"tfill\")\"\n   \"delstack\"\n\n   Address ispexec \"libdef ispplib library id(\"dynlib\") stack\"\n   return\n\n/*__________________________________________________________________*/\n   Free_popup:\n/* -------------                                                    */\n/* Frees the ISPF Tempoprary dataset and deletes it.                */\n/*__________________________________________________________________*/\n   Address Ispexec \"libdef ispplib\"\n   Address tso \"free f(\"dynlib\")\"\n   TrapON=OutTrap('ON')\n   Address tso \"delete '\"tempds\"'\"\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT891/FILE891.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT891", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}