{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012151000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE490.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE490.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x07'", "DS1TRBAL": "b'\\x91n'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\x8e\\x00\\x03\\x03\\x8e\\x00\\x0c\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x00%\\x01\\x102O\\x01\\x102O \\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-11-20T00:00:00", "modifydate": "2010-11-20T20:14:25", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-480"}, "text": "REGULAR CBT TAPE - VERSION 480    FILE:  490\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT480.FILE490\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 35 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,043 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/20/10    20:14:25    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x005_\\x01\\x005_\\x11W\\x00\\x12\\x00\\r\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-12-20T00:00:00", "modifydate": "2000-12-20T11:57:00", "lines": 18, "newlines": 13, "modlines": 0, "user": "WSBG"}, "text": "Here are two files from my site in TSO XMIT format:\n\n    1)  XMITMAIL - a \"lite, fast\" version of XMITIP, written in\nCOBOL, callable from any HLL in batch or CICS.  Attachments\nonly supported if you format them yourself. (File 490)\n\n    2)  INSTASM   -  library of macros useful for reentrant\nassembler programming, including a reentrant date conversion\nroutine.                                    (File 491)\n\nMuch thanks to Lionel Dyck.  His version of XMITIP (the original,\nwritten in REXX) is on File 312 of the CBT Tape.\n\n    Andy Robertson <andywrobertson@clara.co.uk>\n\n    home site:  http://home.clara.net/andywrobertson/mvsindex.html\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x05\\x07\\x0f\\x01\\x05\\x07\\x0f\\x107\\x00\\x19\\x00\\x19\\x00\\x00\\xc1\\xd5\\xc4\\xe8\\xd9@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-11T00:00:00", "modifydate": "2005-03-11T10:37:22", "lines": 25, "newlines": 25, "modlines": 0, "user": "ANDYR"}, "text": "Sam, here are up to date versions of the MVS freeware I have\nwritten, for the CBT tape.  They are in zipped binary XMIT\nformat.  I am not sure if they are on the tape or the overflow\nalready - I have a feeling I sent versions a few years ago but I\ncan't find them - but if they are they won't be up to date.\n\n\nLECH\nA sample LE condition handler. Code two COPY statements in your\ncobol mainline. Interrupts will be intercepted with a dump and a\nmessage and your program will continue to run.\n\nBATCHART.\nDrive the GDDM-PGF CHART utility in batch using a SYSIN-type file\nof commands. No terminal required.  Create gifs in batch.\n\nINSTASM\nA set of assembler macros useful for building re-entrant\nassembler programs, date handling, parsing and stringing, and\nsome utilities.\n\nXMITCICS / XMITMAIL\n\"lite\" version of XMITIP, in Cobol, usable from CICS\n\nAndy Robertson\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x102O\\x01\\x102O \\x14\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-11-20T00:00:00", "modifydate": "2010-11-20T20:14:11", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT updates\nFrom:     \"pinlighter\" <pinlighter@btconnect.com>\nDate:     Sat, 20 Nov 2010 21:54:48 -0000\nTo:       <sbgolob@cbttape.org>\n\nSam\n\nHere are updated versions of my freeware: I think on Files 490 491.\n\nINSTASM\nLECH\nBATCHART\nXMITMAIL/XMITCICS\n\nHome has now moved to\n\nhttp://www.thenightland.co.uk/MYWEB/mvsindex.html\n\nHope this is OK - many thanks for your work\n\nAndy Robertson\n\ninstasm.xmit\nbatchart.xmit\nlech.xmit\nxmitmail.xmit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00 \\x00\\x985/\\x01\\x04\\x00/\\x14%\\x00)\\x005\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1998-12-18T00:00:00", "modifydate": "2004-01-02T14:25:20", "lines": 41, "newlines": 53, "modlines": 0, "user": "TSO057"}, "text": "\n      The macros/routine in the INSTASM library are useful in\n      building reentrant ASSEMBLER programs.\n\n      They include entry/exit macros, procedure macros, a\n      date-processing routine, a messaging routine, a \"string\" macro\n      which combines and edits different fields into a single output\n      field, and a parsing macro\n\n      I have used them in system exits such as IEFUJV\n\n      See member INSTDOC for furthur information\n\n\n\n\n\n\n\n\n      Copyright (C) 2000  Andy Robertson\n\n      This program is free software; you can redistribute it and/or\n      modify it under the terms of the GNU General Public License as\n      published by the Free Software Foundation; either version 2 of the\n      License, or (at your option) any later version.\n\n      This program is distributed in the hope that it will be useful,\n      but WITHOUT ANY WARRANTY; without even the implied warranty of\n      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n      GNU General Public License for more details.\n\n      You should have received a copy of the GNU General Public License\n      along with this program; if not, write to the Free Software\n      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE490": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x00\\x19\\x01\\x102O\\x01\\x102O \\x14\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-11-20T00:00:00", "modifydate": "2010-11-20T20:14:19", "lines": 15, "newlines": 15, "modlines": 0, "user": "CBT-480"}, "text": "//***FILE 490 is from Andy Robertson and contains a useful set      *   FILE 490\n//*           of Assembler Macros.  These macros make it easier     *   FILE 490\n//*           to write re-entrant programs.                         *   FILE 490\n//*                                                                 *   FILE 490\n//*     INSTASM   -  library of macros useful for reentrant         *   FILE 490\n//*                  assembler programming, including a             *   FILE 490\n//*                  reentrant date conversion routine.             *   FILE 490\n//*                                                                 *   FILE 490\n//*     Andy Robertson <pinlighter@btconnect.com>                   *   FILE 490\n//*                                                                 *   FILE 490\n//*     home site:                                                  *   FILE 490\n//*         http://www.thenightland.co.uk/MYWEB/mvsindex.html       *   FILE 490\n//*                                                                 *   FILE 490\n//*     modified:   November 20, 2010                               *   FILE 490\n//*                                                                 *   FILE 490\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSTBALI": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00!\\x00\\x985/\\x01\\t\\x13_\\x10\\x12\\x00+\\x00\\x14\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1998-12-18T00:00:00", "modifydate": "2009-05-15T10:12:21", "lines": 43, "newlines": 20, "modlines": 0, "user": "TSO057"}, "text": "       MACRO\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n.*\n.*\n.* BALI FOR RENT ASM PROGRAM START \"PERFORMED\" PROCEDURE BY BAL R1,NAME\n.*\n.*\n.*\n&NAME  INSTBALI &TRACE=\n         GBLA  &INSTBALN\n         AIF   ('&NAME' NE '').NAMEOK\n         MNOTE 8,'NAME MUST BE SPECIFIED'\n         MEXIT\n.NAMEOK  ANOP\n\n       AIF ('&TRACE' NE 'TPUT').TPUTZ\n\n&NAME  DS    0H\n       ST    R1,INSTWORK_BAL+4*&INSTBALN\n\n&INSTBALN  SETA  &INSTBALN+1\n\n\n       TPUT  &NAME._INSTBALI_FLAG,L'&NAME._INSTBALI_FLAG\n       B     &NAME._INSTBALI_FLAG_Z\n&NAME._INSTBALI_FLAG DC C'&NAME'\n&NAME._INSTBALI_FLAG_Z DS  0H\n        MEXIT\n.TPUTZ   ANOP\n\n\n\n&NAME  DS    0H\n\n       ST    R1,INSTWORK_BAL+4*&INSTBALN\n\n&INSTBALN  SETA  &INSTBALN+1\n\n       MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTBALO": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x003\\x00\\x985/\\x01\\x004\\x9f\\x13R\\x00\\x12\\x00\\r\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1998-12-18T00:00:00", "modifydate": "2000-12-14T13:52:33", "lines": 18, "newlines": 13, "modlines": 0, "user": "TSO057"}, "text": "       MACRO\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n.*\n.*\n.* BALO FOR RENT ASM PROGRAM END \"PERFORMED\" PROCEDURE BY BAL R1,NAME\n.*\n.*\n&NAME  INSTBALO\n       GBLA  &INSTBALN\n&NAME  DS    0H\n       L     R1,INSTWORK_BAL+4*&INSTBALN-4\n       BR    R1\n\n       MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTCNVX": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x004\\x9f\\x01\\x004\\x9f\\x15\\x16\\x008\\x006\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-14T00:00:00", "modifydate": "2000-12-14T15:16:46", "lines": 56, "newlines": 54, "modlines": 0, "user": "TSO057"}, "text": "**********************************************************************\n*\n*  12/12/00  1.0    WRITTEN                                     AWR *\n*\n**********************************************************************\n\n**********************************************************************\n*        SIMPLE HEX CONVERSION ROUTINE\n*        PARAMETERS: FROM-FIELD, TO-FIELD, LENGTH\n**********************************************************************\n\nINSTCNVX INSTSS SAVEAREA=NO          TO SAVE TIME, NO GETMAIN/FREEMAIN      0000\n\n         LM    R2,R4,0(R1)              PICK UP 3 ADDS                      0001\n         L     R4,0(R4)                 LEN IN R4\n         LTR   R4,R4                    LEN VALID > 0 ?\n         BNP   ERROR_EXIT               NO-> ERREXIT                        0004\n*                                                                           0005\n******** PROCESSING OF VALID PARAMETERS                                     0006\n*                                                                           0007\nCHAR_LOOP DS   0H                       LOOP\n         SLR   R1,R1\n         IC    R1,0(R2)\n         SLL   R1,1                     R1 = OFFSET IN TAB\n         LA    R8,XTAB(R1)\n         MVC   0(2,R3),0(R8)\n         LA    R2,1(R2)\n         LA    R3,2(R3)\n         BCT   R4,CHAR_LOOP\n\n\n         INSTRS  RC=0                                                       0057\n\n\nERROR_EXIT EQU *                        EXIT DOING NOWT                     0058\n         INSTRS RC=0                                                        0060\n\n\n\nXTAB     DC    C'000102030405060708090A0B0C0D0E0F'\n         DC    C'101112131415161718191A1B1C1D1E1F'\n         DC    C'202122232425262728292A2B2C2D2E2F'\n         DC    C'303132333435363738393A3B3C3D3E3F'\n         DC    C'404142434445464748494A4B4C4D4E4F'\n         DC    C'505152535455565758595A5B5C5D5E5F'\n         DC    C'606162636465666768696A6B6C6D6E6F'\n         DC    C'707172737475767778797A7B7C7D7E7F'\n         DC    C'808182838485868788898A8B8C8D8E8F'\n         DC    C'909192939495969798999A9B9C9D9E9F'\n         DC    C'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    C'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    C'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    C'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    C'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    C'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTDOC": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00U\\x01\\x004\\x9f\\x01\\x05\\x06?\\x14D\\x01P\\x00v\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2000-12-14T00:00:00", "modifydate": "2005-03-04T14:44:55", "lines": 336, "newlines": 118, "modlines": 0, "user": "TSO057"}, "text": "   ----------------------------------------------------------------\n   12/12/00  1.0    written                                     AWR\n   27/12/00  1.1    INSTSTR added                               AWR\n   27/12/01  1.2    INSTLXSV, INSTTCMD, added                   AWR\n   27/12/02  1.3    INSTPRS added                               AWR\n   17/05/03  1.4    INSTGET,INSTSET, INSTUJI added              AWR\n   17/12/03  1.5    INSTWTL                                     AWR\n   01/01/04  1.6    INSTNUM                                     AWR\n   09/09/04  1.7    INSTPDSL                                    AWR\n   ----------------------------------------------------------------\n\n\n\n\n    Macros and routines in INSTASM\n    ------------------------------\n\n    These are for use in system exits and reentrant assembler programs.\n\n    They create REENTRANT code, which can run in AMODE 31 or 24.\n\n    I have used them in system exits, for example IEFUJV\n\n\n\n\n    For examples of their use, see the INSTIVP program\n\n\n\n\n    Macros\n    ------\n\n\n      1)  INSTSS       -  Entry of reentrant module.  Getmains Save\n                          area and Working Storage in dsect defined by\n                          INSTWORK START.  Getmain is below the line to\n                          allow for possible AMODE 24 running.\n\n\n      2)  INSTRS       -  Exit of reentrant module.  Freemains Save\n                          area and Working Storage.\n\n\n      3)  INSTWORK     -  Defines  Working Storage - R/W area of module\n                          with save area at start.\n\n                          Use these three together thus:\n\n\n                          name   INSTSS\n                                     ...\n                                   (code)\n                                     ...\n                                     ...\n\n                                 INSTRS\n\n                                     ...\n                                   (read-only data)\n                                     ...\n                                     ...\n                                 LTORG\n\n                                 INSTWORK START\n\n                                     ...\n                                   (read-write data)\n                                     ...\n                                     ...\n\n                                 INSTWORK END\n\n                                   (Other dsects)\n\n                                 END\n\n\n                          Standard register use is that R12 is base\n                          register for the module, R13 for the working\n                          storage.\n\n\n                          If you do not require a save area use\n\n                              INSTSS SAVEAREA=NO\n\n                          INSTSS will do no getmain and\n                          INSTRS will do no freemain.\n\n                         (You cannot use INSTWORK, INSTSTR, INSTPRS or\n                          INSTBALI/O)\n\n\n      4)  INSTBALI/O   -  Procedure entry/exit macro - supports\n                          procedures that can be invoked from other\n                          parts of the program by a\n\n                            BAL R1,procedure_name\n\n                          Invocations can be nested to any depth. Return\n                          addresses are held in cells automatically\n                          generated by INSTWORK\n\n                          You must use INSTSS, INSTRS and INSTWORK to\n                          use INSTBALI/O\n\n\n      5)  INSTREQU     -  R0 EQU 0\n                          R1 EQU 1\n                          R2 EQU 2\n                          . . . . .\n                          etc . . .\n\n\n                          Not a complicated macro!\n\n\n\n      6)  INSTSTR      -  STRING FIELDS TOGETHER INTO A RECEIVING\n                          FIELD.\n\n\n                          INSTSTR  F1,F2,F3.... RES=R\n\n                          Fn  May be\n\n\n                             -  A literal  ' HI THERE '\n\n                             -  A field name\n\n                             -  A number.  This number of spaces\n                                are inserted\n\n                             -  *+number.  Reposition to this number\n                                of spaces from start of receiving\n                                field\n\n                             -  A formatted field. Fields may be\n                                formatted as numeric or hex\n\n                                for example\n\n\n                                  (fieldname,X) - hex\n\n                                  (fieldname,N) - numeric.  Packed,\n                                                  binary fields are\n                                                  suitably interpreted\n\n                                  (fieldname,N,12) - numeric, left\n                                                     just to 12 bytes\n\n                             -  A register, in brackets.  Registers can\n                                be formatted as hex or numeric, like\n                                fields\n\n\n                          For examples, see INSTIVP\n\n\n\n                          The \"corruptible\" registers R14-R1 are saved\n                          before INSTSTR starts and the saved version\n                          is what is displayed\n\n\n\n                          INSTSTR requires INSTWORK.\n\n\n\n                ** NOTE   Also if you use it you must include a\n\n                            COPY INSTSTRC\n\n                          at the end of your deck.  INSTSTRC is a\n                          auxillary routine needed for INSTSTR\n                          (You may at your discretion assemble INSTSTRC\n                          to object code and include it at linkedit\n                          time)\n\n\n      7)  INSTPRS      -  PARSE A FIELD INTO SUBFIELDS\n\n\n                          INSTPRS  FIELD,RES=(RES1,RES2,RES3),DLM=','\n\n                          FIELD is a field containing data\n\n                          RES1, RES2, RES3 . . .  (up to 30) are\n                          receiving fields where the parsed results\n                          will be placed left-justified\n\n                          DLM is a set of delimiter characters.  There\n                          may be more than one, but if so the single\n                          characters are (all) used as delimiters.  You\n                          cannot specify a string.\n\n                          Leading delimiters in FIELD are ignored.\n\n                          INSTPRS requires INSTWORK.\n\n\n      8)  INSTNUM      -  GET THE NUMERIC VALUE OF A CHAR STRING\n\n\n                          INSTNUM  FIELD\n\n                          A very simple macro to read a number\n                          freeformat.  The field must be an optional\n                          string of blanks followed by a string of\n                          digits and an optional string of blanks.\n                          That is to say, it is a line with a number in\n                          it somewhere, not necessarily at the start.\n\n                          On exit, R1 holds the parsed out numeric\n                          value and R15 is 0 if all valid or 4 if\n                          format error.\n\n\n\n\n    Callable routines\n    -----------------\n\n\n      1)  INSTDTID     -  CALLable routine to convert from ISO date\n                          YYYY-MM-DD to and from a fullword\n                          (DAYS_SINCE_1_JAN_1_AD+1).\n\n                          This number is is of course meaningless\n                          before the date adjustments of the middle\n                          ages, so it is best defined as\n\n                           01.01.2000 = 730120\n\n\n      2)  INSTWTOR     -  CALLable routine to do WTOs and WTORs with a\n                          100 byte message - abrogates need to\n                          construct reentrant WTORs and WTOs in exits\n\n      3)  INSTCNVX     -  CALLable routine to convert a string to hex\n\n      4)  INSTSTRC     -  Auxillary needed for INSTSTR macro\n\n      5)  INSTPRSE     -  Auxillary needed for INSTPRS macro\n\n      6)  INSTGET      -  See the INSTSET/INSTGET section\n\n      7)  INSTWTL      -  Sample routine to do a WTL, adding a time\n                          stamp and job name stamp.\n\n\n\n\n    All these may be assembled to object form and included at linkedit\n    time at your discretion\n\n\n\n\n\n    Utilities\n    ---------\n\n\n      1)  INSTLXSV     -  A sample PANEL exit.  We use this to feed\n                          system variables through to ISPF panels\n\n      2)  INSTTCMD     -  A sample batch program to issue commands.\n                          This should be RACF-protected\n\n      3)  INSTSET      -  See the INSTSET/INSTGET section\n\n      4)  INSTPDSL     -  A sample subroutine used to get the listing of\n                          a PDS or PDSE\n\n\n\n\n\n\n\n\n\n    INSTSET/INSTGET Installation\n    ----------------------------\n\n\n    The batch program INSTSET, the SMF exit INSTUJI, and the routine\n    INSTGET, form a connected subset of utilities\n\n\n\n    INSTSET is used to create a \"string\" for a job.  The string is held\n    name/token pairs.\n\n    The string is as it were a global \"environment variable\" readable\n    by subsequent programs in the job.\n\n    The programs read it by calling INSTGET.  INSTGET returns a halfword\n    prefixed string in a buffer provided by the calling program.\n\n    INSTUJI is used to pre-clean out the name/token pairs before a job\n    runs.  This exit must be added to the SMF IEFUJI list in PROGXX\n\n\n\n    To install these utilities:\n\n\n    1) Modify and run INSTNT01.   INSTUJI must be in a linklist\n       library.  INSTSET must be in an authorised library.  Here I put\n       them both in SYS1.LINKLIB\n\n\n    2) F LLA,REFRESH\n\n\n    3) Include in a PROGXX member\n\n       EXIT ADD    EXITNAME(SYS.IEFUJI) MODNAME(INSTUJI)\n\n\n    4) Issue   SET PROG=xx    (whatever xx is)\n\n\n    5) Run the IVP program INSTNT02\n\n\n    6) At your discretion compile INSTGET to object code form so it\n       can be called by HLL programs\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTDTID": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x01\\x00\\x98\\x05\\x0f\\x01\\x01\\x01/\\x17D\\x01\\xa4\\x01\\xa9\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1998-02-19T00:00:00", "modifydate": "2001-01-12T17:44:01", "lines": 420, "newlines": 425, "modlines": 0, "user": "TSO057"}, "text": "**********************************************************************\n*\n*  12/12/00  1.0    WRITTEN                                     AWR *\n*\n**********************************************************************\n\n*******************************************************************\n*                                                                 *\n*        THIS IS AN ISO / DAYS CONVERSION                         *\n*        ROUTINE.                                                 *\n*                                                                 *\n*                                                                 *\n*        THREE PARAMETERS:                                        *\n*                                                                 *\n*            1)  '1' FOR ISO->DAYS, '2' FOR DAYS->ISO             *\n*                                                                 *\n*            2)  THE ISO DATE 'CCYY-MM-DD'   -  MUST HAVE DASHES  *\n*                NOT BLANKS OR ANY OTHER SEPARATOR                *\n*                                                                 *\n*            3)  A FULLWORD HOLDING THE (DAYS_SINCE_1_JAN_1_AD)+1 *\n*                                                                 *\n*                                                                 *\n*               This number is is of course meaningless           *\n*               before the date adjustments of the middle         *\n*               ages, so it is best defined as                    *\n*                                                                 *\n*                01.01.2000 = 730120                              *\n*                                                                 *\n*                                                                 *\n*                                                                 *\n*                                                                 *\n*        It is reentrant and contains no SVCs                     *\n*        and also bimodal (able to run in 24 or 31 bit mode)      *\n*                                                                 *\n*                                                                 *\n*                                                                 *\n*******************************************************************\nISO      DSECT\nISOCCYY  DS   0CL4\nISOCC    DS    CL2\nISOYY    DS    CL2\nISODSH1  DS    C\nISOMM    DS    CL2\nISODSH2  DS    C\nISODD    DS    CL2\n*\nDAY      DSECT\nDAYA     DS    A\n*\nFLAG     DSECT\nFLAGC    DS    C\n*\n         INSTREQU\n*\nINSTDTID INSTSS SAVEAREA=NO\n         LM    R9,R11,0(R1)    GET PARAMETER ADDRESSES\n         USING FLAG,R9\n         USING ISO,R10\n         USING DAY,R11\n         CLI   FLAGC,C'1'\n         BE    ISOTOD\n         CLI   FLAGC,C'2'\n         BE    DTOISO\n         B     RETBAD\n*\nLASTDAY  EQU   3652059\n*\nDTOISO   EQU   *\n*\n* TO CHANGE (DAYS_SINCE_1_JAN_1_AD)+1 TO A YEAR-MONTH-DAY\n* DATES GO IN A 400 YEAR CYCLE.  WE DECOMPOSE THE DAY INTO A FINITE\n* NUMBER OF 400 YEAR PERIODS, FOLLOWED BY 0-3 100YEAR PERIODS,\n* FOLLOWED BY 0-24 4-YEAR PERIODS, FOLLOWED BY 0-3 YEARS, FOLLOWED BY\n* A NUMBER OF DAYS.\n*\n* CHECK DAYS BETWEEN 1 AND 3652059 (= 9999-12-31)\n*\n         L     R1,DAYA\n         C     R1,=A(1)\n         BL    RETBAD\n         C     R1,=A(LASTDAY)\n         BH    RETBAD\n*\n* DECOMPOSE INTO 400YR, 100YR, 4YR, YEAR, DAYSLEFT\n*\n*\n         BCTR  R1,0            R1 = DAYS- 1\n*\nDAYS4Y    EQU 365*4+1\nDAYS100Y  EQU DAYS4Y*25-1\nDAYS400Y  EQU DAYS100Y*4+1\n*\n         SLR   R0,R0           R0R1 = DAYS - 1\n         D     R0,=A(DAYS400Y)\n*                              R1 = NO 400 YR PERIODS SINCE 1 JAN 0001\n*                              R0 = DAYS LEFT OVER\n*\n         LR    R3,R0\n         SLR   R2,R2           R2R3 = DAYS LEFT OVER\n         D     R2,=A(DAYS100Y)\n         CH    R3,=Y(4)        IF 4 100YR PERIODS\n         BL    BB001\n         LA    R3,3            REDUCE TO 3\n         A     R2,=A(DAYS100Y) ADD A 100YR PERIOD TO DAYS LEFT OVER\nBB001    EQU   *\n*                              R3 = NO 100 YR PERIODS SINCE LAST WHOLE\n*                                   400 YR PERIOD\n*                              R2 = DAYS LEFT OVER\n*\n         LR    R5,R2\n         SLR   R4,R4           R4R5 = DAYS LEFT OVER\n         D     R4,=A(DAYS4Y)\n*                              R5 = NO 4 YR PERIODS SINCE LAST WHOLE\n*                                   100 YR PERIOD\n*                              R4 = DAYS LEFT OVER\n*\n         LR    R7,R4\n         SLR   R6,R6           R6R7 = DAYS LEFT OVER\n         D     R6,=A(365)\n         CH    R7,=Y(4)        IF 4 YEARS\n         BL    BB002\n         LA    R7,3            REDUCE TO 3\n         A     R6,=A(365)      ADD A YEAR TO DAYS LEFT OVER\nBB002    EQU   *\n*                              R7 = NO YEARS SINCE LAST WHOLE\n*                                   4 YR PERIOD\n*                              R6 = DAYS LEFT OVER\n*\n* STORE YEAR IN R8\n*\n         LR    R8,R1\n         MH    R8,=Y(400)\n         LR    R0,R3\n         MH    R0,=Y(100)\n         AR    R8,R0\n         LR    R0,R5\n         MH    R0,=Y(4)\n         AR    R8,R0\n         AR    R8,R7\n         AH    R8,=Y(1)        R8 = YEAR\n*\n* NOW POINT R1 TO A TABLE OF DAYS IN\n* MONTH\n*\n         LA    R1,MONTHT       ASSUME NOT LEAP YEAR\n         CH    R7,=Y(3)        IS IT LAST YEAR OF 4-YR CYCLE\n         BNE   BB0031          NO -> NOT LEAP YEAR\n         CH    R5,=Y(24)       IS IT LAST 4-YR OF A 100-YR CYCLE?\n         BNE   BB003           NO -> LEAP YEAR\n         CH    R3,=Y(3)        IS IT LAST 100-YR OF 400-YR CYCLE\n         BNE   BB0031          NO -> NOT LEAP YEAR\nBB003    EQU   *\n         LA    R1,MONTHTL      IT'S A LEAP YEAR.\nBB0031   EQU   *\n*\nJAND     EQU   31\nMARD     EQU   31\nAPRD     EQU   30\nMAYD     EQU   31\nJUND     EQU   30\nJULD     EQU   31\nAUGD     EQU   31\nSEPD     EQU   30\nOCTD     EQU   31\nNOVD     EQU   30\nDECD     EQU   31\n*\n*        SET R2 AS MONTH COUNTER\n*\n         LA    R2,1\nBB005    EQU   *\n         CH    R2,=Y(12)\n         BH    RETBAD\n         CH    R6,0(R1)\n         BL    BB006\n         SH    R6,0(R1)         REDUCE NO OF DAYS LEFT\n         LA    R2,1(R2)         SKIP UP\n         LA    R1,2(R1)         SKIP UP MONTH TAB\n         B     BB005\nBB006    EQU   *\n         LA    R6,1(R6)\n*\n*        R8 = YYYY\n*        R2 = MONTH\n*        R6 = DAYS\n*\n*        PUT EM BACK IN DECIMAL WITHOUT ANY WORKING STORAGE TO USE!\n*\n         LR    R0,R6\n         SRDL  R0,32\n         D     R0,=A(10)\n         STC   R0,ISODD+1\n         STC   R1,ISODD\n         OC    ISODD,=X'F0F0'\n         LR    R0,R2\n         SRDL  R0,32\n         D     R0,=A(10)\n         STC   R0,ISOMM+1\n         STC   R1,ISOMM\n         OC    ISOMM,=X'F0F0'\n         LR    R0,R8\n         SRDL  R0,32\n         D     R0,=A(10)\n         STC   R0,ISOCCYY+3\n         SLR   R0,R0\n         D     R0,=A(10)\n         STC   R0,ISOCCYY+2\n         SLR   R0,R0\n         D     R0,=A(10)\n         STC   R0,ISOCCYY+1\n         STC   R1,ISOCCYY\n         OC    ISOCCYY,=X'F0F0F0F0'\n         MVI   ISODSH1,C'-'\n         MVI   ISODSH2,C'-'\n         B     RET0\n*\nMONTHT  DC Y(JAND,28,MARD,APRD,MAYD,JUND,JULD,AUGD,SEPD,OCTD,NOVD,DECD)\nMONTHTL DC Y(JAND,29,MARD,APRD,MAYD,JUND,JULD,AUGD,SEPD,OCTD,NOVD,DECD)\n*\n*\n*         PROCEDURE FOR YYYY-MM-DD TO A(DAY)\n*\n*\n*\nISOTOD   EQU   *\n*        CHECK INPUT HAS VALID CHARACTERS\n*\n         CLI   ISODSH1,C'-'\n         BNE   RETBAD\n         CLI   ISODSH2,C'-'\n         BNE   RETBAD\n         CLI   ISOCCYY+0,C'0'\n         BL    RETBAD\n         CLI   ISOCCYY+0,C'9'\n         BH    RETBAD\n         CLI   ISOCCYY+1,C'0'\n         BL    RETBAD\n         CLI   ISOCCYY+1,C'9'\n         BH    RETBAD\n         CLI   ISOCCYY+2,C'0'\n         BL    RETBAD\n         CLI   ISOCCYY+2,C'9'\n         BH    RETBAD\n         CLI   ISOCCYY+3,C'0'\n         BL    RETBAD\n         CLI   ISOCCYY+3,C'9'\n         BH    RETBAD\n         CLI   ISOMM+0,C'0'\n         BL    RETBAD\n         CLI   ISOMM+0,C'9'\n         BH    RETBAD\n         CLI   ISOMM+1,C'0'\n         BL    RETBAD\n         CLI   ISOMM+1,C'9'\n         BH    RETBAD\n         CLC   ISOMM,=C'12'\n         BH    RETBAD\n         CLC   ISOMM,=C'01'\n         BL    RETBAD\n         CLI   ISODD+0,C'0'\n         BL    RETBAD\n         CLI   ISODD+0,C'9'\n         BH    RETBAD\n         CLI   ISODD+1,C'0'\n         BL    RETBAD\n         CLI   ISODD+1,C'9'\n         BH    RETBAD\n         CLC   ISODD,=C'01'\n         BL    RETBAD\n*\n* CHECK FOR UPPER BOUNDS VALID DAY WILL BE DONE LATER.\n*\n* NOW GET YEAR IN R5\n*\n         SLR   R2,R2\n         IC    R2,ISOCCYY\n         SH    R2,=Y(X'F0')\n         MH    R2,=Y(1000)\n         LR    R5,R2\n         SLR   R2,R2\n         IC    R2,ISOCCYY+1\n         SH    R2,=Y(X'F0')\n         MH    R2,=Y(100)\n         AR    R5,R2\n         SLR   R2,R2\n         IC    R2,ISOCCYY+2\n         SH    R2,=Y(X'F0')\n         MH    R2,=Y(10)\n         AR    R5,R2\n         SLR   R2,R2\n         IC    R2,ISOCCYY+3\n         SH    R2,=Y(X'F0')\n         AR    R5,R2\n*\n* R5 = YEAR\n*\n* SET UP R6 AS \"LEAP\"  =  (YEAR%4) - (YEAR%100) + (YEAR%400)\n*\n* % = DIVIDE AND DISCARD REMAINDER\n*\n         SLR   R6,R6\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(4)\n         AR    R6,R1\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(100)\n         SR    R6,R1\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(400)\n         AR    R6,R1\n*\n* POINT R3 TO A TABLE OF DAYS-FROM-MAR1-OF-THIS-YEAR\n* POINT R4 TO A TABLE OF DAYS-IN-MONTH\n*\n* THERE ARE 2 TABLES, ONE FOR LEAP YEARS, ONE FOR YEARS\n*\n         LA    R3,OFFT\n         LA    R4,MONTHT\n*\n*        IS IT LEAP YEAR?\n*\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(4)\n         LTR   R0,R0                     DIV BY 4 ?\n         BNZ   C0002                     NO -> NO LEAP YEAR\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(400)\n         LTR   R0,R0                     DIV BY 400\n         BZ    C0001                     YES-> LEAP YEAR\n         SLR   R0,R0\n         LR    R1,R5\n         D     R0,=A(100)\n         LTR   R0,R0                     DIV BY 100\n         BZ    C0002                     YES-> NO LEAP YEAR\nC0001    DS    0H\n         LA    R3,OFFTL\n         LA    R4,MONTHTL\nC0002    DS    0H\n*                                        GET MONTH IN R7\n         SLR   R2,R2\n         IC    R2,ISOMM\n         SH    R2,=Y(X'F0')\n         MH    R2,=Y(10)\n         LR    R7,R2\n         SLR   R2,R2\n         IC    R2,ISOMM+1\n         SH    R2,=Y(X'F0')\n         AR    R7,R2                       R7 = MM\n*                                         POINT TO ENTRIES FOR MONTH\n         AR    R3,R7\n         AR    R3,R7\n         S     R3,=A(2)                   R3 -> CORRECT ENTRY\n         AR    R4,R7\n         AR    R4,R7\n         S     R4,=A(2)                   R4 -> CORRECT ENTRY\n*\n*    GET THE DAY OF THE MONTH IN R8\n*\n         SLR   R2,R2\n         IC    R2,ISODD\n         SH    R2,=Y(X'F0')\n         MH    R2,=Y(10)\n         LR    R8,R2\n         SLR   R2,R2\n         IC    R2,ISODD+1\n         SH    R2,=Y(X'F0')\n         AR    R8,R2                       R8 = DD\n*                                          IS MONTH TOO HIGH?\n         CH    R8,0(R4)\n         BH    RETBAD                     -> EXIT\n*                                         GET DAYS SINCE 0001-01-01\n         LR    R1,R5                      YEAR\n         SLR   R0,R0\n         M     R0,=A(365)                 R0R1 = YEAR*365\n         AR    R1,R6                      + LEAP\n         AH    R1,0(R3)                   + DAYS SINCE MAR1\n         AR    R1,R8                      + DD\n         S     R1,=A(306)                 -306\n         ST    R1,DAYA\n         B     RET0\n*\nOFFT     DS    0Y\n         DC    Y(-(28+JAND))\n         DC    Y(-28)\n         DC    Y(0)\n         DC    Y(MARD)\n         DC    Y(MARD+APRD)\n         DC    Y(MARD+APRD+MAYD)\n         DC    Y(MARD+APRD+MAYD+JUND)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD+OCTD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD+OCTD+NOVD)\nOFFTL    DS    0Y\n         DC Y(-(29+JAND))\n         DC Y(-29)\n         DC    Y(0)\n         DC    Y(MARD)\n         DC    Y(MARD+APRD)\n         DC    Y(MARD+APRD+MAYD)\n         DC    Y(MARD+APRD+MAYD+JUND)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD+OCTD)\n         DC    Y(MARD+APRD+MAYD+JUND+JULD+AUGD+SEPD+OCTD+NOVD)\n*\n*\n*\n*\n*\nRET0     INSTRS RC=0\nRETBAD   INSTRS RC=8\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTGET": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x01\\x03\\x14/\\x01\\x03\\x14/\\x135\\x00=\\x00<\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-05-22T00:00:00", "modifydate": "2003-05-22T13:35:46", "lines": 61, "newlines": 60, "modlines": 0, "user": "TSO057"}, "text": "*********************************************************************\n*                                                                   *\n*    THIS SUBROUTINE IS USED TO GET A HALFWORD PREFIXED STRING      *\n*    PASSED TO IT FROM A SET OF NAME/TOKEN PAIRS.  IT IS TO BE USED *\n*    IN CONJUNCTION WITH INSTSET AND INSTUJI                        *\n*                                                                   *\n*    SEE INSTDOC FOR AN EXPLANATION OF THESE MACROS                 *\n*                                                                   *\n*********************************************************************\nINSTGET  INSTSS\n         L      R3,0(R1)     R3 -> REPLY\n*\n* MOVE INTO BUFFER PADDING WITH LOWVALUES\n*\n         MVC    NAME,=C'INST.TTYY.ASIDXX'   TOKEN NAME SKEL\n         LA     R1,0\n         USING  PSA,R1\n         L      R1,PSAAOLD\n         DROP   R1\n         USING  ASCB,R1\n         MVC    NAME+14(2),ASCBASID         GET ASID IN HEX INTO NAME\n         DROP   R1\n*\n*        SET UP TOKENS, EACH 16 BYTES OF THE STRING\n*        THE FIRST TOKEN WE DON'T GET STOPS US\n*\n         LA     R2,0\nTLOOP   EQU    *\n         STCM   R2,3,NAME+7\n         CALL   IEANTRT,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BNZ    TLOOPZ\n         MVC    0(L'TOKEN,R3),TOKEN\n         LA     R3,L'TOKEN(R3)\n         LA     R2,1(R2)\n         B      TLOOP\nTLOOPZ   EQU    *\n*\nOK       EQU    *\n         INSTRS RC=0\n*\nLEVEL    DC     A(IEANT_SYSTEM_LEVEL)\n         LTORG\nPERSIST  DC     A(IEANT_PERSIST)\n\n\n         INSTWORK  START\n\nPL       CALL   ,(,,,,,,,),MF=L\n\nNAME     DC     CL16' '\nTOKEN    DC     CL16' '\nRETC     DC     A(0)\n\n         INSTWORK  END\n\n\n         IHAPSA  DSECT=YES\n         IHAASCB DSECT=YES\n         IEANTASM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTIVP": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01D\\x00I\\x01\\x004\\x9f\\x01\\x05\\x05O\\x16A\\x01H\\x00\\x17\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.68", "flags": 0, "createdate": "2000-12-14T00:00:00", "modifydate": "2005-02-23T16:41:49", "lines": 328, "newlines": 23, "modlines": 0, "user": "TSO057"}, "text": "***********************************************************************\n*                                                                     *\n*  12/12/00  1.0    WRITTEN                                     AWR   *\n*  28/12/00  1.1    INSTSTR STUFF ADDED                         AWR   *\n*                                                                     *\n***********************************************************************\n\n***********************************************************************\n*                                                                     *\n*        THIS PROGRAM GETS THE DATE, CONVERTS IT TO DISPLAY HEX BY    *\n*        CALLING INSTCVTX, CHANGES IT TO DAYS BY CALLING              *\n*        INSTDTID, CALCULATES WHAT DAY OF THE WEEK IT IS BY DIVIDING  *\n*        BY 7, FORMATS A SUITABLE MESSAGE USING INSTSTR, AND THEN     *\n*        ISSUES A WTO BY CALLING INSWTOR                              *\n*                                                                     *\n*        AFTER THIS,   A NUMBER OF DEMONSTRATIONS OF INSTSTR ARE      *\n*        GIVEN AND THE RESULTS DISPLAYED                              *\n*                                                                     *\n*                                                                     *\n*        THE CALLED PROGRAMS ARE HERE COPIED INLINE.  THIS IS THE     *\n*        RECOMMENDED WAY OF USING THEM, BUT YOU MAY IF                *\n*        YOU WISH COMPILE THEM TO OBJECT CODE AND LINK THEM IN        *\n*                                                                     *\n*        ASSEMBLE THIS USING JOB INSTIVP1                             *\n*                                                                     *\n***********************************************************************\n\n\nINSTIVP  INSTSS\n\n         TIME  DEC,STOREADDR,LINKAGE=SYSTEM,DATETYPE=YYYYMMDD\n         BAL   R1,FORMAT_AND_DISPLAY_TIME\n\n*        SOME DEMOS OF INSTSTR\n\n*        HEX FORMATTING, AND STRINGING IN AN UNFORMATTED CHAR FIELD\n\n         INSTSTR  ' F1=',(F1,X),ACHARFIELD,RES=MESSAGE\n         BAL  R1,WTO\n\n*        NUMERIC FORMATTING\n\n         INSTSTR  ' F2=',(F2,N),RES=MESSAGE\n         BAL  R1,WTO\n\n*        DISPLAY OF A REGISTER - HEX AND NUM.  ALSO SHOWING\n*        HOW TO INSERT SPACES\n\n         LA   R1,999\n\n         INSTSTR  ' R1=',((R1),N),3,((R1),X),RES=MESSAGE\n         BAL  R1,WTO\n\n*        HOW TO SPECIFY LENGTH OF FORMATTED FIELDS.  ALSO ABSOLUTE\n*        POSITIONING BY *+NN\n\n\n         INSTSTR  *+0,' F1=',(F1,N,4),*+10,'F2=',(F2,N,4),RES=MESSAGE\n         BAL  R1,WTO\n\n\n*        SOME DEMOS OF INSTPRS\n\n\n*        PARSE A ASSEMBLER-STYLE COMMAND INTO NAME,COMMAND,OPERANDS\n\n\n         INSTPRS  FIELD,RES=(NAME,COMMAND,OPERANDS),DLM=' '\n         MVC  MESSAGE,NAME\n         BAL  R1,WTO\n\n         MVC  MESSAGE,COMMAND\n         BAL  R1,WTO\n\n         MVC  MESSAGE,OPERANDS\n         BAL  R1,WTO\n\n*        PARSE OPERANDS INTO OP1,OP2,OP3\n\n\n         INSTPRS OPERANDS,RES=(OP1,OP2,OP3),DLM=','\n         MVC  MESSAGE,OP1\n         BAL  R1,WTO\n\n         MVC  MESSAGE,OP2\n         BAL  R1,WTO\n\n         MVC  MESSAGE,OP3\n         BAL  R1,WTO\n\n\n*        USE INSTNUM TO GET THE NUMEIC VALUE OF OP2\n*\n\n         INSTNUM      OP2\n INSTSTR  ' INSTNUM OP2  R1=',((R1),N),' R15=',((R15),N),RES=MESSAGE\n         BAL  R1,WTO\n\n*        USE INSTNUM TO TRY IT FOR OP1 - ERROR\n*\n\n         INSTNUM      OP1\n INSTSTR  ' INSTNUM OP1  R1=',((R1),N),' R15=',((R15),N),RES=MESSAGE\n         BAL  R1,WTO\n\n\n\n\n\n*        PARSE OPERANDS FOR A LENGTH SPECIFIED IN A REGISTER\n*        BY THIS MEANS ONLY PART OF A FIELD CAN BE USED AS SOURCE\n\n\n         LA   R3,6\n         INSTPRS OPERANDS,RES=(OP1,OP2,OP3),DLM=',',LEN=(R3)\n\n\n         MVC  MESSAGE,OP1\n         BAL  R1,WTO\n\n         MVC  MESSAGE,OP2\n         BAL  R1,WTO\n\n         MVC  MESSAGE,OP3\n         BAL  R1,WTO\n\n\n         INSTRS  RC=0\n\n\nFIELD   DC   CL100'NAME   COMMAND  OP1,999,XXX'\n\n\nACHARFIELD DC C' <=== LOOKY HERE!'\nF1  DC   PL3'44'\nF2  DC   F'-5'\n\n\n\nFORMAT_AND_DISPLAY_TIME INSTBALI\n\n***********************************************************************\n*                                                                     *\n*        THIS IS A \"PERFORMED\" PROCESS                                *\n*                                                                     *\n*        IT IN TURN \"PERFORMS\" SEVERAL SUB-PROCESSES.  GENERALLY      *\n*        THIS WOULD BE AN UNNECESSARY FUSS, BUT IT IS SHOWN HERE TO   *\n*        DEMONSTRATE NESTED \"PERFORMS\".                               *\n*                                                                     *\n***********************************************************************\n\n         BAL  R1,CONV_HEX\n         BAL  R1,COMPUTE_DAY\n         BAL  R1,FORMAT_MESSAGE\n         BAL  R1,WTO\n\n\n         INSTBALO\n\n\n\nCONV_HEX INSTBALI\n*\n*        CONVERT THE FULLWORD IN YYYYMMDD TO 8 BYTES HEX\n*\n         CALL INSTCNVX,(YYYYMMDD,HEX,FROM_LEN),VL,MF=(E,CALL_L)\n         LTR  R15,R15\n         BNZ  CONV_HEX_ERR\n         INSTBALO\n\nCONV_HEX_ERR  EQU  *\n         LR   R5,R15\n         WTO  'INSTCNVX ERROR'\n         LR   R15,R5\n         INSTRS RC=(R15)\n\n\n\nCOMPUTE_DAY INSTBALI\n*\n*        GET DAY OF THE WEEK IN R7\n*\n         MVI  ISOSL1,C'-'\n         MVI  ISOSL2,C'-'\n         MVC  ISOYYYY,HEXYYYY\n         MVC  ISOMM,HEXMM\n         MVC  ISODD,HEXDD\n         CALL INSTDTID,(=C'1',ISO,DAYS),VL,MF=(E,CALL_L)\n         LTR  R15,R15\n         BNZ  COMPUTE_DAY_ERR\n\n*        DAYS IS NOW THE DAYS_SINCE_1_JAN_1_AD+1.   DIVIDE BY 7 AND\n*        REMAINDER IS DAY OF WEEK, 0=SUN -> 6=SAT\n\n         SLR  R0,R0\n         L    R1,DAYS\n         D    R0,=A(7)\n         LR   R1,R0\n         MH   R1,=Y(L'DAYTAB)\n         LA   R7,DAYTAB(R1)\n\n*        R7 -> THE DAY\n\n         INSTBALO\n\n\nCOMPUTE_DAY_ERR  EQU  *\n         LR   R5,R15\n         WTO  'INSTDTID ERROR'\n         LR   R15,R5\n         INSTRS RC=(R15)\n\n\nFORMAT_MESSAGE INSTBALI\n         INSTSTR ' TODAY IS ',(0(R7),C,L'DAYTAB),                      X\n               RES=MESSAGE\n         INSTBALO\n\n\nWTO      INSTBALI\n         CALL  INSTWTOR,(MESSAGE,ROUTECDE),VL,MF=(E,CALL_L)\n         INSTBALO\n\n\n\n***********************************************************************\n*                                                                     *\n*        R/O STUFF HERE - CONSTANTS                                   *\n*                                                                     *\n***********************************************************************\n\nDAYTAB    DC   CL10'SUNDAY'\n          DC   CL10'MONDAY'\n          DC   CL10'TUESDAY'\n          DC   CL10'WEDNESDAY'\n          DC   CL10'THURSDAY'\n          DC   CL10'FRIDAY'\n          DC   CL10'SATURDAY'\n\nFROM_LEN  DC   A(L'YYYYMMDD)\n\nROUTECDE  DC   A(0)\n\n\n          LTORG\n\n\n***********************************************************************\n*                                                                     *\n*        R/W STUFF HERE, BETWEEN INSTWORK START AND INSTWORK END      *\n*                                                                     *\n***********************************************************************\n\n          INSTWORK START\n\nCALL_L    CALL  ,(,,,,),MF=L\n\nSTOREADDR DS 4F\n          ORG STOREADDR\n          DS  F\n          DS  F\nYYYYMMDD  DS  F\n          ORG\n\nDAYS      DS   F\n\nISO       DS   CL10\n          ORG  ISO\nISOYYYY   DS   CL4\nISOSL1    DS   C\nISOMM     DS   CL2\nISOSL2    DS   C\nISODD     DS   CL2\n          ORG\n\nHEX       DS   CL8\n          ORG  HEX\nHEXYYYY   DS   CL4\nHEXMM     DS   CL2\nHEXDD     DS   CL2\n          ORG\n\nMESSAGE   DS  CL100\nNAME      DS  CL100\nCOMMAND   DS  CL100\nOPERANDS  DS  CL100\nOP1       DS  CL100\nOP2       DS  CL100\nOP3       DS  CL100\n\n          INSTWORK END\n\n\n\n          END\n\n\n***********************************************************************\n*                                                                     *\n*         COPY IN OTHER, CALLED, PROGRAMS HERE                        *\n*                                                                     *\n***********************************************************************\n\n\n          COPY INSTDTID\n\n          COPY INSTWTOR\n\n          COPY INSTCNVX\n\n***********************************************************************\n*                                                                     *\n*         INSTSTRC NEEDED BECAUSE INSTSTR IS USED                     *\n*                                                                     *\n***********************************************************************\n\n          COPY INSTSTRC\n\n***********************************************************************\n*                                                                     *\n*         INSTPRSE NEEDED BECAUSE INSTPRS IS USED                     *\n*                                                                     *\n***********************************************************************\n\n          COPY INSTPRSE\n\n\n          END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTIVP1": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00P\\x01\\x004\\x9f\\x01\\x034?\\x142\\x00/\\x00/\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-12-14T00:00:00", "modifydate": "2003-12-09T14:32:50", "lines": 47, "newlines": 47, "modlines": 0, "user": "TSO057"}, "text": "//TSO057X JOB (T951V57),                                                JOB00892\n//           CLASS=A,MSGCLASS=T,\n//           NOTIFY=TSO057\n//*\n//********************************************************************\n//*\n//*  12/12/00  1.0    WRITTEN                                     AWR\n//*\n//********************************************************************\n//*\n//*        ASSEMBLE, LINK AND RUN THE IVP PROGRAM\n//*\n//*        BEFORE YOU RUN THIS:\n//*\n//*            1)  CUSTOMISE JOB CARD\n//*\n//*            2)  CHANGE \"SFT.INSTASM.ASM\" TO WHATEVER YOU HAVE\n//*                UNLOADED INSTASM INTO\n//*\n//********************************************************************\n//*\n//*\n//ASM      EXEC PGM=ASMA90,\n// PARM='NORLD,XREF(SHORT),DECK,NOOBJECT,LIST,TERM,RENT'\n//SYSTERM  DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1700,(600,600))\n//SYSLIN   DD   DUMMY\n//SYSPUNCH DD   DSN=&&OBJ,DISP=(NEW,PASS),\n//         SPACE=(80,(1500,750)),UNIT=SYSALLDA,BLKSIZE=3120\n//SYSLIB   DD   DSN=SFT.INSTASM.ASM,DISP=SHR\n//         DD   DSN=SYS1.MACLIB,DISP=SHR\n//SYSIN    DD   DSN=SFT.INSTASM.ASM(INSTIVP),DISP=SHR\n//*\n//*\n//LINK     EXEC PGM=HEWL,COND=(0,LT),\n// PARM=('XREF,LIST,MAP',\n// 'AMODE=31,RMODE=ANY,RENT,REUS')\n//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1024,(100,30))\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLIB   DD   DUMMY\n//SYSLMOD  DD   DSN=&&LOAD(INSTIVP),DISP=(,PASS),SPACE=(99,(99,999,1)),\n//         UNIT=SYSALLDA\n//*\n//RUN      EXEC PGM=INSTIVP\n//STEPLIB  DD   DSN=&&LOAD,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTLEN": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x01\\x01\\t\\x14?\\x01\\t\\x14O\\x17I\\x00-\\x00o\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2009-05-23T00:00:00", "modifydate": "2009-05-24T17:49:01", "lines": 45, "newlines": 111, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n&NAME    INSTLEN &FIELD,&DLM=' ',&LEN=\n&NAME    DS    0H\n\n\n\n         LCLA  &SUBA,&RESN\n         LCLC  &DL\n\n\n         INSTREQU\n\n\n         AIF   ('&FIELD' NE '').A\n         MNOTE 4,'FIELD NOT SPECIFIED'\n         MEXIT\n.A       ANOP\n\n\n&DL      SETC  '&DLM'\n         AIF   ('.&DLM' NE '.').DLMB\n&DL      SETC  ''' '''\n.DLMB    ANOP\n\n\n\n         LA    R1,&FIELD\n         LA    R14,&FIELD\n         AIF   ('&LEN' NE '').LENB\n         LA    R15,&FIELD+L'&FIELD\n.LENB    ANOP\n         AIF   ('&LEN' EQ '').LENC\n         LA    R15,&FIELD+&LEN\n.LENC    ANOP\nINSA&SYSNDX   EQU   *\n         CR   R1,R15\n         BNL  INS0&SYSNDX\n         CLI  0(R1),C&DLM\n         BE   INS0&SYSNDX\n         LA   R1,1(R1)\n         B    INSA&SYSNDX\nINS0&SYSNDX   EQU   *\n         SR   R1,R14\n         MEND\n         MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTLXSV": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x001\\x01\\x02\\x00\\x7f\\x01\\x04\\x00/\\x142\\x00\\x8a\\x00\\x8f\\x00\\n\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-01-07T00:00:00", "modifydate": "2004-01-02T14:32:31", "lines": 138, "newlines": 143, "modlines": 10, "user": "TSO057"}, "text": "//TSO0572 JOB (T951V88),AWR,MSGCLASS=T,CLASS=A,NOTIFY=TSO057\n/*JOBPARM ROOM=VVVV\n//  INCLUDE MEMBER=SYSLEV\n//*\n//*\n//*    DONE  OS/390 2.10 01/2001\n//*\n//*\n//*\n//*    THIS JOB INSTALL THE PANEL EXIT INSTLXSV WHICH IS\n//*    USED TO GET THE SYSTEM VARIABLES IN ISPF PANELS\n//*\n//*\n//*\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,RENT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.&SYSLEV..SHASSRC,DISP=SHR\n//         DD  DSN=SYS1.&SYSLEV..AMODGEN,DISP=SHR\n//         DD  DSN=SFT.INSTASM.ASM,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(9999,(600,100))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=SYSSQ,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n***********************************************************************\n*                                                                     *\n*   INSTLXSV IS A PANEL EXIT                                          *\n*                                                                     *\n*   INSTLXSV IS USED TO GET A MVS SYSTEM VARIABLE AND PASS IT TO ISPF *\n*                                                                     *\n*                                                                     *\n*   TO GET SYSTEM VARIABLE \"FRED\" IT MUST BE CALLED THUS              *\n*   IN THE )PROC  )INIT OR )REINIT PORTION OF THE PANEL               *\n*                                                                     *\n*                                                                     *\n*  &FRED = AAAAAAAA   /* MUST BE LONG ENOUGH TO HOLD SUBSTITUTED VALUE\n*  PANEXIT((FRED),LOAD,INSTLXSV)                                      *\n*                                                                     *\n*                                                                     *\n*   INPUT PARAMETERS                                                  *\n*                                                                     *\n*                1)   FULLWORD OF EXIT DATA                           *\n*                2)   CALLING PANEL NAME                              *\n*                3)   1 BYTE PANEL SECTION  I/R/P                     *\n*                4)   CL8(ERROR MSG ID)                               *\n*                5)   FULLWORD NUMBER OF VARIABLES MUST BE 1          *\n*                6)   ARRAY OF VARIABLE NAMES CL8 MUST BE ONE ONLY    *\n*                7)   ARRAY OF FULLWORD VARIABLE LENGTHS MUST BE ONE  *\n*                8)   VARIABLE VALUES PACKED IN A SINGLE BUFFER       *\n*                                                                     *\n*   THIS ROUTINE TAKES THE VARIABLE NAME AND PREFIXES AN &, AND THEN  *\n*   CALLS THE SYSTEM ASASYMBM ROUTINE TO SUBSTITUTE IT.  IF THIS ENDS *\n*   SUCCESSFULLY IT REPLACES THE VALUE IN THE BUFFER                  *\n*                                                                     *\n*   THE ROUTINE IS REENTRANT, 31/ANY AND LPA RESIDENT                 *\n*                                                                     *\n***********************************************************************\nINSTLXSV INSTSS\n\n         LR    R6,R1       SAVE R1\n         L     R1,16(R6)   CHECK NO OF VARIABLES\n         L     R1,0(R1)\n         C     R1,=A(1)\n         BNE   FAIL\n         L     R1,20(R6)   GET NAME OF VARIABLE\n         MVC   PATTERN_VN,0(R1) MOVE IN TO PATTERN PREFIXED BY &\n         MVI   PATTERN_AMP,C'&&'\n*\n*        CALL ASASYMBU TO DO SUBSTITUTION\n*\n*        SET UP CONTROL BLOCK\n*\n         XC    SYMBP(SYMBP_LEN),SYMBP   INITIALIZE TO ZERO\n         LA    R1,PATTERN               ADDRESS OF PATTERN\n         ST    R1,SYMBPPATTERN@         SAVE IN SYMBP AREA\n         LA    R1,L'PATTERN             LENGTH OF PATTERN\n         ST    R1,SYMBPPATTERNLENGTH    SAVE IN SYMBP AREA\n         LA    R1,TARGET                ADDRESS OF TARGET\n         ST    R1,SYMBPTARGET@          SAVE IN SYMBP AREA\n         MVC   TARGETLENGTH,=A(L'TARGET)  SET LENGTH OF TARGET\n         LA    R1,TARGETLENGTH          ADDRESS OF TARGET LENGTH\n         ST    R1,SYMBPTARGETLENGTH@    SAVE IN SYMBP AREA\n         LA    R1,RETURNCODE            ADDRESS OF RETURN CODE\n         ST    R1,SYMBPRETURNCODE@      SAVE IN SYMBP AREA\n  LINK   EP=ASASYMBM,MF=(E,MYSYMBP),SF=(E,LINKL),DCB=0\n         CLC   =A(0),RETURNCODE\n         BNE    FAIL\n         L     R2,28(R6)        R2 -> VARIABLE VALUE\n         L     R3,24(R6)\n         L     R3,0(R3)         R3 = VARIABLE LENGTH ON INPUT\n         LA    R4,TARGET\n         L     R5,TARGETLENGTH\n         O     R5,=A(X'40000000')   BLANK PAD/TRUNCATE\n         MVCL  R2,R4\n         B     OK\n\n\nOK       EQU   *\n         INSTRS\n\n\nFAIL     EQU   *\n         INSTRS  RC=8\n\n\n\n         INSTWORK START\n\nLINKL        LINK SF=L\nPL           CALL MF=L\n\nPATTERN      DC    CL9' '\n             ORG   PATTERN\nPATTERN_AMP  DS    C\nPATTERN_VN   DS    CL8\n             ORG   PATTERN+L'PATTERN\n\n             DS    0F\nRETURNCODE   DS    F                   RETURN CODE\nTARGETLENGTH DS    F                   LENGTH OF TARGET\nTARGET       DS    CL80\nMYSYMBP      DS    CL(SYMBP_LEN)       SYMBP AREA\n             ORG   MYSYMBP\n             ASASYMBP  DSECT=NO        MAPPING OF SYMBP AREA\n\n        INSTWORK END\n\n        END\n//LKED    EXEC PGM=IEWL,PARM=(XREF,LIST,RENT,AMODE(31),RMODE(ANY)),\n//             COND=(0,LT,ASM)  **NB RENT CHECK\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=1210)\n//SYSLMOD  DD  DSN=YOUR.LINK.OR.LPA.LIB,DISP=SHR\n   NAME  INSTLXSV(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTNT01": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x01\\x03\\x14/\\x01\\x034/\\x17C\\x00C\\x00R\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-05-22T00:00:00", "modifydate": "2003-12-08T17:43:09", "lines": 67, "newlines": 82, "modlines": 0, "user": "TSO057"}, "text": "//TSO0571 JOB (T951V40),'INSTIN1',MSGCLASS=T,CLASS=Z,NOTIFY=TSO057,\n//          SCHENV=SYSAFF\n// INCLUDE MEMBER=SYSLEV\n//*\n//*\n//*      INSTSET/INSTGET INSTALLATION\n//*\n//*\n//*\n//* 1) MODIFY AND RUN THIS JOB.   INSTUJI MUST BE IN A LINKLIST\n//* LIBRARY.  INSTSET MUST BE IN AN AUTHORISED LIBRARY.  HERE I PUT\n//* THEM BOTH IN SYS1.LINKLIB\n//*\n//* 2) F LLA,REFRESH\n//*\n//* 3) INCLUDE IN A PROGXX MEMBER\n//*\n//*  EXIT ADD    EXITNAME(SYS.IEFUJI) MODNAME(INSTUJI)\n//*\n//* 4) ISSUE   SET PROG=XX    (WHATEVER XX IS)\n//*\n//* 5) RUN INSTNT02 THE IVP PROGRAM\n//*\n//*\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK),COND=(0,NE)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.&SYSLEV..AMODGEN,DISP=SHR\n//         DD  DSN=SFT.INSTASM.ASM,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(9999,(600,100))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=SYSSQ,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=SFT.INSTASM.ASM(INSTSET)\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,AC=1,RENT,REFR',\n//             COND=(4,LT)\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=1210)\n//SYSLIB   DD  DSN=SYS1.&SYSLEV..CSSLIB,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LINKLIB,DISP=SHR\n   SETCODE AC(1)\n   NAME  INSTSET(R)\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK),COND=(4,LT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.&SYSLEV..AMODGEN,DISP=SHR\n//         DD  DSN=SFT.INSTASM.ASM,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(9999,(600,100))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=SYSSQ,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=SFT.INSTASM.ASM(INSTUJI)\n//LKED    EXEC PGM=IEWL,PARM='XREF,LIST,RENT,REFR',\n//             COND=(4,LT,ASM)\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=1210)\n//SYSLIB   DD  DSN=SYS1.&SYSLEV..CSSLIB,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LINKLIB,DISP=SHR\n   NAME  INSTUJI(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTNT02": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x008\\x01\\x03\\x14/\\x01\\x03\\x14/\\x13A\\x00J\\x00'\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2003-05-22T00:00:00", "modifydate": "2003-05-22T13:41:38", "lines": 74, "newlines": 39, "modlines": 0, "user": "TSO057"}, "text": "//TSO057X JOB (T951V57),                                                JOB00892\n//           CLASS=A,MSGCLASS=T,\n//           NOTIFY=TSO057\n//*\n//        INCLUDE MEMBER=SYSLEV\n//*\n//*\n//*        ASSEMBLE, LINK AND RUN THE IVP PROGRAM\n//*\n//*        THIS PROGRAM USES INSTGET TO GET THE NAME/TOKEN STRING\n//*        AND THEN DISPLAYS IT\n//*\n//********************************************************************\n//*\n//* AFTER YOU HAVE DONE THIS, YOU MAY ELABORATE AS YOU PLEASE.\n//*\n//* INSTGET CAN BE COMPILED TO OBJECT CODE AND SO MADE CALLABLE FROM\n//* ANY PROGRAM THAT CAN HANDLE OS LINKAGE (COBOL, C, PLI).\n//*\n//*\n//*\n//*\n//         EXEC PGM=INSTSET,PARM='KEY1=FRED,KEY2=JONES'\n//*\n//*\n//ASM      EXEC PGM=ASMA90,\n// PARM='NORLD,XREF(SHORT),DECK,NOOBJECT,LIST,TERM,RENT'\n//SYSTERM  DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1700,(600,600))\n//SYSLIN   DD   DUMMY\n//SYSPUNCH DD   DSN=&&OBJ,DISP=(NEW,PASS),\n//         SPACE=(80,(1500,750)),UNIT=SYSALLDA,BLKSIZE=3120\n//SYSLIB   DD   DSN=SFT.INSTASM.ASM,DISP=SHR\n//         DD   DSN=SYS1.MACLIB,DISP=SHR\nINSTNT02 INSTSS\n\n         XC      STRING,STRING\n         CALL    INSTGET,(STRING),VL,MF=(E,PL)\n         CALL    INSTWTOR,(STRING,=A(L'STRING)),VL,MF=(E,PL)\n\n         INSTRS  RC=0\n\n\n\n         INSTWORK START\n\nPL        CALL  ,(,,,,),MF=L\n\nSTRING    DS       CL200' '\n          INSTWORK END\n\n\n\n\n\n\n          END\n          COPY INSTGET\n          COPY INSTWTOR\n//*\n//*\n//LINK     EXEC PGM=HEWL,COND=(0,LT),\n// PARM=('XREF,LIST,MAP',\n// 'AMODE=31,RMODE=ANY,RENT,REUS')\n//SYSUT1   DD   UNIT=SYSALLDA,SPACE=(1024,(100,30))\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSLIB   DD   DISP=SHR,DSN=SYS1.&SYSLEV..CSSLIB\n//SYSLMOD  DD DSN=&&LOAD(INSTNT02),DISP=(,PASS),SPACE=(99,(99,999,1)),\n//         UNIT=SYSALLDA\n//*\n//RUN      EXEC PGM=INSTNT02\n//STEPLIB  DD   DSN=&&LOAD,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTNUM": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00(\\x01\\x04\\x00/\\x01\\t\\x14?\\x18\\x13\\x00m\\x00o\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-01-02T00:00:00", "modifydate": "2009-05-23T18:13:28", "lines": 109, "newlines": 111, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n&NAME    INSTNUM &FIELD,&LEN=\n&NAME    DS    0H\n\n\n\n         LCLA  &SUBA,&RESN\n\n\n         INSTREQU\n\n\n         AIF   ('&FIELD' NE '').A\n         MNOTE 4,'FIELD NOT SPECIFIED'\n         MEXIT\n.A       ANOP\n\n\n.C       ANOP\n\n         AIF   ('&LEN' NE '').LENB\n         LA    R1,L'&FIELD\n         AGO   .LENZ\n.LENB    ANOP\n         AIF   ('&LEN'(1,1) NE '(').LENC\n         LR    R1,&LEN\n         AGO   .LENZ\n.LENC    ANOP\n         LA    R1,&LEN\n.LENZ    ANOP\n\n\n\n.*  R1 HOLDS LENGTH\n\n         LA    R14,&FIELD\n\n.*  R14 IS FIELD POINTER\n\n         LA    R15,0(R14,R1)\n\n.*  R15 IS END OF FIELD\n\n\n\n\n\n.*       INITIAL SET OF BLANKS\nINSA&SYSNDX   EQU   *\n         CR   R14,R15\n         BNL  INS0&SYSNDX\n         CLI  0(R14),C' '\n         BNE  INSB&SYSNDX\n         LA   R14,1(R14)\n         B    INSA&SYSNDX\nINSB&SYSNDX   EQU   *\n\n\n.* NOW THERE MUST BE A STRING OF DIGITS\n\n\n         CLI  0(R14),C'0'\n         BL   INS0&SYSNDX\n         CLI  0(R14),C'9'\n         BH   INS0&SYSNDX\n\n\n\n         SLR  R1,R1\n         SLR  R0,R0\nINSH&SYSNDX   EQU   *\n         IC   R0,0(R14)\n         SH   R0,=Y(X'F0')\n         AR   R1,R0\n         LA   R14,1(R14)\n         CR   R14,R15\n         BNL  INSJ&SYSNDX\n         CLI  0(R14),C'0'\n         BL   INSJ&SYSNDX\n         CLI  0(R14),C'9'\n         BH   INSJ&SYSNDX\n         MH   R1,=Y(10)\n         B    INSH&SYSNDX\n\nINSJ&SYSNDX   EQU   *\n\n\nINSM&SYSNDX   EQU   *\n         CR   R14,R15\n         BNL  INS9&SYSNDX\n         CLI  0(R14),C' '\n         BNE  INS0&SYSNDX\n         LA   R14,1(R14)\n         B    INSM&SYSNDX\n\n\n\n\nINS0&SYSNDX   DS    0H BAD FIELD\n         LA   R15,4\n         B    INSZ&SYSNDX\n\nINS9&SYSNDX   DS    0H ALL OK\n         LA   R15,0\n\n\nINSZ&SYSNDX   DS    0H\n         MEND\n         MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTPDSL": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x04&\\x0f\\x01\\x04&\\x0f\\x11\\x15\\x01.\\x01.\\x00\\x01\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-09-16T00:00:00", "modifydate": "2004-09-16T11:15:25", "lines": 302, "newlines": 302, "modlines": 1, "user": "TSO057"}, "text": "****************************************************************\n*\n*   SUBROUTINE TO GET LIST OF MEMBERS IN LIBRARY\n*   RETURNS UP TO 20000 MEMBERS + LAST ONE BLANK\n*   AND NUMBER OF MEMBERS\n*\n*   ASSUMES :  DDNAME IS ALLOCATED TO LIBRARY\n*              LIBRARY IS PO\n*\n*\n*   RC = 0  OK\n*      = 4  OVERFLOW OR NO MEMBERS IN LIBRARY\n*      > 4  SERIOUS ERROR\n*\n****************************************************************\nINSTPDSL INSTSS\n         LM    R4,R6,0(R1)\n         L     R11,12(R1)\n         USING DDNAME,R4\n         USING MEMNAME,R5\n         USING SLOTNO,R6\n         USING MEMNO,R11\n\n         MVC   MEMNO,=A(0)\n\n         MVI   OVERFLOW,C'N'\n\n         MVC   R_DCB(R_DCB_Z-R_DCB),T_DCB\n         MVC   R_OPEN(R_OPEN_Z-R_OPEN),T_OPEN\n         MVC   R_CLOSE(R_CLOSE_Z-R_CLOSE),T_CLOSE\n         MVC   R_DESERV(R_DESERV_Z-R_DESERV),T_DESERV\n\n         LA    R10,R_DCB\n         USING IHADCB,R10\n\n         MVC   DCBDDNAM,DDNAME\n\n         CLOSE ((R10)),MF=(E,R_CLOSE)\n         OPEN  ((R10)),MF=(E,R_OPEN)\n         LTR   R15,R15\n         BNZ   RET12\n\n* DO A DESERV ON THIS DDNAME\n\n         DESERV FUNC=GET_ALL,DCB=((R10)),                              X\n               AREAPTR=R_APTR,MF=(E,R_DESERV)\n*1       JLPTRACE ((R15),X),((R0),X),(R_APTR,X)\n\n* EMPTY LIBRARY?\n\n         C     R15,=A(8)\n         BNE   NOT_NOMEM\n         N     R0,=A(X'0000FFFF')\n         CH    R0,=Y(X'3F4')\n         BNE   NOT_NOMEM\n\n         CLOSE ((R10)),MF=(E,R_CLOSE)\n         B     RET4\nNOT_NOMEM DS  0H\n\n*1_II    JLPTRACE ((R15),X),((R0),X),(R_APTR,X)\n\n         LTR   R15,R15\n         BNZ   RET12\n\n         L     R7,R_APTR\n         USING DESB,R7\n\n\n         LA    R1,0\n         ST    R1,MEMNO\nONE_DESB_LOOP  DS   0H\n         LTR   R7,R7\n         BZ    ONE_DESB_LOOP_END\n         CLC   =CL8'IGWDESB',DESB_ID\n         BNE   RET12\n\n*T2       JLPTRACE  DESB_FIXED,(DESB_FIXED,X),\n*               (DESB_NEXT,X),\n*               (DESB_COUNT,X),\n*               (DESB_LEN,X),\n*               (DESB_SUBPOOL,X),\n*               (DESB_GAP_LEN,X),\n*               (DESB_DATA,,100),\n*               (DESB_DATA,X,40)\n\n\n\n\n\n         LA    R8,DESB_DATA\n         USING SMDE,R8\n\n\n         LA    R1,0\n         ST    R1,W_SMDE_COUNT\n\n\nONE_SMDE_LOOP  DS   0H\n         L     R1,W_SMDE_COUNT\n         C     R1,DESB_COUNT\n         BNL   ONE_SMDE_LOOP_END\n\n         CLC   =CL8'IGWSMDE',SMDE_ID\n         BNE   RET12\n\n*        MVC    D,0(R8)\n*T21 JLPTRACE ((R8),X),D1,(D1,X),D2,(D2,X),D3,(D3,X),D4,(D4,X)\n\n         CLI   SMDE_LIBTYPE,SMDE_LIBTYPE_PDS\n         BNE   SMDE_NOT_PDS\n         LH    R1,SMDE_NAME_OFF\n         LA    R1,0(R1,R8)\n         USING SMDE_NAME,R1\n\n         L     R0,MEMNO\n         C     R0,SLOTNO\n         BNL   SMDE_PDS_TOO_MANY\n         A     R0,=A(1)\n         ST    R0,MEMNO\n         MVC   MEMNAME,SMDE_NAME_VAL\n         LA    R5,L'MEMNAME(R5)\n         B     SMDE_PDS_ROOM\nSMDE_PDS_TOO_MANY DS 0H\n         MVI   OVERFLOW,C'Y'\nSMDE_PDS_ROOM DS 0H\n         DROP  R1\n\n         B     SMDE_PROCESSED\nSMDE_NOT_PDS  DS    0H\n\n         CLI   SMDE_LIBTYPE,SMDE_LIBTYPE_PDSE\n         BNE   SMDE_NOT_PDSE\n         LH    R1,SMDE_NAME_OFF\n         LA    R1,0(R1,R8)\n         USING SMDE_NAME,R1\n\n         L     R0,MEMNO\n         C     R0,SLOTNO\n         BNL   SMDE_PDSE_TOO_MANY\n         A     R0,=A(1)\n         ST    R0,MEMNO\n         MVC   MEMNAME,SMDE_NAME_VAL\n         LA    R5,L'MEMNAME(R5)\n         B     SMDE_PDSE_ROOM\nSMDE_PDSE_TOO_MANY DS 0H\n         MVI   OVERFLOW,C'Y'\nSMDE_PDSE_ROOM DS 0H\n         DROP R1\n\n\n         B     SMDE_PROCESSED\nSMDE_NOT_PDSE DS    0H\n         B     RET12\nSMDE_PROCESSED DS    0H\n\n\n*T211    JLPTRACE  W_NAME,(W_NAME,X)\n\n* SKIP UP TO NEXT SMDE\n\n         A     R8,SMDE_LEN\n\n         L     R1,W_SMDE_COUNT\n         LA    R1,1(R1)\n         ST    R1,W_SMDE_COUNT\n         B     ONE_SMDE_LOOP\nONE_SMDE_LOOP_END  DS   0H\n\n\n         DROP  R8\n\n\n\n\n*        FREEMAIN EACH DESB ENTRY AS DONE\n\n         L     R1,DESB_NEXT\n         ST    R1,W_DESB_NEXT\n         L     R3,DESB_LEN\n         SLR   R2,R2\n         ICM   R2,8,DESB_SUBPOOL\n         FREEMAIN RC,A=(R7),SP=(R2),LV=(R3)\n*T22      JLPTRACE ((R15),X),((R0),X)\n\n         L     R7,W_DESB_NEXT\n         B     ONE_DESB_LOOP\nONE_DESB_LOOP_END  DS   0H\n         DROP  R7\n         MVC   MEMNAME,=CL8' '\n\n\n\n\n         CLOSE ((R10)),MF=(E,R_CLOSE)\n*3       JLPTRACE ((R15),X),((R0),X)\n         LTR   R15,R15\n         BNZ   RET12\n         B     RET0\n\nRET0     EQU   *\n         CLI   OVERFLOW,C'Y'\n         BE    RET4\n         INSTRS RC=0\n\nRET4     EQU   *\n         INSTRS RC=4\n\n\nRET12    EQU   *\n         CLOSE ((R10)),MF=(E,R_CLOSE)\n         INSTRS RC=12\n\n         LTORG\n\n*TEMPLATES\n         DS   0D\nT_DCB    DCB                                                           X\n               DDNAME=XXXXXXXX,                                        X\n               MACRF=R,                                                X\n               DSORG=PO\nT_DCB_Z  DS       0D\n\n         DS   0D\nT_DESERV DESERV FUNC=GET_ALL,DCB=T_DCB,AREAPTR=T_APTR,MF=L\nT_DESERV_Z DS 0D\n\n         DS   0D\nT_APTR   DS 0A\n\n         DS   0D\nT_OPEN   OPEN  (T_DCB),MF=L\nT_OPEN_Z DS   0D\n\n         DS   0D\nT_CLOSE  CLOSE (T_DCB),MF=L\nT_CLOSE_Z DS 0D\n\n\n         INSTWORK  START\n\n\n*REAL CONTROL BLOCKS\n         DS   0D\nR_DCB    DCB                                                           X\n               DDNAME=XXXXXXXX,                                        X\n               MACRF=R,                                                X\n               DSORG=PO\nR_DCB_Z     DS   0D\n\n         DS   0D\nR_OPEN   OPEN  (T_DCB),MF=L\nR_OPEN_Z DS   0D\n\n         DS   0D\nR_CLOSE  CLOSE (T_DCB),MF=L\nR_CLOSE_Z DS 0D\n\n         DS   0D\nR_DESERV DESERV FUNC=GET_ALL,DCB=T_DCB,AREAPTR=T_APTR,MF=L\nR_DESERV_Z DS 0D\n\n         DS   0D\nR_APTR   DS  A  ADDRESS RETURNED BY DESERV\n\n\nW_SMDE_COUNT  DS F\nW_DESB_NEXT   DS A\nW_NAME        DS CL16\nOVERFLOW      DS  C\n\n*\n*  D DS          CL120\n*            ORG  D\n*  D1        DS  CL30\n*  D2        DS  CL30\n*  D3        DS  CL30\n*  D4        DS  CL30\n*            ORG\n\n\n         INSTWORK  END\n\n         IGWDES\n         IGWSMDE\n\n         DCBD  DSORG=PO\n\nDDNAMEDS DSECT\nDDNAME   DS  CL8\n\nMEMNAMEDS DSECT\nMEMNAME  DS  CL8\n\nMEMNODS DSECT\nMEMNO    DS  A\n\nSLOTNOX DSECT\nSLOTNO   DS  A\n\n\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTPRS": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00R\\x01\\x03\\x05\\x0f\\x01\\x034?\\x141\\x00;\\x00>\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-12-09T14:31:52", "lines": 59, "newlines": 62, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n&NAME    INSTPRS &FIELD,&RES=,&DLM=' ,',&LEN=\n&NAME    DS    0H\n\n         GBLA  &INSTPRSN\n         LCLA  &SUBA,&RESN\n\n&INSTPRSN  SETA  &INSTPRSN+1\n\n         AIF   ('&FIELD' NE '').A\n         MNOTE 4,'FIELD NOT SPECIFIED'\n         MEXIT\n.A       ANOP\n\n\n         AIF   ('&RES' NE '').B\n         MNOTE 4,'RESULT NOT SPECIFIED'\n         MEXIT\n.B       ANOP\n\n.C       ANOP\n\n         AIF   ('&LEN' NE '').LENB\n         LA    R1,L'&FIELD\n         AGO   .LENZ\n.LENB    ANOP\n         AIF   ('&LEN'(1,1) NE '(').LENC\n         LR    R1,&LEN\n         AGO   .LENZ\n.LENC    ANOP\n         LA    R1,&LEN\n.LENZ    ANOP\n\n         STH   R1,INSPRS_LEN\n         B     INSF&SYSNDX\nINSD&SYSNDX DC  Y(INSE&SYSNDX-*-2),C&DLM\nINSE&SYSNDX DS  0C\nINSF&SYSNDX DS  0H\n         DS  0H\n&SUBA    SETA  1\n&RESN    SETA N'&RES\n         LA     R1,&RESN\n         STH    R1,INSPRS_RECFL\n         LA     R1,&RESN\n         STH    R1,INSPRS_RECFL\n.E       ANOP\n         LA     R1,L'&RES(&SUBA)\n         STH    R1,INSPRS_RECFL+0+2*&SUBA\n         LA     R1,&RES(&SUBA)\n         ST     R1,INSPRS_CALL+12+4*&SUBA\n&SUBA    SETA   &SUBA+1\n         AIF    (&SUBA LE &RESN).E\n.CALL    ANOP\nINSZ&SYSNDX DS  0H\n.CALL1   ANOP\n         CALL   INSTPRSE,(INSPRS_LEN,INSD&SYSNDX,INSPRS_RECFL,         X\n               &FIELD),MF=(E,INSPRS_CALL)\n         MEND\n         MACRO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTPRSE": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x03\\x05\\x0f\\x01\\x03\\x05\\x0f\\x101\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-02-19T10:31:47", "lines": 163, "newlines": 163, "modlines": 0, "user": "TSO057"}, "text": "          PRINT NOGEN\n**********************************************************************\n*                                                                    *\n*         INSTPRSE IS A GENERAL PURPOSE PARSING ROUTINE              *\n*                                                                    *\n*         INPUT PARAMETERS ARE                                       *\n*                                                                    *\n*         1) Y(L'FIELD)                                              *\n*         2) PARSING DELIMITER CHARACTERS (PRECEDED BY HALFWORD      *\n*            WITH NUMBER OF CHARS IN)                                *\n*         3) Y(NO. REC FIELDS,L'REC FIELD 1,L'REC FIELD 2, ..)       *\n*         4) FIELD                                                   *\n*         5) REC FIELD 1                                             *\n*         6) REC FIELD 2                                             *\n*         .....                                                      *\n*         AND SO ON ....                                             *\n*                                                                    *\n*                                                                    *\n**********************************************************************\nINSTPRSE  INSTSS\n          XC    RC,RC\n          XC    NX,NX\n          XC    X,X\n          LR    R8,R1\n          L     R1,0(R8)\n          LTR   R1,R1\n          BNP   Z012\n          LH    R1,0(R1)\n          LTR   R1,R1\n          BM    Z012\n          L     R1,4(R8)\n          LTR   R1,R1\n          BNP   Z012\n          LH    R1,0(R1)\n          LTR   R1,R1\n          BM    Z012\n          L     R1,8(R8)\n          LTR   R1,R1\n          BNP   Z012\n          LH    R1,0(R1)\n          LTR   R1,R1\n          BM    Z012\n          L     R1,12(R8)\n          LTR   R1,R1\n          BNP   Z012\n          L     R2,8(R8)              R2->REC FIELD LENGTHS\n          LA    R9,2(R2)              R9 ->LEN REC FIELD 1\n          LH    R2,0(R2)              R2=NO OF FIELDS\n          LTR   R2,R2\n          BZ    A200                  IF NOT 0 FIELDS\n          LA    R10,16(R8)            R10->ADD REC FIELD 1\nA100      EQU   *                     LOOP TO CLEAR ONE FIELD\n          LH    R15,0(R9)             R15=LEN REC FIELD\n          LTR   R15,R15\n          BM    Z012\n          L     R14,0(R10)            R14->REC FIELD\n          LA    R0,*\n          L     R1,=A(X'40000000')    FOR PAD\n          MVCL  R14,R0                CLEAR\n          LA    R10,4(R10)            NEXT FIELD\n          LA    R9,2(R9)              NEXT LENGTH\n          BCT   R2,A100            ENDLOOP TO CLEAR ONE FIELD\nA200      EQU   *                     ENDIF\n          L     R2,4(R8)              R2->DELIMITERS\n          XC    X,X                   CLEAR XLATE TAB\n          LR    R9,R2                 R9-> FIRST FIELD - 2\n          LH    R2,0(R2)              R2=NO OF DELIMS\n          LTR   R2,R2\n          BZ    A275                  IF NOT 0 DELIMS\n          SLR   R1,R1\n          IC    R3,=X'FF'\nA250      EQU   *                     LOOP TO PUT ONE DELIMITER IN\n          IC    R1,1(R9,R2)\n          STC   R3,X(R1)              MOVE IN ONE \u00acZERO CHAR\n          BCT   R2,A250            ENDLOOP\nA275      EQU   *                     ENDIF\n          MVI   NX,X'FF'\n          MVC   NX+1(L'NX-1),NX       FILL INVERSE XLATE TAB.\n          XC    NX,X                  XLATE TAB FOR NON-DELIMS\n          XC    RC,RC                 0 RC\n          L     R4,12(R8)             R4->FIELD POINTER\n          L     R5,0(R8)              R5->FIELD LEN\n          LH    R5,0(R5)              R5=FIELD LEN LEFT TO DO\n          AR    R5,R4                 R5-> END FIELD\n          L     R6,8(R8)              R6->REC FIELD LENGTHS\n          LH    R7,0(R6)              R7=NO OF REC FIELDS LEFT\n          LA    R6,2(R6)              R6->REC FIELD LENGTH 1\n          LA    R10,16(R8)            R10->ADD REC FIELD 1\nA300      EQU   *                     LOOP TO PARSE TO ONE REC FIELD\n          CR    R4,R5                 LEAVE WHEN FIELD DONE\n          BNL   A500\n          LTR   R7,R7                 LEAVE WHEN NO REC FIELDS LEFT\n          BZ    A500\nA350      EQU   *                     LOOP TO XLATE 256 BYTES\n          LA    R1,256(R4)\n          LR    R11,R5                *\n          SR    R11,R4                *  WANT TO LOOK AT THE NEXT\n          BCTR  R11,0                 *  256 BYTES OF THE INPUT\n          C     R11,=F'255'           *  FIELD, OR IF NOT THAT\n          BNH   A351                  *  MUCH, THEN AS MUCH AS\n          L     R11,=F'255'           *  THERE IS\nA351      EX    R11,TRT1              *\n          BNZ   A370                  LEAVE WHEN FOUND\n          CR    R1,R5\n          BH    A370                  LEAVE WHEN PAST END\n          LA    R4,256(R4)\n          B     A350\nA370      EQU   *                     ENDLOOP\n          LR    R4,R1\n          CR    R4,R5\n          BNH   A390\n          LR    R4,R5\nA390      EQU   *\n          LR    R14,R4\nA400      EQU   *\n          LA    R1,256(R4)\n          LR    R11,R5                *\n          SR    R11,R4                *  WANT TO LOOK AT THE NEXT\n          BCTR  R11,0                 *  256 BYTES OF THE INPUT\n          C     R11,=F'255'           *  FIELD, OR IF NOT THAT\n          BNH   A401                  *  MUCH, THEN AS MUCH AS\n          L     R11,=F'255'           *  THERE IS\nA401      EX    R11,TRT2              *\n          BNZ   A420\n          CR    R1,R5\n          BH    A420\n          LA    R4,256(R4)\n          B     A400\nA420      EQU   *\n          LR    R4,R1\n          CR    R4,R5\n          BNH   A440\n          LR    R4,R5\nA440      EQU   *\n          LR    R15,R4\n          SR    R15,R14\n          L     R0,0(R10)\n          LH    R1,0(R6)\n          CR    R1,R15\n          BNL   A450\n          MVC   RC,=A(4)\nA450      EQU   *\n          A     R15,=A(X'40000000')\n          MVCL  R0,R14\n          BCTR  R7,0                  ONE REC FIELD DONE\n          LA    R10,4(R10)            R10->ADD NEXT REC FIELD\n          LA    R6,2(R6)              R6->NEXT REC FIELD LENGTH\n          B     A300\nA500      EQU   *                  ENDLOOP TO PARSE TO ONE REC FIELD\n          CLC   RC,=A(0)\n          BE    RET0\nRET4     INSTRS RC=4\nRET0     INSTRS RC=0\nZ012     INSTRS RC=12\n          LTORG\nTRT1      TRT   0(0,R4),NX\nTRT2      TRT   0(0,R4),X\n          INSTWORK   START\nRC        DC    A(0)\nX         DC    XL256'00'\nNX        DC    XL256'00'\n          INSTWORK   END\n          END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTREQU": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x009\\x00\\x985/\\x01\\x004\\x9f\\x13R\\x00!\\x00\\x15\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1998-12-18T00:00:00", "modifydate": "2000-12-14T13:52:39", "lines": 33, "newlines": 21, "modlines": 0, "user": "TSO057"}, "text": "       MACRO\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n       INSTREQU\n       GBLB  &INSTREQU\n       AIF   (&INSTREQU EQ 1).MEXIT\n\n\nR0     EQU   0\nR1     EQU   1\nR2     EQU   2\nR3     EQU   3\nR4     EQU   4\nR5     EQU   5\nR6     EQU   6\nR7     EQU   7\nR8     EQU   8\nR9     EQU   9\nR10    EQU   10\nR11    EQU   11\nR12    EQU   12\nR13    EQU   13\nR14    EQU   14\nR15    EQU   15\n\n&INSTREQU SETB 1\n\n.MEXIT ANOP\n\n       MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTRS": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00A\\x00\\x985\\x1f\\x01\\x004\\x9f\\x13R\\x00<\\x00\\x12\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1998-12-17T00:00:00", "modifydate": "2000-12-14T13:52:41", "lines": 60, "newlines": 18, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n&NAME    INSTRS &RC=\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n.*\n.*\n.* RETURN FROM RENT ASM PROGRAM\n.*\n.*\n       GBLB   &INSTSAVE\n\n&NAME    DS   0H\n         AIF   ('&RC' EQ '').RCOK\n         AIF   ('&RC' EQ '(R15)').RCOK\n         AIF   ('&RC' EQ '(15)').RCOK\n         AIF   ('&RC' EQ '0').RC15\n         AIF   ('&RC' EQ '1').RC15\n         AIF   ('&RC' EQ '2').RC15\n         AIF   ('&RC' EQ '3').RC15\n         AIF   ('&RC' EQ '4').RC15\n         AIF   ('&RC' EQ '5').RC15\n         AIF   ('&RC' EQ '6').RC15\n         AIF   ('&RC' EQ '7').RC15\n         AIF   ('&RC' EQ '8').RC15\n         AIF   ('&RC' EQ '9').RC15\n         AIF   ('&RC' EQ '10').RC15\n         AIF   ('&RC' EQ '11').RC15\n         AIF   ('&RC' EQ '12').RC15\n         AIF   ('&RC' EQ '13').RC15\n         AIF   ('&RC' EQ '14').RC15\n         AIF   ('&RC' EQ '15').RC15\n         AIF   ('&RC' EQ '16').RC15\n       MNOTE 8,'YOU MAY ONLY SPECIFY RC=(R15) OR RC=(15) OR RC=0 TO 16'\n         MEXIT\n.RC15    ANOP\n         LA    R15,&RC\n.RCOK    ANOP\n\n\n\n         AIF   (&INSTSAVE EQ 0).RET\n\n         LR    R2,R15              SAVE R15\n         LR    R1,R13              GET FREEMAIN ADDRESS\n         L     R13,INSTWORK_SAVEBK R13 NOW OLD REG 13\n         L     R0,=A(INSTWORK_DATALEN) SET GETMAIN LEN\n         FREEMAIN RU,LV=(0),A=(1)   FREE DATA DSECT STORAGE\n         LR    R15,R2              RC IN R15\n\n.RET     ANOP\n         L     R14,12(R13)         RESTORE R14\n         LM    R0,R12,20(R13)      RESTORE R0-R14\n         AIF   ('&RC' NE '').NOZERO\n         SLR   R15,R15\n.NOZERO  ANOP\n         BSM   0,R14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTSET": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00E\\x01\\x03\\x10O\\x01\\x05\\x06?\\x14B\\x00x\\x00v\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2005-03-04T14:42:45", "lines": 120, "newlines": 118, "modlines": 0, "user": "TSO057"}, "text": "       PUNCH 'SETCODE AC(1)'\n*********************************************************************\n*                                                                   *\n*    THIS SUBROUTINE IS USED TO SET HALFWORD PREFIXED STRING        *\n*    PASSED TO IT INTO A SET OF NAME/TOKEN PAIRS.  IT IS TO BE USED *\n*    IN CONJUNCTION WITH INSTGET AND INSTUJI                        *\n*                                                                   *\n*    SEE INSTDOC FOR AN EXPLANATION OF THESE MACROS                 *\n*                                                                   *\n*********************************************************************\nINSTSET  INSTSS\n         L      R3,0(R1)     R3 -> STRING\n         LH     R4,0(R3) R4 = LEN STRING\n         LA     R4,2(R4)\n*\n* MOVE INTO BUFFER PADDING WITH LOWVALUES\n*\n         LA     R14,BUFARR\n         L      R15,=A(BUFARRZ-BUFARR)\n         LR     R0,R3\n         LR     R1,R4\n         MVCL   R14,R0\n         MODESET MODE=SUP\n         MVC    NAME,=C'INST.TTYY.ASIDXX'   TOKEN NAME SKEL\n         LA     R1,0\n         USING  PSA,R1\n         L      R1,PSAAOLD\n         DROP   R1\n         USING  ASCB,R1\n         MVC    NAME+14(2),ASCBASID         SET ASID IN HEX INTO NAME\n         DROP   R1\n*\n*        DELETE ALL TOKENS CURRENTLY SET AND A FEW MORE\n*\n         LA     R2,0\n         STCM   R2,3,NAME+7\n         CALL   IEANTDL,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\nDLOOP    EQU    *\n         LA     R2,1(R2)\n         STCM   R2,3,NAME+7\n         CALL   IEANTDL,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BZ     DLOOP\n         LA     R2,1(R2)\n         STCM   R2,3,NAME+7\n         CALL   IEANTDL,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BZ     DLOOP\n         LA     R2,1(R2)\n         STCM   R2,3,NAME+7\n         CALL   IEANTDL,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BZ     DLOOP\n         LA     R2,1(R2)\n         STCM   R2,3,NAME+7\n         CALL   IEANTDL,(LEVEL,NAME,TOKEN,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BZ     DLOOP\n         B      DLOOPZ\nDLOOPZ   EQU    *\n*\n*        SET UP TOKENS, EACH 16 BYTES OF THE STRING\n*        THE FIRST SET OF BYTES BLANK STOPS US DOING THIS\n*\n         LA     R2,0\n         LA     R6,BUFARR\n         LA     R4,BUFARR(R4)\nTLOOP   EQU    *\n         STCM   R2,3,NAME+7\n         CALL   IEANTCR,(LEVEL,NAME,(6),PERSIST,RETC),VL,MF=(E,PL)\n         LTR    R15,R15\n         BNZ    ERRRE\n         LA     R6,L'TOKEN(R6)\n         LA     R2,1(R2)\n         CR     R6,R4\n         BH     TLOOPZ\n         B      TLOOP\nTLOOPZ   EQU    *\n         MODESET MODE=PROB\n         B      OK\n*\n*\nERRRE    EQU    *\n         LR     R4,R15\n         MODESET MODE=PROB\n         LR     R15,R4\n         B      ERR\n*\nERR      EQU    *\n         INSTRS RC=(R15)\n*\nOK       EQU    *\n         INSTRS RC=0\n*\nLEVEL    DC     A(IEANT_SYSTEM_LEVEL)\n         LTORG\nPERSIST  DC     A(IEANT_PERSIST)\n\n\n         INSTWORK  START\n\nLBUFARR  DC  A(BUFARRZ-BUFARR)\n\nPL       CALL   ,(,,,,,,,),MF=L\n\nNAME     DC     CL16' '\nTOKEN    DC     CL16' '\nRETC     DC     A(0)\n\nBUFARR   DS  0C\n         DS  CL2000\nBUFARRZ DS 0C\n\n         INSTWORK  END\n\n\n         IHAPSA  DSECT=YES\n         IHAASCB DSECT=YES\n         IEANTASM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTSS": {"ttr": 1550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\t\\x11\\x1f\\x01\\t\\x11\\x1f\\x14F\\x00H\\x00H\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-04-21T00:00:00", "modifydate": "2009-04-21T14:46:48", "lines": 72, "newlines": 72, "modlines": 0, "user": "TSO057"}, "text": "       MACRO\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n.*\n.*\n.* START RENT ASM PROGRAM\n.*\n.* AFTER THIS R12 IS THE BASE ON THE PROGRAM CSECT, R13 THE BASE\n.* ON THE GETMAINED DSECT FOR WORKING STORAGE.  ANY FURTHUR USINGS\n.* MUST BE SET UP MANUALLY\n.*\n.*\n.*\n&NAME  INSTSS &VER=1,&SAVEAREA=YES\n\n.*\n.* FOR INSTBALI/O CELLS\n.*\n       GBLA   &INSTBALN\n       GBLB   &INSTSAVE\n&INSTBALN SETA   0 NO OF BAL CELLS\n&INSTSAVE SETB   0 GETMAIN SAVE AND WORK AREA?\n\n         AIF   ('&SAVEAREA' EQ 'YES').SAVEOK\n         AIF   ('&SAVEAREA' EQ 'NO').SAVEOK\n         MNOTE 8,'SAVEAREA MUST BE YES OR NO'\n         MEXIT\n.SAVEOK  ANOP\n\n         AIF   ('&NAME' NE '').NAMEOK\n         MNOTE 8,'NAME MUST BE SPECIFIED'\n         MEXIT\n.NAMEOK  ANOP\n\n&NAME  CSECT\n&NAME  AMODE 31\n&NAME  RMODE ANY\n       INSTREQU\n       USING *,R15\n       SAVE (14,12),,'&NAME VER &VER &SYSDATE &SYSTIME '\n       DROP  R15\n       USING &NAME,R12         SET UP CSECT ADDRESSABILITY\n       LR    R12,R15             LOAD BASE REGISTER\n\n\n.*     SAVEAREA = NO MEANS NO WORK AREA/SAVE AREA GETMAINED\n\n       AIF   ('&SAVEAREA' EQ 'NO').MEXIT\n\n\n\n&INSTSAVE SETB   1 GETMAIN SAVE AND WORK AREA?\n\n\n       L     R0,INSTWORK_DATALEN_A\n       GETMAIN RU,LV=(0),LOC=BELOW   STORAGE FOR DATA DSECT, ADDR IN R1\n       USING INSTWORK_DATA,R1\n       ST    R13,INSTWORK_SAVEBK CHAIN BACK\n       ST    R1,INSTWORK_SAVEFW-INSTWORK_SAVE(R13) CHAIN FOREWARD\n       LR    R15,R1\n       LM    R0,R1,INSTWORK_SAVER0-INSTWORK_SAVE(R13) RESTORE R0 R1\n       LR    R13,R15             LOAD REGISTER 13 ADDR GETMAINED SA\n       DROP  R1\n       USING INSTWORK_DATA,R13   SET UP DATA DSECT ADDR.\n       B     *+8\nINSTWORK_DATALEN_A DC A(INSTWORK_DATALEN)\n\n.MEXIT ANOP\n       MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTSTR": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00A\\x01\\x006/\\x01\\t!\\x9f\\x17@\\x02C\\x01\\xea\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2000-12-27T00:00:00", "modifydate": "2009-08-07T17:40:41", "lines": 579, "newlines": 490, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n.**********************************************************************\n.*\n.*  26/12/00  1.1    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n&NAME    INSTSTR &RES=,&BAL=\n         GBLA  &INSTSTRN\n         LCLA  &OPNO,&CT1,&CT2,&DR15,&FLDLEN\n         LCLC  &C,&T,&P,&ASTYP,&INTYP,&EDTYP,&FLD,&EDLEN,&EDLENT\n         LCLC  &WK1\n         GBLB  &INSTSWK,&INSTSPG\n         LCLB  &INSTSPL\n\n&INSTSTRN  SETA  &INSTSTRN+1\n\n.******                                     *******\n.*\n.*    WILL CONCATENATE ANY NO OF OPERANDS INTO A FIELD SPECIFIED BY\n.*    RES=\n.*\n.*    EACH OPERAND SPECIFIED MAY BE:\n.*\n.*              1) ABSEXP|RX   ->THAT NO SPACES GENERATED\n.*\n.*              2) *+ABSEXP    ->SKIP ABSEXP COLS FROM START\n.*\n.*              3) 'STRING'    ->PUT THAT STRING INTO LINE\n.*\n.*              4) (NAME,EDITTYPE,EDITLEN) OR (NAME,EDITTYPE) OR NAME\n.*\n.*                 WHERE NAME IS CLASSIFIED AS:\n.*              ASSEMBLER FIELD TYPE             TREATED INTERNALLY AS\n.*                 (REG) ---------------------------INTYP R\n.*                 ABSEXP(REG) OR UNDEFINED --------INTYP LA\n.*                 FIELD TYPE  X,B,R,Q,V,S,C,G,D,E\n.*                             W--------------------INTYP C\n.*                 FIELD TYPE  P -------------------INTYP P\n.*                 FIELD TYPE  Z -------------------INTYP Z\n.*                 FIELD TYPE  F,A,Y,H--------------INTYP F\n.*\n.*                 TYPE G IS FIXED POINT EXPLICIT LENGTH\n.*                 TYPE R IS ADDRESS CON EXPLICIT LENGTH\n.*\n.*\n.*                 EDITLEN IS THE LEN. OF THE FIELD TO BE PUT ON THE\n.*                 LINE (FOR INTYPE X THE EDITLEN IS ROUNDED DOWN AND\n.*                 HALVED,AND THEN TWICE THAT LENGTH IS PUT ON\n.*                 THE LINE)\n.*\n.*                 IT MAY BE:\n.*                 (R2-R12):\n.*                 ANYTHING VALID RX INSTRUCTION:\n.*\n.*                 EDITTYPE IS\n.*\n.*                 X  ---- CONVHEX TO LINE\n.*                 C  ---- MOVE TO LINE\n.*                 N  ---- PUT ON LINE AS A NO. WITH 0 SUPRESSION\n.*                         AND LEADING -IF NEGATIVE.\n.*\n.*                 FOR NUMERIC EDITING THE DEFAULT EDIT LENGTH IS THAT\n.*                 NEEDED TO JUST HOLD THE NUMBER\n.*                 FOR CHAR. EDITING THE DEFAULT EDITLEN IS THE FIELD\n.*                 LENGTH,OR 4 FOR INTYPE R|LA\n.*                 FOR HEX EDITING IT IS TWICE THAT\n.*\n.*\n.* EXAMPLE\n.*\n.*\n.*\n.*                  *  P =  \" R1=XXXXXXXX \"\n.*\n.*                      INSTSTR  ' R1=',((R1),X),RES=P\n.*\n.*\n.*                  *  P =  \" COUNT=44\"\n.*\n.*                      ZAP  Q,=P'44'\n.*                      INSTSTR  ' COUNT=',Q,RES=P\n.*\n.*\n.*                  P   DS   CL80\n.*                  Q   DS   PL3\n.*                  A   DS   PL3\n.*\n.*\n&NAME    DS    0H\n         AIF   ('&RES' NE '').RESOK\n         MNOTE 9,'NO RESULT FIELD SPECIFIED'\n         MEXIT\n\n\n.RESOK   MVI   &RES,C' '\n         MVC   &RES+1(L'&RES-1),&RES     CLEAR RESULT\n.*\n.* IN THE CASE OF ONE LITERAL PARAMETER ONLY\n.*\n         AIF   (N'&SYSLIST NE 1).NOTQUIC\n&OPNO    SETA      1\n&C       SETC  '&SYSLIST(&OPNO)'\n&T       SETC  T'&SYSLIST(&OPNO)\n         AIF   (K'&C EQ 0).NOTQUIC      NULL OPERAND\n         AIF   ('&C'(1,1) NE '''').NOTQUIC    STRING IN QUOTES\n\n.QSTRING  AIF   ('&C'(1,1) NE '''').QSTRINGZ    STRING IN QUOTES\n&CT1     SETA  2\n&CT2     SETA  0\n.QCTLOOP  ANOP\n\n         AIF   (&CT1 EQ K'&C).QCTZ\n         AIF   ('&C'(&CT1,1) NE '''').QSQE\n&CT1     SETA  &CT1+1\n\n.QSQE     ANOP\n&CT1     SETA  &CT1+1\n&CT2     SETA  &CT2+1\n         AGO   .QCTLOOP\n.QCTZ     ANOP\n\n         AIF   (&CT2 EQ 0).QSTRINGZ\n         AIF   (&CT2 GT 1).QMVC\n         MVI &RES,C&C\n         AGO   .QMZ\n.QMVC     MVC &RES.(&CT2),=C&C\n.QMZ      ANOP\n.QSTRINGZ ANOP\n         AGO   .QOPLOOPZ\n\n\n\n\n\n\n.NOTQUIC ANOP\n\n         STM   R14,R1,INSTSTR_SRSV       SAVE RR 1-14\n         LA    R15,&RES                  R15->FIRST COL\n&OPNO    SETA  0\n\n\n.OPLOOP  ANOP                            LOOP FOR 1 OPERAND\n\n&OPNO    SETA      &OPNO+1\n         AIF   (N'&SYSLIST LT &OPNO).OPLOOPZ\n&C       SETC  '&SYSLIST(&OPNO)'\n&T       SETC  T'&SYSLIST(&OPNO)\n.NUL     AIF   (K'&C NE 0).NULZ         NULL OPERAND\n         AGO   .OPLOOPE\n.NULZ    ANOP\n\n.STRING  AIF   ('&C'(1,1) NE '''').STRINGZ    STRING IN QUOTES\n&CT1     SETA  2\n&CT2     SETA  0\n.CTLOOP  ANOP\n\n         AIF   (&CT1 EQ K'&C).CTZ\n         AIF   ('&C'(&CT1,1) NE '''').SQE\n&CT1     SETA  &CT1+1\n\n.SQE     ANOP\n&CT1     SETA  &CT1+1\n&CT2     SETA  &CT2+1\n         AGO   .CTLOOP\n.CTZ     ANOP\n\n         AIF   (&CT2 EQ 0).OPLOOPE\n         AIF   (&CT2 GT 1).MVC\n         MVI &DR15.(R15),C&C\n         AGO   .MZ\n.MVC     MVC &DR15.(&CT2,R15),=C&C\n.MZ      ANOP\n\n&DR15    SETA  &DR15+&CT2\n         AGO   .OPLOOPE\n.STRINGZ ANOP\n\n.COL     AIF   (K'&C LE 2).COLZ         *+ABSEXP ->COL ABSEXP\n         AIF   ('&C'(1,2) NE '*+').COLZ\n         LA    R15,&RES-*+&C\n&DR15    SETA  0\n         AGO   .OPLOOPE\n.COLZ    ANOP\n\n.SPO     AIF   (('&T' NE 'O') OR ('&C'(1,1) EQ '(')).SPOZ  SPACES\n         LA    R15,&DR15+&C.(R15)\n&DR15    SETA  0\n         AGO   .OPLOOPE\n.SPOZ    ANOP\n\n.SPU     AIF   (('&T' NE 'U') OR ('&C'(1,1) EQ '(')).SPUZ  SPACES\n         LA    R15,&DR15+&C.(R15)\n&DR15    SETA  0\n         AGO   .OPLOOPE\n.SPUZ    ANOP\n\n.SPN     AIF   (('&T' NE 'N') OR ('&C'(1,1) EQ '(')).SPNZ  SPACES\n&DR15    SETA  &DR15+&SYSLIST(&OPNO)\n         AGO   .OPLOOPE\n.SPNZ    ANOP\n\n.*\n.*\n.*\n.*\n&EDTYP   SETC  'C'\n&EDLEN   SETC  ''\n&EDLENT  SETC  ''\n&CT1     SETA  N'&SYSLIST(&OPNO)\n         AIF   (&CT1 GT 1).NO1Z\n&FLD     SETC  '&SYSLIST(&OPNO)'\n&ASTYP   SETC  T'&SYSLIST(&OPNO)\n         AIF   ('&SYSLIST(&OPNO,1)' EQ '').NO11Z\n    AIF   ('&SYSLIST(&OPNO,1)'(K'&SYSLIST(&OPNO,1),1) NE ')').NO11Z\n&FLD     SETC  '&SYSLIST(&OPNO,1)'\n&ASTYP   SETC  T'&SYSLIST(&OPNO,1)\n.NO11Z   ANOP\n\n         AGO   .NOZ\n.NO1Z    ANOP\n\n&FLD     SETC  '&SYSLIST(&OPNO,1)'\n&ASTYP   SETC  T'&SYSLIST(&OPNO,1)\n         AIF   (('FLD' NE '') AND (N'&SYSLIST(&OPNO) LE 3)).FLDOK1\n         MNOTE 9.'INVALID OPERAND &C'\n         MEXIT\n\n.FLDOK1  ANOP\n&EDTYP   SETC  '&SYSLIST(&OPNO,2)'\n         AIF   (N'&SYSLIST(&OPNO) LE 2).NO3Z\n&EDLEN   SETC  '&SYSLIST(&OPNO,3)'\n         AIF   ('&EDLEN' EQ '').NO3Z\n         AIF   ('&EDLEN'(1,1) NE '(').EDLRZ\n&EDLENT  SETC  'LR'\n         AGO   .EDLENTZ\n.EDLRZ   ANOP\n\n         AIF   (T'&SYSLIST(&OPNO,3) NE 'N').EDLNZ\n&EDLENT  SETC  'N'\n         AGO   .EDLENTZ\n.EDLNZ   ANOP\n\n         AIF   (T'&SYSLIST(&OPNO,3) NE 'U').EDLUZ\n        AIF ('&SYSLIST(&OPNO,3)'(K'&SYSLIST(&OPNO,3),1) EQ ')').EDLUZ\n&EDLENT  SETC  'U'\n         AGO   .EDLENTZ\n.EDLUZ   ANOP\n\n&EDLENT  SETC  'LA'\n.EDLENTZ ANOP\n\n.NO3Z    ANOP\n.NOZ     ANOP\n.*\n.*\n.*\n.*\n.*\n         AIF   ('&EDTYP' NE '').EDTCZ\n&EDTYP   SETC  'C'\n.EDTCZ   ANOP\n\n         AIF   ('&EDTYP' EQ 'C').EDTOK\n         AIF   ('&EDTYP' EQ 'N').EDTOK\n         AIF   ('&EDTYP' EQ 'X').EDTOK\n         MNOTE 9,'INVALID EDIT TYPE &EDTYP'\n         MEXIT\n.EDTOK   ANOP\n.*\n.*\n.*\n.*\n         AIF   ('&FLD'(1,1) NE '(').INTRZ\n&INTYP   SETC  'R'\n&FLDLEN  SETA  4\n         AGO   .INTZ\n.INTRZ   ANOP\n\n         AIF   ('&FLD'(K'&FLD,1) NE ')').INTLAZ\n&INTYP   SETC  'LA'\n&FLDLEN  SETA  4\n         AGO   .INTZ\n.INTLAZ  ANOP\n\n         AIF   ('&ASTYP' NE 'Z').INTZZ\n&INTYP   SETC  'Z'\n&FLDLEN  SETA  L'&SYSLIST(&OPNO,1)\n         AGO   .INTZ\n.INTZZ   ANOP\n\n         AIF   ('&ASTYP' NE 'P').INTPZ\n&INTYP   SETC  'P'\n&FLDLEN  SETA  L'&SYSLIST(&OPNO,1)\n         AGO   .INTZ\n.INTPZ   ANOP\n\n         AIF   ('&ASTYP' EQ 'F').INTF\n         AIF   ('&ASTYP' EQ 'A').INTF\n         AIF   ('&ASTYP' EQ 'H').INTF\n         AIF   ('&ASTYP' EQ 'Y').INTF\n         AGO   .INTFZ\n.INTF    ANOP\n&INTYP   SETC  'F'\n&FLDLEN  SETA  L'&SYSLIST(&OPNO,1)\n         AGO   .INTZ\n.INTFZ   ANOP\n\n         AIF   ('&ASTYP' EQ 'X').INTC\n         AIF   ('&ASTYP' EQ 'B').INTC\n         AIF   ('&ASTYP' EQ 'C').INTC\n         AIF   ('&ASTYP' EQ 'D').INTC\n         AIF   ('&ASTYP' EQ 'E').INTC\n         AIF   ('&ASTYP' EQ 'G').INTC\n         AIF   ('&ASTYP' EQ 'Q').INTC\n         AIF   ('&ASTYP' EQ 'R').INTC\n         AIF   ('&ASTYP' EQ 'S').INTC\n         AIF   ('&ASTYP' EQ 'V').INTC\n         AIF   ('&ASTYP' EQ 'W').INTC\n         AGO   .INTCZ\n.INTC    ANOP\n&INTYP   SETC  'C'\n&FLDLEN  SETA  L'&SYSLIST(&OPNO,1)\n         AGO   .INTZ\n.INTCZ   ANOP\n\n         AIF   ('&ASTYP' EQ 'U').INTLA2\n         AGO   .INTLA2Z\n.INTLA2  ANOP\n&INTYP   SETC  'LA'\n&FLDLEN  SETA  4\n         AGO   .INTZ\n.INTLA2Z ANOP\n\n         MNOTE 9,'&FLD HAS INVALID TYPE &ASTYP'\n         MEXIT\n.INTZ    ANOP\n.*\n.*\n.*\n.*\n         AIF   ('&INTYP' NE 'R').RCHZ\n&FLD     SETC  '&FLD'(2,K'&FLD-2)\n         AIF   (('&FLD' NE '14') AND ('&FLD' NE 'R14')).R14CHZ\n&FLD     SETC  'INSTSTR_SRSE'\n         AGO   .RCHASEL\n.R14CHZ  ANOP\n         AIF   (('&FLD' NE '15') AND ('&FLD' NE 'R15')).R15CHZ\n&FLD     SETC  'INSTSTR_SRSF'\n         AGO   .RCHASEL\n.R15CHZ  ANOP\n         AIF   (('&FLD' NE '1') AND ('&FLD' NE 'R1')).R1CHZ\n&FLD     SETC  'INSTSTR_SRS1'\n         AGO   .RCHASEL\n.R1CHZ   ANOP\n         AIF   (('&FLD' NE '0') AND ('&FLD' NE 'R0')).R0CHZ\n&FLD     SETC  'INSTSTR_SRS0'\n         AGO   .RCHASEL\n.R0CHZ   ANOP\n         AIF   ('&EDTYP' EQ 'X').RCHMOD1\n         AIF   ('&EDTYP' EQ 'N').RCHMODZ\n         AIF   ('&EDLEN' EQ '').RCHMODZ\n.RCHMOD1 ST    &FLD,INSTSTR_SRS#\n&FLD     SETC  'INSTSTR_SRS#'\n         AGO   .RCHASEL\n.RCHMODZ ANOP\n.RCHNSEL ANOP\n         AGO   .RCHESEL\n.RCHASEL ANOP\n&INTYP  SETC  'F'\n&FLDLEN SETA  4\n.RCHESEL ANOP\n.RCHZ    ANOP\n.*\n.*\n.*\n.*\n         AIF   ('&EDTYP' NE 'C').ETCZ\n         AIF   ('&INTYP' NE 'R').CRZ\n         ST    &FLD,&DR15.(R15)\n&DR15    SETA  &DR15+4\n         AGO   .CZ\n.CRZ     ANOP\n         AIF   ('&EDLENT' NE '').CMVCZ\n         MVC   &DR15.(&FLDLEN,R15),&FLD\n&DR15    SETA  &DR15+&FLDLEN\n         AGO   .CZ\n.CMVCZ   ANOP\n         AIF   ('&EDLENT' NE 'N').CMVCNZ\n         MVC   &DR15.(&EDLEN,R15),&FLD\n&DR15    SETA  &DR15+&SYSLIST(&OPNO,3)\n         AGO   .CZ\n.CMVCNZ  ANOP\n         AIF   ('&EDLENT' NE 'U').CMVCUZ\n         MVC   &DR15.(&EDLEN,R15),&FLD\n         LA    R15,&DR15+&EDLEN.(R15)\n&DR15    SETA  0\n         AGO   .CZ\n.CMVCUZ  ANOP\n         AIF   (&DR15 EQ 0).CMVCX1\n         LA    R15,&DR15.(R15)\n&DR15    SETA  0\n.CMVCX1  ANOP\n         LA    R14,&FLD\n         AIF   ('&EDLENT' NE 'LA').CMVCLAZ\n         LA    R1,&EDLEN\n         SH    R1,=Y(1)\n         BNP   *+12\n         EX    R1,INSTSTR_SXAA\n         LA    R15,1(R1,R15)\n         AGO   .CZ\n.CMVCLAZ ANOP\n         AIF   ('&EDLENT' NE 'LR').CMVCLRZ\n         LR    R1,&EDLEN\n         SH    R1,=Y(1)\n         BNP   *+12\n         EX    R1,INSTSTR_SXAA\n         LA    R15,1(R1,R15)\n         AGO   .CZ\n.CMVCLRZ ANOP\n.CZ      ANOP\n         AGO   .ETZ\n.ETCZ    ANOP\n.*\n.*\n.*\n&INSTSPL SETB  1                        TO GEN. GLOBAL CALL AREA\n.*\n.*\n.*\n.*\n.*\n         AIF   ('&EDTYP' NE 'X').ETXZ\n         AIF   (&DR15 EQ 0).X1\n         LA    R15,&DR15.(R15)\n&DR15    SETA  0\n.X1      ANOP\n         LA    R14,&FLD\n         AIF   ('&EDLENT' NE '').XLZ\n         LA    R1,&FLDLEN*2\n         AGO   .XZ\n.XLZ     ANOP\n         AIF   ('&EDLENT' NE 'LR').XLRZ\n         LR    R1,&EDLEN\n         AGO   .XZ\n.XLRZ    ANOP\n         LA    R1,&EDLEN\n.XZ      ANOP\n         BAL   R0,INSTSTR_SPX1\n         AGO   .ETZ\n.ETXZ    ANOP\n         AIF   ('&EDTYP' NE 'N').ETNZ\n         AIF   ('&INTYP' NE 'R').NRZ\n         LR    R14,&FLD\n         AGO   .NZ\n.NRZ     ANOP\n         AIF   ('&INTYP' NE 'F').NFZ\n         AIF   (&FLDLEN EQ 2).NFH\n         L     R14,&FLD\n         AGO   .NFFZ\n.NFH     LH    R14,&FLD\n.NFFZ    ANOP\n         AGO   .NZ\n.NFZ     ANOP\n         AIF   ('&INTYP' NE 'Z').NZZ\n         PACK  INSTSTR_SPNP,&FLD\n         AGO   .NZ\n.NZZ     ANOP\n         AIF   ('&INTYP' NE 'P').NPZ\n         ZAP   INSTSTR_SPNP,&FLD\n         AGO   .NZ\n.NPZ     ANOP\n         AIF   (&FLDLEN LE 4).NC4\n         MNOTE 9,'&FLD > 4 BYTES LONG'\n         MEXIT\n.NC4     AIF   (&FLDLEN LT 4).NC4Z\n         ICM   R14,15,&FLD\n         AGO   .NZ\n.NC4Z    ANOP\n         SLR   R14,R14\n         AIF   (&FLDLEN LT 3).NC3Z\n         ICM   R14,7,&FLD\n         AGO   .NZ\n.NC3Z    ANOP\n         AIF   (&FLDLEN LT 2).NC2Z\n         ICM   R14,3,&FLD\n         AGO   .NZ\n.NC2Z    ANOP\n         IC    R14,&FLD\n         AGO   .NZ\n.NZ      ANOP\n         AIF   ('&EDLENT' EQ '').N22\n&P       SETC  'INSTSTR_SPN2'\n         AIF   (('&INTYP' EQ 'Z') OR ('&INTYP' EQ 'P')).N21\n&P       SETC  'INSTSTR_SPN1'\n.N21     ANOP\n         AGO   .N24\n.N22     ANOP\n&P       SETC  'INSTSTR_SPN4'\n         AIF   (('&INTYP' EQ 'Z') OR ('&INTYP' EQ 'P')).N23\n&P       SETC  'INSTSTR_SPN3'\n.N23     ANOP\n.N24     ANOP\n.*\n.*\n.*\n.*\n         AIF   ('&EDLENT' NE '').NL0Z\n         AGO   .NLZ\n.NL0Z    ANOP\n         AIF   ('&EDLENT' NE 'LR').NLLRZ\n         LR    R1,&EDLEN\n         AGO   .NLZ\n.NLLRZ   ANOP\n         LA    R1,&EDLEN\n.NLZ     ANOP\n.*\n.*\n.*\n.*\n         AIF   (&DR15 EQ 0).N44\n         LA    R15,&DR15.(R15)\n&DR15    SETA  0\n.N44     ANOP\n         BAL   R0,&P\n.*\n.*\n         AGO   .ETZ\n.ETNZ    ANOP\n         MNOTE 9,'MACRO ERROR ETNZ'\n         MEXIT\n.ETZ     ANOP\n.*\n.OPLOOPE ANOP\n         AGO   .OPLOOP\n.OPLOOPZ ANOP\n\n         LM    R14,R1,INSTSTR_SRSV\n.QOPLOOPZ ANOP\n\n\n         AIF   ('&BAL' EQ '').BALZ\n         BAL   R1,&BAL\n.BALZ    ANOP\n\n         AIF   (NOT &INSTSWK).GEN\n         AIF   ((NOT &INSTSPG) AND (&INSTSPL)).GEN\n         AGO   .GENZ\n.GEN     B     INST_A&SYSNDX\n         AIF   (&INSTSWK).GEN1Z\n&INSTSWK SETB 1\nINSTSTR_SXAA MVC 0(0,R15),0(R14)\n.GEN1Z   ANOP\n         AIF   ((&INSTSPG) OR (NOT &INSTSPL)).GEN2Z\n&INSTSPG SETB 1\nINSTSTR_SPX1 DS 0H\n         MVI   INSTSTR_SFLG,INSTSTR_SCVX\n         B     INSTSTR_SCAL\nINSTSTR_SPN1 DS 0H\n         CVD   R14,INSTSTR_SDWD\n         ZAP   INSTSTR_SPNP,INSTSTR_SDWD\nINSTSTR_SPN2 DS 0H\n         MVI   INSTSTR_SFLG,INSTSTR_SED1\n         B     INSTSTR_SCAL\nINSTSTR_SPN3 DS 0H\n         CVD   R14,INSTSTR_SDWD\n         ZAP   INSTSTR_SPNP,INSTSTR_SDWD\nINSTSTR_SPN4 DS 0H\n         MVI   INSTSTR_SFLG,INSTSTR_SED2\nINSTSTR_SCAL EQU *\n         STM   R14,R1,INSTSTR_SLST\n         CALL  INSTSTRC,(INSTSTR_SDSC),VL,MF=(E,INSTSTR_CALL)\n         L     R15,INSTSTR_SFPT\n         L     R14,INSTSTR_SRTA\n         BR    R14\n.GEN2Z   ANOP\nINST_A&SYSNDX DS   0H\n.GENZ    ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTSTRC": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x18\\x01\\x006/\\x01\\x02\\x00\\x8f\\x15 \\x00i\\x00N\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2000-12-27T00:00:00", "modifydate": "2002-01-08T15:20:18", "lines": 105, "newlines": 78, "modlines": 0, "user": "TSO057"}, "text": "INSTSTRC INSTSS SAVEAREA=NO\n**********************************************************************\n*\n*  12/12/00  1.1    WRITTEN                                     AWR *\n*\n**********************************************************************\n* **********************************************************\n* *          *                                             *\n* *   INSTSTRC IS CALLED BY THE MACRO INSTSTR  TO DO ANY   *\n* *   COMPLEX EDITING.                                     *\n* *          *                                             *\n* *   ON INPUT THERE IS ONE PARAM IN THE FORMAT OF         *\n* *   INSTSDSC                                             *\n* *          *                                             *\n* **********************************************************\n         L     R3,0(R1)\n         USING INSTSTR_SDSC,R3\n         CLI   INSTSTR_SFLG,INSTSTR_SED1 WHEN EDIT IN WITH LEN\n         BNE   A100\n         MVC   INSTSTR_EDWK,EDM         MOVE IN EDIT MASK\n         LA    R1,INSTSTR_EDWK+L'INSTSTR_EDWK-1\n         EDMK  INSTSTR_EDWK,INSTSTR_SPNP EDIT IN FROM PACKED FIELD\n         BNM   A020                     IF -VE\n         BCTR  R1,0\n         MVI   0(R1),C'-'               MOVE IN -VE SIGN\nA020     EQU   *                        ENDIF\n         LA    R5,INSTSTR_EDWK+L'INSTSTR_EDWK R5->END EDIT FIELD\n         L     R1,INSTSTR_SFLN          R1=LEN\n         SLR   R5,R1                    R5->START FIELD TO MOVE\n         BCTR  R1,0\n         L     R6,INSTSTR_SFPT          R6->CURR POINT TO MOVE\n         EX    R1,MVC65\n         LA    R1,1(R1,R6)              SET UP POINTER\n         ST    R1,INSTSTR_SFPT\n         B     A900                     SELECT\nA100     EQU   *\n         CLI   INSTSTR_SFLG,INSTSTR_SED2 WHEN EDIT IN TO MIN LEN\n         BNE   A200\n         L     R6,INSTSTR_SFPT\n         MVC   INSTSTR_EDWK,EDM         MOVE IN EDIT MASK\n         LA    R1,INSTSTR_EDWK+L'INSTSTR_EDWK-1\n         EDMK  INSTSTR_EDWK,INSTSTR_SPNP EDIT IN FROM PACKED FIELD\n         BNM   A120                     IF -VE\n         MVI   0(R6),C'-'               MOVE IN -VE SIGN\n         LA    R6,1(R6)                 SKIP UP FIELD\nA120     EQU   *                        ENDIF\n         LA    R4,INSTSTR_EDWK+L'INSTSTR_EDWK-1 R4->END EDIT FIELD-1\n         SLR   R4,R1                    R4->LEN FIELD TO MOVE -1\n         LR    R5,R1                    R5->DIGITS\n         EX    R4,MVC65\n         LA    R1,1(R4,R6)              SET UP POINTER\n         ST    R1,INSTSTR_SFPT\n         B     A900                     SELECT\nA200     EQU   *\n         CLI   INSTSTR_SFLG,INSTSTR_SCVX WHEN CONVHEX\n         BNE   A300\n         LM    R5,R8,INSTSTR_SFLD       R5->SOURCE,R6->RESULT,R8=LEN\n         LA    R1,0(R6,R8)\n         ST    R1,INSTSTR_SFPT\n         SRL   R8,1\n         LTR   R8,R8\n         BNP   A300\n*\nCHAR_LOOP DS   0H                       LOOP\n         SLR   R1,R1\n         IC    R1,0(R5)\n         SLL   R1,1                     R1 = OFFSET IN TAB\n         LA    R9,XTAB(R1)\n         MVC   0(2,R6),0(R9)\n         LA    R5,1(R5)\n         LA    R6,2(R6)\n         BCT   R8,CHAR_LOOP\n\n         B     A900                     SELECT\nA300     EQU   *\n*\n*\n*\nA900     EQU   *\n         INSTRS\nEDM      DC    X'40',29X'20',X'2120'\nMVC65    MVC   0(0,R6),0(R5)\n\nXTAB     DC    C'000102030405060708090A0B0C0D0E0F'\n         DC    C'101112131415161718191A1B1C1D1E1F'\n         DC    C'202122232425262728292A2B2C2D2E2F'\n         DC    C'303132333435363738393A3B3C3D3E3F'\n         DC    C'404142434445464748494A4B4C4D4E4F'\n         DC    C'505152535455565758595A5B5C5D5E5F'\n         DC    C'606162636465666768696A6B6C6D6E6F'\n         DC    C'707172737475767778797A7B7C7D7E7F'\n         DC    C'808182838485868788898A8B8C8D8E8F'\n         DC    C'909192939495969798999A9B9C9D9E9F'\n         DC    C'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    C'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    C'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    C'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    C'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    C'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         LTORG\n\nINSTSTR_D    DSECT\n        COPY INSTSTRD\n\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTSTRD": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x02\\x00\\x8f\\x01\\x02\\x00\\x8f\\x15 \\x00\\r\\x00\\r\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-01-08T00:00:00", "modifydate": "2002-01-08T15:20:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "TSO057"}, "text": "INSTSTR_SDSC DS 0D\nINSTSTR_EDWK DS CL32\nINSTSTR_SDWD DS 0D                      DW FOR CVD\nINSTSTR_SLST DS 0CL16\nINSTSTR_SFLD DS F                       ->FIELD\nINSTSTR_SFPT DS F                       -> RESULT\nINSTSTR_SRTA DS F\nINSTSTR_SFLN DS F                       LEN OF FIELD\nINSTSTR_SPNP DS PL16                    NUMERIC VALUE\nINSTSTR_SFLG DS AL1                     FLAG\nINSTSTR_SED1 EQU 0                      EDIT IN WITH LEN. FROM NLN\nINSTSTR_SED2 EQU 4                      EDIT IN TO MIN POSSIBLE LEN\nINSTSTR_SCVX EQU 8                      CONVHEX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTSYMB": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x054?\\x01\\x054?\\x10\\x01\\x00k\\x00k\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-12-09T00:00:00", "modifydate": "2005-12-09T10:01:32", "lines": 107, "newlines": 107, "modlines": 0, "user": "TSO057"}, "text": "***********************************************************************\n*                                                                     *\n*   INSTSYMB IS USED TO CALL ASASYMBU TO DO SUBSTITUTIONS             *\n*                                                                     *\n*                1)   CONTROL BYTE                                    *\n*                2)   CL255 SUBSTUTUTE STRING                         *\n*                3)   CL255 SUBSTUITUTED STRING                       *\n*                4)   REPLY Y OR N                                    *\n*                                                                     *\n*   THE ROUTINE IS REENTRANT, 31/ANY AND LPA RESIDENT                 *\n*                                                                     *\n***********************************************************************\nINSTSYMB INSTSS\n\n         LR    R6,R1       SAVE R1\n         L     R1,00(R6)   GET PATTERN\n\n         CLI   0(R1),C'1' ONLY TYPE 1 ALLOWED SO FAR\n         BE    TYPE1\n\n         B     FAIL\n\nTYPE1    DS    0H\n         L     R1,04(R6)   GET PATTERN\n         MVC   PATTERN,0(R1)\n*\n*        CALL ASASYMBU TO DO SUBSTITUTION\n*\n*        SET UP CONTROL BLOCK\n*\n         LA    R2,MYSYMBP\n         USING SYMBP,R2\n         XC    SYMBP(SYMBP_LEN),SYMBP   INITIALIZE TO ZERO\n         LA    R1,PATTERN               ADDRESS OF PATTERN\n         ST    R1,SYMBPPATTERN@         SAVE IN SYMBP AREA\n         LA    R1,L'PATTERN             LENGTH OF PATTERN\n         ST    R1,SYMBPPATTERNLENGTH    SAVE IN SYMBP AREA\n         MVC   TARGET,=CL255' '\n         LA    R1,TARGET                ADDRESS OF TARGET\n         ST    R1,SYMBPTARGET@          SAVE IN SYMBP AREA\n         MVC   TARGETLENGTH,=A(L'TARGET)  SET LENGTH OF TARGET\n         LA    R1,TARGETLENGTH          ADDRESS OF TARGET LENGTH\n         ST    R1,SYMBPTARGETLENGTH@    SAVE IN SYMBP AREA\n         LA    R1,RETURNCODE            ADDRESS OF RETURN CODE\n         ST    R1,SYMBPRETURNCODE@      SAVE IN SYMBP AREA\n\n         LA    R1,MYSYMBT               SYMBOL TABLE\n         ST    R1,SYMBPSYMBOLTABLE@     SAVE IN SYMBP AREA\n         DROP R2\n\n         LA    R2,MYSYMBT               SYMBOL TABLE\n         USING SYMBT,R2\n         XC    SYMBTHEADER,SYMBTHEADER\n         OI    SYMBTFLAGS,SYMBTWARNNOSUB WARN IF NO SUB\n         LA    R1,0                    NUMBEROFSYMBOLS\n         STH   R1,SYMBTNUMBEROFSYMBOLS SAVEINSYMBTAREA\n         DROP   R2\n\n  LINK   EP=ASASYMBM,MF=(E,MYSYMBP),SF=(E,LINKL),DCB=0\n         L     R2,08(R6)        R2 -> RETURNED VALUE\n         MVC   0(L'TARGET,R2),TARGET\n         CLC   =A(0),RETURNCODE\n         BNE    FAIL\n         B     OK\n\n\n\n\n\nOK       EQU   *\n         L     R1,12(R6)\n         MVI 0(R1),C'Y'\n         INSTRS\n\n\nFAIL     EQU   *\n         L     R1,12(R6)\n         MVI 0(R1),C'N'\n         INSTRS  RC=0\n\n\n\n\n         INSTWORK START\n\nLINKL        LINK SF=L\nPL           CALL MF=L\n\nPATTERN      DS    CL255\n\n             DS    0F\nRETURNCODE   DS    F                   RETURN CODE\nTARGETLENGTH DS    F                   LENGTH OF TARGET\nTARGET       DS    CL255\n             DS    CL255 BUFFER\n\n             DS    0D\nMYSYMBP      DS    CL(SYMBP_LEN)       SYMBP AREA\n\n\n             DS    0D\nMYSYMBT      DS    CL(SYMBT_LEN)\n\n        INSTWORK END\n\n             ASASYMBP                  MAPPING OF SYMBP AREA\n        END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTTCMD": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x01\\x02\\x00\\x7f\\x01\\x03\\x05\\x0f\\x130\\x00\\xba\\x00\\xc0\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-01-07T00:00:00", "modifydate": "2003-02-19T13:30:55", "lines": 186, "newlines": 192, "modlines": 0, "user": "TSO057"}, "text": "//TSO0571 JOB (T951V40),'INSTTCMD',MSGCLASS=T,CLASS=Z,NOTIFY=TSO057\n// INCLUDE MEMBER=SYSLEV\n//*\n//*\n//*        THIS JOB INSTALL THE MODULE INSTTCMD WHICH ALLOWS\n//*        A JOB TO ISSUE ANY SYSTEM COMMAND\n//*\n//*        THIS MODULE IS AUTHORISED AND MUST BE RACF-PROTECTED AND ON\n//*        A READ-PROTECTED LIBRARY SO IT CANNOT BE COPIED ELSEWHERE\n//*        PROBABLY A LINKLIST OR LPALIST LIBRARY\n//*\n//*\n//*        1) WILL WAIT 1 SEC BETWEEN COMMANDS\n//*        2) WILL TREAT \"//* \" IN LINES 1-3 AS COMMENT\n//*        3) WILL TREAT \"//*WAIT HHMMSSTH\" AS INSTR TO WAIT\n//*        4) AFTER 100TH COMMAND WILL ONLY WAIT 1/4 SEC AND WILL\n//*           ISSUE NO WTO.\n//*\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.&SYSLEV..AMODGEN,DISP=SHR\n//         DD  DSN=SFT.INSTASM.ASM,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(9999,(600,100))\n//SYSUT2   DD  DSN=&&SYSUT2,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSUT3   DD  DSN=&&SYSUT3,UNIT=VIO,SPACE=(1700,(300,50))\n//SYSPRINT DD  SYSOUT=*,DCB=BLKSIZE=1089\n//SYSPUNCH DD  SYSOUT=B\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=SYSSQ,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\nINSTTCMD TITLE 'JLP ROUTINE FOR ISSUING SYSTEM COMMANDS USING SVC34'\n*\n***********************************************************************\n*\n*         MODULE NAME = INSTTCMD\n*\n***********************************************************************\n         EJECT\nINSTTCMD CSECT ,\n         INSTREQU\n         SAVE  (14,12),,INSTTCMD\n         USING INSTTCMD,R12\n         LR    R12,R15         SAVE BASE ADDRESS\n         ST    R13,SAVE+4\n         LA    R13,SAVE\nGETPARM  EQU   *                    DO GET PARM\n         L     R3,0(R1)             POINT TO PARM LENGTH\n         LH    R4,0(R3)             LOAD PARM LENGTH\n         LTR   R4,R4                TEST LENGTH\n         BNP   NOPARM               SKIP IF LENGTH WAS 0\n         LA    R3,2(R3)             R3 POINT TO COMMAND\n         BCTR  R4,0                 DECREMENT LENGTH\n         EX    R4,MVCCR3            MOVE PARM INTO COMTXT\n         LA    R4,COMTXT-LENG+1(R4) RESTORE LENGTH + ADD PREFIX\n         STH   R4,LENG              STORE IN LENGTH FIELD FOR SVC34\n         BAL   R9,ISSUE             DO ISSUE COMMAND\nNOPARM   EQU   *\n         MVC   LENG,=Y(COMTXT-LENG+72) 72 BYTES INPUT FILE USED\n         OPEN   (SYSIN,(INPUT))\n         LA    R6,0\nCMLOOP   EQU   *\n         GET   SYSIN,COMTXT\n         BAL   R9,ISSUE\n         LA    R6,1(R6)\n         B     CMLOOP\nENDFILE  EQU   *\n         CLOSE  SYSIN\n         FREEPOOL SYSIN\n         L     R13,SAVE+4\n         RETURN (14,12),RC=0\n\nISSUE    EQU   *\n\n         CLC   =C'//*WAIT',COMTXT            IF //*WAIT COMMAND\n         BNE   WAITZ\n         CLI   COMTXT+8,C'0'\n         BL    TRERR\n         CLI   COMTXT+8,C'9'\n         BH    TRERR\n         CLI   COMTXT+9,C'0'\n         BL    TRERR\n         CLI   COMTXT+9,C'9'\n         BH    TRERR\n         CLI   COMTXT+10,C'0'\n         BL    TRERR\n         CLI   COMTXT+10,C'9'\n         BH    TRERR\n         CLI   COMTXT+11,C'0'\n         BL    TRERR\n         CLI   COMTXT+11,C'9'\n         BH    TRERR\n         CLI   COMTXT+12,C'0'\n         BL    TRERR\n         CLI   COMTXT+12,C'9'\n         BH    TRERR\n         CLI   COMTXT+13,C'0'\n         BL    TRERR\n         CLI   COMTXT+13,C'9'\n         BH    TRERR\n         CLI   COMTXT+14,C'0'\n         BL    TRERR\n         CLI   COMTXT+14,C'9'\n         BH    TRERR\n         CLI   COMTXT+15,C'0'\n         BL    TRERR\n         CLI   COMTXT+15,C'9'\n         BH    TRERR\n         CLC   COMTXT+8(8),=C'01000000'      1 HR MAX\n         BH    TRERR\n         MVC   TOWAIT,COMTXT+8\n         STIMER WAIT,DINTVL=TOWAIT\n         B     WAITZ\nTRERR    EQU   *\n         WTO   'INSTTCMD INVALID //*WAIT NNNNNNNN CARD'\nWAITZ    EQU   *\n\n\n         CLC   =C'//*',COMTXT                BYPASS IF JCL COMMENT\n         BE    COMMENT\n         CLC   =C'*',COMTXT                  BYPASS IF ASM COMMENT\n         BE    COMMENT\n\nCOMMAND  EQU   *\n         MODESET KEY=ZERO,MODE=SUP\n         C     R6,=A(10000)\n         BH    NOWTO\n\nWTO      EQU   *\n         STIMER WAIT,DINTVL=ONESEC\n\n         CLC   COMTXT,=CL255' '\n         BE    NOCMD\n         XR    R0,R0\n         LA    R1,LENG\n         SVC   34\n         MVC   WTOI+20(20),COMTXT\n         WTO   MF=(E,WTOI)\nNOCMD    EQU   *\n         B     COMMANDZ\n\nNOWTO    EQU   *\n         STIMER WAIT,DINTVL=QTRSEC\n         CLC   COMTXT,=CL255' '\n         BE    NOCMD1\n         XR    R0,R0\n         LA    R1,LENG\n         SVC   34\nNOCMD1   EQU   *\n\nCOMMANDZ EQU   *\n         MODESET KEY=NZERO,MODE=PROB\n\nCOMMENT  EQU   *\n         BR    R9\n\nSAVE     DC    18F'0'\n\nSYSIN    DCB   DDNAME=SYSIN,                                           X\n               LRECL=80,RECFM=FB,                                      X\n               DSORG=PS,                                               X\n               EODAD=ENDFILE,                                          X\n               MACRF=GM\n\nLENG     DC    H'100'\n         DC    H'0'\nCOMTXT   DC    CL100' '\n\nWTOI     WTO   'JOB HAS ISSUED                           COMMAND',MF=L\nMVCCR3   MVC   COMTXT(0),0(R3)\n         DS    0D\nONESEC   DC    C'00000100'\n         DS    0D\nQTRSEC   DC    C'00000025'\n         DS    0D\nTOWAIT   DC    C'00000000'\n\n\n         END\n//LKED    EXEC PGM=IEWL,PARM=(XREF,LIST),\n//             COND=(4,LT,ASM)\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1024,(50,20))\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,LRECL=121,BLKSIZE=1210)\n//SYSLMOD  DD  DSN=YOUR.LINK.OR.LPA.LIB,DISP=SHR\n   SETCODE AC(1)\n   NAME  INSTTCMD(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTUJI": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x03\\x10O\\x01\\x03\\x14/\\x137\\x00Y\\x00X\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-05-22T13:37:22", "lines": 89, "newlines": 88, "modlines": 0, "user": "TSO057"}, "text": "INSTUJI  INSTSS\n***********************************************************************\n*                                                                     *\n* THIS MODULE IS ADDED TO THE IEFUJI EXIT LIST. SEE SYS1.PARMLIB      *\n* MEMBER PROGXX                                                       *\n*                                                                     *\n* ITS FUNCTION IS TO DELETE THE SETVAR TOKENS BEFORE A JOB RUNS       *\n*                                                                     *\n*    MUST BE RENT REUS 31                                             *\n*                                                                     *\n***********************************************************************\n*\n*                                                                     *\n         LA    R1,0\n         USING PSA,R1\n         L     R1,PSAAOLD\n         DROP  R1\n         USING ASCB,R1\n         MVC   NAMEASID,ASCBASID\n         DROP  R1\n*        DELETE SETVAR TOKENS\n*\n* THESE HAVE FORM INST.SPYY.ASDIXX WHERE XX = HEX ASID\n* YY = HALFWORD 1 TO 1000\n*\n\n         MVC   NAME(14),=CL14'INST.SPYY.ASID'\n         LA    R2,0\n         LA    R3,1000\n         LA    R15,4\nDELSPTL  EQU   *\n*        WTO   'ONE TOKEN DELETE LOOP'\n         STCM  R2,3,NAME+7\n         CALL  IEANTDL,(LEVEL,NAME,RETC),MF=(E,CALLLIST)\n         LTR   R15,R15\n         BZ    DELSPTL\n         LA    R2,1(R2)\n         STCM  R2,3,NAME+7\n         CALL  IEANTDL,(LEVEL,NAME,RETC),MF=(E,CALLLIST)\n         LTR   R15,R15\n         BZ    DELSPTL\n         LA    R2,1(R2)\n         STCM  R2,3,NAME+7\n         CALL  IEANTDL,(LEVEL,NAME,RETC),MF=(E,CALLLIST)\n         LTR   R15,R15\n         BZ    DELSPTL\n         LA    R2,1(R2)\n         STCM  R2,3,NAME+7\n         CALL  IEANTDL,(LEVEL,NAME,RETC),MF=(E,CALLLIST)\n         LTR   R15,R15\n         BZ    DELSPTL\n         C     R15,=A(4) ** NOT FOUND\n         BE    ALDELD\n         LA    R2,1(R2)\n         BCT   R3,DELSPTL\nALDELD   EQU   *\n*\n*\n*\nEXIT     DS    0H                  EXIT PROLOGUE\n*                                  JUST FREE STORAGE AND EXIT\n         INSTRS\n\n*\n* DEFINE LINK  LIST FORM\n\nLEVEL    DC     A(IEANT_SYSTEM_LEVEL)\n\n         LTORG\n\n\n         INSTWORK START\n\nNAME     DS   0CL16\n         DS    CL14\nNAMEASID DS    CL2\n\nRETC     DS    A\n\nCALLLIST CALL  ,(0,0,0),MF=L\n\n         INSTWORK END\n\n\n         IHAPSA  DSECT=YES\n         IHAASCB DSECT=YES\n         IEANTASM\n\n         END   INSTUJI\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTWORK": {"ttr": 2064, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00@\\x01\\x03\\x05\\x0f\\x01\\t\\x14? $\\x00`\\x00j\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2009-05-23T20:24:40", "lines": 96, "newlines": 106, "modlines": 0, "user": "TSO057"}, "text": "         MACRO\n.**********************************************************************\n.*\n.*  12/12/00  1.0    WRITTEN                                     AWR *\n.*\n.**********************************************************************\n         INSTWORK &SE\n\n         GBLA  &INSTBALN,&INSTSTRN,&INSTPRSN\n\n\n         AIF  ('&SE' EQ 'START').START\n         AIF  ('&SE' EQ 'END').END\n         MNOTE 8,'MUST SPECIFY START OR END'\n         MEXIT\n\n\n\n.END     ANOP\n.*\n.*\n.* END OF DSECT FOR GETMAINED WORKING STORAGE\n.*\n.*\n         DS   0D\nINSTWORK_DATALEN EQU *-INSTWORK_DATA\n         MEXIT\n\n\n\n\n.START   ANOP\n.*\n.*\n.* START OF DSECT FOR GETMAINED WORKING STORAGE\n.*\n.*\n         LTORG\n         DS   0D\n\nINSTWORK_DATA   DSECT\nINSTWORK_SAVE   DS 18F             SAVE AREA FOR REGISTERS ON ENTRY\n                ORG   INSTWORK_SAVE\nINSTWORK_SAVEXX DS F\nINSTWORK_SAVEBK DS F\nINSTWORK_SAVEFW DS F\nINSTWORK_SAVER14 DS F\nINSTWORK_SAVER15 DS F\nINSTWORK_SAVER0 DS F\nINSTWORK_SAVER1 DS F\n         ORG\nINSTWORK_BAL    DC  &INSTBALN.A(0) BAL CELLS FOR INSTBALI/O\n\n\n\n\n\n.*       INSTSTR WORK AREAS\n.*\n\n         AIF   (&INSTSTRN GE 1).INSTS\n         AGO   .NOTINSTS\n.INSTS   ANOP\n        COPY INSTSTRD\n\nINSTSTR_SRSV DS 0F\nINSTSTR_SRSE DS F                       SAVE FOR REG 14\nINSTSTR_SRSF DS F                       SAVE FOR REG 15\nINSTSTR_SRS0 DS F                       SAVE FOR REG 0\nINSTSTR_SRS1 DS F                       SAVE FOR REG 1\nINSTSTR_SRS# DS F                       WORK AREA\nINSTSTR_CALL CALL ,(,),MF=L\n\n\n.NOTINSTS ANOP\n\n\n\n\n.*       INSTPRS WORK AREAS\n.*\n\n         AIF   (&INSTPRSN GE 1).INSTP\n         AGO   .NOTINSTP\n.INSTP   ANOP\nINSPRS_CALL CALL ,(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,),MF=L\nINSPRS_LEN   DC  Y(0)\nINSPRS_RECFL DC  Y(0),30Y(0)\n.NOTINSTP ANOP\n\n         MEXIT\n\n\n\n\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTWTL": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x034?\\x01\\x034?\\x12\\x11\\x00C\\x00C\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-12-09T00:00:00", "modifydate": "2003-12-09T12:11:57", "lines": 67, "newlines": 67, "modlines": 0, "user": "TSO057"}, "text": "***********************************************************************\n*                                                                     *\n*        SAMPLE PROGRAM TO DO WTL WITH JOB AND TIME STAMPED IN MESSAGE*\n*                                                                     *\n***********************************************************************\nINSTWTL  INSTSS\n         L      R3,0(R1)\n\n         TIME DEC,LINKAGE=SVC\n*\n*                              R1=0CYYNNNF C = 0 FOR 19XX, 1 FOR 20XX\n*                              R0=HHMMSSTH\n*\n         IC    R0,X'C0'        OVERWRITE TENTHS-HUNDS BY SIGN+0\n         SRL   R0,4            SHIFT OUT 0\n         ST    R0,HHMMSS\n         MVC   WORK,EDMASK     MOVE IN MASK\n         ED    WORK,HHMMSS     CREATE TIME IN HH.MM.SS FORMAT\n         MVC   WTLWORK(WTLWORKZ-WTLWORK),WTLMASK\n         MVC   WTLWORK+15(8),WORKTIME   MOVE TO MSG\n\n         ST    R1,NCYYDDDF\n         UNPK  NCYYDDD,NCYYDDDF\n         MVC   WTLWORK+9(5),NCYYDDD+2 MOVE YYDDD TO MSG\n\n         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,EXTRACTL)\n         L     R1,TIOTA\n         MVC   WTLWORK+24(8),0(R1)  MOVE JOBNAME TO MSG\n\n\n         MVC   WTLWORK+33(5),=C'2222 '\n         MVC   WTLWORK+38(100),0(R3)\n\n         WTL   MF=(E,WTLWORK)\n\n         INSTRS\n\nEDMASK   DC    X'F02120204B20204B2020'   MASK FOR HH.MM.SS\nWTLMASK  WTL '1111 YYDDD HH:MM:SS JOBNAME  XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',MF=L\n         DC   CL100' '\nWTLMASKZ DS   0C\n\n\n         INSTWORK START\nNCYYDDDF DC    F'0'\nNCYYDDD  DC    CL7' '\n\nWORK     DS    0CL10\n         DS    CL2\nWORKTIME DS    CL8\nHHMMSS   DS    A                         TIME IN HHMMSS FORMAT PACKED\n\nEXTRACTL EXTRACT      ,FIELDS=TIOT,MF=L\nTIOTA     DS   F\n\nWTLWORK   WTL '1111 YYDDD HH:MM:SS JOBNAME  XXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',MF=L\n          DC   CL100' '\nWTLWORKZ  DS   0C\n\nDDMMYYDDD DC   CL9' '\n         INSTWORK END\n\n          END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INSTWTOR": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00B\\x00\\x99\\x03?\\x01\\x006?\\x10E\\x00p\\x00[\\x00\\x00\\xe3\\xe2\\xd6\\xf0\\xf5\\xf7@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "2000-12-28T10:45:42", "lines": 112, "newlines": 91, "modlines": 0, "user": "TSO057"}, "text": "**********************************************************************\n*\n*  12/12/00  1.0    WRITTEN                                     AWR *\n*\n**********************************************************************\n\n**********************************************************************\n* MODULE TO DISPLAY A 100 BYTE MESSAGE\n* ROUTCDE IN FULLWORD SECOND OPERAND\n* 100 BYTE REPLY AS OPTIONAL 3RD OPERAND\n*\n**********************************************************************\n\nINSTWTOR INSTSS\nMSGLEN   EQU    100\nREPLEN   EQU    100\n         LR     R7,R1\n         L      R3,0(R7)\n         LTR    R3,R3\n         BM     WTO1PAR\n         L      R4,4(R7)\n         LTR    R4,R4\n         BM     WTO\n         B      WTOR\n\n\nWTO1PAR  DS    0H\n*        WTO   'WTO1PAR'\n         LA    R4,ROUTCDEAL\n         B     WTO\n\nWTO      DS    0H\n*        WTO   'WTO'\n         MVC    WTOWORK(WTOWORKZ-WTOWORK),WTOSKEL\n\n         MVC    WTOWORK+4(MSGLEN),0(R3)\n\n         L      R1,0(R4)\n         STCM   R1,3,WTOWORKZ-2\n\n         SLR    R0,R0\n         WTO    MF=(E,WTOWORK)\n\n*        WTO   'WTO - INSTRS'\n         INSTRS\n\n\nWTOR     DS    0H\n*        WTO   'WTOR'\n         L      R5,8(R7)\n         MVC    WTORWORK(WTORWORKZ-WTORWORK),WTORSKEL\n\n         MVC    WTORWORK+12(MSGLEN),0(R3)\n\n         L      R1,0(R4)\n         STCM   R1,3,WTORWORKZ-2    ROUTCDE\n\n         XC     WTOECB,WTOECB\n         MVI    WTORREP,C' '\n         MVC    WTORREP+1(L'WTORREP-1),WTORREP\n\n         SLR    R0,R0\n         WTOR   ,WTORREP,L'WTORREP,WTOECB,MF=(E,WTORWORK)\n*        WTO   'WTOR -2'\n         LA     R7,WTOECB\n         WAIT   ECB=(R7),LONG=YES\n\n*        WTO   'WTOR -3'\n         MVC    0(REPLEN,R5),WTORREP\n\n*        WTO   'WTOR -INSTRS'\n         INSTRS\n\nDMYREP   DS    0CL(REPLEN) DUMMY REPLY FIELD\nDMYECB   DS    0A     DUMMY ECB\n\n\nWTOSKEL  WTO  '01234567890123456789012345678901234567890123456789012345X\n               67890123456789012345678901234567890123456789',          X\n               MF=L,ROUTCDE=(1,2,3)\nWTOSKELZ DS    0C\n\nWTORSKEL WTOR '01234567890123456789012345678901234567890123456789012345X\n               67890123456789012345678901234567890123456789',          X\n               DMYREP,L'DMYREP,DMYECB,MF=L,ROUTCDE=(1,2,3)\nWTORSKELZ DS   0C\n\nROUTCDEAL DC A(B'1111111100000000')\n\n         INSTWORK START\n\nWORK     DS    0D\nWTOWORK  WTO  '01234567890123456789012345678901234567890123456789012345X\n               67890123456789012345678901234567890123456789',          X\n               MF=L,ROUTCDE=(1,2,3)\nWTOWORKZ DS    0C\n\n         ORG   WORK\nWTORWORK WTOR '01234567890123456789012345678901234567890123456789012345X\n               67890123456789012345678901234567890123456789',          X\n               DMYREP,L'DMYREP,DMYECB,MF=L,ROUTCDE=(1,2,3)\nWTORWORKZ DS   0C\n\n         ORG\n\nWTORREP  DS    CL(REPLEN)\nWTOECB   DS    A\n\n         INSTWORK END\n\n\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT490/FILE490.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT490", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}